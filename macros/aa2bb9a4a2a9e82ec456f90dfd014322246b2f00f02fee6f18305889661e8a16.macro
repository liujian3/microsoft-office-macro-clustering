Attribute VB_Name = "ChartSeries"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'This Class module provides an easy way to access the items in a
'chart's SERIES formula. It can be exported and then imported into
'any project

'Developed by John Walkenbach, JWALK AND ASSOCIATES
'Copyright 1999. All rights reserved.
'May be used and distributed freely, but may not be sold.
'http://www.j-walk.com/ss/

'===================================
' PROPERTIES FOR CHARTSERIES OBJECT
'===================================

'Chart (read/write)
'ChartSeries (read/write)

'SeriesName (read/write)
'XValues (read/write)
'Values (read/write)
'PlotOrder (read/write)

'SeriesNameType (read-only)
'XValuesType (read-only)
'ValuesType (read-only)
'PlotOrderType (read-only)


'Sub ExampleUsage()
'    Dim MySeries As New ChartSeries
'    With MySeries
'        .Chart = Sheets(1).ChartObjects(1).Chart
'        .ChartSeries = 1
'        If .XValuesType = "Range" Then
'            MsgBox .XValues.Address
'        Else
'            MsgBox .XValues
'        End If
'    End With
'End Sub

Option Explicit
Dim CurrChart As Chart    'accessible to all procedures
Dim CurrSeries As Integer 'accessible to all procedures

Property Get Chart() As Chart
    Set Chart = CurrChart
End Property

Property Let Chart(Cht)
    Set CurrChart = Cht
End Property


Property Get ChartSeries()
    ChartSeries = CurrSeries
End Property

Property Let ChartSeries(SeriesNum)
    CurrSeries = SeriesNum
End Property


Property Get SeriesName() As Variant
    If SeriesNameType = "Range" Then
        Set SeriesName = Range(SERIESFormulaElement(CurrChart, CurrSeries, 1))
    Else
        SeriesName = SERIESFormulaElement(CurrChart, CurrSeries, 1)
    End If
End Property

Property Let SeriesName(SName)
    CurrChart.SeriesCollection(CurrSeries).Name = SName
End Property

Property Get SeriesNameType() As String
    SeriesNameType = SERIESFormulaElementType(CurrChart, CurrSeries, 1)
End Property


Property Get XValues() As Variant
    If XValuesType = "Range" Then
        Set XValues = Range(SERIESFormulaElement(CurrChart, CurrSeries, 2))
    Else
        XValues = SERIESFormulaElement(CurrChart, CurrSeries, 2)
    End If
End Property

Property Let XValues(XVals)
    CurrChart.SeriesCollection(CurrSeries).XValues = XVals
End Property

Property Get XValuesType() As String
    XValuesType = SERIESFormulaElementType(CurrChart, CurrSeries, 2)
End Property


Property Get Values() As Variant
    If ValuesType = "Range" Then
        Set Values = Range(SERIESFormulaElement(CurrChart, CurrSeries, 3))
    Else
        Values = SERIESFormulaElement(CurrChart, CurrSeries, 3)
    End If
End Property

Property Let Values(Vals)
    CurrChart.SeriesCollection(CurrSeries).Values = Vals
End Property

Property Get ValuesType() As String
    ValuesType = SERIESFormulaElementType(CurrChart, CurrSeries, 3)
End Property



Property Get PlotOrder()
        PlotOrder = SERIESFormulaElement(CurrChart, CurrSeries, 4)
End Property

Property Let PlotOrder(PltOrder)
    CurrChart.SeriesCollection(CurrSeries).PlotOrder = PltOrder
End Property

Property Get PlotOrderType() As String
    PlotOrderType = SERIESFormulaElementType(CurrChart, CurrSeries, 4)
End Property


Private Function SERIESFormulaElementType(ChartObj, SeriesNum, Element) As String
'   Returns a string that describes the element of a chart's SERIES formula
'   This function essentially parses and analyzes a SERIES formula

'   Element 1: Series Name. Returns "Range" , "Empty", or "String"
'   Element 2: XValues. Returns "Range", "Empty", or "Array"
'   Element 3: Values. Returns "Range" or "Array"
'   Element 4: PlotOrder. Always returns "Integer"

    Dim SeriesFormula As String
    Dim FirstComma As Integer, SecondComma As Integer, LastComma As Integer
    Dim FirstParen As Integer, SecondParen As Integer
    Dim FirstBracket As Integer, SecondBracket As Integer
    Dim StartY As Integer
    Dim SeriesName, XValues, Values, PlotOrder As Integer
    
'   Exit if Surface chart (surface chrarts do not have SERIES formulas)
    If ChartObj.ChartType >= 83 And ChartObj.ChartType <= 86 Then
        SERIESFormulaElementType = "ERROR - SURFACE CHART"
        Exit Function
    End If
    
'   Exit if nonexistent series is specified
    If SeriesNum > ChartObj.SeriesCollection.Count Or SeriesNum < 1 Then
        SERIESFormulaElementType = "ERROR - BAD SERIES NUMBER"
        Exit Function
    End If

'   Exit if element is > 4
    If Element > 4 Or Element < 1 Then
        SERIESFormulaElementType = "ERROR - BAD ELEMENT NUMBER"
        Exit Function
    End If

'   Get the SERIES formula
    SeriesFormula = ChartObj.SeriesCollection(SeriesNum).Formula

'   Get the First Element (Series Name)
    FirstParen = InStr(1, SeriesFormula, "(")
    FirstComma = InStr(1, SeriesFormula, ",")
    SeriesName = Mid(SeriesFormula, FirstParen + 1, FirstComma - FirstParen - 1)
    If Element = 1 Then
        If IsRange(SeriesName) Then
            SERIESFormulaElementType = "Range"
        Else
            If SeriesName = "" Then
                SERIESFormulaElementType = "Empty"
            Else
                If TypeName(SeriesName) = "String" Then
                    SERIESFormulaElementType = "String"
                End If
            End If
        End If
        Exit Function
    End If

'   Get the Second Element (X Range)
    If Mid(SeriesFormula, FirstComma + 1, 1) = "(" Then
'       Multiple ranges
        FirstParen = FirstComma + 2
        SecondParen = InStr(FirstParen, SeriesFormula, ")")
        XValues = Mid(SeriesFormula, FirstParen, SecondParen - FirstParen)
        StartY = SecondParen + 1
    Else
        If Mid(SeriesFormula, FirstComma + 1, 1) = "{" Then
'           Literal Array
            FirstBracket = FirstComma + 1
            SecondBracket = InStr(FirstBracket, SeriesFormula, "}")
            XValues = Mid(SeriesFormula, FirstBracket, SecondBracket - FirstBracket + 1)
            StartY = SecondBracket + 1
        Else
'          A single range
            SecondComma = InStr(FirstComma + 1, SeriesFormula, ",")
            XValues = Mid(SeriesFormula, FirstComma + 1, SecondComma - FirstComma - 1)
            StartY = SecondComma
        End If
    End If
    If Element = 2 Then
        If IsRange(XValues) Then
            SERIESFormulaElementType = "Range"
        Else
            If XValues = "" Then
                SERIESFormulaElementType = "Empty"
            Else
                SERIESFormulaElementType = "Array"
            End If
        End If
        Exit Function
    End If

'   Get the Third Element (Y Range)
    If Mid(SeriesFormula, StartY + 1, 1) = "(" Then
'       Multiple ranges
        FirstParen = StartY + 1
        SecondParen = InStr(FirstParen, SeriesFormula, ")")
        Values = Mid(SeriesFormula, FirstParen + 1, SecondParen - FirstParen - 1)
        LastComma = SecondParen + 1
    Else
        If Mid(SeriesFormula, StartY + 1, 1) = "{" Then
'           Literal Array
            FirstBracket = StartY + 1
            SecondBracket = InStr(FirstBracket, SeriesFormula, "}")
            Values = Mid(SeriesFormula, FirstBracket, SecondBracket - FirstBracket + 1)
            LastComma = SecondBracket + 1
        Else
'          A single range
            FirstComma = StartY
            SecondComma = InStr(FirstComma + 1, SeriesFormula, ",")
            Values = Mid(SeriesFormula, FirstComma + 1, SecondComma - FirstComma - 1)
            LastComma = SecondComma
        End If
    End If
    If Element = 3 Then
        If IsRange(Values) Then
            SERIESFormulaElementType = "Range"
        Else
            SERIESFormulaElementType = "Array"
        End If
        Exit Function
    End If
    
'   Get the Fourth Element (Plot Order)
    PlotOrder = Mid(SeriesFormula, LastComma + 1, Len(SeriesFormula) - LastComma - 1)
    If Element = 4 Then
        SERIESFormulaElementType = "Integer"
        Exit Function
    End If
End Function


Private Function SERIESFormulaElement(ChartObj, SeriesNum, Element) As String
'   Returns one of four elements in a chart's SERIES formula (as a string)
'   This function essentially parses and analyzes a SERIES formula

'   Element 1: Series Name. Can be a range reference, a literal value, or nothing
'   Element 2: XValues. Can be a range reference (including a non-contiguous range), a literal array, or nothing
'   Element 3: Values. Can be a range reference (including a non-contiguous range), or a literal array
'   Element 4: PlotOrder. Must be an integer

    Dim SeriesFormula As String
    Dim FirstComma As Integer, SecondComma As Integer, LastComma As Integer
    Dim FirstParen As Integer, SecondParen As Integer
    Dim FirstBracket As Integer, SecondBracket As Integer
    Dim StartY As Integer
    Dim SeriesName, XValues, Values, PlotOrder As Integer
    
'   Exit if Surface chart (surface chrarts do not have SERIES formulas)
    If ChartObj.ChartType >= 83 And ChartObj.ChartType <= 86 Then
        SERIESFormulaElement = "ERROR - SURFACE CHART"
        Exit Function
    End If
    
'   Exit if nonexistent series is specified
    If SeriesNum > ChartObj.SeriesCollection.Count Or SeriesNum < 1 Then
        SERIESFormulaElement = "ERROR - BAD SERIES NUMBER"
        Exit Function
    End If

'   Exit if element is > 4
    If Element > 4 Then
        SERIESFormulaElement = "ERROR - BAD ELEMENT NUMBER"
        Exit Function
    End If

'   Get the SERIES formula
    SeriesFormula = ChartObj.SeriesCollection(SeriesNum).Formula

'   Get the First Element (Series Name)
    FirstParen = InStr(1, SeriesFormula, "(")
    FirstComma = InStr(1, SeriesFormula, ",")
    SeriesName = Mid(SeriesFormula, FirstParen + 1, FirstComma - FirstParen - 1)
    If Element = 1 Then
        SERIESFormulaElement = SeriesName
        Exit Function
    End If

'   Get the Second Element (X Range)
    If Mid(SeriesFormula, FirstComma + 1, 1) = "(" Then
'       Multiple ranges
        FirstParen = FirstComma + 2
        SecondParen = InStr(FirstParen, SeriesFormula, ")")
        XValues = Mid(SeriesFormula, FirstParen, SecondParen - FirstParen)
        StartY = SecondParen + 1
    Else
        If Mid(SeriesFormula, FirstComma + 1, 1) = "{" Then
'           Literal Array
            FirstBracket = FirstComma + 1
            SecondBracket = InStr(FirstBracket, SeriesFormula, "}")
            XValues = Mid(SeriesFormula, FirstBracket, SecondBracket - FirstBracket + 1)
            StartY = SecondBracket + 1
        Else
'          A single range
            SecondComma = InStr(FirstComma + 1, SeriesFormula, ",")
            XValues = Mid(SeriesFormula, FirstComma + 1, SecondComma - FirstComma - 1)
            StartY = SecondComma
        End If
    End If
    If Element = 2 Then
        SERIESFormulaElement = XValues
        Exit Function
    End If

'   Get the Third Element (Y Range)
    If Mid(SeriesFormula, StartY + 1, 1) = "(" Then
'       Multiple ranges
        FirstParen = StartY + 1
        SecondParen = InStr(FirstParen, SeriesFormula, ")")
        Values = Mid(SeriesFormula, FirstParen + 1, SecondParen - FirstParen - 1)
        LastComma = SecondParen + 1
    Else
        If Mid(SeriesFormula, StartY + 1, 1) = "{" Then
'           Literal Array
            FirstBracket = StartY + 1
            SecondBracket = InStr(FirstBracket, SeriesFormula, "}")
            Values = Mid(SeriesFormula, FirstBracket, SecondBracket - FirstBracket + 1)
            LastComma = SecondBracket + 1
        Else
'          A single range
            FirstComma = StartY
            SecondComma = InStr(FirstComma + 1, SeriesFormula, ",")
            Values = Mid(SeriesFormula, FirstComma + 1, SecondComma - FirstComma - 1)
            LastComma = SecondComma
        End If
    End If
    If Element = 3 Then
        SERIESFormulaElement = Values
        Exit Function
    End If
    
'   Get the Fourth Element (Plot Order)
    PlotOrder = Mid(SeriesFormula, LastComma + 1, Len(SeriesFormula) - LastComma - 1)
    If Element = 4 Then
        SERIESFormulaElement = PlotOrder
        Exit Function
    End If
End Function

Private Function IsRange(ref) As Boolean
'   Returns True if ref is a Range
    Dim x As Range
    On Error Resume Next
    Set x = Range(ref)
    If Err = 0 Then IsRange = True Else IsRange = False
End Function

Attribute VB_Name = "ClearOutput"
Attribute VB_Base = "0{E374CD17-DCB3-45FE-8E7A-6B3DD749A203}{7F61C389-7D16-4BE5-B7BB-304814314D99}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim f_nResult As Long

Property Get ButtonPressed() As Long
    ButtonPressed = f_nResult
End Property

Private Sub CommandButtonClearAll_Click()
    f_nResult = 0
    Me.Hide
End Sub

Private Sub CommandButtonClearCdfOnly_Click()
    f_nResult = 1
    Me.Hide
End Sub
Attribute VB_Name = "JSONIO4"
Option Explicit
Option Base 1
'
' added JSON_ before all subs and functions to avoid nameing conflicts with existing LibraryIO4_dge code
'
'SIP/JSON Formatting and Exchange
'John Marc Thibault
'marc@smpro.ca
'
'Copyright (C) 2013
'MIT License
'
' **** Needs reference to Microsoft Scripting Library
'
'
' Version 1.03
' 2016-03-05
' Build 13
'

 
'Ask for a folder then read in the SLURPs
Public Sub JSON_readSlurpLibrary()
    Dim fileTable As Range
    Dim folderPath As String
    Dim filePath As String
    Dim fileCell As Range
    Dim slurpSheetName As String
    Dim i As Long
    
    'Be on the right sheet
    Sheets("Control").Activate
    
    'Define Names for PM_IV and PM_IV_INDEX
    'JSON_setupIVTable
    
    'Where to get the SLURP file and sheet names
    Set fileTable = Range([SLURPS])
    
    'get a folder from the user
    folderPath = JSON_GetFolder("Pick a SLURP Folder")
    
    'Loop through the slurp files
    i = 1
    Do Until IsEmpty(fileTable(i, 1))
        Set fileCell = fileTable(i, 1)
        filePath = folderPath & "\" & fileCell.value
        slurpSheetName = fileCell(1, 2).value
        JSON_readOneSlurp filePath, slurpSheetName
        i = i + 1
    Loop
End Sub

'Set up the Names entries for PM_IV, PM_IV_INDEX
'Leave a single blank if there are no indexed values.
Public Sub JSON_setupIVTable()
    Dim tabtlc As Range
    Dim a As Range
    Dim n As Long
    
    Set tabtlc = Sheets("Control").Range([PM_IVTable])
    Set a = tabtlc.CurrentRegion
    n = a.Rows.Count - 1
    n = IIf(n > 0, n, 1)
    Names.Add "PM_IV", a.Cells(2, 1).Resize(n, 1)
    Names.Add "PM_IV_INDEX", a.Cells(2, 2).Resize(n, 1)
End Sub

'Read one SLURP from the folder
'filePath = file path to SLURP file
'sheetName = sheet name
Private Sub JSON_readOneSlurp(filePath As String, sheetName As String)
    Dim controlsheet As Worksheet
    Dim aSheet As Worksheet
    Dim putSlurpKeys As Range
    Dim putSipKeys As Range
    Dim putSipData As Range
    Dim getSlurpKeys As Range
    Dim getSipKeys As Range
    Dim i As Long
    
    Set controlsheet = Sheets("Control")
    
    'Set up the sheet
    On Error Resume Next
        Set aSheet = Sheets(sheetName)
        If Err = 0 Then
            aSheet.UsedRange.ClearContents
        Else
            Set aSheet = Sheets.Add(After:=controlsheet)
            aSheet.Name = sheetName
        End If
    On Error GoTo 0
    aSheet.Activate
    
    'Lay out the SLURP metadata keys
    Set putSlurpKeys = aSheet.Range([SLURPkeys])
    Set getSlurpKeys = controlsheet.Range([slurpMeta])
    i = 1
    Do While Not IsEmpty(getSlurpKeys(i, 1))
        putSlurpKeys(i, 1) = getSlurpKeys(i, 1)
        i = i + 1
    Loop
    Set putSlurpKeys = putSlurpKeys.Resize(i - 1, 1)
    
    'Layout the SIP metadata keys
    Set putSipKeys = aSheet.Range([SIPkeys])
    Set getSipKeys = controlsheet.Range([sipMeta])
    i = 1
    Do While Not IsEmpty(getSipKeys(i, 1))
        putSipKeys(i, 1) = getSipKeys(i, 1)
        i = i + 1
    Loop
    Set putSipKeys = putSipKeys.Resize(i - 1, 1)
    Set putSipData = aSheet.Range([siptlc])
    
    'Read and layout the SLURP
    
    'Read from a SIP Library
    JSON_fromStdLibrary filePath, putSipData, _
        putSipKeys, putSipKeys.Cells(1, 2), _
        putSlurpKeys, putSlurpKeys.Cells(1, 2)

End Sub

'Get a folder path
Public Function JSON_GetFolder(ByVal Title As String) As String
    With Application.FileDialog(msoFileDialogFolderPicker)
        .Title = Title
        If .Show Then
            JSON_GetFolder = .SelectedItems(1)
        End If
    End With
End Function
 
'Read from a SIP Library
'path = Std JSON file path
'SIPs = where to put the SIP columns
'keys = list of attributes to capture from each SIP
'attributes = where to put the attributes
'slurpkeys = list of slurp metadata keys
'slurpvalues = where to put the SLURP metadata values
'Returns true if no problems

Private Function JSON_fromStdLibrary( _
    path As String, _
    SIPs As Range, _
    keys As Range, _
    attributes As Range, _
    SLURPkeys As Range, _
    SLURPvalues As Range _
    ) As Boolean
    
    
    Dim sipstr As String          'SIP string
    Dim s As String             'Line from file
    Dim filePath As String      'file name
    Dim fso As FileSystemObject
    Dim dfile As TextStream
    Dim i As Long               'index into s
    Dim j As Long
    Dim k As Long
    Dim a As String
    Dim b As String
    Dim SIPCount As Long        'number of samples
    Dim SIPnum As Long          'SIP Counter
    Dim SIPname As String       'SIP name attribute
    Dim SIPattrs As String      'SIP Attributes string
    Dim SIPakeys                'SIP Attributes called for
    Dim sipCSV As String        'SIP CSV string
    Dim SIPar As Range          'SIP column array
    Dim numIV As Long           'Size of index vector
    Dim foundit As Boolean
    Dim indexVal As Range
    Dim controlsheet As Worksheet
    
    
    JSON_fromStdLibrary = False
    Set controlsheet = Sheets("Control")
    
    
    ' ------------ Open the file for reading -----------------------
    Set fso = CreateObject("Scripting.FileSystemObject")
    'Path to the file. Make sure it exists
    filePath = fso.GetAbsolutePathName(path)
    If Not fso.FileExists(filePath) Then
        Err.Raise 6666, "JSON_fromStdLibrary", "Can't find file " & filePath
    End If
    'Open the file -Use GetStandardStream for Unicode
    Set dfile = fso.OpenTextFile(filePath)
        
    ' --------------- Find and Process SLURP --------------------------
    foundit = False
    'scan for a SLURP object.
    s = ""
    Do
        s = s & JSON_readNextLine(dfile)
        i = InStr(s, "{")
    Loop Until i > 0
    
'{  "instanceof":"SLURP",
'   "name":"CONS",
'   "coherent":"True",
'   "count":"1000",
'   "about":"Real consumption growth (measured as consumption of services plus nondurables)",
'   "origin":"MATLAB PRISM Model - http://www.phil.frb.org/research-and-data/real-time-center/PRISM/",
'   "sips":[
'   Fixed to handle Linux files. Build 13.
'
    ' trim off to the opening brace
    s = Mid$(s, i + 1) & " "

'Process SLURP attributes
    ' get the SLURP attributes
    i = InStr(1, s, """sips""", vbTextCompare)
    Do Until i > 0
        s = s & JSON_readNextLine(dfile)
        i = InStr(1, s, """sips""", vbTextCompare)
    Loop
    For j = 1 To UBound(SLURPkeys.value)
        SLURPvalues.Cells(j, 1) = JSON_jKeyAttr(s, SLURPkeys.Cells(j, 1))
    Next j
    ' Done with SLURP attributes, get SIPs
    s = Mid$(s, i + 1)
    
    Do Until InStr(s, "[") > 0
        s = s & JSON_readNextLine(dfile)
    Loop
    ' cut past array opener
    s = Mid$(s, 1 + InStr(s, "["))
    
    SIPnum = 0
    
    Do 'loop through SIPs
        SIPnum = SIPnum + 1
        'Find the SIP object
        Do Until InStr(s, "{") > 0
            s = s & JSON_readNextLine(dfile)
        Loop
        s = Mid$(s, 1 + InStr(s, "{"))
        
        ' Bring in the whole SIP
        Do Until InStr(s, "}") > 0
            s = s & JSON_readNextLine(dfile)
        Loop
        
        ' Check that its a SIP object
        If JSON_jKeyAttr(s, "instanceof") <> "SIP" Then
            dfile.Close
            Set dfile = Nothing
            Err.Raise 6666, "JSON_fromStdLibrary", "No SIP Object"
        End If
        
        'get SIP metadata attributes
        For k = 2 To UBound(keys.value)
            a = keys.Cells(k, 1)
            b = JSON_jKeyAttr(s, a)
            attributes.Cells(k, SIPnum) = b
        Next k
        SIPCount = CLng(JSON_jKeyAttr(s, "count"))
        SIPname = Replace(JSON_jKeyAttr(s, "name"), " ", "_")
        
        ' get the SIP value and drop it onto worksheet
        sipCSV = jValue(s)
        Set SIPar = SIPs.Cells(1, SIPnum).Resize(SIPCount, 1)
        SIPar.value = JSON_fromCSV(sipCSV)
        Names.Add SIPname, SIPar

        'Done one SIP, cut used part
        s = Mid$(s, 1 + InStr(s, "}"))
       
        'scan for a delimiter
        Do While JSON_jNextDelim(s) = 0
            s = s & JSON_readNextLine(dfile)
        Loop
        
        'comma means more SIP
        i = JSON_jNextDelim(s)
        a = Mid$(s, i, 1)
        
    Loop While a = "," 'end loop through SIPs
    dfile.Close
    JSON_fromStdLibrary = True
End Function

'Read one line
' *** Future: detect and skip comments
Private Function JSON_readNextLine(dfile As TextStream) As String
    Dim s As String
    Do
        If dfile.AtEndOfStream Then
            dfile.Close
            Set dfile = Nothing
            Err.Raise 6666, "JSON_fromStdLibrary", "Premature end of file"
        End If
        s = dfile.readline
    Loop Until Len(s) > 0
    JSON_readNextLine = s
End Function

' *****************************************************
'                JSON Input helpers
' *****************************************************

' Find next delimiter, return index into s
'Usage:
'   do
'       delim = JSON_jNextDelim(s)
'       If delim = 0 then s = s & dfile.readline
'   loop until delim > 0
'

Public Function JSON_jNextDelim(s As String) As Long
    Dim delims As String
    Dim matches
    Dim match
    Dim regex As Object
    delims = ":,{}\[\]"
    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = "([^" & delims & "]*[" & delims & "])"
    regex.Global = False
    Set matches = regex.Execute(s)
    If matches.Count = 0 Then
        JSON_jNextDelim = 0
    Else
        JSON_jNextDelim = Len(matches(0))
    End If
End Function

' *****************************************************
'           Write SIPs to JSON in a file
' *****************************************************

Public Sub JSON_writeJSONLibrary(Optional defaultPath As Variant)
    Dim cSht As Worksheet
    Dim fileTable As Range
    Dim fileCell As Range
    Dim filePath As String
    Dim folderPath As String
    Dim slurpSheetName As String
    Dim slurpMetaKeys As Range
    Dim slurpMetaValues As Range
    Dim sipMetaKeys As Range
    Dim sipMetaValues As Range
    Dim sipData As Range
    Dim i

    'Where to get the SLURP file and sheet names
    Set fileTable = Range([SLURPS])
    
    If IsMissing(defaultPath) Then
        'get a folder from the user
        folderPath = JSON_GetFolder("Pick a Library Folder")
    Else
        folderPath = defaultPath
    End If
    
    'Loop through the slurp files
    i = 1
    Do
        Set fileCell = fileTable(i, 1)
        If IsEmpty(fileCell) Then Exit Do
        
        slurpSheetName = fileTable(i, 2).value
        Set cSht = Sheets(slurpSheetName)
        
        filePath = folderPath & "\" & fileCell.value
        
        'Write one SLURP File
        'Setup table top left corner pointers
        Set slurpMetaKeys = cSht.Range([SLURPkeys])(2, 1)
        Set slurpMetaValues = slurpMetaKeys(1, 2)
        Set sipMetaKeys = cSht.Range([SIPkeys])(2, 1)
        Set sipMetaValues = sipMetaKeys(1, 2)
        Set sipData = cSht.Range([siptlc])
        
        'Format and write the file
        JSON_toStdLibrary filePath, slurpMetaKeys, slurpMetaValues, _
            sipMetaKeys, sipMetaValues, sipData

        i = i + 1
    Loop
End Sub


'Write SLURP to a standard SIP JSON library file

'filePath = path to output file
'SLURPkeys = SLURP attribute key table. TLC
'SLURPvalues = SLURP attribute value table. TLC
'SIPkeys = SIP attribute keys. TLC
'SIPvalues = SIP attribute values. TLC
'SIPs = where to find the SIP columns. TLC
'csvr = default number of digits after the decimal

'Range values point to source worksheet.
' All are top left corner.

Private Sub JSON_toStdLibrary( _
    filePath As String, _
    SLURPkeys As Range, _
    SLURPvalues As Range, _
    SIPkeys As Range, _
    SIPvalues As Range, _
    SIPs As Range, _
    Optional csvr _
    )
    
    Dim fso As FileSystemObject 'File params
    Dim dfile As TextStream
    Dim k As String
    Dim v As String
    Dim s As String
    Dim i As Long
    Dim j As Long
    Dim sip
    Dim SIPCount As Long
    Dim c As String
    
    If IsMissing(csvr) Then csvr = 2

    'Open the file for overwrite
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set dfile = fso.CreateTextFile(filePath, True)

    'Write the Opening SLURP tag
    s = "{  ""instanceof"":""SLURP"""
    i = 1
    Do Until IsEmpty(SLURPkeys(i, 1))
        s = s & "," & vbCr & "   " & jattr(CStr(SLURPkeys(i, 1)), CStr(SLURPvalues(i, 1)))
        i = i + 1
    Loop
    s = s & "," & vbCr & "   ""sips"":["
    dfile.WriteLine s
    
    
    'Write the SIPs
    j = 1   'SIP Number
    Do Until IsEmpty(SIPvalues(1, j))
    
        'Write one SIP
        If j <> 1 Then dfile.WriteLine "   },"
        s = "   {""instanceof"":""SIP""" 'start SIP string
        
        'Attributes
        i = 1
        Do Until IsEmpty(SIPkeys(i, 1))
            k = CStr(SIPkeys(i, 1))
            v = CStr(SIPvalues(i, j))
            s = s & "," & vbCr & "     " & jattr(k, v)
            If LCase(k) = "count" Then SIPCount = CLng(v)
            If LCase(k) = "csvr" Then csvr = v
            i = i + 1
        Loop
        s = s & "," & vbCr & "     ""value"":" & vbCr & "     ["
        
        'content
        sip = SIPs(1, j).Resize(SIPCount, 1).value
        s = s & JSON_toCSV(sip, csvr) & "]"
        dfile.WriteLine s
        
        j = j + 1
    Loop
    'write the SLURP end
     dfile.WriteLine "     }" & vbCr & "  ]" & vbCr & "}"
    
    'close the file
    dfile.Close
    DoEvents
    Set dfile = Nothing
    
End Sub

'Format a JSON attribute string
Public Function jattr(key As String, value As String) As String
    jattr = """" & key & """:""" & value & """"
End Function

' Get an attribute from a JSON string
' Just looks for "key":"value"
Private Function JSON_jKeyAttr(dtext, key) As String
    Dim matches
    Dim match
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = """" & key & """\s*:\s*""([^""]+)"""
    regex.Global = False
    Set matches = regex.Execute(dtext)
    If matches.Count = 0 Then
        JSON_jKeyAttr = ""
    Else
        JSON_jKeyAttr = matches(0).submatches(0)
    End If
End Function

' Find and return SIP value
Private Function jValue(s As String) As String
    Dim matches
    Dim match
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = """value""\s*:\s*\[([^\]]+)\]"
    regex.Global = False
    Set matches = regex.Execute(s)
    If matches.Count = 0 Then
        jValue = ""
    Else
        jValue = matches(0).submatches(0)
    End If

End Function

' *******************************************************
'          Borrowed from SDXL
' *******************************************************

' Get an attribute from an XML string
' Just looks for key="value"
Private Function JSON_keyAttr(dtext, key) As String
    Dim matches
    Dim match
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = "\b" & key & "\s*=\s*""([^""]+)"""
    regex.Global = False
    Set matches = regex.Execute(dtext)
    If matches.Count = 0 Then
        JSON_keyAttr = ""
    Else
        JSON_keyAttr = matches(0).submatches(0)
    End If
End Function



'Convert a CSV string to a colArray
Public Function JSON_fromCSV(s As String)
    Dim a() As String
    Dim n As Long
    Dim ar()
    Dim i As Long
    
    a = Split(s, ",")
    n = 1 + UBound(a)
    ReDim ar(1 To n, 1 To 1)
    For i = 1 To n
        ar(i, 1) = CDbl(a(i - 1))
    Next i
    JSON_fromCSV = ar
End Function


'Convert a distribution to a CSV string
Public Function JSON_toCSV(a, Optional r = 0) As String
    Dim z
    Dim b()
    Dim s As String
    Dim d As Integer
    Dim i As Long
            
    ReDim b(1 To UBound(a))
    
    'Check for Boolean - change -1 to 1
    If TypeName(a(1, 1)) = "Boolean" Then
        For i = 1 To UBound(a)
            b(i) = IIf(a(i, 1), "1", "0")
        Next i
    Else
        d = CInt(r)
        For i = 1 To UBound(a)
            b(i) = FormatNumber(a(i, 1), d, vbTrue, vbFalse, vbFalse)
        Next i
    End If
    JSON_toCSV = Join(b, ",")
End Function




Attribute VB_Name = "LibraryIO4_dge"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
'
' remove the following until I figure out how to do XML and file IO on Mac
'
' references that need to be removed or replaced are:
' Microsoft Scripting Runtime
' Microsoft XML, v3.0
'
Option Explicit
Option Base 1
'SIP XML Formatting and Exchange
'John Marc Thibault
'13 July 2013
'marc@smpro.ca
'
'Copyright (C) 2013
'MIT License
'
' **** Needs reference to Microsoft Scripting Library
'
' Additions and modifications by Dave Empey, before May 12 2015
' - 12 May 2015
' - fixed issue with "octothorpe_procesed" being added to "count"
'
' Version 4.02
' 24 April 2015
'   Fixed hangup when there's no IV table.
'   setupIVtable(): force a single empty cell.

Const SHEET_NAME As String = "Control" ' dge add ?
Const ALPHA_UNDER = "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" ' dge add
Const ALPHANUM_DASH_PERIOD_ = "0123456789-._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" ' dge add

'Callback for openXML onAction
#If Mac Then
Sub openXmlSlurp()
#Else
Sub openXmlSlurp(control As IRibbonControl)
#End If
    readSlurpFile
    chkCalcMode
End Sub

'Ask for a folder then read in the SLURPs
Public Sub readSlurpLibrary()
    Dim fileTable As Range
    Dim folderPath As String
    Dim filePath As String
    Dim fileCell As Range
    Dim slurpSheetName As String
    Dim i As Long

    'Be on the right sheet
    Sheets("Control").Activate

    'Define Names for PM_META and PM_META_INDEX
    setupIVTable

    'Where to get the SLURP file and sheet names
    Set fileTable = Range([SLURPS])

    'get a folder from the user
    folderPath = GetFolder("Pick a SLURP Folder")

    'Loop through the slurp files
    i = 1
    Do Until IsEmpty(fileTable(i, 1))
        Set fileCell = fileTable(i, 1)
        filePath = folderPath & "\" & fileCell.value
        slurpSheetName = fileCell(1, 2).value
        readOneSlurp filePath, slurpSheetName
        i = i + 1
    Loop
End Sub

'
' dge 2015-may-1 ask for a file, load XML format SLURP from that file if possible.
' code modified from Marc Thibault's original
'
Public Sub readSlurpFile()

    Dim slurpFilePathAndName As Variant
    Dim slurpFilePath As String
    Dim slurpFileName As String
    Dim fileNameStart As Long
    
    ' get a file name
    slurpFilePathAndName = Application.GetOpenFilename("All files (*.*), *.*, SIP files (*.sip), *.sip", 2, "Open an XML SLURP")

    ' break into path and name
    If VarType(slurpFilePathAndName) = vbString Then
        fileNameStart = 1 + InStrRev(slurpFilePathAndName, "\")
        slurpFileName = Mid$(slurpFilePathAndName, fileNameStart)
        slurpFilePath = Left$(slurpFilePathAndName, -1 + fileNameStart)
        '
        ' 2015 dec 3 moved workbook, controls, and IVtable creation into this If statement
        '
        ' make a new workbook
        Workbooks.Add
    
        ' create a "controls" tab in the active workbook if necessary
        'createControlsTab
    
        ' set up the IVtable stuff as in Marc's version
        'setupIVTable

        readOneSlurp (slurpFilePathAndName), "SLURP" 'slurpFileName
    End If

End Sub

'Set up the Names entries for PM_META, PM_META_INDEX
'Leave a single blank if there are no indexed values.
Public Sub setupIVTable()
    Dim tabtlc As Range
    Dim a As Range
    Dim n As Long

    Set tabtlc = Sheets("Control").Range([PM_IVTable])
    Set a = tabtlc.CurrentRegion
    n = a.Rows.Count - 1
    n = IIf(n > 0, n, 1)
    Names.Add "PM_META", a.Cells(2, 1).Resize(n, 1)
    Names.Add "PM_META_INDEX", a.Cells(2, 2).Resize(n, 1)
End Sub

'Read one SLURP from the folder
'filePath = file path to SLURP file
'sheetName = sheet name
Public Sub readOneSlurp(filePath As String, sheetName As String)

    Dim controlsheet As Worksheet
    Dim aSheet As Worksheet
    Dim putSlurpKeys As Range
    Dim putSipKeys As Range
    Dim putSipData As Range
    Dim getSlurpKeys As Range
    Dim getSipKeys As Range
    Dim i As Long

'''    Set controlsheet = Sheets(SHEET_NAME)

    'Set up the sheet
    On Error Resume Next
        Set aSheet = Sheets(sheetName)
        If Err = 0 Then
            aSheet.UsedRange.ClearContents
        Else
            Set aSheet = Sheets.Add '(After:=controlsheet)
            aSheet.Name = sheetName
        End If
    On Error GoTo 0
    aSheet.Activate

    'Lay out the SLURP metadata keys
    Set putSlurpKeys = aSheet.Range("C5") ' was [PM_SLURPkeys]
    Dim slurpKeysA As Variant
    slurpKeysA = Array("SLURP", "name", "coherent", "count", "about", "origin")
    For i = LBound(slurpKeysA) To UBound(slurpKeysA)
        putSlurpKeys(i + 1 - LBound(slurpKeysA), 1) = slurpKeysA(i)
    Next i
    Set putSlurpKeys = putSlurpKeys.Resize(i - LBound(slurpKeysA), 1)

    'Layout the SIP metadata keys
    Set putSipKeys = aSheet.Range("C15") ' C15 was [PM_SIPkeys]
    Dim sipKeysA As Variant
    sipKeysA = Array("SIP", "name", "type", "count", "csvr", "about")
    For i = LBound(sipKeysA) To UBound(sipKeysA)
        putSipKeys(i + 1 - LBound(sipKeysA), 1) = sipKeysA(i)
    Next i
    Set putSipKeys = putSipKeys.Resize(i - LBound(sipKeysA), 1)
    
    Set putSipData = aSheet.Range("D26") ' D26 was [PM_siptlc]

    'Read and layout the SLURP

    'Read from a SIP Library
        fromStdLib_ViaMSXML30 filePath, putSipData, _
            putSipKeys, putSipKeys.Cells(1, 2), _
            putSlurpKeys, putSlurpKeys.Cells(1, 2)

End Sub

'Get a folder path
Public Function GetFolder(ByVal Title As String) As String
#If Mac Then
#Else
    With Application.FileDialog(msoFileDialogFolderPicker)
        .Title = Title
        If .Show Then
            GetFolder = .SelectedItems(1)
        End If
    End With
#End If
End Function

Private Function fromStdLib_ViaMSXML30( _
    path As String, _
    SIPs As Range, _
    keys As Range, _
    attributes As Range, _
    SLURPkeys As Range, _
    SLURPvalues As Range _
    ) As Boolean
#If Mac Then
#Else
    '
    ' set up SIptlc, SIPkeys, SIPvalues, for export routines
    '
    SIPs.Parent.Parent.Names.Add "PM_SIPtlc", SIPs
    keys.Parent.Parent.Names.Add "PM_SIPkeys", keys
    attributes.Parent.Parent.Names.Add "PM_SIPvalues", attributes

    Dim xmlDoc As DOMDocument30
    Dim filePath As String      'file name
    Dim fso As FileSystemObject
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim a As String
    Dim b As String
    Dim SIPCount As Long        'number of samples
    Dim SIPnum As Long          'SIP Counter
    Dim SIPname As String       'SIP name attribute
    Dim SIPattrs As String      'SIP Attributes string
    Dim SIPakeys                'SIP Attributes called for
    Dim sipCSV As String        'SIP CSV string
    Dim SIPar As Range          'SIP column array
    Dim numIV As Long           'Size of index vector
    Dim foundit As Boolean
'''    Dim indexVal As Range
'''    Dim controlsheet As Worksheet
    Dim varVal As Variant

    fromStdLib_ViaMSXML30 = False
'''    Set controlsheet = Sheets(SHEET_NAME)

    Set xmlDoc = New DOMDocument30
    xmlDoc.validateOnParse = False ' no DTD or schema defined, so don't validate
    xmlDoc.async = False
    Set fso = CreateObject("Scripting.FileSystemObject")
    'Path to the file. Make sure it exists
    filePath = fso.GetAbsolutePathName(path)
    If Not fso.FileExists(filePath) Then
        Err.Raise 6666, "fromStdLib_ViaMSXML30", "Can't find file " & filePath
    End If
    If Not xmlDoc.Load(filePath) Then
        Err.Raise 6667, "fromStdLib_ViaMSXML30", "Can't load file " & filePath
    End If
    '
    ' now we have the whole SLURP lib in xmlDoc, we hope
    '
    'Process SLURP attributes
    For i = 1 To UBound(SLURPkeys.value)
        varVal = xmlDoc.DocumentElement.getAttribute(SLURPkeys.Cells(i, 1))
        SLURPvalues.Cells(i, 1) = IIf(IsNull(varVal), "", varVal)
    Next i

    ' -------------- Process SIPs in the SLURP ----------------------

    Dim xmlSIPlist As IXMLDOMNodeList
    Dim xmlSIP As IXMLDOMNode
    Dim xmlAttr As IXMLDOMAttribute
    Dim xmlElement As IXMLDOMElement
    Dim sAttrVal As String
    Dim sProcessedMark As String   ' string appended to attribute values to mark them as already processed
                                   ' there must be a better way to do that but I don't know what it is
    Dim rMetadataNameCell As Range
'''    Dim rMeta As Range             ' range of metadata names
    Dim numMeta As Long            ' number of metadata items
'''    Dim rMetaIndex As Range        ' metadata indices
    Dim aSipRowHeads As Variant    ' trial number and names of metadata for the SIP arrays
    Dim aSipRowHeadsT As Variant   ' transpose of above
    Dim n As Long
'-------------------------------------------------------
    Dim aMetaData As Variant
    Dim aMetaIndex As Variant
    
    aMetaData = Array() ' creates an empty array with ubound = lbound - 1
    aMetaIndex = Array()
    sProcessedMark = "_octothorpe_processed"
    aSipRowHeads = Array()
    Set xmlSIPlist = xmlDoc.DocumentElement.ChildNodes
    For SIPnum = 0 To xmlSIPlist.length - 1
        Set xmlSIP = xmlDoc.DocumentElement.ChildNodes(SIPnum)
        Set xmlElement = xmlSIP

        'Break into attributes and values
        sipCSV = xmlSIP.Text

        'Process Values
        Set xmlElement = xmlSIP
        varVal = xmlElement.getAttribute("count")
        sAttrVal = IIf(IsNull(varVal), "", varVal)
        SIPCount = CLng(sAttrVal)
        'ActiveWorkbook.Sheets(SHEET_NAME).Range("PM_Trials") = SIPCount
        ' mark as processed, by appending sProcessedMark to the attribute value
        If (Right$(sAttrVal, Len(sProcessedMark)) <> sProcessedMark) Then xmlElement.setAttribute "count", sAttrVal & sProcessedMark
        Set SIPar = SIPs.Cells(1, SIPnum + 1).Resize(SIPCount, 1)
        SIPar.value = fromCSV(sipCSV)
        numIV = SIPCount
        If UBound(aSipRowHeads) < SIPCount Then
            ReDim Preserve aSipRowHeads(1 To SIPCount)
            For n = 1 To SIPCount
                aSipRowHeads(n) = n
            Next n
        End If

        'Process attributes
        For k = 2 To UBound(keys.value)
            a = keys.Cells(k, 1)
            varVal = xmlElement.getAttribute(a)
            b = IIf(IsNull(varVal), "", varVal)
            If (Right$(b, Len(sProcessedMark)) <> sProcessedMark) Then xmlElement.setAttribute a, b & sProcessedMark
            If (Right$(b, Len(sProcessedMark)) = sProcessedMark) Then b = Left$(b, Len(b) - Len(sProcessedMark))
            attributes.Cells(k, SIPnum + 1) = b
        Next k

        Set SIPar = SIPs.Cells(1, SIPnum + 1).Resize(numIV, 1)
        varVal = xmlElement.getAttribute("name")
        If Right$(varVal, Len(sProcessedMark)) = sProcessedMark Then varVal = Left$(varVal, Len(varVal) - Len(sProcessedMark))
        varVal = IIf(IsNull(varVal), "_", varVal)
        SIPname = Replace(varVal, " ", "_")
        Names.Add SIPname, SIPar

        '
        ' add all other attributes to metadata list, if they aren't there already, or processed already
        '
        For Each xmlAttr In xmlElement.attributes
            If Right$(xmlAttr.value, Len(sProcessedMark)) <> sProcessedMark Then
                '
                ' see if this attr is in the metadata list
                '
                For numMeta = LBound(aMetaData) To UBound(aMetaData)
                    If aMetaData(numMeta) = xmlAttr.Name Then Exit For
                Next numMeta
                If numMeta > UBound(aMetaData) Then ' attr name was not found so add it to list
                    ReDim Preserve aMetaData(LBound(aMetaData) To numMeta)
                    ReDim Preserve aMetaIndex(LBound(aMetaIndex) To numMeta)
                    aMetaData(numMeta) = xmlAttr.Name
                    aMetaIndex(numMeta) = Application.WorksheetFunction.Max(aMetaIndex, SIPCount) + 1
                    If aMetaIndex(numMeta) > UBound(aSipRowHeads) Then
                        ReDim Preserve aSipRowHeads(1 To aMetaIndex(numMeta))
                        aSipRowHeads(aMetaIndex(numMeta)) = xmlAttr.Name
                    End If
                Else
                    ' attr was found already
                End If
                '
                ' add attr to SIP column
                '
                SIPar.Cells(aMetaIndex(numMeta), 1).value = xmlAttr.value
                Names.Add SIPname & ".MD", SIPar.Resize(aMetaIndex(numMeta))
                Names.Add SIPname, SIPar.Resize(SIPCount)
            End If
        Next xmlAttr
    Next SIPnum
    '
    ' Add PM_Meta and PM_Meta_Index ranges and data if there is any to add
    '
    If LBound(aMetaData) <= UBound(aMetaData) Then
        With SIPs.Parent ' SIPs is a range on the sheet where the data is being written
        '
        ' insert rows at top to hold metadata table
        '
            .Range("A2").Resize(2 + UBound(aMetaData) - LBound(aMetaData), 1).EntireRow.Insert
        '
        ' insert headers
        '
            .Range("B2") = "Indexed Values"
            .Range("C2") = "Index"
        '
        ' insert data
        '
            .Range("B3").Resize(1 + UBound(aMetaData) - LBound(aMetaData), 1) _
                = Application.WorksheetFunction.Transpose(aMetaData)
            .Range("C3").Resize(1 + UBound(aMetaIndex) - LBound(aMetaIndex), 1) _
                = Application.WorksheetFunction.Transpose(aMetaIndex)
        '
        ' define the names
        '
            ActiveWorkbook.Names.Add _
                "PM_Meta", _
                .Range("B3").Resize(1 + UBound(aMetaData) - LBound(aMetaData), 1)
            ActiveWorkbook.Names.Add _
                "PM_Meta_Index", _
                .Range("C3").Resize(1 + UBound(aMetaIndex) - LBound(aMetaIndex), 1)
        End With
    End If ' metadata is present
    
    With SIPs.Parent
        .Range("A1") = SIPCount
        Names.Add "PM_Trials", .Range("A1")
    End With

    ReDim aSipRowHeadsT(1 To UBound(aSipRowHeads), 1 To 1)

    For n = 1 To UBound(aSipRowHeads)
        aSipRowHeadsT(n, 1) = aSipRowHeads(n)
    Next n
    SIPs.Offset(0, -1).Resize(UBound(aSipRowHeads), 1).value = aSipRowHeadsT

    SIPs.Resize(SIPCount, 1).EntireRow.Group
    SIPs.Resize(SIPCount, 1).EntireRow.Hidden = True

    Dim vSaveAsFileName As Variant
    Dim bSaveDone As Boolean

    bSaveDone = False
    Do Until bSaveDone
        vSaveAsFileName = Application.GetSaveAsFilename("", "XLSX file (*.xlsx), *.xlsx")
        '
        ' make sure file ends in .xlsx
        '
        If VarType(vSaveAsFileName) = vbString Then
            If LCase(Right$(vSaveAsFileName, 5)) = ".xlsx" Then
                ActiveWorkbook.SaveAs vSaveAsFileName, 51
                bSaveDone = True
            Else
                MsgBox "File name should end in .xlsx", vbInformation, APP_NAME
            End If
        Else
            bSaveDone = True
        End If
    Loop

#End If

End Function

'Read from a SIP Library
'path = Std XML file path
'SIPs = where to put the SIP columns
'keys = list of attributes to capture from each SIP
'attributes = where to put the attributes
'slurpkeys = list of slurp metadata keys
'slurpvalues = where to put the SLURP metadata values
'Returns true if no problems

Private Function fromStdLibrary( _
    path As String, _
    SIPs As Range, _
    keys As Range, _
    attributes As Range, _
    SLURPkeys As Range, _
    SLURPvalues As Range _
    ) As Boolean


    Dim sipstr As String          'SIP string
    Dim s As String             'Line from file
    Dim filePath As String      'file name
#If Mac Then
    Dim fso
    Dim dfile
#Else
    Dim fso As FileSystemObject
    Dim dfile As TextStream
#End If
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim a As String
    Dim b As String
    Dim SIPCount As Long        'number of samples
    Dim SIPnum As Long          'SIP Counter
    Dim SIPname As String       'SIP name attribute
    Dim SIPattrs As String      'SIP Attributes string
    Dim SIPakeys                'SIP Attributes called for
    Dim sipCSV As String        'SIP CSV string
    Dim SIPar As Range          'SIP column array
    Dim numIV As Long           'Size of index vector
    Dim foundit As Boolean
    Dim indexVal As Range
    Dim controlsheet As Worksheet


    fromStdLibrary = False
    Set controlsheet = Sheets("Control")


    ' ------------ Open the file for reading -----------------------
    Set fso = CreateObject("Scripting.FileSystemObject")
    'Path to the file. Make sure it exists
    filePath = fso.GetAbsolutePathName(path)
    If Not fso.FileExists(filePath) Then
        Err.Raise 6666, "fromStdLibrary", "Can't find file " & filePath
    End If
    'Open the file -Use GetStandardStream for Unicode
    Set dfile = fso.OpenTextFile(filePath)

    ' --------------- Find and Process SLURP --------------------------
    foundit = False
    Do
        s = readNextLine(dfile)
        'Is it a SLURP element?
        i = InStr(1, s, "<SLURP ", vbTextCompare)
        If i > 0 Then
            foundit = True
        End If
    Loop Until foundit

    'Process SLURP attributes
    i = InStr(s, ">")
    Do Until i > 0
        s = s & readNextLine(dfile)
        i = InStr(s, ">")
    Loop
    For i = 1 To UBound(SLURPkeys.value)
        SLURPvalues.Cells(i, 1) = keyAttr(s, SLURPkeys.Cells(i, 1))
    Next i

    ' -------------- Process SIPs until </SLURP> ----------------------
    foundit = False
    SIPnum = 0
    Do
        s = readNextLine(dfile)
        'detect end of SLURP
        i = InStr(1, s, "</SLURP>", vbTextCompare)
        If i > 0 Then
            foundit = True
        End If

        'Look for a SIP
        i = InStr(1, s, "<SIP ", vbTextCompare)
        If i > 0 Then
            'Found <SIP, collect input to </SIP>
            sipstr = ""
            s = Right$(s, Len(s) - i - 4)
            Do
                j = InStr(i, s, "</SIP>", vbTextCompare)
                If j > 0 Then
                    'Found it, now process it
                    sipstr = sipstr & Left$(s, j - 1)
                    SIPnum = SIPnum + 1

                    'Break into attributes and values
                    k = InStr(sipstr, ">")
                    SIPattrs = Left$(sipstr, k - 1)
                    sipCSV = Right$(sipstr, Len(sipstr) - k)

                    'Process Values
                    Set indexVal = controlsheet.Range([PM_Indexed])

                    SIPCount = CLng(keyAttr(SIPattrs, "count"))
                    Set SIPar = SIPs.Cells(1, SIPnum).Resize(SIPCount, 1)
                    SIPar.value = fromCSV(sipCSV)
                    numIV = SIPCount

                    'Process attributes
                    For k = 2 To UBound(keys.value)
                        a = keys.Cells(k, 1)
                        b = keyAttr(SIPattrs, a)
                        attributes.Cells(k, SIPnum) = b
                        If Not IsEmpty(indexVal(k, 1)) Then
                            SIPar.Cells(indexVal(k, 1).value, 1) = b
                            numIV = WorksheetFunction.Max(numIV, indexVal(k, 1).value)
                        End If
                    Next k

                    Set SIPar = SIPs.Cells(1, SIPnum).Resize(numIV, 1)
                    SIPname = Replace(keyAttr(SIPattrs, "name"), " ", "_")
                    Names.Add SIPname, SIPar
                    Exit Do
                Else
                    'still looking for </SIP>
                    sipstr = sipstr & s
                    s = readNextLine(dfile)
                End If
            Loop
        End If
    Loop Until foundit
    fromStdLibrary = True
End Function

'Read one line
' *** Future: detect and skip comments
#If Mac Then
Private Function readNextLine(dfile) As String

End Function
#Else
Private Function readNextLine(dfile As TextStream) As String
    Dim s As String
    Do
        If dfile.AtEndOfStream Then
            dfile.Close
            Set dfile = Nothing
            Err.Raise 6666, "fromStdLibrary", "Premature end of file"
        End If
        s = dfile.readline
    Loop Until Len(s) > 0
    readNextLine = s
End Function
#End If
' *****************************************************
'           Write SIPs to XML in a file
' *****************************************************

Public Sub writeSlurpLibrary()
    Dim cSht As Worksheet
    Dim fileTable As Range
    Dim fileCell As Range
    Dim filePath As String
    Dim folderPath As String
    Dim slurpSheetName As String
    Dim slurpMetaKeys As Range
    Dim slurpMetaValues As Range
    Dim sipMetaKeys As Range
    Dim sipMetaValues As Range
    Dim sipData As Range
    Dim i

    'Where to get the SLURP file and sheet names
    Set fileTable = Range([SLURPS])

    'get a folder from the user
    folderPath = GetFolder("Pick a Library Folder")

    'Loop through the slurp files
    i = 1
    Do
        Set fileCell = fileTable(i, 1)
        If IsEmpty(fileCell) Then Exit Do

        slurpSheetName = fileTable(i, 2).value
        Set cSht = Sheets(slurpSheetName)

        filePath = folderPath & "\" & fileCell.value

        'Write one SLURP File
        'Setup table top left corner pointers
        Set slurpMetaKeys = cSht.Range([SLURPkeys])(2, 1)
        Set slurpMetaValues = slurpMetaKeys(1, 2)
        Set sipMetaKeys = cSht.Range([SIPkeys])(2, 1)
        Set sipMetaValues = sipMetaKeys(1, 2)
        Set sipData = cSht.Range([siptlc])

        'Format and write the file
        toStdLibrary filePath, slurpMetaKeys, slurpMetaValues, _
            sipMetaKeys, sipMetaValues, sipData

        i = i + 1
    Loop
End Sub


'Write SLURP to a standard SIP XML library file

'filePath = path to output file
'SLURPkeys = SLURP attribute key table. TLC
'SLURPvalues = SLURP attribute value table. TLC
'SIPkeys = SIP attribute keys. TLC
'SIPvalues = SIP attribute values. TLC
'SIPs = where to find the SIP columns. TLC
'csvr = default number of digits after the decimal

'Range values point to source worksheet.
' All are top left corner.

Public Sub toStdLibrary( _
    filePath As String, _
    SLURPkeys As Range, _
    SLURPvalues As Range, _
    SIPkeys As Range, _
    SIPvalues As Range, _
    SIPs As Range, _
    Optional csvr _
    )
#If Mac Then
    Dim fso  'File params
    Dim dfile
#Else
    Dim fso As FileSystemObject 'File params
    Dim dfile As TextStream
#End If
    Dim k As String
    Dim v As String
    Dim s As String
    Dim i As Long
    Dim j As Long
    Dim sip
    Dim SIPCount As Long
    Dim t() As String ' dge: translated key names
    Dim m As String ' dge: message to user about translating
    Dim n As Long   ' dge

    If IsMissing(csvr) Then csvr = 2

    'Open the file for overwrite
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set dfile = fso.CreateTextFile(filePath, True)

    'Write the SLURP tag
    s = "<SLURP "
    i = 1
    Do Until IsEmpty(SLURPkeys(i, 1))
        s = s & attr(CStr(SLURPkeys(i, 1)), CStr(SLURPvalues(i, 1)))
        i = i + 1
    Loop
    s = s & ">"
    dfile.WriteLine s

    'Write the SIPs
    j = 1   'SIP Number
    Do Until IsEmpty(SIPvalues(1, j))

        'Write one SIP
        s = "<SIP " 'start SIP string

        ' check that attribute names will be ok
        i = 1
        m = ""
        Do Until IsEmpty(SIPkeys(i, 1))
            k = CStr(SIPkeys(i, 1))
            ReDim Preserve t(1 To i)
            t(i) = k
            If 0 = InStr(ALPHA_UNDER, Left(t(i), 1)) Then
                t(i) = translateChar(Left(t(i), 1)) & "_" & Mid(t(i), 2)
            End If
            n = 2
            Do Until n > Len(t(i))
                If 0 = InStr(ALPHANUM_DASH_PERIOD_, Mid(t(i), n, 1)) Then
                    t(i) = Left(t(i), n - 1) & translateChar(Mid(t(i), n, 1)) & Mid(t(i), n + 1)
                    n = n - 1 + Len(translateChar(Mid(t(i), n, 1)))
                End If
                n = n + 1
            Loop
            If t(i) <> k Then m = vbNewLine & m & k & " ===> " & t(i)
            i = i + 1
        Loop
        If m <> "" Then
            If vbYes = MsgBox("Some of the metadata names might be invalid for the XML format." _
                & vbNewLine & "SIPmath can translate these names into valid forms for XML." _
                & vbNewLine & "The suggested translations ars shown below:" & m _
                & vbNewLine & "You can accept these translations or cancel and manually rename " _
                & "the metadata.", vbOKCancel, APP_NAME) _
            Then
                For i = 1 To UBound(t)
                    SIPkeys(i, 1) = t(i)
                Next i
            Else
                Exit Sub
            End If
        End If

        'Attributes
        i = 1
        Do Until IsEmpty(SIPkeys(i, 1))
            k = CStr(SIPkeys(i, 1))
            v = CStr(SIPvalues(i, j))
            s = s & attr(k, v)
            If LCase(k) = "count" Then SIPCount = CLng(v)
            If LCase(k) = "csvr" Then csvr = v
            i = i + 1
        Loop
        s = s & "> "

        'content
        sip = SIPs(1, j).Resize(SIPCount, 1).value
        s = s & toCSV(sip, csvr) & "</SIP>"
        dfile.WriteLine s
        j = j + 1
    Loop
    'write the SLURP end
     dfile.WriteLine "</SLURP>"

    'close the file
    dfile.Close
    DoEvents
    Set dfile = Nothing

End Sub




' *******************************************************
'          Borrowed from SDXL
' *******************************************************

' Get an attribute from an XML string
' Just looks for key="value"
Private Function keyAttr(dtext, key) As String
    Dim matches
    Dim match
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    regex.Pattern = "\b" & key & "\s*=\s*""([^""]+)"""
    regex.Global = False
    Set matches = regex.Execute(dtext)
    If matches.Count = 0 Then
        keyAttr = ""
    Else
        keyAttr = matches(0).submatches(0)
    End If
End Function

'Format an attribute string
Private Function attr(key As String, value As String) As String
    attr = " " & key & "=""" & value & """"
End Function

'Convert a CSV string to a colArray
Public Function fromCSV(s As String)
    Dim a() As String
    Dim n As Long
    Dim ar()
    Dim i As Long

    a = Split(s, ",")
    n = 1 + UBound(a)
    ReDim ar(1 To n, 1 To 1)
    For i = 1 To n
        ar(i, 1) = CDbl(a(i - 1))
    Next i
    fromCSV = ar
End Function


'Convert a distribution to a CSV string
Public Function toCSV(a, Optional r = 0) As String
    Dim z
    Dim b()
    Dim s As String
    Dim d As Integer
    Dim i As Long

    ReDim b(1 To UBound(a))

    'Check for Boolean - change -1 to 1
    If TypeName(a(1, 1)) = "Boolean" Then
        For i = 1 To UBound(a)
            b(i) = IIf(a(i, 1), "1", "0")
        Next i
    Else
        d = CInt(r)
        For i = 1 To UBound(a)
            b(i) = FormatNumber(a(i, 1), d, vbFalse, , vbFalse)
        Next i
    End If
    toCSV = Join(b, ",")
End Function

Sub createControlsTab()

    On Error Resume Next

    Dim cSheet As Worksheet

    Set cSheet = ActiveWorkbook.Sheets(SHEET_NAME)
    If Err = 0 Then
        cSheet.UsedRange.ClearContents
    Else
        Set cSheet = Sheets.Add
        cSheet.Name = SHEET_NAME
    End If

    With cSheet
        .Range("A1").Formula = "Globals"
        .Range("A2").Formula = "PM_Trials"
'''        .Range("B2").Formula = "1000" '
        .Range("A3").Formula = "Indexed"
        .Range("B3").Formula = "F14"
        .Range("H3").Formula = "Indexed Values"
        .Range("I3").Formula = "Index"
        .Range("A4").Formula = "SLURPS"
        .Range("B4").Formula = "A13"
'''        .Range("H4").Formula = "Average"
'''        .Range("I4").Formula = "=F21"
        .Range("A5").Formula = "SLURPMeta"
        .Range("B5").Formula = "D14"
'''        .Range("H5").Formula = "Minimum"
'''        .Range("I5").Formula = "=F19"
        .Range("A6").Formula = "SIPMeta"
        .Range("B6").Formula = "E14"
'''        .Range("H6").Formula = "Maximum"
'''        .Range("I6").Formula = "=F20"
        .Range("A7").Formula = "IVTable"
        .Range("B7").Formula = "H3"
        .Range("A8").Formula = "SLURPkeys"
        .Range("B8").Formula = "C5"
        .Range("A9").Formula = "PM_SIPkeys"
        .Range("B9").Formula = "C15"
        .Range("A10").Formula = "PM_SIPtlc"
        .Range("B10").Formula = "D26"
        .Range("A12").Formula = "SLURP Files"
        .Range("B12").Formula = "Sheets"
        .Range("A13").Formula = "cons_Jun-2013.sip"
        .Range("B13").Formula = "Consumption"
        .Range("D13").Formula = "Metadata keys"
        .Range("D14").Formula = "SLURP"
        .Range("E14").Formula = "SIP"
        .Range("F14").Formula = "Indexed"
        .Range("D15").Formula = "name"
        .Range("E15").Formula = "name"
        .Range("D16").Formula = "coherent"
        .Range("E16").Formula = "type"
        .Range("D17").Formula = "count"
        .Range("E17").Formula = "count"
        .Range("D18").Formula = "about"
        .Range("E18").Formula = "csvr"
        .Range("D19").Formula = "origin"
#If True Then
        .Range("E19").Formula = "about"
#Else
        .Range("E19").Formula = "min"
        .Range("F19").Formula = "1002"
        .Range("E20").Formula = "max"
        .Range("F20").Formula = "1003"
        .Range("E21").Formula = "avg"
        .Range("F21").Formula = "1001"
        .Range("E22").Formula = "about"
#End If
    End With
    With ActiveWorkbook
        .Names.Add "PM_Indexed", "='" & SHEET_NAME & "'!$B$3"
        .Names.Add "PM_IVTable", "='" & SHEET_NAME & "'!$B$7"
        .Names.Add "PM_META", "='" & SHEET_NAME & "'!$D$4:$D$4"
        .Names.Add "PM_META_INDEX", "='" & SHEET_NAME & "'!$E$4:$E$4"
        .Names.Add "PM_Trials", "='" & SHEET_NAME & "'!$B$2"
        .Names.Add "PM_SIPkeys", "='" & SHEET_NAME & "'!$B$9"
        .Names.Add "PM_SIPMeta", "='" & SHEET_NAME & "'!$B$6"
        .Names.Add "PM_SIPtlc", "='" & SHEET_NAME & "'!$B$10"
        .Names.Add "PM_SLURPkeys", "='" & SHEET_NAME & "'!$B$8"
        .Names.Add "PM_SLURPMeta", "='" & SHEET_NAME & "'!$B$5"
        .Names.Add "PM_SLURPS", "='" & SHEET_NAME & "'!$B$4"
    End With

End Sub

Function translateChar(c As String) As String

    Select Case c
        Case "!": translateChar = "_exclam_"
        Case """": translateChar = "_quote_"
        Case "#": translateChar = "_hash_"
        Case "$": translateChar = "_dollar_"
        Case "%": translateChar = "_pct_"
        Case "&": translateChar = "_and_"
        Case "'": translateChar = "_singlequote_"
        Case "(": translateChar = "_lparen_"
        Case ")": translateChar = "_rparen_"
        Case "*": translateChar = "_asterisk_"
        Case "+": translateChar = "_plus_"
        Case ",": translateChar = "_comma_"
        Case "/": translateChar = "_slash_"
        Case "0": translateChar = "zero_"
        Case "1": translateChar = "one_"
        Case "2": translateChar = "two_"
        Case "3": translateChar = "three_"
        Case "4": translateChar = "four_"
        Case "5": translateChar = "five_"
        Case "6": translateChar = "six_"
        Case "7": translateChar = "seven_"
        Case "8": translateChar = "eight_"
        Case "9": translateChar = "nine_"
        Case ":": translateChar = "_colon_"
        Case ";": translateChar = "_semicolon_"
        Case "<": translateChar = "_less-than_"
        Case "=": translateChar = "_equal_"
        Case ">": translateChar = "_greater-than_"
        Case "?": translateChar = "_question_"
        Case "@": translateChar = "_at_"
        Case "[": translateChar = "_lbracket_"
        Case "\": translateChar = "_backslash_"
        Case "]": translateChar = "_rbracket_"
        Case "^": translateChar = "_caret_"
        Case "`": translateChar = "_backquote_"
        Case "{": translateChar = "_lbrace_"
        Case "|": translateChar = "_vertical_"
        Case "}": translateChar = "_rbrace_"
        Case "~": translateChar = "_tilde_"
        Case " ": translateChar = "_"
        Case Else: translateChar = "_chr" & Format(Asc(c), "000") & "_"
    End Select

End Function

Attribute VB_Name = "Module1"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
'
' to prep for mac:
' uncheck references to
' - Microsoft Scripting Runtime
' - Microsoft Shell Controls and Automation
' - Microsoft XML, v3.0
'
Option Explicit

Public Const VERSION_NUMBER As String = "3.4.6"

Public g_sWorkbookName As String

#If PROJECT = SIPMATH_HISTOGRAM Then
Public Const SIPmathHistogram As Boolean = True
Public Const appName As String = "Histogram"
#Else
Public Const SIPmathHistogram As Boolean = False
Public Const appName As String = "Modeler Tools"
#End If

#If Mac Then
Const MY_STYLE As Long = msoButtonIcon
Function tmSymbol() As String: tmSymbol = Chr(170): End Function
#Else
Const MY_STYLE As Long = msoButtonCaption
Function tmSymbol() As String: tmSymbol = ChrW(&H2122): End Function
#End If

Public Sub SIPmathModelerToolsCreateMenu()

    Dim MyControl As CommandBarButton, MyBar
    
    On Error Resume Next
    Application.CommandBars("SIPmathModelerToolsBar").Delete
    On Error GoTo 0
    
    With CommandBars
        .DisplayTooltips = True
        .DisplayKeysInTooltips = True
    End With
    
#If Mac Then
    Application.CommandBars.Add(Name:="SIPmathModelerToolsBar").Visible = True
    Set MyBar = Application.CommandBars("SIPmathModelerToolsBar")
#Else
    Set MyBar = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup, Temporary:=True)
    MyBar.Caption = "&SIPmath"
    'MyBar.Name = "SIPmathModelerToolsBar"
#End If

#If PROJECT = SIPMATH_TOOLS Then

'Initialize
    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
        .OnAction = "Setup"
        .TooltipText = "Initialize"
        '.Picture = Application.CommandBars.GetImageMso("TranslationToolTip", 16, 16)
#If Mac Then
        .FaceId = 284
#Else
        .Caption = .TooltipText
#End If ' Mac
    End With
    
'Define output
'Clear
'Graphs
'Get Stats
'Trial Info
'Save Results
'Settings
'About

'Library Input
    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
        .OnAction = "ShowInputForm"
        .TooltipText = "Define Inputs"
        '.Picture = Application.CommandBars.GetImageMso("FileCheckIn", 16, 16)
#If Mac Then
        .FaceId = 44
#Else
        .Caption = .TooltipText
#End If ' Mac
    End With
    
''Generate Input
'    MyBar.Controls.Add Type:=msoControlDropdown
'    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
'    With MyControl
'        .Style = MY_STYLE
'        .OnAction = "ShowInputForm"
'        .TooltipText = "Define Inputs"
'        '.Picture = Application.CommandBars.GetImageMso("FileCheckIn", 16, 16)
'#If Mac Then
'        .FaceId = 44
'#Else
'        .Caption = .TooltipText
'#End If ' Mac
'    End With
'
    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
        .OnAction = "ShowMakeTableForm"
        .TooltipText = "Define Outputs"
        '.Picture = Application.CommandBars.GetImageMso("FileCheckOut", 16, 16)
#If Mac Then
        .FaceId = 243
#Else
        .Caption = .TooltipText
#End If ' Mac
        ''ThisWorkbook.Sheets("Sheet1").Shapes(1).CopyPicture
        ''.PasteFace
    End With
    
#End If

    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
#If PROJECT = SIPMATH_HISTOGRAM Then
        .OnAction = "smh_ShowGraphsForm"
#Else
        .OnAction = "ShowGraphsForm"
#End If
        .TooltipText = "Graphs"
        '.Picture = Application.CommandBars.GetImageMso("TableStyleTotalsRow", 16, 16)
#If Mac Then
        .FaceId = 433
#Else
        .Caption = .TooltipText
#End If ' Mac
    End With
    
#If PROJECT = SIPMATH_TOOLS Then

    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
        .OnAction = "convertReference"
        .TooltipText = "Stats"
        '.Picture = Application.CommandBars.GetImageMso("Help", 16, 16)
#If Mac Then
        .FaceId = 226
#Else
        .Caption = .TooltipText
#End If ' Mac
    End With
    
    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
        .OnAction = "ShowInfo"
        .TooltipText = "Trial Info"
        '.Picture = Application.CommandBars.GetImageMso("ControlLayoutTabular", 16, 16)
#If Mac Then
        .FaceId = 300
#Else
        .Caption = .TooltipText
#End If ' Mac
    End With
    
    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
        .OnAction = "saveResultsAsSipLib"
        .TooltipText = "Save Results"
        '.Picture = Application.CommandBars.GetImageMso("ControlLayoutTabular", 16, 16)
#If Mac Then
        .FaceId = 159
#Else
        .Caption = .TooltipText
#End If ' Mac
    End With
#End If

    MyBar.Controls.Add Type:=msoControlButton
    Set MyControl = MyBar.Controls(MyBar.Controls.Count)
    With MyControl
        .Style = MY_STYLE
#If PROJECT = SIPMATH_HISTOGRAM Then
        .OnAction = "smh_AboutBtn"
        .TooltipText = "About SIPmath Histogram"
#Else
        .OnAction = "AboutBtn"
        .TooltipText = "About SIPmath Modeler Tools"
#End If
        '.Picture = Application.CommandBars.GetImageMso("Help", 16, 16)
#If Mac Then
        .FaceId = 49
#Else
        .Caption = .TooltipText
#End If ' Mac
    End With
    
End Sub

'Callback for customButton onAction
#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub ShowMakeTableForm()
#Else
Public Sub ShowMakeTableForm(Optional control As IRibbonControl)
#End If
    UserFormDefineOutputs.Show
    chkCalcMode
End Sub

#If PROJECT = SIPMATH_HISTOGRAM Then
#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub smh_ShowGraphsForm()
#Else
Public Sub smh_ShowGraphsForm(Optional control As IRibbonControl)
#End If
#Else
#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub ShowGraphsForm()
#Else
Public Sub ShowGraphsForm(Optional control As IRibbonControl)
#End If
#End If
    On Error Resume Next
    Unload UserForm_smmt_Graphs
    UserForm_smmt_Graphs.Show
    chkCalcMode
End Sub

#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub ShowInputForm()
#Else
Public Sub ShowInputForm(Optional control As IRibbonControl)
#End If
    UserFormFromLibrary.Show
    chkCalcMode
End Sub

#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub Setup()
#Else
Public Sub Setup(Optional control As IRibbonControl)
#End If
'    Debug.Print "before init,calc mode = "; Application.Calculation
    UserFormInitialize.Show
'    Debug.Print "after init, calc mode = "; Application.Calculation
    chkCalcMode
End Sub

#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub ShowInfo()
#Else
Public Sub ShowInfo(Optional control As IRibbonControl)
#End If
    Dim r As Variant
    On Error Resume Next
    '
    ' see if the PM_ ranges exist; if not, display error
    '
    Err.Clear
    Set r = Names("PM_Index").RefersToRange
    '
    ' we won't worry about PM_META_Index or PM_IV_Index or PM_META or PM_IV
    '
    If Err <> 0 Then
        MsgBox "The model has apparently not been initialized.", vbExclamation, APP_NAME
    Else
        UserFormInfo.Show False
        chkCalcMode
    End If
    
End Sub

'Callback for Id_Clear onAction
#If Mac And MAC_OFFICE_VERSION < 15 Then

Sub clearInputOrOutput()
    Call clearInputOrOutput_body
    chkCalcMode
End Sub

#Else

Sub clearInputOrOutput(control As IRibbonControl)
    Call clearInputOrOutput_body
    chkCalcMode
End Sub

#End If

Sub clearInputOrOutput_body()
    '
    ' if selection is a % CDF chart then figure out which output it's charting
    ' and delete the % CDF data of that output
    '
    ' otherwise,
    ' for all cells in current selection,
    ' if they are SIPmath inputs, clear any formulas and sparklines in the cell,
    ' and any data on the SIPmath chart data sheet
    ' if they are SIPmat outputs, clear any sparklines in the cell, remove the output column
    ' on PMTable, remove any data on the SIPmath chart data sheet
    '
    Dim rSelection As Range, rCell As Range, MySeries As New ChartSeries
    
    On Error Resume Next
    If TypeOf Selection Is Chart Or TypeOf Selection.Parent Is Chart Or TypeOf Selection.Parent.Parent Is Chart Then
        If TypeOf Selection Is Chart Then MySeries.Chart = Selection
        If TypeOf Selection.Parent Is Chart Then MySeries.Chart = Selection.Parent
        If TypeOf Selection.Parent.Parent Is Chart Then MySeries.Chart = Selection.Parent.Parent
        MySeries.ChartSeries = 1
        If MySeries.XValuesType <> "Range" Then Exit Sub
        deleteCdfData MySeries.XValues.EntireColumn.Resize(1, 1).Value2
        MySeries.Chart.Parent.Delete
        Exit Sub
    ElseIf Not TypeOf Selection Is Range Then
        Exit Sub
    End If
    
    Dim calcState As Variant
    calcState = Application.Calculation
    Application.Calculation = xlCalculationManual
    
    Set rSelection = Selection
    
    'Dim rex As Object
    'Set rex = CreateObject("VBScript.RegExp")
    
    Dim sInput As String, sRName As String ' _R_ange Name
    Dim rCol As Range, rChartData As Range, rFreqCell As Range, s1stFreqAddress As String
    Dim sFRName As String ' _F_requency formula _R_ange Name
    Dim sBaseRangeName As String, sRangeNameSuffix As Variant
    Dim sTrimRName As String, sTrimFRName As String ' names with any ".MD"s on the end removed
    Dim tableCell As Range, tf As String, sheetName As String
    Dim cRangesToDelete As Collection, nCount As Long
    Dim bIsIO As Boolean, sRCellAddr As String
    ''
    '' define a pattern to recognize Input formulas in a cell
    '' it matches, e.g., =INDEX(, or = INDEX(, and finds 1st arg, which should be the name of an Input range
    ''
    'With rex
    '    .Global = True
    '    .MultiLine = True
    '    .IgnoreCase = True
    '    .Pattern = "^=\s*INDEX\(\s*(\S[^,]*),.*"
    'End With
    
    For Each rCell In rSelection
        bIsIO = False
        '
        ' look for the cell's address on PMTable to see if it's an output cell
        '
        If InStr(rCell.Parent.Name, " ") <> 0 Then
            sRCellAddr = "'" & rCell.Parent.Name & "'!" & rCell.Address(1, 1, xlA1, False)
        Else
            sRCellAddr = rCell.Parent.Name & "!" & rCell.Address(1, 1, xlA1, False)
        End If
        Set tableCell = Nothing
        On Error Resume Next
#If Mac Then
        Set tableCell = ActiveWorkbook.Sheets("PMTable").Rows("3:3").Find( _
            What:=sRCellAddr, _
            After:=ActiveWorkbook.Sheets("PMTable").Cells(3, 1), LookIn:=xlFormulas, _
            LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
            MatchCase:=False)
#Else
        Set tableCell = ActiveWorkbook.Sheets("PMTable").Rows("3:3").Find( _
            What:=sRCellAddr, _
            After:=ActiveWorkbook.Sheets("PMTable").Cells(3, 1), LookIn:=xlFormulas, _
            LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
            MatchCase:=False, SearchFormat:=False)
#End If
        On Error GoTo 0
        If tableCell Is Nothing Then ' then you didn't find it on PMTable, so it's not an output,
                                     ' but might be an input
            '
            ' see if it's an input, if so remove it
            '
            If test_FName(rCell.Formula, "INDEX") Then
            'If rex.test(rCell.Formula) Then ' =INDEX( found as first part of formula,
                                            ' so it might be an Input
                'sRName = rex.Replace(rCell.Formula, "$1")
                sRName = first_arg(rCell.Formula)
                If UCase(Right(sRName, 3)) = ".MD" Then sRName = Left(sRName, Len(sRName) - 3)
                deleteChartData sRName, rCell
                bIsIO = True
            End If
        Else ' cell is an output, so delete the output
            '
            ' rCell is an output, so delete its column in PMTable and any chart data table columns that
            ' refer to it. tableCell should be in the column of PMTable which has the output data
            '
            ' I delete the chart data first
            '
            ' at this point, tableCell should be the cell of the PMTable tab that refers to the
            ' output cell rCell. The cell above tableCell should be the name of the output data
            ' range.
            '
            deleteChartData tableCell.Offset(-1, 0).Value2, rCell
            deleteCdfData tableCell.Offset(-1, 0).Value2
            '
            ' now remove the column of the PMTable containing tableCell by
            ' deleting the table formula, deleting the column, and re-creating the table
            ' with one fewer column
            ' (something similar is done in the re-initialize routine and the add output routine)
            '
            deleteOutputData tableCell
            bIsIO = True
        End If ' tableCell is Nothing
        If bIsIO Then
            ' just clear any sparkline and unmerge cells, but leave input or output formula
            rCell.MergeArea.SparklineGroups.ClearGroups
            rCell.MergeCells = False
        Else
            rCell.MergeArea.Clear
        End If
    Next rCell
    On Error GoTo 0
    Application.Calculation = calcState
    
End Sub

Sub deleteChartData(sRName As String, rCell As Range)
    '
    ' sRName is the input range; look for a chart data column that refers to this range
    ' the best place is in the =FREQUENCY() function
    '
    Dim rChartData As Range, rFreqCell As Range
    Dim sFRName As String ' _F_requency _R_ange Name
    Dim s1stFreqAddress As String, sLastFreqAddress As String
    Dim cRangesToDelete As Collection
    Dim sBaseRangeName As String, vRangeNameSuffix As Variant
    
    'Dim rex2 As Object
    '
    'Set rex2 = CreateObject("VBScript.RegExp")
    'With rex2
    '    .Global = True
    '    .MultiLine = True
    '    .IgnoreCase = True
    '    .Pattern = "^=\s*FREQUENCY\(\s*(\S[^,]*),.*"
    'End With
    
    On Error Resume Next
    Err.Clear
    Set rChartData = ActiveWorkbook.Sheets(scd).UsedRange
    If Err = 0 Then ' chart data found
        '
        ' search chart page for an =FREQUENCY() formula with an argument which is the same
        ' as the previously found argument to INDEX()
        '
        Set cRangesToDelete = New Collection
        Set rFreqCell = rChartData(1)
#If Mac Then
        Set rFreqCell = rChartData.Find(What:="frequency", After:=rFreqCell, _
            LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByColumns, _
            SearchDirection:=xlNext, MatchCase:=False)
#Else
        Set rFreqCell = rChartData.Find(What:="frequency", After:=rFreqCell, _
            LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByColumns, _
            SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=False)
#End If
        If Not rFreqCell Is Nothing Then
            '
            ' look through all cells found with "frequency" in the column.
            ' if one of them has a formula =FREQUENCY( <array>... ) where <array> is also
            ' the argument to =INDEX(), above, then we've presumably found a column
            ' with the chart data for the selected input
            '
            s1stFreqAddress = rFreqCell.Address
            Do
                'If rex2.test(rFreqCell.Formula) Then
                If test_FName(rFreqCell.Formula, "FREQUENCY") Then
                    'sFRName = rex2.Replace(rFreqCell.Formula, "$1")
                    sFRName = first_arg(rFreqCell.Formula)
                    If UCase(Right(sFRName, 3)) = ".MD" Then sFRName = Left(sFRName, Len(sFRName) - 3)
                    If Range(sFRName)(1).Address(, , , 1) = Range(sRName)(1).Address(, , , 1) Then
                        '
                        ' found a FREQUENCY() formula with the same argument as the INDEX() formula
                        ' so now erase the chart data for that column.
                        ' the base range name to be deleted should be at the top of the column that
                        ' the frequency formula was in.
                        '
                        sBaseRangeName = rFreqCell.EntireColumn(1).value
                        For Each vRangeNameSuffix In Array("_axis_lbls_", "_bins", "_cume", "_cume_data", "_freq", "_hist_data", "_lbls")
                            ActiveWorkbook.Names("PM_" & sBaseRangeName & vRangeNameSuffix).Delete
                        Next vRangeNameSuffix
                        '
                        ' save column for later deletion; if we delete it now it messes up the find
                        '
                        ' 1st check if column was just added; if so, don't add again.
                        '
                        If cRangesToDelete.Count <= 1 Then
                            cRangesToDelete.Add rFreqCell
                        ElseIf rFreqCell.EntireColumn.Address _
                            <> cRangesToDelete(cRangesToDelete.Count).EntireColumn.Address Then
                            cRangesToDelete.Add rFreqCell
                        End If
'                        If cRangesToDelete.Count > 1 Then
'                            If rFreqCell.EntireColumn.Address _
'                                <> cRangesToDelete(cRangesToDelete.Count).EntireColumn.Address Then
'                                cRangesToDelete.Add rFreqCell
'                            End If
'                        Else
'                            cRangesToDelete.Add rFreqCell
'                        End If
                    End If ' Range(sFRName).Address(, , , 1) = Range(sRName).Address(, , , 1)
                End If ' rex2.test(rFreqCell.Formula)
                If rFreqCell.HasArray Then Set rFreqCell = rFreqCell.CurrentArray(rFreqCell.CurrentArray.Count)
                sLastFreqAddress = rFreqCell.Address
                Set rFreqCell = rChartData.FindNext(rFreqCell)
            Loop Until s1stFreqAddress = rFreqCell.Address Or sLastFreqAddress = rFreqCell.Address
            If cRangesToDelete.Count > 0 Then rCell.SparklineGroups.Clear
            For Each rFreqCell In cRangesToDelete
                rFreqCell.EntireColumn.Delete Shift:=xlToLeft
            Next rFreqCell
        End If ' Not rFreqCell is Nothing
    End If ' Err = 0
End Sub

Sub deleteOutputData(rTableCell As Range)
    '
    ' I will need to handle both the "multiple outputs" case and the "multiple experiments" case
    '
    Dim numRows As Long, numCols As Long, sTableFormula As String
    With ActiveWorkbook.Sheets("PMTable")
        If .Range("c4").HasArray Then
            numRows = .Range("c4").CurrentArray.Rows.Count
            numCols = .Range("c4").CurrentArray.Columns.Count
            sTableFormula = .Range("c4").FormulaArray
            On Error Resume Next
            ActiveWorkbook.Names(rTableCell.Offset(-1, 0).Value2).Delete
            On Error GoTo 0
            .Range("c4").CurrentArray.Offset(1, 1).Resize(numRows - 1, numCols - 1).Clear
            rTableCell.EntireColumn.Delete xlToLeft
            '
            ' redo table if there are any outputs left
            '
            If numCols > 2 Then
                If sTableFormula = "=TABLE(,A1)" Then ' multiple outputs
                    .Range("B3").Resize(numRows, numCols - 1).Table _
                        ColumnInput:=.Range("A1")
                Else ' this should be the multiple experiments case
                    .Range("B3").Resize(numRows, numCols - 1).Table _
                        ColumnInput:=.Range("A1"), RowInput:=.Range("B1")
                End If
            End If
        End If
    End With
    
End Sub

Sub deleteCdfData(sRName As String)
    '
    ' sRName is the input range; look for a CDF data column that refers to this range
    ' look in the =PERCENTILE() function arguments
    '
    Dim rCdfData As Range, rPctlCell As Range
    Dim sPRName As String ' _P_ercentile _R_ange Name
    Dim s1stPctlAddress As String, sLastPctlAddress As String
    Dim cRangesToDelete As Collection
    Dim sBaseRangeName As String, vRangeNameSuffix As Variant
    
    Dim vCalcMode As Variant
    vCalcMode = Application.Calculation
    Application.Calculation = xlCalculationManual
    
    On Error Resume Next
    Err.Clear
    Set rCdfData = ActiveWorkbook.Sheets(scd).UsedRange
    If Err = 0 Then ' chart data found
        '
        ' search chart page for an =PERCENTILE() formula with an argument which is the same
        ' as the previously found argument to INDEX()
        '
        Set cRangesToDelete = New Collection
        Set rPctlCell = rCdfData(1)
#If Mac Then
        Set rPctlCell = rCdfData.Find(What:="PERCENTILE", After:=rPctlCell, _
            LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByColumns, _
            SearchDirection:=xlNext, MatchCase:=False)
#Else
        Set rPctlCell = rCdfData.Find(What:="PERCENTILE", After:=rPctlCell, _
            LookIn:=xlFormulas, LookAt:=xlPart, SearchOrder:=xlByColumns, _
            SearchDirection:=xlNext, MatchCase:=False, SearchFormat:=False)
#End If
        If Not rPctlCell Is Nothing Then
            '
            ' look through all cells found with "PERCENTILE" in the column.
            ' if one of them has a formula =PERCENTILE( <array>... ) where <array> is also
            ' the argument to =INDEX(), above, then we've presumably found a column
            ' with the chart data for the selected input
            '
            s1stPctlAddress = rPctlCell.Address
            Do
                If test_FName(rPctlCell.Formula, "PERCENTILE") Then
                    sPRName = first_arg(rPctlCell.Formula)
                    If UCase(Right(sPRName, 3)) = ".MD" Then sPRName = Left(sPRName, Len(sPRName) - 3)
                    If Range(sPRName)(1).Address(, , , 1) = Range(sRName)(1).Address(, , , 1) Then
                        '
                        ' found a PERCENTILE() formula with the same argument as the INDEX() formula
                        ' so now erase the chart data for that column.
                        ' the base range name to be deleted should be at the top of the column that
                        ' the PERCENTILE formula was in.
                        '
                        sBaseRangeName = rPctlCell.EntireColumn(1).value
                        For Each vRangeNameSuffix In Array("_cdf_X")
                            ActiveWorkbook.Names("PM_" & sBaseRangeName & vRangeNameSuffix).Delete
                        Next vRangeNameSuffix
                        '
                        ' erase the percentile formulas
                        '
                        Range(rPctlCell, rPctlCell.End(xlDown)).ClearContents
                    End If ' Range(sPRName).Address(, , , 1) = Range(sRName).Address(, , , 1)
                End If ' test_FName(rPctlCell.Formula, "PERCENTILE")
                If Not IsEmpty(rPctlCell.Offset(1, 0)) Then Set rPctlCell = rPctlCell.End(xlDown).Offset(1, 0)
                sLastPctlAddress = rPctlCell.Address
                Set rPctlCell = rCdfData.FindNext(rPctlCell)
            Loop Until s1stPctlAddress = rPctlCell.Address Or sLastPctlAddress = rPctlCell.Address
        End If ' Not rPctlCell is Nothing
    End If ' Err = 0
    Application.Calculation = vCalcMode
    
End Sub

#If PROJECT = SIPMATH_HISTOGRAM Then
#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub smh_AboutBtn()
    Call aboutBtn_Mac_body
End Sub
#Else
#If Mac Then
Public Sub smh_AboutBtn(Optional control As IRibbonControl)
    Call aboutBtn_Mac_body
End Sub
#Else
Public Sub smh_AboutBtn(Optional control As IRibbonControl)
    Call aboutBtn_Windows_body
End Sub
#End If
#End If
#Else
#If Mac And MAC_OFFICE_VERSION < 15 Then
Public Sub AboutBtn()
    Call aboutBtn_Mac_body
End Sub
#Else
#If Mac Then
Public Sub AboutBtn(Optional control As IRibbonControl)
    Call aboutBtn_Mac_body
End Sub
#Else
Public Sub AboutBtn(Optional control As IRibbonControl)
    Call aboutBtn_Windows_body
End Sub
#End If
#End If
#End If
Public Sub aboutBtn_Mac_body()
    MsgBox "SIPmath" & tmSymbol() & " " & appName & " v " & VERSION_NUMBER & vbNewLine & vbNewLine _
    & "Designed by Sam Savage and Marc Thibault" & vbNewLine & "Programmed by David Empey" _
    & vbNewLine & vbNewLine & "HDR random number generator by Hubbard Decision Research" & vbNewLine & vbNewLine _
     & "Metalog distribution by Tom Keelin" & vbNewLine & vbNewLine _
     & "Additional functions available in Enterprise version of SIPmath Tools for Windows:" & vbNewLine _
     & "     Import From|fffd| imports SIP Libraries from XML and CSV" & vbNewLine _
     & "     Export To|fffd| exports SIP Libraries to XML, CSV, or JSON" & vbNewLine _
     & "     Crystal Ball and @Risk create SIP Libraries from Crystal Ball or @Risk models" & vbNewLine & vbNewLine _
     & "Contact support@probabilitymanagement.org for more information." & vbNewLine & vbNewLine _
     & "For videos, downloads and tutorials visit probabilitymanagement.org" & vbNewLine & vbNewLine _
    & "Please support our efforts through a tax-deductible donation at 501(c)(3) non-profit ProbabilityManagement.org" & vbNewLine & vbNewLine _
        & "|fffd| Copyright 2012-2017, Probability Management Inc.", vbInformation, "About SIPmath" & tmSymbol() & " " & appName
End Sub

Public Sub aboutBtn_Windows_body()
    MsgBox "SIPmath" & tmSymbol() & " " & appName & " v " & VERSION_NUMBER & vbNewLine & vbNewLine _
    & "Designed by Sam Savage and Marc Thibault" & vbNewLine & "Programmed by David Empey" _
    & vbNewLine & vbNewLine & "HDR random number generator by Hubbard Decision Research" & vbNewLine & vbNewLine _
     & "Metalog distribution by Tom Keelin" & vbNewLine & vbNewLine _
     & "Additional functions available in Enterprise version of SIPmath Tools for Windows:" & vbNewLine _
     & "     Import From|fffd| imports SIP Libraries from XML and CSV" & vbNewLine _
     & "     Export To|fffd| exports SIP Libraries to XML, CSV, or JSON" & vbNewLine _
     & "     Crystal Ball and @Risk create SIP Libraries from Crystal Ball or @Risk models" & vbNewLine & vbNewLine _
     & "Contact support@probabilitymanagement.org for more information." & vbNewLine & vbNewLine _
     & "For videos, downloads and tutorials visit probabilitymanagement.org" & vbNewLine & vbNewLine _
    & "Please support our efforts through a tax-deductible donation at 501(c)(3) non-profit ProbabilityManagement.org" & vbNewLine & vbNewLine _
        & "|fffd| Copyright 2012-2017, Probability Management Inc.", vbInformation, "About SIPmath" & tmSymbol() & " " & appName
End Sub

Public Sub ReInitializeModel()
    UserFormResetModel.Show ' False ' false = not modal?
    chkCalcMode
End Sub

Function CheckForLibrary(newLibraryName As String) As Boolean
    Dim d As Variant, nameOnly As String
    On Error Resume Next
#If Mac Then
    d = InStrRev(newLibraryName, "/")
#Else
    d = InStrRev(newLibraryName, "\")
#End If
    nameOnly = Mid$(newLibraryName, d + 1)
    Err.Clear
    d = Workbooks(nameOnly).Names("PM_Trials").RefersTo
    If Err <> 0 Then
        MsgBox "'" & nameOnly & "' does not seem to be a library file.", vbExclamation, APP_NAME
        CheckForLibrary = False
    Else
        CheckForLibrary = True
    End If
    
End Function

Sub conformNumTrials()

    Load UserFormInitialize ' this runs the form's Initialize event
    UserFormInitialize.UserForm_Activate
    
End Sub

Function hdrCheck() As Boolean
    
    On Error Resume Next
    
    Dim PmIndex As Variant
    
    Err.Clear
    PmIndex = ActiveWorkbook.Names("PM_Index").RefersTo
    If Err <> 0 Then
        hdrCheck = (vbYes = MsgBox("The name PM_Index is not defined, which will cause #NAME? errors in " _
            & "HDR random values. (This can be fixed by initializing the model.) Do you want to proceed anyway?", vbYesNo Or vbQuestion, APP_NAME))
    Else
        hdrCheck = True
    End If

End Function

Public Sub activateWorkbook()
    On Error Resume Next
    Workbooks(g_sWorkbookName).Activate
End Sub
Attribute VB_Name = "Module3PartyApps"
Option Explicit

#If Mac Then
    '
    ' Crystal ball and @risk are not available on the Mac
    '
#Else

'Callback for thirdPartyApps getVisible
Sub get3rdPartyGroupVisible(control As IRibbonControl, ByRef returnedVal)
    ' don't Call notAvailableMsg but replace with code from version 3.4.0 for Enterprise Version
    returnedVal = True
End Sub

'Callback for CrystalBall onAction
Sub crystalBall(control As IRibbonControl)
    MsgBox "replace this msg box with Crystal Ball tie-in code"
End Sub

'Callback for CristalBall getVisible
Sub getCbVisible(control As IRibbonControl, ByRef returnedVal)
    ' don't Call notAvailableMsg but replace with code from version 3.4.0 for Enterprise Version
    returnedVal = True
End Sub

'Callback for AtRisk onAction
Sub atRisk(control As IRibbonControl)
    MsgBox "replace this msg box with @ Risk tie-in code"
End Sub

'Callback for AtRisk getVisible
Sub getArVisible(control As IRibbonControl, ByRef returnedVal)
    ' don't Call notAvailableMsg but replace with code from version 3.4.0 for Enterprise Version
    returnedVal = True
End Sub

#End If

Attribute VB_Name = "ModuleCopyPasteFormulas"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit

Public copiedCell As Range
Const AN_ As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"

#If Mac Then
Public Sub copySIPmathFormula()
#Else
Public Sub copySIPmathFormula(Optional control As IRibbonControl)
#End If

    '
    ' copies current active cell to a global variable
    '
    Set copiedCell = ActiveCell
    ActiveCell.Copy
    
End Sub

#If Mac Then
Sub pasteSIPmathFormula()
#Else
Sub pasteSIPmathFormula(Optional control As IRibbonControl)
#End If

    '
    ' paste the copied formula, changing any SIPmath output range names as implied by
    ' relative position of pasted cell and original cell
    '
    
    Dim sFmla As String, sIdent As String, sC As String, sReplace As String
    
If copiedCell Is Nothing Then Exit Sub
    
    sFmla = copiedCell.Formula
    
    Dim output As Variant, outputCell As Range
    Dim destRange As Range, destCell As Range, offsetOutputCell As Range, pmTableCell As Range
    Dim rDif As Long, cDif As Long
    Dim subOutputName As String
    
    Dim nC As Long ' character index value
    Dim nL As Long ' length
    Dim nSAN As Long ' start index of alphanumeric substring within string
    Dim nLAN As Long ' length of alphanumeric substring
    Dim sId As String ' identifier string; possible name of output
    
    nL = Len(sFmla)
    For nC = 1 To nL
        nLAN = 1
        If 0 <> InStr(AN_, Mid(sFmla, nC, 1)) Then ' if character nC is alphanumeric
            '
            ' found an alphanumeric string, so find how long it is
            '
            Do Until nC + nLAN >= nL Or 0 = InStr(AN_, Mid(sFmla, nC + nLAN, 1))
                nLAN = nLAN + 1
            Loop
            sId = Trim(Mid(sFmla, nC, nLAN))
            '
            ' sId is the possible output name; see if it really is one
            '
            ' it must be a defined name, and the range must be a single column on
            ' PMTable, starting in row 2 or more
            '
            On Error Resume Next
            Err.Clear
            Set output = ActiveWorkbook.Names(sId)
            If Err = 0 Then
                If (output.RefersToRange.Parent.Name <> "PMTable") Then GoTo Iterate
                If (output.RefersToRange.row <= 1) Then GoTo Iterate
                If (output.RefersToRange.Columns.Count <> 1) Then GoTo Iterate
                On Error GoTo 0
                GoTo Continue
            End If ' Err = 0
Iterate:
            Err.Clear
            On Error GoTo 0
        End If ' if character nC is alphanumeric
        nC = nC + nLAN - 1
    Next nC
    '
    ' getting to here by exiting the loop means we didn't find any output range names,
    ' so might as well quit
    '
Exit Sub
Continue:
    '
    ' if we get here, sId should match an output name defined on PMTable, hopefully.
    ' the cell above the range should refer to an output cell. The cell's formula should be,
    ' .e.g., "=Sheet1!$B$2", Sheet1!$B$2 being the output cell.
    ' Using Evaluate() on that formula text should return a ref to the otuput cell.
    '
    On Error Resume Next ' ... but it might not
    Err.Clear
    Set outputCell = Application.Evaluate(output.RefersToRange.Offset(-1, 0).Resize(1, 1).Formula)
    If Err <> 0 Then Exit Sub ' ... and if not, quit
    On Error GoTo 0
    
    On Error Resume Next
    Err.Clear
    Set destRange = Selection
    If Err <> 0 Then Exit Sub
    Err.Clear
    On Error GoTo 0
    For Each destCell In destRange
        '
        ' find row and column difference from original copied cell to destCell
        '
        rDif = destCell.row - copiedCell.row
        cDif = destCell.Column - copiedCell.Column
        Set offsetOutputCell = outputCell.Offset(rDif, cDif)
        '
        ' somewhere on PMTable row 3 should be a reference to the offsetOutputCell. Find it.
        '
        Set pmTableCell = ActiveWorkbook.Sheets("PMTable").Range("C3")
        Do
            If offsetOutputCell.Address(, , , 1) = Application.Evaluate(pmTableCell.Formula).Address(, , , 1) Then Exit Do
            Set pmTableCell = pmTableCell.Offset(0, 1)
        Loop Until IsEmpty(pmTableCell)
        If Not IsEmpty(pmTableCell) Then
            '
            ' now at last we can copy the formula with the output range replaced with the correct offset range
            '
            subOutputName = pmTableCell.Offset(-1, 0).value
            sReplace = Replace(sFmla, output.Name, subOutputName)
            destCell.Formula = sReplace
        End If
    Next destCell
    
End Sub

#If Mac And MAC_OFFICE_VERSION < 15 Then
Sub convertReference()
    Call convertReferenceBody
End Sub
#Else
Sub convertReference(Optional control As IRibbonControl)
    Call convertReferenceBody
End Sub
#End If
Sub convertReferenceBody()
'
' try to find references to output cells and convert them to references to the ranges than
' tabulate the simulated output values
'
' I will look for strings delimited by "=" "(" "," ")" "+" "-" "*" "/" "^"
'
    Dim lastCalcMode As Variant
    lastCalcMode = Application.Calculation
    Application.Calculation = xlCalculationManual
    
    Dim sFmla As String, fCell As Range, pmTableCell As Range, subOutputName As String
    Dim sReplace As String, sCell As Range, bCellFound As Boolean
    
    Dim numCells As Long
    
    Dim nC As Long ' character index value
    Dim nL As Long ' length
    Dim nSCR As Long ' start index of possible cell reference
    Dim nLCR As Long ' length of cell reference substring
    Dim sCR As String ' possible cell reference string
    
    Dim nSS As Long ' Sip Start
    Dim nSE As Long ' Sip End
    Dim sISN As String ' Input Sip Name
    Dim sTrimFmla As String '
    
    Dim sPattern As String
    
    Dim sSparkSource As String, rSparkRange As Range, rFreqCell As Range
    'dim rex As Object
    Dim sReplaceName As String
    
    bCellFound = False
    On Error Resume Next
    If TypeName(Selection) <> TypeName(Range("A1")) Then
        UserFormInstructions.Show
        Application.Calculation = lastCalcMode
        Exit Sub
    End If
    On Error GoTo 0
    For Each sCell In Selection
        sFmla = sCell.Formula
        
        sPattern = "=*()+/,"
        ' punctuation marks; but not - or ' since they might be part of a cell reference
        '
        ' try to find a cell reference
        '
        nL = Len(sFmla)
        nC = 1
        Do Until nC > nL
            nLCR = 1
            If 0 = InStr(sPattern, Mid(sFmla, nC, 1)) Then ' character is not punctuation mark
                '
                ' find the length of the string of non-punctuation
                '
                Do Until nC + nLCR >= nL Or 0 <> InStr(sPattern, Mid(sFmla, nC + nLCR, 1))
                    nLCR = nLCR + 1
                Loop
                sCR = Trim(Mid(sFmla, nC, nLCR))
                On Error Resume Next
                numCells = 0
                numCells = Application.Evaluate(sCR).Cells.Count
                If numCells = 1 Then  ' ouput cells are single cells only
                    '
                    ' we found a ref to a single cell
                    ' now look for a PMTable column that refers to it
                    '
                    Err.Clear
                    On Error GoTo 0
                    '
                    ' somewhere on PMTable row 3 should be a reference to the cell identified
                    ' by sCR. Find it.
                    '
                    Set fCell = Application.Evaluate(sCR)
                    Set pmTableCell = ActiveWorkbook.Sheets("PMTable").Range("C3")
                    Do Until IsEmpty(pmTableCell)
                        If fCell.Address(, , , 1) = Application.Evaluate(pmTableCell.Formula).Address(, , , 1) Then Exit Do
                        Set pmTableCell = pmTableCell.Offset(0, 1)
                    Loop
                    If Not IsEmpty(pmTableCell) Then
                        '
                        ' now at last we can copy the formula with the output range replaced with the correct offset range
                        '
                        bCellFound = True
                        subOutputName = pmTableCell.Offset(-1, 0).value
                        sReplace = Replace(sFmla, Trim(sCR), subOutputName)
                        Err.Clear
                        sCell.Formula = sReplace
                        If Err = 0 Then
                            sFmla = sCell.Formula
                            nL = Len(sFmla)
                            nLCR = Len(subOutputName)
                        End If
                        On Error GoTo 0
                        'Exit For
                        GoTo Next_nC
                    Else
                        '
                        ' see if the cell formula is the formula for an Input SIP
                        '
                        ' you might either have an external SIP, with a formula something like
                        ' =INDEX( 'some file.xlsx'!SIPname, ...
                        '
                        ' or an internal SIP, with a formula like
                        ' =INDEX( SIPname, ...
                        '
                        sTrimFmla = fCell.Formula
                        If Left(sTrimFmla, 7) = "=INDEX(" Then
                            nSS = 8
                            nSE = InStr(nSS, sTrimFmla, ",")
                            If nSE = 0 Or InStr(nSS, sTrimFmla, ")") < nSE Then nSE = InStr(nSS, sTrimFmla, ")")
                            sISN = Trim(Mid(sTrimFmla, nSS, nSE - nSS))
                            If Right(sISN, 3) = ".MD" Then sISN = Left(sISN, Len(sISN) - 3)
                            If sISN <> "" Then
                                '
                                ' hopefully sISN is an input sip name, so let's try and see
                                '
                                On Error Resume Next
                                Err.Clear
                                bCellFound = True
                                sReplace = Replace(sFmla, Trim(sCR), sISN)
                                If Err = 0 Then
                                    sCell.Formula = sReplace
                                    If Err = 0 Then
                                        sFmla = sCell.Formula
                                        nL = Len(sFmla)
                                        nLCR = Len(sISN)
                                    End If
                                    On Error GoTo 0
                                    GoTo Next_nC
                                    'Exit For
                                End If
                                On Error GoTo 0
                            End If
                        End If
                    End If ' Not IsEmpty(pmTableCell)
                    '
                    ' if we get to here, then we didn't find an output cell or input sip
                    ' so try looking at sparkline source data
                    '
                    On Error Resume Next
                    sSparkSource = ""
                    sSparkSource = Range(sCR).SparklineGroups.Item(1).Item(1).SourceData
                    '
                    ' we find the =FREQUENCY() call in the sparklines column of the SIPmath Chart Data
                    ' page, and look at the 1st argument, to find the range name to replace the cell
                    ' reference. So first, find the actual range from the source string
                    '
                    Err.Clear
                    Set rSparkRange = Range(sSparkSource)
                    If Err = 0 Then
#If Mac Then
                        Set rFreqCell = rSparkRange.EntireColumn.Find( _
                            What:="FREQUENCY(", After:=rSparkRange(1), LookIn:=xlFormulas, _
                            LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
                            MatchCase:=True)
#Else
                        Set rFreqCell = rSparkRange.EntireColumn.Find( _
                            What:="FREQUENCY(", After:=rSparkRange(1), LookIn:=xlFormulas, _
                            LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
                            MatchCase:=True, SearchFormat:=False)
#End If
                        ''
                        '' regular expression pattern to find 1st argument of =FREQUENCY()
                        ''
                        'Set rex = CreateObject("VBScript.RegExp")
                        'With rex
                        '    .Global = True
                        '    .MultiLine = True
                        '    .IgnoreCase = True
                        '    .Pattern = "^=\s*FREQUENCY\(\s*(\S[^,]*),.*"
                        'End With
                        'If rex.test(rFreqCell.Formula) Then
                        If test_FName(rFreqCell.Formula, "FREQUENCY") Then
                            'sReplaceName = rex.Replace(rFreqCell.Formula, "$1")
                            sReplaceName = first_arg(rFreqCell.Formula)
                            '
                            ' sReplaceName should now be the 1st arg to the FREQUENCY() formula
                            ' and is hopefully the name of the input or output data range
                            ' with which we should replce the cell reference
                            ' so let's try it
                            '
                            bCellFound = True
                            Err.Clear
                            sReplace = Replace(sFmla, Trim(sCR), sReplaceName)
                            If Err = 0 Then
                                sCell.Formula = sReplace
                                If Err = 0 Then
                                    sFmla = sCell.Formula
                                    nL = Len(sFmla)
                                    nLCR = Len(sReplaceName)
                                End If
                                On Error GoTo 0
                                'Exit For
                                GoTo Next_nC
                            End If
                            On Error GoTo 0
                        End If
                    End If ' Err = 0 ' found a valid sparkline source
                End If ' numCells = 1
                Err.Clear
                On Error GoTo 0
            End If ' character is not punctuation mark
Next_nC:
            nC = nC + nLCR
        Loop
    Next sCell
    If Not bCellFound Then UserFormInstructions.Show
    Application.Calculation = lastCalcMode
    chkCalcMode
    
End Sub
Attribute VB_Name = "ModuleExportSlurp"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit
    
'
' prefix g_ for Global vars
'
Public g_vOutputList As Variant
Public g_vMetadataList As Variant

Public g_sSlurpName As String
Public g_sSlurpOrigin As String
Public g_sLibProvenance As String
Public g_sLibName As String

Public g_bCancel As Boolean

Public g_sExistingLibName As String
Public g_bAddToExistingLib As Boolean

Sub notAvailableMsg()
    MsgBox "This feature is available in the Enterprise version of the SIPmath Tools for Windows." & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information.", vbInformation, APP_NAME
End Sub
'
' exports the PM Table as an Excel-format slurp library
' user can define a table of metadata to add to the end of the PM_Table
'
'Callback for exportLib onAction
#If Mac And MAC_OFFICE_VERSION < 15 Then
Sub saveResultsAsSipLib()

#Else
Sub saveResultsAsSipLib(Optional control As IRibbonControl)
#End If
    '
    ' I will put the SLURP lib in a new Workbook.
    '
    Dim modelBook As Workbook
    Dim slurpBook As Workbook
    Dim slurpSheet As Worksheet
    Dim metadataRange As Range
    Dim nNumMetadataOutputs As Long
    Dim nNumPMTableColumns As Long
    
    Set metadataRange = Selection
    Set modelBook = ActiveWorkbook
    
    On Error Resume Next
    '
    ' test if there's a PMTable sheet
    '
    Dim rCheckRange
    Err.Clear
    Set rCheckRange = ActiveWorkbook.Sheets("PMTable").Range("A1")
    If Err <> 0 Then
        MsgBox "The active workbook does not seem to be a SIPmath model.", vbInformation, APP_NAME
        Exit Sub
    End If
    '
    ' active sheet is possibly a Model so get a list of outputs to be exported
    '
    UserFormSelectOutputs.Show
    If VarType(g_vOutputList) = vbBoolean Then Exit Sub
    '
    ' g_vOutputList should now have a list of output name ranges
    '
    If g_bAddToExistingLib Then
        On Error Resume Next
        Set slurpBook = Workbooks.Open(g_sExistingLibName)
        If Err <> 0 Then
            MsgBox "Could not open file " & g_sExistingLibName, vbExclamation, APP_NAME
            Exit Sub
        End If
    Else
        '
        ' make new book
        '
        Set slurpBook = Workbooks.Add
        '
        ' add PM_Trials
        '
        Set slurpSheet = slurpBook.Sheets(1)
        With slurpSheet
            .Cells(1, 1) = "PM_Trials"
            modelBook.Activate
            .Cells(1, 2) = [=PM_Trials]
            slurpBook.Names.Add "PM_Trials", .Cells(1, 2)
            slurpBook.Activate
        End With
    End If
    '
    ' copy PMtable to new book
    '
    ' I will now copy the outputs named in g_vOutputList to the export SLURP page
    '
    Dim vSipName As Variant
    Dim nSipNum As Long
    Dim nUsedOutputNdx As Long, nNumExistingOutputs As Long
    
    If g_bAddToExistingLib Then
        ' look for SIPtlc
        Dim rTest As Range
        On Error Resume Next
        Err.Clear
        Set rTest = slurpBook.Names("PM_SIPtlc").RefersToRange
        If Err <> 0 Then
            MsgBox "The file " & g_sExistingLibName & " does not have a PM_SIPtlc range.", vbExclamation, APP_NAME
            Application.DisplayAlerts = False
            Workbooks(g_sExistingLibName).Close
            Application.DisplayAlerts = True
            Exit Sub
        End If
        Set slurpSheet = slurpBook.Names("PM_SIPtlc").RefersToRange.Parent
    End If
    With modelBook.Sheets("PMTable")
        If g_bAddToExistingLib Then
            If IsEmpty(slurpSheet.Range("PM_SIPtlc").Offset(0, 1)) Then
                nNumExistingOutputs = 1
            Else
                nNumExistingOutputs = Range(slurpSheet.Range("PM_SIPtlc"), slurpSheet.Range("PM_SIPtlc").End(xlToRight)).Columns.Count
            End If
        Else
            nUsedOutputNdx = 0
        End If
        For Each vSipName In g_vOutputList
            If vSipName <> "" Then
                nUsedOutputNdx = nUsedOutputNdx + 1
                If g_bAddToExistingLib Then
                    slurpSheet.Range("PM_SIPtlc").Offset(-1, nUsedOutputNdx + nNumExistingOutputs - 1) = vSipName
                    slurpSheet.Range("PM_SIPtlc").Offset(0, nUsedOutputNdx + nNumExistingOutputs - 1).Resize([=PM_Trials], 1).value _
                        = .Range(vSipName).Value2
                Else
                    slurpSheet.Range("B3").Offset(0, nUsedOutputNdx) = vSipName
                    slurpSheet.Range("B4").Offset(0, nUsedOutputNdx).Resize([=PM_Trials], 1).value _
                        = .Range(vSipName).Value2
                End If
            End If
        Next vSipName
    End With
    '
    ' put in the trial index numbers
    '
    Dim aNdxTbl As Variant
    Dim nTrialNdx As Long
    
    If Not g_bAddToExistingLib Then
        aNdxTbl = Split("", ",")
        ReDim aNdxTbl(1 To [=PM_Trials], 1 To 1) As Long
        For nTrialNdx = 1 To [=PM_Trials]
            aNdxTbl(nTrialNdx, 1) = nTrialNdx
        Next nTrialNdx
        slurpSheet.Range("B4").Resize([=PM_Trials], 1).value = aNdxTbl
        '
        ' these names will be used by the saveResultsToXml sub
        '
        slurpBook.Names.Add "PM_SIPtlc", slurpSheet.Range("C4")
        slurpBook.Names.Add "PM_SIPkeys", slurpSheet.Range("B4").Offset([=PM_Trials], 0)
        slurpBook.Names.Add "PM_SIPvalues", slurpSheet.Range("C4").Offset([=PM_Trials], 0)
    End If
    '
    ' Now do the metadata
    '
    ' I will assume the metadata is just below the data table on the PMTable sheet.
    ' UserFormSelectOutputs should have set up g_vMetadataList() as needed for this to work.
    '
'''    ' I will assume that the user selected a range containing rows or columns of metadata,
'''    ' not necessarily all of which will be used, but that if they are used, they are arranged
'''    ' in the same order as in PMTable
'''    '
'''    ' I just need to find out which rows or columns are to be used
'''    ' ... which hopefully was done by UserFormSelectOutputs; the range names should now be in
'''    ' the array g_vMetadataList()
'''    '

    On Error GoTo wrong_number_of_metadata_outputs
    
    Dim nOutputNdx As Long
    Dim orientation As String
    Dim nMetadataNdx As Long
    Dim metadataA As Variant
    Dim metadataT As Variant ' transpose of above
    Dim nNumMetadata As Long
    Dim sSipName As String
    Dim rSipRange As Range
    Dim vMetadatumRow As Variant
    Dim nSNdx As Long 'index of char in a char string
    Dim sMName As String ' metadata name
    '
    ' fill in an array with the metadata and then assign it to a cell range all at once
    '
    On Error GoTo 0
    nNumMetadata = UBound(g_vMetadataList)
    If nNumMetadata < 0 Then nNumMetadata = 0
    With slurpSheet
        If nNumMetadata > 0 Then
            If g_bAddToExistingLib Then
                ReDim metadataA(1 To nNumMetadata, 1 To UBound(g_vOutputList))
            Else
                ReDim metadataA(1 To nNumMetadata, 0 To UBound(g_vOutputList))
            End If
            For nMetadataNdx = 1 To nNumMetadata
                vMetadatumRow = Application.Evaluate(g_vMetadataList(nMetadataNdx))
                If Not g_bAddToExistingLib Then metadataA(nMetadataNdx, 0) = vMetadatumRow(1, 1)
                nUsedOutputNdx = 0
                For nOutputNdx = 1 To UBound(g_vOutputList)
                    If g_vOutputList(nOutputNdx) <> "" Then
                        nUsedOutputNdx = nUsedOutputNdx + 1
                        If UBound(vMetadatumRow) > 1 Then
                            metadataA(nMetadataNdx, nUsedOutputNdx) = vMetadatumRow(nOutputNdx + 1, 1)
                        Else
                            metadataA(nMetadataNdx, nUsedOutputNdx) = vMetadatumRow(1, nOutputNdx + 1)
                        End If
                    End If
                Next nOutputNdx
            Next nMetadataNdx
            If g_bAddToExistingLib Then
                .Range("PM_SIPvalues").Offset(0, nNumExistingOutputs).Resize(nNumMetadata, UBound(g_vOutputList)) = metadataA
            Else
                .Range("B4").Offset(.Range("PM_Trials").Value2, 0).Resize(nNumMetadata, 1 + UBound(g_vOutputList)) = metadataA
            End If
        End If
        '
        ' define SIP ranges and SIP .MD ranges
        '
        nUsedOutputNdx = 0
        For nOutputNdx = 1 To UBound(g_vOutputList)
            sSipName = g_vOutputList(nOutputNdx)
            If sSipName <> "" Then
                nUsedOutputNdx = nUsedOutputNdx + 1
                If g_bAddToExistingLib Then
                    Set rSipRange = .Range("PM_SIPtlc").Offset(0, nUsedOutputNdx + nNumExistingOutputs - 1).Resize(.Range("PM_Trials").Value2, 1)
                Else
                    Set rSipRange = .Range("B4").Offset(0, nUsedOutputNdx).Resize(.Range("PM_Trials").Value2, 1)
                End If
                slurpBook.Names.Add sSipName, rSipRange
                slurpBook.Names.Add sSipName & ".MD", _
                    rSipRange.Resize(.Range("PM_Trials").Value2 + nNumMetadata, 1)
            End If
        Next nOutputNdx
        If Not g_bAddToExistingLib Then
            '
            ' group SIP data rows with +/- button
            '
            .Range("B4").Resize(.Range("PM_Trials").Value2, 1).EntireRow.Group
            .Range("B4").Resize(.Range("PM_Trials").Value2, 1).EntireRow.Hidden = True
            '
            ' define PM_Meta_Index table
            '
            ' insert rows to make space for the pm_meta_index table
            '
            .Rows(3).Resize(nNumMetadata + 2).Insert
            .Range("D3").value = "Meta Data"
            .Range("E3").value = "Index"
            If nNumMetadata > 0 Then
                .Range("D4").Resize(nNumMetadata).value _
                    = .Range("B4").Offset(.Range("PM_Trials").Value2 + nNumMetadata + 2) _
                        .Resize(nNumMetadata).Value2
                ReDim aNdxTbl(1 To nNumMetadata, 1 To 1)
                For nMetadataNdx = 1 To nNumMetadata
                    aNdxTbl(nMetadataNdx, 1) = .Range("PM_Trials").Value2 + nMetadataNdx
                Next nMetadataNdx
                .Range("E4").Resize(nNumMetadata).value = aNdxTbl
                slurpBook.Names.Add "PM_Meta", .Range("D4").Resize(nNumMetadata)
                slurpBook.Names.Add "PM_Meta_Index", .Range("E4").Resize(nNumMetadata)
            End If
            .Rows(2).Insert
            .Cells(2, 1) = "PM_Lib_Provenance"
            .Cells(2, 2) = g_sLibProvenance
            slurpBook.Names.Add "PM_Lib_Provenance", .Cells(2, 2)
            On Error Resume Next
            .Name = g_sLibName
            On Error GoTo 0
            .Range("PM_SIPtlc").Offset(-2, -2).Value2 = "Click [+] to show data"
        End If
    End With ' slurpSheet
    chkCalcMode
    
Exit Sub

wrong_number_of_metadata_outputs:
    MsgBox "The number of metadata outputs is different from the number of outputs on PMTable", vbInformation, APP_NAME
    chkCalcMode
Exit Sub

End Sub

'
' dike out the following until I sort out the problem with XML and Scripting
'
' references that need to be removed or replaced are:
' Microsoft Scripting Runtime
' Microsoft XML, v3.0
'
' anyway, these aren't even used in the current SIPmath tools (2.4.6.x)
'
'''#If Mac And MAC_OFFICE_VERSION < 15 Then
'''Sub saveResultsToXml()
'''#Else
'''#End If
#If Not Mac Then
Sub disabledExportMsg(Optional control As IRibbonControl)
    MsgBox "Exports SIP Libraries to XML, CSV, or JSON. Available in the Enterprise version of the SIPmath Tools for Windows." & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information", vbInformation, APP_NAME
End Sub

Sub saveResultsToXml(Optional control As IRibbonControl)
    Call notAvailableMsg
End Sub

#End If

#If Mac And MAC_OFFICE_VERSION < 15 Then
Sub saveResultsToCsv()
#Else
#End If
#If Not Mac Then
Sub saveResultsToCsv(Optional control As IRibbonControl)
    Call notAvailableMsg
End Sub

#End If

#If Mac And MAC_OFFICE_VERSION < 15 Then
Sub saveResultsToJson()
    Call saveResultsToJson_body
End Sub
#Else
#End If
#If Not Mac Then
Sub saveResultsToJson(Optional control As IRibbonControl)
    Call saveResultsToJson_body
End Sub
#End If

#If Mac And MAC_OFFICE_VERSION < 15 Then
Sub saveResultsToJsonClipboard()
    Call saveResultsToJson_body(bSaveToFile:=False)
End Sub
#Else
#End If
#If Not Mac Then
Sub saveResultsToJsonClipboard(Optional control As IRibbonControl)
    Call saveResultsToJson_body(bSaveToFile:=False)
End Sub
#End If

Sub saveResultsToJson_body(Optional bSaveToFile As Boolean = True)
    Call notAvailableMsg
End Sub
Attribute VB_Name = "ModuleFormFix"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit

Sub test()
    Dim af As Object
    Set af = ThisWorkbook.VBProject.VBComponents("UserFormInsertDistribution").Designer
    Debug.Print af.Width
End Sub

'''Sub addDollarButton()
'''
'''    Dim newDollarButton As MSForms.CommandButton
'''    Dim aForm As VBComponent, anotherForm As Object
'''    Dim sFormNames As Variant, formName As Variant, aControl As control
'''
'''    sFormNames = Array( _
'''        "UserFormInsertBinom", _
'''        "UserFormInsertChiSquare", _
'''        "UserFormInsertExponential", _
'''        "UserFormInsertF", _
'''        "UserFormInsertGamma", _
'''        "UserFormInsertLognormal", _
'''        "UserFormInsertMultiNormal", _
'''        "UserFormInsertMultiUniform", _
'''        "UserFormInsertMyerson", _
'''        "UserFormInsertNormal", _
'''        "UserFormInsertPoisson", _
'''        "UserFormInsertResample", _
'''        "UserFormInsertT", _
'''        "UserFormInsertTriang", _
'''        "UserFormInsertUniform", _
'''        "UserFormInsertWeibull" _
'''        )
'''    On Error Resume Next
'''    Dim sCaption As String
'''    For Each formName In sFormNames
'''        Set aForm = ThisWorkbook.VBProject.VBComponents(formName)
'''        For Each aControl In aForm.Designer.Controls
'''            sCaption = ""
'''            sCaption = aControl.Caption
'''            Err.Clear
'''            If sCaption = "$" Then aControl.Name = "CommandButtonF4"
'''        Next aControl
''''        Set newDollarButton = aForm.Designer.Controls.Add("forms.CommandButton.1")
''''        With newDollarButton
''''            .Height = 24
''''            .Left = 306
''''            .Top = 6
''''            .Width = 18
''''            .Caption = "$"
''''        End With
''''        For Each aControl In aForm.Designer.Controls
''''            If Left(aControl.Name, 7) = "RefEdit" Then
''''                If formName = "UserFormInsertLognormal" Then
''''                    aControl.Width = 174
''''                Else
''''                    aControl.Width = 204
''''                End If
''''            End If
''''        Next aControl
'''    Next formName
'''
'''End Sub
'''
'Sub fixDistForms()
'
'    Dim newCheckBox As MSForms.CheckBox
'    Dim aForm As VBComponent
'    Dim formsArray As Variant, formName As Variant
'    formsArray = Array("UserFormInsertLognormal", "UserFormInsertT", "UserFormInsertF", "UserFormInsertExponential", "UserFormInsertBinom", "UserFormInsertNormal", "UserFormInsertChiSquare", "UserFormInsertGamma")
'    For Each formName In formsArray
'        Set aForm = ThisWorkbook.VBProject.VBComponents(formName)
''    For Each aForm In ThisWorkbook.VBProject.VBComponents
'        Set newCheckBox = aForm.Designer.Controls.Add("forms.CheckBox.1")
'        With newCheckBox
'            .Top = 102
'            .Left = 77
'            .Width = 95
'            .Caption = "External Random Cell"
'            .Name = "CheckBoxUseExternalRandom"
'        End With
'        aForm.Designer.Controls("Label4").Name = "LabelRandomValueCell"
'        aForm.Designer.Controls("LabelRandomValueCell").Visible = False
'        aForm.Designer.Controls("LabelRandomValueCell").Caption = "Random Cell"
'        aForm.Designer.Controls("RefEditRandCell").Visible = False
'        aForm.Designer.Controls("RefEditRandCell").Enabled = False
'        aForm.Designer.Controls("OptionButtonUserRNG").Visible = False
'    Next formName
'
'End Sub

'''Sub MakeUserForm()
'''
'''    Dim MyUserForm As VBComponent
'''    Dim NewOptionButton As MSForms.OptionButton
'''    Dim NewCommandButton1 As MSForms.CommandButton
'''    Dim NewCommandButton2 As MSForms.CommandButton
'''    Dim MyComboBox As MSForms.ComboBox
'''    Dim N, X As Integer, MaxWidth As Long
'''
'''     '//First, check the form doesn't already exist
'''    For N = 1 To ActiveWorkbook.VBProject.VBComponents.Count
'''        If ActiveWorkbook.VBProject.VBComponents(N).Name = "NewForm" Then
'''            ShowForm
'''            Exit Sub
'''        Else
'''        End If
'''    Next N
'''
'''     '//Make a userform
'''    Set MyUserForm = ActiveWorkbook.VBProject _
'''    .VBComponents.Add(vbext_ct_MSForm)
'''    With MyUserForm
'''        .Properties("Height") = 100
'''        .Properties("Width") = 200
'''        On Error Resume Next
'''        .Name = "NewForm"
'''        .Properties("Caption") = "Here is your user form"
'''    End With
'''
'''     '//Add a Cancel button to the form
'''    Set NewCommandButton1 = MyUserForm.Designer.Controls.Add("forms.CommandButton.1")
'''    With NewCommandButton1
'''        .Caption = "Cancel"
'''        .Height = 18
'''        .Width = 44
'''        .Left = MaxWidth + 147
'''        .Top = 6
'''    End With
'''
'''     '//Add an OK button to the form
'''    Set NewCommandButton2 = MyUserForm.Designer.Controls.Add("forms.CommandButton.1")
'''    With NewCommandButton2
'''        .Caption = "OK"
'''        .Height = 18
'''        .Width = 44
'''        .Left = MaxWidth + 147
'''        .Top = 28
'''    End With
'''
'''     '//Add code on the form for the CommandButtons
'''    With MyUserForm.CodeModule
'''        X = .CountOfLines
'''        .InsertLines X + 1, "Sub CommandButton1_Click()"
'''        .InsertLines X + 2, "    Unload Me"
'''        .InsertLines X + 3, "End Sub"
'''        .InsertLines X + 4, ""
'''        .InsertLines X + 5, "Sub CommandButton2_Click()"
'''        .InsertLines X + 6, "    Unload Me"
'''        .InsertLines X + 7, "End Sub"
'''    End With
'''
'''     '//Add a combo box on the form
'''    Set MyComboBox = MyUserForm.Designer.Controls.Add("Forms.ComboBox.1")
'''    With MyComboBox
'''        .Name = "Combo1"
'''        .Left = 10
'''        .Top = 10
'''        .Height = 16
'''        .Width = 100
'''    End With
'''
'''    ShowForm
'''End Sub
'''
'''Sub ShowForm()
'''    NewForm.Show
'''End Sub
'''


Attribute VB_Name = "ModuleGraphs"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit

#If PROJECT = SIPMATH_HISTOGRAM Then
    Public Const APP_NAME = "SIPmath Histogram"
    Public Const scd = "SIPmath Chart Data"
#ElseIf PROJECT = SIPMATH_TOOLS Then
    Public Const APP_NAME = "SIPmath Modeler Tools " & VERSION_NUMBER ' "SIPmath Modeler Tools 3.4.6"
    Public Const scd = "SIPmath Chart Data"
#Else
    Public Const APP_NAME = "SIPmaker"
    Public Const scd = "SIPmaker Chart Data"
#End If

'Public Const cdfn = "SIPmath CDF Data"
Public Const SCHLD = "SIPmath Cholesky Decomposition"

Const ALPHABETICAL_CHARS As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
Const NUMERIC_CHARS As String = "0123456789"

Public g_MaxBins As Long
Public g_DfltBins As Long

Public ufscdlReturn As Long

'#If PROJECT = SIPMATH_HISTOGRAM Then
'
'Sub smh_getOutputNameAndRange(outputCell As Range, outputName As Variant, outputRange As Range)
'
'#ElseIf PROJECT = SIPMATH_TOOLS Then
'
Sub smmt_getOutputNameAndRange(outputCell As Range, outputName As Variant, outputRange As Range)
'
'#Else
'
'Sub smkr_getOutputNameAndRange(outputCell As Range, outputName As Variant, outputRange As Range)
'
'#End If

    Dim tableCell As Range
    Dim sheetName As String
    Dim tf As String ' table cell formula
    
    On Error GoTo UFG_gONAR_could_not_find_output_cell
    If TypeName(outputCell.value) = TypeName("this is a string") _
    Then
        ' assume outputCell contains the name of the output range
        outputName = outputCell.value
        Set outputRange = Range(outputName)
    Else ' assume outputCell is the formula of the output, so look for its cell reference on the PMTable sheet
        Set tableCell = ActiveWorkbook.Sheets("PMTable").Range("C3")
        Do
            tf = tableCell.Formula
            ' check if A1 coords of table cell match those of the outputcell
            If Mid$(tf, 1 + InStr(1, tf, "!", vbTextCompare)) _
                = outputCell.Address(1, 1) Then
                '
                ' check if sheets match
                ' need to check both with and without '' around the sheet name
                ' since I don't know if the name will have '' around it.
                '
                sheetName = Mid$(tf, 2, -2 + InStr(tf, "!"))
                If sheetName = outputCell.Parent.Name _
                    Or sheetName = "'" & outputCell.Parent.Name & "'" Then Exit Do
            End If
            If tableCell.Column > 16382 Then
                Set tableCell = Nothing
                Exit Do
    '   note: exit do
            Else
                Set tableCell = tableCell.Offset(0, 1)
            End If
        Loop
        If Not tableCell Is Nothing Then
            outputName = tableCell.Offset(-1, 0).value
            Set outputRange = Range(outputName)
        Else
            Err.Raise 513, "UserFormGraphs.getOutputNameAndRange()", "Could not find output cell matching the formula"
        End If
    End If
    Exit Sub
    
UFG_gONAR_could_not_find_output_cell:
    Err.Raise 513, "UserFormGraphs.getOutputNameAndRange()", "Could not find output cell matching the formula"
    Exit Sub
    
End Sub

'''#If PROJECT = SIPMATH_HISTOGRAM Then
'''
'''Public Sub smh_UserFormGraphs_CommandButtonOK_Click( _
'''    sGraphRanges As String, numBins As Long, bExcelChart As Boolean, bSparkline As Boolean, _
'''    bColumn As Boolean, bRow As Boolean, bChartSelectedData As Boolean, bDataIsAColumn As Boolean, _
'''    bChartSIPmathOutput As Boolean, bDataNamesInHeadings As Boolean, sFrequencyDest As String, _
'''    sCumulativeDest As String, _
'''    oCallingForm As Object, bIntegerChart As Boolean, _
'''    Optional rDefaultChartDataLocation As Range = Nothing, _
'''    Optional sSparklineType As String = "", Optional vaOutputNames, _
'''    Optional bUseCollection As Boolean = False, Optional cRangeCollection As Collection)
'''
'''#ElseIf PROJECT = SIPMATH_TOOLS Then
'''
Public Sub smmt_UserFormGraphs_CommandButtonOK_Click( _
    sGraphRanges As String, numBins As Long, bExcelChart As Boolean, bSparkline As Boolean, _
    bColumn As Boolean, bRow As Boolean, bChartSelectedData As Boolean, bDataIsAColumn As Boolean, _
    bChartSIPmathOutput As Boolean, bDataNamesInHeadings As Boolean, sFrequencyDest As String, _
    sCumulativeDest As String, _
    oCallingForm As Object, bIntegerChart As Boolean, _
    Optional rDefaultChartDataLocation As Range = Nothing, _
    Optional sSparklineType As String = "", Optional vaOutputNames, _
    Optional bUseCollection As Boolean = False, Optional cRangeCollection As Collection)

'''#Else
'''
'''Public Sub smkr_UserFormGraphs_CommandButtonOK_Click( _
'''    sGraphRanges As String, numBins As Long, bExcelChart As Boolean, bSparkline As Boolean, _
'''    bColumn As Boolean, bRow As Boolean, bChartSelectedData As Boolean, bDataIsAColumn As Boolean, _
'''    bChartSIPmathOutput As Boolean, bDataNamesInHeadings As Boolean, sFrequencyDest As String, _
'''    sCumulativeDest As String, _
'''    oCallingForm As Object, bIntegerChart As Boolean, _
'''    Optional rDefaultChartDataLocation As Range = Nothing, _
'''    Optional sSparklineType As String = "", Optional vaOutputNames, _
'''    Optional bUseCollection As Boolean = False, Optional cRangeCollection As Collection)
'''
'''#End If

    Dim outputName As Variant, bin As Long, outputRange As Range, RangeSize As Long, dataRanges As Range
    Dim outputRangeID As Variant
    Dim f As Long, rm As Long, cm As Long ' f = offset, rm = row multiplier, cm  = col multiplier
    Dim xrm As Long, xcm As Long ' xrm = X-axis Row Multiplier, xcm = similar
    Dim outputCell As Range, lastSelection As Object, lastActiveSheet As Object
    Dim tableCell As Range, ufSCDL As Object
    Dim rgbSeriesColor As Long
    Dim tempNumBins As Long
    Dim calcMode As Variant
    Dim nMaxBins As Long
    
    calcMode = Application.Calculation
    Application.Calculation = xlCalculationManual
    '
    ' get max bins
    '
    Dim sMaxBins As String
    On Error Resume Next
    Err.Clear
    nMaxBins = [=PM_MaxBins]
    If Err <> 0 Then
        Do
            sMaxBins = InputBox("SIPmath could not find a value for the MAXIMUM number of bins allowed.", _
                "SIPmath", "50")
            Err.Clear
            nMaxBins = sMaxBins
        Loop Until Err = 0
        ActiveWorkbook.Names.Add "PM_MaxBins", sMaxBins
    End If
    Err.Clear
    On Error GoTo 0
    '
    ' check that RefEditGraphRanges has a valid range
    '
    If Not bUseCollection Then
        On Error GoTo ufg_cbo_c_regr_error:
        Set outputName = Range(sGraphRanges)
        Set outputName = Nothing
        On Error GoTo 0
    End If
    
    On Error GoTo cbo_c_error
    Application.ScreenUpdating = False
    'Application.Calculation = xlCalculationManual
    
    Set lastSelection = Selection
    Set lastActiveSheet = ActiveSheet
    
    If bExcelChart Or bSparkline Then
        rm = 0
        cm = 0
        If bColumn Then rm = 1 ' I know this seems backwards but it's really correct.
        If bRow Then cm = 1
    End If
    f = 0
    '
    ' if we don't have a chart data sheet, then create one in the ActiveWorkbook
    '
    Dim chartDataLocation As Range
    Dim msgBoxReturn, bScdPresent As Boolean, libFileName As String, lastActiveSheetName As String
    Dim nHeadRow As Long
    
    bScdPresent = False
    On Error Resume Next
    Err.Clear
    bScdPresent = (ActiveWorkbook.Sheets(scd).Name = scd)
    On Error GoTo 0
    If Not bScdPresent Then
        lastActiveSheetName = ActiveSheet.Name
        ActiveWorkbook.Sheets.Add After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
        ActiveSheet.Name = scd
        If ActiveSheet.Name <> scd Then
            MsgBox APP_NAME & " could not create the worksheet " & scd, vbExclamation, APP_NAME
            Application.Calculation = calcMode
            Exit Sub
        Else
            With ActiveSheet
                .Outline.ShowLevels RowLevels:=8, ColumnLevels:=8
                .Cells.Interior.Color = &HFFFFFF
                nHeadRow = 2
                .Cells(nHeadRow, 1).value = "Expected Value": nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Series Name":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Integer chart?":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Loss Exceedance":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Number of Bins":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Label position":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Bin Width":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Decimals":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Scale":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Use Axis Title?":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Axis Title":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Min":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Bin Range":  .Cells(nHeadRow, 1).Interior.Color = &H8080FF: nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Frequency":  .Cells(nHeadRow, 1).Interior.Color = &H80FFFF: nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Labels":  .Cells(nHeadRow, 1).Interior.Color = &HFFFF80: nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Cumulative":  .Cells(nHeadRow, 1).Interior.Color = &H80FF80: nHeadRow = nHeadRow + 1
                
                Dim pctVals(1 To 105, 1 To 1) As Double
                Dim pctNdx As Long
                
                pctVals(1, 1) = 0.001
                pctVals(2, 1) = 0.004
                pctVals(3, 1) = 0.007
                For pctNdx = 1 To 99
                    pctVals(pctNdx + 3, 1) = pctNdx * 0.01
                Next
                pctVals(103, 1) = 0.993
                pctVals(104, 1) = 0.996
                pctVals(105, 1) = 0.999
                .Range("A1").Offset(3 * nMaxBins + 21, 0).Resize(105, 1).value = pctVals
                '
                ' define CDF Y axis ranges
                '
                ActiveWorkbook.Names.Add "PM_cdf_Y", .Range("A1").Offset(3 * nMaxBins + 21, 0).Resize(105, 1)
                ActiveSheet.Cells(1, 1).Offset(13, 0).Resize(nMaxBins + 1, 1).Rows.Group
                ActiveSheet.Cells(1, 1).Offset(15 + nMaxBins, 0).Resize(nMaxBins + 2, 1).Rows.Group
                ActiveSheet.Cells(1, 1).Offset(18 + 2 * nMaxBins, 0).Resize(nMaxBins + 2, 1).Rows.Group
                ActiveSheet.Cells(1, 1).Offset(21 + 3 * nMaxBins, 0).Resize(105, 1).Rows.Group
            End With
            bScdPresent = True
        End If ' ActiveSheet.Name <> scd
        ActiveWorkbook.Sheets(lastActiveSheetName).Activate
    End If ' Not bScdPresent
    ActiveWorkbook.Sheets(scd).Outline.ShowLevels RowLevels:=8, ColumnLevels:=8
    '
    ' I have several different ways to loop through the data:
    ' 1: data is a collection of rows
    ' 2: data is a collection of columns
    ' 3: data is a collection of cells with output names
    ' 4: data is a collection of cells output formulas
    ' 5: data is a collection of ranges, in cRangeCollection (indicated by bUseCollection = true)
    '
    ' The thing to do is to put together a collection of ranges (either rows, columns, or cells)
    ' and loop through them; using Cases or Ifs or something to figure out what the output names and ranges
    ' should be for the main loop body.
    '
    Dim rangeToLoopThru As Object, rangeElement As Range, elementNum As Long

    '
    ' so first I figure out what collection to loop through
    '
    If bChartSelectedData Then
        If bUseCollection Then
            Set rangeToLoopThru = cRangeCollection
        ElseIf bDataIsAColumn Then
            Set rangeToLoopThru = Range(sGraphRanges).Columns
        Else
            Set rangeToLoopThru = Range(sGraphRanges).Rows
        End If
    ElseIf bChartSIPmathOutput Then
        Set rangeToLoopThru = Range(sGraphRanges)
    End If
    '
    ' then loop through the collection...
    '
    Dim j As Long, convertChars As Boolean, sTmpAdr As String
    Dim rMinLoc As Range, rBinWdthLoc As Range, rNumBinsLoc As Range
    Dim rScdCell As Range, rLastCell As Range
    Dim dBinSize As Double, dMaxVal As Double, nDigits As Long, rNDigitsLoc As Range
    Dim rLblPosnLoc As Range, rScaleLoc As Range, rShowAxLblLoc As Range, rAxLblLoc As Range
    Dim bLocalLib As Boolean, bExtInput As Boolean, sLibFileName As String
    Dim rIntegerChartLoc As Range, sIntTempSubFmla As String, sFltTempSubFmla As String
    
    Dim vBorderID As Variant
    Dim nColCount As Long
    
    Dim sSeriesNameCellAddr As String
    Dim bAlreadyExistingData As Boolean
    
    elementNum = 0
    For Each rangeElement In rangeToLoopThru    'was: For Each outputCell In Range(UserFormGraphs.RefEditGraphRanges)
        On Error GoTo cbo_could_not_find_output
        '
        ' ...and figure out the output name and ranges for the main loop body
        '
        If bChartSelectedData Then
            Set outputRange = Range(rangeElement.Address(, , , 1))
            If bDataNamesInHeadings Then
                outputName = outputRange(1, 1).value
                '
                ' check for valid characters
                '
                convertChars = False
                '
                ' names must start with a letter or "_", and must contain only letters, digits, periods, or "_"
                '
                For j = 1 To Len(outputName)
                    If (j = 1 And 0 = InStr(ALPHABETICAL_CHARS & "_", Mid$(outputName, j, 1))) _
                    Or (j > 1 And 0 = InStr(ALPHABETICAL_CHARS & NUMERIC_CHARS & "_" & ".", Mid$(outputName, j, 1))) Then
                        If Not convertChars Then
                            If vbYes = MsgBox("The output name""" & outputName & _
                                """ has an invalid character." & vbNewLine & _
                                "SIPmath can convert invalid names to valid range names by replacing invalid characters with the ""_"" character." & vbNewLine & vbNewLine & _
                                "Do you want to do that?", vbQuestion Or vbYesNo, APP_NAME) _
                            Then
                                convertChars = True
                            Else
                                MsgBox "Please ensure output names contain only letters, digits, periods, and ""_"" characters.", _
                                    vbExclamation, APP_NAME
                                Application.Calculation = calcMode
                                Exit Sub
                            End If
                        End If
                        If j = 1 And 0 <> InStr(NUMERIC_CHARS, Mid$(outputName, j, 1)) Then
                            ' 1st char is number, so just put a _ in front
                            outputName = "_" & outputName
                        Else
                            outputName = Left(outputName, j - 1) & "_" & Mid$(outputName, j + 1)
                        End If
                    End If
                Next j
                
                If bDataIsAColumn Then
                    Set outputRange = outputRange.Offset(1, 0).Resize(outputRange.Cells.Count - 1, 1)
                Else
                    Set outputRange = outputRange.Offset(0, 1).Resize(1, outputRange.Cells.Count - 1)
                End If
                outputRangeID = outputRange.Address(RowAbsolute:=False, ColumnAbsolute:=False, External:=True)
            Else 'output names aren't given in the range so I have to figure out a name
                outputRangeID = ""
                On Error Resume Next
                outputRangeID = outputRange.Name.Name
                '
                ' The above line causes the "Strange Bug" where you can't chart an input if it has no metadata,
                ' because if that is the case, then the outputRange.Name.Name will just be the inputSIP name,
                ' but it should have the full external reference with the filename and ! characters.
                '
                ' To fix it, I will need to know two things: 1) if I'm charting an input, and 2), if it's external.
                ' To determine 1) & 2), I will check if the library is local, and, if not, if the outputRange is in the
                ' external library
                '
                ' if 1) and 2) hold then the range id should include the full external address of the outputrange
                '
                bLocalLib = False
                bExtInput = False
                Err.Clear
                bLocalLib = [=PM_local_library]
                If Err <> 0 Then
                    bLocalLib = [=local_library]
                End If
                Err.Clear
                sLibFileName = [=PM_library_file_name]
                If Err <> 0 Then
                    sLibFileName = [=library_file_name]
                End If
                bExtInput = (outputRange.Parent.Parent.Name = sLibFileName)
                
                On Error GoTo cbo_could_not_find_output
                If outputRangeID = "" Then
                    outputRangeID = outputRange.Address(RowAbsolute:=False, ColumnAbsolute:=False, External:=True)
                    If IsMissing(vaOutputNames) = True Then
                        outputName = "_" & Replace(outputRange.Address(RowAbsolute:=False, ColumnAbsolute:=False), ":", "_to_")
                    Else
                        outputName = vaOutputNames
                    End If
                Else
                    outputName = outputRangeID
                    '
                    ' now fix outputRangeID in case the "Strange Bug" would occur
                    ' hopefully this case only occurs if the outputRangeID is the name of a range, and we just
                    ' just need to add the filename and ! before the range name to get a full external reference
                    '
                    If Not bLocalLib And bExtInput Then
                        outputRangeID = "'" & Replace(outputRange.Parent.Parent.Name, "'", "''") & "'!" & outputRangeID
                    End If
                End If
            End If
        Else
            Set outputCell = rangeElement
#If PROJECT = SIPMATH_HISTOGRAM Then
            smh_getOutputNameAndRange outputCell, outputName, outputRange
#ElseIf PROJECT = SIPMATH_TOOLS Then
            smmt_getOutputNameAndRange outputCell, outputName, outputRange
#Else
            smkr_getOutputNameAndRange outputCell, outputName, outputRange
#End If
            outputRangeID = outputName
        End If
        On Error GoTo cbo_c_error
        If outputRange.Columns.Count > 1 And outputRange.Rows.Count = 1 Then ' outputRange is a row; put bins, freqs, cumuls at end of row
            xrm = 1: xcm = 0 ' formerly xrm=0, xcm=1 to put chart data in a row when outputrange is a row
            RangeSize = outputRange.Columns.Count
        ElseIf outputRange.Columns.Count = 1 And outputRange.Rows.Count > 1 Then
            xrm = 1: xcm = 0
            RangeSize = outputRange.Rows.Count
        Else ' range is neither a row nor a column
            xrm = 0: xcm = 0
            MsgBox APP_NAME & " could not create a histogram from the name '" & outputName _
                & "'. Check that '" & outputName & "' refers to a single row or column of cells.", vbExclamation, _
                APP_NAME
        End If
        '
        ' try this to make sure input/output sparklines are always done in columns:
        '
        If sSparklineType = "Input" Or sSparklineType = "Output" Then
            xrm = 1: xcm = 0
            ' rangeSize is left alone, though
        End If
        '
        ' hopefully this is now set up to correctly make chart data for both row-wise
        ' and column-wise source data
        '
        ' note that the chart data is always put in columns, even if the source data is in rows
        '
        ' chart data location was either specified by user or is at end of the source data,
        ' or is on the sipmath chart data sheet
        '
        bAlreadyExistingData = False
        If bScdPresent Then
            '
            ' see if there is already a column of chart data for this output
            '
            Set rScdCell = ActiveWorkbook.Sheets(scd).Cells(1, 2)
            nColCount = Columns.Count
            Do
                If CStr(rScdCell.Value2) = outputName Or CStr(rScdCell.Offset(1, 0).Value2) = outputName Then
                    bAlreadyExistingData = True
                    Exit Do
                End If
                If rScdCell.Column >= nColCount Then Exit Do
                Set rScdCell = rScdCell.Offset(0, 1)
            Loop
'            Set rLastCell = ActiveWorkbook.Sheets(scd).Cells.SpecialCells(xlCellTypeLastCell)
            With ActiveWorkbook.Sheets(scd)
                On Error Resume Next
                Err.Clear
#If Mac Then
                Set rLastCell = .Cells.Find(What:="*", After:=.[A1], LookIn:=xlValues, _
                    LookAt:=xlPart, SearchOrder:=xlByColumns, _
                    SearchDirection:=xlPrevious, MatchCase:=False)
#Else
                Set rLastCell = .Cells.Find(What:="*", After:=.[A1], LookIn:=xlValues, _
                    LookAt:=xlPart, SearchOrder:=xlByColumns, _
                    SearchDirection:=xlPrevious, MatchCase:=False, SearchFormat:=False)
#End If
                If Err <> 0 Then Set rLastCell = .Cells(1, 1)
                Err.Clear
                On Error GoTo cbo_c_error
            End With
            
            If rScdCell.Value2 = outputName Or rScdCell.Offset(1, 0).Value2 = outputName Then
                Set chartDataLocation = rScdCell.EntireColumn.Resize(1, 1).Offset(1, 0)
            Else
                Set chartDataLocation = rLastCell.EntireColumn.Resize(1, 1).Offset(1, 1)
            End If
        ElseIf bChartSIPmathOutput Then ' use end of source data
            If rDefaultChartDataLocation Is Nothing Then
                Set chartDataLocation = outputRange.Resize(1, 1).Offset(xrm * RangeSize, xcm * RangeSize)
            Else
                Set chartDataLocation = rDefaultChartDataLocation
            End If
        Else ' user specified location
            Set chartDataLocation = chartDataLocation(1, 1)
        End If ' bScdPresent
        Set rDefaultChartDataLocation = chartDataLocation
        
        With chartDataLocation.Offset(4 * xrm, 4 * xcm).Offset(2, 0)
            '
            ' clear space for the chart data. leave other cells alone
            '
            If "" <> Trim(sFrequencyDest) Then
                .Offset(6, 0).Resize(3 * (nMaxBins + 3) - 1, 1).ClearContents
            End If
            If "" <> Trim(sCumulativeDest) Then
                .Offset(5 + 3 * (nMaxBins + 3), 0).Resize(107, 1).ClearContents
            End If
            Set rIntegerChartLoc = .Offset(-4 * xrm, -4 * xcm)
            Set rNumBinsLoc = .Offset(-2 * xrm, -2 * xcm)
            Set rLblPosnLoc = .Offset(-xrm, -xcm)
            Set rMinLoc = .Offset(5 * xrm, 5 * xcm)
            Set rBinWdthLoc = .Offset(0 * xrm, 0 * xcm)
            Set rNDigitsLoc = .Offset(1 * xrm, 1 * xcm)
            Set rScaleLoc = .Offset(2 * xrm, 2 * xcm)
            Set rAxLblLoc = .Offset(4 * xrm, 4 * xcm)
            Set rShowAxLblLoc = .Offset(3 * xrm, 3 * xcm)
                
            .Offset(-2 * xrm, -2 * xcm).Formula = _
                "=if( " & rIntegerChartLoc.Address & ", " & _
                    "min( int( max( " & outputRangeID & " ) - min( " & outputRangeID & " ) + 1 ), " & _
                    numBins & " ), " & numBins & " )"
            
            ' below will be used later when defining the chart series names
            sSeriesNameCellAddr = .Offset(-5, 0).Resize(1, 1).Address(0, 0, xlA1, True)
                
            .Offset(-4 * xrm, -4 * xcm).Resize(1, 1).value = bIntegerChart
            
            If Not bAlreadyExistingData Then
                .Offset(-7 * xrm, -7 * xcm).Resize(1, 1).value = outputName
                '
                ' add series name with EV (expected value)
                '
                .Offset(-6, 0).Resize(1, 1).Formula = "=ROUND( AVERAGE( " & outputRangeID & " ), " & rNDigitsLoc.Address & " )"
                .Offset(-5, 0).Resize(1, 1).FormulaR1C1 = "=r1c" & Trim(.Column) & " & "" EV "" & r" & Trim(.Offset(-6, 0).Resize(1, 1).row) & "c" & Trim(.Column)
                
                .Offset(-4 * xrm, -4 * xcm).BorderAround 1
                .Offset(-3 * xrm, -3 * xcm).Resize(1, 1).value = False ' Loss Exceedance flag:
                .Offset(-3 * xrm, -3 * xcm).BorderAround 1
                .Offset(-2 * xrm, -2 * xcm).Formula = _
                    "=if( " & rIntegerChartLoc.Address & ", " & _
                        "min( int( max( " & outputRangeID & " ) - min( " & outputRangeID & " ) + 1 ), " & _
                        numBins & " ), " & numBins & " )"
                .Offset(-2 * xrm, -2 * xcm).BorderAround 1
                .Offset(-xrm, -xcm).value = 10 ' default label spacing
                .Offset(-xrm, -xcm).BorderAround 1
                '
                ' min of data:
                '
                .Offset(5 * xrm, 5 * xcm).Formula = _
                    "=min( " & outputRangeID & " ) - if( " & rIntegerChartLoc.Address & ", 1, 0 )"
                .Offset(5 * xrm, 5 * xcm).BorderAround 1
                '
                ' initial bin size:
                '
                dMaxVal = Application.WorksheetFunction.Max(Range(outputRangeID))
                dBinSize = (dMaxVal - rMinLoc.Value2) / numBins
                If dBinSize > 0 Then nDigits = -Int(-0.5 + Log(dBinSize) * 0.434294481903252) Else nDigits = 0
                If nDigits < 0 Then nDigits = 0
                If bIntegerChart Then nDigits = 0
                dBinSize = Int(0.5 + dBinSize * 10 ^ nDigits) * 10 ^ -nDigits
                rMinLoc.value = Int(0.5 + rMinLoc.Value2 * 10 ^ nDigits) * 10 ^ -nDigits
                
                .Offset(0 * xrm, 0 * xcm).value = dBinSize
                .Offset(0 * xrm, 0 * xcm).BorderAround 1
                '
                ' decimals of rounding for bins
                '
                .Offset(1 * xrm, 1 * xcm).BorderAround 1
                .Offset(1 * xrm, 1 * xcm).value = nDigits
                '
                ' modified formulas for Min and Bin width
                '
                rMinLoc.Formula = "=round( min( " & outputRangeID & " ), " & rNDigitsLoc.Address & " )" _
                        & " - if( " & rIntegerChartLoc.Address & ", 1, 0 )"
                    rBinWdthLoc.Formula _
                        = "=roundup(( max( " & outputRangeID & " ) - " & rMinLoc.Address & " )" _
                            & " / " & rNumBinsLoc.Address & ", " & rNDigitsLoc.Address & " )"
                '
                ' add Scale control for number of 000s
                ' rScaleLoc as Range, rShowAxLblLoc as Range, rAxLblLoc as Range
                '
                .Offset(2 * xrm, 2 * xcm).BorderAround 1
                .Offset(2 * xrm, 2 * xcm).Value2 = 1
                '
                ' add optional axis title showing how many 000s
                '
                .Offset(4 * xrm, 4 * xcm).BorderAround 1
                
                Dim sUseTitleAddr As String, sScaleAddr As String
                sUseTitleAddr = .Offset(3, 0).Resize(1, 1).Address(1, 1, xlR1C1)
                sScaleAddr = .Offset(2, 0).Resize(1, 1).Address(1, 1, xlR1C1)
                .Offset(4 * xrm, 4 * xcm).FormulaR1C1 _
                    = "=if( and( " & sUseTitleAddr & ", " & sScaleAddr & " > 1 ), mid( text( " & _
                        sScaleAddr & ", ""#,##0"" ), if( mod( len( text( " & sScaleAddr & ", ""0"" )), 3 ) = 1, 3, 2), 100 ) & ""s"", ""Axis Title"" )"
                '
                ' add option to turn the title on and off
                '
                .Offset(3 * xrm, 3 * xcm).BorderAround 1
                .Offset(3 * xrm, 3 * xcm).Value2 = False
                '
                ' resize column A so labels will all show
                '
                chartDataLocation.Parent.Range("A2:A9").Columns.AutoFit
                '
                ' I will put in nMaxBins+2 bins.
                ' =FREQUENCY() will need nMaxBins+1 bin values.
                ' The labels will need nMaxBins+3 numbers: the bin values and a min and a max
                '
                ' final min formula
                '
                rMinLoc.Formula = "=round( min( " & outputRangeID & " ), " _
                    & rNDigitsLoc.Address & " - log( " & rScaleLoc.Address & " ))" _
                        & " - if( " & rIntegerChartLoc.Address & ", 1, 0 )"
            End If ' Not bAlreadyExistingData
            '
            ' now I add the rest of the bins, just after the rounded min
            '
            For bin = 0 To nMaxBins + 1
                .Offset(xrm * (6 + bin), xcm * (6 + bin)).Formula = _
                    "=round( " & .Offset(xrm * (5 + bin), xcm * (5 + bin)).Address _
                    & " + " & rBinWdthLoc.Address & ", " & rNDigitsLoc.Address & " - log( " & rScaleLoc.Address & " ))"
            Next bin
            '
            ' define the bin range
            '
            ActiveWorkbook.Names.Add "PM_" & outputName & "_bins", _
                .Offset(xrm * 6, xcm * 6) _
                    .Resize(xrm * (nMaxBins + 1) + xcm * 1, _
                            xrm * 1 + xcm * (nMaxBins + 1))
            ActiveWorkbook.Names("PM_" & outputName & "_bins").RefersToRange.Interior.Color = &H8080FF
            '
            ' put in the =FREQUENCY() formulas
            '
            .Offset(xrm * (nMaxBins + 8), xcm * (nMaxBins + 8)) _
                .Resize(xrm * (nMaxBins + 2) + xcm * 1, _
                        xrm * 1 + xcm * (nMaxBins + 2)) _
                    .FormulaArray = _
                "=" & IIf(xcm = 1, "TRANSPOSE( ", "") & "FREQUENCY( " _
                        & outputRangeID & ", " _
                        & "PM_" & outputName & "_bins ) / COUNT( " & outputRangeID & " )" & IIf(xcm = 1, ")", "") '
            '
            ' define the =FREQUENCY() range
            '
            ActiveWorkbook.Names.Add _
                "PM_" & outputName & "_freq", _
                .Offset(xrm * (nMaxBins + 8), xcm * (nMaxBins + 8)) _
                    .Resize(xrm * (nMaxBins + 2) + xcm * 1, _
                            xrm * 1 + xcm * (nMaxBins + 2))
            ActiveWorkbook.Names("PM_" & outputName & "_freq").RefersToRange.Interior.Color = &H80FFFF
            '
            ' formulas to create labels
            '
            sFltTempSubFmla = IIf(xrm = 1, "r[-" & 2 * nMaxBins + 6 & "]c" & Trim(.Column), "r" & Trim(.row) & "c[-" & 2 * nMaxBins + 6 & "]")
            sIntTempSubFmla = IIf(xrm = 1, "r[-" & 2 * nMaxBins + 5 & "]c" & Trim(.Column), "r" & Trim(.row) & "c[-" & 2 * nMaxBins + 5 & "]")
            .Offset(xrm * (2 * nMaxBins + 11), xcm * (2 * nMaxBins + 11)) _
                .Resize(xrm * (nMaxBins + 2) + xcm, xrm + xcm * (nMaxBins + 2)).FormulaR1C1 _
                    = "=if(" & rIntegerChartLoc.Address(1, 1, xlR1C1) & ", " _
                    & sIntTempSubFmla _
                    & ", " & sFltTempSubFmla _
                        & " / " & rScaleLoc.Address(ReferenceStyle:=xlR1C1) _
                        & " & rept( "" "", " & rLblPosnLoc.Address(True, True, xlR1C1) & " ))"
            '
            ' define range name for labels
            '
            ActiveWorkbook.Names.Add "PM_" & outputName & "_lbls", _
                .Offset(xrm * (2 * nMaxBins + 11), xcm * (2 * nMaxBins + 11)) _
                    .Resize(xrm * (nMaxBins + IIf(bIntegerChart, 1, 2)) + xcm, _
                            xrm + xcm * (nMaxBins + IIf(bIntegerChart, 1, 2)))
            ActiveWorkbook.Names("PM_" & outputName & "_lbls").RefersToRange.Interior.Color = "&hffff80"
            '
            ' convert data and labels to named offset formulas that allow changing # of bins dynamically
            ' 1. define names referring to the ranges
            '    (these must be different from the existing output_freq and output_cume names, because
            '     the new names will be re-defined later to be OFFSET() formulas)
            ' 2. set the chart to refer to these names
            ' 3. re-define the names to refer to the Offset() formulas
            '
            ' steps 2 and 3 will be deferred to after the charts are created, of course
            ' step 1 is below:
            '
            ActiveWorkbook.Names.Add "PM_" & outputName & "_hist_data", Names("PM_" & outputName & "_freq").RefersToRange
            ActiveWorkbook.Names.Add "PM_" & outputName & "_axis_lbls", Names("PM_" & outputName & "_lbls").RefersToRange
            '
            ' make CDF formulas when cumulative chart location specified
            '
            If "" <> Trim(sCumulativeDest) Then
                .Offset(3 * nMaxBins + 14, 0).Resize(105, 1).ClearContents
                .Offset(3 * nMaxBins + 14, 0).Resize(105, 1).FormulaR1C1 _
                    = "=PERCENTILE( " & Application.ConvertFormula(outputRangeID, xlA1, xlR1C1, xlAbsolute) & ", IF( r5c" & Trim(.Column) & ", 1-rc1, rc1 ))"
                .Offset(3 * nMaxBins + 14, 0).Resize(105, 1).Interior.Color = &H80FF80
                '
                ' define CDF X-axis ranges
                '
                ActiveWorkbook.Names.Add "PM_" & outputName & "_cdf_X", _
                    .Offset(3 * nMaxBins + 14, 0).Resize(105, 1)
            End If ' "" <> Trim(sCumulativeDest)
        End With
        
        If ("" <> Trim(sFrequencyDest)) _
        Or ("" <> Trim(sCumulativeDest)) Then
            On Error Resume Next
            If "" <> Trim(sFrequencyDest) Then ' freq chart specified
                If bSparkline Then
                    If sSparklineType = "Input" Then
                        rgbSeriesColor = 5296274 ' light green
                    ElseIf sSparklineType = "Output" Then
                        rgbSeriesColor = 15773696 ' light blue
                    Else
                        rgbSeriesColor = 1
                    End If
                    With Range(sFrequencyDest)(1, 1).Offset(f * rm, f * cm)
                        '
                        ' step 2. set the chart to refer to the range names which will
                        ' be changed to OFFSET() formulas in step 3.
                        '
                        .SparklineGroups.Add Type:=2, SourceData:="PM_" & outputName & "_hist_data" ' type 2 = xlSparkColumn. Use the 2 so it doesn't crash in Excel 2007
                        .SparklineGroups.Item(1).Axes.Vertical.MinScaleType = 3 ' 3 = xlSparkScaleCustom
                        .SparklineGroups.Item(1).Axes.Vertical.CustomMinScaleValue = 0
                        If rgbSeriesColor <> 1 Then
                            .SparklineGroups.Item(1).SeriesColor.Color = rgbSeriesColor
                            For Each vBorderID In Array(xlEdgeLeft, xlEdgeTop, xlEdgeRight, xlEdgeBottom)
                                With .MergeArea.Borders(vBorderID)
                                    .LineStyle = xlContinuous
                                    .Color = &H808080
                                    .Weight = xlThin
                                End With
                            Next vBorderID
                            ' .BorderAround xlContinuous, xlMedium
                            .HorizontalAlignment = xlRight
                            .VerticalAlignment = xlTop
                            .Font.FontStyle = "Bold"
                        End If
                    End With
                ElseIf bExcelChart Then
                    ' create excel bar chart histogram here
                    ActiveWorkbook.Names("PM_" & outputName & "_freq").RefersToRange.Parent.Activate
                    ActiveWorkbook.Names("PM_" & outputName & "_freq").RefersToRange.Select
                    ActiveSheet.ChartObjects.Add(100, 100, 343, 212).Select ' ActiveSheet.Shapes.AddChart.Select
                    ActiveChart.ChartType = xlColumnClustered
                    ActiveChart.SetSourceData source:=ActiveWorkbook.Names("PM_" & outputName & "_freq").RefersToRange
                    ActiveChart.SeriesCollection(1).Name = "=" & sSeriesNameCellAddr ' outputName & " histogram"
                    ActiveChart.SeriesCollection(1).XValues = Range("PM_" & outputName & "_lbls")
                    ActiveChart.Axes(xlValue).TickLabels.NumberFormat = "0%"
                    ActiveChart.Axes(xlValue).MinimumScale = 0
                    ActiveChart.SetElement (msoElementLegendNone)
                    ActiveChart.ChartGroups(1).GapWidth = 15
                    ActiveChart.Location xlLocationAsObject, Range(sFrequencyDest).Parent.Name
                    ActiveChart.ChartArea.Top = Range(sFrequencyDest)(1, 1).Offset(f * rm, f * cm).Top
                    ActiveChart.ChartArea.Left = Range(sFrequencyDest)(1, 1).Offset(f * rm, f * cm).Left
                    '
                    ' step 2. set the chart to refer to the range names which will
                    ' be changed to OFFSET() formulas in step 3.
                    '
                    ActiveChart.SeriesCollection(1).Values = _
                            "='" & ActiveWorkbook.Name & "'!" & "PM_" & outputName & "_hist_data"
                    ActiveChart.SeriesCollection(1).XValues = _
                        "='" & ActiveWorkbook.Name & "'!" & "PM_" & outputName & "_axis_lbls"
                    ActiveChart.SetElement (msoElementPrimaryCategoryAxisTitleAdjacentToAxis)
#If Mac Then
                    ActiveChart.Axes(xlCategory).AxisTitle.FormulaR1C1 = "=" & rAxLblLoc.Address(1, 1, xlR1C1, 1)
#Else
                    Selection.Caption = "=" & rAxLblLoc.Address(1, 1, xlR1C1, 1)
#End If
                    lastActiveSheet.Activate
                End If ' bSparkline
            End If ' freq chart specified
            If "" <> Trim(sCumulativeDest) Then ' cumulative chart specified
                If bExcelChart Then
                    ' create excel CDF scatterplot line
                    ' note we don't need to redefine ranges as OFFSET() formulas for this chart
                    ActiveSheet.ChartObjects.Add(100, 100, 343, 212).Select ' ActiveSheet.Shapes.AddChart.Select
                    ActiveChart.SetSourceData source:=ActiveWorkbook.Names("PM_cdf_Y").RefersToRange
                    ActiveChart.ChartType = xlXYScatterLinesNoMarkers
                    ActiveChart.SeriesCollection(1).Name = "=" & sSeriesNameCellAddr 'outputName & " CDF"
                    ActiveChart.Axes(xlValue).TickLabels.NumberFormat = "0%"
                    ActiveChart.Axes(xlValue).MinimumScale = 0
                    ActiveChart.Axes(xlValue).MaximumScale = 1
                    
                    ActiveChart.SetElement (msoElementLegendNone)
                    ActiveChart.Location xlLocationAsObject, Range(sCumulativeDest).Parent.Name
                    ActiveChart.ChartArea.Top = Range(sCumulativeDest)(1, 1).Offset(f * rm, f * cm).Top
                    ActiveChart.ChartArea.Left = Range(sCumulativeDest)(1, 1).Offset(f * rm, f * cm).Left
                    '
                    ' step 2. set the chart to refer to the range names
                    '
                    ActiveChart.SeriesCollection(1).Values = _
                        "='" & ActiveWorkbook.Name & "'!" & "PM_cdf_Y"
                    ActiveChart.SeriesCollection(1).XValues = _
                        "='" & ActiveWorkbook.Name & "'!" & "PM_" & outputName & "_cdf_X"
                    ActiveChart.SetElement (msoElementPrimaryCategoryAxisTitleAdjacentToAxis)
#If Mac Then
                    ActiveChart.Axes(xlCategory).AxisTitle.FormulaR1C1 = "=" & rAxLblLoc.Address(1, 1, xlR1C1, 1)
#Else
                    Selection.Caption = "=" & rAxLblLoc.Address(1, 1, xlR1C1, 1)
#End If
                    lastActiveSheet.Activate
                End If ' bSparkline
            End If ' cumulative chart specified
            '
            ' step 3. re-define the chart source data name (and label names) to be an OFFSET() formula
            '
            ActiveWorkbook.Names.Add _
                "PM_" & outputName & "_hist_data", _
                "=OFFSET( " & Names("PM_" & outputName & "_freq").RefersToRange.Address(True, True, xlA1, True) & _
                            ", 0, 0, " & rNumBinsLoc.Address(, , , True) & " )"
            ActiveWorkbook.Names.Add _
                "PM_" & outputName & "_axis_lbls", _
                "=OFFSET( " & Names("PM_" & outputName & "_lbls").RefersToRange.Address(True, True, xlA1, True) & _
                            ", 0, 0, " & rNumBinsLoc.Address(, , , True) & " )"
            On Error GoTo 0
            f = f + 1
        End If
        If bChartSelectedData Then
            If bDataIsAColumn Then
                Set chartDataLocation = chartDataLocation.Offset(0, 1)
            Else
                Set chartDataLocation = chartDataLocation.Offset(1, 0)
            End If
            Set rDefaultChartDataLocation = chartDataLocation
        End If
    Next rangeElement ' was: outputCell
    lastActiveSheet.Activate
    lastSelection.Select
    'Unload Me
    Application.Calculation = calcMode
    Exit Sub
    
cbo_could_not_find_output:
    MsgBox APP_NAME & " could not find the output range for cell " & outputCell.Address & ".", _
    vbExclamation, APP_NAME
    Application.Calculation = calcMode
    'Unload Me
    Exit Sub
    
cbo_c_error:
    MsgBox APP_NAME & " could not create a histogram from the specified name. " & _
        "Check that the name refers to a single row or column of cells.", vbExclamation, APP_NAME
    Application.Calculation = calcMode
    'Unload Me
    Exit Sub
    
ufg_cbo_c_regr_error:
    MsgBox Trim(sGraphRanges) & " is not a valid range.", vbExclamation, APP_NAME
    Application.Calculation = calcMode
    'Unload Me
    Exit Sub

End Sub

Sub conditionalMergeBeforeCharting(sDataToChart_Name As String, sSparklineLocation_Name As String)
    '
    ' if sSparklineLocation_Name has more than 1 cell, try to guess how to
    ' merge cells
    '
    ' if there's only 1 input being defined by sDataToChart_Name, merge the whole range and pass in
    ' the 1st cell in the range as the sparkline location
    '
    ' otherwise, if there's mutiple inputs in a row, and sSparklineLocation_Name
    ' is multiple cells, merge a column of cells as high as that range.
    ' then move one column over and repeat, for each input in the row
    '
    ' if there's multiple inputs in a column, do the same, with rows/cols swapped
    '
    ' if you run into already merged cells, or cells with data in them, then
    ' complain and exit.
    '
    Dim rDataToChart As Range, rSparklineLocation As Range
    Dim nDRows As Long, nDCols As Long, nSRows As Long, nSCols As Long
    ' _D_ata Rows, _S_parkline Rows, etc
    
    Dim rSMerge As Range, n As Long
    
    If Trim(sSparklineLocation_Name) = "" Then Exit Sub
    Set rDataToChart = Range(sDataToChart_Name)
    Set rSparklineLocation = Range(sSparklineLocation_Name)
    
    If sSparklineLocation_Name = "" Then Exit Sub
    If rSparklineLocation.Cells.Count = 1 Then Exit Sub
    
    nDRows = rDataToChart.Rows.Count
    nDCols = rDataToChart.Columns.Count
    nSRows = rSparklineLocation.Rows.Count
    nSCols = rSparklineLocation.Columns.Count
    If rDataToChart.Cells.Count = 1 Then
        On Error Resume Next
        Err.Clear
        rSparklineLocation.Merge
        On Error GoTo 0
    ElseIf nDRows = 1 And nSRows > 1 Then
        On Error Resume Next
        For n = 1 To nDCols
            Set rSMerge = rSparklineLocation.Offset(0, n - 1).Resize(nSRows, 1)
        '''For Each rSMerge In rSparklineLocation.Columns
            rSMerge.Merge
        '''Next rSMerge
        Next n
        On Error GoTo 0
    ElseIf nDCols = 1 And nSCols > 1 Then
        On Error Resume Next
        For n = 1 To nDRows
            Set rSMerge = rSparklineLocation.Offset(n - 1).Resize(1, nSCols)
        '''For Each rSMerge In rSparklineLocation.Rows
            rSMerge.Merge
        '''Next rSMerge
        Next n
        On Error GoTo 0
    End If
    
End Sub

'Function makeCdfSheet() As Boolean
'    Dim lastActiveSheetName As String
'    lastActiveSheetName = ActiveSheet.Name
'    ActiveWorkbook.Sheets.Add After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
'    ActiveSheet.Name = cdfn
'    If ActiveSheet.Name <> cdfn Then
'        MsgBox APP_NAME & " could not create the worksheet " & cdfn, vbExclamation, APP_NAME
'        'Application.Calculation = calcMode
'        makeCdfSheet = False
'        Exit Function
'    End If
'    makeCdfSheet = True
'    ActiveWorkbook.Sheets(lastActiveSheetName).Activate
'End Function
'
Sub niceRange(dMin As Double, dMax As Double, nTicks As Long)

    Dim d As Double
    Dim dRange As Double, dX As Double
    
    If nTicks < 2 Then nTicks = 2
    dRange = niceNum(dMax - dMin, False)
    d = niceNum(dRange / (nTicks - 1), True)
    dMin = Int(dMin / d) * d
    dMax = Application.WorksheetFunction.Ceiling(dMax / d, 1) * d
    
End Sub

Function niceNum(dNum As Double, bRound As Boolean)

    Dim nExp As Long    ' exponent of dNum
    Dim dFrac As Double ' fractional part of dNum
    Dim dNf As Double   ' nice rounded fraction
    
    nExp = Int(Log(dNum) * 0.434294481903252)  ' .4343 = 1/log(10)
    dFrac = dNum / (10 ^ nExp)
    If bRound Then
        If dFrac < 1.5 Then
            dNf = 1
        ElseIf dFrac < 3 Then
            dNf = 2
        ElseIf dFrac < 7 Then
            dNf = 5
        Else
            dNf = 10
        End If
    Else
        If dFrac <= 1 Then
            dNf = 1
        ElseIf dFrac <= 2 Then
            dNf = 2
        ElseIf dFrac <= 5 Then
            dNf = 5
        Else
            dNf = 10
        End If
    End If
    niceNum = dNf * 10 ^ (nExp)
    
End Function
Attribute VB_Name = "ModuleImport"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
#If Mac Then
    '
    ' feature not available on Mac
    '
#Else

Option Explicit

'Callback for Id_ImportLibrary onAction
Sub inportLibrary(control As IRibbonControl)
    ' don't Call notAvailableMsg but replace with 3.4.0 code for Enterprise Version
    MsgBox "Imports SIP Libraries from XML and CSV. Available in the Enterprise version of SIPmath Tools for Windows." & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information.", vbInformation, APP_NAME
End Sub

'Sub importXmlLib(xmlFileName As Variant)
' replace with 3.4.0 code for Enterprise Version
'End Sub
'
'Sub importCsvLib(csvFileName As Variant)
' replace with 3.4.0 code for Enterprise Version
'End Sub

#End If
Attribute VB_Name = "ModuleInsertDistributions"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit

#If Mac And MAC_OFFICE_VERSION < 15 Then
#Else

Public Sub insertUniform(Optional control As IRibbonControl)

    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Uniform Distribution"
        .Label2.Visible = False: .RefEdit2.Enabled = False: .RefEdit2.Visible = False
        .Label3.Visible = False: .RefEdit3.Enabled = False: .RefEdit3.Visible = False
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .CheckBoxUseExternalRandom.Enabled = False
        .CheckBoxUseExternalRandom.Visible = False
        .FormulaTemplate = "=_r_"
        .Show
    End With
    chkCalcMode
'''    UserFormInsertUniform.Show
    'chkCalcMode
    
End Sub
    
Public Sub insertBeta(Optional control As IRibbonControl)

    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Beta Distribution"
        .Label2.Caption = "Alpha"
        .Label3.Caption = "Beta"
        .Label4.Caption = "A"
        .RefEdit4.Text = "0.0"
        .Label5.Caption = "B"
        .RefEdit5.Text = "1.0"
        .FormulaTemplate = "=BETA.INV( _r_, _0_, _1_, _2_, _3_ )"
        .Show
    End With
    chkCalcMode

End Sub

Public Sub insertBinom(Optional control As IRibbonControl)

    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Binomial Distribution"
        .Label2.Caption = "Number of Trials"
        .Label3.Caption = "Chance of Success"
        .RefEdit3.Text = "0.5"
        .Label4.Visible = False: .RefEdit4.Visible = False: .RefEdit4.Enabled = False
        .Label5.Visible = False: .RefEdit5.Visible = False: .RefEdit5.Enabled = False
        .FormulaTemplate = "=IFERROR( BINOM.INV( _0_, _1_, _r_ ), (_0_) * ((_1_)=1))"
        .Show
    End With
    'UserFormInsertBinom.Show
    chkCalcMode

End Sub

Public Sub insertChiSquare(Optional control As IRibbonControl)

    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Chi Square Distribution"
        .Label2.Caption = "Degrees of Freedom"
        .Label3.Visible = False: .RefEdit3.Enabled = False: .RefEdit3.Visible = False
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=CHIINV( _r_, _0_ )"
        .Show
    End With
    'UserFormInsertChiSquare.Show
    chkCalcMode
    
End Sub

Public Sub insertDiscrete(Optional control As IRibbonControl)

    With UserFormInsertDistribution
        .Caption = "Insert Discrete Distribution"
        .Label2.Caption = "Values"
        .RefEdit2.Text = ""
        .Label3.Caption = "Probabilities"
        .RefEdit3.Text = ""
        .Label4.Height = 25
        .RefEdit4.Text = ""
        .Label4.Width = 84
        .Label4.Top = .Label4.Top - 6
        .Label4.Caption = "Cumulative Prob" & vbNewLine & "(computed)"
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=LOOKUP( _r_, _a2_, _a0_ )"
        .DistType = 3
        .IsArray = False ' was True
        .Show
    End With
    chkCalcMode
    
End Sub

Public Sub insertExponential(Optional control As IRibbonControl)

    With UserFormInsertDistribution
        .Caption = "Insert Exponential Distribution"
        .Label2.Caption = "Alpha"
        .Label3.Visible = False: .RefEdit3.Enabled = False: .RefEdit3.Visible = False
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=-LN( 1 - _r_ ) * _0_"
        .Show
    End With
'''    UserFormInsertExponential.Show
    chkCalcMode
    
End Sub

Public Sub insertF(Optional control As IRibbonControl)

    With UserFormInsertDistribution
        .Caption = "Insert F Distribution"
        .Label2.Caption = "Degrees Free 1"
        .Label3.Caption = "Degrees Free 2"
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=FINV( _r_, _0_, _1_ )"
        .Show
    End With
    'UserFormInsertF.Show
    chkCalcMode
    
End Sub

Public Sub insertGamma(Optional control As IRibbonControl)

    With UserFormInsertDistribution
        .Caption = "Insert Gamma Distribution"
        .Label2.Caption = "Alpha"
        .Label3.Caption = "Beta"
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=GAMMAINV( _r_, _0_, _1_ )"
        .Show
    End With
'''    UserFormInsertGamma.Show
    chkCalcMode
    
End Sub

Public Sub insertLognormal(Optional control As IRibbonControl)

    With UserFormInsertDistribution
        .Caption = "Insert Lognormal Distribution"
        .RefEditDistribution.Width = 174
        .RefEditDistribution.Left = 126
        .LabelDistribution.Width = 54
        .LabelDistribution.Left = 66
        .RefEdit2.Width = 174
        .RefEdit2.Left = 126
        .RefEdit2.Text = "1"
        .RefEdit3.Left = 6
        .RefEdit3.Width = 78
        .RefEdit3.TextAlign = fmTextAlignRight
        .RefEdit3.Text = "0.9"
        .RefEdit4.Top = .RefEdit3.Top
        .RefEdit4.Width = 174
        .RefEdit4.Left = 126
        .RefEdit4.Text = "4"
        .Label2.Caption = "50th %ile"
        .Label2.Width = 54
        .Label2.Left = 66
        .Label3.Caption = "Enter 0.6 to 0.99"
        .Label3.Left = 6
        .Label3.Top = 60
        .Label3.TextAlign = fmTextAlignLeft
        .Label4.Caption = "th %ile"
        .Label4.Width = 48
        .Label4.Left = 72
        .Label4.Top = 48
        .Label4.ZOrder 1 ' bottom
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=LOGINV( _r_, LN( _0_ ), ( LN( _2_ ) - LN( _0_ )) / NORMSINV( _1_ ))"
        .Show
    End With
'''    UserFormInsertLognormal.Show
    chkCalcMode
    
End Sub

Public Sub insertMetalog(Optional control As IRibbonControl)
    UserFormInsertMetalog.Show
End Sub

Public Sub insertMultiNormal(Optional control As IRibbonControl)

    MsgBox "Inserts multiple correlated normal distributions. Available in the Enterprise version of SIPmath Tools for Windows." _
        & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information.", vbInformation, APP_NAME
        
    ' version 3.4 has the previous code for this
    
    chkCalcMode

End Sub

Public Sub insertMultiUniform(Optional control As IRibbonControl)

    MsgBox "Inserts multiple correlated uniform distributions. Available in the Enterprise version of SIPmath Tools for Windows." _
        & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information.", vbInformation, APP_NAME
        
    ' version 3.4 has the previous code for this
    
    chkCalcMode

End Sub

Public Sub insertMyerson(Optional control As IRibbonControl)

    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Myerson Distribution"
        .Label2.Caption = "10th percentile"
        .Label3.Caption = "50th percentile"
        .Label4.Caption = "90th percentile"
        .RefEdit4.value = 15
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .CheckBoxUseExternalRandom = True
        .CheckBoxUseExternalRandom.Enabled = False
        .LabelRandomValueCell.Height = 25
        .LabelRandomValueCell.Left = 6
        .LabelRandomValueCell.Top = 120
        .LabelRandomValueCell.Width = 84
        .LabelRandomValueCell.Caption = "Random Cell" & vbNewLine & "(required)"
        .RandCellRequired = True
        .FormulaTemplate = "=_1_ + ( _2_ - _1_ ) " _
            & "* IF( ABS((( _2_ - _1_ ) / ( _1_ - _0_ )) - 1 ) < 0.0001,  " _
            & "NORMINV( _r_, 0, 0.780304146072379 ), " _
            & "((( _2_ - _1_ ) / ( _1_ - _0_ ))^NORMINV( _r_, 0, 0.780304146072379 ) - 1 )" _
            & " / ((( _2_ - _1_ ) / ( _1_ - _0_ )) - 1 ))"
        .Show
    End With
'''    UserFormInsertMyerson.Show
    chkCalcMode
    
End Sub

Public Sub insertNormal(Optional control As IRibbonControl)

    With UserFormInsertDistribution
        .Caption = "Insert Normal Distribution"
        .Label2.Caption = "Mean"
        .Label3.Caption = "Standard Deviation"
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=IF( _1_ = 0, _0_, NORMINV( _r_, _0_, _1_ ))"
        .Show
    End With
'''    UserFormInsertNormal.Show
    chkCalcMode
    
End Sub

Public Sub insertPoisson(Optional control As IRibbonControl)

    Dim s As Variant
    s = ""
    On Error Resume Next
    Err.Clear
    s = ActiveWorkbook.Sheets("PMTable").Name
    If Err <> 0 Then
        MsgBox "Poisson distributions require that the PMTable sheet be present. You can ensure this by initializing the model.", vbExclamation
        Exit Sub
    End If
    On Error GoTo 0
    ActiveWorkbook.Names.Add "PM_1.66", "={-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20," _
        & "21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50," _
        & "51,52,53,54,55,56,57,58,59,60,61,62,63,64}"
    
    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Poisson Distribution"
        .Label2.Caption = "Lambda"
        .Label3.Visible = False: .RefEdit3.Enabled = False: .RefEdit3.Visible = False
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .CheckBoxUseExternalRandom = True
        .CheckBoxUseExternalRandom.Enabled = False
        .LabelRandomValueCell.Height = 25
        .LabelRandomValueCell.Left = 6
        .LabelRandomValueCell.Top = 120
        .LabelRandomValueCell.Width = 84
        .LabelRandomValueCell.Caption = "Random Cell" & vbNewLine & "(required)"
        .RandCellRequired = True
        .IsArray = True
        .FormulaTemplate = "=IF( _0_ > 20, INT( NORM.INV( _r_, _0_, SQRT( _0_ ))), " & _
           "MATCH( _r_, IF( PM_1.66 = -1, 0, POISSON( PM_1.66, " & _
           "_0_, TRUE ))) - 1 )"
        .Show
    End With
'''    UserFormInsertPoisson.Show
    chkCalcMode

End Sub

Public Sub insertResample(Optional control As IRibbonControl)

    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Resampled Distribution"
        .Label2.Caption = "Data to Resample"
        .Label3.Visible = False: .RefEdit3.Enabled = False: .RefEdit3.Visible = False
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=INDEX( _a0_, INT( _r_ * ROWS( _a0_ ) * COLUMNS( _a0_ )) + 1 )"
        .Show
    End With
'''    UserFormInsertResample.Show
    chkCalcMode
    
End Sub

Public Sub insertTriang(Optional control As IRibbonControl)

    Load UserFormInsertDistribution
    With UserFormInsertDistribution
        .Caption = "Insert Triangular Distribution"
        .Label2.Caption = "Minimum"
        .RefEdit2.Text = "0"
        .Label3.Caption = "Most Likely"
        .RefEdit3.Text = "1"
        .Label4.Caption = "Maximum"
        .RefEdit4.Text = "2"
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .CheckBoxUseExternalRandom = True
        .CheckBoxUseExternalRandom.Enabled = False
        .LabelRandomValueCell.Height = 25
        .LabelRandomValueCell.Left = 6
        .LabelRandomValueCell.Top = 120
        .LabelRandomValueCell.Width = 84
        .LabelRandomValueCell.Caption = "Random Cell" & vbNewLine & "(required)"
        .RandCellRequired = True
        .FormulaTemplate = "=IF( _0_ > _1_, NA(), IF( _1_ > _2_, NA(), IF( _0_ = _2_, _1_, " _
            & "IF( _r_ < (( _1_ - _0_ ) / ( _2_ - _0_ )), " _
            & "_0_ + SQRT( _r_ * ( _1_ - _0_ ) * ( _2_ " _
            & "- _0_ )), _2_ - SQRT(( 1 - _r_ ) * ( _2_ " _
            & "- _0_ ) * ( _2_ - _1_ ))))))"
        .Show
    End With
'''    UserFormInsertTriang.Show
    chkCalcMode
    
End Sub

Public Sub insertT(Optional control As IRibbonControl)

    With UserFormInsertDistribution
        .Caption = "Insert T Distribution"
        .Label2.Caption = "Alpha"
        .Label3.Visible = False: .RefEdit3.Enabled = False: .RefEdit3.Visible = False
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=T.INV.2T( _r_, _0_ )"
        .Show
    End With
'''    UserFormInsertT.Show
    chkCalcMode
    
End Sub

'Callback for Weibull onAction
Public Sub insertWeibull(control As IRibbonControl)
    
    With UserFormInsertDistribution
        .Caption = "Insert Weibull Distribution"
        .Label2.Caption = "Lambda"
        .Label3.Caption = "K"
        .Label4.Visible = False: .RefEdit4.Enabled = False: .RefEdit4.Visible = False
        .Label5.Visible = False: .RefEdit5.Enabled = False: .RefEdit5.Visible = False
        .FormulaTemplate = "=_0_ * -LN( 1 - _r_ ) ^ ( 1 / _1_ )"
        .Show
    End With
'''    UserFormInsertWeibull.Show
    chkCalcMode
    
End Sub

#End If

Sub splitSheetAndAddress(sRef As String, sShtName As String, sAddr As String, Optional sWbk As String)
    '
    ' tries to split sRef into a sheet name and cell address
    '
    If InStr(sRef, "!") > 0 Then ' sRef includes a sheet name
        sShtName = Left(sRef, -1 + InStr(sRef, "!"))
        ' trim single quotes, if present
        If Left(sShtName, 1) = "'" Then sShtName = Mid(sShtName, 2, -2 + Len(sShtName))
        ' is there a workbook name?
        If InStr(sShtName, "]") > 0 Then
            sWbk = Left(sShtName, InStr(sShtName, "]"))
            sShtName = Mid(sShtName, 1 + InStr(sShtName, "]"))
        End If
        sAddr = Mid(sRef, 1 + InStr(sRef, "!"))
    Else
        sAddr = sRef
    End If
End Sub

Sub makeCholeskyMatrix(rCorrel As Range, rCholesky As Range, bDoTranspose As Boolean)
' see version 3.4.0 for code
End Sub

Public Sub makeMultiNormal( _
    sDest As String, sMeans As String, sCovars As String, _
    bUserRNG As Boolean, bHdr As Boolean, sRandCell As String, _
    sCholeskyStart As String, sCholeskyEnd As String)
' see version 3.4.0 for code
End Sub
'
' version without checkboxes; interprets cell address to decide fixed-cell vs relative cell
' single cells are fixed, and a range of cells is presumed to be relative
'
Public Sub writeSomeDist(rDest As Range, startVarId As String, bHdr As Boolean, bUsrRnd As Boolean, _
                         bIsArray As Boolean, _
                         sFcn As String, sRandCell As String, aRefStyles() As Long, fcnArgs() As Variant, _
                         Optional nDestRows As Variant, Optional nDestCols As Variant)
    '
    ' writes one or more instances of a formula to generate a pseudo-random distribution
    '
    ' rDest is the destination range for the distribution; it should be a row or column of 1 or more
    ' cells, either 1xN or Nx1 --- or it can be a rectangle if nDestRows and nDestCols specify 1 row, N cols, or vice versa
    '
    ' startVarID is the starting variable ID for HDR format pseudo-random numbers; it should evaluate
    ' to a long
    '
    ' bHdr is a flag to tell whether to use HDR pseudo-randoms or Excels RAND() function
    '
    ' bIsArray is a flag telling if the formula should be an array formula (ctl-shift-enter) or
    ' a standard formula
    '
    ' sFcn is a dummy call of the inverse formula for the distribution, with args numbered in the order
    ' in which they are specified in fcnArgs().  For instance, if you are writing a normal, sFcn will
    ' be something like "=NORMINV( _r_, _0_, _1_ )"
    ' for a binomial, you'd have "=BINOM.INV( _0_, _1_, _r_ )"
    ' for a triangular, you'd have something more complicated
    '
    ' placeholders of the form _a0_, etc, represent arguments that are not single cells but arrays of data.
    ' as of july 30, only used in the Resample distribution
    '
    ' sRandCell is the address of the cell where the rand function, either RAND() or the HDR expression,
    ' should go. If it's blank, the rand function is put where the _r_ placeholder is. Otherwise,
    ' put sRandCell in the _r_ placeholder, and the rand function in the cell specified by sRandCell.
    '
    ' caller will ensure that sRandCell is either "" or an actual cell address
    '
    ' aRefStyles()  is the absolute/relative reference type of the args in fcnArgs (below), either xlAbsolute, xlAbsRowRelColumn,
    ' xlRelRowAbsColumn, or xlRelative. aRefStyles(4) = ref type of sRandCell, aRefStyles(5) = ref type of startVarID
    '
    ' if aRefStyle is 0, then we do a special default behavior: addresses will be relative unless
    ' the Distribution range has two or more cells, and the field or argument being addressed is a single cell.
    ' Except Array parameters are a bit more complicated: I use absolute addresses unless the array has as
    ' many columns (respectively, rows) as the destination row (column) has, in which case I use relative addressing,
    ' but use each column (resp row) as a separate array argument, rather than using the whole rectangular array.
    '
    ' fcnArgs are the addresses, or constant values, of the arguments to the function call,
    ' listed in order _0_, _1_, _2_, ...
    '
    Dim nVarId As Long, f0 As String, f As String, c As Range, calcMode As Variant
    Dim sVarIdR1C1 As String, r0 As String, r As String, sRandCellR1C1 As String
    Dim rRandRange As Range, bFixedRandCell As Boolean, rPrngCell As Range
    
    If IsMissing(nDestRows) Or IsMissing(nDestCols) Then
        If rDest.Rows.Count > 1 And rDest.Columns.Count > 1 Then
            MsgBox "Select a single row or column", vbExclamation, "SIPmath"
            Exit Sub
        Else
            nDestRows = rDest.Rows.Count
            nDestCols = rDest.Columns.Count
        End If
    Else
    End If
    
    calcMode = Application.Calculation
    Application.Calculation = xlCalculationManual
    
    Dim rParam As Range
    Dim rTest As Range, nArg As Long, sArg As String, nRowOff As Long, nColOff As Long
    Dim ufYNYta As UserFormYesNoYestoall, nUfResult As Long, bYesToAll As Boolean
    Dim vDummy As Variant, vArrayParam As Variant, vEndParam As Variant
    
    ' look for array parameters, named _a0_, etc
    ' these would not need to be resized since they are arrays.
    
    If UBound(fcnArgs) < LBound(fcnArgs) Then
        vArrayParam = Array()
    Else
        ReDim vArrayParam(LBound(fcnArgs) To UBound(fcnArgs)) As Boolean
        If InStr(sFcn, "_a") <> 0 Then
            For nArg = 0 To UBound(fcnArgs) - LBound(fcnArgs)
                If InStr(sFcn, "_a" & Format(nArg, "0")) <> 0 Then
                    vArrayParam(nArg + LBound(fcnArgs)) = True
                End If
            Next nArg
        End If
    End If
    '
    ' now vArrayParam() tells if parameter # N is an array. That is, if the entire array
    ' is used to evaluate the function, vs. just one element of the array per instance of the function.
    
    ' look for "end" parameters, which are to be used as the end corner of a range specification, and
    ' should NOT use any external workbook or sheet names.
    '
    If UBound(fcnArgs) < LBound(fcnArgs) Then
        vEndParam = Array()
    Else
        ReDim vEndParam(LBound(fcnArgs) To UBound(fcnArgs)) As Boolean
        If InStr(sFcn, "_e") <> 0 Then
            For nArg = 0 To UBound(fcnArgs) - LBound(fcnArgs)
                If InStr(sFcn, "_e" & Format(nArg, "0")) <> 0 Then
                    vEndParam(nArg + LBound(fcnArgs)) = True
                End If
            Next nArg
        End If
    End If
    '
    ' convert arguments that are range addresses to R1C1 form, using relative or absolute addressing as specified
    ' by the aRefStyle()
    '
    Dim bRowAbs As Boolean, bColAbs As Boolean, bSheetNeeded As Boolean
    Set ufYNYta = New UserFormYesNoYestoall
    On Error Resume Next
    For nArg = LBound(fcnArgs) To UBound(fcnArgs)
        Err.Clear
        Set rParam = Range(fcnArgs(nArg))
        If Err = 0 Then ' it's a range, so  convert cell address to r1c1 addressing
            vDummy = Names(fcnArgs(nArg)).RefersTo ' is arg a defined name?
            If Err <> 0 Then ' no, so convert the address
                bSheetNeeded = (rParam.Parent.Name <> rDest.Parent.Name) Or (rParam.Parent.Parent.Name <> rDest.Parent.Parent.Name)
                bRowAbs = (aRefStyles(nArg) < 3)
                bColAbs = ((aRefStyles(nArg) Mod 2) = 1)
                If vArrayParam(nArg) Then ' for array parameters convert the whole range
                    If aRefStyles(nArg) > 0 Then
                        fcnArgs(nArg) = rParam.Address(bRowAbs, bColAbs, xlR1C1, bSheetNeeded, rDest)
                    Else ' no ref style specified, so try to do something reasonable
                        If (nDestCols > 1 And nDestCols = rParam.Columns.Count) _
                        Or (nDestRows > 1 And nDestRows = rParam.Rows.Count) _
                        Then ' use relative addressing, treat first column / row of the array rectangle as an argument
                            If nDestCols > 1 Then
                                fcnArgs(nArg) = rParam.Columns(1).Address(1, 0, xlR1C1, bSheetNeeded, rDest)
                            Else
                                fcnArgs(nArg) = rParam.Rows(1).Address(0, 1, xlR1C1, bSheetNeeded, rDest)
                            End If
                        Else
                            fcnArgs(nArg) = rParam.Address(1, 1, xlR1C1, bSheetNeeded, rDest)
                        End If
                    End If
                ElseIf vEndParam(nArg) Then ' convert to r1c1 only, don't add sheet or workbook value
                    If aRefStyles(nArg) > 0 Then
                        fcnArgs(nArg) = rParam(1).Address(bRowAbs, bColAbs, xlR1C1, False, rDest)
                    Else ' no ref style specified, so try to do something reasonable
                        If rDest.Count > 1 And rParam.Count = 1 Then
                            fcnArgs(nArg) = rParam(1).Address(1, 1, xlR1C1, False, rDest)
                        Else
                            fcnArgs(nArg) = rParam(1).Address(0, 0, xlR1C1, False, rDest)
                        End If
                    End If
                Else ' for non-array parameters convert only the address of the 1st cell in the range
                    If aRefStyles(nArg) > 0 Then
                        fcnArgs(nArg) = rParam(1).Address(bRowAbs, bColAbs, xlR1C1, bSheetNeeded, rDest)
                    Else ' no ref style specified, so try to do something reasonable
                        If rDest.Count > 1 And rParam.Count = 1 Then
                            fcnArgs(nArg) = rParam(1).Address(1, 1, xlR1C1, bSheetNeeded, rDest)
                        Else
                            fcnArgs(nArg) = rParam(1).Address(0, 0, xlR1C1, bSheetNeeded, rDest)
                        End If
                    End If
                End If ' vArrayParam(nArg)
            End If ' Err <> 0
        End If ' Err = 0
    Next nArg
    '
    ' convert sRandCell (if present) to R1C1
    '
    If sRandCell <> "" Then
        bRowAbs = (aRefStyles(4) < 3)
        bColAbs = ((aRefStyles(4) Mod 2) = 1)
        Err.Clear
        Set rRandRange = Range(sRandCell)
        If aRefStyles(4) > 0 Then
            ' need to find out if the cell should be regarded as "fixed", i.e. not relative. This is true if the
            ' randcell row is $, and the rDest is a column, or vice versa
            bFixedRandCell = (bRowAbs And nDestRows > 1) Or (bColAbs And nDestCols > 1)
        Else ' no ref style specified, so try to do something reasonable
            bFixedRandCell = rDest.Count > 1 And rRandRange.Count = 1
        End If
        If Err = 0 Then ' randcell is actually a range, so convert address to r1c1
            bSheetNeeded = (rRandRange.Parent.Name <> rDest.Parent.Name) Or (rRandRange.Parent.Parent.Name <> rDest.Parent.Parent.Name)
            nRowOff = Range(sRandCell)(1, 1).row - rDest(1, 1).row
            nColOff = Range(sRandCell)(1, 1).Column - rDest(1, 1).Column
            vDummy = Names(sRandCell).RefersTo ' is sRandCell a defined name?
            If Err = 0 Then
                bFixedRandCell = True
            Else ' no, so convert it to r1c1
                If aRefStyles(4) > 0 Then
                    sRandCellR1C1 = rRandRange(1).Address(bRowAbs, bColAbs, xlR1C1, bSheetNeeded, rDest(1, 1))
                Else ' no ref style so try to do something reasonable
                    If bFixedRandCell Then
                        sRandCellR1C1 = rRandRange(1).Address(1, 1, xlR1C1, bSheetNeeded, rDest(1, 1))
                    Else
                        sRandCellR1C1 = rRandRange(1).Address(0, 0, xlR1C1, bSheetNeeded, rDest(1, 1))
                    End If
                End If
            End If ' Err = 0
        End If ' Err = 0
    End If ' sRandCell <> ""
    On Error GoTo 0
    
    f0 = sFcn ' e.g. "=BINOM.INV( _0_, _1_, _r_ )"
    '
    ' among other things, convert sVarID to R1C1
    '
    If bHdr Then ' using Hubbard random function
        bRowAbs = (aRefStyles(5) < 3)
        bColAbs = ((aRefStyles(5) Mod 2) = 1)
        On Error Resume Next
        Err.Clear
        Set rTest = Range(startVarId)
        If Err = 0 Then  ' startvarid is a range, so put in the range address in the formula
            bSheetNeeded = (rTest.Parent.Name <> rDest.Parent.Name) Or (rTest.Parent.Parent.Name <> rDest.Parent.Parent.Name)
            If aRefStyles(5) > 0 Then
                If sRandCell = "" Then
                    sVarIdR1C1 = Range(startVarId).Resize(1, 1).Address(bRowAbs, bColAbs, xlR1C1, bSheetNeeded, rDest(1, 1))
                Else
                    sVarIdR1C1 = Range(startVarId).Resize(1, 1).Address(bRowAbs, bColAbs, xlR1C1, bSheetNeeded, Range(sRandCell)(1, 1))
                End If
            Else ' no ref style specified so try to do something reasonable
                If rDest.Count > 1 And rTest.Count = 1 Then
                    bRowAbs = True
                    bColAbs = True
                Else
                    bRowAbs = False
                    bColAbs = False
                End If
                If sRandCell = "" Then
                    sVarIdR1C1 = Range(startVarId).Resize(1, 1).Address(bRowAbs, bColAbs, xlR1C1, bSheetNeeded, rDest(1, 1))
                Else
                    sVarIdR1C1 = Range(startVarId).Resize(1, 1).Address(bRowAbs, bColAbs, xlR1C1, bSheetNeeded, Range(sRandCell)(1, 1))
                End If
            End If
        Else
            nVarId = startVarId ' otherwise, use the constant value
        End If
        Err.Clear
        On Error GoTo 0
        If sRandCell = "" Then
            f0 = Replace(f0, "_r_", "( MOD((( MOD( #VarId#^2 + #VarId#*(PM_Index+1e7), 99999989 )) + 1000007 ) * (( MOD( (PM_Index+1e7)^2 + (PM_Index+1e7) * ( MOD( #VarId#^2 + #VarId#*(PM_Index+1e7), 99999989 )), 99999989 )) + 1000013 ), 2147483647 ) + 0.5 ) / 2147483647")
            If sVarIdR1C1 <> "" Then f0 = Replace(f0, "#VarId#", "(" & sVarIdR1C1 & "+1e6)")
        Else
            '
            ' we were given a cell address to hold the PRNG value.
            ' this can be either
            '    1, a single cell, so we use only that cell, and only a single VarID
            ' or 2, a range, so we use each cell in that range, offset to the same relative position
            '       with respect to the destination cells, (and we must add 1 to the VarID in each succesive cell)
            '
            ' this should be already taken care of by whether the SRandCellR1C1 is an absolute or relative
            ' address, but we will have to get the VarID value right later
            '
            f0 = Replace(f0, "_r_", sRandCellR1C1)
            r0 = "=( MOD((( MOD( #VarId#^2 + #VarId#*(PM_Index+1e7), 99999989 )) + 1000007 ) * (( MOD( (PM_Index+1e7)^2 + (PM_Index+1e7) * ( MOD( #VarId#^2 + #VarId#*(PM_Index+1e7), 99999989 )), 99999989 )) + 1000013 ), 2147483647 ) + 0.5 ) / 2147483647"
            If sVarIdR1C1 <> "" Then r0 = Replace(r0, "#VarId#", "(" & sVarIdR1C1 & "+1e6)")
        End If
    Else
        If sRandCell = "" Then
            f0 = Replace(f0, "_r_", "RAND()")
        Else
            r0 = "=RAND()"
            f0 = Replace(f0, "_r_", sRandCellR1C1)
        End If
    End If
    
    Dim b2ndTimeThru As Boolean
    bYesToAll = False
    For Each c In rDest
        If Not IsEmpty(c) And Not bYesToAll Then
            ufYNYta.Message = "The cell " & c.Address(0, 0) & " is not empty. " _
                & "Do you want to over-write it with a distribution formula?"
            ufYNYta.Show
            bYesToAll = (ufYNYta.Result = 2)
            If ufYNYta.Result = 0 Then ' result 0 = cancel
                Unload ufYNYta
                Exit Sub
            End If
        End If
        If bHdr And sVarIdR1C1 = "" Then
            '
            ' we are using HDR counter-based PRNG and the VarID cell is "", so that means
            ' we must put the VarId value used by HDR directly into the distribution formula
            ' or the PRNG formula, depending on whether we are putting the RNG in a separate cell
            '
            f = Replace(f0, "#VarId#", "(" & nVarId & "+1e6)")
            r = Replace(r0, "#VarId#", "(" & nVarId & "+1e6)")
            If Not bFixedRandCell Then nVarId = nVarId + 1
        Else
            f = f0
            r = r0
        End If

#If Mac Then
        If bIsArray Then
            c.FormulaR1C1 = f
            c.FormulaArray = c.Formula
        Else
            c.FormulaR1C1 = f
            Application.ScreenUpdating = True
            c.Offset(1, 1).Select
            c.Select
            Application.ScreenUpdating = False
        End If
#Else
        If bIsArray Then
            c.FormulaArray = f
        Else
            c.FormulaR1C1 = f
        End If
#End If
        '
        ' replace _N_ with cell addresses or constants from argument list
        '
        Application.ReferenceStyle = xlR1C1
        For nArg = LBound(fcnArgs) To UBound(fcnArgs)
#If Mac Then
            c.Activate
            ExecuteExcel4Macro "FORMULA.REPLACE(""_" & Format(nArg, "0") & "_"",""" & fcnArgs(nArg) _
                & """,2,1,TRUE,FALSE,,FALSE,FALSE,FALSE,FALSE)"
            ExecuteExcel4Macro "FORMULA.REPLACE(""_a" & Format(nArg, "0") & "_"",""" & fcnArgs(nArg) _
                & """,2,1,TRUE,FALSE,,FALSE,FALSE,FALSE,FALSE)"
            ExecuteExcel4Macro "FORMULA.REPLACE(""_e" & Format(nArg, "0") & "_"",""" & fcnArgs(nArg) _
                & """,2,1,TRUE,FALSE,,FALSE,FALSE,FALSE,FALSE)"
#Else
            c.Replace What:="_" & Format(nArg, "0") & "_", Replacement:=fcnArgs(nArg), _
                LookAt:=xlPart, SearchOrder:=xlByRows, _
                MatchCase:=False, SearchFormat:=False, ReplaceFormat:=False
            c.Replace What:="_a" & Format(nArg, "0") & "_", Replacement:=fcnArgs(nArg), _
                LookAt:=xlPart, SearchOrder:=xlByRows, _
                MatchCase:=False, SearchFormat:=False, ReplaceFormat:=False
            c.Replace What:="_e" & Format(nArg, "0") & "_", Replacement:=fcnArgs(nArg), _
                LookAt:=xlPart, SearchOrder:=xlByRows, _
                MatchCase:=False, SearchFormat:=False, ReplaceFormat:=False
#End If
        Next nArg
        Application.ReferenceStyle = xlA1
        If sRandCellR1C1 <> "" And Not bUsrRnd Then
            If bFixedRandCell Then
                Set rPrngCell = rRandRange.Parent.Range(rDest(1, 1).Offset(nRowOff, nColOff).Address)
            Else
                Set rPrngCell = rRandRange.Parent.Range(c.Offset(nRowOff, nColOff).Address)
            End If
            If Not IsEmpty(rPrngCell) And Not bYesToAll And Not (b2ndTimeThru And bFixedRandCell) Then
                ufYNYta.Message = "The cell " & rPrngCell.Address(0, 0) _
                    & " is not empty. Do you want to over-write it with a pseudo-random number formula?"
                ufYNYta.Show
                bYesToAll = (ufYNYta.Result = 2)
                If ufYNYta.Result = 0 Then ' result 0 = cancel
                    Unload ufYNYta
                    Exit Sub
                End If
            End If
            rPrngCell.Formula = r
        End If
        b2ndTimeThru = True
    Next c
    If bFixedRandCell Then nVarId = nVarId + 1
    If bHdr And sVarIdR1C1 = "" Then Names.Add "PM_InitialVariableID", nVarId
    
    Unload ufYNYta
#If Mac Then
    Application.Calculate
#Else
    rDest.Calculate
#End If
    Application.Calculation = calcMode
    
End Sub

Sub placeholder()

End Sub
'
' function skeleton for the triang ls as follows:
' =IF( _r_ < (( _2_ - _0_ ) / ( _1_ - _0_ )),
'   _0_ + SQRT( _r_ * ( _2_-_0_ ) * ( _1_ - _0_ )),
'   _1_ - SQRT(( 1 - _r_ ) * ( _1_ - _0_ ) * ( _1_ - _2_ )))
'
' how do I deal with _r_ and the rand storage cell that may be needed?
'
' if the rand storage cell range is present, then
' copy the rand function, either =RAND() or the HDR function, into the cell (using relative addressing
' and relative var id addressing)
' then replace _r_ with relative address of the rand storage cell
'
' if no range is present, then bHdr had better be true; or else _r_ must appear only once in sFcn.
' don't copy anything to any rand cell, just replace _r_ with the HDR function
'
Attribute VB_Name = "ModulePatterns"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit
'
' code to find text patterns without using the RegEx library (so it'll work on the Mac)
'
Function test_FName(s As String, sFName As String) As Boolean
'
' tests s to see if it begins with a function named sFName
' for instance if sFName = "INDEX(", test for "=INDEX(" or "= INDEX(", etc
'
    Dim sEqFName As String, n As Long, sTest As String
    
    sEqFName = "=" & sFName
    If Len(s) < Len(sEqFName) Then
        test_FName = False
        Exit Function
    End If
    If Left(s, 1) <> "=" Then
        test_FName = False
        Exit Function
    End If
    '
    ' now see if the string contains sFName
    n = InStr(s, sFName)
    If n = 0 Then
        test_FName = False
        Exit Function
    End If
    sTest = Mid(s, 2, n - 2)
    '
    ' sTest should be everything between the opening = sign and the sEqFName
    ' hopefully sTest is whitespace only, whitespace being blanks and line-feeds.
    ' I don't know any nice way to check other than to check if each char is a blank or line feed.
    '
    Dim i As Long, c As String
    For i = 1 To Len(sTest)
        c = Mid(sTest, i, 1)
        If c <> " " And c <> vbLf Then Exit For ' this leaves I <= len(sTest)
    Next i
    If i <= Len(sTest) Then ' we exited the For-loop early, because we found non-whitespace
        test_FName = False
        Exit Function
    End If
    
    test_FName = True
    
End Function

Function first_arg(sF As String) As String
    '
    ' finds first argument of an excel formula of the form "=<FNAME>( <arg> , ..."
    ' or "=<FNAME>( <arg> )"
    ' where the whitespace is optional
    '
    ' so look for an open paren, look the next next comma or close paren, and return
    ' the bit in between, with whitespace trimmed
    '
    Dim nOpnPrn As Long, nEndArg As Long
    
    nOpnPrn = InStr(sF, "(")
    If nOpnPrn = 0 Then
        first_arg = sF
        Exit Function
    End If
    nEndArg = InStr(nOpnPrn, sF, ",")
    If nEndArg = 0 Then nEndArg = InStr(nOpnPrn, sF, ")")
    If nEndArg = 0 Then
        first_arg = sF
        Exit Function
    End If
    first_arg = Trim(Mid(sF, nOpnPrn + 1, nEndArg - nOpnPrn - 1))
    
End Function
Attribute VB_Name = "ModuleRibbonControl"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit

#If Mac And MAC_OFFICE_VERSION < 15 Then
Public YourRibbon
#Else

Public YourRibbon As IRibbonUI
Public MyTag As String

#End If

#If Mac Then
    '
    ' saving Ribbon handle doesn't work for the Mac
    '
    ' need to put stub CopyMemory so Mac will compile ok
    Public Sub CopyMemory(ByRef destination, ByRef source, ByVal length As Long)
    End Sub
#Else

#If VBA7 Then
    Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByRef destination As Any, ByRef source As Any, ByVal length As Long)
#Else
    Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByRef destination As Any, ByRef source As Any, ByVal length As Long)
#End If

#End If


#If Mac And MAC_OFFICE_VERSION < 15 Then
#Else

Public Sub SIPmath326RibbonOnLoad(ribbon As IRibbonUI)
   ' Store pointer to IRibbonUI
    Set YourRibbon = ribbon
#If Not Mac Then
    ThisWorkbook.Names.Add "SIPmathRibbon", ObjPtr(ribbon)
#End If

End Sub

#End If

#If Not Mac Then

#If VBA7 Then
Function GetRibbon(ByVal lRibbonPointer As LongPtr) As Object
#Else
Function GetRibbon(ByVal lRibbonPointer As Long) As Object
#End If
        Dim objRibbon As Object
        CopyMemory objRibbon, lRibbonPointer, LenB(lRibbonPointer)
        Set GetRibbon = objRibbon
        Set objRibbon = Nothing
End Function

#End If

Sub RefreshRibbon()
    If YourRibbon Is Nothing Then
#If Not Mac Then
        On Error Resume Next
        Set YourRibbon = GetRibbon(Application.Evaluate(ThisWorkbook.Names("SIPmathRibbon").RefersTo))
#End If
        If YourRibbon Is Nothing Then
            MsgBox "The Ribbon handle was lost and could not be restored. To restore the ribbon, restart Excel.", vbCritical, APP_NAME
        End If
        YourRibbon.Invalidate
    Else
        YourRibbon.Invalidate
    End If
End Sub

#If Mac And MAC_OFFICE_VERSION < 15 Then
#Else

Sub getImpLibVisible(control As IRibbonControl, ByRef returnedVal)
    
#If Mac Then
    returnedVal = False
#Else
    returnedVal = True
#End If

End Sub

#End If

Sub getExportVisible(control As IRibbonControl, ByRef returnedVal)
#If Mac Then
    returnedVal = False
#Else
    returnedVal = True
#End If
End Sub

Sub getExportImageMso(control As IRibbonControl, ByRef returnedVal)
#If Mac Then
    returnedVal = "ConvertTableToText"
#Else
    returnedVal = "ExportTextFile"
#End If
End Sub

Attribute VB_Name = "ModuleSettings"
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
#If Mac And MAC_OFFICE_VERSION < 15 Then
    '
    ' feature not available on Mac
    '
#Else

Option Explicit

Public Sub sipmathSettings(Optional control As IRibbonControl)
    UserFormSettings.Show
End Sub

#End If

Sub chkCalcMode()
    
    On Error Resume Next
    'If [=PM_autocalc] Then
    If Application.Evaluate(ThisWorkbook.Names("PM_autocalc").RefersTo) Then
        If Application.Calculation <> xlCalculationAutomatic Then
            'If [=PM_warnAutoCalc] Then
            If Application.Evaluate(ThisWorkbook.Names("PM_warnAutoCalc").RefersTo) Then
                UserFormCheckCalcMode.Show
            End If
            Application.Calculation = xlCalculationAutomatic
        End If
    End If
    Application.ReferenceStyle = xlA1
    
End Sub
Attribute VB_Name = "REgistryTools"
#If Mac Then
    '
    ' no Windows registry on the mac, so no need for these
    '
#Else

Option Explicit

#If VBA7 And Win64 Then
    
    Private Declare PtrSafe Function RegOpenKeyA Lib "ADVAPI32.DLL" _
        (ByVal hKey As LongPtr, ByVal lpSubKey As String, _
        phkResult As LongPtr) As Long
        
    Private Declare PtrSafe Function RegCloseKey Lib "ADVAPI32.DLL" _
        (ByVal hKey As LongPtr) As Long
    
    Private Declare PtrSafe Function RegSetValueExA Lib "ADVAPI32.DLL" _
        (ByVal hKey As LongPtr, ByVal sValueName As String, _
        ByVal dwReserved As Long, ByVal dwType As Long, _
        ByVal sValue As String, ByVal dwSize As Long) As Long
    
    Private Declare PtrSafe Function RegCreateKeyA Lib "ADVAPI32.DLL" _
        (ByVal hKey As LongPtr, ByVal sSubKey As String, _
        ByRef hkeyResult As LongPtr) As Long
        
    Private Declare PtrSafe Function RegQueryValueExA Lib "ADVAPI32.DLL" _
        (ByVal hKey As LongPtr, ByVal sValueName As String, _
        ByVal dwReserved As Long, ByRef lValueType As Long, _
        ByVal sValue As String, ByRef lResultLen As Long) As Long
#Else
    Private Declare Function RegOpenKeyA Lib "ADVAPI32.DLL" _
        (ByVal hKey As Long, ByVal sSubKey As String, _
        ByRef hkeyResult As Long) As Long
    
    Private Declare Function RegCloseKey Lib "ADVAPI32.DLL" _
        (ByVal hKey As Long) As Long
    
    Private Declare Function RegSetValueExA Lib "ADVAPI32.DLL" _
        (ByVal hKey As Long, ByVal sValueName As String, _
        ByVal dwReserved As Long, ByVal dwType As Long, _
        ByVal sValue As String, ByVal dwSize As Long) As Long
    
    Private Declare Function RegCreateKeyA Lib "ADVAPI32.DLL" _
        (ByVal hKey As Long, ByVal sSubKey As String, _
        ByRef hkeyResult As Long) As Long
    
    Private Declare Function RegQueryValueExA Lib "ADVAPI32.DLL" _
        (ByVal hKey As Long, ByVal sValueName As String, _
        ByVal dwReserved As Long, ByRef lValueType As Long, _
        ByVal sValue As String, ByRef lResultLen As Long) As Long
#End If

Sub UpdateRegistryWithTime()
    Dim RootKey As String
    Dim path As String
    Dim RegEntry As String
    Dim RegVal As Date
    Dim LastTime As String
    Dim Msg As String
    
    RootKey = "hkey_current_user"
    path = "software\microsoft\office\14.0\excel\LastStarted"
    RegEntry = "DateTime"
    RegVal = Now()
    
    LastTime = GetRegistry(RootKey, path, RegEntry)
    Select Case LastTime
        Case "Not Found"
            Msg = "This routine has not been executed before."
        Case Else
            Msg = "This routine was lasted executed: " & LastTime
    End Select
    Msg = Msg & Chr(13) & Chr(13)
    
    Select Case WriteRegistry(RootKey, path, RegEntry, RegVal)
        Case True
            Msg = Msg & "The registry has been updated with the current date and time."
        Case False
            Msg = Msg & "An error occured writing to the registry..."
    End Select
    MsgBox Msg, vbInformation, "Registry Demo"
End Sub

Public Function GetRegistry(key, path, ByVal ValueName As String)
'  Reads a value from the Windows Registry

#If VBA7 And Win64 Then
    Dim TheKey As LongPtr
    Dim hKey As LongPtr
#Else
    Dim TheKey As Long
    Dim hKey As Long
#End If
    
    Dim lValueType As Long
    Dim sResult As String
    Dim lResultLen As Long
    Dim ResultLen As Long
    Dim x


    TheKey = -99
    Select Case UCase(key)
        Case "HKEY_CLASSES_ROOT": TheKey = &H80000000
        Case "HKEY_CURRENT_USER": TheKey = &H80000001
        Case "HKEY_LOCAL_MACHINE": TheKey = &H80000002
        Case "HKEY_USERS": TheKey = &H80000003
        Case "HKEY_CURRENT_CONFIG": TheKey = &H80000004
        Case "HKEY_DYN_DATA": TheKey = &H80000005
    End Select
    
'   Exit if key is not found
    If TheKey = -99 Then
        GetRegistry = "Not Found"
        Exit Function
    End If

    If RegOpenKeyA(TheKey, path, hKey) <> 0 Then _
        x = RegCreateKeyA(TheKey, path, hKey)
    
    sResult = Space(100)
    lResultLen = 100
    
    x = RegQueryValueExA(hKey, ValueName, 0, lValueType, _
    sResult, lResultLen)
        
    Select Case x
        Case 0: GetRegistry = Left(sResult, lResultLen - 1)
        Case Else: GetRegistry = "Not Found"
    End Select
    
    RegCloseKey hKey
End Function

Private Function WriteRegistry(ByVal key As String, _
    ByVal path As String, ByVal entry As String, _
    ByVal value As String)
    
#If VBA7 And Win64 Then
    Dim TheKey As LongPtr
    Dim hKey As LongPtr
#Else
    Dim TheKey As Long
    Dim hKey As Long
#End If
    
    
    Dim lValueType As Long
    Dim sResult As String
    Dim lResultLen As Long
    Dim x
    
   
    TheKey = -99
    Select Case UCase(key)
        Case "HKEY_CLASSES_ROOT": TheKey = &H80000000
        Case "HKEY_CURRENT_USER": TheKey = &H80000001
        Case "HKEY_LOCAL_MACHINE": TheKey = &H80000002
        Case "HKEY_USERS": TheKey = &H80000003
        Case "HKEY_CURRENT_CONFIG": TheKey = &H80000004
        Case "HKEY_DYN_DATA": TheKey = &H80000005
    End Select
    
'   Exit if key is not found
    If TheKey = -99 Then
        WriteRegistry = False
        Exit Function
    End If

'   Make sure  key exists
    If RegOpenKeyA(TheKey, path, hKey) <> 0 Then
        x = RegCreateKeyA(TheKey, path, hKey)
    End If

    x = RegSetValueExA(hKey, entry, 0, 1, value, Len(value) + 1)
    If x = 0 Then WriteRegistry = True Else WriteRegistry = False
End Function


Sub Wallpaper()
    Dim RootKey As String
    Dim path As String
    Dim RegEntry As String
    RootKey = "hkey_current_user"
    path = "Control Panel\Desktop"
    RegEntry = "Wallpaper"
    MsgBox GetRegistry(RootKey, path, RegEntry), vbInformation, path & "\RegEntry"
End Sub

#End If
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'
' Copyright |fffd| 2012-2015 Probability Management, Inc.
'
Option Explicit

#If Mac Then

Private Sub Workbook_BeforeClose(Cancel As Boolean)
    On Error Resume Next
    Application.CommandBars("SIPmathModelerToolsBar").Delete
End Sub

#End If ' Mac

Private Sub Workbook_Open()

    Randomize
    
#If Not Mac Then

    Dim bUseCb As Boolean, bUseAR As Boolean
    
    On Error Resume Next
    '
    '     don't Call notAvailableMsg, but
    '     for Enterprise version put back code from version 3.4.0
    '

#End If

    SIPmathModelerToolsCreateMenu

End Sub


Attribute VB_Name = "UserFormCheckCalcMode"
Attribute VB_Base = "0{210A0B6A-6813-44FB-A30B-0A5B8D6C1881}{4751C647-E7B9-41F6-B7BA-1258E8768584}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub CommandButtonOK_Click()

    ThisWorkbook.Names.Add "PM_autocalc", Not Me.CheckBoxChkAutoCalc
    ThisWorkbook.Names.Add "PM_warnAutoCalc", Not Me.CheckBoxWarnAutoCalc
    Unload Me
    
End Sub

Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            If TypeName(c) <> "ScrollBar" Then
                c.Font.Name = "Lucida Grande"
                c.Font.Size = 10
            End If
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub
Attribute VB_Name = "UserFormDefineOutputs"
Attribute VB_Base = "0{66B49FB1-EC45-4224-9EB7-8D7F966DCBD8}{7500E62A-5325-456A-A86C-03182D27DC43}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Dim outputsDlgMode As Long
Const MULTIPLE_OUTPUTS_MODE As Long = 0
Const PARAMETRIC_MODE As Long = 1
Const PARAMETRIC_DISABLED_MODE As Long = 2

Const DELTA_HEIGHT As Long = 102

Const ALPHABETICAL_CHARS As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
Const NUMERIC_CHARS As String = "0123456789"

Private Sub CommandButtonCancel_Click()
    On Error Resume Next
    Unload Me
End Sub

Private Sub ParametricTableOK()
    Call CommandButtonCancel_Click
    ' see version 3.4.0 for original code
End Sub

Private Sub CommandButtonOK_Click()

    Dim nOCA As Long, nONA As Long ' number of Output Cell Areas, number of Output Name Areas
    
    nOCA = 1
    nONA = 1
    On Error Resume Next
    nOCA = Range(Me.RefEditOutputCells.value).Areas.Count
    nONA = Range(Me.RefEditOutputNames.value).Areas.Count
    On Error GoTo 0
        
    '
    If outputsDlgMode = PARAMETRIC_DISABLED_MODE Then
        Call CommandButtonCancel_Click
        Exit Sub
    End If
    
    If Trim(Me.RefEditOutputNames.value) = "" Then
        MsgBox "Please specify an output name or names.", vbInformation, APP_NAME
    ElseIf nOCA > 1 Or nONA > 1 Then
        MsgBox "Output ranges must be contiguous cells. If you wish to define non-contiguous output cells, you must use a separate press of the Define Output button for each non-contiguous cell.", vbInformation, APP_NAME
    Else
        If outputsDlgMode = PARAMETRIC_MODE Then
            Call ParametricTableOK
        Else
            Call MultipleOutputsTableOK
        End If
    End If
End Sub

Private Sub MultipleOutputsTableOK()

    Dim outputCells As Range, outputNames As Variant, singleCell As Range, L As Long
    Dim calcMode As Variant, maxTrials As Long, outputNamesA As Variant
    Dim libraryFileName As String, lNumberOfBins As Long
    
    On Error Resume Next
    Err.Clear
    libraryFileName = Application.Evaluate(ActiveWorkbook.Names("PM_library_file_name").RefersTo)
    If Err <> 0 Then
        Err.Clear
        libraryFileName = Application.Evaluate(ActiveWorkbook.Names("library_file_name").RefersTo)
    End If
    
    Dim bRandomMode As Boolean
    On Error Resume Next
    bRandomMode = False
    Err.Clear
    bRandomMode = Application.Evaluate(ActiveWorkbook.Names("PM_random_mode").RefersTo)
    If Err <> 0 Then
        Err.Clear
        bRandomMode = Application.Evaluate(ActiveWorkbook.Names("_random_mode").RefersTo)
    End If
    On Error GoTo 0
    If bRandomMode Then
        maxTrials = [=PM_Trials]
    Else
        On Error Resume Next
        maxTrials = Workbooks(libraryFileName).Names("PM_Trials").RefersToRange.value
        If Err <> 0 Then
            MsgBox "SIPmath couldn't read the number of trials from the Library file " & vbNewLine & libraryFileName & vbNewLine & "SIPmath will try to read the number of trials from the current model.", vbInformation, APP_NAME
            Err.Clear
            maxTrials = [=PM_Trials]
            If Err <> 0 Then
                MsgBox "SIPmath couldn't read the number of trials from the current model. The output will not be defined.", vbCritical, APP_NAME
                Exit Sub
            End If
            On Error GoTo 0
        End If
    End If
    
    calcMode = Application.Calculation
    Application.Calculation = xlCalculationManual
    
    On Error GoTo ufdo_moto_reoc_error:
    Set outputCells = Range(Me.RefEditOutputCells.value)
    On Error GoTo 0
    '
    ' see if output cells contain formulas
    ' if not, ask whether to use anyway
    '
    Dim sNoFormula As String
    sNoFormula = ""
    For Each singleCell In outputCells
        If Not singleCell.HasFormula Then
            sNoFormula = vbNewLine & sNoFormula & singleCell.Address
        End If
    Next singleCell
    If sNoFormula <> "" Then
        If vbNo = MsgBox("The following output cells have no formulas. " _
            & "Do you want to use them as output cells anyway?" & sNoFormula, vbYesNo Or vbQuestion, APP_NAME) Then
            Application.Calculation = calcMode
            Exit Sub
        End If
    End If
    '
    ' create output range
    '
    On Error Resume Next
    Dim i As Long
    '
    ' see if output names value is an existing defined name
    '
    Dim rt As String
    Err.Clear
    rt = Names(Me.RefEditOutputNames.value).RefersTo
    If Err = 0 Then ' then the OutputNames field refers to a defined name that already exists
        If Me.CheckBoxDeleteExistingOutputs.value = True Then
            Names(Me.RefEditOutputNames.value).Delete
        Else
            rt = "A range named '" & Me.RefEditOutputNames.value & "' already exists. Do you wish to over-write it?"
            If vbNo = MsgBox(rt, vbQuestion Or vbYesNo, APP_NAME) Then
                Application.Calculation = calcMode
                Exit Sub
            Else
                Names(Me.RefEditOutputNames.value).Delete
            End If
        End If
    End If
    Err.Clear
    Set outputNames = Range(Me.RefEditOutputNames.value)
    If Err = 0 Then ' no error, so outputNames is a range address
                    ' (and not an existing range name, since I checked for that above)
        ReDim outputNamesA(1 To outputNames.Count)
        For i = 1 To outputNames.Count
            outputNamesA(i) = outputNames(i).Text
        Next
    Else '            field isn't a valid range, so presumably names are literal
        outputNamesA = Split("," & Me.RefEditOutputNames.value, ",") ' prepend "," delimiter to fake 1-based array
    End If
    '
    ' check that # names = # outputs
    '
    Dim nNamesCount As Long
    nNamesCount = UBound(outputNamesA) - LBound(outputNamesA)
    If LBound(outputNamesA) > 0 Then nNamesCount = nNamesCount + 1
    If outputCells.Cells.Count <> nNamesCount Then
        MsgBox "The number of output names must equal the number of outputs", vbInformation, APP_NAME
        Application.Calculation = calcMode
        Exit Sub
    End If
    '
    ' check for valid characters, existing names, names that are cell references
    '
    Dim j As Long, convertChars As Boolean, alreadyDefinedNames As String, cellRefs As String
    Dim rTest As Range
    
    convertChars = False
    alreadyDefinedNames = ""
    For i = LBound(outputNamesA) To UBound(outputNamesA)
        '
        ' names must start with a letter or "_", and must contain only letters, digits, periods, or "_"
        '
        For j = 1 To Len(outputNamesA(i))
            If (j = 1 And 0 = InStr(ALPHABETICAL_CHARS & "_", Mid$(outputNamesA(i), j, 1))) _
            Or (j > 1 And 0 = InStr(ALPHABETICAL_CHARS & NUMERIC_CHARS & "_" & ".", Mid$(outputNamesA(i), j, 1))) Then
                If Not convertChars Then
                    If vbYes = MsgBox("One or more of the output names has an invalid character." & vbNewLine & "SIPmath can convert invalid names to valid range names by replacing invalid characters with the ""_"" character." & vbNewLine & vbNewLine & "Do you want to do that?", vbQuestion Or vbYesNo, APP_NAME) Then
                        convertChars = True
                    Else
                        MsgBox "Please ensure output names contain only letters, digits, periods, and ""_"" characters.", vbExclamation, APP_NAME
                        Application.Calculation = calcMode
                        Exit Sub
                    End If
                End If
                If j = 1 And 0 <> InStr(NUMERIC_CHARS, Mid$(outputNamesA(i), j, 1)) Then
                    ' 1st char is number, so just put a _ in front
                    outputNamesA(i) = "_" & outputNamesA(i)
                ElseIf j = 1 And 0 <> InStr(" " & Chr(10), Left(outputNamesA(i), 1)) Then
                    ' 1st char is white space, so remove it and set j back to 0
                    outputNamesA(i) = Mid(outputNamesA(i), 2)
                    j = 0
                Else
                    outputNamesA(i) = Left(outputNamesA(i), j - 1) & "_" & Mid$(outputNamesA(i), j + 1)
                End If
            End If
        Next j
        '
        ' see if any of the current output names are existing defined names. If so, make a list of existing names,
        ' and ask user whether to overwrite them.
        '
        Err.Clear
        rt = Names(outputNamesA(i)).RefersTo
        If Err = 0 Then ' then outputNamesA(i) is a defined name that already exists
            alreadyDefinedNames = alreadyDefinedNames & vbNewLine & outputNamesA(i)
            'MsgBox "A range named '" & outputNamesA(i) & "' already exists. Please choose another output name."
            'Exit Sub
        Else
            '
            ' make sure no output names are cell references
            '
            Err.Clear
            Set rTest = Range(outputNamesA(i))
            If Err = 0 Then ' it is the name of a cell (probably)
                cellRefs = cellRefs & vbNewLine & outputNamesA(i)
            End If
        End If
        Err.Clear
    Next i
    If alreadyDefinedNames <> "" And Me.CheckBoxDeleteExistingOutputs.value = False Then
        If vbNo = MsgBox("The following output names are already defined. Do you wish to over-write them?" & alreadyDefinedNames, vbYesNo Or vbQuestion, APP_NAME) Then
            Application.Calculation = calcMode
            Exit Sub
        End If
    End If
    If cellRefs <> "" Then
        MsgBox "The following output names are cell references; please change them to non-cell references." & cellRefs, , APP_NAME
        Application.Calculation = calcMode
        Exit Sub
    End If
    On Error GoTo 0
    '
    ' delete old table if DeleteExistingTable checkbox is checked, and old table is present
    ' ... also delete old output names
    '
    Dim numRows As Long, r As Range
    If Me.CheckBoxDeleteExistingOutputs.value Then
        With ActiveWorkbook.Sheets("PMTable").Range("c4")
            If .HasArray Then
                Set r = ActiveWorkbook.Sheets("PMTable").Range("C2")
                On Error Resume Next
                Do Until IsEmpty(r)
                    ActiveWorkbook.Names(r.value).Delete
                    Set r = r.Offset(0, 1)
                Loop
                On Error GoTo 0
                numRows = .CurrentArray.Rows.Count
                .CurrentArray.Borders.LineStyle = xlNone
                .CurrentArray.Offset(-1, 1).Resize(numRows + 1).Clear
            End If
        End With
    End If
    '
    ' on output tab, put formulas pointing to the defined output cells
    '
    ' find number of columns in existing table, if any
    '
    Dim numCols As Long
    If ActiveWorkbook.Sheets("PMTable").Range("C4").HasArray Then
        numCols = ActiveWorkbook.Sheets("PMTable").Range("C4").CurrentArray.Columns.Count - 1
    Else
        numCols = 0
    End If
    L = 0
    For Each singleCell In outputCells
        ActiveWorkbook.Sheets("PMTable").Range("C3").Offset(0, L + numCols).Formula _
            = "=" & singleCell.Address(External:=True)
        L = L + 1
    Next singleCell
    '
    ' create table. Note width is L+numCols+1, not L+numCols, to allow for the column of indices.
    '
    ActiveWorkbook.Sheets("PMTable").Range("B3").Resize(maxTrials + 1, L + numCols + 1).Table ColumnInput:=ActiveWorkbook.Sheets("PMTable").Range("A1")
    ActiveWorkbook.Sheets("PMTable").Range("B3").Resize(maxTrials + 1, L + numCols + 1).BorderAround xlContinuous, xlThin, , 0
    '
    ' color the data
    '
    Dim rOutputData As Range ' save for use after the For loop, as argument to UserFormGraphs_CommandButtonOK_Click
    Set rOutputData = ActiveWorkbook.Sheets("PMTable").Range("c4").Resize(maxTrials, L + numCols)
    rOutputData.Interior.Color = RGB(197, 217, 241) ' = 15849925
    Set rOutputData = ActiveWorkbook.Sheets("PMTable").Range("c4").Offset(0, numCols).Resize(maxTrials, L)
    For L = L To 1 Step -1
        ActiveWorkbook.Sheets("PMTable").Range("B2").Offset(0, L + numCols).value = outputNamesA(L)
        ActiveWorkbook.Names.Add outputNamesA(L), ActiveWorkbook.Sheets("PMTable").Range("B4").Offset(0, L + numCols).Resize(maxTrials, 1)
    Next L
    ActiveWorkbook.Sheets("PMTable").Range("B2").value = "Index"
    ActiveWorkbook.Sheets("PMTable").Range("B3").value = "Values"
    Application.Calculate
    Application.Calculation = calcMode
    '
    ' see if we said to insert sparklines, and there's a sparklines sheet
    '
    Dim bInsertSparklines As Boolean, bOutputIsRow As Boolean
    
    bInsertSparklines = False
    lNumberOfBins = 10
    On Error Resume Next
    Err.Clear
    ''' v 3.1. 36 bInsertSparklines = [=PM_SparklinesForOutputs]
    ''' v 3.1. 36 If Err <> 0 Then bInsertSparklines = [=SparklinesForOutputs]
    ''' v 3.1. 36 bInsertSparklines = bInsertSparklines And ActiveWorkbook.Sheets(scd).Name = scd
    Err.Clear
    lNumberOfBins = [=PM_SparklinesIONumberOfBins]
    If Err <> 0 Then lNumberOfBins = [=SparklinesIONumberOfBins]
    
    On Error GoTo 0
    '
    ' put in sparklines if wanted
    '
    bOutputIsRow = (Range(Me.RefEditOutputCells.value).Columns.Count > 1)
    ''' v 3.1. 36 If bInsertSparklines Then
    If Me.RefEditSparklineStartCell.value <> "" Then
        conditionalMergeBeforeCharting Me.RefEditOutputCells.value, Me.RefEditSparklineStartCell.value
#If PROJECT = SIPMATH_HISTOGRAM Then
        smh_UserFormGraphs_CommandButtonOK_Click _
            sGraphRanges:=rOutputData.Address(, , , 1), _
            numBins:=lNumberOfBins, bExcelChart:=False, bSparkline:=True, bColumn:=Not bOutputIsRow, _
            bRow:=bOutputIsRow, bChartSelectedData:=True, bDataIsAColumn:=True, bChartSIPmathOutput:=False, _
            bDataNamesInHeadings:=False, _
            sFrequencyDest:=Range(Me.RefEditSparklineStartCell.value).Address(, , , 1), _
            sCumulativeDest:="", oCallingForm:=Me, bIntegerChart:=False, sSparklineType:="Output"
#Else
        smmt_UserFormGraphs_CommandButtonOK_Click _
            sGraphRanges:=rOutputData.Address(, , , 1), _
            numBins:=lNumberOfBins, bExcelChart:=False, bSparkline:=True, bColumn:=Not bOutputIsRow, _
            bRow:=bOutputIsRow, bChartSelectedData:=True, bDataIsAColumn:=True, bChartSIPmathOutput:=False, _
            bDataNamesInHeadings:=False, _
            sFrequencyDest:=Range(Me.RefEditSparklineStartCell.value).Address(, , , 1), _
            sCumulativeDest:="", oCallingForm:=Me, bIntegerChart:=False, sSparklineType:="Output"
#End If
    End If
    
    Unload Me
    Application.Calculation = calcMode
    
    Exit Sub
    
ufdo_moto_reoc_error:
    Application.Calculation = calcMode
    MsgBox "Invalid range in " & Me.LabelOutputCells.Caption & " field.", vbExclamation, APP_NAME
    
End Sub

Private Sub OptionButtonMultipleOutputCells_Click()
    
    If outputsDlgMode = PARAMETRIC_MODE Then
        Me.CheckBoxDeleteExistingOutputs.Visible = True
        Me.CheckBoxDeleteExistingOutputs.Enabled = True
        Me.LabelOutputNames.Caption = "Output Names"
        Me.LabelOutputCells.Caption = "Output Cells"
        Me.LabelParameterCell.Visible = False
        Me.RefEditParameterCell.Visible = False
        Me.RefEditParameterCell.Enabled = False
        Me.LabelParameterName.Visible = False
        Me.RefEditParameterName.Visible = False
        Me.RefEditParameterName.Enabled = False
        Me.LabelParameterRange.Visible = False
        Me.RefEditParameterRange.Visible = False
        Me.RefEditParameterRange.Visible = False
        Me.Frame1.Visible = False
        Me.Frame1.Enabled = False
        Me.RefEditSparklineStartCell.Top = Me.RefEditSparklineStartCell.Top - DELTA_HEIGHT
        Me.LabelSparklineStartCell.Top = Me.LabelSparklineStartCell.Top - DELTA_HEIGHT
        Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top - DELTA_HEIGHT
        Me.CommandButtonOK.Top = Me.CommandButtonOK.Top - DELTA_HEIGHT
        Me.Height = Me.Height - DELTA_HEIGHT
    ElseIf outputsDlgMode = PARAMETRIC_DISABLED_MODE Then
        With Me.LabelOutputNames
            .Width = 66
            .Height = 12
            .TextAlign = fmTextAlignRight
            .Caption = "Output Names"
        End With
        With Me.RefEditOutputNames
            .Visible = True
            .Enabled = True
        End With
        With Me.CheckBoxDeleteExistingOutputs
            .Visible = True
            .Enabled = True
        End With
        With Me.LabelOutputCells
            .Visible = True
            .Visible = True
        End With
        Me.RefEditOutputCells.Enabled = False
        
        Me.LabelSparklineStartCell.Visible = False
        With Me.RefEditSparklineStartCell
            .Visible = True
            .Enabled = True
        End With
    End If
    outputsDlgMode = MULTIPLE_OUTPUTS_MODE

End Sub

Private Sub OptionButtonParametric_Click()

'       see version 3.4.0 for original code
    If outputsDlgMode = MULTIPLE_OUTPUTS_MODE Then
        With Me.LabelOutputNames
            '.Top = .Top - 24
            .Width = Me.InsideWidth - .Left * 2
            .Height = Me.CommandButtonOK.Top - .Top - 10
            .TextAlign = fmTextAlignLeft
            .Caption = "Allows repeating a model with multiple input values. " _
                & "Available in the Enterprise version of SIPmath Tools for Windows." _
                & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information."
        End With
        With Me.RefEditOutputNames
            .Visible = False
            .Enabled = False
        End With
        With Me.CheckBoxDeleteExistingOutputs
            .Visible = False
            .Enabled = False
        End With
        With Me.LabelOutputCells
            .Visible = False
            .Visible = False
        End With
        Me.RefEditOutputCells.Enabled = False
        
        Me.LabelSparklineStartCell.Visible = False
        With Me.RefEditSparklineStartCell
            .Visible = False
            .Enabled = False
        End With
'       see version 3.4.0 for original code
    End If
    outputsDlgMode = PARAMETRIC_DISABLED_MODE

End Sub

Private Sub UserForm_Activate()

    On Error Resume Next
    
    Dim localLibrary As Boolean
    
    Err.Clear
    localLibrary = Application.Evaluate(ActiveWorkbook.Names("PM_local_library").RefersTo)
    If Err <> 0 Then
        Err.Clear
        localLibrary = Application.Evaluate(ActiveWorkbook.Names("local_library").RefersTo)
    End If
''''''''''''''''''
    If Err <> 0 Then
        Me.Hide
        MsgBox "This model does not appear to be initialized. Please use the Initialize button before defining inputs.", vbExclamation, APP_NAME
        On Error Resume Next
        Unload Me
        Exit Sub
    End If
''''''''''''''''''
    If localLibrary Then
        ActiveWorkbook.Names.Add "PM_library_file_name", ActiveWorkbook.Name
        ActiveWorkbook.Names.Add "PM_library_file_path", ActiveWorkbook.path
    End If
    Me.RefEditOutputCells.value = Selection.Address ' (, , , 1)
    If [=PM_DfltChart] Then Me.RefEditSparklineStartCell.value = Me.RefEditOutputCells.value
    Me.RefEditOutputNames.SetFocus
    outputsDlgMode = PARAMETRIC_MODE
    Call OptionButtonMultipleOutputCells_Click
    
End Sub

Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            'c.font.size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub
Attribute VB_Name = "UserFormFromLibrary"
Attribute VB_Base = "0{329231CE-1C28-4BB4-9C1C-63B80C13F715}{D38C2D11-C93F-497C-8745-297D2F4C440F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Dim nameList() As String, firstName(1 To 1) As String, nameCount As Long, listSelections() As Long, selectionCount As Long
Dim filterList() As String
Dim newLibraryName As String

Private Sub CommandButtonOpenLib_Click()
    
    Dim libraryFileName As Variant, L As Long, lastWorkbookName As String, nLibTrials As Long
    Dim nCurrTrials As Long, rTest As Range, nPMTrialsType As Long, sLibraryWorkbookName As String
    Dim nPMTableCols As Long, vCalcMode As Variant, nIndices() As Long, sTableFmla As String
    Dim nIndex As Long, rOutputCell As Range
    
#If Mac Then
    libraryFileName = Application.GetOpenFilename
#Else
    On Error Resume Next
    ChDir [=PM_library_file_path]
    On Error GoTo 0
    libraryFileName = Application.GetOpenFilename("All files (*.*), *.*, Excel files (*.xl*; *.htm; *.html; *.mht; *.mhtml; *.xml; *.odc; *.uxdc; *.ods), *.xl*; *.htm; *.html; *.mht; *.mhtml; *.xml; *.odc; *.uxdc; *.ods, XML files (*.xml; *.sip), *.xml; *.sip", 2, "Browse for library file...")
#End If
    If VarType(libraryFileName) <> vbBoolean Then
        newLibraryName = libraryFileName
        'L = InStrRev(newLibraryName, "\")
        'Me.TextBoxLibraryFileName.value = Mid$(newLibraryName, 1 + L, Len(newLibraryName) - L)
        If Trim(newLibraryName) <> "" Then
            lastWorkbookName = ActiveWorkbook.Name
            'Set lastWorkbook = ActiveWorkbook
            If 0 <> InStr("#xml#sip#", LCase(Right(newLibraryName, 3))) Then
                '
                ' load in an XML SLURP
                '
                ' make a new workbook
                Workbooks.Add
            
                ' create a "controls" tab in the active workbook if necessary
                createControlsTab
            
                ' set up the IVtable stuff as in Marc's version
                setupIVTable
        
                readOneSlurp (newLibraryName), "SLURP"
                
                If Not CheckForLibrary(ActiveWorkbook.Name) Then
                    ActiveWorkbook.Close SaveChanges:=False
                    Exit Sub
                End If
                Workbooks(lastWorkbookName).Names.Add "PM_library_file_name", ActiveWorkbook.Name
                Workbooks(lastWorkbookName).Names.Add "PM_library_file_path", ActiveWorkbook.path
                Workbooks(lastWorkbookName).Names.Add "PM_local_library", False
            Else
                On Error Resume Next
                Err.Clear
                Workbooks.Open newLibraryName
                If Err = 0 Then
                    If Not CheckForLibrary(newLibraryName) Then
                        ActiveWorkbook.Close SaveChanges:=False
                        Exit Sub
                    End If
                    Workbooks(lastWorkbookName).Names.Add "PM_library_file_name", ActiveWorkbook.Name
                    Workbooks(lastWorkbookName).Names.Add "PM_local_library", False
                    Workbooks(lastWorkbookName).Names.Add "PM_library_file_path", ActiveWorkbook.path
                Else
                    MsgBox "SIPmath could not open the specified library file.", vbExclamation, APP_NAME
                End If
            End If
            On Error GoTo 0
            fillInputListBox ActiveWorkbook
            Me.ListBoxMetadata.Clear
            fillMetadataListBox Workbooks(lastWorkbookName)
            nLibTrials = Application.Evaluate(ActiveWorkbook.Names("PM_Trials").RefersTo)
            nCurrTrials = Workbooks(lastWorkbookName).Sheets(1).Evaluate(Workbooks(lastWorkbookName).Names("PM_Trials").RefersTo)
            '
            ' add or update PM_Meta range and PM_Meta_Index range
            '
            Dim numMetaData As Long, metaRangeName As String
            On Error Resume Next
            numMetaData = ActiveWorkbook.Names("PM_Meta").RefersToRange.Cells.Count
            metaRangeName = "Meta"
            If Err <> 0 Then
                Err.Clear
                numMetaData = ActiveWorkbook.Names("PM_IV").RefersToRange.Cells.Count
                metaRangeName = "IV"
            End If
            If Err = 0 Then
                Workbooks(lastWorkbookName).Sheets("PMTable").Range("A3").Resize(numMetaData, 1).FormulaArray _
                    = "=" & ActiveWorkbook.Names("PM_" & metaRangeName).RefersToRange.Address(, , , 1)
                Workbooks(lastWorkbookName).Names.Add "PM_Meta", _
                    Workbooks(lastWorkbookName).Sheets("PMTable").Range("A3").Resize(numMetaData, 1)
                Workbooks(lastWorkbookName).Sheets("PMTable").Range("A3").Offset(numMetaData, 0).Resize(numMetaData, 1).FormulaArray _
                    = "=" & ActiveWorkbook.Names("PM_" & metaRangeName & "_INDEX").RefersToRange.Address(, , , 1)
                Workbooks(lastWorkbookName).Names.Add "PM_Meta_INDEX", _
                    Workbooks(lastWorkbookName).Sheets("PMTable").Range("A3").Offset(numMetaData, 0).Resize(numMetaData, 1)
            End If
            If nLibTrials <> nCurrTrials Then
                If vbYes = MsgBox("This library has " & nLibTrials & " trials. " & vbNewLine & _
                    "Currently the model has " & nCurrTrials & " trials." & vbNewLine & _
                    "Do you want to change the number of trials to " & nLibTrials & "?", _
                    vbYesNo Or vbQuestion, APP_NAME) _
                Then
                    sLibraryWorkbookName = ActiveWorkbook.Name
                    On Error Resume Next
                    Err.Clear
                    Set rTest = Workbooks(lastWorkbookName).Names("PM_Trials").RefersToRange
                    nPMTrialsType = Err
                    On Error GoTo 0
                    If nPMTrialsType = 0 Then ' PM_Trials is a range, so overwrite the range with the new
                                              ' num trials
                        Workbooks(lastWorkbookName).Names.Add "PM_Trials", rTest
                        rTest.value = nLibTrials
                    Else ' PM_Trials is a constant, replace the constant with new value
                        Workbooks(lastWorkbookName).Names.Add "PM_Trials", nLibTrials
                    End If
                    ' adjust PMTable data table (if any) for new size
                    With Workbooks(lastWorkbookName).Sheets("PMTable")
                        '
                        ' delete indices, recreate as many as will be needed
                        '
                        .Range("B4").Resize(nCurrTrials, 1).Clear
                        ReDim nIndices(1 To nLibTrials, 1 To 1)
                        For nIndex = 1 To nLibTrials
                            nIndices(nIndex, 1) = nIndex
                        Next nIndex
                        .Range("B4").Resize(nLibTrials, 1) = nIndices
                        If .Range("C4").HasArray Then
                            vCalcMode = Application.Calculation
                            Application.Calculation = xlCalculationManual
                            nPMTableCols = .Range("C4").CurrentArray.Columns.Count - 1
                            '
                            ' delete =TABLE() formula, hopefully without disturbing row heading formulas
                            '
                            sTableFmla = .Range("C4").FormulaArray
                            .Range("C4").CurrentArray.Offset(1, 1).Resize(nCurrTrials, nPMTableCols).Delete
                            '
                            ' recreate table with appropriate row, column cells
                            '
                            If sTableFmla = "=TABLE(,A1)" Then
                                .Range("B3").Resize(nLibTrials + 1, nPMTableCols + 1).Table _
                                    ColumnInput:=.Range("A1")
                            Else
                                .Range("B3").Resize(nLibTrials + 1, nPMTableCols + 1).Table _
                                    RowInput:=.Range("B1"), ColumnInput:=.Range("A1")
                            End If
                            '
                            ' redefine output ranges to have correct number of rows
                            '
                            For Each rOutputCell In .Range("C2").Resize(1, nPMTableCols)
                                Workbooks(lastWorkbookName).Names.Add _
                                    rOutputCell.value, _
                                    rOutputCell.Offset(2, 0).Resize(nLibTrials, 1)
                            Next rOutputCell
                            Application.Calculation = vCalcMode
                        End If
                    End With
                End If
            End If
            'Set libraryBook = ActiveWorkbook
            'Workbooks(lastWorkbookName).Activate
            Windows(lastWorkbookName).Activate
        End If
    End If
    Me.CommandButtonOpenLib.Enabled = False
    
End Sub

Private Sub RefEditInputDestination_Change()
    Call setDirection
End Sub

Private Sub RefEditNameDestination_Change()
    Call setDirection
End Sub

Private Sub setDirection()

    Dim iDest As Range, nDest As Range
    
    On Error GoTo ufi_sd_err
    
    Set iDest = Range(Me.RefEditInputDestination.value)
    Set nDest = Range(Me.RefEditNameDestination.value)
    
    If (iDest.Column = nDest.Column) And (iDest.row <> nDest.row) Then
        Me.OptionButtonRow = True
    ElseIf (iDest.Column <> nDest.Column) And (iDest.row = nDest.row) Then
        Me.OptionButtonColumn = True
    End If
    
ufi_sd_err:

End Sub

Private Sub CommandButtonCancel_Click()
    On Error Resume Next
    Unload Me
End Sub

Private Sub CheckIfOverwrite(rDest As Range, nUfResult As Long, bYesToAll As Boolean)

    Dim ufYNYta As UserFormYesNoYestoall
    
    nUfResult = 1
    If Not IsEmpty(rDest) And Not bYesToAll Then
        Set ufYNYta = New UserFormYesNoYestoall
        ufYNYta.Message = "This will overwrite cell " & rDest.Address(False, False) & _
            " containing '" & Left(CStr(rDest.Value2), 10) & "...'" & vbNewLine & _
            "Do you wish to do that?"
        ufYNYta.Show
        nUfResult = ufYNYta.Result
        Unload ufYNYta
        bYesToAll = (nUfResult = 2)
    End If
    
End Sub

Private Sub CommandButtonOK_Click()

    Dim libraryBook As Object, L As Long, rowMult As Long, colMult As Long
    Dim rf As Long, cf As Long 'rf = Row oFfset, cf = Col oFfset
    Dim inputCount As Long, sGraphRanges As String, bDataIsColumn As Boolean
    Dim defaultChartDataLocation As Range
    Dim bInsertSparklines As Boolean, lNumberOfBins As Long
    Dim maxTrials As Long
    Dim n As Long
    Dim sMetaName As String
    Dim rPmMeta As Range, rPMIndex As Range
    Dim nMetaIndex As Long, mrf As Long, mcf As Long, nmc As Long
    Dim rDest As Range, bYesToAll As Boolean
    Dim ufYNYta As UserFormYesNoYestoall, nUfResult As Long
    Dim sRN As String ' [R]ange [N]ame
    Dim sTmp As String
    
    On Error Resume Next
    Err.Clear
    Set libraryBook = Workbooks(Application.Evaluate(ActiveWorkbook.Names("PM_library_file_name").RefersTo))
    If Err <> 0 Then
        Err.Clear
        Set libraryBook = Workbooks(Application.Evaluate(ActiveWorkbook.Names("library_file_name").RefersTo))
    End If
    Err.Clear
    Set rPmMeta = libraryBook.Names("PM_Meta").RefersToRange
    If Err <> 0 Then
        Err.Clear
        Set rPmMeta = libraryBook.Names("PM_IV").RefersToRange
    End If
    If Err = 0 Then
        Set rPMIndex = libraryBook.Names("PM_Meta_Index").RefersToRange
        If Err <> 0 Then
            Err.Clear
            Set rPMIndex = libraryBook.Names("PM_IV_Index").RefersToRange
        End If
    End If
    
    Err.Clear
    With Range(Me.RefEditInputDestination.Text)
        If Me.OptionButtonColumn.value = True And .Rows.Count = 1 And .Columns.Count > 1 Then
            If vbNo = MsgBox("You have selected Multiple Inputs as Columns, but the Destination range is a row. Is that what you meant to do?", vbQuestion Or vbYesNo, APP_NAME) Then Exit Sub
        ElseIf Me.OptionButtonRow.value = True And .Rows.Count > 1 And .Columns.Count = 1 Then
            If vbNo = MsgBox("You have selected Multiple Inputs as Rows, but the Destination range is a column. Is that what you meant to do?", vbQuestion Or vbYesNo, APP_NAME) Then Exit Sub
        End If
    End With
    
    On Error GoTo 0
    
    rowMult = 0
    colMult = 0
    If Me.OptionButtonColumn.value Then rowMult = 1 Else colMult = 1
    '
    ' see if we said to insert sparklines and there's a sparklines sheet
    '
    bInsertSparklines = False
    On Error Resume Next
    Err.Clear
    ''' v 3.1.36 bInsertSparklines = [=PM_SparklinesForInputs]
    ''' v 3.1.36 If Err <> 0 Then bInsertSparklines = [=SparklinesForInputs]
    ''' v 3.1.36 bInsertSparklines = bInsertSparklines And ActiveWorkbook.Sheets(scd).Name = scd
    bInsertSparklines = Me.RefEditSparklineStartCell.value <> "" _
        And ActiveWorkbook.Sheets(scd).Name = scd
    On Error GoTo 0
    '
    ' count selected items
    '
    inputCount = 0
    For L = 0 To Me.ListBoxInputRanges.ListCount - 1
        If Me.ListBoxInputRanges.Selected(L) Then
            inputCount = inputCount + 1
        End If
    Next L
    If inputCount = 0 Then
        MsgBox "Please select at least 1 input", vbExclamation, APP_NAME
        Exit Sub
    End If
    '
    ' see if we need to merge the sparkline destination cells
    ' this is based on whether the inputs are going to be in a row or column, and whether
    ' the sparkline destination has multiple rows or columns
    ' args to conditionaMergeBeforeCharting are range addresses
    ' I must synthesize the data range addresses for it to work, and resize the
    ' destination address to have as many rows or columns as are selected
    '
    If bInsertSparklines Then
        If inputCount > 1 Then
            If Me.OptionButtonColumn.value Then
                conditionalMergeBeforeCharting _
                    Range("A1").Resize(inputCount, 1).Address, _
                    Range(Me.RefEditSparklineStartCell.value).Resize(inputCount).Address(, , , 1)
            Else
                conditionalMergeBeforeCharting _
                    Range("A1").Resize(1, inputCount).Address, _
                    Range(Me.RefEditSparklineStartCell.value).Resize(, inputCount).Address(, , , 1)
            End If
        Else
            If Me.OptionButtonColumn.value Then
                conditionalMergeBeforeCharting _
                    Range("A1").Resize(inputCount, 1).Address, _
                    Range(Me.RefEditSparklineStartCell.value).Address(, , , 1)
            Else
                conditionalMergeBeforeCharting _
                    Range("A1").Resize(1, inputCount).Address, _
                    Range(Me.RefEditSparklineStartCell.value).Address(, , , 1)
            End If
        End If
    End If ' bInsertSparklines
    
    Dim bNameUsed As Boolean
    bNameUsed = False
    inputCount = 0
    For L = 0 To Me.ListBoxInputRanges.ListCount - 1
        If Me.ListBoxInputRanges.Selected(L) Then
            rf = inputCount * rowMult
            cf = inputCount * colMult
            
            Set rDest = Range(Me.RefEditInputDestination.value)(1, 1).Offset(rf, cf)
            CheckIfOverwrite rDest, nUfResult, bYesToAll
            If nUfResult = 0 Then Exit Sub
            '
            ' check if the range name has an .MD version; if so, use that one
            '
            On Error Resume Next
            Err.Clear
            sRN = Replace(libraryBook.Names(Me.ListBoxInputRanges.List(L)).Parent.Name, "'", "''") _
                    & "'!" & Me.ListBoxInputRanges.List(L)
            sTmp = libraryBook.Names(Me.ListBoxInputRanges.List(L) & ".MD").Name
            If Err = 0 Then sRN = sRN & ".MD"
            rDest.Formula = "=index( '" & sRN & ", PM_Index )"
            '
            ' put in any metadata, if metata destination was specified
            '
            ' first put in Name as a separate case, since Name may not be a numbered metadata item
            '
            If "" <> Trim(Me.RefEditNameDestination.value) Then
                If Me.ListBoxMetadata.Selected(0) = True Then ' 0th item is "Name"; if selected, put in Name
                    bNameUsed = True
                    Set rDest = Range(Me.RefEditNameDestination.value)(1, 1).Offset(rf, cf)
                    CheckIfOverwrite rDest, nUfResult, bYesToAll
                    If nUfResult = 0 Then Exit Sub
                    rDest.value = Me.ListBoxInputRanges.List(L)
                End If
                '
                ' put in metadata header if specified
                '
                If (Me.CheckBoxIncludeHeadings.value = True) And inputCount = 0 And bNameUsed Then
                    Set rDest = Range(Me.RefEditNameDestination.value)(1, 1) _
                        .Offset(-rowMult, -colMult)
                    CheckIfOverwrite rDest, nUfResult, bYesToAll
                    If nUfResult = 0 Then Exit Sub
                    rDest.value = "Name"
                End If
                '
                ' also put in any other metadata that was specified, to right or below the name
                '
                If Not rPMIndex Is Nothing Then
                    If bNameUsed Then nmc = 0 Else nmc = -1 ' n Meta Counter
                    For n = 1 To Me.ListBoxMetadata.ListCount - 1 ' Item 0 was taken care of above
                        If Me.ListBoxMetadata.Selected(n) = True Then
                            sMetaName = Me.ListBoxMetadata.List(n)
                            On Error Resume Next
                            Err.Clear
                            nMetaIndex = _
                                Application.WorksheetFunction.Index( _
                                    rPMIndex, _
                                    Application.WorksheetFunction.match( _
                                        sMetaName, _
                                        rPmMeta, _
                                        0))
                            If Err = 0 Then
                                nmc = nmc + 1
                                mrf = rf + colMult * nmc
                                mcf = cf + rowMult * nmc
                                Set rDest = Range(Me.RefEditNameDestination.value)(1, 1).Offset(mrf, mcf)
                                CheckIfOverwrite rDest, nUfResult, bYesToAll
                                If nUfResult = 0 Then Exit Sub
                                rDest.Formula = "=index( '" & sRN & ", " & nMetaIndex & " )"
                                '
                                ' put in metadata header if specified
                                '
                                If (Me.CheckBoxIncludeHeadings.value = True) And inputCount = 0 Then
                                    Set rDest = Range(Me.RefEditNameDestination.value)(1, 1) _
                                        .Offset(nmc * colMult - rowMult, _
                                                nmc * rowMult - colMult)
                                    CheckIfOverwrite rDest, nUfResult, bYesToAll
                                    If nUfResult = 0 Then Exit Sub
                                    rDest.value = sMetaName
                                End If
                            End If
                        End If
                    Next n
                End If
            End If ' "" <> Trim(Me.RefEditNameDestination.value)
            If bInsertSparklines Then
                '
                ' figure out the data range to use. It is in the LibraryBook under the name #L in the listboxInputRanges.
                ' it may be a row or a column, so we count rows to find out which
                '
                With libraryBook.Names(Me.ListBoxInputRanges.List(L)).RefersToRange
                    If .Rows.Count > 1 Then
                        ' rows > 1 so the range is a single column. Use the 1st PM_Trials rows of the range
                        bDataIsColumn = True
                        sGraphRanges _
                            = .Resize( _
                                Application.Evaluate(libraryBook.Names("PM_Trials").RefersToRange.Address(, , , 1)), _
                                1) _
                            .Address(, , , 1)
                    Else
                        bDataIsColumn = False
                        sGraphRanges _
                            = .Resize(1, Application.Evaluate(libraryBook.Names("PM_Trials").RefersToRange.Address(, , , 1))).Address(, , , 1)
                    End If
                End With
                
                lNumberOfBins = 10
                On Error Resume Next
                Err.Clear
                lNumberOfBins = [=PM_SparklinesIONumberOfBins]
                If Err <> 0 Then lNumberOfBins = [=SparklinesIONumberOfBins]
                On Error GoTo 0
#If PROJECT = SIPMATH_HISTOGRAM Then
                smh_UserFormGraphs_CommandButtonOK_Click _
                    sGraphRanges:=sGraphRanges, numBins:=lNumberOfBins, bExcelChart:=False, _
                    bSparkline:=True, bColumn:=True, bRow:=False, bChartSelectedData:=True, _
                    bDataIsAColumn:=bDataIsColumn, bChartSIPmathOutput:=False, bDataNamesInHeadings:=False, _
                    sFrequencyDest:=Range(Me.RefEditSparklineStartCell.value)(1, 1).Offset(rf, cf).Address(, , , 1), _
                    sCumulativeDest:="", oCallingForm:=Me, bIntegerChart:=False, _
                    rDefaultChartDataLocation:=defaultChartDataLocation, _
                    sSparklineType:="Input", vaOutputNames:=Me.ListBoxInputRanges.List(L)
#Else
                smmt_UserFormGraphs_CommandButtonOK_Click _
                    sGraphRanges:=sGraphRanges, numBins:=lNumberOfBins, bExcelChart:=False, _
                    bSparkline:=True, bColumn:=True, bRow:=False, bChartSelectedData:=True, _
                    bDataIsAColumn:=bDataIsColumn, bChartSIPmathOutput:=False, bDataNamesInHeadings:=False, _
                    sFrequencyDest:=Range(Me.RefEditSparklineStartCell.value)(1, 1).Offset(rf, cf).Address(, , , 1), _
                    sCumulativeDest:="", oCallingForm:=Me, bIntegerChart:=False, _
                    rDefaultChartDataLocation:=defaultChartDataLocation, _
                    sSparklineType:="Input", vaOutputNames:=Me.ListBoxInputRanges.List(L)
#End If
            End If 'bInsertSparklines
            inputCount = inputCount + 1
        End If ' Me.ListBoxInputRanges.Selected(L)
    Next L
    
    On Error Resume Next
    Unload Me

End Sub

Private Sub TextBoxFilter_Change()
    Dim n As Long, fN As Long
    ReDim filterList(0 To 0)
    fN = -1
    For n = 0 To UBound(nameList)
        If InStr(nameList(n), Me.TextBoxFilter.Text) And UCase(Right(nameList(n), 3)) <> ".MD" Then
            fN = fN + 1
            ReDim Preserve filterList(0 To fN)
            filterList(fN) = nameList(n)
        End If
    Next n
    Me.ListBoxInputRanges.List = filterList
End Sub

Private Sub UserForm_Activate()
    
    Dim aName As Object, libraryBook As Object, currSel As String, bookName As String
    Dim i As Long, j As Long, bRandomMode As Boolean, tempNameList As Variant
    Dim bLocalLib As Boolean
    
    On Error Resume Next
    
    bRandomMode = False
    Err.Clear
    bRandomMode = Application.Evaluate(ActiveWorkbook.Names("PM_random_mode").RefersTo)
    If Err <> 0 Then
        Err.Clear
        bRandomMode = Application.Evaluate(ActiveWorkbook.Names("_random_mode").RefersTo)
    End If
    If bRandomMode Then
'        MsgBox "Inputs are not used in Random mode.", vbExclamation, APP_NAME
'        Unload Me
'        Exit Sub
    End If
    Err.Clear
    bLocalLib = [=PM_local_library]
    If Err <> 0 Then
        Err.Clear
        bLocalLib = [=local_library]
        Err.Clear
    End If
    If bLocalLib Then
        ActiveWorkbook.Names.Add "PM_library_file_name", ActiveWorkbook.Name
        ActiveWorkbook.Names.Add "PM_library_file_path", ActiveWorkbook.path
    End If
    Err.Clear
    Set libraryBook = Workbooks(Application.Evaluate(ActiveWorkbook.Names("PM_library_file_name").RefersTo))
    If Err <> 0 Then
        Err.Clear
        Set libraryBook = Workbooks(Application.Evaluate(ActiveWorkbook.Names("library_file_name").RefersTo))
    End If
    If Err <> 0 Then
        Me.Hide
        MsgBox "The model may not be initialized.   If not, please use the initialize button before defining inputs." & vbNewLine & _
            "If the model has been initialized and the worksheets ""PMTable"" and ""SIPmath Data Table"" exist, then please open the library identified by the variable name ""PM_Library_File_Name"".  Using the Excel command  ""Data / Edit Links / Open Source"" may be an easy way to open the library.", vbExclamation, APP_NAME
        On Error Resume Next
        Unload Me
        Exit Sub
    Else
        If libraryBook.Names.Count > 0 Then
            firstName(1) = libraryBook.Names(1).Name
        End If
        nameCount = 0
        ReDim nameList(0 To 0)
        For Each aName In libraryBook.Names
            If Left$(aName.Name, 3) <> "PM_" _
            And 0 = InStr("#_cume#_freq#_bins#_lbls#", "#" & Right$(aName.Name, 5) & "#") _
            And 0 = InStr("#library_file_name#local_library#sparklinesForInputs#sparklinesForOutputs" _
                            & "#sparklinesIONumberOfBins#_random_mode#", _
                          "#" & aName.Name & "#") _
            And aName.Visible _
            Then
                ReDim Preserve nameList(0 To nameCount)
                nameList(nameCount) = aName.Name
                nameCount = nameCount + 1
            End If
        Next aName
        ReDim filterList(0 To nameCount - 1)
        For i = 0 To UBound(nameList)
            filterList(i) = nameList(i)
        Next i
    End If
    '
    ' load list of possible metadata from library file, if any
    '
    fillMetadataListBox ActiveWorkbook
    
    If nameCount < 1 Then
'        Me.Hide
'        MsgBox "No inputs found", vbExclamation, "SIPmath"
'        Unload Me
    Else
        j = 0
        tempNameList = Array()
        For i = 0 To UBound(nameList)
            If UCase(Right(nameList(i), 3)) <> ".MD" Then
                ReDim Preserve tempNameList(0 To j)
                tempNameList(j) = nameList(i)
                j = j + 1
            End If
        Next i
        selectionCount = -1
        If j > 0 Then
            Me.ListBoxInputRanges.List = tempNameList
        Else
            Me.ListBoxInputRanges.List = nameList
        End If
        Me.ListBoxInputRanges.ListIndex = 0
    End If
    
    currSel = Selection.Address(External:=True)
    i = InStr(currSel, "[")
    If i > 0 Then
        j = InStr(i, currSel, "]")
        If j > 0 Then
            bookName = Mid(currSel, i, j - i + 1)
            currSel = Replace(currSel, bookName, "", Count:=1)
        End If
    End If
    Me.RefEditInputDestination.value = currSel
    'Me.ListBoxInputRanges.Height = 100
    If [=PM_DfltChart] Then Me.RefEditSparklineStartCell.value = Me.RefEditInputDestination.value
    Me.RefEditNameDestination.SetFocus
    
End Sub

Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            c.Font.Size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub

Sub fillInputListBox(libraryBook As Workbook)

    Dim aName As Variant, i As Long
    
    '
    ' previously I had retained the old names, but since I only have 1 lib at a time the old names won't work after you load a new lib
    ' therefore I now start with a blank list of names
    '
    nameCount = 0 ' was Me.ListBoxInputRanges.ListCount
    'ReDim Preserve nameList(0 To nameCount) ' no need to preserve this now
    nameList = Split("a", ",") ' Split() makes an empty array of strings
    For Each aName In libraryBook.Names
        If Left$(aName.Name, 3) <> "PM_" _
        And 0 = InStr("#_cume#_freq#_bins#_lbls#", "#" & Right$(aName.Name, 5) & "#") _
        And 0 = InStr("#library_file_name#local_library#sparklinesForInputs#sparklinesForOutputs" _
                        & "#sparklinesIONumberOfBins#_random_mode#", _
                      "#" & aName.Name & "#") _
        And aName.Visible And LCase(Right$(aName.Name, 3)) <> ".md" _
        Then
            ReDim Preserve nameList(0 To nameCount)
            nameList(nameCount) = aName.Name
            nameCount = nameCount + 1
        End If
    Next aName
    ReDim filterList(0 To nameCount - 1)
    For i = 0 To UBound(nameList)
        filterList(i) = nameList(i)
    Next i
    selectionCount = -1
    Me.ListBoxInputRanges.List = nameList
    Me.ListBoxInputRanges.ListIndex = 0

End Sub

Private Sub fillMetadataListBox(wModel As Workbook)

    '
    ' if there is a library file defined, and it is open, then fill the box with items from
    ' the PM_Meta range
    '
    Dim sLibName As String
    Dim wLib As Workbook
    Dim rMetaItems As Range
    Dim rMetaSingleItem As Range
    
    Me.ListBoxMetadata.AddItem "Name"
    
    sLibName = ""
    On Error Resume Next
    Err.Clear
    sLibName = Application.Evaluate(wModel.Names("PM_library_file_name").RefersTo)
    If Err <> 0 Then
        Err.Clear
        sLibName = Application.Evaluate(wModel.Names("library_file_name").RefersTo)
        If Err <> 0 Then Exit Sub ' no library file name defined
    End If
    
    ' if we reach here, then there is a library name defined; see if it is open
    Err.Clear
    Set wLib = Workbooks(sLibName)
    If Err <> 0 Then Exit Sub ' library workbook isn't open
    
    ' if we reach here, then there is an open library
    ' check if it has any metadata
    Err.Clear
    Set rMetaItems = wLib.Names("PM_Meta").RefersToRange
    If Err <> 0 Then
        Err.Clear
        Set rMetaItems = wLib.Names("PM_IV").RefersToRange
        If Err <> 0 Then Exit Sub ' no metadata range is defined.
    End If
    
    ' if we reach here, then there is a metadata range, so load its items into the listbox
    For Each rMetaSingleItem In rMetaItems
        Me.ListBoxMetadata.AddItem rMetaSingleItem.Value2
    Next rMetaSingleItem
    
End Sub

Attribute VB_Name = "UserFormGetLocation"
Attribute VB_Base = "0{A89A23FB-F303-41A6-BD76-542BBC0DE689}{2E9E994E-9C58-4373-9BBB-645AE04A5B2D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Private Sub CommandButtonCancel_Click()
    g_bCancel = True
    Unload Me
End Sub

Private Sub CommandButtonOK_Click()
    g_bCancel = False
    Me.Hide
End Sub

Attribute VB_Name = "UserFormGetSlurpMetadata"
Attribute VB_Base = "0{6817F9BE-39AE-4367-9E14-E4706B4878AD}{C1A90B70-B154-40D7-A3FC-C00C1B474EF5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Private Sub CommandButtonCancel_Click()
    
    g_sSlurpName = ""
    g_sSlurpOrigin = ""
    Unload Me
    
End Sub

Private Sub CommandButtonOK_Click()

    g_sSlurpName = Me.TextBoxSlurpName.value
    g_sSlurpOrigin = Me.TextBoxSlurpOrigin.value
    Unload Me
    
End Sub
Attribute VB_Name = "UserFormInfo"
Attribute VB_Base = "0{E0D11614-851F-42C7-9D40-834D487AFC84}{2D3DCB00-CD45-4D4E-BA2F-C192EF207DC6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Dim bInSpin As Boolean, bInText As Boolean

Dim sourceBooks() As String

Private Sub ComboBoxMetaData_Change()

    If Me.ComboBoxMetaData.value = "Trial Value" Then
        Me.SpinButtonTrialNumber.Enabled = True
        Me.SpinButtonTrialNumber.Visible = True
        Me.TextBoxTrialNumber.value = Me.SpinButtonTrialNumber.value
        On Error Resume Next
        Err.Clear
        Names("PM_Index").RefersToRange.Item(1, 1).value = Me.SpinButtonTrialNumber.value
        If Err <> 0 Then Unload Me
        On Error GoTo 0
    Else
        Me.SpinButtonTrialNumber.Enabled = False
        Me.SpinButtonTrialNumber.Visible = False
        Me.TextBoxTrialNumber.value = Me.ComboBoxMetaData.value
        On Error Resume Next
        Err.Clear
        Names("PM_Index").RefersToRange.Item(1, 1).value _
            = ActiveWorkbook.Names("PM_Meta_INDEX").RefersToRange.Item(Me.ComboBoxMetaData.ListIndex)
        If Err <> 0 Then
            Err.Clear
            Names("PM_Index").RefersToRange.Item(1, 1).value _
                = ActiveWorkbook.Names("PM_IV_INDEX").RefersToRange.Item(Me.ComboBoxMetaData.ListIndex)
            If Err <> 0 Then Unload Me
        End If
            'Workbooks(Application.Evaluate(ActiveWorkbook.Names("library_file_name").RefersTo)).Names("PM_IV_INDEX").RefersToRange.Item(Me.ComboBoxMetaData.ListIndex)
    End If
    
End Sub

Private Sub CommandButtonClose_Click()
    Unload Me
End Sub

Private Sub ScrollBarTrialNumber_Change()
'
'    On Error Resume Next
'    If Me.ComboBoxMetaData.value = "Trial Value" Then
'        Me.LabelTrialNumber.Caption = "Trial Number " & Me.ScrollBarTrialNumber.value
'        Err.Clear
'        Names("PM_Index").RefersToRange.Item(1, 1).value = Me.ScrollBarTrialNumber.value
'        If Err <> 0 Then Unload Me
'    End If
'
End Sub

Private Sub SpinButtonTrialNumber_Change()

    If bInText Then Exit Sub
    
    bInSpin = True
    
    On Error Resume Next
    If Me.ComboBoxMetaData.value = "Trial Value" Then
        Me.TextBoxTrialNumber.value = Me.SpinButtonTrialNumber.value
        Err.Clear
        Names("PM_Index").RefersToRange.Item(1, 1).value = Me.SpinButtonTrialNumber.value
        If Err <> 0 Then Unload Me
    End If
    
    bInSpin = False
    
End Sub

Private Sub TextBoxTrialNumber_Change()

    Dim vVal As Variant
    
    If bInSpin Or bInText Then Exit Sub
    bInText = True
    
    On Error Resume Next
    If Me.ComboBoxMetaData.value = "Trial Value" Then
        Err.Clear
        vVal = Me.SpinButtonTrialNumber.value
        Me.SpinButtonTrialNumber.value = Me.TextBoxTrialNumber.value
        If Err <> 0 Or Me.SpinButtonTrialNumber.value < 1 Or Me.SpinButtonTrialNumber.value > [=PM_Trials] Then
            Beep
            Me.SpinButtonTrialNumber.value = vVal
            Me.TextBoxTrialNumber.value = vVal
        End If
        Err.Clear
        Names("PM_Index").RefersToRange.Item(1, 1).value = Me.SpinButtonTrialNumber.value
        If Err <> 0 Then Unload Me
    End If
    
    bInText = False
    
End Sub

Private Sub UserForm_Activate()
    
    Dim aName As Object, wb As Object, numRanges As Long, aCell As Range
    Dim bLocalLib As Boolean
    
    On Error Resume Next
    
    Err.Clear
    
    bLocalLib = [=PM_local_library]
    If Err <> 0 Then
        Err.Clear
        bLocalLib = [=local_library]
    End If
    If bLocalLib Then
        ActiveWorkbook.Names.Add "PM_library_file_name", ActiveWorkbook.Name
        ActiveWorkbook.Names.Add "PM_library_file_path", ActiveWorkbook.path
    End If
    Me.SpinButtonTrialNumber.Max = _
        Application.Evaluate(ActiveWorkbook.Names("PM_Trials").RefersTo)
        'Workbooks(Application.Evaluate(ActiveWorkbook.Names("library_file_name").RefersTo)).Names("PM_Trials").RefersToRange.Value
    'Me.ScrollBarTrialNumber.LargeChange = Me.ScrollBarTrialNumber.Max / 10
    Me.ComboBoxMetaData.AddItem "Trial Value"
    'For Each aCell In Workbooks(Application.Evaluate(ActiveWorkbook.Names("library_file_name").RefersTo)).Names("PM_IV").RefersToRange
    
    Err.Clear
    Set aCell = ActiveWorkbook.Names("PM_Meta").RefersToRange
    If Err = 0 Then
        For Each aCell In ActiveWorkbook.Names("PM_Meta").RefersToRange
            Me.ComboBoxMetaData.AddItem aCell.value
        Next aCell
    Else
        For Each aCell In ActiveWorkbook.Names("PM_IV").RefersToRange
            Me.ComboBoxMetaData.AddItem aCell.value
        Next aCell
    End If
    Me.SpinButtonTrialNumber.value = [=PM_Index]
    Me.ComboBoxMetaData.ListIndex = 0
    
    On Error GoTo 0
    
End Sub


Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            If TypeName(c) <> "ScrollBar" And TypeName(c) <> "SpinButton" Then
                c.Font.Name = "Lucida Grande"
                c.Font.Size = 10
            End If
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub

Attribute VB_Name = "UserFormInitialize"
Attribute VB_Base = "0{BE47DBD2-05BE-46FD-8308-80702537CA51}{156CB14E-7F7E-41AE-A36A-A3EF990BFBD9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Dim newLibraryName As String

Dim bGenerateMode As Boolean, bClosedGenerate As Boolean, b1stAct As Boolean

''Dim dynBtn As ClassDynamicButton

Private Sub CommandButtonBrowse_Click()
    
    Dim libraryFileName As Variant, L As Long
    
#If Mac Then
    libraryFileName = Application.GetOpenFilename
#Else
'''    libraryFileName = Application.GetOpenFilename("All files (*.*), *.*, Excel files (*.xl*; *.htm; *.html; *.mht; *.mhtml; *.xml; *.odc; *.uxdc; *.ods), *.xl*; *.htm; *.html; *.mht; *.mhtml; *.xml; *.odc; *.uxdc; *.ods, XML files (*.sip; *.xml), *.sip; *.xml", 2, "Browse for library file...")
    On Error Resume Next
    ChDir [=PM_library_file_path]
    On Error GoTo 0
    libraryFileName = Application.GetOpenFilename("Excel files (*.xl*; *.htm; *.html; *.mht; *.mhtml; *.xml; *.odc; *.uxdc; *.ods), *.xl*; *.htm; *.html; *.mht; *.mhtml; *.xml; *.odc; *.uxdc; *.ods", 1, "Browse for library file...")
#End If
    If VarType(libraryFileName) <> vbBoolean Then
        newLibraryName = libraryFileName
        L = InStrRev(newLibraryName, "\")
        Me.TextBoxLibraryFileName.value = Mid$(newLibraryName, 1 + L, Len(newLibraryName) - L)
    End If
    
End Sub

Private Sub CommandButtonCancel_Click()
    On Error Resume Next
    Unload Me
End Sub

Public Sub CommandButtonOK_Click()
    
    Dim lastWorkbookName As String, libraryBook As Workbook, numMetaData As Long, metaN As Long
    'Dim lastWorkbook As Workbook
    Dim lastSheet As Object, indices() As Double, maxTrials As Long
    Dim metaRangeName As String, shapeName As String
    Dim numCols As Long
    Dim outputCell As Variant
    Dim colHdFmls As Variant
    Dim r As Long
    Dim calcMode As Variant
    Dim sTableFcn As String
    Dim nOldTrials As Long
    Dim vDummy As Variant
    
    On Error Resume Next
        
    Application.ScreenUpdating = False
    calcMode = Application.Calculation
    Application.Calculation = xlCalculationManual
    Set lastSheet = ActiveSheet
    
    Dim i As Long
    If (Me.CheckBoxSparklinesForInputs.value = True And Me.OptionButtonGenerateMode.value <> True) _
        Or Me.CheckBoxSparklinesForOutputs.value = True _
    Then
        i = 0
        i = Me.TextBoxDfltBins.value
        If i < 2 Then
            MsgBox "Please select 2 or more bins", vbInformation, APP_NAME
            Exit Sub
        End If
    End If
    g_MaxBins = Me.TextBoxMaxBins.value
    g_DfltBins = Me.TextBoxDfltBins.value
    
    If bGenerateMode Then
        Dim numTrials As Long, pm_TrialsCell As Range, nInitVarId As Long
        Err.Clear
        numTrials = Me.TextBoxLibraryFileName.value
        If Err <> 0 Then
            MsgBox "Please enter a whole number for the number of trials", vbInformation, APP_NAME
            Exit Sub
        End If
        Err.Clear
        nInitVarId = 0
        nInitVarId = Me.TextBoxInitVarID.value
        If Err <> 0 Or nInitVarId < 1 Then
            MsgBox "Pleae enter a positive whole number for the initial variable ID", vbInformation, APP_NAME
            Exit Sub
        End If
        '
        ' if there is already a PMTable sheet wtih a data table, delete that data table
        ' (but save the number of columns in it, and the array function, so I can rebuild the data table)
        '
        ActiveWorkbook.Sheets("PMTable").Activate
        If ActiveSheet.Name = "PMTable" Then
            With ActiveWorkbook.Sheets("PMTable").Range("C4")
                If .HasArray Then
                    numCols = .CurrentArray.Columns.Count - 1
                    nOldTrials = .CurrentArray.Rows.Count - 1
                    sTableFcn = .FormulaArray
                    '
                    '
                    '
                    If numTrials > nOldTrials Then
                        If Application.CountA(.Resize(numTrials, numCols)) > Application.CountA(.Resize(nOldTrials, numCols)) Then
                            If vbCancel = MsgBox("Overwrite data in the range " & .Resize(numTrials, numCols).Address(, , , 1) & " ?", vbOKCancel Or vbQuestion, APP_NAME) Then
                                GoTo End_UserFormInitialize_CommandButtonOK_Click
                            End If
                        End If
                    End If
                    With .CurrentArray
                        .Borders.LineStyle = xlNone
                        .Offset(1, 1).Resize(-1 + .Rows.Count, -1 + .Columns.Count).Clear
                    End With
                Else
                    numCols = 0
                End If
            End With
        End If ' ActiveSheet.Name = "PMTable"
        ActiveWorkbook.Names.Add "PM_Trials", numTrials
        ActiveWorkbook.Names.Add "PM_random_mode", True
        ActiveWorkbook.Names.Add "PM_local_library", True
        ActiveWorkbook.Names.Add "PM_InitialVariableID", nInitVarId
        maxTrials = numTrials
    ElseIf Me.OptionButtonCurrentBook.value = True Then
        If Not CheckForLibrary(ActiveWorkbook.Name) Then Exit Sub
        ActiveWorkbook.Names.Add "PM_local_library", True
        ActiveWorkbook.Names.Add "PM_random_mode", False
        maxTrials = Application.Evaluate(ActiveWorkbook.Names("PM_Trials").RefersTo)
    Else
        If Trim(newLibraryName) = "" Then
            MsgBox "Please specify a SIP library file.", vbInformation, APP_NAME
            Application.Calculation = calcMode
            Exit Sub
        End If
        ActiveWorkbook.Names.Add "PM_local_library", False
        ActiveWorkbook.Names.Add "PM_random_mode", False
''''''        If Trim(newLibraryName) <> "" Then
        lastWorkbookName = ActiveWorkbook.Name
        'Set lastWorkbook = ActiveWorkbook
''''''        If 0 <> InStr("#xml#sip#", LCase(Right(newLibraryName, 3))) Then
''''''            '
''''''            ' load in an XML SLURP
''''''            '
''''''            ' make a new workbook
''''''            Workbooks.Add
''''''
''''''            ' create a "controls" tab in the active workbook if necessary
''''''            createControlsTab
''''''
''''''            ' set up the IVtable stuff as in Marc's version
''''''            setupIVTable
''''''
''''''            readOneSlurp (newLibraryName), "SLURP"
''''''            If Not CheckForLibrary(ActiveWorkbook.Name) Then
''''''                ActiveWorkbook.Close SaveChanges:=False
''''''                Exit Sub
''''''            End If
''''''            Workbooks(lastWorkbookName).Names.Add "PM_library_file_name", ActiveWorkbook.Name
''''''        Else
        Err.Clear
#If Mac Then
        r = InStrRev(newLibraryName, "/")
        Workbooks(Mid$(newLibraryName, r + 1)).Activate
        If Err = 0 Then
            ' file is loaded so don't try to load it again
        Else
            Err.Clear
            Workbooks.Open newLibraryName
        End If
#Else
        Workbooks.Open newLibraryName
#End If
        If Err = 0 Then
            If Not CheckForLibrary(newLibraryName) Then
                ActiveWorkbook.Close SaveChanges:=False
                Application.Calculation = calcMode
                Exit Sub
            End If
#If Mac Then
            r = InStrRev(newLibraryName, "/")
            Workbooks(Mid$(newLibraryName, r + 1)).Activate
#End If
            Workbooks(lastWorkbookName).Names.Add "PM_library_file_name", ActiveWorkbook.Name
            Workbooks(lastWorkbookName).Names.Add "PM_library_file_path", ActiveWorkbook.path
        Else
            MsgBox "SIPmath could not open the specified library file.", vbExclamation, APP_NAME
        End If ' Err = 0
''''''        End If ' 0 <> InStr("#xml#sip#", LCase(Right(newLibraryName, 3)))
        maxTrials = Application.Evaluate(ActiveWorkbook.Names("PM_Trials").RefersTo)
        Set libraryBook = ActiveWorkbook
        Workbooks(lastWorkbookName).Activate
        'Windows(lastWorkbookName).Activate
        g_sWorkbookName = lastWorkbookName
        Application.OnTime Now(), "activateWorkbook"
''''''        End If ' Trim(newLibraryName) <> ""
    End If ' bGenerateMode
    
    ActiveWorkbook.Names.Add "PM_MaxBins", g_MaxBins
    ActiveWorkbook.Names.Add "PM_DfltBins", g_DfltBins
    
    Dim pmTableExists As Boolean, lastCalcMode As Variant
    
    ActiveWorkbook.Sheets("PMTable").Activate
    If ActiveSheet.Name <> "PMTable" Then
        pmTableExists = False
        ActiveWorkbook.Sheets.Add After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
        ActiveSheet.Name = "PMTable"
    Else
        pmTableExists = True
    End If
    If ActiveSheet.Name = "PMTable" Then
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        If pmTableExists Then
            'Application.OnTime Now() + 1.15740740740741E-05, "'reRandom " & maxTrials & "'"
        Else
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            ActiveWorkbook.Names.Add "PM_Index", ActiveSheet.Range("A1")
            ActiveSheet.Range("A1").Interior.Color = RGB(255, 255, 0) ' yellow
            ActiveSheet.Range("A1").value = 1
            ActiveSheet.Range("B1").value = "Generated with the SIPmath" & tmSymbol() & " Modeler Tools from ProbabilityManagement.org"
            ReDim indices(1 To maxTrials, 1 To 1) As Double
            For r = 1 To maxTrials
                indices(r, 1) = r
            Next
            ActiveSheet.Range("B2").value = "Index"
            ActiveSheet.Range("B3").value = "Values"
            ActiveSheet.Range("B4").Resize(maxTrials, 1).value = indices
            ActiveSheet.Range("B4").Resize(maxTrials, 1).Interior.Color = RGB(255, 255, 0) ' yellow
            If Me.OptionButtonExternalBook.value = True Then
                On Error Resume Next
                Err.Clear
                numMetaData = libraryBook.Names("PM_Meta").RefersToRange.Count
                metaRangeName = "Meta"
                If Err <> 0 Then
                    Err.Clear
                    numMetaData = libraryBook.Names("PM_IV").RefersToRange.Count
                    metaRangeName = "IV"
                End If
                ActiveSheet.Range("A2").Formula _
                    = "=" & libraryBook.Names("PM_Trials").RefersToRange.Address(, , , 1)
                ActiveWorkbook.Names.Add "PM_Trials", _
                    ActiveSheet.Range("A2")
                ActiveSheet.Range("A3").Resize(numMetaData, 1).FormulaArray _
                    = "=" & libraryBook.Names("PM_" & metaRangeName).RefersToRange.Address(, , , 1)
                ActiveWorkbook.Names.Add "PM_Meta", _
                    ActiveSheet.Range("A3").Resize(numMetaData, 1)
                ActiveSheet.Range("A3").Offset(numMetaData, 0).Resize(numMetaData, 1).FormulaArray _
                    = "=" & libraryBook.Names("PM_" & metaRangeName & "_INDEX").RefersToRange.Address(, , , 1)
                ActiveWorkbook.Names.Add "PM_Meta_INDEX", _
                    ActiveSheet.Range("A3").Offset(numMetaData, 0).Resize(numMetaData, 1)
            End If
            '
            ' add PM logo if it's not there
            '
            Err.Clear
            shapeName = ActiveSheet.Shapes("PM Logo").Name
            If Err <> 0 Then ' then the Logo is not on the PMTable sheet, so copy it there
                ActiveSheet.Rows("1:1").RowHeight = 70
                Sheet1.Shapes("PM Logo").Copy
                ActiveSheet.Range("B1").Select
                ActiveSheet.PasteSpecial Format:="Picture (PNG)"
                Selection.Name = "PM Logo"
                Selection.ShapeRange.ScaleHeight 0.2, msoFalse, msoScaleFromTopLeft
                If Application.OperatingSystem Like "Mac*" Then
                    Selection.ShapeRange.LockAspectRatio = msoFalse
                    Selection.ShapeRange.ScaleHeight 0.23, msoTrue, msoScaleFromTopLeft
                End If
                Selection.ShapeRange.IncrementLeft 1.5
                ActiveSheet.Range("A1").Select
            End If ' Err <> 0
        End If ' pmTableExists
    End If ' ActiveSheet.Name = "PMTable"
    lastSheet.Activate
    
    Dim nHeadRow As Long, nMaxBins As Long
    
    If Me.CheckBoxSparklinesForInputs.value = True Or Me.CheckBoxSparklinesForOutputs.value = True Then
        ActiveWorkbook.Names.Add "PM_sparklinesForInputs", Me.CheckBoxSparklinesForInputs.value, False
        ActiveWorkbook.Names.Add "PM_sparklinesForOutputs", Me.CheckBoxSparklinesForOutputs.value, False
        ActiveWorkbook.Names.Add "PM_sparklinesIONumberOfBins", i, False
        ActiveWorkbook.Sheets(scd).Activate
        If ActiveSheet.Name <> scd Then
            ActiveWorkbook.Sheets.Add After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
            ActiveSheet.Name = scd
            nMaxBins = [=PM_MaxBins]
            ActiveSheet.Cells(1, 1).Offset(13, 0).Resize(nMaxBins + 1, 1).Rows.Group
            ActiveSheet.Cells(1, 1).Offset(15 + nMaxBins, 0).Resize(nMaxBins + 2, 1).Rows.Group
            ActiveSheet.Cells(1, 1).Offset(18 + 2 * nMaxBins, 0).Resize(nMaxBins + 2, 1).Rows.Group
            ActiveSheet.Cells(1, 1).Offset(21 + 3 * nMaxBins, 0).Resize(105, 1).Rows.Group
        End If
        If ActiveSheet.Name = scd Then
            With ActiveSheet
                nHeadRow = 2
                nMaxBins = [=PM_MaxBins]
                .Outline.ShowLevels RowLevels:=8, ColumnLevels:=8
                .Cells(nHeadRow, 1).value = "Expected Value": nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Series Name":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Integer chart?":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Loss Exceedance":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Number of Bins":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Label position":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Bin Width":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Decimals":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Scale":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Use Axis Title?":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Axis Title":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Min":  nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Bin Range":  .Cells(nHeadRow, 1).Interior.Color = &H8080FF: nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Frequency":  .Cells(nHeadRow, 1).Interior.Color = &H80FFFF: nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Labels":  .Cells(nHeadRow, 1).Interior.Color = &HFFFF80: nHeadRow = nHeadRow + 1
                .Cells(nHeadRow, 1).value = "Cumulative":  .Cells(nHeadRow, 1).Interior.Color = &H80FF80: nHeadRow = nHeadRow + 1
                
                Dim pctVals(1 To 105, 1 To 1) As Double
                Dim pctNdx As Long
                
                pctVals(1, 1) = 0.001
                pctVals(2, 1) = 0.004
                pctVals(3, 1) = 0.007
                For pctNdx = 1 To 99
                    pctVals(pctNdx + 3, 1) = pctNdx * 0.01
                Next
                pctVals(103, 1) = 0.993
                pctVals(104, 1) = 0.996
                pctVals(105, 1) = 0.999
                .Range("A1").Offset(3 * nMaxBins + 21, 0).Resize(105, 1).value = pctVals
                '
                ' define CDF Y axis ranges
                '
                ActiveWorkbook.Names.Add "PM_cdf_Y", .Range("A1").Offset(3 * nMaxBins + 21, 0).Resize(105, 1)
            End With
        End If
    End If
    '
    ' if in random mode, and numCols > 0, then re-create data table with correct number of rows
    '
    If numCols > 0 Then
        '
        ' put in all needed indices
        '
        ReDim indices(1 To maxTrials, 1 To 1) As Double
        
        For r = 1 To maxTrials
            indices(r, 1) = r
        Next
        With ActiveWorkbook.Sheets("PMTable")
            .Range("B4").Resize(maxTrials, 1).value = indices
            .Range("B4").Resize(maxTrials, 1).Interior.Color = RGB(255, 255, 0) ' yellow
            '
            '   save formulas in table column headings, then delete them
            '
            colHdFmls = .Range("C3").Resize(1, numCols).Formula
            .Range("C3").Resize(1, numCols).ClearContents
            '
            '   re-create table, if any, with correct number of rows
            '
            If sTableFcn = "=TABLE(B1,A1)" Then
                .Range("B3").Resize(maxTrials + 1, numCols + 1).Table RowInput:=.Range("B1"), ColumnInput:=.Range("A1")
            Else
                .Range("B3").Resize(maxTrials + 1, numCols + 1).Table ColumnInput:=.Range("A1")
            End If
            .Range("B3").Resize(maxTrials + 1, numCols + 1).BorderAround xlContinuous, xlThin, , 0
            .Range("C4").Resize(maxTrials, numCols).Interior.Color = RGB(197, 217, 241)
            '
            ' delete any extra rows if we are reducing the size of the PMTable
            '
            If nOldTrials > maxTrials Then
                ' look for data besides the row index values in the rows to be deleted
                If Application.CountA(.Cells(4, 3).Offset(maxTrials).Resize(nOldTrials - maxTrials, 1).EntireRow) > nOldTrials - maxTrials Then
                    If vbYes = MsgBox("Erase data in rows " & maxTrials + 4 & " to " & nOldTrials + 3 & " ?", vbYesNo Or vbQuestion, APP_NAME) Then
                        .Cells(4, 3).Offset(maxTrials).Resize(nOldTrials - maxTrials, 1).EntireRow.Delete Shift:=xlUp
                    End If
                Else
                    .Cells(4, 3).Offset(maxTrials).Resize(nOldTrials - maxTrials, 1).EntireRow.Delete Shift:=xlUp
                End If
            End If
'''            '
'''            '   clear any rows that might be below the table
'''            '
'''            .Range("B3").Offset(maxTrials + 1, 0).Resize(1000003# - maxTrials, numCols + 1).Clear
            '
            ' re-define all the output ranges
            '
            For Each outputCell In .Range("C2").Resize(1, numCols)
                Names.Add outputCell.Value2, outputCell.Offset(2, 0).Resize(maxTrials, 1)
            Next outputCell
            '
            ' put back the formulas
            '
            .Range("C3").Resize(1, numCols).Formula = colHdFmls
        End With ' ActiveWorkbook.Sheets("PMTable")
    End If ' numCols > 0
    ''''''''''''''''''''''''''''''''''''''
    lastSheet.Activate
    Application.ScreenUpdating = True
    'Windows(lastWorkbookName).Activate
    If Not bGenerateMode And Me.OptionButtonCurrentBook.value <> True Then
        libraryBook.Activate
    End If
    Windows(lastSheet.Parent.Name).Activate

End_UserFormInitialize_CommandButtonOK_Click:
    Application.Calculation = calcMode
    Unload Me

End Sub

Private Sub CommandButtonReset_Click()
    Application.OnTime Now(), "ReInitializeModel"
    
    On Error Resume Next
    Unload Me
End Sub

Private Sub OptionButtonCurrentBook_Click()
    Me.TextBoxLibraryFileName.Enabled = False
    Me.TextBoxLibraryFileName.BackColor = &H8000000F
    Me.CommandButtonBrowse.Enabled = False
    Call closeGenerateMode
End Sub

Private Sub OptionButtonExternalBook_Click()
    Me.TextBoxLibraryFileName.Enabled = True
    Me.TextBoxLibraryFileName.BackColor = &H80000005
    Me.CommandButtonBrowse.Enabled = True
    Call closeGenerateMode
    bClosedGenerate = True
    Call UserForm_Activate
    bClosedGenerate = False
End Sub

Private Sub OptionButtonGenerateMode_Click()
    
    If Not bGenerateMode Then
        Me.Height = 177 ' 252
        Me.CommandButtonBrowse.Enabled = False
        Me.CommandButtonBrowse.Visible = False
        '
        ' in generateMode, use TextBoxLibraryFileName for number of trials
        '
        Me.TextBoxLibraryFileName.value = ""
        Me.TextBoxLibraryFileName.Width = 73
        Me.TextBoxLibraryFileName.Top = Me.TextBoxLibraryFileName.Top + 12
        Me.TextBoxLibraryFileName.Enabled = True
        Me.TextBoxLibraryFileName.BackColor = &H80000005

        Me.LabelNumTrials.Top = Me.TextBoxLibraryFileName.Top - 12
        Me.LabelNumTrials.Left = Me.TextBoxLibraryFileName.Left
        Me.LabelNumTrials.Height = 12
        Me.LabelNumTrials.Width = 73 + 36
        Me.LabelNumTrials.Caption = "Number of Trials"
        Me.LabelNumTrials.Visible = True
        
        Me.LabelInitvarID.Top = Me.LabelNumTrials.Top
        Me.LabelInitvarID.Left = Me.TextBoxLibraryFileName.Left + Me.TextBoxLibraryFileName.Width + 5
        Me.LabelInitvarID.Visible = True
        
        Me.TextBoxInitVarID.Top = Me.TextBoxLibraryFileName.Top
        Me.TextBoxInitVarID.Left = Me.TextBoxLibraryFileName.Left + Me.TextBoxLibraryFileName.Width + 5
        Me.TextBoxInitVarID.Visible = True
        Me.TextBoxInitVarID.Enabled = True
        
        Me.LabelCreateSparklines.Top = Me.LabelCreateSparklines.Top + 12
        Me.LabelNumBins.Top = Me.LabelCreateSparklines.Top
        Me.LabelMaxBins.Top = Me.LabelNumBins.Top + 19
        Me.TextBoxMaxBins.Top = Me.LabelMaxBins.Top - 3
        Me.LabelDfltBins.Top = Me.LabelMaxBins.Top ' + 20
        Me.TextBoxDfltBins.Top = Me.TextBoxMaxBins.Top ' + 20
        Me.CheckBoxSparklinesForInputs.Top = Me.CheckBoxSparklinesForInputs.Top + 12
        'Me.CheckBoxSparklinesForInputs.Visible = False
        'Me.CheckBoxSparklinesForInputs.Enabled = False
        
        Me.CheckBoxSparklinesForOutputs.Top = Me.CheckBoxSparklinesForOutputs.Top + 12
        '''Me.CommandButtonOK.Top = Me.CommandButtonOK.Top + 12
        '''Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top + 12
        Me.TextBoxLibraryFileName.SetFocus
        bGenerateMode = True
    End If
End Sub

Private Sub closeGenerateMode()
    If bGenerateMode Then
        Me.RefEditPM_TrialsCell.Enabled = False
        Me.RefEditPM_TrialsCell.Visible = False
        Me.LabelNumTrials.Visible = False
        Me.LabelPM_TrialsCell.Visible = False
        Me.TextBoxLibraryFileName.Width = 108
        Me.TextBoxLibraryFileName.Top = Me.TextBoxLibraryFileName.Top - 12
        
        Me.TextBoxInitVarID.Visible = False
        Me.TextBoxInitVarID.Enabled = False
        Me.LabelInitvarID.Visible = False
        
        Me.CommandButtonBrowse.Visible = True
        Me.CommandButtonBrowse.Enabled = True
        Me.LabelCreateSparklines.Top = Me.LabelCreateSparklines.Top - 12
        Me.LabelNumBins.Top = Me.LabelCreateSparklines.Top
        Me.LabelMaxBins.Top = Me.LabelNumBins.Top + 19
        Me.TextBoxMaxBins.Top = Me.LabelMaxBins.Top - 3
        Me.LabelDfltBins.Top = Me.LabelMaxBins.Top ' + 20
        Me.TextBoxDfltBins.Top = Me.TextBoxMaxBins.Top ' + 20
        ''' v 3.1.36 Me.CheckBoxSparklinesForInputs.Visible = True
        ''' v 3.1.36 Me.CheckBoxSparklinesForInputs.Enabled = True
        Me.CheckBoxSparklinesForInputs.Top = Me.CheckBoxSparklinesForInputs.Top - 12
        Me.CheckBoxSparklinesForOutputs.Top = Me.CheckBoxSparklinesForOutputs.Top - 12
        '''Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top - 12
        '''Me.CommandButtonOK.Top = Me.CommandButtonOK.Top - 12
        Me.Height = 177 ' 240
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Me.LabelNumTrials = "Number of Trials"
        ''' v 3.1.36 Me.CheckBoxSparklinesForOutputs.Enabled = True
        ''' v 3.1.36 Me.CheckBoxSparklinesForOutputs.Visible = True
        Me.TextBoxMaxBins.Enabled = False ' True
        Me.TextBoxMaxBins.Visible = False ' True
        Me.LabelCreateSparklines.Visible = False ' True
        Me.LabelNumBins.Visible = False ' True
        Me.LabelMaxBins.Visible = False ' True
        Me.TextBoxMaxBins.Visible = False ' True
        Me.LabelDfltBins.Visible = False ' True
        Me.TextBoxDfltBins.Visible = False ' True
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        bGenerateMode = False
    End If
End Sub

Public Sub UserForm_Activate()
    
'''    Dim myBtn As CommandButton
    
    On Error Resume Next
    
    If Workbooks.Count = 0 Then
        MsgBox "You must open or create a workbook before initializing a model.", vbInformation Or vbOKOnly, APP_NAME
        Exit Sub
    End If
    Me.TextBoxLibraryFileName.value = ""
    Err.Clear
    Me.TextBoxLibraryFileName.value = Application.Evaluate(ActiveWorkbook.Names("PM_library_file_name").RefersTo)
    If Err <> 0 Then
        Err.Clear
        Me.TextBoxLibraryFileName.value = Application.Evaluate(ActiveWorkbook.Names("library_file_name").RefersTo)
    End If
    If Me.TextBoxMaxBins.value = "" Then
        Me.TextBoxMaxBins.value = "100"
        Me.TextBoxDfltBins.value = "10"
    End If
    Me.CheckBoxSparklinesForInputs.value = True
    Me.CheckBoxSparklinesForOutputs.value = True
    
    Dim reRandom As Boolean, bSparklines As Boolean
    
    Err.Clear
    reRandom = False: reRandom = Application.Evaluate(ActiveWorkbook.Names("PM_random_mode").RefersTo)
    If Err <> 0 Then
        Err.Clear
        reRandom = Application.Evaluate(ActiveWorkbook.Names("_random_mode").RefersTo)
    End If
    bSparklines = False
    Err.Clear
    bSparklines = Application.Evaluate(ActiveWorkbook.Names("PM_sparklinesForOutputs").RefersTo)
    If Err <> 0 Then
        Err.Clear
        bSparklines = Application.Evaluate(ActiveWorkbook.Names("sparklinesForOutputs").RefersTo)
    End If
    If reRandom And Not bClosedGenerate Then
        Me.OptionButtonGenerateMode = True
        
        Me.OptionButtonCurrentBook.Visible = False
        Me.OptionButtonCurrentBook.Enabled = False
        
        Me.OptionButtonExternalBook.Visible = False
        Me.OptionButtonExternalBook.Enabled = False
        
        Me.OptionButtonGenerateMode.Visible = False
        Me.OptionButtonGenerateMode.Enabled = False
        
        Err.Clear
        Me.TextBoxInitVarID.value _
            = Application.Evaluate(ActiveWorkbook.Names("PM_InitialVariableID").RefersTo)
        If Err <> 0 Then Me.TextBoxInitVarID.value = Int(1 + Rnd() * 10000000#)
        Me.LabelSelectLibrary.Visible = False
        
        Me.LabelNumTrials = "Reset Number of Trials"
        
        Me.TextBoxLibraryFileName = Application.Evaluate(ActiveWorkbook.Names("PM_Trials").RefersTo)
        
        ''' v 3.1.36 If bSparklines Then Me.CheckBoxSparklinesForOutputs.value = True Else Me.CheckBoxSparklinesForOutputs.value = False
        
        Me.CheckBoxSparklinesForOutputs.Enabled = False
        Me.CheckBoxSparklinesForOutputs.Visible = False
        
        Me.TextBoxMaxBins.Enabled = False
        Me.TextBoxMaxBins.Visible = False
        
        Me.LabelCreateSparklines.Visible = False
    
        Me.LabelMaxBins.Visible = False
        
        Me.LabelNumTrials.Top = 6
        
        Me.TextBoxLibraryFileName.Top = 18
        
        Me.CommandButtonCancel.Top = 48
        
        Me.CommandButtonOK.Top = 48
        
        Me.Height = 105
    
        Me.CommandButtonReset.Top = 18
        Me.CommandButtonReset.Left = Me.CommandButtonCancel.Left
        Me.CommandButtonReset.Enabled = True
        Me.CommandButtonReset.Visible = True
        Exit Sub
    Else
        '
        ' see if _random_mode range has been defined
        '
        On Error Resume Next
        Err.Clear
        reRandom = Application.Evaluate(ActiveWorkbook.Names("PM_random_mode").RefersTo)
        If Err <> 0 Then
            Err.Clear
            reRandom = Application.Evaluate(ActiveWorkbook.Names("_random_mode").RefersTo)
        End If
        If Err = 0 Then ' the range has been defined, so this is an already initialized model
            '
            ' so display the reset (i.e. re-initialize) form
            '
            Application.OnTime Now(), "ReInitializeModel"
            On Error Resume Next
            Unload Me
        Else
            '
            ' otherwise see if PM_InitialVariableID is defined (by a Generate Input dialog)
            ' in which case fill the initial variable id field with the current value
            '
            Err.Clear
            Me.TextBoxInitVarID = [=PM_InitialVariableID]
            If Err <> 0 Then Me.TextBoxInitVarID = Int(Rnd() * 10000000# + 1)
        End If
    End If
    
    If b1stAct Then
        Call OptionButtonGenerateMode_Click ' default to Generate mode
        Me.OptionButtonGenerateMode.value = True
        Me.TextBoxLibraryFileName.Text = "1000"
        b1stAct = False
    End If
    
End Sub

Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            'c.Font.Size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If
    b1stAct = True
    
End Sub
Attribute VB_Name = "UserFormInsertDistribution"
Attribute VB_Base = "0{E2B23DEE-577F-47AD-BAE5-28A93D99CC21}{74D9B8F1-91F1-4B4C-9CC1-F4BE647DF186}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Public Enum DistTypes
    Ordinary
    Multinormal
    Multiuniform
    Discrete
End Enum

Dim f_nLastRefEdit As Long
Dim f_aLastRefStyle() As Long
Dim f_aRefEditNames() As String
Dim f_bInF4 As Boolean
Dim f_sFmlaTemplate As String
Dim f_bRandCellRequired As Boolean
Dim f_bIsArray As Boolean
Dim f_nDistType As DistTypes ' 0 = no special features, 1 = correlated normal, 2 = correlated uniform

Property Let DistType(nVal As DistTypes)
    f_nDistType = nVal
End Property

Property Get DistType() As DistTypes
    DistType = f_nDistType
End Property

Property Let IsArray(bVal As Boolean)
    f_bIsArray = bVal
End Property

Property Get IsArray() As Boolean
    IsArray = f_bIsArray
End Property

Property Let RandCellRequired(bVal As Boolean)
    f_bRandCellRequired = bVal
End Property

Property Get RandCellRequired() As Boolean
    RandCellRequired = f_bRandCellRequired
End Property

Property Let FormulaTemplate(sVal As String)
    f_sFmlaTemplate = sVal
End Property

Property Get FormulaTemplate() As String
    FormulaTemplate = f_sFmlaTemplate
End Property

Private Sub CheckBoxUseExternalRandom_Click()

    If Me.CheckBoxUseExternalRandom.value = True Then
        Me.RefEditRandCell.Visible = True
        Me.RefEditRandCell.Enabled = True
        Me.LabelRandomValueCell.Visible = True
        Me.OptionButtonUserRNG.Visible = True
        Me.OptionButtonUserRNG.Enabled = True
        'Me.OptionButtonUserRNG.value = True
        Me.RefEditRandCell.SetFocus
    Else
        Me.RefEditRandCell.Visible = False
        Me.RefEditRandCell.Enabled = False
        Me.LabelRandomValueCell.Visible = False
        Me.OptionButtonUserRNG.Visible = False
        Me.OptionButtonUserRNG.Enabled = False
        If Me.OptionButtonHdr.value = False And Me.OptionButtonRand.value = False Then
            Me.OptionButtonRand.value = True
        End If
    End If
    
End Sub

Private Sub CommandButtonCancel_Click()
    On Error Resume Next
    Unload Me
End Sub

Private Sub CommandButtonOK_Click()
    
    Dim aRefStyles() As Long, asFcnArgs() As Variant, n As Long
    Dim rTest As Range
    
    If Me.RandCellRequired Then
        On Error Resume Next
        Err.Clear
        Set rTest = Range(Me.RefEditRandCell)
        If Err <> 0 Then
            MsgBox "This distribution requires that a Random Value Cell be specified2", vbInformation, APP_NAME
            Exit Sub
        End If
    ElseIf Me.RefEditRandCell.value = "" And Me.OptionButtonUserRNG.value = True Then
        MsgBox "If 'User' is selected, you must also select Random value cells.", vbInformation, APP_NAME
        Exit Sub
    End If
    
    If Me.OptionButtonHdr.value = True Then
        If Not hdrCheck Then Exit Sub
    End If
    
    Dim sCholeskyStart As String, sCholeskyEnd As String, sRandStart As String, sRandEnd As String
    
    Select Case Me.DistType
        Case Multinormal
            '
            ' check that Distribution destination range and range of Means have the same shape
            '
            If Range(Me.RefEdit2.Text).Rows.Count <> Range(Me.RefEditDistribution.Text).Rows.Count _
                Or Range(Me.RefEdit2.Text).Columns.Count <> Range(Me.RefEditDistribution.Text).Columns.Count _
            Then
                MsgBox "The Distribution range and the Means range have different shapes. They must be either both rows or both columns.", vbExclamation, APP_NAME
                Exit Sub
            End If
            makeMultiNormal _
                Me.RefEditDistribution.value, Me.RefEdit2.value, _
                Me.RefEdit3.value, Me.OptionButtonUserRNG.value, Me.OptionButtonHdr.value, _
                Me.RefEditRandCell.value, sCholeskyStart, sCholeskyEnd
            Me.RefEdit3.value = Me.RefEditRandCell.value
            Me.RefEdit4.value = sCholeskyStart
        Case Multiuniform
            makeMultiNormal Me.RefEditDistribution.value, "", _
                Me.RefEdit2.value, Me.OptionButtonUserRNG.value, Me.OptionButtonHdr.value, _
                Me.RefEditRandCell.value, sCholeskyStart, sCholeskyEnd
            Me.RefEdit2.value = Me.RefEditRandCell.value
            Me.RefEdit3.value = sCholeskyStart
    End Select
        
    If Me.CheckBoxUseExternalRandom.value = False Then Me.RefEditRandCell.value = ""
            
    ReDim asFcnArgs(0 To 3)
    
    ReDim aRefStyles(0 To 5)
    For n = 0 To 5
        aRefStyles(n) = f_aLastRefStyle(n + 2)
    Next n
    Select Case Me.DistType
        Case Multinormal
            aRefStyles(0) = xlRelative
            aRefStyles(1) = xlAbsolute
            aRefStyles(2) = xlRelative
            aRefStyles(4) = xlRelative
        Case Multiuniform
            aRefStyles(0) = xlAbsolute
            aRefStyles(1) = xlRelative
            'aRefStyles(2) = xlRelative
            aRefStyles(4) = xlRelative
        Case Discrete
            '
            ' Discrete Distribution
            '
            Dim nValRows As Long, nValCols As Long, nDstRows As Long, nDstCols As Long
            
            nValRows = Range(Me.RefEdit2.Text).Rows.Count
            nValCols = Range(Me.RefEdit2.Text).Columns.Count
            nDstRows = Range(Me.RefEditDistribution.Text).Rows.Count
            nDstCols = Range(Me.RefEditDistribution.Text).Columns.Count
            
            If aRefStyles(0) = 0 Then
                '
                ' fix rows or columns depending on shape of destination.
                ' if dest is row, fix columns and vice versa
                '
                If nDstRows > 1 And nDstCols = 1 Then
                    aRefStyles(0) = xlRelRowAbsColumn
                    'aRefStyles(2) = xlRelRowAbsColumn
                ElseIf nDstRows = 1 And nDstCols > 1 Then
                    aRefStyles(0) = xlAbsRowRelColumn
                    'aRefStyles(2) = xlAbsRowRelColumn
                Else
                    aRefStyles(0) = xlAbsolute
                    'aRefStyles(2) = xlAbsolute
                End If
            End If
            aRefStyles(1) = xlRelative
            aRefStyles(2) = 0
            '
            ' check that the Values range, the Probabilities range, and the Cumulative range all have the same # of rows and cols
            '
            If Range(Me.RefEdit2.Text).Rows.Count <> Range(Me.RefEdit3.Text).Rows.Count _
                Or Range(Me.RefEdit2.Text).Rows.Count <> Range(Me.RefEdit4.Text).Rows.Count _
                Or Range(Me.RefEdit2.Text).Columns.Count <> Range(Me.RefEdit3.Text).Columns.Count _
                Or Range(Me.RefEdit2.Text).Columns.Count <> Range(Me.RefEdit4.Text).Columns.Count _
            Then
                MsgBox "the values, probabilities, and cumulative ranges must all be the same shape."
                Exit Sub
            End If
            '
            ' for Discrete distribution, Values and Distribution must have the following relations:
            ' if Values is a single row or column, Distribution must be a single cell
            ' if Values is a rectangle with >=2 rows and >=2 columns, then Distribution should be either
            ' 1) a single row with as many columns as Values, or
            ' 2) a single column with as many rows as Values
            '
            If nValRows = 1 And nValCols = 1 Then
                If vbNo = MsgBox("The Values, Probabilities, and Cumulative Probabilities ranges are single cells. Are you sure that is what you want to do?", vbYesNo Or vbQuestion, APP_NAME) Then
                    Exit Sub
                End If
            ElseIf (nValRows = 1 Or nValCols = 1) And (nDstRows > 1 Or nDstCols > 1) Then
                If vbNo = MsgBox("When the Values are a single row or column, the Distribution should be a single cell, rather than a row or column. Are you sure you want to use these Values and Distributions?", vbYesNo Or vbQuestion, APP_NAME) Then
                    Exit Sub
                End If
            ElseIf (nValRows > 1 And nValCols > 1) And ((nDstRows = 1 And nDstCols <> nValCols) Or (nDstRows <> nValRows And nDstCols = 1)) Then
                MsgBox "When the Values are a rectangle, the Distribution should be either a single row the same width as Values, or else a single column the same height as Values.", vbInformation, APP_NAME
                Exit Sub
            End If
            '
            ' construct a table of cumulative probabilities
            ' notice the repeated RefEdit3 below; this is not an error
            '
            asFcnArgs(0) = Me.RefEdit3.value ' repeated RefEdit3 is correct
            asFcnArgs(1) = Me.RefEdit3.value '
            asFcnArgs(2) = Me.RefEdit3.value
            asFcnArgs(3) = Me.RefEdit5.value
            writeSomeDist Range(Me.RefEdit4.value), Me.RefEditStartVarID.value, _
                False, False, False, "=IF( SUM( _a2_ ) <> 1, NA(), SUM( _0_:_e1_ ) - _e1_ )", _
                "", _
                aRefStyles, asFcnArgs, _
                Range(Me.RefEditDistribution.value).Rows.Count, _
                Range(Me.RefEditDistribution.value).Columns.Count
            
            For n = 0 To 5
                aRefStyles(n) = f_aLastRefStyle(n + 2)
            Next n
    End Select
    
    asFcnArgs(0) = Me.RefEdit2.value
    asFcnArgs(1) = Me.RefEdit3.value
    asFcnArgs(2) = Me.RefEdit4.value
    asFcnArgs(3) = Me.RefEdit5.value
    writeSomeDist Range(Me.RefEditDistribution.value), Me.RefEditStartVarID.value, _
        Me.OptionButtonHdr.value, Me.OptionButtonUserRNG.value, Me.IsArray, _
        Me.FormulaTemplate, _
        Me.RefEditRandCell.value, _
        aRefStyles, asFcnArgs ' _
        Me.RefEdit2.value , _
        Me.RefEdit3.value, _
        Me.RefEdit4.value, _
        Me.RefEdit5.value
    
    On Error Resume Next
    Unload Me
    
End Sub

Private Sub UserForm_Activate()

    On Error Resume Next
    Me.RefEditDistribution = Selection.Address
    Err.Clear
    Me.RefEditStartVarID = [=PM_InitialVariableID]
    If Err <> 0 Then Me.RefEditStartVarID = Int(1 + Rnd() * 10000000#)
    On Error GoTo 0
    If Me.RefEdit2.Enabled Then
        With Me.RefEdit2
            .SetFocus
            .SelStart = 0
            .SelLength = Len(.Text)
        End With
    ElseIf Me.RefEditStartVarID.Enabled Then
        With Me.RefEditStartVarID
            .SetFocus
            .SelStart = 0
            .SelLength = Len(.Text)
        End With
    End If
    
End Sub

Private Sub CommandButtonF4_Click()

    Dim sRefEditFmla As String
    
    If Me.DistType > 0 And f_nLastRefEdit <> 7 Then
        MsgBox "This field's referency type cannot be changed.", vbExclamation, APP_NAME
        'sndPlaySound32 "C:\Windows\Media\Windows Error.wav", 0&
        Exit Sub
    End If
    
    On Error Resume Next
    Err.Clear
    f_bInF4 = True
    
    sRefEditFmla = Me.Controls(f_aRefEditNames(f_nLastRefEdit)).Text
    If f_aLastRefStyle(f_nLastRefEdit) = 0 Then f_aLastRefStyle(f_nLastRefEdit) = 1
    f_aLastRefStyle(f_nLastRefEdit) = (f_aLastRefStyle(f_nLastRefEdit) Mod 4) + 1
    sRefEditFmla = Application.ConvertFormula(sRefEditFmla, xlA1, xlA1, f_aLastRefStyle(f_nLastRefEdit))
    If Err <> 0 Then Beep
    Err.Clear
    Me.Controls(f_aRefEditNames(f_nLastRefEdit)).Text = sRefEditFmla
    
    f_bInF4 = False

End Sub

Private Sub RefEditDistribution_Change()
    If Not f_bInF4 Then If f_aLastRefStyle(1) > 0 Then f_aLastRefStyle(1) = xlAbsolute
End Sub

Private Sub RefEditDistribution_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    f_nLastRefEdit = 1
End Sub

Private Sub RefEdit2_Change()
    If Not f_bInF4 Then If f_aLastRefStyle(2) > 0 Then f_aLastRefStyle(2) = xlAbsolute
End Sub

Private Sub RefEdit2_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    f_nLastRefEdit = 2
End Sub

Private Sub RefEdit3_Change()
    If Not f_bInF4 Then If f_aLastRefStyle(3) > 0 Then f_aLastRefStyle(3) = xlAbsolute
End Sub

Private Sub RefEdit3_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    f_nLastRefEdit = 3
End Sub

Private Sub RefEdit4_Change()
    If Not f_bInF4 Then If f_aLastRefStyle(4) > 0 Then f_aLastRefStyle(4) = xlAbsolute
End Sub

Private Sub RefEdit4_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    f_nLastRefEdit = 4
End Sub

Private Sub RefEdit5_Change()
    If Not f_bInF4 Then If f_aLastRefStyle(5) > 0 Then f_aLastRefStyle(5) = xlAbsolute
End Sub

Private Sub RefEdit5_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    f_nLastRefEdit = 5
End Sub

Private Sub RefEditRandCell_Change()
    If Not f_bInF4 Then If f_aLastRefStyle(6) > 0 Then f_aLastRefStyle(6) = xlAbsolute
End Sub

Private Sub RefEditRandCell_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    f_nLastRefEdit = 6
End Sub

Private Sub RefEditStartVarID_Change()
    If Not f_bInF4 Then If f_aLastRefStyle(7) > 0 Then f_aLastRefStyle(7) = xlAbsolute
End Sub

Private Sub RefEditStartVarID_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    f_nLastRefEdit = 7
End Sub

Private Sub UserForm_Initialize()
    ReDim f_aLastRefStyle(1 To 7), f_aRefEditNames(1 To 7)
    f_aRefEditNames(1) = "RefEditDistribution"
    f_aRefEditNames(2) = "RefEdit2"
    f_aRefEditNames(3) = "RefEdit3"
    f_aRefEditNames(4) = "RefEdit4"
    f_aRefEditNames(5) = "RefEdit5"
    f_aRefEditNames(6) = "RefEditRandCell"
    f_aRefEditNames(7) = "RefEditStartVarID"
End Sub
Attribute VB_Name = "UserFormInsertMetalog"
Attribute VB_Base = "0{15B4ADD4-D87A-4CD1-B30B-BC1312F1FBAC}{78FCEA1C-2399-4CF4-A40C-8E5797938A0E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
Option Explicit

Const templateFileName As String = "SPT Metalogs for SIPmath.xlsx"


Dim vhwc As Long, vhwoc As Long, vw As Long, hhwc As Long, hhwoc As Long, hw As Long
' Vertical layout Height With Chart, Vertical layout Height WithOut Chart, Vertical Width, ...
Dim vsr As Long, vsc As Long, vrr As Long, vrc As Long, hsr As Long, hsc As Long, hrr As Long, hrc As Long
' Vertical layout Start var id cell Row,... Vertical layout Random cell Row,...

Private Sub CheckBoxIncludeCharts_Click()
    If Me.OptionButtonVertical.value = True Then
        If Me.CheckBoxIncludeCharts.value = True Then
            Me.LabelDimensions.Caption = "3 columns and 152 rows per variable"
        Else
            Me.LabelDimensions.Caption = "3 columns and 14 rows per variable"
        End If
    Else
        If Me.CheckBoxIncludeCharts.value = True Then
            Me.LabelDimensions.Caption = "11 columns and 132 rows per variable"
        Else
            Me.LabelDimensions.Caption = "11 columns and 4 rows per variable"
        End If
    End If
End Sub

Private Sub CommandButtonCancel_Click()
    On Error Resume Next
    Unload Me
End Sub

Private Sub CommandButtonOK_Click()
    
    Dim destRng As Range, destAddr As String, numCols As Long, dataCount As Long, errMsg As String
    Dim mtlgNum As Long
    
    On Error Resume Next
    mtlgNum = [=PM_mtlgNum]
    If Err <> 0 Then mtlgNum = 1
    
    On Error GoTo UBIMCBO_C_error
    
    errMsg = "Could not read starting location " & Me.RefEditStrtLocn.Text
    Set destRng = Range(Me.RefEditStrtLocn.Text)
    destAddr = destRng.Address(, , , 1)
    
    errMsg = "Could not evaluate number of variables " & Me.TextBoxNumVars.Text
    'numCols = Application.Evaluate(Me.TextBoxNumVars.Text)
    On Error Resume Next
    numCols = CLng(Me.TextBoxNumVars.Text)
    If Err <> 0 Then
        Err.Clear
        On Error GoTo UBIMCBO_C_error
        numCols = CLng(Range(Me.TextBoxNumVars.Text).Value2)
    End If
    
    If numCols <> Int(numCols) Or numCols < 1 Then
        errMsg = "Number of variables must be a whole number greater than zero."
        Err.Raise vbObjectError + 513
    End If
    
    errMsg = "Error attempting to check for data in destination range starting at " & Me.RefEditStrtLocn
    If Me.OptionButtonVertical.value = True Then
        If Me.CheckBoxIncludeCharts.value = True Then
            Set destRng = destRng.Resize(vhwc, vw * numCols)
        Else
            Set destRng = destRng.Resize(vhwoc, vw * numCols)
        End If
    Else
        If Me.CheckBoxIncludeCharts.value = True Then
            Set destRng = destRng.Resize(hhwc, hw * numCols)
        Else
            Set destRng = destRng.Resize(hhwoc, hw * numCols)
        End If
    End If
    
    errMsg = "Error counting data in destination range " & destRng.Address(0, 0)
    dataCount = Application.WorksheetFunction.CountA(destRng)
        
    errMsg = ""
    
    If dataCount > 0 Then
        If vbNo = MsgBox("There is data in the destination range " & destRng.Address(0, 0) & ". Do you want to overwrite it?", vbInformation Or vbYesNo, APP_NAME) Then
            Exit Sub
        End If
    End If
    
    Dim startVarIDVal As Long, StartVarIdCell As Range, originalVIDCellAddr As String
    errMsg = "Could not read Start Var ID value"
    startVarIDVal = Application.Evaluate(Me.RefEditStartVarID.Text)
    On Error Resume Next
    Err.Clear
    Set StartVarIdCell = Range(Me.RefEditStartVarID.Text)
    If Err <> 0 Then originalVIDCellAddr = "" Else originalVIDCellAddr = Me.RefEditStartVarID.Text
    
    On Error GoTo UBIMCBO_C_error

    '
    ' copy metalog formulas from template file
    '
    Dim mtlgTplt As Workbook
    Dim tgtCell As Range, varCount As Long, tgtCellAddr As String
    Dim chartCount As Long
    Dim aRefStyles(0 To 5) As Long
    Dim asFcnArgs(0 To 3) As Variant

    Application.ScreenUpdating = False
    
#If Mac Then
    errMsg = "Error opening metalog template file " & ThisWorkbook.path & "/" & templateFileName
#Else
    errMsg = "Error opening metalog template file " & ThisWorkbook.path & "\" & templateFileName
#End If

    For varCount = 1 To numCols
#If Mac Then
        Set mtlgTplt = Workbooks.Open(ThisWorkbook.path & "/" & templateFileName)
#Else
        Set mtlgTplt = Workbooks.Open(ThisWorkbook.path & "\" & templateFileName)
#End If
        If Me.OptionButtonVertical.value = True Then
            Set tgtCell = Range(destAddr)(1, 1).Offset(0, varCount * vw - vw)
        Else
            Set tgtCell = Range(destAddr)(1, 1).Offset(0, varCount * hw - hw)
        End If
        tgtCellAddr = tgtCell.Address
        
        errMsg = "Error copying metalog formulas"
        If Me.OptionButtonVertical.value = True Then
            If Me.CheckBoxIncludeCharts.value = True Then
                mtlgTplt.Sheets("vertical layout").Range("B4").Resize(vhwc, vw).Cut tgtCell
            Else
                mtlgTplt.Sheets("vertical layout").Range("B4").Resize(vhwoc, vw).Cut tgtCell
            End If
            mtlgTplt.Sheets("vertical layout").Range("B2:D2").Copy
        Else
            If Me.CheckBoxIncludeCharts.value = True Then
                mtlgTplt.Sheets("horizontal layout").Range("B4").Resize(hhwc, hw).Cut tgtCell
            Else
                mtlgTplt.Sheets("horizontal layout").Range("B4").Resize(hhwoc, hw).Cut tgtCell
            End If
            mtlgTplt.Sheets("vertical layout").Range("B2:D2").Copy
        End If
        tgtCell.PasteSpecial Paste:=xlPasteColumnWidths, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
        Set tgtCell = tgtCell.Parent.Range(tgtCellAddr)
#If Mac Then
        tgtCell.Parent.Activate
#End If
        errMsg = ""
        
        If Me.OptionButtonVertical.value = True Then
            Set StartVarIdCell = tgtCell.Offset(vsr, vsc)
            '
            ' put in rand() or hdr formula in the random variable cell location
            '
            If Me.OptionButtonUserRNG.value <> True Then
                writeSomeDist tgtCell.Offset(vrr, vrc), _
                    StartVarIdCell.Address(, , , 1), _
                    Me.OptionButtonHdr.value, Me.OptionButtonUserRNG, False, "=_r_", "", aRefStyles, asFcnArgs
            End If
        Else
            Set StartVarIdCell = tgtCell.Offset(hsr, hsc)
            '
            ' put in rand() or hdr formula in the random variable cell location
            '
            If Me.OptionButtonUserRNG.value <> True Then
                writeSomeDist tgtCell.Offset(hrr, hrc), _
                    StartVarIdCell.Address(, , , 1), _
                    Me.OptionButtonHdr.value, Me.OptionButtonUserRNG, False, "=_r_", "", aRefStyles, asFcnArgs
            End If
        End If
        mtlgTplt.Close False
        If originalVIDCellAddr = "" Then
            StartVarIdCell.value = startVarIDVal
        Else
            StartVarIdCell.Formula = "=" & mtlgNum & " + " & originalVIDCellAddr
        End If
        tgtCell.Offset(2, 0).value = "metalog_" & mtlgNum ' startVarIDVal
        mtlgNum = mtlgNum + 1
        startVarIDVal = startVarIDVal + 1
    Next varCount
    
    Names.Add "PM_InitialVariableID", startVarIDVal
    Names.Add "PM_mtlgNum", mtlgNum
    
    Application.ScreenUpdating = True
    Unload Me
    Exit Sub
    
UBIMCBO_C_error:
    If errMsg = "" Then errMsg = Err.Description
    MsgBox errMsg, vbExclamation, APP_NAME
    Exit Sub
    
End Sub

Private Sub LabelAbtMtlgDstbtns_Click()
    ThisWorkbook.FollowHyperlink "http://www.metalogdistributions.com"
End Sub

Private Sub LabelMtlgEqns_Click()
    ThisWorkbook.FollowHyperlink "http://www.metalogdistributions.com/equations.html"
End Sub

Private Sub LabelMtlgPubs_Click()
    ThisWorkbook.FollowHyperlink "http://www.metalogdistributions.com/publications.html"
End Sub

Private Sub LabelXLWkbks_Click()
    ThisWorkbook.FollowHyperlink "http://www.metalogdistributions.com/excelworkbooks.html"
End Sub

Private Sub LabelTutorial_Click()
    ThisWorkbook.FollowHyperlink "http://www.metalogdistributions.com/downloads/sipmath.html"
End Sub

Private Sub OptionButtonHorizontal_Click()
    If Me.CheckBoxIncludeCharts.value = True Then
        Me.LabelDimensions.Caption = "11 columns and 132 rows per variable"
    Else
        Me.LabelDimensions.Caption = "11 columns and 4 rows per variable"
    End If
End Sub

Private Sub OptionButtonVertical_Click()
    If Me.CheckBoxIncludeCharts.value = True Then
        Me.LabelDimensions.Caption = "3 columns and 152 rows per variable"
    Else
        Me.LabelDimensions.Caption = "3 columns and 14 rows per variable"
    End If
End Sub

Private Sub UserForm_Activate()
    On Error Resume Next
    Me.RefEditStrtLocn.Text = ActiveCell.Address(, , , 1)
    Me.RefEditStartVarID = [=PM_InitialVariableID]
End Sub

Private Sub UserForm_Initialize()
    Application.ScreenUpdating = False
    On Error Resume Next
    Dim mtlgTplt As Workbook
#If Mac Then
    Set mtlgTplt = Workbooks.Open(ThisWorkbook.path & "/" & templateFileName)
#Else
    Set mtlgTplt = Workbooks.Open(ThisWorkbook.path & "\" & templateFileName)
#End If
    If Err = 0 Then
        With mtlgTplt.Sheets("Metadata")
            vhwc = .Range("B2")
            vhwoc = .Range("C2")
            vw = .Range("D2")
'Dim vsr As Long, vsc As Long, vrr As Long, vrc As Long, hsr As Long, hsc As Long, hrr As Long, hrc As Long
            vsr = .Range("E2")
            vsc = .Range("F2")
            vrr = .Range("G2")
            vrc = .Range("H2")
            hhwc = .Range("B3")
            hhwoc = .Range("C3")
            hw = .Range("D3")
            hsr = .Range("E3")
            hsc = .Range("F3")
            hrr = .Range("G3")
            hrc = .Range("H3")
        End With
        mtlgTplt.Close
    Else
        MsgBox APP_NAME & " could not load the template file " & templateFileName, vbCritical, APP_NAME
        Unload Me
    End If
    Application.ScreenUpdating = True
End Sub
Attribute VB_Name = "UserFormInstructions"
Attribute VB_Base = "0{AD4133AB-9CAB-41D5-B7F4-19693D7565FD}{44E180BF-B0C5-4195-95F1-A536080C453B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Private Sub CommandButtonOK_Click()
    On Error Resume Next
    Unload Me
End Sub

Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Me.Height = Me.Height * 1.33
        Me.Width = Me.Width * 1.33
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            c.Font.Size = 10
            c.Height = c.Height * 1.33
            c.Width = c.Width * 1.33
            c.Top = c.Top * 1.33
            c.Left = c.Left * 1
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub

Attribute VB_Name = "UserFormResetModel"
Attribute VB_Base = "0{379BF361-C50D-4ADF-B502-6A1F2777AD7D}{6691E044-14E8-4B7E-ADA7-93B7C70F84CD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Private Sub CancelButton_Click()
    Unload Me
End Sub

Private Sub OKButton_Click()
    
    Dim n As Name, sPName As String 'Parent Name
    Dim r As Range
    Dim numRows As Long
    
'''    If Me.CheckBoxClearOutputs Then
        On Error Resume Next
        Set r = Nothing
        Err.Clear
        Set r = ActiveWorkbook.Sheets("PMTable").Range("C2")
        If Err = 0 Then
            Do Until IsEmpty(r)
                ActiveWorkbook.Names(r.value).Delete
                Set r = r.Offset(0, 1)
            Loop
            With ActiveWorkbook.Sheets("PMTable").Range("C4")
                If .HasArray Then
                    numRows = .CurrentArray.Rows.Count
                    .CurrentArray.Borders.LineStyle = xlNone
                    .CurrentArray.Offset(-1, 1).Resize(numRows + 1).Clear
                End If
            End With
        End If
        Application.DisplayAlerts = False
'''        On Error Resume Next
        ActiveWorkbook.Sheets("PMTable").Delete
        On Error GoTo 0
'''    End If
        
'''    If Me.CheckBoxClearChartData Then
        On Error Resume Next ' so you don't get an error if there's no scd sheet
        With ActiveWorkbook.Sheets(scd)
            .Range(.Range("A1"), .Range("A1").SpecialCells(xlCellTypeLastCell)).Clear
        End With
        For Each n In ActiveWorkbook.Names
            sPName = ""
            On Error Resume Next
            sPName = n.RefersToRange.Parent.Name
            Err.Clear
            On Error GoTo 0
            If sPName = scd Then n.Delete
        Next n
        Application.DisplayAlerts = False
        On Error Resume Next
        ActiveWorkbook.Sheets(scd).Delete
        On Error GoTo 0
'''    End If
    
    On Error Resume Next
    Dim bLocal As Boolean
    Err.Clear
    bLocal = [=PM_local_library]
    If Err <> 0 Then bLocal = [=local_library]
    With ActiveWorkbook
        .Names("_random_mode").Delete
        .Names("PM_random_mode").Delete
        .Names("local_library").Delete
        .Names("PM_local_library").Delete
        .Names("library_file_name").Delete
        .Names("PM_library_file_name").Delete
        .Names("PM_Index").Delete
        If Not bLocal Then
            .Names("PM_Trials").Delete
            .Names("PM_Meta").Delete
            .Names("PM_Meta_INDEX").Delete
            .Names("PM_IV").Delete
            .Names("PM_IV_INDEX").Delete
        End If
        .Names("sparklinesForInputs").Delete
        .Names("PM_sparklinesForInputs").Delete
        .Names("sparklinesForOutputs").Delete
        .Names("PM_sparklinesForOutputs").Delete
        .Names("sparklinesIONumberOfBins").Delete
        .Names("PM_sparklinesIONumberOfBins").Delete
    End With
        
    Application.OnTime Now(), "Setup"
    Unload Me

End Sub

Private Sub UserForm_Initialize()
    Me.OKButton.Top = 12
    Me.CancelButton.Top = 12
    Me.Height = 69
    
    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            'c.font.size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub

Attribute VB_Name = "UserFormSelectOutputs"
Attribute VB_Base = "0{1AE6036F-E9C9-495A-81DA-9F9FE485F74C}{C83F11F4-2DA9-43FD-A3D9-4F9A0126D6E5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Private nCountOutputs As Long
Private nCountMetadata As Long

Private Sub CheckBoxAddToExistingLib_Click()
    
    g_bAddToExistingLib = Me.CheckBoxAddToExistingLib.value
    If g_bAddToExistingLib Then
        Me.CommandButtonGetLib.Enabled = True
        Me.CommandButtonGetLib.Visible = True
        Me.LabelLibFile.Visible = True
        Me.TextBoxLibName.Locked = True
        Me.TextBoxLibName.BackColor = vbButtonFace
        Me.TextBoxLibProv.Locked = True
        Me.TextBoxLibProv.BackColor = vbButtonFace
    Else
        Me.CommandButtonGetLib.Enabled = False
        Me.CommandButtonGetLib.Visible = False
        Me.LabelLibFile.Visible = False
        Me.TextBoxLibName.Locked = False
        Me.TextBoxLibName.BackColor = vbWindowBackground
        Me.TextBoxLibProv.Locked = False
        Me.TextBoxLibProv.BackColor = vbWindowBackground
    End If
    
End Sub

Private Sub CommandButtonCancel_Click()

    g_vOutputList = False
    On Error Resume Next
    Unload Me
    
End Sub

Private Sub CommandButtonGetLib_Click()
    Dim v As Variant
    v = Application.GetOpenFilename(Title:="Select an existing SIP Library file:")
    If VarType(v) = vbString Then
        g_sExistingLibName = v
        Me.LabelLibFile.Caption = g_sExistingLibName
    End If
End Sub

Private Sub CommandButtonOK_Click()

    Dim L As Long
    Dim n As Long
    Dim rMeta As Range
    Dim rMetaRow As Range
    
    On Error Resume Next
    Err.Clear
    Set rMeta = Range(Me.RefEditMetadata.value)
    If Err <> 0 Then
        MsgBox "Invalid metadata range", vbExclamation, APP_NAME
        Exit Sub
    End If
    On Error GoTo 0
    
    If Me.ListBoxOutputNames.ListCount < 1 Then
        MsgBox "Please select at least one output", vbExclamation, APP_NAME
        Exit Sub
    End If
    
    g_vOutputList = Split("", ",")   ' to create an empty array
    g_vMetadataList = Split("", ",") ' ditto
    
    ReDim g_vOutputList(1 To Me.ListBoxOutputNames.ListCount)
    For L = 0 To Me.ListBoxOutputNames.ListCount - 1
        If Me.ListBoxOutputNames.Selected(L) Then
            g_vOutputList(L + 1) = Me.ListBoxOutputNames.List(L)
        End If
    Next L
    
    n = 0
    If Me.OptionButtonNoMetadata.value <> True Then
        For L = 0 To Me.ListBoxMetadata.ListCount - 1
            If Me.ListBoxMetadata.Selected(L) Then
                n = n + 1
                ReDim Preserve g_vMetadataList(1 To n)
                If Me.OptionButtonLeftCol.value = True Then
                    g_vMetadataList(n) = rMeta.Rows(L + 1).Address
                Else
                    g_vMetadataList(n) = rMeta.Columns(L + 1).Address
                End If
            End If
        Next L
    Else
        '
        ' get metadata from just below data table on sheet PMTable
        '
        Set rMetaRow = Sheets("PMTable").Range("C2")
        Set rMetaRow = Range(rMetaRow(1, 0), rMetaRow.End(xlToRight))
        Set rMetaRow = rMetaRow.Offset(2 + [=PM_Trials], 0)
        Do Until IsEmpty(rMetaRow(1, 1)) Or rMetaRow.row > 2 ^ 20 - 2
            n = n + 1
            ReDim Preserve g_vMetadataList(1 To n)
            g_vMetadataList(n) = Range(rMetaRow, rMetaRow).Address(True, True, xlA1, True)
            Set rMetaRow = rMetaRow.Offset(1, 0)
        Loop
    End If
    
    g_sLibProvenance = Me.TextBoxLibProv.Text
    g_sLibName = Me.TextBoxLibName.Text
    
    On Error Resume Next
    Unload Me
    
End Sub

Private Sub addAttributeName(rAtt As Range)
    
    Dim sAtt As String
    Dim bValidAtt As Boolean
    Dim nDx As Long
    
    sAtt = rAtt.Value2
    bValidAtt = True
    If 0 = InStr("_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", Left(sAtt, 1)) Then
        bValidAtt = False
    End If
    For nDx = 2 To Len(sAtt)
        If 0 = InStr("_-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", Mid(sAtt, nDx, 1)) Then
            bValidAtt = False
        End If
    Next nDx
    
End Sub

Sub fillWithRows()
    Dim c As Range
    Dim rMeta As Range
    
    On Error Resume Next
    Err.Clear
    Set rMeta = Range(Me.RefEditMetadata.value)
    If Err <> 0 Then
        MsgBox "Invalid metadata range", vbExclamation, APP_NAME
        Exit Sub
    End If
    On Error GoTo 0
    Me.LabelOrientation.Caption = "Select metadata rows"
    Me.ListBoxMetadata.Clear
    For Each c In rMeta.Rows
        Me.ListBoxMetadata.AddItem c.Cells(1).Value2
    Next c
    nCountMetadata = 0

End Sub

Sub fillWithColumns()
    
    Dim c As Range
    Dim rMeta As Range
    
    On Error Resume Next
    Err.Clear
    Set rMeta = Range(Me.RefEditMetadata.value)
    If Err <> 0 Then
        MsgBox "Invalid metadata range", vbExclamation, APP_NAME
        Exit Sub
    End If
    On Error GoTo 0
    Me.LabelOrientation.Caption = "Select metadata columns"
    Me.ListBoxMetadata.Clear
    For Each c In rMeta.Columns
        Me.ListBoxMetadata.AddItem c.Cells(1).Value2
    Next
    nCountMetadata = 0
    
End Sub

Private Sub ListBoxMetadata_Change()
    
    nCountMetadata = 0
    Dim n As Long
    For n = 0 To Me.ListBoxMetadata.ListCount - 1
        If Me.ListBoxMetadata.Selected(n) Then nCountMetadata = nCountMetadata + 1
    Next n
    
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If
    

End Sub

Private Sub ListBoxMetadata_Click()
    
    nCountMetadata = 0
    Dim n As Long
    For n = 0 To Me.ListBoxMetadata.ListCount - 1
        If Me.ListBoxMetadata.Selected(n) Then nCountMetadata = nCountMetadata + 1
    Next n
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If
    
End Sub

Private Sub ListBoxOutputNames_Change()

    nCountOutputs = 0
    Dim n As Long
    For n = 0 To Me.ListBoxOutputNames.ListCount - 1
        If Me.ListBoxOutputNames.Selected(n) Then nCountOutputs = nCountOutputs + 1
    Next n
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If

End Sub

Private Sub ListBoxOutputNames_Click()

    nCountOutputs = 0
    Dim n As Long
    For n = 0 To Me.ListBoxOutputNames.ListCount - 1
        If Me.ListBoxOutputNames.Selected(n) Then nCountOutputs = nCountOutputs + 1
    Next n
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If
    
End Sub

Private Sub OptionButtonLeftCol_Click()
    
    If Me.OptionButtonLeftCol.value <> True Then
        fillWithColumns
    Else
        fillWithRows
    End If
    
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If

End Sub

Private Sub OptionButtonNoMetadata_Click()
    
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If
    
End Sub

Private Sub OptionButtonTopRow_Click()
    
    If Me.OptionButtonTopRow.value = True Then
        fillWithColumns
    Else
        fillWithRows
    End If
    
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If

End Sub

Private Sub TextBoxLibName_Change()
    
'''    If Me.TextBoxLibName.value <> "" _
'''        And Me.TextBoxLibProv.value <> "" _
'''        And nCountOutputs > 0 _
'''        And (nCountMetadata > 0 Or Me.OptionButtonNoMetadata.value = True) _
'''    Then
'''        Me.CommandButtonOK.Enabled = True
'''    Else
'''        Me.CommandButtonOK.Enabled = False
'''    End If
    
End Sub

Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            'c.font.size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
        Me.MultiPage1.BackColor = Me.BackColor
    End If
    '
    ' fill list box with output names
    '
    Dim n As Name
    Dim rOutput As Range
    
    On Error Resume Next
    '
    ' get names from PMTable!C2 and cells to the right
    '
    Set rOutput = ActiveWorkbook.Sheets("PMTable").Range("C2")
    Do Until rOutput Is Nothing Or IsEmpty(rOutput.Value2)
        Set n = ActiveWorkbook.Names(rOutput.Value2)
        If Not n Is Nothing Then
            Me.ListBoxOutputNames.AddItem n.Name
        End If
        Set rOutput = rOutput.Offset(0, 1)
    Loop
    Me.ListBoxMetadata.AddItem " "
    Me.ListBoxMetadata.Clear
'    For Each N In ActiveWorkbook.Names
'        If N.RefersToRange.Parent.Name <> "PMTable" Then GoTo next_n
'        If N.RefersToRange.Row <= 1 Then GoTo next_n
'        If N.RefersToRange.Columns.Count <> 1 Then GoTo next_n
'        '
'        ' n is (probably) an output name, so add it to the listbox
'        '
'        Me.ListBoxOutputNames.AddItem N.Name
'next_n:
'    Next N

    Me.CheckBoxAddToExistingLib.value = False
    Me.CommandButtonGetLib.Enabled = False
    Me.CommandButtonGetLib.Visible = False
    Me.LabelLibFile.Visible = False
    Me.ListBoxOutputNames.MultiSelect = fmMultiSelectExtended
    Me.ListBoxMetadata.MultiSelect = fmMultiSelectExtended
    Me.RefEditMetadata.Text = ActiveWindow.RangeSelection.Address
    '''Me.CommandButtonOK.Enabled = False
    nCountOutputs = 0
    nCountMetadata = 0
    
End Sub
Attribute VB_Name = "UserFormSettings"
Attribute VB_Base = "0{B1D4ACB8-617D-48B6-BAF5-1EE67FB8CB47}{389A20A6-9073-427A-8B66-1B9C90D3FBE5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Dim bCbOn As Boolean, bArOn As Boolean

#If False Then
Public value
#End If

Private Sub CommandButtonCancel_Click()
    Unload Me
End Sub

Private Sub CommandButtonOK_Click()

    On Error Resume Next
    If Me.TextBoxDefNumBins > 100 Then
        MsgBox "Number of bins must be <= 100", vbExclamation, APP_NAME
        Exit Sub
    End If
    ActiveWorkbook.Names.Add "PM_DfltBins", Me.TextBoxDefNumBins
    ActiveWorkbook.Names.Add "PM_SparklinesIONumberOfBins", Me.TextBoxDefNumBins
    'ActiveWorkbook.Names.Add "PM_Index", Me.TextBoxPMIndex
    ActiveWorkbook.Sheets("PMTable").Range("PM_Index") = Me.TextBoxPMIndex
    ActiveWorkbook.Names.Add "PM_InitialVariableID", Me.TextBoxVarId
    ActiveWorkbook.Names.Add "PM_DfltChart", Me.CheckBoxDefChart
    ThisWorkbook.Names.Add "PM_AutoCalc", Me.CheckBoxAutoCalc
    ThisWorkbook.Names.Add "PM_warnAutoCalc", Me.CheckBoxWarnAutoCalc
#If Mac Then
#Else
    ' don't Call notAvailableMsg but replace with code from version 3.4.0 for Enterprise Version
#End If
    
    Unload Me
    
End Sub

Private Sub UserForm_Activate()
    On Error Resume Next
    Me.TextBoxNumberOfTrials = [=PM_Trials]
    If [=PM_random_mode] Then
        Me.TextBoxMode = "Generate"
    ElseIf [=PM_local_library] Then
        Me.TextBoxMode = "Local Library"
    Else
        Me.TextBoxMode = "Library: " & [=PM_library_file_name]
    End If
    Me.TextBoxDefNumBins = [=PM_DfltBins]
    Me.TextBoxPMIndex = [=PM_Index]
    Me.TextBoxVarId = [=PM_InitialVariableID]
    If [=PM_DfltChart] Then Me.CheckBoxDefChart = True Else Me.CheckBoxDefChart = False
    Me.CheckBoxAutoCalc = Application.Evaluate(ThisWorkbook.Names("PM_autocalc").RefersTo)
    Me.CheckBoxWarnAutoCalc = Application.Evaluate(ThisWorkbook.Names("PM_warnAutoCalc").RefersTo)
#If Mac Then
#Else
    Me.CheckBoxUseAtRisk.value = Application.Evaluate(ThisWorkbook.Names("UseAtRisk").RefersTo)
    Me.CheckBoxUseCb.value = Application.Evaluate(ThisWorkbook.Names("UseCB").RefersTo)
    bCbOn = Me.CheckBoxUseCb.value
    bArOn = Me.CheckBoxUseAtRisk.value
#End If

End Sub


Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            'c.font.size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
        
        Me.CheckBoxUseAtRisk.Visible = False
        Me.CheckBoxUseCb.Visible = False
        Me.CheckBoxUseAtRisk.Enabled = False
        Me.CheckBoxUseCb.Enabled = False
        
    End If

End Sub
Attribute VB_Name = "UserFormYesNoYestoall"
Attribute VB_Base = "0{5E63C53F-A894-4171-8FDB-81E6011A8A05}{DD8CD290-D642-4568-857C-5234EA192FB9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Private m_nResult As Long
Private m_sMessage As String

Public Property Let Message(sMessage As String)
    m_sMessage = sMessage
End Property

Public Property Get Result() As Long
    Result = m_nResult
End Property

Private Sub CommandButtonCancel_Click()
    m_nResult = 0
    Me.Hide
End Sub

Private Sub CommandButtonYes_Click()
    m_nResult = 1
    Me.Hide
End Sub

Private Sub CommandButtonYesToAll_Click()
    m_nResult = 2
    Me.Hide
End Sub

Private Sub UserForm_Activate()
    Me.LabelMsg.Caption = m_sMessage
End Sub

Private Sub UserForm_Initialize()

    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            'c.font.size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
  'Intercept/repurpose Unload if user clicks form "X" close button.
  If CloseMode = 0 Then
    Cancel = True
    m_nResult = 0
    Me.Hide
  End If
End Sub
Attribute VB_Name = "UserForm_smmt_Graphs"
Attribute VB_Base = "0{89AC6009-6B15-4C0F-8B54-3CB77C42159E}{F9A9F95B-C239-492A-A42D-E2FADB741E8D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Const ID_chars As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"

Const DATA_ONLY_MODE As Long = 0
Const CHART_MODE As Long = 1
Const COPY_FORMULAS_MODE As Long = 2

Dim deltaHeight As Double, copyFormulasDeltaHeight As Double, chartOutputsDeltaHeight As Double
Dim standAloneDelta As Double

Dim dlg_mode As Long

Dim outputRangeList() As String, allRangeList() As String
Dim outputRangeCount As Long, allRangeCount As Long

#If PROJECT = SIPMATH_HISTOGRAM Then

Private Function smh_selectionTitle()
    If Me.OptionButtonChartSelectedData Then smh_selectionTitle = "Data" Else smh_selectionTitle = "Outputs"
End Function

#Else

Private Function smmt_selectionTitle()
    If Me.OptionButtonChartSelectedData Then smmt_selectionTitle = "Data" Else smmt_selectionTitle = "Outputs"
End Function

#End If

Private Sub CheckBoxIntegerChart_Click()
    Me.ScrollBarNumberBins.Enabled = Not Me.CheckBoxIntegerChart.value
    Me.LabelNumberBins.Enabled = Not Me.CheckBoxIntegerChart
End Sub

Private Sub CommandButtonCancel_Click()
    On Error Resume Next
    Unload Me
End Sub

#If PROJECT = SIPMATH_HISTOGRAM Then

Private Sub smh_CopyFormulasOK()
    
#Else

Private Sub smmt_CopyFormulasOK()
    
#End If

    Dim outputName As Variant, outputRange_Unused As Range
    Dim f As Long, rm As Long, cm As Long
    Dim outputCell As Range
    Dim lastSelection As Object, lastActiveSheet As Object, i As Long, replaceIt As Boolean
    
    Dim firstOutputName As String, formulaCell As Range, formulaString As String
    
    Application.ScreenUpdating = False
    Set lastSelection = Selection
    Set lastActiveSheet = ActiveSheet
    Me.Hide
    rm = 0
    cm = 0
    If Me.OptionButtonColumn.value Then rm = 1 ' I know this seems backwards but it's really correct.
    If Me.OptionButtonRow.value Then cm = 1    '
    f = 0
    For Each outputCell In Range(Me.RefEditGraphRanges.value) ' this is the RefEditOutputNames control when copying formulas
        If f = 0 Then ' 1st output cell; save the name; it will be replaced by the other names when copying the formulas
#If PROJECT = SIPMATH_HISTOGRAM Then
            smh_getOutputNameAndRange outputCell, firstOutputName, outputRange_Unused
#Else
            smmt_getOutputNameAndRange outputCell, firstOutputName, outputRange_Unused
#End If
        Else ' copy the formulas, replacing the firstOutputName with the current outputName
            On Error GoTo ufg_cfo_could_not_find_output
#If PROJECT = SIPMATH_HISTOGRAM Then
            smh_getOutputNameAndRange outputCell, outputName, outputRange_Unused
#Else
            smmt_getOutputNameAndRange outputCell, outputName, outputRange_Unused
#End If
            On Error GoTo 0
            For Each formulaCell In Range(Me.RefEditFrequencyDest.value) ' this is the RefEditFormulasToCopy control when copying formulas
                formulaString = formulaCell.FormulaR1C1
                i = InStr(formulaString, firstOutputName)
                Do While i > 0
                    ' see if characters before and after the found name are non-identifier characters
                    replaceIt = True
                    If i > 1 Then ' there is a character before it
                        If 0 <> InStr(ID_chars, Mid(formulaString, i - 1, 1)) Then replaceIt = False
                        ' if char is an identifier, then don't replace this substring.
                    End If
                    If i + Len(firstOutputName) <= Len(formulaString) Then ' there are characters after this occurance of firstOutputName
                        If 0 <> InStr(ID_chars, Mid(formulaString, i + Len(firstOutputName), 1)) Then replaceIt = False
                        ' if char is an identifier, then don't replace this substring.
                    End If
                    formulaString = Left(formulaString, i - 1) & Replace(formulaString, firstOutputName, outputName, start:=i, Count:=1)
                    i = InStr(i + Len(outputName), formulaString, firstOutputName)
                Loop
                '
                ' now the formula should refer to the correct output range name, or so I hope
                '
                ' put the formula in the appropriate cell
                '
                On Error Resume Next
                formulaCell.Offset(f * rm, f * cm).FormulaR1C1 = formulaString
                On Error GoTo 0
            Next formulaCell
        End If
        f = f + 1
    Next outputCell
    lastActiveSheet.Activate
    lastSelection.Select
    
    On Error Resume Next
    Unload Me
    Exit Sub
    
ufg_cfo_could_not_find_output:
    MsgBox APP_NAME & " could not find the output range for cell " & outputCell.Address & ".", vbExclamation, APP_NAME
    
    On Error Resume Next
    Unload Me
    Exit Sub
    
End Sub

Private Sub CommandButtonGotoChartControls_Click()
    On Error Resume Next
    Application.GoTo Reference:="'" & scd & "'!R2C1"
    Unload Me
End Sub

Private Sub CommandButtonOK_Click()
    
    Dim outputName As Variant ', bin As Long, outputRange As Range, rangeSize As Long, dataRanges As Range
'    Dim outputRangeName As Variant
'    Dim f As Long, rm As Long, cm As Long ' f = offset, rm = row multiplier, cm  = col multiplier
'    Dim xrm As Long, xcm As Long ' xrm = X-axis Row Multiplier, xcm = similar
    Dim outputCell As Range ', numBins As Long, lastSelection As Object, lastActiveSheet As Object
'    Dim tableCell As Range, ufSCDL As Object
    
    If (Me.RefEditCumulativeDest.Text = "" Or Me.OptionButtonSparkline.value) And Me.RefEditFrequencyDest = "" Then
        MsgBox "You must fill in the Histogram Starting Location or Cumulative Chart Starting Location.", vbInformation, APP_NAME
        Exit Sub
    End If
    
    Dim rCell As Range, bInputFound As Boolean, cInputSIPColl As Collection
    
    'Dim rex As Object
    'Set rex = CreateObject("VBScript.RegExp")
    
    Dim sInput As String, sRName As String
    
    '' matches, e.g., =INDEX(, or = INDEX(, and finds 1st arg,
    '' which should be the name of an Input range
    'With rex
    '    .Global = True
    '    .MultiLine = True
    '    .IgnoreCase = True
    '    .Pattern = "^=\s*INDEX\(\s*(\S[^,]*),.*"
    'End With
    '
    ' check that RefEditGraphRanges has a valid range
    '
    On Error GoTo ufg_cbo_c_regr_error:
    Set outputName = Range(Me.RefEditGraphRanges)
    Set outputName = Nothing
    On Error GoTo 0
    
    If Me.OptionButtonCopyFormulas.value Then
#If PROJECT = SIPMATH_HISTOGRAM Then
        Call smh_CopyFormulasOK
#Else
        Call smmt_CopyFormulasOK
#End If
        Exit Sub
    End If
    '
    ' if we find Input sips, assemble the (data) sips into a collection of ranges and
    ' call the graph function with optional bInputSipColl arg set to true
    '
    'sInputSipNames = ""
    Dim sOutCellAddr As String, sRCellAddr As String
    Set cInputSIPColl = New Collection
    For Each rCell In Range(Me.RefEditGraphRanges)
        sInput = rCell.Formula
        'If rex.test(sInput) Then
        If test_FName(sInput, "INDEX") Then
            '
            ' this might be an input, but it might also be an output, so look for this cell
            ' in PMTable to make sure it's not an output
            '
            On Error Resume Next
            If InStr(rCell.Parent.Name, " ") <> 0 Then
                sRCellAddr = "'" & rCell.Parent.Name & "'!" & rCell.Address(1, 1, xlA1, False)
            Else
                sRCellAddr = rCell.Parent.Name & "!" & rCell.Address(1, 1, xlA1, False)
            End If
#If Mac Then
            sOutCellAddr = ActiveWorkbook.Sheets("PMTable").Rows("3:3").Find( _
                What:=sRCellAddr, _
                After:=ActiveWorkbook.Sheets("PMTable").Cells(3, 1), LookIn:=xlFormulas, _
                LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
                MatchCase:=False).Address
#Else
            sOutCellAddr = ActiveWorkbook.Sheets("PMTable").Rows("3:3").Find( _
                What:=sRCellAddr, _
                After:=ActiveWorkbook.Sheets("PMTable").Cells(3, 1), LookIn:=xlFormulas, _
                LookAt:=xlPart, SearchOrder:=xlByColumns, SearchDirection:=xlNext, _
                MatchCase:=False, SearchFormat:=False).Address
#End If
            On Error GoTo 0
            If sOutCellAddr = "" Then bInputFound = True
            'sRName = rex.Replace(sInput, "$1")
            sRName = first_arg(sInput)
            On Error Resume Next
            Err.Clear
            Set outputCell = Range(sRName)
            If Err = 0 Then
                Err.Clear
                '
                ' this was commented out for some reason; but we need something like this somewhere so we
                ' don't chart Metadata when we chart an input.
                '
                If UCase(Right(sRName, 3)) = ".MD" Then sRName = Left(sRName, Len(sRName) - 3)
                '
                Set outputCell = Range(sRName)
                If Err = 0 Then
                    cInputSIPColl.Add outputCell, sRName
                    'sInputSipNames = sInputSipNames & IIf(sInputSipNames = "", "", ",") & sRName
                    '
                    ' this will mess up if some of the input sips have different orientations,
                    ' but too bad
                    '
                    Me.OptionButtonDataIsAColumn = outputCell.Rows.Count > 1
                    Me.OptionButtonDataIsARow = outputCell.Columns.Count > 1
                End If
            End If
        ElseIf bInputFound Then ' if we found an input, and then didn't find one
            MsgBox "Skipping non-input cell " & rCell.Address(0, 0), vbInformation, APP_NAME
        End If
    Next rCell
    If bInputFound Then
        '
        ' try to merge cells as needed
        '
        If Me.OptionButtonSparkline.value = True Then
            conditionalMergeBeforeCharting Me.RefEditGraphRanges.value, Me.RefEditFrequencyDest.value
            conditionalMergeBeforeCharting Me.RefEditGraphRanges.value, Me.RefEditCumulativeDest.value
        End If
#If PROJECT = SIPMATH_HISTOGRAM Then
        smh_UserFormGraphs_CommandButtonOK_Click _
            "A1", Me.ScrollBarNumberBins.value, _
            Me.OptionButtonExcelChart.value, _
            Me.OptionButtonSparkline.value, Me.OptionButtonColumn.value, _
            Me.OptionButtonRow.value, _
            True, Me.OptionButtonDataIsAColumn.value, _
            Me.OptionButtonChartSIPmathOutput.value, _
            Me.CheckBoxDataNamesInHeadings.value, _
            Me.RefEditFrequencyDest.value, Me.RefEditCumulativeDest.value, Me, _
            Me.CheckBoxIntegerChart.value, _
            , , , True, cInputSIPColl
#Else
        smmt_UserFormGraphs_CommandButtonOK_Click _
            "A1", Me.ScrollBarNumberBins.value, _
            Me.OptionButtonExcelChart.value, _
            Me.OptionButtonSparkline.value, Me.OptionButtonColumn.value, _
            Me.OptionButtonRow.value, _
            True, Me.OptionButtonDataIsAColumn.value, _
            Me.OptionButtonChartSIPmathOutput.value, _
            Me.CheckBoxDataNamesInHeadings.value, _
            Me.RefEditFrequencyDest.value, Me.RefEditCumulativeDest.value, Me, _
            Me.CheckBoxIntegerChart.value, _
            , , , True, cInputSIPColl
#End If
        On Error Resume Next
        Unload Me
        Exit Sub
    End If
    
    If Me.OptionButtonSparkline.value = True Then
        conditionalMergeBeforeCharting Me.RefEditGraphRanges.value, Me.RefEditFrequencyDest.value
        conditionalMergeBeforeCharting Me.RefEditGraphRanges.value, Me.RefEditCumulativeDest.value
    End If
#If PROJECT = SIPMATH_HISTOGRAM Then
    smh_UserFormGraphs_CommandButtonOK_Click _
        Me.RefEditGraphRanges.value, Me.ScrollBarNumberBins.value, Me.OptionButtonExcelChart.value, _
        Me.OptionButtonSparkline.value, Me.OptionButtonColumn.value, Me.OptionButtonRow.value, _
        Me.OptionButtonChartSelectedData.value, Me.OptionButtonDataIsAColumn.value, _
        Me.OptionButtonChartSIPmathOutput.value, _
        Me.CheckBoxDataNamesInHeadings.value, _
        Me.RefEditFrequencyDest.value, Me.RefEditCumulativeDest.value, Me, _
        Me.CheckBoxIntegerChart.value
#Else
    smmt_UserFormGraphs_CommandButtonOK_Click _
        Me.RefEditGraphRanges.value, Me.ScrollBarNumberBins.value, Me.OptionButtonExcelChart.value, _
        Me.OptionButtonSparkline.value, Me.OptionButtonColumn.value, Me.OptionButtonRow.value, _
        Me.OptionButtonChartSelectedData.value, Me.OptionButtonDataIsAColumn.value, _
        Me.OptionButtonChartSIPmathOutput.value, _
        Me.CheckBoxDataNamesInHeadings.value, _
        Me.RefEditFrequencyDest.value, Me.RefEditCumulativeDest.value, Me, _
        Me.CheckBoxIntegerChart.value
#End If
    
    On Error Resume Next
    Unload Me
    Exit Sub
    
cbo_could_not_find_output:
    MsgBox APP_NAME & " could not find the output range for cell " & outputCell.Address & ".", vbExclamation, APP_NAME
    On Error Resume Next
    Unload Me
    Exit Sub
    
cbo_c_error:
    MsgBox APP_NAME & " could not create a histogram from the specified name. " _
        & "Check that the name refers to a single row or column of cells.", vbExclamation, APP_NAME
    On Error Resume Next
    Unload Me
    Exit Sub
    
ufg_cbo_c_regr_error:
    MsgBox Trim(Me.LabelNamesToGraph.Caption) & " is not a valid range.", vbExclamation, APP_NAME
    On Error Resume Next
    Unload Me
    Exit Sub

End Sub

Private Sub OptionButtonChartSelectedData_Click()
    
    Dim spaceIndex As Long
    
    spaceIndex = InStr(Me.LabelNamesToGraph.Caption, " ")

#If PROJECT = SIPMATH_HISTOGRAM Then
    If spaceIndex > 0 Then
        Me.LabelNamesToGraph.Caption = smh_selectionTitle() & Mid$(Me.LabelNamesToGraph, spaceIndex)
    Else
        Me.LabelNamesToGraph.Caption = smh_selectionTitle()
    End If
#Else
    If spaceIndex > 0 Then
        Me.LabelNamesToGraph.Caption = smmt_selectionTitle() & Mid$(Me.LabelNamesToGraph, spaceIndex)
    Else
        Me.LabelNamesToGraph.Caption = smmt_selectionTitle()
    End If
#End If

    If Me.OptionButtonChartSelectedData.value = True Then
        Call RefEditGraphRanges_Change
    End If
    
    Dim ctl As control
    Me.OptionButtonDataIsAColumn.Visible = True
    Me.OptionButtonDataIsAColumn.Enabled = True
    Me.OptionButtonDataIsARow.Visible = True
    Me.OptionButtonDataIsARow.Enabled = True
    Me.CheckBoxDataNamesInHeadings.Visible = True
    Me.CheckBoxDataNamesInHeadings.Enabled = True
    Me.OptionButtonCopyFormulas.Visible = False
    Me.OptionButtonCopyFormulas.Enabled = False
    If Me.OptionButtonCopyFormulas.value = True Then Me.OptionButtonNoChart.value = True
    
    Me.Height = Me.Height + chartOutputsDeltaHeight
    
    For Each ctl In Me.Controls
        If ctl.Top > Me.LabelNumberBins.Top _
        And ctl.Name <> "OptionButtonDataIsAColumn" _
        And ctl.Name <> "OptionButtonDataIsARow" _
        And ctl.Name <> "CheckBoxDataNamesInHeadings" Then
            ctl.Top = ctl.Top + chartOutputsDeltaHeight
        End If
    Next ctl
    Me.LabelNumberBins.Top = Me.LabelNumberBins.Top + chartOutputsDeltaHeight
        
End Sub

Private Sub OptionButtonChartSIPmathOutput_Click()

    Dim spaceIndex As Long
    
    spaceIndex = InStr(Me.LabelNamesToGraph.Caption, " ")
    
#If PROJECT = SIPMATH_HISTOGRAM Then
    If spaceIndex > 0 Then
        Me.LabelNamesToGraph.Caption = smh_selectionTitle() & Mid$(Me.LabelNamesToGraph, spaceIndex)
    Else
        Me.LabelNamesToGraph.Caption = smh_selectionTitle()
    End If
#Else
    If spaceIndex > 0 Then
        Me.LabelNamesToGraph.Caption = smmt_selectionTitle() & Mid$(Me.LabelNamesToGraph, spaceIndex)
    Else
        Me.LabelNamesToGraph.Caption = smmt_selectionTitle()
    End If
#End If

    Me.OptionButtonDataIsAColumn.Visible = False
    Me.OptionButtonDataIsAColumn.Enabled = False
    
    Me.OptionButtonDataIsARow.Visible = False
    Me.OptionButtonDataIsARow.Enabled = False
    
    Me.CheckBoxDataNamesInHeadings.Visible = False
    Me.CheckBoxDataNamesInHeadings.Enabled = False
    
    'Me.OptionButtonCopyFormulas.Visible = True
    'Me.OptionButtonCopyFormulas.Enabled = True
    
    Dim ctl As control
    For Each ctl In Me.Controls
        If ctl.Top > Me.LabelNumberBins.Top Then
            ctl.Top = ctl.Top - chartOutputsDeltaHeight
        End If
    Next ctl
    Me.LabelNumberBins.Top = Me.LabelNumberBins.Top - chartOutputsDeltaHeight
    Me.Height = Me.Height - chartOutputsDeltaHeight
    
End Sub

Private Sub OptionButtonCopyFormulas_Click()

    Me.LabelFrequencyDest.Caption = "Formulas to Copy"
#If PROJECT = SIPMATH_HISTOGRAM Then
    Me.LabelNamesToGraph.Caption = smh_selectionTitle() ' "Outputs"
#Else
    Me.LabelNamesToGraph.Caption = smmt_selectionTitle() ' "Outputs"
#End If
    Me.OptionButtonColumn.Caption = "Copy down columns"
    Me.OptionButtonRow.Caption = "Copy along rows"
    'Me.RefEditGraphRanges.Enabled = False
    'Me.RefEditFrequencyDest.Value = Selection.Address
    If dlg_mode = DATA_ONLY_MODE Then ' open out everything but the cumulative field
        Me.Height = Me.Height + deltaHeight - copyFormulasDeltaHeight
        
        Me.CommandButtonOK.Top = Me.CommandButtonOK.Top + deltaHeight - copyFormulasDeltaHeight
        Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top + deltaHeight - copyFormulasDeltaHeight
        Me.CommandButtonGotoChartControls.Top = Me.CommandButtonGotoChartControls.Top + deltaHeight - copyFormulasDeltaHeight
        
        Me.OptionButtonColumn.Top = Me.OptionButtonColumn.Top - copyFormulasDeltaHeight
        Me.OptionButtonRow.Top = Me.OptionButtonRow.Top - copyFormulasDeltaHeight
        
        Me.LabelFrequencyDest.Visible = True
        Me.RefEditFrequencyDest.Visible = True
        Me.RefEditFrequencyDest.Enabled = True
        
        Me.LabelCumulativeDest.Visible = False
        Me.RefEditCumulativeDest.Visible = False
        Me.RefEditCumulativeDest.Enabled = False
        
        Me.OptionButtonRow.Visible = True
        Me.OptionButtonRow.Enabled = True
        
        Me.OptionButtonColumn.Visible = True
        Me.OptionButtonColumn.Enabled = True
        
        Me.RefEditFrequencyDest.SetFocus
    ElseIf dlg_mode = CHART_MODE Then ' everything is open, so close the cumulative field
        Me.LabelCumulativeDest.Visible = False
        Me.RefEditCumulativeDest.Visible = False
        Me.RefEditCumulativeDest.Enabled = False
        
        Me.OptionButtonColumn.Top = Me.OptionButtonColumn.Top - copyFormulasDeltaHeight
        Me.OptionButtonRow.Top = Me.OptionButtonRow.Top - copyFormulasDeltaHeight
        
        Me.CommandButtonOK.Top = Me.CommandButtonOK.Top - copyFormulasDeltaHeight
        Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top - copyFormulasDeltaHeight
        Me.CommandButtonGotoChartControls.Top = Me.CommandButtonGotoChartControls.Top - copyFormulasDeltaHeight
        
        Me.Height = Me.Height - copyFormulasDeltaHeight
    End If
    dlg_mode = COPY_FORMULAS_MODE
    Call RefEditGraphRanges_Change

End Sub

Private Sub OptionButtonExcelChart_Click()
    Call OptionButtonSparkline_Click
End Sub

Private Sub OptionButtonNoChart_Click()
        
#If PROJECT = SIPMATH_HISTOGRAM Then
    Me.LabelNamesToGraph.Caption = smh_selectionTitle() ' "Outputs"
#Else
    Me.LabelNamesToGraph.Caption = smmt_selectionTitle() ' "Outputs"
#End If
    Me.OptionButtonRow.Visible = False
    Me.OptionButtonRow.Enabled = False
    
    Me.OptionButtonColumn.Visible = False
    Me.OptionButtonColumn.Enabled = False
    
    Me.LabelFrequencyDest.Visible = False
    Me.RefEditFrequencyDest.Visible = False
    Me.RefEditFrequencyDest.Enabled = False
    
    Me.LabelCumulativeDest.Visible = False
    Me.RefEditCumulativeDest.Visible = False
    Me.RefEditCumulativeDest.Enabled = False
    
    If dlg_mode = CHART_MODE Then
        Me.CommandButtonOK.Top = Me.CommandButtonOK.Top - deltaHeight
        Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top - deltaHeight
        Me.CommandButtonGotoChartControls.Top = Me.CommandButtonGotoChartControls.Top - deltaHeight
        
        Me.Height = Me.Height - deltaHeight
    ElseIf dlg_mode = COPY_FORMULAS_MODE Then
        Me.CommandButtonOK.Top = Me.CommandButtonOK.Top - deltaHeight + copyFormulasDeltaHeight
        Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top - deltaHeight + copyFormulasDeltaHeight
        Me.CommandButtonGotoChartControls.Top = Me.CommandButtonGotoChartControls.Top - deltaHeight + copyFormulasDeltaHeight
        
        Me.OptionButtonColumn.Top = Me.OptionButtonColumn.Top + copyFormulasDeltaHeight
        Me.OptionButtonRow.Top = Me.OptionButtonRow.Top + copyFormulasDeltaHeight
        
        Me.Height = Me.Height - deltaHeight + copyFormulasDeltaHeight
    End If
    dlg_mode = DATA_ONLY_MODE
    
End Sub

Private Sub OptionButtonSparkline_Click()

#If PROJECT = SIPMATH_HISTOGRAM Then
    Me.LabelNamesToGraph.Caption = smh_selectionTitle() & " to Graph"
#Else
    Me.LabelNamesToGraph.Caption = smmt_selectionTitle() & " to Graph"
#End If
    Me.LabelFrequencyDest.Caption = "Histogram Starting Location"
    Me.LabelCumulativeDest.Caption = "Cumulative Chart Starting Location"
    Me.OptionButtonColumn.Caption = "Put multiple charts in columns"
    Me.OptionButtonRow.Caption = "Put multiple charts in rows"
    Me.RefEditGraphRanges.Enabled = True
    If dlg_mode = DATA_ONLY_MODE Then ' open up everything
        Me.Height = Me.Height + deltaHeight
        
        Me.CommandButtonOK.Top = Me.CommandButtonOK.Top + deltaHeight
        Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top + deltaHeight
        Me.CommandButtonGotoChartControls.Top = Me.CommandButtonGotoChartControls.Top + deltaHeight
        
        Me.LabelFrequencyDest.Visible = True
        Me.RefEditFrequencyDest.Visible = True
        Me.RefEditFrequencyDest.Enabled = True
        
        Me.LabelCumulativeDest.Visible = True
        Me.RefEditCumulativeDest.Visible = True
        Me.RefEditCumulativeDest.Enabled = True
        
        Me.OptionButtonRow.Visible = True
        Me.OptionButtonRow.Enabled = True
        
        Me.OptionButtonColumn.Visible = True
        Me.OptionButtonColumn.Enabled = True
        
        Me.RefEditFrequencyDest.SetFocus
    ElseIf dlg_mode = COPY_FORMULAS_MODE Then ' we only need to open up the cumulative field
        Me.Height = Me.Height + copyFormulasDeltaHeight
        
        Me.CommandButtonOK.Top = Me.CommandButtonOK.Top + copyFormulasDeltaHeight
        Me.CommandButtonCancel.Top = Me.CommandButtonCancel.Top + copyFormulasDeltaHeight
        Me.CommandButtonGotoChartControls.Top = Me.CommandButtonGotoChartControls.Top + copyFormulasDeltaHeight
        
        Me.OptionButtonColumn.Top = Me.OptionButtonColumn.Top + copyFormulasDeltaHeight
        Me.OptionButtonRow.Top = Me.OptionButtonRow.Top + copyFormulasDeltaHeight
        
        Me.LabelCumulativeDest.Visible = True
        Me.RefEditCumulativeDest.Visible = True
        Me.RefEditCumulativeDest.Enabled = True
    End If
    If Me.OptionButtonSparkline.value = True Then
        Me.RefEditCumulativeDest.Enabled = False
        Me.RefEditCumulativeDest.Visible = False
        Me.LabelCumulativeDest.Visible = False
    Else
        Me.RefEditCumulativeDest.Enabled = True
        Me.RefEditCumulativeDest.Visible = True
        Me.LabelCumulativeDest.Visible = True
    End If
    dlg_mode = CHART_MODE
    
End Sub

Private Sub RefEditGraphRanges_Change()
    '
    ' determine whether to pre-select rows or columns, depending on whether output names are
    ' in a row or a column.
    '
    Dim outputNames As Range
    
    On Error GoTo ufg_regr_c_error:
    Set outputNames = Range(Me.RefEditGraphRanges.value)
    If Me.OptionButtonChartSelectedData Then
        If outputNames.Columns.Count > outputNames.Rows.Count Then
            Me.OptionButtonDataIsARow.value = True
        Else
            Me.OptionButtonDataIsAColumn.value = True
        End If
        Me.CheckBoxDataNamesInHeadings.value = (VarType(outputNames(1, 1).value) = vbString)
    Else
        If outputNames.Columns.Count = 1 And outputNames.Rows.Count > 1 Then
            Me.OptionButtonColumn.value = True
        Else
            Me.OptionButtonRow.value = True
        End If
    End If
ufg_regr_c_error:
End Sub

Private Sub ScrollBarNumberBins_Change()
    Me.LabelNumberBins.Caption = "Number of Bins: " & Me.ScrollBarNumberBins.value
End Sub

Private Sub UserForm_Activate()
    
'''    Dim ctl As Control
'''    If ThisWorkbook.VBProject.Name = "StandAloneHistogram" And standAloneDelta = 0 Then
'''        standAloneDelta = Me.LabelNamesToGraph.Top - Me.OptionButtonChartSelectedData.Top
'''        Me.OptionButtonChartSelectedData.Visible = False
'''        Me.OptionButtonChartSIPmathOutput.Visible = False
'''        Me.OptionButtonChartSelectedData.Enabled = False
'''        Me.OptionButtonChartSIPmathOutput.Enabled = False
'''        For Each ctl In Me.Controls
'''            If ctl.Top > Me.LabelNamesToGraph.Top Then
'''                ctl.Top = ctl.Top - standAloneDelta
'''            End If
'''        Next ctl
'''        Me.LabelNamesToGraph.Top = Me.LabelNamesToGraph.Top - standAloneDelta
'''        Me.Height = Me.Height - standAloneDelta
'''    ElseIf ThisWorkbook.VBProject.Name = "SIPmath" Then
'''    End If
'''
'''    Dim aName As Object
'''
'''    On Error Resume Next
'''    If Application.Evaluate(ActiveWorkbook.Names("PM_local_library").RefersTo) Then ActiveWorkbook.Names.Add "PM_library_file_name", ActiveWorkbook.Name
'''    dlg_mode = CHART_MODE
'''    Call OptionButtonNoChart_Click
'''    Me.RefEditGraphRanges.Value = Selection.Address
'''    Call RefEditGraphRanges_Change
'''
'''    Call OptionButtonChartSIPmathOutput_Click
'''
'''    If ThisWorkbook.VBProject.Name = "StandAloneHistogram" Then
'''        Me.OptionButtonChartSelectedData.Value = True
'''    End If
    If Me.OptionButtonExcelChart Or Me.OptionButtonSparkline Then Call OptionButtonSparkline_Click
End Sub

Private Sub UserForm_Initialize()
    
    Dim usedHeight As Double, topMargin As Double, bottomMargin As Double, cMult As Double
    
    If Application.OperatingSystem Like "Mac*" Then
        topMargin = Me.OptionButtonChartSelectedData.Top
        bottomMargin = Me.Height - Me.CommandButtonOK.Top - Me.CommandButtonOK.Height
        usedHeight = Me.Height - bottomMargin - topMargin
        Me.Height = Me.Height * 1.4
        cMult = (Me.Height - topMargin - bottomMargin) / usedHeight
        
        Dim c
        For Each c In Me.Controls
            c.Top = topMargin + (c.Top - topMargin) * cMult
            If TypeName(c) <> "ScrollBar" Then
                c.Font.Name = "Lucida Grande"
                'c.Font.Size = 10
            End If
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If
    
    'Me.ScrollBarNumberBins.Max = g_MaxBins
    'Me.ScrollBarNumberBins.value = g_DfltBins
    Dim sMaxBins As String, sDfltBins As String
    On Error Resume Next
    Err.Clear
    Me.ScrollBarNumberBins.Max = [=PM_MaxBins]
    If Err <> 0 Then
        Do
            sMaxBins = InputBox("SIPmath could not find a value for the MAXIMUM number of bins allowed.", _
                "SIPmath", "50")
            Err.Clear
            Me.ScrollBarNumberBins.Max = sMaxBins
        Loop Until Err = 0
        ActiveWorkbook.Names.Add "PM_MaxBins", sMaxBins
    End If
    Err.Clear
    Me.ScrollBarNumberBins.value = [=PM_DfltBins]
    Call ScrollBarNumberBins_Change
    If Err <> 0 Then
        Do
            sDfltBins = InputBox("SIPmath could not find a value for the DEFAULT number of bins.", _
                "SIPmath", "50")
            Err.Clear
            Me.ScrollBarNumberBins.Max = sDfltBins
        Loop Until Err = 0
        ActiveWorkbook.Names.Add "PM_DfltBins", sDfltBins
    End If
    On Error GoTo 0
    
    deltaHeight = Me.CommandButtonCancel.Top - Me.OptionButtonCopyFormulas.Top - Me.OptionButtonCopyFormulas.Height - 6 'Me.LabelFrequencyDest.Top
    copyFormulasDeltaHeight = Me.OptionButtonRow.Top - Me.LabelCumulativeDest.Top
    chartOutputsDeltaHeight = Me.LabelNumberBins.Top - Me.OptionButtonDataIsAColumn.Top

    Dim ctl As control
    If SIPmathHistogram And standAloneDelta = 0 Then
        standAloneDelta = Me.LabelNamesToGraph.Top - Me.OptionButtonChartSelectedData.Top
        Me.OptionButtonChartSelectedData.Visible = False
        Me.OptionButtonChartSIPmathOutput.Visible = False
        Me.OptionButtonChartSelectedData.Enabled = False
        Me.OptionButtonChartSIPmathOutput.Enabled = False
        For Each ctl In Me.Controls
            If ctl.Top > Me.LabelNamesToGraph.Top Then
                ctl.Top = ctl.Top - standAloneDelta
            End If
        Next ctl
        Me.LabelNamesToGraph.Top = Me.LabelNamesToGraph.Top - standAloneDelta
        Me.Height = Me.Height - standAloneDelta
    End If

    Dim aName As Object, localLibrary As Boolean

    localLibrary = False
    On Error Resume Next
    Err.Clear
    localLibrary = [=PM_local_library]
    If Err <> 0 Then localLibrary = [=local_library]
    If localLibrary Then
        ActiveWorkbook.Names.Add "PM_library_file_name", ActiveWorkbook.Name
        ActiveWorkbook.Names.Add "PM_library_file_path", ActiveWorkbook.path
    End If
    dlg_mode = CHART_MODE
    Call OptionButtonNoChart_Click
    Me.RefEditGraphRanges.value = Selection.Address
    Call RefEditGraphRanges_Change

    Call OptionButtonChartSIPmathOutput_Click
    
    If SIPmathHistogram Then
        Me.OptionButtonChartSelectedData.value = True
    End If

End Sub
Attribute VB_Name = "UserForm_smmt_SelChartDataLoc"
Attribute VB_Base = "0{A7CC3327-45DA-4ED5-A6AC-AA0F1C6C6F7C}{37FB7EBC-3E2E-47C8-AE14-EE30BBA23E34}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'
' Copyright |fffd| 2012-2016 Probability Management, Inc.
'
Option Explicit

Private Sub CommandButtonCancel_Click()
    ufscdlReturn = vbCancel
    Me.Hide
End Sub

Private Sub CommandButtonOK_Click()
    ufscdlReturn = vbRetry
    Me.Hide
End Sub

Private Sub CommandButtonOverwrite_Click()
    ufscdlReturn = vbIgnore
    Me.Hide
End Sub

Private Sub UserForm_Initialize()
    
    If Application.OperatingSystem Like "Mac*" Then
        Dim c
        For Each c In Me.Controls
            c.Font.Name = "Lucida Grande"
            'c.font.size = 10
        Next c
        Me.BackColor = RGB(219, 219, 219)
    End If

End Sub
Attribute VB_Name = "VBASetup"
#If Mac Then
    '
    ' feature not available on Macintosh
    '
    ' stub Subroutines are here so Excel 2011 for Mac will compile
    ' since apparently the #if feature is not correctly implemented
    '
Sub SIPModeler_RegistyChk()
End Sub
    
Sub IsCBInstalled_RegistyChk()
End Sub

Sub IsARInstalled_RegistyChk()
End Sub

#Else

Public CBInstalled
Public ARLoaded
Public ARAppPath
Public CBAppPath
'Public CBLoaded

'This code is to document the SIPModeler Install drive.
'This will require the recoding of the installer app to
'add an entry in HKEY Local Machine\Software.

Sub SIPModeler_RegistyChk()

RootKey = "HKEY_LOCAL_MACHINE"
path = "SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\SIPmath-Tools\"
RegEntry = "UninstallString"

IsSIPInstalledFile = REgistryTools.GetRegistry(RootKey, path, RegEntry)

On Error Resume Next
NewPath = Left(IsSIPInstalledFile, Len(IsSIPInstalledFile) - 11)
If Err <> 0 Then MsgBox APP_NAME & " may not have been correctly installed. You may wish to re-run the install program.", vbExclamation, APP_NAME
ThisWorkbook.Worksheets("Settings").Range("MainDirectory").value = NewPath
End Sub



'This Code is to establis if AR or CB are installed on the machine via registry checks
'______________________________________________

'Macro Buttons for Ribbon
'__________________________________


Public Sub runMacroButton(control As IRibbonControl)
    ' don't Call notAvailableMsg but replace with 3.4.0 code for Enterprise Version
    MsgBox "Creates SIP Libraries from Crystal Ball models. Available in the Enterprise version of SIPmath." & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information.", vbInformation, APP_NAME
End Sub

Public Sub runImportRisk(control As IRibbonControl)
    ' don't Call notAvailableMsg but replace with 3.4.0 code for Enterprise Version
    MsgBox "Creates SIP Libraries from @Risk models. Available in the Enterprise version of SIPmath." & vbNewLine & vbNewLine & "Contact support@probabilitymanagement.org for more information.", vbInformation, APP_NAME
End Sub

Sub Demo()
    Dim b As Boolean
    b = CheckAddin("CBImport_SIP")
    MsgBox "CB Import Script is " & IIf(b, "", "not ") & "installed"
End Sub

Function CheckAddin(s As String) As Boolean
    Dim x As Variant
    On Error Resume Next
    x = AddIns(s).Installed
    On Error GoTo 0
    If IsEmpty(x) Then
        CheckAddin = False
    Else
        CheckAddin = True
    End If
End Function

'
'Folder and File tools for forms - to be implemented later
'__________________________________________________________


Function BrowseFolder(Optional Caption As String, Optional InitialFolder As String) As String

Dim SH As Shell32.Shell
Dim f As Shell32.Folder

Set SH = New Shell32.Shell
Set f = SH.BrowseForFolder(0&, Caption, BIF_RETURNONLYFSDIRS, InitialFolder)
If Not f Is Nothing Then
    BrowseFolder = f.Items.Item.path
End If

End Function

Sub show_file_locations()
fmSettings.Show
End Sub

Sub SelectDir()
'Browse for a directory Using The Shell Controls Library
'Reference http://www.cpearson.com/excel/BrowseFolder.aspx

PUBstrDirectoryPath = BrowseFolder(Caption:="Select A Folder", InitialFolder:="")
If PUBstrDirectoryPath = vbNullString Then
    'Debug.Print "No folder selected."
    MsgBox "Please select an output directory...", vbCritical, "Prospector"
Else
    'Debug.Print "Folder Selected: " & PUBstrDirectoryPath

End If

End Sub


Sub SelectAppDir()
'Browse for a directory Using The Shell Controls Library
'Reference http://www.cpearson.com/excel/BrowseFolder.aspx

Range("MainDirectory") = BrowseFolder(Caption:="Select A Folder", InitialFolder:="")
If Range("MainDirectory") = vbNullString Then
    'Debug.Print "No folder selected."
    MsgBox "Please select an output directory...", vbCritical, "00"
Else
    'Debug.Print "Folder Selected: " & PUBstrDirectoryPath

End If

End Sub

Sub SelectCBDir()
'Browse for a directory Using The Shell Controls Library
'Reference http://www.cpearson.com/excel/BrowseFolder.aspx

Range("CB_App_Directory") = BrowseFolder(Caption:="Select A Folder", InitialFolder:="")
If Range("CB_App_Directory") = vbNullString Then
    'Debug.Print "No folder selected."
    MsgBox "Please select an output directory...", vbCritical, "00"
Else
    'Debug.Print "Folder Selected: " & PUBstrDirectoryPath

End If

End Sub




Sub Tester()
RootKey = "HKEY_LOCAL_MACHINE"
path = "SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\SIPmath-Tools\"
RegEntry = "UninstallString"

IsSIPInstalledFile = REgistryTools.GetRegistry(RootKey, path, RegEntry)
MsgBox (IsSIPInstalledFile)
MsgBox (Len(IsSIPInstalledFile))
NewPath = Left(IsSIPInstalledFile, Len(IsSIPInstalledFile) - 11)
MsgBox (NewPath)
End Sub

Sub start()
cb.startup
End Sub

Sub AppStarter()

ARAppPath = ThisWorkbook.Worksheets("Settings").Range("AR_App_Dir").value & "RISK6\Risk.exe"
Shell ARAppPath

End Sub

#End If
Attribute VB_Name = "aa_ChangeLog"
Option Explicit
'
' Copyright |fffd| 2012-2017 Probability Management, Inc.
'
' to prep for mac:
' uncheck references to
' - Microsoft Scripting Runtime
' - Microsoft Shell Controls and Automation
' - Microsoft XML, v3.0
'
'
' 3.4.6
' - remove Multiple Experiment mode
' - added Version Number constant so I only have to change it once.
'
' 3.4.5
' - remove correlated RVs, replace with message about full version
'
' 3.4.2,3,4
' - ??? probably fixing the disabled buttons to work as desired
'   with greyed-out icons that still pop up descriptions of disabled buttons
'   as well as in about box
'
' 3.4.1
' - disable Import, Save, Export, Crystal Ball, @Risk buttons
' - add descriptions of disabled buttons to the About box
' - add credit for Tom Keelin
'
' 3.4.0
' - just change version #
'
' 3.3.5.beta03
' - fix Mac chart and axis titles
' - fix metalog distributions on Mac
' - fix correlated distributions on Mac
'
' 3.3.5.beta02
' - change "Multiple Inputs as Row" -> "... in a Row", etc, in UFFromLibrary
'
' 3.3.5.beta01
' - fix error message when lib not found (had it in the wrong dialog)
'
' 3.3.4
' - add PM_ in front of range names Indexed and IVTable when importing XML file so these ranges don't
'   show up in the Define Input dialog
' - check that correlated normal Dist range and Mean range have the same shape
' - use better error message if library files aren't found when defining outputs
'
' 3.3.4.beta04
' - browse for new library file starting in same folder as current library file (if there is one.)
'
' 3.3.4.beta03
' - change wording on Save Results dialog to make it more apparent how to add to existing library.
' - hide Get Existing Library button until user checks "Add to Existing Library"
'
' 3.3.4.beta02
' - un-commented line in Graphs dialog code that removed .MDs from input ranges; i.e. I restored the
'   code that removed .MDs; this allows graphing of Input ranges without the metadata; but maybe breaks
'   something else.
'
' 3.3.4.beta01
' - change evaluation of NumCols in UF InsertMetalog, from Evaluate(text) to Clng(text) and Clng(Range(text).Value)
'
' 3.3.3
' - changed to 3.3.3 since I sent out a 3.3.2 prematurely
' - removed Max bins and Default bins from Init dialog; just use 100 and 10
'   and allow default to be changed in Settings
' - added "<=100" note to default bins field in Settings
' - added check for default bins <= 100 in Settings
' - fix Default Bins value to actually work
'
' 3.3.2.beta18
' - fixed IsArOpen to not display error message every time it's called.
' - changed IsArOpen to attempt to open @Risk 7 when called, instead of @Risk 6
' - fixed UFInstructions dialog to say Get Stats, not Convert Stats
'
' 3.3.2.beta16
' - added check in UDF FromLibrary for destination a row but column option button set, and vice versa
' - changed default axis title to "Axis Title" instead of blank.
'
' 3.3.2.beta15
' - fix bug when inserting distribution formulas in macs: they show as R1C1 instead of A1
'
' 3.3.2 beta14
' - removed unused var in Metalog dialog
' - added metalog template metadata allowing you to change size of metadata,
'   location of random and var id cells
' - changed value added to var id cell to be = metalog var number, not just loop index number
'
' 3.3.2 beta13
' - added horizontal and vertical options to metalog layouts
' - start numbering metalog var names with 1 and increment them continuously
'   on successive invocations of the metalog dialog
'
' 3.3.2 beta12
' - change metalog template name to "SPT Metalogs for SIPmath.xlsx"
'
' 3.3.2 beta11
' - workaround for weird bug that misplaced first start var id value
'
' 3.3.2 beta10
' - change hyperlinks on Metalog dialog
'
' 3.3.2 beta09
' - nudge PMTable PM Logo image 1.5 left so it doesn't cover up edge of cell A1.
'
' 3.3.2.beta08
' - add Randomize statement to Workbook_Open so start var ids will be random
'
' 3.3.2.beta07
' - add credit for Doug Hubbard to About
'
' 3.3.2.beta06
' - change metalog var id to refer to cell by address, if one was specified, instead
'   of using only the cell value
'
' 3.3.2.beta05
' - implemented metalog "include charts" checkbox
' - hopefully fixed a weird bug causing metalog target cells to be in wrong spot
'
' 3.3.2.beta04
' - added VarID to metalog distribution
' - added error check for Beta distribution
' - added note about only filling in lower triangluar matrix
' - added rand start var id
'
' 3.3.2.beta03
' - add metalog distribution
' - add Var ID to metalog distribution
'
' 3.3.1
' - add error checking to Discrete distribution
' - change HDR formula by adding 0.5 before dividing by 2^31-1; this is HDR original design
'   this should mean that HDR doesn't ever give 0.0
' - put in defaults of 0, 1 for Beta A, B parameters
' - changed Info dialog caption from sipMath to SIPmath
'
' 3.3.0 beta06
' - allow no lib name or provenance in Save Results
' - disable lib name and provenance when checking Add to Lib in Sve Results
'
' 3.3.0 beta05
' - fix bug in adding to lib where wrong column was defined as SIP
'
' 3.3.0.beta04
' - allow adding to existing library when "Saving" results
'
' 3.3.0.beta03
' - respect integer flag in graphs even when re-doing existing chart
'
' 3.3.0.beta02
' - added check that histogram location or cumulative location are filled in when pressing OK in Graphs dialog
' - fix FromLibrary to not show ".MD" names when loading a new library
' - fix FromLibrary to not show old input names after loading a new library
'
' 3.3.0.beta01
' - changed RibbonOnLoad to SIPmath326RibbonOnLoad to avoid name conflict that caused crash in Settings dialog.
' - delete and re-create PMTable if changing # trials with Library Input dialog
' - fixed Graphs routine to deal gracefully with an error value in cells on Chart Data Page when checking to see if cells have an output name value.
' - fix FromLibrary to correctly read number of trials from another library without making an error
'
' 3.2.6 final
' - removed "beta19" from version
' 3.2.6 beta19
' - fix Expected Value row on Chart Data tab to use external workbook name when charting SIP lib inputs
'
' 3.2.6 beta18
' - make CDF data a green color to match legend on Chart Data
' - make CDF chart x-axis autoscale
'
' 3.2.6 beta17
' - use ChartObject.Add instead of Shapes.AddChart to make new charts in ModuleGraphs, so Excel won't "helpfully"
'   create superfluous data series in the chart.
'
' 3.2.6 beta16
' - in Triang dist, added check for lo <= likely <= hi
' - in Discrete dist, add check that probabilities add to 1.0
' - on Chart Data page made all refs absolute for columns
' - expand all groups on chart data page when making a chart
' - fix Number of Bins setting in Settings page to actually work
' - removed default scalar values for Discrete Dialog range arguments, default to blanks instead
'
' 3.2.6 beta15
' - to delete %CDF data only, select %CDF chart and press clear
' - group rows on chart tab for easy hiding/showing
'
' 3.2.6 beta14
' - add Walkenbach ChartSeries class to manipulate chart data series more easily
' - fold pdf and cdf chart pages back into one sheet again with percentile-CDF data at bottom
' - add loss exceedence option to %ile CDF chart
' - try to use same x axis values for PDF and % CDF
' - use # of digits value in chart control data for rounding of the Expected Value in series name
'
' 3.2.6 beta13
' - use single range for y-axis on CDF chart, instead of a separate range for each chart
'
' 3.2.6.dev12
' - change CDF charts to use =PERCENTILE() functions
' - add ability to delete PERCENTILE() data
'
' 3.2.6.dev11 2016 Dec 6 dge
' - fix RandCell addressing in distributions
'
' 3.2.6.dev09 2016 Nov 21 dge
' - default to HDR
' - fix correlated uniform caption to say Uniform, not Normal
'
' 3.2.6.dev08 2016 Nov 21 dge
' - allow same sheet name in a different workbook
'
' 3.2.6.dev07 2016 Nov 21 dge
' - don't put in unnecessary sheet names in distribution formulas
'
' 3.2.6.dev06 2016 Nov 19 dge
' - fix discrete to work after dev05 broke it
' - define constant array PM_1.66 and use in Poisson distribution formula
'
' 3.2.6.dev05 2016 Nov 18 dge
' - fix Poisson to work with longer workbook names and sheet names; remove warning message
' - fix Poisson to use PMTable for the A1:A66 array, since people are unlikely to mess with PMTable
'
' 3.2.6.dev04 2016 Nov 15 dge
' - add JSON export
' - add warning message if sheet names / file names are too long for Poisson
'
' 3.2.6.dev03 2016 Aug 25 dge
' - fix correlated uniforms that I broke in dev02
'
' dev02
' - move "Values" field to before "Probabilities" field in Discrete Dist
' - make Discrete dist a non-array formula
' - fix error message for HDR when PM_Index not defined
' - use LOOKUP() instead of INDEX() / MATCH()
'
' dev01
' - add rounding to cholesky formulas to avoid some #num errors
' - add discrete user-defined distribution
'
' 3.2.5 2016 Aug 20 dge
' - fix bug: Library Input dialog crashes Mac version if used right after Initializing a Library
'   try to fix by using OnTime to switch back to Model page after Initialize dialog ends.
'   Use global variable to hold Model workbook name, instead of the undocumented feature that
'   apparently doesn't work on Macs
' - fix bug in Mac: Poisson distribution doesn't work
'   (apparently FormulaArray requires A1 addressing in mac version?)
' - fix bug in Mac: reopening already open Library doesn't work.
'
' 3.2.4 2016 Aug 19 dge
' - fix bug: PMTable created in external Library
'
' 3.2.3 2016 Aug 19 dge
' - fix to work with files and tabs with apostrophes in their names
' - fix problem with loaded libraries 'freezing'
' - activate model sheet after loading library
'
' 3.2.2 2016 Aug 14 dge
' - warn before deleting data on PMTable
' - don't clear region below the PMTable when re-doing it.
'
' 3.2.1 2016 Aug 13 dge
' - issue sensible error message when defining output and library isn't loaded.
' - resize PMTable page if reducing # of trials
'
' 3.2.0 2016 Aug 11 dge
' - require external random cells in Myerson distribution
'
' 3.1.63.5 2016 Aug 7 dge
' - combine all distribution forms into one
' - select User when External Random checked
' - add aa_ChangeLog module to hold these comments.
'
' 3.1.63.3 2016 july 27 dge
' - try new distribution reference style rule: if all arguments are "single", use relative. If some are "single", some "multiple",
'   then use absolute for the "single" ones, relative for the multiple ones. If all are "multiple", use relative.
'
' 3.1.63.2 2016 july 16 dge
' - fix typo in multi-uniform dialog code
' - fix Define Output so it doesn't default to cancel
' - fix all other dialogs to not default to cancel
' - fix correllated distributions that are still broken
' - add Myerson distribution
'
' 3.1.63.1 2016 July 13 dge
' - fix Multi-variate distributions, since 3.1.63 broke them
'
' 3.1.63 2016 July 1 dge
' - insert distributions should now work with arguments on different pages
'
' 3.1.62 2016 July 1 dge
' - fix resample bug introduced in 3.1.61, where you can't define just 1 resample distribution
'
' 3.1.61 2016 June 30 dge
' - try to allow define several resamples at the same time
' - try to fix problem when re-charting the same output
'
' 3.1.60 2016 June 27 dge
' - fix triangular distribution to do something reasonable if hi = lo = middle
' - fix normal distribution to do something reasonable if stdev = 0
' - change "Create Charts by Default" to "Create Sparklines by Default" in settings dialog.
' - add resample distribution
'
' 3.1.59 2016 May 30 dge
' - add Export to CSV format for Windows version
'
' 3.1.58 2016 May 28 dge
' - fix location of HDR Var ID cell
'
' 3.1.57 2016 May 12 dge
' - fix problem with 256-column workbooks not being able to chart or define outputs.
' - fix T distribution
' - fix Trials Info icon to work in Excel 2010, 356, 2016
'
' 3.1.56 2016 May 11 dge
' - fix some dialog controls so they are not cut off in Mac
' - fix writeSomeDist to use named random cell ranges by name, not cell address
'
' 3.1.55 2016 May 05 dge
' - fix distribution dialogs to close when pressing Esc.
' - fix error where input metadata skips Name column even if Name not checked off
'
' 3.1.54 2016 May 05 dge
' - change lognormal to use decimal fraction for top %-ile, instead of dividing the value by 100
'
' 3.1.53 2016 May 04 dge
' - change lognormal to use 50th percentile and a top %-ile specified by user
'   (so the 3 args are 50th pct value, top pct #, and top pctile value)
'
' 3.1.52 2016 May 03 dge
' - don't run SIPModeler_RegistyChk unless use cb or use @r are checked in settings
' - restore auto-calc after running make chart routine
' - don't allow trial # = 0 in Trial Info dialog
'
' 3.1.51 2016 May 01 dge
' - fix turn calc back on in initialize
' - fix sense of "don't show this again" in UserFormCheckCalcMode
'
' 3.1.50 2016 Apr 30 dge
' - "turn calc on" warning doesn't go away when you check the "don't show again" box.
'   fix that bug
' - remove section names for Export, Settings, About
'
' 3.1.49 2016 Apr 25 dge
' - numerous Mac compatibility tweaks
'   - note changed Ribbon icons
' - don't require save when importing CSV or XML
'
' 3.1.48 2016 Apr 25 dge
' - Mac compatibility:
'   - On Mac, don't compile stuff that won't work on the Mac
'   - respect 2011 and 2016 differences, too
' - CB and @Risk compatibility
'   - add CB and @Risk setting checkboxes
'   - don't run code if CB and @Risk not checked in Settings
'
' 3.1.47 2016 Apr 23 dge
' - add Settings dialog to show Number of Trials, Mode (i.e. Generate, External Lib, Local Lib),
'   Default # Bins, Trial #, Var ID, checkbox whether to include sparklines by default, and checkbox
'   telling whether to turn on calc in every command
'
' 3.1.46 2016 Apr 11 dge
' - change UserFormInfo to use Spin button instead of Scroll bar.
' - allow directly typing in trial number
'
' 3.1.45 2016 Apr 7 dge
' - use main diagonal of correlation / covariance matrix for correlated
'   distributions
'
' 3.1.44 2016 Apr 6 dge
' - fix Cholesky factor to work right when inputs are in rows, which requires a transposed
'   cholesky matrix
'
' 3.1.43 2016 Mar 29 dge
' - add Multi-variate Normal and Uniform distributions
' - turn off auto calc during convertReference
'
' 3.1.42 2016 Mar 25 dge
' - More informative error if setup has not been run
' - don't add unneeded _'s in front of converted names
'
' 3.1.41 2016 Mar 24 dge
' - Add Eric Torkia's Crystal Ball and @Risk macros
'
' 3.1.40 2016 Mar 08 dge
' - rearrange ribbon and add section names, rename some ribbon buttons
' - Clear works right on merged cells
' - add error message when initializing with external library when no library selected
' - don't allow loading XML or CSV libraries directly. They must be Imported first
' - add Import button and connect it to XML and CSV import routines
' - add settings button to allow users to turn on @Risk and CrystalBall buttons
' - fix bug where outputs with an INDEX() formula are thought to be inputs when making charts
' - ditto for clearing outputs with INDEX() formulas
'
' 3.1.39 2016 Mar 05 dge
' - Convert Stats changed to Get Stats
' - Distribution Input changed to Generate Input
' - Get Stats works on sparkline cells - at least some of the time!
'
' 3.1.38 2016 Feb 27 dge
' - check that # names = # outputs when defining outputs, and give a
'   sensible error message if not
' - check that output names are not the same as cell addresses, and give a
'   sensible error message if they are
' - issue a warning when a distribution uses HDR before the model is
'   initialized.
' - add Weibull distribution
'
' 3.1.37 2016 Feb 26 dge
' - merges sparkline cells when selecting multiple cells as sparkline
'   destination
'
' 3.1.36 2016 Feb 24 dge
' - turn off automatic calculation during Clear routine
' - change copyright date to 2016
'
' 3.1.35 2016 Feb 23 dge
' - fixes bug with deleting Inputs with .MD ranges
' - all selected cells are cleared of all formatting, contents, and
'   sparklines
'
' 3.1.34 2016 Feb 23 dge
' - Uses different icon for Clear
' - Fixes issue with automatic input/output sparklines using maximum bins
'   instead of default bins.
'
' 3.1.33 2016 Feb 23 dge
' - allows deleting inputs and outputs from the model.
'
' 3.1.32 2016 Feb 19 dge
' - adds the External Random checkbox to the distribution dialogs.
'
' 3.1.31 2016 Feb 16 dge
' - Distributions dialogs assume that single cell parameters are absolute
'   fixed addresses, but multiple cell parameters should be treated as
'   relative to the start cell of the destination range.
' - checks for overwriting cells when putting in distributions.
' - adds a random value cell for each distribution, which can be HDR,
'   RAND(), or a user-defined function.
'
' 3.1.30 skipped
' 3.1.29 skipped
' 3.1.28 2016 Feb 02 dge
' - saves SLURPs with .MD ranges, too
'
' 3.1.27 2016 Feb 01 dge
' - allows doing stats and convert stats on Input SIPs
' - adds .MD (i.e. MetaData) range names to SLURP libraries
'
' 3.1.26 skipped
' 3.1.25 skipped
' 3.1.24 skipped
' 3.1.23 2016 Jan 09 dge
' - set max number of bins in Initialize dialog
'
' 3.1.22 2016 Jan 08 dge
' - allows selecting metadata in the From Library dialog.
' - allows asking for Headers when defining inputs
' - checks for over-writing when using From Library
'
' 3.1.21 2016 Jan 02 dge
' - add single-cell Poisson distribution (including using Normal ' - Approximation when lambda > 20)
' - color codes chart data,
' - put selected metadata next to names,
' - lighter line around sparklines,
' - no resizing of sparklines
'
' 3.1.20 2015 Dec 30 dge
' - add metadata to output when saving results
'
' 3.1.19 skipped
' 3.1.18 2015 Dec 17 dge
' - fixes problem with bin labels on integer histograms
'
' 3.1.17 2015 Dec 12 dge
' - adds a flag to turn on integer charts in the controls section of the Chart data tab.
'
' 3.1.16 2015 Dec 05 dge
' - fixes a problem when opening a SIP file with different # of trials than currently
'   defined in the model. In some cases, PMTable indices were not being updated
'   correctly.
'
' 3.1.15 2015 Dec 04 dge
' - 50 bins on chart data page instead of 100
' - # bins controlled by single easy to change constant instead of hard-coded
'
' 3.1.14 2015 Dec 03 dge
' - load XML format SLURPs
'
' 3.1.13 skipped
' 3.1.12 2015 Nov 25 dge
' - fix bug preventing graphing of data when no model initialized
'
' 3.1.11 2015 Nov 16 dge
' - fixes bug in integer histograms and loss exceedence
'
' 3.1.10 2015 Nov 14 dge
' - support Loss Exceedence charts
'
' 3.1.9 2015 Nov 14 dge
' - Fixes problem with Save results function when there is no metadata
'
' 3.1.8 skipped
' 3.1.7 2015 Nov 11 dge
' - adds a bunch of HDR- (and RAND-) based distributions,
' - allows loading a library in Generate mode (with the From Library button)
' - asks whether to resizes PM_Trials (etc) if necessary
'
' 3.1.6 2015 Nov 06 dge
' - added binomial, chi-square, and F distribution
'
' 3.1.5 2015 Nov 03 dge
' - allow getting var id from a cell
' - add radio button : rand | hdr, to distribution dialog boxes
' - adds beta dist
'
' 3.1.4 2015 Nov 03 dge
' - add correct constant values to Var ID # and PM_Index when generating Hubbard RNGs
'
' 3.1.3 2015 Nov 02 dge
'
' 3.1.2 2015 Nov 02 dge
' - added Normal distribution to Distributions menu
'
' 3.1.1 2015 Nov 02 dge
' - fixed bug with re-initialization to change number of trials
' - renamed some buttons
' - new Init icon
'
' 3.1.0 2015 Nov 02 dge
' - add Doug Hubbards random number generator
' - add dialog to insert formulas for some standard distributions.
'
' 3.0.4 2015 Oct 03 dge
' - fixed CheckForLibrary() to use the name, not the full path
' - check for an open workbook before initializing
'
' 3.0.3 2015 Oct 03 dge
' - fix CheckForLibrary() to look at workbook passed is as argument, not ActiveWorkbook
'
' 3.0.2 2015 Aug 14 dge
' - use scale when rounding Min value
' - make all internal names begin with PM_ and don't show such names in the Define Input / Output dialogs
' - max random mode re-init work if using a "Multiple Experiment" model
' 2015 Aug 30 dge
' - allow periods in output names
' 2015 Sep 1 dge
' - automatically overwrite output names if "overwrite" checkbox is checked
' - don't crash if trying to convert stats with no outputs defined yet
'
' 3.0.1 2015 Aug 12 dge
' - hopefully Fix error when re-initing and there's no PMTable sheet
' - don't allow multiple areas when selecting outputs
' - don't delete PM_Trials if re-initing internal model
'
' 3.0.0 2015 July 26 dge
' - change version to 3.0.0
'
' 2.4.6 2015 July 14 dge
' - remove XML and CSV save code so it works on Mac
' - add user-controllable dynamic bin size, min value, and number of bins
' - change bin labels to 1 value with a bunch of spaces to position the label near the left edge of a column
' - add user control for number of spaces
' - put the chart controls in 1 block, put a box around them.
' - delete old chart data for output, if any, when charting an output
' - remove metadata page from Save Results dialog; always include Average metadata
' - pick 'nice' default values for bin size, min, number of bins
' - make it all work on Mac too
' - add Number of decimals for rounding of bins
' - get metadata from bottom of PMTable
' 2015 July 18 dge
' - Min and Bin Width chart control values should be formulas
' - add button to Graphs dialog, to go to chart control location
' - put back PM Logo
' - autofit chart control labels
' 2015 July 20 dge
' - fix data table color when re-initialized Random mode
' - fix error when initial bin size is 0
' 2015 July 23 dge
' - add Scale, don't use negative Decimals, add optional axis title
' 2015 July 25 dge
' - fix "Strange Bug" where external libs don't work if SIPs have no metadata
'
' 2.4.5 2015 June 8 dge
' - don't translate metadata names unless saving as XML
'
' 2.4.5 2015 June 4 dge
' - fix re-export of imported slurps
'
' 2.4.4 2015 June 4 dge
' - Export Library ==> Save Results
' - added nice dialog to define library metadata, SIPs to save, Metadata to save
'
' 2.4.3 2015 June 2 dge
' - add Save Library function
'
' 2.4.0 2015 April 9 dge
' - change Graphs dialog to default to Excel charts.
' - new release
'
' 2.3.13 2015 April 5 dge
' - fix copyright date to 2015 in About box
'
' 2.3.12 2015 April 5 dge
' - (version 2.3.11 had code to change from Full Modeler Tools mode to Histogram Only mode.
'   but was not complete.)
' - Put delete PMTable at start of reset code.
' - trap error when trying to delete non-existent chart data sheet
' - fix issue with Overwrite ranges not removing old range name definitions
'
' 2.3.10 2015 March 30 dge
' - add error message when defining output if cell has no formula
'
' 2.3.9 2015 March 30 dge
' - don't ask about clearing stuff, just do it and remove tabs.
'
' 2.3.8 2015 March 26 dge
' - add reset model feature
'
' 2.3.7 2015 March 21 dge
' - fix Stats toolbar icon for mac (.FaceId = 443 changed to .FaceId = 433)
'
' 2.3.6 2015 March 21 dge
' - add image with instructions to instructions form
'
' 2.3.5 2015 March 21 dge
' - remove modFormulaParser code which I never used
' - fix UserFormDefineOutputs code to use [=PM_Trials], not [PM_Trials], so Mac will work.
' - remove Copy and Paste buttons from Ribbon / Menu / Toolbar
' - rename Stats button to Convert Stats; put a Sigma on it
' - call a userForm with instructions if you push the Stats button with no cell selected.
'
' 2.3.4 2015 March 21 dge
' - don't use RegEx since it doesn't work on the Mac
'
' 2.3.3 2015 March 20 dge
' - put "Stats" button on top of section; put all buttons in one group named
'   SIPmath Modeler Tools
'
' 2.3.2 2015 March 18 dge
' - rename ribbon buttons and change graph icon.
' - add "Stats" button to replace a reference to an output cell with the range of simulated values for that output.
'
' 2.3.0 2015 March 13
' - Add copy SIPmath Formula and paste SIPmath formula commands to menu and Ribbon.
' - remove "copy formula" option from Stats & Graphs
' - don't show _random_mode in list of inputs in UserFormInput.
'
' 2.2.5 2015 Jan 29
' - change "Change Number of Trials to..." to "Reset Number of Trials"
' - remove radio buttons when re-initializing Random mode; don't allow changing modes.
' - fix bug when changing #trials with only one output
' - fix bug: changing #trials turns off sparklines
' - make re-initialize dialog smaller - no bug white space
'
' 2.2.4 2015 Jan 28
' - change "Number of Trials" to "Change Number of Trials to..." when re-initializiing random mode.
' - hide sparklines checkboxes and number of bins controls when re-initializing random mode.
'
' 2.2.3 2015 Jan 28
' - put in color for index column in PMTable when changing number of trials
'
' 2.2.2 2015 Jan 27
' - do Names.Add calls and PMTable re-indexing only while no data table exists; to avoid the dialog apparently hanging
' - use existing sparklines settings as default when changing number of trials in Random mode.
'
' 2.2.1 2015 jan 27
' - delete formulas in data table when resizing it, then restore them, to hoopefully speed up.
'
' 2.2.0 2015 Jan 25
' - change random mode to put PM_Trials in a name, not a cell.
' - Init dialog should know if re-initing a random model, just ask how many trials.
' - allow over-writing existing output names
' - re-create existing outputs if changing number of trials
'
' 2.1.0 2014 Dec 25
'   - conform to SIPmaker ModuleGraphs
'     - add new #constant for SIPmaker code (not used here) so I can have different subroutine names (to avoid name collisions) in
'       SIPmaker, SIPmath Tools and SIPmath Histogram
'     - when making sparkline, make row height 1/2 column width
'     - put sparkline text in top right corner of sparkline cell
'
' - 2.0.12 2014 Dec 16
'   - don't show _lbls ranges in list of input names.
'
' - 2.0.11 2014 Oct 19
'   - make PM logo aspect ratio better with Mac
'   - correct wording of error message when workbook not initialized
'
' - 2.0.10 2014 Oct 19
'   - check for existence of a library in the Define Output dialog before running it.
'
' - 2.0.9 2014 Oct 18
'   - fix TM symbol on PMTable to work for both Mac and Windows
'   - make row 1 on PMTable height = 70 so the IP notice will fit with a large font.
'
' - 2.0.8 2014 Oct 17
'   - fix bug when output name is already used as range name
'   - add PM Logo to PMTable sheet
'
' - 2.0.7 2014 Sep 16
'   - added tax deductible support message to About box.
'
' - 2.0.6 2014 Sep 9
'   - fixed declaration order of MY_STYLE constant for Mac
'
' - 2.0.4
'   - added old-style menus to Windows version so it's usable if Ribbon won't display for some reason.
'
' 2014 August 20
' - 2.0.2
'   - Change Copy Formula to copy in R1C1 mode so relative ranges in copied formulas are respected.
'
' 2014 August 21
' - 2.0.1.0
'   - Change PM_IV to PM_Meta, PM_IV_INDEX to PM_Meta_INDEX, but maintain backward compatibility with previous
'   versions using PM_IV
'
' 2014 July 24
' - 2.0.0.11
'   - don't display hidden range names in Input dialog.
'   - put headings on chart data page
'
' 2014 July  7
' - 2.0.0.9 dev
'   - fix Input form not to display a bunch of names created by SIPmath that are not SIP names.
'
' 2014 June 16
' - fix histogram chart y-axis to always start at 0
' - fix NumberOfBins scrollbar to be disabled when Integer Chart checkbox is checked
'
' 2014 June 12
' - 2.0.0.7 dev
'   - added Integer chart option
'
' 2014 May 28
' - 2.0.0.6
'   - fix standalone histogram / ModuleGraphs to put "Decimal Places"/"Offset" in A2:A3 of SIPmath Chart Data page
'
' - 2.0.0.5
'   - copied code back from standalone histogram
'   - defined #Const SIPMATH_HISTOGRAM in Project Properties dialog (so it's defined in all modules)
'   instead of with #Const statements in module code (where it's private to the module)
'
' 2014 May 26
' - 2.0.0.4 (for standalone histogram:)
'   - fixed bugs when the names local_library and and library_file_name not defined
'   - fixed standalone histogram code to create the SIPmath Chart Data sheet just like the full version
'   - fixed data-name-in-header option to check those data names for invalid chars
'
' 2014 May 25
' - 2.0.0.3
'   - set maximum value on cumulative chart to 100%
' - 2.0.0.2
'   - format chart y-axis as %0
' - 2.0.0.1
'   - make automatic sparklines on by default
'
' - 2.0.0.0
'   - added automatic sparklines to inputs and outputs
'   - make histogram bounds pretty
'   - make histogram labels easier to understand
'
' 2014 Mar 12
' - 1.0.71.1
'   * change Graph form to change captions appropriately when selecting various option buttons.
' - 1.0.71.0
'   * change Graph form to allow specifying outputs by the output cell itself, not just the output name.
'
' 2013 Dec 19
' - 1.0.70.2
'   * fix last bin of graphs
'
' 2013 Aug 25
' - 1.0.70.0
'   * just change version #
'
' - 1.0.68.6
'   * 3rd try
'
' - 1.0.68.5
'   * another try at leaving library open.
'
' - 1.0.68.4
'   * modified UserFormOpenLibrary to leave library on top in 2010 and 2007.
'
' 2013 Aug 24
' - added "(case sensitive)" to label for Filter box in UserFormInput
' - 1.0.68.3
'
' 1.0.68.2
'

Attribute VB_Name = "x_ScrapBook"
#If Mac Then
    '
    ' festure not available on Mac
    '
#Else

Function CBLoaded2() 'Code allows to detect if CB is loaded.
  On Error GoTo Handler
  
  ' This is the main COM addins index - will throw an index out of range error if CB is not installed
  CBLoaded2 = Application.COMAddIns("SecureCBAddin.Connect").progID = "SecureCBAddin.Connect"
 
Handler:
  CBLoaded2 = False
  MsgBox (CBLoaded2)
  
End Function



Sub References_RemoveMissing()
     'Macro purpose:  To remove missing references from the VBE. Requires Visual Basic for Application Extensibility Library be installed/referenced.
     
     Result = ThisWorkbook.VBProject.References.Count
     
    MsgBox (Result)
    
    Dim theRef As Variant, i As Long
     
    On Error Resume Next
     
    For i = ThisWorkbook.VBProject.References.Count To 1 Step -1
        Set theRef = ThisWorkbook.VBProject.References.Item(i)
        If theRef.IsBroken = True Then
            ThisWorkbook.VBProject.References.Remove theRef
        End If
    Next i
     
    If Err <> 0 Then
        MsgBox "A missing reference has been encountered!" _
        & "You will need to remove the reference manually.", _
        vbCritical, "Unable To Remove Missing Reference"
    End If
     
    On Error GoTo 0
End Sub


Sub ListCOMAddIns()
    Dim CurrAddin As Office.COMAddIn
    Dim r As Long
    Dim ws As Excel.Worksheet

    Set ws = ActiveSheet
    Cells.Select
    Selection.ClearContents
    Range("A1").Select

    r = 1
    For Each CurrAddin In Excel.Application.COMAddIns
        ws.Cells(r, 1).value = CurrAddin.Description
        ws.Cells(r, 2).value = CurrAddin.Application
        ws.Cells(r, 3).value = CurrAddin.GUID
        ws.Cells(r, 4).value = CurrAddin.Connect
        ws.Cells(r, 5).value = CurrAddin.Creator
        ws.Cells(r, 6).value = CurrAddin.progID
        r = r + 1
    Next CurrAddin
    MsgBox "Its done.", vbInformation
End Sub

Sub ListAddIns()
  Dim CurrAddin As Excel.AddIn
  Dim r As Long
  Dim ws As Excel.Worksheet

  Set ws = ActiveSheet
  Cells.Select
  Selection.ClearContents
  Range("A1").Select

  r = 1
  For Each CurrAddin In Excel.Application.AddIns
      ws.Cells(r, 1).value = CurrAddin.FullName
      ws.Cells(r, 2).value = CurrAddin.Installed
      ws.Cells(r, 3).value = CurrAddin.Name
      ws.Cells(r, 4).value = CurrAddin.path
      ws.Cells(r, 5).value = CurrAddin.progID
      ws.Cells(r, 6).value = CurrAddin.CLSID
      ws.Cells(r, 7).value = CurrAddin.Name

      r = r + 1
  Next CurrAddin

  MsgBox "Its done.", vbInformation
End Sub

#End If

' InQuest injected base64 decoded content
' V+"nW
' v+Mjg
' 1"w%

INQUEST-PP=macro
