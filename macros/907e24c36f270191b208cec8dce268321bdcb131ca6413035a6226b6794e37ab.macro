Attribute VB_Name = "FormMain"
Attribute VB_Base = "0{8AFA130F-8912-444E-8C0D-FAB9FF442E08}{4934C6A1-8E7B-40CC-82A8-F5E811BB27E1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim EmailSubj As String
Dim HomePageUrl As String
Dim Form_hWnd1 As Long

Private Sub PrintPass_Chb_Click()
    UpdateCaptions
End Sub

Private Sub PrintPass_Tb_Change()
    sPortblSheetPasswrd = PrintPass_Tb.Text
End Sub

Private Sub PrintPassMask_Chb_Click()
    PrintPass_Tb.PasswordChar = IIf(PrintPassMask_Chb.Value, "*", "")
    PrintPass_Tb.SelStart = 0: PrintPass_Tb.SelLength = Len(PrintPass_Tb.Text)
    If PrintPassMask_Chb.Value Then PrintToXLS_Bt.SetFocus Else PrintPass_Tb.SetFocus
End Sub

Private Sub SheetPasssMask_Chb_Click()
    SheetPass_Tb.PasswordChar = IIf(SheetPasssMask_Chb.Value, "*", "")
    SheetPass_Tb.SelStart = 0: SheetPass_Tb.SelLength = Len(SheetPass_Tb.Text)
    If SheetPasssMask_Chb.Value Then PrintToXLS_Bt.SetFocus Else SheetPass_Tb.SetFocus
End Sub

Private Sub UserForm_Initialize()
    Dim Wb As Excel.Workbook
    Dim PictureFile As String

    'IsPortg = appHostApp.International(xlCountryCode) = 55
    If Width > 2 * 311 Then Twips = 20 Else Twips = 1    'Em ComAddin as dimens|fffd|es do formul|fffd|rio |fffd| em twip, mas as posi|fffd||fffd|es dos controles continuma em pontos

    If IsPortg Then
        Caption = sAddInCaptByApp
        About_Lb.Caption = "Sobre|fffd|"
        Workbook_Lb.Caption = "Pasta de Trabalho aberta:"
        Sheet_Lb.Caption = "Planilha na pasta selecionada acima:"
        SheetPass_Lb.Caption = "Senha da planilha:": SheetPasssMask_Chb.Caption = "M|fffd|sc": SheetPasssMask_Chb.ControlTipText = "M|fffd|scara"
        Send_Bt.Caption = "Enviar"
        Close_Bt.Caption = "Sair"
        ViewDone_Bt.Caption = "Visualizar feitos": ViewDone_Bt.ControlTipText = "Visualizar arquivos XLS j|fffd| feitos em outra inst|fffd|ncia do Excel."
        Page_Fr.Caption = "P|fffd|gina"
        Page_Bt.Caption = "Configurar"
        Preview_Bt.Caption = "Visualizar"
        PrintPass_Chb.Caption = "Proteger XLS port|fffd|vel contra altera|fffd||fffd|es": PrintPassMask_Chb.Caption = "M|fffd|scara"
        PrintPass_Lb.Caption = "Senha:"
        ZipPortblXLS_Chb.Caption = "Zipar XLS port|fffd|vel"
        AfterDone_Fr.Caption = "Depois do XLS port|fffd|vel feito:"
        SavePortblXLSasWebPg_Chb.Caption = "Salvar como p|fffd|gina da Web ou outro formato"
    Else
        Caption = sAddInCaptByApp
        About_Lb.Caption = "About|fffd|"
    End If

    Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
    Email_Lb.ControlTipText = "orlando@cpap.com.br"
    EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
    HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
    HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
    HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")
    Email_Lb.Left = Width / Twips - Email_Lb.Width - (Width / Twips - InsideWidth) - 4    'Email_Lb.Left = Width / Twips - Email_Lb.Width - 8

    For Each Wb In appHostApp.Workbooks
        If Wb.Windows(1).Visible Then
            Workbook_Cb.AddItem (Wb.Name)
            If appHostApp.ActiveWorkbook.Name = Wb.Name Then Workbook_Cb.Value = Wb.Name
        End If
    Next

    vEnableEvents = False
    sPortblSheetPasswrd = GearPsw(14)    'Aleat|fffd|ria ao iniciar, se o usu|fffd|rio quiser alterar sempre, assim em geral cada impress|fffd|o est|fffd| protegida diferentemente
    PrintPass_Chb.Value = bPortblSheetProtect
    PrintPass_Tb.Text = sPortblSheetPasswrd
    ZipPortblXLS_Chb.Value = bZipPortblXLS
    SendPortblXLSbyEmail_Chb.Value = bSendPortblXLSbyEmail
    SavePortblXLSasWebPg_Chb.Value = bSavePortblXLSasWebPg
    vEnableEvents = True

    UpdateCaptions
    Send_Bt.Visible = False    'Ocultado e afastado, mas funcional tal qual no PrintThruEmail

    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel
    If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
End Sub

Private Sub UpdateCaptions()
    If ZipPortblXLS_Chb.Value Then
        SendPortblXLSbyEmail_Chb.Caption = IIf(IsPortg, "Enviar zippado por e-mail", "Send it zipped by email")
    Else
        SendPortblXLSbyEmail_Chb.Caption = IIf(IsPortg, "Enviar por e-mail", "Send it by email")
    End If

    PrintPass_Chb.Enabled = Not SavePortblXLSasWebPg_Chb.Value
    PrintPass_Lb.Enabled = Not SavePortblXLSasWebPg_Chb.Value
    PrintPass_Tb.Enabled = Not SavePortblXLSasWebPg_Chb.Value And PrintPass_Chb.Value
    PrintPass_Lb.Enabled = Not SavePortblXLSasWebPg_Chb.Value And PrintPass_Chb.Value
    PrintPassMask_Chb.Enabled = Not SavePortblXLSasWebPg_Chb.Value And PrintPass_Chb.Value
    ZipPortblXLS_Chb.Enabled = Not SavePortblXLSasWebPg_Chb.Value
    SendPortblXLSbyEmail_Chb.Enabled = Not SavePortblXLSasWebPg_Chb.Value

    'PrintPass_Lb.Left = PrintPass_Chb.Left + PrintPass_Chb.Width - 3
    PrintPass_Tb.Left = PrintPass_Lb.Left + PrintPass_Lb.Width + 1
    PrintPass_Tb.Width = AfterDone_Fr.Left - PrintPass_Tb.Left - PrintPassMask_Chb.Width - 2
    PrintPassMask_Chb.Left = PrintPass_Tb.Left + PrintPass_Tb.Width + 1
End Sub

Public Sub UserForm_Activate()
    If Workbook_Cb.ListCount = 0 Then
        Msg1 = IIf(IsPortg, "Antes de executar " & sAddInCaptByApp & ", voc|fffd| deve abrir a(s) pasta(s) com a(s) planilha(s) a imprimir.", "Before executing " & sAddInCaptByApp & ", you have to open the workbook(s) with the sheet(s) to print.")
        Msg1 = IIf(IsPortg, "Planilha n|fffd|o Encontrada! ", "Sheet not Found! ") & Msg1
        MyMsgBox Msg1, 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
        Close_Bt_Click
    End If
    If RetError <> 0 Then MyMsgBox Err.Description, 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
    If RetError = 2 Then SheetPass_Tb.SetFocus
End Sub

Private Sub Workbook_Cb_Change()
    If Workbook_Cb.Value = "" Then Exit Sub
    appHostApp.Workbooks(Workbook_Cb.Value).Activate: ActWbWinAppSDIBaseForm Form_hWnd1
    vEnableEvents = False
    Do While Sheet_Cb.ListCount > 0
        Sheet_Cb.RemoveItem (0)
    Loop
    Sheet_Cb.Value = ""
    vEnableEvents = True
    Dim Sh    'As Excel.Worksheet 'Fail if chart sheet
    For Each Sh In appHostApp.Workbooks(Workbook_Cb.Value).Sheets
        If Sh.Visible Then    'A priori n|fffd|o parece ter sentido imprimir planilha oculta.
            Sheet_Cb.AddItem (Sh.Name)
            If appHostApp.Workbooks(Workbook_Cb.Value).ActiveSheet.Name = Sh.Name Then Sheet_Cb.Value = Sh.Name
        End If
    Next
End Sub

Private Sub Sheet_Cb_Change()
    If vEnableEvents = False Then Exit Sub
    appHostApp.ActiveWorkbook.Sheets(Sheet_Cb.Value).Activate
    If fPaperSize(False) Then
        Page_Lb.Caption = IIf(IsPortg, "Nome do Papel: " & tPaperSize.sName, "Paper name: " & tPaperSize.sName)
    Else
        Page_Lb.Caption = IIf(IsPortg, "Nome do Papel: ", "Paper name: ")
    End If
    With appHostApp.ActiveWindow.ActiveSheet.PageSetup
        'eliminado
    End With
    bShHasPass = appHostApp.ActiveWindow.ActiveSheet.ProtectContents
    SheetPass_Lb.Enabled = bShHasPass
    SheetPass_Tb.Enabled = bShHasPass: SheetPasssMask_Chb.Enabled = bShHasPass
End Sub

Private Sub Page_Bt_Click()
    Hide
    If dHostAppVer >= 11 + 1 + 2 + 1 Then SetForegroundWindowEsp App_hWnd, 0.5      'In Excel 15 hiding a modal form can change TargetWb focus.
    If fPaperSize(True) Then
        Page_Lb.Caption = IIf(IsPortg, "Nome do Papel: " & tPaperSize.sName, "Paper name: " & tPaperSize.sName)
    End If
    Show 1
End Sub

Private Sub PrintToXLS_Bt_Click()
    bPrintToXLS = True: bZipPortblXLS = ZipPortblXLS_Chb.Value: bSendPortblXLSbyEmail = SendPortblXLSbyEmail_Chb.Value: bSavePortblXLSasWebPg = SavePortblXLSasWebPg_Chb.Value
    sEmlEmail = "": sEmlSubj = "": sEmlMsg = ""
    sPortblSaveName = ""
    Send_Bt_Click
    bPrintToXLS = False
    WriteINISetting    'S|fffd| guarda configura|fffd||fffd|o depois que apertar o botao PrintToXLS
End Sub

Private Sub ZipPortblXLS_Chb_Click()
    UpdateCaptions
End Sub

Private Sub SavePortblXLSasWebPg_Chb_Click()
    UpdateCaptions
End Sub

Private Sub Send_Bt_Click()
    bPortblSheetProtect = PrintPass_Chb.Value
    sPortblSheetPasswrd = PrintPass_Tb.Value
    sShPass = SheetPass_Tb.Value
    RetError = 0

    Hide
    If dHostAppVer >= 11 + 1 + 2 + 1 Then SetForegroundWindowEsp App_hWnd, 0.5      'In Excel 15 hiding a modal form can change TargetWb focus.
    If dHostAppVer > 8 And Not bPrintToXLS Then     'Se print to XLS e enviando e-mail, ser|fffd| exibido ap|fffd|s o SaveAs
        If Not IsPortg Then
            With UserFormWait
                .Caption = "Please!"
                .Label1.Caption = "Wait the email appear..."
                .Alert_Lb.Caption = "Tip! Press Ctrl+V to paste on the email body, if the massage template isn't shown automatically."
            End With
        End If
        #If VBA6 Then
            UserFormWait.Show 0
        #End If
        DoEvents
    Else
        appHostApp.StatusBar = IIf(IsPortg, "AGUARDE...", "WAIT...")
    End If

    EnviarEmailPrintArea

    If (dHostAppVer > 8 And Not bPrintToXLS) Or (dHostAppVer > 8 And bPrintToXLS And bSendPortblXLSbyEmail) Then
        VBA.Unload UserFormWait    'UserFormWait.Hide
    Else
        appHostApp.StatusBar = False
    End If
    If Not bIsCOMAddin Then Show 1 Else UserForm_Activate: Show 1    'Tem workaround para resolver bug em COM, ver ProjetosTo2016\Lembrete2016.doc
End Sub

Private Sub Close_Bt_Click()
    AlertAboutNewVer
    Unload Me
    RetError = 0
    'Clean temp folder de temp file criado aqui. Antes verifica se sTempFileName |fffd| um temp mesmo de impress|fffd|o, pois pode ser s|fffd| um anexado salvo usado so no cpap e mantido aqui para conservar semelhan|fffd|a e facilitar updates l|fffd| e c|fffd|
    If InStr(1, sTempFileName, TempFolder()) = 1 _
       And InStr(1, sTempFileName, sAddInNameByApp & "_tmp") > VBA.Strings.Len(TempFolder()) _
       And IsNumeric(VBA.Strings.Mid(sTempFileName, InStr(1, sTempFileName, sAddInNameByApp & "_tmp") + VBA.Strings.Len(sAddInNameByApp & "_tmp"), VBA.Strings.Len("hhmmss"))) Then
        On Error Resume Next
        If Dir(sTempFileName) <> "" Then Kill sTempFileName
    End If
    sTempFileName = ""
End Sub

Private Sub Preview_Bt_Click()
    Dim lCellCount As Double
    Dim lPageCount As Long

    'Excel PrintPreview is a form and to Show it from other form must Hide this. And before Hide is good critisize to avoid possible fails.
    If TypeName(appHostApp.ActiveWindow.ActiveSheet) <> "Chart" And TypeName(appHostApp.ActiveWindow.ActiveSheet) <> "DialogSheet" Then
        If dHostAppVer < 11 + 1 Then lCellCount = appHostApp.ActiveWindow.ActiveSheet.Cells.Count Else lCellCount = appHostApp.ActiveWindow.ActiveSheet.Cells.CountLarge
        If Not (appHostApp.WorksheetFunction.CountBlank(appHostApp.ActiveWindow.ActiveSheet.Cells) < lCellCount Or appHostApp.ActiveWindow.ActiveSheet.Shapes.Count > 0) Then
            Msg1 = IIf(IsPortg, "Imposs|fffd|vel visualizar impress|fffd|o, a planilha est|fffd| vazia!", "Impossible to preview the print, the sheet is empty!")
            Msg2 = sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
            MyMsgBox Msg1, 1, Msg2
            Exit Sub
        End If
    End If

    Hide
    If dHostAppVer >= 11 + 1 + 2 + 1 Then SetForegroundWindowEsp App_hWnd, 0.5      'In Excel 15 hiding a modal form can change TargetWb focus.
    appHostApp.ActiveWindow.SelectedSheets.PrintPreview
    Show 1
End Sub

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub About_Lb_Click()
    If IsPortg Then
        Msg1 = "Copyright|fffd| 2009-" & VBA.Strings.Right(Year(VerDate), 2) & " by Fco Orlando Magalh|fffd|es Filho." & vbCrLf & _
               "Todos os direitos reservados." & vbCrLf & _
               "Licensa de Uso: Gr|fffd|tis (Freeware)" & vbCrLf & _
               "Tipo: " & IIf(bIsCOMAddin, "COM add-in programado em VBA (dll)", "Excel Add-in programado em VBA (xla)") & vbCrLf & _
               "Vers|fffd|o: " & fGetVersion & " (" & Format(VerDate, "yyyy.mm.dd") & ")" & vbCrLf & vbCrLf & _
               "Visitar o site para ver as novidades sobre este e outros utilit|fffd|rios. Ok?"
    Else
        Msg1 = "Copyright|fffd| 2009-" & VBA.Strings.Right(Year(VerDate), 2) & " by Fco Orlando Magalh|fffd|es Filho." & vbCrLf & _
               "All rights reserved." & vbCrLf & _
               "Use License: Freeware" & vbCrLf & _
               "Type: " & IIf(bIsCOMAddin, "COM add-in", "Add-in") & " programmed in VBA" & vbCrLf & _
               "Version: " & fGetVersion & " (" & Format(VerDate, "yyyy.mm.dd") & ")" & vbCrLf & vbCrLf & _
               "Visit the site to see the news about this and others utilities. Ok?"
    End If
    If MyMsgBox(Msg1, 2, IIf(IsPortg, "Sobre o 'Popup' ", "About Popup ") & sAddInCaptByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)"), Left / Twips - 95, Top / Twips - 15) = 1 Then
        On Error Resume Next
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            appHostApp.ActiveWorkbook.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True  'DifAppMet
        Case "Microsoft Word"
            appHostApp.ActiveDocument.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True
        Case "Microsoft PowerPoint"
            appHostApp.ActivePresentation.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True
        Case "Microsoft Access"
            appHostApp.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Sobre", "More.asp?IdC=About"), , True
        End Select
        If Err.Number <> 0 Then MsgBox Err.Description
    End If
End Sub

Private Sub ViewDone_Bt_Click()    'Obtem o nome do arquivo de forma semelhante ao nome para salvar XLS portable e depois Shell para que a nova inst|fffd|ncia do Excel seja de mesma vers|fffd|o
    On Error Resume Next
    If sPortblSavePath = "" Or VBA.Dir(sPortblSavePath, vbDirectory) = "" Then sPortblSavePath = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Desktop", False)   'ThisDLLPath
    If VBA.Strings.Mid(sPortblSavePath, 2, 1) = ":" Then ChDrive sPortblSavePath
    ChDir sPortblSavePath
TryOtherName:
    Err.Clear
    sPortblSaveName = appHostApp.GetOpenFilename("Portable Files (*.xlsx; *.xls),*.xlsx;*.xls")
    If sPortblSaveName = CStr(False) Or Not (sPortblSaveName Like "*.xls" Or sPortblSaveName Like "*.xlsx") Then Exit Sub        'S|fffd| aceita xls ou xlsx.
    'VBA.Interaction.Shell appHostApp.Path & appHostApp.PathSeparator & "Excel.exe /e /automation /r " & Chr(34) & sPortblSaveName & Chr(34), vbNormalFocus
    VBA.Interaction.Shell appHostApp.Path & appHostApp.PathSeparator & "Excel.exe /e /r " & VBA.Strings.Chr(34) & sPortblSaveName & VBA.Strings.Chr(34), vbNormalFocus
End Sub


Attribute VB_Name = "FormMyMsgBox"
Attribute VB_Base = "0{27D24128-4662-481B-AE11-72F5F9CA5853}{751E61B7-14CC-4C35-B75F-E26C924F477D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public EmailSubj As String
Public HomePageUrl As String
Dim Form_hWnd1 As Long
Public lBut As Long
Public Xpos As Long
Public Ypos As Long

Private Sub HomePage_Lb_Click()
    SendEMailByURL HomePage_Lb, HomePageUrl, "", "", False
End Sub

Private Sub Email_Lb_Click()
    SendEMailByURL Email_Lb, Email_Lb.ControlTipText, EmailSubj, EmlMsg, False
End Sub

Private Sub Ok_Bt_Click()
    BotAcionado = 1
    Hide
End Sub
Private Sub Cancel_Bt_Click()
    BotAcionado = 2
    Hide
End Sub

Private Sub Ignore_Bt_Click()
    BotAcionado = 3
    Hide
End Sub

Private Sub UserForm_Activate()
    Dim CountLines As Long
    Dim Lins
    Dim l As Long

    With Alert_Tb
        .Width = 284
        'Lins = Split(.Text, vbCrLf)
        Lins = MySplit(.Text, vbCrLf)
        For l = 0 To UBound(Lins)
            CountLines = CountLines + 1 + Int(VBA.Strings.Len(Lins(l)) / 70)    '75
        Next
        .Height = (1 + CountLines) * 12
        If .Height > 16 * 12 Then
            .Height = 15 * 12
            .SpecialEffect = fmSpecialEffectSunken
            .SetFocus
            .SelStart = 0
        End If
    End With


    Icon_Lb.Caption = IIf(lBut <> 1, "?", "i")
    Cancel_Bt.Visible = lBut <> 1
    Ignore_Bt.Visible = lBut = 3

    OK_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "Sim", "Yes"), "OK")
    Cancel_Bt.Caption = IIf(lBut = 3, IIf(IsPortg, "N|fffd|o", "No"), IIf(IsPortg, "Cancelar", "Cancel"))
    Ignore_Bt.Caption = IIf(IsPortg, "Ignorar", "Ignore")

    OK_Bt.Top = Alert_Tb.Top + Alert_Tb.Height + 5
    Cancel_Bt.Top = OK_Bt.Top
    Ignore_Bt.Top = OK_Bt.Top
    HomePage_Lb.Top = OK_Bt.Top + 7.5
    Email_Lb.Top = HomePage_Lb.Top
    If Width > 2 * 311 Then Twips = 20 Else Twips = 1    'Em ComAddin as dimens|fffd|es do formul|fffd|rio |fffd| em twip, mas as posi|fffd||fffd|es dos controles continuma em pontos
    Email_Lb.Left = Width / Twips - Email_Lb.Width - (Width / Twips - InsideWidth) - 4    'Email_Lb.Left = Width / Twips - Email_Lb.Width - 8    'Em COM add-in |fffd| preciso transformar width e height em Twips
    Height = (HomePage_Lb.Top + OK_Bt.Height) * Twips + (Height - InsideHeight * Twips) - 1 * Twips    'Height = (HomePage_Lb.Top + OK_Bt.Height) * Twips + (Height - InsideHeight * Twips - (Width - InsideWidth * Twips) / 2) + 2 * Twips  'Entre parentese: altura da barra de t|fffd|tulo(caption)

    If lBut = 1 Then OK_Bt.Left = 135
    If lBut = 2 Then OK_Bt.Left = 90: Cancel_Bt.Left = 180
    If Xpos <> 0 Then Left = Xpos
    If Ypos <> 0 Then Top = Ypos

    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel
    If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = 0 Then BotAcionado = IIf(Cancel_Bt.Visible, 2, 1)
End Sub

Attribute VB_Name = "FormPaperSize"
Attribute VB_Base = "0{60AB52E7-AFAB-464A-B64B-565F1B434F63}{4BD54E9B-2FEC-48E8-A2AC-8869D888EC5F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim Form_hWnd1 As Long

Private Sub Cancel_Bt_Click()
    PressBot = 2
    Unload Me
End Sub

Private Sub Inch_OpB_Click()
    Width_Tb.Value = VBA.Strings.Format(Width_Tb.Value / 25.4, "#,##0.0##")
    Height_Tb.Value = VBA.Strings.Format(Height_Tb.Value / 25.4, "#,##0.0##")
    Millimeter_OpB.Value = False
End Sub

Private Sub Millimeter_OpB_Click()
    Width_Tb.Value = VBA.Strings.Format(Width_Tb.Value * 25.4, "#,##0.0##")
    Height_Tb.Value = VBA.Strings.Format(Height_Tb.Value * 25.4, "#,##0.0##")
    Inch_OpB.Value = False
End Sub

Private Sub Ok_Bt_Click()
    P(Pindx, 1) = Round(Width_Tb.Value * IIf(Millimeter_OpB.Value, 1, 25.4), 1)
    P(Pindx, 2) = Round(Height_Tb.Value * IIf(Millimeter_OpB.Value, 1, 25.4))
    Unload Me
    PressBot = 1
End Sub

Private Sub UserForm_Initialize()
    If IsPortg Then
        Caption = "Tamanho de Papel Desconhecido"
        Caption_Lb.Caption = "Tipo de papel desconhecido ou personalizado. Entre ou confirme o tamanho:"
        Unit_Fr.Caption = "Unidades:"
        Width_Lb.Caption = "Largura:"
        Height_Lb.Caption = "Altura:"
        Millimeter_OpB.Caption = "Milimetros"
        Inch_OpB.Caption = "Polegadas"
        Cancel_Bt.Caption = "Cancelar"
    End If
    Width_Tb.Value = VBA.Strings.Format(P(Pindx, 1) * IIf(Millimeter_OpB.Value, 1, 1 / 25.4), "#,##0.0##")
    Height_Tb.Value = VBA.Strings.Format(P(Pindx, 2) * IIf(Millimeter_OpB.Value, 1, 1 / 25.4), "#,##0.0##")

    'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel
    If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    PressBot = 2
End Sub


Private Sub Width_Tb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    EvValor_Cb_MouseMove Width_Tb, Button, Shift, X, Y
End Sub
Private Sub Width_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    EvValor_Cb_KeyDown Width_Tb, KeyCode, Shift
    '   If KeyCode = 40 Or KeyCode = 38 Then JurTaxaCalculadora_Bt_Click
End Sub
Private Sub Width_Tb_Change()
    If vEnableEvents = False Then Exit Sub
    '   If Width_Tb.Value = MarcHist Then ConfHist Width_Tb, VBA.Strings.Format(Princ(7, 2).Value, "#,##0.0##"), False, "#,##0.0##"
    EvValor_Cb_Change Width_Tb, True
End Sub
Private Sub Width_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    EvValor_Cb_Exit Width_Tb, Cancel, "#,##0.0##"
End Sub


Private Sub Height_Tb_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    EvValor_Cb_MouseMove Height_Tb, Button, Shift, X, Y
End Sub
Private Sub Height_Tb_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    EvValor_Cb_KeyDown Height_Tb, KeyCode, Shift
    '   If KeyCode = 40 Or KeyCode = 38 Then JurTaxaCalculadora_Bt_Click
End Sub
Private Sub Height_Tb_Change()
    If vEnableEvents = False Then Exit Sub
    '   If Height_Tb.Value = MarcHist Then ConfHist Height_Tb, VBA.Strings.Format(Princ(7, 2).Value, "#,##0.00########"), False, "#,##0.00########"
    EvValor_Cb_Change Height_Tb, True
End Sub
Private Sub Height_Tb_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    EvValor_Cb_Exit Height_Tb, Cancel, "#,##0.0##"
End Sub
Attribute VB_Name = "Mod1PortblXLSPrinter"
Option Explicit
Public Const VerDate As Date = #7/30/2019#
Public IniDate As Date
Public bIsCOMAddin As Boolean
'Public ObjToVBA As XLSPrintObjToVBA    'Esse m|fffd|d. de class n|fffd|o |fffd| necess|fffd|rio em add-in. Remover e comentar essa linha

Private Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Private Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hWnd As Long) As Long
Public Declare Function GetForegroundWindow Lib "user32" () As Long
Public Declare Function GetActiveWindow Lib "user32" () As Long

Public Const GWL_HWNDPARENT As Long = -8
Public Const GWL_STYLE = (-16)
Public Const WS_THICKFRAME = &H40000
Public Const WS_MINIMIZEBOX = &H20000
Public Const WS_MAXIMIZEBOX = &H10000
Public Const GWL_EXSTYLE = (-20)
Public Const WS_CAPTION As Long = &HC00000
Public Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Public Declare Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Public Declare Function SetForegroundWindow Lib "user32" (ByVal hWnd As Long) As Long

Public Const WS_BORDER = &H800000
Public Const WS_DLGFRAME = &H400000
Public Const WS_EX_CLIENTEDGE = &H200
Public Const WS_EX_LAYERED = &H80000
Public Const LWA_ALPHA = &H2&
Public Const WS_EX_WINDOWEDGE = &H100
Public Const WS_EX_STATICEDGE = &H20000
Public Const WS_EX_APPWINDOW As Long = &H40000   'Show on taskbar
Public Const WS_EX_TOOLWINDOW As Long = &H80     'Tool Window (Small titlebar withoud any control except Close control)
Public Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Public Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Public Declare Function AdjustWindowRectEx Lib "user32" (lpRect As RECT, ByVal dsStyle As Long, ByVal bMenu As Long, ByVal dwEsStyle As Long) As Long
Public Declare Function MoveWindow Lib "user32" (ByVal hWnd As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long

Public sAddInNameByApp As String  'PortblXLSPrinter
Public sAddInCaptByApp As String    'Portable XLS Printer for Excel, Impressor de XLS Port|fffd|vel para Excel
Public AddInTitle As String    'Orlando's PortblXLSPrinter"
Public bAlertAboutNewVer As Boolean
'
Public bGetLastSetFail As Boolean
Public sIniDateChk As String    'Para garantir a integridade da data

Public sDLLProgId As String    '= "AddInPortblXLSPrinter.ExcelDesigner"
Public dHostAppVer As Double
Public App_hWnd As Long

Dim sINIfile As String
Public sPathSep As String
Public hFile As Long
Dim sFileDescr As String

Public sEmlEmail As String, sEmlSubj As String, sEmlMsg As String

Public Sub PortblXLSPrinter()
'IsPortg = appHostApp.International(xlCountryCode) = 55
    If dHostAppVer > 11 + 1 + 2 + 1 + 1 Then
        Msg1 = IIf(IsPortg, "Nova vers|fffd|o do Excel desconhecida para esta vers|fffd|o do " & sAddInCaptByApp & "! Clique no link Ajuda, logo abaixo, para baixar uma nova vers|fffd|o compat|fffd|vel.", _
                   "New Excel version unknown to this " & sAddInCaptByApp & " version! Click Help link, soon below, to download a new compatible version.")
        Msg2 = sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
        MyMsgBox Msg1, 1, Msg2
    Else
        Dim Wb As Excel.Workbook
        Dim WbSaved()
        Dim WbCnt As Long
        Dim i As Long
        'Guardando situa|fffd||fffd|o de salvamento das pastas ao iniciar
        WbCnt = appHostApp.Workbooks.Count
        If WbCnt > 0 Then
            ReDim WbSaved(WbCnt - 1, 1)
            For Each Wb In appHostApp.Workbooks
                i = i + 1
                WbSaved(i - 1, 0) = Wb.Name
                WbSaved(i - 1, 1) = Wb.Saved
            Next
        End If

        If IniDate = 0 Then ReadINISetting    'Ler vari|fffd|veis, se ainda n|fffd|o tiver lido
        If dHostAppVer >= 11 + 1 + 2 + 1 Then WbSDIWinRestAll: App_hWnd = appHostApp.hWnd    'Always get because in Excel 15 SDI each wb has its window with different handle.
        Load FormMain: If Not bIsCOMAddin Then FormMain.Show 1 Else FormMain.UserForm_Activate: If FormMain.Workbook_Cb.ListCount <> 0 Then FormMain.Show 1    'Tem workaround para resolver bug em COM, ver ProjetosTo2016\Lembrete2016.doc

        'Restaurando situa|fffd||fffd|o das pastas
        If WbCnt > 0 Then
            On Error Resume Next
            For i = 1 To WbCnt
                appHostApp.Workbooks(WbSaved(i - 1, 0)).Saved = WbSaved(i - 1, 1)
            Next
            On Error GoTo 0
        End If
    End If
    '   If Not ShiftDown Then ThisWorkbook.Close False
End Sub

Function fPortblXLSPrinter(Optional ToPrintWorkbookName As String, Optional ToPrintSheetName As String, Optional ToPrintSheetPasswrd As String, _
                           Optional PortblSavePath As String, Optional PortblSaveName As String, Optional PortblSheetPasswrd As String = "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|", _
                           Optional ZipPortbl As Boolean = False, Optional AfterDoneEmail As String, _
                           Optional EmailSubj As String, Optional EmailMsg As String) As Long

'Criticar argumentos
    On Error Resume Next    ': Set appHostApp = Application
    If ToPrintWorkbookName = "" Then ToPrintWorkbookName = appHostApp.ActiveWorkbook.Name _
                                                           Else appHostApp.Workbooks(ToPrintWorkbookName).Activate
    If Err.Number <> 0 Then
        fPortblXLSPrinter = 101    'RetError = 101
        Exit Function
    End If

    'Definir vari|fffd|veis de acordo com argumentos. Aqui porque bSendPortblXLSbyEmail j|fffd| vai definir a seguir.
    If IniDate = 0 Then ReadINISetting    'Ler vari|fffd|veis, se ainda n|fffd|o tiver lido
    WriteINISetting    'Grava para preservar UI cfg atual e restaurar no final

    If AfterDoneEmail = "" Then AfterDoneEmail = "0"
    bSendPortblXLSbyEmail = False: bSavePortblXLSasWebPg = False:
    sEmlEmail = "": sEmlSubj = "": sEmlMsg = ""
    If AfterDoneEmail = "0" Then
        bSuccessAlert = True
    ElseIf AfterDoneEmail = "1" Then
        bSuccessAlert = False
    ElseIf InStr(1, AfterDoneEmail, "@") > 2 And InStr(1, AfterDoneEmail, ".") > 1 Then
        bSendPortblXLSbyEmail = True
        sEmlEmail = Trim(AfterDoneEmail)
        sEmlSubj = EmailSubj
        sEmlMsg = EmailMsg
    ElseIf AfterDoneEmail = "SaveAs" Then
        bSavePortblXLSasWebPg = True
    Else
        fPortblXLSPrinter = 106    'RetError = 106   'Invalid argument or invalid email.
        Exit Function
    End If

    Dim bSendEmailOnly As Boolean
    bSendEmailOnly = bSendPortblXLSbyEmail And ToPrintWorkbookName <> "" And ToPrintSheetName = "" And ToPrintSheetPasswrd = "" And PortblSavePath = "" And PortblSaveName = "" And PortblSheetPasswrd = "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|"
    If Not bSendEmailOnly Then
        If ToPrintSheetName = "" Then ToPrintSheetName = appHostApp.ActiveWindow.ActiveSheet.Name _
                                                         Else appHostApp.ActiveWorkbook.Sheets(ToPrintSheetName).Activate
        If Err.Number <> 0 Then
            fPortblXLSPrinter = 102    'RetError = 102
            Exit Function
        End If

        bShHasPass = appHostApp.ActiveWindow.ActiveSheet.ProtectContents
        If bShHasPass And ToPrintSheetPasswrd = "" Then
            fPortblXLSPrinter = 103    'RetError = 103
            Exit Function
        End If
        sShPass = ToPrintSheetPasswrd

        If PortblSavePath = "" Then PortblSavePath = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Desktop", False)    'VBA.FileSystem.CurDir()
        If VBA.Strings.Right(PortblSavePath, 1) = "\" Then PortblSavePath = VBA.Strings.Left(PortblSavePath, VBA.Strings.Len(PortblSavePath) - 1)
        If PortblSavePath = "" Or Dir(PortblSavePath, vbDirectory) = "" Then
            fPortblXLSPrinter = 104    'RetError = 104
            Exit Function
        End If

        If appHostApp.ActiveWorkbook.Path = "" Then
            sPortblSaveExt = ".xls" & IIf(dHostAppVer >= 12, "x", "")
        Else
            sPortblSaveExt = IIf(Left(Right(ToPrintWorkbookName, 4), 1) = ".", ".xls", ".xlsx")    'Agora ser|fffd| do mesmo tipo do ActWkb  ".xls" & IIf(dHostAppVer >= 12, "x", "")
        End If
        If PortblSaveName = "" Then PortblSaveName = ToPrintWorkbookName & "_Portbl" & sPortblSaveExt
        If Not PortblSaveName Like "*" & sPortblSaveExt Then
            fPortblXLSPrinter = 105    'RetError = 105
            Exit Function
        End If

        If PortblSheetPasswrd = "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|" Then PortblSheetPasswrd = GearPsw(14)
    End If

    RetError = 0
    HasVBAProject = False
    If bSendEmailOnly Then
        Dim WbSaved As Boolean
        WbSaved = appHostApp.ActiveWorkbook.Saved
        appHostApp.ActiveWorkbook.Saved = True
        Set ActWkb = appHostApp.ActiveWorkbook
        Set ActWkbSel = appHostApp.Selection

        EnviarEmailTudo
        ActWkb.Saved = WbSaved
    Else
        sPortblSavePath = PortblSavePath
        sPortblSaveName = sPortblSavePath & appHostApp.PathSeparator & PortblSaveName
        bAddPortblNewSh = VBA.FileSystem.Dir(sPortblSaveName) <> ""  'Pela fun|fffd||fffd|o, se existir, vai sempre add new sheet silenciosamente
        bPrintToXLS = True: bZipPortblXLS = ZipPortbl
        bPortblSheetProtect = PortblSheetPasswrd <> ""    'Send_Bt_Click
        sPortblSheetPasswrd = PortblSheetPasswrd

        EnviarEmailPrintArea    'Chamado tal como em FormMain depois que todas as cfg foram preparadas igualmente.
    End If

    If Err.Number <> 0 Then RetError = 107: MyMsgBox Err.Description, 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")    'Erro no VBA n|fffd|o definido, mas com alerta exibindo descri|fffd||fffd|o.
    fPortblXLSPrinter = RetError
    bPrintToXLS = False
    ReadINISetting    'Restaura UI cfg
End Function

Sub test()
    Dim ret As Long
    'ret = fPortblXLSPrinter(, , "a")
    'ret = fPortblXLSPrinter("PortblXLSPrinterTest3.xls", "Sheet1", "", "C:\Documents and Settings\Orlando\Desktop", "TestPortbla.xls", "", False)
    ret = fPortblXLSPrinter("PortblXLSPrinterTest3.xls", , , , , , , "test@test.com", "Sobre plan", "Caro Vendedor," & Chr(10) & Chr(10) & "Veja em anexo")
End Sub

Public Function fGetVersion() As String
    fGetVersion = "1.2.2"
End Function

Sub WriteINISetting()
    If sINIfile = "" Then GetINIfile

    Dim bINInew As Boolean
    If VBA.FileSystem.Dir(sINIfile) = "" Then bINInew = True Else If VBA.FileSystem.FileLen(sINIfile) = 0 Then bINInew = True
    If bGetLastSetFail Then bINInew = True    'Se houve alguma falha na leitura considerar novo tamb|fffd|m
    sIniDateChk = CheckSum4(VBA.Strings.Format(IniDate, "mm/dd/yyyy"))

    On Error GoTo ErrorHandler
    hFile = FreeFile
    Open sINIfile For Output As #hFile
    Write #hFile, sFileDescr
    Write #hFile, IniDate
    Write #hFile, sIniDateChk
    Write #hFile, bPortblSheetProtect
    Write #hFile, bZipPortblXLS
    Write #hFile, bSendPortblXLSbyEmail
    Write #hFile, bSavePortblXLSasWebPg
    Write #hFile, sPortblSavePath
    'Write #hFile, HotKey

    Close #hFile

    'Se foi criado novo com sucesso, alertar sobre nova vers|fffd|o se vers|fffd|o com mais de 1ano e meio
    If bINInew And Date > VerDate + 3 * 180 Then bAlertAboutNewVer = True
    Exit Sub
ErrorHandler:
    MyMsgBox IIf(IsPortg, "N|fffd|o foi poss|fffd|vel salvar a nova configura|fffd||fffd|o no arquivo INI em:", "It wasn't possible to save the new setting on INI file at:") & vbCrLf & sINIfile, 1, IIf(IsPortg, "Erro! " & Err.Description, "Error! " & Err.Description)
End Sub

Sub ReadINISetting()
    If sINIfile = "" Then GetINIfile    'Se ainda n|fffd|o tiver definido, define e fica valendo para ler e escrever
    bGetLastSetFail = False

    On Error Resume Next
    hFile = FreeFile
    Open sINIfile For Input As #hFile
    Input #hFile, sFileDescr
    Input #hFile, IniDate
    Input #hFile, sIniDateChk
    Input #hFile, bPortblSheetProtect
    Input #hFile, bZipPortblXLS
    Input #hFile, bSendPortblXLSbyEmail
    Input #hFile, bSavePortblXLSasWebPg
    Input #hFile, sPortblSavePath
    'Input #hFile, HotKey

    Close #hFile

    If Err.Number <> 0 Then
        bGetLastSetFail = True    'Sinaliza para usa cfg padr|fffd|o e tentar ler novamente da pr|fffd|xima vez
    Else
        'Se j|fffd| existir INI funcional:
        'Alertar sobre nova vers|fffd|o, se IniDate lido estiver corrompido, pois pode ter sido proposital
        If sIniDateChk <> CheckSum4(VBA.Strings.Format(IniDate, "mm/dd/yyyy")) Then
            bAlertAboutNewVer = True: IniDate = 0
        Else
            'Alertar sobre nova vers|fffd|o a cada seis meses. Para evitar cria|fffd||fffd|o proposital de ini com data muito no futuro, criticar
            'atraso de seis meses tamb|fffd|m, mas s|fffd| em data ap|fffd|s VerDate, assim suporta problema eventual no rel|fffd|gio do computador
            If Date >= VerDate Then If VBA.Math.Abs(Date - IniDate) > 180 Then bAlertAboutNewVer = True    'Alertar s|fffd| quando o utilit|fffd|rio for requisitado realmente de prefer|fffd|ncia em cima de um form, pois alertar ao trabalhar em bakground confunde
        End If
    End If

    'Criticar vari|fffd|veis obtidas
    If IniDate = 0 Then IniDate = Date: bPortblSheetProtect = True    'Booleans aqui porque default is True if fail
    'If HotKey <> "" Then If Not fHotKey(HotKey, True, True) Then HotKey = ""    'Falhou limpa. Talvez isto n|fffd|o seja necess|fffd|rio
End Sub

Sub GetINIfile()
    Dim i As Long

    'Primeiro tenta junto ao xla, se falhar vai para o temp. Normalmente em usu|fffd|rio Restrito.
    Select Case appHostApp.Name
    Case "Microsoft Excel", "Microsoft Word"
        sPathSep = appHostApp.PathSeparator
        sINIfile = IIf(LCase(ThisDLLPath) = LCase(appHostApp.StartupPath), appHostApp.StartupPath & sPathSep & "..", _
                       ThisDLLPath) & sPathSep & sAddInNameByApp & ".ini"
    Case "Microsoft PowerPoint", "Microsoft Access"
        sPathSep = "\"
        sINIfile = ThisDLLPath & sPathSep & sAddInNameByApp & ".ini"
    End Select

    On Error Resume Next
    For i = 1 To 3
        Err.Number = 0
        hFile = FreeFile
        'Open sINIfile For Binary Lock Write As #hFile 'Only for write
        Open sINIfile For Append As #hFile                        'For read and write
        Close #hFile
        If Err.Number = 0 Then Exit For
        MyWait 0.3
    Next

    If Err.Number <> 0 Then
        If TempFolder <> "" Then
            'Em Temp tenta a subpasta OrlandoApp, se n|fffd|o existir cria e se n|fffd|o tiver sucesso vai no raiz mesmo
            If VBA.FileSystem.Dir(TempFolder & sPathSep & "OrlandoApp", vbDirectory) <> "" Then
                sINIfile = TempFolder & sPathSep & "OrlandoApp" & sPathSep & sAddInNameByApp & ".ini"
            Else
                Err.Clear
                VBA.FileSystem.MkDir TempFolder & sPathSep & "OrlandoApp"
                If Err.Number <> 0 Then
                    sINIfile = TempFolder & sPathSep & sAddInNameByApp & ".ini"
                Else
                    sINIfile = TempFolder & sPathSep & "OrlandoApp" & sPathSep & sAddInNameByApp & ".ini"
                End If
            End If
        End If
    End If

    sFileDescr = IIf(IsPortg, ";Este arquivo cont|fffd|m a configura|fffd||fffd|o inicial de " & sAddInCaptByApp & ". Ele pode ser exclu|fffd|do sem problemas", ";This file contains the initial setting of " & sAddInCaptByApp & ". It can be deleted without problems.")
End Sub

Function TempFolder() As String
'Get Temp Folder
    Dim fctRet As Long
    TempFolder = String$(255, 0)
    fctRet = GetTempPath(255, TempFolder)
    If fctRet <> 0 Then
        TempFolder = VBA.Strings.Left(TempFolder, fctRet)
        If VBA.Strings.Right(TempFolder, 1) = sPathSep Then TempFolder = VBA.Strings.Left(TempFolder, VBA.Strings.Len(TempFolder) - 1)
    Else
        TempFolder = ""
    End If
End Function

Public Sub AlertAboutNewVer()
    Static lDelay As Long

    If lDelay <> 0 Then Exit Sub    'Alerta uma |fffd|nica vez a cada execu|fffd||fffd|o
    If IniDate = 0 Then ReadINISetting    'Ler vari|fffd|veis, se ainda n|fffd|o tiver lido
    If bGetLastSetFail Then WriteINISetting    'Salva vari|fffd|veis padr|fffd|o, se houve falha na |fffd|ltima leitura
    If Not bAlertAboutNewVer Then Exit Sub    'Se em read e write n|fffd|o houve justificativa para alert sai

    If IsPortg Then
        Msg1 = "Esta vers|fffd|o j|fffd| tem mais de seis meses:" & vbCrLf & vbCrLf & _
               "OK - Suspender este alerta por um ou seis meses se conseguir abrir a homepage para voc|fffd| visitar e ver atualiza|fffd||fffd|es ou" & vbCrLf & vbCrLf & _
               "Cancelar - Alertar novamente na pr|fffd|xima execu|fffd||fffd|o. Se Ctrl + Shift estiverem pressionados, este alerta tamb|fffd|m ser|fffd| suspenso por seis meses sem visita |fffd| homepage."
        Msg2 = sAddInCaptByApp
    Else
        Msg1 = "This version already has more than six months:" & vbCrLf & vbCrLf & _
               "OK - Suspend this alert for one or six months if it gets to open the homepage for you visit and see updates or" & vbCrLf & vbCrLf & _
               "Cancel - Alert again in the next execution. If Ctrl + Shift are pushed, this alert will be suspended too for six month without homepage visit."
        Msg2 = sAddInCaptByApp
    End If
    If MyMsgBox(Msg1, 2, Msg2) = 2 Then
        lDelay = 1
    Else
        lDelay = 2
        On Error Resume Next
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            appHostApp.ActiveWorkbook.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True  'DifAppMet
        Case "Microsoft Word"
            appHostApp.ActiveDocument.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True
        Case "Microsoft PowerPoint"
            appHostApp.ActivePresentation.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True
        Case "Microsoft Access"
            appHostApp.FollowHyperlink "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=ProcUpdt", "More.asp?IdC=LookUpdt"), , True
        End Select
        If Err.Number <> 0 Then MsgBox Err.Description Else lDelay = 3: MyWait 2: VBA.Interaction.AppActivate GetAppWinCaption
    End If
    If CtrlDown And ShiftDown Then
        lDelay = 3
        Do While CtrlDown Or ShiftDown: MyWait 0.1: Loop
    End If
    If lDelay > 1 Then    'Se n|fffd|o vai adiar n|fffd|o precisa salvar e em cancelamento |fffd| melhor n|fffd|o alterar nada, pois pode ser algum desajuste no rel|fffd|gio conhecido pelo usu|fffd|rio.
        IniDate = Date + Choose(lDelay, 0, -150, 0)
        WriteINISetting
    End If
End Sub

Function GetActWinCaption() As String
    Dim vStr As String
    Dim ret As Long
    vStr = String(GetWindowTextLength(GetActiveWindow), Chr$(0))
    ret = GetWindowText(GetActiveWindow, vStr, VBA.Strings.Len(vStr) + 1)
    If ret <> 0 Then
        GetActWinCaption = vStr
    End If
End Function

Function GetAppWinCaption() As String
    Dim vStr As String
    Dim ret As Long
    vStr = String(GetWindowTextLength(App_hWnd), Chr$(0))
    ret = GetWindowText(App_hWnd, vStr, VBA.Strings.Len(vStr) + 1)
    If ret <> 0 Then
        GetAppWinCaption = vStr
    End If
End Function

Function ThisDLLPath() As String
    Static sDllPath As String
    If sDllPath <> "" Then ThisDLLPath = sDllPath: Exit Function
    If bIsCOMAddin Then
        Dim sGuid As String
        On Error Resume Next
        sGuid = GetRegValue(HKEY_CLASSES_ROOT, sDLLProgId & "\CLSID", "", False)
        sDllPath = GetRegValue(HKEY_CLASSES_ROOT, "CLSID\" & sGuid & "\InprocServer32", "", False)
        If VBA.FileSystem.Dir(sDllPath) <> "" Then sDllPath = VBA.Strings.Left(sDllPath, VBA.Strings.Len(sDllPath) - VBA.Strings.Len(Dir(sDllPath)) - 1) Else sDllPath = ""
        If Err.Number <> 0 Then sDllPath = ""
    Else
        sDllPath = appHostApp.ThisWorkbook.Path
    End If
    ThisDLLPath = sDllPath
End Function

Sub FixForm(hWinHld As Long)
'Fixar form
    Dim lStyle As Long
    lStyle = GetWindowLongA(hWinHld, GWL_STYLE)
    lStyle = lStyle And Not WS_THICKFRAME    'Fixar tamanho
    lStyle = lStyle And Not WS_MINIMIZEBOX
    lStyle = lStyle And Not WS_MAXIMIZEBOX
    SetWindowLongA hWinHld, GWL_STYLE, lStyle

    lStyle = GetWindowLongA(hWinHld, GWL_EXSTYLE)
    lStyle = lStyle And Not WS_EX_APPWINDOW     'N|fffd|o exibir na barra de tarefa do Windows. S|fffd| |fffd| |fffd|til em COM add-in, mas n|fffd|o tem problema usar em xla
    SetWindowLongA hWinHld, GWL_EXSTYLE, lStyle

    DrawMenuBar hWinHld    'Atualizar barra
End Sub

Sub WbSDIWinRestAll()    'Need in Excel 15 SDI before loading a modal form that can navigate between Wb, because you can restore window wb when is showing.
    Dim ActWb As Excel.Workbook
    Dim Wb As Excel.Workbook
    If appHostApp.Workbooks.Count > 1 Then
        Set ActWb = appHostApp.ActiveWorkbook
        For Each Wb In appHostApp.Workbooks
            If Wb.Windows(1).WindowState = xlMinimized Then Wb.Windows(1).WindowState = xlNormal: DoEvents: Wb.Activate
        Next
        ActWb.Activate
    End If
End Sub

Function GearPsw(lLen As Long) As String
    Do
        VBA.Math.Randomize
        GearPsw = GearPsw & VBA.Strings.Chr(Int((126 - 33 + 1) * VBA.Math.Rnd + 33))    'Gera caract entre 33 e 126
    Loop While VBA.Strings.Len(GearPsw) < lLen
End Function

Function CheckSum2(CheckString)
    Dim i
    Dim ac
    Dim cs
    For i = 1 To VBA.Strings.Len(CheckString)
        ac = ac + (i * Asc(VBA.Strings.Mid(CheckString, i, 1)))
    Next
    cs = (ac And &HFF0000) \ 65536    ' third byte
    cs = cs + (ac And &HFF00&) \ 256  ' + second byte
    cs = (cs + (ac And 255)) And 255  ' + low byte
    CheckSum2 = VBA.Strings.Right("0" & Hex(cs), 2)
End Function

Function CheckSum4(CheckString)
'Especial checksum com quatro caracteres
    CheckSum4 = CheckSum2(CheckString)
    CheckSum4 = CheckSum4 & CheckSum2("ostegsdj uyfopp6gd dj" & CheckSum4)
End Function

Attribute VB_Name = "Mod1Prepare"
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'|fffd| APPLICATION:   PortblXLSPrinter.xla
'|fffd|
'|fffd| AUTHOR & DATE: FCO ORLANDO MAGALH|fffd|ES FILHO  4 April 2000
'|fffd|                Microsoft MVP - Excel
'|fffd|                Santa Quit|fffd|ria-Ce - Brazil
'|fffd|
'|fffd| CONTACT:       orlando@cpap.com.br
'|fffd| WEB SITE:      http://cpap.com.br/orlando
'|fffd|
'|fffd| DESCRIPTION:   Portable XLS Printer
'|fffd|
'|fffd| COPYRIGHTS:    Free to use with your application and free to distribute
'|fffd|                since this pack and any of file is not alter without previous
'|fffd|                authorization of the author.
'|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
Option Explicit

Type PaperSize
    lXlIndex As Long
    sName As String
    dWidth As Double
    dHeight As Double
End Type
Public tPaperSize As PaperSize

Public appHostApp As Excel.Application
Public Twips As Long

Public Pindx As Integer
Public PressBot As Integer
Public P(44, 4)

Public bPortblSheetProtect As Boolean
Public sPortblSheetPasswrd As String
Public bShHasPass As Boolean
Public sShPass As String
Public HasVBAProject As Boolean
Public RetError As Long

Dim filtArray()
Dim sFiltRng As String
Dim i As Long

Public ActWkb As Excel.Workbook, ActWkbSel   'As Range

Sub EnviarEmailPrintArea()
'Dim ActWkbSel    'As Range
    Dim sPrintArea As String
    Dim NewWkb As Excel.Workbook
    Dim Fig As Excel.Shape    'Se n|fffd|o explicitar Excel n|fffd|o reconhece ControlFormat no 2000
    Dim Nome As Excel.Name
    Dim bHasShapes As Boolean
    Dim bShapeOutPrnt As Boolean
    Dim TmpWkb As Excel.Workbook
    Dim bHasVCmOutPrtA As Boolean    'Tem coment|fffd|rios visiveis ancorado fora da |fffd|rea de impress|fffd|o

    Dim LinI As Long
    Dim LinF As Long
    Dim ColI As Long
    Dim ColF As Long
    Dim LinFt As Long
    Dim ColFt As Long
    Dim j As Long
    Dim AppCalc As Long
    Dim WbSaved As Boolean, bHadChg As Boolean    'Verifica se necessita de altera|fffd||fffd|es para ser pott|fffd|vel.
    Dim ShScrArea As String

    On Error Resume Next
    Set ActWkb = appHostApp.ActiveWorkbook
    Set ActWkbSel = appHostApp.Selection

    If TypeName(appHostApp.ActiveWindow.ActiveSheet) <> "Chart" Then    'Se Chart, fazer o mesmo isolado depois, pois h|fffd| mais diferen|fffd|as e semelhan|fffd|as do que igualdades
        WbSaved = appHostApp.ActiveWorkbook.Saved: bHadChg = Not WbSaved

        'Capta e envia s|fffd| |fffd|rea de impress|fffd|o da planilha ativa
        AppCalc = appHostApp.Calculation
        appHostApp.Calculation = xlManual
        appHostApp.ScreenUpdating = False
        appHostApp.EnableEvents = False

        If dHostAppVer < 11 + 1 Then    'Antes do 2007 essa desprote|fffd||fffd|o logo aqui |fffd| necess|fffd|ria, pois o Paste l|fffd| na frente |fffd| necess|fffd|rio para completar texto de c|fffd|lulas com mais de 255 caracteres n|fffd|o suportada pela c|fffd|pia de planilha inteira.
            If bShHasPass Then
                appHostApp.ActiveWindow.ActiveSheet.Unprotect sShPass
                If Err.Number <> 0 Then
                    appHostApp.Calculation = AppCalc
                    appHostApp.EnableEvents = True
                    appHostApp.ScreenUpdating = True
                    ActWkb.Saved = WbSaved
                    RetError = 2
                    Exit Sub
                End If
            End If
            ShScrArea = appHostApp.ActiveWindow.ActiveSheet.ScrollArea
            If ShScrArea <> "" Then appHostApp.ActiveWindow.ActiveSheet.ScrollArea = ""
            appHostApp.ActiveWindow.ActiveSheet.Range("A1").Select    'Testa se foi desprotegido antes de obter |fffd|rea de impress|fffd|o. Este era o primeiro teste em vers|fffd|es antigas, agora antecipando a desprote|fffd||fffd|o talvez n|fffd|o seja necess|fffd|ria, mas fica por garantia.
            If Err.Number <> 0 Then
                appHostApp.Calculation = AppCalc
                appHostApp.EnableEvents = True
                appHostApp.ScreenUpdating = True
                If ShScrArea <> "" Then appHostApp.ActiveWindow.ActiveSheet.ScrollArea = ShScrArea
                ActWkb.Saved = WbSaved
                RetError = 1
                Exit Sub
            End If
        End If
        On Error GoTo 0

        Dim bNewWkbInMem As Boolean    'A c|fffd|pia da planilha a imprimir para um novo Wb a ser trabalhado pode ser feito s|fffd| na mem|fffd|ria (padr|fffd|o) ou via disco que |fffd| mais r|fffd|pido quando tem muitas linhas ocultas. No entanto, se for protegido para abrir vai ser mais demorado pedir senha.
        bNewWkbInMem = True: i = 0
        If ActWkb.HasPassword = False And ActWkb.Path <> "" Then i = appHostApp.ActiveWindow.ActiveSheet.UsedRange.Rows.Count: If i > 7000 + 1000 And Not bShHasPass Then bNewWkbInMem = appHostApp.ActiveWindow.ActiveSheet.Range("A1").Resize(i, 1).Cells.Count - appHostApp.ActiveWindow.ActiveSheet.Range("A1").Resize(i, 1).SpecialCells(xlCellTypeVisible).Cells.Count < 7000
        If bShHasPass Then bNewWkbInMem = i < 7000 + 1000    'xlCellTypeVisible gera erro em planilha protegida
NewWkbInMem:
        If bNewWkbInMem Then
            Dim bCopyObj As Boolean    'Necess|fffd|rio no Excel 2007
            bCopyObj = appHostApp.CopyObjectsWithCells
            appHostApp.CopyObjectsWithCells = True
            appHostApp.ActiveWindow.ActiveSheet.Copy
            appHostApp.CopyObjectsWithCells = bCopyObj
            Set NewWkb = appHostApp.ActiveWorkbook
        Else    'Tenta via disco usando tmp, mas se falhar volta silenciosamente e tenta o padr|fffd|o s|fffd| na mem|fffd|ria mesmo mais demorado.
            Dim sNewSh As String, Sh As Object     'As Excel.Worksheet 'Fail if chart sheet
            sPortblSaveExt = IIf(Left(Right(ActWkb.Name, 4), 1) = ".", Right(ActWkb.Name, 4), Right(ActWkb.Name, 5))    'Para SaveCopyAs tem que ser a mesma do ActWkb  '".xls" & IIf(dHostAppVer >= 12, "x", "")
            GetTempFileName
            sNewSh = appHostApp.ActiveWindow.ActiveSheet.Name
            On Error Resume Next
            If Err.Number = 0 Then appHostApp.ActiveWorkbook.SaveCopyAs sTempFileName
            If Err.Number = 0 Then Set NewWkb = appHostApp.Workbooks.Open(sTempFileName, 0, True)
            If Err.Number = 0 Then NewWkb.Sheets(sNewSh).Activate
            If Err.Number = 0 Then
                appHostApp.DisplayAlerts = False
                For Each Sh In NewWkb.Sheets
                    If Sh.Name <> sNewSh Then Sh.Delete
                Next
                appHostApp.DisplayAlerts = True
            End If
            If Err.Number <> 0 Then bNewWkbInMem = True Else If Dir(sTempFileName) <> "" Then Kill sTempFileName: sTempFileName = ""    'J|fffd| na mem, libera espa|fffd|o no disco mesmo podendo aproveitar logo a frente, pois o que ser|fffd| salvo l|fffd| ser|fffd| significat. menor.
            If bNewWkbInMem Then GoTo NewWkbInMem
        End If

        If bShHasPass Then
            On Error Resume Next
            appHostApp.ActiveWindow.ActiveSheet.Unprotect sShPass
            If Err.Number <> 0 Then
                NewWkb.Close False
                appHostApp.Calculation = AppCalc
                appHostApp.EnableEvents = True
                appHostApp.ScreenUpdating = True
                ActWkb.Saved = WbSaved
                RetError = 2
                Exit Sub
            End If
        End If
        On Error Resume Next    'Isso ignora qualquer problema. Quando quiser testar o ideal |fffd| quebrar esta linha e usar        On Error GoTo 0

        'Obtendo |fffd|rea de impress|fffd|o j|fffd| na c|fffd|pia e j|fffd| desprotegida
        appHostApp.ActiveWindow.ActiveSheet.ScrollArea = ""
        sPrintArea = appHostApp.ActiveWindow.ActiveSheet.PageSetup.PrintArea
        If sPrintArea = "" Then
            Dim s As Excel.Shape
            Dim lHeight As Double
            Dim lWidth As Double
            lHeight = 0
            lWidth = 0
            For Each s In appHostApp.ActiveWindow.ActiveSheet.Shapes
                If s.Visible Then
                    If s.Left + s.Width > lWidth Then lWidth = s.Left + s.Width
                    If s.Top + s.Height > lHeight Then lHeight = s.Top + s.Height
                End If
            Next

            Dim c As Range
            Set c = appHostApp.ActiveWindow.ActiveSheet.UsedRange
            If c.Left + c.Width >= lWidth Then lWidth = c.Left + c.Width
            If c.Top + c.Height >= lHeight Then lHeight = c.Top + c.Height

            For Each c In appHostApp.ActiveWindow.ActiveSheet.Range("A1").EntireRow.Cells
                If c.Left + c.Width >= lWidth Then
                    sPrintArea = c.Column
                    Exit For
                End If
            Next
            For Each c In appHostApp.ActiveWindow.ActiveSheet.Range("A1").EntireColumn.Cells
                If c.Top + c.Height >= lHeight Then
                    sPrintArea = appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1), appHostApp.ActiveWindow.ActiveSheet.Cells(c.Row, sPrintArea * 1)).Address
                    Exit For
                End If
            Next
        End If

        If appHostApp.ActiveWindow.FreezePanes <> False Or appHostApp.ActiveWindow.SplitRow <> 0 Or appHostApp.ActiveWindow.SplitColumn <> 0 Then bHadChg = True
        appHostApp.ActiveWindow.FreezePanes = False: appHostApp.ActiveWindow.SplitRow = 0: appHostApp.ActiveWindow.SplitColumn = 0

        Const bDelAtEnd As Boolean = True    'Deletar, ocultar ou mesmo limpar colunas ou linhas com outras linhas e colunas ocultal fica muito lento. Ent|fffd|o em guarda em array linhas e colunas ocultas e no final exibe tudo ent|fffd|o deleta ou limpa.
        Dim DelRow() As Long, DelCol() As Long
        Dim bDelRow As Boolean, bDelCol As Boolean, j1 As Long
        ReDim DelRow(1 To appHostApp.ActiveWindow.ActiveSheet.UsedRange.Rows.Count + 1)    'Mais 1 por seguran|fffd|a
        ReDim DelCol(1 To appHostApp.ActiveWindow.ActiveSheet.UsedRange.Columns.Count + 1)

        'Limpa AutoFilter
        Dim bAFmode As Boolean
        Dim HiddRow() As Long
        Dim AFRng As Range
        Dim r As Range
        bAFmode = appHostApp.ActiveWindow.ActiveSheet.AutoFilterMode
        i = 0
        If bAFmode Then
            Set AFRng = appHostApp.ActiveWindow.ActiveSheet.AutoFilter.Range
            For Each r In AFRng.Rows
                If r.Hidden Then
                    If bDelAtEnd Then
                        DelRow(r.Row) = 1: bDelRow = True: bHadChg = True
                    Else
                        i = i + 1
                        ReDim Preserve HiddRow(i - 1)
                        HiddRow(i - 1) = r.Row
                    End If
                End If
            Next
            appHostApp.ActiveWindow.ActiveSheet.AutoFilterMode = False
            If i > 0 Then
                For j = 0 To i - 1
                    appHostApp.ActiveWindow.ActiveSheet.Cells(HiddRow(j), 1).EntireRow.Hidden = True
                    If Int(j / 10) = j / 10 Then    'Necess|fffd|rio no 2007. Muito lento
                        DoEvents
                        appHostApp.StatusBar = IIf(IsPortg, "Analisando Auto Filtro: ", "Analizing Auto Filter: ") & j & "/" & i - 1
                    End If
                Next
                appHostApp.StatusBar = False
            End If
        End If

        If dHostAppVer < 11 + 1 Then    'No 2007 esse lim foi eliminado
            'Paste |fffd| necess|fffd|rio aqui para completar texto de c|fffd|lulas com mais de 255 caracteres n|fffd|o suportada
            'pela c|fffd|pia de planilha inteira. Paste special n|fffd|o funciona aqui se houver c|fffd|lulas mescladas e o
            'paste normal cola tamb|fffd|m objetos e linca gr|fffd|ficos, por isso foi necess|fffd|rio uma pasta tempor|fffd|ria
            'para limpar os objetos quando houver. Talvez usar CopyObjectsWithCells seria suficiente, acho que
            'foi desconhecimento em vers|fffd|es antiga, mas vou deixar como est|fffd|, j|fffd| bem testado.
            ActWkb.Activate
            If bAFmode Then StoreAutoFilter

            bHasShapes = appHostApp.ActiveWindow.ActiveSheet.Shapes.Count > 0
            If bHasShapes Then
                Set TmpWkb = appHostApp.Workbooks.Add(Template:=appHostApp.ActiveWindow.ActiveSheet.Type)    'Workbooks.Add(1)
                ActWkb.Activate
            End If

            appHostApp.GoTo Reference:=appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea)
            appHostApp.Selection.Copy: ActWkbSel.Select

            If bHasShapes Then
                TmpWkb.Activate
                appHostApp.GoTo Reference:=TmpWkb.ActiveSheet.Range(sPrintArea)
                TmpWkb.ActiveSheet.Paste
                appHostApp.CutCopyMode = False
                'Excluindo objetos em TmpWkb
                For Each Fig In TmpWkb.ActiveSheet.Shapes
                    Fig.Delete
                Next
                appHostApp.GoTo Reference:=TmpWkb.ActiveSheet.Range(sPrintArea)
                appHostApp.Selection.Copy
            End If

            NewWkb.Activate
            appHostApp.GoTo Reference:=appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea)
            appHostApp.DisplayAlerts = False    'Skip name alert
            appHostApp.ActiveWindow.ActiveSheet.Paste
            appHostApp.CutCopyMode = False
            appHostApp.DisplayAlerts = True

            If bHasShapes Then TmpWkb.Close False

            If bAFmode Then
                ActWkb.Activate
                RestoreAutoFilter
                NewWkb.Activate
            End If
        End If

        'Paste especial para eliminar formulas
        appHostApp.GoTo Reference:=appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea)
        Dim vHas As Variant
        vHas = appHostApp.Selection.HasFormula
        If IsNull(vHas) Or vHas = True Then
            appHostApp.Selection.Copy
            appHostApp.Selection.PasteSpecial Paste:=xlValues: bHadChg = True
            appHostApp.CutCopyMode = False
        End If
        vHas = appHostApp.Selection.Locked
        If IsNull(vHas) Or vHas = False Then appHostApp.Selection.Locked = True: bHadChg = True

        'Quebrar links de gr|fffd|ficos convertendo em figura e excluir se n|fffd|o imprim|fffd|veis
        Dim Ch As Excel.ChartObject, Ch1 As Excel.ChartObject
        Dim Sr As Excel.Series
        Dim sNumbFormC As String, sNumbFormV As String
        Dim oPic As Object
        Dim i1 As Long
        For Each Ch In appHostApp.ActiveWindow.ActiveSheet.ChartObjects
            i = i + 1: bHadChg = True    'A priori, se houver chart considera que vai haver altera|fffd||fffd|es, pois s|fffd|o muitos detalhes.
            Set Fig = appHostApp.ActiveWindow.ActiveSheet.Shapes(Ch.Name)    'Necess|fffd|rio no Excel 2007 pois a linha abaixo falha
            'If Not Ch.PrintObject Or Ch.ShapeRange.Left > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Width Or Ch.ShapeRange.Top > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Height Then 'No Excel 2007 falha
            If Not Fig.ControlFormat.PrintObject Or Fig.Left > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Width Or Fig.Top > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Height Then
                Fig.Delete
            Else
                Ch.Chart.Axes(xlCategory).TickLabels.AutoScaleFont = False
                Ch.Chart.Axes(xlValue).TickLabels.AutoScaleFont = False
                Ch.Chart.Axes(xlCategory).TickLabels.NumberFormatLinked = False
                Ch.Chart.Axes(xlValue).TickLabels.NumberFormatLinked = False

                'Obter algumas propriedades do original que podem ter sido alterada na copia da planilha normalmente quando h|fffd| links externos
                i1 = 0
                For Each Ch1 In ActWkb.ActiveSheet.ChartObjects
                    i1 = i1 + 1
                    If i1 = i Then
                        sNumbFormC = Ch1.Chart.Axes(xlCategory).TickLabels.NumberFormat
                        sNumbFormV = Ch1.Chart.Axes(xlValue).TickLabels.NumberFormat
                        Exit For
                    End If
                Next

                Ch.Chart.Axes(xlCategory).TickLabels.NumberFormat = sNumbFormC
                If Ch.Chart.Axes(xlCategory).CategoryType = xlAutomaticScale _
                   And InStr(1, sNumbFormC, "/") > 0 Then
                    Ch.Chart.Axes(xlCategory).CategoryType = xlTimeScale
                    sNumbFormC = IIf(appHostApp.International(xl4DigitYears), "yyyy", "yy")
                    Select Case appHostApp.International(xlDateOrder)
                    Case 0
                        sNumbFormC = IIf(appHostApp.International(xlMonthLeadingZero), "mm", "m") & "/" & IIf(appHostApp.International(xlDayLeadingZero), "dd", "d") & "/" & sNumbFormC
                    Case 1
                        sNumbFormC = IIf(appHostApp.International(xlDayLeadingZero), "dd", "d") & "/" & IIf(appHostApp.International(xlMonthLeadingZero), "mm", "m") & "/" & sNumbFormC
                    Case 2
                        sNumbFormC = sNumbFormC & "/" & IIf(appHostApp.International(xlMonthLeadingZero), "mm", "m") & "/" & IIf(appHostApp.International(xlDayLeadingZero), "dd", "d")
                    End Select
                    Ch.Chart.Axes(xlCategory).TickLabels.NumberFormat = sNumbFormC
                End If

                Ch.Chart.Axes(xlValue).TickLabels.NumberFormat = sNumbFormV

                'Quebrar links copiando e colando como figura
                If dHostAppVer <= 9 Then   'Excel 2002 em diante tem o m|fffd|todo BreakLink que parece mais exato, evitanto captar objetos sobre o gr|fffd|fico ao copiar e colar a figura. No PrintThruEmail n|fffd|o confiei s|fffd| nele, pois era novo.
                    Ch.Chart.CopyPicture Appearance:=xlScreen, Size:=xlScreen, Format:=xlPicture
                    Set oPic = appHostApp.ActiveWindow.ActiveSheet.Pictures.Paste
                    oPic.ShapeRange.Left = Ch.Left
                    oPic.ShapeRange.Top = Ch.Top
                    While oPic.ZOrder > Ch.ZOrder
                        oPic.ShapeRange.ZOrder msoSendBackward
                    Wend
                    oPic.Placement = xlMove
                    Ch.Delete
                End If
            End If
        Next

        'Excluindo coment|fffd|rios n|fffd|o imprim|fffd|veis
        Dim cm As Excel.Comment
        If appHostApp.ActiveWindow.ActiveSheet.Comments.Count > 0 Then
            Select Case appHostApp.ActiveWindow.ActiveSheet.PageSetup.PrintComments
            Case xlPrintNoComments
                appHostApp.ActiveWindow.ActiveSheet.Range("A1").SpecialCells(xlCellTypeComments).ClearComments: bHadChg = True
            Case xlPrintInPlace
                For Each cm In appHostApp.ActiveWindow.ActiveSheet.Comments
                    If cm.Visible Then
                        bShapeOutPrnt = cm.Shape.Top + cm.Shape.Height < appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top _
                                        Or cm.Shape.Left + cm.Shape.Width < appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left _
                                        Or cm.Shape.Left > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Width _
                                        Or cm.Shape.Top > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Height
                        If bShapeOutPrnt Then
                            cm.Delete: bHadChg = True
                        Else
                            If cm.Shape.Placement <> xlMove Then cm.Shape.Placement = xlMove: bHadChg = True
                            If Intersect(cm.Parent, appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea)) Is Nothing Then bHasVCmOutPrtA = True
                        End If
                    Else
                        cm.Delete: bHadChg = True
                    End If
                Next
            Case xlPrintSheetEnd
                For Each cm In appHostApp.ActiveWindow.ActiveSheet.Comments
                    If appHostApp.Intersect(cm.Parent, appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea)) Is Nothing Then cm.Delete: bHadChg = True
                Next
            End Select
        End If

        'Excluindo objetos n|fffd|o imprim|fffd|veis e quebrar links
        For Each Fig In appHostApp.ActiveWindow.ActiveSheet.Shapes
            If Fig.Type <> msoComment And Fig.Type <> msoChart Then
                If Not Fig.Visible Then
                    Fig.Delete: bHadChg = True
                Else
                    bShapeOutPrnt = Fig.Top + Fig.Height < appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top _
                                    Or Fig.Left + Fig.Width < appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left _
                                    Or Fig.Left > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Width _
                                    Or Fig.Top > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Height
                    If bShapeOutPrnt Then
                        Fig.Delete: bHadChg = True
                    Else
                        If Fig.ControlFormat.PrintObject Then
                            If Fig.Type <> msoOLEControlObject Then
                                If Fig.OnAction <> "" Then Fig.OnAction = "": bHadChg = True
                                If Fig.Type <> msoFormControl And Fig.Type <> msoGroup And Fig.Type <> msoLine Then Fig.DrawingObject.Formula = "": bHadChg = True  'No 2007 figura de gr|fffd|fico n|fffd|o aceita f|fffd|rmula e d|fffd| erro.
                            End If
                            If Fig.Placement <> xlMove Then Fig.Placement = xlMove: bHadChg = True
                        Else
                            Fig.Delete: bHadChg = True
                        End If
                    End If
                End If
            End If
        Next
        appHostApp.ActiveWindow.ActiveSheet.Range("A1").Select

        'Quebrar query table links
        Dim qt As Excel.QueryTable
        If appHostApp.ActiveWindow.ActiveSheet.QueryTables.Count > 0 Then
            For Each qt In appHostApp.ActiveWindow.ActiveSheet.QueryTables
                qt.Delete: bHadChg = True
            Next
        End If

        'Quebrar hyperlinks
        Dim h As Excel.Hyperlink
        For Each h In appHostApp.ActiveWindow.ActiveSheet.Hyperlinks
            h.Address = "": bHadChg = True
            h.SubAddress = appHostApp.ActiveWindow.ActiveSheet.Name & "!A1"
        Next

        'Excluindo nomes (Preciso verificar links aqui tamb|fffd|m xxxx)
        For Each Nome In appHostApp.ActiveWorkbook.Names
            If VBA.Strings.Right(Nome.Name, 10) = "Print_Area" _
               Or VBA.Strings.Right(Nome.Name, 12) = "Print_Titles" _
               Then Else Nome.Delete: bHadChg = True
        Next

        'Quebrar links externos restantes (O m|fffd|todo BreakLink s|fffd| funciona Excel 2002 em diante)
        Dim arrLinks As Variant
        Dim sLnk As Variant
        Dim bHasLnkYet As Boolean
        arrLinks = appHostApp.ActiveWorkbook.LinkSources(Type:=xlLinkTypeOLELinks)
        If Not IsEmpty(arrLinks) Then
            bHadChg = True
            For Each sLnk In arrLinks
                If dHostAppVer > 9 Then appHostApp.ActiveWorkbook.BreakLink _
                Name:=sLnk, Type:=xlLinkTypeOLELinks Else bHasLnkYet = True
            Next
        End If
        arrLinks = appHostApp.ActiveWorkbook.LinkSources(Type:=xlLinkTypeExcelLinks)
        If Not IsEmpty(arrLinks) Then
            bHadChg = True
            For Each sLnk In arrLinks
                If dHostAppVer > 9 Then appHostApp.ActiveWorkbook.BreakLink _
                Name:=sLnk, Type:=xlLinkTypeExcelLinks Else bHasLnkYet = True
            Next
        End If
        '    If bHasLnkYet Then 'Esse alert pode ser falso, por isso foi removido
        '        If IsPortg Then
        '            Msg1 = "Nem todos os v|fffd|nculos foram removidos. Normalmente isto n|fffd|o causa qualquer problema, se o destinat|fffd|rio, ao abrir, cancelar o alerta para atualizar v|fffd|nculos. " _
                     '                    & Chr(10) & Chr(10) & "Por favor, se for poss|fffd|vel, envie uma c|fffd|pia da impress|fffd|o para orlando@cpap.com.br para que o problema possa ser corrigido. "
        '                    Msg2 = sAddInNameByApp & " - Falha! Removendo V|fffd|nculos"
        '        Else
        '            Msg1 = "Nor all links were removed. Normally this don't cause any problem, if the recipient, when open, cancels the alert to update links. " _
                     '                    & Chr(10) & Chr(10) & "Please, if it's possible, send a print copy to orlando@cpap.com.br for that the problem could be corrected."
        '                    Msg2 = sAddInNameByApp & " - Fail! Removing Links"
        '        End If
        '        MyMsgBox Msg1, 1, Msg2
        '    End If

        'Excluindo colunas e linhas fora da |fffd|rea de impress|fffd|o. S|fffd| limpa, se houver coment|fffd|rios vis|fffd|veis ancorados fora da |fffd|rea de impress|fffd|o
        LinI = appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Row
        LinF = LinI + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Rows.Count - 1
        ColI = appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Column
        ColF = ColI + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Columns.Count - 1
        LinFt = appHostApp.ActiveWindow.ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell).Row + 1    '00 'appHostApp.ActiveWindow.ActiveSheet.UsedRange.Rows.Count gera o mesmo resultado.
        ColFt = appHostApp.ActiveWindow.ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell).Column + 1    '00 Seguran|fffd|a de 100 provoca demora desnecess|fffd|ria. Acreditar em xlCellTypeLastCell mais j|fffd| suficiente.
        If LinFt > appHostApp.ActiveWindow.ActiveSheet.Rows.Count Then LinFt = appHostApp.ActiveWindow.ActiveSheet.Rows.Count    '65536
        If ColFt > appHostApp.ActiveWindow.ActiveSheet.Columns.Count - 1 Then ColFt = appHostApp.ActiveWindow.ActiveSheet.Columns.Count - 1    '250
        If LinFt > LinF Then
            If bDelAtEnd Then
                For j1 = LinF + 1 To LinFt
                    DelRow(j1) = 1: bDelRow = True
                Next
            Else
                With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(LinF + 1, 1), appHostApp.ActiveWindow.ActiveSheet.Cells(LinFt, 1)).EntireRow
                    If bHasVCmOutPrtA Then    'Se tiver coment|fffd|rios visiveis ancorado em qualquer c|fffd|lula fora da |fffd|rea de impress|fffd|o, n|fffd|o deletar linhas apenas limpar
                        .ClearContents
                        '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                    Else
                        .Delete
                    End If
                End With
            End If
        End If
        If ColFt > ColF Then
            If bDelAtEnd Then
                For j1 = ColF + 1 To ColFt
                    DelCol(j1) = 1: bDelCol = True
                Next
            Else
                With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(1, ColF + 1), appHostApp.ActiveWindow.ActiveSheet.Cells(1, ColFt)).EntireColumn
                    If bHasVCmOutPrtA Then    'Se tiver coment|fffd|rios visiveis ancorado em qualquer c|fffd|lula fora da |fffd|rea de impress|fffd|o, n|fffd|o deletar colunas apenas limpar
                        .ClearContents
                        '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                    Else
                        .Delete
                    End If
                End With
            End If
        End If
        If LinI > 1 Then
            If bDelAtEnd Then
                For j1 = 1 To LinI - 1
                    DelRow(j1) = 1: bDelRow = True
                Next
            Else
                With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1), appHostApp.ActiveWindow.ActiveSheet.Cells(LinI - 1, 1)).EntireRow
                    If bHasVCmOutPrtA Then
                        .ClearContents
                        '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                        .Hidden = True
                    Else
                        .Delete
                    End If
                End With
            End If
        End If
        If ColI > 1 Then
            If bDelAtEnd Then
                For j1 = 1 To ColI - 1
                    DelCol(j1) = 1: bDelCol = True
                Next
            Else
                With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1), appHostApp.ActiveWindow.ActiveSheet.Cells(1, ColI - 1)).EntireColumn
                    If bHasVCmOutPrtA Then
                        .ClearContents
                        '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                        .Hidden = True
                    Else
                        .Delete
                    End If
                End With
            End If
        End If

        'Excluindo colunas e linhas ocultas em lote para maior rapidez. S|fffd| limpa, se houver coment|fffd|rios vis|fffd|veis ancorados fora da |fffd|rea de impress|fffd|o
        Dim iAc As Long
        j = appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Rows.Count
        iAc = 0
        For i = j To 1 Step -1
            If i - 1 > 0 Then
                iAc = iAc - 1 * (appHostApp.ActiveWindow.ActiveSheet.Cells(i, 1).Height = 0)
                If iAc > 0 And (appHostApp.ActiveWindow.ActiveSheet.Cells(i - 1, 1).Height <> 0 Or i - 1 = 1) Then
                    If bDelAtEnd Then
                        For j1 = i To i + iAc - 1
                            DelRow(j1) = 1: bDelRow = True
                        Next
                    Else
                        With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(i, 1), appHostApp.ActiveWindow.ActiveSheet.Cells(i + iAc - 1, 1)).EntireRow
                            If bHasVCmOutPrtA Then
                                .ClearContents
                                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                            Else
                                .Delete
                            End If
                        End With
                    End If
                    iAc = 0
                End If
            Else
                If appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1).Height = 0 Then
                    If bDelAtEnd Then
                        For j1 = 1 To 1
                            DelRow(j1) = 1: bDelRow = True
                        Next
                    Else
                        With appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1).EntireRow
                            If bHasVCmOutPrtA Then
                                .ClearContents
                                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                            Else
                                .Delete
                            End If
                        End With
                    End If
                End If
            End If
            appHostApp.StatusBar = IIf(IsPortg, "Limpando linhas: ", "Cleaning rows: ") & Int((j - i) / j * 100) & "%"
        Next
        j = appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Columns.Count
        iAc = 0
        For i = j To 1 Step -1
            If i - 1 > 0 Then
                iAc = iAc - 1 * (appHostApp.ActiveWindow.ActiveSheet.Cells(1, i).Width = 0)
                If iAc > 0 And (appHostApp.ActiveWindow.ActiveSheet.Cells(1, i - 1).Width <> 0 Or i - 1 = 1) Then
                    If bDelAtEnd Then
                        For j1 = i To i + iAc - 1
                            DelCol(j1) = 1: bDelCol = True
                        Next
                    Else
                        With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(1, i), appHostApp.ActiveWindow.ActiveSheet.Cells(1, i + iAc - 1)).EntireColumn
                            If bHasVCmOutPrtA Then
                                .ClearContents
                                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                            Else
                                .Delete
                            End If
                        End With
                    End If
                    iAc = 0
                End If
            Else
                If appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1).Width = 0 Then
                    If bDelAtEnd Then
                        For j1 = 1 To i
                            DelCol(j1) = 1: bDelCol = True
                        Next
                    Else
                        With appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1).EntireColumn
                            If bHasVCmOutPrtA Then
                                .ClearContents
                                '.ClearFormats    'Parece um bug pois |fffd| extremamente lento e torno o saveas quase infinito
                            Else
                                .Delete
                            End If
                        End With
                    End If
                End If
            End If
            appHostApp.StatusBar = IIf(IsPortg, "Limpando colunas: ", "Cleaning columns: ") & Int((j - i) / j * 100) & "%"
        Next

        If bDelAtEnd And (bDelRow Or bDelCol) Then
            appHostApp.ActiveWindow.ActiveSheet.Cells.ClearOutline
            If bDelRow Then appHostApp.ActiveWindow.ActiveSheet.UsedRange.EntireRow.Hidden = False
            If bDelCol Then appHostApp.ActiveWindow.ActiveSheet.UsedRange.EntireColumn.Hidden = False

            For j1 = 1 To 1 - 1 * bHasVCmOutPrtA    'No caso de bHasVCmOutPrtA s|fffd|o duas passadas na primeira limpa e na segunda oculta.
                If bDelRow Then
                    j = UBound(DelRow())
                    iAc = 0
                    For i = j To 1 Step -1
                        If i - 1 > 0 Then
                            iAc = iAc - 1 * (DelRow(i) = 1)
                            If iAc > 0 And (DelRow(i - 1) <> 1 Or i - 1 = 1) Then
                                With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(i, 1), appHostApp.ActiveWindow.ActiveSheet.Cells(i + iAc - 1, 1)).EntireRow
                                    If bHasVCmOutPrtA Then
                                        If j1 = 1 Then .Clear Else .Hidden = True
                                    Else
                                        .Delete
                                    End If
                                End With
                                iAc = 0
                            End If
                        Else
                            If DelRow(i) = 1 Then
                                With appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1).EntireRow
                                    If bHasVCmOutPrtA Then
                                        If j1 = 1 Then .Clear Else .Hidden = True
                                    Else
                                        .Delete
                                    End If
                                End With
                            End If
                        End If
                        appHostApp.StatusBar = IIf(IsPortg, "Limpando linhas: ", "Cleaning rows: ") & Int((j - i) / j * 100) & "%"
                    Next
                End If

                If bDelCol Then
                    j = UBound(DelCol())
                    iAc = 0
                    For i = j To 1 Step -1
                        If i - 1 > 0 Then
                            iAc = iAc - 1 * (DelCol(i) = 1)
                            If iAc > 0 And (DelCol(i - 1) <> 1 Or i - 1 = 1) Then
                                With appHostApp.ActiveWindow.ActiveSheet.Range(appHostApp.ActiveWindow.ActiveSheet.Cells(1, i), appHostApp.ActiveWindow.ActiveSheet.Cells(1, i + iAc - 1)).EntireColumn
                                    If bHasVCmOutPrtA Then
                                        If j1 = 1 Then .Clear Else .Hidden = True
                                    Else
                                        .Delete
                                    End If
                                End With
                                iAc = 0
                            End If
                        Else
                            If DelCol(i) = 1 Then
                                With appHostApp.ActiveWindow.ActiveSheet.Cells(1, 1).EntireColumn
                                    If bHasVCmOutPrtA Then
                                        If j1 = 1 Then .Clear Else .Hidden = True
                                    Else
                                        .Delete
                                    End If
                                End With
                            End If
                        End If
                        appHostApp.StatusBar = IIf(IsPortg, "Limpando colunas: ", "Cleaning columns: ") & Int((j - i) / j * 100) & "%"
                    Next
                End If
            Next j1
        End If

        appHostApp.StatusBar = False
        appHostApp.Calculation = AppCalc

    ElseIf TypeName(appHostApp.ActiveWindow.ActiveSheet) = "Chart" Then         'Se Chart, fazer o mesmo isolado aqui, pois h|fffd| mais diferen|fffd|as e semelhan|fffd|as do que igualdades
        WbSaved = appHostApp.ActiveWorkbook.Saved: bHadChg = True    'A priori, se houver chart considera que vai haver altera|fffd||fffd|es, pois s|fffd|o muitos detalhes.
        appHostApp.ActiveChart.Deselect
        AppCalc = appHostApp.Calculation
        appHostApp.Calculation = xlManual
        appHostApp.ScreenUpdating = False
        appHostApp.EnableEvents = False

        appHostApp.ActiveChart.Copy

        Set NewWkb = appHostApp.ActiveWorkbook
        If bShHasPass Then
            On Error Resume Next
            appHostApp.ActiveChart.Unprotect sShPass
            If Err.Number <> 0 Then
                NewWkb.Close False
                appHostApp.Calculation = AppCalc
                appHostApp.EnableEvents = True
                appHostApp.ScreenUpdating = True
                ActWkb.Saved = WbSaved
                RetError = 2
                Exit Sub
            End If
        End If

        On Error Resume Next    'Isso ignora qualquer problema. Quando quiser testar o ideal |fffd| quebrar esta linha e usar        On Error GoTo 0

        'Quebrar links de gr|fffd|ficos convertendo em figura e excluir se n|fffd|o imprim|fffd|veis
        appHostApp.ActiveChart.Axes(xlCategory).TickLabels.AutoScaleFont = False
        appHostApp.ActiveChart.Axes(xlValue).TickLabels.AutoScaleFont = False
        appHostApp.ActiveChart.Axes(xlCategory).TickLabels.NumberFormatLinked = False
        appHostApp.ActiveChart.Axes(xlValue).TickLabels.NumberFormatLinked = False

        'Obter algumas propriedades do original que podem ter sido alterada na copia da planilha normalmente quando h|fffd| links externos
        sNumbFormC = ActWkb.ActiveChart.Axes(xlCategory).TickLabels.NumberFormat
        sNumbFormV = ActWkb.ActiveChart.Axes(xlValue).TickLabels.NumberFormat

        appHostApp.ActiveChart.Axes(xlCategory).TickLabels.NumberFormat = sNumbFormC
        If appHostApp.ActiveChart.Axes(xlCategory).CategoryType = xlAutomaticScale _
           And InStr(1, sNumbFormC, "/") > 0 Then
            appHostApp.ActiveChart.Axes(xlCategory).CategoryType = xlTimeScale
            sNumbFormC = IIf(appHostApp.International(xl4DigitYears), "yyyy", "yy")
            Select Case appHostApp.International(xlDateOrder)
            Case 0
                sNumbFormC = IIf(appHostApp.International(xlMonthLeadingZero), "mm", "m") & "/" & IIf(appHostApp.International(xlDayLeadingZero), "dd", "d") & "/" & sNumbFormC
            Case 1
                sNumbFormC = IIf(appHostApp.International(xlDayLeadingZero), "dd", "d") & "/" & IIf(appHostApp.International(xlMonthLeadingZero), "mm", "m") & "/" & sNumbFormC
            Case 2
                sNumbFormC = sNumbFormC & "/" & IIf(appHostApp.International(xlMonthLeadingZero), "mm", "m") & "/" & IIf(appHostApp.International(xlDayLeadingZero), "dd", "d")
            End Select
            appHostApp.ActiveChart.Axes(xlCategory).TickLabels.NumberFormat = sNumbFormC
        End If

        appHostApp.ActiveChart.Axes(xlValue).TickLabels.NumberFormat = sNumbFormV

        'Quebrar links copiando e colando como figura
        If dHostAppVer <= 9 Then   'Excel 2002 em diante tem o m|fffd|todo BreakLink que parece mais exato, evitanto captar objetos sobre o gr|fffd|fico ao copiar e colar a figura. No PrintThruEmail n|fffd|o confiei s|fffd| nele, pois era novo.
            appHostApp.ActiveChart.CopyPicture Appearance:=xlScreen, Size:=xlScreen, Format:=xlPicture
            Set oPic = appHostApp.ActiveChart.Pictures.Paste
            appHostApp.ActiveChart.ChartArea.Clear
        End If

        'Excluindo objetos n|fffd|o imprim|fffd|veis e quebrar links
        For Each Fig In appHostApp.ActiveChart.Shapes
            If Fig.Type <> msoComment And Fig.Type <> msoChart Then
                If Not Fig.Visible Then
                    Fig.Delete
                Else
                    'bShapeOutPrnt = Fig.Top + Fig.Height < appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top _
                     Or Fig.Left + Fig.Width < appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left _
                     Or Fig.Left > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Left + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Width _
                     Or Fig.Top > appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Top + appHostApp.ActiveWindow.ActiveSheet.Range(sPrintArea).Height 'Chart Sheet n|fffd|o tem defini|fffd||fffd|o de |fffd|rea de impress|fffd|o.
                    If bShapeOutPrnt Then
                        Fig.Delete
                    Else
                        If Fig.ControlFormat.PrintObject Then
                            If Fig.Type <> msoOLEControlObject Then
                                Fig.OnAction = ""
                                If Fig.Type <> msoFormControl And Fig.Type <> msoGroup And Fig.Type <> msoLine Then Fig.DrawingObject.Formula = ""  'No 2007 figura de gr|fffd|fico n|fffd|o aceita f|fffd|rmula e d|fffd| erro.
                            End If
                            Fig.Placement = xlMove
                        Else
                            Fig.Delete
                        End If
                    End If
                End If
            End If
        Next
        appHostApp.ActiveChart.Deselect

        'Quebrar hyperlinks
        For Each h In appHostApp.ActiveChart.Hyperlinks
            h.Delete  'h.Address = "" 'Como n|fffd|o existe uma ref. fixa em Chart como A1 em Worksheet, |fffd| melhor deletar.
            'h.SubAddress = appHostApp.ActiveChart.Name    '& "!A1"
        Next

        'Excluindo nomes (Preciso verificar links aqui tamb|fffd|m xxxx)
        For Each Nome In appHostApp.ActiveWorkbook.Names
            If VBA.Strings.Right(Nome.Name, 10) = "Print_Area" _
               Or VBA.Strings.Right(Nome.Name, 12) = "Print_Titles" _
               Then Else Nome.Delete
        Next

        'Quebrar links externos restantes (O m|fffd|todo BreakLink s|fffd| funciona Excel 2002 em diante)
        arrLinks = appHostApp.ActiveWorkbook.LinkSources(Type:=xlLinkTypeOLELinks)
        If Not IsEmpty(arrLinks) Then
            For Each sLnk In arrLinks
                If dHostAppVer > 9 Then appHostApp.ActiveWorkbook.BreakLink _
                Name:=sLnk, Type:=xlLinkTypeOLELinks Else bHasLnkYet = True
            Next
        End If
        arrLinks = appHostApp.ActiveWorkbook.LinkSources(Type:=xlLinkTypeExcelLinks)
        If Not IsEmpty(arrLinks) Then
            For Each sLnk In arrLinks
                If dHostAppVer > 9 Then appHostApp.ActiveWorkbook.BreakLink _
                Name:=sLnk, Type:=xlLinkTypeExcelLinks Else bHasLnkYet = True
            Next
        End If

        appHostApp.Calculation = AppCalc
    End If


    'Evitar alerta de macro
    If appHostApp.ActiveWindow.ActiveSheet.Type <> xlWorksheet And TypeName(appHostApp.ActiveWindow.ActiveSheet) <> "Chart" Then
        'Convertendo macrosheet para sheet
        Call MacroSheetToSheet: bHadChg = True
    End If
    HasVBAProject = False
    If Left(Right(ActWkb.Name, 4), 1) = "." Then  'dHostAppVer < 11 + 1 Then    'A priori, s|fffd| aceita a mesma extens|fffd|o para evitar distor|fffd||fffd|o. E, ao salvar em xlsx no 12 em diante, o c|fffd|digo VBA |fffd| removido pelo pr|fffd|prio Excel
        'Limpando VBAProject
        Dim ShCN As String
        Dim CofL As Long
        On Error Resume Next    'Se a op|fffd||fffd|o de acesso ao VBA por c|fffd|digo n|fffd|o estiver assinalada causa erro
        If appHostApp.ActiveWindow.ActiveSheet.Parent.VBProject.Protection = 0 Then
            If Err.Number = 0 Then
                ShCN = appHostApp.ActiveWindow.ActiveSheet.CodeName
                CofL = appHostApp.ActiveWindow.ActiveSheet.Parent.VBProject.VBComponents(ShCN).CodeModule.CountOfLines
                If CofL > 1 Then
                    HasVBAProject = True: bHadChg = True
                    appHostApp.ActiveWindow.ActiveSheet.Parent.VBProject.VBComponents(ShCN).CodeModule.DeleteLines 1, CofL
                End If
            Else
                Static bOnlyOne As Boolean
                Msg1 = IIf(IsPortg, "Imposs|fffd|vel Verificar e Limpar C|fffd|digo VBA!", "Unable Verify and Clean VBA Code!") & vbCrLf & vbCrLf & IIf(IsPortg, "Erro: ", "Error: ") & Err.Number & " - " & Err.Description & vbCrLf & IIf(IsPortg, "Obs: Este erro n|fffd|o |fffd| fatal, tem apenas o inconveniente de n|fffd|o remover o c|fffd|digo VBA, se houver, por tr|fffd|s do objeto Planilha que |fffd| normalmente desnecess|fffd|rio. S|fffd| voc|fffd| pode alterar configura|fffd||fffd|o de seguran|fffd|a no seu Excel, mas, mesmo que voc|fffd| n|fffd|o altere, este alerta n|fffd|o ser|fffd| mais exibido nesta execu|fffd||fffd|o.", "Note: This error is not fatal, it has only the drawback of not removing VBA code, if any, behind the Sheet object that is usually unnecessary. Only you can change security setting on your Excel, but, even if you do not change, this alert will no longer appear in this execution.")
                If Not bOnlyOne Then MyMsgBox Msg1, 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
                bOnlyOne = True
            End If
        End If
    Else
        If LCase(Right(ActWkb.Name, 5)) <> ".xlsx" Then bHadChg = True    'Vai ser necess|fffd|rio salvar como xlsx removendo c|fffd|digo se houver.
    End If

    If TypeName(appHostApp.ActiveWindow.ActiveSheet) <> "Chart" Then appHostApp.GoTo appHostApp.ActiveWindow.ActiveSheet.Range("A1"), True
    If bPortblSheetProtect And Not bSavePortblXLSasWebPg Then appHostApp.ActiveWindow.ActiveSheet.Protect sPortblSheetPasswrd    'Se houver senha n|fffd|o salva em webpage.
    If IIf(bSavePortblXLSasWebPg Or Not bPortblSheetProtect, "", sPortblSheetPasswrd) <> sShPass Or ActWkb.HasPassword Or (bShHasPass And sShPass = "") Then bHadChg = True

    If bHadChg = False Then NewWkb.Close False: ActWkb.Activate: ActWkb.Saved = True    'Se para ser port|fffd|vel n|fffd|o necessitou altera|fffd||fffd|o ent|fffd|o enviar o pr|fffd|prio.
    EnviarEmailTudo

    If appHostApp.ActiveWorkbook.Name <> ActWkb.Name Then appHostApp.ActiveWindow.Close False    'Agora com a op|fffd||fffd|o bSendMailByNewExcelInst o WbTempToSend pode ter sido fechado para ser aberto em outra inst|fffd|ncia do Excel.
    ActWkb.Activate
    If ShScrArea <> "" Then appHostApp.ActiveWindow.ActiveSheet.ScrollArea = ShScrArea
    ActWkbSel.Select
    appHostApp.EnableEvents = True
    ActWkb.Saved = WbSaved
    appHostApp.ScreenUpdating = True
End Sub

Sub StoreAutoFilter()
    If bShHasPass Then appHostApp.ActiveWindow.ActiveSheet.Unprotect sShPass
    With appHostApp.ActiveWindow.ActiveSheet.AutoFilter
        sFiltRng = .Range.Address
        With .Filters
            ReDim filtArray(1 To .Count, 1 To 3)
            For i = 1 To .Count
                With .Item(i)
                    If .On Then
                        filtArray(i, 1) = .Criteria1
                        If .Operator Then
                            filtArray(i, 2) = .Operator
                            filtArray(i, 3) = .Criteria2
                        End If
                    End If
                End With
            Next
        End With
    End With
    appHostApp.ActiveWindow.ActiveSheet.AutoFilterMode = False
End Sub

Sub RestoreAutoFilter()
    appHostApp.ActiveWindow.ActiveSheet.AutoFilterMode = False
    For i = 1 To UBound(filtArray(), 1)
        If Not IsEmpty(filtArray(i, 1)) Then
            If filtArray(i, 2) Then
                appHostApp.ActiveWindow.ActiveSheet.Range(sFiltRng).AutoFilter field:=i, _
                                                                               Criteria1:=filtArray(i, 1), _
                                                                               Operator:=filtArray(i, 2), _
                                                                               Criteria2:=filtArray(i, 3)
            Else
                appHostApp.ActiveWindow.ActiveSheet.Range(sFiltRng).AutoFilter field:=i, _
                                                                               Criteria1:=filtArray(i, 1)
            End If
        End If
    Next
    If bShHasPass Then appHostApp.ActiveWindow.ActiveSheet.Protect sShPass
End Sub

Sub MacroSheetToSheet()
'Se fosse MacroSheet daria alerta de virus
    Dim NomeSh As String
    Dim NomeNewSh As String
    NomeSh = appHostApp.ActiveWindow.ActiveSheet.Name
    Dim Cfg(6)
    With appHostApp.ActiveWindow
        Cfg(1) = .DisplayGridlines
        Cfg(2) = .DisplayHeadings
        Cfg(3) = .DisplayOutline
        Cfg(4) = .DisplayZeros
        Cfg(5) = .DisplayWorkbookTabs
    End With
    appHostApp.ActiveWindow.ActiveSheet.Cells.Select
    appHostApp.Selection.Copy
    appHostApp.ActiveWorkbook.Sheets.Add
    NomeNewSh = appHostApp.ActiveWindow.ActiveSheet.Name
    appHostApp.ActiveWindow.ActiveSheet.Paste
    appHostApp.CutCopyMode = False
    With appHostApp.ActiveWindow
        .DisplayGridlines = Cfg(1)
        .DisplayHeadings = Cfg(2)
        .DisplayOutline = Cfg(3)
        .DisplayZeros = Cfg(4)
        .DisplayWorkbookTabs = Cfg(5)
    End With
    With appHostApp.ActiveWindow.ActiveSheet.PageSetup
        .PrintTitleRows = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.PrintTitleRows
        .PrintTitleColumns = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.PrintTitleColumns
    End With
    appHostApp.ActiveWindow.ActiveSheet.PageSetup.PrintArea = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.PrintArea
    With appHostApp.ActiveWindow.ActiveSheet.PageSetup
        .LeftHeader = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.LeftHeader
        .CenterHeader = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.CenterHeader
        .RightHeader = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.RightHeader
        .LeftFooter = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.LeftFooter
        .CenterFooter = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.CenterFooter
        .RightFooter = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.RightFooter
        .LeftMargin = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.LeftMargin
        .RightMargin = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.RightMargin
        .TopMargin = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.TopMargin
        .BottomMargin = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.BottomMargin
        .HeaderMargin = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.HeaderMargin
        .FooterMargin = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.FooterMargin
        .PrintHeadings = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.PrintHeadings
        .PrintGridlines = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.PrintGridlines
        .PrintComments = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.PrintComments
        .CenterHorizontally = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.CenterHorizontally
        .CenterVertically = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.CenterVertically
        .Orientation = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.Orientation
        .Draft = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.Draft
        .PaperSize = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.PaperSize
        .FirstPageNumber = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.FirstPageNumber
        .Order = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.Order
        .BlackAndWhite = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.BlackAndWhite
        .Zoom = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.Zoom
        .FitToPagesWide = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.FitToPagesWide
        .FitToPagesTall = appHostApp.ActiveWorkbook.Sheets(NomeSh).PageSetup.FitToPagesTall
    End With

    'Ajustando objetos
    If appHostApp.ActiveWindow.ActiveSheet.Shapes.Count > 0 Then appHostApp.ActiveWindow.ActiveSheet.DrawingObjects.Delete

    appHostApp.ActiveWorkbook.Sheets(NomeSh).Select
    If appHostApp.ActiveWindow.ActiveSheet.Shapes.Count > 0 Then
        With appHostApp.ActiveWindow.ActiveSheet.Shapes.AddShape(msoShapeRectangle, 0, 0, 1, 1)
            .Fill.Visible = msoFalse
            .Fill.Transparency = 0#
            .Line.Visible = msoFalse
        End With
        appHostApp.ActiveWindow.ActiveSheet.DrawingObjects.Copy

        appHostApp.ActiveWorkbook.Sheets(NomeNewSh).Select
        appHostApp.ActiveWindow.ActiveSheet.Paste
        appHostApp.ActiveWindow.ActiveSheet.Range("A1").Select
        appHostApp.ActiveWorkbook.Sheets(NomeSh).Select
    End If
    appHostApp.DisplayAlerts = False
    appHostApp.ActiveWindow.SelectedSheets.Delete
    appHostApp.DisplayAlerts = True
End Sub

Function fPaperSize(vSet As Boolean) As Boolean
    Dim vReStart As Boolean
    Dim XlIndx As Integer
    Dim i As Integer
    Dim pName As String
    Dim pWidth As Double
    Dim pHeight As Double

    If P(1, 0) = Empty Then
        P(1, 0) = 1: P(1, 1) = 215.9: P(1, 2) = 279.4: P(1, 3) = "Letter (8-1/2 in. x 11 in.)": P(1, 4) = "Carta (215,9 mm x 279,4 mm)"
        P(2, 0) = 2: P(2, 1) = 216: P(2, 2) = 279: P(2, 3) = "Letter Small (8-1/2 in. x 11 in.)": P(2, 4) = "Carta pequena (216 mm x 279 mm)"
        P(3, 0) = 3: P(3, 1) = 279: P(3, 2) = 432: P(3, 3) = "Tabloid (11 in. x 17 in.)": P(3, 4) = "Tabl|fffd|ide (279 mm x 432 mm)"
        P(4, 0) = 4: P(4, 1) = 432: P(4, 2) = 279: P(4, 3) = "Ledger (17 in. x 11 in.)": P(4, 4) = "Ledger (432 mm x 279 mm)"
        P(5, 0) = 5: P(5, 1) = 215.9: P(5, 2) = 355.6: P(5, 3) = "Legal (8-1/2 in. x 14 in.)": P(5, 4) = "Of|fffd|cio (215,9 mm x 355,6 mm)"
        P(6, 0) = 6: P(6, 1) = 140: P(6, 2) = 216: P(6, 3) = "Statement (5-1/2 in. x 8-1/2 in.)": P(6, 4) = "Declara|fffd||fffd|o (140 mm x 216 mm)"
        P(7, 0) = 7: P(7, 1) = 190.5: P(7, 2) = 266.7: P(7, 3) = "Executive (7-1/2 in. x 10-1/2 in.)": P(7, 4) = "Executivo (190,5 mm x 266,7 mm)"
        P(8, 0) = 8: P(8, 1) = 297: P(8, 2) = 420: P(8, 3) = "A3 (297 mm x 420 mm)": P(8, 4) = "A3 (297 mm x 420 mm)"
        P(9, 0) = 9: P(9, 1) = 210: P(9, 2) = 297: P(9, 3) = "A4 (210 mm x 297 mm)": P(9, 4) = "A4 (210 mm x 297 mm)"
        P(10, 0) = 10: P(10, 1) = 210: P(10, 2) = 297: P(10, 3) = "A4 Small (210 mm x 297 mm)": P(10, 4) = "A4 pequeno (210 mm x 297 mm)"
        P(11, 0) = 11: P(11, 1) = 148: P(11, 2) = 210: P(11, 3) = "A5 (148 mm x 210 mm)": P(11, 4) = "A5 (148 mm x 210 mm)"
        P(12, 0) = 12: P(12, 1) = 250: P(12, 2) = 354: P(12, 3) = "B4 (250 mm x 354 mm)": P(12, 4) = "B4 (250 mm x 354 mm)"
        P(13, 0) = 13: P(13, 1) = 148: P(13, 2) = 210: P(13, 3) = "A5 (148 mm x 210 mm)": P(13, 4) = "A5 (148 mm x 210 mm)"
        P(14, 0) = 14: P(14, 1) = 216: P(14, 2) = 330: P(14, 3) = "Folio (8-1/2 in. x 13 in.)": P(14, 4) = "F|fffd|lio (216 mm x 330 mm)"
        P(15, 0) = 15: P(15, 1) = 215: P(15, 2) = 275: P(15, 3) = "Quarto (215 mm x 275 mm)": P(15, 4) = "Quarto (215 mm x 275 mm)"
        P(16, 0) = 16: P(16, 1) = 254: P(16, 2) = 355.6: P(16, 3) = "10 in. x 14 in. ": P(16, 4) = "10 x 14 in (254 mm x 355,6 mm)"
        P(17, 0) = 17: P(17, 1) = 279: P(17, 2) = 432: P(17, 3) = "11 in. x 17 in. ": P(17, 4) = "11 x 17 in (279 mm x 432 mm)"
        P(18, 0) = 18: P(18, 1) = 261: P(18, 2) = 279: P(18, 3) = "Note (8-1/2 in. x 11 in.)": P(18, 4) = "Nota (261 mm x 279 mm)"
        P(19, 0) = 19: P(19, 1) = 98: P(19, 2) = 225: P(19, 3) = "Envelope #9 (3-7/8 in. x 8-7/8 in.)": P(19, 4) = "Envelope #9 (98 mm x 225 mm)"
        P(20, 0) = 20: P(20, 1) = 104.8: P(20, 2) = 241: P(20, 3) = "Envelope #10 (4-1/8 in. x 9-1/2 in.)": P(20, 4) = "Envelope #10 (104,8 mm x 241 mm)"
        P(21, 0) = 21: P(21, 1) = 114: P(21, 2) = 263: P(21, 3) = "Envelope #11 (4-1/2 in. x 10-3/8 in.)": P(21, 4) = "Envelope #11 (114 mm x 263 mm)"
        P(22, 0) = 22: P(22, 1) = 124: P(22, 2) = 279: P(22, 3) = "Envelope #12 (4-1/2 in. x 11 in.)": P(22, 4) = "Envelope #12 (124 mm x 279 mm)"
        P(23, 0) = 23: P(23, 1) = 127: P(23, 2) = 292: P(23, 3) = "Envelope #14 (5 in. x 11-1/2 in.)": P(23, 4) = "Envelope #14 (127 mm x 292 mm)"
        P(24, 0) = 27: P(24, 1) = 110: P(24, 2) = 220: P(24, 3) = "Envelope DL (110 mm x 220 mm)": P(24, 4) = "Envelope DL (110 mm x 220 mm)"
        P(25, 0) = 28: P(25, 1) = 162: P(25, 2) = 229: P(25, 3) = "Envelope C5 (162 mm x 229 mm)": P(25, 4) = "Envelope C5 (162 mm x 229 mm)"
        P(26, 0) = 29: P(26, 1) = 324: P(26, 2) = 458: P(26, 3) = "Envelope C3 (324 mm x 458 mm)": P(26, 4) = "Envelope C3 (324 mm x 458 mm)"
        P(27, 0) = 30: P(27, 1) = 229: P(27, 2) = 324: P(27, 3) = "Envelope C4 (229 mm x 324 mm)": P(27, 4) = "Envelope C4 (229 mm x 324 mm)"
        P(28, 0) = 31: P(28, 1) = 114: P(28, 2) = 162: P(28, 3) = "Envelope C6 (114 mm x 162 mm)": P(28, 4) = "Envelope C6 (114 mm x 162 mm)"
        P(29, 0) = 32: P(29, 1) = 114: P(29, 2) = 229: P(29, 3) = "Envelope C65 (114 mm x 229 mm)": P(29, 4) = "Envelope C65 (114 mm x 229 mm)"
        P(30, 0) = 33: P(30, 1) = 250: P(30, 2) = 353: P(30, 3) = "Envelope B4 (250 mm x 353 mm)": P(30, 4) = "Envelope B4 (250 mm x 353 mm)"
        P(31, 0) = 34: P(31, 1) = 176: P(31, 2) = 250: P(31, 3) = "Envelope B5 (176 mm x 250 mm)": P(31, 4) = "Envelope B5 (176 mm x 250 mm)"
        P(32, 0) = 35: P(32, 1) = 176: P(32, 2) = 125: P(32, 3) = "Envelope B6 (176 mm x 125 mm)": P(32, 4) = "Envelope B6 (176 mm x 125 mm)"
        P(33, 0) = 36: P(33, 1) = 110: P(33, 2) = 230: P(33, 3) = "Envelope (110 mm x 230 mm)": P(33, 4) = "Envelope (110 mm x 230 mm)"
        P(34, 0) = 37: P(34, 1) = 98.4: P(34, 2) = 190.5: P(34, 3) = "Envelope Monarch (3-7/8 in. x 7-1/2 in.)": P(34, 4) = "Envelope Monarch (98,4 mm x 190,5 mm)"
        P(35, 0) = 38: P(35, 1) = 92.1: P(35, 2) = 165: P(35, 3) = "Envelope (3-5/8 in. x 6-1/2 in.)": P(35, 4) = "Envelope 3-5/8 x 6-1/2 (92,1 mm x 165 mm)"
        P(36, 0) = 39: P(36, 1) = 377.8: P(36, 2) = 279.4: P(36, 3) = "U.S. Standard Fanfold (14-7/8 in. x 11 in.)": P(36, 4) = "Formul|fffd|rio cont|fffd|nuo padr|fffd|o americano (377,8 mm x 279,4 mm)"
        P(37, 0) = 40: P(37, 1) = 215.9: P(37, 2) = 330.2: P(37, 3) = "German Legal Fanfold (8-1/2 in. x 13 in.)": P(37, 4) = "Formul|fffd|rio cont|fffd|nuo of|fffd|cio alem|fffd|o (215,9 mm x 330,2 mm)"
        P(38, 0) = 41: P(38, 1) = 215.9: P(38, 2) = 330.2: P(38, 3) = "German Legal Fanfold (8-1/2 in. x 13 in.)": P(38, 4) = "Formul|fffd|rio cont|fffd|nuo of|fffd|cio alem|fffd|o (215,9 mm x 330,2 mm)"
        P(39, 0) = 256: P(39, 1) = 215.9: P(39, 2) = 279.4: P(39, 3) = "User-defined ": P(39, 4) = "Definido pelo usu|fffd|rio "
        P(40, 0) = 263: P(40, 1) = 216: P(40, 2) = 305: P(40, 3) = "Fanfold (216 mm x 305 mm)": P(40, 4) = "Fanfold (216 mm x 305 mm)"
        P(41, 0) = 264: P(41, 1) = 203: P(41, 2) = 152: P(41, 3) = "8 x 6 in (203 mm x 152 mm)": P(41, 4) = "8 x 6 in (203 mm x 152 mm)"
        P(42, 0) = 265: P(42, 1) = 210: P(42, 2) = 305: P(42, 3) = "Fanfold (210 mm x 305 mm)": P(42, 4) = "Fanfold (210 mm x 305 mm)"
        P(43, 0) = 267: P(43, 1) = 216: P(43, 2) = 330: P(43, 3) = "Fanfold (216 mm x 330 mm)": P(43, 4) = "Fanfold (216 mm x 330 mm)"
        P(44, 0) = 1000: P(44, 1) = 215.9: P(44, 2) = 279.4: P(44, 3) = "Other": P(44, 4) = "Outro"
    End If
    fPaperSize = False
    vReStart = False
ReStart:
    If vSet Then
        Dim bDlgPgSetup As Boolean
        If dHostAppVer < 11 + 1 Then
            bDlgPgSetup = appHostApp.Dialogs(xlDialogPageSetup).Show    'Bug em 2007
        Else
            bDlgPgSetup = appHostApp.ExecuteExcel4Macro("PAGE.SETUP?()")
        End If
        If bDlgPgSetup = False Then
            If vReStart Or vSet Then Exit Function
        End If
    End If

    On Error Resume Next
    XlIndx = appHostApp.ActiveWindow.ActiveSheet.PageSetup.PaperSize
    If Err.Number <> 0 Then
        If IsPortg Then
            Msg1 = "H|fffd| algo de errado em seu sistema. Talvez n|fffd|o haja impressora configurada."
            Msg2 = sAddInNameByApp & " - Tamanho do Papel - Falha!"
        Else
            Msg1 = "There is something wrong in your system. Maybe there isn't configured printer."
            Msg2 = sAddInNameByApp & " - Paper Size - Fail!"
        End If
        MyMsgBox Msg1, 1, Msg2
        Exit Function
    End If
    On Error GoTo 0

    Pindx = 44
    For i = 0 To 44
        If P(i, 0) = XlIndx Then
            Pindx = i
            Exit For
        End If
    Next
    If Pindx = 44 Then XlIndx = 1000
    If XlIndx = 256 Or XlIndx = 1000 Then
        FormPaperSize.Show 1
        If PressBot = 2 Then Exit Function
    End If
    pName = P(Pindx, IIf(IsPortg, 4, 3))
    pWidth = P(Pindx, 1) / 25.4
    pHeight = P(Pindx, 2) / 25.4

    On Error Resume Next
    If XlIndx <> 256 And XlIndx <> 1000 Then
        If appHostApp.ActiveWindow.ActiveSheet.PageSetup.PaperSize <> XlIndx Then appHostApp.ActiveWindow.ActiveSheet.PageSetup.PaperSize = XlIndx    'Fazer igual o que j|fffd| |fffd| provoca a recalcula|fffd||fffd|o geral que pode ser longa e sempre desnecess|fffd|ria. Bug antigo detectado em 26/07/2019.
        If Err.Number <> 0 Then
            If IsPortg Then
                Msg1 = "O papel com tamanho ''" & pName & "'' n|fffd|o |fffd| suportado pela impressora " & appHostApp.ActivePrinter & Chr(10) & Chr(10) _
                     & "OK  -  Configurar outro PAPEL;" & Chr(10) & Chr(10) _
                     & "Cancelar - Configurar outra IMPRESSORA."
                Msg2 = sAddInNameByApp & " - Tamanho do Papel - Falha!"
            Else
                Msg1 = "The paper with size ''" & pName & "'' isn't supported by the printer " & appHostApp.ActivePrinter & Chr(10) & Chr(10) _
                     & "OK  -  Setup other PAPER;" & Chr(10) & Chr(10) _
                     & "Cancel - Setup other PRINTER."
                Msg2 = sAddInNameByApp & " - Paper Size - Fail!"
            End If
            If MyMsgBox(Msg1, 2, Msg2) = 1 Then
                vReStart = True
                vSet = True
                GoTo ReStart
            Else
                If appHostApp.Dialogs(xlDialogPrinterSetup).Show Then
                    GoTo ReStart
                Else
                    Exit Function
                End If
            End If
        End If
    End If

    tPaperSize.lXlIndex = XlIndx
    tPaperSize.sName = pName
    tPaperSize.dWidth = pWidth
    tPaperSize.dHeight = pHeight
    fPaperSize = True
End Function


Attribute VB_Name = "Mod2Send"
Option Explicit
Public sTempFileName As String, PathTemp As String    'Apenas troquei o nome, pois estava inadequado como path, e alterei o scopo para public para limpar temp ao sair
Public lResult As Long
Public EmlEmail As String
Public vEnableEvents As Boolean
Public bPrintToXLS As Boolean, bZipPortblXLS As Boolean, bSendPortblXLSbyEmail As Boolean, bSavePortblXLSasWebPg As Boolean, bSuccessAlert As Boolean
Public sPortblSavePath As String  'Pode vir do .ini
Public sPortblSaveName As String: Public bAddPortblNewSh As Boolean
Public sPortblSaveExt As String

Dim EmlRel As String
Dim EmlSubj As String
Dim EmlEmpr As String
Dim RelView As String

Sub EnviarEmailTudo()
'Envia a pasta ativa toda
    If sEmlEmail = "" And TypeName(ActWkbSel) = "Range" Then    'Tenta captar email no range ativo, se sucesso tenta captar tamb|fffd|m subj e msg se houver mais de uma c|fffd|lula na sele|fffd||fffd|o, tentando primeiro descendo e depois para direita.
        If InStr(1, ActWkbSel.Cells(1, 1).Value, "@") > 2 And InStr(1, ActWkbSel.Cells(1, 1).Value, ".") > 1 Then sEmlEmail = Trim(ActWkbSel.Cells(1, 1).Value)
        If sEmlEmail <> "" And ActWkbSel.Cells.Count > 1 Then
            If ActWkbSel.Rows.Count > 1 Then sEmlSubj = ActWkbSel.Cells(2, 1).Value
            If sEmlSubj = "" And ActWkbSel.Columns.Count > 1 Then
                sEmlSubj = ActWkbSel.Cells(1, 2).Value
                If sEmlSubj <> "" And ActWkbSel.Columns.Count > 2 Then sEmlMsg = ActWkbSel.Cells(1, 3).Value
            Else
                If sEmlSubj <> "" And ActWkbSel.Rows.Count > 2 Then sEmlMsg = ActWkbSel.Cells(3, 1).Value
            End If
        End If
    End If

    If sEmlEmail <> "" Then EmlEmail = sEmlEmail Else EmlEmail = IIf(IsPortg, "anonimo", "anonymous") & "@cpap.com.br"   'Definido em fPortblXLSPrinter ou captado na sele|fffd||fffd|o ativa tem prefer|fffd|ncia.
    EmlRel = IIf(IsPortg, "Relat|fffd|rio X...", "Report X...")
    If sEmlSubj <> "" Then EmlSubj = sEmlSubj Else EmlSubj = EmlRel & " - " & sAddInNameByApp    'Definido em fPortblXLSPrinter ou captado na sele|fffd||fffd|o ativa tem prefer|fffd|ncia.
    EmlEmpr = appHostApp.UserName
    If EmlEmpr = "" Then EmlEmpr = IIf(IsPortg, "Nome", "Name")
    RelView = IIf(IsPortg, " que pode ser visualizado e impresso atrav|fffd|s do Microsoft Excel ou atrav|fffd|s de aplicativos gratuitos como o Visualizador do Excel|fffd| e o OpenOffice|fffd|.", " that can be viewed and printed thru the Microsoft Excel or thru free applications like Excel Viewer|fffd| and OpenOffice|fffd|.")

    'Primeira tentativa envia usando MAPIvb32.bas sem necessidade de sendkeys.
    'Se falhar tenta o metodo anterior que necessita de send.keys usando ou n|fffd|o o clipboard
    'Dim PathTemp As String    'Apenas passei usar um nome de arquivo, pois estava inadequado como path, e alterei o scopo para public
    If ActWkb.Path = "" Then
        sPortblSaveExt = ".xls" & IIf(dHostAppVer >= 12, "x", "")
    Else
        sPortblSaveExt = IIf(Left(Right(ActWkb.Name, 4), 1) = ".", ".xls", ".xlsx")    'Agora ser|fffd| mesmo tipo do ActWkb se j|fffd| salvo.
    End If
    If appHostApp.ActiveWorkbook.Saved And Not HasVBAProject Then
        sTempFileName = appHostApp.ActiveWorkbook.FullName
    Else
        GetTempFileName
        If TypeName(appHostApp.ActiveWindow.ActiveSheet) <> "Chart" Then appHostApp.ActiveWindow.ActiveSheet.Calculate
        appHostApp.DisplayAlerts = False    'Evitar alerta, se por ventura restar links para uma pasta n|fffd|o salva
        If Err.Number = 0 Then appHostApp.ActiveWorkbook.SaveAs sTempFileName, IIf(dHostAppVer < 12, 1, IIf(Len(sPortblSaveExt) = 4, 56, 51))    '51 xlOpenXMLWorkbook
        appHostApp.DisplayAlerts = True
        If Err.Number <> 0 Then
            If IsPortg Then
                Msg1 = "Erro ao salvar arquivo tempor|fffd|rio: " & Err.Number & " - " & Err.Description
            Else
                Msg1 = "Error when saving temp file: " & Err.Number & " - " & Err.Description
            End If
            MyMsgBox Msg1, 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
            Exit Sub
        End If
        If HasVBAProject Then
            appHostApp.ActiveWorkbook.Close False
            MyWait 0.5
            TryOpenAndSave sTempFileName
            MyWait 0.5
            appHostApp.Workbooks.Open sTempFileName
        End If
    End If

    'Originalmente no PrintThruEmail e no CPAP, o bot|fffd|o Send salva em um XLS temp e envia direto anexado ao email. Aqui, no
    'PortbXLSPrinter, s|fffd| desvio para o usu|fffd|rio Salvar o mesmo temp j|fffd| pronto como um novo XLS com o nome e local que ele
    'desejar. O bot|fffd|o Send continua com a mesma funcionalidade, mas oculto, e para enviar por Email, zipar ou salvar como
    'Web Page foram criadas op|fffd||fffd|es para agir ap|fffd|s o SaveAs e assim o anexo a ser enviado ser|fffd| o do SaveAs ou seu zip bem
    'como para salvar como Web Page.
    Dim WbTempToSend As Excel.Workbook, bActWkbIsPortable As Boolean: Set WbTempToSend = appHostApp.ActiveWorkbook: ActWkb.Activate: appHostApp.ScreenUpdating = True    'Updating para msgs e forms novos em PortblXLSPrinter n|fffd|o marcar tela do Excel, mas, para n|fffd|o ficar exibindo temp wb, foi necess criar vari|fffd|vel WbTempToSend
    If bPrintToXLS And appHostApp.ActiveWorkbook.Saved And appHostApp.ActiveWorkbook.FullName = ActWkb.FullName Then    'Se for o pr|fffd|prio ActWkb
        If Not bSendPortblXLSbyEmail And Not bSavePortblXLSasWebPg Then
            Msg1 = IIf(IsPortg, "A pasta de trabalho ativa e salva, " & ActWkb.Name & " j|fffd| |fffd| um arquivo XLS port|fffd|vel, mas voc|fffd| pode continuar assim mesmo para salvar uma c|fffd|pia com outro nome ou local. Ok?", "The active and saved workbook, " & ActWkb.Name & ", is already a portable XLS file, but you can still go on to save a copy with another name or location. Ok?")
            Msg2 = sAddInNameByApp & IIf(IsPortg, " - Arquivo J|fffd| |fffd| XLS Port|fffd|vel!", " - File Is Already Portable XLS!")
            If MyMsgBox(Msg1, 2, Msg2) = 2 Then Exit Sub
        Else
            sPortblSaveName = ActWkb.FullName: bActWkbIsPortable = True    'Vai tratar ActWkb j|fffd| ativo como WbTempToSend, mas sem questionar novo nome e nem kill no final.
        End If
    End If

    On Error Resume Next
    If bPrintToXLS Then
        If sPortblSavePath = "" Or VBA.Dir(sPortblSavePath, vbDirectory) = "" Then sPortblSavePath = GetRegValue(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Desktop", False)   'ThisDLLPath
        If sPortblSaveName = "" Then If VBA.Strings.Mid(sPortblSavePath, 2, 1) = ":" Then ChDrive sPortblSavePath: ChDir sPortblSavePath    'Se j|fffd| vier com nome definido como n|fffd|o fun|fffd||fffd|o talvez n|fffd|o seja necess|fffd|rio ativar a pasta
TryOtherName:
        Err.Clear
        If sPortblSaveName = "" Then
            sPortblSaveName = ActWkb.Name & "_Portbl" & sPortblSaveExt: bAddPortblNewSh = False
            sPortblSaveName = appHostApp.GetSaveAsFilename(sPortblSaveName, IIf(dHostAppVer < 12, "Portable Files (*.xls),*.xls", "Portable Files (*.xlsx; *.xls),*.xlsx;*.xls"))
            If sPortblSaveName = CStr(False) Or Not (sPortblSaveName Like "*.xls" Or sPortblSaveName Like "*.xlsx") Then WbTempToSend.Close False: Exit Sub        'S|fffd| aceita xls ou xlsx.

            If Dir(sPortblSaveName) <> "" Then
                Msg1 = IIf(IsPortg, "O arquivo " & sPortblSaveName & " j|fffd| existe. Voc|fffd| quer adicionar uma nova planilha nele?" & vbCrLf & vbCrLf & "Sim - Adicionar uma nova planilha no arquivo existente;" & vbCrLf & vbCrLf & "N|fffd|o - Substituir o arquivo existente ou" & vbCrLf & vbCrLf & "Ignorar - Indicar outro nome de arquivo.", "The file " & sPortblSaveName & " already exists. Do you want to add a new sheet in it?" & vbCrLf & vbCrLf & "Yes - Add a new sheet in the existing file" & vbCrLf & vbCrLf & "No  - Replace the existing file" & vbCrLf & vbCrLf & "Ignore - Inform another name file")
                Msg2 = sAddInNameByApp & IIf(IsPortg, " - Sobrescrever Arquivo ou Adicionar Planilha!", " - Overwrite File or Add Sheet!")
                MyMsgBox Msg1, 3, Msg2
                If BotAcionado = 1 Then bAddPortblNewSh = True
                If BotAcionado = 2 Then Kill sPortblSaveName
                If Err.Number <> 0 Then MyMsgBox IIf(IsPortg, "N|fffd|o foi poss|fffd|vel salvar a nova impress|fffd|o sobrescrevendo arquivo existente:", "Unable to save the new print overwriting existing file:") & vbCrLf _
                                               & sPortblSaveName & vbCrLf & vbCrLf _
                                               & IIf(IsPortg, "(Excel erro n|fffd|mero: " & Err.Number & ". Descri|fffd||fffd|o: ", "(Excel error number: " & Err.Number & ". Description: ") & Err.Description & ")", 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
                If BotAcionado = 3 Or Err.Number <> 0 Then sPortblSaveName = "": GoTo TryOtherName
            End If
        End If

        If bZipPortblXLS And Not bSavePortblXLSasWebPg Then    'Se for zipar, verifico logo aqui se o zip j|fffd| existe assim, depois do SaveAs continua a zip
            Dim sDestZipPath    'Mantive a defini|fffd||fffd|o porque requer Variant
            Dim sOrigPath
            Dim sFileFilter As String
            Dim lAttrib As Long

            sDestZipPath = VBA.Strings.Left(sPortblSaveName, VBA.Strings.Len(sPortblSaveName) - VBA.Strings.Len(sPortblSaveExt)) & ".zip"    '"c:\backtest.zip"
            If Dir(sDestZipPath) <> "" Then
                Msg1 = IIf(IsPortg, "O arquivo ZIP " & sDestZipPath & " j|fffd| existe. Voc|fffd| quer substituir o arquivo existente?", "The ZIP file " & sDestZipPath & " already exists. Do you want to replace the existing file?")
                Msg2 = sAddInNameByApp & IIf(IsPortg, " - Sobrescrever Arquivo ZIP!", " - Overwrite ZIP File!")
                MyMsgBox Msg1, 2, Msg2
                If BotAcionado = 1 Then Kill sDestZipPath
                If BotAcionado = 2 Or Err.Number <> 0 Then sPortblSaveName = "": GoTo TryOtherName
            End If
        End If

        If bAddPortblNewSh Then    'Abre XLS existente para adiciona nova planilha e ent|fffd|o zipar, enviar email ou save as web
            Dim ExistXLSWb As Excel.Workbook
            appHostApp.DisplayAlerts = False    'Skip read-only alert that is show despite error resume when Notify argument is set
            Set ExistXLSWb = appHostApp.Workbooks.Open(sPortblSaveName, 0, False, , , , , , , , False)
            appHostApp.DisplayAlerts = True
            ActWkb.Activate
            If Err.Number <> 0 Then
                If Not ExistXLSWb Is Nothing Then ExistXLSWb.Close False
                Set ExistXLSWb = Nothing: sPortblSaveName = ""
                GoTo TryOtherName
            End If
            WbTempToSend.ActiveSheet.Name = VBA.Strings.Left(WbTempToSend.ActiveSheet.Name, VBA.Strings.Len(WbTempToSend.ActiveSheet.Name) - 1) & ExistXLSWb.Sheets.Count + 1
            WbTempToSend.ActiveSheet.Copy After:=ExistXLSWb.Sheets(ExistXLSWb.Sheets.Count)
            ActWkb.Activate
            If Err.Number <> 0 Then
                ExistXLSWb.Close False
                Set ExistXLSWb = Nothing: sPortblSaveName = ""
                GoTo TryOtherName
            Else    'Close WbTempToSend created to print and set ExistXLSWb as WbTempToSend
                ExistXLSWb.Save
                If Err.Number <> 0 Then
                    MyMsgBox IIf(IsPortg, "N|fffd|o foi poss|fffd|vel salvar a nova impress|fffd|o no arquivo existente:", "Unable to save the new print on existing file:") & vbCrLf _
                           & sPortblSaveName & vbCrLf & vbCrLf _
                           & IIf(IsPortg, "(Excel erro n|fffd|mero: " & Err.Number & ". Descri|fffd||fffd|o: ", "(Excel error number: " & Err.Number & ". Description: ") & Err.Description & ")", 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!")
                    ExistXLSWb.Close False: Set ExistXLSWb = Nothing: sPortblSaveName = "": GoTo TryOtherName
                End If
                WbTempToSend.Close False
                Set WbTempToSend = ExistXLSWb
            End If
        Else
            If Not bActWkbIsPortable Then
                If bSavePortblXLSasWebPg Or Not sPortblSaveName Like "*" & sPortblSaveExt Then
                    If Not sPortblSaveName Like "*" & sPortblSaveExt Then sPortblSaveExt = IIf(Left(Right(sPortblSaveName, 4), 1) = ".", ".xls", ".xlsx")    'Se o usu|fffd|rio tiver alterado a extens|fffd|o adotadada para WbTempToSend, ent|fffd|o tem que usar saveas.
                    WbTempToSend.SaveAs sPortblSaveName, IIf(dHostAppVer < 12, 1, IIf(Len(sPortblSaveExt) = 4, 56, 51))    '51 xlOpenXMLWorkbook
                Else
                    WbTempToSend.SaveCopyAs sPortblSaveName             'Usei SaveAs sem problema, mas SaveCopyAs parece mais seguro para anexar e zipar por deixar o arquivo livre do Excel. No caso de bSavePortblXLSasWebPg |fffd| necess. SaveAs para que a caixa de dialogo do Excel abra na pasta do portabl gerado
                End If
            End If
            If Err.Number <> 0 Then sPortblSaveName = "": GoTo TryOtherName
            sPortblSavePath = Dir(sPortblSaveName)    'Get new path set by user
            If VBA.Strings.Len(sPortblSavePath) < 5 Then sPortblSaveName = "": GoTo TryOtherName
        End If
        sPortblSavePath = VBA.Strings.Left(sPortblSaveName, VBA.Strings.Len(sPortblSaveName) - VBA.Strings.Len(Dir(sPortblSaveName)) - 1)

        If bZipPortblXLS And Not bSavePortblXLSasWebPg Then
            sOrigPath = sPortblSavePath    '"s:\cpap"
            sFileFilter = Dir(sPortblSaveName)    '"Areceber\testeLOtot.xls"
            If VBA.Strings.Len(sFileFilter) < 5 Then sPortblSaveName = "": GoTo TryOtherName
            lAttrib = 0
            If Not CopyToZipFolder(sDestZipPath, sOrigPath, sFileFilter, lAttrib) Then sPortblSaveName = "": GoTo TryOtherName   'Else Kill sPortblSaveName      'Depois de zipado n|fffd|o h|fffd| raz|fffd|o para manter xls. Desta nova vers|fffd|o sim, pois pode adicionar novas planilha no futuro
        End If

        If bSavePortblXLSasWebPg Then
            If bAddPortblNewSh Then    'Planilha adicionadas em impress|fffd|es passadas poder estar protegida. Este alerta |fffd| necess|fffd|rio porque dialogs().Show n|fffd|o exibe alerta e fica travado
                Dim Sh
                For Each Sh In WbTempToSend.Sheets
                    If Sh.ProtectContents Then
                        Msg1 = IIf(IsPortg, "Existe planilha protegida por senha na Pasta de Trabalho que voc|fffd| est|fffd| tentando salvar. Planilhas protegidas por senha ou Pasta de Trabalho inteira n|fffd|o podem ser salvas em uma p|fffd|gina da Web. Para salvar, voc|fffd| deve primeiro remover senha.", "There is password protected sheet in the workbook you are trying to save. Password protected sheets or entire workbook cannot be saved in a Web Page. To save, you must first remove the password.")
                        Msg2 = sAddInNameByApp & IIf(IsPortg, " - Existe Planilha Protegida!", " - There Is Protected Sheet!")
                        MyMsgBox Msg1, 1, Msg2
                        Exit For
                    End If
                Next
            End If
            WbTempToSend.Activate
            appHostApp.Dialogs(xlDialogSaveAs).Show VBA.Strings.Left(sPortblSaveName, VBA.Strings.Len(sPortblSaveName) - VBA.Strings.Len(sPortblSaveExt)) & ".html", xlHtml             'appHostApp.CommandBars.FindControl(, 3823).Execute    '748
            If bActWkbIsPortable Then WbTempToSend.Close False: Set ActWkb = appHostApp.Workbooks.Open(sPortblSaveName)    'Se j|fffd| port|fffd|vel, fecha pois agora |fffd| html ou outra e reabre para restaurar ActWkb felizmente como |fffd| um portable n|fffd|o tem senha para abrir.
            Exit Sub
        End If

        Const bSendMailByNewExcelInst As Boolean = True    'Desvio, se vai enviar email com xls e n|fffd|o zip attach, para enviar por outra inst|fffd|ncia do Excel. Assim, pode visualizar e editar antes de enviar. Nada foi alterado acima e abaixo para ficar f|fffd|cil de implementar no CPAP.
        If bSendPortblXLSbyEmail And Not bZipPortblXLS And bSendMailByNewExcelInst And Not bActWkbIsPortable Then SendMailByNewExcelInst EmlSubj, WbTempToSend: Exit Sub

        If bSendPortblXLSbyEmail Then    'Se for para enviar por email, continua como no PrintThruEmail agora anexado o save as ou o zip em vez do temp
            Dim sTempFileName1 As String
            sTempFileName1 = IIf(bZipPortblXLS, sDestZipPath, sPortblSaveName)
            If dHostAppVer > 8 Then
                If Not IsPortg Then
                    With UserFormWait
                        .Caption = "Please!"
                        .Label1.Caption = "Wait the email appear..."
                        .Alert_Lb.Caption = "Tip! Press Ctrl+V to paste on the email body, if the massage template isn't shown automatically."
                    End With
                End If
                #If VBA6 Then
                    UserFormWait.Show 0
                #End If
                DoEvents
            Else
                appHostApp.StatusBar = IIf(IsPortg, "AGUARDE...", "WAIT...")
            End If
        Else
            Msg1 = IIf(IsPortg, "Arquivo salvo com sucesso!", "File saved with success!")
            Msg2 = sAddInNameByApp & IIf(IsPortg, " - Sucesso!", " - Success!"): VBA.Interaction.Beep
            If bSuccessAlert Then MyMsgBox Msg1, 1, Msg2
            WbTempToSend.Activate: Exit Sub
        End If
    End If

    Dim Msg As String
    If sEmlMsg <> "" Then Msg = sEmlMsg Else GetMsg Msg   'Definido em fPortblXLSPrinter ou captado na sele|fffd||fffd|o ativa tem prefer|fffd|ncia.

    lResult = -2    'SendMailByMAPIvb32 EmlEmail, EmlSubj, Msg, IIf(bPrintToXLS, sTempFileName1, sTempFileName) 'A priore vou descontinuar este m|fffd|todo, pois falha muito e assim simula falha e envia pelo Excel.

    If bPrintToXLS Then WbTempToSend.Activate Else ActWkb.Activate
    If dHostAppVer < 10 Then AppActivate appHostApp.Caption Else SetForegroundWindowEsp App_hWnd, 0.5    'Se agora tenho um mais preciso, por que n|fffd|o usar.

    'if MAPIvb32 fail try:
    If lResult > 1 Or lResult < 0 Then   'Se falhar com MAPIvb32 tenta exibindo xlDialogSendMail do Excel e cola msg com sendkeys
        SendKeysMsg Msg
        VBA.Unload UserFormWait: appHostApp.StatusBar = False    'Fiz sem condicionais, pois n|fffd|o faz diferen|fffd|a usar em qualquer configura|fffd||fffd|o de op|fffd||fffd|es.
        On Error Resume Next    'Para lembrar que sem isso, um erro no dialog a seguir provoca sa|fffd|da imediata n|fffd|o finalizando o sub.
        lResult = appHostApp.Dialogs(xlDialogSendMail).Show(EmlEmail, EmlSubj)
        If Err.Number <> 0 Then lResult = -2: MyMsgBox IIf(IsPortg, "N|fffd|o foi poss|fffd|vel enviar o e-mail usando API ou a caixa de di|fffd|logo interna do Excel. Talvez voc|fffd| n|fffd|o tenha programa da Microsoft instalado em seu computador para envio de e-mail que |fffd| necess|fffd|rio.", "Unable to send the email using API or the Excel built-in dialog. You may not have Microsoft program installed on your computer to send email that is required.") & vbCrLf _
                                                     & IIf(IsPortg, "(Excel erro n|fffd|mero: " & Err.Number & ". Descri|fffd||fffd|o: ", "(Excel error number: " & Err.Number & ". Description: ") & Err.Description & ")", 1, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!"): Err.Clear
        RetError = IIf(lResult = 0, -1, IIf(lResult = -1, 0, 3))    '-1 Envio de email cancelado pelo usu|fffd|iro. 3 Falha no envio.
    End If
End Sub

Sub GetTempFileName()
    Dim PathTemp As String
    On Error Resume Next
    If sTempFileName <> "" Then    'Se j|fffd| foi criado um nome na atual execu|fffd||fffd|o, tenta aproveitar e deletando se existir arquivo
        If Dir(sTempFileName) <> "" Then Kill sTempFileName
        If Err.Number <> 0 Then sTempFileName = ""
    End If
    If sTempFileName = "" Then
        PathTemp = TempFolder(): If VBA.Strings.Right(PathTemp, 1) = "\" Then PathTemp = VBA.Strings.Left(PathTemp, VBA.Strings.Len(PathTemp) - 1)
        Do
            sTempFileName = PathTemp & "\" & sAddInNameByApp & "_tmp" & VBA.Strings.Format(Now, "hhmmss") & sPortblSaveExt
            If VBA.FileSystem.Dir(sTempFileName) <> "" Then MyWait 0.5 Else Exit Do   'If file already exist, wait for the next second
        Loop
    End If
End Sub

Sub SendMailByMAPIvb32(Email As String, Subj As String, Msg As String, Attach As String)
    Dim oMsg As MAPIMessage    'Types here are set in ModMAPIvb32
    Dim oRecipients(0) As MapiRecip
    Dim oAttachments(0) As MapiFile
    Dim lSession As Long
    Dim oCurDir As String
    Dim sDefMailer As String

    'S|fffd| tenta usar diretamente a bilioteca MAPI se um dos Mailer da MS for default
    sDefMailer = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail", "", False)
    If Not VBA.Strings.Left(sDefMailer, 15) = "Outlook Express" _
       And Not VBA.Strings.Left(sDefMailer, 17) = "Microsoft Outlook" _
       And Not VBA.Strings.Left(sDefMailer, 18) = "Microsoft Exchange" _
       And Not VBA.Strings.Left(sDefMailer, 14) = "Microsoft Mail" Then
        lResult = -1
        Exit Sub
    End If

    '    'Verifica se Outlook Express |fffd| o padr|fffd|o e se for verifica e concerta o registro
    '    If VBA.Strings.left(GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail", "", False), 15) = "Outlook Express" Then
    '        Dim DLLPath
    '        Dim DLLPathEx
    '        DLLPath = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPath", False)
    '        DLLPath = appHostApp.WorksheetFunction.Clean(DLLPath)
    '        DLLPathEx = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx", False)
    '        DLLPathEx = appHostApp.WorksheetFunction.Clean(DLLPathEx)
    '        If DLLPath <> DLLPathEx Then
    '            SetKeyValue HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx", CLng(DLLPath), REG_SZ
    '        End If
    '    End If

    oCurDir = CurDir   'Store to restore because MAPIvb32 change currente dir

    ' Logon
    lResult = MAPILogon(0, "", "", MAPI_LOGON_UI + MAPI_NEW_SESSION, 0, lSession)

    If lResult = 3 Then   'S|fffd| suspende o envio se usu|fffd|rio cancelar
        '        MsgBox "Logon failed. Result = " & lResult
        lResult = 1   'Indica cancelado pelo usu|fffd|rio
        GoTo RestCurDir
        Exit Sub
    End If

    ' Fill out the message
    With oMsg
        .Reserved = 0
        .NoteText = Msg
        .FileCount = IIf(Attach = "", 0, 1)
        .RecipCount = 1  'only 1 recipient
        .Subject = Subj
    End With

    ' Fill out the recipient
    With oRecipients(0)
        ' TODO: Change "test@online.microsoft.com" to the address you want to send to
        .Name = Email
        .RecipClass = MAPI_TO
        .Reserved = 0
    End With

    If Attach <> "" Then
        With oAttachments(0)
            '         .FileName = "filename.ext" 'File name on the email
            .PathName = Attach   'File fullname on HD
            '    .Position = 0
            '    .FileType = 0
        End With
    End If

    '    lResult = MAPIResolveName(lSession, 0, oRecipients(0).Name, 0, 0, oRecipients(0))
    '
    '    If lResult <> 0 Then
    '        MsgBox "MAPIResolveName failed. Result = " & lResult
    '        GoTo RestCurDir
    '    End If


    ' Send the message
    lResult = MAPISendMail(lSession, 0, oMsg, oRecipients, oAttachments, MAPI_DIALOG, 0&)

    '   If lResult = 0 Then
    '      MsgBox "Mensagem enviada!", , "CPAP|fffd|"
    '   Else
    '      If lResult <> 1 Then MsgBox "Motivo = " & lResult, , "Falha ao Enviar Mensagem!"
    '   End If

    ' Log off
    If lResult = 0 Or lResult = 1 Then MAPILogoff lSession, 0, 0, 0

    '   If lResult <> 0 Then
    '      MsgBox "Logoff failed. Result = " & lResult
    '   End If

RestCurDir:
    If VBA.Strings.Mid(oCurDir, 2, 1) = ":" Then ChDrive oCurDir
    ChDir oCurDir
End Sub

Function PrepToSendKeys(vStr As String) As String
    With appHostApp.WorksheetFunction
        vStr = .Substitute(vStr, "{", "[")
        vStr = .Substitute(vStr, "}", "]")

        vStr = .Substitute(vStr, "+", "{+}")
        vStr = .Substitute(vStr, "%", "{%}")
        vStr = .Substitute(vStr, "^", "{^}")
        vStr = .Substitute(vStr, "~", "{~}")
        vStr = .Substitute(vStr, "(", "{(}")
        vStr = .Substitute(vStr, ")", "{)}")
        vStr = .Substitute(vStr, "[", "{[}")
        vStr = .Substitute(vStr, "]", "{]}")
    End With
    PrepToSendKeys = vStr
End Function

Sub TryOpenAndSave(sTempFileName1 As String)
'   If MsgBox("Open and save?", vbOKCancel) = vbCancel Then Exit Sub
'Tenta abrir e salvar em outra execu|fffd||fffd|o do Excel em sil|fffd|ncio, um insucesso n|fffd|o ser|fffd| motivo para interromper o processo
'Isto |fffd| necess|fffd|rio porque ao limpar c|fffd|digo e salvar em uma mesmo procedimento continua a exib alerta de macro
    Dim ExcelObj As Excel.Application
    Dim Wb As Excel.Workbook
    If OpenDftVerAppObj(ExcelObj, 0) = False Then Exit Sub
    On Error Resume Next
    Set Wb = ExcelObj.Workbooks.Open(sTempFileName1)
    DoEvents
    ExcelObj.ActiveWindow.ActiveSheet.Calculate
    Wb.Save
    Wb.Close False
    ExcelObj.Quit
End Sub

Private Function OpenDftVerAppObj(ExcelObjDftVer As Object, Optional lVerfOnly As Long) As Boolean    'From Tool of ToEXE
    Dim i As Long
    On Error Resume Next
    'Loop necess|fffd|rio para ter certeza de que o app |fffd| um novo, pois parece que, quando h|fffd|
    'mais de um Excel instalado, isto n|fffd|o acontece na primeira tentativa. O Loop interno
    '|fffd| para se assegurar de que objeto foi criado antes de chamar suas propriedades.
    Do
        Do
            i = i + 1
            If i > lVerfOnly And lVerfOnly <> 0 Then Exit Function    'N|fffd|o insistir al|fffd|m das tentativa passadas, pois |fffd| mais uma verifica|fffd||fffd|o se pode ser criado
            If i > 10 Then
                If MyMsgBox(IIf(IsPortg, "N|fffd|o foi poss|fffd|vel criar um novo objeto Excel.Application! Tentar novamente?", "Wasn't possible to create a new Excel.Application object! Try again?"), 2, sAddInNameByApp & IIf(IsPortg, " - Falha!", " - Fail!"), vbModeless) = 2 Then
                    Exit Function
                Else
                    i = 0
                End If
            End If
            Err.Clear








            'Set ExcelObjDftVer = CreateObject("Excel.Application")
            Set ExcelObjDftVer = New Excel.Application
        Loop Until Err.Number = 0 And Not ExcelObjDftVer Is Nothing
        MyWait 0.2
    Loop Until ExcelObjDftVer.Workbooks.Count = 0
    OpenDftVerAppObj = True




End Function




Sub FixOutlookExpress()
    If MsgBox("Verificar a configura|fffd||fffd|o e tornar o Outlook Express seu programa padr|fffd|o para o envio de emails?" & Chr(10) & Chr(10) & "   Obs.: S|fffd| use se estiver com problema para o envio de Email.", vbOKCancel + vbQuestion, "Outlook Express") = vbCancel Then Exit Sub
    Dim DLLPath
    Dim DLLPathEx
    Dim GetValue
    DLLPath = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPath", False)
    DLLPath = appHostApp.WorksheetFunction.Clean(DLLPath)
    If DLLPath = "Error" Then GoTo FalhaNoRegitro

    DLLPathEx = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx", False)
    DLLPathEx = appHostApp.WorksheetFunction.Clean(DLLPathEx)
    If DLLPath <> DLLPathEx Then
        SetKeyValue HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express", "DLLPathEx", CLng(DLLPath), REG_SZ
    End If

    GetValue = "Outlook Express"
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\Clients\Mail", "", CLng(GetValue), REG_SZ
    '@="Outlook Express"

    GetValue = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express\Protocols\mailto", "", False)
    GetValue = appHostApp.WorksheetFunction.Clean(GetValue)
    If InStr(1, GetValue, "MailTo") = 0 Then GoTo FalhaNoRegitro
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\CLASSES\mailto", "", CLng(GetValue), REG_SZ
    '[HKEY_LOCAL_MACHINE\Software\Clients\Mail\Outlook Express\Protocols\mailto]
    '@="URL:protocolo MailTo"
    '[HKEY_LOCAL_MACHINE\Software\CLASSES\mailto]
    '@="URL:protocolo MailTo"

    GetValue = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express\Protocols\mailto\DefaultIcon", "", False)
    GetValue = appHostApp.WorksheetFunction.Clean(GetValue)
    If InStr(1, GetValue, "\MSIMN.EXE") = 0 Then GoTo FalhaNoRegitro
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\CLASSES\mailto\DefaultIcon", "", CLng(GetValue), REG_SZ
    '[HKEY_LOCAL_MACHINE\Software\Clients\Mail\Outlook Express\Protocols\mailto\DefaultIcon]
    '@="C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE,-2"
    '[HKEY_LOCAL_MACHINE\Software\CLASSES\mailto\DefaultIcon]
    '@="C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE,-2"

    GetValue = GetRegValue(HKEY_LOCAL_MACHINE, "Software\Clients\Mail\Outlook Express\Protocols\mailto\shell\open\command", "", False)
    GetValue = appHostApp.WorksheetFunction.Clean(GetValue)
    If InStr(1, GetValue, "\MSIMN.EXE") = 0 Then GoTo FalhaNoRegitro
    SetKeyValue HKEY_LOCAL_MACHINE, "Software\CLASSES\mailto\shell\open\command", "", CLng(GetValue), REG_SZ
    '[HKEY_LOCAL_MACHINE\Software\Clients\Mail\Outlook Express\Protocols\mailto\shell\open\command]
    '@="\"C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE\" /mailurl:%1"
    '[HKEY_LOCAL_MACHINE\Software\CLASSES\mailto\shell\open\command]
    '@="\"C:\\ARQUIVOS DE PROGRAMAS\\OUTLOOK EXPRESS\\MSIMN.EXE\" /mailurl:%1"

    MsgBox "Agora o Outlook Express |fffd| o programa padr|fffd|o para o envio de emails, mas voc|fffd| precisa sair e reiniciar o CPAP para efetivar a nova configura|fffd||fffd|o.", vbInformation, "Outlook Express - Sucesso na Configura|fffd||fffd|o!"
    '   Hide
    BotAcionado = 1
    Exit Sub
FalhaNoRegitro:
    MsgBox "Antes voc|fffd| precisa instalar ou reinstalar o Outlook Express em seu computador!", vbCritical, "Outlook Express - Falha no Registro!"
End Sub

Sub SendMailByNewExcelInst(sSubj As String, WbTempToSend As Excel.Workbook)   'Abrir em outra inst|fffd|ncia e enviar email.
    On Error GoTo 0
    WbTempToSend.Close False: Set WbTempToSend = Nothing    'Agora fecha e mata aqui para ser aberto e tratado em outra inst|fffd|ncia.
    ActWkb.Activate
    If dHostAppVer < 10 Then AppActivate appHostApp.Caption Else SetForegroundWindowEsp App_hWnd, 0.5    'Se agora tenho um mais preciso, por que n|fffd|o usar.

    Dim ExcelObj As Excel.Application
    VBA.Interaction.Beep
ResumeSend:
    If dHostAppVer < 10 Then AppActivate appHostApp.Caption Else SetForegroundWindowEsp App_hWnd, 0.5    'Se agora tenho um mais preciso, por que n|fffd|o usar.
    Msg1 = IIf(IsPortg, "Enviar agora, com o arquivo XLS Port|fffd|vel salvo, acione:" & vbCrLf & vbCrLf & "Sim - Enviar agora em um e-mail como anexo;" & vbCrLf & vbCrLf & "N|fffd|o - Visualizar antes ou editar em outra janela do Excel ou" & vbCrLf & vbCrLf & "Ignorar - Desistir.", "Send now, with the Portable XLS file saved, click on:" & vbCrLf & vbCrLf & "Yes - Send now in an email attachment" & vbCrLf & vbCrLf & "No - Preview before or edit in another Excel window" & vbCrLf & vbCrLf & "Ignore - Give up")
    Msg2 = sAddInNameByApp & IIf(IsPortg, " - XLS Port|fffd|vel Feito - Enviar por E-mail", " - Portable XLS Done - Send Thru Email")
    MyMsgBox Msg1, 3, Msg2: DoEvents
    If BotAcionado = 1 Then
        If OpenDftVerAppObj(ExcelObj, 0) = False Then Exit Sub
        ExcelObj.WindowState = xlMinimized
        ExcelObj.Visible = True
        Set WbTempToSend = ExcelObj.Workbooks.Open(sPortblSaveName)
        If WbTempToSend.ReadOnly Then
            Msg1 = "'" & sPortblSaveName & IIf(IsPortg, "' est|fffd| como somente leitura! Verifique se est|fffd| aberto em visualiza|fffd||fffd|o ou em edi|fffd||fffd|o em outra janela do Excel, feche e tente enviar novamente.", "' is read-only! Make sure it is open in preview or edit in another Excel window, close it and try sending again.")
            ExcelObj.ExecuteExcel4Macro ("ALERT(""" & Msg1 & """, 3)")
            WbTempToSend.Close False: ExcelObj.Quit
            DoEvents: Set ExcelObj = Nothing
            GoTo ResumeSend
        End If

        Dim Msg As String
        If sEmlMsg <> "" Then Msg = sEmlMsg Else GetMsg Msg   'Definido em fPortblXLSPrinter ou captado na sele|fffd||fffd|o ativa tem prefer|fffd|ncia.
        If dHostAppVer < 10 Then AppActivate appHostApp.Caption Else SetForegroundWindowEsp App_hWnd, 0.5    'Se agora tenho um mais preciso, por que n|fffd|o usar.
        SendKeysMsg Msg
        On Error Resume Next: ExcelObj.Dialogs(xlDialogSendMail).Show EmlEmail, sSubj: On Error GoTo 0
        WbTempToSend.Close False: ExcelObj.Quit
    ElseIf BotAcionado = 2 Then
        If OpenDftVerAppObj(ExcelObj, 0) = False Then Exit Sub
        ExcelObj.WindowState = IIf(appHostApp.WindowState = xlNormal, xlMaximized, xlNormal)
        ExcelObj.Visible = True
        Set WbTempToSend = ExcelObj.Workbooks.Open(sPortblSaveName)
        If WbTempToSend.ReadOnly Then
            Msg1 = "'" & sPortblSaveName & IIf(IsPortg, "' est|fffd| como somente leitura! Verifique se est|fffd| aberto em visualiza|fffd||fffd|o ou em edi|fffd||fffd|o em outra janela do Excel, feche e tente enviar novamente.", "' is read-only! Make sure it is open in preview or edit in another Excel window, close it and try sending again.")
            ExcelObj.ExecuteExcel4Macro ("ALERT(""" & Msg1 & """, 3)")
            WbTempToSend.Close False: ExcelObj.Quit
        Else
WaitClose:
            Dim Wb As Excel.Workbook, bWaitClose As Boolean
            Msg1 = IIf(IsPortg, "Esperando visualizar ou editar em outra janela do Excel. Feche l|fffd| e acione Ok para retomar o envio aqui.", "Waiting to view or edit in another Excel window. Close there and click Ok to resume sending here.")
            Msg2 = sAddInNameByApp & IIf(IsPortg, " - XLS Port|fffd|vel Feito - Enviar por E-mail", " - Portable XLS Done - Send Thru Email")
            MyMsgBox Msg1, 1, Msg2: MyWait 0.2: bWaitClose = False: On Error Resume Next
            For Each Wb In ExcelObj.Workbooks
                If Wb.FullName Like sPortblSaveName Then bWaitClose = True: Exit For
            Next
            On Error GoTo 0
            If bWaitClose Then
                VBA.Interaction.Beep
                If dHostAppVer < 10 Then AppActivate ExcelObj.Caption Else SetForegroundWindowEsp ExcelObj.hWnd, 0.5     'Se agora tenho um mais preciso, por que n|fffd|o usar.
                GoTo WaitClose
            End If
        End If
        DoEvents: Set ExcelObj = Nothing
        GoTo ResumeSend
    End If
End Sub

Sub GetMsg(Msg As String)
    Dim ExcelVer As String
    Dim ExcelL|fffd|ngua As String
    Dim i

    Msg = IIf(IsPortg, "Prezado(a) Sr(a),", "Dear Sir or Madam,") & vbCrLf & vbCrLf
    Msg = Msg & IIf(IsPortg, "Segue, anexo, o ", "Follow, attached, the ") & EmlRel & RelView & vbCrLf & vbCrLf
    Msg = Msg & IIf(IsPortg, "Atenciosamente,", "Cordially,") & vbCrLf & vbCrLf
    Msg = Msg & appHostApp.Rept("_", VBA.Strings.Len(EmlEmpr)) & vbCrLf
    Msg = Msg & EmlEmpr & vbCrLf

    i = appHostApp.International(xlCountryCode)
    ExcelL|fffd|ngua = IIf(i = 1, "Ingl|fffd|s", IIf(i = 55, "Portugu|fffd|s", "L|fffd|ngua " & i))
    ExcelVer = "Microsoft Excel " & appHostApp.Version & " (" & ExcelL|fffd|ngua & ")"
    Msg = Msg & ExcelVer & vbCrLf
    Msg = Msg & sAddInNameByApp & " " & fGetVersion & " (http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=MsgEmail", "More.asp?IdC=EmailMsg") & ")" & vbCrLf & vbCrLf
    Msg = Msg & "|fffd|Excel Viewer: http://office.microsoft.com/downloads/2000/xlviewer.aspx" & vbCrLf
    Msg = Msg & "|fffd|OpenOffice.org: " & IIf(IsPortg, "http://www.openoffice.org.br/downloads.php", "http://download.openoffice.org/index.html") & vbCrLf
End Sub

Sub SendKeysMsg(Msg As String)
'Se estiver usando userform VBA, tenta montar o email pelo clipboard
'pois a cola instant|fffd|nea parece mais elegante do que a inclus|fffd|o demorada com sendkeys
    Dim UsarClipb As Boolean
    If CloseAllApp(True, "Outlook.exe") = False Then
        'CloseAllAppProcByImgName "Outlook.exe"      'Se passar, refor|fffd|a fechamento procurando e fechando qualquer processo, assim fecha eventuais travados a espera de a|fffd||fffd|o ou |fffd|rfans. Diferente dos toEXEs, aqui vou deixar que isto s|fffd| seja feito pelo usu|fffd|rio com Shift down,
    End If
    MyWait 0.8
    UsarClipb = True
    On Error Resume Next
    Dim MyData As MSForms.DataObject
    If UsarClipb Then
        Set MyData = New MSForms.DataObject
        MyData.SetText Msg
        MyData.PutInClipboard
        If Err.Number = 0 Then
            MyWait 0.2: VBA.Interaction.SendKeys "{TAB 6}{BS 30}" & IIf(InStr(1, EmlEmail, ";") = 0, "", "+({TAB 3});{BS}+{TAB};{BS}+{TAB};{BS}{TAB 6}{BS 10}") & "^v"  'Se for mais de um e-mail, volta tabeando e insere e tira um ; em To,cc (talvez bcc) e retorna para o Outlook validar todos e-mails em To.
        Else
            UsarClipb = False
        End If
    End If

    If UsarClipb = False Then
        Msg = PrepToSendKeys(Msg)
        VBA.Interaction.SendKeys "{TAB 6}{BS 10}" & Msg
    End If
End Sub
Attribute VB_Name = "Mod3Others"
Option Explicit    'Ok from watermark.xla
Public Declare Function GetTempPath Lib "kernel32" Alias _
                                    "GetTempPathA" (ByVal nBufferLength As Long, _
                                                    ByVal lpBuffer As String) As Long

Declare Function apiGetSys Lib "user32" Alias "GetSystemMetrics" (ByVal nIndex As Long) As Long
Public Const SM_CXSCREEN = 0
Public Const SM_CYSCREEN = 1
Public Declare Function GetDC Lib "user32" _
                              (ByVal hWnd As Long) As Long
Public Declare Function GetDeviceCaps Lib "gdi32" _
                                      (ByVal hdc As Long, ByVal nIndex As Long) As Long
Public Const LOGPIXELSX = 88
Public Const LOGPIXELSY = 90

Public Declare Function GetKeyState Lib "user32" (ByVal vKey As Integer) As Integer

Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long
Private Declare Function GetModuleHandle Lib "kernel32" Alias "GetModuleHandleA" (ByVal lpModuleName As String) As Long
Private Declare Function GetCurrentProcess Lib "kernel32" () As Long
Private Declare Function IsWow64Process Lib "kernel32" (ByVal hProc As Long, bWow64Process As Boolean) As Long
Public Const KEY_WOW64_64KEY = &H100

Public Function ShiftDown()
'Verif. se shift est|fffd| pressionada
    ShiftDown = (GetKeyState(16) < 0)
End Function

Public Function CtrlDown()
'Verif se Ctrl est|fffd| pressionada
    CtrlDown = (GetKeyState(17) < 0)
End Function

Public Function IsWin9x() As Boolean
    IsWin9x = InStr(1, appHostApp.OperatingSystem, "4.") <> 0    'Windows (32-bit) 4.10, Windows (32-bit) NT 5.01 (XP), Windows (32-bit) NT 6.00 (Vista)
End Function

Public Function IsWin64bit() As Boolean    'From http://www.freevbcode.com/ShowCode.asp?ID=9043
    Dim lRet As Long, bIsWow64 As Boolean
    lRet = GetProcAddress(GetModuleHandle("kernel32"), "IsWow64Process")    'Now check to see if IsWow64Process function exists
    If lRet > 0 Then IsWow64Process GetCurrentProcess(), bIsWow64    'If IsWow64Process function exists, now use the function to determine if we are running under Wow64
    IsWin64bit = bIsWow64
End Function


'EVENTOS DE CAIXA DE TEXTO PARA VALOR FINANCEIRO

Sub EvValor_Cb_MouseMove(Valor_Cb As Object, ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)    'As Control pode dar erro em COM add-in
    Dim sd As String
    Valor_Cb.Locked = False
    sd = appHostApp.International(xlDecimalSeparator)
    If Valor_Cb.Text = "0" Or Valor_Cb.Text = "0" & sd & "00" Then
        Valor_Cb.SelStart = 0
        Valor_Cb.SelLength = VBA.Strings.Len(Valor_Cb.Text)
    End If
End Sub

Sub EvValor_Cb_KeyDown(Valor_Cb As Object, ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)    'As Control pode dar erro em COM add-in
    Dim sd As String
    Dim vKeyCode As Integer
    sd = appHostApp.International(xlDecimalSeparator)
    vKeyCode = IIf(sd = ",", 188, 190)
    Valor_Cb.Locked = False
    If KeyCode = 37 Or (Shift = 2 And KeyCode = 86) Or (Shift = 1 And KeyCode = 45) Or (Shift = 2 And KeyCode = 88) Then Exit Sub   'Seta Esquerda e teclas do clipboard
    If KeyCode = 110 Or KeyCode = 190 Then KeyCode = vKeyCode
    If KeyCode = 188 Then If InStr(1, Valor_Cb.Value, sd) > 0 Then Valor_Cb.Locked = True
    If (KeyCode >= 96 And KeyCode <= 105) _
       Or (KeyCode >= 48 And KeyCode <= 57 And Shift = 0) _
       Or KeyCode = 188 Or KeyCode = 8 Or KeyCode = 46 _
       Or KeyCode = 107 Or (KeyCode = 187 And Shift = 1) _
       Or KeyCode = 109 Or (KeyCode = 189 And Shift = 0) Then Else Valor_Cb.Locked = True
End Sub

Sub EvValor_Cb_Change(Valor_Cb As Object, Optional vAbs As Boolean = False)    'As Control pode dar erro em COM add-in
    Dim sd As String
    Dim sm As String
    Dim SinNeg As String
    Dim PartInt As String
    Dim PartFrac As String
    Dim TamPartInt As Integer
    Dim RepCurs As Integer


    Dim i As String
    Dim j As Integer
    Dim k As Integer
    i = Valor_Cb.Value
    j = Valor_Cb.SelStart
    SinNeg = vAbs = False And InStr(1, i, "-") > 0 And InStr(1, i, "+") = 0
    i = appHostApp.WorksheetFunction.Substitute(i, "-", "")
    i = appHostApp.WorksheetFunction.Substitute(i, "+", "")
    PartInt = i
    sd = appHostApp.International(xlDecimalSeparator)
    sm = appHostApp.International(xlThousandsSeparator)
    k = InStr(1, i, sd)
    If k > 0 Then
        PartFrac = VBA.Strings.Mid(i, k + 1, 100)
        PartFrac = appHostApp.WorksheetFunction.Substitute(PartFrac, sm, "")
        PartInt = VBA.Strings.Mid(i, 1, k - 1)
        If PartInt = "" Then PartInt = "0"
    End If
    TamPartInt = VBA.Strings.Len(PartInt)
    PartInt = appHostApp.WorksheetFunction.Substitute(PartInt, sm, "")
    PartInt = VBA.Strings.Format(PartInt, "#,##0")
    RepCurs = VBA.Strings.Len(PartInt) - TamPartInt
    vEnableEvents = False
    Valor_Cb.Value = IIf(SinNeg, "-", "") & PartInt & IIf(PartInt = "" Or k = 0, "", sd) & PartFrac
    vEnableEvents = True
    j = -(j + RepCurs) * (j + RepCurs >= 0)
    If VBA.Strings.Left(Valor_Cb.Value, 2) = "0" & sd And j < 3 Then j = 2
    Valor_Cb.SelStart = j

    'Evita colar texto
    Static ValorOld
    If Valor_Cb.Value <> "" And Valor_Cb.Value <> "-" And Not (IsNumeric(Valor_Cb.Value)) Then
        MsgBox Valor_Cb.Value, vbCritical, IIf(IsPortg, "Invalid Value!", "Valor Inv|fffd|lido!")
        Valor_Cb.Value = ValorOld
    Else
        ValorOld = Valor_Cb.Value
    End If
End Sub

Sub EvValor_Cb_Exit(Valor_Cb As Object, Cancel As MSForms.ReturnBoolean, Formato As String)    'As Control pode dar erro em COM add-in
    If Valor_Cb.Value = "" Then Valor_Cb.Value = 0
    If IsNumeric(Valor_Cb.Value) Then
        If Valor_Cb.Value <> VBA.Strings.Format(Valor_Cb.Value, Formato) Then Valor_Cb.Value = VBA.Strings.Format(Valor_Cb.Value, Formato)
    Else
        MsgBox IIf(IsPortg, "Data inv|fffd|lida!", "Invalid date"), vbCritical, IIf(IsPortg, "Falha!", "Fail!")
        Cancel = True
    End If
End Sub
Attribute VB_Name = "Mod4RegEdit"
Option Explicit                                            'Fiz logo igual ao Tool de ToEXE para ficar totalmente atualizdo

Public Const REG_SZ As Long = &H1
Private Const REG_DWORD As Long = &H4
Private Const REG_BINARY As Long = &H3

Public Const HKEY_CLASSES_ROOT As Long = &H80000000
Public Const HKEY_CURRENT_USER As Long = &H80000001
Public Const HKEY_LOCAL_MACHINE As Long = &H80000002
Public Const HKEY_USERS As Long = &H80000003

Private Const KEY_ALL_ACCESS As Long = &H3F
Private Const KEY_QUERY_VALUE As Long = &H1
Private Const REG_OPTION_NON_VOLATILE As Long = 0

Private Const ERROR_MORE_DATA As Long = 234

Private Type SECURITY_ATTRIBUTES
    nLength As Long
    lpSecurityDescriptor As Long
    bInheritHandle As Long
End Type

Private Declare Function RegCloseKey Lib "advapi32.dll" _
                                     (ByVal hKey As Long) As Long

Private Declare Function RegCreateKeyEx Lib "advapi32.dll" _
                                        Alias "RegCreateKeyExA" (ByVal hKey As Long, _
                                                                 ByVal lpSubKey As String, _
                                                                 ByVal Reserved As Long, _
                                                                 ByVal lpClass As String, _
                                                                 ByVal dwOptions As Long, _
                                                                 ByVal samDesired As Long, _
                                                                 lpSecurityAttributes As SECURITY_ATTRIBUTES, _
                                                                 phkResult As Long, _
                                                                 lpdwDisposition As Long) As Long

Public Declare Function RegDeleteKey Lib "advapi32.dll" _
                                     Alias "RegDeleteKeyA" _
                                     (ByVal hKey As Long, _
                                      ByVal lpSubKey As String) As Long

Private Declare Function RegQueryValueExStr Lib "advapi32.dll" _
                                            Alias "RegQueryValueExA" _
                                            (ByVal hKey As Long, ByVal lpValueName As String, _
                                             ByVal lpReserved As Long, ByRef lpType As Long, _
                                             ByVal lpData As String, ByRef lpcbData As Long) As Long    'Note that if you declare the lpData parameter as String, you must pass it By Value.

Private Declare Function RegQueryValueExLng Lib "advapi32.dll" _
                                            Alias "RegQueryValueExA" _
                                            (ByVal hKey As Long, ByVal lpValueName As String, _
                                             ByVal lpReserved As Long, ByRef lpType As Long, _
                                             lpData As Long, ByRef lpcbData As Long) As Long    'Note that if you declare the lpData parameter as String, you must pass it By Value.

Private Declare Function RegQueryValueExByt Lib "advapi32.dll" _
                                            Alias "RegQueryValueExA" _
                                            (ByVal hKey As Long, ByVal lpValueName As String, _
                                             ByVal lpReserved As Long, ByRef lpType As Long, _
                                             lpData As Byte, ByRef lpcbData As Long) As Long    'Note that if you declare the lpData parameter as String, you must pass it By Value.

Private Declare Function RegOpenKeyEx Lib "advapi32" _
                                      Alias "RegOpenKeyExA" _
                                      (ByVal hKey As Long, _
                                       ByVal lpSubKey As String, _
                                       ByVal ulOptions As Long, _
                                       ByVal samDesired As Long, _
                                       phkResult As Long) As Long

Private Declare Function RegSetValueExStr Lib "advapi32.dll" _
                                          Alias "RegSetValueExA" _
                                          (ByVal hKey As Long, ByVal lpValueName As String, _
                                           ByVal Reserved As Long, ByVal dwType As Long, _
                                           ByVal lpData As String, ByVal cbData As Long) As Long    ' Note that if you declare the lpData parameter as String, you must pass it By Value.

Private Declare Function RegSetValueExLng Lib "advapi32.dll" _
                                          Alias "RegSetValueExA" _
                                          (ByVal hKey As Long, ByVal lpValueName As String, _
                                           ByVal Reserved As Long, ByVal dwType As Long, _
                                           lpData As Long, ByVal cbData As Long) As Long      ' Note that if you declare the lpData parameter as String, you must pass it By Value.

Private Declare Function RegSetValueExByt Lib "advapi32.dll" _
                                          Alias "RegSetValueExA" _
                                          (ByVal hKey As Long, ByVal lpValueName As String, _
                                           ByVal Reserved As Long, ByVal dwType As Long, _
                                           lpData As Byte, ByVal cbData As Long) As Long      ' Note that if you declare the lpData parameter as String, you must pass it By Value.

Sub FileExtAssociation(sExt As String, sAppName As String, sAppFullNameFile As String)
    Dim OpenKeyHdl As Long
    Dim lRet As Long
    Dim SecurAttr As SECURITY_ATTRIBUTES

    'Create root extension subkey (.xxx)
    If GetRegValue(HKEY_CLASSES_ROOT, sExt, "", False) = "Error" Then
        RegCreateKeyEx HKEY_CLASSES_ROOT, sExt, _
                       0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                       KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
        RegCloseKey OpenKeyHdl
    End If

    'Create root Application subkey about file extension (AppNameFile subkey)
    If GetRegValue(HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", "", False) = "Error" Then
        RegCreateKeyEx HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", _
                       0&, vbNullString, REG_OPTION_NON_VOLATILE, _
                       KEY_ALL_ACCESS, SecurAttr, OpenKeyHdl, lRet
        RegCloseKey OpenKeyHdl
    End If

    'Set open command value at AppNameFile subkey
    SetKeyValue HKEY_CLASSES_ROOT, sAppName & "File\shell\open\command", "", REG_SZ, """" & sAppFullNameFile & """" & " %1"

    'Define a description for the extension file as default value at AppNameFile subkey.
    SetKeyValue HKEY_CLASSES_ROOT, sAppName & "File", "", REG_SZ, sAppName & " File"

    'Set default value at extension subkey to look for commands at AppNameFile subkey
    SetKeyValue HKEY_CLASSES_ROOT, sExt, "", REG_SZ, sAppName & "File"

End Sub

Function SetValueEx(ByVal hKey As Long, _
                    sValueName As String, _
                    lType As Long, _
                    vlpData As Variant) As Long

    Dim blpData() As Byte
    Dim llpData As Long
    Dim slpData As String

    Select Case lType
    Case REG_BINARY
        blpData = vlpData
        SetValueEx = RegSetValueExStr(hKey, _
                                      sValueName, _
                                      0&, _
                                      lType, _
                                      blpData(0), _
                                      UBound(blpData) - LBound(blpData) - 1)

    Case REG_SZ
        slpData = vlpData & Chr$(0)
        SetValueEx = RegSetValueExStr(hKey, _
                                      sValueName, _
                                      0&, _
                                      lType, _
                                      slpData, _
                                      VBA.Strings.Len(slpData))

    Case REG_DWORD
        llpData = vlpData
        SetValueEx = RegSetValueExLng(hKey, _
                                      sValueName, _
                                      0&, _
                                      lType, _
                                      llpData, _
                                      4)
    End Select
End Function

Sub SetKeyValue(lKey As Long, sSubKey As String, _
                sValueName As String, lType As Long, vValue As Variant)
    Dim OpenKeyHdl As Long

    'open the key
    RegOpenKeyEx lKey, sSubKey, 0, KEY_ALL_ACCESS, OpenKeyHdl

    'Set the value
    SetValueEx OpenKeyHdl, sValueName, lType, vValue

    'Close the key
    RegCloseKey OpenKeyHdl

End Sub

'Get Registry Value, Arguments:
'1 - Reg Key (Ex.: HKEY_LOCAL_MACHINE),
'2 - Reg SubKey (Ex.: "Software\Microsoft\Windows\CurrentVersion"),
'3 - Name of Value (Ex.:"ProgramFilesDir" or "" for default)
'4 - Convert to text like written in reg files (*.reg)
Function GetRegValue(lKey As Long, sSubKey As String, sValueName As String, ConvRegText)
    Dim sRet As String * 255                               'Fixed-length strings
    Dim lRet As Long
    Dim OpenKeyHdl As Long
    Dim lType As Long
    Dim lLen As Long
    Dim sDataRet As String
    Dim lDataRet As Long
    Dim abDataRet() As Byte
    Dim i As Integer
    Dim BrkLine As Long

    lRet = RegOpenKeyEx(lKey, sSubKey, 0, KEY_QUERY_VALUE, OpenKeyHdl)
    If lRet <> 0 And IsWin64bit Then lRet = RegOpenKeyEx(lKey, sSubKey, 0, KEY_QUERY_VALUE + KEY_WOW64_64KEY, OpenKeyHdl)    'Se falhar na procura pelo de 32-bit, tenta ver se tem o de 64-bit. More info about 32 rodando em 64 em http://msdn.microsoft.com/en-us/library/aa384129(v=VS.85).aspx

    lRet = RegQueryValueExLng(OpenKeyHdl, sValueName, 0&, lType, 0&, lLen)
    If lRet And lRet <> ERROR_MORE_DATA Then
        RegCloseKey OpenKeyHdl
        GetRegValue = "Error"
        Exit Function
    End If

    Select Case lType
    Case REG_DWORD
        lRet = RegQueryValueExLng(OpenKeyHdl, sValueName, _
                                  0&, lType, lDataRet, lLen)
        GetRegValue = CLng(lDataRet)

        If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=dword:" & VBA.Strings.Left("00000000", 8 - VBA.Strings.Len(Hex(GetRegValue))) & Hex(GetRegValue)

    Case REG_SZ
        sDataRet = String$(lLen - 1, 0)
        lRet = RegQueryValueExStr(OpenKeyHdl, sValueName, _
                                  0&, lType, sDataRet, lLen)
        GetRegValue = sDataRet

        If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=" & GetRegValue

    Case Else                                          'REG_BINARY and others
        ReDim abDataRet(lLen)
        lRet = RegQueryValueExByt(OpenKeyHdl, sValueName, _
                                  0&, lType, abDataRet(0), lLen)
        GetRegValue = abDataRet

        If ConvRegText Then
            If lType = REG_BINARY Then
                GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=hex:"
                sDataRet = String$(lLen, 0)
                lRet = RegQueryValueExStr(OpenKeyHdl, sValueName, 0&, lType, sDataRet, lLen)
                BrkLine = VBA.Strings.Len(GetRegValue)
                For i = 1 To lLen
                    If BrkLine >= 77 Then
                        BrkLine = 2
                        GetRegValue = GetRegValue & "\" & Chr(10) & "  "
                    End If
                    GetRegValue = GetRegValue _
                                & IIf(VBA.Strings.Len(Hex(Asc(VBA.Strings.Mid(sDataRet, i, 1)))) = 1, "0", "") _
                                & Hex(Asc(VBA.Strings.Mid(sDataRet, i, 1))) & ","
                    BrkLine = BrkLine + 3
                Next
            Else
                If ConvRegText Then GetRegValue = """" & IIf(sValueName = "", "@", sValueName) & """=" & GetRegValue
            End If
        End If
    End Select
    RegCloseKey OpenKeyHdl
End Function







Attribute VB_Name = "Mod8CloseApp"
Option Explicit                                            'Igual
Public Declare Function apiFindWindow Lib "user32" Alias "FindWindowA" (ByVal strClass As String, ByVal lpWindow As String) As Long
Private Declare Function apiSendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, lParam As Long) As Long
Public Declare Function apiSetForegroundWindow Lib "user32" Alias "SetForegroundWindow" (ByVal hWnd As Long) As Long
Public Declare Function apiShowWindow Lib "user32" Alias "ShowWindow" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
Private Declare Function apiIsIconic Lib "user32" Alias "IsIconic" (ByVal hWnd As Long) As Long
Private Declare Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long

'====== APIs for terminate process by PID or hWhd. Code get at http://en.allexperts.com/q/Visual-Basic-1048/Kill-Process-VB-its-1.htm
Private Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hWnd As Long, lpdwProcessId As Long) As Long
Private Declare Function AdjustTokenPrivileges Lib "advapi32.dll" (ByVal TokenHandle As Long, ByVal DisableAllPrivileges As Long, NewState As TOKEN_PRIVILEGES, ByVal BufferLength As Long, PreviousState As TOKEN_PRIVILEGES, ReturnLength As Long) As Long
Private Declare Function OpenProcessToken Lib "advapi32.dll" (ByVal ProcessHandle As Long, ByVal DesiredAccess As Long, TokenHandle As Long) As Long
Private Declare Function LookupPrivilegeValue Lib "advapi32.dll" Alias "LookupPrivilegeValueA" (ByVal lpSystemName As String, ByVal lpName As String, lpLuid As LUID) As Long
Private Declare Function GetCurrentProcess Lib "kernel32" () As Long

Private Type LUID
    LowPart As Long
    HighPart As Long
End Type

Private Type LUID_AND_ATTRIBUTES
    pLuid As LUID
    Attributes As Long
End Type

Private Type TOKEN_PRIVILEGES
    PrivilegeCount As Long
    TheLuid As LUID
    Attributes As Long
End Type

'====== APIs for terminate process by Image
Private Declare Function CreateToolhelpSnapshot Lib "kernel32" Alias "CreateToolhelp32Snapshot" (ByVal lFlags As Long, ByVal lProcessId As Long) As Long
Private Declare Function ProcessFirst Lib "kernel32" Alias "Process32First" (ByVal hSnapShot As Long, uProcess As PROCESSENTRY32) As Long
Private Declare Function ProcessNext Lib "kernel32" Alias "Process32Next" (ByVal hSnapShot As Long, uProcess As PROCESSENTRY32) As Long
'Private Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
'Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
'Private Declare Sub CloseHandle Lib "kernel32" (ByVal hPass As Long)

Private Type PROCESSENTRY32
    dwSize As Long
    cntUsage As Long
    th32ProcessID As Long
    th32DefaultHeapID As Long
    th32ModuleID As Long
    cntThreads As Long
    th32ParentProcessID As Long
    pcPriClassBase As Long
    dwFlags As Long
    szExeFile As String * 260
End Type
Const sApplication As String = "Outlook"

'====== Close app via automation (Normalmente visible e rodando)

Function CloseAllApp(bAlertOnly As Boolean, sAppImgName As String)
    Dim mWnd As Long
    Const WM_CLOSE = &H10
    Const GW_HWNDFIRST = 0
ReTry:
    CloseAllApp = True
    Do While fIsAppRunning(False, mWnd)  'Diferente dos toEXEs, aqui n|fffd|o vou ativar o Outlook e vou adaptar a mensagem abaixo,
        If Not bAlertOnly Then apiSendMessage mWnd, WM_CLOSE, 0, ByVal 0&
        MyWait 0.5
        If GetWindow(mWnd, GW_HWNDFIRST) <> 0 Then Exit Do
    Loop
    If fIsAppRunning(False, mWnd) Then
        UnhideApp
        If IsPortg Then
            Msg1 = "Por favor, feche o " & sApplication & " e acione OK para continuar." & vbCrLf & vbCrLf & _
                    "     Obs.: " & vbCrLf & _
                    "     - Ao acionar OK, se for encontrado algum " & sApplication & " ainda rodando oculto ou n|fffd|o, ser|fffd|o feitas tentativas para fechar questionando sobre dados por salvar." & vbCrLf & _
                    "     - Ao acionar Cancelar, vai continuar mesmo com o " & sApplication & " rodando, mas o texto da mensagem n|fffd|o ir|fffd| aparecer, ent|fffd|o voc|fffd| ter|fffd| que colar manualmente usando Ctrl + V." & IIf(InStr(1, EmlEmail, ";") = 0, "", " E ainda inserir um ; no final do campo 'Para' para o Outlook reconhecer a lista de e-mails informada.") & vbCrLf & _
                    "     Dica! Se estiver dif|fffd|cil para fechar, baixe a tecla Shift para for|fffd|ar fechamento sem questionar."
            Msg2 = "Encontrado " & sApplication & " Rodando!"
        Else
            Msg1 = "Please, close the " & sApplication & " and action OK to continue." & vbCrLf & vbCrLf & _
                    "     Notes:" & vbCrLf & _
                    "     - When action OK, if some hide or visible " & sApplication & " were found running, it will be done attempts to close questioning about data to save." & vbCrLf & _
                    "     - When action Cancel, it will continue even with " & sApplication & " running, but the message text will not appear, so you will have to paste it manually using Ctrl V." & IIf(InStr(1, EmlEmail, ";") = 0, "", " And also insert a ; at the end of the 'To' field for Outlook to recognize the informed email list.") & vbCrLf & _
                    "     Tip! If hard to close, hold down Shift key to force closing without question."
            Msg2 = "Found " & sApplication & " Running!"
        End If
        If MyMsgBox(Msg1, 2, Msg2, vbModeless) = 1 Then
            bAlertOnly = False
            If ShiftDown Then                              'Antes CloseAllAppProcByImgName era chamada s|fffd| depois deste por seguran|fffd|a, mas h|fffd| situa|fffd||fffd|es em que este n|fffd|o consegue exibir a janela para usu|fffd|rio fechar e n|fffd|o fecha tudo retornando False ao ser cancelado ap|fffd|s tentativas. Agora o usu|fffd|rio com Shift pode chamar aqui mesmo e for|fffd|ar fechamento.
                Do While ShiftDown: Loop
                CloseAllAppProcByImgName sAppImgName
            End If
            GoTo ReTry
        End If
        CloseAllApp = False
    End If
End Function

Function fIsAppRunning(fActivate As Boolean, ByRef lHandle As Long) As Boolean
    Dim lngH As Long, lngX As Long, lngTmp As Long
    Const WM_USER = 1024
    On Error GoTo ErrorHandler
    fIsAppRunning = False

    Select Case sApplication
        Case "Excel"
            lngH = apiFindWindow("XLMain", vbNullString)
        Case "PowerPoint"
            lngH = apiFindWindow("PP97FrameClass", vbNullString)    'KB288902 informa ClassNames at|fffd| o 2007
            If lngH = 0 Then lngH = apiFindWindow("PP9FrameClass", vbNullString)
            If lngH = 0 Then lngH = apiFindWindow("PP10FrameClass", vbNullString)
            If lngH = 0 Then lngH = apiFindWindow("PP11FrameClass", vbNullString)
            If lngH = 0 Then lngH = apiFindWindow("PP12FrameClass", vbNullString)
            If lngH = 0 Then lngH = apiFindWindow("PPTFrameClass", vbNullString)
        Case "Word"
            lngH = apiFindWindow("OpusApp", vbNullString)
        Case "Access"
            lngH = apiFindWindow("OMain", vbNullString)
        Case "Outlook"
            lngH = apiFindWindow("rctrl_renwnd32", vbNullString)
    End Select

    If lngH <> 0 Then
        apiSendMessage lngH, WM_USER + 18, 0, 0
        lngX = apiIsIconic(lngH)
        If lngX <> 0 Then
            lngTmp = apiShowWindow(lngH, 1)
        End If
        If fActivate Then
            lngTmp = apiSetForegroundWindow(lngH)
        End If
        fIsAppRunning = True
        lHandle = lngH
    End If
    Exit Function
ErrorHandler:
    fIsAppRunning = False
End Function

Sub UnhideApp()
    Dim AppObj As Object
    On Error Resume Next
    Set AppObj = GetObject(, sApplication & ".Application")
    AppObj.Visible = True
End Sub



'====== Terminate process by PID or hWhd (Hidden, lock, or orphan when lost class and windows handle)

'Purpose   :    Terminates a process given a process ID or a the handle to a form. (Like pressing End Task In Task Mananger)
'Inputs    :    [lProcessID]          The process ID (or PID) to terminate.
'          [lHwndWindow]          Any window handle belonging to the application.
'Outputs   :    Returns True on success.
'Author    :    Andrew Baker (http://www.vbusers.com/code/codeget.asp?ThreadID=344&PostID=1&NumReplies=0)
'Date      :    28/04/2001
'Notes     :    In WIN NT, click the "Processes" tab in the "Task Manager"
'          to see the process ID (or PID) for an application.
'          Must specify either lHwndWindow or lProcessID.
'          Equivalent to pressing Alt+Ctrl+Del then "End Task"

Function ProcessTerminate(Optional lProcessId As Long, Optional lHwndWindow As Long) As Boolean
    Dim lhwndProcess As Long
    Dim lExitCode As Long
    Dim lRetVal As Long
    Dim lhThisProc As Long
    Dim lhTokenHandle As Long
    Dim tLuid As LUID
    Dim tTokenPriv As TOKEN_PRIVILEGES, tTokenPrivNew As TOKEN_PRIVILEGES
    Dim lBufferNeeded As Long

    Const PROCESS_ALL_ACCESS = &H1F0FFF, PROCESS_TERMINATE = &H1
    Const ANYSIZE_ARRAY = 1, TOKEN_ADJUST_PRIVILEGES = &H20
    Const TOKEN_QUERY = &H8, SE_DEBUG_NAME As String = "SeDebugPrivilege"
    Const SE_PRIVILEGE_ENABLED = &H2

    On Error Resume Next
    If lHwndWindow Then
        'Get the process ID from the window handle
        lRetVal = GetWindowThreadProcessId(lHwndWindow, lProcessId)
    End If

    If lProcessId Then
        'Give Kill permissions to this process
        lhThisProc = GetCurrentProcess

        OpenProcessToken lhThisProc, TOKEN_ADJUST_PRIVILEGES Or TOKEN_QUERY, lhTokenHandle
        LookupPrivilegeValue "", SE_DEBUG_NAME, tLuid
        'Set the number of privileges to be change
        tTokenPriv.PrivilegeCount = 1
        tTokenPriv.TheLuid = tLuid
        tTokenPriv.Attributes = SE_PRIVILEGE_ENABLED
        'Enable the kill privilege in the access token of this process
        AdjustTokenPrivileges lhTokenHandle, False, tTokenPriv, Len(tTokenPrivNew), tTokenPrivNew, lBufferNeeded

        'Open the process to kill
        lhwndProcess = OpenProcess(PROCESS_TERMINATE, 0, lProcessId)

        If lhwndProcess Then
            'Obtained process handle, kill the process
            ProcessTerminate = CBool(TerminateProcess(lhwndProcess, lExitCode))
            Call CloseHandle(lhwndProcess)
        End If
    End If
    On Error GoTo 0
End Function



'====== Terminate process by Image Name (Hidden, lock, or orphan when lost class and windows handle)
Public Sub CloseAllAppProcByImgName(sAppImgName As String)
    Dim lPID As Long
    Dim lRet As Long
    Dim i As Long
    Do
        lPID = GetProcessId(sAppImgName)                   'Process image name argument
        If lPID <> 0 Then
            'lRet = TerminateProcess(OpenProcess(&H1, 0, lPID), 0)
            lRet = ProcessTerminate(lPID)                  'J|fffd| existia e talvez tenha mais controle e direitos do que chamar API direto
            If lRet = 0 Then i = i + 1: DoEvents
        End If
    Loop While lPID <> 0 And i < 100
End Sub

Private Function GetProcessId(sImgName As String) As Long
    Dim hSnapShot As Long, pe32 As PROCESSENTRY32
    hSnapShot = CreateToolhelpSnapshot(2, ByVal 0)
    pe32.dwSize = Len(pe32)
    ProcessFirst hSnapShot, pe32
    Do
        If InStr(1, pe32.szExeFile, sImgName & vbNullChar, vbTextCompare) = 1 Then
            GetProcessId = pe32.th32ProcessID
            Exit Do
        End If
    Loop While ProcessNext(hSnapShot, pe32)
    CloseHandle hSnapShot
End Function




Attribute VB_Name = "ModMAPIvb32"
'**************************************************************************
' Visual Basic declaration for the MAPI functions.
'
' This file can be loaded into the global module.
'**************************************************************************

'***************************************************
'   MAPI Message holds information about a message
'***************************************************

Type MAPIMessage
    Reserved As Long
    Subject As String
    NoteText As String
    MessageType As String
    DateReceived As String
    ConversationID As String
    Flags As Long
    RecipCount As Long
    FileCount As Long
End Type


'************************************************
'   MAPIRecip holds information about a message
'   originator or recipient
'************************************************

Type MapiRecip
    Reserved As Long
    RecipClass As Long
    Name As String    'myemail@server.com (Don't forget to set RecipCount=1 in Type MAPIMessage)
    Address As String
    EIDSize As Long
    EntryID As String
End Type


'******************************************************
'   MapiFile holds information about file attachments
'******************************************************

Type MapiFile
    Reserved As Long
    Flags As Long
    Position As Long
    PathName As String    'Fullname (Path and name of a file to attached. Don't forget to set FileCount=1 in Type MAPIMessage)
    FileName As String    'Any name that you want to show on email
    FileType As String
End Type


'***************************
'   FUNCTION Declarations
'***************************

Declare Function MAPILogon Lib "MAPI32.DLL" (ByVal UIParam&, ByVal User$, _
                                             ByVal Password$, ByVal Flags&, ByVal Reserved&, Session&) As Long
Declare Function MAPILogoff Lib "MAPI32.DLL" (ByVal Session&, ByVal _
                                                              UIParam&, ByVal Flags&, ByVal Reserved&) As Long
Declare Function BMAPIReadMail Lib "MAPI32.DLL" (lMsg&, nRecipients&, _
                                                 nFiles&, ByVal Session&, ByVal UIParam&, MessageID$, ByVal Flag&, ByVal _
                                                                                                                   Reserved&) As Long
Declare Function BMAPIGetReadMail Lib "MAPI32.DLL" (ByVal lMsg&, Message As _
                                                                 MAPIMessage, Recip() As MapiRecip, File() As MapiFile, Originator As _
                                                                                                                        MapiRecip) As Long
Declare Function MAPIFindNext Lib "MAPI32.DLL" Alias "BMAPIFindNext" (ByVal _
                                                                      Session&, ByVal UIParam&, MsgType$, SeedMsgID$, ByVal Flag&, ByVal _
                                                                                                                                   Reserved&, MsgID$) As Long
Declare Function MAPISendDocuments Lib "MAPI32.DLL" (ByVal UIParam&, ByVal _
                                                                     DelimStr$, ByVal FilePaths$, ByVal FileNames$, ByVal Reserved&) As Long
Declare Function MAPIDeleteMail Lib "MAPI32.DLL" (ByVal Session&, ByVal _
                                                                  UIParam&, ByVal MsgID$, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPISendMail Lib "MAPI32.DLL" Alias "BMAPISendMail" (ByVal _
                                                                      Session&, ByVal UIParam&, Message As MAPIMessage, Recipient() As MapiRecip, _
                                                                      File() As MapiFile, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPISaveMail Lib "MAPI32.DLL" Alias "BMAPISaveMail" (ByVal _
                                                                      Session&, ByVal UIParam&, Message As MAPIMessage, Recipient() As MapiRecip, _
                                                                      File() As MapiFile, ByVal Flags&, ByVal Reserved&, MsgID$) As Long
Declare Function BMAPIAddress Lib "MAPI32.DLL" (lInfo&, ByVal Session&, _
                                                ByVal UIParam&, Caption$, ByVal nEditFields&, Label$, nRecipients&, Recip() _
                                                                                                                    As MapiRecip, ByVal Flags&, ByVal Reserved&) As Long
Declare Function BMAPIGetAddress Lib "MAPI32.DLL" (ByVal lInfo&, ByVal _
                                                                 nRecipients&, Recipients() As MapiRecip) As Long
Declare Function MAPIDetails Lib "MAPI32.DLL" Alias "BMAPIDetails" (ByVal _
                                                                    Session&, ByVal UIParam&, Recipient As MapiRecip, ByVal Flags&, ByVal _
                                                                                                                                    Reserved&) As Long
Declare Function MAPIResolveName Lib "MAPI32.DLL" Alias "BMAPIResolveName" _
                                 (ByVal Session&, ByVal UIParam&, ByVal UserName$, ByVal Flags&, ByVal _
                                                                                                 Reserved&, Recipient As MapiRecip) As Long



'**************************
'   CONSTANT Declarations
'**************************
'

Global Const SUCCESS_SUCCESS = 0
Global Const MAPI_USER_ABORT = 1
Global Const MAPI_E_USER_ABORT = MAPI_USER_ABORT
Global Const MAPI_E_FAILURE = 2
Global Const MAPI_E_LOGIN_FAILURE = 3
Global Const MAPI_E_LOGON_FAILURE = MAPI_E_LOGIN_FAILURE
Global Const MAPI_E_DISK_FULL = 4
Global Const MAPI_E_INSUFFICIENT_MEMORY = 5
Global Const MAPI_E_BLK_TOO_SMALL = 6
Global Const MAPI_E_TOO_MANY_SESSIONS = 8
Global Const MAPI_E_TOO_MANY_FILES = 9
Global Const MAPI_E_TOO_MANY_RECIPIENTS = 10
Global Const MAPI_E_ATTACHMENT_NOT_FOUND = 11
Global Const MAPI_E_ATTACHMENT_OPEN_FAILURE = 12
Global Const MAPI_E_ATTACHMENT_WRITE_FAILURE = 13
Global Const MAPI_E_UNKNOWN_RECIPIENT = 14
Global Const MAPI_E_BAD_RECIPTYPE = 15
Global Const MAPI_E_NO_MESSAGES = 16
Global Const MAPI_E_INVALID_MESSAGE = 17
Global Const MAPI_E_TEXT_TOO_LARGE = 18
Global Const MAPI_E_INVALID_SESSION = 19
Global Const MAPI_E_TYPE_NOT_SUPPORTED = 20
Global Const MAPI_E_AMBIGUOUS_RECIPIENT = 21
Global Const MAPI_E_AMBIG_RECIP = MAPI_E_AMBIGUOUS_RECIPIENT
Global Const MAPI_E_MESSAGE_IN_USE = 22
Global Const MAPI_E_NETWORK_FAILURE = 23
Global Const MAPI_E_INVALID_EDITFIELDS = 24
Global Const MAPI_E_INVALID_RECIPS = 25
Global Const MAPI_E_NOT_SUPPORTED = 26

Global Const MAPI_ORIG = 0
Global Const MAPI_TO = 1
Global Const MAPI_CC = 2
Global Const MAPI_BCC = 3


'***********************
'   FLAG Declarations
'***********************

'* MAPILogon() flags *

Global Const MAPI_LOGON_UI = &H1
Global Const MAPI_NEW_SESSION = &H2
Global Const MAPI_FORCE_DOWNLOAD = &H1000

'* MAPILogoff() flags *

Global Const MAPI_LOGOFF_SHARED = &H1
Global Const MAPI_LOGOFF_UI = &H2

'* MAPISendMail() flags *

Global Const MAPI_DIALOG = &H8
Global Const MAPI_NO_DIALOG = &H0

'* MAPIFindNext() flags *

Global Const MAPI_UNREAD_ONLY = &H20
Global Const MAPI_GUARANTEE_FIFO = &H100

'* MAPIReadMail() flags *

Global Const MAPI_ENVELOPE_ONLY = &H40
Global Const MAPI_PEEK = &H80
Global Const MAPI_BODY_AS_FILE = &H200
Global Const MAPI_SUPPRESS_ATTACH = &H800

'* MAPIDetails() flags *

Global Const MAPI_AB_NOMODIFY = &H400

'* Attachment flags *

Global Const MAPI_OLE = &H1
Global Const MAPI_OLE_STATIC = &H2

'* MapiMessage flags *

Global Const MAPI_UNREAD = &H1
Global Const MAPI_RECEIPT_REQUESTED = &H2
Global Const MAPI_SENT = &H4

Function CopyFiles(MfIn As MapiFile, MfOut As MapiFile) As Long

    MfOut.FileName = MfIn.FileName
    MfOut.PathName = MfIn.PathName
    MfOut.Reserved = MfIn.Reserved
    MfOut.Flags = MfIn.Flags
    MfOut.Position = MfIn.Position
    MfOut.FileType = MfIn.FileType
    CopyFiles = 1&

End Function

Function CopyRecipient(MrIn As MapiRecip, MrOut As MapiRecip) As Long

    MrOut.Name = MrIn.Name
    MrOut.Address = MrIn.Address
    MrOut.EIDSize = MrIn.EIDSize
    MrOut.EntryID = MrIn.EntryID
    MrOut.Reserved = MrIn.Reserved
    MrOut.RecipClass = MrIn.RecipClass

    CopyRecipient = 1&

End Function

Function MAPIAddress(Session As Long, UIParam As Long, Caption As String, _
                     nEditFields As Long, Label As String, nRecipients As Long, Recips() As _
                                                                                MapiRecip, Flags As Long, Reserved As Long) As Long


    Dim Info&
    Dim rc&
    Dim nRecips As Long

    ReDim Rec(0 To nRecipients) As MapiRecip
    ' Use local variable since BMAPIAddress changes the passed value
    nRecips = nRecipients

    '*****************************************************
    ' Copy input recipient structure into local
    ' recipient structure used as input to BMAPIAddress
    '*****************************************************

    For i = 0 To nRecipients - 1
        Ignore& = CopyRecipient(Recips(i), Rec(i))
    Next i

    rc& = BMAPIAddress(Info&, Session&, UIParam&, Caption$, nEditFields&, _
                       Label$, nRecips&, Rec(), Flags, 0&)

    If (rc& = SUCCESS_SUCCESS) Then

        '**************************************************
        ' New recipients are now in the memory referenced
        ' by Info (HANDLE). nRecipients is the number of
        ' new recipients.
        '**************************************************
        nRecipients = nRecips     ' Copy back to parameter

        If (nRecipients > 0) Then
            ReDim Rec(0 To nRecipients - 1) As MapiRecip
            rc& = BMAPIGetAddress(Info&, nRecipients&, Rec())

            '*********************************************
            ' Copy local recipient structure to
            ' recipient structure passed as procedure
            ' parameter. This is necessary because
            ' VB doesn't seem to work properly when
            ' the procedure parameter gets passed
            ' directory to the BMAPI.DLL Address routine
            '*********************************************

            ReDim Recips(0 To nRecipients - 1) As MapiRecip

            For i = 0 To nRecipients - 1
                Ignore& = CopyRecipient(Rec(i), Recips(i))
            Next i

        End If

    End If

    MAPIAddress = rc&

End Function

Function MAPIReadMail(Session As Long, UIParam As Long, MessageID As _
                                                        String, Flags As Long, Reserved As Long, Message As MAPIMessage, Orig As _
                                                                                                                         MapiRecip, RecipsOut() As MapiRecip, FilesOut() As MapiFile) As Long

    Dim Info&
    Dim nFiles&, nRecips&

    rc& = BMAPIReadMail(Info&, nRecips, nFiles, Session, 0, MessageID, _
                        Flags, Reserved)

    If (rc& = SUCCESS_SUCCESS) Then

        'Message is now read into the handles array. We have to redim the
        'arrays and read the information in.

        If (nRecips = 0) Then nRecips = 1
        If (nFiles = 0) Then nFiles = 1

        ReDim Recips(0 To nRecips - 1) As MapiRecip
        ReDim Files(0 To nFiles - 1) As MapiFile

        rc& = BMAPIGetReadMail(Info&, Message, Recips(), Files(), Orig)

        '*******************************************
        ' Copy Recipient and File structures from
        ' Local structures to those passed as
        ' parameters
        '*******************************************

        ReDim FilesOut(0 To nFiles - 1) As MapiFile
        ReDim RecipsOut(0 To nRecips - 1) As MapiRecip

        For i = 0 To nRecips - 1
            Ignore& = CopyRecipient(Recips(i), RecipsOut(i))
        Next i

        For i = 0 To nFiles - 1
            Ignore& = CopyFiles(Files(i), FilesOut(i))
        Next i

    End If

    MAPIReadMail = rc&

End Function


Attribute VB_Name = "ModMyMsgBox"
Option Explicit
Public Const LOCALE_USER_DEFAULT& = &H400
Public Const LOCALE_SENGLANGUAGE = &H1001                  'English name of language
Public Const LOCALE_SLANGUAGE = &H2                        'localized name of language
Public Const LOCALE_SLIST = &HC                            '  list item separator
Public Const LOCALE_SDECIMAL = &HE                         '  decimal separator
Public Const LOCALE_STHOUSAND = &HF                        '  thousand separator
Public Const LOCALE_ICOUNTRY = &H5                         '  country code
Private Declare Function apiGetLocaleInfo Lib "kernel32" _
                                          Alias "GetLocaleInfoA" (ByVal Locale As Long, _
                                                                  ByVal LCType As Long, ByVal lpLCData As String, _
                                                                  ByVal cchData As Long) As Long
Private Declare Function GetVersion Lib "kernel32" () As Long
Declare Function WNetGetUser Lib "mpr.dll" _
                             Alias "WNetGetUserA" (ByVal lpName As String, _
                                                   ByVal lpUserName As String, lpnLength As Long) As Long

Private Declare Function ShellExecute Lib "shell32.dll" _
                                      Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, _
                                                             ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, _
                                                             ByVal nShowCmd As Long) As Long
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Public BotAcionado As Integer
Public IsPortg As Boolean
Public Msg1 As String
Public Msg2 As String

Public Function MyMsgBox(sPrompt As String, lBut As Long, sTitle As String, Optional Xpos As Long, Optional Ypos As Long)
    With FormMyMsgBox
        .Caption = sTitle
        .Alert_Tb = sPrompt
        .lBut = lBut
        .Email_Lb.Caption = IIf(IsPortg, "E-mail", "Email")
        .Email_Lb.ControlTipText = "orlando@cpap.com.br"
        .EmailSubj = IIf(IsPortg, "Informa|fffd||fffd|es sobre o ", "Information about ") & sAddInNameByApp & IIf(bIsCOMAddin, " (COM add-in)", " (Add-in)")
        .HomePage_Lb.Caption = IIf(IsPortg, "Ajuda", "Help")
        .HomePage_Lb.ControlTipText = "http://cpap.com.br/orlando/"
        .HomePageUrl = "http://cpap.com.br/orlando/" & sAddInNameByApp & IIf(IsPortg, "Mais.asp?IdC=Ajuda", "More.asp?IdC=Help")
        .Xpos = Xpos * Twips    'Twips usa-se em COM Add-in, essa a |fffd|nica diferen|fffd|a, pois as dimens|fffd|es do formul|fffd|rio |fffd| em twip, mas as posi|fffd||fffd|es dos controles continuma em pontos
        .Ypos = Ypos * Twips
        .Show 1   '|fffd| preciso usar em COM add-in
    End With
    Unload FormMyMsgBox
    MyMsgBox = BotAcionado
End Function

Sub MyWait(PauseSeg As Double)
    Dim Start
    Start = Timer
    Do While Timer < Start + PauseSeg
        DoEvents
        Sleep 1    'Com isso o CPU Usage cai de 100% para seus 0 ou 2% normal
    Loop
End Sub

Function gLocInfo(vType As Long) As String
    Dim vStr As String, vLng As Long
    Dim ret As Long
    vStr = String$(255, 0)
    vLng = 255 - 1
    ret = apiGetLocaleInfo(LOCALE_USER_DEFAULT, vType, vStr, vLng)
    If ret <> 0 Then
        gLocInfo = Left$(vStr, ret - 1)
    End If
End Function

Function SendEMailByURL(oCtrl As Object, EmailUrl As String, Subj As String, Msg As String, bCtrlError As Boolean) As Boolean
    Dim URL As String
    Dim ret As Long

    If Not oCtrl Is Nothing Then
        If oCtrl.MousePointer = fmMousePointerHourGlass Then Exit Function
        oCtrl.MousePointer = fmMousePointerHourGlass
        oCtrl.ForeColor = &H80FF&
        DoEvents
    End If

    If Subj <> "" Then                                     'Indica para montar uma URL para email
        If appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word" Then _
 appHostApp.StatusBar = IIf(IsPortg, "Preparando E-mail. Aguarde...", "Preparing Email. Wait...")

        '& in Hex
        Subj = MyReplace(Subj, "&", "%26")
        Msg = MyReplace(Msg, "&", "%26")

        'Spaces in Hex
        Subj = MyReplace(Subj, " ", "%20")
        Msg = MyReplace(Msg, " ", "%20")

        'CRLF in Hex
        Msg = MyReplace(Msg, vbCrLf, "%0D%0A")

        URL = "mailto:" & EmailUrl & "?subject=" & Subj & "&body=" & Msg

        'Launch Start command with URL (Falha no Win2000)
        'Ret = Shell(VBA.Strings.left("Start " & URL, 460), vbHide)
    Else
        URL = EmailUrl
    End If

    If Not bCtrlError And InStr(1, URL, "#") = 0 Then
        'A vantagem do ShellExecute |fffd| que no m|fffd|todo FollowHyperlink a lingua do Navegador n|fffd|o |fffd| enviada
        'e tem que ter documento aberto. Vou usar FollowHyperlink s|fffd| quando precisar controlar erro e
        'se houver bookmark
        ShellExecute 0&, vbNullString, VBA.Strings.Left(URL, 457), vbNullString, vbNullString, vbNormalFocus
    Else
        Dim sBookmark As String
        If InStr(1, URL, "#") = 0 Then
            sBookmark = ""
        Else
            sBookmark = VBA.Strings.Mid(URL, InStr(1, URL, "#"))
            URL = VBA.Strings.Left(URL, InStr(1, URL, "#") - 1)
        End If

        On Error Resume Next
        Select Case appHostApp.Name
        Case "Microsoft Excel"
            If appHostApp.ActiveWorkbook Is Nothing Then appHostApp.Workbooks.Add
            appHostApp.ActiveWorkbook.FollowHyperlink VBA.Strings.Left(URL, 457), sBookmark, True       'DifAppMet
        Case "Microsoft Word"
            If appHostApp.ActiveDocument Is Nothing Then appHostApp.Documents.Add
            appHostApp.ActiveDocument.FollowHyperlink VBA.Strings.Left(URL, 457), sBookmark, True
        Case "Microsoft PowerPoint"
            If appHostApp.ActivePresentation Is Nothing Then appHostApp.Presentations.Add
            appHostApp.ActivePresentation.FollowHyperlink VBA.Strings.Left(URL, 457), sBookmark, True
        Case "Microsoft Access"
            appHostApp.FollowHyperlink VBA.Strings.Left(URL, 457), sBookmark, True
        End Select
    End If
    If Err.Number = 0 Then MyWait 10
    If Subj <> "" And (appHostApp.Name = "Microsoft Excel" Or appHostApp.Name = "Microsoft Word") Then _
 appHostApp.StatusBar = False

    If Err.Number <> 0 Then MsgBox Err.Description
    If Not oCtrl Is Nothing Then oCtrl.MousePointer = fmMousePointerCustom
    SendEMailByURL = Err.Number = 0
    Err.Clear
End Function

Function MyReplace(vText As String, vTxtFind As String, vTxtRep As String)
'Word 6.0 VBA doesn't have Replace function
    Dim lPos As Long
    lPos = 1 - VBA.Strings.Len(vTxtRep)
vStart:
    lPos = InStr(lPos + VBA.Strings.Len(vTxtRep), vText, vTxtFind)
    If lPos = 0 Or vTxtFind = "" Then
        MyReplace = vText
        Exit Function
    End If
    vText = VBA.Strings.Left(vText, lPos - 1) & vTxtRep & VBA.Strings.Right(vText, VBA.Strings.Len(vText) - lPos - VBA.Strings.Len(vTxtFind) + 1)
    GoTo vStart
End Function

Function MySplit(ByVal sString As String, Optional sDelim As String, Optional lLimit As Long = -1, Optional bCompare As Long = 0) As Variant
'Excel 97 and Word6 haven't Split function
    Dim sSplitArr() As String
    Dim lPos As Long
    Dim i As Long
    Dim r As Long

    If sString = "" Or lLimit = 0 Then
        MySplit = Array()
        Exit Function
    End If

    If sDelim = "" Then
        ReDim Preserve sSplitArr(i)
        sSplitArr(i) = sString
    Else
        lPos = InStr(1, sString, sDelim, bCompare)
        If lPos = 0 Then
            ReDim Preserve sSplitArr(i)
            sSplitArr(i) = sString
        Else
            r = 2
            Do
                ReDim Preserve sSplitArr(i)
                If r > 1 Then
                    sSplitArr(i) = VBA.Strings.Left(sString, lPos - 1)
                    sString = VBA.Strings.Mid(sString, lPos + VBA.Strings.Len(sDelim))
                Else
                    sSplitArr(i) = sString
                    sString = ""
                End If
                lPos = InStr(1, sString, sDelim, bCompare)
                r = r - 1 - 1 * (lPos > 0)
                If lLimit <> -1 And i = lLimit - 1 Then
                    sSplitArr(i) = sSplitArr(i) & IIf(r > 0, sDelim & sString, "")
                    Exit Do
                End If
                i = i + 1
            Loop While r > 0
        End If
    End If
    MySplit = sSplitArr
End Function

Function EmlMsg() As String
    Dim WinVer As String
    Dim AppVer As String
    EmlMsg = ""
    EmlMsg = EmlMsg & IIf(IsPortg, "Prezado", "Dear") & " Orlando,"
    EmlMsg = EmlMsg & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Gostaria...", "I would like...")
    EmlMsg = EmlMsg & vbCrLf & vbCrLf & vbCrLf & vbCrLf
    EmlMsg = EmlMsg & IIf(IsPortg, "Atenciosamente,", "Regards,") & vbCrLf & vbCrLf & vbCrLf

    EmlMsg = EmlMsg & "___" & vbCrLf
    EmlMsg = EmlMsg & GetWinUserName & vbCrLf              'O acc e pp n|fffd|o tem appHostApp.UserName e Win user me parece mais

    Select Case appHostApp.Name
    Case "Microsoft Excel"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)    'DifAppMet
    Case "Microsoft Word"
        WinVer = appHostApp.System.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft PowerPoint"
        WinVer = appHostApp.OperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    Case "Microsoft Access"
        WinVer = GetOperatingSystem & " " & gLocInfo(LOCALE_SLANGUAGE)
    End Select

    AppVer = gLocInfo(LOCALE_ICOUNTRY)
    AppVer = IIf(AppVer = 1, "English", IIf(AppVer = 55, "Portugu|fffd|s", "Language " & AppVer))
    AppVer = appHostApp.Name & " " & dHostAppVer & " (" & AppVer & ")"
    EmlMsg = EmlMsg & WinVer & vbCrLf
    EmlMsg = EmlMsg & AppVer & vbCrLf
End Function

Public Function GetOperatingSystem() As String
    Dim Ver As Long, WinVer As Long
    Ver = GetVersion()
    WinVer = Ver And &HFFFF&
    'retrieve the windows version
    GetOperatingSystem = "Windows " & Format((WinVer Mod 256) + ((WinVer \ 256) / 100), "Fixed")
End Function

Function GetWinUserName() As String
    Dim vStr As String, ret As Long, lpName As String
    vStr = String$(255, 0)
    ret = WNetGetUser(lpName, vStr, 255)
    If ret = 0 Then GetWinUserName = Left$(vStr, InStr(vStr, Chr(0)) - 1)
End Function

Sub ActWbWinAppSDIBaseForm(Form_hWnd1 As Long)     'Necess|fffd|rio no Excel 15 sempre que ativar um Wb by code com form Modal.
    If dHostAppVer >= 11 + 1 + 2 + 1 And Form_hWnd1 <> 0 Then  'Basear o form na janela ativa do Excel.
        App_hWnd = appHostApp.hWnd    'Always get because in Excel 15 SDI each wb has its window with different handle.
        SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd
        SetForegroundWindow Form_hWnd1
    End If
End Sub

Sub SetForegroundWindowEsp(lhWnd As Long, PauseSeg As Double)
'No Vista e Win7, se vier de um runas com pedido de eleva|fffd||fffd|o de direitos, h|fffd| perda do foco que fica
'travado por outro processo que n|fffd|o permite apiSetForegroundWindow. Ent|fffd|o |fffd| usar o Alt+Tab para
'simular a|fffd||fffd|o do usu|fffd|rio indo para outro processo.
    Dim i As Long
    Do
        If i > 0 Then SendKeys "%{TAB}": MyWait 0.1
        SetForegroundWindow lhWnd                          ' Como tenho o handle melhor que AppActivate.
        i = i + 1
    Loop While GetForegroundWindow() <> lhWnd And i < 40

    If PauseSeg <> 0 Then MyWait PauseSeg    'Esta espera foi necess|fffd|ria para a Ribbon em PrintPreview n|fffd|o ficar travada. Talvez s|fffd| isto fosse suficiente, mas deixei completo.
End Sub

Attribute VB_Name = "ModZip"
Option Explicit    'Veio resumidamente do backup do CPAP
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

'Here's the enum for Sheel.Application Filter. Encontrei no CD1 do VS60 em F:\VC98\INCLUDE s|fffd| 6,
'mas para o XP e Vista tem mais constantes. As 3 |fffd|ltimas |fffd| s|fffd| no Vista.
Public Const SHCONTF_FOLDERS = 32    '&H20    'Include items that are folders in the enumeration
Public Const SHCONTF_NONFOLDERS = 64    '&H40    'Include items that are not folders in the enumeration
Const SHCONTF_INCLUDEHIDDEN = 128    '&H80    'Include hidden items in the enumeration

Const SHCONTF_INIT_ON_FIRST_NEXT = 256    '&H100    'http://msdn2.microsoft.com/en-us/library/ms649332.aspx
Const SHCONTF_NETPRINTERSRCH = 512    '&H200
Const SHCONTF_SHAREABLE = 1024    '&H400
Const SHCONTF_STORAGE = 2048    '&H800

Const SHCONTF_FASTITEMS = 8192    '&H2000
Const SHCONTF_FLATLIST = 16384    '&H4000
Const SHCONTF_ENABLE_ASYNC = -32768    '&H8000

Sub TestCopyToZipFolder()
    Dim sDestZipPath
    Dim sOrigPath
    Dim sFileFilter As String
    Dim lAttrib As Long

    sDestZipPath = "c:\backtest.zip"
    sOrigPath = "s:\cpap"
    '    sFileFilter = "*.mac"
    '    sFileFilter = "areceber"
    '    sFileFilter = ""
    sFileFilter = "Areceber\testeLOtot.xls"
    lAttrib = 32
    'lAttrib = 64
    lAttrib = 0
    If Dir(sDestZipPath) <> "" Then Kill sDestZipPath

    CopyToZipFolder sDestZipPath, sOrigPath, sFileFilter, lAttrib
End Sub

Function CopyToZipFolder(sDestZipPath As Variant, sOrigPath As Variant, _
                         Optional sFileFilter As String, Optional lAttrib As Long) As Boolean
'Um problema desta rotina |fffd| que se houver falha, como uma subpasta em branco ou um caractere n|fffd|o
'aceit|fffd|vel para zip (|fffd||fffd|), o restante dos arquivos n|fffd|o s|fffd|o copiados. A solu|fffd||fffd|o |fffd| criticar tudo antes
'de copiar ou abrir e copiar e criticar um a um.
    Dim ShlApp
    Dim OrigItems
    Dim lDest As Long
    Dim lOrig As Long
    Dim lWaitMax As Long
    Dim lAdding As Long
    Dim lAddingAnt As Long

    On Error GoTo ErrorHandler
    appHostApp.StatusBar = IIf(IsPortg, "Zipando ", "Zipping ") & sFileFilter & "..."
    With VBA.Interaction.CreateObject("Scripting.FileSystemObject")
        If Not .FileExists(sDestZipPath) Then .CreateTextFile(sDestZipPath, True).Write "PK" & Chr(5) & Chr(6) & String(18, Chr(0))
    End With

    Set ShlApp = VBA.Interaction.CreateObject("Shell.Application")
    lDest = ShlApp.Namespace(sDestZipPath).items.Count

    Set OrigItems = ShlApp.Namespace(sOrigPath).items    'Se sDestZipPath e sOrigPath n|fffd|o forem Variant d|fffd| erro

    'Filtrar por atributo ou m|fffd|scara de nome de arquivo ou folder
    Select Case lAttrib
    Case SHCONTF_FOLDERS    '32 para copiar s|fffd| SubFolders
        OrigItems.Filter SHCONTF_FOLDERS, sFileFilter
    Case SHCONTF_NONFOLDERS    '64 para copiar s|fffd| arquivos, ignora SubFolders
        OrigItems.Filter SHCONTF_NONFOLDERS, sFileFilter
    Case Else    'Sem atributo definido
        'Se existir m|fffd|scara, copia s|fffd| os arquivos que a satisfa|fffd|am. Do contr|fffd|rio, n|fffd|o
        'filtra nada e vai copiar todos os arquivos e subfolders
        If sFileFilter <> "" Then OrigItems.Filter SHCONTF_NONFOLDERS, sFileFilter
    End Select

    lOrig = OrigItems.Count
    ShlApp.Namespace(sDestZipPath).CopyHere OrigItems    ', 4 nao atende as op|fffd||fffd|es, parece bug

    'Esperar
    appHostApp.Interactive = False
    Do
        MyWait 1
        lAdding = GetlAdding(sDestZipPath)    'ShlApp.NameSpace(sDestZipPath).items.Count Troquei pela fun|fffd||fffd|o ver obs. na mesma
        appHostApp.StatusBar = IIf(IsPortg, "Aguardando zip de ", "Waiting zip of ") & sFileFilter & ": " & lWaitMax & "s"
        If lAdding = lAddingAnt Then lWaitMax = lWaitMax + 1 Else lWaitMax = 0
        lAddingAnt = lAdding
    Loop While lAdding < lDest + lOrig And lWaitMax < 60
    appHostApp.Interactive = True

ErrorHandler:
    If Err.Number <> 0 Then MyMsgBox IIf(IsPortg, "Erro ", "Error ") & Err.Number & " (" & Err.Description & ")", 1, IIf(IsPortg, "Falha no Procedimento CopyToZipFolder!", "Fail in CopyToZipFolder Procedure!")
    CopyToZipFolder = Err.Number = 0 And lWaitMax < 60
    Set OrigItems = Nothing
    Set ShlApp = Nothing
    appHostApp.StatusBar = " ": appHostApp.StatusBar = False    'No 2007 false n|fffd|o atualiza de imediato
End Function

Private Function GetlAdding(sDestZipPath As Variant) As Long
'A contagem dava erro inexplic|fffd|vel no 2007 em Virtual principalmente se verif. nomes de arquivos e
'projeto VBA estivesse protegido. Com esta fun|fffd||fffd|o o controle de erro fica separado e retornando
'contagem 0 o que |fffd| mais adequado. Assim h|fffd| mais tentativas e deixa pra sair na espera max.
    Dim ShlApp
    On Error Resume Next
    Set ShlApp = VBA.Interaction.CreateObject("Shell.Application")
    GetlAdding = ShlApp.Namespace(sDestZipPath).items.Count
    If Err.Number <> 0 Then GetlAdding = 0
    Set ShlApp = Nothing
End Function

Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit    'Fiz similar ao do ExcelWatermark
'Implements IDTExtensibility2
'Implements IRibbonExtensibility
Private WithEvents HostApp As Excel.Application
Attribute HostApp.VB_VarHelpID = -1
Private WithEvents cbbButton As Office.CommandBarButton
Attribute cbbButton.VB_VarHelpID = -1

Dim cbcMyBar As Office.CommandBar
Dim btnMyButton As Office.CommandBarButton
Dim bRibbon As Boolean

Private Sub Workbook_Open()




'Store startup reference
    IsPortg = GetIsPortg           'Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070  'appHostApp.International(xlCountryCode) = 55
'   sDLLProgId = AddInInst.ProgId
    bIsCOMAddin = sDLLProgId <> ""
    If bIsCOMAddin Then
        '        sAddInNameByApp = Split(AddInInst.Description, " - ")(0)
        '        sAddInCaptByApp = Split(AddInInst.Description, " - ")(1)
    Else
        sAddInNameByApp = "PortblXLSPrinter"
        sAddInCaptByApp = "Portable XLS Printer for Excel"
    End If
    If IsPortg Then sAddInCaptByApp = MyReplace(sAddInCaptByApp, "Portable XLS Printer for", "Impressor de XLS Port|fffd|vel para")
    AddInTitle = "Orlando's " & sAddInNameByApp
    '    sUtilSerialID = "6"
    'N|fffd|o conecta, se o ExcelWatermark (ou o OfficeWatermark) j|fffd| tiver se conectado. N|fffd|o h|fffd| conflito apenas para evitar uma duplicidade sem nenhum benef|fffd|cio
    'If Not Application.CommandBars.FindControl(Tag:= _
     "Orlando's " & IIf(sAddInNameByApp = "OfficeWatermark", "PortblXLSPrinter", "OfficeWatermark")) Is Nothing Then Exit Sub

    Set HostApp = Application
    dHostAppVer = Val(HostApp.Version)
    If dHostAppVer < 9 Then Exit Sub Else If dHostAppVer < 10 Then App_hWnd = GetActiveWindow Else App_hWnd = HostApp.hWnd   'Neces. no 9, pois mais seguro que FindWindowA porque o Excel n|fffd|o |fffd| MDI e poder ter mais de uma janela
    Set appHostApp = HostApp

    'Se COM e o add-in xla j|fffd| aberto, deixa menu para ele, pois serve para todas vers|fffd|es do Excel
    If bIsCOMAddin Then
        On Error Resume Next
        Msg1 = HostApp.Workbooks(sAddInNameByApp & ".xla").Name     'Testa se est|fffd| aberto
        If Err.Number = 0 Then HostApp.Run sAddInNameByApp & ".xla!fGetVersion"     'Testa se |fffd| meu e a vers|fffd|o
        If Err.Number = 0 Then Exit Sub
        On Error GoTo 0
    End If

    'To call from RibbonX thru PortblXLSPrinter.xlam and Object to show in VBA
    If dHostAppVer >= 11 + 1 Then
        Dim sDllPath As String
        On Error Resume Next
        sDllPath = ThisDLLPath
        If InStr(1, UCase(sDllPath), UCase("\vb6debug.dll")) Then sDllPath = "E:\ComoMVP\MeuSite\Projetos\" & sAddInNameByApp     'In debug mode
        If Err.Number = 0 And VBA.FileSystem.Dir(sDllPath & "\" & sAddInNameByApp & ".xlam") <> "" Then
            appHostApp.Workbooks.Open sDllPath & "\" & sAddInNameByApp & ".xlam"
            DoEvents
            bRibbon = (Err.Number = 0)
        End If
    End If

    'ReadINISetting    'Isso s|fffd| |fffd| necess|fffd|rio para habilitar o hotkey. Se um dia for necess|fffd|rio, n|fffd|o esquecer de testar o atraso na carga do Excel principalmente chamando GetRegDatFile(True). O |fffd|cone da barra de menu demora aparecer e se o Excel for chamado antes vai gerar GPF e na pr|fffd|xima exec. vai querer desabilitar.

    'Add the commandbar
    If Not bRibbon Then Set cbbButton = CreateBar(): CreateBar 2    'Basta um Set para ativar eventos de bot|fffd|o, depois, para novos bot|fffd|es, basta criar com o mesmo Tag para responder nos mesmos eventos

    'Se COM class Object to show in VBA
    '    Set ObjToVBA = New PortblXLSPrinterObjToVBA
    '    AddInInst.Object = ObjToVBA
End Sub

Private Sub Workbook_AddinInstall()
    Workbook_Open
End Sub

Private Sub IDTExtensibility2_OnAddInsUpdate(custom() As Variant)
'
End Sub

Private Sub IDTExtensibility2_OnBeginShutdown(custom() As Variant)
'
End Sub

'Private Sub IDTExtensibility2_OnDisconnection(ByVal _
 '        RemoveMode As AddInDesignerObjects.ext_DisconnectMode, _
 '        custom() As Variant)
Private Sub Workbook_BeforeClose(Cancel As Boolean)
    If dHostAppVer < 10 Or TypeName(appHostApp) = "Nothing" Then Exit Sub      'A |fffd|ltima |fffd| pare evitar beforeClose novamente, pois em xla ao fechar e cancelar de um alerta de salvar ele j|fffd| aconteceu

    If Not bRibbon Then
        RemoveToolbar 2: RemoveToolbar
    Else
        On Error Resume Next
        appHostApp.Workbooks(sAddInNameByApp & ".xlam").Close False
    End If

    ' remove references to shutdown
    '    Set ObjToVBA = Nothing    'Necess|fffd|rio se n|fffd|o fica gerando GPF as sair do Excel
    Set cbbButton = Nothing
    Set appHostApp = Nothing
    Set HostApp = Nothing
End Sub

Private Sub IDTExtensibility2_OnStartupComplete(custom() As Variant)
'
End Sub


Public Function CreateBar(Optional lBarOpt As Long) As Office.CommandBarButton
' Specify the command bar
    On Error GoTo CreateBar_Err
    If lBarOpt = 0 Then Set cbcMyBar = appHostApp.CommandBars("File") Else Set cbcMyBar = appHostApp.CommandBars("Chart Menu Bar").Controls("File").CommandBar

    ' Specify the commandbar button
    Dim btnPos As Long
    Set btnMyButton = cbcMyBar.FindControl(Type:=msoControlButton, Tag:="Orlando" & sAddInNameByApp)
    If btnMyButton Is Nothing Then
        btnPos = cbcMyBar.FindControl(Type:=msoControlButton, ID:=4).Index    '247
        Set btnMyButton = cbcMyBar.Controls.Add(Type:=msoControlButton, _
                                                Parameter:="Orlando" & sAddInNameByApp, Before:=btnPos + 1, Temporary:=True)
        '        IsPortg = appHostApp.International(xlCountryCode) = 55
        With btnMyButton
            .Style = msoButtonCaption
            '      .BeginGroup = True
            .Caption = IIf(IsPortg, "Impressor de &XLS Port|fffd|vel...", "Portable &XLS Printer...")
            .TooltipText = IIf(IsPortg, "Imprimi para um XLS port|fffd|vel de igual impress|fffd|o, mas com o m|fffd|nimo de dados poss|fffd|vel.", "Print to a portable XLS of equal printing, but with as little data as possible.")
            '      .Width = "24"
            .Tag = "Orlando" & sAddInNameByApp
        End With
    End If

    ' Display and return the commandbar
    '   cbcMyBar.Visible = True
    Set CreateBar = btnMyButton
    Exit Function

CreateBar_Err:
    MsgBox Err.Number & vbCrLf & Err.Description
End Function

Private Function RemoveToolbar(Optional lBarOpt As Long)
    On Error GoTo 0
    'Achei melhor redefinir prevenindo uma eventual perda de defini|fffd||fffd|o de vari|fffd|vel
    If lBarOpt = 0 Then Set cbcMyBar = appHostApp.CommandBars("File") Else Set cbcMyBar = appHostApp.CommandBars("Chart Menu Bar").Controls("File").CommandBar
    Set btnMyButton = cbcMyBar.FindControl(Type:=msoControlButton, Tag:="Orlando" & sAddInNameByApp)

    If Not btnMyButton Is Nothing Then btnMyButton.Delete
End Function

Private Sub cbbButton_Click(ByVal Ctrl As Office.CommandBarButton, CancelDefault As Boolean)
'    Set appHostApp = Ctrl.Application    'Com dll s|fffd| funciona com isso ou talvez tivesse perdendo e isto se renovaria fica aqui desativado para uma eventualidade
    PortblXLSPrinter    'xWorkbook_Open
End Sub


Function GetIsPortg()
'Empacotei a linha abaixo nesta fun|fffd||fffd|o(ou sub) porque no Excel 2003, se ela for usada diretamente no OpenEvent
'provoca GPF ao carregar projeto decompilado que tenha tamanho maior que 200Kb decompilado (500 compilado)
'   GetIsPortg = Application.International(xlCountryCode) = 55
    GetIsPortg = Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 1046 Or Application.LanguageSettings.LanguageID(msoLanguageIDUI) = 2070                 'appHostApp.International(xlCountryCode) = 55
End Function



Attribute VB_Name = "UserFormWait"
Attribute VB_Base = "0{61F96357-F5C7-44A1-850E-B4E885DE68C5}{F7F2EB9E-1350-4006-BA03-2AF48C3FC729}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Dim Form_hWnd1 As Long

Private Sub UserForm_Activate()
'Get form handle
    Form_hWnd1 = FindWindowA(IIf(bIsCOMAddin, "ThunderRT6DFrame", "ThunderDFrame"), Caption)
    If Form_hWnd1 = 0 Then Form_hWnd1 = FindWindowA(vbNullString, Caption)
    'Basear o form na janela do Excel
    If bIsCOMAddin Then SetWindowLongA Form_hWnd1, GWL_HWNDPARENT, App_hWnd
    'Fixar form
    If bIsCOMAddin Then FixForm Form_hWnd1    'Se alterar caption, precisa aplicar novamente
End Sub


' InQuest injected base64 decoded content
' L\zR'
' Z,x	e

INQUEST-PP=macro
