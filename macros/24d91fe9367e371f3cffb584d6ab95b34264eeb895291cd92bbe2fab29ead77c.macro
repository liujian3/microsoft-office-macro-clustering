Attribute VB_Name = "Hoja1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_Open()
'Stop
'Call Hacer_traspaso
'Stop
'ActiveWorkbook.Close SaveChanges:=True

End Sub
Attribute VB_Name = "Traspasando"
Sub Hacer_traspaso()

'si hay un error finalizo el proceso devolviendo los datos que han sido procesados
'On Error GoTo Fin

'bajo los datos
GoTo PRINCIPIO:
sheets("traspasos").Activate
getThisSheet

PRINCIPIO:
'Stop

'defino variables
Dim AlmOut As String
Dim AlmIn As String
Dim Ctd As String
Dim CodArt As String
Dim i As Integer
Dim j As Integer

Dim ihistoria As Integer


Dim item As String
Dim thisCon As New ADODB.Connection

'conocer cual es la ultima celda del historico
sheets("historico").Activate
If Range("A2") = "" Then
ihistoria = 2
Else
Range("A1").End(xlDown).Select
ihistoria = ActiveCell.Row + 1
End If


''ordenar los datos

    sheets("traspasos").Activate
    'Range("A1").Select
    sheets("TRASPASOS").Sort.SortFields.clear
    sheets("TRASPASOS").Sort.SortFields.add Key:=Range( _
        "A2:A100"), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:= _
        xlSortNormal
    sheets("TRASPASOS").Sort.SortFields.add Key:=Range( _
        "I2:I100"), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:= _
        xlSortNormal
    With sheets("TRASPASOS").Sort
        .SetRange Range("A1:I100")
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .SortMethod = xlPinYin
        .Apply
    End With
i = 2
j = 1
'Stop
'Do Until sheets("traspasos").Cells(i, j) = ""
Do Until i = 100
Ctd = Replace(sheets("traspasos").Cells(i, 2), ",", ".")
sheets("traspasos").Cells(i, 2) = "=""" & Replace(sheets("traspasos").Cells(i, 2), ",", ".") & """"

'SI CANTIDAD ES CERO PASA AL SIGUIENTE CICLO
If Ctd = "" Or Ctd = "0" Then
GoTo NextCycle
End If

CodArt = sheets("traspasos").Cells(i, 6)
AlmOut = sheets("traspasos").Cells(i, 7)

Select Case AlmOut

Case 0
GoTo NextCycle
Case ""
GoTo NextCycle
Case 7
AlmIn = 1
Case 1
AlmIn = 7
End Select
'si no tiene fecha traspaso pasa de el
If sheets("traspasos").Cells(i, 1) = "" Then
GoTo NextCycle
End If
'si no tiene REF pasa de el
If sheets("traspasos").Cells(i, 6) = "" Then
GoTo NextCycle
End If

'HACER TRASPASO
        item = "INSERT INTO FAHistoricoMvtos (TipoMvto,NumAlmacenIN,NumAlmacenOUT,Cantidad,CodArt) VALUES (2," & AlmIn & "," & AlmOut & "," & Ctd & ",'" & CodArt & "')"
        'MsgBox (item)
        thisCon.ConnectionString = "DSN=SQLData0100;Description=Acceso SQL a FENIX;UID=fdrva0100;PWD=FELIPE;APP=2007 Microsoft Office system;WSID=PCFELIPEVISTA;DATABASE=VALLES;LANGUAGE=Espa|fffd|ol;Network=DBMSSOCN"
        thisCon.Open
        thisCon.Execute (item)
        thisCon.Close
'Stop
sheets("historico").Activate
sheets("historico").Cells(ihistoria, 1) = Replace(sheets("traspasos").Cells(i, 1), ",", ".")
sheets("historico").Cells(ihistoria, 2) = "=""" & Replace(sheets("traspasos").Cells(i, 2), ",", ".") & """"
'sheets("historico").Cells(ihistoria, 2) = Replace(sheets("historico").Cells(ihistoria, 2), ",", ".")
sheets("historico").Cells(ihistoria, 3) = Replace(sheets("traspasos").Cells(i, 3), ",", ".")
sheets("historico").Cells(ihistoria, 4) = Replace(sheets("traspasos").Cells(i, 4), ",", ".")
sheets("historico").Cells(ihistoria, 5) = Replace(sheets("traspasos").Cells(i, 5), ",", ".")
sheets("historico").Cells(ihistoria, 6) = Replace(sheets("traspasos").Cells(i, 6), ",", ".")
sheets("historico").Cells(ihistoria, 7) = Replace(sheets("traspasos").Cells(i, 7), ",", ".")
sheets("historico").Cells(ihistoria, 8) = Replace(sheets("traspasos").Cells(i, 8), ",", ".")
sheets("historico").Cells(ihistoria, 9) = Replace(sheets("traspasos").Cells(i, 9), ",", ".")
ihistoria = ihistoria + 1
sheets("traspasos").Activate
sheets("traspasos").Cells(i, 1) = ""
sheets("traspasos").Cells(i, 2) = ""
sheets("traspasos").Cells(i, 3) = ""
sheets("traspasos").Cells(i, 4) = ""
sheets("traspasos").Cells(i, 5) = ""
sheets("traspasos").Cells(i, 6) = ""
sheets("traspasos").Cells(i, 7) = ""
sheets("traspasos").Cells(i, 8) = ""
sheets("traspasos").Cells(i, 9) = ""


NextCycle:
i = i + 1
Loop
GoTo FINAL
Stop
Fin:

'vaciamos el objeto
Set thisCon = Nothing

''volvemos a ordenar
  
    sheets("TRASPASOS").Sort.SortFields.clear
    sheets("TRASPASOS").Sort.SortFields.add Key:=Range( _
        "A2:A100"), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:= _
        xlSortNormal
    sheets("TRASPASOS").Sort.SortFields.add Key:=Range( _
        "I2:I100"), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:= _
        xlSortNormal
    With sheets("TRASPASOS").Sort
        .SetRange Range("A1:I100")
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .SortMethod = xlPinYin
        .Apply
    End With
Stop
'volcamos los datos a Sheets
sheets("traspasos").Activate
putThisSheet
'Stop
'actualizamos almacenes y historico
    sheets("ALM1FINAL").Select
    Range("A2").Select
    Selection.ListObject.QueryTable.Refresh BackgroundQuery:=False
    putThisSheet
   'Stop
    
    sheets("ALM7FINAL").Select
    Range("A2").Select
    Selection.ListObject.QueryTable.Refresh BackgroundQuery:=False
    putThisSheet
    'Stop
    
    sheets("historico").Activate
    putThisSheet
    
FINAL:
End Sub
Attribute VB_Name = "cBrowser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 3:54:18 PM : from manifest:7471153 gist https://gist.github.com/brucemcpherson/3423912/raw/cBrowser.cls
Option Explicit
' acknowledgement
' http://pastie.org/1192157 for basic authentication 'how to'
'for more about this
' http://ramblings.mcpher.com/Home/excelquirks/classeslink/data-manipulation-classes
'to contact me
' http://groups.google.com/group/excel-ramblings
'reuse of code
' http://ramblings.mcpher.com/Home/excelquirks/codeuse
' v2.14
Private pLockActive As Boolean
Private pLockdown As Boolean
Private pSuccessCode As String
Private pDeniedCode As String
Private pResponseHeaders As String
Private pOptionUrl As String
Private pHtml As String
Private pText As String
Private WithEvents pIeOB As InternetExplorer
Attribute pIeOB.VB_VarHelpID = -1
Private pStatus As Long
Const SXH_SERVER_CERT_IGNORE_CERT_DATE_INVALID = 8192


' everything to do with accessing web pages from Excel
Public Property Get browser() As InternetExplorer
        Set browser = pIeOB.Application
        
End Property
Public Property Get isOk() As Boolean
    isOk = (pStatus = 200 Or pStatus = 201)
End Property
Public Property Get status() As Long
        status = pStatus
End Property
Public Property Get responseHeaders() As String
        responseHeaders = pResponseHeaders
End Property
Public Property Get optionURL() As String
        optionURL = pOptionUrl
End Property
Public Property Get successCode() As String
        successCode = pSuccessCode
End Property
Public Property Get deniedCode() As String
        deniedCode = pDeniedCode
End Property
Public Property Get Text() As String
        Text = pText
End Property
Public Property Get url() As String
    url = pHtml
End Property
Public Function Init() As cBrowser
    Set pIeOB = New InternetExplorer
    Set Init = Me
End Function

Public Function Navigate(fn As String, Optional lockDown As Boolean = False, _
                    Optional visible As Boolean = True) As cBrowser
    ' bring up the web page requested
    pHtml = fn
    pLockdown = lockDown
    pSuccessCode = vbNullString
    pDeniedCode = vbNullString
    With browser
        If lockDown Then
            .AddressBar = False
            .MenuBar = False
            .Resizable = False
        End If
        .visible = visible
        .Navigate2 pHtml
        pLockActive = True
        ' will fire document complete, then we can set this off
        Do
            DoEvents
            If Not pLockdown Then
                pLockActive = Not (.readyState = READYSTATE_COMPLETE And Not .Busy)
            End If
        Loop Until Not pLockActive

    End With
    Set Navigate = Me
    
End Function
Private Function getHttpObject(Optional timeout As Long = 0) As Object
    '// some installation dont have server object installed, so fall back
    Dim ob As Object
    On Error GoTo missing
    Set ob = CreateObject("Msxml2.ServerXMLHTTP.6.0")
    ob.setOption 2, ob.getOption(2) - SXH_SERVER_CERT_IGNORE_CERT_DATE_INVALID
    ' can have change of timeout for complex/long queries
    If timeout <> 0 Then
        ob.setTimeouts 0, 30 * 1000, 30 * 1000, timeout * 1000
    End If
    Set getHttpObject = ob
    Exit Function
    
missing:
    On Error GoTo screwed
    Set ob = CreateObject("Msxml2.XMLHTTP.6.0")
    Debug.Print "falling back to client xmlhttp - server is not installed on this machine"
    Set getHttpObject = ob
    Exit Function

screwed:
    MsgBox ("cant find either server or client xmlhttp - there missing files from your windows installtion")
    Exit Function
    
End Function
Public Function httpPost(fn As String, _
        Optional data As String = vbNullString, Optional isjson As Boolean = False, _
        Optional authHeader As String = vbNullString, _
        Optional additionalHeaders As cJobject = Nothing, _
        Optional Method As String = "POST") As String
    pHtml = fn
    Dim v As Variant, ohttp As Object
    
    Set ohttp = getHttpObject
    If (ohttp Is Nothing) Then
        Exit Function
    End If
    
    With ohttp

        .Open Method, pHtml, False
        If isjson Then
            .setRequestHeader "Content-Type", "application/json"
        Else
            .setRequestHeader "Content-Type", "application/x-www-form-urlencoded"
        End If
        If (authHeader <> vbNullString) Then
            ohttp.setRequestHeader "Authorization", authHeader
        End If
        extraHeaders ohttp, additionalHeaders

        ohttp.send data
        storeStuff ohttp
    End With
    
    httpPost = pText
    Set ohttp = Nothing
End Function
Private Function extraHeaders(ohttp As Object, additionalHeaders As cJobject) As Object
    Dim job As cJobject
    ' any extra headers?
    If Not additionalHeaders Is Nothing Then
        For Each job In additionalHeaders.children
            ohttp.setRequestHeader job.Key, job.value
        Next job
    End If
    Set extraHeaders = ohttp
End Function

Public Function httpGET(fn As String, _
        Optional authUser As String = vbNullString, _
        Optional authPass As String = vbNullString, _
        Optional accept As String = vbNullString, _
        Optional timeout As Long = 0, _
        Optional authHeader As String = vbNullString, _
        Optional additionalHeaders As Object = Nothing, _
        Optional Method As String = "GET") As String
    
    pHtml = fn

    Dim ohttp As Object, job As Object
    Set ohttp = getHttpObject(timeout)
    
    Call ohttp.Open(Method, pHtml, False)
    If (authUser <> vbNullString) Then
    ' need to do basic authentication
    ' acknowledgement to http://pastie.org/1192157
        ohttp.setRequestHeader "Content-Type", "application/json"
        ohttp.setRequestHeader "Accept", "application/json"
        ohttp.setRequestHeader "Authorization", "Basic " + _
            Base64Encode(authUser + ":" + authPass)
    End If
    
    ' some times we need to set the accept header
    If accept <> vbNullString Then
        ohttp.setRequestHeader "Accept", accept
    End If


    ' this would be if we were doing an oauth2
    If (authHeader <> vbNullString) Then
        ohttp.setRequestHeader "Content-Type", "application/x-www-form-urlencoded"
        ohttp.setRequestHeader "Authorization", authHeader
    End If

    
    extraHeaders ohttp, additionalHeaders
    'Debug.Print method, pHtml
    ohttp.send ""
    storeStuff ohttp
    httpGET = pText
    Set ohttp = Nothing
End Function
Private Sub storeStuff(o As Object)
    With o
        pStatus = .status
        pText = .responseText
        pResponseHeaders = .getAllResponseHeaders()
    End With
End Sub
Public Function element(eID As String) As Object
    On Error GoTo crappedout
    Set element = browser().Document.getElementById(eID)
    Exit Function
crappedout:
    Set element = Nothing
   
End Function
Public Function elementTags(tag As String) As Object
    On Error GoTo crappedout
    Set elementTags = browser().Document.getElementsByTagName(tag)
    Exit Function
crappedout:
    Set elementTags = Nothing
   
End Function
Public Property Get ElementText(eID As String) As String
    Dim e As Object
    Set e = element(eID)
    If (e Is Nothing) Then
        ElementText = ""
    Else
        ElementText = e.value
    End If
End Property

Public Sub kill()
    browser.Quit

End Sub

Private Sub Class_Initialize()
    pLockActive = False
End Sub

Private Sub Class_Terminate()
    Set pIeOB = Nothing
End Sub
Public Sub tearDown()
    If Not pIeOB Is Nothing Then
        kill
        Set pIeOB = Nothing
    End If
    
End Sub



Private Sub pIeOB_OnQuit()
    pLockActive = False
End Sub


Private Sub pIeOB_TitleChange(ByVal Text As String)
    Dim s As String, f As String
    f = "Denied error="
    s = "Success code="
    If (pLockdown) Then
        If (Left(Text, Len(s)) = s) Then
            pSuccessCode = Mid(Text, Len(s) + 1)
            pLockActive = False
        ElseIf (Left(Text, Len(f)) = f) Then
            pDeniedCode = Mid(Text, Len(f) + 1)
            pLockActive = False
        End If
        If (Not pLockActive) Then
            With browser
                .visible = False
            End With
        End If
    End If

End Sub







Attribute VB_Name = "cJavaScript"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private pChunk As cStringChunker
'/**
' * kind of like a script tag - adds a local script file to your code
' * @param {string} scriptFile file name
' * @return {cJavaScript} self
' */
Public Function addFile(scriptFile As String) As cJavaScript
    pChunk.addLine (readFromFile(scriptFile))
    Set addFile = Me
End Function
'/**
' * kind of like a script tag - adds a local apps script stuff
' * @param {string} scriptUrl the web app providing the code
' * @return {cJavaScript} self
' */
Public Function addAppsScript(scriptUrl As String) As cJavaScript
    Dim s As String
    
    s = simpleUrlGet(scriptUrl)
    
    '// need to do special cleaning for apps script
    pChunk.addLine (removeHtmlEscape(s))
    Set addAppsScript = removeScriptTags()

End Function
        
'/**
' * kind of like a script tag - adds a hosted file to your code
' * @param {string} scriptUrl file link
' * @return {cJavaScript} self
' */
Public Function addUrl(scriptUrl As String) As cJavaScript
    pChunk.addLine (simpleUrlGet(scriptUrl))
    Set addUrl = Me
End Function
'/**
' * kind of like a script tag - adds a local script file to your code
' * @param {string} fn file link
' * @param {boolean} complain optional complain if an error
' * @return {string} result
' */
Public Function simpleUrlGet(fn As String, Optional complain As Boolean = True) As String
    
    '// this can be changes to a client object if firewall problems
    Dim ohttp As Object
    Set ohttp = New MSXML2.ServerXMLHTTP60
    
    With ohttp
        .Open "GET", fn, False
        .send ""
        If (.status <> 200) Then
            MsgBox ("error getting " & fn & " code " & .status & " text " & .responseText)
        Else
            simpleUrlGet = .responseText
        End If

        
    End With
End Function

'/**
' * adds code to your script
' * @param {string} scriptCode some code
' * @return {cJavaScript} self
' */
Public Function addCode(scriptCode As String) As cJavaScript
    pChunk.addLine scriptCode
    Set addCode = Me
End Function
'/**
' * returns the code
' * @return {string} the code
' */
Public Property Get code() As String
    code = pChunk.toString
End Property
'/**
' * returns convenience self for with/chaining
' * @return {cJavaScript} self
' */
Public Property Get self() As cJavaScript
    Set self = Me
End Property
'/**
' * clears the code
' * @return {cJavaScript}  self
' */
Public Function clear() As cJavaScript
    pChunk.clear
    Set clear = Me
End Function
'/**
' * expose the stringchunker
' * @return {cStringChunker}  the code chunker
' */
Public Property Get chunker() As cStringChunker
    Set chunker = pChunk
End Property

'/**
' * execute code
' * @return {ScriptControl} the script control to execute run against
' */
Public Function compile() As Variant
    Dim sc As ScriptControl
    Set sc = New ScriptControl

    ' we can't run as a method of this as paramarray cant be passed properly in VBA
    With sc
        .Language = "JScript"
        .addCode pChunk.addLine("").toString
    End With
    
    Set compile = sc
    
End Function
'/**
' * if you need to deal with arrays, this will convert back and forwards from JS to vba
' * @return {cJavaScript} self
' */
Public Function addArraySupport() As cJavaScript
    pChunk.add "var XLiberation = (function(xLiberation) {" & _
                "xliberation.getArray = function (arrayIn) {" & _
                    "return new VBArray(arrayIn).toArray();}" & _
                "xLiberation.setArray = function setArray(ja) {" & _
                    "var dict = new ActiveXObject('Scripting.Dictionary');" & _
                    "for (var i=0;i < ja.length; i++ )dict.add(i,ja[i]);" & _
                    "return dict.items();}" & _
                " return xLiberation; " & _
        "})(Xliberation || {});"
    Set addArraySupport = Me
End Function
Public Function removeHtmlEscape(t As String) As String

    Dim oXML As Object
    ' as far as i know, only << are left escaped by contentservice
    removeHtmlEscape = Replace(t, "&lt;", "<")
    
End Function
'/**
' * apps script sometimes have script tags
' * @return {cJavaScript} self
' */
Public Function removeScriptTags() As cJavaScript
    Dim s As String, t As String
    t = pChunk.toString
    Set removeScriptTags = Me
    s = Replace(Replace(t, "<script>", ""), "</script>", "")
    If (s <> t) Then
        pChunk.clear.add (s)
    End If
End Function

Private Sub Class_Initialize()
    Set pChunk = New cStringChunker
End Sub

Attribute VB_Name = "cJobject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 4:47:45 PM : from manifest:3414394 gist https://gist.github.com/brucemcpherson/3414365/raw
' this is used for object serliazation. Its just basic JSON with only string data types catered for
Option Explicit
' v2.25 3414365
'for more about this
' http://ramblings.mcpher.com/Home/excelquirks/classeslink/data-manipulation-classes
'to contact me
' http://groups.google.com/group/excel-ramblings
'reuse of code
' http://ramblings.mcpher.com/Home/excelquirks/codeuse
Private pParent As cJobject
Private pValue As Variant
Private pkey As String
Private pChildren As Collection
Private pValid As Boolean
Private pIndex As Long
Const cNull = "_null"
Const croot = "_deserialization"
Private pFake As Boolean            ' not a real key
Private pisArrayRoot                ' this is the root of an array
Private pPointer As Long            ' this one is used for deserializing string
Private pJstring As String          ' so is this
Private pWhatNext As String
Private pActive As Boolean
Private pJtype As eDeserializeType
Private pBacktrack As cJobject        ' used in parsing
Public Enum eDeserializeType
    eDeserializeNormal
    eDeserializeGoogleWire
End Enum
' this is for treeview - i couldnt find it anywhere
Public Enum tvw
    tvwFirst = 0
    tvwLast = 1
    tvwNext = 2
    tvwPrevious = 3
    tvwChild = 4
End Enum
Public Enum eSort
    eSortNone
    eSortAscending
    eSortDescending
End Enum
Public Enum eTypeofColumn
    eTCdate
    eTCnumeric
    eTCtext
    eTCmixed
    eTCboolean
    eTCunknown
End Enum
Private pbyKey As String
Public Property Get backtrack() As cJobject
    Set backtrack = pBacktrack
End Property
Public Property Set backtrack(back As cJobject)
    Set pBacktrack = back
End Property

Public Property Get self() As cJobject
    Set self = Me
End Property
Public Property Get isValid() As Boolean
    isValid = pValid
End Property
Public Property Let setValid(good As Boolean)
    pValid = good
End Property
Public Property Get jString() As String
    jString = pJstring
End Property
Public Property Get fake() As Boolean
    fake = pFake
    If Not pParent Is Nothing Then
        fake = fake And pParent.isArrayRoot
    End If
End Property
Public Property Get childIndex() As Long
    childIndex = pIndex
End Property
Public Property Let childIndex(p As Long)
    pIndex = p
End Property
Public Property Get isArrayRoot() As Boolean
    isArrayRoot = pisArrayRoot
End Property
Public Property Get isArrayMember() As Boolean
    If Not pParent Is Nothing Then
        isArrayMember = pParent.isArrayRoot
    Else
        isArrayMember = False
    End If
End Property
Public Property Let isArrayRoot(p As Boolean)
    pisArrayRoot = p
End Property

Public Property Get parent() As cJobject
    Set parent = pParent
End Property
Public Property Set parent(p As cJobject)
    Set pParent = p
End Property
Public Property Get isRoot() As Boolean
    isRoot = (root Is Me)
End Property
Public Sub clearParent()
    Set pParent = Nothing
End Sub
Public Property Get root() As cJobject
    Dim jo As cJobject
    ' the root is the object with no parent
    Set jo = Me
    While Not jo.parent Is Nothing
        Set jo = jo.parent
    Wend
    Set root = jo
End Property
Public Property Get Key() As String
    Key = pkey
End Property
Public Property Get value() As Variant
    If IsObject(pValue) Then
        Set value = pValue
    Else
        value = pValue
    End If
End Property
Public Function setValue(p As Variant) As cJobject
    If IsObject(p) Then
        Set pValue = p
    Else
        pValue = p
    End If
    Set setValue = Me
End Function
Public Function isVoid(Optional childName As String = vbNullString) As Boolean
    If childName = vbNullString Then
        If isObjValue Then
            isVoid = pValue Is Nothing
        Else
            isVoid = IsEmpty(pValue)
        End If
    Else
        isVoid = child(childName).isVoid
    End If
End Function
Public Function isObjValue(Optional childName As String = vbNullString) As Boolean
    If childName = vbNullString Then
        isObjValue = IsObject(value)
    Else
        isObjValue = child(childName).isObjValue
    End If
End Function
Public Function cValue(Optional childName As String = vbNullString) As Variant
    If childName = vbNullString Then
        cValue = value
    Else
        cValue = child(childName).value
    End If
End Function
Public Function kids(Optional childName As String = vbNullString) As Collection
    If (childName = vbNullString) Then
        Set kids = children
    Else
        Set kids = child(childName).children
    End If
End Function
Public Function toString(Optional childName As String = vbNullString) As String
    If isObjValue Then
        toString = "object:" + TypeName(getObject())
    Else
        toString = CStr(cValue(childName))
    End If
End Function
Public Property Get getObject(Optional childName As String = vbNullString) As Object
    Dim t As cJobject
    If childName <> vbNullString Then
        Set t = Me.child(childName)
    Else
        Set t = Me
    End If
    
    Set getObject = t.value
   
End Property
Public Property Let value(p As Variant)
    pValue = p
End Property

Public Property Get children() As Collection
    Set children = pChildren
End Property
Public Property Set children(p As Collection)
    Set pChildren = p
End Property
Public Property Get hasChildren() As Boolean
    hasChildren = False
    If Not pChildren Is Nothing Then
        hasChildren = (pChildren.Count > 0)
    End If
End Property
Public Function deleteChild(childName As String) As cJobject
    ' this deletes a child from the children collection
    Dim job As cJobject, target As cJobject
    Set target = childExists(childName)
    
    If (Not target Is Nothing) Then
        children.remove target.childIndex
        For Each job In children
            If job.childIndex > target.childIndex Then
                job.childIndex = job.childIndex - 1
            End If
        Next job
        target.tearDown
       
    End If
    Set deleteChild = Me
End Function
Public Function valueIndex(v As Variant) As Long
    ' check to see if h is in the cj array
    Dim cj As cJobject
    valueIndex = 0
    For Each cj In children
        If Not cj.isObjValue Then
            If cj.value = v Then
                valueIndex = cj.childIndex
                Exit Function
            End If
        End If
    Next cj
    
End Function

Public Function toTreeView(tr As Object, Optional bEnableCheckBoxes As Boolean = False) As Object
    ' this populates a treeview with a cJobject
    tr.CheckBoxes = bEnableCheckBoxes
    Set toTreeView = treeViewPopulate(tr, Me)
    
End Function

Private Function treeViewPopulate(tr As Object, cj As cJobject, Optional parent As cJobject = Nothing)
    Dim c As cJobject, s As String
    s = vbNullString
    If cj.hasChildren Then
        s = cj.Key
    Else
        s = cj.Key + " : " & cj.toString
    End If
    If (Not parent Is Nothing) Then
        tr.Nodes.add parent.fullKey, tvwChild, cj.fullKey, s
    Else
        tr.Nodes.add(, , cj.fullKey, cj.Key).Expanded = True
    End If
    For Each c In cj.children
        treeViewPopulate tr, c, cj
    Next c
    Set treeViewPopulate = tr
    
End Function
Public Function Init(p As cJobject, Optional k As String = cNull, Optional v As Variant = Empty) As cJobject
    Set pParent = p
    Set pBacktrack = p
    pbyKey = "sortKey"
    
    pFake = (k = cNull)
    If pFake Then
        pkey = CStr(pIndex)
    Else
        pkey = k
    End If

    If Not pParent Is Nothing Then
        If Not child(pkey) Is Nothing Then
            MsgBox ("Programming error " & pkey & " is a duplicate object")
            pValid = False
        Else
            pIndex = pParent.children.Count + 1
            If pFake Then
                pkey = CStr(pIndex)
            End If
            pParent.children.add Me, pkey
        End If
    End If

    Set Init = setValue(v)

End Function

Public Function child(s As String) As cJobject
    Dim aString As Variant, n As Long, jo As cJobject, jc  As cJobject
    
    If Len(s) > 0 Then
        aString = Split(s, ".")
        Set jo = Me
        ' we take something x.y.z and find the child
        For n = LBound(aString) To UBound(aString)
            Set jc = jo.childExists(CStr(aString(n)))
            Set jo = jc
            If jo Is Nothing Then Exit For
        Next n
    End If
    Set child = jo

End Function
Public Function insert(Optional s As String = cNull, Optional v As Variant = Empty) As cJobject
    Dim joNew As cJobject, sk As String
    Set joNew = childExists(s)

    If joNew Is Nothing Then
        ' if its an array, use the child index as the name if there is no name given
        If pisArrayRoot And s = cNull Then
            sk = cNull

        Else
            sk = s
        End If
        
        Set joNew = New cJobject
        joNew.Init Me, sk, v
    Else
        If Not IsEmpty(v) Then joNew.setValue v
    End If
    Set insert = joNew
End Function
Public Function add(Optional k As String = cNull, Optional v As Variant = Empty) As cJobject
    Dim aString As Variant, n As Long, jo As cJobject, jc  As cJobject
    aString = Split(k, ".")
    Set jo = Me
    ' we take something x.y.z and add z with parent of y
    For n = LBound(aString) To UBound(aString)
        Set jc = jo.insert(CStr(aString(n)), v)
        Set jo = jc
    Next n
    Set add = jo
End Function
Public Function addArray() As cJobject
    pisArrayRoot = True
    Set addArray = Me
End Function
' check if this childExists in current children
Public Function childExists(s As String) As cJobject
    On Error GoTo handle
    Set childExists = pChildren(s)
    Exit Function
handle:
    Set childExists = Nothing
End Function
Private Function unSplitToString(a As Variant, delim As String, _
    Optional startAt As Long = -999, Optional howMany As Long = -999, _
    Optional startAtEnd As Boolean = False) As String
    Dim s As String, c As cStringChunker, i As Long

    ' sort out possible boundaries
    If startAt = -999 Then startAt = LBound(a)
    If howMany = -999 Then howMany = UBound(a) - startAt + 1
    If startAtEnd Then startAt = UBound(a) - howMany + 1
    ' will return nullstring on outside bounds
    If startAt < LBound(a) Or howMany + startAt - 1 > UBound(a) Then
        unSplitToString = vbNullString
    Else
        Set c = New cStringChunker
        ' combine and convert to string
        For i = startAt To startAt + howMany - 1
            c.add(CStr(a(i))).add delim
        Next i
        unSplitToString = c.chopIf(delim).content
        Set c = Nothing
    End If
    End Function
Public Function findInArray(prop As String, val As Variant, Optional asKey As Boolean = True) As cJobject
    ' find a particular prop value in an array
    Dim cj As cJobject, p As cJobject
    For Each cj In children
        Set p = cj.childExists(prop)
        If (isSomething(p)) Then
            If (Not p.isObjValue() And Not p.hasChildren) Then
                If compareAsKey(p.value, val, asKey) Then
                    Set findInArray = p
                    Exit Function
                End If
            End If
        End If
    Next cj
    Set findInArray = Nothing
End Function

Public Function find(s As String) As cJobject
    Dim jo As cJobject, f As cJobject, k As String, fk As String, possible As Boolean
    k = makeKey(s)
    fk = makeKey(fullKey(False))
    
    ' need to deal with find("x.y.z") as well as simple find("x")
    Dim kk As String, a As Variant, b As Variant
    b = Split(fk, ".")
    a = Split(k, ".")
    kk = unSplitToString(b, ".", , arrayLength(a), True)
    
    'now the fullkey is the same number of items as the key to compare it against
    If kk = k Then
        Set f = Me
    ElseIf hasChildren Then
        For Each jo In pChildren
            Set f = jo.find(s)
            If Not f Is Nothing Then Exit For
        Next jo
    End If
    Set find = f
End Function
Public Function convertToArray() As cJobject
    ' here's where have something like {x:{a:'x',b:'y'}} and we need to make {x:[{a:'x',b:'y'}]}
    Dim kids As Collection, newParent As cJobject, job As cJobject, newRoot As cJobject, i As Long
    
    ' if its got no kids but has a value then we need to assign that value
    
    If Not hasChildren Then
        addArray
        If Not IsEmpty(value) Then
            ' make a space for the value
            add , value
        Else
            ' do nothing
        End If
        Set convertToArray = Me
    Else
        ' we need to make a space for the object and for each child
        Set kids = children
        ' remove current item
        parent.children.remove (Key)
        ' reset child indices
        i = 0
        For Each job In parent.children
            i = i + 1
            job.childIndex = i
        Next job
        
        ' add a new version of me
        Set newRoot = parent.add(Key).addArray

        ' move over contents
        With newRoot.add
            For Each job In kids
                .add job.Key, job.value
            Next job
        End With
        
        Set convertToArray = newRoot
    End If

    
End Function
Public Function fullKey(Optional includeRoot As Boolean = True) As String
    ' reconstruct full key to parent
    Dim s As String, jo As cJobject
    Set jo = Me
    While Not jo Is Nothing
        If (Not jo.isRoot) Or includeRoot Then s = jo.Key & "." & s
        Set jo = jo.parent
    Wend
    If Len(s) > 0 Then s = Left(s, Len(s) - 1)
    fullKey = s
    
End Function

Public Function findByValue(x As Variant) As cJobject
    Dim job As cJobject, result As cJobject
    
    If Not isObjValue() And value = x Then
        Set findByValue = Me
        Exit Function
    
    Else
        For Each job In children
            Set result = job.findByValue(x)
            If Not result Is Nothing Then
                Set findByValue = result
                Exit Function
            End If
        Next job
    End If
    
End Function
Public Function hasKey() As Boolean
    hasKey = pkey <> vbNullString And _
        pkey <> cNull And _
        (hasChildren Or Not isArrayMember) And Not pFake
End Function
Public Function needsCurly() As Boolean
    needsCurly = hasKey And Not isArrayRoot
    If hasChildren Then
        needsCurly = pChildren(1).hasKey
    End If
    
End Function

Public Function needsSquare() As Boolean

    needsSquare = isArrayRoot

End Function
Public Function stringify(Optional blf As Boolean) As String
    stringify = serialize(blf)
End Function
Public Function serialize(Optional blf As Boolean = False) As String
' make a JSON string of this structure
  Dim t As cStringChunker
  
  Set t = New cStringChunker
  If Not fake Then t.add "{"
  recurseSerialize Me, t, blf
  If Not fake Then t.add "}"
 
  serialize = t.content
End Function
Public Property Get needsIndent() As Boolean
    needsIndent = needsCurly Or needsSquare
End Property
Public Function recurseSerialize(job As cJobject, Optional soFar As cStringChunker = Nothing, _
                Optional blf As Boolean = False) As cStringChunker
  Dim s As String, jo As cJobject, t As cStringChunker
  Static indent As Long
  If indent = 0 Then indent = 3
  If soFar Is Nothing Then
    Set t = New cStringChunker
  Else
    Set t = soFar
  End If

  If blf And (job.hasKey Or job.needsCurly) Then t.add Space(indent)
  
  If job.hasKey Then
    t.add(quote(job.Key)).add (":")
  End If
  
  If Not (job.hasChildren Or job.isArrayRoot) Then
    If blf And Not job.hasKey Then s = s & Space(indent)
    If (job.isObjValue()) Then
        t.add quote(job.toString)
    ElseIf (VarType(job.value) <> vbLong And _
        VarType(job.value) <> vbBoolean And _
        VarType(job.value) <> vbInteger And _
        VarType(job.value) <> vbDouble And _
        VarType(job.value) <> vbSingle And _
        VarType(job.value) <> vbCurrency And Not job.isVoid()) Then
            t.add quote(CStr(escapeify(job.value)))
    Else
        If Not job.isVoid() Then
            t.add LCase(job.toString)
        Else
            t.add "null"
        End If
    End If
        
  Else
    ' arrays need squares
    
    If job.needsSquare Then t.add "["
    If job.needsCurly Then t.add "{"
    If blf And Not job.isArrayRoot Then t.add vbLf
    If job.needsIndent Then
        indent = indent + 3
    End If
    
    For Each jo In job.children
      recurseSerialize(jo, t, blf).add (",")
      If blf Then t.add (vbLf)
    Next jo
    
    ' get rid of trailing comma
    t.chopWhile(" ").chopIf(vbLf).chopIf (",")

    
    If job.needsIndent Then
        indent = indent - 3
        If blf Then t.add vbLf
    End If
    If blf Then t.add Space(indent)
    If job.needsCurly Then t.add "}"
    If job.needsSquare Then t.add " ]"
    
  End If
  Set recurseSerialize = t
End Function

Public Property Get longestFullKey() As Long
    longestFullKey = clongestFullKey(root)
End Property
Public Function clone() As cJobject
    Dim cj As cJobject
    Set cj = New cJobject
    Set cj = cj.Init(Nothing).append(Me).children(1)
    cj.clearParent
    Set clone = cj
End Function
Public Function arrayAppend(arrJob As cJobject) As cJobject
    Dim j As cJobject
    For Each j In arrJob.children
        Me.append j
    Next j
    Set arrayAppend = Me
End Function
Public Function mergeArrayOfJobs() As cJobject
    Dim job As cJobject, head As cJobject, jo As cJobject
    
    ' Me should be an array of Jobjects, which are themsleves arrays
    ' that needs to be merged into the first object
    Debug.Assert isArrayRoot
    
    For Each job In children
        Debug.Assert job.isObjValue And job.isArrayMember
        If (job.childIndex > 1) Then
            For Each jo In job.getObject().children
                Set jo.parent = head
                jo.childIndex = head.children.Count + 1
                head.children.add jo, CStr(jo.childIndex)
            Next jo
        Else
            Set head = job.getObject
        End If
    Next job
    
    Set mergeArrayOfJobs = head
End Function
Public Function extractAndBlowArrayOfJobs() As cJobject
    Dim job As cJobject, newArray As cJobject, jo As cJobject, head As cJobject, joc As cJobject
    
    ' Me should be an array of Jobjects, which are themsleves objects
    ' will blow out the objects ffor stringifiyinh
    Debug.Assert isArrayRoot
    
    Set newArray = New cJobject
    With newArray.Init(Nothing).addArray
        '// select out any objects and add them
        For Each job In children
            Set head = .add
            For Each jo In job.children
                If (jo.isObjValue) Then
                    For Each joc In jo.getObject.children
                        Set joc.parent = head
                        joc.childIndex = head.children.Count
                        head.children.add joc, joc.Key
                    Next joc
                End If
            Next jo
        Next job
    End With

    
    Set extractAndBlowArrayOfJobs = newArray
End Function
Public Function replaceBranch(byThis As cJobject) As cJobject
    
    Debug.Assert Not parent Is Nothing
    Debug.Assert parent.hasChildren
    
    ' set the parent as me
    Set byThis.parent = parent
    
    ' remove me
    remove
    
    ' add me and set my index
    Dim k As String
    k = byThis.Key

    
    byThis.childIndex = byThis.parent.children.Count + 1
    If byThis.fake Then
        k = CStr(byThis.childIndex)
    End If
    byThis.parent.children.add byThis, k
    Set replaceBranch = byThis
    
    ' kill the previous
    Me.tearDown


End Function
Public Function merge(mergeThisIntoMe As cJobject) As cJobject
    ' merge this cjobject with another
    ' items in merged with are replaced with items in Me
    Dim cj As cJobject, p As cJobject
    
    Set p = Me.find(mergeThisIntoMe.fullKey(False))
    
    If p Is Nothing Then
    ' i dont have it yet
        Set p = Me.append(mergeThisIntoMe)
    Else
    ' actually i do have it already
        If p.isArrayRoot Then
            ' but its an array - i need to get rid of it
            Set p = p.remove
            Set p = p.append(mergeThisIntoMe)
        Else
            p.setValue (mergeThisIntoMe.value)
        End If
    End If
    ' now the other childreb tio merge in
    For Each cj In mergeThisIntoMe.children
       p.merge cj
    Next cj
    Set merge = Me

End Function
Public Function remove() As cJobject
    ' removes a branch
    Dim cj As cJobject, p As cJobject, i As Long
    
    Debug.Assert Not parent Is Nothing
    Debug.Assert parent.hasChildren
    
    parent.children.remove childIndex
    ' fix the childindices
    i = 0
    For Each cj In parent.children
        i = i + 1
        cj.childIndex = i
    Next cj
    Set remove = parent

End Function
Public Function attach(attachment As cJobject) As cJobject
    ' continue with another cjobject at this branch, but keep the same key

    ' remove from the old parent
    If (isSomething(attachment.parent)) Then attachment.remove
    
    ' set the parent as me
    Set attachment.parent = Me
    
    ' add to my children
    children.add attachment, CStr(attachment.Key)
    
    ' fix the child index
    attachment.childIndex = children.Count

    Set attach = Me
End Function
Public Function append(appendThisToMe As cJobject) As cJobject
    ' append another object to me
    Dim cj As cJobject, p As cJobject

    If appendThisToMe.parent Is Nothing Then
        Set p = Me.add(appendThisToMe.Key, appendThisToMe.value)
    
    ElseIf Not appendThisToMe.fake Then
        Set p = Me.add(appendThisToMe.Key, appendThisToMe.value)
    
    Else
        Set p = Me.add(, appendThisToMe.value)
    End If
    
    If appendThisToMe.isArrayRoot Then p.addArray
    For Each cj In appendThisToMe.children
       p.append cj
    Next cj
    Set append = Me
End Function
Public Property Get depth(Optional l As Long = 0) As Long
    Dim jo As cJobject
    l = l + 1
    For Each jo In pChildren
        l = jo.depth(l)
    Next jo
    depth = l
End Property
Private Function clongestFullKey(job As cJobject, Optional soFar As Long = 0) As Long
    Dim jo As cJobject
    Dim l As Long
    l = Len(job.fullKey)
    If l < soFar Then l = soFar
    If Not job.children Is Nothing Then
        For Each jo In job.children
            l = clongestFullKey(jo, l)
        Next jo
    End If
    clongestFullKey = l
End Function
Public Property Get formatData(Optional bDebug As Boolean = False) As String
    formatData = cformatdata(root, , bDebug)
End Property
Private Function cformatdata(job As cJobject, Optional soFar As String = "", Optional bDebug As Boolean = False) As String
    Dim jo As cJobject, ji As cJobject
    Dim s As String
    s = soFar

        s = s & itemFormat(job, bDebug)
        If job.hasChildren Then
            For Each ji In job.children
                s = cformatdata(ji, s, bDebug)
            Next ji
        End If


    cformatdata = s
End Function
Private Function itemFormat(jo As cJobject, Optional bDebug As Boolean = False) As String
    Dim s As String
    s = jo.fullKey & Space(longestFullKey + 4 - Len(jo.fullKey)) _
            & jo.toString
    If bDebug Then
        s = s + "("
        s = s & "debug: Haskey :" & jo.hasKey & " NeedsCurly :" & jo.needsCurly & " NeedsSquare:" & jo.needsSquare
        s = s + " isArrayMember:" & jo.isArrayMember & " isArrayRoot:" & jo.isArrayRoot & " Fake:" & jo.fake
        s = s & ")"
    
    End If
    itemFormat = s + vbCrLf
End Function
Public Sub jdebug()
    Debug.Print formatData(True)
End Sub
Private Function quote(s As String) As String
    quote = q & s & q
End Function
'/**
' *this will take a JSON string and parse it into a cJobject branch under ME
' *it behaves as the JavaScript JSON.parse except it allows for single quoted props & values too
' *@param {string} s the string to be parsed
' *@param {edeserializetype} jtype type of serialization
' *@param {boolean} complain whether to complain in the event of an error
' *@param {boolean} dealWithLikelyTimestamps whether to convert things that look like JS or unix timestamps to excel dates
' *@return {cJobject} the branch header
'*/
Public Function parse(s As String, _
    Optional jtype As eDeserializeType, _
    Optional complain As Boolean = True, _
    Optional dealWithLikelyTimestamps As Boolean = True) As cJobject
    
    Dim j As cJobject
    Set j = deSerialize(s, jtype, complain, dealWithLikelyTimestamps)
    If j.Key = croot Then
        ' drop fake header
        j.sever
    End If
    Set parse = j
End Function
'/**
' *this will take a JSON string and deserialize into a cJobject branch under ME
' *@param {string} s the string to be parsed
' *@param {edeserializetype} jtype type of serialization
' *@param {boolean} complain whether to complain in the event of an error
' *@param {boolean} dealWithLikelyTimestamps whether to convert things that look like JS or unix timestamps to excel dates
' *@return {cJobject} the branch header
'*/
Public Function deSerialize(s As String, _
    Optional jtype As eDeserializeType = eDeserializeNormal, _
    Optional complain As Boolean = True, _
    Optional dealWithLikelyTimestamps As Boolean = True) As cJobject
    
    ' this will take a JSON string and deserialize into a cJobject branch starting at ME
    ' prepare string for processing
    Dim jo As cJobject

    pPointer = 1
    pJstring = noisyTrim(s)
    Set jo = New cJobject
    jo.Init Nothing, croot
    pJtype = jtype
    Set jo = dsLoop(jo, complain, dealWithLikelyTimestamps)
    ' already has its own root
    If jtype = eDeserializeGoogleWire Then
        Set jo = jo.children(1)
        jo.clearParent
    End If
    jo.setValid = pValid
    Set deSerialize = jo
End Function
Public Function sever() As cJobject
    pkey = cNull
    Set pParent = Nothing
    Set sever = Me
    pFake = True
End Function
Private Function noisyTrim(s As String) As String
    Dim ns As String
    ns = Trim(s)
    If Len(ns) > 0 Then
        While (isNoisy(Right(ns, 1)))
            ns = Left(ns, Len(ns) - 1)
        Wend
    End If
    noisyTrim = ns
End Function
Private Function nullItem(job As cJobject) As cJobject
    Set nullItem = Nothing
    
    If peek() = "," Then
    ' need an array element
    ' simulate a { 'x':'x}
        If pJtype = eDeserializeGoogleWire Then
            Set nullItem = job.add.add("v")
        Else
            Set nullItem = job.add
        End If
    End If
    

End Function

Private Function dsLoop(job As cJobject, complain As Boolean, _
        dealWithLikelyTimestamps As Boolean) As cJobject
    
    Dim cj As cJobject, jo As cJobject, ws As String
    Set jo = job
    pActive = True
    pWhatNext = "{["
    While pPointer <= Len(pJstring) And pActive
        Set jo = dsProcess(jo, complain, dealWithLikelyTimestamps)
    Wend
    Set dsLoop = job
End Function
Private Function okWhat(what As String) As Boolean

    okWhat = (InStr(pWhatNext, nOk) <> 0 And _
                (what = "." Or what = "-" Or IsNumeric(what))) Or _
                (InStr(pWhatNext, what) <> 0)

            
End Function
Private Function peekNextToken() As String
    ' this is in case the next token is a special
    Dim k As Long
    peekNextToken = vbNullString

    ignoreNoise
    k = pPointer
    While Not (isQuote(pointedAt(k)) Or isNoisy(pointedAt(k)) Or _
        IsNumeric(pointedAt(k)) Or 0 <> InStr("[]{},.:", pointedAt(k)))
        k = k + 1
    Wend
    If (k > pPointer) Then peekNextToken = LCase(pointedAt(, k - pPointer))
    
End Function

Private Function doNextToken() As String
    Dim nextToken As String
    ' poke around to fix exceptions like null, false, true
    nextToken = peekNextToken
    If nextToken = "null" Then
        pPointer = pPointer + Len(nextToken)
        ignoreNoise
        doNextToken = pointedAt
    ElseIf nextToken = "false" Then
        doNextToken = "0"
        pPointer = pPointer + Len(nextToken)
    ElseIf nextToken = "true" Then
        doNextToken = "1"
        pPointer = pPointer + Len(nextToken)
    End If
End Function
Private Function dsProcess(job As cJobject, complain As Boolean, _
        dealWithLikelyTimestamps As Boolean) As cJobject
        
    Dim k As Long, jo As cJobject, s As String, what As String, jd As cJobject, v As Variant
    Dim nextToken As String, nt As String, a As Variant, av As String, jt As cJobject
    'are we done?
    Set dsProcess = job
    If pPointer > Len(pJstring) Then Exit Function

    Set jo = job
    ignoreNoise

    nextToken = doNextToken
    If nextToken <> vbNullString Then
        what = nextToken
    Else
        what = pointedAt
    End If
    
    ' is it what was expected
    
    If Not okWhat(what) Then
        badJSON pWhatNext, , complain
        Exit Function
    End If
    ' process next token
    Select Case what
    ' start of key:value pair- do nothing except set up to get the key name
        Case "{"
            pPointer = pPointer + 1
            If jo.isArrayRoot Then Set jo = jo.add
            Set dsProcess = jo
            pWhatNext = anyQ & ",}"
            
    ' its the beginning of an array - need to kick off a new array
        Case "["
            pPointer = pPointer + 1
            If jo.isArrayRoot Then
                ' this is a double [[
                Set jo = jo.add
            End If
            If nullItem(jo.addArray) Is Nothing Then
                pWhatNext = nOk & anyQ & "{],["
            Else
                pWhatNext = ","
            End If
            Set dsProcess = jo

            
     ' could be a key or an array value
        Case q, qs, "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "."
            v = getvItem(dealWithLikelyTimestamps, , nextToken)
            If IsEmpty(v) Then
                badJSON pWhatNext, , complain
            Else
                ' start of key/value pair
                If peek() = ":" Then
                ' add as a new key, and set up for getting the value
                    Set jt = jo
                    Set jo = jo.add(CStr(v))
                    Set jo.backtrack = jt
                    
                    pWhatNext = ":"
                ElseIf jo.isArrayRoot Then
                ' an array value is allowed without a key
                    jo.add , v
                    pWhatNext = ",]"
                Else
                    badJSON pWhatNext, , complain
                End If
                Set dsProcess = jo

            End If

    ' its the value of a pair
        Case ":"
            pPointer = pPointer + 1
            nt = peekNextToken
            v = getvItem(dealWithLikelyTimestamps, , doNextToken)

            If IsEmpty(v) And nt <> "null" Then
                ' about to start an array rather than get a value
                pWhatNext = "{["
            Else
                ' store the value, come back for the next
                ' boolean hack
                If (v = 1 And nt = "true") Then
                    v = True
                ElseIf (v = 0 And nt = "false") Then
                    v = False
                End If
                jo.value = v
                Set jo = jo.backtrack
                pWhatNext = ",}"
            End If
            Set dsProcess = jo
            
        Case ","
    ' another value - same set
            pPointer = pPointer + 1
            If nullItem(jo) Is Nothing Then
                pWhatNext = nOk & anyQ & "{}],["
            Else
                pWhatNext = ","
            End If
            Set dsProcess = jo
            
        Case "}"
    ' backup a level
            pPointer = pPointer + 1
            pWhatNext = ",]}"
            Set dsProcess = jo.backtrack
               
        Case "]"
    ' backup a level
            pPointer = pPointer + 1
            pWhatNext = ",}]"
            Set dsProcess = jo.backtrack
            
        Case Else
    ' unexpected thing happened
            badJSON pWhatNext, , complain
    
    End Select

    
End Function
Private Function nOk() As String
    ' some character to say that a numeric is ok
    nOk = Chr(254)
End Function
Private Function getvItem(dealWithLikelyTimestamps As Boolean, _
    Optional whichQ As String = "", _
    Optional nextToken As String = vbNullString) As Variant
    
    Dim s As String
    ' is it a string?
    getvItem = Empty
    ignoreNoise
    Select Case nextToken
        Case "1"
            getvItem = 1
        Case "0"
            getvItem = 0
        Case Else
            If isQuote(pointedAt) Then
                getvItem = getQuotedItem(whichQ)
            Else
    ' maybe its a number
                s = getNumericItem
                If Len(s) > 0 Then getvItem = toNumber(s, dealWithLikelyTimestamps)
            End If
    End Select
    
End Function
Private Function peek() As String
    Dim k As Long
    ' peek ahead to next non noisy character
    k = pPointer
    ignoreNoise
    peek = pointedAt
    pPointer = k
End Function
Private Function peekBehind() As String
    Dim k As Long
    k = pPointer - 1
    While k > 0 And isNoisy(pointedAt(k))
        k = k - 1
    Wend
    If k > 0 Then
        peekBehind = pointedAt(k)
    End If
End Function
Private Function toNumber(sIn As String, dealWithLikelyTimestamps As Boolean) As Variant
    ' convert string to numeric , either double or long
    Dim ts As String, s As String, x As Date
 ' find out the '.' separator for this locale
    ts = Mid(CStr(1.1), 2, 1)
 ' and use it so that cdbl works properly
    s = Replace(sIn, ".", ts)
    On Error GoTo overflow
   

    If InStr(1, s, ts) Then
        toNumber = CDbl(s)
    Else
        toNumber = CLng(s)
    End If
    Exit Function
    
overflow:
    'perhaps this is a javascript date
    On Error GoTo overflowAgain
    If (Len(s) = 13 And dealWithLikelyTimestamps And Not InStr(1, s, ts)) Then
        x = DateAdd("s", CDbl(Left(s, 10)), DateSerial(1970, 1, 1))
    Else
        ' we're not going to convert to date, so try to overflow to a double
        x = CDbl(s)
    End If
    toNumber = x
    Resume Next
    Exit Function
    
overflowAgain:
    'this wasnt a javascript date or a convertable number
    toNumber = 0
    Resume Next
    Exit Function
    
End Function
Private Function pointedAt(Optional pos As Long = 0, Optional sLen As Long = 1) As String
    ' return what ever the currently quoted character is
    Dim k As Long
    If pos = 0 Then
        k = pPointer
    Else
        k = pos
    End If
    pointedAt = Mid(pJstring, k, sLen)
End Function

Private Function getQuotedItem(Optional whichQ As String = "") As String
    Dim s As String, k As Long, wq As String
    ignoreNoise
    s = ""

    If isQuote(pointedAt, whichQ) Then
        wq = pointedAt
    ' extract until the next matching quote
        k = pPointer + 1

        While Not isQuote(pointedAt(k), wq)
          If isUnicode(pointedAt(k, 2)) Then
            s = s & ChrW(CLng("&H" & pointedAt(k + 2, 4)))
            'S = S & StrConv(Hex2Dec(pointedAt(k + 2, 4)), vbFromUnicode)
            k = k + 6
            
          ElseIf isEscape(pointedAt(k)) Then
            Select Case LCase(pointedAt(k + 1))
                Case "t"
                    s = s & vbTab
                Case "n"
                    s = s & vbLf
                Case "r"
                    s = s & vbCr
                Case Else
                    s = s & pointedAt(k + 1)
            End Select
            k = k + 2
          Else
            s = s & pointedAt(k)
            k = k + 1
          End If
        Wend
        pPointer = k + 1
    End If
    getQuotedItem = s

End Function

Private Function getNumericItem() As String
    Dim s As String, k As Long, eAllowed As Boolean
    ignoreNoise
    s = vbNullString
    eAllowed = False
    k = pPointer
    While IsNumeric(pointedAt(k)) Or pointedAt(k) = "." Or pointedAt(k) = "-" Or (eAllowed And pointedAt(k) = "E")
        s = s & pointedAt(k)
        eAllowed = InStr(1, s, "E") < 1
        k = k + 1
    Wend
    pPointer = pPointer + Len(s)

    getNumericItem = s
    
End Function


Private Function isQuote(s As String, Optional whichQ As String = "") As Boolean
    If Len(whichQ) = 0 Then
        ' any quote
        isQuote = (s = q Or s = qs)
    Else
        isQuote = (s = whichQ)
    End If
End Function
Private Sub badJSON(pWhatNext As String, Optional add As String = "", Optional complain As Boolean = True)
    If (complain) Then
        MsgBox add & "got " & pointedAt & " expected --(" & pWhatNext & _
            ")-- Bad JSON at character " & CStr(pPointer) & " starting at " & _
            Mid(pJstring, pPointer)
    End If
    pValid = False
    pActive = False
    
End Sub

Private Sub ignoreNoise(Optional pos As Long = 0, Optional extraNoise As String = "")
    Dim k As Long, t As Long
    If pos = 0 Then
        t = pPointer
    Else
        t = pos
    End If
    For k = t To Len(pJstring)
        If Not isNoisy(Mid(pJstring, k, 1), extraNoise) Then Exit For
    Next k
    pPointer = k
End Sub
Private Function isNoisy(s As String, Optional extraNoise As String = "") As Boolean
    isNoisy = InStr(vbTab & " " & vbCrLf & vbCr & vbLf & extraNoise, s)
End Function
Private Function isEscape(s As String) As Boolean
    isEscape = (s = "\")
End Function
Private Function isUnicode(s As String) As Boolean
    isUnicode = LCase(s) = "\u"
End Function
Private Function q() As String
    q = Chr(34)
End Function
Private Function qs() As String
    qs = Chr(39)
End Function
Private Function anyQ() As String
    anyQ = q & qs
End Function

Public Function sortByValue() As cJobject
    ' sorts an objects children by their keys
    Dim job As cJobject, i As Long
    
    ' this will be accessed by needswap
    
    SortColl children, eSortAscending
    
    ' now need to sort out the indexes
    i = 0
    For Each job In children
        i = i + 1
        job.childIndex = i
    Next job
    Set sortByValue = Me
End Function
Public Function needSwap(cc As cJobject, e As eSort) As Boolean
    ' this can be used from a sorting alogirthm
    
    Dim a As Variant, b As Variant

    Select Case e
        Case eSortAscending
            needSwap = sortNorm(cValue(pbyKey)) > sortNorm(cc.cValue(pbyKey))
            
        Case eSortDescending
            needSwap = sortNorm(cValue(pbyKey)) < sortNorm(cc.cValue(pbyKey))
    
        Case Else
            needSwap = False
    End Select
End Function
Private Function sortNorm(v As Variant) As Variant

    If (VarType(v) = vbString) Then
        sortNorm = LCase(v)
    Else
        sortNorm = v
    End If
    
End Function
Private Sub Class_Initialize()
    pisArrayRoot = False
    pValid = True
    pIndex = 1
    Set pChildren = New Collection
End Sub
Public Sub tearDown()
    Dim cj As cJobject
    If Not pChildren Is Nothing Then
        For Each cj In pChildren
            cj.tearDown
        Next cj
    End If
    Set pParent = Nothing
    Set pBacktrack = Nothing
    Set pChildren = Nothing
End Sub









Attribute VB_Name = "cOauth2"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 3:54:14 PM : from manifest:5055578 gist https://gist.github.com/brucemcpherson/6937450/raw/cOauth2.cls
Option Explicit
'" based on Kyle Beachill Oauth2
'" for credits and details see
'" http://ramblings.mcpher.com/Home/excelquirks/guests/oauth2
' for details on this implementation see http://ramblings.mcpher.com/Home/excelquirks/googleoauth2
' v1.5

Private pPackage As cJobject
Private pCb As cBrowser
Private pDialog  As cJobject
Private pSalt As String
Private pMessage As String


Public Function googleAuth(scopeEntry As String, _
        Optional replacementConsole As cJobject = Nothing, _
        Optional clientID As String = vbNullString, _
        Optional clientSecret As String = vbNullString, _
        Optional complain As Boolean = True, _
        Optional cloneFromScopeEntry As String = vbNullString, _
        Optional apikey As String = vbNullString) As cOauth2
    
    ' this will do an oauth2 against google - the generated token() is usuable for subsequent requests against the given scope
    ' a auth interactive dialog wont be necessary if there is a refresh token, or an unexpired auth token
    ' available in the registry for this user.
    ' All data in registry is encrypted, and package from the last access is stored there
    ' this mimics the behavior of sites that authorized against google credentials
    
    ' setting up for the fist time.
    ' the first time this is used, there is nothing in the registry, so this needs to be called with either
    ' a cJobject which is simply the JSONPARSE of the string you can download from google when you register an app
    ' or, the clientID and client secret
    ' or you can clone all this from another scope
    ' once this has ever been called, the registry is used for the source of all this.
    
    ' refreshing the registry
    ' if for any reason the registry is stale, just repeat as if setting up for the first time
    Dim authFlavor As String, aKey As String, sKey As String, clonePackage As cJobject
    authFlavor = "google"
    aKey = "type_" & authFlavor
    sKey = "scope_" & scopeEntry

    Set googleAuth = Me
    
    ' first see if we are cloning from another scope
    If (cloneFromScopeEntry <> vbNullString) Then
        Set clonePackage = getRegistryPackage(aKey, "scope_" & cloneFromScopeEntry)
    End If
    
    If (clientID <> vbNullString Or clientSecret <> vbNullString Or Not replacementConsole Is Nothing _
        Or Not clonePackage Is Nothing) Then
        ' need a refresh
        If (clonePackage Is Nothing) Then
            Set pPackage = googlePackage(replacementConsole)
        Else
            ' use the cloned credentials, but revoke it to force a new authentication
            Set pPackage = clonePackage
            revoke
        End If
        ' use replacement package and add any passwords passed over (they may already be in the package)
        With pPackage.child("parameters")
            If clientSecret <> vbNullString Then .add "client_secret", clientSecret
            If clientID <> vbNullString Then .add "client_id", clientID
            .add "authFlavor", aKey
            .add "scopeEntry", sKey
        End With
        ' store this too
        If (apikey <> vbNullString) Then
            pPackage.add "custom.apiKey", apikey
        End If
    Else
        ' get existing ppackage from registry if there is one
        Set pPackage = getRegistryPackage(aKey, sKey)
        If (pPackage Is Nothing) Then
            pMessage = "need to supply new credentials - nothing in registry"
            Exit Function
        End If
    
    End If
    ' this looks up the URL for the given scope entry
    addGoogleScope (scopeEntry)
    
    ' do the auth
    If (Not hasRefreshToken) Then
'        " first step is to either get user consent and get a new token
        getUserConsent
'        " now get an access token
        Set googleAuth = getToken
    
    ElseIf (isExpired) Then
'        " or to refresh an old one
        Set googleAuth = getToken("refresh_token")
        
    Else
    
'        " or we are already good
        Set googleAuth = Me
    End If
    
'    " update registry package
    setRegistryPackage
    

End Function
'" do we have a token
Public Property Get hasToken() As Boolean
    hasToken = token <> ""
End Property
' the auth header
Public Property Get authHeader() As String
    If hasToken Then authHeader = tokenType & " " & token
End Property
'" the token
Public Property Get token() As String
    token = getItemValue("parameters.access_token")
End Property
Public Property Get apikey() As String
    apikey = getItemValue("custom.apikey")
End Property
'" the denied error
Public Property Get denied() As String
    denied = getItemValue("parameters.deniedCode") & pMessage
End Property
Private Function revoke() As cOauth2
    With pPackage.child("parameters")
        .add "access_token", vbNullString
        .add "refresh_token", vbNullString
        .add "code", vbNullString
    End With
    Set revoke = Me
End Function
'" the first phase - get user consent to proceed
Private Function getUserConsent() As cOauth2

    If pCb Is Nothing Then
        Set pCb = New cBrowser
    End If
    Dim phase As String
    phase = "userConsent"
    
    With pCb
        .Init().Navigate _
            createUrl(phase) & "?" & generatePhaseParameters(phase), True
'        " store results
        With pPackage.child("parameters")
            .add "code", pCb.successCode
            .add "deniedCode", pCb.deniedCode
        End With
    End With
    
    Set getUserConsent = Me
End Function

'" if we got user consent, then we can go ahead and get an access token
Private Function getToken(Optional phase As String = "authorization_code") As cOauth2

    Dim job As cJobject, joc As cJobject

    If isAuthenticated Then
        If pCb Is Nothing Then
            Set pCb = New cBrowser
        End If
        
        pPackage.child("parameters").add "grant_type", phase
        pCb.httpPost createUrl(phase), generatePhaseParameters(phase)
        With pPackage.child("parameters")
            If (pCb.status <> 200) Then
                revoke
                .add "deniedCode", pCb.status

            Else
                Set job = JSONParse(pCb.Text)

                For Each joc In job.children
                    .add joc.Key, joc.value
                Next joc
                If hasRefreshToken Then
                    .add "expires", addSeconds(Now(), expiresIn)
                End If

            End If
        End With
    End If
    Set getToken = Me
    
End Function
Private Function addSeconds(d As Date, n As Long) As Date
    addSeconds = DateAdd("s", n, d)
End Function
'" - none of these need to be exposed --
'" do we have user consent
Private Property Get isAuthenticated() As Boolean
    isAuthenticated = code <> ""
End Property

Private Property Get tokenType() As String
    tokenType = getItemValue("parameters.token_type")
End Property
Private Property Get expiresIn() As Long
    expiresIn = getItemValue("parameters.expires_in")
End Property
Private Property Get expires() As Date
    expires = getItemValue("parameters.expires")
End Property
'" the user consent
Private Property Get code() As String
    code = getItemValue("parameters.code")
End Property
Private Property Get hasRefreshToken() As Boolean
    hasRefreshToken = refreshToken <> vbNullString
End Property
Private Property Get isExpired() As Boolean
    isExpired = addSeconds(Now(), 660) > expires
    
End Property

'" the refresh token
Private Property Get refreshToken() As String
    refreshToken = getItemValue("parameters.refresh_token")
End Property
Private Function getItemValue(Key As String) As String
    On Error GoTo crapped
        If Not pPackage Is Nothing Then
            getItemValue = pPackage.child(Key).toString
        Else
            getItemValue = vbNullString
        End If
        Exit Function
crapped:
    getItemValue = vbNullString
End Function
Private Function createUrl(parameterType As String) As String
    createUrl = getItemValue("parameters." & pDialog.child(parameterType).toString("url"))
End Function

Private Function generatePhaseParameters(whichPhase As String) As String
    Dim joc As cJobject, s As cStringChunker
'    " this will construct a parameterstring for everything needed for an authentication phase
    Set s = New cStringChunker
    With pDialog.child(whichPhase).child("parameters")
       For Each joc In .children
           With pPackage.child("parameters").child(joc.value)
               If (.toString <> vbNullString) Then
                   s.add(.Key).add("=").add(.toString).add ("&")
               End If
           End With
       Next joc
    End With
    generatePhaseParameters = s.chopIf("&").content
    Set s = Nothing
End Function

'" release up memory - should be called when done
Public Function tearDown() As cOauth2
    If (Not pPackage Is Nothing) Then
        pPackage.tearDown
        Set pPackage = Nothing
    End If
    If (Not pDialog Is Nothing) Then
        pDialog.tearDown
        Set pDialog = Nothing
    End If
    If (Not pCb Is Nothing) Then
        pCb.tearDown
        Set pCb = Nothing
    End If
    Set tearDown = Me
End Function

'"---- encryption ----
Public Property Let salt(p As String)
'    " you can change the encrypt salt if necessary
    pSalt = p
End Property
Private Function encrypt(s As String) As String
'   encryptin not needed for registry
    encrypt = s
End Function
Private Function decrypt(s As String) As String
'   encryptin not needed for registry
    decrypt = s
End Function
'" ---- registry -----
'" in registry entries, the values are encrypted useing the salt
'" the structure is
'" xLiberation/googleAuth/scope - json pPackage values
Private Function getRegistryPackage(authFlavor As String, scopeEntry As String) As cJobject
    Dim s As String
    s = GetSetting("xLiberation", _
            authFlavor, _
            scopeEntry)
    
    If (s <> vbNullString) Then Set getRegistryPackage = JSONParse(decrypt(s))
End Function
Private Function setRegistryPackage() As cJobject
    Dim s As String
    s = JSONStringify(pPackage)
    SaveSetting "xLiberation", _
            getItemValue("parameters.authFlavor"), _
            getItemValue("parameters.scopeEntry"), _
            encrypt(s)
            
End Function
Private Function describeDialog() As cJobject
    Set describeDialog = JSONParse( _
    "{'userConsent':" & _
        "{'url':'url','parameters':" & _
            "['response_type','token_uri','redirect_uri','client_id','scope']}," & _
    "'authorization_code':{'url':'token_uri','parameters':['code','client_id'," & _
    "'client_secret','redirect_uri','grant_type']}," & _
    "'refresh_token':{'url':'refresh_uri','parameters'" & _
    ":['refresh_token','client_id','client_secret','grant_type']}}")
     
End Function
'" this is the package describing google oauth2
Private Function googlePackage(Optional consolePackage As cJobject = Nothing) As cJobject
    Dim job As cJobject, package As cJobject, p As cJobject, c As cJobject

    ' use data provided or create an empty one
    If consolePackage Is Nothing Then
        Set job = makeBasicGoogleConsole()
    Else
        Set job = consolePackage
    End If
    
    Set package = skeletonPackage
    Set c = job.child("installed")
    Set p = package.child("parameters")
    
    addFromOther c, p, "url", "auth_uri"
    addFromOther c, p, "token_uri"
    p.add "response_type", "code"
    p.add "redirect_uri", c.child("redirect_uris.1").value
    addFromOther c, p, "client_id"
    addFromOther c, p, "client_secret"
    addFromOther c, p, "refresh_uri", "token_uri"
    p.add "grant_type", "authorization_code"

    
    Set googlePackage = package
    If (consolePackage Is Nothing) Then job.tearDown
    
End Function
Private Sub addFromOther(c As cJobject, p As cJobject, k As String, Optional ok As String = vbNullString)
    If ok = vbNullString Then ok = k
    With p
        If Not c.childExists(ok) Is Nothing Then
            .add k, c.child(ok).value
        Else
            .add k
        End If
    End With
End Sub
Public Function addGoogleScope(s As String) As cOauth2
    

    With pPackage.child("parameters")
        Select Case s
            Case "analytics"
                .add "scope", URLEncode("https://www.googleapis.com/auth/analytics.readonly")
            
            Case "drive"
                .add "scope", URLEncode("https://www.googleapis.com/auth/drive")
                
            Case "driveexternal"
                .add "scope", URLEncode("https://www.googleapis.com/auth/drive") & "+" & _
                     URLEncode("https://www.googleapis.com/auth/script.external_request")

            Case "feeds"
                .add "scope", URLEncode("https://spreadsheets.google.com/feeds")
                
            Case "viz"
                .add "scope", URLEncode("https://spreadsheets.google.com/feeds") + "+" & _
                     URLEncode("https://www.googleapis.com/auth/drive")
            
            Case "urlshortener"
                .add "scope", URLEncode("https://www.googleapis.com/auth/urlshortener")
                
            Case "sheets"
                .add "scope", URLEncode("https://www.googleapis.com/auth/spreadsheets")
                
            Case "MMo4EFhHV6wqa7IdrGew0eiz3TLx7pV4j"
                .add "scope", URLEncode("https://www.googleapis.com/auth/spreadsheets")
                
            Case "drivesheets"
                .add "scope", URLEncode("https://www.googleapis.com/auth/drive") & "+" & _
                     URLEncode("https://www.googleapis.com/auth/spreadsheets")
                
            Case "drivesheetsexternal"
                .add "scope", URLEncode("https://www.googleapis.com/auth/drive" & " " & _
                     "https://www.googleapis.com/auth/script.external_request" & " " & _
                     "https://www.googleapis.com/auth/spreadsheets")
            
            Case "MCdA2axM9sPPJZcPjFLQZb2lFl_CRdesR"
                .add "scope", URLEncode("https://www.googleapis.com/auth/spreadsheets")
                     
            Case Default
                Debug.Assert False
        End Select
    End With
    Set addGoogleScope = Me
End Function

Private Function makeBasicGoogleConsole() As cJobject
    Dim consoleJSON As String
'    " when you register your app with google, you can download the Json
    
    consoleJSON = _
"{'installed':{'auth_uri':'https://accounts.google.com/o/oauth2/auth'," & _
  "'token_uri':'https://accounts.google.com/o/oauth2/token'," & _
  "'redirect_uris':['urn:ietf:wg:oauth:2.0:oob','oob']," & _
  "'auth_provider_x509_cert_url':'https://www.googleapis.com/oauth2/v1/certs'}}"

'  " then parse it
  Set makeBasicGoogleConsole = JSONParse(consoleJSON)
End Function
Public Function skeletonPackage() As cJobject
    Dim package As cJobject
    Set package = New cJobject
    With package.Init(Nothing)
        With .add("parameters")
            .add "url"
            .add "token_uri"
            .add "response_type"
            .add "redirect_uri"
            .add "client_id"
            .add "code"
            .add "client_secret"
            .add "refresh_uri"
            .add "grant_type"
            .add "scope"
            .add "authFlavor"
            .add "scopeEntry"
            .add "deniedCode"
        End With
    End With
    Set skeletonPackage = package
End Function


Private Sub Class_Initialize()
    Set pDialog = describeDialog
    pSalt = "xLiberation"
End Sub












Attribute VB_Name = "cSheetsV4"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private pSheetId As String
Private pAccessToken As String
Private pBrowser As cBrowser
Private pRoot As String
Private pAuthName As String

Public Function setSheetId(id) As cSheetsV4
    pSheetId = id
    Set setSheetId = Me
End Function

Public Function getSheetId() As String
    getSheetId = pSheetId
End Function
Public Function setAuthName(nm) As cSheetsV4
    pAuthName = nm
    Set setAuthName = Me
End Function
Public Function getAuthName() As String
    getAuthName = pAuthName
End Function
Public Function getSheets() As cJobject
    Set getSheets = urlExecute(pSheetId, encodeFields(getSheetDefs()))
End Function
Public Function insertSheet(sheetName As Variant) As cJobject
    Dim s As String, payload As New cJobject
    s = CStr(sheetName)
    
    With payload.Init(Nothing).add("requests").addArray
        With .add
            With .add("addSheet")
                With .add("properties")
                    .add "title", s
                End With
            End With
        End With
    End With
    Set insertSheet = urlExecute(pSheetId & ":batchUpdate", encodeFields(getInsertSheetDefs()), "POST", payload)
    payload.tearDown

End Function
Public Function clearValues(sheetName As String, rangeA1 As String) As cJobject
'Stop
    Set clearValues = urlExecute(pSheetId & "/values/" & _
      URLEncode(sheetName & "!" & Replace(rangeA1, "$", "")) & ":clear", , "POST")
          
End Function
Public Function getValues(ranges As String) As cJobject
    Set getValues = urlExecute(pSheetId & "/values:batchGet", _
      getValuesParams & "&" & getRangesParams(ranges) & "&" & _
      encodeFields(getValuesDefs()))
End Function
Public Function setValues(values As Variant, sheetName As String, rangeA1 As String) As cJobject
    Dim payload As cJobject
    '// convert array to object
    Set payload = getValuesPayload(values, sheetName, rangeA1)
    
    ''// do the api call
    Set setValues = urlExecute(pSheetId & "/values:batchUpdate", _
        encodeFields("responses"), "POST", _
        payload _
    )
    '// clean
    payload.tearDown
End Function
Public Function getValuesPayload(values As Variant, sheetName As String, rangeA1 As String) As cJobject
    Dim i As Long, j As Long, payload As New cJobject
    ' only using a:z for now TODO.. make it more specific
    With payload.Init(Nothing)
        .add "valueInputOption", "USER_ENTERED"
        With .add("data").addArray.add
            .add "range", sheetName & "!" & Replace(rangeA1, "$", "")
            With .add("values").addArray
                For i = LBound(values, 1) To UBound(values, 1)
                    With .add.addArray
                        For j = LBound(values, 2) To UBound(values, 2)
                            .add , values(i, j)
                        Next j
                    End With
                Next i
            End With
        End With
    End With
    
    Set getValuesPayload = payload
End Function
Private Function getSheetDefs() As String
    getSheetDefs = "sheets(properties(sheetId,title))"
End Function
Private Function getInsertSheetDefs() As String
    getInsertSheetDefs = "replies(addSheet)"
End Function
Private Function getValuesDefs() As String
    getValuesDefs = "valueRanges(range,values)"
End Function
Private Function getValuesParams() As String
    getValuesParams = "dateTimeRenderOption=SERIAL_NUMBER&valueRenderOption=FORMATTED_VALUE"
End Function
Private Function getRangesParams(ranges) As String
    Dim a As Variant, i As Long, c As New cStringChunker
    a = Split(ranges, ",")
    For i = LBound(a) To UBound(a)
        c.add("ranges=").uri(CStr(a(i))).add "&"
    Next i
    getRangesParams = c.chopWhile("&").toString
    
End Function

'/**
'* encode partial field definitions
'* @param {[string]} varArray actually this is any number of args
'* @return {string} the encoded fields
'*/
Private Function encodeFields(ParamArray arguments() As Variant) As String
    Dim c As New cStringChunker, i
    encodeFields = ""
    For i = LBound(arguments) To UBound(arguments)
        c.uri(CStr(arguments(i))).add (",")
    Next i
    If (c.size > 0) Then
        encodeFields = "fields=" & c.chopWhile(",").toString
    End If
End Function

'/* execute a API request
'  * @param {string} urlTail the url appendage
'  * @param {string} [params] the params
'  * @param {string} [method=GET] what to do
'  * @param {cJobject} [payload] teh payload
'  * @return {cjobject} a standard response object
'  */
Private Function urlExecute(urlTail As String, _
    Optional params As String = vbNullString, _
    Optional Method As String = "GET", _
    Optional payload As cJobject = Nothing) As cJobject

    Dim url As String, body As String, ob As cJobject, paramstring As New cStringChunker
    Dim result As New cJobject, googled As cOauth2
    body = ""
    If (isSomething(payload)) Then
        body = payload.stringify
    End If
    Set googled = getGoogled(pAuthName)

    paramstring.add("?key=").add googled.apikey
    If (params <> vbNullString) Then
        paramstring.add("&").add params
    End If
    '//--------
    url = pRoot & urlTail & paramstring.toString
    If (Method <> "GET") Then
        pBrowser.httpPost url, body, True, googled.authHeader, , Method
    Else
        pBrowser.httpGET url, , , , , googled.authHeader
    End If
    
    result.Init(Nothing).add "response", pBrowser.Text
    
    If (pBrowser.isOk()) Then
        Set ob = JSONParse(pBrowser.Text)
        result.add("data").attach ob
        result.add "success", ob.childExists("error") Is Nothing
        
    Else
        result.add "success", False
    End If
    
    Set urlExecute = result
    
End Function

 
  

Private Sub Class_Initialize()
    ' default url for sheets api
    pRoot = "https://sheets.googleapis.com/v4/spreadsheets/"
    Set pBrowser = New cBrowser
End Sub

Attribute VB_Name = "cStringChunker"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 4:48:00 PM : from manifest:7471153 gist https://gist.github.com/brucemcpherson/5102369/raw/cStringChunker.cls

Option Explicit
' v1.09  5102369
Private pContent As String
Private pSize As Long
' minimum amount to increment by each time
Const defaultChunkSize = 64
'/**
' * stringChunker class for VBA because string concat takes ages
' */

'/**
' * get the length of the current string
' *@return {long} the length of the current string
' */
Public Property Get size() As Long
    ' this is how much content is real
    size = pSize
End Property
'/**
' * get the content of the current string
' *@return {string} the current string
' */
Public Property Get content() As String
    ' return the real part of the content
    If pSize > 0 Then
        content = getLeft(size)
    Else
        content = vbNullString
    End If
End Property
'/**
' *extract the leftmost portion of a string
' *@param {} howMany the length of the string to return
' *@return {string} the current string
' */
Public Property Get getLeft(howMany As Long) As String
    ' return the left part of the content
    ' c.getLeft(howmany) is equivalent to left(c.content,howmany), but avoids extra assignment
    getLeft = getMid(1, howMany)
End Property
'/**
' *extract the rightmost portion of a string
' *@param {} howMany the length of the string to return
' *@return {string} the current string
' */
Public Property Get getRight(howMany As Long) As String
    ' return the right part of the content
    ' c.getRight(howmany) is equivalent to right(c.content,howmany), but avoids extra assignment
    getRight = getMid(pSize - howMany + 1, howMany)
End Property
'/**
' *extract a portion of a string
' *@param {} startPos the (1 base) start position to extraction from
' *@param {} howMany the length of the string to return
' *@return {string} the current string
' */
Public Property Get getMid(startPos As Long, _
            Optional howMany As Long = -1) As String
    ' extract from content
    ' c.getMid(startPos,howmany) is equivalent to mid(c.content,startPos, howmany), but avoids extra assignment
    Dim n As Long
    Debug.Assert startPos > 0 And startPos <= pSize
    n = howMany
    If n = -1 Then
        n = pSize - startPos + 1
    End If
    n = minNumber(pSize - startPos + 1, n)
    If n > 0 Then
        getMid = Mid(pContent, startPos, n)
    Else
        getMid = vbNullString
    End If
End Property
'/**
' *a self reference (useful for inside with..)
' *@return {} self
' */
Public Property Get self() As cStringChunker
    ' convenience for with in with
    Set self = Me
End Property
'/**
' *clear a chunker (set string to null)
' *@return {} self
' */
Public Function clear() As cStringChunker
    ' easy to clear out.. may as well keep the same buffer going
    pSize = 0
    Set clear = Me
End Function
'/**
' *encode a uri and add
' *@param {} url the url to add
' *@return {} self
' */
Public Function uri(url As String) As cStringChunker
    Set uri = add(URLEncode(url))
End Function
'/**
' *return the string
' *@return {} the string
' */
Public Function toString() As String
    toString = content()
End Function
'/**
' *add a string to the chunker
' *@param {} addstring the string to add
' *@return {} self
' */
Public Function add(addString As String) As cStringChunker
    Dim k As Long
    ' add some content to end
    k = Len(addString)
    If k > 0 Then
        adjustSize (k)
    
        Mid(pContent, size + 1, k) = addString
        pSize = size + k
    End If
    Set add = Me
End Function
'/**
' *add a string to the chunker, followed by a new line
' *@param {} addstring the string to add
' *@return {} self
' */
Public Function addLine(Optional addString As String = "") As cStringChunker
    Set addLine = add(addString).add(vbCrLf)
End Function
'/**
' *add a number of new lines
' *@param {} howMany number of lines to add
' *@return {} self
' */
Public Function addLines(Optional howMany As Long = 1) As cStringChunker
    Dim i As Long
    For i = 1 To howMany
        addLine
    Next i
   Set addLines = Me
End Function
'/**
' *insert a string at a particular position
' *@param {} insertString the string to insert (default 1 space)
' *@param {} insertBefore the position(base 1) before which to insert
' *@return {} self
' */
Public Function insert(Optional insertString As String = " ", _
                    Optional insertBefore As Long = 1) As cStringChunker
    'default position is at beginning, insert a space
    'c.insert("x",c.size+1) is equivalent to c.add("x")
    
    If insertBefore = pSize + 1 Then
        Set insert = add(insertString)
        
    Else
        ' 'todo .. how to handle programming errors?
        Debug.Assert insertBefore > 0 And insertBefore <= pSize
        
        ' regular string concatenation is better since there is overlap
        pContent = getLeft(insertBefore - 1) & insertString & getMid(insertBefore)
        pSize = Len(pContent)
        Set insert = Me
            
    End If
    Set insert = Me
End Function
'/**
' *overwrite a string at a particular position
' *@param {} overWriteString the string to insert (default 1 space)
' *@param {} overWriteAt the position(base 1) to start overwriting at
' *@return {} self
' */
Public Function overwrite(Optional overWriteString As String = " ", _
                    Optional overWriteAt As Long = 1) As cStringChunker
    'default position is at beginning, overwrite with a space
    Dim k As Long
    k = Len(overWriteString)
    If k > 0 Then
        ' 'todo .. how to handle programming errors?
        Debug.Assert overWriteAt >= 0
        '' we'll allow overwrite to extend past end, be greedy
        adjustSize (k)
        pSize = maxNumber(pSize, k + overWriteAt - 1)
        
        Mid(pContent, overWriteAt, k) = overWriteString
        
    End If
    Set overwrite = Me
End Function
'/**
' *shift the contents inside the chunker space
' *@param {} startPos the start position (base 1) of the string to shift
' *@param {} howManyChars the length of the string to shift (-ve means left, +ve right)_
' *@param {} replaceWith what to replace the moved contents with
' *@return {} self
' */
Public Function shift(Optional startPos As Long = 1, _
                Optional howManyChars As Long = 0, _
                Optional replaceWith As String = vbNullString) As cStringChunker
    ' shift by howmany chars .. negative= left, positive = right
    'TODO how to deal with programming errors? message, raise error, assert?
    Dim howMany As Long
    
    
    howMany = howManyChars
    If howMany = 0 Then
        howMany = Len(replaceWith)
    End If
        
    Debug.Assert howMany + startPos > 0
    Debug.Assert startPos <= pSize And startPos > 0
    
    ' make space
    If howMany <> 0 Then

        If howMany > 0 Then
        ' its a right shift, use insert
            Set shift = insert(Space(howMany), startPos)
        Else
            ' a left shift
            If startPos > 1 Then
                ' we can do an overwrite
                overwrite getMid(startPos, pSize + howMany), startPos + howMany
                pSize = pSize + howMany
            End If
        
        End If
    End If
    
    Set shift = Me
End Function
'/**
' *chop characters from the end of the content
' *@param {} howMany number of characters to chop
' *@return {} self
' */
Public Function chop(Optional howMany As Long = 1) As cStringChunker
    ' chop n charaters from end of content
    pSize = maxNumber(0, pSize - howMany)
    Set chop = Me
End Function
'/**
' *trim \s type chars from beginning and end
' *@param {} fromBeginning trim the beginnging of the content
' *@param {} fromEnd trim the end of the content
' *@return {} self
' */
Public Function chopSuperTrim(Optional fromBeginning As Boolean = True, _
    Optional fromEnd As Boolean = True) As cStringChunker
    
    Dim s As String, l As Long
    s = " " & vbCr & vbLf & vbTab

    If (fromEnd) Then
        Do While (pSize > 0)
            If (InStr(1, s, getRight(1)) = 0) Then Exit Do
            chop
        Loop
    End If
    
    l = 0
    If (fromBeginning) Then
        Do While (l < pSize)
            If (InStr(1, s, getMid(l + 1, 1)) = 0) Then Exit Do
            l = l + 1
        Loop
        ' l is the number of chars that are \s
        If (l > 0) Then shift l + 1, -l
    End If
    
    Set chopSuperTrim = Me
End Function
'/**
' *trim chars from end of content
' *@param {} chopString trim the beginnging of the content
' *@return {} self
' */
Public Function chopIf(chopString As String) As cStringChunker
    ' chop if content ends with chopString
    Dim k As Long
    k = Len(chopString)
    If k <= pSize Then
        If getRight(k) = chopString Then
            chop (k)
        End If
    End If
    Set chopIf = Me
End Function
'/**
' *trim chars from end of content and keep doing it while it matches
' *@param {} chopString trim the beginnging of the content
' *@return {} self
' */
Public Function chopWhile(chopString As String) As cStringChunker

    Dim k As Long, x As Long
    
    Set chopWhile = Me
    x = pSize
    While chopIf(chopString).size <> x
        x = pSize
    Wend

End Function
'/**
' *local max function
' *@param {} a first number to compare
' *@param {} b second number to compare
' *@return {} the bigger of a and b
' */
Private Function maxNumber(a As Long, b As Long) As Long
    If a > b Then
        maxNumber = a
    Else
        maxNumber = b
    End If
End Function
'/**
' *local min function
' *@param {} a first number to compare
' *@param {} b second number to compare
' *@return {} the smaller of a and b
' */
Private Function minNumber(a As Long, b As Long) As Long
    If a < b Then
        minNumber = a
    Else
        minNumber = b
    End If
End Function
'/**
' *adjust the underlying chunker buffer size if its needed
' *@param {} needMore how many chars we want space for
' *@return {} self
' */
Private Function adjustSize(needMore As Long) As cStringChunker
    Dim need As Long
    need = pSize + needMore
    If Len(pContent) < need Then
        pContent = pContent & Space(needMore + maxNumber(defaultChunkSize, Len(pContent)))
    End If
    Set adjustSize = Me
End Function
'/**
' *intialize some starting buffer
' */
Private Sub Class_Initialize()
    pSize = 0
    pContent = Space(defaultChunkSize)
End Sub








Attribute VB_Name = "cregXLib"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 4:47:48 PM : from manifest:3414394 gist https://gist.github.com/brucemcpherson/3414836/raw/cregXLib.cls
Option Explicit
' v2.02
'for more about this
' http://ramblings.mcpher.com/Home/excelquirks/classeslink/data-manipulation-classes
'to contact me
' http://groups.google.com/group/excel-ramblings
'reuse of code
' http://ramblings.mcpher.com/Home/excelquirks/codeuse
' for building up a library of useful regex expressions
Private pName As String
Private pRegex As RegExp
Public Property Get pattern() As String
    pattern = pRegex.pattern
End Property
Public Property Let pattern(p As String)
    pRegex.pattern = p
End Property
Public Property Get NAME() As String
    NAME = pName
End Property
Public Property Let NAME(p As String)
   pName = p
End Property
Public Property Get ignorecase() As Boolean
    ignorecase = pRegex.ignorecase
End Property
Public Property Let ignorecase(p As Boolean)
     pRegex.ignorecase = p
End Property
Public Property Get rGlobal() As Boolean
    rGlobal = pRegex.Global
End Property
Public Property Let rGlobal(p As Boolean)
   pRegex.Global = p
End Property

Public Sub Init(sname As String, _
            Optional spat As String = "", _
            Optional bIgnoreSpaces As Boolean = True, _
            Optional bIgnoreCase As Boolean = True, _
            Optional bGlobal As Boolean = True)
    
    Dim s As String
    s = spat
    If bIgnoreSpaces Then
        s = Replace(s, " ", "")
    End If
    Set pRegex = New RegExp
    With pRegex
        .pattern = s
        .ignorecase = bIgnoreCase
        .Global = bGlobal
    End With
    pName = sname

End Sub
Public Function getString(sFrom As String) As String
    Dim mc As MatchCollection, am As match, rs As String
    Set mc = pRegex.Execute(sFrom)
    rs = ""
    For Each am In mc
        rs = rs & am.value
    Next am
    getString = rs
End Function
Public Function getGroup(sFrom As String, groupNumber As Long) As String
    Dim mc As MatchCollection, am As match, bm As SubMatches, rs As String
    Set mc = pRegex.Execute(sFrom)
    rs = ""
    
    
    If mc.Count > 1 And mc.Count >= groupNumber Then
        rs = mc.item(groupNumber - 1).value
    ElseIf mc.Count = 1 Then
        If mc.item(0).SubMatches.Count >= groupNumber Then
    ' dont really understand this yet
            rs = mc.item(0).SubMatches(groupNumber - 1)
        End If
    End If
    
    getGroup = rs
End Function
Function getReplace(sFrom As String, sTo As String) As String
    getReplace = pRegex.Replace(sFrom, sTo)

End Function
Function getTest(sFrom As String) As Boolean
    getTest = pRegex.Test(sFrom)

End Function






Attribute VB_Name = "oauth"
Option Explicit
Public Function getGoogled(scope As String, _
                                Optional replacementpackage As cJobject = Nothing, _
                                Optional clientID As String = vbNullString, _
                                Optional clientSecret As String = vbNullString, _
                                Optional complain As Boolean = True, _
                                Optional cloneFromeScope As String = vbNullString, _
                                Optional apikey As String = vbNullString) As cOauth2
    Dim o2 As cOauth2
    Set o2 = New cOauth2
    With o2.googleAuth(scope, replacementpackage, clientID, clientSecret, complain, cloneFromeScope, apikey)
        If Not .hasToken And complain Then
            MsgBox ("Failed to authorize to google for scope " & scope & ":denied code " & o2.denied)
        End If
    End With
    
    Set getGoogled = o2
End Function


 
Attribute VB_Name = "regXLib"
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 4:47:47 PM : from manifest:3414394 gist https://gist.github.com/brucemcpherson/3414836/raw/regXLib.vba
Option Explicit
' v2.02
'for more about this
' http://ramblings.mcpher.com/Home/excelquirks/classeslink/data-manipulation-classes
'to contact me
' http://groups.google.com/group/excel-ramblings
'reuse of code
' http://ramblings.mcpher.com/Home/excelquirks/codeuse
Public Function rxString(sname As String, s As String, Optional ignorecase As Boolean = True) As String
    Dim rx As cregXLib
    ' create a new regx
    Set rx = rxMakeRxLib(sname)
    rx.ignorecase = ignorecase
    ' extract the string that matches the requested pattern
    rxString = rx.getString(s)

End Function
Public Function rxGroup(sname As String, s As String, group As Long, Optional ignorecase As Boolean = True) As String
    Dim rx As cregXLib
    ' create a new regx
    Set rx = rxMakeRxLib(sname)
    rx.ignorecase = ignorecase
    ' extract the string that matches the requested pattern
    rxGroup = rx.getGroup(s, group)

End Function
Public Function rxTest(sname As String, s As String, Optional ignorecase As Boolean = True) As Boolean
    Dim rx As cregXLib
    ' create a new regx
    Set rx = rxMakeRxLib(sname)
    rx.ignorecase = ignorecase
    ' extract the string that matches the requested pattern
    rxTest = rx.getTest(s)

End Function
Public Function rxReplace(sname As String, sFrom As String, sTo As String, Optional ignorecase As Boolean = True) As String
    Dim rx As cregXLib
     ' create a new regx
    Set rx = rxMakeRxLib(sname)
    rx.ignorecase = ignorecase
    ' replace the string that matches the requested pattern
    rxReplace = rx.getReplace(sFrom, sTo)
    
End Function
Public Function rxPattern(sname As String) As String
    Dim rx As cregXLib
     ' create a new regx
    Set rx = rxMakeRxLib(sname)
    ' just returnthe pattern
    rxPattern = rx.pattern
    
End Function
 Function rxMakeRxLib(sname As String) As cregXLib
    Dim rx As cregXLib, s As String
    Set rx = New cregXLib
    ' normally sname points to a preselected regEX
    ' if not known, silently assume its a regex pattern
        s = Replace(UCase(sname), " ", "")
        Select Case s
            Case "POSTALCODEUK"
                rx.Init s, _
                "(((^[BEGLMNS][1-9]\d?) | (^W[2-9] ) | ( ^( A[BL] | B[ABDHLNRST] | C[ABFHMORTVW] | D[ADEGHLNTY] | E[HNX] | F[KY] | G[LUY] | H[ADGPRSUX] | I[GMPV] |" & _
                " JE | K[ATWY] | L[ADELNSU] | M[EKL] | N[EGNPRW] | O[LX] | P[AEHLOR] | R[GHM] | S[AEGKL-PRSTWY] | T[ADFNQRSW] | UB | W[ADFNRSV] | YO | ZE ) \d\d?) |" & _
                " (^W1[A-HJKSTUW0-9]) | ((  (^WC[1-2])  |  (^EC[1-4]) | (^SW1)  ) [ABEHMNPRVWXY] ) ) (\s*)?  ([0-9][ABD-HJLNP-UW-Z]{2})) | (^GIR\s?0AA)"
            
            Case "POSTALCODESPAIN"
                rx.Init s, _
                    "^([1-9]{2}|[0-9][1-9]|[1-9][0-9])[0-9]{3}$"
                    
            Case "PHONENUMBERUS"
                rx.Init s, _
                "^\(?(?<AreaCode>[2-9]\d{2})(\)?)(-|.|\s)?(?<Prefix>[1-9]\d{2})(-|.|\s)?(?<Suffix>\d{4})$"
                
            Case "CREDITCARD" 'amex/visa/mastercard
                rx.Init s, _
                "^((4\d{3})|(5[1-5]\d{2}))(-?|\040?)(\d{4}(-?|\040?)){3}|^(3[4,7]\d{2})(-?|\040?)\d{6}(-?|\040?)\d{5}"
                
            Case "NUMERIC"
                rx.Init s, _
                    "[\0-9]"
            
            Case "ALPHABETIC"
                rx.Init s, _
                    "[\a-zA-Z]"
                    
            Case "NONNUMERIC"
                rx.Init s, _
                    "[^\0-9]"
                    
            Case "IPADDRESS"
                rx.Init s, _
                "^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$"
            
            Case "SINGLESPACE"  ' should take a replace value of "$1 "
                rx.Init s, _
                    "(\S+)\x20{2,}(?=\S+)"
            
            Case "EMAIL"
                rx.Init s, _
                    "^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$"
                    
            Case "EMAILINSIDE"
                rx.Init s, _
                    "\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b"
                    
            Case "NONPRINTABLE"
                rx.Init s, "[\x00-\x1F\x7F]"
                
                
            Case "PUNCTUATION"
                rx.Init s, "[^A-Za-z0-9\x20]+"

            Case Else
                rx.Init "Adhoc", sname
        
        End Select
    
    Set rxMakeRxLib = rx
End Function






Attribute VB_Name = "usefulSheetsV4Api"
Option Explicit
'// useful functions to go along with the cSheetsV4 class for accessing the Sheets API

'//DEMOS
Private Function getMySheetId() As String
'// make this into your own sheet id
'// simplest way to implement in a form would be to make a picker for google drive
    getMySheetId = "1432kfrlN8kM4ISFqHAi0D07dIly0Vw8aas4iMbeaThw"
End Function
'// this is about setting up for OAUTH2
'// all you have to do is to create a google console developer project
'// create some credentials of app type other
'// activeate the sheets api
'// copy the credentials to the below function (the ones here wont work- they are deactivated)
'// and run this function once.
'// you can delete it once you;ve run it - its not needed any more if you successfully go through the google auth process
Private Function sheetsOnceOff()
    
    getGoogled "sheets", , _
    "850726066373-olmcla1ulddhuosrvbv6t2lu286qinh2.apps.googleusercontent.com", _
    "O9VzwydQfQzCxLqM8QBZkP_W"

End Function
'// this wil get the active sheet from google
'// go can replace the active sheet name with some other sheets, or a list of sheets separated by commas
Public Sub getThisSheet()
    Dim result As cJobject
    
    '// get the data from a given sheet id, and match to the active excell sheet
    '// OAUTH2 will be taken care of if required
    Set result = getStuffFromSheets(getMySheetId(), ActiveSheet.NAME)
    
    '// success will tell us if it worked
    If (Not result.child("success").value) Then
        MsgBox ("failed on sheets API " + result.child("response").stringify)
        Exit Sub
    End If
    
    '// now write that data to the current sheet, clearing it first
    writeToSheets result.child("data").children(1).child("valueRanges"), True
    
End Sub
'// this puts the active sheet to google
'// go can replace the active sheet name with some other sheets, or a list of sheets separated by commas
Public Sub putThisSheet()
    Dim result As cJobject, clearFirst As Boolean
    
    '// set this to true if you want to always clear the sheet first
    clearFirst = True
    
    '// put the data from a given sheet id, and match to the active excel sheet
    '// OAUTH2 will be taken care of if required
    Set result = putStuffToSheets(getMySheetId(), ActiveSheet.NAME, clearFirst)
    
    '// just check that all went fine
    If (Not result.child("success").value) Then
        MsgBox ("failed on sheets API " + result.child("response"))
        Exit Sub
    End If
    
End Sub
'// below here are the useful functions you'll need
Private Function sheetExistsAtGoogle(results As cJobject, sheetName As Variant, Optional complain As Boolean = False) As cJobject

    Dim theSheet As String, s As String, job As cJobject
    theSheet = LCase(CStr(sheetName))
    
    For Each job In results.child("data").children(1).child("sheets").children
        s = job.toString("properties.title")
        If (LCase(s) = theSheet) Then
            Set sheetExistsAtGoogle = job
            Exit Function
        End If
    Next job
    If (complain) Then
        MsgBox ("sheet does not exist on Google " & theSheet)
    End If
    Set sheetExistsAtGoogle = Nothing
End Function
Public Function putStuffToSheets(id As String, sheetNames As String, Optional clearFirst As Boolean = False) As cJobject

    Dim names As Variant, i As Long, _
        results As cJobject, sheet As Worksheet, _
        r As Range, values As Variant, result As cJobject, sheetAccess As cSheetsV4
    
    names = Split(sheetNames, ",")
    
    '// set up an access object
    Set sheetAccess = New cSheetsV4
    sheetAccess.setAuthName("sheets").setSheetId (id)
    
    '// get all the sheets at  the google end
    Set results = sheetAccess.getSheets()
    If (Not results.child("success").value) Then
        MsgBox "failed getting sheets meta data " & results.toString("response")
        Set putStuffToSheets = results
        Exit Function
    End If
    
    '// put the sheet data .. will bacth this up later
    For i = LBound(names) To UBound(names)
        With sheetExists(names(i), True)
            ' see if it exists at google
            If (sheetExistsAtGoogle(results, names(i)) Is Nothing) Then
              ' we need to create it
                Set result = sheetAccess.insertSheet(names(i))
                If (Not result.child("success").value) Then
                    MsgBox "failed inserting sheet " & result.toString("response")
                    Set putStuffToSheets = result
                    Exit Function
                End If
            End If

            
            '// and write it
            If (clearFirst) Then
                Set result = sheetAccess.clearValues(.NAME, "a:i")
                If (Not result.child("success").value) Then
                    MsgBox ("failed on sheets API " + result.child("response").stringify)
                End If
            End If
            Set result = sheetAccess.setValues(.UsedRange.value, .NAME, .UsedRange.Address)
            If (Not result.child("success").value) Then
                MsgBox ("failed on sheets API " + result.child("response").stringify)
            End If
        End With

    Next i
    
    Set putStuffToSheets = result

End Function
Private Function writeToSheets(data As cJobject, Optional overwrite As Boolean = False)
    Dim job As cJobject, a As Variant, d As Variant, _
      sheetName As String, sheet As Worksheet, ov As Boolean, _
      values As cJobject, jor As cJobject, joc As cJobject
      
    For Each job In data.children
        a = Split(LCase(job.toString("range")), "!")
        sheetName = CStr(a(0))
        '// see if the sheet exists
        Set sheet = sheetExists(sheetName)
        If (isSomething(sheet)) Then
            If (Not overwrite) Then
                ov = MsgBox("sheet already exists " & sheetName & " overwrite?", vbYesNo)
            End If
            If (ov Or overwrite) Then
                sheet.Cells.ClearContents
                
            Else
                Set sheet = Nothing
            End If
        Else
            Set sheet = sheets.add
            sheet.NAME = sheetName
        End If

        '// now write the data
        If (isSomething(sheet)) Then
            Set values = job.child("values")
            'we have to dimension to the maximum size of the array, as empty rows can return jagged arrays
            Dim m As Long
            m = 0
            For Each jor In values.children
                If jor.hasChildren Then
                    If (jor.children.Count > m) Then
                        m = jor.children.Count
                    End If
                End If
            Next jor
            If (m > 0) Then
                ReDim d(0 To values.children.Count - 1, 0 To m)
                For Each jor In values.children
                    For Each joc In jor.children
                        d(jor.childIndex - 1, joc.childIndex - 1) = joc.value
                    Next joc
                Next jor
            
            '// now we just need to write it out
                sheet.Cells(1, 1) _
                .Resize(values.children.Count, m) _
                .value = d
            
            End If
        End If
    Next job
    
End Function ' check if this childExists in current children

Private Function sheetExists(sname As Variant, Optional complain As Boolean = False) As Worksheet
    Dim sheetName As String

    On Error GoTo handle
    sheetName = CStr(sname)
    Set sheetExists = sheets(sheetName)
    Exit Function
handle:
    Set sheetExists = Nothing
    If (complain) Then
        MsgBox ("sheet " & sheetName & " doesnt exist")
    End If
End Function
'/**
' * get the sheet contents from google
' * @param {string} id the spreadsheet id
' * @param {string} [sheets] separated buy commas - blank gets them all
' * @return {cjobject} the result
'*/
Private Function getStuffFromSheets(id As String, _
            Optional sheets As String = vbNullString) As cJobject
    Dim oauth As cOauth2
    Dim sheetAccess As cSheetsV4
    Dim results As cJobject, a As Variant, theSheet As String, _
      i As Long, job As cJobject, ranges As cStringChunker, c As cStringChunker


    '// set up an access object
    Set sheetAccess = New cSheetsV4
    sheetAccess.setAuthName("sheets").setSheetId (id)
    
    '// get what sheets exist
    Set results = sheetAccess.getSheets()
    If (Not results.child("success").value) Then
        MsgBox "failed getting sheets meta data " & results.toString("response")
        Set getStuffFromSheets = results
        Exit Function
    End If
    
    
    '// here's what they are
    '//Debug.Print JSONStringify(results.child("data"))
    
    '// get the data for the sheets that exist or were asked for
    '// see if they exist at google
    Set c = New cStringChunker
    If (sheets <> vbNullString) Then
        a = Split(sheets)
        For i = LBound(a) To UBound(a)
          If (isSomething(sheetExistsAtGoogle(results, a(i), True))) Then
            c.add(CStr(a(i))).add (",")
          End If
        Next i
        sheets = c.chopWhile(",").toString
    End If
    
    sheets = LCase(sheets) + ","
    
    Set ranges = New cStringChunker
    For Each job In results.child("data").children(1).child("sheets").children
        theSheet = job.toString("properties.title")
        If (sheets = "," Or InStr(1, sheets, LCase(theSheet) & ",") > 0) Then
          ranges.add(theSheet).add("!a:i").add (",")
        End If
    Next job

    '// now lets get the data in the selected sheets
    Set getStuffFromSheets = sheetAccess.getValues(ranges.chopWhile(",").toString)
     
End Function


Attribute VB_Name = "usefulStuff"
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 4:48:00 PM : from manifest:7471153 gist https://gist.github.com/brucemcpherson/3414346/raw
Option Explicit
' v2.23  3414346

' Acknowledgement for the microtimer procedures used here to
' thanks to Charles Wheeler - http://www.decisionmodels.com/
' ---


#If VBA7 And Win64 Then

Private Declare PtrSafe Function getTickCount _
    Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long

Private Declare PtrSafe Function getFrequency _
    Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
    
Private Declare PtrSafe Function ShellExecute _
  Lib "shell32.dll" Alias "ShellExecuteA" ( _
  ByVal hwnd As Long, _
  ByVal Operation As String, _
  ByVal fileName As String, _
  Optional ByVal parameters As String, _
  Optional ByVal Directory As String, _
  Optional ByVal WindowStyle As Long = vbMaximizedFocus _
  ) As Longlong
  
Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
    ByVal CodePage As Longlong, ByVal dwflags As Longlong, _
    ByVal lpWideCharStr As Longlong, ByVal cchWideChar As Longlong, _
    ByVal lpMultiByteStr As Longlong, ByVal cchMultiByte As Longlong, _
    ByVal lpDefaultChar As Longlong, ByVal lpUsedDefaultChar As Longlong) As Longlong
    
    
#Else

Private Declare Function getTickCount Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long
Private Declare Function getFrequency Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
Private Declare Function ShellExecute _
  Lib "shell32.dll" Alias "ShellExecuteA" ( _
  ByVal hwnd As Long, _
  ByVal Operation As String, _
  ByVal fileName As String, _
  Optional ByVal parameters As String, _
  Optional ByVal Directory As String, _
  Optional ByVal WindowStyle As Long = vbMaximizedFocus _
  ) As Long
  
Private Declare Function WideCharToMultiByte Lib "kernel32" ( _
    ByVal CodePage As Long, ByVal dwflags As Long, _
    ByVal lpWideCharStr As Long, ByVal cchWideChar As Long, _
    ByVal lpMultiByteStr As Long, ByVal cchMultiByte As Long, _
    ByVal lpDefaultChar As Long, ByVal lpUsedDefaultChar As Long) As Long
    
#End If

' note original execute shell stuff came from this post
' http://stackoverflow.com/questions/3166265/open-an-html-page-in-default-browser-with-vba
' thanks to http://stackoverflow.com/users/174718/dmr

Private Const CP_UTF8 = 65001
Public Const cFailedtoGetHandle = -1

Public Function OpenUrl(url) As Boolean
    #If VBA7 And Win64 Then
    Dim lSuccess As Longlong
    #Else
    Dim lSuccess As Long
    #End If
    lSuccess = ShellExecute(0, "Open", url)
    OpenUrl = lSuccess > 32
End Function

Sub deleteAllFromCollection(co As Collection)
    Dim o As Object, i As Long
    For i = co.Count To 1 Step -1
        co(i).Delete
    Next i
    
End Sub


Public Function UTF16To8(ByVal UTF16 As String) As String
Dim sBuffer As String
#If VBA7 And Win64 Then
    Dim lLength As Longlong
#Else
    Dim lLength As Long
#End If
If UTF16 <> "" Then
    lLength = WideCharToMultiByte(CP_UTF8, 0, StrPtr(UTF16), -1, 0, 0, 0, 0)
    sBuffer = Space$(CLng(lLength))
    lLength = WideCharToMultiByte( _
        CP_UTF8, 0, StrPtr(UTF16), -1, StrPtr(sBuffer), Len(sBuffer), 0, 0)
    sBuffer = StrConv(sBuffer, vbUnicode)
    UTF16To8 = Left$(sBuffer, CLng(lLength - 1))
Else
    UTF16To8 = ""
End If
End Function
'end of utf16to8


Public Function URLEncode( _
   StringVal As String, _
   Optional SpaceAsPlus As Boolean = False, _
   Optional UTF8Encode As Boolean = True _
) As String

Dim StringValCopy As String: StringValCopy = _
    IIf(UTF8Encode, UTF16To8(StringVal), StringVal)
Dim StringLen As Long: StringLen = Len(StringValCopy)

If StringLen > 0 Then
    ReDim result(StringLen) As String
    Dim i As Long, CharCode As Integer
    Dim Char As String, Space As String

  If SpaceAsPlus Then Space = "+" Else Space = "%20"

  For i = 1 To StringLen
    Char = Mid$(StringValCopy, i, 1)
    CharCode = Asc(Char)
    Select Case CharCode
      Case 97 To 122, 65 To 90, 48 To 57, 45, 46, 95, 126
        result(i) = Char
      Case 32
        result(i) = Space
      Case 0 To 15
        result(i) = "%0" & Hex(CharCode)
      Case Else
        result(i) = "%" & Hex(CharCode)
    End Select
  Next i
  URLEncode = Join(result, "")

End If
End Function
Public Sub cloneFormat(b As Range, a As Range)
    
    ' this probably needs additional properties copied over
    With a.Interior
        .Color = b.Interior.Color
    End With
    With a.Font
        .Color = b.Font.Color
        .size = b.Font.size
    End With
    With a
        .HorizontalAlignment = b.HorizontalAlignment
        .VerticalAlignment = b.VerticalAlignment
        
    End With

End Sub
Public Function compareAsKey(a As Variant, b As Variant, Optional asKey As Boolean = True) As Boolean
    If (asKey And TypeName(a) = "String" And TypeName(b) = "String") Then
        compareAsKey = (makeKey(a) = makeKey(b))
    Else
        compareAsKey = (a = b)
    
    End If
End Function
' sort a collection
Function SortColl(ByRef coll As Collection, eorder As Long) As Long
    Dim ita As Long, itb As Long
    Dim va As Variant, vb As Variant, bSwap As Boolean
    Dim x As Object, y As Object
    
    For ita = 1 To coll.Count - 1
        For itb = ita + 1 To coll.Count
            Set x = coll(ita)
            Set y = coll(itb)
            bSwap = x.needSwap(y, eorder)
            If bSwap Then
                With coll
                    Set va = coll(ita)
                    Set vb = coll(itb)
                    .add va, , itb
                    .add vb, , ita
                    .remove ita + 1
                    .remove itb + 1
                End With
            End If
        Next
    Next
End Function
Public Function getHandle(sname As String, Optional readOnly As Boolean = False) As Integer
    Dim hand As Integer
    On Error GoTo handleError
        hand = FreeFile
        If (readOnly) Then
            Open sname For Input As hand
        Else
            Open sname For Output As hand
        End If
        getHandle = hand
        Exit Function

handleError:
    MsgBox ("Could not open file " & sname)
    getHandle = cFailedtoGetHandle
End Function
Function afConcat(arr() As Variant) As String
    Dim i As Long, s As String
    s = ""
    For i = LBound(arr) To UBound(arr)
        s = s & arr(i, 1) & "|"
    Next i
    afConcat = s
End Function
Public Function quote(s As String) As String
    quote = q & s & q
End Function
Public Function q() As String
    q = Chr(34)
End Function
Public Function qs() As String
    qs = Chr(39)
End Function
Public Function bracket(s As String) As String
    bracket = "(" & s & ")"
End Function
Public Function list(ParamArray args() As Variant) As String
    Dim i As Long, s As String
    s = vbNullString
    For i = LBound(args) To UBound(args)
        If s <> vbNullString Then s = s & ","
        s = s & CStr(args(i))
    Next i
    list = s
End Function

Public Function qlist(ParamArray args() As Variant) As String
    Dim i As Long, s As String
    s = vbNullString
    For i = LBound(args) To UBound(args)
        If s <> vbNullString Then s = s & ","
        s = s & quote(CStr(args(i)))
    Next i
    qlist = s
End Function
Public Function diminishingReturn(val As Double, Optional s As Double = 10) As Double
    diminishingReturn = Sgn(val) * s * (Sqr(2 * (Sgn(val) * val / s) + 1) - 1)
End Function
Public Function superTrim(s As String) As String
    Dim c As cStringChunker
    Set c = New cStringChunker
    superTrim = c.add(s).chopSuperTrim.toString
    
End Function
Public Function makeKey(v As Variant) As String
    makeKey = LCase(Trim(CStr(v)))
End Function
' The below is taken from http://stackoverflow.com/questions/496751/base64-encode-string-in-vbscript
Function Base64Encode(sText)
    Dim oXML, oNode
    Set oXML = CreateObject("Msxml2.DOMDocument.3.0")
    Set oNode = oXML.createElement("base64")
    oNode.DataType = "bin.base64"
    oNode.nodeTypedValue = Stream_StringToBinary(sText)
    ' function inserts line feeds so we need to get rid of them
    Base64Encode = Replace(oNode.Text, vbLf, "")
    Set oNode = Nothing
    Set oXML = Nothing
End Function
'Stream_StringToBinary Function
'2003 Antonin Foller, http://www.motobit.com
'Text - string parameter To convert To binary data
Function Stream_StringToBinary(Text)
  Const adTypeText = 2
  Const adTypeBinary = 1

  'Create Stream object
  Dim BinaryStream 'As New Stream
  Set BinaryStream = CreateObject("ADODB.Stream")

  'Specify stream type - we want To save text/string data.
  BinaryStream.Type = adTypeText

  'Specify charset For the source text (unicode) data.
  BinaryStream.Charset = "us-ascii"

  'Open the stream And write text/string data To the object
  BinaryStream.Open
  BinaryStream.WriteText Text

  'Change stream type To binary
  BinaryStream.Position = 0
  BinaryStream.Type = adTypeBinary

  'Ignore first two bytes - sign of
  BinaryStream.Position = 0

  'Open the stream And get binary data from the object
  Stream_StringToBinary = BinaryStream.Read

  Set BinaryStream = Nothing
End Function

'Stream_BinaryToString Function
'2003 Antonin Foller, http://www.motobit.com
'Binary - VT_UI1 | VT_ARRAY data To convert To a string
Function Stream_BinaryToString(Binary)
  Const adTypeText = 2
  Const adTypeBinary = 1

  'Create Stream object
  Dim BinaryStream 'As New Stream
  Set BinaryStream = CreateObject("ADODB.Stream")

  'Specify stream type - we want To save text/string data.
  BinaryStream.Type = adTypeBinary

  'Open the stream And write text/string data To the object
  BinaryStream.Open
  BinaryStream.write Binary

  'Change stream type To binary
  BinaryStream.Position = 0
  BinaryStream.Type = adTypeText

  'Specify charset For the source text (unicode) data.
  BinaryStream.Charset = "us-ascii"

  'Open the stream And get binary data from the object
  Stream_BinaryToString = BinaryStream.ReadText
  Set BinaryStream = Nothing
End Function
' Decodes a base-64 encoded string (BSTR type).
' 1999 - 2004 Antonin Foller, http://www.motobit.com
' 1.01 - solves problem with Access And 'Compare Database' (InStr)
Function Base64Decode(ByVal base64String)
  'rfc1521
  '1999 Antonin Foller, Motobit Software, http://Motobit.cz
  Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  Dim dataLength, sOut, groupBegin
  
  'remove white spaces, If any
  base64String = Replace(base64String, vbCrLf, "")
  base64String = Replace(base64String, vbTab, "")
  base64String = Replace(base64String, " ", "")
  base64String = Replace(base64String, vbLf, "")
   
  'The source must consists from groups with Len of 4 chars
  dataLength = Len(base64String)
  If dataLength Mod 4 <> 0 Then
    err.Raise 1, "Base64Decode", "Bad Base64 string."
    Exit Function
  End If

  
  ' Now decode each group:
  For groupBegin = 1 To dataLength Step 4
    Dim numDataBytes, CharCounter, thisChar, thisData, nGroup, pOut
    ' Each data group encodes up To 3 actual bytes.
    numDataBytes = 3
    nGroup = 0

    For CharCounter = 0 To 3
      ' Convert each character into 6 bits of data, And add it To
      ' an integer For temporary storage.  If a character is a '=', there
      ' is one fewer data byte.  (There can only be a maximum of 2 '=' In
      ' the whole string.)

      thisChar = Mid(base64String, groupBegin + CharCounter, 1)

      If thisChar = "=" Then
        numDataBytes = numDataBytes - 1
        thisData = 0
      Else
        thisData = InStr(1, Base64, thisChar, vbBinaryCompare) - 1
      End If
      If thisData = -1 Then
        err.Raise 2, "Base64Decode", "Bad character In Base64 string."
        Exit Function
      End If

      nGroup = 64 * nGroup + thisData
    Next
    
    'Hex splits the long To 6 groups with 4 bits
    nGroup = Hex(nGroup)
    
    'Add leading zeros
    nGroup = String(6 - Len(nGroup), "0") & nGroup
    
    'Convert the 3 byte hex integer (6 chars) To 3 characters
    pOut = Chr(CByte("&H" & Mid(nGroup, 1, 2))) + _
      Chr(CByte("&H" & Mid(nGroup, 3, 2))) + _
      Chr(CByte("&H" & Mid(nGroup, 5, 2)))
    
    'add numDataBytes characters To out string
    sOut = sOut & Left(pOut, numDataBytes)
  Next

  Base64Decode = sOut
End Function
Public Function openNewHtml(sname As String, sContent As String) As Boolean
    Dim handle As Integer

    handle = getHandle(sname)
    If (handle <> cFailedtoGetHandle) Then
        Print #handle, sContent
        Close #handle
        openNewHtml = True
    End If

End Function
Public Function readFromFile(sname As String) As String
    Dim handle As Integer
    handle = getHandle(sname, True)
    If (handle <> cFailedtoGetHandle) Then
        readFromFile = Input$(LOF(handle), #handle)
        Close #handle
    End If
End Function
Public Function arrayLength(a) As Long
    arrayLength = UBound(a) - LBound(a) + 1
End Function
Public Function getControlValue(ctl As Object) As Variant
    Select Case TypeName(ctl)
        Case "Shape"
            getControlValue = ctl.TextFrame.Characters.Text
        Case "Label"
            getControlValue = ctl.Caption
        Case Else
            getControlValue = ctl.value
    End Select
End Function
Public Function setControlValue(ctl As Object, v As Variant) As Variant
    Select Case TypeName(ctl)
        Case "Shape"
            ctl.TextFrame.Characters.Text = v
        Case "Label"
            ctl.Caption = v
        Case Else
            ctl.value = v
    End Select
    setControlValue = v
End Function
Public Function isinCollection(vCollect As Variant, sid As Variant) As Boolean
    Dim v As Variant
    If Not vCollect Is Nothing Then
        On Error GoTo handle
        Set v = vCollect(sid)
        isinCollection = True
        Exit Function
    End If
handle:
    isinCollection = False
End Function

Public Function dimensionCount(a As Variant) As Long
' the only way I can figure out how to do this is to keep trying till it fails
    Dim n As Long, j As Long

    n = 1
    On Error GoTo allDone
    While True
        j = UBound(a, n)
        n = n + 1
    Wend
    Debug.Assert False
    Exit Function
    
allDone:
    dimensionCount = n - 1
    Exit Function
    
End Function

Public Function encloseTag(tag As String, Optional newLine As Boolean = True, _
                    Optional tClass As String = vbNullString, _
                    Optional args As Variant) As String
    
    Dim i As Long, t As cStringChunker
    Set t = New cStringChunker
    ' args can be an array or a single item
    If Not IsArray(args) Then
        With t
            .add("<").add (tag)
            If tClass <> vbNullString Then .add(" class=").add (tClass)
            .add (">")
            If newLine Then .add (vbCrLf)
            .add (CStr(args))
            If newLine Then .add (vbCrLf)
            .add("</").add(tag).add (">")
            If newLine Then .add (vbCrLf)
        End With
    Else
        ' recurse for array memmbers
        For i = LBound(args) To UBound(args)
            t.add encloseTag(tag, newLine, tClass, args(i))
        Next i
    End If
    encloseTag = t.content
End Function

Public Function scrollHack() As String
    'hack for IOS
    scrollHack = _
     "<div id='wrapper' style='width:100%;height:100%;overflow-x:auto;" & _
     "overflow-y:auto;-webkit-overflow-scrolling: touch;'>"
End Function

Public Function escapeify(s As String) As String
    escapeify = _
                    Replace( _
                        Replace( _
                            Replace( _
                                Replace(s _
                                    , q, "\" & q), _
                                "%", "\" & "%"), _
                            ">", "\>"), _
                        "<", "\<")
    

    
End Function
Public Function unEscapify(s As String) As String
    unEscapify = _
                    Replace( _
                        Replace( _
                            Replace( _
                                Replace( _
                                    s, "\" & q, q), _
                                 "\" & "%", "%"), _
                             "\>", ">"), _
                         "\<", "<")
    
End Function
Public Function basicStyle() As String
    With New cStringChunker
        .add ".viewdiv {}"
        .add ".hide {"
        .add "display:none;position:absolute;"
        .add "padding:5px;background:white;color:black;"
        .add "border-radius:5px;border:1px solid black;"
        .add "}"
        basicStyle = .content
    End With

End Function
' i adapted this from some table css I found - apologies I dont have the site for crediting.
Public Function tableStyle() As String
    Dim t As cStringChunker
    Set t = New cStringChunker
t.add _
 " table {" & _
    "font-family:Arial, Helvetica, sans-serif;" & _
    "color:#666;" & _
    "font-size:10px;" & _
    "background:#eaebec;" & _
    "margin:4px;" & _
    "border:#ccc 1px solid;" & _
    "-moz-border-radius:3px;" & _
    "-webkit-border-radius:3px;" & _
    "border-radius:3px;" & _
    "-moz-box-shadow: 0 1px 2px #d1d1d1;" & _
    "-webkit-box-shadow: 0 1px 2px #d1d1d1;" & _
    "box-shadow: 0 1px 2px #d1d1d1;" & _
    "}" & _
 "table th {" & _
    "padding:8px 9px 8px 9px;" & _
    "border-top:1px solid #fafafa;" & _
    "border-bottom:1px solid #e0e0e0;" & _
    "background: #ededed;" & _
    "background: -webkit-gradient(linear, left top, left bottom, from(#ededed), to(#ebebeb));" & _
    "background: -moz-linear-gradient(top,  #ededed,  #ebebeb);" & _
    "}"
    
t.add _
 "table tr {" & _
    "text-align: left;" & _
    "padding-left:16px;" & _
    "}" & _
 "table td {" & _
    "padding:6px;" & _
    "border-top: 1px solid #ffffff;" & _
    "border-bottom:1px solid #e0e0e0;" & _
    "border-left: 1px solid #e0e0e0;" & _
    "background: #fafafa;" & _
    "}" & _
 "table tr.even td {" & _
    "background: #f6f6f6;" & _
    "}"


 
    tableStyle = t.content
End Function
Public Function is64BitExcel() As Boolean
#If VBA7 And Win64 Then
    is64BitExcel = True
#Else
    is64BitExcel = False
#End If
End Function
Public Function includeJQuery() As String
    ' include jquery source
    With New cStringChunker
        .addLine jScriptTag("http://www.google.com/jsapi")
        .addLine jScriptTag
        .addLine "google.load('jquery', '1');"
        .addLine "</script>"
        includeJQuery = .content
    End With
    
End Function
Public Function includeGoogleCallBack(c As String) As String
    ' include google call back
    With New cStringChunker
        .addLine jScriptTag
        .addLine "google.setOnLoadCallback("
        .addLine c
        .addLine ");"
        .addLine "</script>"
        includeGoogleCallBack = .content
    End With
    
End Function
Public Function jScriptTag(Optional src As String) As String
    With New cStringChunker
        .add "<script type='text/javascript'"
        If src <> vbNullString Then
            .add(" src='").add(src).addLine ("'></script>")
        Else
            .addLine ">"
        End If
        jScriptTag = .content
    End With
End Function
Public Function jDivAtMouse()
    With New cStringChunker
        .addLine "function() {"
        .add "$('a.viewdiv').mousemove("
        .addLine "function(e) {"
        .add "var targetdiv = $('#d'+this.id);"
        .add "targetdiv.css({left:(e.pageX + 20) + 'px',"
        .add "top: (Math.max(0,e.pageY - targetdiv.height()/2)) + 'px'}).show();"
        .addLine "});"
        .add "$('a.viewdiv').mouseout("
        .addLine "function(e) {"
        .add "$('#d'+this.id).hide();"
        .addLine "});"
        .addLine "}"
        jDivAtMouse = .content
    End With
End Function


Function biasedRandom(possibilities, weights) As String
    Dim w As Variant, a As Variant, p As Variant, _
        r As Double, i As Long
    ' comes in as 2 lists
    a = Split(weights, ",")
    p = Split(possibilities, ",")
    ReDim w(LBound(a) To UBound(a))

    ' create cumulative
    For i = LBound(w) To UBound(w)
        w(i) = CDbl(a(i))
        If i > LBound(w) Then w(i) = w(i - 1) + w(i)
    Next i
    
    ' get random index
    r = Rnd() * w(UBound(w))
    
    ' find its weighted position
    For i = LBound(w) To UBound(w)
        If (r <= w(i)) Then
            biasedRandom = p(i)
            Exit Function
        End If
    Next i
    
End Function

Public Sub sleep(seconds As Long)

    Application.Wait TimeSerial(hour(Now()), Minute(Now()), Second(Now()) + seconds)
End Sub
Public Function getDateFromTimestamp(s As String) As Date
    Dim d As Double
    
    If (Len(s) = 13) Then
        ' javaScript Time
        d = CDbl(Left(s, 10))
        ' may need to round for milliseconds
        If Int(Mid(s, 11, 3) >= 500) Then
            d = d + 1
        End If
        
    ElseIf (Len(s) = 10) Then
        ' unix Time
        d = CDbl(s)
    
    Else
        ' wtf time
        getDateFromTimestamp = 0
        Exit Function
    
    End If
    getDateFromTimestamp = DateAdd("s", d, DateSerial(1970, 1, 1))

End Function
Public Function dateFromUnix(s As Variant) As Variant
    Dim d As Date, sd As String
    sd = CStr(s)
    
    If (Len(sd) > 0) Then
        d = getDateFromTimestamp(sd)
        If d = 0 Then
            dateFromUnix = CVErr(xlErrValue)
        Else
            dateFromUnix = d
        End If
    Else
        dateFromUnix = Empty
    End If

End Function
Public Function isSomething(o As Object) As Boolean

    isSomething = Not o Is Nothing
End Function


Public Function tinyTime() As Double
' Returns seconds.
    Dim cyTicks1 As Currency
    Static cyFrequency As Currency
    tinyTime = 0
' Get frequency.
    If cyFrequency = 0 Then getFrequency cyFrequency
' Get ticks.
    getTickCount cyTicks1
    If cyFrequency Then tinyTime = cyTicks1 / cyFrequency
End Function


Function applyDefaults(value As Variant, defaultValue As Variant) As Variant
    If (IsObject(defaultValue)) Then
        If isUndefined(value) Then
            Set applyDefaults = defaultValue
        Else
            Set applyDefaults = value
        End If
    Else
        If isUndefined(value) Then
            applyDefaults = defaultValue
        Else
            applyDefaults = value
        End If
    End If
End Function
Function isUndefined(value As Variant) As Boolean
    If (IsObject(value)) Then
        isUndefined = value Is Nothing
    Else
        If (IsMissing(value) Or IsEmpty(value)) Then
            isUndefined = True
        Else
            isUndefined = (value = vbNullString)
        End If
    End If
End Function
Function conditionalAssignment(condition As Boolean, a As Variant, b As Variant) As Variant
    If (condition) Then

        If IsObject(a) Then
            Set conditionalAssignment = a
        Else
            conditionalAssignment = assignHelper(a)
        End If

    Else
        If IsObject(b) Then
            Set conditionalAssignment = b
        Else
            conditionalAssignment = assignHelper(b)
        End If
    
    End If
End Function
Private Function assignHelper(a As Variant) As Variant
    If IsObject(a) Then
        Set assignHelper = a
    Else
        If Not isUndefined(a) Then
            assignHelper = a
        Else
            assignHelper = vbNullString
        End If
    End If
End Function
Public Function getTimestampFromDate(Optional dt As Date = 0) As Double
    Dim d As Double
    
    If (dt = 0) Then
        dt = Now()
    End If
    
    ' convert into time since the epoch
    d = DateDiff("s", DateSerial(1970, 1, 1) + TimeSerial(0, 0, 0), dt)
    
    ' convert to ms
    d = d * 1000#

    getTimestampFromDate = d

End Function

Public Function checkOrCreateFolder(path As String, Optional optCreate As Boolean = True) As Object
    ' doing late binding to avoid refernce for this
    
    Dim fso As Object, cleanPath As String
    Set fso = CreateObject("Scripting.FileSystemObject")

    'fso not smart enough to create entire thing, so we need recurse for each
    If (optCreate) Then
        recurseCreateFolder fso, fso.GetAbsolutePathName(path)
    End If
    
    Set checkOrCreateFolder = fso.getFolder(path)
End Function
Private Function recurseCreateFolder(fso As Object, cleanPath As String) As Object
    Dim parentPathString As String

    If Not fso.FolderExists(cleanPath) Then
        ' need to create the parent first
        recurseCreateFolder fso, fso.GetParentFolderName(cleanPath)
        ' now we can do it
        fso.CreateFolder (cleanPath)
    End If

End Function
Public Function writeToFolderFile(folderName As String, fileName As String, content As String) As String
    
    Dim file As Object, fso As Object
    Dim path As String
    path = fileName
    ' create the folder if we need to
    
    If (folderName <> vbNullString) Then
        path = concatFolderName(folderName, path)
        checkOrCreateFolder folderName
    End If
    ' write the data
  
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set file = fso.OpenTextFile(path, 2, True)
    file.write content
    writeToFolderFile = content
End Function
Public Function getAllSubFolderPaths(folderName As String) As String
    Dim folder As Object, subFolder As Object, c As cStringChunker
    Set c = New cStringChunker
    Set folder = checkOrCreateFolder(folderName, False)
    If (isSomething(folder)) Then
        For Each subFolder In folder.subFolders
            c.add(subFolder.path).add ","
        Next subFolder
    End If
    getAllSubFolderPaths = c.chopIf(",").toString
End Function
Public Function readFromFolderFile(folderName As String, fileName As String) As String
    Dim file As Object, fso As Object
    Dim path As String
    path = fileName
    
    If (folderName <> vbNullString) Then
        path = concatFolderName(folderName, fileName)
    End If
    ' read the data
    If (fileExists(path)) Then
        Set fso = CreateObject("Scripting.FileSystemObject")
        Set file = fso.OpenTextFile(path, 1)
        If (file.AtEndOfStream) Then
            readFromFolderFile = ""
        Else
            readFromFolderFile = file.readAll()
        End If
        file.Close
    End If
    
End Function
Public Function fileExists(path As String) As Boolean
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    fileExists = fso.fileExists(path)
End Function
Public Function concatFolderName(folderName As String, fileName As String) As String
    Dim c As cStringChunker
    Set c = New cStringChunker
    concatFolderName = c.add(folderName).chopIf("/").chopIf("\").add("/").add(fileName).toString
    
End Function


Attribute VB_Name = "usefulcJobject"
'gistThat@mcpher.com :do not modify this line - see ramblings.mcpher.com for details: updated on 8/18/2014 4:47:46 PM : from manifest:3414394 gist https://gist.github.com/brucemcpherson/3414365/raw/usefulcJobject.vba
'v2.16 11.5.15
Option Explicit

Public Function fromISODateTime(iso As String) As Date
    Dim rx As RegExp, matches As MatchCollection, d As Date, ms As Double, sec As Double
    Set rx = New RegExp
    With rx
        .ignorecase = True
        .Global = True
        .pattern = "(\d{4})-([01]\d)-([0-3]\d)T([0-2]\d):([0-5]\d):(\d*\.?\d*)Z"
    End With
    Set matches = rx.Execute(iso)
    
    ' TODO -- timeszone

    If matches.Count = 1 And matches.item(0).SubMatches.Count = 6 Then

        With matches.item(0)
            sec = CDbl(.SubMatches(5))
            ms = sec - Int(sec)
            d = DateSerial(.SubMatches(0), .SubMatches(1), .SubMatches(2)) + _
                TimeSerial(.SubMatches(3), .SubMatches(4), Int(sec)) + ms / 86400
        End With
    
    Else
        d = 0
    End If
    
    fromISODateTime = d
   
End Function

Public Function toISODateTime(d As Date) As String
    Dim s As String, ms As Double, adjustSecond As Long
    
    ' need to adjust if seconds are going to be rounded up
    ms = milliseconds(d)
    adjustSecond = 0
    If (ms >= 0.5) Then adjustSecond = -1
    
    ' TODO - timezone
    toISODateTime = Format(year(d), "0000") & "-" & Format(month(d), "00") & "-" & Format(day(d), "00T") & _
            Format(d, "hh:mm:") & Format(DateAdd("s", adjustSecond, d), "ss") & Format(ms, ".000Z")

    
End Function
Public Function milliseconds(d As Date) As Double
    ' extract the milliseconds from the time
    Dim t As Date
    t = (d - DateSerial(year(d), month(d), day(d)) - TimeSerial(hour(d), Minute(d), Second(d)))
    If t < 0 Then
        ' the millsecond rounded it up
        t = (d - DateSerial(year(d), month(d), day(d)) - TimeSerial(hour(d), Minute(d), Second(d) - 1))
    End If
    
    milliseconds = t * 86400
    
End Function
Public Function JSONParse(s As String, Optional jtype As eDeserializeType, Optional complain As Boolean = True) As cJobject
    Dim j As New cJobject
    Set JSONParse = j.Init(Nothing).parse(s, jtype, complain)
    j.tearDown
End Function
Public Function JSONStringify(j As cJobject, Optional blf As Boolean) As String
    JSONStringify = j.stringify(blf)
End Function
Public Function jSonArgs(options As String) As cJobject
    ' takes a javaScript like options paramte and converts it to cJobject
    ' it can be accessed as job.child('argName').value or job.find('argName') etc.
    Dim job As New cJobject
    If options <> vbNullString Then
        Set jSonArgs = job.Init(Nothing, "jSonArgs").deSerialize(options)
    End If
End Function
Public Function optionsExtend(givenOptions As String, _
            Optional defaultOptions As String = vbNullString) As cJobject
    Dim jGiven As cJobject, jDefault As cJobject, _
        jExtended As cJobject, cj As cJobject
    ' this works like $.extend in jQuery.
    ' given and default options arrive as a json string
    ' example -
    ' optionsExtend ("{'width':90,'color':'blue'}", "{'width':20,'height':30,'color':'red'}")
    ' would return a cJobject which serializes to
    ' "{width:90,height:30,color:blue}"
    Set jGiven = jSonArgs(givenOptions)
    Set jDefault = jSonArgs(defaultOptions)
    
    ' now we combine them
    If Not jDefault Is Nothing Then
        Set jExtended = jDefault
    Else
        Set jExtended = New cJobject
        jExtended.Init Nothing
    End If
    
    ' now we merge that with whatever was given
    If Not jGiven Is Nothing Then
        jExtended.merge jGiven
    End If
    
    ' and its over
    Set optionsExtend = jExtended
End Function

'udfs to expose classes
Public Function ucJobjectMake(r As Variant) As cJobject
    Dim cj As New cJobject
    Set ucJobjectMake = cj.deSerialize(CStr(r))
End Function
Public Function ucJobjectChildValue(json As Variant, child As Variant) As String
    ucJobjectChildValue = ucJobjectMake(CStr(json)).child(CStr(child)).value
End Function
Public Function ucJobjectLint(json As Variant, Optional child As Variant) As String
    Dim cj As cJobject
    Set cj = ucJobjectMake(json)
    If Not IsMissing(child) Then
        Set cj = cj.child(CStr(child))
    End If
    ucJobjectLint = cj.serialize(True)
End Function
Public Function cleanGoogleWire(sWire As String) As String
    Dim jStart As String, p As Long, newWire As Boolean, e As Long, s As String, reg As RegExp, _
        match As match, matches As MatchCollection, v As Double, i As Long, _
        year As Long, month As Long, day As Long, hour As Long, min As Long, sec As Long, ms As Long, _
        t As cStringChunker, consumed As Long

    jStart = "table:"
    p = InStr(1, sWire, jStart)
    'there have been multiple versions of wire ...
    If p = 0 Then
        'try the other one
        jStart = q & ("table") & q & ":"
        p = InStr(1, sWire, jStart)
        newWire = True
    End If

    p = InStr(1, sWire, jStart)
    e = Len(sWire) - 1

    If p <= 0 Or e <= 0 Or p > e Then
        MsgBox " did not find table definition data"
        Exit Function
    End If
    
    If Mid(sWire, e, 2) <> ");" Then
        MsgBox ("incomplete google wire message")
        Exit Function
    End If
    ' encode the 'table:' part to a cjobject
    p = p + Len(jStart)
    s = "{" & jStart & "[" & Mid(sWire, p, e - p - 1) & "]}"
    ' google protocol doesnt have quotes round the key of key value pairs,
    ' and i also need to convert date from javascript syntax new Date()
    ' we'll force it to be a 13 digit timestamp, since cjobject knows how to make that into a date
    's = rxReplace("(new\sDate)(\()(\d+)(,)(\d+)(,)(\d+)(\))", s, "'$3/$5/$7'")
    'new\s+date\s*\(\s*(\d+)\s*(,\s*\d+)\s*(,\s*\d+)?\s*(,\s*\d+)?\s*(,\s*\d+)?\s*(,\s*\d+)?\s*(,\s*\d+)?\)
    Set reg = New RegExp
    With reg
        .pattern = "new\s+Date\s*\(\s*(\d+)\s*(,\s*\d+)\s*(,\s*\d+)?\s*(,\s*\d+)?\s*(,\s*\d+)?\s*(,\s*\d+)?\s*(,\s*\d+)?\)"
        .Global = True
    End With
    Set matches = reg.Execute(s)

    
    If matches.Count > 0 Then
        Set t = New cStringChunker
        consumed = 0
        For Each match In matches
            t.add Mid(s, consumed + 1, match.FirstIndex - consumed)
            consumed = consumed + match.FirstIndex - consumed
            With match
                If .SubMatches.Count >= 2 And .SubMatches.Count <= 7 Then
                    'these are the only valid number of args to a javascript new Date()
                    day = 1
                    hour = 0
                    min = 0
                    sec = 0
                    ms = 0
                    year = .SubMatches(0)
                    month = Replace(.SubMatches(1), ",", "") + 1
                    If .SubMatches.Count > 2 And Not IsEmpty(.SubMatches(2)) Then day = Replace(.SubMatches(2), ",", "")
                    If .SubMatches.Count > 3 And Not IsEmpty(.SubMatches(3)) Then hour = Replace(.SubMatches(3), ",", "")
                    If .SubMatches.Count > 4 And Not IsEmpty(.SubMatches(4)) Then min = Replace(.SubMatches(4), ",", "")
                    If .SubMatches.Count > 5 And Not IsEmpty(.SubMatches(5)) Then sec = Replace(.SubMatches(5), ",", "")
                    If .SubMatches.Count > 6 And Not IsEmpty(.SubMatches(6)) Then ms = Replace(.SubMatches(6), ",", "")
                    ' now convert to a date and format
                    t.add(q) _
                        .add(CStr(DateSerial(year, month, day) + TimeSerial(hour, min, sec) + CDbl(ms) / 86400)) _
                        .add (q)
                    consumed = consumed + match.Length
                End If
            End With
        Next match
        If consumed < Len(s) Then t.add Mid(s, consumed + 1)
        s = t.content
        Set t = Nothing
    End If
    If Not newWire Then s = rxReplace("(\w+)(:)", s, "'$1':")
    cleanGoogleWire = s
    
End Function

Public Function xmlStringToJobject(xmlString As String, Optional complain As Boolean = True) As cJobject
    Dim doc As Object
    ' parse xml

    Set doc = CreateObject("msxml2.DOMDocument")
    doc.LoadXML xmlString
    If doc.parsed And doc.parseError = 0 Then
        Set xmlStringToJobject = docToJobject(doc, complain)
        Exit Function
    End If

    Set xmlStringToJobject = Nothing
    If complain Then
        MsgBox ("Invalid xml string - xmlparseerror code:" & doc.parseError)
    End If
    
    Exit Function
    
End Function
Public Function docToJobject(doc As Object, Optional complain As Boolean = True) As cJobject
    ' convert xml document to a cjobject
    Dim node As IXMLDOMNode, job As cJobject
    Set job = New cJobject
    job.Init Nothing
       
    Set docToJobject = handleNodes(doc, job)
End Function
Private Function isArrayRoot(parent As IXMLDOMNode) As Boolean
    
    Dim node As IXMLDOMNode, n As Long, node2 As IXMLDOMNode
    
    
    isArrayRoot = False
    If parent.NodeType = NODE_ELEMENT And parent.ChildNodes.Length > 1 Then
        For Each node2 In parent.ChildNodes
            If node2.NodeType = NODE_ELEMENT Then
                n = 0
                For Each node In parent.ChildNodes
                    If node.NodeType = NODE_ELEMENT And _
                        node2.nodeName = node.nodeName Then n = n + 1
                Next node
                If n > 1 Then
                    ' this shoudl be true, but for leniency i'll comment
                    'Debug.Assert n = parent.ChildNodes.Length
                    isArrayRoot = True
                    Exit Function
                End If
            End If
        Next node2
    End If

    
End Function
Private Function handleNodes(parent As IXMLDOMNode, job As cJobject) As cJobject
    Dim node As IXMLDOMNode, joc As cJobject, attrib As IXMLDOMAttribute, i As Long, _
         arrayJob As cJobject
    
    If isArrayRoot(parent) Then
        ' we need an array associated with this this node
        ' subsequent members will need to make space for themselves
        Set joc = job.add(parent.nodeName).addArray
    Else
        Set joc = handleNode(parent, job)
    End If
    
    ' deal with any attributes
    If Not parent.Attributes Is Nothing Then
        For Each attrib In parent.Attributes
            handleNode attrib, joc
        Next attrib
    End If
    
    ' do the children
    If Not parent.ChildNodes Is Nothing And parent.ChildNodes.Length > 0 Then
        For Each node In parent.ChildNodes
            handleNodes node, joc
        Next node
    End If
    
    ' always return the level at which we arrived
    Set handleNodes = job
    
End Function
Private Function handleNode(node As IXMLDOMNode, job As cJobject, Optional arrayHead As Boolean = False) As cJobject
    Dim Key As cJobject
    '' not a comprehensive convertor
    Set handleNode = job
    Debug.Print node.nodeName & node.NodeType & node.NodeValue
    Select Case node.NodeType
        Case NODE_ATTRIBUTE
            ' we cant have an array of attributes - this will silently use the latest
            job.add node.nodeName, node.NodeValue
            
        Case NODE_ELEMENT
            If job.isArrayRoot Then
                Dim b As Boolean
                b = (node.ChildNodes.Length = 1)
                If (b) Then b = node.ChildNodes(0).NodeType = NODE_TEXT
                If (b) Then
                    Set handleNode = job.add.add
                Else
                    Set handleNode = job.add.add(node.nodeName)
                End If
            Else
                Set handleNode = job.add(node.nodeName)
            End If

        Case NODE_TEXT
            job.value = node.NodeValue

            
        Case NODE_DOCUMENT, NODE_CDATA_SECTION, NODE_ENTITY_REFERENCE, _
            NODE_ENTITY, NODE_PROCESSING_INSTRUCTION, NODE_COMMENT, NODE_DOCUMENT_TYPE, _
            NODE_DOCUMENT_FRAGMENT, NODE_NOTATION
            ' just ignore these for now

            
        Case Else
            Debug.Assert False
    End Select
    
End Function
'/**
'* this will deal with the problem of code copied from javascript, where JSON has no quotes round property names
'* @param {string} theString the string to be hacked
'* @return {string} the hacked string
'*/
Public Function hackJSObjectToJSON(theString As String) As String
    hackJSObjectToJSON = _
        rxReplace("({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):", theString, "$1""$2"":")

End Function

'/**
'* this will deal with the problem of code copied from javascript, where JSON has no quotes round property names, with a callback
'* @param {string} theString the string to be hacked
'* @return {string} the hacked string
'*/
Public Function hackJSONPObjectToJSON(theString As String) As String
    hackJSONPObjectToJSON = _
        hackJSObjectToJSON(rxReplace("\w+\s*\()(.*)\);*", theString, "$2"))

End Function


' InQuest injected base64 decoded content
' Z+a.)
' -jjl
' "pj(

INQUEST-PP=macro
