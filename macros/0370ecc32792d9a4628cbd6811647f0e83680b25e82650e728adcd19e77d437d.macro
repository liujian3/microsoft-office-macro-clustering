Attribute VB_Name = "DialogCloseForm"
Attribute VB_Base = "0{ED66AFD2-FFBB-4035-A7EC-354C49F74D08}{571B7D62-2470-450F-AB09-F92DDFEDC7E8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False








Private Sub btnClose_Click()
    Unload Me
End Sub

Private Sub Userform_Initialize()
    Me.lblMessage = txtDialogMessage
End Sub
Attribute VB_Name = "DialogConfirmedForm"
Attribute VB_Base = "0{BFAC3870-2B5D-4CA4-A469-E1652A9ACE04}{06673EFC-8E7A-4377-A6BA-88168FD410A7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False









Private Sub btnClose_Click()
    Unload Me
End Sub

Private Sub Userform_Initialize()
    Me.lblMessage = txtDialogMessage
End Sub
Attribute VB_Name = "DialogInputForm"
Attribute VB_Base = "0{F6873DDF-AC55-4BF7-BD92-702288BB75C8}{4B55CEA6-A1F2-420F-8702-8E0C848A509C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







Private Sub btnNo_Click()
    txtDialogInput = ""
    bolDialogChoiceYesNo = False
    Unload Me
End Sub

Private Sub btnYes_Click()
    txtDialogInput = Me.txtInput.Value
    bolDialogChoiceYesNo = True
    Unload Me
End Sub


Private Sub Userform_Initialize()
    Me.lblMessage = txtDialogMessage
    Me.txtInput.SetFocus
End Sub
Attribute VB_Name = "DialogLoginForm"
Attribute VB_Base = "0{8421F024-5ED1-4BFC-9379-1C1F610B4964}{2C7EA6F2-5AE8-4D9C-BBA3-D18617C2680C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Private Sub btnNo_Click()
    txtDialogInput = ""
    bolDialogChoiceYesNo = False
    Unload Me
End Sub


Private Sub btnYes_Click()
    txtDialogInput = Me.txtUsername.Value
    txtDialogInput2 = Me.lblPassword.Caption
    If (IsUserLoginValid(txtDialogInput, txtDialogInput2)) Then 'Implement IsUserLoginValid function below that implements validation of user login
        bolDialogChoiceYesNo = True
        Unload Me
    Else
        DialogClose "Login failed."
    End If
    
End Sub


Private Sub txtPassword_Change()
'Handling masking of password characters after every key entered

    Dim intLength As Integer
    Dim intHiddenLength As Integer
    
    intLength = Len(txtPassword.Value)
    intHiddenLength = Len(lblPassword.Caption)
    
    If (intLength = 0) Then
        Me.lblPassword.Caption = vbNullString
    ElseIf (intLength > intHiddenLength) Then
        Me.lblPassword.Caption = Me.lblPassword.Caption & Right(Me.txtPassword.Value, 1)
        Me.txtPassword.Value = Replace(Space(intLength), " ", Chr(149))
    ElseIf (intLength < intHiddenLength) Then
        Me.lblPassword.Caption = Left(Me.lblPassword.Caption, intHiddenLength - 1)
        Me.txtPassword.Value = Replace(Space(intLength), " ", Chr(149))
    End If
End Sub


Private Sub Userform_Initialize()
    bolDialogChoiceYesNo = False
    Me.txtUsername.SetFocus
End Sub



Function IsUserLoginValid(strName As String, strPass As String) As Boolean
'Implement your user validation against any database / table

    
End Function


Attribute VB_Name = "DialogYesNoForm"
Attribute VB_Base = "0{CE8450A1-F6CD-4D04-B4C1-F7193331E77E}{8D1C594E-3565-4637-A75B-72773A291C3B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






Private Sub btnNo_Click()
    bolDialogChoiceYesNo = False
    Unload Me
End Sub

Private Sub btnYes_Click()
    
    bolDialogChoiceYesNo = True
    Unload Me
End Sub


Private Sub Userform_Initialize()
    Me.lblMessage = txtDialogMessage
End Sub
Attribute VB_Name = "GeneralArrays"
Option Explicit
'5 functions

'Code use credit text: Code by Mor Sagmon

Function IsArrayAllocated(arr As Variant) As Boolean
'Returns True if arr is a dimentioned array

        On Error Resume Next
        IsArrayAllocated = IsArray(arr) And _
                           Not IsError(LBound(arr, 1)) And _
                           LBound(arr, 1) <= UBound(arr, 1)
        On Error GoTo 0
End Function



Function Get2DArrayIndexByValue(ByRef arr() As Variant, ByVal varValue As Variant, Optional lngMatchRowColIndex As Long = 1, Optional intDimension As Integer = 1) As Long
'Returns the index of varValue along lngMatchRowColIndex row (if intDimension=1)/column (if intDimension=2), in a 2-D array.
'This is equivalent to the Worksheet MATCH function on a selected row or column of an array
'Returns -1 if not found

    Dim i As Long
    
    Get2DArrayIndexByValue = -1
    
    If IsArrayAllocated(arr) Then
        If IsNumeric(varValue) Then varValue = CLng(varValue)
        
        If (intDimension = 1) Then
            For i = LBound(arr, 1) To UBound(arr, 1)
                If (arr(i, lngMatchRowColIndex) = varValue) Then
                    Get2DArrayIndexByValue = i
                    GoTo CloseSub
                End If
            Next i
        Else
            For i = LBound(arr, 2) To UBound(arr, 2)
                If (arr(lngMatchRowColIndex, i) = varValue) Then
                    Get2DArrayIndexByValue = i
                    GoTo CloseSub
                End If
            Next i
        End If
    End If

CloseSub:

End Function


Function Get1DArrayIndexByValue(ByRef arr() As Variant, ByVal varValue As Variant) As Long
'Returns the index (1-based) of varValue in arr.
'arr is a 1-D array.
'Returns -1 if not in array.

    Dim i As Long
    Dim lngIndex As Long
    
    Get1DArrayIndexByValue = -1
    lngIndex = 0
    For i = LBound(arr) To UBound(arr)
        lngIndex = lngIndex + 1
        If (arr(i) = varValue) Then
            Get1DArrayIndexByValue = lngIndex
            Exit Function
        End If
    Next i

End Function




Public Function TransposeArray(arr() As Variant) As Variant
'Transpose a variant array.
'Returns the transposed array (by ref).

Dim i As Long
Dim j As Long
Dim iUpper As Long
Dim jUpper As Long
Dim arrTemp As Variant

    If (IsArrayAllocated(arr)) Then
        iUpper = UBound(arr, 2)
        jUpper = UBound(arr, 1)
        ReDim arrTemp(iUpper, jUpper)
        For i = LBound(arr, 2) To iUpper
            For j = LBound(arr, 1) To jUpper
                arrTemp(i, j) = arr(j, i)
            Next j
        Next i
        TransposeArray = arrTemp
    End If
End Function



Function SumArrayColumn(ByRef arr() As Variant, ByVal intColIndex As Integer) As Double
'Sums all numeric values in column intColIndex of 2D array. 1-D is rows.

    Dim i As Long
    Dim dblSum As Double
    
    intColIndex = LBound(arr, 2) + intColIndex - 1
    dblSum = 0
    For i = LBound(arr, 1) To UBound(arr, 1)
        If (IsNumeric(arr(i, intColIndex))) Then
            dblSum = dblSum + arr(i, intColIndex)
        End If
    Next i
        
    SumArrayColumn = dblSum
End Function



'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************


Sub TestIsArrayAllocated()

    Dim arr() As Variant
    
    Debug.Print (IsArrayAllocated(arr)) 'Will return False
    
    ReDim arr(1 To 2)
    
    Debug.Print (IsArrayAllocated(arr)) 'Will return True
End Sub



Sub TestGet2DArrayIndexByValue()

    Dim arr() As Variant
    Dim strName As String
    
    arr = ThisWorkbook.Sheets("Orders").Range("OrdersTable[#Data]").Value
    strName = "Colin Dixon"
    
    Debug.Print (Get2DArrayIndexByValue(arr, strName, 4, 1)) 'Colin Dixon is 13 in column 4
End Sub



Sub TestGet1DArrayIndexByValue()
    Dim arr() As Variant
    
    ReDim arr(0 To 1) As Variant
    arr(0) = "Alef"
    arr(1) = "Bet"
    Debug.Print (Get1DArrayIndexByValue(arr, "Bet"))
End Sub



Sub TestTransposeArray()

    Dim arr() As Variant
    Dim arrTransposed() As Variant
    
    arr = ThisWorkbook.Sheets("Orders").Range("OrdersTable[#Data]").Value
    
    arrTransposed = TransposeArray(arr)
    
    Debug.Print (arr(4, 2)) 'Now I'm in row 4 col 2
    Debug.Print (arrTransposed(2, 4)) 'Now I'm in row 2 col 4
End Sub



Sub TestSumArrayColumn()

    Dim arr() As Variant
    
    arr = ThisWorkbook.Sheets("Orders").Range("OrdersTable[#Data]").Value
    
    Debug.Print (SumArrayColumn(arr, 6))
End Sub
Attribute VB_Name = "GeneralControl"
Option Explicit
'2 functions

'Code use credit text: Code by Mor Sagmon

Function InProduction() As Boolean
'Returns true if production flag is set
'Production flag is cell J1 in the "Settings" Worksheet

    On Error Resume Next
    InProduction = ActiveWorkbook.Names("In_Production_Flag").RefersToRange.Value
    On Error GoTo 0
End Function


Sub RestoreState(Optional SheetToProtect As String = vbNullString)
'Restores the application state to normal:
'  - Protect SheetToProtect (if passed)
'  - Protects the Workbook if in Production mode (see InProductoin function)
'  - Sets the calculation mode to Automatic
'  - Activates the Workbook events listener
'  - Restores the mouse cursoe to its default icon
'  - Turns screen updating on

    Notify "Finishing calculations..."
        
    If (SheetToProtect <> vbNullString) Then
        ProtectSheet SheetToProtect
    End If
    
    If InProduction Then
        ProtectWorkbook
    End If
    
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    
    Application.Cursor = xlDefault
    
    Call NotifyOff
    Application.ScreenUpdating = True
End Sub



'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************

Sub TestInProduction()

    Debug.Print (InProduction)
End Sub


Sub TestRestoreState()

    RestoreState
End Sub

Attribute VB_Name = "GeneralExportImport"
Option Explicit
'10 functions

'Code use credit text: Code by Mor Sagmon

'************************************************ IMPORT/EXPORT CSV FILES ********************************************************

'*********************************** CALLABLE EXPORT/IMPORT FUNCTIONS **************************************

'*************************** EXPORT ***********************************************

Function ExportTableData(ByVal strSheetName As String, ByVal strTableName As String, ByVal strFileName As String, _
            Optional bolMetaFirstRow As Boolean = True, _
            Optional bolFullPath As Boolean = False, _
            Optional strDelim As String = ",") As Long
'Exports an Excel Table (ListObject) by the name strTableName in strSheetName Worksheet, as a csv file by the (full path and name / just name) strFileName.
'Returns number of rows exported (not including first metadata row), or -1 if failed
'  @bolMetaFirstRow - if True - first row of csv file will hold metadata: section name, data rows exported, data columns exported, export timestamp
'  @bolFullPath - if True - @strFileName holds the full path, else, take path from cell named "Data_Folder_Location" in "Settings" Worksheet
'  @strDelim - specify fields (columns) delimiter. Default is comma.

    Dim strDataRootFolder As String
    Dim strFullPathFileName As String
    Dim intFileHandle As Integer
    Dim lngRowsExported As Long
    
    With ActiveWorkbook
        If Not bolFullPath Then
            strDataRootFolder = .Worksheets("Settings").Range("Data_Folder_Location").Value
            If (Right(strDataRootFolder, 1) <> Application.PathSeparator) Then strDataRootFolder = strDataRootFolder & Application.PathSeparator
            
            strFullPathFileName = strDataRootFolder & strFileName
        Else
            strFullPathFileName = strFileName
        End If
        
        If InProduction Then On Error GoTo FailedDataExport
        
        Notify "Exporting " & strSheetName & " data. Please wait..."
        Application.Cursor = xlWait
        Application.ScreenUpdating = False
        
        intFileHandle = 1
        
        Open strFullPathFileName For Output As #intFileHandle
        
        'First line with metadata
        If (bolMetaFirstRow) Then
            Print #intFileHandle, "[Section: " & strSheetName & "]" & strDelim & .Worksheets(strSheetName).Range(strTableName).Rows.Count & strDelim & .Worksheets(strSheetName).Range(strTableName).Columns.Count & strDelim & " timestamp " & Format(Now(), "yyyy-MM-dd hh:mm:ss")
        End If
        'Export table data rows
        lngRowsExported = ExportTable(intFileHandle, strSheetName, strTableName, 0, strDelim)
    End With
    
    ExportTableData = lngRowsExported
CloseSub:
    Close #intFileHandle
    Call RestoreState
    Exit Function
FailedDataExport:
    ExportTableData = -1
    DialogClose "Failed data export from " & strSheetName & " to: " & strFullPathFileName
    GoTo CloseSub
End Function




Function ExportSheetData(ByVal strSheetName As String, ByVal strFileName As String, _
    Optional bolExportFirstRow As Boolean = True, _
    Optional bolFullPath As Boolean = False, _
    Optional strDelim As String = ",") As Long
'Export all rows within Worksheet organized in columns and rows starting at cell A1.
'  @bolMetaFirstRow - if True - first row of csv file will hold metadata: section name, data rows exported, data columns exported, export timestamp
'  @bolFullPath - if True - @strFileName holds the full path, else, take path from cell named "Data_Folder_Location" in "Settings" Worksheet
'  @strDelim - specify fields (columns) delimiter. Default is comma.
'Returns number of rows exported (not including first metadata row), or -1 if failed


    Dim strDataRootFolder As String
    Dim strFullPathFileName As String
    Dim intFileHandle As Integer
    Dim lngRowsExported As Long
    
    If Not bolFullPath Then
        strDataRootFolder = Worksheets("Settings").Range("Data_Folder_Location").Value
        If (Right(strDataRootFolder, 1) <> Application.PathSeparator) Then strDataRootFolder = strDataRootFolder & Application.PathSeparator
        
        strFullPathFileName = strDataRootFolder & strFileName
    Else
        strFullPathFileName = strFileName
    End If
    
    If InProduction Then On Error GoTo FailedDataExport
    
    Notify "Exporting " & strSheetName & " data. Please wait..."
    Application.Cursor = xlWait
    Application.ScreenUpdating = False
    
    intFileHandle = 1
    
    Open strFullPathFileName For Output As #intFileHandle
    
    'First line with metadata
    Print #intFileHandle, "[Section: " & strSheetName & "]" & strDelim & Worksheets(strSheetName).UsedRange.Rows.Count - Abs((bolExportFirstRow = False)) & strDelim & Worksheets(strSheetName).UsedRange.Columns.Count & strDelim & " timestamp " & Format(Now(), "yyyy-MM-dd hh:mm:ss")
    'Export table data rows
    lngRowsExported = ExportWorksheet(intFileHandle, strSheetName, bolExportFirstRow, strDelim)
    
    ExportSheetData = lngRowsExported
CloseSub:
    Close #intFileHandle
    Call RestoreState
    Exit Function
FailedDataExport:
    ExportSheetData = -1
    DialogClose "Failed data export from " & strSheetName & " to: " & strFullPathFileName
    GoTo CloseSub
End Function



Function ExportArrayData(ByRef arr() As Variant, strSectionName As String, ByVal strFileName As String, _
            Optional bolMetaFirstRow As Boolean = True, _
            Optional bolFullPath As Boolean = False, _
            Optional strDelim As String = ",") As Long
'Exports an array pointed by the argument: arr, as a csv file by the (full path and name / just name) strFileName.
'  @bolMetaFirstRow - if True - first row of csv file will hold metadata: section name, data rows exported, data columns exported, export timestamp
'  @bolFullPath - if True - @strFileName holds the full path, else, take path from cell named "Data_Folder_Location" in "Settings" Worksheet
'  @strDelim - specify fields (columns) delimiter. Default is comma.
'Returns number of rows exported (not including first metadata row), or -1 if failed


    Dim strDataRootFolder As String
    Dim strFullPathFileName As String
    Dim intFileHandle As Integer
    
    With ActiveWorkbook
        If Not bolFullPath Then
            strDataRootFolder = .Worksheets("Settings").Range("Data_Folder_Location").Value
            If (Right(strDataRootFolder, 1) <> Application.PathSeparator) Then strDataRootFolder = strDataRootFolder & Application.PathSeparator
            
            strFullPathFileName = strDataRootFolder & strFileName
        Else
            strFullPathFileName = strFileName
        End If
        
        If InProduction Then On Error GoTo FailedDataExport
        
        Notify "Exporting data. Please wait..."
        Application.Cursor = xlWait
        Application.ScreenUpdating = False
        
        intFileHandle = 1
        
        Open strFullPathFileName For Output As #intFileHandle
        
        'First line with metadata
        If (bolMetaFirstRow) Then
            Print #intFileHandle, "[Section: " & strSectionName & "]" & strDelim & UBound(arr, 1) - LBound(arr, 1) + 1 & strDelim & UBound(arr, 2) - LBound(arr, 2) + 1 & strDelim & " timestamp " & Format(Now(), "yyyy-MM-dd hh:mm:ss")
        End If
        'Export table data rows
        lngRowsExported = ExportArray(intFileHandle, arr, 0, strDelim)
    End With
    
    ExportArrayData = lngRowsExported
CloseSub:
    Close #intFileHandle
    Call RestoreState
    Exit Function
FailedDataExport:
    ExportArrayData = -1
    DialogClose "Failed data export from " & strSheetName & " to: " & strFullPathFileName
    GoTo CloseSub
End Function



'*************************** IMPORT ***********************************************


Function ImportTableData(ByVal strSheetName As String, ByVal strTableName As String, ByVal strFileName As String, _
    Optional strDelim As String = ",")
'Imports the strFileName csv file into strTableName table in strSheetName Worksheet.
'Expects first row to hold Meta-data as described in ExportTableData function above.
'  @strDelim - specify fields (columns) delimiter. Default is comma.
'Returns number of rows imported (not including first metadata row), or -1 if failed


    Dim strDataRootFolder As String
    Dim strFullPathFileName As String
    Dim intFileHandle As Integer
    Dim lngRowsImported As Long
    Dim LineFromFile As String
    Dim LineItems As Variant
    
    Dim strSectionLabel As String
    Dim lngFileRows As Long
    Dim intFileCols As Integer
    Dim strTimeStamp As String
    
    strDataRootFolder = Worksheets("Settings").Range("Data_Folder_Location").Value
    If (Right(strDataRootFolder, 1) <> Application.PathSeparator) Then strDataRootFolder = strDataRootFolder & Application.PathSeparator
    
    strFullPathFileName = strDataRootFolder & strFileName
    
    If Not FileExists(strFullPathFileName) Then
        DialogClose "File not found: " & strFullPathFileName
        Exit Function
    End If
    
    If InProduction Then On Error GoTo FailedDataImport
    
    Notify "Importing " & strSheetName & " data. Please wait..."
    Application.Cursor = xlWait
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    intFileHandle = 1
    
    Open strFullPathFileName For Input As #intFileHandle
    
    'Read first line - identify valid file
    Line Input #intFileHandle, LineFromFile
    LineItems = Split(LineFromFile, strDelim)
    strSectionLabel = Trim(LineItems(0))
    lngFileRows = CLng(Trim(LineItems(1)))
    intFileCols = CLng(Trim(LineItems(2)))
    strTimeStamp = Trim(LineItems(3))
    
    'Import table data rows
    If (lngFileRows > 0) Then
        UnprotectSheet strSheetName
        lngRowsImported = ImportTable(intFileHandle, strSheetName, strTableName, lngFileRows, intFileCols, strDelim)
    Else
        DialogClose "No rows to import found in: " & strFileName
    End If
    
    ImportTableData = lngRowsImported
CloseSub:
    Close #intFileHandle
    Call RestoreState(strSheetName)
    On Error GoTo 0
    Exit Function
FailedDataImport:
    ImportTableData = -1
    DialogClose "Failed data import of: " & strFullPathFileName & " into " & strSheetName
    GoTo CloseSub
End Function



Function ImportSheetData(ByVal strSheetName As String, ByVal strFileName As String, _
    Optional bolImportFirstRow As Boolean = True, _
    Optional strDelim As String = ",")
'Imports the strFileName csv file into strSheetName Worksheet at cell A1.
'Expects first row to hold Meta-data as described in ExportTableData function above.
'  @strDelim - specify fields (columns) delimiter. Default is comma.
'Returns number of rows imported (not including first metadata row), or -1 if failed

    Dim strDataRootFolder As String
    Dim strFullPathFileName As String
    Dim intFileHandle As Integer
    Dim lngRowsImported As Long
    Dim LineFromFile As String
    Dim LineItems As Variant
    
    Dim strSectionLabel As String
    Dim lngFileRows As Long
    Dim intFileCols As Integer
    Dim strTimeStamp As String
    
    strDataRootFolder = Worksheets("Settings").Range("Data_Folder_Location").Value
    If (Right(strDataRootFolder, 1) <> Application.PathSeparator) Then strDataRootFolder = strDataRootFolder & Application.PathSeparator
    
    strFullPathFileName = strDataRootFolder & strFileName
    
    If Not FileExists(strFullPathFileName) Then
        DialogClose "Data file not found: " & strFullPathFileName
        Exit Function
    End If
    
    If InProduction Then On Error GoTo FailedDataImport
    
    Notify "Importing " & strSheetName & " data. Please wait..."
    Application.Cursor = xlWait
    Application.ScreenUpdating = False
    
    intFileHandle = 1
    
    Open strFullPathFileName For Input As #intFileHandle
    
    'Read first line - identify valid file
    Line Input #intFileHandle, LineFromFile
    LineItems = Split(LineFromFile, strDelim)
    strSectionLabel = Trim(LineItems(0))
    lngFileRows = CLng(Trim(LineItems(1)))
    intFileCols = CLng(Trim(LineItems(2)))
    strTimeStamp = Trim(LineItems(3))
    
    'Import table data rows
    If (lngFileRows > 0) Then
        UnprotectSheet strSheetName
        lngRowsImported = ImportWorksheet(intFileHandle, strSheetName, lngFileRows, intFileCols, bolImportFirstRow, strDelim)
    Else
        DialogClose "No rows to import found in: " & strFileName
    End If
    
    ImportSheetData = lngRowsImported
CloseSub:
    Close #intFileHandle
    Call RestoreState(strSheetName)
    On Error GoTo 0
    Exit Function
FailedDataImport:
    ImportSheetData = -1
    DialogClose "Failed data import of: " & strFullPathFileName & " into " & strSheetName
    GoTo CloseSub
End Function


'*********************************** END CALLABLE EXPORT/IMPORT FUNCTIONS **********************************


Function ExportTable(intFileHandle As Integer, strSheetName As String, strTableName As String, Optional intColumns As Integer = 0, Optional strDelim As String = ",") As Long
'Receives an open csv file handle and writes all rows of a table, comma delimited, to the file.
'If intColumns>0 = export only intColumns number of first columns.
'Returns number of rows exported

    Dim arr() As Variant 'Array holding all table data
    Dim strLine As String 'Export line constructor
    Dim i, j As Integer
    Dim varCurrentValue As Variant
    
    ExportTable = 0
    
    'Assumes error handling in calling function
    
    arr = Worksheets(strSheetName).Range(strTableName & "[#Data]").Value
    
    If (intColumns = 0) Then
        intColumns = UBound(arr, 2)
    End If
    
    For i = LBound(arr, 1) To UBound(arr, 1) 'Rows loop
        strLine = vbNullString
        For j = LBound(arr, 2) To intColumns 'Columns loop
            varCurrentValue = arr(i, j)
            'Adjusting value for special considerations:
            If VarType(varCurrentValue) = vbString Then
                varCurrentValue = Replace(varCurrentValue, strDelim, "<delim>") 'Replace the delimiter char (if exists) with a unique tag: <delim>
            End If
            If VarType(varCurrentValue) = vbDate Then
                varCurrentValue = CLng(varCurrentValue) 'Convert dates to their numeric representation. Can also convert to universal format: yyyy-mm-dd
            End If
            strLine = strLine & varCurrentValue
            If (j < intColumns) Then 'Adding the delimiter after every value except the last value in the line
                strLine = strLine & strDelim
            End If
        Next j
        
        strLine = Replace(strLine, vbCrLf, "<vbCrLf>") 'replace all vbCrLf with tag - to avoid new line in output file
        strLine = Replace(strLine, vbLf, "<vbLf>") 'replace all vbLf with tag - to avoid new line in output file
        Print #intFileHandle, strLine
    Next i
    ExportTable = i

End Function




Function ExportWorksheet(intFileHandle As Integer, strSheetName As String, bolExportFirstRow As Boolean, Optional strDelim As String = ",") As Long
'Receives an open csv file handle and writes all rows of Worksheet, strDelim delimited, to the file.
'Rows are expected to be organizaed in columns and rows, starting at cell A1.
'  @bolExportFirstRow indicated if first row will be exported or not.
'Returns number of rows exported.

    Dim arr() As Variant 'Array holding all table data
    Dim intColumns As Integer
    Dim lngRows As Long
    Dim strLine As String 'Export line constructor
    Dim i, j As Integer
    Dim varCurrentValue As Variant
    
    ExportWorksheet = 0
    
    arr = Worksheets(strSheetName).UsedRange.Value
    intColumns = UBound(arr, 2)
    
    For i = LBound(arr, 1) To intColumns
        strLine = vbNullString
        For j = LBound(arr, 2) To UBound(arr, 2)
            varCurrentValue = arr(i, j)
            If VarType(varCurrentValue) = vbString Then
                varCurrentValue = Replace(varCurrentValue, strDelim, "<delim>")
            End If
            If VarType(varCurrentValue) = vbDate Then
                varCurrentValue = CLng(varCurrentValue)
            End If
            strLine = strLine & varCurrentValue
            If (j < intColumns) Then 'Adding the delimiter after every value except the last value in the line
                strLine = strLine & strDelim
            End If
        Next j
        
        strLine = Replace(strLine, vbCrLf, "<vbCrLf>") 'replace all vbCrLf with tag - to avoid new line in output file
        strLine = Replace(strLine, vbLf, "<vbLf>") 'replace all vbLf with tag - to avoid new line in output file
        
        If (i > LBound(arr, 1)) Or (bolExportFirstRow) Then
            Print #intFileHandle, strLine
        End If
    Next i
    ExportWorksheet = i

End Function




Function ExportArray(intFileHandle As Integer, ByRef arr() As Variant, Optional intColumns As Integer = 0, Optional strDelim As String = ",") As Long
'Receives an open csv file handle and writes all rows of array, strDelim delimited, to the file.
'If intColumns>0 = export only intColumns number of first array columns.
'Returns number of rows exported
    
    Dim strLine As String 'Export line constructor
    Dim i, j As Integer
    Dim varCurrentValue As Variant
    
    ExportArray = 0
    
    'Error handling in calling sub
    
    If (intColumns = 0) Then
        intColumns = UBound(arr, 2)
    End If
    
    For i = LBound(arr, 1) To UBound(arr, 1)
        strLine = ""
        For j = LBound(arr, 2) To intColumns
            varCurrentValue = arr(i, j)
            If VarType(varCurrentValue) = vbString Then
                'varCurrentValue = Replace(varCurrentValue, strDelim, "<delim>")
            End If
            If VarType(varCurrentValue) = vbDate Then
                varCurrentValue = Format(varCurrentValue, "yyyy-mm-dd")
            End If
            strLine = strLine & varCurrentValue
            If (j < intColumns) Then 'Adding the delimiter after every value except the last value in the line
                strLine = strLine & strDelim
            End If
        Next j
        
        strLine = Replace(strLine, vbCrLf, "<vbCrLf>") 'replace all vbCrLf with tag - to avoid new line in output file
        strLine = Replace(strLine, vbLf, "<vbLf>") 'replace all vbLf with tag - to avoid new line in output file
        Print #intFileHandle, strLine
    Next i
    ExportArray = i

End Function





Function ImportTable(intFileHandle As Integer, strSheetName As String, strTableName As String, lngRowsNumber As Long, intColsNumber As Integer, Optional strDelim As String = ",") As Long
'Receives an open csv file handle and reads all rows of the file, strDelim delimited, to the table.
'Returns number of rows Imported

    Dim strLine As String 'Import line constructor
    Dim i As Integer
    Dim iRow As Long
    Dim currValueRead As Variant
    Dim varCurrentValue As Variant
    Dim rngAnchor As Range
    Dim arr() As Variant
    Dim LineFromFile As String
    Dim LineItems As Variant
    
    ReDim arr(lngRowsNumber - 1, intColsNumber - 1)
    
    ImportTable = 0
    
    'Assumes error handling in calling sub
    
    'Prepares the tavle to receive data: clears current data and resizes to data size
    Call ClearTable(strSheetName, strTableName)
    Call ResizeTable(strSheetName, strTableName, lngRowsNumber, GetTableColumns(strSheetName, strTableName))
    
    iRow = 0
    Do Until EOF(intFileHandle)
        
        Line Input #intFileHandle, LineFromFile
        LineItems = Split(LineFromFile, strDelim)
        
        For i = 0 To intColsNumber - 1 'Columns loop
            currValueRead = LineItems(i)
            'Revert back any manipulations written on Export
            currValueRead = Replace(currValueRead, "<delim>", strDelim)
            currValueRead = Replace(currValueRead, "<vbCrLf>", vbCrLf) 'replace all <vbCrLf> tags with vbCrLf - to restore line breaks in multi-line strings
            currValueRead = Replace(currValueRead, "<vbLf>", vbLf) 'replace all <vbLf> tags with vbLf - to restore line breaks in multi-line strings
            arr(iRow, i) = currValueRead
        Next i
        iRow = iRow + 1
    Loop
    
    Set rngAnchor = Range(strTableName & "[#Headers]").Resize(1, 1)
    
    rngAnchor.Offset(1, 0).Resize(iRow, intColsNumber).Value = arr
    rngAnchor.Offset(1, 0).Resize(iRow, intColsNumber).WrapText = False 'Ommit that line if text may wrap inside cells
    
    ImportTable = iRow
    
End Function




Function ImportWorksheet(intFileHandle As Integer, strSheetName As String, lngRowsNumber As Long, intColsNumber As Integer, bolImportFirstRow As Boolean, Optional strDelim As String = ",") As Long
'Receives an open csv file handle and reads all rows of the file, comma delimited, to the Worksheet, starting from cell A2 or A1 if bolImportFirstRow=True.
'Returns number of rows Imported

    Dim strLine As String 'Import line constructor
    Dim i As Integer
    Dim iRow As Long
    Dim varCurrentValue As Variant
    Dim rngAnchor As Range
    Dim LineFromFile As String
    Dim LineItems As Variant
    Dim currValueRead As Variant
    
    ImportWorksheet = 0
    
    'Error handling in calling sub
    
    'Clear sheet rows except first row
    With ActiveWorkbook.Sheets(strSheetName)
        If (bolImportFirstRow) Then
            .Range("A1").Resize(.UsedRange.Rows.Count, .UsedRange.Columns.Count).EntireRow.Delete
        Else
            .Range("A2").Resize(.UsedRange.Rows.Count - 1, .UsedRange.Columns.Count).EntireRow.Delete
        End If
    End With
    
    Set rngAnchor = ActiveWorkbook.Sheets(strSheetName).Range("A1")
    
    iRow = bolImportFirstRow
    Do Until EOF(intFileHandle)
        iRow = iRow + 1
        Line Input #intFileHandle, LineFromFile
        LineItems = Split(LineFromFile, strDelim)
        

        For i = 0 To intColsNumber - 1
            currValueRead = LineItems(i)
            currValueRead = Replace(currValueRead, "<delim>", strDelim)
            currValueRead = Replace(currValueRead, "<vbCrLf>", vbCrLf) 'replace all <vbCrLf> tags with vbCrLf - to restore line breaks in multi-line strings
            currValueRead = Replace(currValueRead, "<vbLf>", vbLf) 'replace all <vbLf> tags with vbLf - to restore line breaks in multi-line strings
            rngAnchor.Offset(iRow, i).Value = currValueRead
            rngAnchor.Offset(iRow, i).WrapText = False
        Next i
    Loop
    ImportWorksheet = i

    Set rngAnchor = Nothing
End Function






'************************************************ END IMPORT/EXPORT CSV FILES ****************************************************


'************************************************ END IMPORT/EXPORT CSV FILES ****************************************************




'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************



Sub TestExportTableData()
    Debug.Print (ExportTableData("Orders", "OrdersTable", "orders.csv"))
End Sub


Sub TestImportTableData()
    Debug.Print (ImportTableData("Orders", "OrdersTable", "orders.csv"))
End Sub


Sub TestExportSheetData()
    Debug.Print (ExportSheetData("Employees", "employees.csv"))
End Sub


Sub TestImportSheetData()
    Debug.Print (ImportSheetData("Employees", "employees.csv"))
End Sub
Attribute VB_Name = "GeneralIO"
Option Explicit
'8 functions

'Code use credit text: Code by Mor Sagmon

Sub DeleteFile(strFullPathFileName As String)
'Deletes the file (if exists).
'  @strFullPathFileName is expected to hold the full path and file name of the file to be deleted.
    On Error Resume Next
        Kill strFullPathFileName
    On Error GoTo 0
End Sub




Function StripFileNameFromPath(ByVal strFullPath As String) As String
'Returns the file name ending the full path and file name given in strFullPath.
'If no path exists returns the file name provided as argument.

    Dim position As Integer
    
    position = InStrRev(strFullPath, Application.PathSeparator)
    If (position > 0) Then
        StripFileNameFromPath = Mid(strFullPath, position + 1)
    Else
        StripFileNameFromPath = strFullPath
    End If
    
End Function




Function strLegalFileName(strFileNameIn As String) As String
'Returns a valid file name out of strFileName.
'Illegal characters are replaced with underscore "_"

    Dim i As Integer
    
    Const strIllegals = "\/|?*<>"":"
    strLegalFileName = strFileNameIn
    For i = 1 To Len(strIllegals)
        strLegalFileName = Replace(strLegalFileName, Mid$(strIllegals, i, 1), "_")
    Next i
End Function




Function DeleteOldFilesInFolder(strPath As String, intDays As Integer) As Integer
'Deletes all files in strPath with date last modifed older than intDays
'Returns number of files deleted, or -1 if failed

    Dim oFSO As Object
    Dim oFile As Object
    Dim intFiles As Integer 'Files count
    
    intFiles = -1
    
    On Error GoTo FailedCommand
    
    Set oFSO = CreateObject("Scripting.FileSystemObject")
    If oFSO.FolderExists(strPath) Then 'Check that the folder exists
        intFiles = 0
        For Each oFile In oFSO.GetFolder(strPath).Files
            If DateDiff("d", oFile.DateLastModified, Now) > intDays Then 'Look at each file to check if it is older than intDays days
                oFile.Delete
                intFiles = intFiles + 1
            End If
        Next
    End If
CloseSub:
    DeleteOldFilesInFolder = intFiles
    Exit Function
FailedCommand:
    intFiles = -1
    GoTo CloseSub
End Function



Function GetDrivesList() As String
'Returns the available Disk Drives as a comma separated string, e.g.: C,D,F

    Dim d As Object
    Dim strResult As String
    
    If InProduction Then On Error GoTo FailedSub
    
    strResult = vbNullString
    With CreateObject("Scripting.FileSystemObject")
        For Each d In .Drives
            strResult = strResult & Replace(d.Path, ":", ",")
        Next
    End With

    strResult = Left(strResult, Len(strResult) - 1)
    GetDrivesList = strResult
    
CloseSub:
    
    Exit Function
FailedSub:
    DialogClose "Failed retreiving disk drives from the system."
    GetDrivesList = vbNullString
    GoTo CloseSub
End Function


Function MoveFile(ByVal strSource As String, ByVal strTarget As String, Optional bolOverwrite As Boolean = True) As Boolean
'Move strSource file to strTarget.
'Source and Target must represent the full path and file names.
'  @bolOverwrite - will overwrite target file is True

    Dim fso As Object

    If InProduction Then On Error GoTo FailedSub
    
    Set fso = CreateObject("Scripting.Filesystemobject")
    
    If FileExists(strTarget) Then
        If (bolOverwrite) Then
            Call DeleteFile(strTarget)
        Else
            GoTo FailedSub
        End If
    End If
    
    fso.MoveFile Source:=strSource, Destination:=strTarget
    MoveFile = True
    
CloseSub:
    Set fso = Nothing
    Exit Function
FailedSub:
    MoveFile = False
    DialogClose "Failed moving file " & strSource & " to: " & strTarget & ". Check if file already exists in destination"
    GoTo CloseSub
End Function



Function CopyFile(ByVal strSource As String, ByVal strTarget As String, Optional bolOverwrite As Boolean = True) As Boolean
'Copy strSource file to strTarget.
'Source and Target must represent the full path and file names.
'  @bolOverwrite - will overwrite target file is True

    Dim fso As Object

    If InProduction Then On Error GoTo FailedSub
    
    Set fso = CreateObject("Scripting.Filesystemobject")
    
    If FileExists(strTarget) Then
        If (bolOverwrite) Then
            Call DeleteFile(strTarget)
        Else
            GoTo FailedSub
        End If
    End If
    
    fso.CopyFile Source:=strSource, Destination:=strTarget
    CopyFile = True
    
CloseSub:
    Set fso = Nothing
    Exit Function
FailedSub:
    CopyFile = False
    DialogClose "Failed copying file " & strSource & " to: " & strTarget & ". Check if file already exists in destination"
    GoTo CloseSub
End Function



Function FileExists(strFile As String) As Boolean
'Returns True if strFile exists.
'strFile may hold the full path and filename.

    Dim TestStr As String
        
    TestStr = vbNullString
    On Error Resume Next
    TestStr = Dir(strFile)
    On Error GoTo 0
    If TestStr = vbNullString Then
        FileExists = False
    Else
        FileExists = True
    End If

End Function

'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************



Sub testDeleteFile()
    Call DeleteFile("C:\temp\MyFile.txt")
End Sub


Sub testStripFileNameFromPath()
    Debug.Print (StripFileNameFromPath("C:temp\MyFile.txt"))
End Sub


Sub teststrLegalFileName()
    Debug.Print (strLegalFileName("Monthly Orders File: 1.txt"))
End Sub


Sub testDeleteOldFilesInFolder()
    Debug.Print (DeleteOldFilesInFolder("C:\temp\reports", 30))
End Sub


Sub testGetDrivesList()
    Debug.Print (GetDrivesList)
End Sub


Sub testMoveFile()
    Debug.Print (MoveFile("C:\temp\employees.csv", "C:\temp\reports\MyEmployees.csv"))
End Sub


Sub testCopyFile()
    Debug.Print (CopyFile("C:\temp\orders.csv", "C:\temp\reports\MyOrders.csv"))
End Sub



Sub testFileExists()
    Debug.Print (FileExists("C:\temp\employees.csv"))
End Sub
Attribute VB_Name = "GeneralNotification"
Option Explicit
'2 functions

'Code use credit text: Code by Mor Sagmon

Public Sub Notify(ByVal strMessage As Variant)
'Presents a message in the bottom status bar.

    Application.DisplayStatusBar = True

    Application.StatusBar = strMessage

    Application.DisplayStatusBar = True
    
End Sub

Public Sub NotifyOff()
'Clears the bottom status bar.

    Application.StatusBar = vbNullString
    Application.StatusBar = False
End Sub


'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************


Sub TestNotify()
    Call Notify("Status bar message to the user")
End Sub



Sub TestNotifyOff()
    Call NotifyOff
End Sub
Attribute VB_Name = "GeneralPrinting"
Option Explicit
'3 functions

'Code use credit text: Code by Mor Sagmon

Function IsPrinterReady(Optional strPrinter As String = "") As Boolean
'Returns True if printer is turned on and ready.
'If no strPrintername provided, active printer is assumed.

    If (strPrinter = "") Then strPrinter = Application.ActivePrinter
    
    IsPrinterReady = False
    
    'If strPrinter has port part - discard
    Dim intOnPosition As Integer
    intOnPosition = InStr(1, strPrinter, " on ")
    If (intOnPosition > 0) Then
        strPrinter = Left(strPrinter, intOnPosition - 1)
    Else
        intOnPosition = InStr(1, strPrinter, " " & Chr(225)) 'For Hebrew string of " on ". Replace 225 with ASCII code as per your own Windows language.
        If (intOnPosition > 0) Then
            strPrinter = Left(strPrinter, intOnPosition - 1)
        End If
    End If
    
    
    If InProduction Then On Error GoTo FailedPrinter
    
    IsPrinterReady = Not GetObject("winmgmts:\\.\root\CIMV2").Get("Win32_Printer='" & strPrinter & "'").WorkOffline
      
    Exit Function
FailedPrinter:
    
End Function


Sub PrintWorksheet(ByVal strSheetName As String)
'Prints out strSheetName if printer is ready.

    If Not (IsPrinterReady) Then
        DialogClose "Printer is not ready."
        Exit Sub
    End If
     
    If InProduction Then On Error GoTo FailedSub
    
    ActiveWorkbook.Worksheets(strSheetName).PrintOut 'PrintPreview for previewing instead of printing

CloseSub:
    Exit Sub
FailedSub:
    DialogClose "Failed printing Worksheet: " & strSheetName
    GoTo CloseSub
End Sub


Sub SetRepeatingRowsPrintedSheet(ByVal SheetName As String, lngRowFrom As Long, lngRowTo As Long)
'Sets rows of SheetName as repeating rows in PageSetup for printing

    Application.PrintCommunication = False
    With ActiveWorkbook.Sheets(SheetName).PageSetup
        .PrintTitleRows = "$" & lngRowFrom & ":$" & lngRowTo
        .PrintTitleColumns = vbNullString
    End With
    Application.PrintCommunication = True
End Sub



'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************


Sub testIsPrinterReady()
    Debug.Print (IsPrinterReady())
End Sub



Sub testSetRepeatingRowsPrintedSheet()
    Call SetRepeatingRowsPrintedSheet("Orders", 1, 3)
End Sub


Sub testPrintWorksheet()
    Call PrintWorksheet("Orders")
End Sub
Attribute VB_Name = "GeneralProtection"
Option Explicit
'6 functions
'Protection password in Settings sheet: 2020

'Code use credit text: Code by Mor Sagmon

Sub UnprotectWorkbook(Optional wkb As Workbook = Nothing)
'Unprotects wkb (or Active) Workbook.
'Protection password is stored in Settings tab

    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    
    wkb.Unprotect Password:=wkb.Sheets("Settings").Range("Protection_Password").Value
End Sub


Sub ProtectWorkbook(Optional wkb As Workbook = Nothing)
'Protects wkb (or Active) Workbook.
'Protection password is stored in Settings tab

    If (InProduction) Then
        If wkb Is Nothing Then Set wkb = ActiveWorkbook
        
        wkb.Protect Password:=wkb.Sheets("Settings").Range("Protection_Password").Value, Structure:=True, Windows:=True
    End If
End Sub


Sub UnprotectSheet(ByVal strSheetName As String, Optional wkb As Workbook = Nothing)
'Unprotects a single sheet by the name strSheetName in wkb (or Active) Workbook.
'Protection password is stored in Settings tab


    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    wkb.Worksheets(strSheetName).Unprotect Password:=wkb.Sheets("Settings").Range("Protection_Password").Value
End Sub

Sub ProtectSheet(ByVal strSheetName As String, Optional wkb As Workbook = Nothing)
'Protects a single sheet by the name strSheetName in wkb (or Active) Workbook.
'Protection password is stored in Settings tab

    If (InProduction) Then
        If wkb Is Nothing Then Set wkb = ActiveWorkbook
        
        wkb.Worksheets(strSheetName).Protect Password:=wkb.Sheets("Settings").Range("Protection_Password").Value, DrawingObjects:=True, Contents:=True, Scenarios:=True, AllowUsingPivotTables:=True, UserInterFaceOnly:=True
    End If

End Sub




Sub UnprotectAllSheets(Optional ByVal bolAskPassword As Boolean = True, Optional wkb As Workbook = Nothing)
'Unprotects all Worksheets in wkb (or in Active Workbook).
'If bolAskPassord then user is prompted for the protection password, compared against the password stored in the Settings tab

    Dim sht As Worksheet
    Dim strPassword As String

    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    
    If (bolAskPassword) Then
        strPassword = InputBox(Prompt:="Unprotect Worksheets Password:", _
          Title:="Unprotect All Worksheets")
        If (strPassword = vbNullString) Then
            Exit Sub
        End If

        If strPassword <> wkb.Sheets("Settings").Range("Protection_Password").Value Then
            MsgBox "Wrong password. Worksheets remain protected.", vbOKOnly + vbInformation, "Wrong Password"
            Exit Sub
        End If
    End If

    Application.ScreenUpdating = False
    UnprotectWorkbook wkb
    For Each sht In wkb.Worksheets
        sht.Unprotect Password:=wkb.Sheets("Settings").Range("Protection_Password").Value
    Next
    Application.ScreenUpdating = True
End Sub


Sub ProtectAllSheets(Optional ByVal bolAskPassword As Boolean = True, Optional wkb As Workbook = Nothing)
'Protects all Worksheets in wkb (or in Active Workbook).
'If bolAskPassord then user is prompted for the protection password, compared against the password stored in the Settings tab

    Dim sht As Worksheet
    Dim strPassword As String

    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    
    If (bolAskPassword) Then
        strPassword = InputBox(Prompt:="Protect Worksheets Password:", _
            Title:="Protect All Worksheets")
          
        If (strPassword = vbNullString) Then
            Exit Sub
        End If
        If strPassword <> wkb.Sheets("Settings").Range("Protection_Password").Value Then
            MsgBox "Wrong password. Worksheets remain unprotected", vbOKOnly + vbInformation, "Wrong Password"
            Exit Sub
        End If
    End If

    Application.ScreenUpdating = False
    For Each sht In wkb.Worksheets
        sht.Protect Password:=wkb.Sheets("Settings").Range("Protection_Password").Value, DrawingObjects:=True, Contents:=True, Scenarios:=True _
        , AllowUsingPivotTables:=True, UserInterFaceOnly:=True
    Next
    ProtectWorkbook wkb
    Application.ScreenUpdating = True
End Sub



'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************

'Set the "In_Production_Flag" cell (J1) to True to witness the effect of these functions

Sub testProtectWorkbook()
    ProtectWorkbook
End Sub


Sub testUnprotectWorkbook()
    UnprotectWorkbook
End Sub


Sub testProtectSheet()
    Call ProtectSheet("Orders")
End Sub


Sub testUnprotectSheet()
    Call UnprotectSheet("Orders")
End Sub


Sub testProtectAllSheets()
    ProtectAllSheets
End Sub


Sub testUnprotectAllSheets()
    UnprotectAllSheets
End Sub






Attribute VB_Name = "GeneralReports"
Option Explicit
'8 functions

'Code use credit text: Code by Mor Sagmon

Sub NumberFormatReportDataColumn(ByVal strSheetName As String, ByVal lngStartRow As Long, ByVal lngRows As Long, ByVal intColumn As Integer, _
    Optional strFormat As String = "General", _
    Optional intAlign As Integer = xlGeneral)
'Formats a column of cells in intColumn of strSheetName, starting at lngStartRow down lngRows with the strFormat string.
'Aligns horizontally cells contents: intAlign options: xlGeneral | xlCenter| | xlDistributed| | xlJustify| | xlLeft| | xlRight|

    With ActiveWorkbook.Worksheets(strSheetName).Cells(lngStartRow, intColumn).Resize(lngRows, 1)
        .NumberFormat = strFormat
        .HorizontalAlignment = intAlign
    End With
End Sub


Sub NumberFormatTableDataColumn(ByVal strSheetName As String, ByVal strTableName As String, ByVal intColumnIndex As Integer, _
    Optional strFormat As String = "General", _
    Optional intAlign As Integer = xlGeneral)
'Formats a column in strTableName with table index intColumn within strSheetName with the strFormat string.
'Aligns horizontally cells contents: intAlign options: xlGeneral | xlCenter| | xlDistributed| | xlJustify| | xlLeft| | xlRight|

    With ActiveWorkbook.Worksheets(strSheetName).ListObjects(strTableName)
        If (.ListRows.Count > 0) Then
            With .DataBodyRange.Columns(intColumnIndex)
                .NumberFormat = strFormat
                .HorizontalAlignment = intAlign
            End With
        End If
    End With
End Sub



Sub SetWrapTextToRange(rng As Range, Optional bolWrap As Boolean = True, Optional bolRowAutoFit As Boolean = True)
'Applies WrapText (or removes it) to rng
'Sets rows height to autofit if bolAutoFit

    rng.WrapText = bolWrap
    If (bolRowAutoFit) Then
        rng.Rows.AutoFit
    End If
End Sub



Sub DrawBorderOutline(ByRef rng As Range, Color As Long, Sides As String, Weight As Integer, _
    Optional bolClearLine As Boolean = False, _
    Optional intLineStyle As Integer = xlContinuous)
'Draws border around rng.
'@Color - border color
'@Sides - which sides to draw border - a combination of T (for top), B (for bottom), L and R, "V" (inner verticals) and "H" (inner horizontals). e.g. "TLR". H for "Inside Horizontal".
'@Weight - border thickness (e.g. xlHairline, xlThin, xlMedium)
'@bolClearLine - clears the current line in the designated Sides
'@intLineStyle - specifies the line style(e.g. xlContinuous, xlDash, xlDot, xlDouble)
        
    If (bolClearLine) Then
        intLineStyle = xlNone
    End If

    If (InStr(Sides, "L") > 0) Then
        With rng.Borders(xlEdgeLeft)
            
            .Color = Color
            .TintAndShade = 0
            .Weight = Weight
            .LineStyle = intLineStyle
        End With
    End If
    If (InStr(Sides, "T") > 0) Then
        With rng.Borders(xlEdgeTop)
            
            .Color = Color
            .TintAndShade = 0
            .Weight = Weight
            .LineStyle = intLineStyle
        End With
    End If
    If (InStr(Sides, "R") > 0) Then
        With rng.Borders(xlEdgeRight)
            
            .Color = Color
            .TintAndShade = 0
            .Weight = Weight
            .LineStyle = intLineStyle
        End With
    End If
    If (InStr(Sides, "B") > 0) Then
        With rng.Borders(xlEdgeBottom)
            
            .Color = Color
            .TintAndShade = 0
            .Weight = Weight
            .LineStyle = intLineStyle
        End With
    End If
    If (InStr(Sides, "H") > 0) Then
        With rng.Borders(xlInsideHorizontal)
            
            .Color = Color
            .TintAndShade = 0
            .Weight = Weight
            .LineStyle = intLineStyle
        End With
    End If
    If (InStr(Sides, "V") > 0) Then
        With rng.Borders(xlInsideVertical)
            
            .Color = Color
            .TintAndShade = 0
            .Weight = Weight
            .LineStyle = intLineStyle
        End With
    End If
End Sub



Sub ColorFormatReportHeaderRow(ByVal strSheetName As String, ByVal lngRow As Long, ByVal intColumns As Integer, _
    ByVal varFillColor As Variant, ByVal varFontColor As Variant, Optional intFirstColumn As Integer = 1, Optional bolBold As Boolean = True, _
    Optional strFontName As String = "Arial", Optional intFontSize As Integer = 11, Optional intRowHeight As Integer = 15, Optional varVertAlign As Variant = xlGeneral)
'Apply formatting to subtotal lngRow of report in strSheetName Worksheet, intColumns wide.
'varVertAlign options: | xlBottom| | xlCenter| | xlDistributed| | xlJustify| | xlTop|

    Dim rng As Range
    
    Set rng = ActiveWorkbook.Sheets(strSheetName).Cells(lngRow, intFirstColumn).Resize(1, intColumns)
    With rng
        .Font.Size = intFontSize
        .Font.Name = strFontName
        .Font.Bold = bolBold
        .Interior.Color = varFillColor
        .Font.Color = varFontColor
        .EntireRow.RowHeight = intRowHeight
        .VerticalAlignment = varVertAlign
    End With
    Set rng = Nothing
End Sub



Sub ColorFormatReportColumns(ByVal strSheetName As String, ByVal lngSheetRow As Long, ByVal lngRows As Long, _
    ByVal intSheetColumn As Integer, _
    Optional intColumns As Integer = 1, _
    Optional varFillColor As Variant = 0, _
    Optional varFontColor As Variant = 0, _
    Optional bolBold As Boolean = False)
'Applies fill and/or font color to a column(s) of cells, starting at lngSheetRow, down lngRows, starting at intSheetColumn, right intColumns.

    Dim rng As Range
    
    Set rng = ActiveWorkbook.Sheets(strSheetName).Cells(lngSheetRow, intSheetColumn).Resize(lngRows, intColumns)
    With rng
        .Font.Bold = bolBold
        .Interior.Color = varFillColor
        .Font.Color = varFontColor
    End With
    Set rng = Nothing
End Sub




Sub ConditionalFormatReportColumns(ByVal strSheetName As String, ByVal lngSheetRow As Long, ByVal lngRows As Long, _
    ByVal intSheetColumn As Integer, ByVal strCondition As String, _
    Optional intColumns As Integer = 1, _
    Optional varFillColor As Variant = 0, _
    Optional varFontColor As Variant = 0)
'Applies fill and/or font color to a column(s) of cells, starting at lngSheetRow, down lngRows, starting at intSheetColumn, right intColumns,
'as a conditional formatting per each cell based on strCondition.
'strCondition includes the part of the formula without the cell reference. E.g.: ">10" will be constructed per each cell: "=(D4>10)"

    Dim rng As Range
    Dim strCellAddress As String
    
    Set rng = ActiveWorkbook.Sheets(strSheetName).Cells(lngSheetRow, intSheetColumn).Resize(lngRows, intColumns)
    strCellAddress = GetColumnLetter(CLng(intSheetColumn)) & lngSheetRow
    
    With rng
        .FormatConditions.Add Type:=xlExpression, Formula1:= _
          "=(" & strCellAddress & strCondition & ")"
        With .FormatConditions(.FormatConditions.Count)
            .SetFirstPriority
            .Interior.Color = varFillColor
            .Font.Color = varFontColor
        End With
    End With
    Set rng = Nothing
End Sub




Sub ClearReportData(ByVal strSheetName As String, ByVal strAnchorRangeName As String, ByVal intReportColumns As Integer)
'Clears content and formattings from all cells of report sheet,
'starting at anchor cell (named range: strAnchorRangeName) down to last used row, to the number of columns specified in intReportColumns.

    Dim FirstRow As Long
    Dim LastRow As Long
    
    With ActiveWorkbook.Sheets(strSheetName)
        FirstRow = ActiveWorkbook.Names(strAnchorRangeName).RefersToRange.Row
        LastRow = Application.Max(.Cells(Rows.Count, 1).End(xlUp).Row, .Cells(Rows.Count, 2).End(xlUp).Row) + 10 'Taking higher last row of two first columns + 10 extra rows
        
            With .Cells(FirstRow, 1).Resize(LastRow, intReportColumns)
                .UnMerge
                .ClearContents
                .ClearFormats
                .EntireRow.RowHeight = STANDARD_ROW_HEIGHT
                .HorizontalAlignment = xlGeneral
                .VerticalAlignment = xlGeneral
                .Orientation = xlHorizontal
            End With
    End With
    
End Sub





'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************



Sub testNumberFormatReportDataColumn()
    Call NumberFormatReportDataColumn("Employees", 2, 5, 3, "yyyy-mm-yy")
    Call NumberFormatReportDataColumn("Employees", 2, 5, 4, "yyyy-mm-yy")
    Call NumberFormatReportDataColumn("Employees", 2, 5, 5, "#,##0")
End Sub


Sub testNumberFormatTableDataColumn()
    Call NumberFormatTableDataColumn("Products", "ProductsTable", 4, "#,##0.00")
End Sub


Sub testSetWrapTextToRange()
    Dim rng As Range
    Set rng = Worksheets("Orders").ListObjects("OrdersTable").ListColumns(2).DataBodyRange
    Call SetWrapTextToRange(rng, True)
End Sub


Sub testDrawBorderOutline()
    Dim rng As Range
    Set rng = Worksheets("Employees").UsedRange
    Call DrawBorderOutline(rng, vbGreen, "TBLR", xlMedium)
End Sub


Sub testColorFormatReportHeaderRow()
    Call ColorFormatReportHeaderRow("Employees", 1, 6, vbBlue, vbYellow, , , , 14, 18, xlCenter)
End Sub


Sub testColorFormatReportColumns()
    Call ColorFormatReportColumns("Employees", 2, 5, 5, , vbWhite, vbRed)
End Sub



Sub testConditionalFormatReportColumns()
    Call ConditionalFormatReportColumns("Employees", 2, 5, 5, ">1100000", , vbYellow, vbRed)
End Sub



Sub testClearReportData()
    Call ClearReportData("Employees", "Employees_Report_Anchor", 6)
End Sub

Attribute VB_Name = "GeneralSearchNavigation"
Option Explicit
'3 functions

'Code use credit text: Code by Mor Sagmon

Sub FindText(strText As String)
'Invokes the find (search) of Excel on the current Worksheet to find strText from current cell onwards.

    On Error GoTo StringNotFound
    Cells.Find(What:=strText, After:=ActiveCell, LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False _
        , SearchFormat:=False).Activate
    Exit Sub

StringNotFound:
    DialogClose "Cannot find " & strText & " here."
    On Error GoTo 0
End Sub



Function GetColumnLetter(lngCol As Long) As String
'Returns the Worksheet column letter of column number (index) lngCol

    On Error Resume Next
    Dim vArr
    vArr = Split(Cells(1, lngCol).Address(True, False), "$")
    GetColumnLetter = vArr(0)
End Function


Sub ActivateStartupSheet()
'Activate the startup Worksheet specified in the Settings tab.
'Typically called from the Workbook_Open event handler in ThisWorkbook module

    Dim strSheet As String
    On Error Resume Next
    strSheet = Worksheets("Settings").Range("Startup_Worksheet").Value
    Worksheets(strSheet).Activate
    On Error GoTo 0
End Sub



'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************



Sub testFindText()
'Run repeateadly to find next occurance
    Worksheets("Products").Activate
    Call FindText("250ml")
End Sub


Sub testGetColumnLetter()
    Debug.Print (GetColumnLetter(9))
End Sub


Sub testActivateStartupSheet()
    
    Call ActivateStartupSheet
End Sub

Attribute VB_Name = "GeneralSheetsBooks"
Option Explicit
'11 functions

'Code use credit text: Code by Mor Sagmon

Function DoesSheetRangeNameExistsInSheet(ByVal strSheetName As String, ByVal strRangeName As String) As Boolean
'Returns True if strRangeName is defined as a sheet-level range name in strSheetName

    Dim SheetLevelName As Name
    
    Set SheetLevelName = Nothing
    
    DoesSheetRangeNameExistsInSheet = False
    
    With ActiveWorkbook.Worksheets(strSheetName)
        On Error Resume Next
        Set SheetLevelName = .Names(strRangeName)
        On Error GoTo 0
        If Not SheetLevelName Is Nothing Then
            DoesSheetRangeNameExistsInSheet = True
        End If
    End With
End Function



Sub HideFlaggedSheets(Optional wkb As Workbook = Nothing)
'Hide all sheets flagged as hidden sheets by Worksheet-level named range within wkb (or Active) Workbook
'Every Worksheet with a Worksheet-Level range name "Hidden_Sheet_Flag" defined on any cell will be hidden

    Dim SheetLevelName As Name
    Dim sh As Worksheet
    
    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    
    UnprotectWorkbook wkb
    
    For Each sh In wkb.Worksheets
        If sh.Visible = -1 Then
            Set SheetLevelName = Nothing
            On Error Resume Next
            Set SheetLevelName = sh.Names("Hidden_Sheet_Flag")
            On Error GoTo 0
            If Not SheetLevelName Is Nothing Then
                sh.Visible = False
            End If
        End If
    Next sh

    Set SheetLevelName = Nothing
    ProtectWorkbook wkb
End Sub




Sub HideSheet(ByVal SheetName As String, Optional wkb As Workbook = Nothing)
'Hide SheetName sheet within wkb (or Active) Workbook
'Protection password is stored in Settings tab

    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    
    With wkb
        .Unprotect Password:=.Sheets("Settings").Range("Protection_Password").Value
        .Sheets(SheetName).Visible = xlSheetHidden
        If InProduction Then
            .Protect Password:=.Sheets("Settings").Range("Protection_Password").Value, Structure:=True, Windows:=True
        End If
    End With
End Sub


Sub UnhideSheet(ByVal SheetName As String, Optional wkb As Workbook = Nothing)
'Unhide SheetName sheet within wkb (or Active) Workbook
'Protection password is stored in Settings tab

    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    
    With wkb
        .Unprotect Password:=.Sheets("Settings").Range("Protection_Password").Value
        .Sheets(SheetName).Visible = xlSheetVisible
        If InProduction Then
            .Protect Password:=.Sheets("Settings").Range("Protection_Password").Value, Structure:=True, Windows:=True
        End If
    End With
End Sub



Function IsSheetHidden(ByVal strSheetName As String, Optional wkb As Workbook = Nothing) As Boolean
'Returns True if strSheetName within wkb (or Active) Workbook is hidden.

    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    
    IsSheetHidden = False
    If Not (wkb.Sheets(strSheetName).Visible = xlSheetVisible) Then
        IsSheetHidden = True
    End If
End Function



Function DoesSheetExists(ByVal SheetName As String, Optional bolCheckVisibility As Boolean = True, Optional wkb As Workbook = Nothing) As Boolean
'Returns True if SheetName exists and is visible. Visibility is only checked if bolCheckVisibility = True

    If wkb Is Nothing Then Set wkb = ActiveWorkbook
    Dim i As Integer
    
    DoesSheetExists = False
    With wkb
        For i = 1 To .Worksheets.Count
            If .Worksheets(i).Name = SheetName Then
                If (bolCheckVisibility) Then
                    If Not IsSheetHidden(SheetName) Then
                        DoesSheetExists = True
                    End If
                Else
                    DoesSheetExists = True
                End If
            End If
        Next i
    End With
End Function



Function OpenWorksheetAsNewExcel(strSheetSourceName As String, strSheetName As String) As Workbook
'Create a new Workbook with the worksheet in it and leave active for the user
'@strSheetName - The Worksheet name to be defined in the new Workbook

    Dim wkbReport As Workbook 'New Workbook
    Dim wkbCurrent As Workbook
    
    If InProduction Then On Error GoTo FailedSub
    Set wkbCurrent = ActiveWorkbook
    Set wkbReport = Workbooks.Add
    
    With wkbReport
        wkbCurrent.Sheets(strSheetSourceName).Copy After:=.Sheets(1)
        Application.DisplayAlerts = False
        .Sheets(1).Delete
        Application.DisplayAlerts = True
        .Sheets(1).Name = strSheetName
    End With
    
    Set OpenWorksheetAsNewExcel = wkbReport
CloseSub:
    Set wkbReport = Nothing
    Set wkbCurrent = Nothing
    Exit Function
FailedSub:
    DialogClose "Failed copying worksheet " & strSheetSourceName & " to a new Excel Workbook."
    GoTo CloseSub
End Function



Function OpenExcelFile(strFullPath As String, Optional bolReadOnly As Boolean = False) As String
'Opens an Excel file if not already open.
'Workbook will be opened in Read-Only mode if bolReadOnly is True
'Returns the Workbook name or "" if failed

    Dim WorkbookName As String 'Name without full path

    WorkbookName = StripFileNameFromPath(strFullPath)
    OpenExcelFile = vbNullString
    If (IsWorkBookOpen(WorkbookName)) Then
        Workbooks(WorkbookName).Activate
    Else
        On Error GoTo FailedFileOpen
        Workbooks.Open Filename:=strFullPath, ReadOnly:=bolReadOnly
    End If
    
    OpenExcelFile = ActiveWorkbook.Name
    
    Exit Function
FailedFileOpen:
    DialogClose "Failed openning Excel file: " & strFullPath
End Function



Function IsWorkBookOpen(strName As String) As Boolean
'Returns True if strName Workbook is open

    Dim xWb As Workbook
    On Error Resume Next
    Set xWb = Application.Workbooks.Item(strName)
    IsWorkBookOpen = (Not xWb Is Nothing)
End Function



Function GetNewWorksheet(ByRef wkb As Workbook, ByVal strSourceSheet) As Worksheet
'returns handle to new worksheet added at the end of wkb, copied from strSourceSheet
    
    With wkb
        .Sheets(strSourceSheet).Copy After:=.Sheets(.Worksheets.Count)
        Set GetNewWorksheet = .Sheets(.Worksheets.Count)
    End With

End Function



Sub CloseWorkbook(strFileName As String, bolSave As Boolean)
'Closes strFileName if open
'bolSave flags to save changes or not

    Dim wkb As Workbook
     
    On Error Resume Next
    Set wkb = Workbooks(strFileName)
    On Error GoTo 0
     
    If Not wkb Is Nothing Then 'Open
        wkb.Close SaveChanges:=bolSave
    End If
    
    Set wkb = Nothing
End Sub


'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************




Sub TestDoesSheetRangeNameExistsInSheet()
    Debug.Print (DoesSheetRangeNameExistsInSheet("Products", "Doc_Date"))
End Sub



Sub testHideFlaggedSheets()
'Worksheet "Hidden" will be hidden - Range A1 is range-named "Hidden_Sheet_Flag" to the Worksheet scope
    Call HideFlaggedSheets
End Sub


Sub testHideSheet()
    
    Call HideSheet("Employees")
End Sub


Sub testUnhideSheet()
    
    Call UnhideSheet("Employees")
End Sub


Sub testIsSheetHidden()
    Debug.Print (IsSheetHidden("Hidden"))
End Sub


Sub testDoesSheetExists()
    Debug.Print (DoesSheetExists("Employees"))
End Sub



Sub testOpenWorksheetAsNewExcel()
    Dim wkbReport As Workbook

    Set wkbReport = OpenWorksheetAsNewExcel("Orders", "2020 Orders")
    wkbReport.SaveAs "C:\temp\2020 Orders.xlsx"
    Debug.Print (wkbReport.Name)
End Sub



Sub testOpenExcelFile()
    Debug.Print (OpenExcelFile("c:\temp\dummy.xlsx"))
End Sub


Sub testIsWorkBookOpen()
    Debug.Print (IsWorkBookOpen("dummy.xlsx"))
End Sub


Sub testGetNewWorksheet()
    Dim shtNew As Worksheet

    Set shtNew = GetNewWorksheet(ThisWorkbook, "Orders")
    shtNew.Name = "New Orders"
    Debug.Print (shtNew.Name)
End Sub


Sub testCloseWorkbook()
    Call CloseWorkbook("2020 Orders.xlsx", False)
End Sub


Attribute VB_Name = "GeneralSystem"
Option Explicit
'5 functions

'Code use credit text: Code by Mor Sagmon

Function GetWindowsUserName() As String
'Returns the logged-in Windows user name

    GetWindowsUserName = Environ("Username")
End Function


Function GetWindowsHostName() As String
'Returns the computer name running this application from the Windows system

    GetWindowsHostName = Environ("computername")
End Function


Function GetWindowsCountryCode() As Long
'Returns the local PC country code (e.g. 1 = United States)
    On Error Resume Next
    GetWindowsCountryCode = Application.International(xlCountrySetting)
    On Error GoTo 0
End Function


Function GetWindowsTempFolder() As String
'Returns the full path to the Windows temporary folder

    GetWindowsTempFolder = Environ("Temp")
End Function



Sub WaitSeconds(intDelay As Integer)
'Pauses execution of program for intDelay seconds

Dim time1, time2

time1 = Now()
time2 = DateAdd("s", intDelay, Now())
    Do Until time1 >= time2
        DoEvents
        time1 = Now()
    Loop

End Sub




'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************



Sub TestGetWindowsUserName()
    Debug.Print (GetWindowsUserName)
End Sub



Sub TestGetWindowsHostName()
    Debug.Print (GetWindowsHostName)
End Sub



Sub TestGetWindowsCountryCode()
    Debug.Print (GetWindowsCountryCode)
End Sub


Sub TestGetWindowsTempFolder()
    Debug.Print (GetWindowsTempFolder)
End Sub



Sub testWaitSeconds()
    Debug.Print "Started", Now()
    Call WaitSeconds(5)
    Debug.Print "Ended", Now()
End Sub
Attribute VB_Name = "GeneralTables"
Option Explicit
'26 functions

'Code use credit text: Code by Mor Sagmon

'********************************************************* TABLES FUNCTIONS ********************************************************


Sub AddTableRow(strSheet As String, strTable As String, strPositionColumn As String, bolPlaceCursor As Boolean, bolSetID As Boolean, Optional strIDColumn As String = "", Optional varNewID As Variant = 0)
'Generic sub to add new row to a table (ListObject).
'Optionally, new ID value can be set in new row, if provided.
'Cursor will be placed in new row and specified column.
' @strSheet - Worksheet name containig the table
' @strTable - ListObject name
' @strPositionColumn - Header name of column to place the cursor in new row
' @bolPlaceCursor - Shall the cursor be placed in new row for user interaction?
' @bolSetID - flag if new ID value will be set
' (optional) @strIDColumn - Header name of column of ID to be set
' (optional) @varNewID - New ID value to be set
    
    UnprotectSheet (strSheet)
    Dim tblTarget As ListObject
    Dim rowNew As ListRow
    
    On Error GoTo FailedAddRow
    
    Set tblTarget = Sheets(strSheet).ListObjects(strTable)
    Set rowNew = tblTarget.ListRows.Add
    
    'Set new ID
    If (bolSetID) Then
        tblTarget.DataBodyRange.Cells(rowNew.Index, tblTarget.ListColumns(strIDColumn).Index) = varNewID
    End If
    
    'Place cursor
    If (bolPlaceCursor) Then
        tblTarget.DataBodyRange.Cells(rowNew.Index, tblTarget.ListColumns(strPositionColumn).Index).Select
    End If

CloseSub:
    Set tblTarget = Nothing
    Set rowNew = Nothing
    ProtectSheet (strSheet)
    Exit Sub
FailedAddRow:
    DialogClose "Failed adding a new row to table: " & strTable
    GoTo CloseSub
End Sub





Sub DeleteTableRow(strSheet As String, strTable As String, strItemName As String, Optional bolRequestConfirmation As Boolean = True)
'Deletes row of current cell within table
' @strSheet - Sheet name containing the table
' @strTable - List Object name
' @strItemName - friendly label of entity being deleted, e.g. order / receipt / employee
' (optional) @bolRequestConfirmation - flag if need to ask for confirmation before deleting

    Dim intTableRow As Integer
    Dim tblSource As ListObject
    Dim rowSource As Range
    Dim dateRecordDate As Date
    
    On Error GoTo FailedDeleting
    
    'Verify active cell is within table range
    If Intersect(ActiveCell, Range(strTable & "[#Data]")) Is Nothing Then
        DialogClose "Place cursor on a valid " & strItemName & " record and try again"
        On Error GoTo 0
        Exit Sub
    End If
            
    'Get user confirmation
    If (bolRequestConfirmation) Then
        If DialogYesNo("Are you sure I can delete this " & strItemName & "?") = False Then Exit Sub
    End If
            
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    intTableRow = ActiveCell.Row - Range(strTable & "[#Headers]").Row
    
    UnprotectSheet (strSheet)
    Set tblSource = Sheets(strSheet).ListObjects(strTable)
    
    Set rowSource = tblSource.ListRows(intTableRow).Range
            
    'Delete row
    rowSource.Delete
    
CloseSub:
    Set tblSource = Nothing
    Set rowSource = Nothing
      
    RestoreState strSheet
    Exit Sub
FailedDeleting:
        Call DialogClose("Failed deleting " & strSheet)
        GoTo CloseSub
End Sub



Function AddTableRowWithFields(ByVal strSheetName As String, ByVal strTableName As String, ByVal intSkipLastColumns As Integer, ParamArray values()) As Long
'Adds a new row at the end of the table and fills its fields with Values array items.
'intSkipLastColumns - this number of columns at the end of the table will not be overwritten. Must match number of Values passed. Typically = 0.
'Returns the new table row index or -1 if failed

    Dim lngNewRow As Long
    lngNewRow = -1
    
    Dim tbl As ListObject
    Dim rowNew As ListRow
    
    UnprotectSheet (strSheetName)
    Application.EnableEvents = False
    On Error GoTo FailedTable

    Set tbl = Sheets(strSheetName).ListObjects(strTableName)
    Set rowNew = tbl.ListRows.Add
    
    If (IsArray(values(0)) = True) Then 'Identify a nested array case: first array parameter holds an array itself
        Worksheets(strSheetName).Cells(rowNew.Range.Row, tbl.HeaderRowRange.Column).Resize(1, tbl.DataBodyRange.Columns.Count - intSkipLastColumns).Value = values(0)
    Else
        Worksheets(strSheetName).Cells(rowNew.Range.Row, tbl.HeaderRowRange.Column).Resize(1, tbl.DataBodyRange.Columns.Count - intSkipLastColumns).Value = values
    End If
    
    lngNewRow = rowNew.Index
CloseSub:
    Set tbl = Nothing
    Set rowNew = Nothing
    Application.EnableEvents = True
    ProtectSheet (strSheetName)
    AddTableRowWithFields = lngNewRow
    Exit Function
FailedTable:
    GoTo CloseSub
End Function




Sub UpdateWorksheetRowWithFields(ByVal strSheetName As String, ByVal lngRow As Long, ByVal intFirstColumn As Integer, ParamArray values())
'Fills a row of Fields in a Worksheet with values.
'@strSheetName - Worksheet name to fill values
'@lngRow - Worksheet row to fill values
'@intFirstColumn - Anchor (left) column of first value to fill
'@Values - ParamArray of values to fill (expecting at least one element). Accepts either an array of arguments (in which case IsArray(Values(0) = True) or list of arguments.

    Dim varValue As Variant
    
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    
    'Assumes error handling in calling subs
    
    If (IsArray(values(0)) = True) Then 'Identify a special case of a single member array
        Worksheets(strSheetName).Range("A1").Offset(lngRow - 1, intFirstColumn - 1).Resize(1, UBound(values(0)) - LBound(values(0)) + 1).Value = values(0)
    Else
        Worksheets(strSheetName).Range("A1").Offset(lngRow - 1, intFirstColumn - 1).Resize(1, UBound(values) - LBound(values) + 1).Value = values
    End If

    Application.Calculation = xlCalculationAutomatic
    'Assumes RestoreState in calling subs
End Sub


Sub DeleteWorksheetRowByWorksheetRow(ByVal strSheetName As String, ByVal lngRow As Long)
'Deletes a complete Worksheet row in strSheetName

    'Assumes error handling in calling subs
    
    Worksheets(strSheetName).Range("A1").Offset(lngRow - 1, 0).EntireRow.Delete

End Sub




Sub DeleteTableRowByKey(ByVal strSheetName As String, ByVal strTableName As String, ByVal strColumn As String, ByVal KeyValue As Variant)
'Deletes a row from strSheetName where KeyValue is matched on strColumn of strTableName on that Worksheet

    Dim lngSheetRow As Long
    Dim lngFirstTableColumn As Long
    Dim lngSheetLookupColumn As Long
    Dim lngSheetUpdateColumn As Long
    
    'Assumes error handling in calling subs
    
    lngFirstTableColumn = GetSheetColumnIndexByTableColumn(strSheetName, strTableName, 1)
    lngSheetLookupColumn = GetSheetColumnIndexByTableColumn(strSheetName, strTableName, strColumn)
    
    If (lngFirstTableColumn * lngSheetLookupColumn > 0) Then
        lngSheetRow = GetRecordRow(strSheetName, strTableName, lngSheetLookupColumn - lngFirstTableColumn + 1, KeyValue, False)
        If (lngSheetRow > 0) Then
            Call DeleteWorksheetRowByWorksheetRow(strSheetName, lngSheetRow)
        End If
    End If

End Sub




Sub RemoveTableLastRow(ByVal strSheetName As String, ByVal strTableName As String, Optional bolLeaveFormulas As Boolean = True)
'Resizes table by one row and clears content of remaining row.
'If bolLeaveFormulas=True and only one row in table - clears only non-formulas cells and leaves first row with formulas.

    Dim lngTableRows As Long
    Dim tbl As ListObject
    
    On Error GoTo FailedTable
    
    Set tbl = Sheets(strSheetName).ListObjects(strTableName)
    lngTableRows = tbl.ListRows.Count
    
    If (lngTableRows = 0) Then GoTo CloseSub
    If (lngTableRows = 1) Then
        If (bolLeaveFormulas) Then
            Call ClearTable(strSheetName, strTableName)
        Else
            tbl.DataBodyRange.Rows.Delete
        End If
        GoTo CloseSub
    End If
     
    tbl.ListRows(lngTableRows).Delete
    
    
CloseSub:
    Set tbl = Nothing
    Exit Sub
FailedTable:
    DialogClose "Failed removing last row of table " & strTableName
    GoTo CloseSub
End Sub




'*************************************** UPDATE SPECIFIC FIELDS IN TABLES *********************************************************************


Function UpdateTableColumnByMatchedKey(ByVal strSheetName As String, ByVal strTableName As String, ByVal strValuesColumn As String, ByVal strNewValue As String, ByVal strKeyColumn As String, ByVal varKey As Variant) As Long
'Updates the column value of one or more rows in a table matching a column key value.
'Updates all cells in strValuesColumn with strNewValue for which their strKeyColumn matchned varKey.
'Returns number of records updated, -1 if failed

    Dim lngRowsUpdated As Long
    Dim arrValues() As Variant
    Dim arrKeys() As Variant
    Dim i As Long
    
    lngRowsUpdated = 0
    
    On Error GoTo FailedSub

    With ActiveWorkbook.Worksheets(strSheetName)
        If Not .ListObjects(strTableName).DataBodyRange Is Nothing Then
            If (.Range(strTableName & "[#Data]").Rows.Count = 1) Then 'Special case of table having a sigle row
                ReDim arrValues(1 To 1, 1 To 1)
                ReDim arrKeys(1 To 1, 1 To 1)
                
                With .ListObjects(strTableName)
                    arrValues(1, 1) = .DataBodyRange.Cells(1, .ListColumns(strValuesColumn).Index)
                    arrKeys(1, 1) = .DataBodyRange.Cells(1, .ListColumns(strKeyColumn).Index)
                End With
            Else
                arrValues = .Range(strTableName & "[" & strValuesColumn & "]").Value
                arrKeys = .Range(strTableName & "[" & strKeyColumn & "]").Value
            End If
            
            For i = LBound(arrValues, 1) To UBound(arrValues, 1)
                If (arrKeys(i, 1) = varKey) Then
                    arrValues(i, 1) = strNewValue
                    lngRowsUpdated = lngRowsUpdated + 1
                End If
            Next i
        
            If (lngRowsUpdated > 0) Then
                .Range(strTableName & "[" & strValuesColumn & "]").Value = arrValues
            End If
            
        End If
    End With
    
CloseSub:
    UpdateTableColumnByMatchedKey = lngRowsUpdated
    Exit Function
FailedSub:
    lngRowsUpdated = -1
    GoTo CloseSub
End Function



Sub ResizeTable(strWorksheetName As String, strTableName As String, lngRows As Long, intCols As Integer, Optional bolUnprotect As Boolean = True)
'Resizes a table (ListObject) to have lngRows (header row included) by intCols cells.
'bolUnprotect flags if strWorksheetName holding the table needs to be unprotected before the table resize operation.

    Dim rng As Range
    Dim HideSheetFlag As Boolean

    If InProduction Then On Error GoTo FailedSub
    
    HideSheetFlag = False
    If (lngRows = 1) Then lngRows = 2
    
    If (IsSheetHidden(strWorksheetName)) Then
        HideSheetFlag = True
        UnprotectWorkbook
        UnhideSheet (strWorksheetName)
    End If

    Set rng = Range(strTableName & "[#All]").Resize(lngRows, intCols)
  
    If bolUnprotect Then UnprotectSheet strWorksheetName
    Sheets(strWorksheetName).ListObjects(strTableName).Resize rng
    
CloseSub:
    If (HideSheetFlag) Then
        HideSheet (strWorksheetName)
        ProtectWorkbook
    End If
    If bolUnprotect Then ProtectSheet strWorksheetName
    
    Set rng = Nothing
    Exit Sub
FailedSub:
    GoTo CloseSub
End Sub


Function GetTableRows(ByVal strSheetName As String, ByVal strTableName As String) As Long
'Returns the DataBodyRange rows count of a table

    Dim tbl As ListObject
    
    Set tbl = Sheets(strSheetName).ListObjects(strTableName)
    
    If Not tbl.DataBodyRange Is Nothing Then
        GetTableRows = tbl.DataBodyRange.Rows.Count
    Else
        GetTableRows = 0
    End If
    Set tbl = Nothing
End Function


Function GetTableColumns(ByVal strSheetName As String, ByVal strTableName As String) As Long
'Returns the columns count of a table

    Dim tbl As ListObject
    
    Set tbl = Sheets(strSheetName).ListObjects(strTableName)
    
    GetTableColumns = tbl.HeaderRowRange.Columns.Count

    Set tbl = Nothing
End Function



Function GetRecordRow(SheetName As String, TableName As String, ColumnNum As Long, Key As Variant, Optional bolCreateNew As Boolean = True) As Long
'Returns the Worksheet ROW in which a Key is matched on ColumnNum of a given range (TableName), or row number of next new table row to be added.
'bolCreateNew flags if a new row is to be added when no match on any table row.

    Dim lngRow As Long
    
    lngRow = GetKeyMatchedTableRow(SheetName, TableName, ColumnNum, Key)
    
    If (lngRow > 0) Then
        GetRecordRow = lngRow
    Else
        GetRecordRow = 0
        'New row needs to be created
        If (bolCreateNew) Then
            GetRecordRow = GetNewRow(SheetName, TableName)
        End If
    End If

End Function


Function GetNewRow(SheetName As String, TableName As String) As Long
'Adds a new row at the end of TableName and returns the Worksheet row number of the newly added row

    Dim tbl As ListObject
    Dim wks As Worksheet
    Dim lngNewRow As Long
    Dim bolFirstRowFlag As Boolean 'flags table in init state: one empty row (preserving formulas).
    
    Set wks = Worksheets(SheetName)
    Set tbl = wks.ListObjects(TableName)
    
    bolFirstRowFlag = False
    
    If (tbl.ListRows.Count = 1) Then
        If (tbl.DataBodyRange(1, 1) = 0) Then
            bolFirstRowFlag = True
        End If
    End If
    
    If (bolFirstRowFlag) Then
        lngNewRow = tbl.HeaderRowRange.Row + 1
    Else
        lngNewRow = tbl.ListRows.Count + tbl.HeaderRowRange.Row + 1
        tbl.ListRows.Add
    End If
    
    GetNewRow = lngNewRow
    
    Set tbl = Nothing
    Set wks = Nothing
End Function


Function GetKeyMatchedTableRow(ByVal SheetName As String, ByVal TableName As String, ByVal ColumnNum As Long, ByVal Key As Variant) As Long
'Returns the Worksheet ROW in which a Key is matched on ColumnNum of a given range (TableName).
'Equivalent to the Worksheet MATCH function
'ColumnNum is the index (relative) column number within TableName range

    Dim shtCurrent As Worksheet
    Dim lngHeaderRow As Long
    Dim lngTableRows As Long
    Dim arrColValues() As Variant
    Dim i As Long
    
    If InProduction Then On Error GoTo FailedSub
    
    GetKeyMatchedTableRow = 0 'not matched
    
    lngTableRows = GetTableRows(SheetName, TableName)
    If (lngTableRows < 1) Then Exit Function
    
    lngHeaderRow = Worksheets(SheetName).Range(TableName & "[#Headers]").Row
    
    If (lngTableRows = 1) Then
        If (Worksheets(SheetName).ListObjects(TableName).DataBodyRange(1, ColumnNum).Value = Key) Then
            GetKeyMatchedTableRow = 1 + lngHeaderRow
            GoTo CloseSub
        End If
    Else
        arrColValues = Worksheets(SheetName).ListObjects(TableName).ListColumns(ColumnNum).DataBodyRange.Value
        For i = LBound(arrColValues, 1) To UBound(arrColValues, 1)
            If (arrColValues(i, 1) = Key) Then
                GetKeyMatchedTableRow = i + lngHeaderRow
                GoTo CloseSub
            End If
        Next i
    End If
    
CloseSub:
    
    Exit Function
FailedSub:
    GoTo CloseSub
End Function



Function GetSheetColumnIndexByTableColumn(ByVal SheetName As String, ByVal TableName As String, ByVal varColumn As Variant) As Long
'Returns the Worksheet COLUMN in which varColumn is found in TableName.
'varColumn can be either table column name or table column index
'Returns 0 if no match

    Dim lngMatchedColumn As Long
     
    On Error Resume Next
    If (IsNumeric(varColumn)) Then
        lngMatchedColumn = Worksheets(SheetName).Range(TableName) _
            .Columns(varColumn).Column
    Else
        lngMatchedColumn = Worksheets(SheetName).Range(TableName) _
            .Columns(WorksheetFunction.Match(varColumn, Range(TableName).Rows(0), 0)).Column
    End If
    If Err.Number <> 0 Then
        Err.Clear
        lngMatchedColumn = 0 'not matched
    End If
    On Error GoTo 0
    
    GetSheetColumnIndexByTableColumn = lngMatchedColumn
End Function



Sub SortTable(strSheetName As String, strTableName As String, strColumnName As String, intSortOrder As Integer)
'Sorts strTableName in strSheetName by strColumnName in Asc or Desc order.
'intSortOrder can be xlAscending or xlDescending

    Dim CurrentCell As Range
    Dim wksCurrentSheet As Worksheet
    Set wksCurrentSheet = Application.ActiveSheet
    Set CurrentCell = ActiveCell
    
    If InProduction Then On Error GoTo FailedSorting
    Notify "Sorting table. Please wait..."
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    With ActiveWorkbook.Worksheets(strSheetName)
        .Activate
        UnprotectSheet strSheetName
        
        Range(strTableName & "[#All]").Select
        .ListObjects(strTableName).Sort.SortFields _
            .Clear
        .ListObjects(strTableName).Sort.SortFields _
            .Add Key:=Range(strTableName & "[" & strColumnName & "]"), SortOn:=xlSortOnValues, Order _
            :=intSortOrder, DataOption:=xlSortNormal
        With .ListObjects(strTableName).Sort
            .Header = xlYes
            .MatchCase = False
            .Orientation = xlTopToBottom
            .SortMethod = xlPinYin
            .Apply
        End With
        
        .ListObjects(strTableName).DataBodyRange(1, 1).Select 'If cursor needs to be positioned on table top-left cell
        
    End With
CloseSub:
    wksCurrentSheet.Select
    CurrentCell.Activate
    
    Set CurrentCell = Nothing
    Set wksCurrentSheet = Nothing
    RestoreState strSheetName 'Replace if state is controlled and restored by the calling sub/function
    Exit Sub
FailedSorting:
    DialogClose "Failed sorting table: " & strTableName
    GoTo CloseSub
End Sub


Public Sub ClearTableRows(strSheet As String, strTableName As String, Optional intRows As Integer = 0)
'Delete TableRows of table, except first intRows of table
'Assumes Error handling and unprotection in calling sub

    Dim tbl As ListObject
    If InProduction Then On Error GoTo CloseSub
    
    Set tbl = Sheets(strSheet).ListObjects(strTableName)
    
    If (tbl.DataBodyRange Is Nothing) Or (tbl.ListRows.Count <= intRows) Then GoTo CloseSub
    
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    tbl.DataBodyRange.Offset(intRows, 0).Resize(tbl.DataBodyRange.Rows.Count - intRows, tbl.DataBodyRange.Columns.Count).Rows.Delete
    
CloseSub:
    Set tbl = Nothing
    Application.DisplayAlerts = True
    Application.EnableEvents = True
End Sub



Public Sub ClearTable(strSheet As String, strTableName As String)
'clears contents of non-formula cells in a table and deletes all rows except first one
'Assumes state control in calling sub/function (ScreenUpdating/DisplayAlerts/etc..)

    Dim tbl As ListObject
    Dim colCurrentCol As ListColumn
    Dim rng As Range
    Dim FirstRow As Range
    
    If InProduction Then On Error GoTo FailedSub
    
    Set tbl = Sheets(strSheet).ListObjects(strTableName)
    
    If (tbl.DataBodyRange Is Nothing) Then GoTo CloseSub
    
    'Delete all but the first table row
    If tbl.DataBodyRange.Rows.Count > 1 Then
        tbl.DataBodyRange.Offset(1, 0).Resize(tbl.DataBodyRange.Rows.Count - 1, _
        tbl.DataBodyRange.Columns.Count).Rows.Delete
    End If
    
    'Clear contents of all non-formula cells in remaining row
    Set FirstRow = tbl.ListRows(1).Range
    For Each colCurrentCol In tbl.ListColumns
        If (Not Intersect(FirstRow, tbl.ListColumns(colCurrentCol.Name).Range).HasFormula) Then
            Intersect(FirstRow, tbl.ListColumns(colCurrentCol.Name).Range).ClearContents
        End If
    Next colCurrentCol
   
CloseSub:
    Set tbl = Nothing
    Set rng = Nothing
    Set FirstRow = Nothing
    Exit Sub
FailedSub:
    DialogClose "Failed clearing data from table: " & strTableName
    GoTo CloseSub
End Sub


Function GetTableValueByIndex(strSheetName As String, strTableName As String, lngRow, strColumnName As String) As Variant
'Returns a value within a ListObject at the intersection of the table row index (lngRow) and tabel column name.
'Returns Empty if not found / error

    Dim tbl As ListObject
    Dim intColumn As Integer
    
    On Error GoTo FailedSub
    GetTableValueByIndex = Empty
    
    Set tbl = Worksheets(strSheetName).ListObjects(strTableName)
    intColumn = tbl.ListColumns(strColumnName).Index
    
    GetTableValueByIndex = tbl.DataBodyRange(lngRow, intColumn).Value
CloseSub:
    Set tbl = Nothing
    Exit Function
FailedSub:
    GetTableValueByIndex = Empty
    GoTo CloseSub
End Function



Function GetTableValueByColumnValue(strSheetName As String, strTableName As String, strLookupColumnName As String, varLookupColumnValue As Variant, strFindColumnName As String) As Variant
'This is in essence a VLOOKUP implementation on a table.
'Lookup varLookupColumnValue in column strLookupColumnName and return the matched value in column strFindColumnName
'Returns Empty if no match found

    Dim i As Long
    Dim tbl As ListObject
    Dim intFindColumn As Integer
    Dim intLookupColumn As Integer
    Dim lngRows As Long 'Total table rows
    Dim lngRow 'Table index of matched row
        
    On Error GoTo FailedSub
    GetTableValueByColumnValue = Empty
    
    Set tbl = Worksheets(strSheetName).ListObjects(strTableName)
    intFindColumn = tbl.ListColumns(strFindColumnName).Index
    intLookupColumn = tbl.ListColumns(strLookupColumnName).Index
    lngRows = tbl.ListRows.Count
    
    lngRow = 0
    If (lngRows < 1) Then GoTo CloseSub
    
    If (lngRows = 1) Then
        If (varLookupColumnValue = tbl.DataBodyRange(1, intLookupColumn).Value) Then
            lngRow = 1
        End If
        GoTo FoundMatch
    End If
    'Lookup the match in all rows - copy lookup column into an array for fast search
    Dim arr As Variant
        
    arr = tbl.DataBodyRange(1, intLookupColumn).Resize(lngRows, 1)
    For i = 1 To lngRows
        If (varLookupColumnValue = arr(i, 1)) Then
            lngRow = i
            GoTo FoundMatch
        End If
    Next i
FoundMatch:
    
    If (lngRow > 0) Then
        GetTableValueByColumnValue = tbl.DataBodyRange(lngRow, intFindColumn).Value
    End If
   
CloseSub:
    Set tbl = Nothing
    Exit Function
FailedSub:
    GetTableValueByColumnValue = Empty
    GoTo CloseSub
End Function



Function UpdateTableCellByMatchedKeyAndColumnName(ByVal strSheetName As String, ByVal strTableName As String, ByVal strLookupColumnName As String, ByVal varLookupColumnValue As Variant, ByVal strFindColumnName As String, ByVal varNewValue As Variant, Optional bolCancelWrapText As Boolean = False) As Boolean
'Looks up a row in a table by a key value, and updates this row's cell in column provided by its column name
'Returns True upon success
' @strLookupColumnName - Column name to search matched value
' @varLookupColumnValue - Value to match on strLookupColumnName
' @strFindColumnName - Column name of cell to be updated
' @varNewValue - New value of target cell
' @bolCancelWrapText - Flags if WrapText is to be cancelled on target cell after the update

    Dim lngSheetRow As Long
    Dim lngFirstTableColumn As Long
    Dim lngSheetLookupColumn As Long
    Dim lngSheetUpdateColumn As Long
    
    UpdateTableCellByMatchedKeyAndColumnName = False
    
    lngFirstTableColumn = GetSheetColumnIndexByTableColumn(strSheetName, strTableName, 1)
    lngSheetLookupColumn = GetSheetColumnIndexByTableColumn(strSheetName, strTableName, strLookupColumnName)
    lngSheetUpdateColumn = GetSheetColumnIndexByTableColumn(strSheetName, strTableName, strFindColumnName)
    If (lngFirstTableColumn * lngSheetLookupColumn * lngSheetUpdateColumn > 0) Then
        lngSheetRow = GetRecordRow(strSheetName, strTableName, lngSheetLookupColumn - lngFirstTableColumn + 1, varLookupColumnValue, False)
        If (lngSheetRow > 0) Then
            Worksheets(strSheetName).Cells(lngSheetRow, lngSheetUpdateColumn).Value = varNewValue
            If (bolCancelWrapText) Then
                Worksheets(strSheetName).Cells(lngSheetRow, lngSheetUpdateColumn).WrapText = False
            End If
            UpdateTableCellByMatchedKeyAndColumnName = True
        End If
    End If

End Function





Function LoadTableColumnIntoArray(ByVal SheetName As String, ByVal TableName As String, ByVal ColumnName As String, ByRef arr() As Variant) As Long
'Loads all rows of a specific column in table into arr - 1-Based
'Returns the number of rows loaded

    Dim lngRows As Long
    
    
    With ActiveWorkbook.Sheets(SheetName).ListObjects(TableName)
        lngRows = .ListRows.Count
        If (lngRows > 0) Then
            If (.ListColumns(ColumnName).DataBodyRange.Cells.Count = 1) Then
                ReDim arr(1 To 1, 1 To 1)
                arr(1, 1) = .ListColumns(ColumnName).DataBodyRange.Value
            Else
                arr = .ListColumns(ColumnName).DataBodyRange.Value
            End If
        End If
    
    End With
    
    LoadTableColumnIntoArray = lngRows
End Function




Sub ReplaceValueInColumnCells(ByVal strSheetName As String, ByVal strTableName As String, strColumn As String, varCurrValue As Variant, varNewValue As Variant)
'Find & Replace varCurrValue with varNewValue in strColumn of strTableName

    Worksheets(strSheetName).Range(strTableName & "[" & strColumn & "]").Replace What:=varCurrValue, Replacement:=varNewValue, SearchOrder:=xlByColumns
    
End Sub



Public Sub ApplyArrayToTable(strSheetName As String, strTableName As String, arr() As Variant)
'Resizes the table to fit the array rows and the table columns
'Throws the array data to the resized table

    Dim tbl As ListObject
    Dim rng As Range
    
    On Error GoTo FailedSub

    Application.EnableEvents = False
    
    Call ClearTable(strSheetName, strTableName) 'Clear previous content in table
    
    With ActiveWorkbook
        
        Set tbl = .Worksheets(strSheetName).ListObjects(strTableName)
        
        'Resizing the table
        Set rng = tbl.HeaderRowRange.Cells(1, 1).Resize(UBound(arr, 1) - LBound(arr, 1) + 1 + 1, tbl.ListColumns.Count)
        tbl.Resize rng
        
        'Throwing the data
        Set rng = tbl.HeaderRowRange.Cells(1, 1).Offset(1, 0).Resize(UBound(arr, 1) - LBound(arr, 1) + 1, tbl.ListColumns.Count) 'Only data range
        rng.Value = arr
    End With
    
CloseSub:
    Application.EnableEvents = True
    Exit Sub
FailedSub:
    GoTo CloseSub
End Sub





Function GetTableRowIndexForUpdate(strSheetName As String, strTableName As String) As Long
'Idenfity active cell in strSheetName
'Verify ActiveCell in the strTableName data range
'Returns table index row of active cell or 0 if not in table range
      
      
    GetTableRowIndexForUpdate = 0
    
    On Error GoTo FailedSub
    
    Dim tbl As ListObject
    Set tbl = ActiveWorkbook.Worksheets(strSheetName).ListObjects(strTableName)
    
    'Verify active cell is in table data range
    If Not Intersect(Application.ActiveCell, tbl.DataBodyRange) Is Nothing Then
        GetTableRowIndexForUpdate = Application.ActiveCell.Row - tbl.HeaderRowRange.Row
    Else
        DialogClose "Please select any table row you wish to update and try again."
    End If
    
CloseSub:
    Exit Function
FailedSub:
    DialogClose "Failed accessing the target table. Please contact support"
    GoTo CloseSub

End Function


'********************************************************* END TABLES FUNCTIONS ****************************************************


'********************************************************* TABLES FILTERS **********************************************************

Sub ClearTableFilters(ByVal strSheetName As String, ByVal strTableName)
'Resets filters of table - shows all records

    Dim i As Integer
    
    With ActiveWorkbook.Sheets(strSheetName).ListObjects(strTableName)

        If Not (.AutoFilter Is Nothing) Then
            .AutoFilter.ShowAllData
            .ShowAutoFilter = False
        End If
    End With
    

End Sub




'********************************************************* END TABLES FILTERS ******************************************************



'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************



Sub testAddTableRow()
    Dim lngLastRoom As Long
    
    lngLastRoom = ThisWorkbook.Names("Last_Room_Number").RefersToRange.Value
    Call AddTableRow("Tables", "RoomsTable", "Room Name", True, True, "Room Number", lngLastRoom + 1)
End Sub


Sub testDeleteTableRow()
'Position the cursor on any cell along the row to be deleted from the Rooms table and run

    Call DeleteTableRow("Tables", "RoomsTable", "Room", True)
End Sub


Sub TestAddTableRowWithFields()
    Debug.Print (AddTableRowWithFields("Tables", "RoomsTable", 0, 4, "Saturn", 20))
End Sub



Sub testUpdateWorksheetRowWithFields()
    Call UpdateWorksheetRowWithFields("Employees", 7, 1, 255, "Ronald LeFevre", "1987-05-12", "2008-10-01", 850000, "Europe")
End Sub



Sub testDeleteWorksheetRowByWorksheetRow()
    Call DeleteWorksheetRowByWorksheetRow("Employees", 7)
End Sub


Sub TestDeleteTableRowByKey()
    Call DeleteTableRowByKey("Orders", "OrdersTable", "Order Number", 1555)
End Sub



Sub TestRemoveTableLastRow()
    Application.EnableEvents = False
    Call RemoveTableLastRow("Orders", "OrdersTable")
    Application.EnableEvents = True
End Sub



Sub TestUpdateTableColumnByMatchedKey()
    Debug.Print (UpdateTableColumnByMatchedKey("Orders", "OrdersTable", "Status", "delivered", "Order Number", 1520))
End Sub


Sub TestGetNewRow()
    Debug.Print (GetNewRow("Tables", "RoomsTable"))
End Sub



Sub testResizeTable()
    Call ResizeTable("Tables", "RoomsTable", 4, 3, False)
End Sub



Sub TestGetTableRows()
    Debug.Print (GetTableRows("Orders", "OrdersTable"))
End Sub



Sub TestGetTableColumns()
    Debug.Print (GetTableColumns("Orders", "OrdersTable"))
End Sub



Sub TestGetRecordRow()
    Debug.Print (GetRecordRow("Products", "ProductsTable", 1, 36))
End Sub



Sub TestGetKeyMatchedTableRow()
    Debug.Print (GetKeyMatchedTableRow("Products", "ProductsTable", 1, 36))
End Sub



Sub TestGetSheetColumnIndexByTableColumn()
    Debug.Print (GetSheetColumnIndexByTableColumn("Products", "ProductsTable", "Product Group"))
End Sub


Sub testSortTable()
    Call SortTable("Tables", "RoomsTable", "Capacity", xlDescending)
End Sub



Sub testClearTableRows()
    Call ClearTableRows("Tables", "RoomsTable", 1)
End Sub



Sub testClearTable()
    Call ClearTable("Tables", "RoomsTable")
End Sub



Sub TestGetTableValueByIndex()
    Dim varResult As Variant

    varResult = GetTableValueByIndex("Products", "ProductsTable", 2, "Product Description")
    If Not IsEmpty(varResult) Then
        Debug.Print (varResult)
    End If
End Sub



Sub TestGetTableValueByColumnValue()
    Dim varResult As Variant

    varResult = GetTableValueByColumnValue("Products", "ProductsTable", "Product Code", 43, "Price")
    If Not IsEmpty(varResult) Then
        Debug.Print (varResult)
    End If
End Sub


Sub TestUpdateTableCellByMatchedKeyAndColumnName()

    Debug.Print (UpdateTableCellByMatchedKeyAndColumnName("Products", "ProductsTable", "Product Code", 43, "Price", 99.8))
End Sub



Sub TestLoadTableColumnIntoArray()

    Dim arr() As Variant
    Dim result As Long
    
    result = LoadTableColumnIntoArray("Products", "ProductsTable", "Product Description", arr)
        
    Debug.Print (result)
    Debug.Print ("Second Product: " & arr(2, 1))
End Sub



Sub testReplaceValueInColumnCells()
    Call ReplaceValueInColumnCells("Products", "ProductsTable", "Product Group", "Female Care", "Feminine Care")
End Sub




Sub testApplyArrayToTable()
    Dim arr(1 To 2, 1 To 2) As Variant
    
    arr(1, 1) = "USD"
    arr(1, 2) = "United States"
    arr(2, 1) = "EUR"
    arr(2, 2) = "Europe"

    Call ApplyArrayToTable("Tables", "CurrenciesTable", arr)
End Sub


Sub TestGetTableRowIndexForUpdate()
'Activate the Products table and position the cursor on any table cell

    Debug.Print (GetTableRowIndexForUpdate("Products", "ProductsTable"))
End Sub


Sub testClearTableFilters()
'Activate AutoFilter on the Products table and run to clear filters

    Call ClearTableFilters("Products", "ProductsTable")
End Sub


Attribute VB_Name = "GeneralUserInteraction"
Option Explicit
'16 functions

'Code use credit text: Code by Mor Sagmon

Public bolDialogChoiceYesNo As Boolean
Public txtDialogMessage As String
Public txtDialogInput As String
Public txtDialogInput2 As String
Public txtDialogInputNewPassword As String
Public bolFullScreen As Boolean

Public bolEnableFormEvents As Boolean 'Flags form init to bypass controls handlers


'********************************************************* USER DIALOGS ***************************************************************************

Function DialogLogin() As Boolean
'Upon form submit user input is provided in:
'txtDialogInput - username
'txtDialogInput2 - user password
'txtDialogInputNewPassword - new password in case password change was requested ("" if not requested)

    DialogLoginForm.Show

    DialogLogin = bolDialogChoiceYesNo
End Function




Sub DialogClose(ByVal varMessage As Variant)
'Pops up a message box with varMessage and a single "Close" button.

    txtDialogMessage = varMessage

    DialogCloseForm.Show
End Sub


Function DialogInput(ByVal varMessage As Variant) As Boolean
'Pops up a dialog requesting an input from the user.
'Returns True if user submitted (not cancelled)
'User input is provided in txtDialogInput upon form submit

    txtDialogMessage = varMessage
    
    DialogInputForm.Show
    DialogInput = bolDialogChoiceYesNo
End Function



Function DialogYesNo(ByVal varMessage As Variant) As Boolean
'Pops up a message box with varMessage and Yes/No buttons.
'Returns True if user clicked "Yes"
    
    txtDialogMessage = varMessage

    DialogYesNoForm.Show
    DialogYesNo = bolDialogChoiceYesNo
End Function



Sub DialogConfirmed(ByVal varMessage As Variant)
'Pops up a message box with varMessage and a single "Close" button.
'Icon represents "Confirmed"

    txtDialogMessage = varMessage

    DialogConfirmedForm.Show
End Sub




'***************************************** USER FORMS SERVICES ******************************************************

Sub LimitEntryLength(frm As Object, ByVal strControl As String, intLimit As Integer)
'Truncates strControl value if exceeds intLimit and notifies the user

    With frm
        If (Len(.Controls(strControl).Value) > intLimit) Then
            .Controls(strControl).Value = Left(.Controls(strControl).Value, intLimit)
            DialogClose "Text is limited to " & intLimit & " characters."
        End If
    End With
End Sub



'**************************************** TABLES ACTION BUTTONS SERVICES *********************************************

Public Function GetCellSheetName() As String
'Returns Worksheet name of active cell

    GetCellSheetName = ActiveCell.Parent.Name
End Function


Public Function GetCellValue() As Variant
'Returns value of active cell

    GetCellValue = ActiveCell.Value
End Function


Public Function GetCellRow() As Long
'Returns Worksheet ROW of active cell

    GetCellRow = ActiveCell.Row
End Function


Public Function GetCellColumn() As Long
'Returns Worksheet COLUMN index of active cell

    GetCellColumn = ActiveCell.Column
End Function


Public Function LookupColumnValueOfActiveCell(ByVal SheetColumnIndex As Integer) As Variant
'Vlookup returning the value of intersection of current active cell row and ColumnIndex of Worksheet

    LookupColumnValueOfActiveCell = ActiveCell.Offset(0, SheetColumnIndex - ActiveCell.Column).Value
End Function

Public Function LookupRowValueOfActiveCell(ByVal SheetRowIndex As Integer) As Variant
'Hlookup returning the value of intersection of current active cell column and RowIndex of Worksheet

    LookupRowValueOfActiveCell = ActiveCell.Offset(SheetRowIndex - ActiveCell.Row, 0).Value
End Function




'**************************************** END TABLES ACTION BUTTONS SERVICES *****************************************


'******************************************************************** FULL SCREEN AND ZOOM *****************************************************************



Sub ScreenViewFull()
'Expands Excel data area to full screen

    Application.ScreenUpdating = False

    Application.DisplayFullScreen = True
    Application.DisplayFormulaBar = False
    
    Call ShowOrHideWorksheetsHeadings(False)
    
    'If you offer zoom-in/zoom-out buttons on the Worksheet (one on top of the other), you may want to toggle their visibility to show only the relevant button
    'ActiveSheet.Shapes("btnFullScreenOut").Visible = False
    'ActiveSheet.Shapes("btnFullScreenIn").Visible = True
    
    bolFullScreen = True
    Application.ScreenUpdating = True
End Sub


Sub ScreenViewRegular()
'Restore Excel data area to regular size

    Application.ScreenUpdating = False
    
    Application.DisplayFullScreen = False
    Application.DisplayFormulaBar = True
    
    Call ShowOrHideWorksheetsHeadings(True)
    
    'If you offer zoom-in/zoom-out buttons on the Worksheet (one on top of the other), you may want to toggle their visibility to show only the relevant button
    'ActiveSheet.Shapes("btnFullScreenOut").Visible = True
    'ActiveSheet.Shapes("btnFullScreenIn").Visible = False
    
    bolFullScreen = False
    Application.ScreenUpdating = True
End Sub



Sub ShowOrHideWorksheetsHeadings(ByVal bolShow As Boolean)
'Show or hide Worksheet rows and columns headings (numbers and letters).
'bolShow flags to show (True) or hide (False)

      Dim wrksh As Worksheet
      Dim prev As Worksheet
    
      Set prev = ActiveSheet

        For Each wrksh In ActiveWorkbook.Worksheets
            If (wrksh.Visible = xlSheetVisible) Then
                wrksh.Activate
                ActiveWindow.DisplayHeadings = bolShow
            End If
        Next wrksh
      prev.Activate
      Set prev = Nothing
End Sub



'************************************************************ USER SHEET BUTTONS ********************************************************



Sub CloseApplication()
'Closes the Excel application or just the active Workbook if more are open).

    If (Application.Workbooks.Count > 1) Then
        ActiveWorkbook.Close True
    Else
        ActiveWorkbook.Save
        Application.DisplayAlerts = False
        ActiveWorkbook.Saved = True
        Application.Quit
    End If
End Sub




'*************************************** USING THE FUNCTIONS EXAMPLES *********************************************

Sub testDialogLogin()
    Debug.Print (DialogLogin)
    Debug.Print ("Username: " & txtDialogInput)
End Sub


Sub TestDialogClose()
    Call DialogClose("Be sure to take a break and breath!")
End Sub


Sub TestDialogInput()
    If (DialogInput("What is your age?") = True) Then
        Debug.Print (txtDialogInput)
    End If
End Sub


Sub testDialogYesNo()
    Debug.Print (DialogYesNo("confirm this?"))
End Sub


Sub TestDialogConfirmed()
    Call DialogConfirmed("You are on your way to become an Excel VBA Master!")
End Sub



Sub TestLimitEntryLength()
'This can only be tested from within an active User Form.
'Typically, on the AfterUpdate event handler of a text control named "txtName" on the form, you may call:

    Call LimitEntryLength(Me, "txtName", 50)
    
End Sub


'To test the Active Cell Action Buttons functions, place the cursor on any valid table cell and run:

Sub TestActionButtonsFunctions()
    Debug.Print "Worksheet: ", GetCellSheetName
    Debug.Print "Cell Value: ", GetCellValue
    Debug.Print "Cell Row: ", GetCellRow
    Debug.Print "Cell Column: ", GetCellColumn
    Debug.Print "Column value of fourth row: ", LookupColumnValueOfActiveCell(4)
    Debug.Print "Column value of fourth column: ", LookupRowValueOfActiveCell(4)
End Sub



Sub TestScreenViewFull()
    Call ScreenViewFull
End Sub


Sub TestScreenViewRegular()
    Call ScreenViewRegular
End Sub


Sub TestShowOrHideWorksheetsHeadings()
    Call ShowOrHideWorksheetsHeadings(True)
End Sub



Sub TestCloseApplication()
'Warning: this will close the application!

    Call CloseApplication
End Sub
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Sheet7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
'Tasks to run upon opening this Workbook

    Call ActivateStartupSheet
End Sub

' InQuest injected base64 decoded content
' k"'u
' k"'u
' k"'u
' k"'u
' -Rzk
' bzWl
' zu)u
' ek %z
' bzWl

INQUEST-PP=macro
