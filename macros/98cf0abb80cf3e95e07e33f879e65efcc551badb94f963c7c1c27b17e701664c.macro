Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True



Option Explicit

Attribute VB_Name = "cBEXbuilder"
Option Explicit

Private gBuilder  As Object

Public Sub builderDestroy()
    Call destroyComponent(gBuilder)
End Sub
Public Function BuilderCreate() As Boolean
    BuilderCreate = False
    If gBuilder Is Nothing Then
        Set gBuilder = CreateObject("SAPRBLogic.SAPRBLog")
        If gBuilder Is Nothing Then
            Call userError("installActiveX", , "Query Manager (wdbrLog.ocx)")
            Exit Function
        End If
    End If ' note: provideComponent doesn't work for this case!
    BuilderCreate = True
End Function

Public Function Build(cQueryID As String, _
                        ByVal iMode As Byte, _
                        Optional cDeleteOld As Boolean, _
                        Optional iCubeID As String, _
                        Optional iConfacID As String) As Boolean
    Dim lBuilderOk As Boolean
    Build = False
    If Not dialIn Then Exit Function
    If Not BuilderCreate Then Exit Function
    With gBuilder
        If Not provideGlobalLoggedOn Then Exit Function
        Set .GlobalData = p_bexGlobal
        .EnableAnimation = True
        .SystemID = p_connectionObj.system
        .LogonLanguage = RegistryGet("logon\language")
        .SAPHelpFile = userHelpFile
        .QuerygenuID = cQueryID
        '% .xxx = confacID ' define conditions / exceptions with defaults
        .PreselectedCube = iCubeID
        Set .QueryDef = p_tables
        Set .ParentApplication = Application
        Call ToolBarsHide
        Call trace(True, "running builder")
        lBuilderOk = .Run(iMode)
        Call ToolBarsUnhide
        If lBuilderOk Then
            cDeleteOld = .wasInEditorMode
            cQueryID = .QuerygenuID
            Build = True
        End If
        If .hasReconnected Then
            Call dialOutClearAllHandles
            cDeleteOld = False ' handle has already been cleared, closing it is not necessary
            Call rfcInitSession
        End If
        Set .QueryDef = Nothing
        Set .ParentApplication = Nothing
    End With
End Function
Attribute VB_Name = "cBEXcommon"
Option Explicit
Option Private Module

Private Declare Function ShowSplashScreen Lib "wdba.dll" _
    (ByVal pAprentWnd As Long, ByVal bSplash As Long) As Long
Private Declare Function SetSplashScreenLabel Lib "wdba.dll" _
    (ByVal strLabel As String) As Long
Private Declare Function SetSplashScreenVersion Lib "wdba.dll" _
    (ByVal strLabel As String) As Long
Private Declare Function HideSplashScreen Lib "wdba.dll" () As Long

Private Declare Function OpenProgress Lib "wdba.dll" _
    (ByVal pWnd As Long, ByVal strTitle As String, ByVal strCancel As String) As Integer
Private Declare Function CloseProgress Lib "wdba.dll" () As Integer
Private Declare Function StartProgress Lib "wdba.dll" _
    (ByVal strText As String, ByVal nStart As Integer, ByVal nEnd As Integer, ByVal nStep As Integer, ByVal bShowCancel As Integer) As Integer
Private Declare Function StartProgressRfc Lib "wdba.dll" _
    (ByVal rfcHandle As Long, ByVal strText As String, ByVal nStart As Integer, ByVal nEnd As Integer, ByVal nStep As Integer, ByVal bShowCancel As Integer) As Integer
Private Declare Function StepProgress Lib "wdba.dll" (ByVal strText As String, ByVal nStep As Integer) As Integer
Private Declare Function CheckProgress Lib "wdba.dll" () As Integer

Private Declare Function CheckFrontend Lib "wdba.dll" (ByVal pConnection As Object, ByVal strSAPBexVersion As String, ByVal strSAPBex0Version As String) As Integer

Private gTaskText As String * 255
Private gIgnoreRemote As Boolean
Private gNoProgress As Byte

Private Const g_cTempTag As String = "xSAPtemp"
Private Const g_cTempTraceFile As String = "SAPBEX.trc"
Private Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathA" _
    (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Public Declare Sub CoFreeUnusedLibraries Lib "ole32.dll" ()

'----- find own window handle

Public Declare Function GetActiveWindow Lib "USER32" () As Long
Private Declare Function FindWindow Lib "USER32" Alias "FindWindowA" _
    (ByVal lpClassName As Any, ByVal lpWindowName As Any) As Long

'----- routines for registry management

Type SECURITY_ATTRIBUTES
    nLength As Long
    lpSecurityDescriptor As Long
    bInheritHandle As Long
End Type
Private Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
    ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, _
    ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, _
    lpSecurityAttributes As SECURITY_ATTRIBUTES, phkResult As Long, lpdwDisposition As Long) As Long
Private Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
    ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, _
    ByVal samDesired As Long, phkResult As Long) As Long
Private Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" ( _
    ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, _
    ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long
    ' Note that if you declare the lpData parameter as String, you must pass it ByVal
Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
    ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, _
    lpType As Long, lpData As Any, lpcbData As Long) As Long
    ' Note that if you declare the lpData parameter as String, you must pass it ByVal
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Public Sub RegistrySet(iSubKeyName As String, _
                        iSubKeyValue As String, _
                        Optional iClassesRoot As Boolean)
    Const KEY_SET_VALUE = &H2
    Dim lHive As Long
    Dim lKeyName As String * 60
    Dim lnullSecurity As SECURITY_ATTRIBUTES
    Dim lRegKey As Long
    Dim lIsNew As Long
    Dim lItemLength As Long
    Dim lItemValue As String * 255
    lHive = IIf(iClassesRoot, &H80000000, &H80000001) ' HKEY_CLASSES_ROOT or HKEY_CURRENT_USER ?
    lKeyName = IIf(iClassesRoot, "SAP.BusinessExplorer.Analyzer\", "Software\SAP\BEx\") & iSubKeyName & vbNullChar
    If RegCreateKeyEx(lHive, lKeyName, 0, vbNullString, 0, KEY_SET_VALUE, lnullSecurity, lRegKey, lIsNew) = 0 Then
      lItemValue = iSubKeyValue & vbNullChar
      lItemLength = Len(iSubKeyValue)
        Call RegSetValueEx(lRegKey, vbNullString, 0, 1, ByVal lItemValue, lItemLength)
        Call RegCloseKey(lRegKey)
    Else
        Call trace(True, "registrySet failed")
        Call trace(False, "entry: " & iSubKeyName & "=" & iSubKeyValue)
        Call trace(False, "root: " & iClassesRoot)
    End If
End Sub

Public Function RegistryGet(iSubKeyName As String, _
                            Optional iValueName As String, _
                            Optional iHiveLocalMachine As Boolean) As String
    Const KEY_QUERY_VALUE = &H1
    Dim lHive As Long
    Dim lKeyName As String * 60
    Dim lValName As String * 60
    Dim lRegKey As Long
    Dim lItemType As Long
    Dim lItemLength As Long
    Dim lItemBuffer As String * 255
    
    lKeyName = IIf(iHiveLocalMachine, "Software\", "Software\SAP\BEx\") & iSubKeyName & vbNullChar
    lHive = IIf(iHiveLocalMachine, &H80000002, &H80000001)   ' HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER ?
    lValName = iValueName & vbNullChar
    If RegOpenKeyEx(lHive, lKeyName, 0, KEY_QUERY_VALUE, lRegKey) = 0 Then
        lItemType = 1
        lItemLength = 255
        Call RegQueryValueEx(lRegKey, lValName, 0, lItemType, ByVal lItemBuffer, lItemLength)
        If lItemLength > 0 Then RegistryGet = Left(lItemBuffer, lItemLength - 1)
        Call RegCloseKey(lRegKey)
    Else
        Call trace(True, "registryGet failed")
        Call trace(False, "entry: " & iSubKeyName & "=?")
    End If

End Function

'----- routines for handling of temporary files
Private Function TempPath() As String
    Dim lTempPathBuffer As String * 255
    Call GetTempPath(255, lTempPathBuffer)
    TempPath = nullTrim(lTempPathBuffer)
End Function

Public Function TempTraceFile(Optional iFullPath As Boolean) As String
    TempTraceFile = IIf(iFullPath, TempPath & g_cTempTraceFile, g_cTempTraceFile)
End Function

Public Function TempNewFileName(iExtension As String) As String
    Call Randomize
    TempNewFileName = TempPath & g_cTempTag & Int(10000 * Rnd()) & "." & iExtension
End Function

'----- Auto open & close
Sub Auto_open()
    
    Call trace(False, "auto_open  start")
    
      On Error Resume Next                                  'VBR:11-053 Begin
    If Not Workbooks("BExAnalyzer.xla") Is Nothing Then
        If Err = 0 Then
          CommandBars("xxxSAPBEXxxx").Visible = False
          Exit Sub
        End If
    End If                                                  'VBR:11-053 End
    
    Application.Visible = True
    Call ShowSplashScreen(0, 1)
    Call maintainToolbar
    Call HideSplashScreen
    Call tryToKill(TempPath & g_cTempTraceFile)
    Call trace(False, "auto_open  end 0")
    Call isConnected
    Call trace(False, "auto_open  end 1")
End Sub
Sub Auto_close()
    Call trace(False, "auto_close  start")
    Call dialOut(silent:=True, destroyAll:=True)
    On Error Resume Next
    Call CommandBars(1).Controls(cProductName).Delete
    With CommandBars(cProductName)
        Call RegistrySet("toolBar\pos", .Position)
        Call RegistrySet("toolBar\rowindex", .rowIndex)
        Call RegistrySet("toolBar\top", .Top)
        Call RegistrySet("toolBar\left", .Left)
        Call .Delete
    End With
    Call tryToKill(TempPath & g_cTempTag & "*.*")
    Call trace(False, "auto_close  end 0")
    Call isConnected
    Call trace(False, "auto_close  end 1")
End Sub

Public Sub AboutBox()
    Call SetSplashScreenVersion(ThisWorkbook.CustomDocumentProperties!Version)
    Call ShowSplashScreen(GetActiveWindow, 0)
End Sub

'----- cancel & progress dialog
 Private Function GetMyWindow() As Long
    ' alternative to GetActiveWindow for cases where Excel may NOT be the active window
    Application.caption = "   Microsoft Excel"
    GetMyWindow = FindWindow(0&, Application.caption)
    Application.caption = Empty
End Function

Private Function NoProgress() As Boolean
    If gNoProgress = 0 Then gNoProgress = IIf(RegistryGet("", "ProgressBar") = "OFF", 1, 2)
    NoProgress = (gNoProgress = 1)
End Function

Public Sub ShowProgress(Optional iAvoidTopmost As Boolean)
    If NoProgress Then Exit Sub
    Dim lStrTitle As String * 30:
    Dim lStrCancel As String * 20:
    lStrTitle = fixLen(cProductNameA, 30)
    lStrCancel = fixLen(userText("buttonCancel"), 20)
    '' OpenProgress FAILS if Excel is the topmost window! --> not anymore!
    'If avoidTopmost Then SAPGUI2front
    Application.Interactive = False
    Call OpenProgress(GetMyWindow, lStrTitle, lStrCancel)
    'Application.Visible = True
End Sub

Public Sub HideProgress()
    If NoProgress Then Exit Sub
    ' must be interactive again before CloseProgress!
    Application.Interactive = True
    Call CloseProgress
End Sub

Public Sub InitProgress(iTaskText As String, _
                        iTicks As Integer, _
                        Optional iShowCancel As Boolean = True)
    If NoProgress Then Exit Sub
    gTaskText = fixLen(iTaskText, 255)
    StartProgress gTaskText, 0, iTicks, 500, IIf(iShowCancel, 1, 0)
End Sub

Public Sub InitProgressRFC(iRfcHandle As Long, _
                            iTaskText As String, _
                            iTicks As Integer, _
                            Optional iShowCancel As Boolean = True)
    If NoProgress Then Exit Sub
    gTaskText = fixLen(iTaskText, 255)
    Call StartProgressRfc(iRfcHandle, gTaskText, 0, iTicks, 500, IIf(iShowCancel, 1, 0))
End Sub

Public Sub MakeProgress()
    If NoProgress Then Exit Sub
    Call StepProgress(gTaskText, 1)
End Sub

Public Function IsCancelled() As Boolean
    If NoProgress Then
        IsCancelled = False
    Else
        DoEvents
        IsCancelled = (CheckProgress = 0)
    End If
End Function

Public Sub IgnoreRemoteBegin()
End Sub

Public Sub IgnoreRemoteEnd()
End Sub

Public Sub checkFrontendVersion()
    Dim lStrSAPBexVersion As String
    Dim lStrSAPBex0Version As String
    lStrSAPBexVersion = ThisWorkbook.CustomDocumentProperties!Version
    On Error Resume Next
    lStrSAPBex0Version = Workbooks("SAPBEX0.XLA").CustomDocumentProperties!Version
    Call CheckFrontend(p_connectionObj, lStrSAPBexVersion, lStrSAPBex0Version)
End Sub

' --- hide floating commandbars, so that they don't get to lie on top of VB dialogs

Public Sub ToolBarsHide()
     Dim lMyBar As CommandBar
     Dim lCounter As Integer
     For lCounter = 2 To Application.CommandBars.Count ' main command bar (i=1) can't be made invisible
         With Application.CommandBars(lCounter)
         If .Position = msoBarFloating Then
             If .Visible Then
                 .Visible = False
             Else
                 .Position = msoBarRight ' make sure they're not erroneously made visible later on ...
             End If
         End If
         End With
     Next lCounter
End Sub

Public Sub ToolBarsUnhide()
    Dim lMyBar As CommandBar
    For Each lMyBar In Application.CommandBars
        If lMyBar.Position = msoBarFloating Then lMyBar.Visible = True
    Next lMyBar
End Sub
Public Function isPdfMakerLoaded() As Boolean
'PDF Maker causes Dr.Watson's, so we don't free the dll's
On Error GoTo isnotloaded
  If Workbooks("PDFmaker.xla") Is Nothing Then
    isPdfMakerLoaded = False
    Else
    isPdfMakerLoaded = True
  End If
  Exit Function
isnotloaded:   isPdfMakerLoaded = False
End Function
Attribute VB_Name = "cBEXconfac"
Option Explicit
Option Private Module

Public Function ConFacSheetGet(Optional iCreateNew As Boolean, Optional iRepoSheet As Worksheet) As Worksheet

    If iRepoSheet Is Nothing Then Set iRepoSheet = p_currentRepoSheet
    Dim lWb As Workbook
    Dim lWs As Worksheet
    Dim lCounter As Long
    
    Set lWb = iRepoSheet.Parent
    
    On Error Resume Next
        Set lWs = lWb.Worksheets(cRepoSheetNameFilters)
    On Error GoTo 0
    
    If lWs Is Nothing And iCreateNew Then
        
        Set lWs = lWb.Worksheets.Add
        With lWs
            .Name = cRepoSheetNameFilters
            .Visible = xlSheetVeryHidden
        End With
            
        With p_currentRepoSheet
            Call trace(True, "converting CON / FAC table ...")
            
            For lCounter = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
                If Len(.Cells(lCounter, cRepoCDValInt)) Then Call Chavl2ConFacAdd(lWs, lCounter, True)
            Next lCounter
        End With
    
    End If
    Set ConFacSheetGet = lWs
    
End Function

Public Function ConFacEltuidGet() As String
    ConFacEltuidGet = ConFacGet(ConFacSheetGet, p_currentQueryIndex, p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName))
End Function

Private Function ConFacGet(iConFacSheet As Worksheet, iMyQueryIndex As Long, iCharName As String) As String
Dim lCounter As Long
    With iConFacSheet
        
        For lCounter = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCN) - 1
            If .Cells(lCounter, cRepoCN) = iMyQueryIndex And _
               .Cells(lCounter, cRepoCNCharName) = iCharName And _
               .Cells(lCounter, cRepoCNConType) = cConTypeSelection Then
                ConFacGet = .Cells(lCounter, cRepoCNEltuid)
                Exit Function
            End If
        Next lCounter
    End With

End Function

Private Function ConFacAdd(iConFacSheet As Worksheet, iMyQueryIndex As Long, iCharName As String) As String
    Dim lNewEltuid As String
    Dim lCounter As Long
    
    lNewEltuid = "!" & iCharName
    With iConFacSheet
        lCounter = cRepoRTop + .Cells(cRepoRCounts, cRepoCN)
        .Cells(lCounter, cRepoCN) = iMyQueryIndex
        .Cells(lCounter, cRepoCNEltuid) = lNewEltuid
        .Cells(lCounter, cRepoCNCharName) = iCharName
        .Cells(lCounter, cRepoCNActive) = "X"
        .Cells(lCounter, cRepoCNConType) = cConTypeSelection
        .Cells(cRepoRCounts, cRepoCN) = .Cells(cRepoRCounts, cRepoCN) + 1
    End With
    ConFacAdd = lNewEltuid
End Function

Private Sub ConFacDelete(iConFacSheet As Worksheet, _
                         iMyQueryIndex As Long, _
                            iCharName As String)
    Dim lCounter As Long
    Dim lCounter2 As Long
    With iConFacSheet
        For lCounter = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCN) - 1
            If .Cells(lCounter, cRepoCN) = iMyQueryIndex And _
               .Cells(lCounter, cRepoCNCharName) = iCharName And _
               .Cells(lCounter, cRepoCNConType) = cConTypeSelection Then
                For lCounter2 = cRepoRTop + .Cells(cRepoRCounts, cRepoCF) - 1 To cRepoRTop Step -1
                    If .Cells(lCounter2, cRepoCF) = .Cells(lCounter, cRepoCN) And _
                       .Cells(lCounter2, cRepoCFEltuid) = .Cells(lCounter, cRepoCNEltuid) Then
                        .Range(.Cells(lCounter2, cRepoCF), .Cells(lCounter2, cRepoCF + .Cells(cRepoRWidths, cRepoCF))).Delete Shift:=xlUp
                        .Cells(cRepoRCounts, cRepoCF) = .Cells(cRepoRCounts, cRepoCF) - 1
                    End If
                Next lCounter2
                .Range(.Cells(lCounter, cRepoCN), .Cells(lCounter, cRepoCN + .Cells(cRepoRWidths, cRepoCN))).Delete Shift:=xlUp
                .Cells(cRepoRCounts, cRepoCN) = .Cells(cRepoRCounts, cRepoCN) - 1
            End If
        Next lCounter
    End With
End Sub

'----- conversion of Rel.1.2 selections (field CHAVL in table DIM) to Rel.2.0 selections (tables CON and FAC)

Public Sub Chavl2ConFacAdd(iConFacSheet As Worksheet, iMyFilterIndex As Long, Optional iNewConFac As Boolean)
    Dim lCharName As String
    Dim lMyQueryIndex As Long
    Dim lNewEltuid As String
    Dim lCounter2 As Long
    With p_currentRepoSheet
           lCharName = .Cells(iMyFilterIndex, cRepoCDCharName)
           lMyQueryIndex = .Cells(iMyFilterIndex, cRepoCD)
        If Not iNewConFac Then Call ConFacDelete(iConFacSheet, lMyQueryIndex, lCharName)
        If Len(.Cells(iMyFilterIndex, cRepoCDValInt)) = 0 Then Exit Sub
    End With
    lNewEltuid = ConFacAdd(iConFacSheet, lMyQueryIndex, lCharName)
    With iConFacSheet
        lCounter2 = cRepoRTop + .Cells(cRepoRCounts, cRepoCF)
        .Cells(lCounter2, cRepoCF) = lMyQueryIndex
        .Cells(lCounter2, cRepoCFEltuid) = lNewEltuid
        .Cells(lCounter2, cRepoCFTermNumber) = 1
        .Cells(lCounter2, cRepoCFFactorNumber) = 1
        .Cells(lCounter2, cRepoCFSelOptNumber) = 1
        .Cells(lCounter2, cRepoCFSign) = "I"
        .Cells(lCounter2, cRepoCFOpt) = "EQ"
        .Cells(lCounter2, cRepoCFLowValue) = p_currentRepoSheet.Cells(iMyFilterIndex, cRepoCDValInt)
        .Cells(lCounter2, cRepoCFLowExt) = p_currentRepoSheet.Cells(iMyFilterIndex, cRepoCDValExt)
        .Cells(lCounter2, cRepoCFLowTxt) = p_currentRepoSheet.Cells(iMyFilterIndex, cRepoCDValTxt)
        .Cells(lCounter2, cRepoCFLowFlag) = 1
        .Cells(lCounter2, cRepoCFHierName) = p_currentRepoSheet.Cells(iMyFilterIndex, cRepoCDHryName)
        .Cells(lCounter2, cRepoCFHierFlag) = IIf(Len(p_currentRepoSheet.Cells(iMyFilterIndex, cRepoCDHryName)), 1, 0)
        .Cells(lCounter2, cRepoCFHierIObj) = p_currentRepoSheet.Cells(iMyFilterIndex, cRepoCDValHry)
        .Cells(cRepoRCounts, cRepoCF) = .Cells(cRepoRCounts, cRepoCF) + 1
    End With
End Sub

Public Sub ConFac2ConFacCopy(iFromQuery As Long, iCharName As String)

    Dim lConFacSheet As Worksheet
    Dim lFromEltuid As String
    Dim lToEltuid As String
    Dim lFacTableWidth As Byte
    Dim lCounter As Long
    Dim lCounter2 As Long
    
    Set lConFacSheet = ConFacSheetGet
    If lConFacSheet Is Nothing Then Exit Sub
    Call ConFacDelete(lConFacSheet, p_currentQueryIndex, iCharName)
    lFromEltuid = ConFacGet(lConFacSheet, iFromQuery, iCharName)
    lToEltuid = ConFacAdd(lConFacSheet, p_currentQueryIndex, iCharName)
    With lConFacSheet
        lFacTableWidth = .Cells(cRepoRWidths, cRepoCF)
        For lCounter = cRepoRTop + .Cells(cRepoRCounts, cRepoCF) - 1 To cRepoRTop Step -1
            If .Cells(lCounter, cRepoCF) = iFromQuery And _
               .Cells(lCounter, cRepoCFEltuid) = lFromEltuid Then
                lCounter2 = cRepoRTop + .Cells(cRepoRCounts, cRepoCF)
                .Cells(lCounter2, cRepoCF) = p_currentQueryIndex
                Call .Range(.Cells(lCounter, cRepoCF + 1), .Cells(lCounter, cRepoCF + lFacTableWidth)).Copy
                Call .Range(.Cells(lCounter2, cRepoCF + 1), .Cells(lCounter2, cRepoCF + lFacTableWidth)).PasteSpecial
                .Cells(lCounter2, cRepoCFEltuid) = lToEltuid
                .Cells(cRepoRCounts, cRepoCF) = .Cells(cRepoRCounts, cRepoCF) + 1
            End If
        Next lCounter
    End With
End Sub

Function ConFacTranslateSelection(iMaxLen As Long) As String
  Dim lIobjnm As String * 30
  lIobjnm = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName)
' Concatenate the Selection text out of CON/FAC
' Get CHAPR Out of DIM
    
    If p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDIsStructure) = "X" Then
        ConFacTranslateSelection = ConFacTranSelMem(iMaxLen, lIobjnm)
    Else
        ConFacTranslateSelection = ConFacTransSelCha(iMaxLen, lIobjnm)
    End If

End Function

Function ConFacTranSelMem(iMaxLen As Long, _
                          iIobjnm As String) As String
  Dim lLen              As Integer
  Dim lContinue       As String
  Dim lHidden As Boolean
  Dim lCounter As Integer
  Dim lDel As String:
  Dim lFactorText As String
  Dim lEltuid As String * 25
  
  lEltuid = iIobjnm
  lContinue = "..."
  lDel = Application.International(xlListSeparator) & " "
  With p_currentRepoSheet
' Is there a Member to display
  For lCounter = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCM) - 1
    If .Cells(lCounter, cRepoCM) = p_currentQueryIndex And _
       .Cells(lCounter, cRepoCMDimName) = lEltuid And _
       .Cells(lCounter, cRepoCMHidden) = "Y" Then lHidden = True
  Next lCounter
  If lHidden = False Then
    ConFacTranSelMem = ""
    Exit Function
  End If
' Get the Text out of the mem
    For lCounter = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCM) - 1
        If .Cells(lCounter, cRepoCM) = p_currentQueryIndex And _
           .Cells(lCounter, cRepoCMDimName) = lEltuid And _
           Len(.Cells(lCounter, cRepoCMHidden)) = 0 Then
            lFactorText = .Cells(lCounter, cRepoCMMemText)
            lFactorText = ConFacReplaceCaret(lFactorText)
            If lFactorText <> "" Then
                lLen = Len(lFactorText) + Len(ConFacTranSelMem) + 2
                If iMaxLen > 0 And lLen > iMaxLen Then
                    ConFacTranSelMem = ConFacTranSelMem + lContinue
                    Exit Function
                Else
                    If ConFacTranSelMem = "" Then
                        ConFacTranSelMem = lFactorText
                   Else
                   ConFacTranSelMem = ConFacTranSelMem + lDel + lFactorText
                    End If
                End If
            End If
        End If
    Next lCounter
  End With
End Function
    
Function ConFacTransSelCha(iMaxLen As Long, _
                           iIobjnm As String) As String
' Get the selection Text out con fac
    Dim lIobjPrsnt        As String * 1
    Const cChaprIni      As String = " "
    Const cChaprKeyText As String = "0"
    Const cChaprKey      As String = "2"
    Const cChaprTextKey As String = "3"
    Const cContinue     As String = "..."
    Dim lFactorText      As String
    Dim lText             As String
    Dim lLen              As Long
    Dim lCounter                  As Integer
    Dim lCounter2                  As Integer
    Dim lIobjnm           As String
    Dim lDel              As String
    lIobjnm = Trim(iIobjnm)
    lDel = Application.International(xlListSeparator) & " "
    With ConFacSheetGet
'   Get iobjprsnt
    lIobjPrsnt = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDIobjPrsnt)
'   Concatenate the text
    For lCounter = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCN) - 1
      If .Cells(lCounter, cRepoCN) = p_currentQueryIndex And _
         .Cells(lCounter, cRepoCNCharName) = lIobjnm And _
         .Cells(lCounter, cRepoCNConType) = cConTypeSelection And _
         Not .Cells(lCounter, cRepoCNActive) = "" Then
      For lCounter2 = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCF) - 1
        If .Cells(lCounter2, cRepoCF) = p_currentQueryIndex And _
           .Cells(lCounter2, cRepoCFEltuid) = .Cells(lCounter, cRepoCNEltuid) Then
          Select Case lIobjPrsnt
            Case cChaprKey, cChaprIni:  lText = .Cells(lCounter2, cRepoCFLowExt)
            Case cChaprKeyText:         lText = .Cells(lCounter2, cRepoCFLowExt) + " " + .Cells(lCounter2, cRepoCFLowTxt)
            Case cChaprTextKey:         lText = .Cells(lCounter2, cRepoCFLowTxt) + " " + .Cells(lCounter2, cRepoCFLowExt)
            Case Else:                  lText = IIf(Len(.Cells(lCounter2, cRepoCFLowTxt)), .Cells(lCounter2, cRepoCFLowTxt), .Cells(lCounter2, cRepoCFLowExt))
          End Select
          Select Case .Cells(lCounter2, cRepoCFOpt)
            Case "EQ":    lFactorText = lText
            Case "LT":    lFactorText = "< " + lText
            Case "LE":    lFactorText = "<= " + lText
            Case "GT":    lFactorText = "> " + lText
            Case "GE":    lFactorText = ">= " + lText
            Case "BT":    lFactorText = lText
              Select Case lIobjPrsnt
                Case cChaprKey, cChaprIni:    lText = .Cells(lCounter2, cRepoCFHighext)
                Case cChaprKeyText:           lText = .Cells(lCounter2, cRepoCFHighext) + " " + .Cells(lCounter2, cRepoCFHightxt)
                Case cChaprTextKey:           lText = .Cells(lCounter2, cRepoCFHightxt) + " " + .Cells(lCounter2, cRepoCFHighext)
                Case Else:                    lText = IIf(Len(.Cells(lCounter2, cRepoCFHightxt)), .Cells(lCounter2, cRepoCFHightxt), .Cells(lCounter2, cRepoCFHighext))
              End Select
              lFactorText = lFactorText + ".." + lText
            Case Else:  lFactorText = cContinue
          End Select
'         Excluding
          If .Cells(lCounter2, cRepoCFSign) = "E" Then lFactorText = "]" + lFactorText + "["
'         Append this entry to the text
          If Len(lFactorText) Then
            lLen = Len(lFactorText) + Len(ConFacTransSelCha) + 2
            If iMaxLen > 0 And lLen > iMaxLen Then
              ConFacTransSelCha = ConFacTransSelCha + cContinue
              Exit Function
            Else
              If Len(ConFacTransSelCha) Then
                ConFacTransSelCha = ConFacTransSelCha + lDel + lFactorText
              Else
                ConFacTransSelCha = lFactorText
              End If
            End If
          End If
        End If
      Next lCounter2
    End If
  Next lCounter
  End With
End Function
Function ConFacReplaceCaret(Str As String) As String
    ConFacReplaceCaret = WorksheetFunction.Substitute(Str, Chr(13), "")
End Function
Attribute VB_Name = "cBEXcontext"
Option Explicit
Option Private Module

Private g_selector As Object ' BWSelectionWizard

Private Const cAxisDown As String = "Y"
Private Const cAxisAcross As String = "X"
Private Const cAxisNone As String = " "
Private Const cAxisFilter As String = "F"

Private Const cHiddenShow As String = " "
Private Const cHiddenDontShow As String = "Y"
Private Const cHiddenInvisible As String = "X"

Public Function contextAction(sh As Worksheet, target As Range, showMenu As Boolean) As Boolean

    contextAction = False
    If contextCheck(sh, target) Then
        contextAction = True
        If showMenu Then menuShow "Context" Else contextDoubleClick
    End If

End Function

Public Sub contextDoubleClick()
    
    With p_currentRepoSheet
        If .Cells(p_currentQueryIndex, cRepoCQInteractive) Then
            If isConnected(True) Then
                If p_currentFilterIndex Then            ' double-click on filter cell
                    If drillState Then
                        contextHandlerUndrill
                    Else
                        If drillWithinLimits Then contextHandlerDrillDown True
                    End If
                Else
                    If p_currentSelection Is Nothing Then
                        If p_currentConFacIndex Then    ' double-click on condition / exception
                            Set p_currentSelection = Nothing
                            If contextSetSelection Then contextConfac
                        End If
                    Else                                ' double-click on result area
                        If .Cells(p_currentQueryIndex, cRepoCQGotoRepeat) And _
                           Len(.Cells(p_currentQueryIndex, cRepoCQGoto)) Then
                            contextJump .Cells(p_currentQueryIndex, cRepoCQGoto)
                        Else
                            If contextSetSelection Then contextSAP "SELC"
                        End If
                    End If
                End If
            Else
                menuShow "Refresh"
            End If
        End If
    End With

End Sub

Public Function contextCheck(sh As Worksheet, target As Range) As Boolean

    contextCheck = False
    If Not isProtected(sh, False) Then
        If repoDetectQuery(target) Then
            contextCheck = True
            target.Select ' note that target may have been clipped by repoDetectQuery
        End If
    End If

End Function

'----- context menu & drill-down handling for condition / exception cells

Sub menuFillConfac(myControls As CommandBarControls, Optional silent As Boolean)

    If isConnected(True, True) Then
        With p_currentConFacSheet
            Dim eltuid As String:   eltuid = .Cells(p_currentConFacIndex, cRepoCNEltuid)
            Dim cfType As String:   cfType = IIf(.Cells(p_currentConFacIndex, cRepoCNConType) = cConTypeException, "Exception", "Condition")
            Select Case .Cells(p_currentConFacIndex, cRepoCNActive)
            Case ""     ' inactive
                userMenu myControls, cfType & "On", "context" & cfType & "On", False, False, eltuid
            Case "C"    ' condition suppressed by another condition
                userMenu myControls, cfType & "On", "context" & cfType & "On", False, False, eltuid
                userMenu myControls, cfType & "Off", "context" & cfType & "Off", False, False, eltuid
            Case "X", "L", "V"
                userMenu myControls, cfType & "Off", "context" & cfType & "Off", False, False, eltuid
            End Select
            If Len(.Cells(p_currentConFacIndex, cRepoCNStatic)) = 0 Then
                userMenu myControls, cfType & "Change", "context" & cfType & "Change", True, False, eltuid
            End If
        End With
    End If
    menuFillDefaults myControls, silent

End Sub

Sub contextConfac()

    If isConnected(True, True) Then
        With p_currentConFacSheet
            Dim activeFlag As String:    activeFlag = .Cells(p_currentConFacIndex, cRepoCNActive)
            contextSAPconfac _
                (.Cells(p_currentConFacIndex, cRepoCNConType) = cConTypeException), _
                (activeFlag = "" Or activeFlag = "C"), _
                .Cells(p_currentConFacIndex, cRepoCNEltuid)
        End With
    End If

End Sub

Public Sub contextExceptionChange()
    queryDefineWithDefaults "ENEW", menuParam
End Sub

Public Sub contextConditionChange()
    queryDefineWithDefaults "CNEW", menuParam
End Sub

Public Sub contextExceptionOn()
    contextSAPconfac True, True
End Sub

Public Sub contextConditionOn()
    contextSAPconfac False, True
End Sub

Public Sub contextExceptionOff()
    contextSAPconfac True, False
End Sub

Public Sub contextConditionOff()
    contextSAPconfac False, False
End Sub

Private Sub contextSAPconfac(exception As Boolean, activate As Boolean, Optional eltuid As String)
    
    If Len(eltuid) = 0 Then eltuid = menuParam
    
    Set p_currentSelection = Nothing
    If contextSetSelection Then
        If tableReset("I_T_CMD_PARAMS") Then
            Dim paramsRow As Object:    Set paramsRow = p_tables("I_T_CMD_PARAMS").Rows.Add
            ' field access by position, because second field was renamed with 2.0b backend patch 5
            paramsRow(1) = "ACTIVE"
            paramsRow(2) = IIf(activate, "X", "")
            contextSAP IIf(exception, "EA", "CA"), eltuid, True
        End If
    End If

End Sub

'----- context menu & drill-down handling for filter cells

Sub menuFillFilter(myControls As CommandBarControls, Optional silent As Boolean)

    With p_currentRepoSheet
    
        If isConnected And .Cells(p_currentQueryIndex, cRepoCQInteractive) Then
        
            Dim isStructure As Boolean: isStructure = Len(.Cells(p_currentFilterIndex, cRepoCDIsStructure))
            Dim isRefreshed As Boolean: isRefreshed = isConnected(True)
            ' p_versionServer <  cV20 needs query to be refreshed for filter selection
            ' p_versionServer >= cV20 needs query to be refreshed for drill up/down and filter deletion

            If p_versionServer < cV20 Then
                If isRefreshed And Not isStructure Then
                    userMenu myControls, "Select", "contextHandlerSelectSAPGUI"
                    userMenu myControls, "SelectRestricted", "contextHandlerSelectSAPGUIrestricted"
                End If
            Else
                If isConnected(False, False, True) Then
                    userMenu myControls, "Select", "launchSelector"
                End If
            End If
            
            If isRefreshed Or .Cells(p_currentQueryIndex, cRepoCQDefVersion) < cV20 Then

                Dim undrillAllowed As Boolean
                undrillAllowed = Len(.Cells(p_currentFilterIndex, cRepoCDIsSumable)) '.. or "there is a filter value" (see below)
                
                Dim indicatorColumn As Byte
                indicatorColumn = IIf(.Cells(p_currentQueryIndex, cRepoCQDefVersion) >= cV20, cRepoCDFiltered, cRepoCDValInt)
                If Len(.Cells(p_currentFilterIndex, indicatorColumn)) Then ' there is a filter value
                    If undrillAllowed Or drillState <> 0 Then
                        userMenu myControls, "FilterValueRemove", "contextHandlerRemoveFilter", True
                    End If
                    If .Cells(p_currentQueryIndex, cRepoCQDefVersion) >= cV20 Then
                        Dim filterRange As Range
                        Set filterRange = RunGetFilterRange(p_currentFilterIndex)
                        If Not filterRange Is Nothing Then
                            If InStr(filterRange.Cells(1, 2).Value, "...") Then
                                userMenu myControls, "FilterValueUnclip", "contextHandlerShowFullValue"
                            End If
                        End If
                    End If
                    If isStructure And .Cells(p_currentFilterIndex, cRepoCDFiltered) = "X" Then
                    undrillAllowed = False
                    Else
                    undrillAllowed = True
                    End If
                End If

                If Not .Cells(p_currentQueryIndex, cRepoCQFlat) Then
                    If drillState <> 0 Or drillWithinLimits Then ' don't offer additional drills when limit is reached!
                        With userSubMenu(myControls, "Drill", True)
                            Select Case Sgn(drillState)
                                Case -1 ' drilled horizontal
                                    If undrillAllowed Then userMenu myControls, "Undrill", "contextHandlerUndrill"
                                    userMenu .Controls, "Down", "contextHandlerDrillDown"
                                Case 0  ' not drilled
                                    userMenu .Controls, "Down", "contextHandlerDrillDown"
                                    userMenu .Controls, "Across", "contextHandlerDrillAcross"
                                Case 1  ' drilled vertical
                                    If undrillAllowed Then userMenu myControls, "Undrill", "contextHandlerUndrill"
                                    userMenu .Controls, "Across", "contextHandlerDrillAcross"
                            End Select
                        End With
                    Else
                        If undrillAllowed Then userMenu myControls, "Undrill", "contextHandlerUndrill"
                    End If
                End If
            
            End If
    
        End If
        menuFillDefaults myControls, silent
    
    End With

End Sub

Private Function oldStyleDrill(Optional unfilter As Boolean) As Boolean
    
    With p_currentRepoSheet
        If .Cells(p_currentQueryIndex, cRepoCQDefVersion) >= cV20 Then
            unfilter = False
            ' drilling by f-codes can not obey "pausing", and is therefore disabled for paused API-calls (wherever possible)
            oldStyleDrill = p_extErrorFlag And checkPause And (.Cells(p_currentFilterIndex, cRepoCDIsStructure) = "")
        Else
            oldStyleDrill = True
        End If
    End With

End Function

Public Sub contextHandlerUndrill()
    
    If oldStyleDrill Then
        undrill
        RunQueryConditioned
    Else
        contextSAPfilter "DRID"
    End If

End Sub

Public Sub contextHandlerDrillDown(Optional unfilter As Boolean)
    
    If oldStyleDrill(unfilter) Then
        contextDrillAndRun cAxisDown, unfilter
    Else
        contextSAPfilter "DRIY"
    End If

End Sub

Public Sub contextHandlerDrillAcross(Optional unfilter As Boolean)
    
    If oldStyleDrill(unfilter) Then
        contextDrillAndRun cAxisAcross, unfilter
    Else
        contextSAPfilter "DRIX"
    End If

End Sub
    
Private Sub contextDrillAndRun(axis As String, unfilter As Boolean)
    
    drill axis
    If unfilter Or p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) < cV20 Then
        setFilterValue "", "", "", ""
    End If
    RunQueryConditioned
    
End Sub

Private Sub drill(axis As String)

    undrill

    Dim maxDown As Integer
    Dim maxAcross As Integer
    Const cAcrossLast As Integer = -1
        
    With p_currentRepoSheet
    
        Dim i As Integer
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
            If .Cells(i, cRepoCD) = p_currentQueryIndex And i <> p_currentFilterIndex Then
                If .Cells(i, cRepoCDAxis) = cAxisAcross And .Cells(i, cRepoCDPosition) > maxAcross Then maxAcross = .Cells(i, cRepoCDPosition)
                If .Cells(i, cRepoCDAxis) = cAxisDown And axis = cAxisDown And _
                   (.Cells(i, cRepoCDHryActive) <> "" Or .Cells(p_currentFilterIndex, cRepoCDHryActive) <> "") Then
                    ' in case of hierarchy conflicts, other dimensions along the same axis are moved away from the axis
                    If .Cells(i, cRepoCDIsStructure) <> "" Then
                        .Cells(i, cRepoCDAxis) = cAxisAcross
                        .Cells(i, cRepoCDPosition) = cAcrossLast
                    Else
                        .Cells(i, cRepoCDAxis) = cAxisNone
                        .Cells(i, cRepoCDPosition) = 0
                    End If
                End If
                If .Cells(i, cRepoCDAxis) = cAxisDown And .Cells(i, cRepoCDPosition) > maxDown Then maxDown = .Cells(i, cRepoCDPosition)
            End If
        Next i
        
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
            If .Cells(i, cRepoCDPosition) = cAcrossLast Then
                maxAcross = maxAcross + 1
                .Cells(i, cRepoCDPosition) = maxAcross
            End If
        Next i
        
        .Cells(p_currentFilterIndex, cRepoCDAxis) = axis
        .Cells(p_currentFilterIndex, cRepoCDPosition) = _
            Switch(axis = cAxisDown, maxDown, axis = cAxisAcross, maxAcross) + 1

    End With

End Sub

Private Sub undrill()
    
    If drillState Then
    
        With p_currentRepoSheet
            
            Dim myAxis As String:       myAxis = .Cells(p_currentFilterIndex, cRepoCDAxis)
            Dim myPosition As Integer:  myPosition = .Cells(p_currentFilterIndex, cRepoCDPosition)
            
            Dim i As Integer
            For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
                If .Cells(i, cRepoCD) = p_currentQueryIndex And _
                   .Cells(i, cRepoCDAxis) = myAxis And _
                   .Cells(i, cRepoCDPosition) > myPosition Then
                    .Cells(i, cRepoCDPosition) = .Cells(i, cRepoCDPosition) - 1
                End If
            Next i
            
            .Cells(p_currentFilterIndex, cRepoCDAxis) = cAxisNone
            .Cells(p_currentFilterIndex, cRepoCDPosition) = 0
            
        End With
        
        displayFilter
            
    End If

End Sub

Private Function drillWithinLimits() As Boolean
            
    Dim maxDrillRemaining As Byte
    maxDrillRemaining = versionInt(99, 99, 10) ' max. count of ( drilled characteristics + key fig structures )
    
    With p_currentRepoSheet
        Dim i As Integer
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
            If .Cells(i, cRepoCD) = p_currentQueryIndex Then
                If .Cells(i, cRepoCDAxis) = cAxisDown Or .Cells(i, cRepoCDAxis) = cAxisAcross Then
                    maxDrillRemaining = maxDrillRemaining - 1
                End If
            End If
        Next i
    End With
    
    drillWithinLimits = (maxDrillRemaining > 0)
    
End Function

Public Function drillState(Optional ByVal filterIndex As Long) As Integer

    If filterIndex = 0 Then filterIndex = p_currentFilterIndex
    Select Case p_currentRepoSheet.Cells(filterIndex, cRepoCDAxis)
    Case cAxisDown:                 drillState = 1
    Case cAxisNone, cAxisFilter:    drillState = 0
    Case cAxisAcross:               drillState = -1
    End Select
    
End Function

Sub contextHandlerSelectSAPGUI()
    contextSAPfilter "SELF"
End Sub

Sub contextHandlerSelectSAPGUIrestricted()
    contextSAPfilter "SELU"
End Sub

Public Sub selectorDestroy()
    destroyComponent g_selector
End Sub

Public Sub launchSelector()
    Dim lElemText As String                                                                 'VBR-07:034
    Dim lRowTexts As Object                                                                 'VBR-07:034
    Dim ldate                                                                               'VBR-07:034
    Dim keydate As String                                                                   'VBR-07:034
    Dim l_date, l_month, l_year                                                             'VBR-07:034
    Dim dateSep As String * 1:  dateSep = Application.International(xlDateSeparator)        'VBR-07:034
    
    If Not RunOpenQuery Then Exit Sub
    userStatusBar "Filter"
    
    Dim filterForStructure As Boolean:  filterForStructure = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDIsStructure) = "X"
    
    If filterForStructure Then
        If Not convertMem2Fac Then GoTo leave
    Else
        Dim myConFacSheet As Worksheet: Set myConFacSheet = ConFacSheetGet(True)
        If Not repoReadTable(myConFacSheet, cRepoCF, "E_T_FAC") Then GoTo leave
        If Not repoReadTable(myConFacSheet, cRepoCN, "E_T_CON") Then GoTo leave
    End If
''    ' Begin                                                                         VBR-07:034
''    ' Following code added to set the Keydate
''    If rfcGetTextSymbols(p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)) Then
''
''        For Each lRowTexts In p_tables("E_T_TXT_SYMBOLS").Rows
''        If lRowTexts("SYM_FS") = 0 Then
''            If lRowTexts("SYM_NAME") = "SRDATE" Then
''                On Error GoTo Leaveloop
''                lElemText = lRowTexts("SYM_VALUE")
''                ldate = Split(lElemText, dateSep)
''                l_date = ldate(0)
''                l_month = ldate(1)
''                l_year = ldate(2)
''
''                keydate = l_year & l_month & l_date
''
''                GoTo Leaveloop
''            End If
''        End If
''        Next lRowTexts
''    End If
''Leaveloop:
''    ' End                                                                          VBR-07:034

    'p_builderEventClass.builderCreate
    If Not provideComponent(g_selector, "SAPBWSelWizard.BWSelectionWizard", "Selektor") Then GoTo leave
    If Not provideGlobalLoggedOn Then GoTo leave

    With g_selector

        Set .GlobalData = p_bexGlobal
        .Caller = IIf(filterForStructure, 6, 1)
        ' run selector for Excel add-in:   1 - normal Dims, 6 - Structures

        .infoobjname = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName)
        .InfoObjText = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharText)

        .ConTabName = "E_T_CON"
        .FacTabName = "E_T_FAC"
        Set .SelectionTables = p_tables
        Set .ParentApplication = Application

        .queryHandle = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)
        .Keydateint = CStr(keydate)                                                 'VBR-07:034
        trace True, "running selector"
 
        If .infoobjname <> "1CUDIM" Then                                'VBR
            ToolBarsHide
            Dim cancelled As Boolean:   cancelled = Not .Run
            ToolBarsUnhide
        Else
            cancelled = True
        End If                                                          ' VBR
        Set .SelectionTables = Nothing
        Set .ParentApplication = Nothing
    
    End With

    If Not cancelled Then
    
        If filterForStructure Then
            convertFac2Mem
        Else
            repoWriteTable myConFacSheet, cRepoCF, "E_T_FAC"
            repoWriteTable myConFacSheet, cRepoCN, "E_T_CON"
        End If
            
        p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQRefreshed) = False
        displayFilter
        RunQueryConditioned True
        
    End If
        
leave:
    userStatusBar ""

End Sub

Private Function convertMem2Fac() As Boolean

    convertMem2Fac = False
    If Not tableReset("E_T_CON") Then Exit Function
    If Not tableReset("E_T_FAC") Then Exit Function
    With p_currentRepoSheet
    
        Dim dimID As String:   dimID = .Cells(p_currentFilterIndex, cRepoCDCharName)
        Dim myRow As Object
        Set myRow = p_tables("E_T_CON").Rows.Add
        myRow("ELTUID") = "!" & dimID
        myRow("IOBJNM") = dimID
        myRow("ACTIVE") = "X"
        myRow("CONTYPE") = cConTypeSelection
        
        Dim i As Long
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCM) - 1
            If .Cells(i, cRepoCM) = p_currentQueryIndex And _
               .Cells(i, cRepoCMDimName) = dimID And _
               .Cells(i, cRepoCMHidden) = "" Then
                Set myRow = p_tables("E_T_FAC").Rows.Add
                myRow("ELTUID") = "!" & dimID
                myRow("TERM") = 1
                myRow("FACTOR") = 1
                myRow("SELOPTLINE") = p_tables("E_T_FAC").Rows.Count
                myRow("SIGN") = "I"
                myRow("OPT") = "EQ"
                myRow("LOWFLAG") = 1
                myRow("LOW") = .Cells(i, cRepoCMMemName)
                myRow("LOWEXT") = .Cells(i, cRepoCMMemName)
                myRow("LOWTXTLG") = .Cells(i, cRepoCMMemText)
            End If
        Next i

    End With
    convertMem2Fac = True

End Function

Private Sub convertFac2Mem()

    With p_currentRepoSheet
    
        Dim dimID As String:    dimID = .Cells(p_currentFilterIndex, cRepoCDCharName)
        Dim nextHidden As Long: nextHidden = p_tables("E_T_FAC").Rows.Count + 1
        Dim i As Long
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCM) - 1
            If .Cells(i, cRepoCM) = p_currentQueryIndex And .Cells(i, cRepoCMDimName) = dimID Then
                .Cells(i, cRepoCMPosition) = nextHidden:            nextHidden = nextHidden + 1
                If .Cells(i, cRepoCMHidden) <> cHiddenInvisible Then
                    .Cells(i, cRepoCMHidden) = cHiddenDontShow
                    Dim myRow As Object
                    For Each myRow In p_tables("E_T_FAC").Rows
                        If myRow("LOW") = .Cells(i, cRepoCMMemName) Then
                            .Cells(i, cRepoCMHidden) = cHiddenShow: nextHidden = nextHidden - 1
                            .Cells(i, cRepoCMPosition) = myRow("SELOPTLINE")
                            Exit For
                        End If
                    Next myRow
                End If
            End If
        Next i

    End With
        
End Sub

Public Sub contextHandlerRemoveFilter()
    If Not dialIn Then Exit Sub
    If p_versionServer >= cV20 Then
        contextSAPfilter "SELD"
    Else
        contextSetFilter "", "", "", "", False
    End If
End Sub

Public Sub contextHandlerShowFullValue()
    
    Dim filterValue As String
    
    If p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDIsStructure) = "X" Then
        filterValue = displayKeyFilterText(p_currentFilterIndex, True)
    Else
        Dim eltuid As String:   eltuid = ConFacEltuidGet
        If Len(eltuid) Then
            If Not repoReadTable(ConFacSheetGet, cRepoCF, "E_T_FAC") Then Exit Sub
            filterValue = ConFacTranslateSelection(0)
        End If
    End If

    If Len(filterValue) Then
        Dim filterRange As Range
        Set filterRange = RunGetFilterRange(p_currentFilterIndex)
        If Not filterRange Is Nothing Then filterRange.Cells(1, 2).Value = filterValue
        ' BugFix : the filterCell.wraptext property being set to true creates formatting
        ' problems in the bex. Hence to correctly format the filtercell when all the values
        ' are shown, the wraptext property is being set here.
        filterRange.Cells(1, 2).WrapText = True
    End If

End Sub

Public Sub contextSetFilter(intValue As String, extValue As String, txtValue As String, hierValue As String, removeDrill As Boolean)
    
    If removeDrill Then undrill
    
    With p_currentRepoSheet
        If .Cells(p_currentFilterIndex, cRepoCDIsStructure) = "X" Then
            Dim dimID As String:   dimID = .Cells(p_currentFilterIndex, cRepoCDCharName)
            Dim i As Long
            For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCM) - 1
                If .Cells(i, cRepoCM) = p_currentQueryIndex And .Cells(i, cRepoCMDimName) = dimID Then
                    .Cells(i, cRepoCMHidden) = IIf(.Cells(i, cRepoCMMemName) = intValue, "", "X")
                End If
            Next i
        Else
            .Cells(p_currentFilterIndex, cRepoCDAxis) = IIf(intValue = "", cAxisNone, cAxisFilter)
            setFilterValue intValue, extValue, txtValue, hierValue
        End If
    End With
    
    RunQueryConditioned
    
End Sub

Private Sub setFilterValue(valInt As String, valExt As String, valTxt As String, valHier As String)

    With p_currentRepoSheet
        .Cells(p_currentFilterIndex, cRepoCDValInt) = "'" & valInt
        .Cells(p_currentFilterIndex, cRepoCDValExt) = "'" & valExt
        .Cells(p_currentFilterIndex, cRepoCDValTxt) = "'" & valTxt
        .Cells(p_currentFilterIndex, cRepoCDValHry) = "'" & valHier
    
        Dim myConFacSheet As Worksheet: Set myConFacSheet = ConFacSheetGet
        If Not myConFacSheet Is Nothing Then Chavl2ConFacAdd myConFacSheet, p_currentFilterIndex

    End With
    displayFilter

End Sub

Public Sub contextGetFilterValue(intValue As String, hierValue As String)
    
    If p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) < cV20 Then
        intValue = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDValInt)
        hierValue = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDValHry)
    Else ' definition comes from a rel. 2.0 server: read value from CON / FAC tables
        Dim eltuid As String:   eltuid = ConFacEltuidGet
        If Len(eltuid) Then
            intValue = ""
            hierValue = ""
            With ConFacSheetGet
                Dim i As Long
                For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCF) - 1
                    If .Cells(i, cRepoCF) = p_currentQueryIndex And .Cells(i, cRepoCFEltuid) = eltuid Then
                        Dim found As Boolean
                        If Not found And .Cells(i, cRepoCFOpt) = "EQ" And .Cells(i, cRepoCFSign) = "I" Then
                            found = True
                            intValue = .Cells(i, cRepoCFLowValue)
                            hierValue = .Cells(i, cRepoCFHierIObj)
                        Else ' complex filter value
                            intValue = "*"
                            hierValue = "*"
                        End If
                    End If
                Next i
            End With
        End If
    End If

End Sub

'----- context menu & drill-down handling for result area / query

Public Sub menuFillResult(myControls As CommandBarControls, Optional silent As Boolean)

    With p_currentRepoSheet
        
        If isConnected(True, True) Then
        
            Dim currentNodes(1 To 5) As CommandBarControls  ' max. 5 levels for R/3 menus
            Set currentNodes(1) = myControls
            
            userStatusBar "Menu"
                            
            If Not contextSetSelection Then Exit Sub ' p_tables("I_T_RANGES") is filled
            
            If p_versionServer < cV20 Then
                userMenu currentNodes(1), "Back", "contextSAP", False, False, "BACK"
                userMenu currentNodes(1), "Start", "contextSAP", False, False, "STRT"
            End If
            
            If rfcGetContextMenu(.Cells(p_currentQueryIndex, cRepoCQHandle)) Then  ' p_tables("E_T_MENU") is now filled
                Dim rowMenu As Object
                For Each rowMenu In p_tables("E_T_MENU").Rows
                    If rowMenu("POPUPLVL") = 0 Then rowMenu("POPUPLVL") = 1 ' compensate error in R/3 menu builder
                    Dim nodeIndex As Integer
                    nodeIndex = rowMenu("POPUPLVL")
                    If rowMenu("CMDID") = "" Then
                        With currentNodes(nodeIndex).Add(Type:=msoControlPopup)
                            .caption = rowMenu("CAPTION")
                            .beginGroup = (rowMenu("BEGINGROUP") = "X")
                            Set currentNodes(1 + nodeIndex) = .Controls
                        End With
                    Else
                        userMenuSAP currentNodes(nodeIndex), rowMenu
                    End If
                Next rowMenu
            End If
            
            userStatusBar ""
        
        End If
        menuFillDefaults myControls, silent

    End With
    
End Sub

Private Sub contextSAPfilter(fCode As String)
    Dim filterObjname As String: filterObjname = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName)
    If Not isConnected(True) Then RunQuery True
    Set p_currentSelection = Nothing
    If contextSetSelection Then contextSAP fCode, filterObjname
End Sub

'Private Sub contextSAPfilter(fCode As String)
'    Set p_currentSelection = Nothing
'    If contextSetSelection Then contextSAP fCode, p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName)
'End Sub

Public Function contextSAP(Optional fCode As String, Optional objName As String, Optional params As Boolean) As Boolean
    ' handler for the R/3-provided functions of a query's context menu
    ' R/3 function code is contained in the active control's Tag property

    If Len(fCode) = 0 Then fCode = menuParam
    
    If Left(fCode, 2) = "BS" Then
        contextSAP = queryJump(cJumpRepRepFCode, fCode)
        RunProcessTextElements "F"
        Exit Function
    End If
    
    If (fCode = "SELF" Or fCode = "SELU") And p_versionServer >= cV20 Then
        launchSelector
        Exit Function
    End If
    
    With p_currentRepoSheet
        
        Dim resultAddress As String:    resultAddress = RunGetResultAddress(p_currentQueryIndex)
        
        trace True, "calling OLAP function"
        trace False, "function code: " & fCode
        trace False, "array: " & resultAddress
                    
        Dim target As Range
        Set target = RunGetTarget
        If target Is Nothing Then
            trace False, "failed: get target"
            contextSAP = False
            Exit Function
        End If
        
        userStatusBar "Function", resultAddress
        screenHalt
        
        Dim keepTop As Long, keepBot As Long, keepLeft As Long, keepRight As Long
        If rfcProcessCommand(.Cells(p_currentQueryIndex, cRepoCQHandle), fCode, keepTop, keepBot, keepLeft, keepRight, objName, params) Then
            pingTimeStart
            repoWriteQuery (fCode = "STRT") Or (Left(fCode, 2) = "NR") Or (Left(fCode, 2) = "LA")
            displayResult target, True, keepTop, keepBot, keepLeft, keepRight
            rfcPing .Cells(p_currentQueryIndex, cRepoCQHandle), pingTimeFinish
            contextSAP = True
        Else
            contextSAP = False
        End If
    
        screenRestore
        userStatusBar ""
    
        ' for functions "new exception" / "new condition", the fcode is only
        ' there to prepare the defaults for the exception / condition builder
        queryDefineWithDefaults fCode
    
    End With
        
End Function

Public Function contextSetSelection() As Boolean
' assumes that repoDetectQuery has been called beforehand to identify the "current" query
    
    If tableReset("I_T_RANGES") Then
        Dim rowSelection As Object
        If p_currentSelection Is Nothing Then ' filter cell is selected, or query is "default" query
            Set rowSelection = p_tables("I_T_RANGES").Rows.Add
            rowSelection("X1") = 0
            rowSelection("Y1") = 0
            rowSelection("X2") = 0
            rowSelection("Y2") = 0
        Else ' cells in the result area are selected, so that repoDetectQuery has set p_currentSelection etc.
            Dim myArea As Range
            For Each myArea In p_currentSelection.Areas
                With myArea
                    Set rowSelection = p_tables("I_T_RANGES").Rows.Add
                    rowSelection("X1") = .column + 1 - p_currentSelXoffset
                    rowSelection("Y1") = .row + 1 - p_currentSelYoffset
                    rowSelection("X2") = .column + .Columns.Count - p_currentSelXoffset
                    rowSelection("Y2") = .row + .Rows.Count - p_currentSelYoffset
                End With
            Next myArea
        End If
        contextSetSelection = True
    Else
        contextSetSelection = False
    End If

End Function

Public Function contextSetIndex(rowIndex As Long, Optional columnIndex As Long) As Boolean
    
    If columnIndex = 0 Then columnIndex = 1
    If tableReset("I_T_RANGES") Then
        Dim rowSelection As Object
        Set rowSelection = p_tables("I_T_RANGES").Rows.Add
        rowSelection("X1") = columnIndex:  rowSelection("Y1") = rowIndex
        rowSelection("X2") = columnIndex:  rowSelection("Y2") = rowIndex
        contextSetIndex = True
    Else
        contextSetIndex = False
    End If

End Function

' ----- default entries

Public Sub menuFillDefaults(myControls As CommandBarControls, Optional silent As Boolean)
        
    If myControls.Count = 0 Then
        userMenu myControls, "RefreshNow", "runQuery", True
    End If
If Not ActiveSheet.ProtectContents Or Not ActiveSheet.ProtectDrawingObjects Then
    userMenu myControls, "ChangeSettings", "contextQuerySettings", True
Else
    userMenu myControls, "ChangeSettings", "contextQuerySettings", True, True
End If

End Sub

Public Sub contextQuerySettings()
    userFormShow dBEXsettings, "captionSettings"
End Sub

Public Sub contextJump(Optional gotoTag As String)
    
    If Len(gotoTag) = 0 Then gotoTag = menuParam
    p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQGoto) = gotoTag
    
    Select Case Left(gotoTag, 1)
        Case cJumpExtView:          queryJump cJumpView, Mid(gotoTag, 2)
        Case cJumpExtViewGlobal:    queryJump cJumpViewGlobal, Mid(gotoTag, 2)
        Case cJumpExtRepRep:        queryJump cJumpRepRep, Mid(gotoTag, 2)
        Case Else:  Exit Sub
    End Select

End Sub
Attribute VB_Name = "cBEXdialinout"
Option Private Module
Option Explicit

Private g_logonObj              As Object
Private g_serverObj             As Object
Private g_pendingEmbedQuery     As String
Private g_pendingEmbedAnchor    As Range
Private g_waitingFor            As String   ' <> "", if waiting for RFC Server connection

Private g_connClient            As String
Private g_connUser              As String
Private g_connLanguage          As String
Private g_connSysNumber         As String
Private g_connAppServer         As String

Private g_pausedUntil As Date

'----- basic login / logout management

Public Function isConnected(Optional andRefreshed As Boolean, Optional andInteractive As Boolean, Optional andValid As Boolean) As Boolean

    isConnected = False
    
    If p_currentQueryIndex Then
        With p_currentRepoSheet
            If andRefreshed Then
                If Not (.Cells(p_currentQueryIndex, cRepoCQRefreshed) And _
                        .Cells(p_currentQueryIndex, cRepoCQHandle) <> 0) Then
                  trace False, "isConntected: not refreshed or no handle"
                  Exit Function
                End If
            End If
            If andValid Then
                If Not (.Cells(p_currentQueryIndex, cRepoCQValid) And _
                        .Cells(p_currentQueryIndex, cRepoCQHandle) <> 0) Then
                  trace False, "isConntected: not valid or no handle"
                  Exit Function
                End If
            End If
            If andInteractive Then
                If Not .Cells(p_currentQueryIndex, cRepoCQInteractive) Then
                  trace False, "isConntected: not interactive"
                  Exit Function
                End If
            End If
        End With
    Else
    ' parameters "and..." are ignored
    End If
    
    If Not p_connectionObj Is Nothing Then
      isConnected = (p_connectionObj.isConnected = 1)
      trace False, "isConntected: true"
    Else
      trace False, "isConntected: false"
    End If

End Function

Sub dialInInfo()

    If isConnected Then
        With p_connectionObj
            If userError("connectInfo", vbInformation + vbYesNo, _
                    vbNewLine & userText("labelClient") & ": " & g_connClient & _
                    vbNewLine & userText("labelUser") & ": " & g_connUser & _
                    vbNewLine & userText("labelLang") & ": " & g_connLanguage & _
                    vbNewLine & userText("connectInfoMore?")) = vbYes Then
                .SystemInformation
            End If
        End With
    Else
        userError "notConnected", vbInformation
    End If

End Sub

Sub dialOut(Optional silent As Boolean, Optional destroyAll As Boolean)
    
    If isConnected Then
        If Not silent Then If userError("confirmDialOut", vbInformation + vbOKCancel) = vbCancel Then Exit Sub
        dialOutClearAllHandles closeQueries:=True
        p_connectionObj.Logoff
        trace True, "Disconnect"
    Else
        If Not silent Then userError "notConnected", vbInformation
        dialOutClearAllHandles
    End If
    
    p_URLprefix = ""
    
    Set p_tables = Nothing
    
    builderDestroy
    openSaveDestroy
    selectorDestroy
    
    If Not p_bexGlobal Is Nothing Then
        Set p_bexGlobal.SAPConnection = Nothing
        Set p_bexGlobal = Nothing
    End If
    
    Set p_connectionObj = Nothing
    If destroyAll Then Set g_logonObj = Nothing
    
    If Not isPdfMakerLoaded Then CoFreeUnusedLibraries

End Sub

Private Sub serverObjDestroy()
    If Not g_serverObj Is Nothing Then
        g_serverObj.finish
        Set g_serverObj.Connection = Nothing
        Set g_serverObj = Nothing
    End If
End Sub

Function dialIn() As Boolean

    If isConnected Then
        dialIn = True
    Else
        dialIn = False
        If dialInPaused Then Exit Function
        If prepareConnection Then
            With p_connectionObj
                Do
                    Application.Visible = True
                    If .Logon(GetActiveWindow(), False) Then
                        Application.Visible = True
                        If initConnection Then dialIn = True Else .Logoff
                        Exit Function ' dialIn = True iff .logon and initConnection were successful
                    Else
                        trace True, "no Connect"
                        If .isConnected = 2 Then ' user pressed Cancel button
                            trace False, "cancelled"
                            dialInPause ' suppress further logon dialogs for 2 secs
                            Exit Function
                        End If
                    End If
                Loop
            End With
        End If
    End If
    
End Function

Private Function dialInPaused() As Boolean
    If g_pausedUntil > Now Then
        trace True, "logon suppressed due to recent cancellation"
        dialInPaused = True
    Else
        dialInPaused = False
    End If
End Function

Public Sub dialInPause(Optional aHundredYears As Boolean)
    Dim pauseUntil As Date: pauseUntil = Now + IIf(aHundredYears, 36525, TimeSerial(0, 0, 2))
    If pauseUntil > g_pausedUntil Then g_pausedUntil = pauseUntil
End Sub

Public Sub dialOutClearAllHandles(Optional closeQueries As Boolean)

    Dim wb As Workbook
    For Each wb In Application.Workbooks
        dialOutClearHandles wb, closeQueries
    Next wb

End Sub

Public Sub dialOutClearHandles(wb As Workbook, closeQueries As Boolean, Optional repoSheet As Worksheet)

    Dim oldRepoSheet As Worksheet:  Set oldRepoSheet = p_currentRepoSheet
    Dim oldQueryIndex As Long:      oldQueryIndex = p_currentQueryIndex
    
    If repoSheet Is Nothing Then
        Set p_currentRepoSheet = repoGetRepoSheet(wb, False)
        If p_currentRepoSheet Is Nothing Then GoTo leave
    Else
        Set p_currentRepoSheet = repoSheet
    End If

    For p_currentQueryIndex = cRepoRTop + p_currentRepoSheet.Cells(cRepoRCounts, cRepoCQ) - 1 To cRepoRTop Step -1
        dialOutClearHandle closeQueries
    Next p_currentQueryIndex
    
leave:
    p_currentQueryIndex = oldQueryIndex
    Set p_currentRepoSheet = oldRepoSheet

End Sub

Public Sub dialOutClearHandle(closeQueries As Boolean)
    
    With p_currentRepoSheet
        If closeQueries Then
            rfcCloseQuery .Cells(p_currentQueryIndex, cRepoCQHandle)
        End If
        If .Cells(p_currentQueryIndex, cRepoCQTransient) Then
            queryDelete False, False, False, True, True
        Else
        On Error Resume Next
            .Cells(p_currentQueryIndex, cRepoCQHandle) = 0
        End If
    End With

End Sub

Public Function prepareConnection() As Boolean
    
    prepareConnection = False
    If provideComponent(g_logonObj, "SAP.LogonControl.1", "Logon Manager") Then
        g_logonObj.ApplicationName = "BEx"
        g_logonObj.enable3d
        Set p_connectionObj = g_logonObj.newConnection()
        p_connectionObj.RfcWithDialog = 1
        #If ABAPDebug Then
            p_connectionObj.tracelevel = vbKeyD
        #End If
        dialOutClearAllHandles
        prepareConnection = True
    End If

End Function

Public Function initConnection() As Boolean
    
    initConnection = False
    If isConnected Then
        
        With p_connectionObj
            
            trace True, "Connect"
            trace False, "system " & .system
            trace False, "server " & .ApplicationServer
            trace False, "user " & .user
            
            g_connClient = .client
            g_connUser = .user
            g_connLanguage = .language
            g_connSysNumber = .systemnumber
            g_connAppServer = .ApplicationServer
            
        End With

        If Not rfcCheckBW Then Exit Function

        checkFrontendVersion        ' 273 by tk

        p_manageGUI = True  ' GUI management for "session initialize" is always client-driven
        If rfcInitSession Then
            ' evaluate session properties
            p_ping = False
            p_versionServer = 0
            Dim rowPrptys As Object
            For Each rowPrptys In p_tables("E_T_PRPTYS").Rows
                With rowPrptys
                    Select Case .cell(1)
                        Case cPropClientError
                            If Len(.cell(2)) Then
                                userError "clientError", vbCritical, vbNewLine & userText("confirmDialOut")
                                Exit Function
                            End If
                        Case cPropReqVersion
                            If .cell(2) > cVersionFrontend Then
                                userError "frontendVersion"
                                Exit Function
                            End If
                        Case cPropCurVersion:       p_versionServer = .cell(2)
                        Case cPropCancelSize:       p_retrieveLimit = .cell(2)
                        Case cPropAuthChecks:       p_prohibitedTools = .cell(2)
                        Case cPropSendPing:         p_ping = (.cell(2) <> "")
                        Case cPropManageGUI:        p_manageGUI = (.cell(2) <> "")
                        Case cPropCurrClient:       g_connClient = .cell(2)
                        Case cPropCurrUser:         g_connUser = .cell(2)
                        Case cPropCurrLanguage:     g_connLanguage = .cell(2)
                        Case cPropCurrSysNumber:    g_connSysNumber = .cell(2)
                    End Select
                End With
            Next rowPrptys
            userLanguageSet g_connLanguage
            initConnection = True
        
        End If
    
    End If
    
    traceContinue
    Set p_appEventClass.myAppEvents = Application ' enable events

End Function

Function dialinGetUser() As String
    dialinGetUser = g_connUser
End Function

Function dialinGetSysNumber() As String
    dialinGetSysNumber = Format(g_connSysNumber, "00")
End Function
Function dialinGetAppServer() As String
    dialinGetAppServer = g_connAppServer
End Function

Attribute VB_Name = "cBEXdisplay"
Option Explicit
Option Private Module

Public g_onRefreshModuleTarget As Range
Private g_spaceDefaultRows As Integer
Private g_spaceDefaultCols As Integer

Public Sub displayResult(target As Range, Optional refresh As Boolean, Optional keepTop As Long, Optional keepBottom As Long, Optional keepLeft As Long, Optional keepRight As Long)
    Dim lHelpTarget As Range
    Dim lHelpTarget2 As Range
    Dim lHelpRow, lHelpRow2 As Integer
    Dim lCalculationMode 'As XlCalculation                                      VBR:10-048
    
    On Error GoTo leave
    screenHalt
    
    lCalculationMode = Application.Calculation                                  'VBR:10-048
    Application.Calculation = xlCalculationManual                               'VBR:10-048

    Dim keepVertical As Long:   keepVertical = keepTop + keepBottom
    Dim keepHorizontal As Long: keepHorizontal = keepLeft + keepRight
    
    trace True, "displaying result"
    
    bbsBackDisable target.Worksheet.Parent
        
    With p_currentRepoSheet

        Dim shapePrefix As String:   shapePrefix = .Cells(p_currentQueryIndex, cRepoCQPrefix) & " "
        
        .Cells(p_currentQueryIndex, cRepoCQRefreshed) = refresh
        Dim firstRefresh As Boolean: firstRefresh = refresh And .Cells(p_currentQueryIndex, cRepoCQFirstRefresh)
        
        If keepVertical Or keepHorizontal Then ' hierarchy op (collapse / expand)
            
            If .Cells(p_currentQueryIndex, cRepoCQResultClipped) Then GoTo spaceMissing
            
        Else ' non-hierarchy op (complete result will be exchanged)

            ' clear all ranges, because filters or text elements may have been deleted
            If firstRefresh Then queryDelete False, False, True, False, False
            displayFilters target, .Cells(p_currentQueryIndex, cRepoCQFirstRefresh)
            RunClearRange target, shapePrefix
            .Cells(p_currentQueryIndex, cRepoCQFirstRefresh) = False
        
        End If
        
        .Cells(p_currentQueryIndex, cRepoCQYData) = 0
        .Cells(p_currentQueryIndex, cRepoCQXData) = 0
        .Cells(p_currentQueryIndex, cRepoCQResultClipped) = False
        
        If refresh And (p_gridHeight + keepVertical) * (p_gridWidth + keepHorizontal) Then

            If keepVertical And keepHorizontal Then
                ' only allowed if space requirements have not changed ... !!
            Else
            
                ' delete area between the keep areas
                Dim targetDelta As Range
                If keepVertical And target.Rows.Count > keepVertical Then
                    Dim lRows As Integer
                    lRows = target.Rows.Count - keepVertical
                    Set targetDelta = target.Resize(lRows)
                    shapesDelete targetDelta.Offset(keepTop), shapePrefix
                    Set lHelpTarget = _
                        Range(targetDelta.Offset(keepTop), _
                              Cells(target.row + target.Rows.Count - 1 - keepBottom, _
                                    targetDelta.column + targetDelta.Columns.Count - 1))
                    lHelpTarget.Delete xlUp
                    Set targetDelta = target.Resize(lRows)
                    lHelpRow = targetDelta.Offset(target.Rows.Count).row
                    Set lHelpTarget = Range(Cells(lHelpRow, targetDelta.column), Cells(lHelpRow + lRows - 1, targetDelta.column + targetDelta.Columns.Count - 1))
                    
                    targetDelta.Offset(target.Rows.Count).Insert xlDown
                    Set lHelpTarget = Range(Cells(lHelpRow, targetDelta.column), Cells(lHelpRow + lRows - 1, targetDelta.column + targetDelta.Columns.Count - 1))

                    'targetDelta.Offset(target.Rows.Count).Clear
                    lHelpTarget.Clear
                End If
                If keepHorizontal And target.Columns.Count > keepHorizontal Then
                    Dim lColumns As Integer
                    lColumns = target.Columns.Count - keepHorizontal
                    Set targetDelta = target.Resize(, lColumns)
                    shapesDelete targetDelta.Offset(, keepLeft), shapePrefix
                    targetDelta.Offset(, keepLeft).Delete xlToLeft
                    Set targetDelta = target.Resize(, lColumns)
                    targetDelta.Offset(, target.Columns.Count).Insert xlToRight
                    Set targetDelta = target.Resize(, lColumns)
                    targetDelta.Offset(, target.Columns.Count).Clear
                End If
    
                trace False, "'keep' areas saved"
  
                'scan for changes in shapes table Delete Shapes if Resularea has no changes, but hier icon
                'has to be removed #nr. 60930 2003
                If keepVertical And target.Rows.Count = keepVertical Then
                    CheckShapes (shapePrefix)
                End If
                ' insert the area that will hold the new result
                If p_gridHeight * p_gridWidth Then
                
                    .Cells(p_currentQueryIndex, cRepoCQResultClipped) = _
                        Not displayProvideRange(target, p_gridHeight + keepVertical, p_gridWidth + keepHorizontal)
                    
                    If keepBottom Then
                        ' to shift keepBottom area, there must be enough space - otherwise overflow shapes from the keepBottom area may be left dangling
                        If .Cells(p_currentQueryIndex, cRepoCQResultClipped) Then GoTo spaceMissing
                        On Error GoTo spaceMissing
                        target.Resize(p_gridHeight).Offset(keepVertical).Delete xlUp
                        Dim lOldAddress As String
                        Dim lRange1 As Range
                        lOldAddress = target.Address
                        target.Resize(p_gridHeight).Offset(keepTop).Insert xlDown
                        Set lRange1 = Range(lOldAddress)
                        If keepTop = 0 Then
                         Set target = Range(Cells(lRange1.row, lRange1.column), Cells(lRange1.row - 1 + lRange1.Rows.Count + p_gridHeight, lRange1.column + lRange1.Columns.Count - 1))
                        End If
                        If keepBottom = 0 Then Set target = target.Resize(p_gridHeight + keepTop)
                        On Error GoTo 0
                    End If
                    If keepRight Then
                        ' to shift keepRight area, there must be enough space - otherwise overflow shapes from the keepRight area may be left dangling
                        If .Cells(p_currentQueryIndex, cRepoCQResultClipped) Then GoTo spaceMissing
                        On Error GoTo spaceMissing
                        target.Resize(, p_gridWidth).Offset(, keepHorizontal).Delete xlToLeft
                        lOldAddress = target.Address
                        target.Resize(, p_gridWidth).Offset(, keepLeft).Insert xlToRight
                        Set lRange1 = Range(lOldAddress)
                        If keepLeft = 0 Then
                         Set target = Range(Cells(lRange1.row, lRange1.column), Cells(lRange1.row + lRange1.Rows.Count, lRange1.column + lRange1.Columns.Count - 1 + p_gridWidth))
                        End If
                        If keepRight = 0 Then Set target = target.Resize(, p_gridWidth + keepLeft)
                        On Error GoTo 0
                    End If
                
                    trace False, "space provided"
                
                End If
                        
            End If
                        
            Dim targetFill As Range
            If p_gridHeight * p_gridWidth Then
                Set targetFill = target.Resize(target.Rows.Count - keepVertical, target.Columns.Count - keepHorizontal).Offset(keepTop, keepLeft)
                fillGrid targetFill, .Cells(p_currentQueryIndex, cRepoCQStyles)
            End If
            If p_versionServer > cV20 Then
                ' symbol coordinates relative to fill area
                shapesCreate targetFill, keepTop
            Else
                ' symbol coordinates relative to complete result area
                shapesCreate target, keepTop
            End If

            If firstRefresh Then RunProcessTextElements  ' must run after shapesCreate !
            If firstRefresh Then runProcessFilterTextElems  ' Must run  VBR:08-043
            
        Else
            'necessary for title if the query has no result
            If firstRefresh Then RunProcessTextElements
            Set target = target.Cells(1, 1)
            target.Value = userText(IIf(refresh, "constNoRowsReturned", "constNotCalculated"))
            If .Cells(p_currentQueryIndex, cRepoCQStyles) Then setStyle target, "SAPBEXstdData"
        
        End If
        
        If refresh Then
            .Cells(p_currentQueryIndex, cRepoCQValid) = True
            HideProgress
''            displayFilters target, False
        End If

        adaptColumnWidth target, .Cells(p_currentQueryIndex, cRepoCQAdjustColumns)

        On Error Resume Next
        .names(CStr(.Cells(p_currentQueryIndex, cRepoCQPrefix))).Delete
        On Error GoTo 0
        .names.Add .Cells(p_currentQueryIndex, cRepoCQPrefix), target
        
        drawUndraw
        
        Dim myChartIndex As Integer: myChartIndex = .Cells(p_currentQueryIndex, cRepoCQChartIndex)
        If myChartIndex > 0 Then
            Dim co As ChartObject: Set co = chartFind(myChartIndex)
            If Not co Is Nothing Then
                If target.Cells.Count > 1 Then co.Chart.SetSourceData target, co.Chart.plotBy
                ' note: adjusting to singleton ranges is unnecessary and might destroy chart format information
            Else
                .Cells(p_currentQueryIndex, cRepoCQChartIndex) = 0
            End If
        End If
        
        If refresh And p_gridHeight + keepVertical > 0 Then
            
            Dim myGISIndex As Integer: myGISIndex = .Cells(p_currentQueryIndex, cRepoCQGISIndex)
            If myGISIndex > 0 Then
                Dim mo As Object: Set mo = gisFind(myGISIndex)
                If Not mo Is Nothing Then
                    gisSetValues mo, target.Value
                Else
                    .Cells(p_currentQueryIndex, cRepoCQGISIndex) = 0
                End If
            End If
                
        End If
                
        screenRestore
  ' Update the calculation mode back to the original set by the user.             VBR:11-057
    Application.Calculation = lCalculationMode
        If g_delayCallToOnRefreshModule <> True Then
        If refresh Then resultExit .Cells(p_currentQueryIndex, cRepoCQPrefix), target
        Else
            Set g_onRefreshModuleTarget = target
        End If
        
    End With

    Application.Calculation = xlCalculationManual                               'VBR:11-057
    
    'Fix : Bad Dll calling convention run-time error 49
    GoTo Exit_Sub

spaceMissing:
    rfcCloseQuery p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)
    p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle) = 0
    userError "spaceMissingHierarchy"
    '% besser: getGrid wiederholen !

leave:
    spaceClearUserPreferences
    screenRestore
    HideProgress                                        'VBR:09-045
    
Exit_Sub:
  
  ' Update the calculation mode back to the original set by the user.             VBR:10-048
    Application.Calculation = lCalculationMode

End Sub

Private Sub displayFilters(target As Range, firstdisplay As Boolean)

    ' note that "target is nothing" will NOT raise runtime errors (viz. displayFilter) !

    Dim anyFilterCreated As Boolean
    Dim thisFilterCreated As Boolean
    
    With p_currentRepoSheet
        Dim i As Long
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
            If .Cells(i, cRepoCD) = p_currentQueryIndex Then
                If Len(.Cells(i, cRepoCDIsStructure)) Then ' if structures are undrilled, their filter cells MUST be shown
                    If drillState(i) = 0 Then .Cells(p_currentQueryIndex, cRepoCQStructFilter) = True
                End If
                If .Cells(i, cRepoCDIsStructure) = "" Or .Cells(p_currentQueryIndex, cRepoCQStructFilter) Then
                    If Len(.Cells(i, cRepoCDIsStructure)) Then .Cells(i, cRepoCDValTxt) = displayKeyFilterText(i)
                    p_currentFilterIndex = i
                    thisFilterCreated = False
                    displayFilter target, thisFilterCreated, firstdisplay
                    If thisFilterCreated Then Set target = target.Offset(1)
                    anyFilterCreated = anyFilterCreated Or thisFilterCreated
                End If
            End If
        Next i
    End With
    
    p_currentFilterIndex = 0
    If anyFilterCreated Then Set target = target.Offset(1)

    displayCons

End Sub

Public Sub displayFilter(Optional target As Range, Optional targetWasUsed As Boolean, Optional firstdisplay As Boolean = True)

    ' the target range may be used as a substitute in case the filter range is undefined
    ' in this case targetWasUsed is returned TRUE

    screenHalt

    Dim filterRange As Range
    Set filterRange = RunGetFilterRange(p_currentFilterIndex)
    If filterRange Is Nothing Then
        If target Is Nothing Then Exit Sub
        Set filterRange = target.Cells(1, 1)
        targetWasUsed = True
    End If
    If isProtected(filterRange.Parent, True) Then Exit Sub

    displayProvideRange filterRange, 1, 2
    userValidate filterRange

    With p_currentRepoSheet

        .names.Add RunGetFilterName(p_currentFilterIndex), filterRange

        On Error GoTo availableCellsMapped
        Dim changeStyle As Boolean:  changeStyle = .Cells(p_currentQueryIndex, cRepoCQStyles)
        Dim filterCell As Range

        If firstdisplay Then
            Set filterCell = filterRange.Cells(1, 1)
            RunClearRange filterCell
            filterCell = .Cells(p_currentFilterIndex, cRepoCDCharText)
            If changeStyle Then setStyle filterCell, "SAPBEXchaText"
        End If
        
        Set filterCell = filterRange.Cells(1, 2)
        RunClearRange filterCell
        filterCell = IIf(.Cells(p_currentQueryIndex, cRepoCQRefreshed), "'", "! ") & ConFacTranslateSelection(70)
        If changeStyle Then setStyle filterCell, IIf(drillState, "SAPBEXfilterDrill", "SAPBEXfilterItem")
        
    End With
    
availableCellsMapped:
    screenRestore

End Sub

Public Sub displayCons(Optional selectGroup As String)

        screenHalt
        
        Dim showStyles As Boolean:  showStyles = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQStyles)
        Dim resultArea As Range
    
        Dim myConFacSheet As Worksheet: Set myConFacSheet = ConFacSheetGet
        If Not myConFacSheet Is Nothing Then
        With myConFacSheet
            
            Dim i As Long
            For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCN) - 1
                If .Cells(i, cRepoCN) = p_currentQueryIndex Then
                    
                    Dim eltuid As String:   eltuid = .Cells(i, cRepoCNEltuid)
                    Dim myRange As Range:   Set myRange = RunGetConRange(eltuid)
                    
                    If myRange Is Nothing And Len(selectGroup) Then
                        If selectGroup = "*" Or (selectGroup = .Cells(i, cRepoCNConType)) Then ' provide new space for con element
                            If resultArea Is Nothing Then Set resultArea = RunGetResultRange(p_currentQueryIndex)
                            If Not resultArea Is Nothing Then Set myRange = RunSetInfoRange(cRangeCondExc, eltuid, resultArea)
                        End If
                    End If
                    
                    If Not myRange Is Nothing Then ' display text element
                        Set myRange = myRange.Cells(1, 1)
                        On Error Resume Next ' myRange.Offset(0, 1) may fail
                        myRange.Value = .Cells(i, cRepoCNText)
                        If showStyles Then setStyle myRange, "SAPBEXheaderText"
                        Set myRange = myRange.Offset(0, 1)
                        myRange.Value = "'" & userText("const" & _
                            IIf(.Cells(i, cRepoCNActive) = "X", "Active", "Inactive" & .Cells(i, cRepoCNActive)))
                        If showStyles Then setStyle myRange, "SAPBEXheaderItem"
                        On Error GoTo 0
                    End If
                
                End If
            Next i
            
        End With
        End If
            
        If Not resultArea Is Nothing Then ' resultArea has been shifted
            ' insert a new row between new textelements and result
            Set myRange = resultArea.Resize(1)
            myRange.Offset(resultArea.Rows.Count).Delete xlUp
            myRange.Insert xlDown
            RunClearRange myRange.Offset(-1)
        End If
        
        screenRestore
    
End Sub

Public Function displayKeyFilterText(ByVal filterIndex As Long, Optional showFullText As Boolean) As String
    
    With p_currentRepoSheet
        
        Dim memberID As String:   memberID = .Cells(filterIndex, cRepoCDCharName)
        Dim myText As String
        Dim i As Long
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCM) - 1
            If .Cells(i, cRepoCM) = p_currentQueryIndex And _
               .Cells(i, cRepoCMDimName) = memberID And _
               Len(.Cells(i, cRepoCMHidden)) = 0 Then
                If Len(myText) Then
                    If showFullText Then
                        myText = myText & ", " & .Cells(i, cRepoCMMemText)
                    Else
                        myText = IIf(Len(.Cells(filterIndex, cRepoCDFiltered)), "*", "")
                        Exit For
                    End If
                Else
                    myText = .Cells(i, cRepoCMMemText)
                End If
            End If
        Next i
    
    End With
    displayKeyFilterText = "'" & myText

End Function

Public Sub resultExit(id As String, area As Range)
    timerStart cTimerExtern
    On Error Resume Next
    Run "'" & area.Worksheet.Parent.Name & "'!" & cVBExit, id, area
    If Err Then
        trace True, "exit failed"
        trace False, "query ID: " & id
        trace False, "target:   " & area.Address(external:=True)
        trace False, "error:    " & Err.Number & Err.Description
    Else
        timerStop cTimerExtern
    End If
End Sub

Private Sub fillGrid(ByVal target As Range, ByVal applyStyles As Boolean)

    Dim targetRemaining As Range
    Set targetRemaining = target
    
'   If the grid contains an empty tile. OSS 445932 2004
    Dim isEmptyTile  As Boolean
    
    If p_retrieveLimit Then If p_gridHeight > p_retrieveLimit Then GoTo cancelled
    
    Dim continueFormatting As Boolean
    continueFormatting = True
    
    ShowProgress True

    Dim tilesRemaining As Integer
    tilesRemaining = 1 + (p_gridHeight / cTilingSize)
    InitProgress userText("statusRetrieving"), tilesRemaining

    Do
        
        MakeProgress
        If IsCancelled Then GoTo cancelled
        
        If applyStyles And p_tables("E_T_RANGES").Rows.Count Then
            InitProgress userText("statusFormatting"), 20
            With target
                If continueFormatting Then continueFormatting = setStyles(.Cells(1, 1), .Rows.Count, .Columns.Count)
            End With
            InitProgress userText("statusRetrieving"), tilesRemaining
        End If
        
        With p_tables("E_T_GRID")
            If .Rows.Count Or isEmptyTile Then
                
                timerStart cTimerFillResult
                
                Dim tile As Range
                If targetRemaining.Rows.Count > p_gridHeight Then
                    Set tile = targetRemaining.Resize(p_gridHeight)
                    Set targetRemaining = targetRemaining.Resize(targetRemaining.Rows.Count - p_gridHeight).Offset(p_gridHeight)
                Else
                    Set tile = targetRemaining
                    Set targetRemaining = Nothing
                    p_gridPending = False
                End If

                If p_gridHeight * p_gridWidth = 1 Then
                    tile.FormulaLocal = Array(.cell(1, 3), "") ' special case "numbers only" -> force to String array
                Else
                    tile.FormulaLocal = .fetchgrid(2, p_gridHeight, 1, p_gridWidth, 3).data
                    
                End If

                ' hierarchy result either contains nodes or is of height 1
                If p_tables(versionStr("E_T_SYMBOLS", "E_T_HRY_DISP")).Rows.Count Or p_gridHeight = 1 Then
                    fillGridIndent tile
                End If
                
                tableReset "E_T_GRID"
                
                timerStop cTimerFillResult
            
            End If
        End With
        
        If p_gridPending Then
            p_gridPending = False ' may be set again by following rfcGetGridContinue
            rfcGetGridContinue p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)
            'Determine if an empty tile is returned in the grid. OSS 445932 2004
            If p_gridHeight > 0 And p_tables("E_T_GRID").Rows.Count = 0 Then
                isEmptyTile = True
            End If
            MakeProgress
            tilesRemaining = IIf(tilesRemaining > 1, tilesRemaining - 1, 0)
        Else
            Exit Do
        End If
    
    Loop
    If target.Parent.ProtectContents Then target.Locked = True
    Exit Sub
    
cancelled:
    targetRemaining.Value = "..."
    target.Style = "Normal"
    tableReset "E_T_GRID"
    p_gridPending = False
    
End Sub

Private Sub fillGridIndent(target As Range)

    With target
        
        Dim indentFactor As Integer:    indentFactor = indentFactorGet(.Worksheet.Parent)
        Dim indentHorizontal As Byte
                        
        Dim gridRow As Object
        If p_versionServer > cV20 Then
            For Each gridRow In p_tables("E_T_GRID").Rows
                If tLevel(gridRow) Or gridRow("ICON_SHIFT") Then
                    
                    Dim currentCell As Range:   Set currentCell = .Cells(gridRow("Y"), gridRow("X"))
                    'Alignment setting is lost on Refresh..Bugfix
                    If currentCell.HorizontalAlignment = xlHAlignLeft Then
                    ' set horizontal indent
                    indentHorizontal = 2 * gridRow("ICON_SHIFT") + IIf(gridRow("DRILLSTATE") = "L", 2, 0) ' BugFix: Leaf in 3.1c not indented as 3.0b
                    If Mid(gridRow("CONTENT"), 4, 1) <> "X" Then
                        indentHorizontal = indentHorizontal + indentFactor * tLevel(gridRow)
                    End If
                    currentCell.IndentLevel = IIf(indentHorizontal > 15, 15, indentHorizontal)
                    End If
                    
                    ' set vertical indent
                    If Mid(gridRow("CONTENT"), 4, 1) = "X" Then
                        If tLevel(gridRow) Then
                            adaptColumnWidth currentCell, p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQAdjustColumns)
                            currentCell = String(tLevel(gridRow), vbLf) & currentCell
                        End If
                    End If
                'BugFix : Hierarchy node texts on the X-Axis is not indented on the same level
                'as the node.
                Else
                    If Mid(gridRow("CONTENT"), 4, 1) = "X" And gridRow("DRILLSTATE") = "L" Then
                    Set currentCell = .Cells(gridRow("Y"), gridRow("X"))
                    If currentCell.HorizontalAlignment = xlHAlignLeft Then
                    currentCell.IndentLevel = 2
                    End If
                    End If
                End If
            Next gridRow
        Else
            For Each gridRow In p_tables("E_T_GRID").Rows
                indentHorizontal = indentFactor * gridRow("TLEVEL")
                If gridRow("X") = 1 Then ' note Excel bounds: 0 <= indentLevel <= 15
                    If CInt(gridRow("TLEVEL")) Then
                        indentHorizontal = 3 + indentFactor * (CInt(gridRow("TLEVEL")) - 1)
                        .Cells(gridRow("Y"), 1).IndentLevel = IIf(indentHorizontal > 15, 15, indentHorizontal)
                    End If
                End If
            Next gridRow
        End If
    End With

End Sub

Public Function displayProvideRange(ByRef target As Range, newHeight As Long, newWidth As Long) As Boolean

    displayProvideRange = True

    ' beachte sheet-grenzen bei schreiben ergebnis !!
    If target.column + newWidth - 1 > xlMaxColumn Then
        newWidth = xlMaxColumn + 1 - target.column
        userError "spaceMissingColumns", vbInformation
    End If
    If target.row + newHeight - 1 > xlMaxRow Then
        newHeight = xlMaxRow + 1 - target.row
        userError "spaceMissingRows", vbInformation
    End If

    Dim interimWidth As Long
    Dim missingSpace As Range
    Dim dimmedArea As Shape
    Dim userPreference As Integer

    Dim oldHeight As Long:  oldHeight = target.Rows.Count
    Dim oldWidth As Long:   oldWidth = target.Columns.Count

    If newHeight > oldHeight Then
        If oldWidth < newWidth Then interimWidth = oldWidth Else interimWidth = newWidth
        Set missingSpace = target.Resize(newHeight - oldHeight, interimWidth).Offset(rowOffset:=oldHeight)
        If isOccupied(missingSpace) Then
            
            With target
                On Error Resume Next
                Set dimmedArea = ActiveSheet.Shapes.addShape(msoShapeRectangle, .Left, .Top, .Width, .Height)
                On Error GoTo 0
            End With
            If Not dimmedArea Is Nothing Then
            With dimmedArea
                With .Fill
                    .ForeColor.RGB = RGB(255, 0, 0)
                    .Patterned msoPatternDarkUpwardDiagonal
                    .Transparency = 0.5
                End With
                .Line.Visible = False
            End With
            End If
            userPreference = spaceGetUserPreference(True)
            If userPreference > 1 Then
                If userPreference = 4 Then Set missingSpace = missingSpace.EntireRow
                On Error Resume Next
                If userPreference > 2 Then missingSpace.Insert xlDown
                If Err > 0 Then
                    userError "adjustFailed"
                    newHeight = oldHeight
                End If
                On Error GoTo 0
            Else
                newHeight = oldHeight
                displayProvideRange = False
            End If
            If Not dimmedArea Is Nothing Then
            dimmedArea.Delete
            End If
        End If
    End If
    
    If newWidth > oldWidth Then
        Set missingSpace = target.Resize(newHeight, newWidth - oldWidth).Offset(columnOffset:=oldWidth)
        If isOccupied(missingSpace) Then
            
            With target
                On Error Resume Next
                Set dimmedArea = ActiveSheet.Shapes.addShape(msoShapeRectangle, .Left, .Top, .Width, .Height)
                On Error GoTo 0
            End With
            If Not dimmedArea Is Nothing Then
            With dimmedArea
                With .Fill
                    .ForeColor.RGB = RGB(255, 0, 0)
                    .Patterned msoPatternDarkUpwardDiagonal
                    .Transparency = 0.5
                End With
                .Line.Visible = False
            End With
            End If
            userPreference = spaceGetUserPreference(False)
            If userPreference > 1 Then
                If userPreference = 4 Then Set missingSpace = missingSpace.EntireColumn
                On Error Resume Next
                If userPreference > 2 Then missingSpace.Insert xlToRight
                If Err > 0 Then
                    userError "adjustFailed"
                    newWidth = oldWidth
                End If
                On Error GoTo 0
            Else
                newWidth = oldWidth
                displayProvideRange = False
            End If
            If Not dimmedArea Is Nothing Then
                dimmedArea.Delete
            End If
        End If
    End If
    
    Set target = target.Resize(newHeight, newWidth)
    
    If oldHeight > newHeight Then
        With target
        
        If .Parent.UsedRange.SpecialCells(xlCellTypeLastCell).row = .row + oldHeight - 1 Then
            Dim freeArea As Range
      'Bug Fix : When refreshing a query if too many rows then while shifting the
      'Results down, the Excel limit of 65536 rows is exceeded, which gives the error
            On Error GoTo SkipFreeArea
            Set freeArea = target.Offset(newHeight).Resize(oldHeight - newHeight).EntireRow
            If Not isOccupied(freeArea) Then freeArea.Delete
        End If
SkipFreeArea:
        End With
    End If
    
End Function

Private Function spaceGetUserPreference(onRows As Boolean) As Byte

    Dim currentPreference As Integer
    currentPreference = IIf(onRows, g_spaceDefaultRows, g_spaceDefaultCols)
    
    If currentPreference > 0 Then
        spaceGetUserPreference = currentPreference
    Else
        Dim newPreference As Integer
        newPreference = 1
        
        If onRows Then
            p_extErrorFlag = False                                      'VBR:11-054
            If userFormShow(dBEXresizeDown, "captionExtend") Then _
                newPreference = Switch( _
                    dBEXresizeDown.optResizeNone, 2, _
                    dBEXresizeDown.optResizeCellsDown, 3, _
                    dBEXresizeDown.optResizeEntireDown, 4 _
                )
            p_extErrorFlag = True                                       'VBR:11-054
        Else
            If userFormShow(dBEXresizeToRight, "captionExtend") Then _
                newPreference = Switch( _
                    dBEXresizeToRight.optResizeNone, 2, _
                    dBEXresizeToRight.optResizeCellsToRight, 3, _
                    dBEXresizeToRight.optResizeEntireToRight, 4 _
                )
        End If
        spaceGetUserPreference = newPreference
        If onRows Then g_spaceDefaultRows = newPreference Else g_spaceDefaultCols = newPreference
    End If

End Function

Private Sub spaceClearUserPreferences()
    g_spaceDefaultRows = 0
    g_spaceDefaultCols = 0
End Sub

Private Function isOccupied(checkRange As Range) As Boolean

    With checkRange
        If .Columns.Count = 1 And .Rows.Count = 1 And .Areas.Count = 1 Then
            'range is single cell
            isOccupied = (.Value <> "")
        Else
            'range is more complex
            On Error Resume Next ' trap errors of type "no cells found"
            .SpecialCells xlCellTypeConstants
            If Err = 0 Then
                isOccupied = True ' range contains at least one constant cell
            Else
                Err.Clear
                .SpecialCells xlCellTypeFormulas
                isOccupied = (Err = 0) ' range contains at least one formula
                Err.Clear
            End If
        End If
    End With

End Function

Private Function adaptColumnWidth(target As Range, autoFitMode As Integer)

    If autoFitMode Then
        Dim targetColumns As Range
        Select Case autoFitMode
            Case 1: Set targetColumns = target.Columns
            Case 2: Set targetColumns = target.Columns.EntireColumn
        End Select
        With targetColumns
            Dim c As Range
            For Each c In target.Rows(1).Cells
                If Len(c) = 0 Then c = " " ' the following trick won't work for "all-empty" columns!
            Next c
            .ColumnWidth = 150 ' = "very wide", necessary to make AutoFit work with multi-line rows
            .autoFit
        End With
        target.Rows.autoFit
    End If

End Function


Private Sub CheckShapes(iShapePrefix As String)
Dim lShapename As String
Dim lRow As Object
On Error Resume Next
For Each lRow In p_tables("E_T_HRY_DISP").Rows
If lRow("DISP_MODE") = "D" Then

    lShapename = iShapePrefix & lRow("NODEID")
    ActiveSheet.Shapes(lShapename).Delete
End If
Next
End Sub

'Set the user preferences                   ND:5-26
Public Sub spaceSetUserPreferenceRows(preferenceOnRows As Integer)
    g_spaceDefaultRows = preferenceOnRows
End Sub

Public Sub spaceSetUserPreferenceCols(preferenceOnCols As Integer)
    g_spaceDefaultCols = preferenceOnCols
End Sub

'Get the user preferences                   ND:5-26
Public Function spaceGetUserPreferenceRows() As Integer
    spaceGetUserPreferenceRows = g_spaceDefaultRows
End Function

Public Function spaceGetUserPreferenceCols() As Integer
    spaceGetUserPreferenceCols = g_spaceDefaultCols
End Function



Attribute VB_Name = "cBEXdraw"
Option Private Module
Option Explicit

Private Const cGraphTag As String = "SAPBEXg"
Private Const cColor = 16711935 ' = RGB(255, 0, 255) "magenta"

Public g_textOffset As Integer

Public Function drawCheck() As Boolean
    
    Dim myShape As Shape
    For Each myShape In ActiveSheet.Shapes
        If Left(myShape.Name, Len(cGraphTag)) = cGraphTag Then
            drawCheck = True
            Exit Function
        End If
    Next myShape
    drawCheck = False
    
End Function

Public Sub drawUndraw()
    
    screenHalt
    
    Dim myShape As Shape
    For Each myShape In ActiveSheet.Shapes
        If Left(myShape.Name, Len(cGraphTag)) = cGraphTag Then myShape.Delete
    Next myShape
    
    screenRestore
    
End Sub

Public Sub drawQueries()

    Set p_currentRepoSheet = repoGetRepoSheet(ActiveWorkbook, False)
    If p_currentRepoSheet Is Nothing Then Exit Sub
    
    drawUndraw
    
    screenHalt
    
    With p_currentRepoSheet
    
        On Error Resume Next
        Dim i As Long
        Dim myOffset As Integer
        Dim myLastQuery As String
        
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCQ) - 1
            Dim resultArea As Range
            Set resultArea = RunGetResultRange(i)
            If Not resultArea.Worksheet Is ActiveSheet Then Set resultArea = Nothing
            If Not resultArea Is Nothing Then drawRectangle resultArea.Cells(1, 1), resultArea.Cells(resultArea.Rows.Count, resultArea.Columns.Count)
        Next i
        
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
            If .Cells(i, cRepoCDIsStructure) = "" Or .Cells(.Cells(i, cRepoCD), cRepoCQStructFilter) Then
                
                Dim queryName As String
                queryName = .Cells(.Cells(i, cRepoCD), cRepoCQPrefix)
                If myLastQuery <> queryName Then
                    myLastQuery = queryName
                    myOffset = 0
                End If
                
                Dim dstCell As Range
                Set dstCell = Nothing ' reset variable, because next line may fail
                Set dstCell = .names(queryName).RefersToRange.Cells(1, 1)
                If Not dstCell.Worksheet Is ActiveSheet Then Set dstCell = Nothing
                
                Dim srcCell As Range
                Set srcCell = RunGetFilterRange(i)
                If Not srcCell.Worksheet Is ActiveSheet Then Set srcCell = Nothing
                
                If srcCell Is Nothing Then
                    If Not dstCell Is Nothing Then
                        drawRectangle dstCell, dstCell, RunGetFilterAddress(i), myOffset
                        myOffset = myOffset + 1
                    End If
                Else
                    If dstCell Is Nothing Then
                        drawRectangle srcCell, srcCell, Mid(.names(queryName).RefersTo, 2)
                    Else
                        With srcCell
                        drawRectangle .Cells(1, 1), .Cells(.Rows.Count, .Columns.Count)
                        End With
                        drawArrow srcCell, dstCell
                    End If
                End If
            
            End If
        Next i
    
    End With
    
    screenRestore

End Sub

Private Sub drawArrow(srcCell As Range, dstCell As Range)
    
    Dim myArrow As Shape
    Set myArrow = ActiveSheet.Shapes.AddLine( _
        srcCell.Left + 0.5 * srcCell.Width, _
        srcCell.Top + 0.5 * srcCell.Height, _
        dstCell.Left + 0.5 * dstCell.Width, _
        dstCell.Top + 0.5 * dstCell.Height _
    )
    myArrow.Name = cGraphTag & ActiveSheet.Shapes.Count
    With myArrow.Line
        .Weight = 1.5
        .ForeColor.RGB = cColor
        .BeginArrowheadLength = msoArrowheadShort
        .BeginArrowheadWidth = msoArrowheadNarrow
        .BeginArrowheadStyle = msoArrowheadOval
        .EndArrowheadLength = msoArrowheadLengthMedium
        .EndArrowheadWidth = msoArrowheadNarrow
        .EndArrowheadStyle = msoArrowheadTriangle
    End With
    
End Sub

Private Sub drawRectangle(topLeftCell As Range, bottomRightCell As Range, Optional thisText As Variant, Optional thisOffset As Integer)
    
    Dim myRect As Shape
    
    Dim myLeft As Integer: myLeft = topLeftCell.Left
    Dim myTop  As Integer: myTop = topLeftCell.Top
    With bottomRightCell
        Set myRect = ActiveSheet.Shapes.addShape(msoShapeRectangle, _
            myLeft, myTop, .Left + .Width - myLeft, .Top + .Height - myTop)
    End With
    
    With myRect
        .Name = cGraphTag & ActiveSheet.Shapes.Count
        .Fill.Visible = msoFalse
        With .Line
            .Weight = 2
            .ForeColor.RGB = cColor
        End With
        If Not IsMissing(thisText) Then
            .Left = .Left + .Width * 0.5
            .Top = .Top + .Height * (0.5 + thisOffset)
            With .TextFrame
                .Characters.Text = thisText
                .Characters.Font.Color = cColor
                .AutoSize = True
            End With
        End If
    End With
    
End Sub
Attribute VB_Name = "cBEXformatting"
Option Explicit
Option Private Module

Private g_oldActiveSheet As Object ' could be Worksheet or Chart
Private g_oldActiveCell As Range

Public Sub activationBackup(Optional backupRange As Boolean, Optional backupSheet As Boolean = True)
    Set g_oldActiveSheet = IIf(backupSheet, ActiveSheet, Nothing)
    Set g_oldActiveCell = IIf(backupRange, ActiveCell, Nothing)
End Sub

Public Sub activationRestore()
    If Not g_oldActiveSheet Is Nothing Then g_oldActiveSheet.activate
    If Not g_oldActiveCell Is Nothing Then g_oldActiveCell.activate
End Sub

' -----

Public Sub importStyles()

    screenHalt
    activationBackup
    
    Dim importBook As Workbook: Set importBook = p_currentRepoSheet.Parent
    Dim ws As Worksheet
    For Each ws In importBook.Worksheets
        If ws.ProtectContents Then Exit Sub ' can't change styles if any sheet is protected
    Next ws
    Dim helperBook As Workbook: Set helperBook = Workbooks.Add

    Application.displayAlerts = False
    helperBook.Styles.Merge ThisWorkbook
    helperBook.Styles.Merge importBook
    ' helperBook now contains: styles from importBook + missing styles from SAPBEX
    importBook.Styles.Merge helperBook
    Application.displayAlerts = True
    importBook.Colors = ThisWorkbook.Colors

    helperBook.Close saveChanges:=False

    activationRestore
    screenRestore

End Sub

Public Sub setStyle(target As Range, styleName As String, Optional altStyleName As String)
    
    On Error Resume Next
    target.Style = styleName
    If Err <> 0 Then
        Err.Clear
        If Len(altStyleName) Then
            target.Style = altStyleName
            If Err = 0 Then Exit Sub
            Err.Clear
        End If
        importStyles
        target.Style = styleName
        If Err <> 0 Then
            Err.Clear
            target.Style = "Normal"
        End If
    End If
    
End Sub

Public Function setStyles(anchor As Range, gridHeight As Long, gridWidth As Long) As Boolean

    timerStart cTimerFormatResult
    
    activationBackup
    anchor.Worksheet.activate
    On Error Resume Next
    
    Dim rowRanges As Object
    For Each rowRanges In p_tables("E_T_RANGES").Rows

        Dim rowCount As Long
        rowCount = rowCount + 20
        If rowCount > p_tables("E_T_RANGES").Rows.Count Then
            rowCount = rowCount - p_tables("E_T_RANGES").Rows.Count
            MakeProgress
            ' note: calling isCancelled too often (e.g. for every rowRanges) will lock the Cancel button on slow PCs
            If IsCancelled Then
                anchor.Resize(gridHeight, gridWidth).Style = "Normal"
                setStyles = False
                GoTo leave
            End If
        End If
    
        If Len(rowRanges(5)) Then
            If rowRanges(5) = "PANE" Then
                p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQYData) = rowRanges(1)
                p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQXData) = rowRanges(2)
            Else
                If rowRanges(1) <= gridWidth And rowRanges(2) <= gridHeight Then
                    If rowRanges(3) > gridWidth Then rowRanges(3) = gridWidth
                    If rowRanges(4) > gridHeight Then rowRanges(4) = gridHeight
                    Dim thisRange As Range
                    Set thisRange = anchor _
                        .Offset(rowRanges(2) - 1, rowRanges(1) - 1) _
                        .Resize(rowRanges(4) + 1 - rowRanges(2), rowRanges(3) + 1 - rowRanges(1))
                    setStyleExt thisRange, rowRanges(5)
                    If rowRanges(6) = "HH:MM:SS" Then rowRanges(6) = "[h]:mm:ss" 'VBR:11-056
                    If Len(rowRanges(6)) Then thisRange.NumberFormat = rowRanges(6)
                End If
            End If
        End If

    Next rowRanges
    setStyles = True
    
leave:
    tableReset "E_T_RANGES"
    activationRestore
    
    timerStop cTimerFormatResult

End Function

Private Sub setStyleExt(target As Range, styleNameExt As String)
  
    If Len(styleNameExt) Then

        Select Case styleNameExt
        
            Case "NNNN": setStyle target, "SAPBEXstdData"
            Case "NTNN": setStyle target, "SAPBEXaggData"
            Case "TNNN": setStyle target, "SAPBEXstdItem"
            Case "TTNN": setStyle target, "SAPBEXaggItem"
            Case "NNYN": setStyle target, "SAPBEXstdDataEmph"
            Case "NTYN": setStyle target, "SAPBEXaggDataEmph"
    
            Case "CHTX": setStyle target, "SAPBEXchaText"
            
            Case "FMTS": setStyle target, "SAPBEXformats"
            Case "UNDE": setStyle target, "SAPBEXundefined"
    
            Case "TH1N": setStyle target, "SAPBEXHLevel0", "SAPBEXstdItem"
            Case "TH2N": setStyle target, "SAPBEXHLevel1", "SAPBEXstdItem"
            Case "TH3N": setStyle target, "SAPBEXHLevel2", "SAPBEXstdItem"
            Case "TH4N": setStyle target, "SAPBEXHLevel3", "SAPBEXstdItem"
            
            Case "TNNX": setStyle target, "SAPBEXstdItemX", "SAPBEXstdItem"
            Case "TTNX": setStyle target, "SAPBEXaggItemX", "SAPBEXaggItem"
            
            Case "TH1X": setStyle target, "SAPBEXHLevel0X", "SAPBEXstdItem"
            Case "TH2X": setStyle target, "SAPBEXHLevel1X", "SAPBEXstdItem"
            Case "TH3X": setStyle target, "SAPBEXHLevel2X", "SAPBEXstdItem"
            Case "TH4X": setStyle target, "SAPBEXHLevel3X", "SAPBEXstdItem"
            
            Case "TRNN": setStyle target, "SAPBEXresItem"
            Case "NRNN": setStyle target, "SAPBEXresData"
            Case "NRYN": setStyle target, "SAPBEXresDataEmph"
            Case "TRNX": setStyle target, "SAPBEXresItemX", "SAPBEXresItem"
    
            Case Else:
    
                Dim lastChar As String: lastChar = Mid(styleNameExt, 4, 1)
                Select Case lastChar
    
                    Case 1, 2, 3:   setStyle target, "SAPBEXexcGood" & lastChar
                    Case 4, 5, 6:   setStyle target, "SAPBEXexcCritical" & lastChar
                    Case 7, 8, 9:   setStyle target, "SAPBEXexcBad" & lastChar
                    Case Else:      setStyle target, "Normal"
    
                End Select
    
        End Select

    End If

End Sub

'----- handlers for the style tool

Sub adaptAlignments()
    adaptStyles xlDialogAlignment
End Sub

Sub adaptBorders()
    adaptStyles xlDialogBorder
End Sub

Sub adaptFonts()
    adaptStyles xlDialogFormatFont
End Sub

Sub adaptPatterns()
    adaptStyles xlDialogPatterns
End Sub

Private Sub adaptStyles(adaptDialog As Integer)

    Dim adaptRange As Range
    Dim c As Range
    Dim lStylesCollection As New Collection
    
    On Error GoTo nothingSelected
    For Each c In Intersect(Selection, ActiveSheet.UsedRange)
        If Left(c.Style, 6) = "SAPBEX" Then
            If adaptRange Is Nothing Then
                Set adaptRange = c
            Else
                Set adaptRange = Union(adaptRange, c)
            End If
        End If
    Next c
    On Error GoTo 0
    
    If Not adaptRange Is Nothing Then
        adaptRange.Select
        With Application
            If .Dialogs(adaptDialog).Show Then
                screenHalt
                For Each c In adaptRange
                    'Check if the style is already processed, if not only then call adaptStyle  ND:5-027
                    'Improves performance when adapting styles for a large number of cells in the resultset
                    If Not styleAlreadyProcessed(lStylesCollection, c.Style) Then
                        lStylesCollection.Add (CStr(c.Style))
                        adaptStyle c, adaptDialog
                    End If
                Next c
                .ScreenUpdating = True
                screenRestore
            End If
        End With
        Exit Sub
    End If

nothingSelected:
    userError "noStylesFound", vbInformation
        
End Sub

Private Sub adaptStyle(c As Range, adaptDialog As Integer)

    Dim styleName As String:    styleName = c.Style
    
    With c.Worksheet.Parent.Styles(styleName)
        
        .IncludeNumber = False
        .IncludeProtection = False
        
        Select Case adaptDialog
        
        Case xlDialogAlignment:     .IncludeAlignment = True
            
            .Orientation = 1                ' note XL bug: if .Orientation = xlVertical, then assigning .Orientation = xlHorizontal won't work
            .Orientation = c.Orientation
            .IndentLevel = c.IndentLevel    ' note XL bug: IndentLevel must be copied *before* HorzAlignment
            .HorizontalAlignment = c.HorizontalAlignment
            .VerticalAlignment = c.VerticalAlignment
            .WrapText = c.WrapText
            .ShrinkToFit = c.ShrinkToFit
        
        Case xlDialogBorder:        .IncludeBorder = True
            
            adaptBorder .Borders(xlLeft), c.Borders(xlLeft)
            adaptBorder .Borders(xlRight), c.Borders(xlRight)
            adaptBorder .Borders(xlBottom), c.Borders(xlBottom)
            adaptBorder .Borders(xlTop), c.Borders(xlTop)
            adaptBorder .Borders(xlDiagonalDown), c.Borders(xlDiagonalDown)
            adaptBorder .Borders(xlDiagonalUp), c.Borders(xlDiagonalUp)
                    
        Case xlDialogFormatFont:    .IncludeFont = True
            
            Dim myFont As Font
            Set myFont = c.Font
            With .Font
                .Name = myFont.Name
                .Size = myFont.Size
                .Bold = myFont.Bold
                .Italic = myFont.Italic
                .Underline = myFont.Underline
                .Strikethrough = myFont.Strikethrough
                .ColorIndex = myFont.ColorIndex
            End With
        
        Case xlDialogPatterns:      .IncludePatterns = True
            
            Dim myInterior As Interior
            Set myInterior = c.Interior
            With .Interior
                .ColorIndex = myInterior.ColorIndex
                .PatternColorIndex = myInterior.PatternColorIndex
                .Pattern = myInterior.Pattern
            End With
        
        End Select
    
    End With
    
    c.Style = styleName
    
End Sub

Private Sub adaptBorder(outBorder As Border, inBorder As Border)
    
    On Error Resume Next
    With inBorder
        If .LineStyle <> xlNone Then
            outBorder.LineStyle = .LineStyle
            outBorder.Weight = .Weight
        End If
        outBorder.ColorIndex = .ColorIndex
    End With

End Sub

'Check if the style of this cell has already been processed and exists in the collection.   ND:5-027
'If not, then insert the style into the collection and return false
Private Function styleAlreadyProcessed(ByRef styleCollection As Collection, styleName As Style) As Boolean
    Dim i As Integer
    
    For i = 1 To styleCollection.Count
        If styleCollection.Item(i) = styleName Then
            styleAlreadyProcessed = True
            Exit Function
        End If
    Next i
    styleAlreadyProcessed = False
End Function
Attribute VB_Name = "cBEXgis"
Option Explicit
Option Private Module

#If GISFloat Then ' floating window vs. OLEembedded map on sheet
Private g_GISMap As Object
#End If

Private Const g_chartNameTag    As String = "SAPBEXchart"
Private Const g_mapNameTag      As String = "SAPBEXmap"

Public Sub chartInsert(target As Range)

    With target
        With .Worksheet.ChartObjects.Add(.Left, .Top, 400, 240)
        Call .Chart.SetSourceData(target, xlRows)     ' In order to make the Chart accept the 'initial' Value, set it first to xlRows and then back
        Call .Chart.SetSourceData(target, xlColumns)
           
            Dim i As Integer
            i = 1
            Do Until chartFind(i) Is Nothing
                i = i + 1
            Loop
            .Name = g_chartNameTag & i
            p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQChartIndex) = i
        End With
    End With

End Sub

Public Function chartFind(chartIndex As Integer) As ChartObject
    
    Dim chartName As String: chartName = g_chartNameTag & chartIndex
    Dim ws As Worksheet
    For Each ws In p_currentRepoSheet.Parent.Worksheets
        Dim co As ChartObject
        For Each co In ws.ChartObjects
            If co.Name = chartName Then
                Set chartFind = co
                Exit Function
            End If
        Next co
    Next ws

End Function

Public Sub gisInsert(target As Range)
    
    If versionFault Then Exit Sub
    
#If GISFloat Then

    If Not provideComponent(g_GISMap, "wdbmflt2.BExMapflt2", "BExMap ActiveX Dll (wdbmflt2.dll)") Then
        Exit Sub
     Else
        With g_GISMap
            
            .BMQueryId = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix)
            
            repoReadQuery
            If Not gisSetValues(g_GISMap, target.Value) Then
                Set g_GISMap = Nothing
                Exit Sub
            End If
            
            p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQGISIndex) = 1
            If p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) < cV20 Then
                p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) = cV20
            End If
            
            Set .BMParentApplication = Application
            .Run
                                
        End With
    End If

#Else
    
    On Error Resume Next
    With target.Worksheet.Parent.Worksheets.Add
        
        Dim i As Integer
        Do
            i = i + 1
            Err = 0
            If i = 1 Then
                .Name = "BEx Map"    ' there is mainly only one map
              Else
                .Name = "BEx Map " & i
            End If
        Loop Until Err = 0
        
        Dim visRange As Range
        Set visRange = ActiveWindow.VisibleRange
        Set visRange = visRange.Resize(visRange.Rows.Count - 1, visRange.Columns.Count - 1)
        
        With .OLEObjects.Add("wdbmbm2.BExMap2", , , , , , , visRange.Left, visRange.Top, visRange.Width, visRange.Height)
            
            If Err > 0 Then
                userError "installActiveX", , "SAP Business Explorer Map Control (wdbmbm2.ocx)"
                .Delete
                Exit Sub
            Else
            
                Set .Object.BMParentApplication = Application
                .Object.BMQueryId = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix)
                i = 1
                Do Until gisFind(i) Is Nothing
                    i = i + 1
                Loop
                .Placement = xlMoveAndSize
                .Name = g_mapNameTag & i
                
                p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQGISIndex) = i
                If p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) < cV20 Then
                    p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) = cV20 ' require rel. 2.0 for that query!
                End If
                
            End If
            
        End With
        
        repoReadQuery
        ' for GIS performance, this call must not (!) be inside the prior WITH block
        If Not gisSetValues(gisFind(i), target.Value) Then
            .Delete
        Else
            ' cause a repaint to make newly embedded object visible
            target.Worksheet.activate
            .activate
        End If
    
    End With

#End If

End Sub

Public Sub gisRemove()

#If GISFloat Then
    Set g_GISMap = Nothing
#Else
    Dim gisObject As Object:    Set gisObject = gisFind(p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQGISIndex))
    Dim gisSheet As Worksheet:  Set gisSheet = gisObject.Parent
        
    gisObject.Object.Cleanup    ' simulate terminate event
    gisObject.Delete
    gisSheet.Delete
#End If

End Sub

Public Function gisSetValues(mapObject As Object, mapData As Variant) As Boolean
    
    gisSetValues = False

#If GISFloat Then
    With mapObject
        If .BMGlobalData Is Nothing Then
            If provideGlobalLoggedOn Then Set .BMGlobalData = p_bexGlobal
        End If
        
        Set .BMParentApplication = Application
        .BMQueryId = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix)
        
        Set .BMQueryDef = p_tables
        If Not IsArray(mapData) Then
            Dim a(1, 1) As Variant
            a(1, 1) = mapData
            mapData = a
        End If
        .BMResultData = mapData
        If .displayResult Then gisSetValues = True
        Set .BMQueryDef = Nothing
        
    End With
#Else               ' Embedded Map
    With mapObject.Object
        
        If .BMGlobalData Is Nothing Then
            If provideGlobalLoggedOn Then Set .BMGlobalData = p_bexGlobal
        End If
        
        Set .BMParentApplication = Application
        .BMQueryId = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix)
        
        Set .BMQueryDef = p_tables
        If Not IsArray(mapData) Then
            Dim a(1, 1) As Variant
            a(1, 1) = mapData
            mapData = a
        End If
        .BMResultData = mapData
        If .displayResult Then gisSetValues = True
        Set .BMQueryDef = Nothing
        
    End With
    
    ' enforce refresh of map control
    If Application.ScreenUpdating = False Then
        Application.ScreenUpdating = True
        mapObject.Parent.Visible = False
        mapObject.Parent.Visible = True
        Application.ScreenUpdating = False
    End If
    
#End If

End Function

Public Function gisFind(mapIndex As Integer) As Object
#If GISFloat Then
    If Not g_GISMap Is Nothing Then
        If Len(g_GISMap.BMQueryId) = 0 Then Set g_GISMap = Nothing                  ' <---
        Set gisFind = g_GISMap
    End If
#Else
    Dim mapName As String: mapName = g_mapNameTag & mapIndex
    Dim ws As Worksheet
    For Each ws In p_currentRepoSheet.Parent.Worksheets
        Dim mo As Object
        For Each mo In ws.OLEObjects
            If mo.Name = mapName Then
                Set gisFind = mo
                Exit Function
            End If
        Next mo
    Next ws
#End If
End Function

Public Function gisCleanUp(wb As Workbook)

    On Error Resume Next
    
    Dim myObj As OLEObject
    Dim ws As Worksheet
    For Each ws In wb.Worksheets
        For Each myObj In ws.OLEObjects
            If Left(myObj.Name, Len(g_mapNameTag)) = g_mapNameTag Then myObj.Object.Cleanup
        Next myObj
    Next ws
    
End Function
Attribute VB_Name = "cBEXhandler"
Option Explicit
Option Private Module

Private g_userPaused    As Boolean  'flag: do not refresh on query changes ("traffic light" on icon bar)
Private g_rightClickOff As Boolean  'flag: do not show BEx menu on right-click
Private g_warningsOff   As Boolean  'flag: do not show warnings

Private g_trace         As Boolean  'flag: trace mode is on
Private g_traceExists   As Boolean
Private g_trace_env     As Boolean  'flag: env for trace is read

Private g_publisher     As Object

'----- handlers for menu entries

Public Sub launchBrowser()
    launchComponent "wdbbapp.exe", "SAP BEx Browser"
End Sub

Public Sub launchPublisher()
    launchComponent "wdbpwpub.exe", "SAP BEx Publisher"
End Sub

Public Sub launchChecker()
    Workbooks.Add ThisWorkbook.Path & "\sapbexc350710.xla"
End Sub

Private Sub launchComponent(cmdLine As String, compName As String)
    On Error Resume Next
    p_connectionObj.Copy True ' TRUE : use same application server
    Err = 0
    Shell ThisWorkbook.Path & "\" & cmdLine, 1
    If Err Then userError "installActiveX", , compName
    On Error GoTo 0
End Sub

Public Sub embedNewNew()
    queryEmbed False, True, , , cBuilderNew
End Sub

Public Sub deleteQuery()
    If userError("confirmDeleteQuery", vbQuestion + vbYesNo) = vbYes Then queryDelete False, False, True, True, True
End Sub

Public Sub deleteQueries()
    If userError("confirmDeleteQueries", vbQuestion + vbYesNo) = vbYes Then queryDelete True, False, True, True, True
End Sub

Public Sub detachQueries()
    If userError("confirmDetachQueries", vbQuestion + vbYesNo) = vbYes Then queryDelete True, False, False, True, True
End Sub

Public Sub detractQueries()
    If userError("confirmDeleteResults", vbQuestion + vbYesNo) = vbYes Then queryDelete True, True, False, False, False
End Sub

Public Sub saveBookmark()

    Dim wbID As String:         wbID = wbIDgetSavedIn20(ActiveWorkbook)
    If Len(wbID) Then
        userStatusBar "SaveView"
        
        ' for backward compatability: 1.2-workbooks may lack this property!
        repoSetProperty cPropGenUniID, p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQID)
        
        Dim viewID As String:   saveDialogView viewID, wbID
        If Len(viewID) Then rfcSaveView wbID, viewID, , viewID, True
        
        userStatusBar ""
    Else
        trace False, "can't save view - no 2.0 release!"
    End If
    
End Sub

Public Sub saveViewGlobal()
    
    If versionFault(, cV30) Then Exit Sub
    
    With dBEXview
        .reset
        While userFormShow(dBEXview, "captionSaveView")
            Dim overwrite As Boolean
            overwrite = False ' may be reset by rfcSaveView
            If rfcSaveView("", "", .editTechName, .editTitle, overwrite) Then
                GoTo leave
            Else
                If overwrite Then
                    If userError("viewNameExists", vbQuestion + vbYesNo) = vbYes Then
                        rfcSaveView "", "", .editTechName, .editTitle, True
                        GoTo leave
                    End If
                Else
                    Exit Sub
                End If
            End If
        Wend
    End With
    
leave:
    If p_dialogSuccess = 2 Then launchPublisher
    
End Sub

Public Sub launchToWeb()

    Dim menuTagView As String: menuTagView = menuParam
    
    Dim urlParams As String
    If Len(menuTagView) Then
        urlParams = versionStr( _
            "&data_provider_id=" & menuTagView, _
            "&viewid=" & translate(menuTagView, " ", "%20") & "&wbid=" & storageGetWBID(ActiveWorkbook) _
            )
    Else
        Dim compID As String
        Dim cubeID As String
        If rfcTranslateQueryIDInv(p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQID), compID, cubeID) Then
            urlParams = "&infocube=" & cubeID & "&query=" & compID
        Else
            userError "noGenUniID"
            Exit Sub
        End If
    End If

    If Len(p_URLprefix) = 0 Then
        If Not rfcGenerateURLprefix Then
            userError "noWebConnection"
        End If
    End If
    internetBrowserLaunch p_URLprefix & urlParams

End Sub

Public Sub attachExceptions()
    displayCons cConTypeException
End Sub

Public Sub attachConditions()
    displayCons cConTypeCondition
End Sub

Public Sub attachTEall()
    attachTextelements "*"
End Sub

Public Sub attachTEgeneral()
    attachTextelements "C"
End Sub

Public Sub attachTEfilters()
    attachTextelements "F"
End Sub

Public Sub attachTEvariables()
    attachTextelements "V"
End Sub

Private Sub attachTextelements(selectGroup As String)
    If ensureRefreshed Then
    
        If selectGroup = "F" Then
            RunProcessTextElements selectGroup, "X"
        Else
            RunProcessTextElements selectGroup
        End If
    End If
End Sub

Public Sub attachChart()
    Dim target As Range: Set target = RunGetTarget
    If Not target Is Nothing Then chartInsert target
End Sub

Public Sub attachGIS(Optional refreshOnly As Boolean)
    If ensureRefreshed Then
        If Not refreshOnly Then
            Dim target As Range: Set target = RunGetResultRange(p_currentQueryIndex)
            If Not target Is Nothing Then gisInsert target
        End If
    End If
End Sub
    
Private Function ensureRefreshed() As Boolean
    If Not isConnected(True) Then
        If userError("refreshFirst", vbQuestion + vbYesNo, vbNewLine & userText("refresh?")) = vbNo Then Exit Function
        RunQuery True
    End If
    ensureRefreshed = True
End Function
    
'----- handlers which require a selected query

Public Sub queryBack()

    If noUnprotectedActiveSheet Then Exit Sub
    
    Dim bbsBackTarget As String:    bbsBackTarget = name2string(ActiveWorkbook.names, xlnameBBSback)
    If Len(bbsBackTarget) > 0 Then
        ' workbook has been created in a report-report-jump, and has not yet been used to navigate -> back to old workbook
        ActiveWorkbook.Close False
        On Error Resume Next
        Application.Workbooks(bbsBackTarget).activate
        Exit Sub
    End If
    
    If repoDetectQueryDefault Then
        If isConnected(True, True) Then
            If contextSetSelection Then contextSAP "BACK"
        End If
    Else
        userError "noQuerySelected", vbExclamation
    End If

End Sub

Public Sub queryRefresh()

    trace False, "queryRefresh start 0"
    isConnected
    trace False, "queryRefresh start 1"

    If Not ActiveWorkbook Is Nothing Then
        Dim viewName  As String:    viewName = name2string(ActiveWorkbook.names, xlnameDownload)
        If Len(viewName) Then
            queryJump cJumpViewGlobal, viewName, True
            Exit Sub
        End If
    End If
    
    If noUnprotectedActiveSheet Then Exit Sub
    If repoDetectQueryDefault Then
        RunQuery
        
        'Refresh the filter text elements also when the query is refreshed      ND:5-26
        'Do not refresh the filter text elements for a workbook when a query in a workbook
        'is refreshed :done to avoid problems with workbook formatting
        On Error Resume Next
        Application.ActiveWorkbook.names.Item ("SAPBEXwbID")
        If Err > 0 Then
            runProcessFilterTextElems
        End If
        
    Else
        If ActiveWorkbook Is Nothing Or p_currentRepoSheet Is Nothing Then
            userError "noQuerySelected"
        Else
            If userError("refreshWorkbook", vbQuestion + vbYesNo) = vbYes Then RunQueriesInWorkbook ActiveWorkbook
        End If
    End If

    trace False, "queryRefresh end 0"
    isConnected
    trace False, "queryRefresh end 1"

End Sub


Public Sub queryRefreshNewVars()

    RunQuery , , , True
        
    'Refresh the filter text elements also when the query is refreshed         ND:5-26
    'Do not refresh the filter text elements for a workbook when a query in a workbook
    'is refreshed :done to avoid problems with workbook formatting
    On Error Resume Next
    Application.ActiveWorkbook.names.Item ("SAPBEXwbID")
    If Err > 0 Then
        runProcessFilterTextElems
    End If

End Sub

Public Sub queryChangeGlobal()
    queryChange cBuilderLarge
End Sub

Public Sub queryChangeLocal()
    If Not isConnected(False, False, True) Then ' for security reasons, a prior "refresh" is necessary
        If userError("refreshFirst", vbQuestion + vbYesNo, vbNewLine & userText("refresh?")) = vbNo Then Exit Sub
        RunQuery True
    End If
    queryChange cBuilderSmall
End Sub

Public Sub queryDefineExceptions()
    If isConnected(True) Then contextSAP "ENEW" Else queryDefineWithDefaults "ENEW"
End Sub

Public Sub queryDefineConditions()
    If isConnected(True) Then contextSAP "CNEW" Else queryDefineWithDefaults "CNEW"
End Sub

Public Sub queryDefineWithDefaults(fCode As String, Optional eltuid As String)
    Select Case fCode
        Case "CNEW": queryChange cBuilderConditions, eltuid
        Case "ENEW": queryChange cBuilderExceptions, eltuid
    End Select
End Sub

Public Sub queryChange(changeMode As Byte, Optional eltuid As String)

    If repoReadQuery Then
        
        With p_currentRepoSheet
                
            userStatusBar "Change"
    
            Dim deleteOld As Boolean
            Dim queryID As String
            queryID = .Cells(p_currentQueryIndex, cRepoCQID)
            
            If Build(queryID, changeMode, deleteOld, "", eltuid) Then
                
                If deleteOld Then
                    rfcCloseQuery .Cells(p_currentQueryIndex, cRepoCQHandle)
                    .Cells(p_currentQueryIndex, cRepoCQHandle) = 0
                    queryDelete False, False, True, (Len(queryID) = 0), False
                End If
                
                If Len(queryID) Then
                    .Cells(p_currentQueryIndex, cRepoCQID) = queryID
                    repoWriteQuery True
                    displayResult RunGetResultRange(p_currentQueryIndex)
                    If deleteOld Then RunQuery Else RunQueryConditioned True
                End If
                
            End If
            userStatusBar ""
                
        End With
        
    End If

End Sub

'----- handlers for menu controls which change their state

Sub toggleGotoRepeat()
    With p_currentRepoSheet
        .Cells(p_currentQueryIndex, cRepoCQGotoRepeat) = Not .Cells(p_currentQueryIndex, cRepoCQGotoRepeat)
    End With
End Sub
            
Sub togglePause()
    If g_userPaused Then
        Dim wb As Workbook
        For Each wb In Application.Workbooks
            RunQueriesInWorkbook wb, True, True
        Next wb
    End If
    g_userPaused = Not g_userPaused
End Sub

Sub toggleRClick()
    g_rightClickOff = Not g_rightClickOff
End Sub

Sub toggleWarnings()
    If checkWarningDialog Then warningsOff Else warningsOn
End Sub

Public Sub toggleTrace()
    If g_trace Then traceOff Else traceOn
End Sub




Public Function checkTrace(Optional traceExists As Boolean) As Boolean
    If g_trace_env = False Then
        g_trace_env = True
        
        Dim SAPBEX_TRACE As String
        SAPBEX_TRACE = Environ("SAPBEX_TRACE")
        If SAPBEX_TRACE = "1" Then
            If provideGlobal Then
                p_bexGlobal.OpenTracefile TempTraceFile
                g_trace = True
                g_traceExists = True
            Else
                g_trace = False
            End If
        End If
    End If
    checkTrace = IIf(traceExists, g_traceExists, g_trace)
End Function
    
    

Private Sub traceOn()
    
    If isConnected Then dialOut
    
    If provideGlobal Then
        p_bexGlobal.OpenTracefile TempTraceFile
        g_trace = True
        g_traceExists = True
    Else
        g_trace = False
    End If
    
    timerInit
    
End Sub

Public Sub traceContinue()
    
    If checkTrace Then
        If provideGlobal Then
            p_bexGlobal.OpenTracefile TempTraceFile
        Else
            g_trace = False
        End If
    End If

End Sub

Private Sub traceOff()
    If Not p_bexGlobal Is Nothing Then p_bexGlobal.CloseTracefile
    g_trace = False
End Sub

Public Sub traceShow()
    If Not p_bexGlobal Is Nothing Then p_bexGlobal.flushtrace
    Shell "notepad.exe " & TempTraceFile(True), 1
End Sub

Public Sub trace(isheader As Boolean, textLine As String)
    If checkTrace Then
        If Not p_bexGlobal Is Nothing Then
            With p_bexGlobal
                .setactivecomponent "XLA", ThisWorkbook.CustomDocumentProperties!Version
                .trace 2, IIf(isheader, Format(Now, "hh:mm:ss "), vbTab & "- ") & textLine
                .flushtrace
            End With
        End If
    End If
End Sub

Public Function checkGotoRepeat() As Boolean
    checkGotoRepeat = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQGotoRepeat)
End Function
            
Public Function checkPause() As Boolean
    checkPause = g_userPaused
End Function

Public Function checkRClick() As Boolean
    checkRClick = Not g_rightClickOff
End Function

Public Function templateState() As String
    Dim myState As String
    myState = RegistryGet("chooseTemplate")
    templateState = IIf(Len(myState), myState, cTemplatePermanent)
End Function

Sub templateEmpty()
    RegistrySet "chooseTemplate", cTemplateEmpty
End Sub

Sub templateChoose()
    RegistrySet "chooseTemplate", cTemplateChoose
End Sub

Sub templatePermanent()
    RegistrySet "chooseTemplate", cTemplatePermanent
End Sub

Public Function checkShapeSelected() As Boolean
    checkShapeSelected = False
    On Error Resume Next
    checkShapeSelected = (Selection.Parent.Shapes(Selection.Name) = Selection.Name)
End Function

Public Sub warningsOn()
    RegistrySet "showErrors", ""
End Sub

Public Sub warningsOff()
    RegistrySet "showErrors", "N"
End Sub

Public Function checkWarningDialog() As Boolean
    checkWarningDialog = RegistryGet("showErrors") <> "N"
End Function
Attribute VB_Name = "cBEXmenu"
Option Explicit
Option Private Module

Public Sub maintainToolbar()

    userStatusBar "Init"
    
    RegistrySet "path", ThisWorkbook.Path, True

    On Error Resume Next
    CommandBars(cProductName).Delete
    CommandBars(cProductNameOld).Delete
    On Error GoTo 0

    With CommandBars("xxxSAPBEXxxx")
        .Name = cProductName
        If RegistryGet("toolBar\pos") = "" Then
            .Position = msoBarFloating
        Else
            .Position = RegistryGet("toolBar\pos")
            On Error Resume Next
            .rowIndex = RegistryGet("toolBar\rowindex")
            'Position of toolbar shifts on opening the BEx Analyzer                 VBR: 06:029
            'Strangely when assigning the value of RegistryGet("toolBar\rowindex")
            'to .rowindex, value reduces by 1
            If .rowIndex <> RegistryGet("toolBar\rowindex") Then
                .rowIndex = .rowIndex + 1
            End If

            On Error GoTo 0
            .Left = RegistryGet("toolBar\left")
            .Top = RegistryGet("toolBar\top")
        End If
        Dim myButton As CommandBarControl
        For Each myButton In .Controls  ' set tooltips language-dependent
            myButton.TooltipText = userText("menu" & myButton.caption)
            myButton.onAction = "menuIconClicked"
        Next myButton
        .Visible = True
    End With
    
    With CommandBars(1)
        On Error Resume Next
        .Controls(cProductName).Delete
        On Error GoTo 0
        With .Controls.Add(Type:=msoControlButton, before:=.Controls.Count, temporary:=True)
            .caption = cProductName
            .Style = msoButtonCaption
            .onAction = "menuIconClicked"
        End With
    End With
    
    Set p_appEventClass.myAppEvents = Application ' enable events
    
    userStatusBar ""

End Sub
    
'----- menus which drop down from the toolbar

Public Sub popupFromToolBar(toolBar As CommandBar)
    With Application.CommandBars
        If .ActionControl Is Nothing Then
            toolBar.ShowPopup
        Else
            With .ActionControl
                toolBar.ShowPopup '.Left, .Top + .Height
            End With
        End If
    End With
End Sub

Public Sub menuIconClicked()

    'Excel Crash problem : Excel crashes after closing a workbook and then clicking the toolbar icon.
    'workaround is to open and close a workbook before this action prevents the crash
    If Application.Workbooks.Count = 0 Then
         Application.ScreenUpdating = False
         Dim l_workbook As New Workbook
         Set l_workbook = Application.Workbooks.Add
         l_workbook.Close False
         Application.ScreenUpdating = True
    End If
    
    p_currentQueryIndex = 0
    p_currentFilterIndex = 0
    p_currentConFacIndex = 0
    Set p_currentSelection = Nothing

    Dim actionName As String:       actionName = Application.CommandBars.ActionControl.caption
    Dim actionHandler As String:    actionHandler = menuGetHandler(actionName)

    If Len(actionHandler) Then Application.Run actionHandler Else menuShow actionName

End Sub

Public Sub menuShow(actionName As String)

    On Error GoTo leave ' commandbars.add may fail if BEx toolbar is shown in an embedded Excel
    Dim myToolbar As CommandBar:    Set myToolbar = CommandBars.Add(Position:=msoBarPopup, temporary:=True)
    With myToolbar
        menuGetControls actionName, .Controls
        If .Controls.Count > 0 Then popupFromToolBar myToolbar
        .Delete
    End With
    Exit Sub
leave:

End Sub

Private Function menuGetHandler(itemName As String) As String

    Select Case itemName
        Case "RefreshNow":  menuGetHandler = "queryRefresh"
        Case "Undo":        menuGetHandler = "queryBack"
    End Select

End Function

Private Sub menuGetControls(itemName As String, itemControls As CommandBarControls, Optional silent As Boolean)

Dim lpath As String                                     ' VBR
lpath = "C:\Program Files\SAP\FrontEnd\Bw\"             ' VBR

    Select Case itemName
        Case "Context"
            If p_currentFilterIndex Then
                menuFillFilter itemControls, silent
            Else
                If p_currentSelection Is Nothing Then
                    If p_currentConFacIndex Then
                        menuFillConfac itemControls, silent
                    Else
                        menuFillDefaults itemControls, silent
                    End If
                Else
                    menuFillResult itemControls, silent
                End If
            End If
        Case "Open":        menuFillOpen itemControls, silent
        Case "Save":        menuFillSave itemControls, silent
        Case "Refresh":     menuFillRefresh itemControls, silent
        Case "Navigate":    menuFillNavigate itemControls, silent
        Case "Goto":        menuFillGoto itemControls, silent
        Case "ContextMenu": menuFillContext itemControls, silent
        Case "Styles":      menuFillFormat itemControls, silent
        Case "Layout":      menuFillLayout itemControls, silent
        Case "Tools":       menuFillTools itemControls, silent
        Case "Status":      menuFillStatus itemControls, silent
        Case "Help":        menuFillHelp itemControls, silent
        Case cProductName
            ' simulate toolbar as menu
            On Error Resume Next
            Dim myToolbar As CommandBar:    Set myToolbar = CommandBars(cProductName)
            If Err Then Exit Sub ' tool bar has been deleted?
            Dim myButton As CommandBarButton
            For Each myButton In myToolbar.Controls
                Dim actionHandler As String:    actionHandler = menuGetHandler(myButton.caption)
                If Len(actionHandler) Then
                    userMenu itemControls, myButton.caption, actionHandler, myButton.beginGroup
                Else
                    With userSubMenu(itemControls, myButton.caption, myButton.beginGroup)
                        menuGetControls myButton.caption, .Controls, True
                        If .Controls.Count = 0 Then .Enabled = False
                    End With
                End If
            Next myButton

            If Len(Dir(ThisWorkbook.Path & "\wdbbapp.exe")) = 0 Then
                userMenu itemControls, "", "launchBrowser", True, Len(Dir(lpath & "\wdbbapp.exe")) = 0, , , cProductNameB
            Else
                userMenu itemControls, "", "launchBrowser", True, Len(Dir(ThisWorkbook.Path & "\wdbbapp.exe")) = 0, , , cProductNameB
            End If
            If Len(Dir(ThisWorkbook.Path & "\wdbpwpub.exe")) = 0 Then
                userMenu itemControls, "", "launchPublisher", , Len(Dir(lpath & "\wdbpwpub.exe")) = 0, , , cProductNameP
            Else
                userMenu itemControls, "", "launchPublisher", , Len(Dir(ThisWorkbook.Path & "\wdbpwpub.exe")) = 0, , , cProductNameP
            End If
            
            userMenu itemControls, "", "launchChecker", , Len(Dir(ThisWorkbook.Path & "\sapbexc350710.xla")) = 0, , , cProductNameC
            
    End Select

End Sub

Private Sub menuFillOpen(myControls As CommandBarControls, Optional silent As Boolean)

    userMenu myControls, "TreeWorkbooks", "openWorkbook"
    userMenu myControls, "TreeQueries", "openQueryNewBook"
    userMenu myControls, "TreeViews", "openViews"
    userMenu myControls, "TreeAlerts", "openAlertsAll", False, versionFault(True)
    
End Sub

Private Sub menuFillSave(myControls As CommandBarControls, Optional silent As Boolean)

    Dim wb As Workbook: Set wb = ActiveWorkbook
    Dim noActiveBook As Boolean
    Dim wbID As String
    If wb Is Nothing Then noActiveBook = True Else wbID = storageGetWBID(wb)
        
    userMenu myControls, "SaveAsNew", "saveNewWorkbook", False, noActiveBook
    userMenu myControls, "SaveExist", "saveNewContent", False, Len(wbID) = 0
    userMenu myControls, "Title", "saveNewTitle", True, Len(wbID) = 0
    
    Dim noBookmarks As Boolean
    If noActiveBook Or versionFault(True) Then
        noBookmarks = True
    Else
        If repoDetectQueryDefault Then
            noBookmarks = isTransient
        Else
            noBookmarks = True
        End If
    End If
    userMenu myControls, "SaveBookmark", "saveBookmark", True, noBookmarks
    userMenu myControls, "SaveViewGlobal", "saveViewGlobal", False, noBookmarks Or versionFault(True, cV30)

End Sub

Private Sub menuFillContext(myControls As CommandBarControls, Optional silent As Boolean)
    
    If noUnprotectedActiveSheet(silent) Then Exit Sub
    
    Dim selectedRange As Range
    Set selectedRange = IIf(TypeName(Selection) = "Range", Selection, ActiveCell)
    
    If contextCheck(ActiveSheet, selectedRange) Then
        menuGetControls "Context", myControls, silent
    Else
        If Not silent Then userError "noQueryCell", vbExclamation
    End If

End Sub

Private Sub menuFillRefresh(myControls As CommandBarControls, Optional silent As Boolean)
    userMenu myControls, "RefreshNow", "runQuery", True
End Sub

Private Sub menuFillNavigate(myControls As CommandBarControls, Optional silent As Boolean)

    If noUnprotectedActiveSheet(silent) Then Exit Sub

    If Not repoDetectQueryDefault Then
        If Not silent Then userError "noQuerySelected", vbExclamation
        Exit Sub
    End If
    
    Dim noNavigation As Boolean:    noNavigation = Not p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQInteractive)
    Dim no20Navigation As Boolean:  no20Navigation = noNavigation Or versionFault(True)
    
    userMenu myControls, "ChangeLocal", "queryChangeLocal", True, noNavigation
    userMenu myControls, "ChangeGlobal", "queryChangeGlobal", False, noNavigation
    ' the following two functions are only supported as of 3.0, patch ...
    ' userMenu myControls, "Exceptions", "queryDefineExceptions", True, no20Navigation
    ' userMenu myControls, "Conditions", "queryDefineConditions", False, no20Navigation
    userMenu myControls, "RefreshNewVars", "queryRefreshNewVars", True
    
End Sub

Private Sub menuFillGoto(myControls As CommandBarControls, Optional silent As Boolean)

    If noUnprotectedActiveSheet(silent) Then Exit Sub

    If Not repoDetectQueryDefault Then
        If Not silent Then userError "noQuerySelected", vbExclamation
        Exit Sub
    End If
    
    If isConnected(True, True) Then
    
        If versionFault(silent) Then Exit Sub
        
        userStatusBar "Menu"
        userMenu myControls, "Alerts", "openAlertsContext"
        With p_currentRepoSheet

            Dim wbID As String:     wbID = storageGetWBID(ActiveWorkbook)
            Dim lastGoto As String: lastGoto = .Cells(p_currentQueryIndex, cRepoCQGoto)
            Dim gotoTag As String
            If isConnected(True, True) Then

                Dim newGroup As Boolean
            
                newGroup = True
                If Len(wbID) Then
                    Dim myRow As Object
                    If rfcGetViewList(wbID, .Cells(p_currentQueryIndex, cRepoCQID)) Then
                        For Each myRow In p_tables("E_T_ITEMS").Rows
                            If Len(myRow("ITEMID")) = 0 Then
                                gotoTag = versionStr(cJumpExtViewGlobal, cJumpExtView) & myRow(versionStr("VIEWIDGLOBAL", "VIEWID"))
                                userMenu myControls, "", "contextJump", newGroup, False, gotoTag, gotoTag = lastGoto, myRow("VIEWID")
                                newGroup = False
                            End If
                        Next myRow
                    End If
                End If

                newGroup = True
                If rfcGetReceiverList(.Cells(p_currentQueryIndex, cRepoCQID)) Then
                    For Each myRow In p_tables("C_T_RRI").Rows
                        If myRow("ISFOLDER") = "0" Then
                            gotoTag = cJumpExtRepRep & myRow("RECEIVER")
                            userMenu myControls, "", "contextJump", newGroup, False, gotoTag, gotoTag = lastGoto, myRow("TEXT")
                            newGroup = False
                        End If
                    Next myRow
                End If

            End If

        End With
        userMenu myControls, "GotoRepeat", "toggleGotoRepeat", True, , , checkGotoRepeat
        userStatusBar ""
    
    Else
        menuFillDefaults myControls, silent
    End If
    
End Sub

Private Sub menuFillFormat(myControls As CommandBarControls, Optional silent As Boolean)
    
    If noUnprotectedActiveSheet(silent, True) Then Exit Sub
    
    Dim ws As Worksheet
    Dim noStyleChanges As Boolean
    noStyleChanges = False
    For Each ws In ActiveSheet.Parent.Worksheets
        If ws.ProtectContents Then noStyleChanges = True
    Next ws
    
    userMenu myControls, "Fonts", "adaptFonts", True, noStyleChanges
    userMenu myControls, "Patterns", "adaptPatterns", False, noStyleChanges
    userMenu myControls, "Borders", "adaptBorders", False, noStyleChanges
    userMenu myControls, "Alignments", "adaptAlignments", False, noStyleChanges
    
    With userSubMenu(myControls, "HierarchyShapes", True, checkShapeSelected)
        If .Enabled Then
            userMenu .Controls, "ShapeExpand", "standardShapeSet", False, False, shapeNamePlus
            userMenu .Controls, "ShapeCompress", "standardShapeSet", False, False, shapeNameMinus
            userMenu .Controls, "ShapeExpandExt", "standardShapeSet", False, False, shapeNameMinusX
            userMenu .Controls, "ShapeLinkDoc", "standardShapeSet", False, False, shapeNameLinkDoc
            ' userMenu .Controls, "ShapeLinkBOR", "standardShapeSet", False, False, shapeNameLinkBor
        End If
    End With
        
    With userSubMenu(myControls, "HierarchyIndent")
        Dim indentFactor As Integer:    indentFactor = indentFactorGet(ActiveWorkbook)
        Dim i As Integer
        For i = 1 To 4
            With .Controls.Add(Type:=msoControlButton)
                .onAction = "indentFactorSet"
                .tag = i
                .caption = userText("constIndent" & i)
                .state = buttonState(i = indentFactor)
            End With
        Next i
    End With
    
End Sub

Private Sub menuFillLayout(myControls As CommandBarControls, Optional silent As Boolean)
    
    If noUnprotectedActiveSheet(silent, True) Then Exit Sub

    Dim noSelectedQuery As Boolean: noSelectedQuery = Not repoDetectQueryDefault
    
    Dim noQuery As Boolean
    If p_currentRepoSheet Is Nothing Then
        noQuery = True
    Else
        noQuery = (p_currentRepoSheet.Cells(cRepoRCounts, cRepoCQ) = 0)
    End If
    If noQuery Then
        If Not silent Then userError "noQueryInBook", vbExclamation
        Exit Sub
    End If
    
    Dim noSelected20query As Boolean: noSelected20query = noSelectedQuery Or versionFault(True)
    
    Dim noGISavailable As Boolean
    If noSelected20query Then
        noGISavailable = True
    Else
        With p_currentRepoSheet
            noGISavailable = True
            If .Cells(p_currentQueryIndex, cRepoCQGISIndex) <> 0 Then
                noGISavailable = gisFind(.Cells(p_currentQueryIndex, cRepoCQGISIndex)) Is Nothing
            End If
        End With
    End If
    
    If Not ActiveCell Is Nothing Then ActiveCell.Select
    
    userMenu myControls, "AttachChart", "attachChart", False, noSelectedQuery
    If noGISavailable Then
        userMenu myControls, "AttachGIS", "attachGIS", False, noSelected20query
    Else
        userMenu myControls, "RemoveGIS", "gisRemove"
    End If
    
    With userSubMenu(myControls, "TextElements", True, noSelectedQuery)
        If .Enabled Then
            userMenu .Controls, "TEall", "attachTEall"
            userMenu .Controls, "TEgeneral", "attachTEgeneral", True
            userMenu .Controls, "TEfilters", "attachTEfilters"
            userMenu .Controls, "TEvars", "attachTEvariables"
        End If
    End With
    userMenu myControls, "DExceptions", "attachExceptions", False, noSelected20query
    userMenu myControls, "DConditions", "attachConditions", False, noSelected20query
    
    userMenu myControls, "MoveQuery", "queryMove", True, noSelectedQuery
    userMenu myControls, "MoveFilter", "queryMoveFilter", False, p_currentFilterIndex = 0
    
    Dim drawn As Boolean: drawn = drawCheck
    userMenu myControls, "Draw", IIf(drawn, "drawUndraw", "drawQueries"), True, ActiveSheet.ProtectDrawingObjects Or noQuery, , drawn

End Sub

Private Sub menuFillTools(myControls As CommandBarControls, Optional silent As Boolean)

    Dim noSheet As Boolean: noSheet = noUnprotectedActiveSheet(True, True)
    Dim lWbid As String
    Dim noSelectedQuery As Boolean
    Dim noQuery As Boolean
    Dim transientQuery As Boolean
    
    If noSheet Then
        noSelectedQuery = True
        noQuery = True
    Else
        If repoDetectQueryDefault Then
            noSelectedQuery = False
            transientQuery = isTransient
        Else
            noSelectedQuery = True
        End If
        If p_currentRepoSheet Is Nothing Then ' p_currentRepoSheet was set by detectQueryDefault !
            noQuery = True
        Else
            noQuery = (p_currentRepoSheet.Cells(cRepoRCounts, cRepoCQ) = 0)
        End If
    End If
    
    If Not ActiveCell Is Nothing Then ActiveCell.Select
    
    With userSubMenu(myControls, "WebLaunch", True, versionFault(True) Or noSelectedQuery Or transientQuery)
        If .Enabled Then
            Dim wbID As String: wbID = storageGetWBID(ActiveWorkbook)
            If Len(wbID) And isConnected Then
                Dim myRow As Object
                If rfcGetViewList(wbID, "") Then
                    For Each myRow In p_tables("E_T_ITEMS").Rows
                        If Len(myRow("ITEMID")) = 0 Then
                            userMenu .Controls, "", "launchToWeb", , , myRow(versionStr("VIEWIDGLOBAL", "VIEWID")), , myRow("VIEWID")
                        End If
                    Next myRow
                End If
            End If
            userMenu .Controls, "QueryDefault", "launchToWeb", True, versionFault(True) Or noSelectedQuery
        End If
    End With
    
    userMenu myControls, "Builder", "embedNewNew", True
    userMenu myControls, "InsertQuery", "openQueryInsert", False, noSheet
    userMenu myControls, "CopyQuery", "queryCopy", False, noSelectedQuery
    userMenu myControls, "DeleteQuery", "deleteQuery", True, noSelectedQuery
    With userSubMenu(myControls, "AllQueries", , noQuery)
        If .Enabled Then
            userMenu .Controls, "DeleteQueries", "deleteQueries"
            userMenu .Controls, "DeleteResults", "detractQueries"
            userMenu .Controls, "DetachQueries", "detachQueries"
        End If
    End With

' BW3.5 Broadcasting
    lWbid = storageGetWBID(ActiveWorkbook)
    If Broadcastactive And Len(lWbid) > 0 Then
      userMenu myControls, "BroadCasting", "BroadCasting", False, False, lWbid, False, BroadCastTitle
    End If
    userMenu myControls, "Protection", "changeProtection", True, noUnprotectedActiveSheet(True, False)
End Sub
Private Function Broadcastactive() As Boolean
    If p_bexGlobal Is Nothing Then
        Broadcastactive = False
    Else
        On Error Resume Next    'only for 3.0 relevant
        Broadcastactive = p_bexGlobal.BroadcasterAvailable
        On Error GoTo 0
    End If
End Function
Private Function BroadCastTitle() As String
    BroadCastTitle = p_bexGlobal.R3Text("ID_EDT_MNU_BROADCAST_XLS", "Distribute Workbook...")
End Function
Private Function BroadCastURL(ByVal iWbid As String) As String
    BroadCastURL = p_bexGlobal.Urlprefix & "cmd=start_broadcaster&source_workbook=" & iWbid
End Function
Public Sub Broadcasting()
    Call internetBrowserLaunch(BroadCastURL(iWbid:=storageGetWBID(ActiveWorkbook)))
End Sub
Private Sub menuFillStatus(myControls As CommandBarControls, Optional silent As Boolean)
    
    Set p_appEventClass.myAppEvents = Application ' enable events
    
    userMenu myControls, "Pause", "togglePause", , , , checkPause
    
    Dim loggedOn As Boolean: loggedOn = isConnected
    userMenu myControls, "Logon", IIf(loggedOn, "dialOut", "dialIn"), True, , , loggedOn
    userMenu myControls, "SysInfo", "dialInInfo", False, Not loggedOn
    
    With userSubMenu(myControls, "Template", True)
        userMenu .Controls, "TemplateEmpty", "templateEmpty", , , , templateState = cTemplateEmpty
        userMenu .Controls, "TemplateChoose", "templateChoose", , , , templateState = cTemplateChoose
        userMenu .Controls, "TemplatePermanent", "templatePermanent", , , , templateState = cTemplatePermanent
    End With
    userMenu myControls, "TemplateStatic", "storageTemplateSet", False
    
    userMenu myControls, "RClick", "toggleRClick", True, , , checkRClick
    userMenu myControls, "WarningsOff", "toggleWarnings", False, , , Not checkWarningDialog
    
    userMenu myControls, "ToggleDebug", "toggleTrace", True, , , checkTrace
    userMenu myControls, "ShowDebug", "traceShow", False, Not checkTrace(True)
    
End Sub

Private Sub menuFillHelp(myControls As CommandBarControls, Optional silent As Boolean)
    userMenu myControls, "OnlineHelp", "userHelp"
    userMenu myControls, "About", "aboutBox"
End Sub

Attribute VB_Name = "cBEXopen"
Option Explicit

Private g_openDialog            As Object
Private g_saveDialog            As Object
Private g_openSave20            As Object
Private g_optionsList           As Object

Private Const cNewQueryGUID      As String = "!NEW"

Private Const cTreeWorkbook      As Byte = 1
Private Const cTreeQuery         As Byte = 2
Private Const cTreeAlert         As Byte = 3
Private Const cTreeView          As Byte = 4

Private Const cTreeQueryEdit    As Byte = 202       ' return value only

Private Const osOK              As Integer = 1
Private Const osCancel          As Integer = 2
Private Const osCreate          As Integer = 3
Private Const osChange          As Integer = 4

Private Const os3Cancel         As String = ""
Private Const os3OK             As String = "00"
Private Const os3Display        As String = "01"
Private Const os3Change         As String = "02"
Private Const os3Create         As String = "03"
'Private Const os3Delete         As String = "04"

Public Sub openSaveDestroy()
    destroyComponent g_openDialog
    destroyComponent g_saveDialog
    destroyComponent g_openSave20
End Sub

Private Function openSaveDialog20(treeID As Long, folderSelection As Boolean, ByVal captionName As String, Optional newName As String, Optional filter As String) As String

    If Not dialIn Then Exit Function
    
    If p_versionServer < cV20 Then
        If folderSelection Or Not (treeID = cTreeWorkbook Or treeID = cTreeQuery) Then
            userError "require20version"
            Exit Function
        End If
    End If
    
    If Not provideComponent(g_openSave20, "SAPBWObjectBrowser.BExOpenSaveDialog", "Open/Save Dialog") Then Exit Function
    If Not provideGlobalLoggedOn Then Exit Function
    
    If g_optionsList Is Nothing Then
        Set g_optionsList = p_bexGlobal.saptablefactory.NewTable
        With g_optionsList
            .Create "LIST", 167
            With .Columns
                With .Add:  .IntLength = 16:    .Name = "ICONID":           End With
                With .Add:  .IntLength = 60:    .Name = "TEXT":             End With
                With .Add:  .IntLength = 2:     .Name = "REQUESTED_TREE":   End With
                With .Add:  .IntLength = 5:     .Name = "GUID_COLINDEX":    End With
                With .Add:  .IntLength = 12:    .Name = "PRESELECTED":      End With
                With .Add:  .IntLength = 72:    .Name = "SUBTREE_FILTER":   End With
            End With
        End With
    Else
        g_optionsList.freetable
    End If
    Dim rowList As Object: Set rowList = g_optionsList.Rows.Add
    rowList("REQUESTED_TREE") = treeID
    rowList("TEXT") = userText("menuTree" & Choose(treeID, "Workbooks", "Queries", "Alerts", "Views"))
    rowList("ICONID") = Choose(treeID, 686, 245, 820, 246)
    rowList("GUID_COLINDEX") = Choose(treeID, 3, 18, 18, 4)
    rowList("SUBTREE_FILTER") = filter
    
    With g_openSave20
    
        Set .GlobalData = p_bexGlobal
        Set .ParentApplication = Application
        .Caller = 0
        .SetListTable g_optionsList
        .WindowTitle = userText(captionName)
        .openMode = Not folderSelection
        
        trace True, "running open/save (v20)"
        .Execute
        trace False, "tree: " & .SelectedTree
        trace False, "GUID: " & .GUID
        trace False, "name: " & .Description
        
        treeID = IIf(.action = osChange, cTreeQueryEdit, .SelectedTree)
        folderSelection = .IsFolderSelected
        newName = .Description
        openSaveDialog20 = Switch( _
            .action = osOK, .GUID, _
            .action = osCancel, "", _
            .action = osCreate, IIf(.GUID = cNewQueryGUID, cNewQueryGUID, cNewQueryGUID & .Techname), _
            .action = osChange, .GUID _
        )
        
    End With

End Function

Private Function openDialog(treeID As Long, ByVal captionName As String, Optional filter As String) As String

    If Not dialIn Then Exit Function
    If p_versionServer < cV30 Then
        openDialog = openSaveDialog20(treeID, False, captionName, filter)
        Exit Function
    End If
    
    If Not provideComponent(g_openDialog, "SAPBWOpenDialog.BExOpenDialog", "Open Dialog") Then Exit Function
    If Not provideGlobalLoggedOn Then Exit Function
    
    With g_openDialog
    
        Set .GlobalData = p_bexGlobal
        .ObjectType = Choose(treeID, "WB", "QU", "AL", "VW")
        .EnableDisplay = False
        .EnableDelete = (treeID <> cTreeAlert)
        .ShowFavorites = True
        .EnableChange = (treeID = cTreeQuery)
        .EnableCreate = (treeID = cTreeQuery)
        .title = userText(captionName)
        Set .Parent = Application
        
        trace True, "running open"
        ToolBarsHide
        .Run
        ToolBarsUnhide
        If .SelectedItem Is Nothing Then
            trace False, "nothing selected"
        Else
            trace False, "UID: " & .SelectedItem.uid
            trace False, "Tech Name: " & .SelectedItem.Techname
            trace False, "Attribute: " & .SelectedItem.attribkey
        End If
        
'    Debug.Print "Text : " & .SelectedItem.Text
'    Debug.Print "ObjType : " & .SelectedItem.ObjType
'    Debug.Print "IsFolder : " & .SelectedItem.IsFolder
'    Debug.Print "AttribText : " & .SelectedItem.AttribText
        
        Dim buttonCode As String:   buttonCode = IIf(.okcode, os3Cancel, .clickedbutton)
        Select Case buttonCode
        Case os3OK:     openDialog = IIf(treeID = cTreeQuery, .SelectedItem.uid, .SelectedItem.Techname)
        Case os3Cancel: openDialog = ""
        Case os3Create: openDialog = cNewQueryGUID & .SelectedItem.attribkey
        Case os3Change: openDialog = .SelectedItem.uid:   treeID = cTreeQueryEdit
        End Select
        
  End With

End Function

Public Sub openWorkbook()
    Dim myItem As String:   myItem = openDialog(cTreeWorkbook, "captionOpenMain")
    If Len(myItem) Then storageRead myItem, Nothing, p_versionServer = cV20
End Sub

Public Function openWorkbookTemplate(chooseStatic As Boolean) As String
    openWorkbookTemplate = openDialog(cTreeWorkbook, IIf(chooseStatic, "captionTemplateStatic", "captionTemplate"))
End Function

Public Sub openQueryInsert()
    openDialogQuery True
End Sub

Public Sub openQueryNewBook()
    openDialogQuery False
End Sub

Private Sub openDialogQuery(embedHere As Boolean)
    
    userStatusBar "Embed"
    
    Dim myTree As Long:     myTree = cTreeQuery ' dialog can change it to cTreeQueryEdit !
    Dim myItem As String:   myItem = openDialog(myTree, "captionQueryList")
    If Len(myItem) Then
        Dim iCubeID As String
        If Left(myItem, Len(cNewQueryGUID)) = cNewQueryGUID Then
            If Len(myItem) > Len(cNewQueryGUID) Then iCubeID = Mid(myItem, Len(cNewQueryGUID) + 1)
            myTree = cTreeQueryEdit
            myItem = ""
        Else
            If p_versionServer < cV20 Then
                If Not rfcTranslateQueryID(myItem) Then GoTo leave
            End If
        End If
        queryEmbed embedHere, (myTree = cTreeQueryEdit), myItem, iCubeID
    End If
    
leave:
    userStatusBar ""

End Sub

Public Sub openAlertsAll()
    openDialogJump cTreeAlert, "Goto", cJumpAlert, True, cV20
End Sub

Public Sub openAlertsContext()
    openDialogJump cTreeAlert, "Goto", cJumpAlert, False, cV20
End Sub

Public Sub openViews()
    openDialogJump cTreeView, "OpenView", cJumpViewGlobal, True, cV30
End Sub

Private Sub openDialogJump(openTree As Long, openCaption As String, jumpType As Long, initialJump As Boolean, checkRelease As Integer)

    If Not dialIn Then Exit Sub
    If versionFault(, checkRelease) Then Exit Sub
    
    Dim myFilter As String: If Not initialJump Then myFilter = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQID)
    Dim myItem As String:   myItem = openDialog(openTree, "caption" & openCaption, myFilter)
    If Len(myItem) Then queryJump jumpType, myItem, initialJump

End Sub

Public Function saveDialogWorkbook(newName As String) As String

    If p_versionServer < cV30 Then
        saveDialogWorkbook = openSaveDialog20(cTreeWorkbook, True, "captionSave", newName)
        Exit Function
    End If
    
    If Not dialIn Then Exit Function
    
    If Not provideComponent(g_saveDialog, "SAPBWOpenDialog.BExSaveDialog", "Save Dialog") Then Exit Function
    If Not provideGlobalLoggedOn Then Exit Function
    
    With g_saveDialog
    
        Set .GlobalData = p_bexGlobal
        If RegistryGet("", "OverwriteSavedWB") = "ON" Or _
            RegistryGet("", "OverwriteSavedWB", True) = "ON" Then
            .enableobjectselection = True
        Else
            .enableobjectselection = False
        End If
        
        .ObjectType = "WB"
        .CheckObject = True
        .title = userText("captionSave")
        Set .Parent = Application
        
        trace True, "running open"
        .Run
        trace False, "Role: " & .savedobject.treeID
        
'    Debug.Print "TechName : " & .SavedObject.TechName
'    Debug.Print "Description : " & .SavedObject.Text
'    Debug.Print "Role : " & .SavedObject.Role
'    Debug.Print "Node : " & .SavedObject.Node
'    Debug.Print "URL : " & .SavedObject.Url

        If .okcode Then ' = 1 means "Cancel"
            saveDialogWorkbook = ""
            newName = ""
        Else ' = 0 means "OK"
        ' The Techname is appended so that if the overwrite workbook functionality
        ' is enabled then the workbook can be overwritten. In other cases the techname
        ' is returned empty
            saveDialogWorkbook = .savedobject.treeID + .savedobject.Techname
            newName = .savedobject.Text
        End If
        
  End With

End Function

Public Sub saveDialogView(viewID As String, ByVal wbID As String)
    Do
        Dim result As String
        result = openSaveDialog20(cTreeView, True, "captionSaveView", viewID, wbID)
        If Len(result) = 0 Then viewID = "" ' user cancellled
    Loop Until viewNameOK(viewID)
End Sub

Public Function viewNameOK(viewID As String) As Boolean
    viewNameOK = True
    Dim i As Integer
    For i = 1 To Len(viewID)
        If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_ ", Mid(viewID, i, 1)) = 0 Then
            userError "viewNameInvalid"
            viewID = ""
            viewNameOK = False
            Exit Function
        End If
    Next i
End Function
Attribute VB_Name = "cBEXprotection"
Option Private Module
Option Explicit

Public Sub changeProtection()
    
    If ActiveSheet Is Nothing Then
        userError "noProtectSheet"
        Exit Sub
    End If
    
    With ActiveSheet
        If .ProtectContents Or .ProtectDrawingObjects Then
            On Error Resume Next
            Do While Application.Dialogs(xlDialogProtectDocument).Show
                If Err Then
                    userError "unprotectFailed"
                    Err.Clear
                Else
                    .names(xlnamePassword).Delete
                    Exit Sub
                End If
            Loop
            On Error GoTo 0
        Else
            If userFormShow(dBEXprotect, "captionProtect") > 0 Then
                If Not SAPprotect(ActiveSheet) Then
                    On Error Resume Next
                    .names(xlnamePassword).Delete
                    On Error GoTo 0
                    userError "protectFailed"
                End If
            End If
        End If
    End With
End Sub

Public Function isProtected(sh As Worksheet, silent As Boolean, Optional checkSapProtection As Boolean) As Boolean

    If sh.ProtectContents Or sh.ProtectDrawingObjects Then
        If SAPprotect(sh) And Not checkSapProtection Then
            isProtected = False
        Else
            If Not silent Then userError "sheetProtected"
            isProtected = True
        End If
    Else
        isProtected = False
    End If

End Function

Public Function noUnprotectedActiveSheet(Optional silent As Boolean, Optional checkSapProtection As Boolean) As Boolean

    On Error GoTo noWorksheet ' note: ActiveSheet can either be Worksheet or Chart!
    noUnprotectedActiveSheet = isProtected(ActiveSheet, silent, checkSapProtection)
    Exit Function
noWorksheet:
    If Not silent Then userError "noActiveSheet"
    noUnprotectedActiveSheet = True

End Function

Public Function SAPprotect(sh As Worksheet) As Boolean

    With sh
        Dim wbPassword As String
        wbPassword = Mid(name2string(.names, xlnamePassword), 2)
        On Error GoTo protectFailed
        If .ProtectContents Or .ProtectDrawingObjects Then
            .Unprotect wbPassword
        Else
            If p_currentRepoSheet Is Nothing Then Set p_currentRepoSheet = repoGetRepoSheet(sh.Parent, True)
        End If
        .Protect password:=wbPassword, userinterfaceonly:=True
    End With
    
    SAPprotect = True
    Exit Function

protectFailed:
    SAPprotect = False

End Function
Attribute VB_Name = "cBEXpublic"
Option Private Module
Option Explicit

'-----
'----- this module contains all the globally defined constants and variables
'-----

Public Const cProductName       As String = "Business Explorer"
Public Const cProductNameOld    As String = "SAP Business Explorer"
Public Const cProductNameA      As String = "Business Explorer Analyzer"
Public Const cProductNameB      As String = "Browser"
Public Const cProductNameC      As String = "Installation Check"
Public Const cProductNameP      As String = "Web Application Designer"

Public Const cVersionFrontend   As Long = 7
Public Const cTilingSize        As Integer = 500
Public Const cTilingLimit       As Integer = 700
Public Const cTilFmtSize        As Integer = 10000
Public Const cTilFmtLimit       As Integer = 12500

Public Const cVBExit            As String = "SAPBEXonRefresh"
Public Const cTitleTextElement  As String = "REPTXTLG"
Public Const cXLnameTag         As String = "SAPBEXq"
Public Const cXLnameTagLen      As Long = 7

Public Const xlMaxRow       As Long = 65536
Public Const xlMaxColumn    As Long = 256

'----- repoSheet constants

' In each workbook containing BIW queries, all the query definitions are
'   stored in special worksheets, the so-called repo ("repository") sheets.
'   There is one repo sheet for selections, which contains the CON and FAC tables
'   and one for everything else. The former one is only needed for 2.0 systems.
'   The repo sheets are alway hidden from the user, but are automatically added
'   to an Excel workbook when needen (i.e. when the first query gets embedded, or
'   when selections are added for the first time)
'   The following constants define the structure of information on repo sheets.

Public Const cRepoMajorVersion      As Integer = 9

Public Const cRepoCVersion          As Byte = 1
Public Const cRepoSheetName         As String = "SAPBEXqueries"
Public Const cRepoSheetNameFilters  As String = "SAPBEXfilters"

Public Const cRepoRGlobal           As Byte = 1
Public Const cRepoRCounts           As Byte = 2
Public Const cRepoRWidths           As Byte = 3
Public Const cRepoRTop              As Byte = 4

' indices of repo columns for storing query information

Public Const cRepoCQ As Byte = 1
Public Const cRepoCD As Byte = cRepoCQ + 30    ' offset for DIM table
Public Const cRepoCM As Byte = cRepoCD + 60    ' offset for MEM table
Public Const cRepoCA As Byte = cRepoCM + 20    ' offset for ATR table
Public Const cRepoCC As Byte = cRepoCA + 20    ' offset for CEL table
Public Const cRepoCT As Byte = cRepoCC + 20    ' offset for HRY_TYPES table
Public Const cRepoCV As Byte = cRepoCT + 30    ' offset for VAR table
Public Const cRepoCP As Byte = cRepoCV + 50    ' offset for PRPTYS table

Public Const cRepoCX As Byte = 101             ' offset for DRILL table
Public Const cRepoCN As Byte = cRepoCX + 55    ' offset for CON table
Public Const cRepoCF As Byte = cRepoCN + 50    ' offset for FAC table

Public Const cRepoCQHandle          As Byte = cRepoCQ + 1  ' long: handle of OLAP session, 0 if invalid
Public Const cRepoCQID              As Byte = cRepoCQ + 2  ' string: unique ID of query in OLAP directory
Public Const cRepoCQValid           As Byte = cRepoCQ + 3  ' boolean: current definition / layout is valid ? (cRepoCQRefreshed -> cRepoCQValid !)
Public Const cRepoCQRefreshed       As Byte = cRepoCQ + 4  ' boolean: current definition / layout already committed to the OLAP server?
Public Const cRepoCQPrefix          As Byte = cRepoCQ + 5  ' string: prefix for XL names concerning this query

Public Const cRepoCQYData           As Byte = cRepoCQ + 6  ' long: index of first data row in current result
Public Const cRepoCQXData           As Byte = cRepoCQ + 7  ' long: index of first data column in current result
Public Const cRepoCQFirstRefresh    As Byte = cRepoCQ + 8  ' boolean: text elements and filter cells must be updated with next refresh?

Public Const cRepoCQStyles          As Byte = cRepoCQ + 11 ' boolean: update styles with each refresh?
Public Const cRepoCQFlat            As Byte = cRepoCQ + 25 ' boolean: query does not allow drill operations?
Public Const cRepoCQTransient       As Byte = cRepoCQ + 24 ' boolean: query does not have a persistent definition in the BW Server?
Public Const cRepoCQResultClipped   As Byte = cRepoCQ + 12 ' boolean: result was clipped on last refresh -> hierarchy ops are denied!

Public Const cRepoCQInteractive     As Byte = cRepoCQ + 14 ' boolean: interactive user navigation etc. enabled?
Public Const cRepoCQReuseVars       As Byte = cRepoCQ + 15 ' boolean: shall variable valuse be stored an reused?
Public Const cRepoCQAdjustColumns   As Byte = cRepoCQ + 16 ' 0, 1, 2: (how) shall columns width be adjusted on refresh?

Public Const cRepoCQChartIndex      As Byte = cRepoCQ + 13 ' integer: index of attached chart
Public Const cRepoCQGISIndex        As Byte = cRepoCQ + 17 ' integer: index of attached map

Public Const cRepoCQDefVersion      As Byte = cRepoCQ + 18 ' integer: version of BW system that sent this definition
Public Const cRepoCQStructFilter    As Byte = cRepoCQ + 19 ' boolean: show filter cells for structure dimensions?
Public Const cRepoCQRefreshOnOpen   As Byte = cRepoCQ + 20 ' boolean: refresh query when opening the workbook from the document store?
Public Const cRepoCQRefreshToGlobal As Byte = cRepoCQ + 23 ' boolean: refresh restores global definition of query?

Public Const cRepoCQGoto            As Byte = cRepoCQ + 21 ' string: tag from last jump
Public Const cRepoCQGotoRepeat      As Byte = cRepoCQ + 22 ' boolean: repeat last jump on double-click

Public Const cRepoQueryTableWidth   As Byte = 24

Public Const cRepoCDCharName        As Byte = cRepoCD + 1
Public Const cRepoCDCharText        As Byte = cRepoCD + 2
Public Const cRepoCDIsSumable       As Byte = cRepoCD + 3
Public Const cRepoCDIsStructure     As Byte = cRepoCD + 4
Public Const cRepoCDAxis            As Byte = cRepoCD + 5
Public Const cRepoCDPosition        As Byte = cRepoCD + 6

Public Const cRepoCDValExt          As Byte = cRepoCD + 7
Public Const cRepoCDValTxt          As Byte = cRepoCD + 8
Public Const cRepoCDValInt          As Byte = cRepoCD + 9
Public Const cRepoCDValHry          As Byte = cRepoCD + 10

Public Const cRepoCDHryActive       As Byte = cRepoCD + 16
Public Const cRepoCDHryName         As Byte = cRepoCD + 17
Public Const cRepoCDFiltered        As Byte = cRepoCD + 36
Public Const cRepoCDIobjPrsnt       As Byte = cRepoCD + 14

Public Const cRepoCMDimName         As Byte = cRepoCM + 1
Public Const cRepoCMMemName         As Byte = cRepoCM + 2
Public Const cRepoCMMemText         As Byte = cRepoCM + 3
Public Const cRepoCMPosition        As Byte = cRepoCM + 4
Public Const cRepoCMHidden          As Byte = cRepoCM + 5

Public Const cRepoCNEltuid          As Byte = cRepoCN + 1
Public Const cRepoCNText            As Byte = cRepoCN + 2
Public Const cRepoCNActive          As Byte = cRepoCN + 3
Public Const cRepoCNConType         As Byte = cRepoCN + 4
Public Const cRepoCNCharName        As Byte = cRepoCN + 6
Public Const cRepoCNStatic          As Byte = cRepoCN + 7

Public Const cRepoCFEltuid          As Byte = cRepoCF + 1
Public Const cRepoCFTermNumber      As Byte = cRepoCF + 4
Public Const cRepoCFFactorNumber    As Byte = cRepoCF + 5
Public Const cRepoCFSelOptNumber    As Byte = cRepoCF + 7
Public Const cRepoCFSign            As Byte = cRepoCF + 8
Public Const cRepoCFOpt             As Byte = cRepoCF + 9
Public Const cRepoCFLowValue        As Byte = cRepoCF + 10
Public Const cRepoCFHierIObj        As Byte = cRepoCF + 11
Public Const cRepoCFLowExt          As Byte = cRepoCF + 12
Public Const cRepoCFLowFlag         As Byte = cRepoCF + 14
Public Const cRepoCFLowTxt          As Byte = cRepoCF + 18
Public Const cRepoCFHierName        As Byte = cRepoCF + 22
Public Const cRepoCFHierFlag        As Byte = cRepoCF + 23
Public Const cRepoCFHighext         As Byte = cRepoCF + 13
Public Const cRepoCFHightxt         As Byte = cRepoCF + 19

Public Const cRepoCPID              As Byte = cRepoCP + 1
Public Const cRepoCPValue           As Byte = cRepoCP + 2

'----- constants for property string IDs (i.e. IDs of strings transported in table E_T_PRPTYS)

' query properties

Public Const cPropFlat          As Integer = 10
Public Const cPropTransient     As Integer = 256    ' flag: query definition is only temporary, and not persisted in the BW server?

Public Const cPropShowDocLinks      As Integer = 20
Public Const cPropShowDocLinksData  As Integer = 23
Public Const cPropShowDocLinksMsd   As Integer = 22
Public Const cPropShowDocLinksMeta  As Integer = 21

Public Const cPropNoMultTxt     As Integer = 100
Public Const cPropShowFormats   As Integer = 101
Public Const cPropNegNumbers    As Integer = 102
Public Const cPropNoStyles      As Integer = 103
Public Const cPropSumPosition   As Integer = 114

' session properties

Public Const cPropSendPing      As Integer = 200    ' flag: shall we send time stamps to the BW server to allow measuring frontend performance?
Public Const cPropManageGUI     As Integer = 222    ' flag: shall we control the visibility of the SAPGUI window from the Analyzer? (no: BW server cares for that!)

Public Const cPropPercentFrac   As Integer = 1001
Public Const cPropMaskDate      As Integer = 1002
Public Const cPropMaskTime      As Integer = 1003
Public Const cPropDCPChar       As Integer = 1004
Public Const cPropExcel2003     As Integer = 2003   ' flag: Excel 2003 or higher ?

Public Const cPropCurrClient    As Integer = 1500
Public Const cPropCurrUser      As Integer = 1501
Public Const cPropCurrLanguage  As Integer = 1502
Public Const cPropCurrSysNumber As Integer = 1503

Public Const cPropReqVersion    As Integer = 3000
Public Const cPropCurVersion    As Integer = 3001
Public Const cPropClientError   As Integer = 1201

Public Const cPropGenUniID      As Integer = 10001

Public Const cPropCancelSize    As Integer = 1600
Public Const cPropAuthChecks    As Integer = 1700

Public Const cPropTilingSize    As Integer = 1100
Public Const cPropTilingLimit   As Integer = 1101
Public Const cPropTilFmtSize    As Integer = 1102
Public Const cPropTilFmtLimit   As Integer = 1103

'----- builder modi

Public Const cBuilderSmall      As Byte = 0
Public Const cBuilderLarge      As Byte = 1
Public Const cBuilderExceptions As Byte = 2
Public Const cBuilderConditions As Byte = 3
Public Const cBuilderNew        As Byte = 4

'----- types of con entries

Public Const cConTypeCondition  As String = "1"
Public Const cConTypeException  As String = "2"
Public Const cConTypeSelection  As String = "3"

'----- range types

Public Const cRangeResult       As String = "r"
Public Const cRangeFilter       As String = "f"
Public Const cRangeCondExc      As String = "c"
Public Const cRangeText         As String = "t"
Public Const cRangeAny          As String = ""

'----- jump types

Public Const cJumpExtRepRep     As String = "r"
Public Const cJumpExtView       As String = "v"
Public Const cJumpExtViewGlobal As String = "g"

Public Const cJumpAlert         As Byte = 3
Public Const cJumpView          As Byte = 4
Public Const cJumpRepRep        As Byte = 5
Public Const cJumpRepRepFCode   As Byte = 6
Public Const cJumpViewGlobal    As Byte = 7

'----- ways to select a template

Public Const cTemplateEmpty     As String = "E"
Public Const cTemplateChoose    As String = "X"
Public Const cTemplatePermanent As String = "T"

'----- public status variables

Public p_ping                   As Boolean  ' send ready signals to BW server for performance monitoring?
Public p_manageGUI              As Boolean  ' nanage visiblity of SAPGUI
Public p_prohibitedTools        As Boolean
Public p_retrieveLimit          As Long     ' maximum size of a query result
Public p_versionServer          As Long
'   1:  Rel.1.0  (not supported!)
'   2:  Rel.1.2a (not supported!)
'   3:  Rel.1.2b
Public Const cV20 = 4
Public Const cV30 = 5

Public p_connectionObj          As Object
Public p_bexGlobal              As Object
Public p_tables                 As Object   ' collection of all tables, which have been created so far
Public p_URLprefix              As String

Public p_appEventClass          As New clBEXeventApp

Public p_currentRepoSheet       As Worksheet
Public p_currentConFacSheet     As Worksheet
Public p_currentQueryIndex      As Long
Public p_currentFilterIndex     As Long
Public p_currentConFacIndex     As Long

Public p_currentSelection       As Range    ' when a query was detected, this range defines the selected areas in the result range
Public p_currentSelYoffset      As Long     ' row offset of the resultArea, where p_currentselection was detected
Public p_currentSelXoffset      As Long     ' column offset ... (see above)

Public p_gridHeight             As Long
Public p_gridWidth              As Long
Public p_gridPending            As Boolean

Public p_newLocation            As Range    ' used in moving filters or queries
Public p_dialogSuccess          As Integer  ' public return value: which button was pressed in last dialog?
Public p_rollbackHandle         As Boolean  ' cancel on variable screen - roll back old handle

Public p_extErrorFlag           As Boolean  ' p_ext... variables are used to monitor
Public p_extErrorCount          As Integer  ' errors in the API for external VBA
Public p_extErrorText           As String   ' programs. (viz. module cBIWexternal)
                                            ' p_extErrorFlag = true  =>  ErrorMsg. will NOT display

Public p_callByBrowserGui       As Boolean  ' Set to true when the BEx Analyzer is started by the
                                            ' Bex browser/sapgui.
Public p_varValuesPending       As Boolean  ' variable values for the next "open" have been set via the VBA API

'----- fetching sheet / book variables stored under XL names

Public Const xlnamePassword     As String = "SAPBEXprtctPW"
Public Const xlnameWorkbookID   As String = "SAPBEXwbID"
Public Const xlnameSystemID     As String = "SAPBEXsysID"
Public Const xlnameRevision     As String = "SAPBEXrevision"
Public Const xlnameHryIndent    As String = "SAPBEXhrIndnt"
Public Const xlnameBBSback      As String = "SAPBEXbbsBack"
Public Const xlnameDownload     As String = "SAPBEXdnldView"

Public Const shapeNamePlus      As String = "SAPBEXhierarchyPlus"
Public Const shapeNameMinus     As String = "SAPBEXhierarchyMinus"
Public Const shapeNameMinusX    As String = "SAPBEXhierarchyMinusX"
Public Const shapeNameLinkDoc   As String = "SAPBEXlinkDoc"
Public Const shapeNameLinkBor   As String = "SAPBEXlinkBor"

'----- working with ActiveX components

Public Sub destroyComponent(myComp As Object)
    If Not myComp Is Nothing Then Set myComp.GlobalData = Nothing
    Set myComp = Nothing
End Sub

Function provideComponent(compObj As Object, compName As String, compTitle As String) As Boolean
    
    provideComponent = True
    On Error Resume Next
    If compObj Is Nothing Then
        Set compObj = CreateObject(compName)
        If compObj Is Nothing Then
            userError "installActiveX", , cProductName & " " & compTitle
            provideComponent = False
        End If
    End If

End Function

Public Function provideGlobal() As Boolean
    provideGlobal = provideComponent(p_bexGlobal, "SAPBExCommonResources.BExGlobal", "Global Services")
End Function

Function provideGlobalLoggedOn() As Boolean

    provideGlobalLoggedOn = False
    If dialIn Then
        If provideGlobal Then
            Set p_bexGlobal.SAPConnection = p_connectionObj
            provideGlobalLoggedOn = True
        End If
    End If

End Function

Function tableReset(tableName As String) As Boolean
    
    On Error Resume Next
    Dim thisTable As Object:    Set thisTable = p_tables(tableName)
    On Error GoTo 0
        
    If thisTable Is Nothing Then
    
        If p_tables Is Nothing Then
            If provideGlobalLoggedOn Then
                Set p_tables = p_bexGlobal.saptablefactory.NewTables
            Else
                Exit Function
            End If
        End If
        
        Dim tableStructure As String
        Dim searchCell As Range
        For Each searchCell In ThisWorkbook.Worksheets("wBEXtables").UsedRange.Columns(1).Cells
            If searchCell.Value = tableName Then
                tableStructure = searchCell.Offset(0, 1).Value
                Exit For
            End If
        Next searchCell
        
        If Len(tableStructure) Then
            If dialIn Then
                Set thisTable = p_bexGlobal.saptablefactory.NewTable
                If thisTable.CreateFromR3Repository(p_connectionObj, tableStructure, tableName) Then
                    p_tables.Add thisTable
                    tableReset = True
                Else
                    userError "createTableFailed", 0, tableName & " (" & tableStructure & ")"
                    trace True, "failed to create table " & tableName & ", structure " & tableStructure
                End If
            End If
        Else
            userError "createTableFailed", 0, tableName & " (" & tableStructure & ")"
            trace True, "unknown table name " & tableName
        End If
    
    Else
        thisTable.freetable
        tableReset = True
    End If
    
End Function

Public Function tableResetResultSet() As Boolean
    
    tableResetResultSet = False
    If Not tableReset("E_T_GRID") Then Exit Function
    If Not tableReset("E_T_RANGES") Then Exit Function
    If p_versionServer > cV20 Then
        If Not tableReset("E_T_SYMBOLS") Then Exit Function
        If Not tableReset("E_T_TEXT") Then Exit Function
        If Not tableReset("E_T_DOC_LIST") Then Exit Function
    Else
        If Not tableReset("E_T_HRY_DISP") Then Exit Function
    End If
    tableResetResultSet = True

End Function

Public Function tableResetDefinition() As Boolean
    
    tableResetDefinition = False
    If Not tableReset("E_T_DIM") Then Exit Function
    If Not tableReset("E_T_MEM") Then Exit Function
    If Not tableReset("E_T_ATR") Then Exit Function
    If Not tableReset("E_T_CEL") Then Exit Function
    If Not tableReset("C_T_HRY_TYPES") Then Exit Function
    If p_versionServer >= cV20 Then
        If Not tableReset("E_T_CON") Then Exit Function
        If Not tableReset("E_T_FAC") Then Exit Function
        If Not tableReset("C_T_VARIABLES") Then Exit Function
    End If
    tableResetDefinition = True

End Function

'----- mixed helpers & idioms

Public Function internetBrowserLaunch(url As String) As String
    
    If Len(url) Then
        If provideGlobal Then p_bexGlobal.Execute url
    End If
    
'    Dim command As String:  command = registryGet("Classes\http\shell\open\command", "", True)
'    Dim parmPos As Integer: parmPos = InStr(command, "%1")
'
'    If parmPos Then
'        Dim suffix As String: If parmPos + 2 < Len(command) Then suffix = Mid(command, parmPos + 2)
'        Shell Left(command, parmPos - 1) & url & suffix
'    Else
'        Shell command & " " & url
'    End If
    
End Function

Public Function name2string(myNames As names, myVariable As String) As String
    On Error Resume Next
    Dim myResult As String
    myResult = myNames(myVariable).RefersTo
    name2string = IIf(Err, "", Mid(myResult, 3, Len(myResult) - 3))
End Function

Public Function name2integer(myNames As names, myVariable As String, Optional myDefault As Integer) As Integer
    On Error Resume Next
    Dim myResult As String
    myResult = myNames(myVariable).RefersTo
    name2integer = IIf(Err, myDefault, Val(Mid(myResult, 2)))
End Function

Public Function nullTrim(myString As String) As String
    nullTrim = Left(myString, InStr(myString, vbNullChar) - 1)
End Function

Public Function tLevel(tableRow As Object) As Long
    tLevel = IIf(tableRow("TLEVEL"), tableRow("TLEVEL") - 1, 0)
End Function

Public Function versionFault(Optional silent As Boolean, Optional checkRelease As Integer = cV20) As Boolean

    versionFault = True
    If Not silent And Not isConnected Then
        If Not dialIn Then Exit Function
    End If
    If isConnected And p_versionServer < checkRelease Then
        If Not silent Then userError Switch(checkRelease = cV20, "require20version", checkRelease = cV30, "require30version"), vbExclamation
    Else
        versionFault = False
    End If

End Function

Public Function versionStr(version30 As String, version20 As String) As String
    If p_versionServer > cV20 Then
        versionStr = version30
    Else
        versionStr = version20
    End If
End Function

Public Function versionInt(version30 As Integer, version20 As Integer, Optional version12 As Integer = -1) As Integer
    If p_versionServer > cV20 Then
        versionInt = version30
    Else
        If p_versionServer = cV20 Or version12 < 0 Then
            versionInt = version20
        Else
            versionInt = version12
        End If
    End If
End Function

Public Function isTransient() As Boolean
    ' query is either transient(1) or a transient view of a normal query (2)
    isTransient = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQTransient) > 0
End Function

Public Function fixLen(myString As String, length As Integer) As String
    If Len(myString) > length Then myString = Left(myString, length)
    fixLen = myString & Space(length - Len(myString))
End Function

Public Function translate(inString As String, whatChar As String, withString As String) As String
    Dim outString As String
    outString = inString
    Dim findPos As Integer
    Do
        findPos = InStr(findPos + 1, outString, whatChar)
        If findPos Then
            outString = Left(outString, findPos - 1) & withString & Right(outString, Len(outString) - findPos)
        Else
            translate = outString
            Exit Function
        End If
    Loop
End Function

Public Function buttonState(condition As Boolean) As Long
    buttonState = IIf(condition, msoButtonDown, msoButtonUp)
End Function

Public Sub safeActivate(target As Range, Optional atRow As Long = 1)
    With target
        .Parent.activate
        .Cells(atRow, 1).activate
    End With
End Sub

Public Sub nyi()
    userError "notYetImplemented"
End Sub
Attribute VB_Name = "cBEXquery"
Public g_delayCallToOnRefreshModule As Boolean
Option Explicit
Option Private Module

Public Function queryEmbed(atActiveCell As Boolean, launchEditor As Boolean, Optional genUID As String, Optional iCubeID As String, Optional editorMode As Byte = cBuilderLarge) As String

    userStatusBar "Embed"
    queryEmbed = ""

    If launchEditor Then ' use the Builder control to (create and) get the definition for a query
        Set p_currentRepoSheet = Nothing
        repoReadQuery ' load empty query definition (p_currentRepoSheet is Nothing !)
        If Not Build(genUID, editorMode, False, iCubeID) Then GoTo leave
    End If

    If Len(genUID) Then
        If Not atActiveCell Then
            Dim newBook As Workbook: Set newBook = storageReadTemplate
            If newBook Is Nothing Then GoTo leave
        End If
        Dim queryID As String: queryID = embedHere(genUID, ActiveCell, Not atActiveCell)
        If Len(queryID) Then
            queryEmbed = queryID
        Else
            If Not newBook Is Nothing Then newBook.Close False
        End If
    End If

leave:
    userStatusBar ""

End Function
        
Private Function embedHere(queryID As String, anchor As Range, reuseDefinition As Boolean, Optional dontExecute As Boolean) As String

    embedHere = ""
    
    If noUnprotectedActiveSheet(False, True) Then Exit Function
    
    Set p_currentRepoSheet = repoGetRepoSheet(anchor.Worksheet.Parent, True)
    If p_currentRepoSheet Is Nothing Then Exit Function

    userStatusBar "Embed"
    
    With p_currentRepoSheet
    
        If .Cells(cRepoRCounts, cRepoCQ) = 0 Then reuseDefinition = False
        
        If reuseDefinition Then
            p_currentQueryIndex = .Cells(cRepoRCounts, cRepoCQ) + cRepoRTop - 1
            .Cells(p_currentQueryIndex, cRepoCQID) = queryID
        Else

            p_currentQueryIndex = .Cells(cRepoRCounts, cRepoCQ) + cRepoRTop
            .Cells(cRepoRCounts, cRepoCQ) = .Cells(cRepoRCounts, cRepoCQ) + 1
            
            .Cells(p_currentQueryIndex, cRepoCQID) = queryID
            .Cells(p_currentQueryIndex, cRepoCQPrefix) = generateNewName
            On Error Resume Next
            
            Dim nameRangeResult As String:  nameRangeResult = .Cells(p_currentQueryIndex, cRepoCQPrefix)
            Dim nameRangeTitle As String:   nameRangeTitle = .Cells(p_currentQueryIndex, cRepoCQPrefix) & cRangeText & cTitleTextElement
            Dim oldRangeResult As Range:    Set oldRangeResult = RunGetResultRange(p_currentQueryIndex)
            Dim oldRangeTitle As Range:     Set oldRangeTitle = RunGetTextRange(cTitleTextElement)
            If oldRangeTitle Is Nothing Then ' text element "title" is created automatically
                .names.Add nameRangeTitle, anchor.Resize(1, 2)
                Set anchor = anchor.Offset(2)
            End If
            .names.Add nameRangeResult, anchor
            
            ' default values for the new query's properties
            .Cells(p_currentQueryIndex, cRepoCQInteractive) = True
            .Cells(p_currentQueryIndex, cRepoCQReuseVars) = False
            .Cells(p_currentQueryIndex, cRepoCQRefreshOnOpen) = False
            
            'Allow the customizing of the 'Adjust Column Width on Refresh' property     ND:5-026
            'By default set to 'Adjust to whole columns'
            If RegistryGet("", "ADJUSTCOLUMNS") = "RESULTAREA" Or _
                RegistryGet("", "ADJUSTCOLUMNS", True) = "RESULTAREA" Then
                .Cells(p_currentQueryIndex, cRepoCQAdjustColumns) = 1
            Else
                .Cells(p_currentQueryIndex, cRepoCQAdjustColumns) = 2
            End If
            
            .Cells(p_currentQueryIndex, cRepoCQStructFilter) = True
            
            .Cells(p_currentQueryIndex, cRepoCQStyles) = True ' store flag redundant for easier access
            repoSetPropertyBoolean cPropShowFormats, True
            repoSetPropertyBoolean cPropNoMultTxt, True
            repoSetPropertyBoolean cPropNoStyles, False
        
        End If
        
        If dontExecute Then
            embedHere = .Cells(p_currentQueryIndex, cRepoCQPrefix)
        Else
            If RunOpenQuery Then
                If contextSetIndex(1) Then
                    'BugFix: OnRefresh module is called before the text elements are
                    'rendered, Hence set the flag to delay the execution of onrefresh
                    g_delayCallToOnRefreshModule = True
                    If contextSAP("STRT") Then
                        embedHere = .Cells(p_currentQueryIndex, cRepoCQPrefix)
                        RunProcessTextElements "F"
                        'Make the call to onrefresh module now.
                        resultExit .Cells(p_currentQueryIndex, cRepoCQPrefix), g_onRefreshModuleTarget
                        GoTo leave
                    End If
                End If
            End If
            If Not reuseDefinition Then
                .names(nameRangeTitle).Delete
                If Not oldRangeTitle Is Nothing Then .names.Add nameRangeTitle, oldRangeTitle
                .names(nameRangeResult).Delete
                If Not oldRangeResult Is Nothing Then .names.Add nameRangeResult, oldRangeResult
                queryDelete False, False, False, True, False
            End If
        End If
    
    End With

leave:
    userStatusBar ""
    'Reset the flags and the query result target
    g_delayCallToOnRefreshModule = False
    Set g_onRefreshModuleTarget = Nothing
    
End Function

Public Function queryJump(jumpType As Long, jumpTarget As String, Optional initialJump As Boolean, Optional genUniIDsender As String) As Boolean

    If versionFault Then Exit Function
    
    trace True, "jump"
    trace False, "target: " & jumpTarget
    
    Dim handle As Integer
    If initialJump Then
        handle = 0
    Else
        handle = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)
        genUniIDsender = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQID)
    End If
    
    Dim genUniID As String
    genUniID = genUniIDsender
    
    If Not contextSetSelection Then Exit Function
    
    Select Case jumpType
        Case cJumpView, cJumpViewGlobal:    userStatusBar "Jump", userText("menuTreeViews")
        Case cJumpAlert:                    userStatusBar "Jump", userText("menuTreeAlerts")
        Case cJumpRepRep, cJumpRepRepFCode: userStatusBar "Jump", userText("menuTreeDrillThrough")
    End Select
            
    If rfcJump(handle, genUniID, jumpType, jumpTarget) Then
        
        Dim bbsBackTarget As String
        
        If genUniIDsender <> genUniID Or jumpType = cJumpRepRep Or jumpType = cJumpRepRepFCode Then
            ' jump outside the current query -> embed query into new book
            If Not initialJump Then bbsBackTarget = p_currentRepoSheet.Parent.Name
            If storageReadTemplate Is Nothing Then GoTo leave
            If Len(embedHere(genUniID, ActiveCell, True, True)) = 0 Then GoTo leave
        End If
        
        repoWriteQuery True
        repoWriteTable p_currentRepoSheet, cRepoCV, "C_T_VARIABLES"
        RunSetHandle handle
        Dim target As Range: Set target = RunGetTarget
        If Not target Is Nothing Then displayResult target, True
        If Len(bbsBackTarget) Then p_currentRepoSheet.Parent.names.Add xlnameBBSback, bbsBackTarget, False
    
        queryJump = True
    
    End If
    
leave:
    userStatusBar ""
    
End Function

Public Sub bbsBackDisable(wb As Workbook)
    On Error Resume Next
    wb.names(xlnameBBSback).Delete
    Err = 0
End Sub

Public Sub queryDelete(allQueries As Boolean, results As Boolean, ranges As Boolean, definition As Boolean, names As Boolean)

    drawUndraw
    screenHalt
    With p_currentRepoSheet
    
        Dim maxIndex As Integer: maxIndex = IIf(allQueries, .Cells(cRepoRCounts, cRepoCQ) + cRepoRTop - 1, p_currentQueryIndex)
        Dim minIndex As Integer: minIndex = IIf(allQueries, cRepoRTop, p_currentQueryIndex)
    
        For p_currentQueryIndex = maxIndex To minIndex Step -1
                        
            If results Then
                On Error Resume Next
                displayResult RunGetResultRange(p_currentQueryIndex)
                .Cells(p_currentQueryIndex, cRepoCQRefreshed) = False
                On Error GoTo 0
            End If
            
            If ranges Or names Then
                Dim queryName As String:    queryName = cRepoSheetName & "!" & .Cells(p_currentQueryIndex, cRepoCQPrefix)
                On Error Resume Next ' because names may have #REF errors
                Dim nm As Name
                For Each nm In .names
                    If Left(nm.Name, Len(queryName)) = queryName Then
                        If ranges Then
                            Dim shapePrefix As String
                            If definition Then
                                shapePrefix = .Cells(p_currentQueryIndex, cRepoCQPrefix)
                            Else
                                If Len(nm.Name) = Len(queryName) Then
                                    shapePrefix = .Cells(p_currentQueryIndex, cRepoCQPrefix) & "_"
                                    RunClearRange nm.RefersToRange, shapePrefix
                                    shapePrefix = .Cells(p_currentQueryIndex, cRepoCQPrefix) & " "
                                End If
                           End If
                            RunClearRange nm.RefersToRange, shapePrefix
                        End If
                        If names Then nm.Delete
                    End If
                Next nm
                On Error GoTo 0
            End If
            
            If definition Then
                repoClearTable p_currentRepoSheet, cRepoCD, True
                repoClearTable p_currentRepoSheet, cRepoCM, True
                repoClearTable p_currentRepoSheet, cRepoCA, True
                repoClearTable p_currentRepoSheet, cRepoCC, True
                repoClearTable p_currentRepoSheet, cRepoCP, True
                repoClearTable p_currentRepoSheet, cRepoCV, True
                Dim myConFacSheet As Worksheet: Set myConFacSheet = ConFacSheetGet
                If Not myConFacSheet Is Nothing Then
                    repoClearTable myConFacSheet, cRepoCN, True
                    repoClearTable myConFacSheet, cRepoCF, True
                    repoClearTable myConFacSheet, cRepoCX, True
                End If
                .Range(.Cells(p_currentQueryIndex, cRepoCQ), .Cells(p_currentQueryIndex, cRepoCQ + .Cells(cRepoRWidths, cRepoCQ))).Delete Shift:=xlUp
                .Cells(cRepoRCounts, cRepoCQ) = .Cells(cRepoRCounts, cRepoCQ) - 1
            End If
        
        Next p_currentQueryIndex
        
        p_currentQueryIndex = IIf(allQueries Or definition, 0, minIndex)
    
    End With
    screenRestore
    
End Sub

Public Sub queryCopy()
    
    screenHalt
    If moveCopyBegin("", True, "captionCopyQuery") Then
        drawUndraw
        
        Dim fromReposheet As Worksheet:     Set fromReposheet = p_currentRepoSheet
        If Not p_newLocation.Worksheet.Parent Is p_currentRepoSheet.Parent Then
            Set p_currentRepoSheet = repoGetRepoSheet(p_newLocation.Worksheet.Parent, True)
            p_newLocation.Worksheet.activate
        End If
    
        ' ... copy structures ...
        
        With fromReposheet
            
            .Range( _
                .Cells(p_currentQueryIndex, cRepoCQ + 1), _
                .Cells(p_currentQueryIndex, cRepoCQ + cRepoQueryTableWidth) _
            ).Copy
        
        End With
        
        Dim newPrefix As String: newPrefix = generateNewName
        
        With p_currentRepoSheet
        
            Dim newQueryIndex As Integer: newQueryIndex = cRepoRTop + .Cells(cRepoRCounts, cRepoCQ)
    
            .Range( _
                .Cells(newQueryIndex, cRepoCQ + 1), _
                .Cells(newQueryIndex, cRepoCQ + cRepoQueryTableWidth) _
            ).PasteSpecial
    
            .Cells(newQueryIndex, cRepoCQHandle) = ""
            .Cells(newQueryIndex, cRepoCQPrefix) = newPrefix
            .Cells(cRepoRCounts, cRepoCQ) = .Cells(cRepoRCounts, cRepoCQ) + 1
    
            Dim oldTitleRange As Range: Set oldTitleRange = RunGetTextRange(cTitleTextElement)
            If Not oldTitleRange Is Nothing Then ' title element is created automatically
                .names.Add newPrefix & cRangeText & cTitleTextElement, p_newLocation.Resize(1, 2)
                If .Cells(newQueryIndex, cRepoCQStyles) Then setStyle p_newLocation.Resize(1, 2), "SAPBEXtitle"
                p_newLocation.Cells(1, 1).Value = oldTitleRange.Cells(1, 1).Value
                Set p_newLocation = p_newLocation.Offset(2)
            Else                                                                                   'VBR:08-045 Start
                setStyle p_newLocation.Resize(1, 2), "SAPBEXtitle"
                p_newLocation.Cells(1, 1).Value = "Query Title"
                Dim NewTitleRange As Range: Set NewTitleRange = RunGetTextRange(cTitleTextElement)
                setStyle p_newLocation.Resize(1, 2), "SAPBEXtitle"
                .names.Add newPrefix & cRangeText & cTitleTextElement, p_newLocation.Resize(1, 2)
                Set p_newLocation = p_newLocation.Offset(2)                                         'VBR:08-045 End
            End If
            
        End With
                
        repoCopyTable p_currentRepoSheet, cRepoCD, newQueryIndex, fromReposheet
        repoCopyTable p_currentRepoSheet, cRepoCM, newQueryIndex, fromReposheet
        repoCopyTable p_currentRepoSheet, cRepoCA, newQueryIndex, fromReposheet
        repoCopyTable p_currentRepoSheet, cRepoCC, newQueryIndex, fromReposheet
        repoCopyTable p_currentRepoSheet, cRepoCV, newQueryIndex, fromReposheet
        repoCopyTable p_currentRepoSheet, cRepoCP, newQueryIndex, fromReposheet
        
        Dim fromConFacSheet As Worksheet: Set fromConFacSheet = ConFacSheetGet(False, fromReposheet)
        If Not fromConFacSheet Is Nothing Then
            Dim myConFacSheet As Worksheet: Set myConFacSheet = ConFacSheetGet(True)
            repoCopyTable myConFacSheet, cRepoCN, newQueryIndex, fromConFacSheet
            repoCopyTable myConFacSheet, cRepoCF, newQueryIndex, fromConFacSheet
            repoCopyTable myConFacSheet, cRepoCX, newQueryIndex, fromConFacSheet
        End If
    
        p_currentQueryIndex = newQueryIndex
    
        displayResult p_newLocation
        safeActivate p_newLocation
    
    End If
    screenRestore
    
End Sub

Public Sub queryMove()
    
    screenHalt
    If moveCopyBegin(RunGetResultAddress(p_currentQueryIndex), False, "captionMoveQuery") Then
        drawUndraw
        
        Dim fromResultArea As Range:    Set fromResultArea = RunGetResultRange(p_currentQueryIndex)
        If Not RunGetResultRange(p_currentQueryIndex) Is Nothing Then
            If userError("confirmMoveQuery", vbQuestion + vbYesNo) = vbNo Then GoTo leave
            RunClearRange fromResultArea, p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix) & " "
        End If
        
        displayResult p_newLocation
        safeActivate p_newLocation
    End If
leave:
    screenRestore
    
End Sub

Public Sub queryMoveFilter()
    
    screenHalt
    If moveCopyBegin(RunGetFilterAddress(p_currentFilterIndex), False, "captionMoveFilter") Then
        drawUndraw
        
        RunClearRange RunGetFilterRange(p_currentFilterIndex)
        On Error Resume Next
        p_currentRepoSheet.names(RunGetFilterName(p_currentFilterIndex)).Delete
        On Error GoTo 0

        displayFilter p_newLocation
        safeActivate p_newLocation
    End If
    screenRestore
    
End Sub

Public Function queryRepair() As Range
    
    p_currentRepoSheet.Parent.activate
    Dim ws As Worksheet
    For Each ws In p_currentRepoSheet.Parent.Worksheets
        If ws.Visible = xlSheetVisible Then
            ws.activate
            Exit For ' activate an arbitrary worksheet in the workbook which contains the query
        End If
    Next ws
    
    screenHalt
    userError "missingAnchor", vbExclamation
    Set queryRepair = Nothing
    If moveCopyBegin("", False, "captionRepair") Then
        drawUndraw
        displayResult p_newLocation
        safeActivate p_newLocation
        Set queryRepair = p_newLocation
    End If
    screenRestore
    
End Function

Private Function moveCopyBegin(initialAddress As String, outsideMoveAllowed As Boolean, caption As String) As Boolean
    
    With dBEXmoveOrCopy
        .setAddress initialAddress
        .outsideMoveAllowed = outsideMoveAllowed
    End With
    moveCopyBegin = CBool(userFormShow(dBEXmoveOrCopy, caption))

End Function

Private Function generateNewName() As String
        
    With p_currentRepoSheet
        Dim j As Integer
        For j = 1 To 9999
            Dim newName As String
            newName = cXLnameTag & Format(j, "0000")
            Dim i As Integer
            For i = .Cells(cRepoRCounts, cRepoCQ) + cRepoRTop - 1 To cRepoRTop Step -1
                If .Cells(i, cRepoCQPrefix) = newName Then GoTo nextTry
            Next i
            generateNewName = newName
            Exit Function
nextTry:
        Next j
    End With
    generateNewName = ""
    userError "createNameFailed"

End Function
Attribute VB_Name = "cBEXrepository"
Option Private Module
Option Explicit
'----- persistent storage of query definition tables

Public Function repoReadTable(repoSheet As Worksheet, indexcolumn As Integer, tableName As String) As Boolean
    ' copies one table buffer from the repo grid to a table object
    
    repoReadTable = False
    If Not tableReset(tableName) Then Exit Function
    repoReadTable = True
    
    If repoSheet Is Nothing Then Exit Function ' table is returned empty !
    With repoSheet
        
        timerStart cTimerReadDefinition
    
        Dim myTable As Object
        Set myTable = p_tables(tableName)
        myTable.Columns.keycolumn = 0 ' temporary, avoids a problem in the table ocx
    
        Dim tableWidth As Integer
        tableWidth = myTable.Columns.Count
        .Cells(cRepoRWidths, indexcolumn) = tableWidth
    
        Dim i As Long
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, indexcolumn) - 1
            If .Cells(i, indexcolumn) = p_currentQueryIndex Then
                Dim myRow As Object
                Set myRow = myTable.Rows.Add
                Dim j As Integer
                For j = 1 To tableWidth
                    myRow.Value(j) = .Cells(i, indexcolumn + j)
                Next j
            End If
        Next i
    
    End With
    
    timerStop cTimerReadDefinition
    
End Function
                    
Public Sub repoWriteTable(repoSheet As Worksheet, indexcolumn As Integer, tableName As String)
    ' copies the table's contents to the repo grid, destroying the previous version
        
    ' Store the current calculation mode and set the calculation mode to        ND:5-027
    ' Manual to avoid trigerring of the calaculation event when repository      ND:5-027
    Dim lCalculationMode 'As XlCalculation                                      VBR:6-030
    lCalculationMode = Application.Calculation
    Application.Calculation = xlCalculationManual
    
    ' steal focus from offending controls, seems to be important under Win2K
    If Not ActiveCell Is Nothing Then
        ActiveCell.activate
    Else
    On Error Resume Next ' neccessary if ActiveSheet is a Chartsheet
        If Not ActiveSheet Is Nothing Then ActiveSheet.Cells(1, 1).activate
    On Error GoTo 0
    End If
        
    timerStart cTimerWriteDefinition
    On Error GoTo leave
    
    Dim myTable As Object:  Set myTable = p_tables(tableName)
    
    With repoSheet
        
        Dim tableWidth As Integer
        tableWidth = myTable.Columns.Count
        .Cells(cRepoRWidths, indexcolumn) = tableWidth
        
        repoClearTable repoSheet, indexcolumn, False
        
        Dim i As Long
        i = cRepoRTop + .Cells(cRepoRCounts, indexcolumn)

        Dim j As Integer                                                'VBR:11-052
        Dim k As Long                                                   'VBR:11-052
        If myTable.rowCount > 0 Then                                    'VBR:11-052
          ReDim cellArray(1 To myTable.rowCount, 0 To tableWidth)       'VBR:11-052
        End If                                                          'VBR:11-052
        
        Dim myRow As Object
        For Each myRow In myTable.Rows
'            .Cells(i, indexcolumn) = p_currentQueryIndex              'VBR:11-052
            k = k + 1                                                   'VBR:11-052
            cellArray(k, 0) = p_currentQueryIndex                       'VBR:11-052

            For j = 1 To tableWidth
'                .Cells(i, indexcolumn + j) = "'" & myRow.cell(j)       'VBR:11-052
               cellArray(k, j) = "'" & myRow.cell(j)                    'VBR:11-052
            Next j
'            i = i + 1                                                  'VBR:11-052
        Next myRow
'        .Cells(cRepoRCounts, indexcolumn) = i - cRepoRTop              'VBR:11-052
        
        .Cells(cRepoRCounts, indexcolumn) = i + k - cRepoRTop           'VBR:11-052
        If myTable.rowCount > 0 Then                                    'VBR:11-052
            .Cells(i, indexcolumn).Resize(k, tableWidth + 1) = cellArray    'VBR:11-052
        End If                                                              'VBR:11-052

    End With
    
leave:
    If Err Then userError "writeTable", , tableName
    timerStop cTimerWriteDefinition

    ' Update the calculation mode back to the original set by the user.             ND:5-027
    Application.Calculation = lCalculationMode

End Sub

Public Sub repoClearTable(repoSheet As Worksheet, indexcolumn As Integer, Optional adjustIndex As Boolean)
    ' deletes one table buffer from the repo grid
    
    screenHalt
    activationBackup True
    
    With repoSheet
        
        .activate
                
        Dim rightColumn As Integer: rightColumn = indexcolumn + .Cells(cRepoRWidths, indexcolumn)
        Dim firstRow As Long
        Dim lastRow As Long
        
        Dim i As Long
        For i = .Cells(cRepoRCounts, indexcolumn) + cRepoRTop - 1 To cRepoRTop Step -1
            If .Cells(i, indexcolumn) = p_currentQueryIndex Then
                firstRow = i
                If lastRow = 0 Then lastRow = i
            Else
                If lastRow > 0 Then
                    .Range(.Cells(firstRow, indexcolumn), .Cells(lastRow, rightColumn)).Delete Shift:=xlUp
                    .Cells(cRepoRCounts, indexcolumn) = .Cells(cRepoRCounts, indexcolumn) - lastRow + firstRow - 1
                    lastRow = 0
                End If
                If adjustIndex And .Cells(i, indexcolumn) > p_currentQueryIndex Then
                    .Cells(i, indexcolumn) = .Cells(i, indexcolumn) - 1
                End If
            End If
        Next i
        
        If lastRow > 0 Then
            .Range(.Cells(firstRow, indexcolumn), .Cells(lastRow, rightColumn)).Delete Shift:=xlUp
            .Cells(cRepoRCounts, indexcolumn) = .Cells(cRepoRCounts, indexcolumn) - lastRow + firstRow - 1
            lastRow = 0
        End If
        
    End With
    
    activationRestore
    screenRestore

End Sub

Public Sub repoCopyTable(repoSheet As Worksheet, indexcolumn As Integer, newIndex As Integer, fromReposheet As Worksheet)
    ' copies one table buffer from fromRepoSheet to the current one, associating it with query index "newIndex"
    
    With repoSheet
         
        .Cells(cRepoRWidths, indexcolumn) = fromReposheet.Cells(cRepoRWidths, indexcolumn)
        
        Dim rightColumn As Integer: rightColumn = indexcolumn + .Cells(cRepoRWidths, indexcolumn)
        Dim newRow As Long
        newRow = .Cells(cRepoRCounts, indexcolumn) + cRepoRTop
        
        Dim i As Long
        For i = cRepoRTop To fromReposheet.Cells(cRepoRCounts, indexcolumn) + cRepoRTop - 1
            If fromReposheet.Cells(i, indexcolumn) = p_currentQueryIndex Then
                fromReposheet.Range(fromReposheet.Cells(i, indexcolumn), fromReposheet.Cells(i, rightColumn)).Copy
                .Range(.Cells(newRow, indexcolumn), .Cells(newRow, rightColumn)).PasteSpecial
                .Cells(newRow, indexcolumn) = newIndex
                newRow = newRow + 1
            End If
        Next i

        .Cells(cRepoRCounts, indexcolumn) = newRow - cRepoRTop
        
    End With

End Sub

Public Function repoReadQuery() As Boolean
    ' if p_currentreposheet is nothing, return an empty definition (i.e. reset all the relevant tables)
    
    repoReadQuery = False
    
    If Not dialIn Then Exit Function
    
    If Not p_currentRepoSheet Is Nothing Then
        If p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) >= cV20 And p_versionServer < cV20 Then
            ' can't fling a 2.0 query definition against a 1.2 system !
            userError "queryRequire20", , RunGetResultAddress(p_currentQueryIndex)
            Exit Function
        End If
    End If

    If Not repoReadTable(p_currentRepoSheet, cRepoCD, "E_T_DIM") Then Exit Function
    If Not repoReadTable(p_currentRepoSheet, cRepoCM, "E_T_MEM") Then Exit Function
    If Not repoReadTable(p_currentRepoSheet, cRepoCA, "E_T_ATR") Then Exit Function
    If Not repoReadTable(p_currentRepoSheet, cRepoCC, "E_T_CEL") Then Exit Function
    If Not repoReadTable(p_currentRepoSheet, cRepoCT, "C_T_HRY_TYPES") Then Exit Function
    If Not repoReadTable(p_currentRepoSheet, cRepoCP, "E_T_PRPTYS") Then Exit Function
        
    If p_versionServer >= cV20 Then
        Dim myConFacSheet As Worksheet
        If Not p_currentRepoSheet Is Nothing Then Set myConFacSheet = ConFacSheetGet(True)
        If Not repoReadTable(myConFacSheet, cRepoCF, "E_T_FAC") Then Exit Function
        If Not repoReadTable(myConFacSheet, cRepoCN, "E_T_CON") Then Exit Function
        If p_versionServer > cV20 Then
            If Not repoReadTable(myConFacSheet, cRepoCX, "C_T_DRILL") Then Exit Function
        End If
    End If
    
    repoReadQuery = True

End Function

Public Sub repoWriteQuery(Optional fullDefinition As Boolean)
    ' set query definition according to input from Process_Command or from QueryBuilder
    
    screenHalt ' otherwise repoWriteTable may flicker ...
    IgnoreRemoteBegin
    
    repoWriteTable p_currentRepoSheet, cRepoCD, "E_T_DIM"
    p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQDefVersion) = p_versionServer
    
    repoWriteTable p_currentRepoSheet, cRepoCM, "E_T_MEM"
    repoWriteTable p_currentRepoSheet, cRepoCA, "E_T_ATR"
    repoWriteTable p_currentRepoSheet, cRepoCP, "E_T_PRPTYS"
    repoWriteTable p_currentRepoSheet, cRepoCT, "C_T_HRY_TYPES"
    
    'If fullDefinition Then
        repoWriteTable p_currentRepoSheet, cRepoCC, "E_T_CEL"
    'End If
    
    If p_versionServer >= cV20 Then
        Dim myConFacSheet As Worksheet: Set myConFacSheet = ConFacSheetGet(True)
        repoWriteTable myConFacSheet, cRepoCF, "E_T_FAC"
        repoWriteTable myConFacSheet, cRepoCN, "E_T_CON"
        If p_versionServer > cV20 Then
            repoWriteTable myConFacSheet, cRepoCX, "C_T_DRILL"
        End If
    End If
    
    With p_currentRepoSheet ' store properties redundant for easier access
        .Cells(p_currentQueryIndex, cRepoCQStyles) = Not repoGetProperty(cPropNoStyles)
        .Cells(p_currentQueryIndex, cRepoCQFlat) = repoGetProperty(cPropFlat)
        .Cells(p_currentQueryIndex, cRepoCQTransient) = repoGetProperty(cPropTransient)
    End With

    IgnoreRemoteEnd
    screenRestore
    
End Sub

Public Function repoGetProperty(propID As Integer) As Boolean
    
    repoGetProperty = False
    With p_currentRepoSheet
        Dim i As Long
        For i = .Cells(cRepoRCounts, cRepoCP) + cRepoRTop - 1 To cRepoRTop Step -1
            If .Cells(i, cRepoCP) = p_currentQueryIndex And _
                 CInt(.Cells(i, cRepoCPID)) = propID And _
                 .Cells(i, cRepoCPValue) = "X" Then
                repoGetProperty = True
                Exit Function
            End If
        Next i
    End With
    
End Function

Public Function repoSetProperty(propID As Integer, propValue As Variant) As Boolean
    
    With p_currentRepoSheet
    
        Dim newValue As Boolean
        Dim i As Long
        
        For i = .Cells(cRepoRCounts, cRepoCP) + cRepoRTop - 1 To cRepoRTop Step -1
            If .Cells(i, cRepoCP) = p_currentQueryIndex And _
                CInt(.Cells(i, cRepoCPID)) = propID Then GoTo setValue
        Next i
        
        newValue = True
        .Cells(cRepoRCounts, cRepoCP) = .Cells(cRepoRCounts, cRepoCP) + 1
        i = .Cells(cRepoRCounts, cRepoCP) + cRepoRTop - 1
        .Cells(i, cRepoCP) = p_currentQueryIndex
        .Cells(i, cRepoCPID) = propID
     
setValue:
        ' return TRUE only if property had a different value before
        repoSetProperty = newValue Or (Trim(.Cells(i, cRepoCPValue)) <> propValue)
        .Cells(i, cRepoCPValue) = propValue
        
    End With

End Function

Public Function repoSetPropertyBoolean(propID As Integer, propValue As Boolean) As Boolean
    repoSetPropertyBoolean = repoSetProperty(propID, IIf(propValue, "X", ""))
End Function


'----- locating queries on the worksheet

Public Function repoDetectQueryDefault() As Boolean

    ' repoDetectQuery must be tried first to set p_currentSelection even if there's only one "default" query
    If repoDetectQuery(ActiveCell) Then
        repoDetectQueryDefault = True
    Else
        repoDetectQueryDefault = False
        Set p_currentRepoSheet = repoGetRepoSheet(ActiveSheet.Parent, False)
        If p_currentRepoSheet Is Nothing Then Exit Function
        If p_currentRepoSheet.Cells(cRepoRCounts, cRepoCQ) = 1 Then
            p_currentQueryIndex = cRepoRTop
            repoDetectQueryDefault = True
        End If
    End If
        
End Function

Public Function repoDetectFilter(atTarget As Range) As Boolean
    
    ' if query is detected at given cell, global variables g_current... are set accordingly
    
    Set p_currentRepoSheet = repoGetRepoSheet(atTarget.Worksheet.Parent, False)
    If p_currentRepoSheet Is Nothing Then
        p_currentQueryIndex = 0
        p_currentFilterIndex = 0
        repoDetectFilter = False
    Else
        p_currentFilterIndex = repoGetFilterIndex(atTarget)
        If p_currentFilterIndex Then
            If p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName) = "" Then p_currentFilterIndex = 0
        End If
        If p_currentFilterIndex Then
            p_currentQueryIndex = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCD)
            repoDetectFilter = True
        Else
            p_currentQueryIndex = 0
            repoDetectFilter = False
        End If
    End If

End Function

Private Function repoGetQueryIndex(atTarget As Range) As Integer

    repoGetQueryIndex = 0
    With p_currentRepoSheet
        On Error Resume Next
        ' test for all the result ranges, whether they contain atCell
        Dim i As Long
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCQ) - 1
            Dim testRange As Range, intersectRange As Range
            Set testRange = Nothing
            Set testRange = RunGetResultRange(i)
            Set intersectRange = Nothing
            Set intersectRange = Intersect(testRange, atTarget)
            If Not intersectRange Is Nothing Then
                Set atTarget = intersectRange
                Set p_currentSelection = atTarget
                p_currentSelYoffset = testRange.row
                p_currentSelXoffset = testRange.column
                repoGetQueryIndex = i
                Exit Function
            End If
            ' range is missing, is not in atCell's sheet, does not contain atCell, or ...
        Next i
    
    End With

End Function

Private Function repoGetFilterIndex(atTarget As Range) As Integer

    repoGetFilterIndex = 0
    With p_currentRepoSheet
        On Error Resume Next
        ' test for all the filter ranges, whether they contain atTarget
        Dim i As Long
        For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
            Dim intersectRange As Range
            Set intersectRange = Nothing
            Set intersectRange = Intersect(RunGetFilterRange(i), atTarget)
            If Not intersectRange Is Nothing Then
                Set atTarget = intersectRange
                repoGetFilterIndex = i
                Exit Function
            End If
            ' range is missing, is not in atTarget's sheet, does not contain atTarget's upper left cell, or ...
        Next i
    End With

End Function

Public Function repoDetectQuery(atTarget As Range, Optional selectRange As String = cRangeAny) As Boolean

    Set p_currentSelection = Nothing
    Set p_currentConFacSheet = Nothing
    p_currentSelYoffset = 0
    p_currentSelXoffset = 0
    p_currentQueryIndex = 0
    p_currentFilterIndex = 0
    p_currentConFacIndex = 0
    repoDetectQuery = False
    
    If atTarget Is Nothing Then Exit Function
    Set p_currentRepoSheet = repoGetRepoSheet(atTarget.Worksheet.Parent, False)
    If p_currentRepoSheet Is Nothing Then Exit Function
    
    Dim nameTag As String:  nameTag = cRepoSheetName & "!" & cXLnameTag
    Dim lenNameTag As Byte: lenNameTag = Len(nameTag)
    On Error Resume Next ' intersecting ranges on different sheets fails
    
    With p_currentRepoSheet
        
        Dim nm As Name
        For Each nm In .names
            Dim intersection As Range
            If Left(nm.Name, lenNameTag) = nameTag Then
            
                Set intersection = Intersect(nm.RefersToRange, atTarget)
                If Not intersection Is Nothing Then
                    
                    Dim queryIndex As Long: queryIndex = 0
                    Dim prefix As String:   prefix = Mid(nm.Name, Len(cRepoSheetName) + 2, cXLnameTagLen + 4)
                    Dim i As Long
                    For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCQ) - 1
                        If .Cells(i, cRepoCQPrefix) = prefix Then
                            queryIndex = i
                            Exit For
                        End If
                    Next i
                    If queryIndex Then ' range belongs to existing query
                    
                        If Len(nm.Name) = lenNameTag + 4 Then ' range is result area
                            If selectRange = cRangeAny Or selectRange = cRangeResult Then
                                Set atTarget = intersection
                                Set p_currentSelection = atTarget
                                p_currentSelYoffset = nm.RefersToRange.row
                                p_currentSelXoffset = nm.RefersToRange.column
                                p_currentQueryIndex = queryIndex
                                repoDetectQuery = True
                                Exit Function
                            End If
                        Else
                            Select Case Mid(nm.Name, lenNameTag + 5, 1)
                                Case cRangeFilter ' range is filter range
                                    If selectRange = cRangeAny Or selectRange = cRangeFilter Then
                                        Dim charName As String: charName = Mid(nm.Name, lenNameTag + 6): charName = translate(charName, "?", "/")
                                        Dim j As Long
                                        For j = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
                                            If .Cells(j, cRepoCD) = queryIndex And .Cells(j, cRepoCDCharName) = charName Then
                                                p_currentFilterIndex = j
                                                p_currentQueryIndex = queryIndex
                                                repoDetectQuery = True
                                                Exit Function
                                            End If
                                        Next j
                                    End If
                                Case cRangeCondExc ' range is condition / exception range
                                    If selectRange = cRangeAny Or selectRange = cRangeCondExc Then
                                        Dim eltuid As String: eltuid = Mid(nm.Name, lenNameTag + 6)
                                        Dim myConFacSheet As Worksheet: Set myConFacSheet = ConFacSheetGet
                                        If Not myConFacSheet Is Nothing Then
                                            Dim k As Long
                                            For k = cRepoRTop To cRepoRTop + myConFacSheet.Cells(cRepoRCounts, cRepoCN) - 1
                                                If myConFacSheet.Cells(k, cRepoCN) = queryIndex And myConFacSheet.Cells(k, cRepoCNEltuid) = eltuid Then
                                                    Set p_currentConFacSheet = myConFacSheet
                                                    p_currentConFacIndex = k
                                                    p_currentQueryIndex = queryIndex
                                                    repoDetectQuery = True
                                                    Exit Function
                                                End If
                                            Next k
                                        End If
                                    End If
                                Case cRangeText ' range is text element
                                    If selectRange = cRangeAny Or selectRange = cRangeText Then
                                        p_currentQueryIndex = queryIndex
                                        repoDetectQuery = True
                                        Exit Function
                                    End If
                                Case Else
                            End Select
                        End If
                        
                    End If
                End If
            End If
        Next nm
    
    End With

End Function

'----- managing the hidden worksheets which store table content

Public Function repoGetRepoSheet(atBook As Workbook, createNew As Boolean) As Worksheet

    Dim mySheet As Worksheet
    On Error Resume Next
    Set mySheet = atBook.Worksheets(cRepoSheetName)
    Select Case Err
        Case 0 ' sheet was found
            On Error GoTo 0
            With mySheet
                If .Cells(cRepoRGlobal, cRepoCVersion) = 8 Then ' convert to version 9
                    .Columns("GD:GF").Cut Destination:=.Range("HW1")
                    .Columns("EP:GC").Cut Destination:=.Range("FY1")
                    .Columns("EF:EO").Cut Destination:=.Range("EU1")
                    .Columns("DQ:EE").Cut Destination:=.Range("EA1")
                    .Columns("CW:DP").Cut Destination:=.Range("DG1")
                    .Columns("CC:CV").Cut Destination:=.Range("CM1")
                    .Columns("AO:CB").Cut Destination:=.Range("AE1")
                    .Cells(cRepoRGlobal, cRepoCVersion) = 9
                End If
                If .Cells(cRepoRGlobal, cRepoCVersion) = cRepoMajorVersion Then
                    Set repoGetRepoSheet = mySheet
                Else
                    If createNew Then
                        If userError("confirmWrongVersionAdd", vbQuestion + vbYesNo) = vbYes Then
                            .Cells.Clear
                            Set repoGetRepoSheet = initRepoSheet(mySheet)
                        Else
                            Set repoGetRepoSheet = Nothing
                        End If
                    Else
                        userError "wrongVersion"
                        Set repoGetRepoSheet = Nothing
                    End If
                End If
            End With
        Case 9 ' sheet with this name does not exist
            On Error GoTo createFailed
            If createNew Then
                activationBackup True, False
                screenHalt
                Set repoGetRepoSheet = initRepoSheet(atBook.Worksheets.Add)
                screenRestore
                activationRestore
                addCodeModule atBook
            Else
                Set repoGetRepoSheet = Nothing
            End If
        Case Else
            Error Err
    End Select
    
    Exit Function
createFailed:
    userError "repoCreateFailed"
    Set repoGetRepoSheet = Nothing
    
End Function

Private Function initRepoSheet(mySheet As Worksheet) As Worksheet
    With mySheet
        .Name = cRepoSheetName
        .Cells(cRepoRGlobal, cRepoCVersion) = cRepoMajorVersion
        .Cells(cRepoRWidths, cRepoCQ) = cRepoQueryTableWidth
        .Visible = xlSheetVeryHidden
    End With
    Set initRepoSheet = mySheet
End Function

Private Sub addCodeModule(wb As Workbook)
                
    On Error Resume Next
    With wb.VBProject.VBComponents
        Dim myModule As Object
        Set myModule = .Item("SAPBEX")
        If Err <> 0 Then
            Err = 0       ' XP! Note 574596
            Set myModule = .Add(1)
            myModule.Name = "SAPBEX"
        End If
    End With
    
    With myModule.CodeModule
        If .ProcStartLine(cVBExit, 0) = 0 Then
            .AddFromString "sub " & cVBExit & "(queryID As String, resultArea As Range)" & vbNewLine & vbNewLine & "End Sub"
        End If
    End With

End Sub
Attribute VB_Name = "cBEXrfc"
Option Private Module
Option Explicit

' these functions are only defined on W2K and later and Windows ME and Later.
Declare Function LockSetForegroundWindow Lib "user32.dll" (ByVal uLockCode As Long) As Long
Public Const LSFW_UNLOCK = 2
Declare Function AllowSetForegroundWindow Lib "user32.dll" (ByVal dwProcessId As Long) As Long
Private Const ASFW_ANY As Long = (-1)


Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (lpVersionInformation As OSVERSIONINFO) As Long

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128 ' Maintenance string for PSS usage
 End Type

Private Declare Function RfcAllocParamSpace Lib "librfc32" (ByVal numexp As Long, ByVal numimp As Long, ByVal numtab As Long) As Long
Private Declare Function RfcFreeParamSpace Lib "librfc32" (ByVal hspace As Long) As Integer
Private Declare Function RfcAddTable Lib "librfc32" (ByVal hspace As Long, ByVal tabpos As Long, ByVal tabname As String, _
    ByVal tabnamelen As Long, ByVal tabtype As Long, ByVal tablen As Long, ByVal tabhandle As Long) As Integer
Private Declare Function RfcAddExportString Lib "librfc32" Alias "RfcAddExportParam" (ByVal hspace As Long, ByVal parpos As Long, _
    ByVal parname As String, ByVal parnamelen As Long, ByVal partype As Long, ByVal parlen As Long, ByVal par As String) As Integer
Private Declare Function RfcAddExportParam Lib "librfc32" (ByVal hspace As Long, ByVal parpos As Long, _
    ByVal parname As String, ByVal parnamelen As Long, ByVal partype As Long, ByVal parlen As Long, par As Any) As Integer
Private Declare Function RfcAddImportParam Lib "librfc32" (ByVal hspace As Long, ByVal parpos As Long, _
    ByVal parname As String, ByVal parnamelen As Long, ByVal partype As Long, ByVal parlen As Long, par As Any) As Integer

Private Declare Function RfcCallExt Lib "librfc32" (ByVal hRfc As Long, ByVal hspace As Long, ByVal funcname As String) As Integer
Private Declare Function RfcReceiveExt Lib "librfc32" (ByVal hRfc As Long, ByVal hspace As Long, ByVal exception As String) As Integer
Private Declare Function RfcCancel Lib "librfc32" (ByVal hRfc As Long, ByVal cancel_type As Integer) As Integer
' note: currently only cancel_type = 2 (RFC_CANCEL_CLOSE) is supported!

Private Declare Function SystemParametersInfo Lib "USER32" Alias "SystemParametersInfoA" ( _
    ByVal uAction As Long, ByVal uParam As Long, ByRef lpvParam As Any, ByVal fuWinIni As Long) As Long

Private Const SPI_SETFOREGROUNDLOCKTIME As Long = &H2001

' ----- general routines for preparing parameter spaces and for calling functions

Private Sub addParamTable(paramSpace As Long, myItem As Integer, paramName As String, Optional tableName As String)
    If tableName = "" Then tableName = paramName
    With p_tables(tableName).rfcparameter
        RfcAddTable paramSpace, myItem, paramName, Len(paramName), .Type, .rowlength, .tableHandle
    End With
End Sub

Private Function callOLAPmsg(functionName As String, paramSpace As Long) As Boolean
    If versionFault(True) Then
       callOLAPmsg = callOLAP(functionName, paramSpace)
    Else ' 2.0 release may try to send system messages
       callOLAPmsg = callOLAPVisible(functionName, paramSpace)
    End If
End Function

Public Function SAPGUI2front() As Boolean
 'Disable pusing the sapgui to front
 'BUGFIX Note : 753342 Message : 0000015612 2004
 If RegistryGet("", "GUI2FRONT") = "DISABLE" Or _
     RegistryGet("", "GUI2FRONT", True) = "DISABLE" Then
         SAPGUI2front = True
         Exit Function
 End If
 
 p_manageGUI = True
    ' no harm done doing it all time
     If (IsWinMeor2KorGreater()) Then
     Dim lRes As Boolean
        ' for NT5, 98, ..., RSAH_ENSURE_GUI_VISIBLE would fail if the Foreground-Locktime is non-zero
        Dim win98fix As Long: win98fix = SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIME, 0, ByVal 0, 0)
        lRes = AllowSetForegroundWindow(ASFW_ANY)
        Call trace(False, "Called AllowSetForegroundWindow, Result: " & lRes & "(<>0 is good)")
        lRes = LockSetForegroundWindow(LSFW_UNLOCK)
        Call trace(False, "Called LockSetForegroundWindow, Result: " & lRes & "(<>0 is good)")
     End If
     If p_manageGUI Then
        ' we explicitely release the handle
        Dim myParamSpace As Long:   myParamSpace = RfcAllocParamSpace(0, 0, 0)
        SAPGUI2front = callOLAP("RSAH_ENSURE_GUI_VISIBLE", myParamSpace, False)
        RfcFreeParamSpace myParamSpace
     Else
        SAPGUI2front = True
     End If

'    If p_manageGUI Then
'        ' for NT5, 98, ..., RSAH_ENSURE_GUI_VISIBLE would fail if the Foreground-Locktime is non-zero
'        Dim win98fix As Long: win98fix = SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIME, 0, ByVal 0, 0)
'        Dim myParamSpace As Long:   myParamSpace = RfcAllocParamSpace(0, 0, 0)
'        SAPGUI2front = callOLAP("RSAH_ENSURE_GUI_VISIBLE", myParamSpace, False)
'        RfcFreeParamSpace myParamSpace
'    Else
'        SAPGUI2front = True
'    End If
End Function

Private Sub SAPGUI2invisible()
 If RegistryGet("", "GUI2FRONT") = "DISABLE" Or _
     RegistryGet("", "GUI2FRONT", True) = "DISABLE" Then
         Exit Sub
 End If
    If p_manageGUI Then
        Dim eSwitch As String * 1:  eSwitch = " "
        Dim myParamSpace As Long:   myParamSpace = RfcAllocParamSpace(1, 0, 0)
        RfcAddExportString myParamSpace, 0, "SWITCH", 6, 0, 1, eSwitch
        callOLAP "RSAH_ENSURE_GUI_VISIBLE", myParamSpace, False
        RfcFreeParamSpace myParamSpace
    End If
End Sub

Private Function callOLAPVisible(functionName As String, paramSpace As Long) As Boolean
    ' SAPGUI window must be in front of Excel's main window during RFC calls, if the module called may possibly send a pop-up
    
    If SAPGUI2front Then                                        ' 1. bring SAPGUI to front
        On Error Resume Next
        Application.CutCopyMode = False
        On Error GoTo 0
        callOLAPVisible = callOLAP(functionName, paramSpace)    ' 2. call function module
    Else                                                        '   (SAPGUI wil become visible automatically,
        callOLAPVisible = False                                 '   if a pop-up arrives during the call)
    End If
    
    #If ABAPDebug = 0 Then
        SAPGUI2invisible                                        ' 3. make SAPGUI invisible
    #End If
    Application.Visible = True                                  ' 4. bring Excel to front
    
End Function

Private Function callOLAP(functionName As String, paramSpace As Long, Optional cancelAllowed As Boolean) As Boolean
    
    callOLAP = False
    If dialIn Then
        
        Dim rfcHandle As Long:                  rfcHandle = p_connectionObj.ConnectionHandle
        Dim rfcFunctionName As String * 80:     rfcFunctionName = functionName & vbNullChar
    
        pingTimeHalt
        If (IsWinMeor2KorGreater()) Then
          Dim lRes As Long
        ' for NT5, 98, ..., RSAH_ENSURE_GUI_VISIBLE would fail if the Foreground-Locktime is non-zero
          Dim win98fix As Long: win98fix = SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIME, 0, ByVal 0, 0)
          lRes = LockSetForegroundWindow(LSFW_UNLOCK)
          Call trace(False, "Called LockSetForegroundWindow, Result: " & lRes)
          lRes = AllowSetForegroundWindow(ASFW_ANY)
          Call trace(False, "Called AllowSetForegroundWindow, Result: " & lRes)
          lRes = LockSetForegroundWindow(LSFW_UNLOCK)
          Call trace(False, "Called LockSetForegroundWindow, Result: " & lRes)
        End If
        If RfcCallExt(rfcHandle, paramSpace, rfcFunctionName) = 0 Then
            
            If cancelAllowed Then ' show progress indicator until RFC receive is possible
                ShowProgress
                IgnoreRemoteBegin
                ' cancel button must only be visible for R/3 basis >= 4.6c !!
                InitProgressRFC rfcHandle, userText("statusOLAP"), 4 * 500, p_connectionObj.SAPRelease >= "46C"
                If IsCancelled Then
                    trace True, "RFC is cancelled due to user intervention"
                    RfcCancel rfcHandle, 2
                    p_connectionObj.Logoff
                    trace False, "cancel/close: ok"
                    dialOutClearAllHandles
                    HideProgress
                    p_connectionObj.Logon 0, True
                    If initConnection Then
                        trace False, "logon again: ok"
                    End If
                    GoTo leave
                End If
            End If
            
            IgnoreRemoteBegin
            Dim rfcException As String * 255:   rfcException = Space(255)
            If (IsWinMeor2KorGreater()) Then
          ' for NT5, 98, ..., RSAH_ENSURE_GUI_VISIBLE would fail if the Foreground-Locktime is non-zero
                win98fix = SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIME, 0, ByVal 0, 0)
                    lRes = LockSetForegroundWindow(LSFW_UNLOCK)
          Call trace(False, "Called LockSetForegroundWindow, Result: " & lRes)
          lRes = AllowSetForegroundWindow(ASFW_ANY)
          Call trace(False, "Called AllowSetForegroundWindow, Result: " & lRes)
          lRes = LockSetForegroundWindow(LSFW_UNLOCK)
          Call trace(False, "Called LockSetForegroundWindow, Result: " & lRes)
            End If
            If RfcReceiveExt(rfcHandle, paramSpace, rfcException) = 0 Then
                trace True, "RFC function " & functionName & " returned ok"
                callOLAP = True
                GoTo leave
            Else
                trace True, "RFC receive " & functionName & " returned an error"
                trace False, "exception: " & rfcException
                ' display error info
                If p_connectionObj Is Nothing Then
                    userError "rfcReceive", , _
                        vbNewLine & userText("exception") & nullTrim(rfcException)
                Else
                    If userError("rfcReceive", vbCritical + vbYesNo, _
                        vbNewLine & userText("exception") & nullTrim(rfcException) & _
                        vbNewLine & userText("labelMore") _
                    ) = vbYes Then p_connectionObj.LastError
                End If
            End If
        Else
            trace True, "RFC call " & functionName & " returned an error"
            userError "rfcCall"
        End If

        If cancelAllowed Then HideProgress
        p_connectionObj.Logoff
        dialOut silent:=True
        dialInPause ' suppress further logon dialogs for 2 secs
    
leave:
        IgnoreRemoteEnd
        pingTimeContinue
    
    End If
    
End Function

' ----- wrappers for functions in group RRY1

Function rfcInitSession() As Boolean

    Dim eTraceMode As String * 1:   eTraceMode = IIf(checkTrace, "X", " ")
    Dim appReturn As Long

    If Not tableReset("E_T_PRPTYS") Then Exit Function
    With Application
        
        Dim y As String:    y = IIf(.International(xl4DigitYears), "YYYY", "YY")
        Dim m As String:    m = IIf(.International(xlMonthLeadingZero), "MM", "M")
        Dim d As String:    d = IIf(.International(xlDayLeadingZero), "DD", "D")
        Dim dateSep As String * 1:  dateSep = .International(xlDateSeparator)
        addProperty cPropMaskDate, Choose(.International(xlDateOrder) + 1, _
            m & dateSep & d & dateSep & y, _
            d & dateSep & m & dateSep & y, _
            y & dateSep & m & dateSep & d _
        )
        
        Dim timeSep As String * 1:  timeSep = .International(xlTimeSeparator)
        addProperty cPropMaskTime, "HH" & timeSep & "MM" & timeSep & "SS"
        addProperty cPropDCPChar, .International(xlDecimalSeparator)
       
        Select Case .International(xlCurrencyNegative)
            Case 0:     addProperty cPropNegNumbers, "3"
            Case 2, 3:  addProperty cPropNegNumbers, "2"
        End Select

    End With

    addProperty cPropPercentFrac, " "
    addProperty cPropTilingSize, cTilingSize
    addProperty cPropTilingLimit, cTilingLimit
    addProperty cPropTilFmtSize, cTilFmtSize
    addProperty cPropTilFmtLimit, cTilFmtLimit
    addProperty cPropReqVersion, cVersionFrontend

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 1, 1)
    RfcAddExportString paramSpace, 0, "I_TRACE_MODE", 12, 0, 1, eTraceMode
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
    addParamTable paramSpace, 0, "C_T_PRPTYS", "E_T_PRPTYS"

    ' visible call, to allow for system messages be displayed
    rfcInitSession = IIf(callOLAPVisible("RRY_SESSION_INITIALIZE", paramSpace), noAppErrors(appReturn, 0), False)
    RfcFreeParamSpace paramSpace
    
End Function

Private Sub addProperty(propID As Integer, propValue As String)
    Dim rowProps As Object
    Set rowProps = p_tables("E_T_PRPTYS").Rows.Add
    rowProps("ID") = Format(propID, "0000000000")
    rowProps("VALUE") = propValue
End Sub

Private Sub setProperty(propID As Integer, propValue As String)
    Dim rowProps As Object
    For Each rowProps In p_tables("E_T_PRPTYS").Rows
        If rowProps("ID") = propID Then
            rowProps("VALUE") = propValue
            Exit Sub
        End If
    Next rowProps
    addProperty propID, propValue
End Sub

Function rfcCheckBW() As Boolean

    Dim eFName As String * 30:          eFName = fixLen("RSAH_LAUNCH_EXCEL", 30)
    Dim rfcException As String * 255:   rfcException = Space(255)
    Dim rfcFunctionName As String * 80: rfcFunctionName = "RFC_FUNCTION_SEARCH" & vbNullChar

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 0, 0)
    RfcAddExportString paramSpace, 0, "FUNCNAME", 8, 0, 30, eFName
    
    rfcCheckBW = False
    If RfcCallExt(p_connectionObj.ConnectionHandle, paramSpace, rfcFunctionName) = 0 Then
        If RfcReceiveExt(p_connectionObj.ConnectionHandle, paramSpace, rfcException) = 0 Then
            rfcCheckBW = True
        Else
            If Left(rfcException, 17) = "NO_FUNCTION_FOUND" Then userError "notBWserver"
            If Left(rfcException, 14) = "SYSTEM_FAILURE" Then userError "notRFCauthorized"
        End If
    End If
    
    RfcFreeParamSpace paramSpace

End Function

Function rfcOpenQuery(queryID As String, ByRef handle As Integer) As Boolean
        
    timerStart cTimerRfcOpen
        
    Dim eQueryID As String * 25:    eQueryID = fixLen(queryID, 25)
    Dim eTraceMode As String * 1:   eTraceMode = IIf(checkTrace, "X", " ")
    Dim appReturn As Long
    Dim longHandle As Long
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(2, 2, 0)
    RfcAddExportString paramSpace, 0, "I_GENUNIID", 10, 0, 25, eQueryID
    RfcAddExportString paramSpace, 1, "I_TRACE_MODE", 12, 0, 1, eTraceMode
    RfcAddImportParam paramSpace, 0, "E_HANDLE_INT", 12, 8, 4, longHandle
    RfcAddImportParam paramSpace, 1, "E_SUBRC", 7, 8, 4, appReturn
    
    rfcOpenQuery = IIf(callOLAPmsg("RRY_REPORT_OPEN", paramSpace), noAppErrors(appReturn, 0), False)
    handle = CInt(longHandle)
    RfcFreeParamSpace paramSpace
    
    timerStop cTimerRfcOpen
        
End Function

Sub rfcCloseQuery(handle As Integer)

    If handle Then

        Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
        Dim appReturn As Long
        
        Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 1, 0)
        RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
        RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
        
        If callOLAPmsg("RRY_REPORT_CLOSE", paramSpace) Then noAppErrors appReturn, handle
        RfcFreeParamSpace paramSpace
        
    End If
    
End Sub

Function rfcFlushVariables(handle As Integer, showScreen As Boolean) As Boolean

    timerStart cTimerRfcVariables
    
    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    Dim eScreen As String * 1:      eScreen = "U"
    Dim appReturn As Long
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(IIf(showScreen, 2, 1), 1, 1)
    RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
    If showScreen Then RfcAddExportString paramSpace, 1, "I_SELSCRN", 9, 0, 1, eScreen
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
    addParamTable paramSpace, 0, "C_T_VARIABLES"
    
    rfcFlushVariables = IIf(callOLAPVisible("RRY_VARIABLES_FLUSH", paramSpace), noAppErrors(appReturn, handle), False)
    RfcFreeParamSpace paramSpace
    
    timerStop cTimerRfcVariables
    
End Function

Function rfcGetTextSymbols(handle As Integer) As Boolean
    
    timerStart cTimerRfcTexts
    
    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    Dim appReturn As Long

    'check for japense customer for vaiable screen by i035331

    If (handle = 0) Then
        Exit Function
    End If

    If Not tableReset("E_T_TXT_SYMBOLS") Then Exit Function
    If p_versionServer > cV20 Then
        If Not tableReset("E_T_DOC_LIST") Then Exit Function
        If Not tableReset("E_T_TEXT") Then Exit Function
    End If
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 1, versionInt(3, 1))
    RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
    addParamTable paramSpace, 0, "E_T_TXT_SYMBOLS"
    If p_versionServer > cV20 Then
        addParamTable paramSpace, 1, "E_T_DOC_LIST"
        addParamTable paramSpace, 2, "E_T_TEXT"
    End If

    rfcGetTextSymbols = IIf(callOLAPmsg("RRY_TEXT_SYMBOLS_GET", paramSpace), noAppErrors(appReturn, handle), False)
    RfcFreeParamSpace paramSpace
    
    timerStop cTimerRfcTexts
    
End Function

Function rfcGetGridContinue(handle As Integer) As Boolean

    timerStart cTimerRfcFillGrid

    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    Dim appReturn As Long
    Dim maxX As Long
    Dim maxY As Long
    
    If Not tableReset("E_T_GRID") Then Exit Function
    If Not tableReset("E_T_RANGES") Then Exit Function
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 3, 2)
    RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
    RfcAddImportParam paramSpace, 0, "E_MAX_X", 7, 8, 4, maxX
    RfcAddImportParam paramSpace, 1, "E_MAX_Y", 7, 8, 4, maxY
    RfcAddImportParam paramSpace, 2, "E_SUBRC", 7, 8, 4, appReturn
    addParamTable paramSpace, 0, "E_T_GRID"
    addParamTable paramSpace, 1, "E_T_RANGES"

    Dim waited As Boolean
    rfcGetGridContinue = IIf(callOLAP("RRY_GRID_GET_CONTINUE", paramSpace), noAppErrors(appReturn, handle, waited), False)
    RfcFreeParamSpace paramSpace
    
    If Not waited Then
        p_gridWidth = maxX
        p_gridHeight = IIf(maxX, maxY, 0)
    End If

    timerStop cTimerRfcFillGrid

End Function

Function rfcGetGrid(handle As Integer, noTiling As Boolean) As Boolean

    timerStart cTimerRfcGetGrid
        
    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    Dim maxX As Long
    Dim maxY As Long
    Dim varChanged As Long
    Dim appReturn As Long
    
    If Not tableResetResultSet Then Exit Function
    If p_versionServer >= cV20 Then
        If Not tableReset("C_T_VARIABLES") Then Exit Function
    End If
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 4, versionInt(15, 12, 9))
    RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
    RfcAddImportParam paramSpace, 0, "E_MAX_X", 7, 8, 4, maxX
    RfcAddImportParam paramSpace, 1, "E_MAX_Y", 7, 8, 4, maxY
    RfcAddImportParam paramSpace, 2, "E_SUBRC", 7, 8, 4, appReturn
    RfcAddImportParam paramSpace, 3, "E_VAR_CHANGED", 13, 8, 4, varChanged
    
    addParamTable paramSpace, 0, "I_T_DIM", "E_T_DIM"
    addParamTable paramSpace, 1, "I_T_MEM", "E_T_MEM"
    addParamTable paramSpace, 2, "I_T_ATR", "E_T_ATR"
    addParamTable paramSpace, 3, "I_T_CEL", "E_T_CEL"
    addParamTable paramSpace, 4, "I_T_PRPTYS", "E_T_PRPTYS"
    addParamTable paramSpace, 5, "C_T_HRY_TYPES"
    
    addParamTable paramSpace, 6, "E_T_GRID"
    addParamTable paramSpace, 7, "E_T_RANGES"
    If p_versionServer > cV20 Then
        addParamTable paramSpace, 8, "E_T_SYMBOLS"
    Else
        addParamTable paramSpace, 8, "E_T_HRY_DISP"
    End If

    If p_versionServer >= cV20 Then
        addParamTable paramSpace, 9, "I_T_FAC", "E_T_FAC"
        addParamTable paramSpace, 10, "I_T_CON", "E_T_CON"
        addParamTable paramSpace, 11, "E_T_VAR", "C_T_VARIABLES"
    End If

    If p_versionServer > cV20 Then
        addParamTable paramSpace, 12, "C_T_DRILL"
        addParamTable paramSpace, 13, "E_T_TEXT"
        addParamTable paramSpace, 14, "E_T_DOC_LIST"
    End If

    If noTiling Then
        setProperty cPropTilingLimit, xlMaxRow
        setProperty cPropTilFmtLimit, xlMaxRow * xlMaxColumn
    End If
    
    Dim waited As Boolean
    rfcGetGrid = IIf(callOLAPmsg("RRY_GRID_GET", paramSpace), noAppErrors(appReturn, handle, waited), False)
    RfcFreeParamSpace paramSpace
    
    If noTiling Then ' reset query properties before definition is stored back
        setProperty cPropTilingLimit, cTilingLimit
        setProperty cPropTilFmtLimit, cTilFmtLimit
    End If
    
    If varChanged Then repoWriteTable p_currentRepoSheet, cRepoCV, "C_T_VARIABLES"
    
    If Not waited Then
        p_gridWidth = maxX
        p_gridHeight = IIf(maxX, maxY, 0)
    End If

    timerStop cTimerRfcGetGrid

End Function

Function rfcProcessCommand(handle As Integer, fCode As String, keepTop As Long, keepBot As Long, keepLeft As Long, keepRight As Long, objName As String, Optional params As Boolean, Optional jumpWait As Boolean) As Boolean

    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    Dim eFCode As String * 4:       eFCode = fixLen(fCode, 4)
    Dim eObjName As String * 30:    eObjName = fixLen(objName, 30)
    Dim maxX As Long
    Dim maxY As Long
    Dim varChanged As Long
    Dim appReturn As Long

    If Not tableResetResultSet Then Exit Function
    If Not tableResetDefinition Then Exit Function
    repoReadTable p_currentRepoSheet, cRepoCP, "E_T_PRPTYS"
    
    If p_versionServer >= cV20 Then
        If Not params Then If Not tableReset("I_T_CMD_PARAMS") Then Exit Function
        If p_versionServer > cV20 Then
            If Not tableReset("C_T_DRILL") Then Exit Function
        End If
    End If
    
    Dim paramSpace As Long
    paramSpace = RfcAllocParamSpace( _
        IIf(Len(objName), 3, 2), _
        versionInt(8, 6), _
        versionInt(17, 14, 10) _
    )
    RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
    RfcAddExportString paramSpace, 1, "I_CMDID", 7, 0, 4, eFCode
    ' eObjName was added as an input parameter in a later version!
    If Len(objName) Then RfcAddExportString paramSpace, 2, "I_IOBJNM", 8, 0, 30, eObjName
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
    RfcAddImportParam paramSpace, 1, "E_MAX_X", 7, 8, 4, maxX
    RfcAddImportParam paramSpace, 2, "E_MAX_Y", 7, 8, 4, maxY
    RfcAddImportParam paramSpace, 3, "E_KEEP_TOP", 10, 8, 4, keepTop
    RfcAddImportParam paramSpace, 4, "E_KEEP_BOT", 10, 8, 4, keepBot
    RfcAddImportParam paramSpace, 5, "E_VAR_CHANGED", 13, 8, 4, varChanged
    If p_versionServer > cV20 Then
        RfcAddImportParam paramSpace, 6, "E_KEEP_LEFT", 11, 8, 4, keepLeft
        RfcAddImportParam paramSpace, 7, "E_KEEP_RIGHT", 12, 8, 4, keepRight
    End If
    
    addParamTable paramSpace, 0, "I_T_RANGES"
    
    addParamTable paramSpace, 1, "E_T_GRID"
    addParamTable paramSpace, 2, "E_T_RANGES"
    If p_versionServer > cV20 Then
        addParamTable paramSpace, 3, "E_T_SYMBOLS"
    Else
        addParamTable paramSpace, 3, "E_T_HRY_DISP"
    End If
    
    addParamTable paramSpace, 4, "E_T_DIM"
    addParamTable paramSpace, 5, "E_T_ATR"
    addParamTable paramSpace, 6, "E_T_MEM"
    addParamTable paramSpace, 7, "E_T_CEL"
    addParamTable paramSpace, 8, "E_T_PRPTYS"
    addParamTable paramSpace, 9, "E_T_HRY_TYPES", "C_T_HRY_TYPES"

    If p_versionServer >= cV20 Then
        addParamTable paramSpace, 10, "E_T_FAC"
        addParamTable paramSpace, 11, "E_T_CON"
        addParamTable paramSpace, 12, "I_T_CMD_PARAMS"
        addParamTable paramSpace, 13, "E_T_VAR", "C_T_VARIABLES"
    End If

    If p_versionServer > cV20 Then
        addParamTable paramSpace, 14, "E_T_DRILL", "C_T_DRILL"
        addParamTable paramSpace, 15, "E_T_TEXT"
        addParamTable paramSpace, 16, "E_T_DOC_LIST"
    End If

    Dim waited As Boolean
    If fCode = "WAIT" Then
        rfcProcessCommand = IIf(callOLAP("RRY_GRID_CMD_PROCESS", paramSpace, True), noAppErrors(appReturn, handle), False)
    Else
        rfcProcessCommand = IIf(callOLAPVisible("RRY_GRID_CMD_PROCESS", paramSpace), noAppErrors(appReturn, handle, waited), False)
    End If
    RfcFreeParamSpace paramSpace
    
    ' you can't always trust the VAR_CHANGED flag ...
    If varChanged And Not jumpWait Then repoWriteTable p_currentRepoSheet, cRepoCV, "C_T_VARIABLES"
    
    If Not waited Then
        p_gridWidth = maxX
        p_gridHeight = IIf(maxX, maxY, 0)
    End If
        
End Function

Function rfcJump(handle As Integer, genUniID As String, ByVal jumpType As Long, _
                 ByVal jumpTarget As String) As Boolean

    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    Dim eWBID As String * 25:       eWBID = fixLen(IIf(jumpType = cJumpView, storageGetWBID(ActiveWorkbook), ""), 25)
    Dim eViewID As String * 40:     eViewID = fixLen(IIf(jumpType = cJumpView, jumpTarget, ""), 40)
    Dim eXViewID As String * 25:    eXViewID = fixLen(IIf(jumpType = cJumpAlert, jumpTarget, ""), 25)
    Dim eGViewID As String * 30:    eGViewID = fixLen(IIf(jumpType = cJumpViewGlobal, jumpTarget, ""), 30)
    Dim eBBSID As String * 8:       eBBSID = fixLen(IIf(jumpType = cJumpRepRep, jumpTarget, ""), 8)
    Dim appReturn As Long
    Dim maxX As Long
    Dim maxY As Long
    Dim longHandle As Long
    
    If Not tableResetResultSet Then Exit Function
    If Not tableReset("I_T_CMD_PARAMS") Then Exit Function
    If jumpType = cJumpRepRepFCode Then
        With p_tables("I_T_CMD_PARAMS")
            .Rows.Add
            .cell(1, 1) = "MENU"
            .cell(1, 2) = jumpTarget
        End With
    End If
    If p_versionServer > cV20 Then
        If Not tableReset("C_T_DRILL") Then Exit Function
    End If
    
    repoReadTable p_currentRepoSheet, cRepoCP, "E_T_PRPTYS"
    If Not tableResetDefinition Then Exit Function
    
    If Not tableReset("E_T_RETURNTEXTS") Then Exit Function
    With p_tables("E_T_RETURNTEXTS")
        .Rows.Add
        .cell(1, 1) = genUniID
    End With
    
    Dim paramSpace As Long
    If p_versionServer > cV20 Then
        paramSpace = RfcAllocParamSpace(6, 4, 18)
    Else
        paramSpace = RfcAllocParamSpace(5, 4, 15)
    End If
    RfcAddExportString paramSpace, 0, "I_HANDLE_SENDER", 15, 0, 4, eHandle
    RfcAddExportString paramSpace, 1, "I_VIEW_WBID", 11, 0, 25, eWBID
    RfcAddExportString paramSpace, 2, "I_VIEW_ID", 9, 0, 40, eViewID
    RfcAddExportString paramSpace, 3, "I_BBS_RECEIVER", 14, 0, 8, eBBSID
    RfcAddExportString paramSpace, 4, "I_EXCEPTION_VIEW", 16, 0, 25, eXViewID
    If p_versionServer > cV20 Then
        RfcAddExportString paramSpace, 5, "I_DATA_PROVIDER_ID", 18, 0, 30, eGViewID
    End If

    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
    RfcAddImportParam paramSpace, 1, "E_MAX_X", 7, 8, 4, maxX
    RfcAddImportParam paramSpace, 2, "E_MAX_Y", 7, 8, 4, maxY
    RfcAddImportParam paramSpace, 3, "E_HANDLE_INT", 12, 8, 4, longHandle
    
    addParamTable paramSpace, 0, "I_T_RANGES"
    
    addParamTable paramSpace, 1, "E_T_GRID"
    addParamTable paramSpace, 2, "E_T_RANGES"
    If p_versionServer > cV20 Then
        addParamTable paramSpace, 3, "E_T_SYMBOLS"
    Else
        addParamTable paramSpace, 3, "E_T_HRY_DISP"
    End If
    addParamTable paramSpace, 4, "C_T_DIM", "E_T_DIM"
    addParamTable paramSpace, 5, "C_T_ATR", "E_T_ATR"
    addParamTable paramSpace, 6, "C_T_MEM", "E_T_MEM"
    addParamTable paramSpace, 7, "C_T_CEL", "E_T_CEL"
    addParamTable paramSpace, 8, "C_T_PRPTYS", "E_T_PRPTYS"
    addParamTable paramSpace, 9, "C_T_HRY_TYPES"
    addParamTable paramSpace, 10, "C_T_FAC", "E_T_FAC"
    addParamTable paramSpace, 11, "C_T_CON", "E_T_CON"
    addParamTable paramSpace, 12, "E_T_VAR", "C_T_VARIABLES"
    addParamTable paramSpace, 13, "I_T_CMD_PARAMS"
    addParamTable paramSpace, 14, "C_T_GENUNIID", "E_T_RETURNTEXTS"

    If p_versionServer > cV20 Then
        addParamTable paramSpace, 15, "C_T_DRILL"
        addParamTable paramSpace, 16, "E_T_TEXT"
        Call tableReset("E_T_URL")
        addParamTable paramSpace, 17, "E_T_URL"
    End If
    
    
    Dim waited As Boolean
    rfcJump = IIf(callOLAPVisible("RRY_JUMP", paramSpace), noAppErrors(appReturn, handle, waited, longHandle, True), False)
    RfcFreeParamSpace paramSpace
        
    On Error Resume Next


    
    genUniID = p_tables("E_T_RETURNTEXTS").cell(1, 1)
    handle = CInt(longHandle)
    
    If Not waited Then
        p_gridWidth = maxX
        p_gridHeight = IIf(maxX, maxY, 0)
    End If
        
End Function

Function rfcSaveView(wbID As String, viewID As String, Optional viewIDglobal As String, Optional title As String, Optional overwrite As Boolean) As Boolean

    Dim eWBID As String * 25:           eWBID = fixLen(wbID, 25)
    Dim eViewID As String * 40:         eViewID = fixLen(viewID, 40)
    Dim eViewIDglobal As String * 30:   eViewIDglobal = fixLen(viewIDglobal, 30)
    Dim eTitle As String * 60:          eTitle = fixLen(title, 60)
    Dim eOverwrite As String * 1:       eOverwrite = IIf(overwrite, "X", " ")
    Dim appReturn As Long
    Dim lRow As Object
    repoReadQuery
    repoReadTable p_currentRepoSheet, cRepoCV, "C_T_VARIABLES"
    
    Dim paramSpace As Long
    ' Change save as jump target
    If p_versionServer < cV30 Then
        paramSpace = RfcAllocParamSpace(versionInt(5, 2), 1, 9)
    ElseIf p_versionServer = cV30 Then
        paramSpace = RfcAllocParamSpace(versionInt(5, 2), 1, 11)
    End If
    RfcAddExportString paramSpace, 0, "I_WBID", 6, 0, 25, eWBID
    RfcAddExportString paramSpace, 1, "I_VIEWID", 8, 0, 40, eViewID
    RfcAddExportString paramSpace, 2, "I_VIEWIDGLOBAL", 14, 0, 30, eViewIDglobal
    RfcAddExportString paramSpace, 3, "I_DESCRIPTION", 13, 0, 60, eTitle
    RfcAddExportString paramSpace, 4, "I_OVERWRITE", 11, 0, 1, eOverwrite
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
    
    addParamTable paramSpace, 0, "I_T_DIM", "E_T_DIM"
    addParamTable paramSpace, 1, "I_T_MEM", "E_T_MEM"
    addParamTable paramSpace, 2, "I_T_ATR", "E_T_ATR"
    addParamTable paramSpace, 3, "I_T_CEL", "E_T_CEL"
    addParamTable paramSpace, 4, "I_T_PRPTYS", "E_T_PRPTYS"
    addParamTable paramSpace, 5, "I_T_HRY_TYPES", "C_T_HRY_TYPES"
    addParamTable paramSpace, 6, "I_T_FAC", "E_T_FAC"
    addParamTable paramSpace, 7, "I_T_CON", "E_T_CON"
    addParamTable paramSpace, 8, "I_T_VAR", "C_T_VARIABLES"
    ' Change save as jump target
    If p_versionServer = cV30 Then
        addParamTable paramSpace, 9, "I_T_DRILL", "C_T_DRILL"
        Call tableReset("E_T_RETURNTEXTS")
        addParamTable paramSpace, 10, "E_T_MSG", "E_T_RETURNTEXTS"
    End If
    If callOLAPVisible("RRXWS_SAVE_VIEW", paramSpace) Then
        If p_versionServer < cV30 Then
            rfcSaveView = noStorageErrors(appReturn)
        Else
            rfcSaveView = False
            Select Case appReturn
                Case 0:     rfcSaveView = True
                Case 700:   overwrite = True
                Case 800 'No Authorization
                rfcSaveView = False
                Set lRow = p_tables("E_T_RETURNTEXTS").Rows(1)
                MsgBox lRow("LINE"), vbCritical
                Case Else:  userError "workbookStorage", , appReturn
            End Select
        End If
    Else
    End If
        
    RfcFreeParamSpace paramSpace

End Function

Sub rfcPing(handle As Integer, microSecsElapsed As Single)

    Dim pingNow As Boolean:         pingNow = repoGetProperty(cPropSendPing)
    If isConnected And (pingNow Or p_ping) Then
    
        Dim eHandle As String * 4:  eHandle = Format(handle, "0000")
        Dim eFCode As String * 4:   eFCode = "PING"
        
        If p_versionServer >= cV20 Then
            If Not tableReset("I_T_CMD_PARAMS") Then Exit Sub
            With p_tables("I_T_CMD_PARAMS")
                .Rows.Add
                .cell(1, 1) = "XLTIME"
                .cell(1, 2) = Format(microSecsElapsed, "0")
            End With
        End If
    
        Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(2, 0, versionInt(1, 1, 0))
        RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
        RfcAddExportString paramSpace, 1, "I_CMDID", 7, 0, 4, eFCode
        
        If p_versionServer >= cV20 Then
            addParamTable paramSpace, 0, "I_T_CMD_PARAMS"
        End If
        
        callOLAPVisible "RRY_GRID_CMD_PROCESS", paramSpace
        RfcFreeParamSpace paramSpace
    
    End If
    
End Sub

Function rfcGetContextMenu(handle As Integer) As Boolean

    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    Dim appReturn As Long
    
    If Not tableReset("E_T_MENU") Then Exit Function
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 1, 2)
    RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, appReturn
    addParamTable paramSpace, 0, "I_T_RANGES"
    addParamTable paramSpace, 1, "E_T_MENU"
        
    rfcGetContextMenu = IIf(callOLAPmsg("RRY_GRID_CONTEXT_MENU_GET", paramSpace), noAppErrors(appReturn, handle), False)
    RfcFreeParamSpace paramSpace
    
End Function

Private Function noAppErrors(appReturn As Long, _
                             handle As Integer, _
                             Optional waited As Boolean, _
                             Optional newHandle As Long, _
                             Optional jump As Boolean, _
                             Optional eUrl As String) As Boolean
    Dim lUrl As String
    Dim lrRow As Object
    Dim lVisible As Boolean: lVisible = True
    waited = False
    
    Dim success As Boolean
    success = False
    
    If appReturn >= 10000 Then
        trace False, "application warning!"
        rfcMessagesGet handle, True
        appReturn = appReturn - 10000
    End If
    
    If appReturn = 500 Then

        waited = True
        contextSetIndex (1)
        
        Dim waitReturn As Long
        If Not rfcProcessCommand(IIf(newHandle, newHandle, handle), "WAIT", 0, 0, 0, 0, "", False, jump) Then GoTo leave
        appReturn = waitReturn
        If appReturn >= 10000 Then
            trace False, "application warning!"
            rfcMessagesGet handle, True
            appReturn = appReturn - 10000
        End If
    
    End If
    
    Select Case appReturn
        Case 0          ' call was ok
            success = True
        Case 205        ' call was ok, but grid data has to be fetched separately
            p_gridPending = True
            success = True
        Case 100        ' no processing necessary
            trace False, "no processing necessary"
        Case 210        ' variable screen cancelled
            trace False, "variable screen cancelled"
            p_rollbackHandle = True
            p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle) = 0
        Case 300        ' OLAP warning
            trace False, "application warning!"
            rfcMessagesGet handle, True
            success = True
        Case 400        ' launch Browser (and that's all)
         Let eUrl = ""
          On Error Resume Next
          For Each lrRow In p_tables("E_T_URL").Rows
            eUrl = eUrl + lrRow("LINE")
          Next
          If eUrl <> "" Then
            Call internetBrowserLaunch(eUrl)
          Else
            For Each lrRow In p_tables("E_T_TEXT").Rows
              eUrl = eUrl + lrRow("TXT")
            Next
            If eUrl <> "" Then Call internetBrowserLaunch(eUrl)
          End If
                    'BUGFIX: for IE opening in the background when invoked via
          'goto-> display documents. Set the lVisible to false here so
          'that Application.visible is not made true below
          lVisible = False
        Case 200 ' OLAP error Connection reset neccessary
            trace False, "application error (no. " & appReturn & " ) !!"
            rfcMessagesGet handle, False
            If (Not p_currentRepoSheet Is Nothing) And p_currentQueryIndex Then dialOutClearHandle False
            dialOut
        Case Else       ' OLAP error
            trace False, "application error (no. " & appReturn & " ) !!"
            rfcMessagesGet handle, False
            If (Not p_currentRepoSheet Is Nothing) And p_currentQueryIndex Then dialOutClearHandle False
    End Select
    
leave:
    If Not success Then
        userStatusBar ""
        HideProgress
        If lVisible Then Application.Visible = True
    End If
    noAppErrors = success

End Function

Private Sub rfcMessagesGet(ByVal handle As Integer, ByVal warningsOnly As Boolean)

    If warningsOnly And Not checkWarningDialog Then Exit Sub

    Dim eHandle As String * 4:      eHandle = Format(handle, "0000")
    
    If Not tableReset("E_T_MESG") Then Exit Sub
        
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 0, 1)
    RfcAddExportString paramSpace, 0, "I_HANDLE", 8, 0, 4, eHandle
    addParamTable paramSpace, 0, "E_T_MESG"
    
    If callOLAPmsg("RRY_MESSAGES_GET", paramSpace) Then
        If p_tables("E_T_MESG").Rows.Count Then
            If checkWarningDialog Then
                HideProgress
                userFormShow dBEXmessages, "captionMessages"
            End If
        End If
    Else
        userError "messagesNotRead"
    End If
    
    RfcFreeParamSpace paramSpace

End Sub

Public Sub rfcMessageDetail(msgArea As String, msgNumber As String, msgV1 As String, msgV2 As String, msgV3 As String, msgV4 As String)

    Dim eArea As String * 20:       eArea = fixLen(msgArea, 20)
    Dim eNumber As String * 3:      eNumber = fixLen(msgNumber, 3)
    Dim eVar1 As String * 50:       eVar1 = fixLen(msgV1, 50)
    Dim eVar2 As String * 50:       eVar2 = fixLen(msgV2, 50)
    Dim eVar3 As String * 50:       eVar3 = fixLen(msgV3, 50)
    Dim eVar4 As String * 50:       eVar4 = fixLen(msgV4, 50)
    
    Dim paramSpace As Long:     paramSpace = RfcAllocParamSpace(6, 0, 0)
    RfcAddExportString paramSpace, 0, "I_ARBGB", 7, 0, 20, eArea
    RfcAddExportString paramSpace, 1, "I_TXTNR", 7, 0, 3, eNumber
    RfcAddExportString paramSpace, 2, "I_MSGV1", 7, 0, 50, eVar1
    RfcAddExportString paramSpace, 3, "I_MSGV2", 7, 0, 50, eVar2
    RfcAddExportString paramSpace, 4, "I_MSGV3", 7, 0, 50, eVar3
    RfcAddExportString paramSpace, 5, "I_MSGV4", 7, 0, 50, eVar4
    
    callOLAPVisible "RRY_MESSAGE_HELP_GET", paramSpace
    RfcFreeParamSpace paramSpace

End Sub

Public Sub rfcHTMLhelp(helpTopic As String, helpStructure As String)

    Dim eType As String * 10:       eType = fixLen("IWB_EXTHLP", 10)
    Dim eTopic As String * 32:      eTopic = fixLen(helpTopic, 32)
    Dim eStructure As String * 32:  eStructure = fixLen(helpStructure, 32)
    
    Dim paramSpace As Long:     paramSpace = RfcAllocParamSpace(3, 0, 0)
    RfcAddExportString paramSpace, 0, "OBJECT_CLASS", 12, 0, 10, eType
    RfcAddExportString paramSpace, 1, "TOPIC_OBJECT_ID", 15, 0, 32, eTopic
    RfcAddExportString paramSpace, 2, "STRUCTURE_OBJECT_ID", 19, 0, 32, eStructure

    callOLAPVisible "IWB_HTML_HELP_BROWSER_CALL", paramSpace
    RfcFreeParamSpace paramSpace

End Sub

' ----- wrappers for functions in group RRMX

Function rfcReadWorkbook(wbID As String, wbPath As String, agrID As String) As Boolean

    Dim eID As String * 25:         eID = fixLen(wbID, 25)
    Dim ePath As String * 128:      ePath = fixLen(wbPath, 128)
    Dim eAgrID As String * 72:      eAgrID = fixLen(agrID, 72)
    Dim returnCode As Long

    If Not tableReset("E_T_RETURNTEXTS") Then Exit Function
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(IIf(Len(agrID) > 0, 3, 2), 1, 1)
    RfcAddExportString paramSpace, 0, "I_ID", 4, 0, 25, eID
    RfcAddExportString paramSpace, 1, "I_PATH", 6, 0, 128, ePath
    If Len(agrID) > 0 Then
        RfcAddExportString paramSpace, 2, "I_AGR_ID", 8, 0, 72, eAgrID
    End If
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, returnCode
    addParamTable paramSpace, 0, "E_T_RETURNTEXTS"
    
    rfcReadWorkbook = IIf(callOLAP("RRMX_WORKBOOK_READ", paramSpace), noStorageErrors(returnCode, Len(wbID) + Len(agrID) = 0), False)
    RfcFreeParamSpace paramSpace

End Function

Function rfcWriteWorkbook(wbID As String, sysID As String, wbPath As String, wbPrivate As String, wbTitle As String, agrID As String, revision As Long) As Boolean
    
    Dim eID As String * 25:         eID = fixLen(wbID, 25)
    Dim ePath As String * 128:      ePath = fixLen(wbPath, 128)
    Dim ePrivate As String * 1:     ePrivate = fixLen(wbPrivate, 1)
    Dim eSystem As String * 8:      eSystem = fixLen(sysID, 8)
    Dim eTitle As String * 60:      eTitle = fixLen(wbTitle, 60)
    Dim eAgrID As String * 72:      eAgrID = fixLen(agrID, 72)
    Dim eRevision As Long:          eRevision = revision
    Dim returnCode As Long
    
    If Not tableReset("E_T_RETURNTEXTS") Then Exit Function
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(6, 1, 2)
    RfcAddExportString paramSpace, 0, "I_ID", 4, 0, 25, eID
    RfcAddExportString paramSpace, 1, "I_PATH", 6, 0, 128, ePath
    If Len(agrID) > 0 Then
        RfcAddExportString paramSpace, 2, "I_AGR_ID", 8, 0, 72, eAgrID      ' rel 2.0+
    Else
        RfcAddExportString paramSpace, 2, "I_PRIVATE", 9, 0, 1, ePrivate    ' rel 1.2
    End If
    RfcAddExportString paramSpace, 3, "I_SYSID", 7, 0, 8, eSystem
    RfcAddExportString paramSpace, 4, "I_TITLE", 7, 0, 60, eTitle
    RfcAddExportParam paramSpace, 5, "I_REVISION", 10, 8, 4, eRevision
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, returnCode
    addParamTable paramSpace, 0, "E_T_RETURNTEXTS"
    addParamTable paramSpace, 1, "I_T_USED_REPORTS"
    
    If callOLAPVisible("RRMX_WORKBOOK_WRITE", paramSpace) Then
        If returnCode = 102 And revision > 0 Then ' workbook wrong revision
            If userError("wbWrongRevision", vbQuestion + vbYesNo) <> vbNo Then
                rfcWriteWorkbook = rfcWriteWorkbook(wbID, sysID, wbPath, wbPrivate, wbTitle, agrID, 0)
            Else
                rfcWriteWorkbook = False
            End If
        Else
            rfcWriteWorkbook = noStorageErrors(returnCode)
        End If
    Else
        rfcWriteWorkbook = False
    End If
    RfcFreeParamSpace paramSpace

End Function

Function rfcSetTemplate(wbID As String, agrID As String) As Boolean

    Dim eID As String * 25:         eID = fixLen(wbID, 25)
    Dim eAgrID As String * 72:      eAgrID = fixLen(agrID, 72)
    Dim returnCode As Long
    
    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(IIf(Len(agrID) > 0, 2, 1), 1, 0)
    RfcAddExportString paramSpace, 0, "I_ID", 4, 0, 25, eID
    If Len(agrID) > 0 Then
        RfcAddExportString paramSpace, 1, "I_AGR_ID", 8, 0, 72, eAgrID
    End If
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, returnCode
    
    rfcSetTemplate = IIf(callOLAP("RRMX_TEMPLATE_SET", paramSpace), noStorageErrors(returnCode), False)
    RfcFreeParamSpace paramSpace
    
End Function

Function rfcGetViewList(wbID As String, queryID As String) As Boolean

    Dim eWBID As String * 25:       eWBID = fixLen(wbID, 25)
    Dim eQueryID As String * 25:    eQueryID = fixLen(queryID, 25)
    
    If Not tableReset("E_T_ITEMS") Then Exit Function

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(2, 0, 1)
    RfcAddExportString paramSpace, 0, "I_WBID", 6, 0, 25, eWBID
    RfcAddExportString paramSpace, 1, "I_GENUNIID", 10, 0, 25, eQueryID
    addParamTable paramSpace, 0, "E_T_ITEMS"
    
    rfcGetViewList = callOLAP(versionStr("RRMX_JUMP_TARGETS_GET", "RRMX_DOC_LIST_GET"), paramSpace)
    RfcFreeParamSpace paramSpace

End Function

Function rfcGetReceiverList(queryID As String) As Boolean

    If Not tableReset("I_T_PARAMS") Then Exit Function
    If Not tableReset("C_T_RRI") Then Exit Function
    Dim myParamRow As Object
    Set myParamRow = p_tables("I_T_PARAMS").Rows.Add
    myParamRow("REQUESTED_TREE") = 5
    myParamRow("SUBTREE_FILTER") = queryID

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(0, 0, 2)
    addParamTable paramSpace, 0, "I_T_PARAMS"
    addParamTable paramSpace, 1, "C_T_RRI"
    
    rfcGetReceiverList = callOLAP("RSZ_X_OPEN_TREE_GET", paramSpace)
    RfcFreeParamSpace paramSpace

End Function

Function rfcGetQueryList() As Boolean

    If Not tableReset("E_T_COMP_F4") Then Exit Function

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(0, 0, 1)
    addParamTable paramSpace, 0, "E_T_COMP_F4"
    
    rfcGetQueryList = callOLAP("RSZ_X_COMPONENT_LIST_GET", paramSpace)
    RfcFreeParamSpace paramSpace

End Function

Function rfcTranslateQueryID(queryID As String) As Boolean

    Dim eCompID As String * 30:       eCompID = fixLen(queryID, 30)

    If Not tableReset("C_T_COMPDIR") Then Exit Function
    If Not tableReset("C_T_COMPIC") Then Exit Function

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 0, 2)
    RfcAddExportString paramSpace, 0, "I_COMPID", 8, 0, 30, eCompID
    addParamTable paramSpace, 0, "C_T_COMPDIR"
    addParamTable paramSpace, 1, "C_T_COMPIC"
    
    rfcTranslateQueryID = False
    If callOLAP("RSZ_X_COMPONENT_GET", paramSpace) Then
        Dim compuID As String
        Dim myRow As Object
        For Each myRow In p_tables("C_T_COMPDIR").Rows
            If myRow("COMPID") = queryID Then
                compuID = myRow("COMPUID")
                Exit For
            End If
        Next myRow
        If Len(compuID) > 0 Then
            For Each myRow In p_tables("C_T_COMPIC").Rows
                If myRow("COMPUID") = compuID Then
                    queryID = myRow("GENUNIID")
                    rfcTranslateQueryID = True
                    Exit Function
                End If
            Next myRow
        End If
    End If
    RfcFreeParamSpace paramSpace

End Function

Function rfcTranslateQueryIDInv(queryID As String, compID As String, cubeID As String) As Boolean

    Dim eGenUniID As String * 25:       eGenUniID = fixLen(queryID, 25)

    If Not tableReset("C_T_COMPDIR") Then Exit Function
    If Not tableReset("C_T_COMPIC") Then Exit Function

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 0, 2)
    RfcAddExportString paramSpace, 0, "I_GENUNIID", 10, 0, 25, eGenUniID
    addParamTable paramSpace, 0, "C_T_COMPDIR"
    addParamTable paramSpace, 1, "C_T_COMPIC"
    
    rfcTranslateQueryIDInv = False
    If callOLAP("RSZ_X_COMPONENT_GET", paramSpace) Then
        Dim compuID As String
        Dim myRow As Object
        For Each myRow In p_tables("C_T_COMPIC").Rows
            If myRow("GENUNIID") = queryID Then
                compuID = myRow("COMPUID")
                cubeID = myRow("INFOCUBE")
                Exit For
            End If
        Next myRow
        If Len(compuID) > 0 Then
            For Each myRow In p_tables("C_T_COMPDIR").Rows
                If myRow("COMPUID") = compuID Then
                    compID = myRow("COMPID")
                    rfcTranslateQueryIDInv = True
                    Exit Function
                End If
            Next myRow
        End If
    End If
    RfcFreeParamSpace paramSpace

End Function

Function rfcGenerateURLprefix() As Boolean

    Dim eURLtemplate As String * 255:   eURLtemplate = fixLen(versionStr("<bsp_protcl>://<bsp_server>/", "<web_protcl>://<web_server>/<web_path_prefix>/"), 255)
    Dim returnCode As Long

    rfcGenerateURLprefix = False
    If Not tableReset("E_T_RETURNTEXTS") Then Exit Function

    Dim paramSpace As Long:    paramSpace = RfcAllocParamSpace(1, 1, 1)
    RfcAddExportString paramSpace, 0, "NODE_DATA", 9, 0, 255, eURLtemplate
    RfcAddImportParam paramSpace, 0, "E_SUBRC", 7, 8, 4, returnCode
    addParamTable paramSpace, 0, "GENERATED_URL", "E_T_RETURNTEXTS"

    If callOLAP("RSBB_TEMPLATE_TO_URL_CONVERT", paramSpace) Then
        If returnCode = 0 And p_tables("E_T_RETURNTEXTS").Rows.Count Then
            Dim myRow As Object
            For Each myRow In p_tables("E_T_RETURNTEXTS").Rows
                p_URLprefix = p_URLprefix & myRow("LINE")
            Next myRow
            p_URLprefix = p_URLprefix & _
                versionStr( _
                    "sap/bw/bex?sap-language=" & p_connectionObj.language & "&", _
                    "webrfc/!?_function=WEBQUERY&" _
                ) & "CMD=LDOC"
            rfcGenerateURLprefix = True
        End If
    End If
    RfcFreeParamSpace paramSpace

End Function

Private Function noStorageErrors(returnCode As Long, Optional readTemplate As Boolean) As Boolean
    ' handle errors from R/3 function group RRMX
    
    noStorageErrors = True

    If returnCode Then
        Select Case returnCode
            Case 100: If readTemplate Then Exit Function
                      userError "wbNotExist"
            Case 101: userError "wbWrongSystem"
            Case 102: userError "wbWrongRevision"
            Case 110: userError "fileOpen"
            Case 111: userError "fileRead"
            Case 112: userError "fileWrite"
            Case 120: userError "transportError"
            Case 130: userError "icatEnqueue"
            Case 131, 172, 200, 1200: If readTemplate Then Exit Function
                      userError "icatNotAuthorized"
            Case 132: userError "icatUnknown"
            Case 133: userError "icatMaxNumber"
        '   Case 220: ... cancel, no error message ...
            Case 250: userError "notMasterLanguage", vbExclamation
                      Exit Function
            Case 300: If readTemplate Then Exit Function
                      userError "wbNotExist"
            Case 301: userError "templateNoQueries"
            Case Else: If returnCode > 299 Or returnCode = 171 Or returnCode = 173 Then userError "workbookStorage", 0, Str(returnCode)
        End Select
        noStorageErrors = False
    End If

End Function

Public Function IsWinMeor2KorGreater() As Boolean
Dim lOsvi As OSVERSIONINFO
lOsvi.dwOSVersionInfoSize = 5 * 4 + 128
Dim lRes As Integer
lRes = GetVersionEx(lOsvi)
' (See MSDN )
'osvi.dwMajorVersion=
'Windows 95         4           0
'Windows 98         4           10
'Windows Me         4           90
'Windows NT 3.51    3           51
'Windows NT 4.0     4           0
'Windows 2000       5           0
'Windows XP         5           1
'Windows .NET Server 5          1

IsWinMeor2KorGreater = ((lOsvi.dwMajorVersion > 4) Or _
   ((lOsvi.dwMajorVersion = 4) And (lOsvi.dwMinorVersion >= 90)))

End Function
Attribute VB_Name = "cBEXrun"
Option Private Module
Option Explicit

Public Sub RunQueriesInWorkbook(cWb As Workbook, _
                                Optional iDontClose As Boolean, _
                                Optional iOnlyUnrefreshed As Boolean, _
                                Optional iOnlyAutoRefresh As Boolean, _
                                Optional iShowScreen As Boolean)                                      'VBR:06-033
    
    Const cVarPoolIndex = -1
    Dim lOldRepoSheet As Worksheet
    Dim lOldQueryIndex As Integer
    Dim lCounter As Integer
    Dim lCounter2 As Integer
    Dim lCounter3  As Integer
    Dim lMyRow As Object
    Dim lcounter_refresh As Integer: lcounter_refresh = 0                                               ' VBR:08-042
    
    Set lOldRepoSheet = p_currentRepoSheet
    Set p_currentRepoSheet = repoGetRepoSheet(atBook:=cWb, createNew:=False)
    If p_currentRepoSheet Is Nothing Then    ' 576984
      Set p_currentRepoSheet = lOldRepoSheet
      Exit Sub
    End If
    lOldQueryIndex = p_currentQueryIndex
    If p_varValuesPending Then  ' initialize variable values pool with pending values
        p_currentQueryIndex = cVarPoolIndex
        Call repoWriteTable(p_currentRepoSheet, cRepoCV, "C_T_VARIABLES")
        p_varValuesPending = False
    End If
    With p_currentRepoSheet
        For lCounter = cRepoRTop + .Cells(cRepoRCounts, cRepoCQ) - 1 To cRepoRTop Step -1
            If Not (iOnlyAutoRefresh And Not .Cells(lCounter, cRepoCQRefreshOnOpen)) And _
               Not (iOnlyUnrefreshed And .Cells(lCounter, cRepoCQRefreshed)) Then
                If Not .Cells(lCounter, cRepoCQReuseVars) Then ' read variable values pool
                    p_currentQueryIndex = cVarPoolIndex
                    If Not repoReadTable(p_currentRepoSheet, cRepoCV, "C_T_VARIABLES") Then Exit Sub
                    p_varValuesPending = True
                End If
                p_currentQueryIndex = lCounter
                Call RunQuery(iDontClose = True, iShowScreen:=iShowScreen)                                  'VBR:06-033
                If lcounter_refresh = 0 Then                                                                'VBR:08-042
                    lcounter_refresh = 1                                                                    'VBR:08-042
                    p_currentQueryIndex = cVarPoolIndex                                                     'VBR:07-035
                    Call repoWriteTable(p_currentRepoSheet, cRepoCV, "C_T_VARIABLES")                       'VBR:07-035
                End If                                                                                      'VBR:08-042
                If Not .Cells(lCounter, cRepoCQReuseVars) Then ' add to variable values pool
                  Call repoReadTable(p_currentRepoSheet, cRepoCV, "C_T_VARIABLES") ' may have been destroyed in runQuery!
                    ' 1. read variable values pool into table (but skip rows which already exist there!)
                    For lCounter2 = cRepoRTop + .Cells(cRepoRCounts, cRepoCV) - 1 To cRepoRTop Step -1
                        If .Cells(lCounter2, cRepoCV) = cVarPoolIndex Then
                            For Each lMyRow In p_tables("C_T_VARIABLES").Rows ' check whether row exists in table
                                ' KW HACK Coca Cola
                                If lMyRow("VNAM") = .Cells(lCounter2, cRepoCV + 1) And _
                                lMyRow("low") = .Cells(lCounter2, cRepoCV + 6) Then
                                    If lMyRow("opt") = "" And lMyRow("sign") = "" And lMyRow("low") = "" Then
                                        lMyRow("VARTYP") = 9
                                    End If
                                    GoTo rowExistsInTable
                                ElseIf lMyRow("VNAM") = .Cells(lCounter2, cRepoCV + 1) And _
                                       lMyRow("LOW") = .Cells(lCounter2, cRepoCV + 6) Then                  'VBR:11-59
                                    GoTo rowExistsInTable                                                   'VBR:10-50
                                End If
                            Next lMyRow
                            Set lMyRow = p_tables("C_T_VARIABLES").Rows.Add
                            
                            For lCounter3 = 1 To p_tables("C_T_VARIABLES").Columns.Count ' copy row into table
                                lMyRow.Value(lCounter3) = .Cells(lCounter2, cRepoCV + lCounter3)
                            Next lCounter3
                        End If
rowExistsInTable:
                    Next lCounter2
                    ' 2. write table into variable values pool
                    p_currentQueryIndex = cVarPoolIndex
                    Call repoWriteTable(p_currentRepoSheet, cRepoCV, "C_T_VARIABLES")
                    p_varValuesPending = False
                End If
            End If
        Next lCounter
    End With

    ' delete variable values pool and restore global variables
    p_currentQueryIndex = cVarPoolIndex
    Call repoClearTable(p_currentRepoSheet, cRepoCV)
    p_currentQueryIndex = lOldQueryIndex
    Set p_currentRepoSheet = lOldRepoSheet
End Sub

Public Sub RunQueryConditioned(Optional iStillValid As Boolean, _
                                Optional iFirstRefresh As Boolean)

    With p_currentRepoSheet
        .Cells(p_currentQueryIndex, cRepoCQRefreshed) = False
        .Cells(p_currentQueryIndex, cRepoCQValid) = iStillValid
        .Cells(p_currentQueryIndex, cRepoCQFirstRefresh) = iFirstRefresh
    End With
    If Not checkPause Then Call RunQuery(True)

End Sub

Public Function RunQuery(Optional iDontCloseQuery As Boolean, _
                            Optional iCallingGIS As Object, _
                            Optional iShowGISOnly As Boolean, _
                            Optional iShowScreen As Boolean) As Boolean

    Dim lTarget             As Range
    Dim lResultAddress      As String
    Dim lHandleBackup       As Integer
    Dim lSuccess            As Boolean
    Dim lRefreshGlobalDef   As Boolean
    RunQuery = False
    With p_currentRepoSheet
            lResultAddress = RunGetResultAddress(p_currentQueryIndex)
        Call trace(True, "running query")
        Call trace(False, "array: " & lResultAddress)
        If iShowGISOnly Then
            If iCallingGIS Is Nothing Then
                Call trace(False, "run failed due to missing GIS object!")
                GoTo leave
            Else
                Call trace(False, "show GIS only")
            End If
        Else
            Set lTarget = RunGetTarget
            If lTarget Is Nothing Then
                Call trace(False, "could not determine target")
                GoTo leave ' target undefined, or: sheet is protected (error has been reported)
            End If
        End If
        
        If Not dialIn Then
            Call trace(False, "run ended incomplete - no login!")
            GoTo leave
        End If
        
        Call userStatusBar("Running", lResultAddress)
        Call timerStart(cTimerAll)
        Call screenHalt
        
        If Not repoReadQuery Then
            Call trace(False, "run failed at reading def tables!")
            GoTo leave
        End If
        
        If Not iCallingGIS Is Nothing Then
#If GISFloat Then
            With iCallingGIS
#Else
            With iCallingGIS.Object
#End If
                Set .BMQueryDef = p_tables
                .getDefinition
                Set .BMQueryDef = Nothing
            End With
        End If
        p_rollbackHandle = False
        If Not iDontCloseQuery Then
            lHandleBackup = .Cells(p_currentQueryIndex, cRepoCQHandle)
            .Cells(p_currentQueryIndex, cRepoCQHandle) = 0
        End If
        If Not RunOpenQuery(iShowScreen) Then
            p_rollbackHandle = True
            Call trace(False, "run failed at open query!")
            GoTo leave
        End If
        lRefreshGlobalDef = Not iShowGISOnly And Not iDontCloseQuery And .Cells(p_currentQueryIndex, cRepoCQRefreshToGlobal)
        If lRefreshGlobalDef Then
            If contextSetIndex(1) Then
                lSuccess = rfcProcessCommand(.Cells(p_currentQueryIndex, cRepoCQHandle), "STRT", 0, 0, 0, 0, "")
            Else
                lSuccess = False
            End If
        Else
            lSuccess = rfcGetGrid(.Cells(p_currentQueryIndex, cRepoCQHandle), iShowGISOnly)
        End If
        
        If lSuccess Then ' present the result
            Call pingTimeStart
            If iShowGISOnly Then
                If p_gridHeight > 0 Then Call gisSetValues(iCallingGIS, p_tables("E_T_GRID").fetchgrid(2, p_gridHeight, 1, p_gridWidth, 3).data)
                Application.Visible = True
            Else
                Call repoWriteQuery(lRefreshGlobalDef)
                .Cells(p_currentQueryIndex, cRepoCQRefreshed) = True
                Call displayResult(lTarget, True)
            End If
            Call rfcPing(.Cells(p_currentQueryIndex, cRepoCQHandle), pingTimeFinish)
        End If
        
        RunQuery = lSuccess
leave:
        If p_rollbackHandle Then
            .Cells(p_currentQueryIndex, cRepoCQHandle) = lHandleBackup
        Else
            If lSuccess Then Call rfcCloseQuery(lHandleBackup)
        End If

    End With

    screenRestore
    Call timerStop(cTimerAll)
    Call userStatusBar("")
    
End Function

Function RunOpenQuery(Optional iShowScreen As Boolean) As Boolean
  Dim lHandle As Integer
  RunOpenQuery = False
  Call dialIn
    With p_currentRepoSheet
        If .Cells(p_currentQueryIndex, cRepoCQHandle) = 0 Then
            Call trace(True, "open query")
            Call trace(False, "unique ID: " & .Cells(p_currentQueryIndex, cRepoCQID))

            If Not rfcOpenQuery(.Cells(p_currentQueryIndex, cRepoCQID), lHandle) Then
                Call userError("cantOpenQuery", , RunGetResultAddress(p_currentQueryIndex))
                Call trace(False, "OLAP open failed")
                Exit Function
            End If
            
            If p_varValuesPending Then
                Call trace(True, "using external variable values")
                p_varValuesPending = False ' reset the flag, because pending variable values will now be used
            Else
                If .Cells(p_currentQueryIndex, cRepoCQReuseVars) Then
                    If Not repoReadTable(p_currentRepoSheet, cRepoCV, "C_T_VARIABLES") Then Exit Function
                Else
                    If Not tableReset("C_T_VARIABLES") Then Exit Function
                End If
            End If
            If Not rfcFlushVariables(lHandle, iShowScreen) Then
                If isConnected Then Call rfcCloseQuery(lHandle)
                Call trace(False, "flush variables failed")
                Exit Function
            End If
            Call repoWriteTable(p_currentRepoSheet, cRepoCV, "C_T_VARIABLES")
            
            Call RunSetHandle(lHandle)
        End If
    End With
     RunOpenQuery = True
End Function

Public Sub RunSetHandle(iHandle As Integer)

    Call trace(False, "handle: " & iHandle)
    With p_currentRepoSheet
        .Cells(p_currentQueryIndex, cRepoCQHandle) = iHandle
        .Cells(p_currentQueryIndex, cRepoCQFirstRefresh) = True
    End With
    
End Sub

Public Function RunProcessTextElements(Optional iSelectGroup As String, _
                                      Optional iRequestFilter As String) As Boolean
    Dim lTextsInserted As Boolean
    Dim lShowStyles As Boolean
    Dim lResultArea As Range
    Dim lMyRange As Range:
    Dim lElemText As String
    Dim lElemName As String
    Dim lElemCaption As String
    Dim lElemType As String
    Dim lRowTexts As Object
    lTextsInserted = False
    Call trace(True, "read text elements")
    If rfcGetTextSymbols(p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)) Then
        lShowStyles = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQStyles)
        Call screenHalt
        Call timerStart(cTimerTexts)
        Call p_tables("E_T_TXT_SYMBOLS").Rows.Add ' empty row to enforce flush buffer for last element
        For Each lRowTexts In p_tables("E_T_TXT_SYMBOLS").Rows
            If lRowTexts("SYM_FS") = 0 Then ' begin new text element
                If lElemName <> "" Then ' flush buffer
                    Set lMyRange = RunGetTextRange(lElemName)
                    If lMyRange Is Nothing And Len(iSelectGroup) Then
                        If iSelectGroup = "*" Or (iSelectGroup = lElemType) Then ' provide new space for text element
                            If lResultArea Is Nothing Then Set lResultArea = RunGetResultRange(p_currentQueryIndex)
                            If Not lResultArea Is Nothing Then
                                If InStr(1, lElemName, "FILTER") <> 1 Then
                                    Set lMyRange = RunSetInfoRange(cRangeText, lElemName, lResultArea)
                                ElseIf p_bexGlobal.R3Text("ID_FLAG_XL_SHOW_NO_FILTERS", "") = "" Or iRequestFilter = "X" Then
                                    Set lMyRange = RunSetInfoRange(cRangeText, lElemName, lResultArea)
                                    lTextsInserted = True
                                End If
                            End If
                        End If
                    End If
                    
                    If Not lMyRange Is Nothing Then ' display text element
                        Set lMyRange = lMyRange.Cells(1, 1)
                        On Error GoTo rangeIsFilled ' myRange.Offset(0, 1) may fail
                        If lElemName = cTitleTextElement Then
                            lMyRange.Value = "'" & lElemText
                            If lShowStyles Then Call setStyle(lMyRange, "SAPBEXtitle")
                            Set lMyRange = lMyRange.Offset(0, 1)
                            lMyRange.Value = ""
                            If lShowStyles Then Call setStyle(lMyRange, "SAPBEXtitle")
                        lTextsInserted = True
                        Else
                        'Necessary to avoid FilterElements when not wished
                            If p_bexGlobal.R3Text("ID_FLAG_XL_SHOW_NO_FILTERS", "") = "" Or iRequestFilter = "X" Then
                                lMyRange.Value = lElemCaption
                                If lShowStyles Then Call setStyle(lMyRange, "SAPBEXheaderText")
                                Set lMyRange = lMyRange.Offset(0, 1)
                                lMyRange.Value = "'" & lElemText
                                If lShowStyles Then Call setStyle(lMyRange, "SAPBEXheaderItem")
                                lTextsInserted = True
                            End If
                        End If
rangeIsFilled:
                        On Error GoTo 0
                    End If
                End If
                lElemName = lRowTexts("SYM_NAME")
                lElemCaption = lRowTexts("SYM_CAPTION")
                lElemText = lRowTexts("SYM_VALUE")
                lElemType = lRowTexts("SYM_TYPE")
            Else ' append to current text element
                If lRowTexts("SYM_BEGIN_GROUP") <> "" Then lElemText = lElemText & Application.International(xlListSeparator)
                lElemText = lElemText & " " & lRowTexts("SYM_VALUE")
            End If
        Next lRowTexts
            
        If Not lResultArea Is Nothing Then ' resultArea has been shifted
            ' insert a new row between new textelements and result
            If displayProvideRange(lResultArea, lResultArea.Rows.Count + 1, lResultArea.Columns.Count) And lTextsInserted Then
                Set lMyRange = lResultArea.Resize(1)
                lMyRange.Offset(lResultArea.Rows.Count - 1).Delete xlUp
                Call lMyRange.Insert(xlDown)
                Call RunClearRange(lMyRange.Offset(-1))
            End If
        End If
        
        If repoGetProperty(cPropShowDocLinks) Or _
           repoGetProperty(cPropShowDocLinksData) Or _
           repoGetProperty(cPropShowDocLinksMsd) Or _
           repoGetProperty(cPropShowDocLinksMeta) Then
            If p_versionServer > cV20 Then Call shapesCreateOutside
        End If
        Call timerStop(cTimerTexts)
        Call screenRestore
            
        RunProcessTextElements = True
        
    Else
    
        Call userError("cantReadTextElements")
        Call trace(False, "failed")
        RunProcessTextElements = False
        
    End If
    
End Function

Public Function RunGetTarget() As Range

    Dim lTarget As Range
    Set lTarget = RunGetResultRange(p_currentQueryIndex)
    If Not lTarget Is Nothing Then
        If lTarget.Worksheet.Parent Is p_currentRepoSheet.Parent Then GoTo targetValid
    End If
        
    Set lTarget = queryRepair
    If lTarget Is Nothing Then
        Call queryDelete(False, False, True, True, True)
        Exit Function
    End If
    
targetValid:
    If isProtected(lTarget.Worksheet, True) Then
        Call userError("cantCalcProtected")
        Set RunGetTarget = Nothing
    Else
        Set RunGetTarget = lTarget
    End If

End Function

Private Function BuildFilterName(iQueryIndex As Long, _
                                 iFilterNm As String) As String
    Dim lFilterNm As String
    lFilterNm = translate(iFilterNm, "/", "?")
    BuildFilterName = p_currentRepoSheet.Cells(iQueryIndex, cRepoCQPrefix) & cRangeFilter & lFilterNm
End Function
Public Function RunGetFilterName(iFilterIndex As Long) As String
    With p_currentRepoSheet
        RunGetFilterName = BuildFilterName(.Cells(iFilterIndex, cRepoCD), .Cells(iFilterIndex, cRepoCDCharName))
    End With
End Function
            
Public Function RunGetFilterAddress(iFilterIndex As Long) As String
    RunGetFilterAddress = ""
    On Error Resume Next
    RunGetFilterAddress = Mid(p_currentRepoSheet.names(RunGetFilterName(iFilterIndex)).RefersTo, 2)
End Function

Public Function RunGetFilterRange(iFilterIndex As Long) As Range
    Set RunGetFilterRange = Nothing
    On Error Resume Next
    Set RunGetFilterRange = p_currentRepoSheet.names(RunGetFilterName(iFilterIndex)).RefersToRange
End Function

Public Function RunGetValueRange(iObjName As String, _
                                    Optional iOffsetRight As Boolean) As Range

    Set RunGetValueRange = Nothing
    On Error Resume Next
    Dim lFilterName As String
    With p_currentRepoSheet
        lFilterName = BuildFilterName(p_currentQueryIndex, iObjName)
        Set RunGetValueRange = .names(lFilterName).RefersToRange.Offset(, IIf(iOffsetRight, 1, 0))
    End With
    
End Function

Public Function RunGetResultAddress(iQueryIndex As Long) As String
    
    RunGetResultAddress = ""
    On Error Resume Next
    With p_currentRepoSheet
        RunGetResultAddress = Mid(.names(CStr(.Cells(iQueryIndex, cRepoCQPrefix))).RefersTo, 2)
    End With

End Function

Public Function RunGetResultRange(iQueryIndex As Long) As Range

    Set RunGetResultRange = Nothing
    On Error Resume Next
    With p_currentRepoSheet
        Set RunGetResultRange = .names(CStr(.Cells(iQueryIndex, cRepoCQPrefix))).RefersToRange
    End With

End Function
Public Function RunGetTextRange(iElemName As String, _
                                Optional iDeleteReference As Boolean) As Range
    Set RunGetTextRange = RunGetInfoRange(cRangeText, iElemName, iDeleteReference)
End Function

Public Function RunGetConRange(iEltuid As String, _
                                Optional iDeleteReference As Boolean) As Range
    Set RunGetConRange = RunGetInfoRange(cRangeCondExc, iEltuid, iDeleteReference)
End Function

Private Function RunGetInfoRange(iTag As String, _
                                 iInfoName As String, _
                                 iDeleteReference As Boolean) As Range
    
    Dim lMyName As Name
    Set RunGetInfoRange = Nothing
    On Error Resume Next
    With p_currentRepoSheet
        Set lMyName = .names(.Cells(p_currentQueryIndex, cRepoCQPrefix) & iTag & iInfoName)
    End With
    If Err = 0 Then
        Set RunGetInfoRange = lMyName.RefersToRange
        If Err <> 0 Or iDeleteReference Then lMyName.Delete
    End If

End Function

Public Function RunSetInfoRange(iTag As String, _
                                iInfoName As String, _
                                iTarget As Range) As Range
    If displayProvideRange(iTarget, iTarget.Rows.Count + 1, iTarget.Columns.Count) Then
        On Error GoTo leave
        Dim lMyRange As Range
        Set lMyRange = iTarget.Resize(1)
        lMyRange.Offset(iTarget.Rows.Count - 1).Delete xlUp
        lMyRange.Insert xlDown
        Set lMyRange = lMyRange.Offset(-1)
        Call RunClearRange(lMyRange)
        Set lMyRange = lMyRange.Resize(1, 2)
        
        iInfoName = translate(iInfoName, "/", "?")
        With p_currentRepoSheet
            Call .names.Add(.Cells(p_currentQueryIndex, cRepoCQPrefix) & iTag & iInfoName, lMyRange)
        End With
        Set RunSetInfoRange = lMyRange
    End If
leave:
End Function

Public Sub RunClearRange(iTarget As Range, _
                         Optional iHryPrefix As String)
    
    If iTarget Is Nothing Then Exit Sub
    
    Call activationBackup(True)
    
    With iTarget
        .Parent.activate
        .Value = "" ' .ClearContents is faster, but can run into run-time errors
        If p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQStyles) Then
            On Error Resume Next
            .Style = "Normal"
            .FormatConditions.Delete
            .Locked = False
            On Error GoTo 0
        End If
        Call .Validation.Delete
        On Error Resume Next ' this may not work on a protected sheet
        .Worksheet.AutoFilterMode = False
    End With

    If Len(iHryPrefix) Then Call shapesDelete(iTarget, iHryPrefix, True)  ' delete hierarchy shapes, too
    Call activationRestore
End Sub

'Render the filter elements again when the query is refreshed       ND:5-26
Public Sub runProcessFilterTextElems()
    Dim lShowStyles As Boolean
    Dim lResultArea As Range
    Dim lMyRange As Range:
    Dim lElemText As String
    Dim lElemName As String
    Dim lElemCaption As String
    Dim lElemType As String
    Dim lRowTexts As Object
    Dim lNamesInWorkbook As names
    Dim lName As Name
    Dim lPrefix As String
    Dim lRangeofLastFilter As Range
    Dim lRangeofFilterTE As Range
    Dim lUserPreferenceOnRows As Integer
    
    On Error Resume Next
    Call trace(True, "Read filter text elements after query refresh")
    
    'Get the text symbols from the backend
    If rfcGetTextSymbols(p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)) Then
        lShowStyles = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQStyles)
        
        'Get all the names in the workbook : this is used to determine the range of
        'the last filter text element in the worksheet
        Set lNamesInWorkbook = Application.ActiveWorkbook.names
        
        For Each lRowTexts In p_tables("E_T_TXT_SYMBOLS").Rows
            lElemName = lRowTexts("SYM_NAME")
            lElemCaption = lRowTexts("SYM_CAPTION")
            lElemText = lRowTexts("SYM_VALUE")
            lElemType = lRowTexts("SYM_TYPE")
            
            'If it is a filter text element
            If InStr(1, lElemName, "FILTER") > 0 Then
                lElemName = translate(lElemName, "/", "?") 'VBR:08-043 'Code correction for Filter problem
            
                'Check if the filter text element already exists in the workbook
                Set lMyRange = RunGetTextRange(lElemName)
                
                'If not then insert it at the correct position below the last
                'filter text element
                If lMyRange Is Nothing Then
' The following portion is commented.
'Reason - to avoid reappear of deleted filter element.
''''                    'Prefix for the filter name
''''                    lPrefix = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix) & "tFILTER"
''''
''''                    'find the existing last filter text element displayed in the workbook
''''                    For Each lName In lNamesInWorkbook
''''
''''                        'Check if this is a filter element
''''                        If InStr(1, lName.Name, lPrefix) > 0 Then
''''                            On Error Resume Next
''''                            Set lRangeofFilterTE = lName.RefersToRange
''''                            If lRangeofFilterTE.row > lRangeofLastFilter.row Then
''''                                Set lRangeofLastFilter = lRangeofFilterTE.Columns
''''                            End If
''''                        End If
''''                    Next lName
''''
''''                    'Make sure that the popup to set the userpreference does not
''''                    'come up at this point. Store the old userpreference
''''                    lUserPreferenceOnRows = spaceGetUserPreferenceRows
''''                    spaceSetUserPreferenceRows (4)
''''
''''                    'Create the filter text element entry in the sheet
''''                    Set lRangeofLastFilter = lRangeofLastFilter.Offset(1)
''''                    Set lMyRange = RunSetInfoRange(cRangeText, lElemName, lRangeofLastFilter)
''''                    If p_bexGlobal.R3Text("ID_FLAG_XL_SHOW_NO_FILTERS", "") = "" Then
''''                        lMyRange.Cells(1, 1) = lElemCaption
''''                        If lShowStyles Then Call setStyle(lMyRange.Cells(1, 1), "SAPBEXheaderText") ''VBR:8-040
''''                        lMyRange.Cells(1, 2) = "'" & lElemText
''''                        If lShowStyles Then Call setStyle(lMyRange.Cells(1, 2), "SAPBEXheaderItem")
''''                    End If
''''
''''                    'Restore the user preference after rendering the text element
''''                    spaceSetUserPreferenceRows (lUserPreferenceOnRows)
''''                    Set lRangeofLastFilter = Nothing
                Else     'VBR code corrections for Filter probelm                               'VBR:08-043
                    lMyRange.Cells(1, 1) = lElemCaption                                         'VBR:08-043
                    If lShowStyles Then Call setStyle(lMyRange, "SAPBEXheaderText")             'VBR:08-043
                    lMyRange.Cells(1, 2) = "'" & lElemText                                      'VBR:08-043
                    If lShowStyles Then Call setStyle(lMyRange.Cells(1, 2), "SAPBEXheaderItem") 'VBR:08-043
                End If
                
            End If
        Next lRowTexts
    End If
End Sub

Attribute VB_Name = "cBEXshapes"
Option Private Module
Option Explicit

Private Const cShapeOnAction = "shapeAction"
Dim g_xIndentSize As Integer
Dim g_yIndentSize As Integer
Dim g_shpNameSuffix As Long

Public Sub standardShapeSet()

    If Application.ActiveWorkbook Is Nothing Then Exit Sub
    
    screenHalt
    
    On Error GoTo noShapeSelected
    Dim myNewShape As Shape
    Set myNewShape = Selection.Parent.Shapes(Selection.Name).Duplicate
    On Error GoTo 0
    Set p_currentRepoSheet = repoGetRepoSheet(ActiveWorkbook, True)
    
    Dim shapeName As String: shapeName = menuParam
    On Error Resume Next
    ActiveSheet.Shapes(shapeName).Delete
    On Error GoTo 0
    
    With myNewShape
        .Name = shapeName
        .Top = 17
        .Cut
    End With
    
    With p_currentRepoSheet
        On Error Resume Next
        .Shapes(shapeName).Delete
        On Error GoTo 0
        .Paste
        .Shapes(shapeName).Top = 1
    End With
    
    screenRestore
    Exit Sub

noShapeSelected:
    screenRestore
    userError "noHierarchyShapeSelected", vbExclamation

End Sub

Private Function standardShapeGet(shapeName As String, atSheet As Worksheet) As Shape

    Dim resultShape As Shape
    
    On Error Resume Next
    Set resultShape = copyShape(p_currentRepoSheet.Shapes(shapeName), atSheet)
    If Err <> 0 Then ' shape doesn't yet exist on p_currentReposheet
        Set resultShape = copyShape(ThisWorkbook.Worksheets("wBEXtables").Shapes(shapeName), p_currentRepoSheet)
        resultShape.Top = 1
        Set resultShape = copyShape(p_currentRepoSheet.Shapes(shapeName), atSheet)
    End If
    On Error GoTo 0
    If Not resultShape Is Nothing Then
      With resultShape
          .Top = 1
          .Placement = xlMove
          .LockAspectRatio = msoTrue
          .onAction = cShapeOnAction
      End With
    End If
    Set standardShapeGet = resultShape

End Function

Public Sub shapesCreate(target As Range, activeRow As Long)

    ' create hierarchy and document shapes in the result area
    
    If p_tables(versionStr("E_T_SYMBOLS", "E_T_HRY_DISP")).Rows.Count + _
       p_tables(versionStr("E_T_DOC_LIST", "E_T_HRY_DISP")).Rows.Count = 0 Then Exit Sub
    
    trace True, "creating shapes"
    
    Dim prefix As String: prefix = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix) & " "
       

    timerStart cTimerFormatHry
    With target

        Dim shapePlus As Shape:         Set shapePlus = standardShapeGet(shapeNamePlus, .Worksheet)
        Dim shapeMinus As Shape:        Set shapeMinus = standardShapeGet(shapeNameMinus, .Worksheet)
        If p_versionServer > cV20 Then
            Dim shapeMinusX As Shape:   Set shapeMinusX = standardShapeGet(shapeNameMinusX, .Worksheet)
            Dim shapeLinkDoc As Shape:  Set shapeLinkDoc = standardShapeGet(shapeNameLinkDoc, .Worksheet)
        End If
        Dim indentFactor As Integer:    indentFactor = indentFactorGet(.Worksheet.Parent)

        estimateShapeIndentSize

        On Error Resume Next
        
        Dim myRow As Object
        If p_versionServer < cV30 Then
            Dim flip As Boolean
            For Each myRow In p_tables("E_T_DIM").Rows
                If myRow("AXIS") = "Y" And myRow("IS_STRUCTURE") = "" Then
                    flip = (myRow("HRY_NODE_POSIT") = 1)
                    Exit For
                End If
            Next myRow
        End If
        
        trace False, "start"
    
        Dim targetHeight As Long:   targetHeight = target.Rows.Count
        Dim shpRow As Object
        If p_versionServer > cV20 Then
            For Each shpRow In p_tables("E_T_SYMBOLS").Rows
                If shpRow("Y") <= targetHeight Then
                    If shpRow("TYPE") <> "D" Then
                        addShape _
                            Choose(InStr("CUED", shpRow("TYPE")), shapePlus, shapeMinusX, shapeMinus, shapeLinkDoc), _
                            indentFactor * (IIf(shpRow("AXIS") = "Y", tLevel(shpRow), 0)) + 2 * shpRow("ICON_SHIFT"), _
                            IIf(shpRow("AXIS") = "X", tLevel(shpRow), 0), _
                            .Cells(shpRow("Y"), shpRow("X")), _
                            prefix & shpRow("TYPE"), _
                            shpRow("NODE_POSIT") = "1", _
                            shpRow("AXIS") = "X", _
                            True, _
                            IIf(InStr("DB", shpRow("TYPE")), getURL(shpRow("TXTINDEX")), "")
                    Else
                        If repoGetProperty(cPropShowDocLinksData) Or repoGetProperty(cPropShowDocLinks) _
                        Or repoGetProperty(cPropShowDocLinksMeta) Or repoGetProperty(cPropShowDocLinksMsd) Then         ' VBR:08-041
                        addShape _
                            shapeLinkDoc, _
                            indentFactor * (IIf(shpRow("AXIS") = "Y", tLevel(shpRow), 0)) + 2 * shpRow("ICON_SHIFT"), _
                            IIf(shpRow("AXIS") = "X", tLevel(shpRow), 0), _
                            .Cells(shpRow("Y"), shpRow("X")), _
                            prefix & shpRow("TYPE"), _
                            False, _
                            False, _
                            True, _
                            IIf(InStr("DB", shpRow("TYPE")), getURL(shpRow("TXTINDEX")), "")
                        End If
                    End If
                End If
            Next shpRow
            If repoGetProperty(cPropShowDocLinks) Or _
               repoGetProperty(cPropShowDocLinksData) Or _
               repoGetProperty(cPropShowDocLinksMsd) Or _
               repoGetProperty(cPropShowDocLinksMeta) Then
                shapesCreateOutside shapeLinkDoc
            End If
        Else
            For Each shpRow In p_tables("E_T_HRY_DISP").Rows
                If InStr("IC", shpRow("DISP_MODE")) Then
                    If shpRow("Y") <= targetHeight Then
                        addShape _
                            IIf(shpRow("DRILLSTATE") = "+", shapePlus, shapeMinus), _
                            indentFactor * tLevel(shpRow), _
                            0, _
                            .Cells(shpRow("Y"), 1), _
                            prefix & shpRow("NODEID"), _
                            flip
                    End If
                End If
            Next shpRow
        End If
                    
        trace False, "finished ok"
        
        shapePlus.Cut
        shapeMinus.Cut
        If p_versionServer > cV20 Then
            shapeMinusX.Cut
            shapeLinkDoc.Cut
        End If
    
    End With
    timerStop cTimerFormatHry
    
    activationBackup
    safeActivate target, IIf(activeRow, activeRow, 1)
    activationRestore
    
End Sub

Public Sub shapesCreateOutside(Optional shapeMater As Shape)

    ' create (document) shapes outside the result area, i.e. on filter cells, text element cells, etc.
    '   1st query refresh: shapeMater == Nothing -> ALL shape types may be created anew
    '   further refreshes: shapeMater <> Nothing -> only shapes on filter VALUE shapes may be created
    Dim prefix As String: prefix = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQPrefix)

    Dim shapeMaterCreated As Boolean
    If shapeMater Is Nothing Then ' 1st query refresh: replace ALL doc shapes
        shapesDelete ActiveCell, prefix & "x", True
        Set shapeMater = standardShapeGet(shapeNameLinkDoc, RunGetResultRange(p_currentQueryIndex).Parent)
        If shapeMater Is Nothing Then
          shapeMaterCreated = False
        Else
          shapeMaterCreated = True
        End If
    End If

    activationBackup True

    Dim shpRow As Object
    For Each shpRow In p_tables("E_T_DOC_LIST").Rows
        Dim atCell As Range
        Select Case shpRow("TYPE")
            Case "D":           Set atCell = RunGetValueRange(shpRow("KEY"), True)
            Case "I":           Set atCell = RunGetValueRange(shpRow("KEY"))
            Case "C", "F", "V": Set atCell = RunGetTextRange(shpRow("KEY"))
            Case Else:          Set atCell = Nothing
        End Select
        If Not atCell Is Nothing Then
            If atCell.Parent Is shapeMater.Parent Then
                If atCell.HorizontalAlignment = xlHAlignLeft Then
                atCell.Cells(1).IndentLevel = 2
                End If
                addShape shapeMater, 0, 0, atCell, prefix & IIf(shpRow("TYPE") = "D", " D", "x D") & shpRow("KEY"), False, False, False, getURL(shpRow("TXTINDEX"))
            End If
        End If
    Next shpRow

    If shapeMaterCreated Then shapeMater.Cut
    activationRestore

End Sub

Private Function copyShape(ByVal fromShape As Shape, ByVal toSheet As Worksheet) As Shape

    Set copyShape = Nothing
    On Error Resume Next
    
    Dim shapeCount As Integer: shapeCount = toSheet.Shapes.Count
    Dim repetitions As Integer
    While repetitions < 1000
        fromShape.Copy
        toSheet.Paste
        If toSheet.Shapes(shapeCount + 1).Name = fromShape.Name Then
            Set copyShape = toSheet.Shapes(shapeCount + 1)
            Exit Function
        Else
            toSheet.Shapes(shapeCount + 1).Delete
        End If
        repetitions = repetitions + 1
    Wend

End Function

Private Function addShape(shapeMater As Shape, xIndent As Integer, yIndent As Integer, atCell As Range, newName As String, flip As Boolean, Optional horizontal As Boolean, Optional randomName As Boolean, Optional shapeURL As String)
    Dim lShape As Shape                                                'ND 5-028
    Dim andi_counter As Integer                                         'VBR
    
    '************* Added by Ezhil on 02.08.2007 to fix the zoom issues in Hierarchical shape*******'
    ' Hotfix Excel2007 Shapes

    Dim lOldSheet As Worksheet
    Dim lOldZoom As Variant
    Set lOldSheet = ActiveSheet
    atCell.Worksheet.activate
    lOldZoom = Windows(1).Zoom
    Windows(1).Zoom = 100
    '************* Added by Ezhil on 02.08.2007 to fix the zoom issues in Hierarchical shape*******'
    
    xIndent = IIf(xIndent > 15, 15, xIndent) * g_xIndentSize + 1
    yIndent = yIndent * g_yIndentSize + 1
    With atCell
        If .Width = 0 Or .Height = 0 Then Exit Function
        If .Width <= xIndent Then ' shape would fall into the next cell to the right
            .ColumnWidth = .ColumnWidth / .Width * xIndent + 1
        End If
        If .Height <= yIndent Then ' shape would fall into the next cell below
            .RowHeight = .RowHeight / .Height * yIndent + 1
        End If
    End With
    
    'shapeMater.Duplicate might create problems on protected worksheet, 'ND 5-028
    'hence if this does not work use copyShape.Cannot use code to
    'unprotect worksheet here as this may lead to password prompt,
    'in case of password protected worksheet.
    'copShape leads to performance problems when large number of
    'shapes are used. Hence shapeMater.duplicate preferred
    On Error Resume Next
    Set lShape = shapeMater.Duplicate
    If lShape Is Nothing Then
        Set lShape = copyShape(shapeMater, atCell.Worksheet)
    End If
    
    With lShape
        On Error Resume Next
        Dim gs As GroupShapes: Set gs = .GroupItems
        Dim l_shpNameSuffix As String
        If randomName Then
        Do
        Err = 0
                l_shpNameSuffix = Hex(Format(Date, "DDMMYY")) & Hex(WorksheetFunction.Substitute(Timer, Application.International(xlDecimalSeparator), "")) & Hex(g_shpNameSuffix)
                g_shpNameSuffix = g_shpNameSuffix + 1
                If g_shpNameSuffix = 256 Then g_shpNameSuffix = 0
                .Name = newName & l_shpNameSuffix
                andi_counter = andi_counter + 1             ' VBR
        Loop Until Err = 0 Or andi_counter > 10             ' VBR

        Else
            If Len(newName) > 30 Then newName = Right(newName, 30) ' VBR 11:55
            On Error GoTo deleteOldShape
            .Name = newName
        End If
        On Error GoTo 0
        Dim s As Shape
        Dim i As Integer
        If Not gs Is Nothing Then
            For Each s In gs
                s.Name = .Name & " " & i
                i = i + 1
            Next s
        End If
        .Left = atCell.Left + xIndent
        .Top = atCell.Top + yIndent
        If flip Then .flip IIf(horizontal, msoFlipHorizontal, msoFlipVertical)
        If Left(Application.Version, 3) <> "8.0" Then ' not supported for Excel97
            .AlternativeText = shapeURL
        End If
    End With
    
     '************* Added by Ezhil on 02.08.2007 to fix the zoom issues in Hierarchical shape*******'
     ' Finalize Hotfix restore Oldstyle

        atCell.Worksheet.activate
        Windows(1).Zoom = lOldZoom
        lOldSheet.activate
     ' end hotfix

    '************* Added by Ezhil on 02.08.2007 to fix the zoom issues in Hierarchical shape*******'
    Exit Function

deleteOldShape:
    Dim c As Integer
    c = c + 1
    If c > 1000 Then Stop
    atCell.Parent.Shapes(newName).Cut
    Resume

End Function

Public Function getURL(txtIndex As Long) As String
    If txtIndex Then
        Dim txtId As String
        txtId = p_tables("E_T_TEXT").cell(txtIndex, "TXTID")
        Dim myUrl As String
        Do
            myUrl = myUrl & p_tables("E_T_TEXT").cell(txtIndex, "TXT")
            If p_tables("E_T_TEXT").Rows.Count > txtIndex Then txtIndex = txtIndex + 1 Else GoTo leave
        Loop While p_tables("E_T_TEXT").cell(txtIndex, "TXTID") = txtId
    End If
leave:
    getURL = myUrl
End Function

Public Sub shapesDelete(target As Range, hryPrefix As String, Optional deleteAll As Boolean)

    Dim lenPrefix As Integer:   lenPrefix = Len(hryPrefix)

    If Not deleteAll Then
        
        Dim last As Range
    
        Dim minY As Double:   minY = target.Resize(1).Top
        Set last = target.Resize(1).Offset(target.Rows.Count - 1)
        Dim maxY As Double:   maxY = last.Top + last.Height
        
        Dim minX As Double:   minX = target.Resize(, 1).Left
        Set last = target.Resize(, 1).Offset(, target.Columns.Count - 1)
        Dim maxX As Double:   maxX = last.Left + last.Width
    
    End If
   '*****************Made as comment on 02.08.2007 **********************************************
    
   ' Dim myShape As Shape
   ' Dim first As Boolean
   ' first = True
   ' For Each myShape In target.Worksheet.Shapes
   '     With myShape
   '         If Left(.Name, lenPrefix) = hryPrefix Then
   '             If deleteAll Or (.Top >= minY And .Top < maxY And .Left >= minX And .Left < maxX) Then
   '                 .Select first
   '                 first = False
   '             End If
   '         End If
   '     End With
   ' Next myShape
   ' If first Then Exit Sub
    
   ' Dim deleteShapeRange As ShapeRange: Set deleteShapeRange = Selection.ShapeRange
   '*****************Made as comment on 02.08.2007 **********************************************
   
    Dim protectSheet As Worksheet
    ' Excel97 can not delete shapes on a "SAPprotected" sheet
    Set protectSheet = target.Parent
    If protectSheet.ProtectContents Then
        protectSheet.Unprotect Mid(name2string(protectSheet.names, xlnamePassword), 2)
    Else
        Set protectSheet = Nothing
    End If
    
    '*****************Added by Ezhil on 02.08.2007 **********************************************

    Dim myShape As Shape
    Dim first As Boolean
    first = True
    For Each myShape In target.Worksheet.Shapes
        With myShape
            If Left(.Name, lenPrefix) = hryPrefix Then
                If deleteAll Or (.Top >= minY And .Top < maxY And .Left >= minX And .Left < maxX) Then
                    .Select first
                    first = False
                End If
            End If
        End With
    Next myShape
    If first Then Exit Sub
    
    Dim deleteShapeRange As ShapeRange: Set deleteShapeRange = Selection.ShapeRange
    
    '*****************Added by Ezhil on 02.08.2007 **********************************************
    
'?    Application.Visible = True
    deleteShapeRange.Delete
    ' this is pure magic and causes some flickering, but it still seems to be necessary:
    ' without it, Excel sometimes crashed when ScreenUpdating became TRUE at the end ogf the macro!
    Application.ScreenUpdating = True
    Application.ScreenUpdating = False
    ' end of magic
    If Not protectSheet Is Nothing Then
        protectSheet.Protect Mid(name2string(protectSheet.names, xlnamePassword), 2), , , , True
    End If

End Sub

' ----- shape action

Public Sub shapesEnable(wb As Workbook)
    shapeSetAction wb, cShapeOnAction
End Sub

Public Sub shapesDisable(wb As Workbook)
    shapeSetAction wb, ""
End Sub

Private Sub shapeSetAction(wb As Workbook, action As String)

    Dim ws As Worksheet
    For Each ws In wb.Worksheets
        Dim sh As Shape
        For Each sh In ws.Shapes
            If Left(sh.Name, cXLnameTagLen) = cXLnameTag Then sh.onAction = action
        Next sh
    Next ws
    
End Sub

' Syntax of Shape Names:
'  Release 2.0 (hierarchy shapes only)
'       <query name>_<SID>          SID is type "Long" and must be reported back to the server on shape action
'  Release 3.0
'       <query name>_<type><ID>     hierarchy shape ("type" is either E, C, or U)
'       <query name>_D<ID>          document shape
'       <query name>x_D<ID>         document shape, x means that shape will only be created on 1st query refresh
'  Parts of group shapes (returned as "caller" under Excel XP)
'       <shapeName>_<partNumber>

Public Sub shapeAction()

    On Error Resume Next
    Dim shapeName As String:    shapeName = Application.Caller
    Dim cutIndex As Integer:    cutIndex = InStr(shapeName, " ")
    Dim queryName As String:    queryName = Left(shapeName, cutIndex - 1)
    Dim shapeValue As String:   shapeValue = Mid(shapeName, cutIndex + 1)
    If InStr(shapeValue, " ") Then ' group shape, Excel XP (or higher)
        shapeValue = Left(shapeValue, InStr(shapeValue, " ") - 1)
        shapeName = queryName & " " & shapeValue
    End If
    On Error GoTo 0
    If Len(queryName) = 0 Then Exit Sub
    
    If Left(shapeValue, 1) = "D" Then   ' link action
        If Left(Application.Version, 3) <> "8.0" Then ' not supported for Excel97!
            internetBrowserLaunch ActiveSheet.Shapes(shapeName).AlternativeText
        Else
            userError "version97", vbInformation
        End If
    Else                                ' hierarchy action
        Set p_currentRepoSheet = repoGetRepoSheet(ActiveWorkbook, False)
        If p_currentRepoSheet Is Nothing Then Exit Sub
        With p_currentRepoSheet
            Dim i As Integer
            For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCQ) - 1
                If .Cells(i, cRepoCQPrefix) = queryName Then
                    p_currentQueryIndex = i
                    If isConnected(True) Then
                        If p_versionServer < cV30 Then
                            If contextSetIndex(CLng(shapeValue)) Then
                                contextSAP "HIRA"
                            End If
                        Else
                            Dim myCell As Range:        Set myCell = ActiveSheet.Shapes(shapeName).topLeftCell
                            Dim resultRange As Range:   Set resultRange = RunGetResultRange(p_currentQueryIndex)
                            If contextSetIndex(myCell.row + 1 - resultRange.row, myCell.column + 1 - resultRange.column) Then
                                contextSAP "HIRT"
                            End If
                        End If
                    Else
                        menuShow "Refresh"
                    End If
                    Exit For
                End If
            Next i
        End With
    End If
    
End Sub

' --- indent factor for hierarchy shapes

Public Sub indentFactorSet()
    
    ActiveWorkbook.names.Add xlnameHryIndent, menuParam, False
    
    Set p_currentRepoSheet = repoGetRepoSheet(ActiveWorkbook, False)
    If p_currentRepoSheet Is Nothing Then Exit Sub
    If p_currentRepoSheet.Cells(cRepoRCounts, cRepoCQ) > 0 Then
        If userError("hryIndentChanged", vbInformation + vbYesNo) = vbYes Then RunQueriesInWorkbook ActiveWorkbook, True
    End If

End Sub

Public Function indentFactorGet(wb As Workbook) As Integer
    indentFactorGet = name2integer(wb.names, xlnameHryIndent, 2)
End Function

Private Sub estimateShapeIndentSize()

    If g_xIndentSize Then Exit Sub  ' indent size has been calculated before ...

    Const cDefaultXindentSize = 9   ' correct indent size for the Excel default (Arial, 10)
    g_xIndentSize = cDefaultXindentSize

    Const cDefaultYindentSize = 13  ' correct indent size for the standard hierarchy style
    g_yIndentSize = cDefaultYindentSize

    With p_currentRepoSheet
        If Application.StandardFont <> "Arial" Or Application.StandardFontSize <> 10 Then
            ' compare sizes of Arial 10 and the current standard font
            .Cells(1, 253) = Space(10):   .Cells(1, 254) = Space(13)
            .Cells(1, 255) = Space(10):   .Cells(1, 256) = Space(13)
            With .Cells(1, 253).Resize(, 2)
                .Font.Name = "Arial"
                .Font.Size = 10
            End With
            With .Cells(1, 255).Resize(, 2)
                .Font.Name = Application.StandardFont
                .Font.Size = Application.StandardFontSize
            End With
            .Columns(253).Resize(, 4).autoFit
            If .Columns(254).Width <> .Columns(253).Width Then
                g_xIndentSize = Int(cDefaultXindentSize * (.Columns(256).Width - .Columns(255).Width) / (.Columns(254).Width - .Columns(253).Width))
            End If
        End If
        
        setStyle .Cells(1001, 252), "SAPBEXHLevel0X", "SAPBEXstdItem": .Cells(1001, 252) = vbLf & "X"
        setStyle .Cells(1002, 252), "SAPBEXHLevel0X", "SAPBEXstdItem": .Cells(1002, 252) = vbLf & vbLf & "X"
        .Rows(1001).Resize(2).autoFit
        If .Rows(1002).Height <> .Rows(1001).Height Then
            g_yIndentSize = .Rows(1002).Height - .Rows(1001).Height
        End If
        
    End With

End Sub
Attribute VB_Name = "cBEXstorage"
Option Private Module
Option Explicit

Private Sub wbPropSet(wb As Workbook, Optional setTitle As Boolean = True)
    Dim textTable As Object: Set textTable = p_tables("E_T_RETURNTEXTS")
    With wb
        On Error Resume Next
        .names(xlnameSystemID).Delete
        .names(xlnameWorkbookID).Delete
        On Error GoTo 0
        .names.Add xlnameSystemID, textTable(1, 1), False
        .names.Add xlnameWorkbookID, textTable(2, 1), False
        If setTitle Then .Windows(1).caption = textTable(3, 1) & " (" & wb.Name & ")"
        If textTable.Rows.Count > 3 Then
        On Error Resume Next
        .names(xlnameRevision).Delete
        .names.Add xlnameRevision, textTable(4, 1), False
        End If
    End With
End Sub

Private Sub wbPropDelete(wb As Workbook)
    On Error Resume Next
    With wb
        .names(xlnameSystemID).Delete
        .names(xlnameWorkbookID).Delete
        .names(xlnameRevision).Delete
    End With
End Sub

Public Function storageGetSysID(wb As Workbook) As String
    If Not wb Is Nothing Then storageGetSysID = name2string(wb.names, xlnameSystemID)
End Function

Public Function storageGetWBID(wb As Workbook) As String
    If Not wb Is Nothing Then storageGetWBID = name2string(wb.names, xlnameWorkbookID)
End Function
    
Private Function storageGetRevision(wb As Workbook) As Long
    Dim currentRevision As Long
    currentRevision = CLng(name2integer(wb.names, xlnameRevision))
    ' either return 0 (i.e. no version check), or return the next (!!) revision number
    If currentRevision Then storageGetRevision = currentRevision + 1
End Function
    
Public Function wbIDgetSavedIn20(wb As Workbook) As String
    
    If versionFault Then Exit Function
    
    Dim wbID As String:     wbID = storageGetWBID(wb)
    Dim sysID As String:    sysID = storageGetSysID(wb)
    If Len(wbID) = 0 Or p_connectionObj.system <> sysID Then
        If userError("saveWorkbookFirst", vbQuestion + vbYesNo, vbNewLine & userText("saveWorkbook?")) = vbYes Then
            saveNewWorkbook
            wbIDgetSavedIn20 = storageGetWBID(wb)
        End If
    Else
        wbIDgetSavedIn20 = wbID
    End If
    
End Function

Public Function storageReadTemplate() As Workbook

    Dim wb As Workbook
    Select Case templateState
        Case cTemplateChoose
            HideProgress ' "open" dialog might conflict with progress bar on embed after jumps
            Dim agrID As String:    agrID = openWorkbookTemplate(False)
            If Len(agrID) Then ' Cancel? -> use empty workbook
                If Not storageRead(agrID, wb, p_versionServer = cV20, True) Then Exit Function
            End If
        Case cTemplatePermanent
            If Not storageRead("", wb, , True) Then Exit Function
        Case Else
            ' use empty workbook
    End Select
    If wb Is Nothing Then
        Set storageReadTemplate = Application.Workbooks.Add
    Else
        Set storageReadTemplate = wb
    End If
    
End Function

Public Sub storageTemplateSet()
    
    Dim wbID As String:     wbID = openWorkbookTemplate(True)
    If Len(wbID) Then
        If p_versionServer = cV20 Then
            rfcSetTemplate "", wbID
        Else
            rfcSetTemplate wbID, ""
        End If
    End If

End Sub

Public Function storageRead(wbID As String, wb As Workbook, Optional asAgrID As Boolean, Optional asTemplate As Boolean) As Boolean
    
    Dim agrID As String
    If asAgrID Then
        agrID = wbID
        wbID = ""
    End If

    userStatusBar "DocumentStore"
    If asTemplate Then screenHalt
    
    Dim wbPath As String:   wbPath = TempNewFileName("xls")
    If rfcReadWorkbook(wbID, wbPath, agrID) Then
        
        On Error Resume Next
        Set wb = Application.Workbooks.Open(fileName:=wbPath, ReadOnly:=True)
        If Err Then
            If Len(wbID) Or Len(agrID) Then
                userError "workbookStorage", , "(read/open)"
                storageRead = False
            Else
                storageRead = True ' storage read succeeded, although template was not found
            End If
            GoTo leave
        End If
        On Error GoTo 0
        
        If asTemplate Then
        
            wbPropDelete wb
            wb.Windows(1).caption = userText("constNewWorkbook") & " (" & wb.Name & ")"
            
        Else
            
            wbPropSet wb
            shapesEnable wb
            
            ' wb.RunAutoMacros xlAutoOpen -> didn't work! (see OSS note 171798/1999)
            On Error Resume Next
            Run wb.Name & "!Auto_Open"
            On Error GoTo 0
            ' run all the queries in the workbook which have their "AutoRefresh" flag set to "on"
            RunQueriesInWorkbook wb, False, False, True
        
        End If
        
        wb.Windows(1).WindowState = xlMaximized
        storageRead = True
        
    End If

leave:
    If asTemplate Then screenRestore
    userStatusBar ""
    
End Function

Public Sub saveNewWorkbook()

    If Not dialIn Then Exit Sub
    If p_versionServer >= cV20 Then ' select activity group to store in via standard open/save dialog
        Dim newName As String
        Dim agrID As String:    agrID = saveDialogWorkbook(newName)
        If Len(agrID) Then storageWrite ActiveWorkbook, False, True, "", newName, agrID
    Else
        With dBEXsave
            .optionSaveAsNew
            If userFormShow(dBEXsave, "captionSave") Then
                storageWrite ActiveWorkbook, False, True, IIf(.optRefPrivate, "5", "3"), .editTitle.Text
            End If
        End With
    End If

End Sub

Public Sub saveNewContent()
    storageWrite ActiveWorkbook, True, True, " "
End Sub

Public Sub saveNewTitle()

    With dBEXsave
        .optionSaveExist
        If userFormShow(dBEXsave, "captionSaveTitle") Then
            storageWrite ActiveWorkbook, True, False, IIf(.optRefPrivate, "5", "3"), .editTitle.Text
        End If
    End With

End Sub

Public Sub storageWrite(wb As Workbook, newVersion As Boolean, saveContent As Boolean, privacyFlag As String, Optional title As String, Optional agrID As String)
    
    If Not tableReset("I_T_USED_REPORTS") Then Exit Sub
    If saveContent Then
        Dim repoSheet As Worksheet: Set repoSheet = repoGetRepoSheet(wb, False)
        If Not repoSheet Is Nothing Then
            With repoSheet
                Dim rowQueries As Object
                Dim i As Integer
                For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCQ) - 1
                    Set rowQueries = p_tables("I_T_USED_REPORTS").Rows.Add
                    rowQueries(1) = i + 1 - cRepoRTop
                    rowQueries(2) = .Cells(i, cRepoCQID)
                Next i
            End With
        End If
    End If
    
    Dim wbID As String
    Dim sysID As String
    Dim revision As Long
    If newVersion Then
        wbID = storageGetWBID(wb)
        sysID = storageGetSysID(wb)
        revision = storageGetRevision(wb)
    End If
    
    userStatusBar "DocumentStore"
    
    Dim wbPath As String
    If saveContent Then
        wbPath = TempNewFileName("xls")
        shapesDisable wb
        On Error Resume Next
        wb.SaveCopyAs wbPath
        On Error GoTo 0
        If Err Then
            userError "workbookStorage", , "(write/save)"
            GoTo leave
        End If
        shapesEnable wb
    End If

    If rfcWriteWorkbook(wbID, sysID, wbPath, privacyFlag, title, agrID, revision) Then
        wbPropSet wb, Len(title)
        wb.Saved = True
    Else
        userError "workbookNotSaved", vbInformation
    End If
    
    If Len(wbPath) Then tryToKill wbPath
        
leave:
    userStatusBar ""
        
End Sub

Public Sub tryToKill(fileName As String)
    On Error Resume Next
    Kill fileName
End Sub
Attribute VB_Name = "cBEXtimer"
Option Explicit

Type Measure
    start As Single
    accumulated As Single
End Type

Private myMeasures(1 To 13) As Measure

Public Const cTimerAll As Byte = 10
Public Const cTimerReadDefinition As Byte = 1
Public Const cTimerWriteDefinition As Byte = 2
Public Const cTimerFillResult As Byte = 3
Public Const cTimerFormatResult As Byte = 4
Public Const cTimerFormatHry As Byte = 5
Public Const cTimerTexts As Byte = 11
Public Const cTimerExtern As Byte = 6
Public Const cTimerRfcOpen As Byte = 7
Public Const cTimerRfcGetGrid As Byte = 8
Public Const cTimerRfcFillGrid As Byte = 9
Public Const cTimerRfcVariables As Byte = 12
Public Const cTimerRfcTexts As Byte = 13

Private g_pingTimeStarted As Single
Private g_pingTimeElapsed As Single
Private g_pingTimeRunning As Boolean

Public Sub timerStart(category As Byte)
    
    #If Timer Then
        If category = cTimerAll Then
            Dim i As Integer
            For i = 0 To UBound(myMeasures)
                myMeasures(i).accumulated = 0
            Next i
        End If
        myMeasures(category).start = Timer
    #End If
    
End Sub

Public Sub timerStop(category As Byte)

    #If Timer Then
        myMeasures(category).accumulated = myMeasures(category).accumulated + Timer - myMeasures(category).start
        If category = cTimerAll Then
            trace True, "*" & _
                myMeasures(cTimerAll).accumulated & vbTab & _
                myMeasures(cTimerReadDefinition).accumulated & vbTab & _
                myMeasures(cTimerWriteDefinition).accumulated & vbTab & _
                myMeasures(cTimerFillResult).accumulated & vbTab & _
                myMeasures(cTimerFormatResult).accumulated & vbTab & _
                myMeasures(cTimerFormatHry).accumulated & vbTab & _
                myMeasures(cTimerTexts).accumulated & vbTab & _
                myMeasures(cTimerExtern).accumulated & vbTab & _
                myMeasures(cTimerRfcOpen).accumulated & vbTab & _
                myMeasures(cTimerRfcGetGrid).accumulated & vbTab & _
                myMeasures(cTimerRfcFillGrid).accumulated & vbTab & _
                myMeasures(cTimerRfcVariables).accumulated & vbTab & _
                myMeasures(cTimerRfcTexts).accumulated
        End If
    #End If

End Sub

Public Sub timerInit()
    
    #If Timer Then
        trace True, "*" & _
            "sum" & vbTab & _
            "read def" & vbTab & _
            "write def" & vbTab & _
            "fill result" & vbTab & _
            "format result" & vbTab & _
            "format hry" & vbTab & _
            "text symbols" & vbTab & _
            "extern" & vbTab & _
            "rfc open" & vbTab & _
            "rfc get" & vbTab & _
            "rfc fill" & vbTab & _
            "rfc vars" & vbTab & _
            "rfc texts"
    #End If
    
End Sub

Public Sub pingTimeStart()
    g_pingTimeElapsed = 0
    g_pingTimeStarted = Timer
    g_pingTimeRunning = True
End Sub

Public Sub pingTimeHalt()
    If g_pingTimeRunning Then
        g_pingTimeElapsed = g_pingTimeElapsed + (Timer - g_pingTimeStarted)
        g_pingTimeRunning = False
    End If
End Sub

Public Sub pingTimeContinue()
    If Not g_pingTimeRunning Then
        g_pingTimeStarted = Timer
        g_pingTimeRunning = True
    End If
End Sub

Public Function pingTimeFinish() As Single
    If g_pingTimeRunning Then
        pingTimeHalt
        pingTimeFinish = g_pingTimeElapsed * 1000000
    Else
        pingTimeFinish = 0
    End If
End Function
Attribute VB_Name = "cBEXuser"
Option Private Module
Option Explicit

Private g_logonLanguage     As String
Private g_languageColumn    As Range
Private g_languageConvert   As Boolean
Private g_helpFileName      As String

Private g_validationTitle   As String * 32
Private g_validationMessage As String * 220

Private g_fontName          As String

Private g_screenState       As Integer
Private g_screenInitial     As Boolean
Private g_screenUpdating    As Boolean
Private g_screenCursor(10)  As Long                     'Since user dialogs calls can be nested, hence array used to store the cursor settings In ScreenBeforeDialog
Private g_cursorPointer     As Integer                  'cursor is stored in array which acts like a stack and in screenafterdialog,it is popped out


'----- functions for error dialogs and multiple language handling

Private Sub initializeLanguage()
    
    Select Case Application.International(xlCountryCode)
        Case 49:        userLanguageSet "DE" ' german
        Case 81:        userLanguageSet "JA" ' japanese
        Case 82:        userLanguageSet "KO" ' korean
        Case 33:        userLanguageSet "FR" ' french
        Case 34:        userLanguageSet "ES" ' spanish
        Case 55, 351:   userLanguageSet "PT" ' portugese
        Case 39:        userLanguageSet "IT" ' italian
        Case 45:        userLanguageSet "DK" ' danish
        Case 46:        userLanguageSet "SV" ' swedish
        Case 47:        userLanguageSet "NO" ' norsk
        Case 358:       userLanguageSet "FI" ' finnish
        Case 31:        userLanguageSet "NL" ' dutch
        Case 36:        userLanguageSet "HU" ' hungarian
        Case 42:        userLanguageSet "CS" ' czech
        Case 48:        userLanguageSet "PL" ' polish
        Case 7:         userLanguageSet "RU" ' russian
        Case 421:       userLanguageSet "SK" ' slovakian
        Case 90:        userLanguageSet "TR" ' turkish
        Case 972:       userLanguageSet "HE" ' hebrew
        Case 86:        userLanguageSet "ZH" ' modern chinese
        Case 886:       userLanguageSet "ZF" ' traditional chinese
        Case 386:       userLanguageSet "SL" ' slovenian
        Case 30:        userLanguageSet "EL" ' greek
        Case 40:        userLanguageSet "RO" ' romanian
        Case Else:      userLanguageSet "EN" ' english (code 1) is also used for unknown country codes
    End Select
    
End Sub

Public Sub userLanguageSet(language As String)
    
    With ThisWorkbook
        g_helpFileName = .Path & "\BIWREE.HLP" ' default: english help file
        g_languageConvert = False
        Dim columnNumber As Byte
        Select Case language
            Case "D", "D ", "DE":   columnNumber = 4:   g_logonLanguage = "DE": g_helpFileName = .Path & "\BIWRED.HLP"
            Case "J", "J ", "JA":   columnNumber = 5:   g_logonLanguage = "JA": g_languageConvert = True
            Case "3", "3 ", "KO":   columnNumber = 6:   g_logonLanguage = "KO": g_languageConvert = True
            Case "F", "F ", "FR":   columnNumber = 7:   g_logonLanguage = "FR"
            Case "S", "S ", "ES":   columnNumber = 8:   g_logonLanguage = "ES"
            Case "P", "P ", "PT":   columnNumber = 9:   g_logonLanguage = "PT"
            Case "I", "I ", "IT":   columnNumber = 10:  g_logonLanguage = "IT"
            Case "O", "O ", "NO":   columnNumber = 11:  g_logonLanguage = "NO"
            Case "V", "V ", "SV":   columnNumber = 12:  g_logonLanguage = "SV"
            Case "K", "K ", "DK":   columnNumber = 13:  g_logonLanguage = "DK"
            Case "U", "U ", "FI":   columnNumber = 14:  g_logonLanguage = "FI"
            Case "N", "N ", "NL":   columnNumber = 15:  g_logonLanguage = "NL"
            Case "H", "H ", "HU":   columnNumber = 16:  g_logonLanguage = "HU": g_languageConvert = True
            Case "L", "L ", "PL":   columnNumber = 17:  g_logonLanguage = "PL": g_languageConvert = True
            Case "R", "R ", "RU":   columnNumber = 18:  g_logonLanguage = "RU": g_languageConvert = True
            Case "C", "C ", "CS":   columnNumber = 19:  g_logonLanguage = "CS": g_languageConvert = True
            Case "Q", "Q ", "SK":   columnNumber = 20:  g_logonLanguage = "SK": g_languageConvert = True
            Case "T", "T ", "TR":   columnNumber = 21:  g_logonLanguage = "TR": g_languageConvert = True
            Case "B", "B ", "HE":   columnNumber = 22:  g_logonLanguage = "HE": g_languageConvert = True
            Case "1", "1 ", "ZH":   columnNumber = 23:  g_logonLanguage = "ZH": g_languageConvert = True
            Case "M", "M ", "ZF":   columnNumber = 24:  g_logonLanguage = "ZF": g_languageConvert = True
            Case "5", "5 ", "SL":   columnNumber = 25:  g_logonLanguage = "SL": g_languageConvert = True
            Case "G", "G ", "EL":   columnNumber = 26:  g_logonLanguage = "EL": g_languageConvert = True
            Case "4", "4 ", "RO":   columnNumber = 27:  g_logonLanguage = "RO": g_languageConvert = True
            Case "CA", "CA ", "CA":   columnNumber = 28:  g_logonLanguage = "CA"
            Case "BG", "BG", "BG": columnNumber = 29: g_logonLanguage = "BG": g_languageConvert = True
            Case Else:              columnNumber = 3:   g_logonLanguage = "EN" ' english is default
        End Select
        Set g_languageColumn = .Worksheets("wBEXlanguage").Columns(columnNumber)
    End With
    
    g_validationTitle = userText("captionFilterInput")
    g_validationMessage = userText("filterInput") & _
        vbNewLine & "- " & userText("filterInput1") & _
        vbNewLine & "- " & userText("filterInput2")
    
End Sub

Public Function userHelpFile() As String
    
    If Len(g_helpFileName) = 0 Then initializeLanguage
    userHelpFile = g_helpFileName

End Function

Public Function userText(stringName As String) As String

    If g_languageColumn Is Nothing Then initializeLanguage
    
    With ThisWorkbook.Worksheets("wBEXlanguage")
        Dim searchArea   As Range:    Set searchArea = .UsedRange.Columns(1)
        Dim searchCursor As Integer
        For searchCursor = 1 To searchArea.Rows.Count
            If searchArea.Cells(searchCursor) = stringName Then
                If g_languageConvert Then
                    userText = decode(g_languageColumn.Cells(searchCursor))
                Else
                    userText = g_languageColumn.Cells(searchCursor)
                End If
                Exit Function
            End If
        Next searchCursor
    End With

    userText = "<string lookup """ & stringName & """ failed>"
    
End Function

Public Function userSubMenu(addToControls As CommandBarControls, itemID As String, Optional beginGroup As Boolean, Optional disabled As Boolean) As CommandBarPopup

    Dim myMenuItem  As CommandBarPopup
    Set myMenuItem = addToControls.Add(Type:=msoControlPopup)
    With myMenuItem
        .caption = userText("menu" & itemID)
        .beginGroup = beginGroup
        .Enabled = Not disabled
    End With
    Set userSubMenu = myMenuItem

End Function

Public Function menuParam() As String
    menuParam = Application.CommandBars.ActionControl.tag
End Function

Public Function userMenu(addToControls As CommandBarControls, itemID As String, onAction As String, Optional beginGroup As Boolean, Optional disabled As Boolean, Optional param As String, Optional pressed As Boolean, Optional specialCaption As String) As CommandBarButton

    Dim myMenuItem  As CommandBarButton
    Set myMenuItem = addToControls.Add(Type:=msoControlButton)
    With myMenuItem
        .tag = param
        .Enabled = Not disabled
        .onAction = ThisWorkbook.Name & "!" & onAction
        .beginGroup = beginGroup
        .caption = IIf(Len(specialCaption), specialCaption, userText("menu" & itemID))
        .state = buttonState(pressed)
    End With
    Set userMenu = myMenuItem
    
End Function

Public Sub userMenuSAP(addToControls As CommandBarControls, rowMenu As Object)
    userMenu _
        addToControls, "", _
        "contextSAP", _
        Len(rowMenu("BEGINGROUP")) > 0, _
        Len(rowMenu("ENABLED")) = 0, _
        rowMenu("CMDID"), _
        Len(rowMenu("CHECKED")) > 0, _
        rowMenu("CAPTION")
End Sub

Public Function userFormShow(thisForm As Object, thisCaption As String) As Integer

    If p_extErrorFlag Then ' dialog is invoked in a function which has been called by the BEx's VBA-API
        userFormShow = 0
        Exit Function
    End If
    
    ' set language dependent labels, texts etc. in the form and then show it
    
    If g_fontName = "" Then g_fontName = Application.StandardFont
    Dim Control As Object
    For Each Control In thisForm.Controls
        With Control
            If .Name Like "label*" Or _
               .Name Like "button*" Or _
               .Name Like "frame*" Or _
               .Name Like "opt*" Or _
               .Name Like "check*" Then
                .caption = userText(.Name)
            End If
            If .Name Like "tab*" Then   ' special case: multi-page control
                Dim p As Page
                On Error Resume Next
                For Each p In .Pages: p.caption = userText(p.Name): Next p
            End If
            .Font.Name = g_fontName
        End With
    Next Control

    HideProgress
    screenBeforeDialog
    
    With thisForm
        .caption = userText(thisCaption)
        .Font.Name = g_fontName
        p_dialogSuccess = 0
        .showForm
    End With
    userFormShow = p_dialogSuccess
    
    screenAfterDialog

End Function

Public Sub userHelp()                                                 'VBR:07-038 Begin
'    rfcHTMLhelp "BA45583CA544EB51E10000000A114084", "F10A5A2EE09411D2ACB90000E829FBFE"
Const RBcOnlin35HelpID As String = "!XLA"           'For Analyzer
Const clObjectID As String = "BA45583CA544EB51E10000000A114084"
Dim lHelpID As String
Dim lSubRc As Long
Dim lServerVersion As String
Const RBcNoHelpIn7ID       As String = "!3X7"                         'VBR:07-039

  If Not provideGlobalLoggedOn Then Exit Sub
  lServerVersion = p_bexGlobal.ServerVersion
  If lServerVersion = vbNullString Then
    Call p_bexGlobal.R3Text("INIT", "INIT")
    lServerVersion = p_bexGlobal.ServerVersion
  End If
  lHelpID = clObjectID
  If lServerVersion >= "30" Then
    If lServerVersion >= "35" Then
      If lServerVersion >= "35A04" Then
      ' NetWeaver Stack 14
        If lServerVersion >= "700" Then
          'Same information as in MsgBox below just in 7.0 documentation
          Call fireBDNLaunch(RBcNoHelpIn7ID, "", True, lSubRc)                      'VBR:07-039
          If lSubRc <> 0 Then                                                       'VBR:07-039
          
            MsgBox "Help is not available" & vbCrLf & _
                   "from this 3.x frontend application" & vbCrLf & _
                   "when you are connected to a BW 7.0 (or higher) backend."
          End If                                                                    'VBR:07-039
        Else
          Call fireBDNLaunch(RBcOnlin35HelpID, lHelpID, True, lSubRc)
        End If
      Else
        MsgBox "Currently the help is not available." & vbCrLf & _
          "Please contact your BW-Administrator." & vbCrLf & _
          "SAP has provided a solution in note 880246." & vbCrLf & vbCrLf & _
          "Temporarily you can use 'SAP Help Portal' online:" & vbCrLf & _
          "http://help.sap.com"
        Select Case _
          MsgBox("If internet connection is available you can use" & vbCrLf & _
                 "directly one of the following options:" & vbCrLf & vbCrLf & _
                 "Press 'Yes' to open 'SAP Help Portal' or" & vbCrLf & _
                 "press 'No' to open 'BEx Analyzer Help' or" & vbCrLf & _
                 "press 'Cancel' to quit.", vbYesNoCancel + vbDefaultButton1)
          Case vbYes: Call CallUrl("http://help.sap.com")
          Case vbNo:  Call CallUrl("http://help.sap.com/saphelp_nw04/helpdata/en/ba/45583ca544eb51e10000000a114084/frameset.htm")
          Case vbCancel
        End Select
      End If
    Else
      Call fireBDNLaunch("!HLP", lHelpID, True, lSubRc)
    End If
  End If

End Sub                                                 'VBR:07-038 End


Public Sub userStatusBar(myStatus As String, Optional appendix As String, Optional notBusy As Boolean)
        
    With Application
        If Len(myStatus) Then
            If Not notBusy Then .Cursor = xlWait
            .StatusBar = "SAP BEx: " & userText("status" & myStatus) & " " & appendix
        Else
            .Cursor = xlDefault
            .StatusBar = False
        End If
    End With
    
End Sub

Public Function userError(errorName As String, Optional errorType As Integer = vbCritical, Optional appendix) As Integer

    Dim errorText   As String
    errorText = userText(errorName)
    If Not IsMissing(appendix) Then errorText = errorText & " " & appendix
    
    Dim errorReturn As Integer
    If p_extErrorFlag Then ' error is raised in a function which has been invoked by the BEx's VBA-API
        p_extErrorText = errorText
        If errorType <> vbInformation Then p_extErrorCount = p_extErrorCount + 1
        errorReturn = 0
    Else
        screenBeforeDialog
        errorReturn = MsgBox(errorText, errorType, cProductName)
        screenAfterDialog
    End If
    
    userError = errorReturn
    trace False, "user message: " & Choose(((errorType And 48) \ 16) + 1, "Information", "Critical", "Question", "Warning") & " - """ & errorText & """"
    trace False, "user replied: " & Choose(errorReturn, "OK", "Cancel", "Abort", "Retry", "Ignore", "Yes", "No")

End Function

Public Sub userValidate(target As Range)

    With target.Validation
        .Delete
        On Error Resume Next
        .Add Type:=xlValidateCustom, AlertStyle:=xlValidAlertInformation, Formula1:="false"
        .ErrorTitle = g_validationTitle
        .ErrorMessage = g_validationMessage
        .ShowInput = False
        .ShowError = True
    End With
    
End Sub

'----- screenUpdating on/off with a stack for previous values

Public Sub screenHalt()
    If g_screenState = 0 Then
        g_screenInitial = Application.ScreenUpdating
        Application.ScreenUpdating = False
    End If
    g_screenState = g_screenState + 1
End Sub

Public Sub screenRestore()
    If g_screenState > 0 Then g_screenState = g_screenState - 1
    If g_screenState = 0 Then
        Application.ScreenUpdating = g_screenInitial
    End If
End Sub

Private Sub screenBeforeDialog()
On Error Resume Next
    g_screenUpdating = Application.ScreenUpdating
    Application.ScreenUpdating = True
    g_screenCursor(g_cursorPointer) = Application.Cursor
    g_cursorPointer = g_cursorPointer + 1
    Application.Cursor = xlDefault
End Sub

Private Sub screenAfterDialog()
On Error Resume Next
    Application.ScreenUpdating = g_screenUpdating
    g_cursorPointer = g_cursorPointer - 1
    Application.Cursor = g_screenCursor(g_cursorPointer)
End Sub

'----- encode/decode for double-byte languages

' double-byte text is stored in encoded format to avoid performance problems in non-DBCS Excel2000

Public Function encode(myInput As String) As String

    Dim i As Integer
    Dim output As String
    For i = 1 To Len(myInput)
        output = output & Right$("0000" & Hex(AscW(Mid(myInput, i, 1))), 4)
    Next i
    encode = output

End Function

Public Function decode(myInput As String) As String

    Dim i As Integer
    Dim output As String
    For i = 1 To Len(myInput) Step 4
        output = output & ChrW(Val("&H" & Mid(myInput, i, 4)))
    Next i
    decode = output

End Function

Private Function encodeSelection()
    Dim c As Range
    For Each c In Selection.SpecialCells(xlCellTypeConstants)
        c.Value = "'" & encode(c.Value)
    Next c
End Function

Private Function decodeSelection()
    Dim c As Range
    For Each c In Selection.SpecialCells(xlCellTypeConstants)
        c.Value = "'" & decode(c.Value)
    Next c
End Function


Private Sub CallUrl(ByVal iUrl As String)                       'VBR:07-038 Begin
Dim lExplorer As Object

  If Trim(iUrl = vbNullString) Then Exit Sub
  On Error Resume Next
  Set lExplorer = CreateObject("InternetExplorer.Application.1")
  If Not lExplorer Is Nothing Then
    lExplorer.Visible = True
    Call lExplorer.Navigate(iUrl) ', navNoHistory Or navNoReadFromCache Or navNoWriteToCache)
  End If
  On Error GoTo 0
End Sub                                                           'VBR:07-038 End
                                                                 'VBR:07-038 Begin
Public Sub fireBDNLaunch( _
     ByVal iTLogo As String, _
     ByVal iObjectName As String, _
     ByVal iReadOnly As Boolean, _
     ByRef eSubRc As Long)
  Const RBcColTlogo          As String = "TLOGO"
  Const RBcColObjectName     As String = "OBJECT_NAME"
  Const RBcColReadOnly       As String = "READ_ONLY"
  Dim litParams As Object
  Dim letParams As Object
  Dim lRow As Object
  
  Call p_bexGlobal.SAPRfcServer.SAPBDNLaunch(litParams, letParams, eSubRc, True)     'For Analyzer
  Set lRow = litParams.Rows.Add
  With lRow
    .Value(RBcColTlogo) = iTLogo
    .Value(RBcColObjectName) = iObjectName
    .Value(RBcColReadOnly) = IIf(iReadOnly, "X", " ")
  End With
  Call p_bexGlobal.SAPRfcServer.SAPBDNLaunch(litParams, letParams, eSubRc, False)        'For Analyzer
  If eSubRc = 0 Then
    'Update of Statusbar: e.g. for Analyzer call userStatusBar
    'Text example: Documentation started in a new process
  Else
    'Update of Statusbar: e.g. for Analyzer call userStatusBar
    'Text example: Error starting documentation in a new process
  End If
End Sub                                                           'VBR:07-038 End

Attribute VB_Name = "clBEXeventApp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' To update version, use immediate window
'? thisworkbook.CustomDocumentProperties.item("Version")
'
'
'
Option Explicit

Public WithEvents myAppEvents As Application
Attribute myAppEvents.VB_VarHelpID = -1

Private Sub Class_Initialize()
    Set myAppEvents = Application ' enable events
End Sub

Private Sub myAppEvents_SheetBeforeDoubleClick(ByVal sh As Object, ByVal target As Excel.Range, Cancel As Boolean)
    Cancel = contextAction(sh, target, False)
    Application.ScreenUpdating = True
End Sub

Private Sub myAppEvents_SheetBeforeRightClick(ByVal sh As Object, ByVal target As Excel.Range, Cancel As Boolean)
    If checkRClick Then
        Cancel = contextAction(sh, target, True)
    Else
        Cancel = False
    End If
    Application.ScreenUpdating = True
End Sub

Private Sub myAppEvents_WorkbookBeforeClose(ByVal wb As Excel.Workbook, Cancel As Boolean)
  
   Dim ws As Worksheet                        'This added code will check whether any query is embeded in workbook or not.
   Dim wbfound As Boolean                     'If the query is embeded then it will do further processing otherwise it
    For Each ws In wb.Worksheets              ' will quit.                      VBR :BEGIN  3500.07.037
        If ws.Name = cRepoSheetName Then
        wbfound = True
        End If
    Next ws
    
    If wbfound = True Then                     'VBR :END
        Dim isSaved As Boolean
        isSaved = wb.Saved
        If isConnected Then dialOutClearHandles wb, True
        shapesDisable wb
        bbsBackDisable wb
        gisCleanUp wb
        wb.Saved = isSaved
        
        If Not p_currentRepoSheet Is Nothing Then
            If p_currentRepoSheet.Parent Is wb Then Set p_currentRepoSheet = Nothing
        End If
        
        If Not isPdfMakerLoaded Then CoFreeUnusedLibraries
    End If                                      'VBR :3500.07.037
End Sub

Private Sub myAppEvents_WorkbookOpen(ByVal wb As Excel.Workbook)
    
    ' several lines are commented out because of a bug in Excel: "Open" event handler can not ...
    
    ' ... move/copy information in the repoSheet
    '(repoGetRepoSheet must not be used, because converting repoSheet version might fail)
    Dim repoSheet As Worksheet
    On Error Resume Next
    Set repoSheet = wb.Worksheets(cRepoSheetName)
    On Error GoTo 0
    If repoSheet Is Nothing Then Exit Sub
    dialOutClearHandles wb, False, repoSheet

    shapesEnable wb
    bbsBackDisable wb
    
    ' ... change formats in the newly opened workbook -> displayResult would fail (if query result changes)
    '  runQueriesInWorkbook wb

End Sub
Attribute VB_Name = "dBEXmessages"
Attribute VB_Base = "0{60341CE9-F545-4329-8E71-62ED78C08866}{65E6965A-F2BA-4D79-994D-6C732A6145EB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = 1
    Hide
End Sub

Private Sub listMessages_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    listMessages_Click
End Sub

Private Sub listMessages_Click()
    
    Dim i As Integer
    For i = 1 To listMessages.ListCount
        If listMessages.Selected(i - 1) Then
            With p_tables("E_T_MESG").Rows(i)
                rfcMessageDetail .Value("ARBGB"), .Value("TXTNR"), .Value("MSGV1"), .Value("MSGV2"), .Value("MSGV3"), .Value("MSGV4")
            End With
        End If
    Next i

End Sub

Private Sub buttonClose_Click()
    Hide
End Sub

Public Function showForm() As Integer
    
    listMessages.Clear
    ' list of messages has already been read from server ...
    Dim rowMessages As Object
    For Each rowMessages In p_tables("E_T_MESG").Rows
        listMessages.AddItem userText("constMType" & rowMessages("MSGTY")) & " " & rowMessages("TEXT")
    Next rowMessages

    Show
    p_dialogSuccess = 1

End Function
Attribute VB_Name = "dBEXmoveOrCopy"
Attribute VB_Base = "0{9E7619EA-507F-4A2E-8CC9-8BF8E4A49706}{CEAF7441-22FD-4C12-B9EF-A177CE8014B6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public outsideMoveAllowed As Boolean

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = 1
    buttonCancel.SetFocus
    Hide
End Sub

Private Sub buttonCancel_Click()
    Set p_newLocation = Nothing
    Hide
End Sub

Private Sub buttonOK_Click()
    
If Me.editPosition.Text <> "" Then
    On Error Resume Next
    Set p_newLocation = Application.Range(editPosition.Value) '.Cells(1, 1)
    On Error GoTo 0
    
    If Not p_newLocation Is Nothing Then
        If p_newLocation.Worksheet.ProtectContents Then
            ' copying into protected sheets is forbidden
            userError "sheetProtected"
        Else
            If p_newLocation.Worksheet.Parent Is p_currentRepoSheet.Parent Or outsideMoveAllowed Then
                p_dialogSuccess = 1
                Hide
                Exit Sub
            Else
                ' moving things is not allowed between workbooks, only copying
                userError "posWrongBook"
            End If
        End If
        Set p_newLocation = Nothing
        setAddress ""
        p_currentRepoSheet.Parent.activate
    End If
    Else
                userError "posWrongBook"
    End If
    editPosition.SetFocus

End Sub

Public Sub setAddress(myAddress As String)
    editPosition.Value = myAddress
End Sub

Public Function showForm() As Integer
    Dim oldReferenceStyle As Integer: oldReferenceStyle = Application.ReferenceStyle
    Application.ReferenceStyle = xlA1
    editPosition.SetFocus
    Show
    Application.ReferenceStyle = oldReferenceStyle
End Function
Attribute VB_Name = "dBEXprotect"
Attribute VB_Base = "0{2DE1FD50-738D-4E26-A533-60010A80ADB5}{BBB9A3DA-B486-4868-97B1-4DD21D530B3B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    ' disable closing the form via the Close command
    If CloseMode = vbFormControlMenu Then Cancel = 1
    buttonCancel.SetFocus
    Hide
End Sub

Private Sub buttonCancel_Click()
    Hide
End Sub

Private Sub buttonOK_Click()
    If editPW1 = "" Then
        tryAgain "passwordNonBlank"
    Else
        If editPW1 = editPW2 Then
            ' pad a "q" in front of the password, to allow numbers as passwords
            ActiveSheet.names.Add xlnamePassword, "q" & editPW1, False
            p_dialogSuccess = 1
            Hide
        Else
            tryAgain "passwordNotIdentical"
        End If
    End If
End Sub

Public Function showForm() As Integer

    With hints
        .SpecialEffect = fmSpecialEffectFlat
        .caption = ""
    End With
    
    editPW1 = ""
    editPW2 = ""
    editPW1.SetFocus
    Show

End Function

Private Sub tryAgain(hintName As String)
    With hints
        .SpecialEffect = fmSpecialEffectSunken
        .caption = " " & userText(hintName)
    End With
    editPW1 = ""
    editPW2 = ""
    editPW1.SetFocus
End Sub


Attribute VB_Name = "dBEXresizeDown"
Attribute VB_Base = "0{D986584F-6403-482F-AA88-CD319DA1347D}{93D90140-81D2-471A-B45E-3924057FE613}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = 1
    buttonCancel.SetFocus
    Hide
End Sub

Private Sub buttonCancel_Click()
    Hide
End Sub

Private Sub buttonOK_Click()
    p_dialogSuccess = 1
    Hide
End Sub

Public Function showForm() As Integer
    optResizeEntireDown = xlOn
    Show
End Function
Attribute VB_Name = "dBEXresizeToRight"
Attribute VB_Base = "0{884EBB8E-84FF-43A9-8BD0-F23B4CAD16C9}{85C31B94-AB22-42E0-B7F9-BBC65433BA6B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = 1
    buttonCancel.SetFocus
    Hide
End Sub

Private Sub buttonCancel_Click()
    Hide
End Sub

Private Sub buttonOK_Click()
    p_dialogSuccess = 1
    Hide
End Sub

Public Function showForm() As Integer
    optResizeEntireToRight = xlOn
    Show
End Function

Attribute VB_Name = "dBEXsave"
Attribute VB_Base = "0{34300ADD-747B-440E-B7D8-90A261BF6024}{C4309046-BCDC-4098-BBC8-42D759A00648}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    ' disable closing the form via the Close command
    If CloseMode = vbFormControlMenu Then Cancel = 1
    buttonCancel.SetFocus
    Hide
End Sub

Private Sub buttonCancel_Click()
    Hide
End Sub

Private Sub buttonOK_Click()
    With editTitle
        If .Text = "" Then
            .SetFocus
        Else
            p_dialogSuccess = 1
            Hide
        End If
    End With
End Sub

Public Sub optionSaveAsNew()
    frameReference.Visible = True
    optRefPrivate = True
End Sub

Public Sub optionSaveExist()
    frameReference.Visible = False
End Sub

Public Function showForm() As Integer
        
    editTitle.Text = ""
    editTitle.SetFocus
    Show

End Function
Attribute VB_Name = "dBEXsettings"
Attribute VB_Base = "0{82EA9D37-AA0B-40EF-9432-6FD383EF0124}{20E9A9A9-4F57-4C0C-ADB1-B430E9A15C86}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit


Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = 1
    buttonCancel.SetFocus
    Hide
End Sub

Private Sub buttonCancel_Click()
    Hide
End Sub

Private Sub buttonOK_Click()
    p_dialogSuccess = 1
    Hide
    applySettings
End Sub

Private Sub buttonAll_Click()

    If userError("confirmSettingsForAll", vbInformation + vbYesNo) = vbNo Then Exit Sub
    
    p_dialogSuccess = 1
    Hide
    
    Dim currentQueryIndex As Integer:   currentQueryIndex = p_currentQueryIndex
    Dim i As Integer
    For i = cRepoRTop To cRepoRTop + p_currentRepoSheet.Cells(cRepoRCounts, cRepoCQ) - 1
        p_currentQueryIndex = i
        applySettings
    Next i
    p_currentQueryIndex = currentQueryIndex

End Sub

Public Function showForm() As Integer
    
    tabProperties.TabIndex = 1
    
    With p_currentRepoSheet
        
        checkShowFormats = repoGetProperty(cPropShowFormats)
        checkNoMultTxt = repoGetProperty(cPropNoMultTxt)
        checkStyles = Not repoGetProperty(cPropNoStyles)
        
        checkStructureFilter = .Cells(p_currentQueryIndex, cRepoCQStructFilter) = True
        checkStructureFilter.Enabled = .Cells(p_currentQueryIndex, cRepoCQDefVersion) >= cV20
        
        If Not repoGetProperty(cPropShowDocLinks) Then                                      ' VBR:06-031
          checkDocLinksData = repoGetProperty(cPropShowDocLinksData)
          checkDocLinksMsd = repoGetProperty(cPropShowDocLinksMsd)
          checkDocLinksMeta = repoGetProperty(cPropShowDocLinksMeta)
          checkDocLinksData.Enabled = .Cells(p_currentQueryIndex, cRepoCQDefVersion) > cV20
          checkDocLinksMsd.Enabled = .Cells(p_currentQueryIndex, cRepoCQDefVersion) > cV20
          checkDocLinksMeta.Enabled = .Cells(p_currentQueryIndex, cRepoCQDefVersion) > cV20
        Else
          checkDocLinksData = True
          checkDocLinksMsd = True
          checkDocLinksMeta = True
          checkDocLinksData.Enabled = .Cells(p_currentQueryIndex, cRepoCQDefVersion) > cV20
          checkDocLinksMsd.Enabled = .Cells(p_currentQueryIndex, cRepoCQDefVersion) > cV20
          checkDocLinksMeta.Enabled = .Cells(p_currentQueryIndex, cRepoCQDefVersion) > cV20
        End If
        checkInteractive = .Cells(p_currentQueryIndex, cRepoCQInteractive) = True
        checkSaveVars = .Cells(p_currentQueryIndex, cRepoCQReuseVars) = True
        checkRefreshOnOpen = .Cells(p_currentQueryIndex, cRepoCQRefreshOnOpen) = True
        checkRefreshToGlobal = .Cells(p_currentQueryIndex, cRepoCQRefreshToGlobal) = True
        
        Select Case .Cells(p_currentQueryIndex, cRepoCQAdjustColumns)
            Case 0: optAdjustNo = True
            Case 1: optAdjustArea = True
            Case 2: optAdjustColumns = True
        End Select
        
        editQIDlocal.Text = .Cells(p_currentQueryIndex, cRepoCQPrefix)
        editQIDglobal.Text = .Cells(p_currentQueryIndex, cRepoCQID)
        editWBID.Text = storageGetWBID(ActiveWorkbook)
        editSysID.Text = IIf(isTransient, "?", storageGetSysID(ActiveWorkbook))
    
        buttonAll.Enabled = .Cells(cRepoRCounts, cRepoCQ) > 1
    
    End With
    
    Show

End Function

Private Sub applySettings()
        
    With p_currentRepoSheet
        
        .Cells(p_currentQueryIndex, cRepoCQStyles) = checkStyles ' store flag redundant for easier access
        .Cells(p_currentQueryIndex, cRepoCQStructFilter) = checkStructureFilter

        .Cells(p_currentQueryIndex, cRepoCQInteractive) = checkInteractive
        .Cells(p_currentQueryIndex, cRepoCQReuseVars) = checkSaveVars
        .Cells(p_currentQueryIndex, cRepoCQRefreshOnOpen) = checkRefreshOnOpen
        .Cells(p_currentQueryIndex, cRepoCQRefreshToGlobal) = checkRefreshToGlobal
        
        .Cells(p_currentQueryIndex, cRepoCQAdjustColumns) = Switch(optAdjustNo, 0, optAdjustArea, 1, optAdjustColumns, 2)
    
            Dim i As Long
            For i = cRepoRTop To cRepoRTop + .Cells(cRepoRCounts, cRepoCD) - 1
                If .Cells(i, cRepoCD) = p_currentQueryIndex And Len(.Cells(i, cRepoCDIsStructure)) Then
                    If checkStructureFilter Then
                        p_currentFilterIndex = i
                        displayFilter
                    Else
                        RunClearRange RunGetFilterRange(i)
                    End If
                End If
            Next i
    
    End With
    
    If repoSetPropertyBoolean(cPropShowFormats, checkShowFormats.Value) Or _
       repoSetPropertyBoolean(cPropNoMultTxt, checkNoMultTxt.Value) Or _
       repoSetPropertyBoolean(cPropNoStyles, Not checkStyles.Value) Or _
       repoSetPropertyBoolean(cPropShowDocLinks, False) Or _
       repoSetPropertyBoolean(cPropShowDocLinksData, checkDocLinksData) Or _
       repoSetPropertyBoolean(cPropShowDocLinksMsd, checkDocLinksMsd) Or _
       repoSetPropertyBoolean(cPropShowDocLinksMeta, checkDocLinksMeta) _
       Then RunQueryConditioned True, True
End Sub
Attribute VB_Name = "dBEXview"
Attribute VB_Base = "0{86E43D3C-360A-457B-AC80-64F4070851D8}{4207ABC0-511D-4281-969C-984FF1803DFD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    ' disable closing the form via the Close command
    If CloseMode = vbFormControlMenu Then Cancel = 1
    buttonCancel.SetFocus
    Hide
End Sub

Private Sub buttonCancel_Click()
    Hide
End Sub

Private Sub buttonOK_Click()

    With editTechName
        If Len(.Text) Then
            If viewNameOK(.Text) Then
                .Text = translate(UCase(.Text), " ", "_")
                p_dialogSuccess = 1
                Hide
                Exit Sub
            End If
        End If
        .SetFocus
    End With
    
End Sub

Public Sub reset()
    editTitle.Text = ""
    editTechName.Text = ""
End Sub

Public Function showForm() As Integer
    editTitle.SetFocus
    Show
End Function

Attribute VB_Name = "language"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True




































Attribute VB_Name = "tables"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True





































Attribute VB_Name = "xBEXapi"
Option Explicit
' This module is the only one which is not declared "Option Private Module".
' It is supposed to contain all the routines which have to be accessible outside the project.

Private g_SAPBEXgetFilterValue_IntValue As String
Private g_SAPBEXgetFilterValue_HierValue As String
Private g_SAPBEXgetDrillState_CurrentState As Integer
Private g_SAPBEXgetResultRange_ResultArea As Range

Private g_screenUpdating As Boolean ' Excel bug: screenUpdating needs to be restored explicitly for external calls

'----- unpublished API for launching the Analyzer from SAPGUI and/or the Browser

Sub sapBEXinit()
    Auto_open
End Sub

Sub sapBEXmaintainToolbar()
    maintainToolbar
End Sub

Sub sapBEXdisable(wb As Workbook)
    shapesDisable wb
End Sub

Sub sapBEXnewQuery(queryID As String)
    extErrorBegin "new query"
    queryEmbed False, False, queryID
    extErrorEnd
End Sub

Sub sapBEXawake()
    Application.Interactive = True
    ' floating commandbars are visible again
    Dim myBar As CommandBar
    For Each myBar In Application.CommandBars
        If myBar.Position = msoBarFloating Then myBar.Visible = True
    Next myBar

    userStatusBar ""
End Sub

Function sapBEXinitConnection(Optional newConnectionObj As Object) As Boolean
    extErrorBegin "init Connection"
    If Not newConnectionObj Is Nothing Then Set p_connectionObj = newConnectionObj
    sapBEXinitConnection = initConnection
    extErrorEnd
End Function

Function sapBEXgetConnection(Optional what As Integer) As Variant
    
    extErrorBegin "get connection"
    Select Case what
    Case 0
        If p_connectionObj Is Nothing Then If Not prepareConnection Then Exit Function
        Set sapBEXgetConnection = p_connectionObj
    Case 1
        sapBEXgetConnection = dialinGetUser
    Case 2
        sapBEXgetConnection = dialinGetSysNumber
    Case 3
        sapBEXgetConnection = dialinGetAppServer
    End Select
    extErrorEnd
    
End Function

Function sapBEXrefreshFromMap(queryID As String, showResults As Boolean) As Integer
    
    g_screenUpdating = Application.ScreenUpdating
    screenHalt
    ActiveCell.activate ' steal focus from calling control
    On Error GoTo leave
    
    sapBEXrefreshFromMap = 1
    
    Dim moSheet As Worksheet:   Set moSheet = ActiveSheet
    
    Dim repoSheet As Worksheet: Set repoSheet = repoGetRepoSheet(ActiveWorkbook, False)
    If repoSheet Is Nothing Then GoTo leave
    
    Dim resultRange As Range:   Set resultRange = repoSheet.names(CStr(queryID)).RefersToRange
    If resultRange Is Nothing Then GoTo leave

    sapBEXrefreshFromMap = 2

    If Not repoDetectQuery(resultRange, cRangeResult) Then GoTo leave

    sapBEXrefreshFromMap = 3

    Dim myGISIndex As Integer:  myGISIndex = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQGISIndex)
    If myGISIndex = 0 Then GoTo leave
    
    Dim mo As Object:           Set mo = gisFind(myGISIndex)
    If mo Is Nothing Then GoTo leave
    
    sapBEXrefreshFromMap = 4
    
    If RunQuery(True, mo, Not showResults) Then sapBEXrefreshFromMap = 0
    
    #If GISFloat Then
        mo.ShowBExMap
    #Else
        moSheet.activate
    #End If
    
leave:
    screenRestore
    Application.ScreenUpdating = g_screenUpdating

End Function

Function sapBEXcommandFromMap(queryID As String, fCode As String, iobjnm As String, row As Long, column As Long) As Integer
    
    ActiveCell.activate ' steal focus from calling control
    g_screenUpdating = Application.ScreenUpdating
    On Error GoTo leave
    
    sapBEXcommandFromMap = 1
        
    Dim repoSheet As Worksheet
    Set repoSheet = repoGetRepoSheet(ActiveWorkbook, False)
    If repoSheet Is Nothing Then Exit Function
    
    Dim resultRange As Range
    Set resultRange = repoSheet.names(CStr(queryID)).RefersToRange
    If resultRange Is Nothing Then Exit Function

    sapBEXcommandFromMap = 2
    
    If Not repoDetectQuery(resultRange.Cells(row, column), cRangeResult) Then Exit Function

    sapBEXcommandFromMap = 4
    
    If contextSetSelection Then If contextSAP(fCode, iobjnm) Then sapBEXcommandFromMap = 0

leave:
    Application.ScreenUpdating = g_screenUpdating

End Function

Sub sapBEXattachGIS(Optional refreshOnly As Boolean)
    If repoDetectQuery(ActiveCell) Then
        attachGIS refreshOnly
    Else
        MsgBox "creating GIS object failed, no query detected at active cell"
    End If
End Sub

' Called when the BEx Analyzer is launched from the BEx Browser or sapgui
Sub sapBEXsetBrowserGuiCall(callByBrowserOrGui As Boolean)
    p_callByBrowserGui = callByBrowserOrGui
End Sub

'----- published API for external, user-defined VBA-programs

Sub SAPBEXpauseOn()
    If Not checkPause Then togglePause
End Sub

Sub SAPBEXpauseOff()
    If checkPause Then togglePause
End Sub

Private Sub extErrorBegin(callerText As String)
    p_extErrorFlag = Not p_callByBrowserGui     ' To differentiate between BEx API calls and the API call made by the BEx Browser/sapgui =>
                                                ' Suppress error msg when called from the VBA API
    p_extErrorCount = 0
    p_extErrorText = ""
    trace True, "[ " & callerText
    g_screenUpdating = Application.ScreenUpdating
    Application.ScreenUpdating = False
End Sub

Private Sub extErrorEnd()
    p_extErrorFlag = False
    trace True, "]"
    ' BUGFIX : Screen Flicker problem when calling APIs
    If Not RegistryGet("", "ScreenUpdate") = "DISABLE" Then
        Application.ScreenUpdating = True
    End If
End Sub

Function SAPBEXgetErrorText() As String
    SAPBEXgetErrorText = p_extErrorText
End Function

Function SAPBEXsetVariables(varValues As Range) As Integer

    extErrorBegin "set variables"

    If tableReset("C_T_VARIABLES") Then
        Dim varTable As Object
        Set varTable = p_tables("C_T_VARIABLES")
        If varTable.Columns.Count < varValues.Columns.Count Then
            SAPBEXsetVariables = -1
        Else
            With varValues
                Dim i As Integer
                For i = 1 To .Rows.Count
                    Dim rowVars As Object
                    Set rowVars = varTable.Rows.Add
                    Dim j As Integer
                    For j = 1 To .Columns.Count
                        If .Cells(i, j) <> "" Then rowVars.Value(j) = .Cells(i, j)
                    Next j
                Next i
            End With
            trace True, "receiving external variable values"
            p_varValuesPending = True
            SAPBEXsetVariables = 0
        End If
    Else
        SAPBEXsetVariables = p_extErrorCount
        Exit Function
    End If
    
exitSub:
    extErrorEnd

End Function

Function SAPBEXrefresh(allQueries As Boolean, Optional atCell As Range, Optional iShowScreen As Boolean) As Integer 'VBR:06-033
    
    extErrorBegin IIf(allQueries, "refresh all", "refresh single")
    SAPBEXrefresh = -1

    On Error GoTo noActiveCell
    If allQueries Then
        Dim myActiveWorkbook As Workbook
        Set myActiveWorkbook = Application.ActiveWorkbook
        On Error GoTo 0
        Call RunQueriesInWorkbook(cWb:=myActiveWorkbook, iShowScreen:=iShowScreen)   'VBR:07-036
        SAPBEXrefresh = p_extErrorCount
    Else
        If atCell Is Nothing Then Set atCell = Application.ActiveCell
        If repoDetectQuery(atCell) Then
            On Error GoTo 0
            Call RunQuery(iShowScreen:=iShowScreen)                                  'VBR:06-033
            SAPBEXrefresh = p_extErrorCount
        End If
    End If

noActiveCell:
    extErrorEnd

End Function

Function SAPBEXsetDrillState(newState As Integer, Optional atCell As Range) As Integer
    
    extErrorBegin "set drill"
    SAPBEXsetDrillState = -1
    
    On Error GoTo noActiveCell
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell, cRangeFilter) Then
        On Error GoTo 0
        Select Case newState
        Case 0: If drillState <> 0 Then contextHandlerUndrill
        Case 1: If drillState <= 0 Then contextHandlerDrillDown True
        Case 2: If drillState >= 0 Then contextHandlerDrillAcross True
        End Select
        SAPBEXsetDrillState = p_extErrorCount
    End If

noActiveCell:
    extErrorEnd

End Function

Function SAPBEXgetDrillState_CurrentState() As Integer: SAPBEXgetDrillState_CurrentState = g_SAPBEXgetDrillState_CurrentState: End Function

Function SAPBEXgetDrillState(currentState As Integer, Optional atCell As Range) As Integer
    
    extErrorBegin "get drill"
    SAPBEXgetDrillState = -1
    
    On Error GoTo noActiveCell
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell, cRangeFilter) Then
        On Error GoTo 0
        currentState = Choose(Sgn(drillState) + 2, 2, 0, 1)
        g_SAPBEXgetDrillState_CurrentState = currentState
        SAPBEXgetDrillState = p_extErrorCount
    End If

noActiveCell:
    extErrorEnd

End Function

Function SAPBEXsetFilterValue(intValue As String, Optional hierValue As String, Optional atCell As Range) As Integer
    
    extErrorBegin "set filter"
    SAPBEXsetFilterValue = -1
    
On Error GoTo noActiveCell
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell, cRangeFilter) Then
        On Error GoTo 0
        contextSetFilter intValue, "", "", hierValue, True
        SAPBEXsetFilterValue = p_extErrorCount
    End If
    
noActiveCell:
    extErrorEnd

End Function

Function SAPBEXgetFilterValue_IntValue() As String: SAPBEXgetFilterValue_IntValue = g_SAPBEXgetFilterValue_IntValue: End Function
Function SAPBEXgetFilterValue_HierValue() As String: SAPBEXgetFilterValue_HierValue = g_SAPBEXgetFilterValue_HierValue: End Function

Function SAPBEXgetFilterValue(intValue As String, hierValue As String, Optional atCell As Range) As Integer
    
    extErrorBegin "get filter"
    SAPBEXgetFilterValue = -1
    
    On Error GoTo noActiveCell
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell, cRangeFilter) Then
        On Error GoTo 0
        contextGetFilterValue intValue, hierValue
        g_SAPBEXgetFilterValue_IntValue = intValue
        g_SAPBEXgetFilterValue_HierValue = hierValue
        SAPBEXgetFilterValue = p_extErrorCount
    End If
    
noActiveCell:
    extErrorEnd

End Function

Function SAPBEXcopyFilterValue(fromCell As Range, Optional atCell As Range) As Integer
    
    extErrorBegin "copy filter"
    SAPBEXcopyFilterValue = -1
    
    If repoDetectQuery(fromCell, cRangeFilter) Then
        Dim fromCharName As String: fromCharName = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName)
        Dim fromQuery As Long:      fromQuery = p_currentQueryIndex
        On Error GoTo noActiveCell
        If atCell Is Nothing Then Set atCell = Application.ActiveCell
        On Error GoTo 0
        If fromCell.Worksheet.Parent Is atCell.Worksheet.Parent Then
            If repoDetectQuery(atCell, cRangeFilter) Then
                If fromCharName = p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName) Then
                    ConFac2ConFacCopy fromQuery, fromCharName
                    RunQueryConditioned
                    SAPBEXcopyFilterValue = p_extErrorCount
                End If
            End If
        End If
    End If
    
noActiveCell:
    extErrorEnd

End Function

Function SAPBEXfireCommand(fCode As String, Optional atCell As Range) As Integer
    
    extErrorBegin "command"
    SAPBEXfireCommand = -1
    
    On Error GoTo contextError
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell) Then
        On Error GoTo 0
        If isConnected(True) Then
            
            If contextSetSelection Then
                If p_currentFilterIndex Then
                    contextSAP fCode, p_currentRepoSheet.Cells(p_currentFilterIndex, cRepoCDCharName)
                Else
                    contextSAP fCode
                End If
            End If
            SAPBEXfireCommand = p_extErrorCount
        
        End If
    End If

contextError:
    extErrorEnd

End Function

Function SAPBEXcheckContext(fCode As String, Optional atCell As Range) As Integer
    
    extErrorBegin "command check"
    SAPBEXcheckContext = -1
    
    On Error GoTo contextError
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell) Then
        On Error GoTo 0
        If p_currentFilterIndex = 0 And isConnected(True) Then
            
            If fCode <> "BACK" And fCode <> "STRT" Then
                If contextSetSelection Then ' p_tables("I_T_RANGES") is filled
                    If rfcGetContextMenu(p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQHandle)) Then  ' p_tables("E_T_MENU") is filled
                        Dim rowMenu As Object
                        For Each rowMenu In p_tables("E_T_MENU").Rows
                            If rowMenu("CMDID") = fCode Then GoTo leaveOK
                        Next rowMenu
                    End If
                    GoTo contextError
                End If
            End If
leaveOK:    SAPBEXcheckContext = p_extErrorCount
        
        End If
    End If
    
contextError:
    extErrorEnd

End Function

Function SAPBEXshowTextElements(Optional selectGroup As String, Optional atCell As Range) As Integer
    
    extErrorBegin "show text elements"
    SAPBEXshowTextElements = -1
    
    On Error GoTo contextError
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell) Then
        On Error GoTo 0
        If isConnected(True) Then
            If Len(selectGroup) = 0 Then selectGroup = "*"
            RunProcessTextElements selectGroup
            SAPBEXshowTextElements = p_extErrorCount
        End If
    End If
    
contextError:
    extErrorEnd

End Function

Function SAPBEXjumpInitial(queryID As String, jumpType As String, jumpTarget As String) As String

    extErrorBegin "jump initial"
    On Error GoTo leave
    
    Dim jumpTypeInt As Long
    Select Case jumpType
    Case cJumpExtView:     jumpTypeInt = cJumpView
    Case cJumpExtRepRep:   jumpTypeInt = cJumpRepRep
    Case Else:  GoTo leave
    End Select
    
    If queryJump(jumpTypeInt, jumpTarget, True, queryID) Then SAPBEXjumpInitial = ActiveWorkbook.Name
leave:
    extErrorEnd

End Function

Function SAPBEXjump(jumpType As String, jumpTarget As String, Optional atCell As Range) As Integer
    
    extErrorBegin "jump"
    SAPBEXjump = -1
    
    On Error GoTo contextError
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell) Then
        On Error GoTo 0
        Select Case jumpType
        Case cJumpExtView
            queryJump cJumpView, jumpTarget
        Case cJumpExtRepRep
            If isConnected(True) Then
                queryJump cJumpRepRep, jumpTarget
            End If
        Case Else
            GoTo contextError
        End Select
        SAPBEXjump = p_extErrorCount
    End If
    
contextError:
    extErrorEnd

End Function

Function SAPBEXgetResultRange_ResultArea() As Range: Set SAPBEXgetResultRange_ResultArea = g_SAPBEXgetResultRange_ResultArea: End Function

Function SAPBEXgetResultRange(ByRef resultArea As Range, dataOnly As Boolean, Optional atCell As Range) As Boolean

    extErrorBegin "get result range"
    SAPBEXgetResultRange = -1
    
    On Error GoTo noActiveCell
    If atCell Is Nothing Then Set atCell = Application.ActiveCell
    If repoDetectQuery(atCell) Then
        On Error GoTo 0
        If p_currentFilterIndex = 0 Then
            Set resultArea = RunGetResultRange(p_currentQueryIndex)
            If dataOnly Then
                Dim rowAnchor As Long: rowAnchor = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQYData) - 1
                Dim colAnchor As Long: colAnchor = p_currentRepoSheet.Cells(p_currentQueryIndex, cRepoCQXData) - 1
                If rowAnchor >= 0 And resultArea.Rows.Count > rowAnchor And _
                   colAnchor >= 0 And resultArea.Columns.Count > colAnchor Then
                    Set resultArea = resultArea _
                        .Offset(rowAnchor, colAnchor) _
                        .Resize(resultArea.Rows.Count - rowAnchor, resultArea.Columns.Count - colAnchor)
                End If
                Set g_SAPBEXgetResultRange_ResultArea = resultArea
            End If
            SAPBEXgetResultRange = p_extErrorCount
        End If
    
    End If
    
noActiveCell:
    extErrorEnd

End Function

Function SAPBEXgetResultRangeByID(ByVal queryID As String, Optional ByVal charName As String) As Range
    
    extErrorBegin "get result range by ID"
    Set SAPBEXgetResultRangeByID = Nothing
    If Len(charName) Then charName = cRangeFilter & charName
    On Error GoTo leave
    Set SAPBEXgetResultRangeByID = repoGetRepoSheet(ActiveWorkbook, False).names(queryID & charName).RefersToRange

leave:
    extErrorEnd

End Function

Function SAPBEXsaveWorkbook(Optional wbName As String) As Integer

    extErrorBegin "save"
    SAPBEXsaveWorkbook = -1
    
    On Error GoTo contextError
    If Len(wbName) = 0 Then wbName = ActiveWorkbook.Name
    storageWrite Application.Workbooks(wbName), True, True, " ", ""
    SAPBEXsaveWorkbook = p_extErrorCount
    
contextError:
    extErrorEnd

End Function

Function SAPBEXreadWorkbook(wbID As String) As String

    extErrorBegin "read"
    SAPBEXreadWorkbook = ""
    
    trace False, "SAPBEXreadWorkbook start 0"
    isConnected
    trace False, "SAPBEXreadWorkbook start 1"
    
    Dim wb As Workbook
    If storageRead(wbID, wb) Then If Not wb Is Nothing Then SAPBEXreadWorkbook = wb.Name
    
    trace False, "SAPBEXreadWorkbook end 0"
    isConnected
    trace False, "SAPBEXreadWorkbook end 1"
    
    extErrorEnd
    
    Application.ScreenUpdating = True           ' 3020.6.608 TK enable screen updating after workbook is opened from BEx Browser (see CM 074984 2003)
End Function

Function SAPBEXgetWorkbookID(wbName As String) As String

    extErrorBegin "get WBID"
    On Error GoTo leave
    SAPBEXgetWorkbookID = storageGetWBID(Application.Workbooks(wbName))
leave:
    extErrorEnd
    
End Function

Function SAPBEXembedQuery(genUID As String, Optional atActiveCell As Boolean) As String
    
    extErrorBegin "embed"
    On Error GoTo leave
    SAPBEXembedQuery = queryEmbed(atActiveCell, False, genUID)
leave:
    extErrorEnd

End Function

Sub SAPBEXunattended()
    ' suppress all logon dialogs (note: error dialogs are suppressed anyway during API-calls!)
    dialInPause aHundredYears:=True
End Sub

Sub SAPBEXtoolbar()
    CommandBars(cProductName).Controls(1).SetFocus
End Sub

Public Function SAPBEXProtect(sh As Worksheet) As Boolean
SAPBEXProtect = SAPprotect(sh)
End Function

Attribute VB_Name = "xBEXinspect"
Option Explicit

Sub sapbexDebugPrint()

    Dim wbOut As Workbook
    Set wbOut = Workbooks.Add
    wbOut.Windows(1).caption = "SAPBEX Status at " & Now

    Dim i As Integer

    Dim wb As Workbook
    For Each wb In Workbooks
        If Not wb Is wbOut Then
            With wbOut.Worksheets.Add
                i = 1
                Dim nm As Name
                For Each nm In wb.names
                    .Cells(i, 1) = nm.Name
                    .Cells(i, 2) = "'" & nm.RefersTo
                    i = i + 1
                Next nm
                .Columns.autoFit
                .Name = "names in """ & IIf(Len(wb.Name) > 20, Left(wb.Name, 15) & "..." & i, wb.Name) & """"
            End With
        End If
    Next wb

    Dim myTable As Object
    If p_tables Is Nothing Then Exit Sub
    For Each myTable In p_tables
            With wbOut.Worksheets.Add
                If myTable.Rows.Count = 0 Then
                    .Cells(1, 1) = "empty"
                Else
                    i = 1
                    For i = 1 To myTable.Columns.Count
                        .Cells(1, i) = myTable.Columns(i).Name
                    Next i
                    .Rows(1).Font.Bold = True
                    .Cells(2, 1).Resize(myTable.Rows.Count, myTable.Columns.Count).Value = myTable.data
                End If
                .Columns.autoFit
                .Name = myTable.Name
            End With
    Next myTable

End Sub

'----- helpers & tools

'Output of a table to Debug-Window
Public Sub TableOutput(itTable As Object)
 
  Dim lRow  As Object
  Dim lColumn  As Object
  Dim lCell As Variant
  Dim lOutput As String
  Dim lColLen As Long
 
  Debug.Print "TABLE: "; itTable.rfcparameter.Name
  For Each lColumn In itTable.Columns
    lColLen = lColumn.IntLength
    If lColumn.Type = 2 Then
      lColLen = lColLen * 2
    End If
    lOutput = Space(Maximum(Len(lColumn.Name), lColLen) + 1)
    Mid(lOutput, 1) = lColumn.Name
    Debug.Print lOutput;
  Next
  For Each lRow In itTable.Rows
    Debug.Print
    For Each lColumn In itTable.Columns
      lCell = itTable.Value(lRow.Index, lColumn.Index)
      lColLen = lColumn.IntLength
      If lColumn.Type = 2 Then
        lColLen = lColLen * 2
      End If
      lOutput = Space(Maximum(Len(lColumn.Name), lColLen) + 1)
      Mid(lOutput, 1) = lCell
      Debug.Print lOutput;
    Next
  Next
  Debug.Print
  Debug.Print
 
End Sub

'Output of a Tables Collection to Debug
Public Sub TablesOutput(iTables As Object)
 
  Dim ltTable As Object
 
  For Each ltTable In iTables
    Call TableOutput(ltTable)
  Next
 
End Sub

'write a table to a file in R/3-COMPONENT_EXPORT-Format
Public Sub TableToFile(iFileName As String, itTable As Object)
  Rem *** FailSafe SKIP
 
  Dim lColumn    As Object
  Dim lLine      As Long
  Dim lItem      As Long
  
  'open R/3 Table file
  Open iFileName For Output As #1
 
  'write table header
  Print #1, "=*-*-*-*="; vbTab; itTable.Name; vbTab; itTable.rfcparameter.Name; vbTab; _
            Format(itTable.rfcparameter.rowlength, "0000"); vbTab; _
            Format(itTable.Columns.Count, "0000")
  'write type info
  For Each lColumn In itTable.Columns
    Print #1, Format(lColumn.Type, "0000"); vbTab;
  Next
  Print #1, ""
  'write len info
  For Each lColumn In itTable.Columns
    Print #1, Format(lColumn.IntLength, "0000"); vbTab;
  Next
  Print #1, ""
  'write name info
  For Each lColumn In itTable.Columns
    Print #1, lColumn.Name; vbTab;
  Next
  Print #1, ""
  'write table content
  For lLine = 1 To itTable.Rows.Count
    For lItem = 1 To itTable.Columns.Count
      Print #1, itTable(lLine, lItem); vbTab;
    Next
    Print #1, ""
  Next
  
  'special for empty tables
  If itTable.Rows.Count = 0 Then
    Print #1, ""
  End If
  
  'cleanup
Cleanup:
  Close #1
 
End Sub

'write a complete tables collection to Files in the given Path
Public Sub TablesToFile(iPath As String, itTables As Object)
  Rem *** FailSafe SKIP

  Dim lTable As Object
  
  For Each lTable In itTables
    Call TableToFile(iPath + lTable.Name + ".txt", lTable)
  Next
  
End Sub

Private Function Maximum(x As Long, y As Long) As Long
  Maximum = IIf(x < y, y, x)
End Function
'Output of a table to HTML
Public Sub Table2HTML( _
                  ByVal itTable As Object, _
         Optional ByVal iInclCounter As Boolean = False)
  Rem *** FailSafe SKIP
Dim lRow            As Object
Dim lColumn         As Object
Dim lCell           As Variant
Dim lOutput         As String
Dim lColLen         As Long
Dim lFileNo         As Long
Dim lFileName       As String
Dim ltTable         As Object

  If itTable Is Nothing Then
    Debug.Print "Table(s) is NOTHING!"
  Else
  
    lFileName = Application.Path & "\Export.html"
    lFileNo = FreeFile
    On Error Resume Next
    Open Application.Path & "\Export.html" For Output As #lFileNo
    If Err.Number <> 0 Then
      Debug.Print Err.Description
      Debug.Assert False            'Steady Breakpoint
    End If
    On Error GoTo 0
    
    Print #lFileNo, "<HTML>"
    Print #lFileNo, "<HEAD>"
        
    'CSS Style Sheet
    Print #lFileNo, "<STYLE TYPE=""Text/css"">"
    Print #lFileNo, "<!--"
    Print #lFileNo, "TABLE {font-family: Verdana; font-size: 8pt;}"
    Print #lFileNo, "TH {background: #EEEEEE; color: #336699;}"
    Print #lFileNo, "-->"
    Print #lFileNo, "</STYLE>"
        
    Print #lFileNo, "</HEAD>"
    Print #lFileNo, "<BODY><font size='1' face='Verdana'>"
    
    If TypeName(itTable) = "CSAPTaFacTables" Then
    'If TypeOf itTable Is Collection Then
      For Each ltTable In itTable
        Print #lFileNo, Table2HTML_int(ltTable, iInclCounter)   'Convert SAPTable to HTML
        Print #lFileNo, "<br><br>"
      Next
    Else
      Print #lFileNo, Table2HTML_int(itTable, iInclCounter)   'Convert SAPTable to HTML
    End If
    Print #lFileNo, "<br>" & Format(Now, "dd.mm.yyyy hh:mm.ss") & "</font>"
        
    Print #lFileNo, "</font></BODY>"
    Print #lFileNo, "</HTML>"
    Close #lFileNo
    
    'Open HTML-File
    lFileName = Replace(lFileName, "'", "\""")
    lFileName = Trim(lFileName)
    lFileName = "cmd /c " & """" & lFileName & """"
    On Error Resume Next: Call Shell(lFileName, vbHide): On Error GoTo 0
  End If
End Sub
Private Function Table2HTML_int(ByVal itTable As Object, ByVal iInclCounter As Boolean) As String
Dim lHeader         As String
Dim lHTML           As String
Dim lRow            As Object
Dim lColumn         As Object
Dim lCell           As Variant
Dim lTmp            As String
Dim lCounter        As Long

  lHTML = itTable.rfcparameter.Name & "<br>"
  
  'HTML TableHeader
  lHTML = lHTML & "<TABLE CELLPADDING=0 CELLSPACING=0 BORDER=1>" & vbCrLf
  
  lHeader = "<TR><TH nowrap>"
  If iInclCounter Then lHeader = lHeader & "#" & "</TH><TH nowrap>" 'JP30B19-574
  For Each lColumn In itTable.Columns
    lHeader = lHeader & lColumn.Name & "</TH><TH nowrap>"
  Next
  lHeader = Left(lHeader, Len(lHeader) - 16) & "</TH></TR>" & vbCrLf
  lHTML = lHTML & lHeader
    
  For Each lRow In itTable.Rows
    lTmp = lTmp & "<TR>"
    If iInclCounter Then                                'JP30B19-574
      lCounter = lCounter + 1                           'JP30B19-574
      lTmp = lTmp & "<TD nowrap>" & lCounter & "</TD>"  'JP30B19-574
    End If                                              'JP30B19-574
    For Each lColumn In itTable.Columns
      lCell = itTable.Value(lRow.Index, lColumn.Index)
      If CStr(lCell) = "" Then lTmp = lTmp & "<TD nowrap>" & "&nbsp;" & "</TD>" _
                          Else lTmp = lTmp & "<TD nowrap>" & CStr(lCell) & "</TD>"
    Next
    lTmp = lTmp & "</TR>" & vbCrLf
  Next
    
  lHTML = lHTML & lTmp & vbCrLf & "</TABLE>"  'HTML Tabellenfu|fffd| generieren
  Table2HTML_int = lHTML
End Function



' InQuest injected base64 decoded content
' YGjwez
' j{%j
' Gjwez
' Gjwez
' Gjwez
' Gjwez
' Gjwez
' jZ >
' x)br
' [Qjx

INQUEST-PP=macro
