Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'---------------------------------------------------------------------------------------
' Procedure : Workbook_Open
' Author    : GDV_Raddatz
' Date      : 11.12.2013
' Purpose   :
'---------------------------------------------------------------------------------------
'
Private Sub Workbook_Open()

   On Error GoTo Workbook_Open_Error

    If ThisWorkbook.Worksheets.Count = 1 Then
        ThisWorkbook.Worksheets("Kontrollblatt").Cells.Clear ' Kontrollblatt glatt machen
        usf1.Show
    Else
        ' nix machen
    End If

   On Error GoTo 0
   Exit Sub

Workbook_Open_Error:
    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure Workbook_Open of VBA Dokument DieseArbeitsmappe", vbCritical, "Workbook_Open()"
 
End Sub
Attribute VB_Name = "Modul1"
Option Explicit
'---------------------------------------------------------------------------------------
' Module    : Modul1
' Author    : GDV_ITE (AE, QS)
' Date      : 11.12.2013
' Purpose   : Erstellen einer Statistik (Pivot) |fffd|ber die Protokolleintr|fffd|ge der Frageb|fffd|gen (IT-Erhebung)
'---------------------------------------------------------------------------------------

Sub start1()

    On Error GoTo fehlerbehandlung
    
    Dim meinExcel As Excel.Application
    Dim meineWorkbooks As Excel.Workbooks
    Dim meineKontrollDatei As Excel.Workbook
    Dim meinKontrollBlatt As Excel.Worksheet
    Dim t As Excel.Worksheet
    Dim res As String
    Dim tf As Variant
    Dim sDialogTitle As String
    Dim sInitDir As String
    Dim sFilter As String
    Dim bMulti As Boolean
    Dim datStart As Date
    Dim datEnde As Date
    Dim laufzeit As String
    Dim AnzahlAusgew|fffd|hlterDateien As Integer
    Dim anzahlAbgewiesenDateien As Integer
    Dim AnzahlAusgeschlossenerDateien As Long
    Dim rkl_grenzen(3) As Double
    Dim bbe_zeile As Integer
    Dim sPraefix As String
    Dim AnzahlZeilenAufBlattFelder As Long
    Dim AnzahlSpaltenAufBlattFelder As Long
    Dim spaltenpos As Integer
    Dim startzeile As Long
    Dim BlattName As String
    Dim sParameter As String
    Dim ws As Worksheet
    Dim i As Integer
    Dim i1 As Integer
    Dim r As Range
    Dim strWert As String
    Dim WB As Workbook
    Dim xlsDatei As String, OldFile As String, xlsxDatei As String
    Dim strFind As String
    Dim rngFind As Range
'
'---------------------------------------- Initialisierung ------------------------------------------------------------------------
'
    datStart = Now()

    Set meinExcel = Application 'Excel-Anwendung
    Set meineWorkbooks = meinExcel.Workbooks
    Set meineKontrollDatei = meinExcel.ActiveWorkbook
                 
    If Dir(meineKontrollDatei.Path & "\Err_dokumente", vbDirectory) = "" Then
       MkDir (meineKontrollDatei.Path & "\Err_dokumente")
    End If
    
    Dim DateiName, DateinameOhneExtension As String
    
    DateiName = meineKontrollDatei.Name
    DateinameOhneExtension = Left(DateiName, InStrRev(DateiName, ".") - 1)
    '
    '
    '---------------------------------------------------
    'alle Bl|fffd|tter l|fffd|schen, au|fffd|er Blatt 1 (Kontrollblatt)
    '---------------------------------------------------
    '
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    For i = Worksheets.Count To 2 Step -1               'durchlauf aller Tabellen in Dokument
        If Not Worksheets(i).Name = "Kontrollblatt" Then
            Worksheets(i).Delete
        End If
    Next
    '
    '
    sInitDir = ThisWorkbook.Path
    sDialogTitle = "ErrorStat - ITE"
    '---Filter setzen
    sFilter = "Alle Excel-Dateien (*.xls,*.xlsx,*.xlsm)|*.xls,*.xlsx,*.xlsm;Alle Dateien (*.*)|*.*"
    bMulti = True
    '
    '---------------------------
    'Dateiauswahlliste erstellen
    '---------------------------
    '
    res = DateienListe(sInitDir, sDialogTitle, sFilter, bMulti)
    If res <> "" Then
        tf = Split(res, Chr(9))
        AnzahlAusgew|fffd|hlterDateien = UBound(tf) + 1
    End If
    '
    '
    ' Es werden zun|fffd|chst alle Frageb|fffd|gen eingelesen und der Inhalt aus dem Blatt Protokoll in das aktuelle Workbook, Blatt VUNR pro VU |fffd|bertragen:

    If FrageboegenInsKontrollblattUebertragen(meineKontrollDatei, AnzahlAusgew|fffd|hlterDateien, tf) = True Then
        'MsgBox "bis hier hin: alles okay"
        '
        '-------------------------------------------------------
        'alle Bl|fffd|tter auslesen und in ein Gesamtblatt |fffd|bertragen
        '-------------------------------------------------------
        '
        Worksheets.Add After:=Worksheets(1)
        ActiveSheet.Name = "VUGesamt"
        '
        '
        Dim Zeile As Integer, zeilenspeicher As Integer    'variabele zum zeilenz|fffd|hlen und zeile speicher
        Dim MeineZeile As Long
        Dim ZeilenAnzahlDesAktuellenBlatts As Long
        Dim Bereich As Range
        Dim Zelle As Range
            
        Zeile = 1                   'Setzen der ersten Zeile auf 1
        For Each t In Sheets        'durchlauf aller Tabellen in Dokument
            If Not (t.Name = "VUGesamt" Or t.Name = "Kontrollblatt") Then
                t.Activate
                'Pr|fffd|fen, ob die Funktion "Protokoll estellen" aufgerufen wurde:
                'Hintergrund: Wenn das Blatt "Protokoll" leer ist, kann es ja sein, dass kein Protokoll erstellt wurde!
                With t
                    strFind = "Ende des Protokolls"
                    Set rngFind = .Columns("C").Find(What:=strFind, After:=Columns("C").Cells(1), LookIn:=xlValues, _
                                LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, _
                                MatchCase:=False)
                
                    If rngFind Is Nothing Then
                        If WorksheetExists("Ausschluss") = False Then
                            Worksheets.Add After:=Worksheets(1)
                            ActiveSheet.Name = "Ausschluss"
                        End If
                        MeineZeile = HoleZeilenAnzahlAusBlatt("Ausschluss")
                        Worksheets("Ausschluss").Cells(MeineZeile + 1, 1).Value = t.Name
                        
'                        MsgBox "Die Variable " & strFind & " konnte nicht gefunden werden!!!", vbCritical, "Schwerwiegender Fehler"
'                        Exit Function
                    Else
                        'zeilenindex = rngFind.Row - 1
                        t.Cells.SpecialCells(xlCellTypeLastCell).Activate                           'suchen der letzten gef|fffd|llten zeile
                        t.Range(Cells(1, 1), (Cells(ActiveCell.Row, ActiveCell.Column))).Copy       'markieren und kopieren
                        zeilenspeicher = ActiveCell.Row
                        Worksheets("VUGesamt").Cells(Zeile, 1).PasteSpecial                         'einf|fffd|gen nach der letzten geschriebenen Zeile
                        Zeile = Zeile + zeilenspeicher
                        zeilenspeicher = 0
                        'Nun wird die Spalte "A" des aktuellen Blattes, die die VU-Nummer beinhaltet, geleert:
                        ZeilenAnzahlDesAktuellenBlatts = HoleZeilenAnzahlAusBlatt(t.Name)
                        Set Bereich = t.Range("A1:A" & ZeilenAnzahlDesAktuellenBlatts)
                        For Each Zelle In Bereich
                            Zelle = ""
                        Next
                    End If
                End With
            End If
        Next
        '
        '
        '
        ' ---------------------------------------
        ' Leere Zeilen l|fffd|schen in VU-Gesamt
        ' Zeilen mit "*" l|fffd|schen in VU-Gesamt
        ' Zeilen mit "Blatt" l|fffd|schen in VU-Gesamt
        ' ---------------------------------------
        '
        Dim lngLastRow As Long
        Dim LetzteSpalte As Integer
        Dim MeinSuchbegriff As String

        Worksheets("VUGesamt").Activate
        Worksheets("VUGesamt").Range("A1").Select
        lngLastRow = ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell).Row

        If lngLastRow > 2 Then
            For i = lngLastRow To 2 Step -1                 ' nur bis 2, damit einmal "Blatt / Fehler" erhalten bleibt (f|fffd|r Pivot-Tabelle (FieldList))
                strWert = Worksheets("VUGesamt").Range("B" & i).Value
                MeinSuchbegriff = Mid(strWert, 1, 5)
                If MeinSuchbegriff = "Blatt" Or MeinSuchbegriff = "*****" Or MeinSuchbegriff = "" Then
                    Rows(i).Delete
                End If
            Next i
        Else
            MsgBox "Das Blatt " & """VUGesamt""" & " ist leer! " & vbNewLine & vbNewLine & "Das bedeutet, dass das Blatt ""Protokoll"" in allen ausgew|fffd|hlten Frageb|fffd|gen leer ist!", vbExclamation, "Start1()"
            Exit Sub
        End If
        '
        '|fffd|berschriftzeile anpassen:
        Worksheets("VUGesamt").Range("A1").Value = "VU-Nummer"
        '
        '
        '---------------------------
        ' Alle Bl|fffd|tter werden formatiert:
        FormatiereExcelblatt

        ' --------------------------------------------------------------------------------------------------------------------------
        '
        '------------------------------------------
        ' alte PivotTabelle l|fffd|schen, wenn vorhanden:
        '------------------------------------------
        '
        Dim pt As PivotTable
        Worksheets("Kontrollblatt").Activate
        With ActiveSheet
            For Each pt In .PivotTables
                pt.TableRange2.Delete
            Next pt
        End With
        ' ----------------------------------------------------------------------------------------------------------
        '
        ' Pivotcache im aktiven Workbook erstellen, dann PivotTabelle im Blatt <Kontrollblatt> erstellen
        ' Anzahl der Zeilen steht in Variable: lngLastRow
        ' Die Tabelle beginnt auf dem Blatt <Kontrollbaltt> in Zeile9, spalte5 (R9C5)
        '
        ' <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        ' lngLastRow = letzte Zeile in der Quelldatei
        ' LetzteSpalte = letzte Spalte in der Quelldatei
        
        LetzteSpalte = 4
        
        LetzteSpalte = Worksheets("VUGesamt").Cells(1, Columns.Count).End(xlToLeft).Column 'letzte Spalte
               
        ActiveWorkbook.PivotCaches.Create(SourceType:=xlDatabase, SourceData:= _
        "VUGesamt!R1C1:R" & lngLastRow & "C" & LetzteSpalte, Version:=xlPivotTableVersion14).CreatePivotTable _
        TableDestination:="Kontrollblatt!R9C5", TableName:="ErrStat", _
        DefaultVersion:=xlPivotTableVersion14
        ' >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        '
        '
        Sheets("Kontrollblatt").Select
        '
        ActiveWorkbook.ShowPivotTableFieldList = False
        '
        With ActiveSheet.PivotTables("ErrStat").PivotFields(2)           ' Blatt
          .Orientation = xlRowField
          .Position = 1
        End With
        '
        With ActiveSheet.PivotTables("ErrStat").PivotFields(3)           ' Fehler
          .Orientation = xlRowField
          .Position = 2
        End With
        '
        ' ein Feld f|fffd|r "Fehler pro Blatt" hinzuf|fffd|gen (Z|fffd|hler)
        '
        ActiveSheet.PivotTables("ErrStat").AddDataField ActiveSheet.PivotTables("ErrStat").PivotFields(3), "Fehler pro Blatt", xlCount
        '
        ' Bl|fffd|tter ("Blatt") nach Fehlerh|fffd|ufigkeit ("Fehler pro Blatt") sortieren
        '
        ActiveSheet.PivotTables("ErrStat").PivotFields(2).AutoSort xlAscending, "Fehler pro Blatt"
        
        '    innerhalb der Bl|fffd|tter die Meldungen nach Fehlerh|fffd|ufigkeit ("Fehler pro Blatt") sortieren
        '
        ActiveSheet.PivotTables("ErrStat").PivotFields(3).AutoSort xlAscending, "Fehler pro Blatt"

        ' ----------------------------------------------------------------------------------------------------------------------------------------------
        '
        ' jetzt noch einige Texte auf das Kontrollblatt ausbringen
        '
        ' Zeile 2
        Worksheets("Kontrollblatt").Range("E2").Value = " Statistik ITE/Protokollmeldungen (Pivot-Tabelle)" ' |fffd|berschrift
        '
        ' Zeile 3
        AnzahlAusgew|fffd|hlterDateien = AnzahlAusgew|fffd|hlterDateien - anzahlAbgewiesenDateien
        Worksheets("Kontrollblatt").Range("E3").Value = "Anz. ausgew|fffd|hlter VU:"
        Worksheets("Kontrollblatt").Range("F3").Value = AnzahlAusgew|fffd|hlterDateien
        '
        ' Zeile 4
        Worksheets("Kontrollblatt").Range("E4").Value = "Anz. abgewiesener VU:"
        AnzahlAusgeschlossenerDateien = HoleZeilenAnzahlAusBlatt("Ausschluss")

        Worksheets("Kontrollblatt").Range("F4").Value = AnzahlAusgeschlossenerDateien
        '
        ' Zeile 5 wird in Subroutine <FrageboegenInsKontrollblattUebertragen> beschickt |fffd|ber Variable <Pfad>
        '
        ' Zeile 6
        datEnde = Now()
        laufzeit = Format(datEnde - datStart, "hh:mm:ss")
        Worksheets("Kontrollblatt").Range("E6").Value = "Laufzeit(HH:MM:SS):"
        Worksheets("Kontrollblatt").Range("F6").Value = laufzeit
        '
        ' Zeile 7
        Worksheets("Kontrollblatt").Range("E7").Value = "Datum:"
        Worksheets("Kontrollblatt").Range("F7").Value = Date
'
'
'           auf Zelle A1 positionieren
'
        Worksheets("VUGesamt").Activate
        Worksheets("VUGesamt").Range("A1").Select
        Worksheets("Kontrollblatt").Activate
        Worksheets("Kontrollblatt").Range("A1").Select
        
        PivotTabelleFormatieren
        '
        ' Datei sichern in vorgesehenem Verzeichnis
        '
        meineKontrollDatei.SaveCopyAs (meineKontrollDatei.Path & "\Err_dokumente\" & DateinameOhneExtension & "ErrorStatistik" & zeitstempel() & ".xlsm")
        
        MsgBox "Das Ergebnis finden Sie " & vbNewLine & "in der Datei: " & vbTab & _
            DateinameOhneExtension & "ErrorStatistik" & zeitstempel() & ".xlsm" & vbNewLine & "im Ordner: " & vbTab & _
            meineKontrollDatei.Path & "\Err_dokumente\", vbInformation, "ZghErrorStat"
        '
        '       alle Bl|fffd|tter l|fffd|schen, au|fffd|er Blatt 1 (Kontrollblatt)
        '
        For i = Worksheets.Count To 2 Step -1               'durchlauf aller Tabellen in Dokument
            If Not Worksheets(i).Name = "Kontrollblatt" And _
                Not Worksheets(i).Name = "Ausschluss" Then
                Application.DisplayAlerts = False
                Worksheets(i).Delete
                Application.DisplayAlerts = True
            End If
        Next
        
        ThisWorkbook.Worksheets("Kontrollblatt").Cells.Clear ' Kontrollblatt glatt machen
        
        Application.DisplayAlerts = True
        Application.ScreenUpdating = True
       
        'Ende der Verarbeitung:
        Unload usf1
        
        ThisWorkbook.Close SaveChanges:=False
        
    Else
        MsgBox "nix okay und fettich ab"
    End If
  
    Exit Sub
    
fehlerbehandlung:
    MsgBox "Der Fehler (Fehlernummer " & Err.Number & "): (" & Err.Description & ") ist in der Startroutine aufgetreten!", vbCritical, "Fehler"

End Sub

Function FrageboegenInsKontrollblattUebertragen(meineKontrollDatei As Excel.Workbook, AnzahlAusgew|fffd|hlterDateien As Integer, tf As Variant) As Boolean
    '
    '---------------------------------------------------------------------------------
    ' Beschreibung:
    '
    '
    '
    '
    '
    ' Argumente:
    '
    '
    ' --------------------------------------------------------------------------------
    ' Datum     I Programmierer(in) I Beschreibung
    '---------------------------------------------------------------------------------
    '           I Said Zeghebibe        I erstellt
    '           I                       I
    '
    ' ----------------------------------------------------------------------------------
    '
    Dim MeinPraefixArray(4) As String
    Dim i As Integer
    Dim meinKontrollBlatt As Excel.Worksheet
    Dim datStart As Date
    Dim datEnde As Date
    Dim laufzeit As String
    Dim startposition As Integer
    Dim mehrAlsEinerAusgew|fffd|hlt As Boolean
    Dim AktuelleDatei As String
    Dim AktuelleDateiOhnePfad As String
    Dim tempPos As Collection
    Dim Pfad As String
    Dim FelderAnzahlZeilen As Long
    Dim aktuellesJahrKontrollbogen As Variant
    Dim spaltenpos As Integer
    Dim AnzahlAusgeschlossenerDateien As Long
    Dim AktuelleSpalte As String
    Dim adrg As String
    Dim mittelwert As String
    Dim mittelwertneu As String
    Dim oldStatus As String
    Dim dblProgress As Double         'Wert (Berechnung) des Fortschritts
    Dim Zaehler As Long
    Dim sPraefixEins As String
    Dim sPraefixZwei As String
    Dim sSuffix As String
    Dim bFormelAendern As Boolean
    Dim bFrageBearbeitet As Boolean
    Dim sAktWS As String
    Dim meineVUNummer As String
    Dim WB As Workbook
    Dim xlsFile  As String, xlsxFile As String, AktuelleDateiNameOhneExtension As String
    Dim FileExtension As String
    Dim AktWSZeilenAnzahl As Long
    Dim Bereich As Range
    Dim Zelle As Range
            
    oldStatus = Application.DisplayStatusBar
    Application.DisplayStatusBar = True
    Application.StatusBar = "Bitte warten... FrageboegenInsKontrollblattUebertragen() l|fffd|uft!"

    Set meinKontrollBlatt = meineKontrollDatei.Sheets("Kontrollblatt")
    
    meinKontrollBlatt.Cells.Clear
    
    startposition = 0
    
    If AnzahlAusgew|fffd|hlterDateien > 1 Then
        mehrAlsEinerAusgew|fffd|hlt = True
    Else
        mehrAlsEinerAusgew|fffd|hlt = False
    End If

    FelderAnzahlZeilen = 400                ' hier wird davon ausgegangen, dass wir nicht nicht mehr als 400 Fehlermeldungen/Hinweise pro VU haben
                                            ' im Schnitt haben wir derzeit ca. 50 Meldungen, von denen die |fffd|berhaupt Fehlermeldungen haben
                                            
    '-------pfad der dateien bestimmen---------
    'Unabh|fffd|ngig davon, wieviele Dateien ausgew|fffd|hlt wurden, es reicht vollkommen, den Pfad der 1.Datei zu bestimmen:
    Set tempPos = ZerteileStringZuCollection(tf(0), "\")
    Pfad = ""
    For i = 1 To tempPos.Count - 1
        Pfad = Pfad & tempPos.Item(i) & "\"
    Next i
    '
    Worksheets("Kontrollblatt").Range("E5").Value = "aus Verzeichnis:"
    Worksheets("Kontrollblatt").Range("F5").Value = Pfad
    
    aktuellesJahrKontrollbogen = 2014
    spaltenpos = 2
    
    datStart = Now()
    '
    '------schleife |fffd|ber alle ausgew|fffd|hlten exceldateien
    startposition = 1
    For i = startposition To AnzahlAusgew|fffd|hlterDateien
    
        AktuelleDatei = tf(i - 1)
        AktuelleDateiOhnePfad = Right(AktuelleDatei, Len(AktuelleDatei) - InStrRev(AktuelleDatei, "\"))
        AktuelleSpalte = ConvertToLetter(spaltenpos)
        
        AktuelleDateiNameOhneExtension = Left(AktuelleDateiOhnePfad, InStrRev(AktuelleDateiOhnePfad, ".") - 1)
        
        'Pr|fffd|fen der ausgew|fffd|hlten Dateien hinsichtlich Excelformat:
        'Alle im xls-Format ausgew|fffd|hlten Dateien werden (tempor|fffd|r!) in das xlsx-Format konvertiert!
        'Hintergrund: Bei den xls-Dateien wurde festgestellt, dass die Funktion GetDataClosedWB( ) manchmal den Fehler "#N/V" zur|fffd|ckliefert,
        'obwohl kein Fehler vorhanden ist:
        
        FileExtension = Mid(AktuelleDateiOhnePfad, InStrRev(AktuelleDateiOhnePfad, "."))
        
        If FileExtension = ".xls" Then
            
            Application.EnableEvents = False
            Application.DisplayAlerts = False
            Application.AskToUpdateLinks = False

            Set WB = Workbooks.Open(Pfad & AktuelleDateiOhnePfad)
        
            With ActiveWorkbook
                ' Dateiformat pr|fffd|fen:
                If .FileFormat = xlWorkbookNormal Or .FileFormat = xlExcel8 Then
                    ' Dateinamen merken:
                    xlsFile = .FullName
                    ' Datei im neuen Dateinformat speichern:
                    .SaveAs Filename:=Replace(xlsFile, "xls", "xlsx"), _
                            FileFormat:=xlOpenXMLWorkbook
                End If
            End With
        
            WB.Close
            xlsxFile = AktuelleDateiNameOhneExtension & ".xlsx"
            AktuelleDateiOhnePfad = xlsxFile
            
            Application.EnableEvents = True
            Application.DisplayAlerts = True
            Application.AskToUpdateLinks = True
            
        End If
        
        ' Hole VUnr aus  Blatt "Unternehmensdaten" und merke dir die VUnr im Kontrollblatt in zelle X1:
        If Not GetDataClosedWB(Pfad, AktuelleDateiOhnePfad, "Unternehmensdaten", "E7", Worksheets("Kontrollblatt").Range("X1")) Then
            MsgBox "Aus " & AktuelleDatei & " konnte nicht gelesen werden!", vbCritical, "Lesefehler-1 aus ausgew|fffd|hler Datei  "
            FrageboegenInsKontrollblattUebertragen = False
            Exit Function
        Else
            'Lege neues Blatt mit dem Namen des meldenden VU an:
            Worksheets.Add After:=Worksheets(1)
            meineVUNummer = CStr(meinKontrollBlatt.Cells(1, 24).Value2)
            'meineVUNummer = Worksheets("Kontrollblatt").Range("X1").Value
            If CStr(meineVUNummer) = "Fehler 2042" Then
                If InStr(AktuelleDateiOhnePfad, "DEVK") > 0 Then
                    meineVUNummer = "5344"
                Else
                    If InStr(AktuelleDateiOhnePfad, "LV1871") > 0 Then
                        meineVUNummer = "1062"
                    End If
                End If
            End If
            
            meineVUNummer = FormatiereVUNummer(meineVUNummer)

            ActiveSheet.Name = "VU" & meineVUNummer
            sAktWS = "VU" & meineVUNummer
            Worksheets("Kontrollblatt").Range("X1").Value = ""
            
        End If
        
        'Kopieren der  Spalte(n) aus aktueller Datei ohne sie zu |fffd|ffnen:
        If Not GetDataClosedWB(Pfad, AktuelleDateiOhnePfad, "Protokoll", "A1:E" & FelderAnzahlZeilen, Worksheets(sAktWS).Range(AktuelleSpalte & "1")) Then
            MsgBox "Aus " & AktuelleDatei & " konnte nicht gelesen werden!", vbCritical, "Lesefehler-2 aus ausgew|fffd|hler Datei "
            FrageboegenInsKontrollblattUebertragen = False
            Exit Function
        Else
            'Anzahl der zeilen auf dem Blatt "sAktWS" ermitteln:
            AktWSZeilenAnzahl = HoleZeilenAnzahlAusBlatt(sAktWS, 2)
            If AktWSZeilenAnzahl > 1 Then
                Set Bereich = Worksheets(sAktWS).Range("A1:A" & AktWSZeilenAnzahl) 'Hier deinen Bereich anpassen
                For Each Zelle In Bereich
                    Zelle = "'" & meineVUNummer
                Next
            End If
        End If
        
        spaltenpos = spaltenpos   ' bleibt immer auf Spalte 2, da wir nun im gesonderten Blatt speichern

        'L|fffd|schen der temp-Datei im "xlsx"-Format:
        If xlsxFile <> "" Then
            If File_Exists(Pfad & xlsxFile) Then
                Kill Pfad & xlsxFile
                'Variable initialisieren:
                xlsxFile = ""
            End If
        End If
        
    Next i
    '
    FrageboegenInsKontrollblattUebertragen = True
    
    ' Selbst-definierte Statusmeldung l|fffd|schen:
    Application.StatusBar = False
    ' Alten Zustand (angezeigt/nicht angezeigt) wiederherstellen:
    Application.DisplayStatusBar = oldStatus
        
End Function
Public Function GetDataClosedWB(SourcePath As String, SourceFile As String, sourceSheet As String, SourceRange As String, TargetRange As Range) As Boolean
    '
    '---------------------------------------------------------------------------------
    ' Beschreibung:
    '
    '
    '
    '
    '
    ' Argumente:
    '
    '
    ' --------------------------------------------------------------------------------
    ' Datum     I Programmierer(in)     I Beschreibung
    '---------------------------------------------------------------------------------
    '           I Said Zeghebibe        I erstellt
    '           I                       I
    '
    ' ----------------------------------------------------------------------------------
    Dim strQuelle As String
    Dim Zeilen As Long
    Dim Spalten As Byte
    Dim oldStatus As String
    
    oldStatus = Application.DisplayStatusBar
    Application.DisplayStatusBar = True
    Application.StatusBar = "Bitte warten... GetDataClosedWB() l|fffd|uft!"

    On Error GoTo InvalidInput

    strQuelle = "'" & SourcePath & "[" & SourceFile & "]" & sourceSheet & "'!" & Range(SourceRange).Cells(1, 1).Address(0, 0)

    Zeilen = Range(SourceRange).Rows.Count
    Spalten = Range(SourceRange).Columns.Count

    With TargetRange.Cells(1, 1).Resize(Zeilen, Spalten)
        .Formula = "=IF(" & strQuelle & "="""",""""," & strQuelle & ")"
        .Value = .Value
    End With
    
    GetDataClosedWB = True
    Application.StatusBar = False
    Application.DisplayStatusBar = oldStatus
    Exit Function

InvalidInput:
    MsgBox "Die Quelldatei oder der Quellbereich ist ung|fffd|ltig!", vbExclamation, "Get data from closed Workbook"
    GetDataClosedWB = False
    Application.StatusBar = False
    Application.DisplayStatusBar = oldStatus
    
End Function

Public Function DateienListe(Pfad As String, Titel As String, Filter As String, Multi As Boolean)
    '
    '---------------------------------------------------------------------------------
    ' Beschreibung:
    '
    '
    '
    '
    '
    ' Argumente:
    '
    '
    ' --------------------------------------------------------------------------------
    ' Datum     I Programmierer(in) I Beschreibung
    '---------------------------------------------------------------------------------
    '           I Said Zeghebibe        I erstellt
    '           I                       I
    '
    ' ----------------------------------------------------------------------------------

        Dim tf As Variant                       ' tf ist die Array-Variable f|fffd|r die die erfragten Filter
        Dim nflt As Integer                     ' Anzahl der Filter
        Dim res As String                       ' R|fffd|ckgabewert
        Dim i As Integer
        Dim p As String

        ' Diese Funktion |fffd|ffnet eine DialogBox zum Selektieren von Dateien.
        ' Sie gibt das Ergebnis in einer Liste zur|fffd|ck.
        ' (Das ist ein String, der aus den Dateinamen besteht, wobei diese Dateinamen durch "TABs" getrennt sind.
        
        ' "Pfad" est Ausgangspfad (Wenn es sich dabei um eine Datei ohne Pfad handelt, wird angenommen, dass sich diese im Arbeitsverzeichnis befindet.
        ' "Title" est die |fffd|berschrift des Fensters
        ' "Filter" ist der Filter f|fffd|r die Dateinamen oder Dateiendungen
        ' "Multi" Bei Multi = TRUE k|fffd|nnen mehr als eine Datei selektiert werden.

        Dim FD As FileDialog

        Set FD = Application.FileDialog(msoFileDialogFilePicker)

        ' Parameter:
        With FD
            .InitialFileName = Pfad
            .Title = Titel
            .ButtonName = "Ausw|fffd|hlen"
            .AllowMultiSelect = Multi
            .InitialView = msoFileDialogViewDetails
        End With

        nflt = 0
        If Filter <> "" Then
            'tf = Split(Filter, Chr(13))
            tf = Split(Filter, ";")
                
            nflt = UBound(tf) + 1
            ' L|fffd|schen der Filter
            FD.Filters.Clear
        End If
    
        For i = 1 To nflt
            ' Zerlegen des Filters nach "TAB":
            'p = InStr(tf(i - 1), Chr(9))
            p = InStr(tf(i - 1), "|")
                
            If p > 0 Then
                ' Anlegen des Filters:
                FD.Filters.Add Description:=Left(tf(i - 1), p - 1), Extensions:=Mid(tf(i - 1), p + 1)
            Else
                ' Falsche Parametrisierung des Filters (Kein TAB gefunden!)
            End If
                
        Next

        ' |fffd|ffnen des Selektierers:
        ' ************************
        With FD
            If .Show = True Then
                ' Wir erhalten die Namen der ausgew|fffd|hlten Dateien in der Kollektion "SelectedItems"
                ' und wir zerlegen den Returnwert (Dateinamen mit "TAB" getrennt)
                res = ""
                For i = 1 To FD.SelectedItems.Count
                    If res <> "" Then res = res & Chr(9)
                    res = res + FD.SelectedItems(i)
                Next
            End If
        End With

        Set FD = Nothing
        DateienListe = res
        
End Function
Public Function zeitstempel() As String
    '
    '---------------------------------------------------------------------------------
    ' Beschreibung:
    '
    '
    '
    '
    '
    ' Argumente:
    '
    '
    ' --------------------------------------------------------------------------------
    ' Datum     I Programmierer(in) I Beschreibung
    '---------------------------------------------------------------------------------
    '           I R|fffd|tting/K|fffd|lper    I erstellt
    '           I                   I
    '
    ' ----------------------------------------------------------------------------------

    Dim Zeit_aktuell As Variant
    Dim Datum_aktuell As Variant
    Dim datum_zeit As String
    
    Zeit_aktuell = Time   ' Aktuelle Systemzeit zur|fffd|ckgeben
    Datum_aktuell = Date
    
    datum_zeit = Trim(Str(Year(Datum_aktuell)))
    'jetzt das datum
    If Month(Datum_aktuell) < 10 Then
        datum_zeit = datum_zeit & "0" & Trim(Str(Month(Datum_aktuell)))
    Else
        datum_zeit = datum_zeit & Trim(Str(Month(Datum_aktuell)))
    End If
    If Day(Datum_aktuell) < 10 Then
        datum_zeit = datum_zeit & "0" & Trim(Str(Day(Datum_aktuell)))
    Else
        datum_zeit = datum_zeit & Trim(Str(Day(Datum_aktuell)))
    End If
    'und jetzt die zeit...
    datum_zeit = datum_zeit & "_"
    If Hour(Zeit_aktuell) < 10 Then
        datum_zeit = datum_zeit & "0" & Trim(Str(Hour(Zeit_aktuell)))
    Else
        datum_zeit = datum_zeit & Trim(Str(Hour(Zeit_aktuell)))
    End If
    If Minute(Zeit_aktuell) < 10 Then
        datum_zeit = datum_zeit & "0" & Trim(Str(Minute(Zeit_aktuell)))
    Else
        datum_zeit = datum_zeit & Trim(Str(Minute(Zeit_aktuell)))
    End If
    If Second(Zeit_aktuell) < 10 Then
        datum_zeit = datum_zeit & "0" & Trim(Str(Second(Zeit_aktuell)))
    Else
        datum_zeit = datum_zeit & Trim(Str(Second(Zeit_aktuell)))
    End If
   ' MsgBox datum_zeit
    zeitstempel = datum_zeit
    
End Function
Public Function ZerteileStringZuCollection(ByVal Quelle As String, Trennzeichen As String) As Collection

    '---------------------------------------------------------------------------------
    ' Beschreibung:
    '
    'diese Funktion trennt den String Quelle mithilfe des Parameter Trennzeichen.
    'der R|fffd|ckgabewert der Funktion ZerteileStringZuCollection() ist eine Kollektion.
    '
    '
    ' Argumente:
    '
    '
    ' --------------------------------------------------------------------------------
    ' Datum     I Programmierer(in) I Beschreibung
    '---------------------------------------------------------------------------------
    '           I R|fffd|tting/K|fffd|lper    I erstellt
    '           I                   I
    '
    ' ----------------------------------------------------------------------------------

    Dim Ergebnis As New Collection                      'Zwischenergebnis f|fffd|r R|fffd|ckgabewert
    Dim zeichen As String                               'aktuelles Zeichen(1 Byte) wird in <zeichen> zwischengespeichert
    Dim token As String                                 'Ansammlung von <zeichen> zwischen zwei <Trennzeichen> (Sonderf|fffd|lle siehe unten)
    Dim L|fffd|nge As Integer                                '<l|fffd|nge> enh|fffd|lt info |fffd|ber Anzahl Zeichen der <Quelle>
    Dim i As Integer                                    'Laufvariable beginnt mit 1, endet mit Wert von <l|fffd|nge>
    
    'Bestimmen der L|fffd|nge des String
    L|fffd|nge = Len(Quelle)
    token = ""
    zeichen = ""
    
    For i = 1 To L|fffd|nge
    
        zeichen = Mid$(Quelle, i, 1)
        'der ganze String besteht aus einem Trennzeichen --> Ergebnis 2 Felder
        ' --Bsp.: ";" --> Ergebnis "(Leerfeld);(Leerfeld)" in Collection
        If i = 1 And zeichen = Trennzeichen And L|fffd|nge = 1 Then
            Ergebnis.Add (token)
            Ergebnis.Add (token)
        'das erste Zeichen des Strings ist ein Trennzeichen --> Ergebnis +1 Feld
        ' --Bsp.: ";hugo;...." --> Ergebnis "(Leerfeld);hugo;...." in Collection
        ElseIf i = 1 And zeichen = Trennzeichen Then
           Ergebnis.Add (token)
        'das letzte Zeichen des Strings ist ein Trennzeichen --> Ergebnis +1 Feld
        ' --Bsp.: "....;hugo;" --> Ergebnis "....;hugo;(Leerfeld)" in Collection
        ElseIf i = L|fffd|nge And zeichen = Trennzeichen Then
           Ergebnis.Add (token) 'das aktuelle Token vor dem Trennzeichen
           token = ""
           Ergebnis.Add (token) ' das leere Feld nach dem Trennzeichnen
        'Normalfall
        ' -- Bsp.: "hugo;...;egon" --> Ergebnis "hugo;....;egon"
        ElseIf zeichen <> Trennzeichen Then
            token = token & zeichen
        'Wenn nichts von dem zutrifft wird ein leerer Token |fffd|bergeben
        Else
            Ergebnis.Add (token)
            token = ""
            zeichen = ""
        End If
    Next i
    'Normalfall - Einlesen des letzten Token / letzter Token nat|fffd|rlich ohne Trennzeichen!
    ' -- Bsp.: "hugo;...;egon" --> Ergebnis "hugo;....;egon"
    If i = L|fffd|nge + 1 And token <> "" Then
        Ergebnis.Add token
    End If
    'Wertr|fffd|ckgabe der Funktion ZerteileStringZuCollection
    Set ZerteileStringZuCollection = Ergebnis
    
End Function
Public Function ConvertToLetter(icol As Integer) As String
'
' author: gdv ae (said)
'

    Dim c As Integer
    Dim c1 As Integer

    c = icol Mod 26
    c1 = Int(icol / 26)

    If c1 > 0 Then
        If c = 0 Then
            If c1 > 1 Then
                ConvertToLetter = Chr(c1 + Asc("A") - 2) + "Z"
            Else
                ConvertToLetter = "Z"
            End If
        Else
            ConvertToLetter = Chr(c1 + Asc("A") - 1) + Chr(c + Asc("A") - 1)
        End If
    Else
        ConvertToLetter = Chr(c + Asc("A") - 1)
    End If
    
End Function


Attribute VB_Name = "Modul2"
Sub PivotTabelleFormatieren()


    Dim intErsteZeile As Integer, intLetzteZeile As Integer
    Dim strMeineRange As String, strKontrollblatt As String
    
    Const ZEILENBESCHRIFTUNG_ZEILENNUMMER = 9
    
    intErsteZeile = ZEILENBESCHRIFTUNG_ZEILENNUMMER
    
    strKontrollblatt = ActiveSheet.Name
    intLetzteZeile = HoleZeilenAnzahlAusBlatt(strKontrollblatt, 5)
    
    strMeineRange = strKontrollblatt & "!" & "$E$" & intErsteZeile & ":" & "$F$" & intLetzteZeile
    
    With ActiveSheet
      If .ChartObjects.Count > 0 Then
            .ChartObjects(1).Delete
      End If
    End With
    '
    ActiveSheet.Shapes.AddChart.Select
    ActiveChart.ChartType = xl3DPie
    
    ActiveChart.SetSourceData Source:=Range(strMeineRange)
    With ActiveSheet.Shapes(1)
        .IncrementLeft 237
        .IncrementTop -10.5
        .ScaleHeight 1.7968751823, msoFalse, _
        msoScaleFromTopLeft
    End With
    '
    With ActiveSheet.PivotTables("ErrStat").PivotFields("Blatt")
        For Each Pi In .PivotItems
            'MsgBox Pi, vbInformation, "Debuggen"
            If Pi = "(blank)" Then
                Pi.Visible = False
            End If
        Next Pi
    End With

End Sub
Attribute VB_Name = "Modul3"
Option Explicit

Function File_Exists(ByVal sPathName As String, Optional Directory As Boolean) As Boolean
    
    'Returns True if the passed sPathName exist
    'Otherwise returns False
    
    On Error Resume Next
    
    If sPathName <> "" Then
        If IsMissing(Directory) Or Directory = False Then
            File_Exists = (Dir$(sPathName) <> "")
        Else
            File_Exists = (Dir$(sPathName, vbDirectory) <> "")
        End If
    End If
    
End Function
Attribute VB_Name = "Modul4"
Option Explicit

Function WorksheetExists(SheetName As Variant, Optional WhichBook As Workbook) As Boolean

    Dim WB As Workbook
    
    Set WB = IIf(WhichBook Is Nothing, ThisWorkbook, WhichBook)
    
    On Error Resume Next
    WorksheetExists = CBool(Len(WB.Worksheets(SheetName).Name) > 0)
    
End Function

Function TestWorksheetExists()

    Dim BlattName As String
    Dim bBlattIstVorhanden As Boolean
    Dim sBlattIstVorhanden As String
    
    BlattName = "Kontrollblatt"
    BlattName = "VU-blatt"

    bBlattIstVorhanden = WorksheetExists(BlattName, ActiveWorkbook)
    
    If bBlattIstVorhanden = False Then
        sBlattIstVorhanden = "nicht "
    Else
        sBlattIstVorhanden = ""
    End If
    
    Application.DisplayAlerts = False
    MsgBox "Das Blatt " & """" & BlattName & """" & " ist " & sBlattIstVorhanden & "vorhanden!", vbInformation, "TestWorksheetExists()"
    Application.DisplayAlerts = True
    
End Function
Attribute VB_Name = "Modul5"
Option Explicit

Function HoleZeilenAnzahlAusBlatt(BlattName As String, Optional Spalte = 1) As Long
    
    Dim meinBlatt As Excel.Worksheet
    Dim MeineSpalte As Integer
    Dim zeilenende As Long
    
    If WorksheetExists(BlattName, ActiveWorkbook) = True Then
   
        Set meinBlatt = Excel.Application.ActiveWorkbook.Sheets(BlattName)
    
        meinBlatt.Activate
        MeineSpalte = Spalte

        zeilenende = LetzteNichtLeereZeile(MeineSpalte)
    
    End If
    
    HoleZeilenAnzahlAusBlatt = zeilenende

End Function

Attribute VB_Name = "Modul6"
Option Explicit

'-----------------------------------------------------------------

' gibt die LetzteNichtLeereZeile in SPALTE zur|fffd|ck

' weitere infos in der vba-hilfe, stichwort: cell, End-Eigenschaft
'-----------------------------------------------------------------
'
Function LetzteNichtLeereZeile(Spalte As Integer) As Long

    Dim Zeile As Long
    
    ' LetzteNichtLeereZeile ermitteln:
    Zeile = Cells(Spalte).Cells(Columns(Spalte).Rows.Count, 1).End(xlUp).Row
    If Cells(Zeile, Spalte) = Empty Then
        ' gibt 0 zur|fffd|ck, falls keine LetzteNichtLeereZeile existiert
        
         ' diesen r|fffd|ckgabewert k|fffd|nnen sie ihren erfordernissen anpassen
        LetzteNichtLeereZeile = 0
    Else
        LetzteNichtLeereZeile = Zeile
    End If
    
End Function
Attribute VB_Name = "Modul7"
Option Explicit

Function FormatiereVUNummer(VuNrKurz As String) As String

    Dim LaengeVonVUNummer As Integer
    Dim AnzahlF|fffd|hrenderNullen As Integer
    
    LaengeVonVUNummer = Len(VuNrKurz)
    AnzahlF|fffd|hrenderNullen = 4 - LaengeVonVUNummer
    
    FormatiereVUNummer = String(AnzahlF|fffd|hrenderNullen, "0") & VuNrKurz
    
End Function
Attribute VB_Name = "Modul8"
Option Explicit

Function FormatiereExcelblatt()

    Dim i As Integer
    Dim ZeilenAnzahlDesAktuellenBlatts As Integer

    Application.ScreenUpdating = False
    
    For i = Worksheets.Count To 2 Step -1
        Worksheets(i).Activate
        If Not Worksheets(i).Name = "Kontrollblatt" And _
            Not Worksheets(i).Name = "Ausschluss" Then
            Range("A1:E1").Select
            Selection.AutoFilter
            Columns("A:E").Select
            ZeilenAnzahlDesAktuellenBlatts = HoleZeilenAnzahlAusBlatt(Worksheets(i).Name, 2)
            With ActiveWorkbook.Worksheets(i)
                If .Name = "VUGesamt" Then
                    .Sort.SortFields.Clear
                    .Range("A2:E" & ZeilenAnzahlDesAktuellenBlatts).Sort Key1:=Range("B2"), Order1:=xlAscending, _
                            key2:=Range("C2"), key3:=Range("D2"), key3:=Range("E2"), _
                            order2:=xlAscending, Orientation:=xlRows
                    With .Sort
                        .SetRange Range("A1:E" & ZeilenAnzahlDesAktuellenBlatts)
                        .Header = xlYes
                        .MatchCase = False
                        .Orientation = xlTopToBottom
                        .SortMethod = xlPinYin
                        .Apply
                    End With
                End If
                
                Selection.ColumnWidth = 67.71
                Columns("A:E").EntireColumn.AutoFit
                Columns("A:E").EntireColumn.AutoFit
                Columns("C:C").Select
                With Selection
                    .HorizontalAlignment = xlGeneral
                    .VerticalAlignment = xlBottom
                    .WrapText = True
                    .Orientation = 0
                    .AddIndent = False
                    .IndentLevel = 0
                    .ShrinkToFit = False
                    .ReadingOrder = xlContext
                    .MergeCells = False
                End With
                Selection.ColumnWidth = 70
                Columns("D:D").EntireColumn.AutoFit
                Columns("E:E").Select
                With Selection
                    .HorizontalAlignment = xlGeneral
                    .VerticalAlignment = xlBottom
                    .WrapText = True
                    .Orientation = 0
                    .AddIndent = False
                    .IndentLevel = 0
                    .ShrinkToFit = False
                    .ReadingOrder = xlContext
                    .MergeCells = False
                End With
                Selection.ColumnWidth = 70
                ActiveWindow.ScrollColumn = 4
                ActiveWindow.ScrollColumn = 3
                ActiveWindow.ScrollColumn = 2
                ActiveWindow.ScrollColumn = 1
                Rows("2:2").Select
                Range(Selection, Selection.End(xlDown)).Select
                ActiveWindow.SmallScroll Down:=6
                Rows("2:" & ZeilenAnzahlDesAktuellenBlatts).EntireRow.AutoFit
                
                If .Name <> "VUGesamt" Then
                    Columns("A:A").EntireColumn.Hidden = True
                End If
                
            End With
            Application.Goto Reference:=Range("B1"), Scroll:=True
        Else
            Application.Goto Reference:=Range("A1"), Scroll:=True
        End If
    Next
    
End Function

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Sub Test()
    '
    '
    ' PivotTabelle l|fffd|schen
    '
     Dim pt As PivotTable
     
     With ActiveSheet
         For Each pt In .PivotTables
             pt.TableRange2.Delete
         Next pt
     End With
    '
    '
    ' PivotTabelle erstellen
    '
    Dim ptTable As PivotTable
    Dim ptCache As PivotCache
    
    '
    ' Die Datenquelle
     Set ptCache = ActiveWorkbook.PivotCaches.Add(SourceType:=xlDatabase, SourceData:="VUGesamt")
    ' Die Pivot-Tabelle erzeugen
     Set ptTable = ptCache.CreatePivotTable _
     (TableDestination:="", _
      TableName:="Statistik")
      
    ' Pivot-Tabellenfelder anordnen
    With ptTable
     .PivotFields("Blatt").Orientation = xlRowField
     .PivotFields("Meldung").Orientation = xlDataField
    End With
    
    Set ptCache = Nothing
    Set ptTable = Nothing
    '

End Sub

Sub CreatePivot()

    ' Creates a PivotTable report from the table on Sheet1
    ' by using the PivotTableWizard method with the PivotFields
    ' method to specify the fields in the PivotTable.
    Dim objTable As PivotTable, objField As PivotField
    
    ' Select the sheet and first cell of the table that contains the data.
    ActiveWorkbook.Sheets("VUGesamt").Range("A1").Select
     
    ' Create the PivotTable object based on the ErrorMSG data on VUGesamt.
    Set objTable = ActiveWorkbook.Sheets("VUGesamt").PivotTableWizard
    
    ' Specify row and column fields.
    Set objField = objTable.PivotFields("Blatt")
    objField.Orientation = xlRowField

   ' Set objField = objTable.PivotFields("Meldung")
   ' objField.Orientation = xlColumnField
    
    ' Specify a data field with its summary
    ' function and format.
    Set objField = objTable.PivotFields("Meldung")
    objField.Orientation = xlDataField
    objField.Function = xlCount
    'objField.NumberFormat = "$ #,##0"
    
    ' Specify a page field.
    'Set objField = objTable.PivotFields("GENDER")
    'objField.Orientation = xlPageField
    
    ' Preview the new PivotTable report.
    ActiveSheet.PrintPreview
    
    ' Prompt the user whether to delete the PivotTable.
    Application.DisplayAlerts = False
    If MsgBox("Delete the PivotTable?", vbYesNo) = vbYes Then
        ActiveSheet.Delete
    End If
    
    Application.DisplayAlerts = True
    
 End Sub
Attribute VB_Name = "usf1"
Attribute VB_Base = "0{E7E43E58-6FB4-48B2-A660-59D6D1F9E452}{8EB301F8-2D7D-4CDE-BDBA-F5C14FF7D06D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Const SWP_NOMOVE = 2
Const SWP_NOSIZE = 1
Const flags = SWP_NOMOVE Or SWP_NOSIZE
Const HWND_TOPMOST = -1
Const HWND_NOTOPMOST = -2

Private Const GC_CLASSNAMEUSERFORM = "ThunderDFrame"

Private Declare Function FindWindow Lib "user32.dll" Alias "FindWindowA" ( _
    ByVal lpClassName As String, _
    ByVal lpWindowName As String) As Long
    
Private Declare Function SetWindowPos Lib "user32" _
  (ByVal hwnd As Long, ByVal hWndInsertAfter As Long, _
   ByVal x As Long, ByVal y As Long, ByVal cx As Long, _
   ByVal cy As Long, ByVal wFlags As Long) As Long

Private Sub cmbButton1_Click()
    cmbButton1.Enabled = False
    lbl1.Caption = "Verarbeitung l|fffd|uft..."
    Call start1
    lbl1.Caption = "Verarbeitung beendet..."
End Sub

Private Sub UserForm_Activate()

    Call SetWindowPos(FindWindow(GC_CLASSNAMEUSERFORM, Caption), _
                        HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE)
    '
    Me.Repaint
    
End Sub


' InQuest injected base64 decoded content
' gxLmz{"
' bzWK
' !1?>
' jKnzY^
' KnzY^
' gxLmz{"
' z)^J

INQUEST-PP=macro
