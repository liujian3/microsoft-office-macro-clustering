Attribute VB_Name = "Dictionary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Collection methods: Add, Count, Item, Remove
'Dictionary : .Add(Key as string, Item as variant), .CompareMode, .Count, .Exists(Key); _
   .Item(Key) - writeable, .Items, .Keys, .Remove(Key), .RemoveAll
'plus KeyValuePairs collection, KeyValuePair(Index as long), Tag as variant
' 25-11-2011 KeyValuePair helper object

Public KeyValuePairs As Collection ' open access but allows iteration
Public Tag As Variant            ' read/write unrestricted

Private Sub Class_Initialize()
   Set KeyValuePairs = New Collection
End Sub

Private Sub Class_Terminate()
   Set KeyValuePairs = Nothing
End Sub

' in Scripting.Dictionary this is writeable, here we have only vbtextCompare because we are using a Collection
Public Property Get CompareMode() As VbCompareMethod
   CompareMode = vbTextCompare   '=1; vbBinaryCompare=0
End Property

Public Property Let item(key As String, item As Variant)    ' dic.Item(Key) = value ' update a scalar value for an existing key
  Dim kvp As KeyValuePair ' used to correct mac error of june 2016
  If Exists(key) Then
    Set kvp = KeyValuePairs.item(key) ' fix mac bug of june 2016
    Let kvp.value = item
  Else
    Add key, item
  End If
End Property

Public Property Set item(key As String, item As Variant)    ' Set dic.Item(Key) = value ' update an object value for an existing key
  Dim kvp As KeyValuePair ' used to correct mac error of june 2016
  If Exists(key) Then
   Set kvp = KeyValuePairs.item(key) ' fix mac bug of june 2016
   Set kvp.value = item
  Else
    Add key, item
  End If
End Property

Public Property Get item(key As String) As Variant
  Dim kvp As KeyValuePair ' used to correct mac error of june 2016
   Set kvp = KeyValuePairs.item(key) ' fix mac bug of june 2016
   AssignVariable item, kvp.value
End Property

' Collection parameter order is Add(Item,Key); Dictionary is Add(Key,Item) so always used named arguments
Public Sub Add(key As String, item As Variant)
   Dim oKVP As KeyValuePair
   Set oKVP = New KeyValuePair
   oKVP.key = key
   If IsObject(item) Then
      Set oKVP.value = item
   Else
      Let oKVP.value = item
   End If
   KeyValuePairs.Add item:=oKVP, key:=key
End Sub

Public Property Get Exists(key As String) As Boolean
   On Error Resume Next
   Exists = TypeName(KeyValuePairs.item(key)) > ""  ' we can have blank key, empty item
End Property

Public Sub Remove(key As String)
   'show error if not there rather than On Error Resume Next
   KeyValuePairs.Remove key
End Sub

Public Sub RemoveAll()
   Set KeyValuePairs = Nothing
   Set KeyValuePairs = New Collection
End Sub

Public Property Get count() As Long
   count = KeyValuePairs.count
End Property

Public Property Get Items() As Variant     ' for compatibility with Scripting.Dictionary
Dim vlist As Variant, i As Long
If Me.count > 0 Then
   ReDim vlist(0 To Me.count - 1) ' to get a 0-based array same as scripting.dictionary
   For i = LBound(vlist) To UBound(vlist)
      AssignVariable vlist(i), KeyValuePairs.item(1 + i).value ' could be scalar or array or object
   Next i
   Items = vlist
End If
End Property

Public Property Get Keys() As String()
Dim vlist() As String, i As Long
Dim kvp As KeyValuePair
'Stop
If Me.count > 0 Then
   ReDim vlist(0 To Me.count - 1)
   For i = LBound(vlist) To UBound(vlist)
     Set kvp = KeyValuePairs.item(1 + i)
      vlist(i) = kvp.key   '
   Next i
   Keys = vlist
End If
End Property

Public Property Get KeyValuePair(index As Long) As Variant  ' returns KeyValuePair object
    Set KeyValuePair = KeyValuePairs.item(1 + index)            ' collections are 1-based
End Property

Private Sub AssignVariable(variable As Variant, value As Variant)
   If IsObject(value) Then
      Set variable = value
   Else
      Let variable = value
   End If
End Sub

Public Sub DebugPrint()
   Dim lItem As Long, lIndex As Long, vItem As Variant, oKVP As KeyValuePair
   lItem = 0
   For Each oKVP In KeyValuePairs
      lItem = lItem + 1
      'debug.print lItem; oKVP.key; " "; TypeName(oKVP.value);
      If InStr(1, TypeName(oKVP.value), "()") > 0 Then
         vItem = oKVP.value
         'debug.print "("; CStr(LBound(vItem)); " to "; CStr(UBound(vItem)); ")";
         For lIndex = LBound(vItem) To UBound(vItem)
            'debug.print " (" & CStr(lIndex) & ")"; TypeName(vItem(lIndex)); "="; vItem(lIndex);
         Next
         'debug.print
      Else
         'debug.print "="; oKVP.value
      End If
   Next
End Sub

' Like the getter, but takes a default value
Public Function GetItem(key As String, Optional DefaultValue As Variant) As Variant
  Dim kvp As KeyValuePair ' used to correct mac error of june 2016


  If Exists(key) Then
    Set kvp = KeyValuePairs.item(key) ' fix mac bug of june 2016
    AssignVariable GetItem, kvp.value
    
  ElseIf Not IsMissing(DefaultValue) Then
    AssignVariable GetItem, DefaultValue
  Else
    AssignVariable GetItem, Null
  End If
End Function


'NB VBA Collection object index is 1-based, scripting.dictionary items array is 0-based
'cf Scripting.Dictionary Methods s.Add(Key, Item), s.CompareMode, s.Count, s.Exists(Key); _
   s.Item(Key) - updateable, s.Items, s.Key(Key), s.Keys, s.Remove(Key), s.RemoveAll
'Scripting.Dictionary has no index number; you can index the 0-based variant array of Items returned
'  unlike Collections which can be indexed starting at 1
'Efficient iteration is For Each varPair in thisdic.KeyValuePairs
'Another difference I introduce is that in a scripting.dictionary, the doc says
'  If key is not found when changing an item, a new key is created with the specified newitem.
'  If key is not found when attempting to return an existing item, a new key is created and its corresponding item is left empty.
'but I want to raise an error when addressing a key that does not exist
'similarly, the scripting.dictionary will create separate integer and string keys for eg 2





Attribute VB_Name = "KeyValuePair"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'Unrestricted class just to hold pairs of values together and permit Dictionary object updating
Public key As String
Public value As Variant
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_BeforeClose(Cancel As Boolean)
    Dim x As Integer
    'close any forms that might be open.  In some cases, if open they will cause a prompt for the VBA project password when closing!
    For x = UserForms.count - 1 To 0 Step -1
      Unload UserForms(x)
    Next

    #If Mac Then
    unLoadMenu
    #End If
End Sub

Private Sub Workbook_AfterSave(ByVal Success As Boolean)
If Len(getValue("lockWhenNotAvailable")) > 0 Then
  If getValue("lockWhenNotAvailable") Then
      webLock_afterSave
    End If
End If
End Sub
Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
Dim prophylactic As String
prophylactic = getValue("prophylactic")
If prophylactic > "" And prophylactic <> "EMPTY" Then ThisWorkbook.password = prophylactic
If Len(getValue("lockWhenNotAvailable")) > 0 Then
  If getValue("lockWhenNotAvailable") = "True" Then
     webLock_beforeSave
  End If
End If

End Sub
'Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
'  exportModuleLines
'End Sub

Private Sub Workbook_NewChart(ByVal Ch As Chart)
  Dim series1 As String
 
  If Ch.SeriesCollection.count > 0 Then series1 = Mid(Ch.SeriesCollection(1).formula, 2)
  If TypeName(Ch.Parent) = "Workbook" Then
    addLogEntry "7" & Chr(30) & Ch.Parent.Parent.name & Chr(30) & Ch.name & Chr(30) & Ch.ChartType & Chr(30) & series1 & Chr(30) & "-1" & Chr(30) & "-1"
  Else
    addLogEntry "7" & Chr(30) & Ch.Parent.Parent.name & Chr(30) & Ch.name & Chr(30) & Ch.ChartType & Chr(30) & series1 & Chr(30) & Ch.Parent.left & Chr(30) & Ch.Parent.top
  End If
  ' tags the chart with the color code from the downloaded file
  With Ch.Shapes.AddLine(1, 1, 1, 1)
    .line.ForeColor.RGB = hexColor2Dec(getValue("accountability"))
    .name = "invisaline"
  End With
End Sub

Private Sub Workbook_NewSheet(ByVal sh As Object)
  addLogEntry "2" & Chr(30) & "Insert Sheet" & Chr(30) & sh.name
End Sub

Private Sub Workbook_Open()
Dim data As Variant
Dim prophylactic As String
prophylactic = getValue("prophylactic")
'=====================Handle the Exam Password==============================
If prophylactic <> "EMPTY" And prophylactic > "" Then     ' there is a password to set
    If left(prophylactic, 1) = Chr(30) Then 'we need to set the password on this workbook
        updateValue "prophylactic", Mid(prophylactic, 2)
        enableMacros.Copy
        Range("a1").value = ThisWorkbook.path & pathSeparator & ThisWorkbook.name
        ActiveWorkbook.Windows(1).visible = False
        Application.OnTime Now + TimeValue("00:00:01"), "enableMacros.openexam"
        ThisWorkbook.password = Mid(prophylactic, 2)
        ThisWorkbook.Close True
    Else  ' the password is already set
      If Workbooks.count > 1 Then
        If Workbooks(Workbooks.count - 1).Worksheets.count = 1 And Workbooks(Workbooks.count - 1).Worksheets(1).name = "Enable Macros" Then
            ' the examOpener is open, close it
            Workbooks(Workbooks.count - 1).Close False
            ThisWorkbook.Activate
        End If
      End If
    End If
End If
'========================================================================



On Error Resume Next
If customProperties.count < 10 Then Exit Sub
  osRecordOpening ' sets the local property to record when last opened in the current OS
  
#If Mac Then
 loadMenu
#Else
  If getValue("dateOpenedMac") <> "EMPTY" And getValue("dateOpenedMac") <> "" Then
    data = Split(getValue("dateOpenedMac"), "|")
    If CSng(data(1)) < 15 Then
      assignment_tools
      MsgBox "This workbook has been saved using a version of Excel for the Macintosh operating system.  A limitation of this version of Excel is that it cannot display ribbon customizations built into a workbook. As a result, the ""Assignment"" tab of the ribbon is no longer in this workbook.  You should see a small window named ""Assignment Tools"" that will provide you the tools that are no longer available in the ribbon.", vbCritical, "Interface Change"
    End If
  End If
  
#End If

On Error GoTo 0


    'show the apporpriate sheets and hide the enable macros sheet
    showSheets
  
 setWritePath ' sets a global variable named "writePath" to be used for writing local files as needed
  
 Run "assignmentSpecificCode"

 logOpenDocument
 
End Sub

Private Sub Workbook_SheetBeforeDelete(ByVal sh As Object)
  addLogEntry "2" & Chr(30) & "Delete Sheet" & Chr(30) & sh.name
End Sub

Private Sub Workbook_SheetChange(ByVal sh As Object, ByVal Target As Range)
  Dim x As Long
  Dim rng As Range
  Dim hasSolver As Boolean
  Dim cellCount As Long
    
    
    
    On Error Resume Next
      hasSolver = sh.Names("solver_eng").name = sh.Names("solver_eng").name
    On Error GoTo Failed
    
    
    If sh.PivotTables.count = 0 And Not hasSolver Then
      ' no solver on sheet, no pivottable record and move on
      recordCellChange sh, Target
      Exit Sub
    End If
    
    Set rng = Target
    
    'build range for all pivottables
    For x = 1 To sh.PivotTables.count
      Set rng = Union(rng, sh.PivotTables(x).TableRange1)
    Next
    
    ' add in ranges that are specified for solver
    On Error Resume Next
    For x = 1 To sh.Names.count
     Set rng = Union(rng, sh.Names(x).RefersToRange)
    Next
    On Error GoTo Failed
    
    If rng.Cells.count > Target.Cells.count Then  ' the cell is not on a pivot table or the changable range of solver
      recordCellChange sh, Target
    End If
Failed:

End Sub



Private Sub Workbook_SheetPivotTableUpdate(ByVal sh As Object, ByVal Target As PivotTable)
  Dim rowFields As String
  Dim columnFields As String
  Dim dataFields As String
  Dim pageFields As String
  Dim x As Integer
  
  For x = 1 To Target.columnFields.count
    columnFields = columnFields & "<br>" & Target.columnFields(x).name
  Next
  For x = 1 To Target.rowFields.count
    rowFields = rowFields & "<br>" & Target.rowFields(x).name
  Next
  For x = 1 To Target.dataFields.count
    dataFields = dataFields & "<br>" & Target.dataFields(x).name
  Next
  For x = 1 To Target.pageFields.count
    pageFields = pageFields & "<br>" & Target.pageFields(x).name
  Next
  
    addLogEntry "8" & Chr(30) & sh.name & Chr(30) & Mid(rowFields, 5) & Chr(30) & Mid(columnFields, 5) & Chr(30) & Mid(dataFields, 5) & Chr(30) & Mid(pageFields, 5)
End Sub

Private Sub Workbook_SheetSelectionChange(ByVal sh As Object, ByVal Target As Range)
  On Error Resume Next
  Set lastSelection = Target
End Sub





Attribute VB_Name = "agent"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
  Dim referer As String
  Public formdata As String
  Dim ie As Object
  Dim theHTML As String
  Dim ucaseHTML As String
  Dim pos As Long
  Dim region As String
  Public http As Object
  Public agentName As String
  Public studyURL As String
  
' These three documents are the ones I use to understand the IE object
' InternetExplorere object reference: http://msdn2.microsoft.com/en-us/library/Aa752084.aspx
' Document object recerence:          http://msdn2.microsoft.com/en-us/library/ms531073.aspx
' body object reference:              http://msdn2.microsoft.com/en-us/library/ms535205.aspx

Public Property Get visible() As Boolean
  If ie Is Nothing Then initializeIE
  visible = ie.visible
End Property

Public Property Let visible(theValue As Boolean)
  If ie Is Nothing Then initializeIE
  ie.visible = theValue
End Property




Sub openpage(url As String, Optional useIE As Boolean)
#If Mac Then
   updateHTML MacScript("return do shell script ""/usr/bin/curl -s -S -m 10 '" & url & "'""")
  
#Else
  If useIE Then
    'opens the specified url in internet explorer
    If ie Is Nothing Then initializeIE
    ie.navigate url
    waitForLoad
    updateHTML
  Else
    
    If Not initializeHTTP Then Exit Sub
    
    http.Open "GET", url, False
    http.SetRequestHeader "user-Agent", agentName & "(" & studyURL & ")"
    If Not ie Is Nothing Then http.SetRequestHeader "Cookie", ie.document.cookie
     If referer > "" Then http.SetRequestHeader "Referer", referer
    http.Send
    updateHTML http.responsetext
  End If
#End If
End Sub



Public Sub updateHTML(Optional theText As String)
  If theText > "" Then
    theHTML = theText
  Else
    theHTML = documentSourceIE()
  End If
  pos = 1
End Sub

Public Function documentSourceIE()
  Dim x As Long
  
  For x = 0 To ie.document.all.length
    If ie.document.all(x).tagname = "HTML" Then
      documentSourceIE = ie.document.all(x).outerhtml
      Exit Function
    End If
  Next
End Function


Public Property Get text() As String
  text = theHTML
End Property

Public Property Let text(theValue As String)
  theHTML = theValue
  ucaseHTML = ""
End Property

Public Property Get position() As Long
  position = pos
End Property

Public Property Let position(theValue As Long)
  pos = theValue
  If pos < 1 Then pos = 1
End Property

Public Property Get explorer() As Object
  Set explorer = ie
End Property

Public Property Get document() As Object
  Set document = ie.document
End Property

Sub initializeIE()
    'call this subprocedure to start internet explorer up
    Set ie = CreateObject("internetexplorer.application")
    pos = 1
End Sub

Sub terminateIE()
  ' call this subprocedure when you are finished with IE to close it down
  On Error Resume Next
  ie.Quit
  Set ie = Nothing
End Sub
Private Function initializeHTTP() As Boolean
    If agentName = "" Or studyURL = "" Then
      MsgBox "You must supply an agent name, and a study URL to use the non-visual data connection.  If your agent variable is ""agent1"", you can set these as follows: " & vbNewLine & vbNewLine & "agent1.studyURL=""http://my.server.edu/mystudy.html"" " & vbNewLine & "agent1.agentName=""AcademicResearchBot 1.2"" "
      Exit Function
    End If
    
    If http Is Nothing Then
      On Error Resume Next
      Set http = CreateObject("MSXML2.serverXMLHTTP")
      http.setTimeouts 20000, 20000, 90000, 90000
      If Err.number <> 0 Then Set http = CreateObject("MSXML2.XMLHTTP")
      On Error GoTo 0
    End If

    initializeHTTP = True

End Function
Sub saveFile(url As String, path As String)
' path is full path including filename
    strFileURL = url
    strHDLocation = path
 
' Fetch the file
    If Not initializeHTTP Then Exit Sub
 
    http.Open "GET", strFileURL, False
    If Not ie Is Nothing Then http.SetRequestHeader "Cookie", ie.document.cookie
    http.Send
 
    If http.status = 200 Then
      Set objADOStream = CreateObject("ADODB.Stream")
      objADOStream.Open
      objADOStream.Type = 1 'adTypeBinary
 
      objADOStream.Write http.responsebody
      objADOStream.position = 0    'Set the stream position to the start
 
      Set objfso = CreateObject("Scripting.FileSystemObject")
        If objfso.fileExists(strHDLocation) Then objfso.deleteFile strHDLocation
      Set objfso = Nothing
 
      objADOStream.SaveToFile strHDLocation
      objADOStream.Close
      Set objADOStream = Nothing
    End If
 


End Sub



Function multiReplace(ByVal expression As String, find As String, replacewith As String) As String
  'this function replaces multiple instances of a substing in a string with another string.
  ' it is helpful to change a arbitrary number of the same character to a single character
  ' such as converting all sequential spaces to a single space.
  
  Do While InStr(1, expression, find) > 0
    expression = Replace(expression, find, replacewith)
  Loop
  multiReplace = expression
End Function

Function removeWhiteSpace(theString) As String
Dim t As String
Dim x As Long
Dim onechar As String * 1
For x = 1 To Len(theString)
  onechar = Mid(theString, x, 1)
  If Asc(onechar) > 32 Then
    t = t & onechar
  Else
    t = t & " "
  End If
  
  Do While InStr(1, t, "  ") > 0
    t = Replace(t, "  ", " ")
  Loop
  
Next

removeWhiteSpace = t

End Function


Function replaceTags(theString As String, replaceTagsWith As String) As String
  ' this function replaces any HTML tags with the specified string.
  ' to remove tags, send a zero-length string as the second parameter
  
  Dim retval As String, dataon As Boolean, onechar As String, x As Long
  retval = ""
  dataon = True
  For x = 1 To Len(theString)
    onechar = Mid(theString, x, 1)
    If onechar = "<" Then
      retval = retval & replaceTagsWith
      dataon = False
    ElseIf onechar = ">" Then
      dataon = True
    ElseIf dataon Then
        retval = retval & onechar
    End If

  Next

  replaceTags = retval

End Function

Function getText(theString As String, Optional ignoreCase As Boolean) As String
Dim myPos As Long
  
  If ignoreCase Then
    If ucaseHTML = "" Then ucaseHTML = UCase(theHTML)
    myPos = InStr(pos, ucaseHTML, UCase(theString))
  Else
    myPos = InStr(pos, theHTML, theString)
  End If
  
  If myPos = 0 Then
    getText = ""
  Else
    getText = Mid(theHTML, pos, myPos - pos)
    pos = myPos + Len(theString)
  End If


End Function

Function moveTo(theString As String, Optional ignoreCase As Boolean, Optional ByVal theCount As Integer = 1) As Boolean
    Dim x As Integer
    moveTo = True
    For x = 1 To theCount
      If Not singleMoveTo(theString, ignoreCase) Then
         moveTo = False
         Exit Function
      End If
    Next
End Function

Private Function singleMoveTo(theString As String, Optional ignoreCase As Boolean) As Boolean
  Dim myPos As Long
  If ignoreCase Then
    If ucaseHTML = "" Then ucaseHTML = UCase(theHTML)
    myPos = InStr(pos, ucaseHTML, UCase(theString))
  Else
    myPos = InStr(pos, theHTML, theString)
  End If
  
  If myPos = 0 Then
    singleMoveTo = False
  Else
    singleMoveTo = True
    pos = myPos + Len(theString)
  End If

End Function
Function moveBackTo(theString As String) As Boolean
  Dim myPos As Long
  If ignoreCase Then
    If ucaseHTML = "" Then ucaseHTML = UCase(theHTML)
    myPos = InStrRev(ucaseHTML, UCase(theString), pos) + Len(theString)
  Else
    myPos = InStrRev(theHTML, theString, pos) + Len(theString)
  End If
  
  
    If myPos = Len(theString) Then
      moveBackTo = False
    Else
      pos = myPos
      moveBackTo = True
    End If

End Function


Function followLinkByText(theText As String, Optional exactMatch As Boolean = False) As Boolean
  'clicks the first link that has the specified text in the tag's inntertext
  Dim alink As Variant
  Dim found As Boolean
   
   For Each alink In ie.document.links
     If exactMatch Then
       found = alink.innerhtml = theText
     Else
       found = InStr(1, alink.innerhtml, theText)
     End If
     If found Then
        alink.Click
        waitForLoad
        followLinkByText = True
        Exit Function
     End If
   Next
   
End Function
Function followLinkByHref(theText As String) As Boolean
  'clicks on the first links that has the specified URL

  Dim alink As Variant
  Dim found As Boolean
   
   For Each alink In ie.document.links
     If exactMatch Then
       found = alink.href = theText
     Else
       found = InStr(1, alink.href, theText)
     End If
     If found Then
        alink.Click
        followLinkByHref = True
        waitForLoad
        Exit Function
     End If
   Next
   
End Function


Sub waitForLoad()
  'pauses the exection of the code until the webpage has loaded
  Do
    If Not ie.busy And ie.readystate = 4 Then
      Application.Wait (Now + TimeValue("00:00:02"))
         If Not ie.busy And ie.readystate = 4 Then
            Exit Do
          End If
    End If
    DoEvents
  Loop
  updateHTML

End Sub


Function readFile(path As String) As String
  ' returns the contents of a text file
  Open path For Input As #1
    readFile = Input(LOF(1), #1)
  Close #1
End Function

Private Sub Class_Initialize()
  agentName = "AcademicTeachingAgent 1.0"
  studyURL = "http://gove.net/academicTeachingAgent"
End Sub

Private Sub Class_Terminate()
  terminateIE
End Sub
Public Function attach(URL_of_IE_Window As String) As Boolean
  ' used to attach to an already open IE window.  Requires the url of hte window
  Set ie = get_IE_handle(URL_of_IE_Window)
  If Not ie Is Nothing Then
    attach = True
  End If
  updateHTML
End Function

Private Function get_IE_handle(URL_of_IE_Window As String) As Object
    Dim window As Object
    For Each window In CreateObject("Shell.application").Windows
      Debug.Print window.LocationURL
      If InStr(1, window.LocationURL, URL_of_IE_Window) Then Exit For
    Next
    Set get_IE_handle = window
End Function

Public Sub execScript(javascript As String)
    ie.document.parentwindow.execScript (javascript)
    waitForLoad
End Sub


Function URLEncode(sRawURL As String) As String
 
     Dim iLoop
     Dim sRtn
     Dim sTmp
     Const sValidChars = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz:/._-$(){}~"
 
 
     If Len(sRawURL) > 0 Then
         ' Loop through each char
 
         For iLoop = 1 To Len(sRawURL)
             sTmp = Mid(sRawURL, iLoop, 1)
 
 
             If InStr(1, sValidChars, sTmp, vbBinaryCompare) = 0 Then
                 ' If not ValidChar, convert to HEX and p
                 '     refix with %
                 sTmp = Hex(Asc(sTmp))
 
 
                 If sTmp = "20" Then
                     sTmp = "+"
                 ElseIf Len(sTmp) = 1 Then
                     sTmp = "%0" & sTmp
                 Else
                     sTmp = "%" & sTmp
                 End If
 
             End If
 
             sRtn = sRtn & sTmp
         Next
 
         URLEncode = sRtn
     End If
 'Debug.Print sRtn
 End Function

 
 
Public Function URLDecode(StringToDecode As String) As String

Dim TempAns As String
Dim CurChr As Integer

CurChr = 1

Do Until CurChr - 1 = Len(StringToDecode)
  Select Case Mid(StringToDecode, CurChr, 1)
    Case "+"
      TempAns = TempAns & " "
    Case "%"
      TempAns = TempAns & Chr(val("&h" & _
         Mid(StringToDecode, CurChr + 1, 2)))
       CurChr = CurChr + 2
    Case Else
      TempAns = TempAns & Mid(StringToDecode, CurChr, 1)
  End Select

CurChr = CurChr + 1
Loop

URLDecode = TempAns
End Function
 
 Function HTMLDecode(ByVal html As String) As String
     Dim i As Long
     
     HTMLDecode = html
     
     Do
         ' search the next ampersand, exit if no more
         i = InStr(i + 1, HTMLDecode, "&")
         If i = 0 Then Exit Do
 

         If StrComp(Mid(HTMLDecode, i, 6), "&nbsp;", vbTextCompare) = 0 Then
            HTMLDecode = left(HTMLDecode, i - 1) & " " & Mid(HTMLDecode, i + 6)
         ElseIf StrComp(Mid(HTMLDecode, i, 6), "&quot;", vbTextCompare) = 0 Then
             HTMLDecode = left(HTMLDecode, i - 1) & """" & Mid(HTMLDecode, _
                 i + 6)
         ElseIf StrComp(Mid(HTMLDecode, i, 5), "&amp;", vbTextCompare) = 0 Then
             HTMLDecode = left(HTMLDecode, i - 1) & "&" & Mid(HTMLDecode, _
                 i + 5)
         ElseIf StrComp(Mid(HTMLDecode, i, 4), "&lt;", vbTextCompare) = 0 Then
             HTMLDecode = left(HTMLDecode, i - 1) & "<" & Mid(HTMLDecode, _
                 i + 4)
         ElseIf StrComp(Mid(HTMLDecode, i, 4), "&gt;", vbTextCompare) = 0 Then
             HTMLDecode = left(HTMLDecode, i - 1) & ">" & Mid(HTMLDecode, _
                 i + 4)
         End If
     Loop
 End Function
 
 
 Function HTMLEncode(text As String) As String
     Dim i As Long
     Dim acode As Byte
     Dim repl As String
 
     HTMLEncode = text
 
     For i = Len(HTMLEncode) To 1 Step -1
         acode = Asc(Mid(HTMLEncode, i, 1))
         If acode = 32 Then
                 repl = "&nbsp;"
         ElseIf acode = 34 Then
                 repl = "&quot;"
         ElseIf acode = 38 Then
                 repl = "&amp;"
         ElseIf acode = 60 Then
                 repl = "&lt;"
         ElseIf acode = 62 Then
                 repl = "&gt;"
         ElseIf acode > 32 And acpde < 128 Then
                 ' don't touch alphanumeric chars
         Else
                 repl = "&#" & CStr(acode) & ";"
         End If
         If Len(repl) Then
             HTMLEncode = left(HTMLEncode, i - 1) & repl & Mid(HTMLEncode, i + 1)
             repl = ""
         End If
     Next
 End Function



 Sub AddFormData(theName As String, ByVal theValue As String)
    If formdata > "" Then formdata = formdata & "&"
    formdata = formdata & theName & "=" & URLEncode(theValue)
  End Sub

 
  Sub clearFormData()
    formdata = ""
  End Sub
 
 
 
 
 
 Function postdoc(theURL As String) As Boolean
 
     On Error GoTo 0
     On Error Resume Next
     
     pos = 1
     url = theURL
#If Mac Then
     
          updateHTML MacScript("return do shell script ""/usr/bin/curl -s -S -m 10 -d'" & formdata & "' '" & url & "'""")
     
#Else
         
         If Not initializeHTTP Then Exit Function
         http.Open "POST", theURL, False
         http.SetRequestHeader "Content-Type", "application/x-www-form-urlencoded"
    '     HTTP.setRequestHeader "From", from
         http.SetRequestHeader "User-Agent", agentName & "(" & studyURL & ")"
         If Not ie Is Nothing Then http.SetRequestHeader "Cookie", ie.document.cookie
         
         If referer > "" Then
           http.SetRequestHeader "Referer", referer
         End If
         
         http.Send (formdata)
         
            If Err.number = 0 Then
                theHTML = http.responsetext
            Else  ' this is to to fix the probem that sprouted on 6/16/2018 for Win 7 machines
                Err.Clear
                serverXMLHTTPfailed = True
                Set http = CreateObject("Msxml2.XMLHTTP")
                http.Open "POST", url, False
                http.SetRequestHeader "Content-Type", "application/x-www-form-urlencoded"
                http.Send (formdata)
                theHTML = http.responsetext
            End If
            
#End If
          
     If Err.number = 0 Then postdoc = True
     On Error GoTo 0
     
   End Function

Function postFile(url As String, filepath As String, fileParamName As String, parameters As String, Optional f As frmSubmit, Optional uploadMessage As String) As Boolean
    ' parameters: name1=value1&name2=value2&name3=value3

    Dim strBody As String
    Dim strBoundary As String
    Dim ff As Integer
    Dim temp As String
    Dim lngLength As Long
    Dim data As Variant
    Dim dataPair As Variant
    Dim filename As String
    Dim x As Integer
    Dim response As String
    Dim macPath As String
    Dim curlcommand As String
    data = Split(parameters, "&")
    filename = Mid(filepath, InStrRev(filepath, pathSeparator()) + 1)
    
    
'    Debug.Print parameters
#If Mac Then
      ' post file using curl
      For x = 0 To UBound(data)
        dataPair = Split(data(x), "=")
        If UBound(dataPair) > 0 Then dataPair(1) = URLDecode((dataPair(1)))
        strBody = strBody & " -F \""" & dataPair(0) & "=" & dataPair(1) & "\"""
      Next
      macPath = MacScript("do shell script ""/usr/bin/osascript -e 'quoted form of POSIX path of \""" & filepath & "\""'""")
      macPath = Mid(macPath, 2, Len(macPath) - 2)
      curlcommand = "return do shell script ""/usr/bin/curl -X POST" & strBody & " -F \""" & fileParamName & "=@" & macPath & "\"" " & url & """"
      'Debug.Print curlcommand
      If Not f Is Nothing Then f.update 1, uploadMessage
      response = MacScript(curlcommand)
      postFile = True
      theHTML = response
#Else
      If Not initializeHTTP Then Exit Function
      strBoundary = "----WebKitFormBoundarydxzuWJIaqA3dG3cJ"
      strBody = "--" & strBoundary & vbNewLine
      
      For x = 0 To UBound(data)
        dataPair = Split(data(x), "=")
        If UBound(dataPair) > 0 Then dataPair(1) = URLDecode((dataPair(1)))
        strBody = strBody & "Content-Disposition: form-data; name=""" & dataPair(0) & """" & vbNewLine & vbNewLine & dataPair(1) & vbNewLine & "--" & strBoundary & vbNewLine
      Next
      
    'preparing to add the file.
    
      strBody = strBody & "Content-Disposition: form-data; name=""" & fileParamName & """; filename=""" & filename & """" & vbNewLine
      strBody = strBody & "Content-Type: application/msaccess" & vbNewLine  ' application/msaccess is currently hardcoded.  Need to see if we need diferent value for differnt file types or if a generic value for both access and excel will work
       
      
      ' This line uses the faster way to access and encode the file.  base64 is  the new approach to the encoding.  It reads the file and returns its encoded version
      
      On Error Resume Next
     
       strBody = strBody & vbNewLine & base64(filepath) & vbNewLine & "--" & strBoundary & "--"  ' try the fast encoding
       If Err.number <> 0 Then   ' if fast encoding fails, use slow boat
         Err.Clear
          ff = FreeFile
          Open filepath For Binary Access Read As ff
          'This is line is the way currently do  bring on the encoded file.  It relies on lines to open and read the file with native vba statements
          strBody = strBody & vbNewLine & Encode64(Input$(LOF(ff), #ff)) & vbNewLine & "--" & strBoundary & "--"
          Close ff
          If Err.number <> 0 Then
            postFile = False
            Exit Function
          End If
       End If
      On Error GoTo 0
      
      ' This line  just inserts the bytes of the file unencoded
       'strBody = strBody & vbNewLine & GetFile(filepath) & vbNewLine & "--" & strBoundary & "--"   ' in this line GetFile(filepath) is fast but does not seem to return all the bytes
       'strBody = strBody & vbNewLine & Input$(LOF(ff), #ff) & vbNewLine & "--" & strBoundary & "--" ' here, input$(LOF(ff), #ff) is slow but gets the whole file.  Let's deal with this after we get uploading working
       
    
      lngLength = Len(strBody)
      
      If serverXMLHTTPfailed Then  ' this is to fix the win 7 problem 6-16-2018
        Set http = CreateObject("Msxml2.XMLHTTP")
      End If
      
      http.Open "POST", url, False
      http.SetRequestHeader "Content-Type", "multipart/form-data; boundary=" & strBoundary
      http.SetRequestHeader "Content-Length", lngLength
      If Not f Is Nothing Then f.update 1, uploadMessage

'Debug.Print strBody
      On Error Resume Next
        http.Send (strBody)
         If Err.number = 0 Then postFile = True
         theHTML = http.responsetext
      On Error GoTo 0
#End If
    

End Function


Function base64(strFileName As String)
Dim objStream
Dim objXMLDoc
Dim objDocElem
Dim objSXH


Set objXMLDoc = CreateObject("MSXML2.DOMDocument")
objXMLDoc.LoadXML "<Base64Data />"

'Read the file into the stream
Set objStream = CreateObject("ADODB.Stream")
objStream.Type = 1
objStream.Open
objStream.LoadFromFile strFileName


  Set objDocElem = objXMLDoc.DocumentElement
  objDocElem.DataType = "bin.base64"
  objDocElem.nodeTypedValue = objStream.Read
  objStream.Close

base64 = objXMLDoc.text
End Function



Public Function Encode64(sString As String) As String

    Dim bTrans(63) As Byte, lPowers8(255) As Long, lPowers16(255) As Long, bOut() As Byte, bin() As Byte
    Dim lChar As Long, lTrip As Long, iPad As Integer, lLen As Long, lTemp As Long, lPos As Long, lOutSize As Long

    For lTemp = 0 To 63                                 'Fill the translation table.
        Select Case lTemp
            Case 0 To 25:  bTrans(lTemp) = 65 + lTemp              'A - Z
            Case 26 To 51: bTrans(lTemp) = 71 + lTemp              'a - z
            Case 52 To 61: bTrans(lTemp) = lTemp - 4               '1 - 0
            Case 62:       bTrans(lTemp) = 43                      'Chr(43) = "+"
            Case 63:       bTrans(lTemp) = 47                      'Chr(47) = "/"
        End Select
    Next lTemp

    For lTemp = 0 To 255                                'Fill the 2^8 and 2^16 lookup tables.
        lPowers8(lTemp) = lTemp * 256
        lPowers16(lTemp) = lTemp * 65536
    Next lTemp

    iPad = Len(sString) Mod 3                           'See if the length is divisible by 3
    If iPad Then                                        'If not, figure out the end pad and resize the input.
        iPad = 3 - iPad
        sString = sString & String(iPad, Chr(0))
    End If

    bin = StrConv(sString, vbFromUnicode)               'Load the input string.
    lLen = ((UBound(bin) + 1) \ 3) * 4                  'Length of resulting string.
    lTemp = lLen \ 72                                   'Added space for vbnewlines.
    lOutSize = ((lTemp * 2) + lLen) - 1                 'Calculate the size of the output buffer.
    ReDim bOut(lOutSize)                                'Make the output buffer.

    lLen = 0                                            'Reusing this one, so reset it.

    For lChar = LBound(bin) To UBound(bin) Step 3
        lTrip = lPowers16(bin(lChar)) + lPowers8(bin(lChar + 1)) + bin(lChar + 2)    'Combine the 3 bytes
        lTemp = lTrip And 16515072                     'Mask for the first 6 bits
        bOut(lPos) = bTrans(lTemp \ 262144)           'Shift it down to the low 6 bits and get the value
        lTemp = lTrip And 258048                     'Mask for the second set.
        bOut(lPos + 1) = bTrans(lTemp \ 4096)       'Shift it down and translate.
        lTemp = lTrip And 4032                   'Mask for the third set.
        bOut(lPos + 2) = bTrans(lTemp \ 64)        'Shift it down and translate.
        bOut(lPos + 3) = bTrans(lTrip And 63)   'Mask for the low set.
        If lLen = 68 Then                               'Ready for a newline
            bOut(lPos + 4) = 13                         'Chr(13) = vbCr
            bOut(lPos + 5) = 10                         'Chr(10) = vbLf
            lLen = 0                                    'Reset the counter
            lPos = lPos + 6
        Else
            lLen = lLen + 4
            lPos = lPos + 4
        End If
    Next lChar

    If bOut(lOutSize) = 10 Then lOutSize = lOutSize - 2 'Shift the padding chars down if it ends with CrLf.

    If iPad = 1 Then                                    'Add the padding chars if any.
        bOut(lOutSize) = 61                             'Chr(61) = "="
    ElseIf iPad = 2 Then
        bOut(lOutSize) = 61
        bOut(lOutSize - 1) = 61
    End If

    Encode64 = StrConv(bOut, vbUnicode)                 'Convert back to a string and return it.

End Function

Public Function Decode64(sString As String) As String

    Dim bOut() As Byte, bin() As Byte, bTrans(255) As Byte, lPowers6(63) As Long, lPowers12(63) As Long
    Dim lPowers18(63) As Long, lQuad As Long, iPad As Integer, lChar As Long, lPos As Long, sOut As String
    Dim lTemp As Long

    sString = Replace(sString, vbCr, vbNullString)      'Get rid of the vbnewlines.  These could be in...
    sString = Replace(sString, vbLf, vbNullString)      'either order.

    lTemp = Len(sString) Mod 4                          'Test for valid input.
    If lTemp Then
        Call Err.Raise(vbObjectError, "MyDecode", "Input string is not valid Base64.")
    End If

    If InStrRev(sString, "==") Then                     'InStrRev is faster when you know it's at the end.
        iPad = 2                                        'Note:  These translate to 0, so you can leave them...
    ElseIf InStrRev(sString, "=") Then                  'in the string and just resize the output.
        iPad = 1
    End If

    For lTemp = 0 To 255                                'Fill the translation table.
        Select Case lTemp
            Case 65 To 90
                bTrans(lTemp) = lTemp - 65              'A - Z
            Case 97 To 122
                bTrans(lTemp) = lTemp - 71              'a - z
            Case 48 To 57
                bTrans(lTemp) = lTemp + 4               '1 - 0
            Case 43
                bTrans(lTemp) = 62                      'Chr(43) = "+"
            Case 47
                bTrans(lTemp) = 63                      'Chr(47) = "/"
        End Select
    Next lTemp

    For lTemp = 0 To 63                                 'Fill the 2^6, 2^12, and 2^18 lookup tables.
        lPowers6(lTemp) = lTemp * 64
        lPowers12(lTemp) = lTemp * 4096
        lPowers18(lTemp) = lTemp * 262144
    Next lTemp

    bin = StrConv(sString, vbFromUnicode)               'Load the input byte array.
    ReDim bOut((((UBound(bin) + 1) \ 4) * 3) - 1)       'Prepare the output buffer.

    For lChar = 0 To UBound(bin) Step 4
        lQuad = lPowers18(bTrans(bin(lChar))) + lPowers12(bTrans(bin(lChar + 1))) + _
                lPowers6(bTrans(bin(lChar + 2))) + bTrans(bin(lChar + 3))           'Rebuild the bits.
        lTemp = lQuad And 16711680                    'Mask for the first byte
        bOut(lPos) = lTemp \ 65536                   'Shift it down
        lTemp = lQuad And 65280                     'Mask for the second byte
        bOut(lPos + 1) = lTemp \ 256                'Shift it down
        bOut(lPos + 2) = lQuad And 255            'Mask for the third byte
        lPos = lPos + 3
    Next lChar

    sOut = StrConv(bOut, vbUnicode)                     'Convert back to a string.
    If iPad Then sOut = left$(sOut, Len(sOut) - iPad)   'Chop off any extra bytes.
    Decode64 = sOut

End Function









Attribute VB_Name = "assignment"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------
'  Last Updated: 6/23/16  7:31pm
'---------------------------------------------------------------


Option Explicit

Private localDataChanged As Boolean



' variables that must be populated for an assignment to be valid
Private localTitle As String
Private localStudentBookName As String
Private localAssignmentID As Integer
Private localGUID As String
Private localCourseName As String
Private localSchool As String
Private localApplicationSpecificData As String
Private localPlatform As String
Private localVersion As String
Private localSubmissionType As String 'practice,graded,minimum score indicating competency
Private localBeenScored As Boolean ' flag to tell if an assignment has been scored

' variables that do not need to be populated on assignment creation
Private studentColor As String
Public taskSets As New Collection
Public instructions As New Collection
Public keyProcs As New Collection
Public dataFields As New Collection



Public Property Get title() As String:                      title = localTitle:                                     End Property
Public Property Get guid() As String:                      guid = localGUID:                                     End Property
Public Property Get studentBookName() As String:            studentBookName = localStudentBookName:                 End Property
Public Property Get assignmentID() As Integer:              assignmentID = localAssignmentID:                       End Property
Public Property Get courseName() As String:                 courseName = localCourseName:                           End Property
Public Property Get school() As String:                     school = localSchool:                                   End Property
Public Property Get applicationSpecificData() As String:    applicationSpecificData = localApplicationSpecificData: End Property
Public Property Get platform() As String:                   platform = localPlatform:                               End Property
Public Property Get version() As String:                    version = localVersion:                                 End Property
Public Property Get submissionType() As String:             submissionType = localSubmissionType:                   End Property
Public Property Get beenScored() As Boolean:                beenScored = localBeenScored:                           End Property

Public Property Let title(theData As String):                      localTitle = theData:                   localDataChanged = True: End Property
Public Property Let guid(theData As String):                      localGUID = theData:                   localDataChanged = True: End Property
Public Property Let studentBookName(theData As String):            localStudentBookName = theData:         localDataChanged = True: End Property
Public Property Let assignmentID(theData As Integer):              localAssignmentID = theData:            localDataChanged = True: End Property
Public Property Let courseName(theData As String):                 localCourseName = theData:              localDataChanged = True: End Property
Public Property Let school(theData As String):                     localSchool = theData:                  localDataChanged = True: End Property
Public Property Let applicationSpecificData(theData As String):    localApplicationSpecificData = theData: localDataChanged = True: End Property
Public Property Let platform(theData As String):                   localPlatform = theData:                localDataChanged = True: End Property
Public Property Let version(theData As String):                    localVersion = theData:                 localDataChanged = True: End Property
Public Property Let submissionType(theData As String):             localSubmissionType = theData:          localDataChanged = True: End Property
Public Property Get ruleCount() As Long
  Dim s As taskSet
  Dim total As Long
  For Each s In taskSets
    total = total + s.ruleCount
  Next
  ruleCount = total
End Property
Public Property Get DataChanged() As Boolean
  Dim i As instruction
  Dim e As process
  Dim s As taskSet
  DataChanged = localDataChanged
  For Each s In taskSets
    If s.DataChanged Then
      DataChanged = True
      Exit Function
    End If
  Next
  For Each i In instructions
    If i.DataChanged Then
      DataChanged = True
      Exit Function
    End If
  Next
  For Each e In keyProcs
    If e.DataChanged Then
      DataChanged = True
      Exit Function
    End If
  Next
End Property
Public Property Let DataChanged(theData As Boolean)
  Dim s As taskSet
  Dim i As instruction
  Dim e As process

  localDataChanged = theData
  If theData = False Then
    For Each s In taskSets
      s.DataChanged = False
    Next
    For Each i In instructions
      i.DataChanged = False
    Next
    
    For Each e In keyProcs
      e.DataChanged = False
    Next
    
  End If
End Property
Sub setProperty(propertyName As String, value As Variant)
  Select Case LCase(propertyName)
    Case "version": localVersion = value
    Case "title": localTitle = value
    Case "studentbookname": localStudentBookName = value
    Case "platform": localPlatform = value
    Case "submissiontype": localSubmissionType = value
    Case "applicationspecificdata": localApplicationSpecificData = value
    Case "guid": localGUID = value
  End Select
  localDataChanged = True
End Sub


Public Function addInstruction(Optional id As String, Optional text As String = "some text", Optional textcolor As Long) As instruction
  instructions.Add New instruction
  instructions(instructions.count).setProperty "id", id
  instructions(instructions.count).setProperty "text", text
  instructions(instructions.count).setProperty "textcolor", textcolor
  Set addInstruction = instructions(instructions.count)
End Function
Public Function addTaskSet(Optional id As String, Optional title As String = "some title", Optional text As String = "some text") As taskSet
  taskSets.Add New taskSet
  taskSets(taskSets.count).setProperty "id", id
  taskSets(taskSets.count).setProperty "title", title
  taskSets(taskSets.count).setProperty "text", text
  Set addTaskSet = taskSets(taskSets.count)
End Function
Public Function addKeyProcess(Optional id As String, Optional procName As String = "some procName", Optional paramList As String = "|") As process
'Stop
  keyProcs.Add New process
  keyProcs(keyProcs.count).setProperty "id", id
  keyProcs(keyProcs.count).setProperty "ProcedureName", procName
  keyProcs(keyProcs.count).setProperty "paramList", paramList
  Set addKeyProcess = keyProcs(keyProcs.count)
End Function

Public Sub processKeyProcs()
  Dim p As process
  For Each p In keyProcs
    p.executeProc
  Next
End Sub

Public Property Get pointsPossible() As Single
  Dim t As taskSet
  Dim c As Single
  For Each t In taskSets
    c = c + t.pointsPossible
  Next
  pointsPossible = ((c * 1000) \ 1) / 1000
End Property

Public Property Get pointsEarned() As Single
  Dim t As taskSet
  Dim c As Single
  For Each t In taskSets
    c = c + t.pointsEarned
  Next
  pointsEarned = ((c * 1000) \ 1) / 1000
End Property

Public Property Get taskCount() As Integer
  Dim t As taskSet
  Dim c As Integer
  For Each t In taskSets
    c = c + t.taskCount
  Next
  taskCount = c
End Property



'===========================================================================================
'    Methods
'===========================================================================================



Sub addIDs()

  Dim s As taskSet
  Dim t As task
  Dim r As rule
  Dim i As instruction
  Dim p As fill
  Dim e As process
  
  For Each i In instructions
    If i.id = "" Or IsNumeric(i.id) Then i.id = newID()
  Next
  For Each s In taskSets
    If s.id = "" Or IsNumeric(s.id) Then s.id = newID()
    For Each t In s.tasks
      If t.id = "" Or IsNumeric(t.id) Then t.id = newID()
      For Each r In t.rules
        If r.id = "" Or IsNumeric(r.id) Then r.id = newID()
        For Each p In r.preFills
          If p.id = "" Or IsNumeric(p.id) Then p.id = newID()
        Next
        For Each e In r.preProcs
          If e.id = "" Or IsNumeric(e.id) Then e.id = newID()
        Next
      Next
    Next
  Next


End Sub

Function newID() As String
  Const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
  Dim temp As String * 5
  Randomize
  Do
    temp = Mid(alphabet, ((Rnd * 51) \ 1) + 1, 1) & Mid(alphabet, ((Rnd * 51) \ 1) + 1, 1) & Mid(alphabet, ((Rnd * 51) \ 1) + 1, 1) & Mid(alphabet, ((Rnd * 51) \ 1) + 1, 1) & Mid(alphabet, ((Rnd * 51) \ 1) + 1, 1)
  Loop While idExists(temp)
  newID = temp
End Function


Function idExists(id As String) As Boolean
  Dim s As taskSet
  Dim t As task
  Dim r As rule
  Dim i As instruction
  Dim p As fill
  Dim e As process
  
  idExists = True
  For Each i In instructions
    If i.id = id Then Exit Function
  Next
  For Each s In taskSets
    If s.id = id Then Exit Function
    For Each t In s.tasks
      If t.id = id Then Exit Function
      For Each r In t.rules
        If r.id = id Then Exit Function
        For Each p In r.preFills
          If p.id = id Then Exit Function
        Next
        For Each e In r.preProcs
          If e.id = id Then Exit Function
        Next
      Next
    Next
  Next


  idExists = False
End Function
Function toJson(Optional addFilename As Boolean) As String
  Dim json As New jsonParser
  Dim js As String
  
  Dim s As taskSet
  Dim t As task
  Dim r As rule
  Dim i As instruction
  Dim p As fill
  Dim e As process
  
  
  Dim sd As Dictionary
  Dim td As Dictionary
  Dim rd As Dictionary
  Dim pd As Dictionary
  Dim ed As Dictionary
  
  Dim ad As New Dictionary
  
  ad.Add "version", localVersion
  ad.Add "title", localTitle
  If addFilename Then
    'this is to give a bit of room for additional values to be added in the file creation process at myEducator
    ad.Add "fileame", "xxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxxXxxxxxxxxx"
  End If
  
  ad.Add "studentBookName", localStudentBookName
  ad.Add "platform", localPlatform
  ad.Add "submissionType", localSubmissionType
  ad.Add "applicationSpecificData", localApplicationSpecificData
  ad.Add "guid", localGUID
  
  ad.Add "keyprocs", New Collection
  For Each e In keyProcs
      Set ed = New Dictionary
      ad.item("keyprocs").Add ed
      ed.Add "id", e.id
      ed.Add "procedure", e.ProcedureName
      ed.Add "params", e.paramList
  Next
  ad.Add "instructions", New Collection
  For Each i In instructions
    Set sd = New Dictionary
    ad.item("instructions").Add sd
    sd.Add "id", i.id
    sd.Add "text", i.text
    sd.Add "color", i.textcolor
  Next
  ad.Add "tasksets", New Collection
  For Each s In taskSets
    Set sd = New Dictionary
    ad.item("tasksets").Add sd
    sd.Add "id", s.id
    sd.Add "title", s.title
    sd.Add "text", s.text
    sd.Add "tasks", New Collection
     For Each t In s.tasks
       Set td = New Dictionary
       sd.item("tasks").Add td
       td.Add "id", t.id
       td.Add "name", t.name
       td.Add "text", t.text
       If t.hint > "" Then td.Add "hint", t.hint
       If t.exhibit > "" Then td.Add "exhibit", t.exhibit
       If t.xmlID > "" Then td.Add "xmlid", t.xmlID
       If t.note > "" Then td.Add "note", t.note
       If t.feedback > "" Then td.Add "feedback", t.feedback
       If t.responseFormula > "" Then td.Add "ResponseFormula", t.responseFormula
       td.Add "rules", New Collection
       For Each r In t.rules
         Set rd = New Dictionary
         td.item("rules").Add rd
         rd.Add "id", r.id
         rd.Add "name", r.name
         rd.Add "points", r.points
         rd.Add "formula", r.ruleFormula
         rd.Add "message", r.errorMessage
         If r.preFills.count > 0 Then
           rd.Add "prefills", New Collection
           For Each p In r.preFills
             Set pd = New Dictionary
             rd.item("prefills").Add pd
             pd.Add "id", p.id
             pd.Add "params", p.paramList
             pd.Add "revert", p.revert
           Next
         End If
         If r.preProcs.count > 0 Then
           rd.Add "preprocs", New Collection
           For Each e In r.preProcs
             Set ed = New Dictionary
             rd.item("preprocs").Add ed
             ed.Add "id", e.id
             ed.Add "procedure", e.ProcedureName
             ed.Add "params", e.paramList
           Next
         End If
       Next
     Next
     'Stop
  Next
  toJson = json.toString(ad)
End Function

Sub build_office_js_task_Guides(path As String)
  Dim json As New jsonParser
  Dim js As String
  
  Dim s As taskSet
  Dim t As task
  Dim r As rule
  Dim i As instruction
  Dim p As fill
  Dim e As process
  
  
  Dim sd As Dictionary
  Dim td As Dictionary
  Dim rd As Dictionary
  Dim pd As Dictionary
  Dim ed As Dictionary
  
  Dim ad As New Dictionary
  
  ad.Add "version", localVersion
  ad.Add "title", localTitle
  
  ad.Add "studentBookName", localStudentBookName
  ad.Add "platform", localPlatform
  ad.Add "submissionType", localSubmissionType
  ad.Add "applicationSpecificData", localApplicationSpecificData
  ad.Add "guid", localGUID
  
  ad.Add "keyprocs", New Collection
  For Each e In keyProcs
      Set ed = New Dictionary
      ad.item("keyprocs").Add ed
      ed.Add "id", e.id
      ed.Add "procedure", e.ProcedureName
      ed.Add "params", e.paramList
  Next
  ad.Add "instructions", New Collection
  For Each i In instructions
    Set sd = New Dictionary
    ad.item("instructions").Add sd
    sd.Add "id", i.id
    sd.Add "text", i.text
    sd.Add "color", i.textcolor
  Next
  ad.Add "tasksets", New Collection
  For Each s In taskSets
    Set sd = New Dictionary
    ad.item("tasksets").Add sd
    sd.Add "id", s.id
    sd.Add "title", s.title
    sd.Add "text", s.text
    sd.Add "tasks", New Collection
     For Each t In s.tasks
       Set td = New Dictionary
       sd.item("tasks").Add td
       td.Add "id", t.id
       td.Add "name", t.name
       td.Add "text", t.text
       If t.hint > "" Then td.Add "hint", t.hint
       If t.exhibit > "" Then td.Add "exhibit", t.exhibit
       If t.xmlID > "" Then td.Add "xmlid", t.xmlID
       If t.note > "" Then td.Add "note", t.note
       If t.feedback > "" Then td.Add "feedback", t.feedback
       If t.responseFormula > "" Then td.Add "ResponseFormula", t.responseFormula
     Next
  Open path & "\" & Trim(s.title) & ".json" For Output As #1
    Print #1, json.toString(sd)
  Close #1
  Next
  
End Sub



Sub clearModel()

Do While instructions.count > 0
  instructions.Remove 1
Loop

Do While taskSets.count > 0
    Do While taskSets(1).tasks.count > 0
        Do While taskSets(1).tasks(1).rules.count > 0
          Do While taskSets(1).tasks(1).rules(1).preFills.count > 0
            taskSets(1).tasks(1).rules(1).preFills.Remove 1
          Loop
          Do While taskSets(1).tasks(1).rules(1).preProcs.count > 0
            taskSets(1).tasks(1).rules(1).preProcs.Remove 1
          Loop
          taskSets(1).tasks(1).rules.Remove 1
        Loop
        taskSets(1).tasks.Remove (1)
    Loop
    taskSets.Remove 1
Loop


End Sub

Sub clearRules(clearPrefills As Boolean)
Dim s As taskSet
Dim t As task
Dim subObjectCount As Integer

For Each s In taskSets
  If s.title <> "precheck" Or clearPrefills Then
    For Each t In s.tasks
        Do While t.rules.count > 0
          subObjectCount = 0
          On Error Resume Next
            subObjectCount = t.rules(1).preFills.count
          On Error GoTo 0
          If subObjectCount > 0 Then
            Do While t.rules(1).preFills.count > 0
              t.rules(1).preFills.Remove 1
            Loop
          End If
          
          subObjectCount = 0
          On Error Resume Next
            subObjectCount = t.rules(1).preProcs.count
          On Error GoTo 0
          
          If subObjectCount > 0 Then
            Do While t.rules(1).preProcs.count > 0
              t.rules(1).preProcs.Remove 1
            Loop
          End If
          
         t.rules.Remove 1
        Loop
    Next
  End If
Next


End Sub





Sub saveModel(Optional ByVal location As String = "KeyValue", Optional resetProperties As Boolean)
' location:
'  KeyValue-> save in the current assingment using the the methods in ModKeyValue
'  file -> save as encoded textfile and infer the path from the location of the current office document
'  [path to save] save as encoded textfile

 Dim x As Long
 Dim s As taskSet
 Dim t As task
 Dim r As rule
 Dim i As instruction
 Dim p As fill
 Dim e As process
  ' variables to remember properties
  Dim data As Variant
  
addIDs

If location = "KeyValue" Then

  If Not resetProperties Then
    data = getPropertyString()
  End If

  DeleteAllCustomProperties
  putNewValue "assignmentLine", "EMPTY"
  putNewValue "firstLogLine", "EMPTY"
  putNewValue "firstUploadPropLine", "EMPTY"
  putNewValue "firstDownloadPropLine", "EMPTY"
  putNewValue "firstLocalLine", "EMPTY"
  
  updateValue "firstUploadPropLine", CStr(propertyCount() + 1)
  putNewValue "clearRules", "true"
  
    Select Case LCase(platform)
      Case "excel vba"
          putNewValue "uploadedBy", "openAccess" ' name of the the person who uploaded the original assignment file
      Case Else:
          putNewValue "uploadedBy", "___Uploaded By___" ' name of the the person who uploaded the original assignment file
    End Select
    
    putNewValue "questionBatchID", "___Question Batch ID___"
    putNewValue "timeAssignmentUploaded", "___Time Uploaded___"
  
  updateValue "firstDownloadPropLine", CStr(propertyCount() + 1)
    putNewValue "courseID", "___Course ID___"
    putNewValue "activityID", "___Activity ID___"
    putNewValue "accountability", "___Color Code___"
    putNewValue "timeDownloaded", "___Time Downloaded___"
    putNewValue "downloadedByName", "___Downloaded By Name___"
    putNewValue "downloadedByEmail", "___Downloaded By Email___"
    putNewValue "downloadedByUserID", "___Downloaded By UserID___"
    putNewValue "accessToken", "EMPTY" ' used to know if we will ask for a password or use this access token to authenticate, deprecated
    putNewValue "prophylactic", "EMPTY"
    'next 4 properties are used for securing exams
    putNewValue "token", "EMPTY"
    putNewValue "authType", "email"  ' shold be email or token.  this is to stand in place of access token
    putNewValue "lockWhenNotAvailable", "false"
    putNewValue "encryptAfterSubmission", "false"
  
  updateValue "firstLocalLine", CStr(propertyCount() + 1)
    putNewValue "assignmentType", "graded"
    putNewValue "fileName", filename()
    putNewValue "atlasVersion", "1.31"
    putNewValue "timeAssignmentCreated", Now()
    putNewValue "recentTool", "EMPTY"
    putNewValue "completeTasks", "|"
    putNewValue "assignmentCreator", Environ$("username")
    putNewValue "authEmail", "EMPTY"
    putNewValue "userType", "EMPTY"
    putNewValue "submissionID", "EMPTY"
    putNewValue "submissionEndTime", "EMPTY"
    putNewValue "submissionStudentName", "EMPTY"
    putNewValue "submissionStudentLink", "EMPTY"
    putNewValue "clockOffset", "EMPTY"
    putNewValue "scoreCode", "EMPTY"
    putNewValue "hash", "EMPTY"
    putNewValue "dateOpenedMac", "EMPTY"
    putNewValue "dateOpenedWin", "EMPTY"
    putNewValue "lateDeduction", "EMPTY"
    putNewValue "debug", "EMPTY"
  
    
    
    updateValue "assignmentLine", CStr(propertyCount() + 1)
    putNewValue "assignment", toJson(True)
'    putNewValue "workingSpace", "This is just to give an extra line for the assingment to grow during the uplod process"
  updateValue "firstLogLine", CStr(propertyCount() + 1)
    ' need to read download properties to make the first log entry: download time, downloaded by
    ' should make the entry when the workbook is first opened.  Check the dateOpenedWin and dateOpenedMac properties
    
  If Not resetProperties Then
    data = Split(Mid(data, 2), Chr(31))
    For x = LBound(data) To UBound(data)
      updateValue CStr(Split(data(x), Chr(30))(0)), CStr(Split(data(x), Chr(30))(1))
    Next
  End If
    
Else
   ' save as a text file at the path specified in location
   If location = "file" Then location = writePath & pathSeparator & "assignment.json"
   writeToFile location, toJson
End If


End Sub


Sub saveModules(path As String)
' used to create initial modules for use in office js addin

   ' save as a text file at the path specified in location
   If location = "file" Then location = writePath & pathSeparator & "assignment.json"
   writeToFile location, toJson

End Sub



Sub loadModelFromFile(Optional ByVal filepath As String)
  If filepath = "" Then filepath = writePath & pathSeparator & "assignment.json"
  loadModel (getFileContents(filepath))
End Sub

Sub loadModel(Optional ByVal jsonString As String)
' if jsonstring is not supplied, this sub will read the string from the document properties


 Dim s As taskSet
 Dim t As task
 Dim r As rule
 Dim f As fill
 Dim p As process

 Dim completeTasks As String
 
 Dim ad As Dictionary
 Dim json As New jsonParser
 
 
Dim td As Dictionary
Dim sd As Dictionary
Dim rd As Dictionary
Dim pd As Dictionary
 
 completeTasks = getValue("completeTasks")
 clearModel

 If jsonString = "" Then jsonString = getAssignmentFromProperties()

 Set ad = json.parse(jsonString)
 
  localTitle = ad.GetItem("title", "")
  localStudentBookName = ad.GetItem("studentBookName", "")
  localApplicationSpecificData = ad.GetItem("applicationSpecificData", "")
  localPlatform = ad.GetItem("platform", "")
  localVersion = ad.GetItem("version", "")
  localSubmissionType = ad.GetItem("submissionType", "")
  localGUID = ad.GetItem("guid", "")
  
 For Each pd In ad.item("keyprocs")
    addKeyProcess pd.GetItem("id", ""), pd.GetItem("procedure", ""), pd.GetItem("params", False)
 Next
 For Each sd In ad.item("instructions")
   addInstruction sd.GetItem("id", ""), sd.GetItem("text", ""), sd.GetItem("textcolor", 0)
 Next
 For Each sd In ad.item("tasksets")
   Set s = addTaskSet(sd.GetItem("id", ""), sd.GetItem("title", ""), sd.GetItem("text", ""))
   For Each td In sd.item("tasks")
'     Set t = s.addTask(td.GetItem("id", ""), td.GetItem("name", ""), td.GetItem("text", ""), td.GetItem("hint", ""), td.GetItem("exhibit", ""), td.GetItem("xmlid", ""), td.GetItem("feedback", ""), td.GetItem("responseFormula", ""))
     ' late august 2016, an update to Excel for Mac caused the above line to stop working.
     s.tasks.Add New task
     Set t = s.tasks(s.tasks.count)
     t.id = td.GetItem("id", "")
     t.name = td.GetItem("name", "")
     t.text = td.GetItem("text", "")
     t.hint = td.GetItem("hint", "")
     t.exhibit = td.GetItem("exhibit", "")
     t.xmlID = td.GetItem("xmlid", "")
     t.feedback = td.GetItem("feedback", "")
     t.responseFormula = td.GetItem("responseFormula", "")
     
     t.note = td.GetItem("note", "")

     If InStr(1, completeTasks, "|" & t.id & "|") Then t.complete = True
     For Each rd In td.item("rules")
       't.addRule rd.GetItem("id", ""), rd.GetItem("name", ""), rd.GetItem("points", 0), rd.GetItem("formula", ""), rd.GetItem("message", "")
       ' late august 2016, an update to Excel for Mac caused the above line to stop working.
       t.rules.Add New rule
       Set r = t.rules(t.rules.count)
       r.id = rd.GetItem("id", "")
       r.name = rd.GetItem("name", "")
       r.points = rd.GetItem("points", 0)
       r.ruleFormula = rd.GetItem("formula", "")
       r.errorMessage = rd.GetItem("message", "")
 
       If rd.Exists("prefills") Then
        For Each pd In rd.item("prefills")
          r.addPreFill pd.GetItem("id", ""), pd.GetItem("params", ""), pd.GetItem("revert", False)
        Next
       End If
       If rd.Exists("preprocs") Then
        For Each pd In rd.item("preprocs")
          Debug.Print pd.GetItem("procedure", ""), pd.GetItem("params", False)
          r.addPreProcess pd.GetItem("id", ""), pd.GetItem("procedure", ""), pd.GetItem("params", False)
        Next
       End If
     Next
   Next
 Next
    
addIDs

End Sub





Public Property Get ScoreCode() As String
  ScoreCode = getScoreCode
End Property
Function getScoreCode() As String

  Dim gradeCode As String
  Dim binstring As String
  Dim oneByte As String
  Dim ncode As Byte
  Dim x As Integer
  Dim s As taskSet
  Dim t As task
  Dim r As rule
  
  
  For Each s In taskSets
    If s.title <> "precheck" Then ' skip if it's a precheck
      For Each t In s.tasks
        For Each r In t.rules
          binstring = binstring + CStr(Int(Abs(r.correct)))
        Next
      Next
    End If ' skip if it's a precheck
  Next
  ''debug.print binString
  For x = 1 To Len(binstring) Step 6
    oneByte = left(binstring & "00000", 6)
    binstring = Mid(binstring, 7)
    gradeCode = gradeCode & Chr(BinaryToDecimal(oneByte) + 59)
  Next
  getScoreCode = gradeCode
End Function
Sub addVolitile(a As agent)

  a.AddFormData "rubricVersion", localVersion
  a.AddFormData "feedback", buildAssignmentBody(Me, True)
  a.AddFormData "pointsEarned", pointsEarned
  a.AddFormData "scoreCode", ScoreCode

End Sub



Public Function BinaryToDecimal(Binary As String) As Long
Dim n As Long
Dim s As Integer

    For s = 1 To Len(Binary)
        n = n + (Mid(Binary, Len(Binary) - s + 1, 1) * (2 ^ _
            (s - 1)))
    Next s

    BinaryToDecimal = n
End Function

Public Function DecimalToBinary(DecimalNum As Long) As String
Dim tmp As String
Dim n As Long

    n = DecimalNum

    tmp = Trim(str(n Mod 2))
    n = n \ 2

    Do While n <> 0
        tmp = Trim(str(n Mod 2)) & tmp
        n = n \ 2
    Loop

    DecimalToBinary = tmp
End Function




Public Sub score(Optional ByVal ScoreCode As String, Optional f As frmSubmit)
  ' a ScoreCode is an encoded string that indicates which rules were right and wrong for this assignment
  ' it is generated by the get property named  "scoreCode"
  ' if suplied, this procedure sets the correc and incorrect based on the code, not on the worksheet
  
  Dim s As taskSet
  Dim t As task
  Dim r As rule
  Dim p As fill
  Dim e As process
  Dim result As Variant
  Dim x As Integer
  Dim binstring As String
  
  buildLanguage
  
  If Not f Is Nothing Then f.update 10, "Evaluating performance"
  preScore  ' run any code that needs to be run every time w score something.  This was introduced for Access to do a resetInformationSchema
  
  localBeenScored = True
  For x = 1 To Len(ScoreCode)
    binstring = binstring & Right("00000" & DecimalToBinary(Asc(left(ScoreCode, 1)) - 59), 6)
    ScoreCode = Mid(ScoreCode, 2)
  Next
  
  x = 0
'  submissionTime = Now
suspendlogging = True
  For Each s In taskSets
    If s.title <> "precheck" Then ' skip if it's a precheck
      For Each t In s.tasks
      
       ' on August 13, 2018, Microsoft released a Mac version of Excel that caused activecell.parent.name to fail with a runtime error
       ' attempts to code around the problem in met with only limit success so we are disabling response formulas when the bug is
       ' present.  This should be verified in future releases to see if bug still exists
       

        t.processResponseFormula
        
        For Each r In t.rules
          x = x + 1
          If binstring > "" Then ' this means a ScoreCode was passed in, use it to assign correctness
            r.correct = CBool(Mid(binstring, x, 1))
          Else
            r.process ' proces the rule
            'For Each e In r.preProcs: e.executeProc: Next
            'For Each p In r.preFills: p.process: Next
            'evaluateRuleFormula r
            'For Each p In r.preFills: p.restore: Next
          End If
        Next
      Next
    End If ' skip if it's a precheck
  Next
 ' submissionID = GetSubmissionID
 postScore ' clean up as needed
 suspendlogging = False
End Sub




Function passPrecheck() As String
  Dim s As taskSet
  Dim t As task
  Dim r As rule
  Dim p As fill
  Dim result As Variant
  Dim Message As String
  Dim x As Integer
  For Each s In taskSets
    If s.title = "precheck" Then  ' process if it's a precheck
      For Each t In s.tasks
        For Each r In t.rules
          For Each p In r.preFills: p.process: Next
          r.process
          If Abs(r.correct) < 1 Then
            ' a precheck has failed
            x = x + 1
            Message = Message & vbNewLine & x & ". " & r.errorMessage
          End If
          
          For Each p In r.preFills: p.restore: Next
        Next
      Next
    End If ' process if it's a precheck
  Next
  Select Case x
    Case 0: passPrecheck = ""
    Case 1: passPrecheck = "Before submitting, the system made a few checks and found the following issue:" & vbNewLine & vbNewLine & Mid(Message, 4 + Len(vbNewLine)) & vbNewLine & vbNewLine & "Do you want to submit anyway?"
    Case Else: passPrecheck = "Before submitting, the system made a few checks and found the following " & x & " issues:" & vbNewLine & Message & vbNewLine & vbNewLine & "Do you want to submit anyway?"
  End Select

End Function


Function submitx(f As frmSubmit) As Boolean
End Function



Sub downloadRules(f As frmSubmit, email As String, password As String)
  Dim activityID As String
  Dim courseID As String
  Dim a As New agent
  Dim data As Variant
  Dim line As Variant
  Dim x As Long
  Dim y As Long
  Dim r As rule
  Dim t As task
  Dim submissionID As String
'  Dim firstname As String
'  Dim lastname As String
  Dim s As taskSet
  Dim p As fill
  Dim e As process
  Dim json As New jsonParser
  Dim response As Dictionary
  Dim str1 As String
  Dim localtime1 As Double
  Dim localtime2 As Double
  Dim serverTime1 As Double
  Dim serverTime2 As Double
  Dim pd As Dictionary
  Dim rd As Dictionary
  Dim serverResponseRecognized As Boolean
  
  If taskSets.count = 0 Then loadModel
  
  
    'f.update -10, "Verifying Credentials"
    updateValue "authEmail", email
    
    activityID = getValue("activityID")
    courseID = getValue("courseID")
    
    a.clearFormData
    a.AddFormData "activityid", activityID
    a.AddFormData "courseid", courseID
    a.AddFormData "question_batch_id", getValue("questionBatchID")  ' injected by ME to handle when there are two differnt student files that could apply to the same activity
    a.AddFormData "client_id", getValue("downloadedByUserID")
    If getValue("accessToken") <> "EMPTY" Then
      a.AddFormData "access_token", getValue("accessToken")
    Else
      a.AddFormData "auth_email", email
      a.AddFormData "auth_password", password
    End If
    
    localtime1 = Now()
    
    If Not a.postdoc(domain & pathForAuthentication) Then
      f.update 1, "Unable to contact server."
      MsgBox "There was a problem with your submission.  Check to be sure that you have a valid Internet connection and try again.  If this problem persists, contact your instructor.", vbCritical, "Submission Failed"
      Exit Sub
    End If
    localtime2 = Now
    
    Set response = json.parse(a.text)
    serverResponseRecognized = False
    On Error Resume Next
      serverResponseRecognized = response.Exists("status")
    On Error GoTo 0
    
    If serverResponseRecognized Then
      Select Case response.item("status")
        Case "success"
          serverTime1 = CDbl(response.item("time1")) / 86400000 + 25569
          serverTime2 = CDbl(response.item("time2")) / 86400000 + 25569
        Case "error"
            If InStr(1, response.item("error"), "Invalid user credentials") > 0 Then
              f.processStep "rules login failed"
            Else
              f.processStep "submission error", response.item("error")
            End If
            Exit Sub
       Case "failure"
              f.processStep "submission failure", response.item("error")
            Exit Sub
      End Select
    Else
        f.processStep "unrecognized Response", "Unrecognized Server Response"
        Exit Sub
    End If
    
    ' record the number of hours the local clock is behind the  server clock
    updateValue "clockOffset", ((serverTime1 - (((localtime2 - localtime1) - (serverTime2 - serverTime1)) / 2)) - localtime1) * 24
    
    updateValue "hash", response.GetItem("hash", "unhashed")

    If response.Exists("roles") Then
      updateValue "userType", json.toString(response.item("roles"))
    Else
      updateValue "userType", "[""student""]"
    End If
   
    If Not response.Exists("rules") Then
      f.update 1, "Server Error:  Rubric not availalbe", "Submission Failed"
      Exit Sub
    End If

    clearRules False
    
    ' integrate rules into existing assignment
    For x = 1 To response.item("rules").count
      Set rd = response.item("rules")(x)
      Set t = getTaskByID(rd.item("taskid"))
      'Set r = t.addRule(rd.GetItem("id", ""), rd.GetItem("name", ""), rd.GetItem("points", ""), rd.GetItem("formula", ""), rd.GetItem("message", ""))
      ' late August, MS released a patch to excel for mac that broke the line above.  had to move functionalty out of the function to the lines below
       t.rules.Add New rule
       Set r = t.rules(t.rules.count)
       r.id = rd.GetItem("id", "")
       r.name = rd.GetItem("name", "")
       r.points = rd.GetItem("points", "")
       r.ruleFormula = rd.GetItem("formula", "")
       r.errorMessage = rd.GetItem("message", "")


       If rd.Exists("prefills") Then
        For Each pd In rd.item("prefills")
          r.addPreFill pd.GetItem("id", ""), pd.GetItem("params", ""), pd.GetItem("revert", False)
        Next
       End If
       If rd.Exists("preprocs") Then
        For Each pd In rd.item("preprocs")
          r.addPreProcess pd.GetItem("id", ""), pd.GetItem("procedure", ""), pd.GetItem("params", False)
        Next
       End If
     Next

    ' now the downloaded rules have been placed in the assignment
    
    
     f.processStep "got rubric"
    
  
  
End Sub



Sub Submit(f As frmSubmit, authEmail As String, password As String, Optional proxyEmail As String)
  Dim a As New agent
  Dim parameters As String
  Dim encoding As String
  Dim stableCount As Long
  Dim r As rule
  Dim t As task
  Dim s As taskSet
  Dim response As Dictionary
  Dim json As New jsonParser
  Dim email As String
  Dim data As Variant
  Dim prophylactic As String
  Dim skipUpload As Boolean
  prophylactic = getValue("prophylactic")

  
  f.update 10, "Evaluating Work"
  a.clearFormData
  
  data = Split(logAnalysis, Chr(30))
  
  a.AddFormData "activityid", getValue("activityID")
  a.AddFormData "atlas_version", getValue("atlasVersion")
  a.AddFormData "courseid", getValue("courseID")
  a.AddFormData "accountability", json.toString(buildAccountabilityDictionary(f))
  f.update 1, "Recording Score"
  a.AddFormData "work_time", data(0)
  a.AddFormData "prior_submissions", data(1)
  a.AddFormData "client_id", getValue("downloadedByUserID")
  a.AddFormData "score_code", getScoreCode
    If getValue("accessToken") <> "EMPTY" Then
      a.AddFormData "access_token", getValue("accessToken")
      email = getValue("downloadedByEmail")
    Else
      a.AddFormData "auth_email", authEmail
      a.AddFormData "auth_password", password
        email = authEmail
        If proxyEmail > "" Then
          If proxyEmail <> authEmail Then
            email = proxyEmail
            a.AddFormData "proxy_email", proxyEmail
          End If
        End If
    End If
  
  a.AddFormData "hash", getValue("hash")
  a.AddFormData "attachment_path", pathToAttachement()
  a.AddFormData "clock_offset", getValue("clockOffset")
  
  
  For Each s In taskSets
    If s.title <> "precheck" Then
      For Each t In s.tasks
        If t.response > "" Then a.AddFormData t.id & "_ans", t.response
        For Each r In t.rules
            a.AddFormData r.id & "_points", r.pointsEarned
            If r.messageAdendum > "" Then
            a.AddFormData r.id & "_fb", r.messageAdendum
            End If
        Next
      Next
    End If
  Next
      

  If Not a.postdoc(domain & pathForSubmission) Then
    f.processStep "The program was unable to contact the server.  Check to be sure that you have a valid Internet connection and try again.  If this problem persists, contact your instructor.", "error"
    Exit Sub
  End If
  
  Set response = json.parse(a.text)
  
    skipUpload = CBool(response.GetItem("skip_upload", "false"))
    updateValue "submissionStudentName", response.GetItem("student_firstname", "U. N.") & " " & response.GetItem("student_lastname", "Owen")
    updateValue "submissionStudentLink", domain & pathForFailedUpload & getValue("courseID") & "/" & getValue("activityID") & "/" & response.GetItem("student_userid", "0")

  
  Select Case response.GetItem("status", "")
    Case "success"
      updateValue "submissionStudentLink", getValue("submissionStudentLink") & "/" & response.item("submissionid")
      updateValue "submissionID", response.item("submissionid")
      If prophylactic > "" And prophylactic <> "EMPTY" Then updateValue "prophylactic", ncode(response.item("submissionid"))
      addLogEntry "6" & Chr(30) & getValue("submissionID") & Chr(30) & email & Chr(30) & response.GetItem("student_firstname", "") & Chr(30) & response.GetItem("student_lastname", "") & Chr(30) & response.GetItem("student_userid", "") & Chr(30) & getValue("clockOffset") & Chr(30) & fullPath
       If skipUpload Then
            f.update -100, "Submission Complete"
            updateValue "lateDeduction", response.GetItem("late_deduction", "0")
            updateValue "scoreCode", getScoreCode
            updateValue "submissionEndTime", Now
            f.processStep "successful upload"
            postUploadCode "success"
       Else
            If proxyEmail > "" Then
                 f.processStep "successful proxy submission"
            Else
              f.processStep "successful submission"
            End If
       End If
       
    Case "error"
      f.processStep "submission error", response.item("error")
    Case "failure"
      f.processStep "submission failure", response.item("error")
    Case Else
       f.processStep "unrecognized Response", "Unrecognized Server Response"

  End Select


End Sub
Sub upload(f As frmSubmit, authEmail As String, password As String, fileListToAttach As String, Optional proxyEmail As String)
  'fileListToAttach is a chr(30)-separated list of full paths to upload
  Dim a As New agent
  Dim Message As String
  Dim status As String
  Dim parameters As String
  Dim encoding As String
  Dim r As rule
  Dim t As task
  Dim s As taskSet
  Dim response As Dictionary
  Dim json As New jsonParser
  Dim Success As Boolean
  Dim uploadLink As String
  Dim uploadMessage As String
  Dim fileList As Variant
  Dim x As Integer
  Dim uploadSuccess As Boolean
  Dim prophylactic As String
  Dim uploadCount As Byte
  Dim uploadStyle As Long
      fileList = Split(fileListToAttach, Chr(30))

   
   
   #If Mac Then
     encoding = "none"
   #Else
     encoding = "base64"
   #End If
   
   If getValue("accessToken") <> "EMPTY" Then
     parameters = "access_token=" & a.URLEncode(getValue("accessToken")) & "&" & _
                             "client_id=" & a.URLEncode(getValue("downloadedByUserID")) & "&" & _
                             "score_code=" & a.URLEncode(getScoreCode) & "&"
   Else
     parameters = "auth_email=" & a.URLEncode(authEmail) & "&" & _
                             "client_id=" & a.URLEncode(getValue("downloadedByUserID")) & "&" & _
                             "auth_password=" & a.URLEncode(password) & "&"
   End If
   
   parameters = parameters & "encoding=" & encoding & "&" & _
                          "submissionid=" & getValue("submissionID") & "&" & _
                          "score_code=" & a.URLEncode(getScoreCode) & "&" & _
                          "activityid=" & getValue("activityID") & "&" & _
                          "hash=" & getValue("hash")
  

  If proxyEmail > "" Then
    If proxyEmail <> authEmail Then
      parameters = parameters & "&proxy_email=" & a.URLEncode(proxyEmail)
    End If
  End If
  
   ' this line is for debugging failed uploads
  ' uploadStyle = MsgBox("Yes: Proceed with normal submission" & vbNewLine & "No: Fail this attempt" & vbNewLine & "Cancel: Fail all three attempts", vbYesNoCancel, "Attempt Upload?")
   
   ' use updatevalue "debug" , "fail upload" in the immediate windows to make the student file behave as if all three submission attempts fail
   ' use updatevalue "debug" , "EMPTY" in the immediate windows to make the student file behave as normal
   If InStr(1, getValue("debug"), "fail upload") = 0 Then
      uploadStyle = vbYes
    Else
      uploadStyle = vbCancel
    End If
    
  For x = 0 To UBound(fileList)
    f.update -50, "Encoding file " & x + 1 & " of " & UBound(fileList) + 1 & "."
    uploadMessage = "Uploading file " & x + 1 & " of " & UBound(fileList) + 1 & ". This may take a few minutes."
    For uploadCount = 1 To 3
      Select Case uploadStyle '  this is for debugiung and showing error handling only
            Case vbYes
                uploadSuccess = a.postFile(domain & pathForUpload, (fileList(x)), "upload", parameters & "&total_file_uploads=" & UBound(fileList) + 1 & "&file_upload=" & x + 1, f, uploadMessage)
            Case vbNo
                uploadSuccess = False
                If uploadCount < 3 Then uploadStyle = MsgBox("The upload has failed.  How do you want to proceed?" & vbNewLine & vbNewLine & "Yes: Proceed with normal submission" & vbNewLine & "No: Fail this attempt" & vbNewLine & "Cancel: Fail all remaining attempts", vbYesNoCancel, "Attempt Upload?")
            Case Else
                a.text = "{""late_deduction"": 0, ""status"": ""failure""}"
                uploadSuccess = False
      End Select
      'uploadSuccess = a.postFile(domain & pathForUpload, (fileList(x)), "upload", parameters & "&total_file_uploads=" & UBound(fileList) + 1 & "&file_upload=" & x + 1, f, uploadMessage)
      If uploadSuccess Then
        addLogEntry "2" & Chr(30) & "File uploaded" & Chr(30) & fileList(x)
        Exit For
      Else
            uploadMessage = "Uploading file " & x + 1 & " of " & UBound(fileList) + 1 & " (attempt # " & x & "). This may take a few minutes."
      End If
    Next
    If uploadSuccess = False Then
    
      addLogEntry "2" & Chr(30) & "File upload failed after 3 attempts" & Chr(30) & fileList(x)
      Exit For
    End If
  Next
   
uploadMessage = "Your score has been recorded and will be released as soon this " & docTypeName & " has been uploaded to the " & publisherName & " website at the following URL:" & vbNewLine & vbNewLine & getValue("submissionStudentLink") & vbNewLine & vbNewLine & "This page should have opened automatically in your browser." & vbNewLine & vbNewLine & "Alternatively, you may choose ""Retry"" for this " & docTypeName & " to try to upload itself automatically. Click ""Cancel"" after uploading the file or to interrupt this submission and return to your work."
   If uploadSuccess Then
   
      Set response = json.parse(a.text)
     
      Select Case response.GetItem("status", "")
        Case "success"
          f.update -100, "Submission Complete"
          updateValue "lateDeduction", response.GetItem("late_deduction", "0")
          updateValue "scoreCode", getScoreCode
          updateValue "submissionEndTime", Now
          Success = True
    '    Case "error"
    '      f.processStep "upload error", "There was an server error uploading your assignment. " & vbNewLine & vbNewLine & uploadMessage
    '    Case "failure"
    '      f.processStep "upload error", "There was a server failure uploading your assignment. " & vbNewLine & vbNewLine & uploadMessage
    '    Case Else
    '      f.processStep "upload error", "There was an unrecognized server response while uploading your assignment. " & vbNewLine & vbNewLine & uploadMessage
      End Select
   End If



If Success Then
    f.processStep "successful upload"
    postUploadCode "success"
Else
    f.update -95, "Waiting for file upload"
    followLink getValue("submissionStudentLink")
     f.processStep "upload error", "One more step... " & vbNewLine & vbNewLine & uploadMessage
    ' f.update 2, "There was an error uploading your assignment. " & vbNewLine & vbNewLine & uploadMessage, "Upload Error"
    postUploadCode "failure"
End If
 


End Sub

Function recentInstruction() As instruction
  Set recentInstruction = instructions(instructions.count)
End Function

Function recentTaskSet() As taskSet
  Set recentTaskSet = taskSets(taskSets.count)
End Function

Function recentTask() As task
  Set recentTask = recentTaskSet.tasks(recentTaskSet.tasks.count)
End Function

Function recentRule() As rule
  Set recentRule = recentTask.rules(recentTask.rules.count)
End Function

Function recentPrefill() As fill
  Set recentPrefill = recentRule.preFills(recentRule.preFills.count)
End Function

Function recentPreprocess() As process
  Set recentPreprocess = recentRule.preprocesses(recentRule.preprocesses.count)
End Function

Public Sub buildModGrader(outputPath As String)
    Dim ff As Integer
    Dim t As task
    Dim s As taskSet
    Dim r As rule
    Dim f As fill
    Dim p As process
    Dim controller As String
    
    
    ff = FreeFile
    Open outputPath & "\modGrader.bas" For Output As #ff
    Print #ff, "Attribute VB_Name = ""modGrader"""
    Print #ff, "Global FunctionResult as variant"
    Print #ff, "function runRule(ID as String) as Boolean"
    Print #ff, " On Error GoTo Z"
    Print #ff, "Select Case id"
    For Each s In Me.taskSets
        For Each t In s.tasks
            For Each r In t.rules
                Print #ff, "  case """ & r.id & """ : runRule=" & r.ruleFormula
            Next
        Next
    Next
    Print #ff, "End Select "
    Print #ff, "Exit Function"
    Print #ff, "Z:"
    Print #ff, "runRule=False"
    Print #ff, "End Function"
  
Close #ff

End Sub

Function getTaskByID(taskid As String) As task
    Dim s As taskSet
    Dim t As task
    For Each s In taskSets
      For Each t In s.tasks
        If taskid = t.id Then
          Set getTaskByID = t
          Exit Function
        End If
      Next
    Next
End Function

Function addObject(objectType As String, Optional ByVal id As String) As Object
  ' adds a new object of the specified type
  Dim s As task
  
  If id = "" Or idExists(id) Then id = newID
  
  Select Case LCase(objectType)
    Case "instruction": Set addObject = addInstruction(id)
    Case "taskset":  Set addObject = addTaskSet(id)
    Case "task": Set addObject = recentTaskSet.addTask(id)
    Case "rule": Set addObject = recentTask.addRule(id)
    Case "prefill": Set addObject = recentRule.addPreFill(id)
    Case "preprocess": Set addObject = recentRule.addPreProcess(id)
    Case "keyprocess": Set addObject = addKeyProcess(id)
  End Select
  
End Function


Attribute VB_Name = "enableMacros"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Sub openexam(Optional paramToMakeHidden As Boolean)
  On Error Resume Next
  Workbooks.Open Range("a1").value
End Sub
Attribute VB_Name = "encryption"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Dim ccOffset As Long  ' used for concat function

'used for the encryption key in build key
Dim ekey(51) As String * 1
Const ub = 51

Function dcrypt(ByVal data As String, key As String)
  Dim x As Integer
  Dim e As Byte
  Dim temp As String
  Dim onechar As String * 1
  Dim dkey(65 To 122) As Byte  ' needs to be adjusted to teh ascii range of the encryption alphabet  currently A to z
  
  buildkey key
  For x = 0 To ub
    dkey(Asc(ekey(x))) = x
  Next
  
  For x = 1 To Len(data)
    onechar = Mid(data, x, 1)
    If IsNumeric(onechar) Then
      If CInt(onechar) < 5 Then
        temp = temp & (onechar + 5)
      Else
        temp = temp & onechar
      End If
    Else
      temp = temp & Right("0" & dkey(Asc(onechar)), 2)
    End If
  Next
  
  x = CInt(left(temp, 2))
  temp = dCrypt2(temp)
    If x Mod 2 Then
      dcrypt = left(temp, Len(temp) - 1)
    Else
      dcrypt = Mid(temp, 2)
    End If
  

  
End Function




Function ncrypt(data As String, key As String)
  Dim x As Integer
  Dim e As Byte
  Dim ndata As String
  Dim temp As String
  Dim addChar As Boolean
  buildkey key
  
  ndata = nCrypt2(data) & (CInt(Rnd * 50) + 10) 'data as now been encryped as numbers, compress to strings using ekey
  
  For x = 1 To Len(ndata) - 1 Step 1
   ' 'debug.print Mid(nData, x, 1)
    e = CInt(Mid(ndata, x, 1) & Mid(ndata, x + 1, 1))
    If e <= ub Then
      temp = temp & ekey(e)
      x = x + 1
      addChar = False
    Else
      If Rnd > 0.5 Then
        temp = temp & Mid(ndata, x, 1)
      Else
        temp = temp & (CInt(Mid(ndata, x, 1)) - 5)
      End If
      addChar = True
    End If
  Next
  
  If addChar Then temp = temp & Right(ndata, 1)
  ncrypt = temp
End Function






Function nCrypt2(ByVal data) As String
  Dim temp As String
  Dim x As Long
  Dim onechar As String * 1
  Dim ascVal As Byte
  Dim lastval As Byte
  
  lastval = Int(Rnd * 89) + 10
  temp = Right("0" & lastval, 2)
  If lastval Mod 2 = 0 Then data = reverseString(data)
  For x = 1 To Len(data)
    ascVal = Asc(Mid(data, x, 1)) - 31
    If ascVal > 99 Then ascVal = 0
    ascVal = ascVal + lastval
    If ascVal > 99 Then ascVal = ascVal - 100
    lastval = ascVal
    temp = temp & Right("0" & ascVal, 2)
  Next
  
  nCrypt2 = temp
End Function


Function dCrypt2(ByVal data) As String
  Dim temp As String
  Dim x As Integer
  Dim onePair As Byte
  Dim onechar As String * 1
  Dim lastval As Byte
  
  lastval = left(data, 2)
  
  For x = 3 To Len(data) Step 2
    onePair = Mid(data, x, 2)
    If onePair > lastval Then
      onechar = Chr(onePair - lastval + 31)
    Else
      onechar = Chr(100 + onePair - lastval + 31)
    End If
    lastval = onePair
    temp = temp & onechar
  Next
  If left(data, 2) Mod 2 = 0 Then temp = reverseString(temp)
  
  dCrypt2 = temp
End Function


Function reverseString(data) As String
  Dim temp As String
  Dim x As Integer
  
  For x = Len(data) To 1 Step -1
    temp = temp & Mid(data, x, 1)
  Next
  
  reverseString = temp
End Function

Sub buildkey(key)
  Static chrs(51) As String * 1
  Dim x As Byte
  Dim c As Byte
  Dim d As Long
  Dim e As Byte
  Dim k As Byte
  Dim c2 As Byte
    
  If chrs(0) <> "A" Then
    ' load array
    For x = 65 To 90
      chrs(c) = Chr(x)
      c = c + 1
    Next
    For x = 97 To 122
      chrs(c) = Chr(x)
      c = c + 1
    Next
  End If

  c2 = ub
  Do
    For k = 1 To Len(key)
      pos = Asc(Mid(key, k, 1))
      c = pos Mod c2
      ekey(e) = chrs(c)
      e = e + 1
      chrs(c) = chrs(c2)
      c2 = c2 - 1
      If c2 < 1 Then Exit Do
    Next
  Loop
  ekey(ub) = chrs(0)


End Sub





      ' http://support.microsoft.com/kb/170964
      ' fast concatenation of long strings
      ' USE: CONCAT(MyString, dataToAppend)
Sub Concat(dest As String, source As String)
  Dim l As Long
  l = Len(source)
  If (ccOffset + l) >= Len(dest) Then
    If l > ccIncrement Then
      dest = dest & Space$(l)
    Else
      dest = dest & Space$(ccIncrement)
    End If
  End If
  Mid$(dest, ccOffset + 1, l) = source
  ccOffset = ccOffset + l
End Sub






Attribute VB_Name = "excelCode"
Option Explicit
Public RubricStartCell As Range '  rubric start cell is used for picking the right rubric in the gradebook
Public Const modelSheetName = "Assignment Specification"
Public lastSelection As Range
Dim junk As String
Dim x As Long
Dim accountabilityReport As String


Sub evaluateRuleFormula(r As rule)
    Dim result As Variant
    Dim correct As Boolean
    Dim pos1 As Integer
    Dim pos2 As Integer
    Dim delimiter As String * 1
    Dim s As Worksheet
    Dim formula As String
    
    'debug.print r.name, r.id, r.ruleformula
    'If r.id = "<enter last printed rule id here>" Then Stop

    Static SheetName As String
    If SheetName = "" Then
      SheetName = "sheet_not_found"
      For Each s In ThisWorkbook.Worksheets
        If s.name = "Enable Macros" Then
          SheetName = s.name
          Exit For
        End If
      Next
    End If
    
    formula = r.ruleFormula
    On Error Resume Next
      formula = Replace(formula, "[targetWB]", targetWB.name)
    On Error GoTo 0
    
    If SheetName = "sheet_not_found" Then
      result = evaluate(formula)
    Else
      ThisWorkbook.Sheets(SheetName).Range("c2").formula = formula
      result = ThisWorkbook.Sheets(SheetName).Range("c2").value
      ThisWorkbook.Sheets(SheetName).Range("c2").value = ""
    End If
    
    ' handle complex messages
    If IsError(result) Then
      r.correct = 0
      r.messageAdendum = ""
    ElseIf IsNumeric(result) Then
      r.correct = Abs(result)
      r.messageAdendum = ""
    Else
      result = Split(Mid(result, 2), left(result, 1))
      r.correct = result(0)
      r.messageAdendum = result(1)
    End If

End Sub


'-------------------ribbon functions--------------------------------

Sub xShowInBrowser(Optional control As Object)
      showAssignmentInBrowser
      addLogEntry "1" & Chr(30) & "Show Assingment in Browser"
End Sub
Sub xShowTaskBox(Optional control As Object)
      showTaskBox
End Sub


Sub xSubmit(Optional control As Object)
      
      frmSubmit.Show
      afterCloseSubmit
End Sub

Sub xViewGradeSheet(Optional control As Object)
      showAssignmentInBrowser True
End Sub


'-------------------end ribbon functions----------------------------




Sub hide_Accountability_flags(Optional f As frmSubmit)
  'removes all comments from the active workbook
  Dim wb As Workbook
  Dim s As Worksheet
  Dim cell As Range
  Dim sheetcount As Integer
  Dim x As Long
  
  Set wb = ActiveWorkbook
  
  f.update 0
  
  
  For Each s In wb.Worksheets
    sheetcount = sheetcount + 1
    If s.visible = xlSheetVisible Then
      f.update CInt((sheetcount / wb.Worksheets.count) * 100), s.name
    For x = s.Shapes.count To 1 Step -1
      If left(s.Shapes(x).name, 25) = "Accountability label for " Then s.Shapes(x).Delete
    Next
    For Each cell In s.UsedRange
      If Not cell.comment Is Nothing Then
        If left(cell.comment.text, 1) = Chr(30) Then
          cell.comment.Delete
        End If
      End If
      'DoEvents
    Next
    End If
  Next

End Sub
Sub ping(Optional junk As String)
  On Error Resume Next
    frmSubmit.wobble
  On Error GoTo 0
End Sub
Function buildAccountabilityDictionary(Optional f As frmSubmit) As Dictionary
  Const MaxCells = 5000
  Dim report As New Dictionary
  Dim sheet As Dictionary
  
  Dim cell As Range
  Dim x As Integer
  Dim data As Variant
  Dim studentName As String
  Dim Message As String
  Dim validCode As Long
  Dim s As Worksheet
  Dim cellsFound As Long
  Dim chartsFound As Long
  Dim sheetsfound As String
  Dim workload As Long
  Dim c As ChartObject
  Dim sh As Shape
  Dim json As New jsonParser
  Dim lastTimeShown As Long
  Dim cellCount As Long
  Dim userData As New Dictionary
  Dim colorCode As Long
  Dim usedCells As Long
  
  validCode = hexColor2Dec(getValue("accountability"))
  report.Add "injection", New Dictionary
  report.item("injection").Add "original_hex", getValue("accountability")
  report.item("injection").Add "original_dec", validCode
  report.Add "accountability", New Dictionary
  
  'Calculate Work load
  For Each s In ThisWorkbook.Worksheets
    If s.visible = xlSheetVisible Then
      usedCells = MaxCells + 1
      On Error Resume Next
        usedCells = s.UsedRange.Cells.count
      On Error GoTo 0
      If usedCells > MaxCells Then
        workload = workload + MaxCells
      Else
        workload = workload + s.UsedRange.Cells.count
      End If
      workload = workload + s.ChartObjects.count
    End If
  Next
  
 ' If Not f Is Nothing Then f.update 0
  For Each s In ThisWorkbook.Worksheets
    On Error Resume Next
    If s.name = ActiveSheet.name Then s.Range("a1").Select
    On Error GoTo 0
    If s.visible = xlSheetVisible Then
        lastTimeShown = 0
        x = 0
        For Each cell In s.UsedRange
            x = x + 1
            cellCount = cellCount + 1
            If Not f Is Nothing Then
                If Int(Timer) < lastTimeShown Then
                  lastTimeShown = Int(Timer)
                ElseIf Int(Timer) > lastTimeShown + 1 Then
                    lastTimeShown = Int(Timer)
                    f.update CInt((cellCount / workload) * -50) + 1, "Worksheet: " & s.name
                    
                End If
            End If
            
            '  If cell.Address = "$I$12" Then Stop
            
              If cell.Interior.color = 15132391 And cell.Interior.PatternColor <> validCode Then '15132391 is the color used to highlight cells that students must fill in
                'Stop
                colorCode = cell.Interior.PatternColor
                
                If Not report.item("accountability").Exists(CStr(colorCode)) Then
                  report.item("accountability").Add CStr(colorCode), New Dictionary
                  report.item("accountability").item(CStr(colorCode)).Add "hex", decColor2Hex(colorCode)
                  report.item("accountability").item(CStr(colorCode)).Add "sheets", New Dictionary
                End If
              
                If Not report.item("accountability").item(CStr(colorCode)).item("sheets").Exists(s.name) Then
                  report.item("accountability").item(CStr(colorCode)).item("sheets").Add s.name, New Dictionary
                End If
                
                If Not report.item("accountability").item(CStr(colorCode)).item("sheets").item(s.name).Exists("cells") Then
                  report.item("accountability").item(CStr(colorCode)).item("sheets").item(s.name).Add "cells", New Collection
                End If
              
               report.item("accountability").item(CStr(colorCode)).item("sheets").item(s.name).item("cells").Add Replace(cell.address, "$", "")
          End If
          If x >= MaxCells Then Exit For
        Next
    
    ' now do the charts
    For Each c In s.ChartObjects
      cellCount = cellCount + 1
      Set sh = Nothing
      On Error Resume Next
        Set sh = c.Chart.Shapes(1)  ' checking to see if the chart has shapes.  If not, the loop will fail
      On Error GoTo 0
      If Not sh Is Nothing Then
        For Each sh In c.Chart.Shapes
          If sh.name = "invisaline" Then ' this must be the the zero-length we placed on chart creation to hold the accountability number
            If sh.line.ForeColor.RGB <> white And sh.line.ForeColor.RGB <> validCode Then ' we have a line color that we do not expect
            
                  colorCode = sh.line.ForeColor.RGB
                  
                  If Not report.item("accountability").Exists(CStr(colorCode)) Then
                    report.item("accountability").Add CStr(colorCode), New Dictionary
                    report.item("accountability").item(CStr(colorCode)).Add "hex", decColor2Hex(colorCode)
                    report.item("accountability").item(CStr(colorCode)).Add "sheets", New Dictionary
                  End If
                
                  If Not report.item("accountability").item(CStr(colorCode)).item("sheets").Exists(s.name) Then
                    report.item("accountability").item(CStr(colorCode)).item("sheets").Add s.name, New Dictionary
                  End If
                  
                  If Not report.item("accountability").item(CStr(colorCode)).item("sheets").item(s.name).Exists("charts") Then
                    report.item("accountability").item(CStr(colorCode)).item("sheets").item(s.name).Add "charts", New Collection
                  End If
                  If c.Chart.HasTitle Then
                    report.item("accountability").item(CStr(colorCode)).item("sheets").item(s.name).item("charts").Add json.parse("{""title"":""" & c.Chart.ChartTitle.text & """,""name"":""" & c.name & """}")
                  Else
                    report.item("accountability").item(CStr(colorCode)).item("sheets").item(s.name).item("charts").Add json.parse("{""name"":""" & c.name & """}")
                  End If
            
            End If
          End If
        Next sh
      End If
    Next c
  End If

Next s
accountabilityReport = json.toString(report)
Set buildAccountabilityDictionary = report

End Function

Sub show_Accountability_flags(Optional f As frmSubmit)
  Dim report As Dictionary
  Dim d As Dictionary
  Dim k As KeyValuePair
  Dim x As Integer
  Dim y As Integer
  Dim sheet As KeyValuePair
  Dim json As New jsonParser
  Dim user As Dictionary
  Dim userName As String
  Dim com As comment
  Dim cellsFound As Integer
  Dim chartsFound As Integer
  Dim commentColor As Long
  Dim sheetsfound As String
  Dim Message As String
  
  If accountabilityReport = "" Then
    Set report = buildAccountabilityDictionary(f)
  Else
     Set report = json.parse(accountabilityReport)
  End If
  sheetsfound = Chr(30)
  
  
  addAccountibilityData report, f
  
  
  For Each k In report.item("accountability").KeyValuePairs
      
      userName = ""
      If k.value.item("users").item("noncourse").count > 0 Then
        For Each user In k.value.item("users").item("noncourse")
          userName = userName & " or " & user.item("user_fname") & " " & user.item("user_lname")
        Next
        commentColor = RGB(255, 0, 0)
      End If
      
      If k.value.item("users").item("similarcourse").count > 0 Then
        For Each user In k.value.item("users").item("similarcourse")
          userName = userName & " or " & user.item("user_fname") & " " & user.item("user_lname")
        Next
        commentColor = RGB(255, 255, 0)
      End If
      
      If k.value.item("users").item("course").count > 0 Then
        For Each user In k.value.item("users").item("course")
          userName = userName & " or " & user.item("user_fname") & " " & user.item("user_lname")
        Next
        commentColor = RGB(0, 0, 255)
      End If
      
      If userName = "" Then
        'no user found for ID
      Else
      
        userName = CStr(k.key) & " (" & Mid(userName, 5) & ")"
        
        For Each sheet In k.value.item("sheets").KeyValuePairs
           f.update 1, "Showing flags for worksheet: " & sheet.key

           If InStr(1, sheetsfound, Chr(30) & sheet.key & Chr(30)) = 0 Then sheetsfound = sheetsfound + sheet.key & Chr(30)
             If sheet.value.Exists("cells") Then
               For y = 1 To sheet.value.item("cells").count
                 cellsFound = cellsFound + 1
                 setCellComment ThisWorkbook.Sheets(sheet.key).Range(sheet.value.item("cells").item(y)), userName, commentColor
               Next
             End If
             If sheet.value.Exists("charts") Then
               For y = 1 To sheet.value.item("charts").count
                  chartsFound = chartsFound + 1

                 setChartComment ThisWorkbook.Sheets(sheet.key).ChartObjects(sheet.value.item("charts").item(y).item("name")).Chart, userName, commentColor
               Next
             End If
        Next
      End If 'found at least one user
  
  Next
  
  ''debug.print json.toString(report)
  
Message = ""
If cellsFound > 0 Then Message = "Copied Cells Found: " & cellsFound & vbNewLine
If chartsFound > 0 Then Message = Message & "Copied Charts Found: " & chartsFound & vbNewLine
If Message = "" Then
  Message = "No copied cells or charts detected."
Else
  Message = Message & "Sheets involved: " & Replace(Mid(sheetsfound, 2, Len(sheetsfound) - 2), Chr(30), ", ")
End If
f.Message = Message
  
End Sub
Sub setCellComment(cell As Range, comment As String, commentColor As Long)
  Dim com As comment

    If cell.comment Is Nothing Then
        Set com = cell.AddComment(Chr(30) & comment)
     Else
       Set com = cell.comment
       com.text Chr(30) & comment
     End If
     
     com.Shape.AutoShapeType = msoShapeRoundedRectangle
     com.Shape.TextFrame.Characters.Font.bold = True
     com.Shape.TextFrame.Characters.Font.ColorIndex = 2
     com.Shape.fill.ForeColor.RGB = commentColor
     com.Shape.fill.OneColorGradient msoGradientDiagonalUp, 1, 0.23
     com.visible = True
     com.Shape.TextFrame.AutoSize = True
     com.Shape.top = cell.top - com.Shape.height
    
    

End Sub
Sub setChartComment(c As Chart, comment As String, commentColor As Long)
Dim s As Worksheet
Dim o As Object
  Set o = c
    Do  ' find the sheet that holds the chart
      Set o = o.Parent
    Loop Until TypeName(o) = "Worksheet"
    Set s = o


            On Error Resume Next
              s.Shapes("Accountability label for " & c.name).Delete
            On Error GoTo 0
            
            With s.Shapes.addTextBox(msoTextOrientationHorizontal, c.Parent.left, c.Parent.top + c.Parent.height, c.Parent.width, 20)
              .TextFrame2.TextRange.Characters.text = comment
              .TextFrame2.TextRange.Characters.Font.fill.ForeColor.RGB = white
              .TextFrame2.TextRange.Characters.Font.bold = True
              .AutoShapeType = msoShapeRoundedRectangle
              .fill.ForeColor.RGB = commentColor
              .fill.OneColorGradient msoGradientDiagonalUp, 1, 0.23
              .TextFrame2.TextRange.ParagraphFormat.Alignment = msoAlignCenter
              .name = "Accountability label for " & c.name
            End With
End Sub

Sub addAccountibilityData(report As Dictionary, Optional f As frmSubmit)
  Dim k As KeyValuePair
  Dim json As New jsonParser
  Dim x As Integer
  For Each k In report.item("accountability").KeyValuePairs
    If Not k.value.Exists("users") Then
      f.update CInt(((x) / report.item("accountability").count) * -100), "Getting user identity for " & k.key
      If Not getAccountabilityIdentity(CStr(k.key), report, f.txtEmail.text, f.txtPassword.text) Then
        Stop
      End If
    End If
      x = x + 1
  Next
  
  accountabilityReport = json.toString(report)
End Sub

Function getAccountabilityIdentity(accountability As Long, report As Dictionary, email As String, password As String) As Boolean

Dim json As New jsonParser
Dim response As Dictionary
Dim a As New agent


  a.clearFormData
  a.AddFormData "activityid", getValue("activityID")
  a.AddFormData "accountability", decColor2Hex(accountability)
  a.AddFormData "auth_email", email
  a.AddFormData "auth_password", password

a.postdoc domain & pathForColorToUsers

Set response = json.parse(a.text)

  Select Case response.GetItem("status", "")
    Case "success"
       getAccountabilityIdentity = True
       report.item("accountability").item(CStr(accountability)).Add "users", json.parse(a.text)
    Case "error"
      Stop
    Case "failure"
      Stop
    Case Else
    Stop
  End Select


End Function
Sub junkie(Optional junk As Boolean)
Dim json As New jsonParser
Dim response As Dictionary
Dim a As New agent


  a.clearFormData
  a.AddFormData "activityid", getValue("activityID")
  a.AddFormData "accountability", decColor2Hex(accountability)
  a.AddFormData "auth_email", email
  a.AddFormData "auth_password", password

a.postdoc domain & pathForColorToUsers

Set response = json.parse(a.text)

  Select Case response.GetItem("status", "")
    Case "success"
       getAccountabilityIdentity = True
       report.item("accountability").item(CStr(accountability)).Add "users", json.parse(a.text)
    Case "error"
      Stop
    Case "failure"
      Stop
    Case Else
    Stop
  End Select

End Sub


Sub showAccountabilityInBrowser(Optional f As frmSubmit)
  Dim k As KeyValuePair
 Dim title As String
 Dim x As Long
 Dim y As Long
 Dim json As New jsonParser
 Dim name As String
 Dim data As Variant
 Dim logTypeName As String
 Dim ff As Integer
 Dim headerPrinted As Boolean
 Dim user As Dictionary
 Dim sheet As KeyValuePair

 Dim path As String


path = getTempPath

Dim report As Dictionary

  If accountabilityReport = "" Then
    Set report = buildAccountabilityDictionary(f)
  Else
     Set report = json.parse(accountabilityReport)
  End If
  addAccountibilityData report, f



title = "Accountability Report"
  
ff = FreeFile
  Open path & "accountability.html" For Output As #ff
  Print #ff, "<!DOCTYPE html><html lang=""en - US""><head><style>body{font-family:Tahoma, Geneva, sans-serif; margin-left:100px; margin-right:100px; margin-top:50px;margin-bottom:50px;}</style>"
  Print #ff, "<title>" & title & "</title></head>" & style & "<body>"
      
  Print #ff, "<h1 class=ee>Accountability Report</h1>" & vbNewLine & "<p class=ee>This report details cells and charts that have been copied from workbooks downloaded by other students.</p>" & vbNewLine
  
      Print #ff, "<table class=ee>"
      Print #ff, "<tr><th class=ee colspan=4>Origin</th></tr>"
      Print #ff, "<tr><th class=ee1>Downloaded By</th><th class=ee1>Email</th><th class=ee1>Time Downloaded</th><th class=ee1>Accountability ID</th></tr>"
      Print #ff, "<tr><td class=ee>" & getValue("downloadedByName") & "</td><td class=ee>" & getValue("downloadedByEmail") & "</td><td class=ee>" & CDate(CDbl(getValue("timeDownloaded")) / 86400000 + 25569) & " UTC</td><td class=ee>" & hexColor2Dec(getValue("accountability")) & "</td></tr>"
      Print #ff, "</table><br><br>"
  
  
  For Each k In report.item("accountability").KeyValuePairs
      headerPrinted = False
          
      
      Print #ff, "<table class=ee>"
      Print #ff, "<tr><th class=ee colspan=4>Report for Accountibility ID: " & CStr(k.key) & "</th></tr>"
      Print #ff, "<tr><th class=ee1>User Name</th><th class=ee1>School ID</th><th class=ee1>Account Created</th><th class=ee1>Relationship to this assignment</th></tr>"

      If k.value.item("users").Exists("course") Then
        If k.value.item("users").item("course").count > 0 Then
          headerPrinted = True
          For Each user In k.value.item("users").item("course")
            Print #ff, "<tr><td class=ee>" & user.item("user_fname") & " " & user.item("user_lname") & " (" & user.item("user_email") & ")</td><td class=ee>" & user.item("user_schoolid") & "</td><td class=ee>" & CDate(Split(user.item("user_create_date"), "T")(0)) & "</td><td class=ee>Registered for this course</td></tr>"
          Next
        End If
      End If
      If k.value.item("users").Exists("similarcourse") Then
        If k.value.item("users").item("similarcourse").count > 0 Then
          headerPrinted = True
          For Each user In k.value.item("users").item("similarcourse")
            Print #ff, "<tr><td class=ee>" & user.item("user_fname") & " " & user.item("user_lname") & "</td><td class=ee>" & user.item("user_institution") & "</td><td class=ee>" & CDate(Split(user.item("user_create_date"), "T")(0)) & "</td><td class=ee>Registered for another course that  uses this assignment</td></tr>"
          Next
        End If
      End If
      
      If k.value.item("users").Exists("noncourse") Then
        If k.value.item("users").item("noncourse").count > 0 Then
          headerPrinted = True
          For Each user In k.value.item("users").item("noncourse")
            Print #ff, "<tr><td class=ee>" & user.item("user_fname") & " " & user.item("user_lname") & "</td><td class=ee>" & user.item("user_institution") & "</td><td class=ee>" & CDate(Split(user.item("user_create_date"), "T")(0)) & "</td><td class=ee>Not registered for a course that uses this assignment</td></tr>"
          Next
        End If
      End If
      
      If headerPrinted Then
      
        
        For Each sheet In k.value.item("sheets").KeyValuePairs

          Print #ff, "<tr><th class=ee1 colspan=4><font color=#333>Worksheet: </font><font color=#003399>" & sheet.key & "</font></th></tr>"

             If sheet.value.Exists("cells") Then
               Print #ff, "<tr><td class=ee>Cells Copied</th><td class=ee colspan=3>"
               For y = 1 To sheet.value.item("cells").count
                 Print #ff, sheet.value.item("cells").item(y) & " "
               Next
               Print #ff, "</td></tr>"
             End If
             
             If sheet.value.Exists("charts") Then
               Print #ff, "<tr><td class=ee>Charts Copied</th><td class=ee colspan=3>"
               For y = 1 To sheet.value.item("charts").count
                 Print #ff, "[" & sheet.value.item("charts").item(y).item("title") & " (" & sheet.value.item("charts").item(y).item("name") & ")] "
               Next
               Print #ff, "</td></tr>"
             End If
        Next
      
      Else
         'no user found for ID, must not
  
      End If 'headerprinted
Print #ff, "</table><br><br>"
  
  Next

Print #ff, "</body></html>"
Close #ff
followLink path & "accountability.html"
'Kill path & "properties.html"
End Sub



'-------------------Logging Functions------------------------

Sub recordCellChange(ByVal sh As Object, ByVal Target As Range)
  Dim cell As Range
  If suspendlogging Then Exit Sub
  If Target.Parent.name = "Assignment Specification" Then Exit Sub
  If Target.Parent.name = "Enable Macros" Then Exit Sub ' used of evaluating formulae
  
  'manipulating a whole worksheet
  If Target.rows.count = Target.Parent.rows.count And Target.columns.count = Target.Parent.columns.count Then
         addLogEntry "5" & Chr(30) & sh.name & Chr(30) & Replace(Target.address, "$", "") & Chr(30) & Target.Cells(1).formula & Chr(30) & Target.Cells(1).text & Chr(30) & 1
  Exit Sub
  End If
  
  
  'manipulating a whole column
  If Target.rows.count = Target.Parent.rows.count Then
    recordByColumn sh, Target
  Exit Sub
  End If
  
  'manipulating a whole row
  If Target.columns.count = Target.Parent.columns.count Then
    recordByRow sh, Target
  Exit Sub
  End If
  
  
  If Target.Cells.count = 1 Then  ' only one cell, it does not matter how we record
    recordByRow sh, Target
    Exit Sub
  End If
  
  If Target.columns.count = 1 Then  ' more than one cell in a single column, record by column
    recordByColumn sh, Target
    Exit Sub
  End If
  
  If Target.rows.count = 1 Then  ' more than one cell in a single row, record by row
    recordByRow sh, Target
    Exit Sub
  End If
  
  ' Multiple rows and multiple columns, the first two cells of the first column have same formula, record by column
  If left(Target.columns(1).Cells(1).FormulaR1C1, 1) = "=" And Target.columns(1).Cells(1).FormulaR1C1 = Target.columns(1).Cells(1).FormulaR1C1 Then
    recordByColumn sh, Target
    Exit Sub
  End If
    
  ' Multiple rows and multiple columns, first two cells of the first row have same formula, record by row
  If left(Target.rows(1).Cells(1).FormulaR1C1, 1) = "=" And Target.rows(1).Cells(1).FormulaR1C1 = Target.rows(1).Cells(1).FormulaR1C1 Then
    recordByRow sh, Target
    Exit Sub
  End If
    
    
  ' the next block causes an error on an undo of a column delete.  This code prevents such actions from being logged
  On Error Resume Next
  junk = lastSelection.address
  If Err.number <> 0 Then Exit Sub
  On Error GoTo 0
  
  ' used for autofill
  If lastSelection.columns.count = Target.columns.count Then
    recordByColumn sh, Target
    Exit Sub
  End If
  
  recordByRow sh, Target
  
End Sub
Sub recordByRow(sh As Object, Target As Range)
  Dim x As Integer
      For x = 1 To Target.rows.count
        addLogEntry "5" & Chr(30) & sh.name & Chr(30) & Replace(Target.rows(x).address, "$", "") & Chr(30) & Target.columns(1).Cells(x).formula & Chr(30) & Target.columns(1).Cells(x).text & Chr(30) & x
      Next
End Sub
Sub recordByColumn(sh As Object, Target As Range)
  Dim x As Integer
      For x = 1 To Target.columns.count
        addLogEntry "5" & Chr(30) & sh.name & Chr(30) & Replace(Target.columns(x).address, "$", "") & Chr(30) & Target.rows(1).Cells(x).formula & Chr(30) & Target.rows(1).Cells(x).text & Chr(30) & x
      Next

End Sub

'---------------------------------- end of logging functions --------------------------------------------
' ----------------------------------- copied from modPresentation -----------------------------------------

' modified 9/18/14 to handle long submission id

Sub prepareFile(Optional paramToMakeNotAMacro As Byte) ' used to hide real sheets, show the Enable Macros sheet, close the workbook and save
  HideSheets
  ThisWorkbook.Close True
End Sub


Sub showSheets(Optional wb As Workbook)

If LCase(getValue("lockWhenNotAvailable")) = "true" Then
    ' hide sheets incase something went wrong during save
    weblock_hidesheets
    'show the apporpriate sheets and hide the enable macros sheet
    webLock_Initialize
Else
        If wb Is Nothing Then Set wb = ThisWorkbook
          Dim r As Long
          On Error Resume Next
               If Not SheetExists(modelSheetName, wb) Then
                  If SheetExists("enable macros", wb) Then
                      If wb.Sheets("enable macros").visible = xlSheetVisible Then
                          For r = wb.Sheets("enable macros").Cells(5000, 2).End(xlUp).row To 2 Step -1
                              wb.Sheets(wb.Sheets("enable macros").Cells(r, 2).value).visible = True
                          Next
                          wb.Sheets(wb.Sheets("enable macros").Range("b2").value).Activate
                          wb.Sheets("enable macros").visible = xlVeryHidden
                      End If
                  End If
              End If
          On Error GoTo 0
End If
End Sub
Sub HideSheets(Optional wb As Workbook)
  If wb Is Nothing Then Set wb = ThisWorkbook
    Dim r As Long
    On Error Resume Next
     wb.Sheets("enable macros").visible = True
        r = 2
        Do Until wb.Sheets("enable macros").Cells(r, 2).value = ""
            wb.Sheets(wb.Sheets("enable macros").Cells(r, 2).value).visible = xlVeryHidden
            r = r + 1
        Loop
    On Error GoTo 0
End Sub


Sub savework(Optional paramToMakeNotAMacro As Byte)
  ThisWorkbook.Save
End Sub

 
 Sub executePreProcess(ByVal procName As String, paramList As String)
  Dim delimiter As String * 1
  
  On Error Resume Next
  If InStr(1, procName, "[targetWB]") > 0 Then procName = Replace(procName, "[targetWB]", "'" & targetWB.name & "'")
  On Error GoTo 0
  
  If Len(paramList) > 1 Then
    delimiter = left(paramList, 1)
    applicationRun procName, Split(Mid(paramList, 2), delimiter)
  Else
    applicationRun procName
  End If
End Sub



Function getAccountabilityNumbers()
Dim s As Worksheet
Dim c As ChartObject
Dim sh As Shape
Dim x As Integer
Dim cell As Range
Dim colors As String
Dim w As Workbook
Dim cellCount As Integer
Dim data As Variant
Set w = ThisWorkbook

colors = getValue("accountability")
colors = "," & RGB("&H" & Mid(colors, 3, 2), "&H" & Mid(colors, 5, 2), "&H" & Mid(colors, 7, 2))
For Each s In w.Worksheets
  If s.visible = xlSheetVisible Then
    For Each cell In s.UsedRange.Cells
      If cell.Interior.PatternColor > 0 Then
        cellCount = cellCount + 1
        addColor cell.Interior.PatternColor, colors
      End If
      If cellCount > 10000 Then Exit For
    Next
  
  ' now do the charts
      For Each c In s.ChartObjects
      For Each sh In c.Chart.Shapes
        If sh.name = "invisaline" Then ' this must be the the zero-length we placed on chart creation to hold the accountability number
          If sh.line.ForeColor.RGB <> white Then
             addColor sh.line.ForeColor.RGB, colors
          End If
        End If
      Next sh
    Next c
  End If

  
Next
data = Split(Mid(colors, 2), ",")
colors = ""
For x = 0 To UBound(data)
  colors = colors & "," & decColor2Hex(CStr(data(x)))
Next
getAccountabilityNumbers = Mid(colors, 2)
  
End Function

Sub addColor(theColor As String, colorList As String)
  If theColor = "0" Then Exit Sub
  If InStr(1, colorList & ",", "," & theColor & ",") = 0 Then
    colorList = colorList & "," & theColor
  End If
End Sub

Function getActivityID() As String
  getActivityID = igmodel.Range("j1").value
End Function

Sub setActivityID(activityID As String)
  igmodel.Range("j1").value = activityID
End Sub

Function countSteps() As Long
  countSteps = Range(ThisWorkbook.Sheets("igModel").Range("b2"), ThisWorkbook.Sheets("igModel").Cells(rows.count, 2).End(xlUp)).Cells.count
End Function

Sub followWebLink(link As String)
  ActiveWorkbook.FollowHyperlink link
End Sub



'-------------------------- modules to make the task form for work both as an excel form and as objects on the sheet ----------------------
' Excel: show task data in task guide
Sub presentTaskData(theForm As Object, tasks As Object, bleft As Single, btop As Single)
  Dim SheetName As String
  Dim wasVisible As Boolean
  
   
  If UCase(Split(tasks(theForm.spnAdvance.value + 1).hint & "|", "|")(0)) <> UCase(activeDocument.name) Then
    On Error Resume Next
    bleft = activeDocument.Shapes("taskBox").left
    btop = activeDocument.Shapes("taskBox").top
    wasVisible = activeDocument.Shapes("taskBox").visible
    activeDocument.Shapes("taskBox").Delete
   
    ThisWorkbook.Sheets(Split(tasks(theForm.spnAdvance.value + 1).hint & "|", "|")(0)).Select
    
    If Not theForm.visible Then
      showTaskBoxOnSheet btop, bleft, theForm.width, theForm.txtTitle.text, theForm.txtTaskNumber.text, theForm.txtTask.text, theForm.chkComplete.value
    End If
    On Error GoTo 0
  End If
  ' relevant sheet is now active, select the relevant range
  
 
 On Error Resume Next
  If Split(tasks(theForm.spnAdvance.value + 1).hint & "|", "|")(1) > "" Then Range(Split(tasks(theForm.spnAdvance.value + 1).hint & "|", "|")(1)).Select
    
    activeDocument.Shapes("body").TextFrame2.TextRange.text = theForm.txtTask.text
    activeDocument.Shapes("number").TextFrame2.TextRange.text = theForm.txtTaskNumber.text
    activeDocument.Shapes("header").TextFrame2.TextRange.text = theForm.txtTitle.text
    activeDocument.Shapes("number").height = activeDocument.Shapes("body").height
    If theForm.chkComplete.value Then
      activeDocument.Shapes("complete").TextFrame2.TextRange.text = Chr(252)
    Else
      activeDocument.Shapes("complete").TextFrame2.TextRange.text = ""
    End If
  
  

End Sub


Sub DockTaskForm(theForm As Object, left As Single, top As Single)

  showTaskBoxOnSheet Cells(ActiveWindow.ScrollRow, ActiveWindow.ScrollColumn).top + 5, _
                     Cells(ActiveWindow.ScrollRow, ActiveWindow.ScrollColumn).left + 5, _
                     theForm.width, theForm.txtTitle.text, theForm.txtTaskNumber.text, theForm.txtTask.text, theForm.chkComplete.value
  left = theForm.left
  top = theForm.top
  theForm.Hide


End Sub

Sub showTaskBoxOnSheet(top As Single, left As Single, blockWidth As Single, header As String, num As String, text As String, complete As Boolean)
  Dim s As Worksheet
  Dim G As Shape
  Dim b(8) As Shape
  
  Dim shp As Shape
  Dim foundBox As Boolean
  Dim msoAlignCenter As Byte
  
  
  Const HeaderHeight = 20
  Const numberWidth = 30
  'Const blockWidth = 300
  Const arrowWidth = 12
  Const margin = 5
  
  
  ' don't know why, but the built inconstants were all empty: redefine
  Const msoThemeColorBackground2 = 16
  Const msoThemeColorText2 = 15
   
  If Application.operatingSystem Like "*Mac*" Then
    msoAlignCenter = 1  ' mac is wacked.  might need to be removed in futre versions of office for mac
  Else
    msoAlignCenter = 2
  End If

   
  
  
  Const msoAnchorMiddle = 3
  Const msoThemeColorText1 = 13
  Const xlThemeColorAccent2 = 6

  Const msoThemeColorBackground1 = 14
  Const msoTrue = -1

  Const msoAutoSizeShapeToFitText = 1
  Const msoShapeMathMultiply = 165
  Const msoShapeStylePreset23 = 23
  Const msoShapeIsoscelesTriangle = 7
  Const msoShapeOval = 9
  
  Set s = ActiveSheet
  
  For Each shp In s.Shapes
    ''debug.print shp.name
    If shp.name = "taskBox" Then
      foundBox = True
      Exit For
    End If
  Next
  
  If foundBox Then
     shp.visible = True
     s.Shapes("body").TextFrame2.TextRange.text = ""
     s.Shapes("number").TextFrame2.TextRange.text = ""
     s.Shapes("header").TextFrame2.TextRange.text = ""
     s.Shapes("complete").TextFrame2.TextRange.text = ""

  Else
      Set b(0) = s.Shapes.addTextBox(1, left, top, blockWidth, HeaderHeight)
      Set b(1) = s.Shapes.addTextBox(1, left + numberWidth, top + HeaderHeight, blockWidth - numberWidth, 100)
      Set b(2) = s.Shapes.addTextBox(1, left, top + HeaderHeight, numberWidth, b(1).height)
      Set b(3) = s.Shapes.AddShape(msoShapeMathMultiply, left + margin / 2, top + margin / 2, (HeaderHeight - margin), (HeaderHeight - margin))
      Set b(4) = s.Shapes.AddShape(msoShapeIsoscelesTriangle, b(3).left + b(3).width + margin, top + margin, (HeaderHeight - margin * 2), (HeaderHeight - margin * 2))
      
      Set b(7) = s.Shapes.addTextBox(1, left + blockWidth - 45, top + HeaderHeight / 4, HeaderHeight / 2, HeaderHeight / 2)
      Set b(5) = s.Shapes.AddShape(msoShapeIsoscelesTriangle, left + blockWidth - 30, top + margin, (HeaderHeight - margin * 1.5), (HeaderHeight - margin * 2))
      Set b(6) = s.Shapes.AddShape(msoShapeIsoscelesTriangle, b(5).left + b(5).width + 2, b(5).top, b(5).width, b(5).height)
      
      
      b(3).ShapeStyle = msoShapeStylePreset23
      b(3).name = "close"
      b(3).OnAction = "DeleteTaskBox"
      
      b(4).ShapeStyle = msoShapeStylePreset23
      b(4).name = "form"
      b(4).OnAction = "reShowForm"
      
      b(5).ShapeStyle = msoShapeStylePreset23
      b(5).name = "prior"
      b(5).OnAction = "priorTask"
      b(5).IncrementRotation -90

      b(6).ShapeStyle = msoShapeStylePreset23
      b(6).name = "next"
      b(6).OnAction = "nextTask"
      b(6).IncrementRotation 90
      
      
      b(7).name = "complete"
      b(7).OnAction = "checkComplete"
      b(7).TextFrame2.TextRange.Font.name = "Wingdings"
      b(7).TextFrame2.MarginLeft = 1
      b(7).TextFrame2.MarginRight = 0
      b(7).TextFrame2.MarginTop = 2
      b(7).TextFrame2.MarginBottom = 0
      b(7).TextFrame2.TextRange.ParagraphFormat.Alignment = 2
      b(7).TextFrame2.VerticalAnchor = 3
     
     ' b(5).ShapeStyle = msoShapeStylePreset23
     ' b(5).name = "move"
      b(2).OnAction = "moveTaskBox"
      
      b(0).fill.ForeColor.RGB = 2303331
      b(1).fill.ForeColor.RGB = 12900829
      b(2).fill.ForeColor.RGB = 9944516
            
      b(2).TextFrame2.TextRange.ParagraphFormat.Alignment = msoAlignCenter
      b(2).TextFrame2.VerticalAnchor = msoAnchorMiddle
      
      b(0).line.ForeColor.ObjectThemeColor = msoThemeColorText1
      b(1).line.ForeColor.ObjectThemeColor = msoThemeColorText1
      b(2).line.ForeColor.ObjectThemeColor = msoThemeColorText1
      
      
      
      
      b(0).OnAction = "taskBoxMove"
      b(1).OnAction = "naught"
      b(2).OnAction = "moveTaskBox"
      
      b(0).name = "header"
      b(1).name = "body"
      b(2).name = "number"
      
      Set G = s.Shapes.Range(Array("header", "body", "number", "close", "form", "next", "prior", "complete")).Group
      G.name = "taskBox"
    
       b(0).TextFrame2.TextRange.ParagraphFormat.Alignment = msoAlignCenter
       
       With b(0).TextFrame2.TextRange.Font
            .bold = msoTrue
            .size = 14
            .fill.ForeColor.RGB = white
       End With
       With b(2).TextFrame2.TextRange.Font
            .bold = msoTrue
            .size = 14
       End With
        
       b(1).TextFrame2.TextRange.Font.size = 12
    
    
       b(1).TextFrame2.AutoSize = msoAutoSizeShapeToFitText
     
  End If 'found box
  
  s.Shapes("body").TextFrame2.TextRange.text = text
  s.Shapes("number").TextFrame2.TextRange.text = num
  s.Shapes("header").TextFrame2.TextRange.text = header
  s.Shapes("number").height = s.Shapes("body").height
  If complete Then s.Shapes("complete").TextFrame2.TextRange.text = "|fffd|"
  
End Sub



Sub moveTaskBox(Optional junk As Boolean)
On Error Resume Next
  activeDocument.Shapes("taskbox").top = ActiveCell.top
  activeDocument.Shapes("taskbox").left = ActiveCell.left


End Sub




'-------------------------- End of task form modules --------------------------------------------------------------------------------------






' only used on mac
Sub unLoadMenu(Optional junk As Boolean)
On Error Resume Next
CommandBars("Worksheet Menu Bar").Controls("&Assignment").Delete

End Sub


' only used on mac
Sub loadMenu(Optional junk As Boolean)
If version < 15 Then
  Dim graderMenu As CommandBarControl
  Dim windowMenu As CommandBarControl
  Set windowMenu = CommandBars("Worksheet Menu Bar").Controls("Window")
  Set graderMenu = CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup, Before:=windowMenu.index)
 ' Set graderMenu = CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup, before:=9)
  
  graderMenu.caption = "&Assignment"
    
  With graderMenu.Controls.Add
    .caption = "Show &Assignment in Browser"
    .OnAction = "xShowInBrowser"
  End With
  With graderMenu.Controls.Add
    .caption = "&Task Guide"
    .OnAction = "xShowTaskBox"
  End With
  If frmTask.Tag <> "Practice" Then
    With graderMenu.Controls.Add
      .caption = "&Submit"
      .OnAction = "xsubmit"
      .BeginGroup = True
    End With
  End If
  With graderMenu.Controls.Add
    .caption = "Grade Sheet"
    .OnAction = "xViewGradeSheet"
    If frmTask.Tag = "Practice" Then .BeginGroup = True
  End With
  
  With graderMenu.Controls.Add
    .caption = "Assignment &Tools"
    .OnAction = "assignment_tools"
    .BeginGroup = True
  End With
Else ' verions
  ' mac excel 2016
    If version < 15.18 Then
            Dim bar As CommandBar
            Dim Button As CommandBarButton
            
            Set bar = CommandBars.Add(name:="A", Temporary:=True)
            bar.visible = True
           
            
            Set Button = bar.Controls.Add(Type:=msoControlButton, Temporary:=True)
            Button.visible = True
            Button.caption = "Show Assignment"
            Button.FaceId = 2299 '916
            Button.OnAction = "xShowInBrowser"
            Button.style = msoButtonIconAndCaption
            
            Set Button = bar.Controls.Add(Type:=msoControlButton, Temporary:=True)
            Button.visible = True
            Button.caption = "Task Guide"
            Button.FaceId = 837
            Button.OnAction = "xShowTaskBox"
            Button.style = msoButtonIconAndCaption
            
            Set Button = bar.Controls.Add(Type:=msoControlButton, Temporary:=True)
            Button.visible = True
            Button.caption = "Submit"
            Button.FaceId = 220
            Button.OnAction = "xsubmit"
            Button.style = msoButtonIconAndCaption
            
            Set Button = bar.Controls.Add(Type:=msoControlButton, Temporary:=True)
            Button.visible = True
            Button.caption = "View Report"
            Button.FaceId = 229
            Button.OnAction = "xViewGradeSheet"
            Button.style = msoButtonIconAndCaption
        
            Set Button = bar.Controls.Add(Type:=msoControlButton, Temporary:=True)
            Button.visible = True
            Button.caption = "Show Tools"
            Button.FaceId = 642
            Button.OnAction = "assignment_tools"
            Button.style = msoButtonIconAndCaption
    End If
End If

End Sub







Function GetCellReferences(ByVal text As String) As String
  Dim a As Variant
  Dim x As Integer
  Dim l As String
  Dim y As Integer
  Dim oneWord As String
  Dim trimmedWord As String
  Dim onechar As String * 1
  Dim rangeRef As String
  Dim hasNum As Boolean
  Dim hasChr As Boolean
  text = Replace(text, " through ", ":", , , vbTextCompare)
  a = Split(text, " ")
  For x = 0 To UBound(a)
    oneWord = a(x)
      trimmedWord = ""
      hasNum = False
      hasChr = False
      For y = 1 To Len(oneWord)
        onechar = Mid(oneWord, y, 1)
        If IsNumeric(onechar) Then hasNum = True
        If Asc(UCase(onechar)) > 64 And Asc(UCase(onechar)) < 91 Then hasChr = True
        If IsNumeric(onechar) Or InStr(1, "abcdefghijklmnopqrstuvwxyz:", LCase(onechar)) Then trimmedWord = trimmedWord & onechar
      Next
      If hasNum And hasChr Then
        If Not IsNumeric(left(trimmedWord, 1)) Then
          rangeRef = rangeRef & "," & trimmedWord
        End If
      End If
  
  Next
  If rangeRef > "" Then GetCellReferences = Mid(rangeRef, 2)

End Function

Sub dumpModel(Optional junk As Boolean)
Dim a As assignment
Set a = loadassignment
exportModel a, Sheet1.Range("a1")

End Sub


Sub exportModel(a As assignment, cell As Range)

'entire column from start cell and two columns to right will be cleared.

Dim SheetName As String
Dim s As taskSet
Dim t As task
Dim r As rule
Dim i As instruction
Dim p As fill
Dim e As process
Dim sh As Worksheet
Dim row As Integer
Dim b As Object
Dim wb As Workbook
Dim app As Object
speedyCode
Set app = cell.Application

With app.Range(cell, cell.Cells(1, 3))
  .EntireColumn.Clear
  .Interior.color = 8421504
  .Font.bold = True
  .Font.color = white
  .EntireColumn.Borders(xlEdgeLeft).Weight = xlMedium
  .EntireColumn.Borders(xlEdgeRight).Weight = xlMedium
  .EntireColumn.Borders(xlInsideVertical).Weight = xlMedium
  .EntireColumn.Borders(xlEdgeLeft).color = 0
  .EntireColumn.Borders(xlEdgeRight).color = 0
  .EntireColumn.Borders(xlInsideVertical).color = 0
  .EntireColumn.Borders(xlEdgeLeft).LineStyle = xlContinuous
  .EntireColumn.Borders(xlEdgeRight).LineStyle = xlContinuous
  .EntireColumn.Borders(xlInsideVertical).LineStyle = xlContinuous
End With
cell.Cells(1, 3).EntireColumn.HorizontalAlignment = -4131 ' left align


ThisWorkbook.Activate

row = row + 1
cell.Cells(row, 1).value = "Object"
cell.Cells(row, 2).value = "Property"
cell.Cells(row, 3).value = "Value"

row = row + 1
cell.Cells(row, 1).value = "assignment"
cell.Cells(row, 2).value = "Version"
cell.Cells(row, 3).value = "'" & a.version

row = row + 1
cell.Cells(row, 1).value = "assignment"
cell.Cells(row, 2).value = "title"
cell.Cells(row, 3).value = "'" & a.title

row = row + 1
cell.Cells(row, 1).value = "assignment"
cell.Cells(row, 2).value = "studentBookName"
cell.Cells(row, 3).value = "'" & a.studentBookName

row = row + 1
cell.Cells(row, 1).value = "assignment"
cell.Cells(row, 2).value = "platform"
cell.Cells(row, 3).value = "'" & a.platform

row = row + 1
cell.Cells(row, 1).value = "assignment"
cell.Cells(row, 2).value = "submissionType"
cell.Cells(row, 3).value = "'" & a.submissionType

row = row + 1
cell.Cells(row, 1).value = "assignment"
cell.Cells(row, 2).value = "applicationSpecificData"
cell.Cells(row, 3).value = "'" & a.applicationSpecificData

row = row + 1
cell.Cells(row, 1).value = "assignment"
cell.Cells(row, 2).value = "guid"
cell.Cells(row, 3).value = "'" & a.guid

row = row + 1


For Each e In a.keyProcs: DoEvents
  Range(cell.Cells(row, 1), cell.Cells(row, 3)).Borders(xlEdgeTop).LineStyle = 1
  cell.Cells(row, 1).value = "keyprocess"
  cell.Cells(row, 2).value = "ID"
  cell.Cells(row, 3).value = e.id: row = row + 1
  cell.Cells(row, 1).value = "keyprocess"
  cell.Cells(row, 2).value = "procedureName"
  cell.Cells(row, 3).value = e.ProcedureName: row = row + 1
  cell.Cells(row, 1).value = "keyprocess"
  cell.Cells(row, 2).value = "paramList"
  cell.Cells(row, 3).value = e.paramList: row = row + 1
Next
For Each i In a.instructions: DoEvents
  app.Range(cell.Cells(row, 1), cell.Cells(row, 3)).Borders(xlEdgeTop).LineStyle = 1
  cell.Cells(row, 1).value = "instruction"
  cell.Cells(row, 2).value = "ID"
  cell.Cells(row, 3).value = i.id: row = row + 1
  cell.Cells(row, 1).value = "instruction"
  cell.Cells(row, 2).value = "text"
  cell.Cells(row, 3).value = i.text: row = row + 1
  cell.Cells(row, 1).value = "instruction"
  cell.Cells(row, 2).value = "textColor"
  cell.Cells(row, 3).value = i.textcolor: row = row + 1
Next
For Each s In a.taskSets: DoEvents
  app.Range(cell.Cells(row, 1), cell.Cells(row, 3)).Borders(xlEdgeTop).LineStyle = 1
  cell.Cells(row, 1).value = "taskSet"
  cell.Cells(row, 2).value = "ID"
  cell.Cells(row, 3).value = s.id: row = row + 1
  cell.Cells(row, 1).value = "taskSet"
  cell.Cells(row, 2).value = "title"
  cell.Cells(row, 3).value = s.title: row = row + 1
  cell.Cells(row, 1).value = "taskSet"
  cell.Cells(row, 2).value = "text"
  cell.Cells(row, 3).value = s.text: row = row + 1
  For Each t In s.tasks: DoEvents
    app.Range(cell.Cells(row, 1), cell.Cells(row, 3)).Borders(xlEdgeTop).LineStyle = 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "ID"
    cell.Cells(row, 3).value = t.id: row = row + 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "name"
    cell.Cells(row, 3).value = t.name: row = row + 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "text"
    cell.Cells(row, 3).value = t.text: row = row + 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "hint"
    cell.Cells(row, 3).value = t.hint: row = row + 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "exhibit"
    cell.Cells(row, 3).value = t.exhibit: row = row + 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "responseFormula"
    cell.Cells(row, 3).value = "'" & t.responseFormula: row = row + 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "xmlID"
    cell.Cells(row, 3).value = t.xmlID: row = row + 1
    cell.Cells(row, 1).value = "  task"
    cell.Cells(row, 2).value = "note"
    cell.Cells(row, 3).value = t.note: row = row + 1
    For Each r In t.rules: DoEvents
      app.Range(cell.Cells(row, 1), cell.Cells(row, 3)).Borders(xlEdgeTop).LineStyle = 1
      cell.Cells(row, 1).value = "    rule"
      cell.Cells(row, 2).value = "ID"
      cell.Cells(row, 3).value = r.id: row = row + 1
      cell.Cells(row, 1).value = "    rule"
      cell.Cells(row, 2).value = "name"
      cell.Cells(row, 3).value = "'" & r.name: row = row + 1
      cell.Cells(row, 1).value = "    rule"
      cell.Cells(row, 2).value = "points"
      cell.Cells(row, 3).value = r.points: row = row + 1
      cell.Cells(row, 1).value = "    rule"
      cell.Cells(row, 2).value = "RuleFormula"
      cell.Cells(row, 3).value = "'" & r.ruleFormula: row = row + 1
      cell.Cells(row, 1).value = "    rule"
      cell.Cells(row, 2).value = "ErrorMessage"
      cell.Cells(row, 3).value = r.errorMessage: row = row + 1
      For Each e In r.preProcs: DoEvents
        app.Range(cell.Cells(row, 1), cell.Cells(row, 3)).Borders(xlEdgeTop).LineStyle = 1
        cell.Cells(row, 1).value = "      preprocess"
        cell.Cells(row, 2).value = "ID"
        cell.Cells(row, 3).value = e.id: row = row + 1
        cell.Cells(row, 1).value = "      preprocess"
        cell.Cells(row, 2).value = "procedureName"
        cell.Cells(row, 3).value = e.ProcedureName: row = row + 1
        cell.Cells(row, 1).value = "      preprocess"
        cell.Cells(row, 2).value = "paramList"
        cell.Cells(row, 3).value = e.paramList: row = row + 1
      Next
      For Each p In r.preFills: DoEvents
        app.Range(cell.Cells(row, 1), cell.Cells(row, 3)).Borders(xlEdgeTop).LineStyle = 1
        cell.Cells(row, 1).value = "      prefill"
        cell.Cells(row, 2).value = "ID"
        cell.Cells(row, 3).value = p.id: row = row + 1
        cell.Cells(row, 1).value = "      prefill"
        cell.Cells(row, 2).value = "paramList"
        cell.Cells(row, 3).value = p.paramList: row = row + 1
        
        cell.Cells(row, 1).value = "      prefill"
        cell.Cells(row, 2).value = "revert"
        cell.Cells(row, 3).value = p.revert: row = row + 1
      Next
    Next
  Next
Next

app.Range(cell, cell.Cells(1, 3)).EntireColumn.AutoFit


'If Cell.Parent.name = modelsheet Then
'Set b = Cell.Parent.Buttons.Add(21, 37.2, 54, 17.4)
'If returnSheetExists("igmodel") Then
'  b.OnAction = "showBuilder"
'  b.Characters.text = "Edit"
'Else
'  b.OnAction = "assignment_tools"
'  b.Characters.text = "Tools"
'End If
'End If

speedyCode False

End Sub


Function loadModelFromText(Optional ByVal wb As Workbook, Optional ByVal a As assignment, Optional version As Single, Optional ByVal cell As Range, Optional ByVal SheetName As String) As assignment
  Dim row As Integer
  Dim ms As Worksheet
  Dim o As Object
  Dim object As String
  Dim property As String
  Dim value As String
  Dim lastObject As String
  Dim firstProperty As String
  
  If SheetName = "" Then SheetName = modelSheetName
  
  If cell Is Nothing Then
        If wb Is Nothing Then Set wb = ThisWorkbook
        If SheetExists(SheetName, wb) Then
          Set ms = wb.Worksheets(SheetName)
          Set cell = ms.Range("d1")
        Else
              If SheetExists("igmodel", wb) Then
                Set ms = wb.Worksheets("igmodel")
                Set cell = ms.Range("n1")
              Else
                Exit Function ' could not find any text model to import
              End If
        End If
  Else
       Set ms = cell.Parent
       Set wb = ms.Parent
  End If 'cell, ms, and wb
  row = 2
    
  If a Is Nothing Then Set a = New assignment
  Set o = a
  lastObject = "assignment"
  
  Do
    object = LCase(Trim(cell(row, 1).value))
    property = LCase(Trim(cell(row, 2).value))
    value = cell(row, 3).value
     If property = "id" Then
       Set o = a.addObject(object, value)
     ElseIf lastObject <> object Or firstProperty = property Then ' for the old version of the text model before the addition of IDs
       Set o = a.addObject(object)
        o.setProperty property, value
        firstProperty = property ' used to tell when we have started a second sequential rule or fill
     Else
       o.setProperty property, value
     End If
     lastObject = object
    row = row + 1
  Loop Until cell(row, 2).value = ""

  Set loadModelFromText = a

End Function

Sub showBuilder(Optional junk As Boolean)
  frmAssignmentGuide.Show
End Sub

Sub deleteSheet(SheetName, Optional wb As Workbook)

If wb Is Nothing Then Set wb = ThisWorkbook
On Error Resume Next
  Application.DisplayAlerts = False
    wb.Sheets(SheetName).visible = 1
    wb.Sheets(SheetName).Delete
  Application.DisplayAlerts = True
On Error GoTo 0

End Sub

Sub deleteBadNames(wb As Workbook)
Dim x As Long
Dim n As name
For x = wb.Names.count To 1 Step -1
  If InStr(1, left(wb.Names(x).value, 2), "#") > 0 Then
    On Error Resume Next
    wb.Names(x).Delete
    On Error GoTo 0
  End If
Next
End Sub


Sub addLocalRubric(NewRubric As String, startCell As Range)
  Dim data As Variant
  Dim oneline As Variant
    data = Split(Replace(NewRubric, "\u0007", """"), "\r\n")
    For r = 1 To UBound(data)
      oneline = Split(data(r - 1), "\t")
        If left(oneline(2), 1) = """" Then
          oneline(2) = Replace(Mid(oneline(2), 2, Len(oneline(2)) - 2), """""", """")
        End If
          startCell.Cells(r, 1).value = oneline(0)
          startCell.Cells(r, 2).value = oneline(1)
          startCell.Cells(r, 3).value = "'" & oneline(2)
    Next
End Sub

Sub updateLocalRubric(NewRubric As String)
    addLocalRubric NewRubric, ThisWorkbook.Sheets("igModel").Range("q1")
    ThisWorkbook.Sheets("igModel").Range("N:P").Delete
End Sub




Sub setWorkbookPatternColor(Optional w As Workbook)
Dim s As Worksheet
Dim cell As Range

If w Is Nothing Then Set w = ThisWorkbook

For Each s In w.Worksheets
  If s.name <> "Assignment Specification" And s.name <> "Enable Macros" Then
    For Each cell In s.UsedRange
      If cell.Interior.color < white Then ' if it is other than white, set it to 16777211(FFFBFFFF)
        cell.Interior.PatternColor = 16777211 ' 16777211=FFFBFFFF
      End If
    Next
  End If
Next

End Sub


Sub speedyCode(Optional fast As Boolean = True)
    Static screenUpdateState As Boolean
    Static statusBarState As Boolean
    Static eventsState As Boolean
    Static calcState As Long
    
    
    If fast Then
        screenUpdateState = Application.ScreenUpdating
        statusBarState = Application.DisplayStatusBar
        eventsState = Application.EnableEvents
        calcState = Application.Calculation
        Application.ScreenUpdating = False
        Application.DisplayStatusBar = False
        Application.Calculation = xlCalculationManual
        Application.EnableEvents = False
    
    Else
        Application.ScreenUpdating = screenUpdateState
        Application.DisplayStatusBar = statusBarState
        Application.Calculation = calcState
        Application.EnableEvents = eventsState
    
    End If
    
End Sub
Sub saveThisWorkbook(Optional paramaterToHide As Boolean)
  '   used by the process to create a workbook
  ThisWorkbook.Save
  If enableMacros.visible = xlSheetVisible Then
    showSheets
    ThisWorkbook.Saved = True
  End If
End Sub


' ----------------------------------- end of copied from modPresentation -----------------------------------------




Sub ConfigureGrader(wb As Workbook)
  Dim x As Integer
  Dim y As Integer
  Dim propName As String
  For x = 1 To wb.CustomDocumentProperties.count
    propName = wb.CustomDocumentProperties(x).name
    If left(propName, 1) = "[" Then
       For y = 1 To ThisWorkbook.CustomDocumentProperties.count
         If propName = ThisWorkbook.CustomDocumentProperties(y).name Then
           ThisWorkbook.CustomDocumentProperties(y).value = wb.CustomDocumentProperties(x).value
           Exit For
         End If
       Next
    ''debug.print wb.CustomDocumentProperties(x).Name
    End If
  Next
End Sub
Attribute VB_Name = "excelFunctions"

'This module is for code that only exists in Excel--there are not analogous functions for the other platforms

Option Explicit
Public RuleData As Variant
Public RuleMessage As Variant
Public foundcell As Range
Public targetWB As Workbook
Public closeTargetWB As Boolean
Public cellReferences As String


'============== added by gove 1/3/14 for grading a differnt workbook than thisWorkbook =========================
Function WorkbookPath(Optional bookname As String) As String
  'returns the path of this workbook or the open workbook with the specified name
  If bookname = "" Then
    WorkbookPath = ThisWorkbook.path & Application.pathSeparator
  Else
    WorkbookPath = Workbooks(bookname).path & Application.pathSeparator
  End If
End Function
Public Sub activateTargetWorkBook(Optional paramToHide As Boolean)
  targetWB.Activate
End Sub
Public Sub closeTargetWorkBook(Optional paramToHide As Boolean)
On Error Resume Next
If closeTargetWB Then targetWB.Close False
closeTargetWB = False
End Sub
Public Sub setTargetWB(ByVal path As String, workbookName As String)
 ' used for a preprocess
 ' sets the targetWB variable to allow functions to work on a different workbook

If Right(path, 1) = Application.pathSeparator Then path = left(path, Len(path) - 1)
Set targetWB = Workbooks(workbookName)

End Sub
Public Function isWorkbookOpen(ByVal path As String, workbookName As String)
Dim wb As Workbook
If Right(path, 1) = Application.pathSeparator Then path = left(path, Len(path) - 1)
For Each wb In Workbooks
  If LCase(path) = LCase(wb.path) And LCase(wb.name) = LCase(workbookName) Then
    isWorkbookOpen = True
    Exit Function
  End If
Next
End Function

Public Function fileAvailable(filepath As String) As Boolean
On Error GoTo returnFalse
  Dim i As Integer
  If Dir$(filepath) = "" Then
    GoTo returnFalse
  Else
    i = FreeFile()
    Open filepath For Random Access Read Write Lock Read Write As #i
    Lock i
    Unlock i
    Close i
  End If
  fileAvailable = True
  On Error GoTo 0
  Exit Function
returnFalse:
  fileAvailable = False
  On Error GoTo 0
End Function
'------------ end of newly added --------------------------


'============== added by gove a long time ago =========================

Function formulaContains(cellRefernece As Range, searchText As String, Optional caseSensitive As Boolean) As Boolean
 
  If caseSensitive Then
    formulaContains = InStr(1, cellRefernece.formula, searchText) > 0
  Else
    formulaContains = InStr(1, cellRefernece.formula, searchText, vbTextCompare) > 0
  End If

End Function
Function SheetName(rangeAddress As String) As String
  SheetName = Replace(Split(rangeAddress, "!")(0), "'", "")
End Function
Function addressOnly(rangeAddress As String, Optional absolute As Boolean) As String
  If absolute Then
    addressOnly = Split(rangeAddress, "!")(1)
  Else
    addressOnly = Replace(Split(rangeAddress, "!")(1), "$", "")
  End If
End Function

Function cellResponse(reference As Range) As String
  #If Mac Then
    cellResponse = Replace(reference.address, "$", "") & ": " & reference.formula
  #Else
  Dim SheetName As String
  SheetName = reference.Parent.name
  If Not SheetExists(SheetName) Then SheetName = "'" & SheetName & "'"
  cellResponse = SheetName & "!" & Replace(reference.address, "$", "") & ": " & reference.formula
  #End If
End Function

Function cellFormat(reference As Range, property As String) As String
  Dim SheetName As String
  SheetName = reference.Parent.name
  If Not SheetExists(SheetName) Then SheetName = "'" & SheetName & "'"
  Select Case LCase(property)
    Case "bold": cellFormat = SheetName & "!" & Replace(reference.address, "$", "") & ": font.Bold=" & reference.Cells(1).Font.bold
    Case "italic": cellFormat = SheetName & "!" & Replace(reference.address, "$", "") & ": font.italic=" & reference.Cells(1).Font.italic
  End Select
End Function

Function rememberValue(addr As String)
  Dim data As Variant
  data = Split(addr, "!")
  data = "'Retirement Planning'!$F$5"
  RuleData = Range(addr).value
End Function

Function getRuleData(Optional index As Byte, Optional delimiter As String = ",") As Variant
  If index > 0 Then
    getRuleData = Split(RuleData, delimiter)(index)
  Else
    getRuleData = RuleData
  End If
End Function

Function getRuleMessage(Optional index As Byte, Optional delimiter As String = ",") As Variant
  If index > 0 Then
    getRuleMessage = Split(RuleMessage, delimiter)(index)
  Else
    getRuleMessage = RuleMessage
  End If
End Function

Sub cellsArePrecedent(referentCellAddress As String, cellsToCheck As String)
  Dim c As Range
  Dim Ch As Range
  
On Error GoTo Hell
  
  Set Ch = Range(cellsToCheck)
  Set c = Range(referentCellAddress)
  If c.Precedents Is Nothing Then
    RuleData = False
  Else
    If c.Precedents.Cells.count = Application.Union(c.Precedents, Ch).count Then
      RuleData = True
    Else
      RuleData = False
    End If
  End If
  Exit Sub
  
Hell:
RuleData = False
  
End Sub

Sub cellsReferencedInFormula(referentCellAddress As String, cellsToCheck As String)
  Dim c As Range
  Dim Ch As Range
  Dim precedentCells As Range
  
  Set Ch = Sheets(Replace(Split(cellsToCheck, "!")(0), "'", "")).Range(Split(cellsToCheck, "!")(1))
  Set c = Sheets(Replace(Split(referentCellAddress, "!")(0), "'", "")).Range(Split(referentCellAddress, "!")(1))
  
  On Error Resume Next
    Set precedentCells = c.DirectPrecedents
  On Error GoTo 0
  
  If precedentCells Is Nothing Then
    RuleData = False
  Else
    If precedentCells.Cells.count = Application.Union(precedentCells, Ch).count Then
      RuleData = True
    Else
      RuleData = False
    End If
  End If
  
End Sub

Function between(theValue, boundary1, boundary2) As Boolean
    If theValue >= boundary1 And theValue <= boundary2 Or theValue <= boundary1 And theValue >= boundary2 Then between = True
End Function

Function findCellByPartialName(lookfor As String, SheetName As String) As Variant
  Dim n As name
  Dim r As Range
  For Each n In ThisWorkbook.Names
    On Error Resume Next
      Set r = n.RefersToRange
    On Error GoTo 0
    If Not r Is Nothing Then
      If LCase(r.Parent.name) = LCase(SheetName) Then
        If InStr(1, n.name, lookfor, vbTextCompare) > 0 Then
          Set findCellByPartialName = r
          Exit Function
        End If
      End If
    End If
  Next
findCellByPartialName = CVErr(xlErrRef)
  
End Function

Function findCell(lookfor As String, SheetName As String, Optional matchEntireCell As Boolean, _
                   Optional MatchCase As Boolean, Optional searchByRow As Boolean, Optional searchInFormulas As Boolean) As Variant
  Dim foundcell As Range
  Dim l As Long
  Dim r As Long
  Dim f As Long
  
  If searchInFormulas Then
    f = xlFormulas
  Else
    f = xlValues
  End If
  
  If matchEntireCell Then
    l = xlWhole
  Else
    l = xlPart
  End If
  
  If searchByRow Then
    r = xlByRows
  Else
    r = xlByColumns
  End If
  
  Set foundcell = Sheets(SheetName).Cells.find( _
        What:=lookfor, _
        LookIn:=f, _
        LookAt:=l, _
        SearchOrder:=r, _
        SearchDirection:=xlNext, _
        MatchCase:=MatchCase, _
        SearchFormat:=False _
        )
   If foundcell Is Nothing Then
     findCell = CVErr(xlErrRef)
   Else
     Set findCell = foundcell
   End If

End Function

'============== end of added by gove =========================
Function GetConditionalFormatting(cell As Range) As String
  Dim fc As Object
  Dim ic As IconCriterion
  Dim temp As String
  
  For Each fc In cell.FormatConditions
    Select Case fc.Type
      Case 6
        temp = temp & "~IconSet:" & "ShowIconOnly=" & fc.ShowIconOnly
        For Each ic In fc.IconCriteria
          temp = temp & "|" & getXlConditionValueType(ic.Type) & "," & getXlFormatConditionOperator(ic.operator) & "," & ic.value
        Next
       Case Else
         temp = "Formatting Condition Type " & fc.Type & " not yet implemented"
    End Select
  Next
  GetConditionalFormatting = temp
End Function

Function getXlConditionValueType(value As Integer) As String
Select Case value
  Case -1: getXlConditionValueType = "xlConditionValueNone"
  Case 0: getXlConditionValueType = "xlConditionValueNumber"
  Case 1: getXlConditionValueType = "xlConditionValueLowestValue"
  Case 2: getXlConditionValueType = "xlConditionValueHighestValue"
  Case 3: getXlConditionValueType = "xlConditionValuePercent"
  Case 4: getXlConditionValueType = "xlConditionValueFormula"
  Case 5: getXlConditionValueType = "xlConditionValuePercentile"
  Case 6: getXlConditionValueType = "xlConditionValueAutomaticMin"
  Case 7: getXlConditionValueType = "xlConditionValueAutomaticMax"
End Select

End Function

Function getXlFormatConditionOperator(value As Integer) As String
Select Case value
  Case 1: getXlFormatConditionOperator = "xlBetween"
  Case 2: getXlFormatConditionOperator = "xlNotBetween"
  Case 3: getXlFormatConditionOperator = "xlEqual"
  Case 4: getXlFormatConditionOperator = "xlNotEqual"
  Case 5: getXlFormatConditionOperator = "xlGreater"
  Case 6: getXlFormatConditionOperator = "xlLess"
  Case 7: getXlFormatConditionOperator = "xlGreaterEqual"
  Case 8: getXlFormatConditionOperator = "xlLessEqual"
End Select

End Function


Function rangeSearch(searchValue As String, SheetName As String, Optional Range As String) As String
' searches for a match (anywhere in the cell) for searchvalue in on the sheet specified. if range is specified, the search is limited to that range.  Returns the cell address where values is found or "" of not found
Dim searchRange As Range
Dim foundcell As Range

If SheetLike(SheetName) = "" Then Exit Function

If Range = "" Then
  Set searchRange = Sheets(SheetName).Cells
Else
  Set searchRange = Sheets(SheetName).Range(Range).Cells
End If

Set foundcell = searchRange.find(searchValue)

If Not foundcell Is Nothing Then
  rangeSearch = foundcell.address
End If
End Function

Function SheetLike(sheetPattern As String) As String
  'returns the name of the first sheet to match the given pattern
  Dim s As Worksheet
  For Each s In Worksheets
    If UCase(s.name) Like UCase(sheetPattern) Then
      SheetLike = s.name
      Exit Function
    End If
  Next
End Function

Function findInOneColumn(SheetName As String, startCol As Integer, endCol As Integer, pipeSeparatedValues As String) As Integer
' searches across the specified columns for ALL of the values in pipeSeparatedValues
' returns the number of the first column to have all data values or zero if unsuccessfull
' it uses a partial match--needed to overcome repeating decimals
Dim data As Variant
Dim foundcell As Range
Dim x As Integer
Dim y As Integer
Dim searchVal As Variant

If SheetLike(SheetName) = "" Then Exit Function

data = Split(pipeSeparatedValues, "|")
For x = startCol To endCol
  For y = 0 To UBound(data)
    searchVal = data(y)
    If IsNumeric(searchVal) Then searchVal = CDbl(searchVal)
    Set foundcell = Sheets(SheetName).columns(x).Cells.find(searchVal, , , xlPart)
    If foundcell Is Nothing Then GoTo nextColumn
  Next
  findInOneColumn = x
nextColumn:
Next

End Function

Function returnPivotTableData(SheetName As String, ReturnType As Integer)

Dim PT As PivotTable
Dim FieldCount As Integer
Dim ItemCount As Integer
Dim theData As String
Dim ItemCounter As Integer
Dim PTItem As PivotItem
Dim PTFilter As PivotFilter
Dim PTCells As Range

If returnPivotTableforSheet(SheetName) = False Then
    returnPivotTableData = False
Else
    
Set PT = returnPivotTableforSheet(SheetName)

Select Case ReturnType

Case 1
'Page Field Data
    For ItemCount = 1 To PT.pageFields.count
    
    theData = theData & "|" & PT.pageFields(ItemCount).name & "("
     For Each PTItem In PT.pageFields(ItemCount).PivotItems
    
        theData = theData & ":" & PTItem.name
        theData = theData & ":" & PTItem.visible
    
    Next
        theData = theData & ")"
    Next
    
    returnPivotTableData = theData

Case 2
'Row Field Data
    For ItemCount = 1 To PT.rowFields.count
    
    theData = theData & "|" & PT.rowFields(ItemCount).name & "("
    
        For Each PTItem In PT.rowFields(ItemCount).PivotItems
            theData = theData & ":" & PTItem.name
            theData = theData & ":" & PTItem.visible
        Next
        theData = theData & ")"
    Next
    
    returnPivotTableData = theData

Case 3
'Column Field Data
        
    For ItemCount = 1 To PT.columnFields.count
    
    theData = theData & "|" & PT.columnFields(ItemCount).name & "("
   
   For Each PTItem In PT.columnFields(ItemCount).PivotItems
    
        theData = theData & ":" & PTItem.name
        theData = theData & ":" & PTItem.visible
     
    
    Next
           theData = theData & ")"
 
            
    Next
    
    returnPivotTableData = theData

Case 4

'Data field Data
    For ItemCount = 1 To PT.dataFields.count
    
     
     theData = theData & "|" & PT.dataFields(ItemCount).name
     theData = theData & "(Display:" & PT.dataFields(ItemCount).Function
     theData = theData & ",Calculation:" & PT.dataFields(ItemCount).Calculation & ")"
        
         For Each PTItem In PT.dataFields(ItemCount).PivotItems
    
        theData = theData & ":" & PTItem.visible
     
    
    Next
    Next
    
    returnPivotTableData = theData
    

Case 5
'Label values

For ItemCount = 1 To PT.pageFields.count
    If PT.pageFields(ItemCount).name <> "Values" Then
    For Each PTFilter In PT.pageFields(ItemCount).PivotFilters
        theData = theData & "|" & PT.pageFields(ItemCount).name & "("
        theData = theData & PTFilter.FilterType
        theData = theData & ":" & PTFilter.Value1 & ")"
    Next
    End If
Next

For ItemCount = 1 To PT.rowFields.count
    If PT.rowFields(ItemCount).name <> "Values" Then
    For Each PTFilter In PT.rowFields(ItemCount).PivotFilters
        theData = theData & "|" & PT.rowFields(ItemCount).name & "("
        theData = theData & PTFilter.FilterType
        theData = theData & ":" & PTFilter.Value1 & ")"
    Next
    End If
Next

For ItemCount = 1 To PT.columnFields.count
    If PT.columnFields(ItemCount).name <> "Values" Then
    For Each PTFilter In PT.columnFields(ItemCount).PivotFilters
        theData = theData & "|" & PT.columnFields(ItemCount).name & "("
        theData = theData & PTFilter.FilterType
        theData = theData & ":" & PTFilter.Value1 & ")"
    Next
    End If
Next

returnPivotTableData = theData

Case 6
'The Data Values

    For Each PTCells In PT.TableRange1.Cells

        theData = theData & "|" & CStr(PTCells.value)
        
        
    Next
    
    returnPivotTableData = theData


Case 7
'check for sorting
For ItemCount = 1 To PT.pageFields.count
    If PT.pageFields(ItemCount).name <> "Values" Then
        theData = theData & "|" & PT.pageFields(ItemCount).name & "("
        theData = theData & PT.pageFields(ItemCount).AutoSortField
        theData = theData & ":" & PT.pageFields(ItemCount).AutoSortOrder & ")"
    End If
Next

For ItemCount = 1 To PT.rowFields.count
    If PT.rowFields(ItemCount).name <> "Values" Then
        theData = theData & "|" & PT.rowFields(ItemCount).name & "("
        theData = theData & PT.rowFields(ItemCount).AutoSortField
        theData = theData & ":" & PT.rowFields(ItemCount).AutoSortOrder & ")"
    End If
Next

For ItemCount = 1 To PT.columnFields.count
    If PT.columnFields(ItemCount).name <> "Values" Then
        theData = theData & "|" & PT.columnFields(ItemCount).name & "("
        theData = theData & PT.columnFields(ItemCount).AutoSortField
        theData = theData & ":" & PT.columnFields(ItemCount).AutoSortOrder & ")"
    End If
Next

returnPivotTableData = theData

End Select

End If



    

End Function
Function PivotTableCountforSheet(SheetName As String)

       
    Dim wb As Workbook
    Dim xlsPT As PivotTable
    Dim PTCount As Integer
    Dim xlsSheet As Worksheet
    
    
    
    Set wb = ActiveWorkbook
    For Each xlsSheet In wb.Worksheets
        If returnStrMatch(xlsSheet.name, SheetName) Then PTCount = xlsSheet.PivotTables.count
    Next xlsSheet
    

    PivotTableCountforSheet = PTCount
    
End Function

Function returnPivotTableforSheet(SheetName As String)

       
    Dim wb As Workbook
    Dim xlsPT As PivotTable
    Dim PTCount As Integer
    Dim xlsSheet As Worksheet
    
    
    returnPivotTableforSheet = False
    
        
    Set wb = ActiveWorkbook
    For Each xlsSheet In wb.Worksheets
        If returnStrMatch(xlsSheet.name, SheetName) Then
           If xlsSheet.PivotTables.count > 0 Then Set returnPivotTableforSheet = xlsSheet.PivotTables(1)
        End If
            
    Next xlsSheet
    
    
    
End Function




Function returnPivotTableforName(SheetName As String, PTableName As String)

       
    Dim wb As Workbook
    Dim xlsPT As PivotTable
    
    returnPivotTableforName = False

    Set wb = ActiveWorkbook

        For Each xlsPT In wb.Worksheets(SheetName).PivotTables
        
            If xlsPT.name = PTableName Then
                Set returnPivotTableforName = xlsPT
            End If
    
        Next


End Function
Function returnPivotTableforNameWildcard(SheetName As String, PTableName As String)

       
    Dim wb As Workbook
    Dim xlsPT As PivotTable
    
    returnPivotTableforNameWildcard = False

    Set wb = ActiveWorkbook

        For Each xlsPT In wb.Worksheets(SheetName).PivotTables
        
            If VBA.UCase(xlsPT.name) Like VBA.UCase(PTableName) Then
                Set returnPivotTableforNameWildcard = xlsPT
            End If
    
        Next


End Function



Function ReturnFormula(TheCell As Range)

    ReturnFormula = TheCell.formula
    


End Function

Function rql(query As String)
'valid RQL
' select cutsomerName from 'Answer Report 2'!B20:F24 where cutomerID = 55 (returns value of customerName column)
' select cutsomerName Address from 'Answer Report 2'!B20:F24 where cutomerID = 55 (returns address of customerName column)
' select _#_ from 'Answer Report 2'!B20:F24 where cutomerID = 55  (returns the number of the row in the table)
' select _#_ from Customers where cutomerID = 55  (Customers must be a named range)
' select cutsomerID from 'Answer Report 2'!B20:F24 where cutomerName like '*s?n' (returns value of customerID for names like hanson or andersen)



Dim projectField As String
Dim table As String
Dim restrictField As String
Dim restrictValue As String
Dim whereClause As String
Dim restrictOperator As String
Dim projectCol As Integer
Dim restrictCol As Integer
Dim notted As Boolean
Dim pos As Integer
Dim x As Integer
Dim cell As Range
Dim startRow As Integer
Dim theSummary As Variant
Dim theCount As Integer
Dim summaryOperation As String
Dim rangecloser As String

pos = InStr(1, query, " from ", vbTextCompare)
projectField = left(query, pos - 1)
pos = InStr(1, query, " ", vbTextCompare)
projectField = Trim(condenseSpaces(Mid(projectField, pos + 1)))

If InStr(1, projectField, "sum(", vbTextCompare) = 1 Then
  summaryOperation = "sum"
ElseIf InStr(1, projectField, "firstaddress(", vbTextCompare) = 1 Then
  summaryOperation = "firstaddress"
ElseIf InStr(1, projectField, "count(", vbTextCompare) = 1 Then
  summaryOperation = "count"
ElseIf InStr(1, projectField, "min(", vbTextCompare) = 1 Then
  summaryOperation = "min"
ElseIf InStr(1, projectField, "max(", vbTextCompare) = 1 Then
  summaryOperation = "max"
ElseIf InStr(1, projectField, "avg(", vbTextCompare) = 1 Then
  summaryOperation = "avg"
ElseIf InStr(1, projectField, "range(", vbTextCompare) = 1 Then
  summaryOperation = "range"
ElseIf InStr(1, projectField, "address(", vbTextCompare) = 1 Then
  summaryOperation = "address"
Else
  summaryOperation = "none"
End If

If Not summaryOperation = "none" Then
  projectField = Mid(projectField, Len(summaryOperation) + 2, Len(projectField) - Len(summaryOperation) - 2)
End If

pos = InStr(1, query, " from ", vbTextCompare)
table = Mid(query, pos + 6)
pos = InStr(1, table, " where ", vbTextCompare)
  

If pos = 0 Then
  restrictValue = "No Restriction No where clause"
  restrictCol = 1
  restrictOperator = "="
Else
  table = left(table, pos - 1)
  pos = InStr(1, LCase(query), " where ", vbTextCompare)
  whereClause = Trim(Mid(query, pos + 7))
  
  If InStr(1, whereClause, "not ", vbTextCompare) = 1 Then
    notted = True
    whereClause = Trim(Mid(whereClause, 5))
  End If
  
  restrictField = Split(Trim(Replace(whereClause, "=", " = ")), " ")(0)
  whereClause = Trim(Mid(whereClause, Len(restrictField) + 1))
  
  If left(whereClause, 1) = "=" Then
    restrictOperator = "="
  ElseIf left(whereClause, 2) = "<=" Then
    restrictOperator = "<="
  ElseIf left(whereClause, 2) = "<>" Then
    restrictOperator = "<>"
  ElseIf left(whereClause, 2) = ">=" Then
    restrictOperator = ">="
  ElseIf left(whereClause, 1) = "<" Then
    restrictOperator = "<"
  ElseIf left(whereClause, 1) = ">" Then
    restrictOperator = ">"
  ElseIf left(UCase(whereClause), 4) = "LIKE" Then
    restrictOperator = "like"
  Else
    rql = "Restrict operator not recognized in """ & whereClause & """"
    Exit Function
  End If
  
  restrictValue = Trim(Mid(whereClause, Len(restrictOperator) + 1))

  If Right(restrictField, 1) = "]" And left(restrictField, 1) = "[" Then
    restrictCol = Trim(Mid(restrictField, 2, Len(restrictField) - 2))
    startRow = 1 ' restrict field is provided as a number, assume there are no headers
  Else
    startRow = 2 ' restrict field provided as a name, there must be headers
    For x = 1 To Range(table).rows(1).Cells.count
      Set cell = Range(table).rows(1).Cells(x)
      If UCase(Replace(cell.value, " ", "_")) = UCase(restrictField) Then restrictCol = x
    Next
    If restrictCol = 0 Then
      rql = "Restriction Field (" & restrictField & ") not found"
      Exit Function
    End If
  End If
End If ' whereclause

If Right(projectField, 1) = "]" And left(projectField, 1) = "[" Then
  projectCol = Trim(Mid(projectField, 2, Len(projectField) - 2))
  startRow = 1 ' project field is provided as a number, assume there are no headers
Else
  startRow = 2 ' project field provided as a name, there must be headers
  For x = 1 To Range(table).rows(1).Cells.count
    Set cell = Range(table).rows(1).Cells(x)
    If UCase(Replace(cell.value, " ", "_")) = UCase(projectField) Then projectCol = x
  Next
  If projectCol = 0 And left(projectField, 1) & Right(projectField, 1) <> "__" Then
    rql = "Projection Field (" & projectField & ") not found"
    Exit Function
  End If
End If


For x = startRow To Range(table).rows.count
  If compare(Range(table).Cells(x, restrictCol).value, restrictOperator, restrictValue) Xor notted Then
    If projectField = "_#_" Then
      rql = x - (startRow - 1)
      Exit Function
    ElseIf summaryOperation = "firstaddress" Then
      rql = "'" & Range(table).Parent.name & "'!" & Range(table).Cells(x, projectCol).address
      Exit Function
    ElseIf summaryOperation = "sum" Then
      theSummary = theSummary + Range(table).Cells(x, projectCol).value
    ElseIf summaryOperation = "count" Then
      theSummary = theSummary + 1
    ElseIf summaryOperation = "min" Then
      If Range(table).Cells(x, projectCol).value = "" Then
        theSummary = Range(table).Cells(x, projectCol).value
      Else
        If Range(table).Cells(x, projectCol).value < theSummary Then theSummary = Range(table).Cells(x, projectCol).value
      End If
    ElseIf summaryOperation = "max" Then
      If Range(table).Cells(x, projectCol).value = "" Then
        theSummary = Range(table).Cells(x, projectCol).value
      Else
        If Range(table).Cells(x, projectCol).value > theSummary Then theSummary = Range(table).Cells(x, projectCol).value
      End If
    ElseIf summaryOperation = "avg" Then
      theSummary = theSummary + Range(table).Cells(x, projectCol).value
      theCount = theCount + 1
    ElseIf summaryOperation = "range" Or summaryOperation = "address" Then
      If theCount > 0 And Range(table).Cells(x, projectCol).row - theCount = 1 Then
        rangecloser = Range(table).Cells(x, projectCol).address
      Else
        If rangecloser = "" Then
          theSummary = theSummary & "," & "'" & Range(table).Parent.name & "'!" & Range(table).Cells(x, projectCol).address
        Else
          theSummary = theSummary & "," & "'" & Range(table).Parent.name & "'!" & Range(table).Cells(x, projectCol).address & ":" & rangecloser
        End If
        rangecloser = ""
      End If
      theCount = Range(table).Cells(x, projectCol).row
    Else
      rql = Range(table).Cells(x, projectCol).value
      Exit Function
    End If
  End If
Next

Select Case summaryOperation
  Case "sum"
    rql = theSummary
  Case "count"
    rql = theSummary
  Case "min"
    rql = theSummary
  Case "max"
    rql = theSummary
  Case "avg"
    rql = theSummary / theCount
  Case "address"
    If rangecloser = "" Then
       rql = Mid(theSummary, 2)
    Else
       rql = Mid(theSummary, 2) & (":" + rangecloser)
    End If
  Case "range"
    If rangecloser = "" Then
       Set rql = Range(Mid(theSummary, 2))
    Else
       Set rql = Range(Mid(theSummary, 2) & (":" + rangecloser))
    End If
  Case Else
    rql = "Not Found"
End Select
End Function
Function splitAndChoose(dataToSplit As String, delimiter As String, entryToReturn As Integer)
  splitAndChoose = Split(dataToSplit, delimiter)(entryToReturn - 1)
End Function
Function rangeToList(theRange As Range, Optional delimiter As String = ",") As String
  Dim cell As Range
  Dim s As String
  
  For Each cell In theRange
    s = s & delimiter & cell.value
  Next
  rangeToList = Mid(s, Len(delimiter) + 1)
End Function
Function makeRange(theString) As Range
  Set makeRange = Range(theString)
End Function

Function compare(expr1, operator As String, expr2) As Boolean
  Dim expr3 As Variant
  Dim expr4 As Variant
  
  If expr2 = "No Restriction No where clause" Then
    compare = True
    Exit Function
  End If
  
  If left(expr2, 1) = "'" Then
  'we are doing a string comparison
    expr3 = CStr(expr1)
    expr4 = CStr(Mid(expr2, 2, Len(expr2) - 2))
  Else
    expr3 = CDbl(expr1)
    expr4 = CDbl(expr2)
  End If
  
  Select Case UCase(operator)
    Case "="
      compare = expr3 = expr4
    Case "<="
      compare = expr3 <= expr4
    Case ">="
      compare = expr3 >= expr4
    Case "<>"
      compare = expr3 <> expr4
    Case "<"
      compare = expr3 < expr4
    Case ">"
      compare = expr3 > expr4
    Case "LIKE"
      compare = expr3 Like expr4
    Case Else
      compare = False
  End Select
  
  
End Function
Function condenseSpaces(d As String) As String
Dim t As String
t = d
Do Until InStr(1, t, "  ") = 0
  t = Replace(t, "  ", " ")
Loop
condenseSpaces = t

End Function


Function solverCell() As Range
  Set solverCell = foundcell
End Function
Function findSolverRange(SheetName As String, table As String) As String
'header objective variable constrant
Dim t As String * 1
Dim searchRange As Range
Dim s As Worksheet

Set s = Sheets(SheetName)

t = UCase(left(table, 1))
Select Case t
  Case "C"
    Set searchRange = Range(s.Cells(s.rows.count, 1).End(xlUp).offset(1, 1).End(xlToRight), s.Cells(s.rows.count, 1).End(xlUp).offset(1, 1).End(xlDown))
  Case "V"
    Set searchRange = Range(s.Cells(s.rows.count, 1).End(xlUp).End(xlUp).offset(1, 1).End(xlToRight), s.Cells(s.rows.count, 1).End(xlUp).End(xlUp).offset(1, 1).End(xlDown))
  Case "O"
    Set searchRange = Range(s.Cells(s.rows.count, 1).End(xlUp).End(xlUp).End(xlUp).offset(1, 1).End(xlToRight), s.Cells(s.rows.count, 1).End(xlUp).End(xlUp).End(xlUp).offset(1, 1).End(xlDown))
  Case Else
    Set searchRange = Range(s.Range("a1"), s.Cells(s.rows.count, 1).End(xlUp).End(xlUp).End(xlUp).offset(0, 1).End(xlUp))
End Select

findSolverRange = "'" & searchRange.Parent.name & "'!" & searchRange.address


End Function




Function ReturnChartCount()

Dim xlsChart As Chart
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet
Dim ChartCount As Integer


For Each xlsSheet In Worksheets
    ChartCount = ChartCount + xlsSheet.ChartObjects.count
Next

ReturnChartCount = ChartCount + ActiveWorkbook.Charts.count

End Function



Function GetFormat(cell As Range) As String 'returns a lot of format info..from  http://dmcritchie.mvps.org/excel/formula.htm#GetFormula
   GetFormat = cell.numberFormat
End Function
Function CellIsHidden(cell As Range) As Boolean
    CellIsHidden = False
    If cell.ColumnWidth = 0 Or cell.rowHeight = 0 Then CellIsHidden = True
End Function
Function SheetExists(sh As String, Optional wb As Workbook)


Dim xlsSheet As Worksheet
Dim SheetName As String

SheetName = sh

If wb Is Nothing Then
  Set wb = ActiveWorkbook
End If

SheetExists = False

    For Each xlsSheet In wb.Worksheets

      If returnStrMatch(xlsSheet.name, SheetName) Then SheetExists = True
      
    Next


End Function

Function MergedCellArea(cell As Range)
    MergedCellArea = cell.MergeArea.address
End Function
Function CellCentered(Cells As Range) As Boolean

    Dim checkCell As Range
    Dim CountCentered As Integer
    Dim CellsCount As Integer
    
    CellsCount = Cells.count
    CountCentered = 0
    
    CellCentered = False
    
    For Each checkCell In Cells
    
        If Cells.HorizontalAlignment = xlCenter Then CountCentered = CountCentered + 1
    
    Next
    
    If CountCentered = CellsCount Then CellCentered = True


    
End Function
Function CellBolded(Cells As Range) As Boolean
    
    Dim checkCell As Range
    Dim CountBolded As Integer
    Dim CellsCount As Integer
    
    CellsCount = Cells.count
    CountBolded = 0
    
    CellBolded = False
    
    For Each checkCell In Cells
    
        If checkCell.Font.bold Then CountBolded = CountBolded + 1
    
    Next
    
    If CountBolded = CellsCount Then CellBolded = True
    

End Function
Function CellItalicized(cell As Range) As Boolean
    CellItalicized = cell.Font.italic = True
End Function
Function CellBottomBorderThick(cell As Range) As Boolean
    CellBottomBorderThick = False
    If (cell.Borders(xlEdgeBottom).LineStyle = 1 And cell.Borders(xlEdgeBottom).Weight = -4138) Then CellBottomBorderThick = True
End Function
Function CellBottomBorderDotted(cell As Range) As Boolean
CellBottomBorderDotted = False
    If cell.Borders(xlEdgeBottom).LineStyle = 1 Then CellBottomBorderDotted = True
End Function
Function CellColorIndex(cell As Range)
    CellColorIndex = cell.Interior.ColorIndex
End Function
Function PageLeftMargin(Page As String)
    PageLeftMargin = Sheets(Page).PageSetup.LeftMargin
End Function
Function PageRightMargin(Page As String)
    PageRightMargin = Sheets(Page).PageSetup.LeftMargin
End Function
Function PagePrintArea(Page As String)
    PagePrintArea = Sheets(Page).PageSetup.PrintArea
End Function
Function PagePrintTitleRows(Page As String)
    PagePrintTitleRows = Sheets(Page).PageSetup.PrintTitleRows
End Function
Function PagePrintTitleColumns(Page As String)
    PagePrintTitleColumns = Sheets(Page).PageSetup.PrintTitleColumns
End Function
Function CellBottomBorderIndex(cell As Range)
    CellBottomBorderIndex = cell.Borders(xlEdgeBottom).LineStyle
End Function
Function CellBottomBorderWeight(cell As Range)
    CellBottomBorderWeight = cell.Borders(xlEdgeBottom).Weight
End Function
Function CellTextWrapped(cell As Range)
    CellTextWrapped = cell.WrapText
End Function
Function FormulaContents(cell As Range)
    Dim formula As String
    formula = cell.formula
 '   FormulaContents = False
    
 '   If Formula <> "" Then FormulaContents = Formula
    FormulaContents = formula

End Function
Function FormulaContentsNoAbs(cell As Range)
    
    
    
    FormulaContentsNoAbs = VBA.Replace(cell.formula, "$", "")
End Function

Function returnFuncParts(cell As Range, funPart As Integer)

Dim formula As String
Dim length As Integer
Dim FormParts(0 To 20) As String
Dim findFormName As Long
Dim FormEnd As Long
Dim TxtPos As Long
Dim ArgPos As Long
Dim PrevStart As Long
Dim n As Long
Dim nLParen As Integer


returnFuncParts = False



'get the formula contents and return formula if no parse request

If funPart = -1 Then
    returnFuncParts = cell.formula

Else


formula = VBA.Replace(cell.formula, " ", "")


If formula <> "" Then

findFormName = VBA.InStr(1, formula, "(", vbBinaryCompare)

If findFormName > 0 Then

'get the function name used (note that this is the first function

FormParts(0) = VBA.Mid(formula, 2, findFormName - 2)

'initialize parsing variables

FormEnd = VBA.Len(formula)

TxtPos = findFormName
ArgPos = 1
PrevStart = TxtPos + 1

'parse through the formula to get all but the last arguments

For n = TxtPos To VBA.Len(formula)
  
  If VBA.Mid(formula, n, 1) = "(" Then nLParen = nLParen + 1
  If VBA.Mid(formula, n, 1) = ")" Then nLParen = nLParen - 1

  If nLParen = 1 And VBA.Mid(formula, n, 1) = "," Then
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, n - PrevStart)
    ArgPos = ArgPos + 1
    PrevStart = n + 1
  End If
  
  If nLParen = 0 Then
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, n - PrevStart)
    ArgPos = ArgPos + 1
    PrevStart = n + 1
    Exit For
  End If
  
Next
    'get the last argument
 
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, VBA.Len(formula))

returnFuncParts = FormParts(funPart)

End If
End If

End If


End Function
Function returnFuncPartsNoAbs(cell As Range, funPart As Integer)

Dim formula As String
Dim length As Integer
Dim FormParts(0 To 20) As String
Dim findFormName As Long
Dim FormEnd As Long
Dim TxtPos As Long
Dim ArgPos As Long
Dim PrevStart As Long
Dim n As Long
Dim nLParen As Integer

returnFuncPartsNoAbs = False

'get the formula contents and return formula if no parse request

If funPart = -1 Then
    returnFuncPartsNoAbs = Replace(cell.formula, "$", "")
    

Else

formula = VBA.Replace(cell.formula, " ", "")

If formula <> "" Then

findFormName = VBA.InStr(1, formula, "(", vbBinaryCompare)

If findFormName > 0 Then

'get the function name used (note that this is the first function

FormParts(0) = VBA.Mid(formula, 2, findFormName - 2)

'initialize parsing variables

FormEnd = VBA.Len(formula)

TxtPos = findFormName
ArgPos = 1
PrevStart = TxtPos + 1

'parse through the formula to get all but the last arguments

For n = TxtPos To VBA.Len(formula)
  
  If VBA.Mid(formula, n, 1) = "(" Then nLParen = nLParen + 1
  If VBA.Mid(formula, n, 1) = ")" Then nLParen = nLParen - 1

  If nLParen = 1 And VBA.Mid(formula, n, 1) = "," Then
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, n - PrevStart)
    FormParts(ArgPos) = VBA.Replace(FormParts(ArgPos), "$", "", 1)
    ArgPos = ArgPos + 1
    PrevStart = n + 1
  End If
  
  If nLParen = 0 Then
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, n - PrevStart)
    FormParts(ArgPos) = VBA.Replace(FormParts(ArgPos), "$", "", 1)
    ArgPos = ArgPos + 1
    PrevStart = n + 1
    Exit For
  End If
  
Next
    'get the last argument
 
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, VBA.Len(formula))
    FormParts(ArgPos) = VBA.Replace(FormParts(ArgPos), "$", "", 1)
    

returnFuncPartsNoAbs = FormParts(funPart)

End If
End If
End If


End Function

Function returnFuncPartsString(Funct As String, funPart As Integer)

Dim formula As String
Dim length As Integer
Dim FormParts(0 To 20) As String
Dim findFormName As Long
Dim FormEnd As Long
Dim TxtPos As Long
Dim ArgPos As Long
Dim PrevStart As Long
Dim n As Long
Dim nLParen As Integer

returnFuncPartsString = False

'get the formula contents

formula = VBA.Replace(Funct, " ", "")
If formula <> "" Then

findFormName = VBA.InStr(1, formula, "(", vbBinaryCompare)
If findFormName > 0 Then



'get the function name used (note that this is the first function

FormParts(0) = VBA.Mid(formula, 1, findFormName - 1)

'initialize parsing variables

FormEnd = VBA.Len(formula)

TxtPos = findFormName
ArgPos = 1
PrevStart = TxtPos + 1

'parse through the formula to get all but the last arguments

For n = TxtPos To VBA.Len(formula)
  
  If VBA.Mid(formula, n, 1) = "(" Then nLParen = nLParen + 1
  If VBA.Mid(formula, n, 1) = ")" Then nLParen = nLParen - 1

  If nLParen = 1 And VBA.Mid(formula, n, 1) = "," Then
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, n - PrevStart)
    ArgPos = ArgPos + 1
    PrevStart = n + 1
  End If
  
Next
    'get the last argument
    FormParts(ArgPos) = VBA.Mid(formula, PrevStart, n - PrevStart - 1)
returnFuncPartsString = FormParts(funPart)

End If
End If


End Function
Function returnChartTitleExists(ChrtSeries As String)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

ChartName = ReturnChartNameForSeries(ChrtSeries)
returnChartTitleExists = False
Set wb = ActiveWorkbook
    For Each xlsSheet In wb.Worksheets
        If xlsSheet.ChartObjects.count > 0 Then
            For Each xlsSheetChart In xlsSheet.ChartObjects
                If xlsSheetChart.Chart.HasTitle Then If returnStrMatch(xlsSheetChart.Chart.name, ChartName) Then returnChartTitleExists = True
            Next
        End If
    Next

    For Each xlsChart In wb.Charts
        If xlsChart.HasTitle Then If returnStrMatch(xlsChart.name, ChartName) Then returnChartTitleExists = True
    Next xlsChart
 
End Function
Function returnChartOwnSheet(ChartSeries As String)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String

ChartName = ReturnChartNameForSeries(ChartSeries)

returnChartOwnSheet = False

Set wb = ActiveWorkbook

For Each xlsChart In wb.Charts
    If returnStrMatch(xlsChart.name, ChartName) Then returnChartOwnSheet = True
Next xlsChart

End Function
Function returnSheetExists(title As String)

Dim wb As Workbook
Dim xlsSheet As Worksheet
Dim SheetTitle As String

SheetTitle = title
returnSheetExists = False

Set wb = ActiveWorkbook

For Each xlsSheet In wb.Worksheets
  If returnStrMatch(xlsSheet.name, SheetTitle) Then returnSheetExists = True
Next xlsSheet


End Function

Function returnSheetExistsExact(title As String)

Dim wb As Workbook
Dim xlsSheet As Worksheet
Dim SheetTitle As String

SheetTitle = title
returnSheetExistsExact = False

Set wb = ActiveWorkbook

For Each xlsSheet In wb.Worksheets
  If xlsSheet.name = SheetTitle Then returnSheetExistsExact = True
Next xlsSheet


End Function

Function returnChartLegend(ChartSeries As String)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

ChartName = ReturnChartNameForSeries(ChartSeries)

returnChartLegend = False
Set wb = ActiveWorkbook
    For Each xlsSheet In wb.Worksheets
        If xlsSheet.ChartObjects.count > 0 Then
            For Each xlsSheetChart In xlsSheet.ChartObjects
            If returnStrMatch(xlsSheetChart.Chart.name, ChartName) Then returnChartLegend = xlsSheetChart.Chart.HasLegend
            Next
        End If
    Next

    For Each xlsChart In wb.Charts
        If returnStrMatch(xlsChart.name, ChartName) Then returnChartLegend = xlsChart.HasLegend
     Next xlsChart

End Function
Function ReturnChartType(ChrtSeries As String)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet
Dim ChartCounter As Integer

ChartName = ReturnChartNameForSeries(ChrtSeries)
ReturnChartType = False

Set wb = ActiveWorkbook
For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
            If returnStrMatch(xlsSheetChart.Chart.name, ChartName) Then ReturnChartType = xlsSheetChart.Chart.ChartType
        Next
    End If
Next

Set wb = ActiveWorkbook
For Each xlsChart In wb.Charts
    If returnStrMatch(xlsChart.name, ChartName) Then ReturnChartType = xlsChart.ChartType
Next xlsChart
      
End Function
Function returnChartXValues(ChrtSeries As String)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

ChartName = ReturnChartNameForSeries(ChrtSeries)
returnChartXValues = False
Set wb = ActiveWorkbook
For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
            If returnStrMatch(xlsSheetChart.Chart.name, ChartName) Then returnChartXValues = Join(xlsSheetChart.Chart.SeriesCollection(1).XValues, ":")
        Next
    End If
Next

Set wb = ActiveWorkbook
     For Each xlsChart In wb.Charts
        If returnStrMatch(xlsChart.name, ChartName) Then returnChartXValues = Join(xlsChart.SeriesCollection(1).XValues, ":")
     Next xlsChart
End Function
Function returnChartSeriesValues(ChrtSeries As String, SeriesNumber As Integer)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String
Dim ChartSeries As String
Dim ChartSeriesNumber As Integer
Dim ChartValuesArray() As Variant
Dim ChartSeriesValues As String
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

ChartName = ReturnChartNameForSeries(ChrtSeries)
ChartSeries = ChrtSeries
ChartSeriesNumber = SeriesNumber

returnChartSeriesValues = False

Set wb = ActiveWorkbook

    For Each xlsSheet In wb.Worksheets
        If xlsSheet.ChartObjects.count > 0 Then
            For Each xlsSheetChart In xlsSheet.ChartObjects
                If returnStrMatch(xlsSheetChart.Chart.name, ChartName) Then
                    If xlsSheetChart.Chart.SeriesCollection.count < ChartSeriesNumber Then
                        returnChartSeriesValues = False
                    Else
                        ChartValuesArray = xlsSheetChart.Chart.SeriesCollection(ChartSeriesNumber).values
                        ChartSeriesValues = xlsSheetChart.Chart.SeriesCollection(ChartSeriesNumber).name & ":" & Join(ChartValuesArray, ":")
                        If returnSeriesMatchesSet(ChartSeriesValues, ChartSeries) Then returnChartSeriesValues = True
                    End If
                End If
            Next
        End If
    Next

Set wb = ActiveWorkbook
    For Each xlsChart In wb.Charts
        If returnStrMatch(xlsChart.name, ChartName) Then
            If xlsChart.SeriesCollection.count < ChartSeriesNumber Then
                returnChartSeriesValues = False
            Else
                ChartValuesArray = xlsChart.SeriesCollection(ChartSeriesNumber).values
                ChartSeriesValues = xlsChart.SeriesCollection(ChartSeriesNumber).name & ":" & Join(ChartValuesArray, ":")
                If returnSeriesMatchesSet(ChartSeriesValues, ChartSeries) Then returnChartSeriesValues = True
            End If
        End If
    Next xlsChart

End Function
Function returnChartTrendLine(ChrtSeries As String)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String
Dim seriesCount As Integer
Dim TrendlineCount As Integer
Dim FindChart
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

ChartName = ReturnChartNameForSeries(ChrtSeries)
TrendlineCount = 0
FindChart = 0

Set wb = ActiveWorkbook
For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
            If returnStrMatch(xlsSheetChart.Chart.name, ChartName) Then
                FindChart = 1
                For seriesCount = 1 To xlsSheetChart.Chart.SeriesCollection.count
                    TrendlineCount = TrendlineCount + xlsSheetChart.Chart.SeriesCollection(seriesCount).Trendlines.count
                Next
            End If
        Next
    End If
Next

For Each xlsChart In wb.Charts
    If returnStrMatch(xlsChart.name, ChartName) Then
        FindChart = 1
        For seriesCount = 1 To xlsChart.SeriesCollection.count
            TrendlineCount = TrendlineCount + xlsChart.SeriesCollection(seriesCount).Trendlines.count
        Next
             
    End If
Next xlsChart
     
returnChartTrendLine = False
If FindChart > 0 And TrendlineCount > 0 Then returnChartTrendLine = True
     
End Function
Function returnChartLabels(ChartSeries As String)

Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartName As String
Dim seriesCount As Integer
Dim FindChart
Dim LabelCount As Integer
Dim LabelFound As Boolean
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

ChartName = ReturnChartNameForSeries(ChartSeries)
FindChart = 0
LabelCount = 0

Set wb = ActiveWorkbook
    For Each xlsSheet In wb.Worksheets
        If xlsSheet.ChartObjects.count > 0 Then
            For Each xlsSheetChart In xlsSheet.ChartObjects
                If returnStrMatch(xlsSheetChart.Chart.name, ChartName) Then
                    FindChart = 1
                    For seriesCount = 1 To xlsSheetChart.Chart.SeriesCollection.count
                        If xlsSheetChart.Chart.SeriesCollection(seriesCount).HasDataLabels Then LabelCount = LabelCount + 1
                    Next
                End If
            Next
        End If
    Next
     
    For Each xlsChart In wb.Charts
        If returnStrMatch(xlsChart.name, ChartName) Then
            FindChart = 1
            For seriesCount = 1 To xlsChart.SeriesCollection.count
                If xlsChart.SeriesCollection(seriesCount).HasDataLabels Then LabelCount = LabelCount + 1
            Next
        End If
    Next xlsChart
     
returnChartLabels = False
     
If FindChart > 0 Then
    If LabelCount > 0 Then returnChartLabels = True
End If

End Function

Function returnTextMatchesSetLoose(TestString As String, matchesSet As String)

Dim testStr As String
Dim matches() As String
Dim matchCount As Integer

testStr = TestString
matches = Split(matchesSet, ":")

returnTextMatchesSetLoose = 0

For matchCount = 0 To UBound(matches)

If testStr Like "*" & matches(matchCount) & "*" Then returnTextMatchesSetLoose = matchCount + 1


Next


End Function

Function returnSeriesMatchesSetbyArg(TestString As String, argNumber As Integer, matchesSet As String)

Dim testStr() As String
Dim matches() As String
Dim matchCount As Integer
Dim argNum As Integer


testStr = Split(TestString, ":")
matches = Split(matchesSet, ":")
argNum = argNumber - 1


returnSeriesMatchesSetbyArg = False

For matchCount = 0 To UBound(matches)

If testStr(argNum) = matches(matchCount) Then returnSeriesMatchesSetbyArg = True



Next


End Function



Function returnSeriesMatchesSet(TestString As String, matchesSet As String)

Dim testStr() As String
Dim matches() As String
Dim testNum As Integer
Dim matchNum As Integer
Dim matchesCount As Integer



testStr = Split(TestString, ":")
matches = Split(matchesSet, ":")
matchesCount = 0


returnSeriesMatchesSet = False


For testNum = 0 To UBound(testStr)

    For matchNum = 0 To UBound(matches)

    If testStr(testNum) = matches(matchNum) Then matchesCount = matchesCount + 1
      
    Next

Next

If matchesCount >= UBound(matches) Then returnSeriesMatchesSet = True
If UBound(matches) < 1 Then returnSeriesMatchesSet = False


End Function

Function returnStrMatch(TestString As String, MatchString As String)

Dim testStr As String
Dim matchStr As String

testStr = TestString
matchStr = MatchString

testStr = VBA.UCase(testStr)
matchStr = VBA.UCase(matchStr)

testStr = VBA.Replace(testStr, " ", "")
matchStr = VBA.Replace(matchStr, " ", "")
testStr = VBA.Replace(testStr, vbCr, "")
matchStr = VBA.Replace(matchStr, vbCr, "")
testStr = VBA.Replace(testStr, """", "")
matchStr = VBA.Replace(matchStr, """", "")


returnStrMatch = False
If testStr = matchStr Then returnStrMatch = True

End Function

Function returnNumMatchSet(testType As Integer, matchType As String)

Dim testTy As String
Dim matchTy() As String
Dim matchCount As Integer


testTy = CStr(testType)
matchTy = Split(matchType, ":")

returnNumMatchSet = False

For matchCount = 0 To UBound(matchTy)

If matchTy(matchCount) = testTy Then returnNumMatchSet = True

Next


End Function
Function ReturnChartNameForSeries(SeriesInf As String)

Dim SeriesInfo As String
Dim ChartSeriesInfo As String
Dim ChartSeriesNumber As Integer
Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartTitle As String
Dim ChartValuesArray() As Variant
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

SeriesInfo = SeriesInf
ReturnChartNameForSeries = ""
Set wb = ActiveWorkbook

For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
            For ChartSeriesNumber = 1 To xlsSheetChart.Chart.SeriesCollection.count
            ChartValuesArray = xlsSheetChart.Chart.SeriesCollection(ChartSeriesNumber).values
            ChartSeriesInfo = xlsSheetChart.Chart.SeriesCollection(ChartSeriesNumber).name & ":" & Join(ChartValuesArray, ":")
            If returnSeriesMatchesSet(SeriesInfo, ChartSeriesInfo) Then ReturnChartNameForSeries = xlsSheetChart.Chart.name
            Next
        Next
    End If
Next

Set wb = ActiveWorkbook

For Each xlsChart In wb.Charts
    For ChartSeriesNumber = 1 To xlsChart.SeriesCollection.count
        ChartValuesArray = xlsChart.SeriesCollection(ChartSeriesNumber).values
        ChartSeriesInfo = xlsChart.SeriesCollection(ChartSeriesNumber).name & ":" & Join(ChartValuesArray, ":")
        If returnSeriesMatchesSet(SeriesInfo, ChartSeriesInfo) Then ReturnChartNameForSeries = xlsChart.name
    Next
Next xlsChart

End Function

Function returnCheckCellValue(ChkSht As String, chkCell As String, CellVal As Variant)

Dim checkSheet As String
Dim checkCell As String
Dim CellValue As Variant
Dim SheetName As String


checkSheet = ChkSht
checkCell = chkCell
CellValue = CellVal

returnCheckCellValue = False
SheetName = returnSheetName(checkSheet)

If SheetName <> "" Then
    If Worksheets(SheetName).Range(checkCell).value = CellValue Then returnCheckCellValue = True
End If





End Function

Function returnSheetName(title As String)

Dim wb As Workbook
Dim xlsSheet As Worksheet
Dim SheetTitle As String

SheetTitle = title
returnSheetName = ""


Set wb = ActiveWorkbook

For Each xlsSheet In wb.Worksheets
  If returnStrMatch(xlsSheet.name, SheetTitle) Then returnSheetName = xlsSheet.name
Next xlsSheet



End Function

Function returnNumberFilteredRows(ShtName As String, ShtRng As String, SubType As Integer)

Dim checkSheet As String
Dim checkRange As String
Dim SheetName As String
Dim SubTotalType As Integer


checkSheet = ShtName
checkRange = ShtRng
SubTotalType = SubType

returnNumberFilteredRows = False

SheetName = returnSheetName(checkSheet)

If SheetName <> "" Then
    returnNumberFilteredRows = WorksheetFunction.Subtotal(SubType, Worksheets(SheetName).Range(checkRange))
End If

End Function

Function ReturnWithinFormula(checkCell As Range, MatchS As String, AbsMat As Integer)
Dim formula As String
Dim MatchString As String
Dim AbsMatter As Integer

ReturnWithinFormula = False

MatchString = MatchS
AbsMatter = AbsMat
formula = checkCell.formula


If AbsMatter = 0 Then
    formula = VBA.Replace(formula, "$", "")
    MatchString = VBA.Replace(MatchString, "$", "")
End If

If VBA.InStr(1, formula, MatchString) > 0 Then ReturnWithinFormula = True

End Function

Function SearchNoErr(FindTxt As String, WithinTxt As String, Optional StPos As Integer)

Dim FindText As String
Dim WithinText As String
Dim StartPos As Integer
Dim FindPos As Integer
Dim findCount As Integer

FindText = FindTxt
WithinText = WithinTxt
StartPos = StPos
If StartPos = 0 Then StartPos = 1

'SearchNoErr = 0
findCount = 0

Do
FindPos = VBA.InStr(StartPos, WithinText, FindText)
If FindPos > 0 Then
  findCount = findCount + 1
  StartPos = FindPos + Len(FindText)
Else
  Exit Do
End If
Loop
'If FindPos > 0 Then SearchNoErr = FindPos

SearchNoErr = findCount

End Function

Function ReturnChartForSeries(SeriesInf As String) As Chart

Dim SeriesInfo As String
Dim ChartSeriesInfo As String
Dim ChartSeriesNumber As Integer
Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartTitle As String
Dim ChartValuesArray() As Variant
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

SeriesInfo = SeriesInf
Set wb = ActiveWorkbook


For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
            For ChartSeriesNumber = 1 To xlsSheetChart.Chart.SeriesCollection.count
            ChartValuesArray = xlsSheetChart.Chart.SeriesCollection(ChartSeriesNumber).values
            ChartSeriesInfo = xlsSheetChart.Chart.SeriesCollection(ChartSeriesNumber).name & ":" & Join(ChartValuesArray, ":")
            If returnSeriesMatchesSet(SeriesInfo, ChartSeriesInfo) Then
               Set ReturnChartForSeries = xlsSheetChart.Chart
            End If
            Next
        Next
    End If
Next

Set wb = ActiveWorkbook

For Each xlsChart In wb.Charts
    For ChartSeriesNumber = 1 To xlsChart.SeriesCollection.count
        ChartValuesArray = xlsChart.SeriesCollection(ChartSeriesNumber).values
        ChartSeriesInfo = xlsChart.SeriesCollection(ChartSeriesNumber).name & ":" & Join(ChartValuesArray, ":")
        If returnSeriesMatchesSet(SeriesInfo, ChartSeriesInfo) Then
          Set ReturnChartForSeries = xlsChart
        End If
    Next
Next xlsChart

End Function

Function ReturnChartInfo(SeriesInfo As String, ReturnType As Integer)

Dim ChartSeriesValues As String
Dim DataSeries As String
Dim FoundChart As Chart
Dim ReturnInfo, seriesCount, LabelCount, Trendline As Integer
Dim ChartValuesArray() As Variant
Dim theData As String



ReturnInfo = ReturnType
DataSeries = SeriesInfo

If ReturnChartForSeries(DataSeries) Is Nothing Then
    ReturnChartInfo = False
Else
    
Set FoundChart = ReturnChartForSeries(DataSeries)

Select Case ReturnInfo

    Case 1
    'Type
    ReturnChartInfo = FoundChart.ChartType
    
    Case 2
    'Series Matching
    'ReturnChartInfo = False
    For seriesCount = 1 To FoundChart.SeriesCollection.count
        ChartValuesArray = FoundChart.SeriesCollection(seriesCount).values
        ChartSeriesValues = FoundChart.SeriesCollection(seriesCount).name & ":" & Join(ChartValuesArray, ":")
        If returnSeriesMatchesSet(ChartSeriesValues, DataSeries) Then ReturnChartInfo = seriesCount
    Next
    
    Case 3
    'Title
    ReturnChartInfo = FoundChart.ChartTitle.text
    
    Case 4
    'XValues
    ReturnChartInfo = Join(FoundChart.SeriesCollection(1).XValues, ":")
    
    Case 5
    'Data Labels
    LabelCount = 0
    For seriesCount = 1 To FoundChart.SeriesCollection.count
    If FoundChart.SeriesCollection(seriesCount).HasDataLabels Then LabelCount = LabelCount + 1
    Next
    ReturnChartInfo = LabelCount
    
    Case 6
    'Trendlines
    Trendline = 0
    For seriesCount = 1 To FoundChart.SeriesCollection.count
    Trendline = Trendline + FoundChart.SeriesCollection(seriesCount).Trendlines.count
    Next
    ReturnChartInfo = Trendline
    
    Case 7
    'Legend
    ReturnChartInfo = FoundChart.HasLegend
    
    Case 8
    ReturnChartInfo = FoundChart.Axes(xlCategory, xlPrimary).AxisTitle.Characters.text
    
    Case 9
    ReturnChartInfo = FoundChart.Axes(xlValue, xlPrimary).AxisTitle.Characters.text
    
    Case 10
        
        For seriesCount = 1 To FoundChart.SeriesCollection.count
        If FoundChart.SeriesCollection(seriesCount).HasDataLabels Then
            theData = theData & "|" & FoundChart.SeriesCollection(seriesCount).name
            theData = theData & ":" & FoundChart.SeriesCollection(seriesCount).DataLabels.ShowPercentage
        End If
        
        Next
        ReturnChartInfo = theData
    
    
    
    Case Else
    ReturnChartInfo = False
    
End Select

End If


End Function



Function ReturnChartInfoForTitle(ChartT As String, ReturnType As Integer, Optional SeriesRangeStr As String, Optional CheckValue As String)

Dim ChartSeriesValues As String
Dim ChartTitle As String
Dim FoundChart As Chart
Dim ReturnInfo As Integer
Dim seriesCount As Integer
Dim valueCount As Integer
Dim ChartValuesArray() As Variant
Dim theData As String
Dim DataSeriesValues() As String
Dim ChartSeries As Series
Dim SeriesInChart As Boolean
Dim CheckValueArray() As String
Dim WorkSheetName() As String
Dim SeriesRange As Range
Dim ProceedWithAnalysis As Boolean
    
    On Error GoTo Hell

ReturnInfo = ReturnType
ChartTitle = ChartT


Set FoundChart = ReturnChartForTitle(ChartTitle)

If FoundChart Is Nothing Then
  ReturnChartInfoForTitle = False
  Exit Function
End If
    


Select Case ReturnInfo

    Case 1
    'Type
        
    ReturnChartInfoForTitle = False
    CheckValueArray = Split(CheckValue, ":")
    For valueCount = 0 To UBound(CheckValueArray)
        If FoundChart.ChartType = CheckValueArray(valueCount) Then ReturnChartInfoForTitle = True
    Next
    
    Case 2
    'A specified series uses a specified range
    ReturnChartInfoForTitle = False
    SeriesInChart = False
    ProceedWithAnalysis = False
    
    If SeriesRangeStr <> "" Then
        WorkSheetName = Split(SeriesRangeStr, "!")
        If InStr(1, WorkSheetName(0), "'", vbBinaryCompare) = 1 And InStr(2, WorkSheetName(0), "'", vbBinaryCompare) = Len(WorkSheetName(0)) Then WorkSheetName(0) = Mid(WorkSheetName(0), 2, Len(WorkSheetName(0)) - 2)
        If returnSheetExists(WorkSheetName(0)) Then
            Set SeriesRange = Range(SeriesRangeStr)
            ProceedWithAnalysis = True
        End If
    End If
     
   If ProceedWithAnalysis Then
    SeriesInChart = False
    For Each ChartSeries In FoundChart.SeriesCollection
        DataSeriesValues = seriesArray(ChartSeries.formula)
        If Union(Range(DataSeriesValues(2)), SeriesRange).Cells.count = Range(DataSeriesValues(2)).count Then SeriesInChart = True
    Next
    
    ReturnChartInfoForTitle = SeriesInChart
        
    End If
    
        
    Case 3
    'Title
    ReturnChartInfoForTitle = False
    If FoundChart.ChartTitle.text = CheckValue Then ReturnChartInfoForTitle = True
    
    Case 4
    'XValues
    ReturnChartInfoForTitle = False
    SeriesInChart = False
    ProceedWithAnalysis = False
    
    If SeriesRangeStr <> "" Then
        WorkSheetName = Split(SeriesRangeStr, "!")
        If InStr(1, WorkSheetName(0), "'", vbBinaryCompare) = 1 And InStr(2, WorkSheetName(0), "'", vbBinaryCompare) = Len(WorkSheetName(0)) Then WorkSheetName(0) = Mid(WorkSheetName(0), 2, Len(WorkSheetName(0)) - 2)
        If returnSheetExists(WorkSheetName(0)) Then
            Set SeriesRange = Range(SeriesRangeStr)
            ProceedWithAnalysis = True
        End If
    End If
     
   If ProceedWithAnalysis Then
            
    For Each ChartSeries In FoundChart.SeriesCollection
    
      '  If FoundChart.ChartTitle.text = "Google Revenue by Business Segment" Then Stop

        DataSeriesValues = seriesArray(ChartSeries.formula)
        If DataSeriesValues(1) = "" Then
           ReturnChartInfoForTitle = False
        Else
           If Union(Range(DataSeriesValues(1)), SeriesRange).Cells.count = Range(DataSeriesValues(1)).count Then SeriesInChart = True
        End If
    Next
    
    ReturnChartInfoForTitle = SeriesInChart
    
    End If
    
    Case 5
    'Data Labels
    
    ReturnChartInfoForTitle = False
    
    For Each ChartSeries In FoundChart.SeriesCollection
        If ChartSeries.HasDataLabels Then ReturnChartInfoForTitle = True
    Next
    
    Case 6
    'Trendlines
    ReturnChartInfoForTitle = False
    
    For Each ChartSeries In FoundChart.SeriesCollection
        If ChartSeries.Trendlines.count > 0 Then ReturnChartInfoForTitle = True
    Next
    
    
    Case 7
    'Legend
    ReturnChartInfoForTitle = False
    
    If FoundChart.HasLegend = True Then ReturnChartInfoForTitle = True
    
    Case 8
    'Category Axis Title Text Matches
    
    ReturnChartInfoForTitle = False
    If FoundChart.Axes(xlCategory, xlPrimary).AxisTitle.Characters.text = CheckValue Then ReturnChartInfoForTitle = True
    
    Case 9
    'XValue Axis Title Text Matches
    ReturnChartInfoForTitle = False
    If FoundChart.Axes(xlValue, xlPrimary).AxisTitle.Characters.text = CheckValue Then ReturnChartInfoForTitle = True
    
    Case 10
    'searches all series and returns if any series has labels displayed as percentages
        ReturnChartInfoForTitle = False
        For Each ChartSeries In FoundChart.SeriesCollection
            If ChartSeries.HasDataLabels Then
                If ChartSeries.DataLabels.ShowPercentage = True Then ReturnChartInfoForTitle = True
            End If
        Next
    
    Case Else
    ReturnChartInfoForTitle = False
    
End Select

Exit Function
Hell:
ReturnChartInfoForTitle = False
End Function
Function seriesArray(seriesFormula As String) As Variant
  ' accepts the series formula of a chart and returns an array of what is separated by the commas
  ' must ignore commas inside quotes or prentheses
  Dim data As String
  Dim x As Long
  Dim o As String * 1
  Dim t As String
  Dim inQuote As Boolean
  Dim parenLevel As Integer
  Dim braceLevel As Integer
  'd = True
  
  data = Mid(seriesFormula, 9, Len(seriesFormula) - 9)
  For x = 1 To Len(data)
    o = Mid(data, x, 1)
    Select Case o
      Case """": inQuote = Not inQuote
      Case "(": parenLevel = parenLevel + 1
      Case ")": parenLevel = parenLevel - 1
      Case "{": braceLevel = braceLevel + 1
      Case "}": braceLevel = braceLevel - 1
    End Select
    
    If o = "," And Not ((braceLevel > 0 Or parenLevel > 0 Or inQuote)) Then
     t = t & Chr(30)
    Else
     t = t & o
    End If
  Next
seriesArray = Split(t, Chr(30))

End Function





Function ReturnChartTrendlineInfo(SeriesInfo As String, Optional SeriesNumber As Integer, Optional TrendlineNumber As Integer, Optional ReturnType As Integer)

Dim ChartSeriesValues As String
Dim DataSeries As String
Dim FoundChart As Chart
Dim ReturnInfo, seriesCount, LabelCount, Trendline As Integer
Dim ChartValuesArray() As Variant
Dim TrendNum As Integer
Dim SeriesNum As Integer

ReturnInfo = ReturnType
DataSeries = SeriesInfo
TrendNum = TrendlineNumber
SeriesNum = SeriesNumber

If ReturnChartForSeries(DataSeries) Is Nothing Then
    ReturnChartTrendlineInfo = False
Else

Set FoundChart = ReturnChartForSeries(DataSeries)

Select Case ReturnInfo

Case 1
'Type

ReturnChartTrendlineInfo = FoundChart.SeriesCollection(SeriesNum).Trendlines(TrendNum).Type

Case 2
ReturnChartTrendlineInfo = FoundChart.SeriesCollection(SeriesNum).Trendlines(TrendNum).DisplayRSquared


Case 3
'Width
ReturnChartTrendlineInfo = FoundChart.SeriesCollection(SeriesNum).Trendlines(TrendNum).border.Weight

Case 4
ReturnChartTrendlineInfo = FoundChart.SeriesCollection(SeriesNum).Trendlines(TrendNum).border.ColorIndex


End Select

End If

End Function

Function ReturnChartInfoByName(ChartN As String, ReturnType As Integer, Optional SeriesInfo As String)

Dim ChartSeriesValues As String
Dim DataSeries As String
Dim FoundChart As Chart
Dim ReturnInfo, seriesCount, LabelCount, Trendline As Integer
Dim ChartValuesArray() As Variant
Dim ChartName As String


ReturnInfo = ReturnType
DataSeries = SeriesInfo
ChartName = ChartN


If ReturnChartForName(ChartName) Is Nothing Then
    ReturnChartInfoByName = False
Else
    
Set FoundChart = ReturnChartForName(ChartName)

Select Case ReturnInfo

    Case 1
    'Type
    ReturnChartInfoByName = FoundChart.ChartType
    
    Case 2
    'Series Matching
    'ReturnChartInfoByName = False
    For seriesCount = 1 To FoundChart.SeriesCollection.count
        ChartValuesArray = FoundChart.SeriesCollection(seriesCount).values
        ChartSeriesValues = FoundChart.SeriesCollection(seriesCount).name & ":" & Join(ChartValuesArray, ":")
        If returnSeriesMatchesSet(ChartSeriesValues, DataSeries) Then ReturnChartInfoByName = seriesCount
    Next
    
    Case 3
    'Title
    ReturnChartInfoByName = FoundChart.ChartTitle.text
    
    Case 4
    'XValues
    ReturnChartInfoByName = Join(FoundChart.SeriesCollection(1).XValues, ":")
    
    Case 5
    'Data Labels
    LabelCount = 0
    For seriesCount = 1 To FoundChart.SeriesCollection.count
    If FoundChart.SeriesCollection(seriesCount).HasDataLabels Then LabelCount = LabelCount + 1
    Next
    ReturnChartInfoByName = LabelCount
    
    Case 6
    'Trendlines
    Trendline = 0
    For seriesCount = 1 To FoundChart.SeriesCollection.count
    Trendline = Trendline + FoundChart.SeriesCollection(seriesCount).Trendlines.count
    Next
    ReturnChartInfoByName = Trendline
    
    Case 7
    'Legend
    ReturnChartInfoByName = FoundChart.HasLegend
    
    
    
    Case Else
    ReturnChartInfoByName = False
    
End Select

End If


End Function


Function ReturnChartForName(ChartN As String) As Chart

Dim ChartName As String
Dim wb As Workbook
Dim xlsChart As Chart
Dim ChartTitle As String
Dim ChartValuesArray() As Variant
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet

ChartName = ChartN
Set wb = ActiveWorkbook

For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
            If xlsSheetChart.Chart.name = ChartName Then
               Set ReturnChartForName = xlsSheetChart.Chart
            End If
        Next
    End If
Next

Set wb = ActiveWorkbook

For Each xlsChart In wb.Charts
        If xlsChart.name = ChartName Then
          Set ReturnChartForName = xlsChart
        End If
Next xlsChart

End Function


Function ReturnChartForTitle(ChartT As String) As Chart

Dim ChartTitle As String
Dim wb As Workbook
Dim xlsChart As Chart
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet
Dim StrPos As Integer
Dim ChartFound As Boolean

ChartTitle = ChartT
Set wb = ActiveWorkbook

For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
        
        ChartFound = False
        
        If xlsSheetChart.Chart.HasTitle Then
        
        
        For StrPos = 1 To Len(xlsSheetChart.Chart.ChartTitle.text)
       
            If InStr(StrPos, VBA.UCase(xlsSheetChart.Chart.ChartTitle.text), VBA.UCase(ChartTitle), vbTextCompare) > 0 Then
                ChartFound = True
                Exit For
            End If
            
        Next
        
        If ChartFound Then
            Set ReturnChartForTitle = xlsSheetChart.Chart
            Exit Function
        End If
        
        End If
        
        Next
    End If
Next

Set wb = ActiveWorkbook

For Each xlsChart In wb.Charts

        ChartFound = False

        If xlsChart.HasTitle Then

        For StrPos = 1 To Len(xlsChart.ChartTitle.text)
       
            If InStr(StrPos, VBA.UCase(xlsChart.ChartTitle.text), VBA.UCase(ChartTitle), vbTextCompare) > 0 Then
                ChartFound = True
                Exit For
            End If
            
        Next
        
        End If
        
        If ChartFound Then
            Set ReturnChartForTitle = xlsChart
            Exit Function
        End If
        
Next xlsChart

End Function


Function ReturnNumChartForTitle(ChartT As String) As Integer

Dim ChartTitle As String
Dim wb As Workbook
Dim xlsChart As Chart
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet
Dim ChartCount As Integer
Dim StrPos As Integer
Dim ChartFound As Boolean

ChartTitle = ChartT
ChartCount = 0

Set wb = ActiveWorkbook

For Each xlsSheet In wb.Worksheets
    If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
            
            ChartFound = False
            
        If xlsSheetChart.Chart.HasTitle Then
            
        For StrPos = 1 To Len(xlsSheetChart.Chart.ChartTitle.text)
       
            If InStr(StrPos, VBA.UCase(xlsSheetChart.Chart.ChartTitle.text), VBA.UCase(ChartTitle), vbTextCompare) > 0 Then
                ChartFound = True
                Exit For
            End If
            
        Next
        
        If ChartFound Then ChartCount = ChartCount + 1
        
        End If
        
        Next
    End If
Next

Set wb = ActiveWorkbook

For Each xlsChart In wb.Charts

        ChartFound = False

        If xlsChart.HasTitle Then
        For StrPos = 1 To Len(xlsChart.ChartTitle.text)
       
            If InStr(StrPos, VBA.UCase(xlsChart.ChartTitle.text), VBA.UCase(ChartTitle), vbTextCompare) > 0 Then
                ChartFound = True
                Exit For
            End If
            
        Next
        
        End If
        
        If ChartFound Then ChartCount = ChartCount + 1


Next xlsChart

ReturnNumChartForTitle = ChartCount

End Function

Function ReturnScenarioForName(SheetName As String, ScenarioName As String) As Scenario


Dim wb As Workbook
Dim xlsScenario As Scenario

Set wb = ActiveWorkbook

For Each xlsScenario In wb.Worksheets(SheetName).Scenarios

    If LCase(xlsScenario.name) = LCase(ScenarioName) Then
        Set ReturnScenarioForName = xlsScenario
    End If
    
Next

End Function

Function ReturnScenarioInfoByName(SheetName As String, ScenarioName As String, ReturnType As Integer, Optional CellInScenario As String, Optional CheckValue As String)

Dim FoundScenario As Scenario
Dim ReturnInfo As Integer
Dim ChangingCellsArray() As Variant
Dim ChangingCell As Range
Dim CheckChangingCell As Range
Dim WorkSheetName() As String
Dim CCCount As Integer
Dim ProceedWithAnalysis As Boolean


ReturnInfo = ReturnType

If ReturnScenarioForName(SheetName, ScenarioName) Is Nothing Then
    ReturnScenarioInfoByName = False
Else
    
Set FoundScenario = ReturnScenarioForName(SheetName, ScenarioName)


Select Case ReturnInfo

Case 1
'Name Exists
ReturnScenarioInfoByName = True

Case 2
'Return Range
ReturnScenarioInfoByName = FoundScenario.ChangingCells.address

Case 3
'Return values
ReturnScenarioInfoByName = Join(FoundScenario.values, ":")

Case 4
'Specific cell in range
ReturnScenarioInfoByName = False

    If CellInScenario <> "" Then
        WorkSheetName = Split(CellInScenario, "!")
        If InStr(1, WorkSheetName(0), "'", vbBinaryCompare) = 1 And InStr(2, WorkSheetName(0), "'", vbBinaryCompare) = Len(WorkSheetName(0)) Then WorkSheetName(0) = Mid(WorkSheetName(0), 2, Len(WorkSheetName(0)) - 2)
        If returnSheetExists(WorkSheetName(0)) Then
            Set CheckChangingCell = Range(CellInScenario)
            ProceedWithAnalysis = True
        End If
    End If

If ProceedWithAnalysis Then

    For CCCount = 1 To FoundScenario.ChangingCells.count

        If FoundScenario.ChangingCells(CCCount).address = CheckChangingCell.address Then ReturnScenarioInfoByName = True
        
    Next

End If


Case 5
'specific value for specific reference
ReturnScenarioInfoByName = False

    If CellInScenario <> "" Then
        WorkSheetName = Split(CellInScenario, "!")
        If InStr(1, WorkSheetName(0), "'", vbBinaryCompare) = 1 And InStr(2, WorkSheetName(0), "'", vbBinaryCompare) = Len(WorkSheetName(0)) Then WorkSheetName(0) = Mid(WorkSheetName(0), 2, Len(WorkSheetName(0)) - 2)
        If returnSheetExists(WorkSheetName(0)) Then
            Set CheckChangingCell = Range(CellInScenario)
            ProceedWithAnalysis = True
        End If
    End If

If ProceedWithAnalysis Then

    For CCCount = 1 To FoundScenario.ChangingCells.count

        If FoundScenario.ChangingCells(CCCount).address = CheckChangingCell.address Then
            If FoundScenario.values(CCCount) = CheckValue Then ReturnScenarioInfoByName = True
        End If
        
    Next

End If


End Select

End If


End Function

Function countCopied(referentCell As Range, TestRange As Range) As Integer
 Dim tc As Range
 Dim copyCount As Integer
 For Each tc In TestRange
   If referentCell.FormulaR1C1 = tc.FormulaR1C1 And referentCell.formula > "" Then copyCount = copyCount + 1
 Next
 countCopied = copyCount
End Function

Function wildcardTextSearch(SearchString As String, CompareString As String)

wildcardTextSearch = False

If CompareString Like SearchString Then wildcardTextSearch = True


End Function

Function wildcardTextSearchNoCase(SearchString As String, CompareString As String)

wildcardTextSearchNoCase = False

If VBA.UCase(CompareString) Like VBA.UCase(SearchString) Then wildcardTextSearchNoCase = True

End Function

Function ReturnScenarioNameForWildcard(SheetName As String, WildCardName As String) As String

Dim wb As Workbook
Dim xlsScenario As Scenario

Set wb = ActiveWorkbook

ReturnScenarioNameForWildcard = False


For Each xlsScenario In wb.Worksheets(SheetName).Scenarios

    If VBA.UCase(xlsScenario.name) Like VBA.UCase(WildCardName) Then
        ReturnScenarioNameForWildcard = xlsScenario.name
    End If
    
Next

End Function

Function ReturnFormatInfo(cell As Range, InfoType As Integer, Optional ExtraParameter As Integer)


    Dim checkCell As Range
    Dim CountFormated As Long
    Dim cellCount As Long
    
    cellCount = cell.count
    CountFormated = 0
    ReturnFormatInfo = False
    Dim x As Long
    Dim numberFormat As Variant
    


'Returns formatting information for a range based on InfoType
'1 - NumberFormat
'2 - Range is hidden
'3 - Merged cells
'4 - Cells are centered
'5 - Bolded
'6 - Italicized
'7 - Linestyle
'8 - Weight
'9 - Wrapped
'10 - interior color

    ReturnFormatInfo = False

Select Case InfoType

    Case 1
    ' returns NumberFormat property of the range
        x = 1
        
        For Each checkCell In cell
        
        If x = 1 Then numberFormat = checkCell.numberFormat
        
        If numberFormat = checkCell.numberFormat Then CountFormated = CountFormated + 1
    
        x = x + 1
        
        
        Next
        
        If CountFormated = cell.count Then ReturnFormatInfo = numberFormat
    
    Case 2
    'Returns in range is Hidden
        If cell.ColumnWidth = 0 Or cell.rowHeight = 0 Then ReturnFormatInfo = True
    
    Case 3
    'Returns the address of merged cells in a the range
        ReturnFormatInfo = cell.MergeArea.address
        
    Case 4
    'Returns true if cells in the range are centered
        For Each checkCell In cell
        
            If checkCell.HorizontalAlignment = xlCenter Then CountFormated = CountFormated + 1
        
        Next
        
        If CountFormated = cellCount Then ReturnFormatInfo = True
        
    Case 5
    'Returns true if cells in the range are bold
        
        For Each checkCell In cell
        
            If checkCell.Font.bold Then CountFormated = CountFormated + 1
               
        Next
        
        If CountFormated = cellCount Then ReturnFormatInfo = True
        
    Case 6
    'Returns true if range is italicized
        
        For Each checkCell In cell
        
            If checkCell.Font.italic Then CountFormated = CountFormated + 1
               
        Next
        
        If CountFormated = cellCount Then ReturnFormatInfo = True
        
         
    Case 7
    'Returns the BorderIndexNumber Based on the ExtraParameter that defines the side needed
        Select Case ExtraParameter
            
            Case 1
            'Top
            ReturnFormatInfo = cell.Borders(xlEdgeTop).LineStyle
            
            Case 2
            'Right
            ReturnFormatInfo = cell.Borders(xlEdgeRight).LineStyle
            
            Case 3
            'Bottom
            ReturnFormatInfo = cell.Borders(xlEdgeBottom).LineStyle
            
            Case 4
            'Left
            ReturnFormatInfo = cell.Borders(xlEdgeLeft).LineStyle
            
        End Select
    
    Case 8
    'Returns the BorderWeight Based on the ExtraParameter that defines the side needed
        Select Case ExtraParameter
            
            Case 1
            'Top
            ReturnFormatInfo = cell.Borders(xlEdgeTop).Weight
            
            Case 2
            'Right
            ReturnFormatInfo = cell.Borders(xlEdgeRight).Weight
            
            Case 3
            'Bottom
            ReturnFormatInfo = cell.Borders(xlEdgeBottom).Weight
            
            Case 4
            'Left
            ReturnFormatInfo = cell.Borders(xlEdgeLeft).Weight
            
        End Select
        
    Case 9
    'Returns True if cells in range are wrapped
    
    'Paste
    
        For Each checkCell In cell
        
            If checkCell.WrapText Then CountFormated = CountFormated + 1
               
        Next
        
        If CountFormated = cellCount Then ReturnFormatInfo = True
        
    Case 10
    'Returns the interior color index number of the range
    ReturnFormatInfo = cell.Interior.ColorIndex
            
End Select

End Function

Function ReturnPageInfo(PageName As String, InfoType As Integer, Optional ExtraParameter As Integer)

'Returns formatting information for a sheet based on InfoType
'1 - Margin

    ReturnPageInfo = False

Select Case InfoType
    
    Case 1
    'Returns Page Margin according to extra parameter

        Select Case ExtraParameter
        
        Case 1
        'Top
        ReturnPageInfo = Sheets(PageName).PageSetup.TopMargin
                
        Case 2
        'Right
        ReturnPageInfo = Sheets(PageName).PageSetup.RightMargin
        
        Case 3
        'Bottom
        ReturnPageInfo = Sheets(PageName).PageSetup.BottomMargin
        
        Case 4
        'Left
        ReturnPageInfo = Sheets(PageName).PageSetup.LeftMargin
        
        End Select
        
    Case 2
    'Returns the Print Area for a worksheet
        ReturnPageInfo = Sheets(PageName).PageSetup.PrintArea
        
    Case 3
    'Title Rows
        ReturnPageInfo = Sheets(PageName).PageSetup.PrintTitleRows
    
    Case 4
    'Title Columns
        ReturnPageInfo = Sheets(PageName).PageSetup.PrintTitleColumns

End Select

End Function
Function TestPassingRanges(TestRange As Range)

    TestPassingRanges = "Workd"
    

End Function


Function ReturnRangeIsSorted(testSheet As String, TestCells As String, SortType As Integer, Optional SecondaryToText As String)

Dim cellCount As Integer
Dim x As Long
Dim numberLevels As Long
Dim NumberRecords As Long
Dim DoNotProcess As Boolean
Dim TestRange As Range
Dim SecondaryTo As Range
Dim testCell As Range


If returnSheetExists(testSheet) Then

Set TestRange = Worksheets(testSheet).Range(TestCells)



If SecondaryToText = "" Then
    numberLevels = 0
Else
    Set SecondaryTo = Worksheets(testSheet).Range(SecondaryToText)
    numberLevels = returnNumberRangeValues(SecondaryTo)
End If



NumberRecords = Application.WorksheetFunction.CountA(TestRange)




Select Case SortType

Case 0
'Ascending

For x = 1 To TestRange.count - 1

    Set testCell = TestRange.Cells(x)
    
    If testCell <= testCell.offset(1, 0) Then cellCount = cellCount + 1

Next

Case 1
'Descending

For x = 1 To TestRange.count - 1

    Set testCell = TestRange.Cells(x)
    
    If testCell >= testCell.offset(1, 0) Then cellCount = cellCount + 1

Next



End Select


ReturnRangeIsSorted = False
If NumberRecords > 0 And cellCount >= NumberRecords - 1 - numberLevels Then ReturnRangeIsSorted = True

Else
    ReturnRangeIsSorted = False
    
End If


End Function

Function returnNumberRangeValues(CellRange As Range)

Dim checkCell As Range
Dim x As Long
Dim y As Long
Dim CheckValue() As Variant
Dim FoundMatch As Boolean
Dim ArraySize As Long

ArraySize = CellRange.count


ReDim CheckValue(ArraySize) As Variant


x = 0

For Each checkCell In CellRange
    
    FoundMatch = False
    If x = 0 Then
        CheckValue(0) = checkCell.value
        x = 1
    Else
        For y = 0 To x
            If CheckValue(y) = checkCell.value Then FoundMatch = True
        Next
        
        If FoundMatch = False Then
            CheckValue(x) = checkCell.value
            x = x + 1
        End If
    End If
        
Next

returnNumberRangeValues = x


End Function

Function ReturnChartExists(SeriesInfo As String)

Dim DataSeries As String

DataSeries = SeriesInfo

If ReturnChartForSeries(DataSeries) Is Nothing Then
    ReturnChartExists = False
Else
    ReturnChartExists = True
End If


End Function

Function SolverInfo(SolverSheet As String, SolverInf As Integer, Optional TestConstraint As String)

Dim SSheet As Worksheet
Dim SInfo As Integer
Dim SType As String
Dim CCount As Integer
Dim SArgs As Integer
Dim LHSConstraint As String
Dim RHSConstraint As String
Dim OperatorConstraint As String
Dim TConstraint() As String
Dim LHSMatch As String
Dim RHSMatch As String
Dim OperatorMatch As String
Dim ObjectiveRange As String
Dim ChangingRange As String
Dim SName As name
Dim SVarCount As Integer


SInfo = SolverInf

SolverInfo = False

'Ensure Sheet Exists. If not, return false

If returnSheetExists(SolverSheet) Then
    Set SSheet = Worksheets(SolverSheet)

        For Each SName In SSheet.Names

        If SearchNoErr("solver_", SName.name) > 0 Then SVarCount = SVarCount + 1

    Next

    If SVarCount = 0 Then Exit Function

Select Case SInfo

    Case 1
    'Objective Cell

    ObjectiveRange = Replace(SSheet.Names(SolverSheet & "!solver_opt").value, "=", "")

    If TestConstraint <> "" Then

        If Union(Range(ObjectiveRange), Range(TestConstraint)).Cells.count = Range(TestConstraint).Cells.count Then
            SolverInfo = True
            Exit Function
        End If
    End If

    Case 2
    'Objective Function (Max, Min, To Value)

    SType = SSheet.Names(SolverSheet & "!solver_typ").value

    Select Case SType
    Case "=1"
        If TestConstraint = "Max" Then
            SolverInfo = True
            Exit Function
        End If

    Case "=2"
        If TestConstraint = "Min" Then
            SolverInfo = True
            Exit Function
        End If

    Case "=3"
        If TestConstraint = SSheet.Names(SolverSheet & "!solver_val").value Then
            SolverInfo = True
            Exit Function
        End If

    End Select

    Case 3
    'Changing Cells
    ChangingRange = Replace(SSheet.Names(SolverSheet & "!solver_adj").value, "=", "")

    If TestConstraint <> "" Then

        If Union(Range(ChangingRange), Range(TestConstraint)).Cells.count = Range(ChangingRange).Cells.count Then
            SolverInfo = True
            Exit Function
        End If

    End If

    Case 4
    'Constraints

    If TestConstraint <> "" Then
        TConstraint = Split(TestConstraint, "|")
        LHSMatch = TConstraint(0)
        OperatorMatch = TConstraint(1)
        RHSMatch = TConstraint(2)

    Select Case OperatorMatch

    Case 1
        CCount = 0
'Cycle through constraints
        For SArgs = 1 To SSheet.Names.count
        If InStr(1, SSheet.Names(SArgs).name, "_lhs") Then
            CCount = CCount + 1
            LHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_lhs" & CCount).value, "=", "")
            RHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rhs" & CCount).value, "=", "")
            OperatorConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rel" & CCount).value, "=", "")

'check to see if constraint is a match
            If Union(Range(LHSConstraint), Range(LHSMatch)).Cells.count = Range(LHSConstraint).Cells.count And OperatorConstraint = 1 Then
                If InStr(1, RHSConstraint, SolverSheet) > 0 And InStr(1, RHSMatch, SolverSheet) > 0 Then
                    If Union(Range(RHSConstraint), Range(RHSMatch)).Cells.count = Range(RHSConstraint).Cells.count Then
                        SolverInfo = True
                        Exit Function
                    End If

                Else
                    If RHSConstraint = RHSMatch Then
                        SolverInfo = True
                        Exit Function
                    End If

                End If
            End If

'check to see if type 3 constraint is reversed
            If InStr(1, RHSConstraint, SolverSheet) > 0 And InStr(1, RHSMatch, SolverSheet) > 0 Then
                If Union(Range(LHSConstraint), Range(RHSMatch)).Cells.count = Range(LHSConstraint).Cells.count And OperatorConstraint = 3 Then
                    If Union(Range(RHSConstraint), Range(LHSMatch)).Cells.count = Range(RHSConstraint).Cells.count Then
                        SolverInfo = True
                        Exit Function
                    End If
                End If
            End If

        End If
        Next

    Case 2
        CCount = 0
'Cycle through constraints
        For SArgs = 1 To SSheet.Names.count
        If InStr(1, SSheet.Names(SArgs).name, "_lhs") Then
            CCount = CCount + 1
            LHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_lhs" & CCount).value, "=", "")
            RHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rhs" & CCount).value, "=", "")
            OperatorConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rel" & CCount).value, "=", "")

'check to see if constraint is a match
            If Union(Range(LHSConstraint), Range(LHSMatch)).Cells.count = Range(LHSConstraint).Cells.count And OperatorConstraint = 2 Then
                If InStr(1, RHSConstraint, SolverSheet) > 0 And InStr(1, RHSMatch, SolverSheet) > 0 Then
                    If Union(Range(RHSConstraint), Range(RHSMatch)).Cells.count = Range(RHSConstraint).Cells.count Then
                        SolverInfo = True
                        Exit Function
                    End If
                Else
                    If RHSConstraint = RHSMatch Then
                        SolverInfo = True
                        Exit Function
                    End If
                End If
            End If

'check to see if type 3 constraint is reversed
            If InStr(1, RHSConstraint, SolverSheet) > 0 And InStr(1, RHSMatch, SolverSheet) > 0 Then
                If Union(Range(LHSConstraint), Range(RHSMatch)).Cells.count = Range(LHSConstraint).Cells.count And OperatorConstraint = 2 Then
                    If Union(Range(RHSConstraint), Range(LHSMatch)).Cells.count = Range(RHSConstraint).Cells.count Then
                        SolverInfo = True
                        Exit Function
                    End If
                End If
            End If

        End If
        Next

    Case 3

        CCount = 0
'Cycle through constraints
        For SArgs = 1 To SSheet.Names.count
        If InStr(1, SSheet.Names(SArgs).name, "_lhs") Then
            CCount = CCount + 1
            LHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_lhs" & CCount).value, "=", "")
            RHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rhs" & CCount).value, "=", "")
            OperatorConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rel" & CCount).value, "=", "")

'check to see if constraint is a match
            If Union(Range(LHSConstraint), Range(LHSMatch)).Cells.count = Range(LHSConstraint).Cells.count And OperatorConstraint = 3 Then
                If InStr(1, RHSConstraint, SolverSheet) > 0 And InStr(1, RHSMatch, SolverSheet) > 0 Then
                    If Union(Range(RHSConstraint), Range(RHSMatch)).Cells.count = Range(RHSConstraint).Cells.count Then
                        SolverInfo = True
                        Exit Function
                    End If
                Else
                    If RHSConstraint = RHSMatch Then SolverInfo = True
                        Exit Function
                    End If
                End If
            End If

'check to see if type 1 constraint is reversed
            If InStr(1, RHSConstraint, SolverSheet) > 0 And InStr(1, RHSMatch, SolverSheet) > 0 Then
                If Union(Range(LHSConstraint), Range(RHSMatch)).Cells.count = Range(LHSConstraint).Cells.count And OperatorConstraint = 1 Then
                    If Union(Range(RHSConstraint), Range(LHSMatch)).Cells.count = Range(RHSConstraint).Cells.count Then
                        SolverInfo = True
                        Exit Function
                    End If
            End If

        End If
        Next


    Case 4
        CCount = 0
        For SArgs = 1 To SSheet.Names.count
        If InStr(1, SSheet.Names(SArgs).name, "_lhs") Then
            CCount = CCount + 1
            LHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_lhs" & CCount).value, "=", "")
            RHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rhs" & CCount).value, "=", "")
            OperatorConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rel" & CCount).value, "=", "")
            If Union(Range(LHSConstraint), Range(LHSMatch)).Cells.count = Range(LHSConstraint).Cells.count Then
                If RHSConstraint = "integer" Then
                    If OperatorConstraint = 4 Then
                        SolverInfo = True
                        Exit Function
                    End If
                End If
            End If
        End If
        Next


    Case 5
        CCount = 0
        For SArgs = 1 To SSheet.Names.count
        If InStr(1, SSheet.Names(SArgs).name, "_lhs") Then
            CCount = CCount + 1
            LHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_lhs" & CCount).value, "=", "")
            RHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rhs" & CCount).value, "=", "")
            OperatorConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rel" & CCount).value, "=", "")
            If Union(Range(LHSConstraint), Range(LHSMatch)).Cells.count = Range(LHSConstraint).Cells.count Then
                If RHSConstraint = "binary" Then
                    If OperatorConstraint = 5 Then
                        SolverInfo = True
                        Exit Function
                    End If
                End If
            End If
        End If
        Next

    Case 6
        CCount = 0
        For SArgs = 1 To SSheet.Names.count
        If InStr(1, SSheet.Names(SArgs).name, "_lhs") Then
            CCount = CCount + 1
            LHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_lhs" & CCount).value, "=", "")
            RHSConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rhs" & CCount).value, "=", "")
            OperatorConstraint = Replace(SSheet.Names(SolverSheet & "!solver_rel" & CCount).value, "=", "")
            If Union(Range(LHSConstraint), Range(LHSMatch)).Cells.count = Range(LHSConstraint).Cells.count Then
                If VBA.LCase(RHSConstraint) = VBA.LCase("AllDifferent") Then
                    If OperatorConstraint = 6 Then
                        SolverInfo = True
                        Exit Function
                    End If
                End If
            End If
        End If
        Next

    End Select
    End If



Case 5
'Solver Engine Used (1-non-linear, 2-simplex, 3-evolutionary)

    SType = SSheet.Names(SolverSheet & "!solver_eng").value

    Select Case SType
    Case "=1"
        If TestConstraint = "1" Then
            SolverInfo = True
            Exit Function
        End If

    Case "=2"
        If TestConstraint = "2" Then
            SolverInfo = True
            Exit Function
        End If

    Case "=3"
        If TestConstraint = "3" Then
            SolverInfo = True
            Exit Function
        End If

    End Select

Case 6
'Make Non-negative

    If SSheet.Names(SolverSheet & "!solver_neg").value = "=1" Then
        SolverInfo = True
        Exit Function
    End If


End Select

End If

End Function

Function SolverUsedOnSheet(SolverSheet As String)

Dim i As Integer
Dim SSheet As Worksheet

SolverUsedOnSheet = False

If returnSheetExists(SolverSheet) Then
    Set SSheet = Worksheets(SolverSheet)

For i = 1 To SSheet.Names.count

    If InStr(1, SSheet.Names(i).name, "solver") > 0 Then SolverUsedOnSheet = True

Next

End If

End Function

Function ReturnAddressForRange(RangeNameText As String)

Dim nameCount As Integer

ReturnAddressForRange = False


For nameCount = 1 To ThisWorkbook.Names.count

    If ThisWorkbook.Names(nameCount).name = RangeNameText Then ReturnAddressForRange = ThisWorkbook.Names(RangeNameText).RefersTo

Next


End Function

Sub FrozenPanes(SheetName As String)

Dim CurrentSheet As String

If SheetExists(SheetName) Then

    CurrentSheet = ActiveSheet.name
    
    Sheets(SheetName).Select
    RuleData = ActiveWindow.FreezePanes
    
    Sheets(CurrentSheet).Select

Else
    RuleData = False
End If

End Sub

Sub FrozenPanesSpot(SheetName As String, FrozenRow As Integer, FrozenCol As Integer)

Dim CurrentSheet As String
Dim PaneNum As Integer


If SheetExists(SheetName) Then

    CurrentSheet = ActiveSheet.name

    Sheets(SheetName).Select
    
    RuleData = False
    
    If ActiveWindow.FreezePanes = True Then
    
        For PaneNum = 1 To ActiveWindow.Panes.count
            If (ActiveWindow.Panes(PaneNum).ScrollRow = FrozenRow) And (ActiveWindow.Panes(PaneNum).ScrollColumn = FrozenCol) Then
                RuleData = True
            End If
        Next
    
    End If
    
    Sheets(CurrentSheet).Select

Else
    RuleData = False
End If

End Sub


Function RangeIsSorted(testSheet As String, TestCells As String, SortType As Integer)

Dim cellCount As Integer
Dim x As Long
Dim TestRange As Range
Dim testCell As Range
Dim TempRangeIsSorted As Boolean

If returnSheetExists(testSheet) Then

    Set TestRange = Worksheets(testSheet).Range(TestCells)
    
    TempRangeIsSorted = True
    
    Select Case SortType
    
    Case 0
    'Ascending
    
    For x = 1 To TestRange.count - 1
    
        Set testCell = TestRange.Cells(x)
        
        If testCell > testCell.offset(1, 0) Then TempRangeIsSorted = False
        
    
    Next
    
    Case 1
    'Descending
    
    For x = 1 To TestRange.count - 1
    
        Set testCell = TestRange.Cells(x)
        
        If testCell < testCell.offset(1, 0) Then TempRangeIsSorted = False
    
    Next



    End Select


    RangeIsSorted = TempRangeIsSorted

Else

    RangeIsSorted = False

End If

End Function

Function RangeIsSortedMultiple(testSheet As String, Level1 As String, L1Type As Integer, Level2 As String, L2Type As Integer)
Dim sortRange As String
Dim startCell As Integer
Dim EndCell As Integer
Dim StartCellAddress As String
Dim TestRange As Range
Dim Level1Column As String
Dim Level1AddressParts() As String
Dim StartCellRow As String
Dim Level1MaxRow As String
Dim EndCellRow As String
Dim RangesAreSorted As Boolean
Dim Level2Column As String
Dim Level2AddressParts() As String
Dim TestRange2 As Range



RangesAreSorted = True
RangeIsSortedMultiple = False

If RangeIsSorted(testSheet, Level1, L1Type) Then

    If SheetExists(testSheet) Then
        Set TestRange = Worksheets(testSheet).Range(Level1)
        Level1AddressParts = Split(TestRange.address, "$")
        Level1Column = Level1AddressParts(1)
        Level1MaxRow = Level1AddressParts(4)
        
        Level2Column = Level2
        
        
        
        startCell = Replace(Level1AddressParts(2), ":", "")
        
        Do Until startCell >= Level1MaxRow
        
            StartCellRow = CStr(startCell)
            
            StartCellAddress = Level1Column & StartCellRow
            
            EndCell = startCell + EndSecondaryRange(testSheet, StartCellAddress)
            EndCellRow = CStr(EndCell)
            
            sortRange = Level2Column & StartCellRow & ":" & Level2Column & CStr(EndCell)
            
            
            If Not (RangeIsSorted(testSheet, sortRange, L2Type)) Then RangesAreSorted = False
        
            startCell = EndCell + 1
                
        Loop
        
        RangeIsSortedMultiple = RangesAreSorted
    
    Else
    
        RangeIsSortedMultiple = False

    End If

End If

End Function

Function EndSecondaryRange(testSheet As String, startCell As String)
    
Dim TestRange As Range
Dim CountCells As Integer

If SheetExists(testSheet) Then
    Set TestRange = Worksheets(testSheet).Range(startCell)
    
Do Until TestRange.offset(1, 0) <> TestRange

    Set TestRange = TestRange.offset(1, 0)
    CountCells = CountCells + 1

Loop


End If

    EndSecondaryRange = CountCells
    

End Function

Function ISMacOpenBooks()
  ISMacOpenBooks = True
  If Int(version) = 14 And Workbooks.count > 1 Then ISMacOpenBooks = False
End Function

Function WorkbookOnCloud()

WorkbookOnCloud = False

If SearchNoErr("https://", ActiveWorkbook.path) > 0 Then WorkbookOnCloud = True

End Function


Sub DeleteBadNamedRanges(Optional paramToMakeHidden As Boolean)

    Dim nameCount As Integer

    For nameCount = Names.count To 1 Step -1

        If InStr(1, Names(nameCount).value, ":\") Then
            Names(nameCount).Delete
        End If

    Next

End Sub

Sub DeleteScenarios(Optional paramToMakeHidden As Boolean)

    Dim Scen As Scenario
    Dim WkSheet As Worksheet
    Dim ScenCount As Integer
    Dim wb As Workbook

    Set wb = ActiveWorkbook

    For Each WkSheet In wb.Worksheets
        For Each Scen In WkSheet.Scenarios
            Scen.Delete
        Next
    Next

End Sub

Sub deleteSeriesFromChart(SheetName As String, ChartName As String, SeriesNumber As Integer)

Dim wb As Workbook
Dim xlsSheetChart As ChartObject

Set wb = ActiveWorkbook
    For Each xlsSheetChart In wb.Worksheets(SheetName).ChartObjects
        If returnStrMatch(xlsSheetChart.name, ChartName) Then
            If xlsSheetChart.Chart.SeriesCollection.count >= SeriesNumber Then
                xlsSheetChart.Chart.SeriesCollection(SeriesNumber).Delete
            End If
            Exit For
        End If
    Next
End Sub

Sub deleteAllNamedRanges(Optional ParamToMakeInvisible As Byte)

    Dim nameCount As Integer

    For nameCount = Names.count To 1 Step -1
        Debug.Print Names(nameCount).name
        
        If InStr(1, Names(nameCount).name, "_xlfn") = 0 Then Names(nameCount).Delete
    Next

End Sub

Function checkFullJournalEntries(debitAccounts As String, DebitAmounts As String, DebitAcctCol As Integer, debitAmountCol As Integer, CreditAccounts As String, CreditAmounts As String, CreditAcctCol As Integer, creditAmountCol As Integer, WkSht As String, JRange As String) As Boolean

Dim rows As Integer
Dim searchRow As Integer
Dim AccountValues() As String
Dim AmountValues() As String
Dim EntriesNeeded As Integer
Dim EntryCounter As Integer
Dim AccountFound As Boolean
Dim entriesFound As Integer
Dim er As Range
Dim debitsCorrect As Boolean
Dim creditsCorrect As Boolean


checkFullJournalEntries = False

If returnSheetExists(WkSht) Then

Set er = Worksheets(WkSht).Range(JRange)


'Check debits

AccountValues = Split(debitAccounts, "|")
AmountValues = Split(DebitAmounts, "|")

If UBound(AccountValues) <> UBound(AmountValues) Then Exit Function

EntriesNeeded = UBound(AccountValues) + 1

rows = er.rows.count
entriesFound = 0

For EntryCounter = 0 To UBound(AccountValues)
    For searchRow = 1 To rows
        If VBA.UCase(er.Cells(searchRow, DebitAcctCol).value) = VBA.UCase(AccountValues(EntryCounter)) Then
            AccountFound = True
            Exit For
        End If
    Next
    If AccountFound And er.Cells(searchRow, debitAmountCol).value = AmountValues(EntryCounter) Then entriesFound = entriesFound + 1
    AccountFound = False
Next

If entriesFound = EntriesNeeded Then debitsCorrect = True

'check credits

AccountValues = Split(CreditAccounts, "|")
AmountValues = Split(CreditAmounts, "|")

If UBound(AccountValues) <> UBound(AmountValues) Then Exit Function

EntriesNeeded = UBound(AccountValues) + 1

rows = er.rows.count
entriesFound = 0

For EntryCounter = 0 To UBound(AccountValues)
    For searchRow = 1 To rows
        If VBA.UCase(er.Cells(searchRow, CreditAcctCol).value) = VBA.UCase(AccountValues(EntryCounter)) Then
            AccountFound = True
            Exit For
        End If
    Next
    If AccountFound And er.Cells(searchRow, creditAmountCol).value = AmountValues(EntryCounter) Then entriesFound = entriesFound + 1
    AccountFound = False
Next

If entriesFound = EntriesNeeded Then creditsCorrect = True

End If

If debitsCorrect And creditsCorrect Then checkFullJournalEntries = True

End Function

Function checkJournalAcctAmtPairs(Accounts As String, Amounts As String, WkSht As String, JRange As String, AcctCol As Integer, AmountCol As Integer) As Boolean

Dim rows As Integer
Dim searchRow As Integer
Dim AccountValues() As String
Dim AmountValues() As String
Dim EntriesNeeded As Integer
Dim EntryCounter As Integer
Dim AccountFound As Boolean
Dim entriesFound As Integer
Dim er As Range


AccountValues = Split(Accounts, "|")
AmountValues = Split(Amounts, "|")

checkJournalAcctAmtPairs = False

If UBound(AccountValues) <> UBound(AmountValues) Then Exit Function

EntriesNeeded = UBound(AccountValues) + 1

If returnSheetExists(WkSht) Then

Set er = Worksheets(WkSht).Range(JRange)

rows = er.rows.count
entriesFound = 0

For EntryCounter = 0 To UBound(AccountValues)
    For searchRow = 1 To rows
        If VBA.UCase(er.Cells(searchRow, AcctCol).value) = VBA.UCase(AccountValues(EntryCounter)) Then
            AccountFound = True
            Exit For
        End If
    Next
    If AccountFound And er.Cells(searchRow, AmountCol).value = AmountValues(EntryCounter) Then entriesFound = entriesFound + 1
    AccountFound = False
Next

End If

If entriesFound = EntriesNeeded Then checkJournalAcctAmtPairs = True

End Function

Function checkJournalElement(Element As String, WkSht As String, JRange As String, elementCol As Integer) As Boolean

Dim rows As Integer
Dim searchRow As Integer
Dim er As Range
Dim elementFound As Boolean


checkJournalElement = False
elementFound = False

If returnSheetExists(WkSht) Then

Set er = Worksheets(WkSht).Range(JRange)

rows = er.rows.count

For searchRow = 1 To rows
    If VBA.UCase(er.Cells(searchRow, elementCol).value) = VBA.UCase(Element) Then
        elementFound = True
        Exit For
    End If
Next

End If

checkJournalElement = elementFound

End Function

Function countJournalEntriesInRange(WkSht As String, JRange As String, AcctList As String, DebitAcctCol As Integer, debitAmountCol As Integer, CreditAcctCol As Integer, creditAmountCol As Integer) As String

Dim rows As Integer
Dim searchRow As Integer
Dim debitEntriesFound As Integer
Dim creditEntriesFound As Integer
Dim er As Range

countJournalEntriesInRange = "0|0"

If returnSheetExists(WkSht) Then

Set er = Worksheets(WkSht).Range(JRange)

rows = er.rows.count

debitEntriesFound = 0
creditEntriesFound = 0

For searchRow = 1 To rows
    If acctInList(er.Cells(searchRow, DebitAcctCol).value, AcctList) And IsNumeric(er.Cells(searchRow, debitAmountCol).value) Then debitEntriesFound = debitEntriesFound + 1
    If acctInList(er.Cells(searchRow, CreditAcctCol).value, AcctList) And IsNumeric(er.Cells(searchRow, creditAmountCol).value) Then creditEntriesFound = creditEntriesFound + 1
Next

countJournalEntriesInRange = debitEntriesFound & "|" & creditEntriesFound

End If

End Function

Function gradeSimpleJournalEntry(DebitAcct As String, DebitAmt As String, DebitAcctCol As Integer, DebitAmtCol As Integer, CreditAcct As String, CreditAmt As String, CreditAcctCol As Integer, CreditAmtCol As Integer, WkSht As String, JRange As String) As Variant
Dim ScoreCode As String

'Grade total entry
    If checkFullJournalEntries(DebitAcct, DebitAmt, DebitAcctCol, DebitAmtCol, CreditAcct, CreditAmt, CreditAcctCol, CreditAmtCol, WkSht, JRange) Then
        ScoreCode = "1"
    Else
        ScoreCode = "0"
    End If
'Grade All Elements
    If checkJournalElement(DebitAcct, WkSht, JRange, DebitAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(DebitAmt, WkSht, JRange, DebitAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(CreditAcct, WkSht, JRange, CreditAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(CreditAmt, WkSht, JRange, CreditAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If

    
    gradeSimpleJournalEntry = ScoreCode

End Function


Function acctInList(CheckAccount As String, RangeName As String) As Boolean

Dim RN As name
Dim checkRange As Range
Dim checkCell As Range

acctInList = False

For Each RN In ActiveWorkbook.Names

    If RN.name = RangeName Then
        Set checkRange = RN.RefersToRange
        Exit For
    End If
Next

For Each checkCell In checkRange

    If VBA.UCase(checkCell.value) = VBA.UCase(CheckAccount) Then
        acctInList = True
        Exit For
    End If
Next

End Function



Function complexOutput(val As Variant) As String
  Select Case val
    Case 1: complexOutput = "|.1|might be a good idea to actualy READ the chapter"
    Case 2: complexOutput = "|.5|It looks as though you are on the right track, but you are not close"
                   RuleMessage = RuleMessage & "|Message that goes at the end for 2"
    Case 3: complexOutput = "|.9|Really good, you almost got the right answer"
                   RuleMessage = RuleMessage & "|Message that goes at the end for 3"
    Case 4: complexOutput = "|1|Give yourself a pat on the back."
    Case Else: complexOutput = "|0|You were so far off that we had no idea what you were talking about"
  End Select

End Function

Function noteText(val As Variant) As String
  Select Case val
    Case 1: noteText = "|0|Extra feedback when the user enters 1"
    Case 2: noteText = "|0|Extra feedback when the user enters 2"
    Case 3: noteText = "|0|Extra feedback when the user enters 3"
    Case 4: noteText = "|0|Extra feedback when the user enters 4"
    Case Else: noteText = "|0|Extra feedback when the user enters some crazy thing"
  End Select

End Function


Function readCumulativeFeedback() As String
  If RuleMessage = "" Then
    readCumulativeFeedback = 1
  Else
    readCumulativeFeedback = "|0|<div class=""comment"">" & Replace(Mid(RuleMessage, 2), "|", "<br>") & "</div>"
    RuleMessage = ""
  End If
End Function

Function complexOutputJournalEntry(val As Variant, Optional Weights As String = "0") As String
    
Dim ScoreElements() As String
Dim ScorePercent As Double
Dim ElementCount As Integer
Dim scoreWeights() As String

ScoreElements = Split(val, "|")

If Weights = "0" Then

    For ElementCount = 0 To UBound(ScoreElements)
        ScorePercent = ScorePercent + ScoreElements(ElementCount)
    Next

    ScorePercent = ScorePercent / (UBound(ScoreElements) + 1)

Else

    scoreWeights = Split(Weights, "|")
    
    For ElementCount = 0 To UBound(ScoreElements)
        ScorePercent = ScorePercent + scoreWeights(ElementCount) * ScoreElements(ElementCount)
    Next

End If


If ScoreElements(0) = 1 Then
    complexOutputJournalEntry = "|1|All journal entry elements are correct."
Else
    complexOutputJournalEntry = "|" & ScorePercent & "|One or more journal elements are missing or incorrect."
End If
  
 
    If ScoreElements(1) = "0" Then RuleMessage = RuleMessage & "|The account debited is incorrect"
    If ScoreElements(2) = "0" Then RuleMessage = RuleMessage & "|The debit amount is incorrect"
    If ScoreElements(3) = "0" Then RuleMessage = RuleMessage & "|The account credited is incorrect"
    If ScoreElements(4) = "0" Then RuleMessage = RuleMessage & "|The credit amount is incorrect"

End Function


Function grade2X2JournalEntry(DebitAcct As String, DebitAmt As String, DebitAcctCol As Integer, DebitAmtCol As Integer, CreditAcct As String, CreditAmt As String, CreditAcctCol As Integer, CreditAmtCol As Integer, WkSht As String, JRange As String) As Variant
Dim ScoreCode As String
Dim DebitAccts() As String
Dim CreditAccts() As String
Dim DebitAmts() As String
Dim CreditAmts() As String

DebitAccts = Split(DebitAcct, "|")
CreditAccts = Split(CreditAcct, "|")
DebitAmts = Split(DebitAmt, "|")
CreditAmts = Split(CreditAmt, "|")

'Grade total entry
    If checkFullJournalEntries(DebitAcct, DebitAmt, DebitAcctCol, DebitAmtCol, CreditAcct, CreditAmt, CreditAcctCol, CreditAmtCol, WkSht, JRange) Then
        ScoreCode = "1"
    Else
        ScoreCode = "0"
    End If
'Grade All Elements
    If checkJournalElement(DebitAccts(0), WkSht, JRange, DebitAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(DebitAccts(1), WkSht, JRange, DebitAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(DebitAmts(0), WkSht, JRange, DebitAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(DebitAmts(1), WkSht, JRange, DebitAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
 
    If checkJournalElement(CreditAccts(0), WkSht, JRange, CreditAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(CreditAccts(1), WkSht, JRange, CreditAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(CreditAmts(0), WkSht, JRange, CreditAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If

        If checkJournalElement(CreditAmts(1), WkSht, JRange, CreditAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    grade2X2JournalEntry = ScoreCode

End Function

Function complexOutputJournalEntry2x2(val As Variant, Optional Weights As String = "0") As String
    
Dim ScoreElements() As String
Dim ScorePercent As Double
Dim ElementCount As Integer
Dim scoreWeights() As String

ScoreElements = Split(val, "|")

If Weights = "0" Then

    For ElementCount = 0 To UBound(ScoreElements)
        ScorePercent = ScorePercent + ScoreElements(ElementCount)
    Next

    ScorePercent = ScorePercent / (UBound(ScoreElements) + 1)

Else

    scoreWeights = Split(Weights, "|")
    
    For ElementCount = 0 To UBound(ScoreElements)
        ScorePercent = ScorePercent + scoreWeights(ElementCount) * ScoreElements(ElementCount)
    Next

End If


If ScoreElements(0) = 1 Then
    complexOutputJournalEntry2x2 = "|1|All journal entry elements are correct."
Else
    complexOutputJournalEntry2x2 = "|" & ScorePercent & "|One or more journal elements are missing or incorrect."
End If
  
 
    If ScoreElements(1) = "0" Or ScoreElements(2) = "0" Then RuleMessage = RuleMessage & "|One or more of the accounts debited is incorrect"
    If ScoreElements(3) = "0" Or ScoreElements(4) = "0" Then RuleMessage = RuleMessage & "|One or more of the debit amounts is incorrect"
    If ScoreElements(5) = "0" Or ScoreElements(6) = "0" Then RuleMessage = RuleMessage & "|One or more of the accounts credited is incorrect"
    If ScoreElements(7) = "0" Or ScoreElements(8) = "0" Then RuleMessage = RuleMessage & "|One or more of the credit amounts is incorrect"
     
End Function

Function complexOutputJournalEntry1x2(val As Variant, Optional Weights As String = "0") As String
    
Dim ScoreElements() As String
Dim ScorePercent As Double
Dim ElementCount As Integer
Dim scoreWeights() As String

ScoreElements = Split(val, "|")

If Weights = "0" Then

    For ElementCount = 0 To UBound(ScoreElements)
        ScorePercent = ScorePercent + ScoreElements(ElementCount)
    Next

    ScorePercent = ScorePercent / (UBound(ScoreElements) + 1)

Else

    scoreWeights = Split(Weights, "|")
    
    For ElementCount = 0 To UBound(ScoreElements)
        ScorePercent = ScorePercent + scoreWeights(ElementCount) * ScoreElements(ElementCount)
    Next

End If


If ScoreElements(0) = 1 Then
    complexOutputJournalEntry1x2 = "|1|All journal entry elements are correct."
Else
    complexOutputJournalEntry1x2 = "|" & ScorePercent & "|One or more journal elements are missing or incorrect."
End If
  
 
    If ScoreElements(1) = "0" Then RuleMessage = RuleMessage & "|One or more of the accounts debited is incorrect"
    If ScoreElements(2) = "0" Then RuleMessage = RuleMessage & "|One or more of the debit amounts is incorrect"
    If ScoreElements(3) = "0" Or ScoreElements(4) = "0" Then RuleMessage = RuleMessage & "|One or more of the accounts credited is incorrect"
    If ScoreElements(5) = "0" Or ScoreElements(6) = "0" Then RuleMessage = RuleMessage & "|One or more of the credit amounts is incorrect"
     
End Function

Function grade1X2JournalEntry(DebitAcct As String, DebitAmt As String, DebitAcctCol As Integer, DebitAmtCol As Integer, CreditAcct As String, CreditAmt As String, CreditAcctCol As Integer, CreditAmtCol As Integer, WkSht As String, JRange As String) As Variant
Dim ScoreCode As String
Dim DebitAccts() As String
Dim CreditAccts() As String
Dim DebitAmts() As String
Dim CreditAmts() As String

DebitAccts = Split(DebitAcct, "|")
CreditAccts = Split(CreditAcct, "|")
DebitAmts = Split(DebitAmt, "|")
CreditAmts = Split(CreditAmt, "|")

'Grade total entry
    If checkFullJournalEntries(DebitAcct, DebitAmt, DebitAcctCol, DebitAmtCol, CreditAcct, CreditAmt, CreditAcctCol, CreditAmtCol, WkSht, JRange) Then
        ScoreCode = "1"
    Else
        ScoreCode = "0"
    End If
'Grade All Elements
    If checkJournalElement(DebitAccts(0), WkSht, JRange, DebitAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    
    If checkJournalElement(DebitAmts(0), WkSht, JRange, DebitAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(CreditAccts(0), WkSht, JRange, CreditAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(CreditAccts(1), WkSht, JRange, CreditAcctCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    
    If checkJournalElement(CreditAmts(0), WkSht, JRange, CreditAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If

        If checkJournalElement(CreditAmts(1), WkSht, JRange, CreditAmtCol) Then
        ScoreCode = ScoreCode & "|1"
    Else
        ScoreCode = ScoreCode & "|0"
    End If
    grade1X2JournalEntry = ScoreCode

End Function

Sub listCellsReferencedInCell(cellReference As String)
  Dim c As Range
  Dim Ch As Range
  Dim precedentCells As Range
  Dim cellCount As Integer
  Dim cellProcessCount As Integer
  Dim outputString As String
  Dim references() As String
  Dim checkValueCount As Integer
  Dim matchFound As Boolean
  Dim rangeCell As Range
  Dim arrayCount As Integer
  Dim matchCount As Integer
  
  
  
  
  Set c = Sheets(Replace(Split(cellReference, "!")(0), "'", "")).Range(Replace(Split(cellReference, "!")(1), "$", ""))
    
  references = Split(cellReferences, "|")
  
    arrayCount = 1
    If UBound(references) > 0 Then arrayCount = UBound(references) + 1

  On Error Resume Next
    Set precedentCells = c.DirectPrecedents
  On Error GoTo 0
 
  If Not (precedentCells Is Nothing) Then
'    cellCount = precedentCells.Count
    For Each rangeCell In precedentCells
        matchFound = False
        For checkValueCount = 1 To UBound(references)
            If references(checkValueCount) = rangeCell.address Then
                matchFound = True
                Exit For
            End If
        Next
        If matchFound = False Then
            ReDim Preserve references(arrayCount) As String
            references(arrayCount) = rangeCell.address
            arrayCount = arrayCount + 1
            matchCount = matchCount + 1
        End If
        
    Next
    If matchCount > 0 Then
        references(0) = "1"
    Else
        references(0) = "0"
    End If
    outputString = references(0)
  End If



  For cellProcessCount = 1 To UBound(references)
  
    outputString = outputString & "|" & references(cellProcessCount)
  Next
  
  cellReferences = outputString

End Sub

Sub listAllPrecedents(checkRange As String)

Dim referencedcells() As String
Dim targetCells As String
Dim targetSheet As String
Dim targetCellCount As Integer
Dim noNewRangeFound As Boolean


targetCells = Split(checkRange, "!")(1)
targetSheet = Replace(Split(checkRange, "!")(0), "'", "")

cellReferences = ""


listCellsReferencedInCell targetSheet & "!" & targetCells

If cellReferences <> "" Then

Do Until noNewRangeFound = True
    referencedcells = Split(cellReferences, "|")
    If referencedcells(0) = "0" Then
        noNewRangeFound = True
    Else
        targetCells = referencedcells(1)
        For targetCellCount = 2 To UBound(referencedcells)
            targetCells = targetCells & "," & referencedcells(targetCellCount)
        Next
    End If


listCellsReferencedInCell targetSheet & "!" & targetCells

Loop
Else
    cellReferences = "Blank"
End If
''debug.print cellReferences
End Sub

Sub checkCellInPrecedents(checkRange As String, checkCell As String)
    Dim checkArray() As String
    Dim checkCount As Integer
    
    RuleData = False
    listAllPrecedents checkRange
    If cellReferences = "Blank" Then
        RuleData = "No Precedents Found"
    Else
        checkArray = Split(cellReferences, "|")
        For checkCount = 1 To UBound(checkArray)
            If InStr(Replace(checkCell, "$", ""), Replace(checkArray(checkCount), "$", "")) > 0 Then RuleData = True
            'debug.print "Looking for:" & Replace(checkCell, "$", "") & "; finding:" & Replace(checkArray(checkCount), "$", "") & ";Match = " & RuleData
        Next
    End If
    'debug.print RuleData
End Sub

Sub checkCellHasPrecedents(checkRange As String)
    Dim checkArray() As String
    Dim checkCount As Integer
    
    RuleData = False
    listAllPrecedents checkRange
    If cellReferences <> "Blank" Then RuleData = True
'    'debug.print RuleData
End Sub

Function searchNoErrorMultiple(checkValues As String, checkString As String, Optional allOrPart As Integer) As Boolean
'checkValues is a pipe delimited string of values to check against the checkString
'allOrPart expects 0 to act like an "Or" only one checkValue must appear in the string anything else will act like an AND

On Error GoTo Hell

Dim valuesCount As Integer
Dim checkValuesArray() As String
Dim matchCount As Integer

Select Case allOrPart

    Case 0
        checkValuesArray = Split(checkValues, "|")
        For valuesCount = 0 To UBound(checkValuesArray)
            If VBA.InStr(1, checkString, checkValuesArray(valuesCount)) > 0 Then
                searchNoErrorMultiple = True
                Exit Function
            End If
        Next
    
    Case Else
        checkValuesArray = Split(checkValues, "|")
        For valuesCount = 0 To UBound(checkValuesArray)
            If VBA.InStr(1, checkString, checkValuesArray(valuesCount)) > 0 Then matchCount = matchCount + 1
            If matchCount = UBound(checkValuesArray) + 1 Then searchNoErrorMultiple = True
        Next
    
End Select

Exit Function

Hell:
    searchNoErrorMultiple = False
    On Error GoTo 0

End Function

Function FilterInfo(wkstName As String, InfoType As Integer, Optional FilterNumber As Integer = 0, Optional param As String) As Boolean
On Error GoTo Hell

Dim WkSheet As Worksheet
Dim FilterCount As Integer

Set WkSheet = Sheets(wkstName)
If WkSheet.AutoFilter.Filters.count = 0 Then Exit Function

Select Case InfoType

    Case 1
    ' returns true if any filter option is set on for FilterNumber or any if FilterNumber is not provided

    If FilterNumber <> 0 Then
        FilterInfo = WkSheet.AutoFilter.Filters(FilterNumber).On
        Exit Function
    Else
        For FilterCount = 1 To WkSheet.AutoFilter.Filters.count
            If WkSheet.AutoFilter.Filters(FilterCount).On Then
                FilterInfo = True
                Exit Function
            End If
        Next
    End If

    Case 2
    'Returns true if the criteria1 used matches the param for filter specified in FilterNumber or if FilterNumber is omited the criteria matches any filter
    If FilterNumber <> 0 Then
        If WkSheet.AutoFilter.Filters(FilterNumber).Criteria1 = param Then
            FilterInfo = True
            Exit Function
        End If
    Else
        For FilterCount = 1 To WkSheet.AutoFilter.Filters.count
            If WkSheet.AutoFilter.Filters(FilterCount).On Then
                If WkSheet.AutoFilter.Filters(FilterCount).Criteria1 = param Then
                    FilterInfo = True
                    Exit Function
                End If
            End If
        Next
    End If

End Select

Exit Function
Hell:
    FilterInfo = False
    On Error GoTo 0
End Function

Sub findNextTask(Optional paramToMakeHidden As Boolean)

Dim responseFormula As String
Dim responseFormulaArray() As String
Dim responseSheet As String

Cells(ActiveCell.row, 4).Select

Do Until ActiveCell.value <> "  task"

    ActiveCell.offset(1, 0).Select

Loop

Do Until ActiveCell.value = "  task"

    If ActiveCell.value = "" Then Exit Sub
    ActiveCell.offset(1, 0).Select
    
Loop

ActiveCell.offset(7, 0).Select

If ActiveCell.offset(-2, 2).value = "" Then

    If MsgBox(ActiveCell.offset(-5, 2), vbYesNo, "Response Formula?") = vbYes Then
    
        If ActiveCell.offset(-4, 2).value <> "" Then
            responseFormulaArray = Split(ActiveCell.offset(-4, 2).value, "|")
            responseSheet = responseFormulaArray(0)
            If InStr(1, responseSheet, " ") > 0 Then responseSheet = "'" & responseSheet & "'"
            responseFormula = responseSheet & "!" & responseFormulaArray(1)
        End If
    
        responseFormula = InputBox("Response Cell?", "Add response formula", responseFormula)
        ActiveCell.offset(-2, 2).value = "'=cellResponse(" & responseFormula & ")"
    
    End If
    
End If



End Sub

Sub displayWorkbookNames(Optional paramToMakeHidden As Boolean)

Dim wkstName As name

For Each wkstName In ActiveWorkbook.Names

    Debug.Print wkstName.name
'    If InStr(1, wkstName.name, "solver_") = 0 Then wkstName.Delete
Next



End Sub

Function conditionalFormatInfo(checkSheet As String, checkRng As String, InfoType As Integer, Optional CheckParam As String) As Boolean

Dim formatRange As Range
Dim formatRule As Integer
Dim CompareValue As Double
Dim CheckParams() As String
Dim IconRule As Integer


On Error GoTo Hell
conditionalFormatInfo = False

If InStr(1, checkSheet, " ") > 0 Then checkSheet = "'" & checkSheet & "'"

Set formatRange = Range(checkSheet & "!" & checkRng)

Select Case InfoType

Case 1
'Conditional formatting used

If formatRange.FormatConditions.count > 0 Then conditionalFormatInfo = True

Case 2
'value used in rule

For formatRule = 1 To formatRange.FormatConditions.count
    
    If formatRange.FormatConditions(formatRule).Type = 2 Or formatRange.FormatConditions(formatRule).Type = 9 Then
        If InStr(1, formatRange.FormatConditions(formatRule).Formula1, CheckParam) > 0 Then
            conditionalFormatInfo = True
            Exit Function
        End If
    End If
Next

Case 3
'Checks to see if a particular formatting type is used in the range

For formatRule = 1 To formatRange.FormatConditions.count

    If formatRange.FormatConditions(formatRule).Type = VBA.CInt(CheckParam) Then
        conditionalFormatInfo = True
        Exit Function
    End If
Next

Case 4
'checks to see if the rule applies to the specified (checkparam) range
For formatRule = 1 To formatRange.FormatConditions.count

    If formatRange.FormatConditions(formatRule).AppliesTo.address = CheckParam Then
        conditionalFormatInfo = True
        Exit Function
    End If
Next

Case 5
'check to see if the interior cell color is set to CheckParam value (or non zero if CheckParam is blank)

If CheckParam = "" Then
    CompareValue = 16777215
    
    For formatRule = 1 To formatRange.FormatConditions.count
        If formatRange.FormatConditions(formatRule).Interior.color <> CompareValue Then
            conditionalFormatInfo = True
            Exit Function
        End If
    Next
    
Else
    CompareValue = CDbl(CheckParam)
    For formatRule = 1 To formatRange.FormatConditions.count
        If formatRange.FormatConditions(formatRule).Interior.color = CompareValue Then
            conditionalFormatInfo = True
            Exit Function
        End If
    Next

End If

Case 6
'check to see if the bar color is set to CheckParam value (or non zero if CheckParam is blank)

If CheckParam = "" Then
    CompareValue = 16777215
    
    For formatRule = 1 To formatRange.FormatConditions.count
        If formatRange.FormatConditions(formatRule).BarColor.color <> CompareValue Then
            conditionalFormatInfo = True
            Exit Function
        End If
    Next
    
Else
    CompareValue = CDbl(CheckParam)
    For formatRule = 1 To formatRange.FormatConditions.count
        If formatRange.FormatConditions(formatRule).BarColor.color = CompareValue Then
            conditionalFormatInfo = True
            Exit Function
        End If
    Next

End If

Case 7
'check to see top or bottom 10 format condition is applied correctly
    For formatRule = 1 To formatRange.FormatConditions.count
    If formatRange.FormatConditions(formatRule).Type = 5 Then
    If formatRange.FormatConditions(formatRule).TopBottom = CInt(CheckParam) Then
        conditionalFormatInfo = True
        Exit Function
    End If
    End If
    Next

Case 8
'check to see top or bottom 10 rank format condition is applied correctly

    For formatRule = 1 To formatRange.FormatConditions.count
    If formatRange.FormatConditions(formatRule).Type = 5 Then
    If formatRange.FormatConditions(formatRule).Rank = CInt(CheckParam) Then
        conditionalFormatInfo = True
        Exit Function
    End If
    End If
    Next

Case 9
'check to see if the border color is changed. If no checkParam then checks to see that it is not default color

'If CheckParam = "" Then
'    CompareValue = 16777215
    
'    For formatRule = 1 To formatRange.FormatConditions.count
'        If formatRange.FormatConditions(formatRule).Interior.color <> CompareValue Then
            conditionalFormatInfo = True
'            Exit Function
'        End If
'    Next
    
'Else
'    CompareValue = CDbl(CheckParam)
'    For formatRule = 1 To formatRange.FormatConditions.count
'        If formatRange.FormatConditions(formatRule).Interior.color = CompareValue Then
'            conditionalFormatInfo = True
'            Exit Function
'        End If
'    Next

'End If

Case 10
'check the icon set combinations of values and operators the checkparam is a pipe delimited string the first value is the operator and the second is the value
CheckParams = Split(CheckParam, "|")

    For formatRule = 1 To formatRange.FormatConditions.count
        If formatRange.FormatConditions(formatRule).Type = 6 Then
            
        For IconRule = 1 To formatRange.FormatConditions(formatRule).IconCriteria.count
            If formatRange.FormatConditions(formatRule).IconCriteria(IconRule).operator = CInt(CheckParams(0)) And formatRange.FormatConditions(formatRule).IconCriteria(IconRule).value = CInt(CheckParams(1)) Then
                conditionalFormatInfo = True
                Exit Function
            End If
        
        Next
        End If
    Next


End Select

Exit Function

Hell:

conditionalFormatInfo = False




End Function


Function findPivotTables(Optional WkSht As String = "") As String
' If optional wksht name is provided, function will look for PivotTable only on that sheet

Dim Wkst As Worksheet
findPivotTables = "No PivotTables Found"

On Error GoTo Hell

For Each Wkst In ActiveWorkbook.Worksheets

    If Wkst.PivotTables.count > 0 Then
    
        If WkSht <> "" Then
            If Wkst.name = WkSht Then
                findPivotTables = Wkst.name
                Exit Function
            End If
        Else
            findPivotTables = Wkst.name
            Exit Function
        End If
    
    End If

Next

Exit Function

Hell:
findPivotTables = "No PivotTables Found"

End Function

Function findPivotTableCount(Optional WkSht As String = "") As Integer
' If optional wksht name is provided, function will look for PivotTable only on that sheet

Dim Wkst As Worksheet
Dim PTCount As Integer
findPivotTableCount = 0

On Error GoTo Hell

For Each Wkst In ActiveWorkbook.Worksheets

    If WkSht <> "" Then
        If Wkst.name = WkSht Then
            findPivotTableCount = Wkst.PivotTables.count
            Exit Function
        End If
    Else
        findPivotTableCount = findPivotTableCount + Wkst.PivotTables.count
    End If

Next

Exit Function

Hell:
findPivotTableCount = 0

End Function

Function PivotTableDataRange(WkSht As String, FieldName As String)

Dim PT As PivotTable
Dim PTItem As PivotItem
Dim PTField As PivotField
Dim shownFields() As String
Dim PTValueCount As Integer
Dim visibleList As String
Dim MonthNum As Integer

PivotTableDataRange = False

On Error GoTo Hell

If returnPivotTableforSheet(WkSht) = False Then
    PivotTableDataRange = False
Else
    
Set PT = returnPivotTableforSheet(WkSht)

For Each PTField In PT.dataFields

    If InStr(1, PTField.name, FieldName) > 0 Then
        PivotTableDataRange = PTField.DataRange.address
    End If

Next

End If
Exit Function

Hell:
PivotTableDataRange = False

End Function



Function PivotTableInfo(WkSht As String, InfoType As Integer, FieldName As String, Optional param As String) As Boolean

Dim PT As PivotTable
Dim PTItem As PivotItem
Dim PTField As PivotField
Dim shownFields() As String
Dim PTValueCount As Integer
Dim visibleList As String
Dim MonthNum As Integer
Dim argumentArray() As String
Dim PTFilter As PivotFilter
Dim PTCell As Range
Dim argCount As Integer



On Error GoTo Hell

If returnPivotTableforSheet(WkSht) = False Then
    PivotTableInfo = False
Else
    
Set PT = returnPivotTableforSheet(WkSht)

Select Case InfoType

Case 1
' fieldName exists in Page, Row, or Column element. If Param Provided then fieldname must be in that element

    Select Case param
    
    Case "Page"
        For Each PTField In PT.pageFields
            If PTField.name = FieldName Then
                PivotTableInfo = True
                Exit Function
            End If
        Next
    
    Case "Row"
        For Each PTField In PT.rowFields
            If PTField.name = FieldName Then
                PivotTableInfo = True
                Exit Function
            End If
        Next
        
    Case "Column"
        For Each PTField In PT.columnFields
            If PTField.name = FieldName Then
                PivotTableInfo = True
                Exit Function
            End If
        Next
                
    Case Else
        For Each PTField In PT.pageFields
            If PTField.name = FieldName Then
                PivotTableInfo = True
                Exit Function
            End If
        Next
        For Each PTField In PT.rowFields
            If PTField.name = FieldName Then
                PivotTableInfo = True
                Exit Function
            End If
        Next
        For Each PTField In PT.columnFields
            If PTField.name = FieldName Then
                PivotTableInfo = True
                Exit Function
            End If
        Next
    End Select

Case 2
' Checks to see if the filters for a field are set correctly

    shownFields = Split(param, "|")
    PivotTableInfo = True

    For Each PTField In PT.pageFields
        If PTField.name = FieldName Then
            For Each PTItem In PTField.PivotItems
                If PTItem.visible Then visibleList = visibleList & "|" & PTItem.name
            Next
        End If
    Next

    For Each PTField In PT.rowFields
        If PTField.name = FieldName Then
            For Each PTItem In PTField.PivotItems
                If PTItem.visible Then visibleList = visibleList & "|" & PTItem.name
            Next
        End If
    Next

    For Each PTField In PT.columnFields
        If PTField.name = FieldName Then
            For Each PTItem In PTField.PivotItems
                If PTItem.visible Then visibleList = visibleList & "|" & PTItem.name
            Next
        End If
    Next


    For PTValueCount = 0 To UBound(shownFields)
        If InStr(1, visibleList, shownFields(PTValueCount)) = 0 Then PivotTableInfo = False
    Next


Case 3
'field in data element of PT
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case 4
'field in data element of PT summarized as correct function

Select Case param

Case "Sum"
'field summarized as SUM
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlSum Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "Count"
'field summarized as COUNT
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlCount Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "Average"
'field summarized as Average
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlAverage Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "Max"
'field summarized as Max
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlMax Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "Min"
'field summarized as Min
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlMin Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "Product"
'field summarized as Product
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlProduct Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "CountNums"
'field summarized as CountNums
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlCountNums Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "StDev"
'field summarized as StDev
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlStDev Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "StDevP"
'field summarized as StDevP
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlStDevP Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "Var"
'field summarized as Var
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlVar Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

Case "VarP"
'field summarized as VarP
        For Each PTField In PT.dataFields
            If InStr(1, PTField.name, FieldName) And PTField.Function = xlVarP Then
                PivotTableInfo = True
                Exit Function
            End If
        Next

End Select

Case 5
'Used to determine if grouping is done by date for the level (Year, Quarter, or Month) given in Param

Select Case FieldName

Case "Month"
For Each PTField In PT.PivotFields
    If PTField.IsCalculated = False Then
    If IsDate(Right(PTField.PivotItems(1), Len(PTField.PivotItems(1)) - 1)) Then
        MonthNum = Month(Right(PTField.PivotItems(1), Len(PTField.PivotItems(1)) - 1))
        Select Case MonthNum
            Case 1
                If PTField.PivotItems(2) = "Jan" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 2
                If PTField.PivotItems(2) = "Feb" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 3
                If PTField.PivotItems(2) = "Mar" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 4
                If PTField.PivotItems(2) = "Apr" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 5
                If PTField.PivotItems(2) = "May" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 6
                If PTField.PivotItems(2) = "Jun" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 7
                If PTField.PivotItems(2) = "Jul" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 8
                If PTField.PivotItems(2) = "Aug" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 9
                If PTField.PivotItems(2) = "Sep" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 10
                If PTField.PivotItems(2) = "Oct" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 11
                If PTField.PivotItems(2) = "Nov" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 12
                If PTField.PivotItems(2) = "Dec" Then
                    PivotTableInfo = True
                    Exit Function
                End If
        End Select
    End If
    End If
Next

Case "Quarter"
For Each PTField In PT.PivotFields
    If PTField.IsCalculated = False Then
    If IsDate(Right(PTField.PivotItems(1), Len(PTField.PivotItems(1)) - 1)) Then
        MonthNum = Month(Right(PTField.PivotItems(1), Len(PTField.PivotItems(1)) - 1))
        Select Case MonthNum
            Case 1
                If PTField.PivotItems(2) = "Qtr1" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 2
                If PTField.PivotItems(2) = "Qtr1" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 3
                If PTField.PivotItems(2) = "Qtr1" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 4
                If PTField.PivotItems(2) = "Qtr2" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 5
                If PTField.PivotItems(2) = "Qtr2" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 6
                If PTField.PivotItems(2) = "Qtr2" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 7
                If PTField.PivotItems(2) = "Qtr3" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 8
                If PTField.PivotItems(2) = "Qtr3" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 9
                If PTField.PivotItems(2) = "Qtr3" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 10
                If PTField.PivotItems(2) = "Qtr4" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 11
                If PTField.PivotItems(2) = "Qtr4" Then
                    PivotTableInfo = True
                    Exit Function
                End If
            Case 12
                If PTField.PivotItems(2) = "Qtr4" Then
                    PivotTableInfo = True
                    Exit Function
                End If
        End Select
    End If
    End If
Next

Case "Year"
For Each PTField In PT.PivotFields
    If PTField.IsCalculated = False Then
    If IsDate(Right(PTField.PivotItems(1), Len(PTField.PivotItems(1)) - 1)) Then
        If param = PTField.PivotItems(2) Then
            PivotTableInfo = True
            Exit Function
        End If
    Else
        If InStr(1, PTField.PivotItems(1), param) > 0 Then
            PivotTableInfo = True
            Exit Function
        End If
    End If
    End If
Next

End Select


Case 6

'specified field in data element of PT has specific formula
    For Each PTField In PT.PivotFields
        If PTField.name = FieldName Then
            If InStr(1, PTField.formula, param) > 0 Then
                PivotTableInfo = True
                Exit Function
            End If
        End If
    Next

Case 7
'checks to see if specified field format matches param
    For Each PTField In PT.dataFields
        If InStr(1, PTField.name, FieldName) > 0 Then
            If PTField.numberFormat = param Then
                PivotTableInfo = True
                Exit Function
            End If
        End If
    Next

Case 8
'checks to see if a specific value exists for a field in the pivotTable

If InStr(1, PT.GetPivotData(FieldName), param) > 0 Then

    PivotTableInfo = True
    Exit Function
 
End If

Case 9
'checks to see if the appropriate filter is applied to a field. Param will be | delimited with the filtertype first and the values in subsequent positions.

argumentArray = Split(param, "|")

Select Case argumentArray(0)

Case "TopN"
'Determines if the Top N filter is applied to the field

For Each PTFilter In PT.PivotFields(FieldName).PivotFilters
    
    If PTFilter.FilterType = xlTopCount And PTFilter.Value1 = argumentArray(1) Then
        PivotTableInfo = True
        Exit Function
    End If

Next

Case "NotBetween"
'Determines if the NotBetween filter is applied to the field

For Each PTFilter In PT.PivotFields(FieldName).PivotFilters
    
    If PTFilter.FilterType = xlValueIsNotBetween And PTFilter.Value1 = argumentArray(1) And PTFilter.Value2 = argumentArray(2) Then
        PivotTableInfo = True
        Exit Function
    End If

Next

Case "BottomN"
'Determines if the NotBetween filter is applied to the field

For Each PTFilter In PT.PivotFields(FieldName).PivotFilters
    
    If PTFilter.FilterType = xlBottomCount And PTFilter.Value1 = argumentArray(1) Then
        PivotTableInfo = True
        Exit Function
    End If

Next

End Select

Case 10
'determines if Param value is included in the set of values displayed for a field


For Each PTField In PT.PivotFields
If InStr(1, PTField.name, FieldName) > 0 Then

For Each PTCell In PTField.DataRange

    If CStr(PTCell.value) = param Then
        PivotTableInfo = True
        Exit Function
    End If

Next

End If
Next

Case 11
'determines if Param value is included in the set of values displayed for a datafield


For Each PTField In PT.dataFields
If InStr(1, PTField.name, FieldName) > 0 Then

For Each PTCell In PTField.DataRange

    If CStr(PTCell.value) = param Then
        PivotTableInfo = True
        Exit Function
    End If

Next

End If
Next

Case 12
'checks to see if the show values as calculation is correct


Select Case param

Case "%DiffFrom"

If PT.PivotFields(FieldName).Calculation = xlPercentDifferenceFrom Then
    PivotTableInfo = True
    Exit Function
End If

End Select

Case 13
'Checks the basefield setting of the PivotTable

If PT.PivotFields(FieldName).BaseField = param Then
    PivotTableInfo = True
    Exit Function
End If

Case 14
'Checks the baseitem setting of the PivotTable

If PT.PivotFields(FieldName).BaseItem = param Then
    PivotTableInfo = True
    Exit Function
End If

End Select
End If

Exit Function

Hell:
PivotTableInfo = False

End Function

Function PivotTableRange(SheetName As String, Optional PTNumber As Integer = 1)

Dim PT As PivotTable

On Error GoTo Hell

If returnPivotTableforSheet(SheetName) = False Then
    PivotTableRange = ""
Else
    
Set PT = returnPivotTableforSheet(SheetName)

PivotTableRange = PT.TableRange1.address

End If

Exit Function

Hell:
PivotTableRange = ""


End Function

Function checkIterativeCalcOn()


On Error GoTo Hell
checkIterativeCalcOn = False

If Application.Iteration Then checkIterativeCalcOn = True

Exit Function

Hell:
checkIterativeCalcOn = False

End Function


Function rangeWithinNamedRange(targetRange As Range, namedRange As String) As Boolean

On Error GoTo Hell

rangeWithinNamedRange = False

If Union(Range(ReturnAddressForRange(namedRange)), targetRange).count = Range(ReturnAddressForRange(namedRange)).count Then rangeWithinNamedRange = True

Exit Function

Hell:
rangeWithinNamedRange = False

End Function

Function valueWithinRange(targetValue As Variant, targetRange As Range, Optional valueCount As Integer = 1) As Boolean

Dim checkCell As Range
Dim numValues As Integer

On Error GoTo Hell
valueWithinRange = False

numValues = 0
For Each checkCell In targetRange.Cells

    If checkCell.value = targetValue Then
    
        numValues = numValues + 1
        
    End If

Next

If numValues = valueCount Then valueWithinRange = True

Exit Function

Hell:

valueWithinRange = False

End Function

Function findPairedValue(val1 As Variant, targetRange As Range, colOffset As Integer) As Variant

Dim checkCell As Range

findPairedValue = ""



On Error GoTo Hell

For Each checkCell In targetRange.Cells

    If checkCell.value = val1 Then
    
        findPairedValue = checkCell.offset(0, colOffset).value
        Exit Function
        
    End If

Next

Exit Function

Hell:
findPairedValue = ""

End Function


Function countTextUsedInRangeCells(searchText As String, targetRange As Range, Optional incidentCount As Integer = 1) As Boolean

Dim checkCell As Range
Dim numValues As Integer

On Error GoTo Hell
countTextUsedInRangeCells = False

numValues = 0
For Each checkCell In targetRange.Cells

    If InStr(1, checkCell.formula, searchText) > 0 Then
    
        numValues = numValues + 1
        
    End If

Next

If numValues = incidentCount Then countTextUsedInRangeCells = True

Exit Function

Hell:

countTextUsedInRangeCells = False

End Function

Function chartCountBySheet(WkSht As String) As Integer

Dim xlSht As Worksheet

On Error GoTo Hell

chartCountBySheet = 0

For Each xlSht In ActiveWorkbook.Sheets

    If xlSht.name = WkSht Then
        chartCountBySheet = xlSht.ChartObjects.count
        Exit Function
    End If
    
Next

Exit Function


Hell:
chartCountBySheet = 0


End Function

Function cellValidation(targetCell As Range, checkType As Integer, Optional param As String)

Dim checkRange As Range
Dim rangeBuilder() As String

On Error GoTo Hell
cellValidation = False

Select Case checkType

Case 1
'type of validation used

If targetCell.Validation.Type = VBA.CInt(param) Then cellValidation = True

Case 2
'formula 1 field of the validation references the prescribed ranges of values. param is a piped delimited string "sheet|Cells"
rangeBuilder = Split(param, "|")
Set checkRange = Sheets(rangeBuilder(0)).Range(rangeBuilder(1))

If Union(Range(targetCell.Validation.Formula1), checkRange).count = Range(targetCell.Validation.Formula1).count Then cellValidation = True
    
End Select


Exit Function

Hell:
cellValidation = False

End Function

Function ChartCountByType(findType As String) As Integer

Dim xlsChart As Chart
Dim xlschartobject As ChartObject
Dim xlsSheetChart As ChartObject
Dim xlsSheet As Worksheet
Dim ChartCount As Integer
Dim searchType() As String
Dim searchCount As Integer


searchType = Split(findType, "|")

'loop through all searched for chart types
For searchCount = 0 To UBound(searchType)

'loop through all worksheets and then all charts on the worksheets

    For Each xlsSheet In Worksheets
        If xlsSheet.ChartObjects.count > 0 Then
        For Each xlsSheetChart In xlsSheet.ChartObjects
'        Debug.Print xlsSheet.name & ":" & xlsSheetChart.Chart.ChartType
            If xlsSheetChart.Chart.ChartType = CInt(searchType(searchCount)) Then
                ChartCount = ChartCount + 1
'                Debug.Print "Match Found:" & ChartCount & "|Type:" & searchType(searchCount) & "|Worksheet:" & xlsSheet.name
            End If
        Next
        End If
    Next

'loop through all workbook chart objects
    For Each xlsChart In ActiveWorkbook.Charts
        If xlsChart.ChartType = searchType(searchCount) Then
            ChartCount = ChartCount + 1
        End If
    Next
Next

ChartCountByType = ChartCount

End Function

Function comboChartTypes(xlsChart As Chart)

Dim seriesCount As Integer
Dim targetSeriesNumber As Integer


seriesCount = xlsChart.FullSeriesCollection.count

comboChartTypes = "Type:" & xlsChart.ChartType & "|SCount:" & seriesCount & "|"


For targetSeriesNumber = 1 To seriesCount

'    comboChartTypes = comboChartTypes & "S" & targetSeriesNumber & ":" & comboChartTypes & xlsChart.FullSeriesCollection(targetSeriesNumber).ChartType & "|"
    comboChartTypes = comboChartTypes & "S" & targetSeriesNumber & ":" & xlsChart.FullSeriesCollection(targetSeriesNumber).ChartType & "|"
    
Next

End Function

Function ChartInfoForSheet(xlsSheetName As String, InfoType As Integer)
Dim xlsSheet As Worksheet
Dim xlsChart As Chart

On Error GoTo Hell


ChartInfoForSheet = False

Set xlsSheet = Sheets(xlsSheetName)

Select Case InfoType

Case 1
ChartInfoForSheet = xlsSheet.ChartObjects.count

Case 2
Set xlsChart = xlsSheet.ChartObjects(1).Chart
ChartInfoForSheet = comboChartTypes(xlsChart)


End Select

Exit Function

Hell:
ChartInfoForSheet = False

End Function

Function SparklinesByRange(xlsSheetName As String, checkRange As String, InfoType As Integer)
Dim xlsSheet As Worksheet
Dim xlsRange As Range

On Error GoTo Hell


SparklinesByRange = False

Set xlsSheet = Sheets(xlsSheetName)

Select Case InfoType

Case 1

For Each xlsRange In xlsSheet.Range(checkRange)

    SparklinesByRange = SparklinesByRange + xlsRange.SparklineGroups.count

Next


End Select

Exit Function

Hell:
SparklinesByRange = False

End Function


Function checkVariations(checkCell As Range, checkCategory As String, checkOption As String) As Boolean

On Error GoTo Hell

checkVariations = False

Select Case checkCategory

Case "Days"

    Select Case checkOption
    
    Case "Sun":
    
        If VBA.UCase(checkCell.value) = "SUN" Or VBA.UCase(checkCell.value) = "SUNDAY" Or VBA.UCase(checkCell.value) = "S" Or VBA.UCase(checkCell.value) = "SU" Then checkVariations = True
    
    Case "Mon":

        If VBA.UCase(checkCell.value) = "MON" Or VBA.UCase(checkCell.value) = "MONDAY" Or VBA.UCase(checkCell.value) = "M" Or VBA.UCase(checkCell.value) = "MO" Then checkVariations = True

    Case "Tues":

        If VBA.UCase(checkCell.value) = "TUES" Or VBA.UCase(checkCell.value) = "TUE" Or VBA.UCase(checkCell.value) = "TUESDAY" Or VBA.UCase(checkCell.value) = "T" Or VBA.UCase(checkCell.value) = "TU" Then checkVariations = True

    Case "Weds":

        If VBA.UCase(checkCell.value) = "WED" Or VBA.UCase(checkCell.value) = "WEDS" Or VBA.UCase(checkCell.value) = "WEDNESDAY" Or VBA.UCase(checkCell.value) = "W" Or VBA.UCase(checkCell.value) = "WE" Then checkVariations = True

    Case "Thurs":

        If VBA.UCase(checkCell.value) = "THURS" Or VBA.UCase(checkCell.value) = "THURSDAY" Or VBA.UCase(checkCell.value) = "THU" Or VBA.UCase(checkCell.value) = "THUR" Or VBA.UCase(checkCell.value) = "T" Or VBA.UCase(checkCell.value) = "TH" Then checkVariations = True

    Case "Fri":

        If VBA.UCase(checkCell.value) = "FRI" Or VBA.UCase(checkCell.value) = "FRIDAY" Or VBA.UCase(checkCell.value) = "F" Or VBA.UCase(checkCell.value) = "FR" Then checkVariations = True

    Case "Sat":

        If VBA.UCase(checkCell.value) = "SAT" Or VBA.UCase(checkCell.value) = "SATURDAY" Or VBA.UCase(checkCell.value) = "S" Or VBA.UCase(checkCell.value) = "SA" Then checkVariations = True
    
    End Select

End Select


Exit Function

Hell:
checkVariations = False

End Function

Function regressionOutput(wksh As String, outputType As Integer, Optional param As String, Optional param2 As Integer) As Variant

Dim RegWkSh As Worksheet
Dim searchRange As Range
Dim analysisCount As Integer
Dim statDesired() As String
Dim searchcell As Integer
Dim outputRow As Integer
Dim outputCol As Integer
Dim searchChart As ChartObject

On Error GoTo Hell

regressionOutput = False
Set RegWkSh = ActiveWorkbook.Sheets(wksh)

Select Case outputType

    Case 1 'returns the number of regression analyses found on a worksheet
    
    For Each searchRange In RegWkSh.Range("A1:Z1000")
        If searchRange.value = "Regression Statistics" Then
            If searchRange.offset(1, 0).value = "Multiple R" And searchRange.offset(2, 0).value = "R Square" And searchRange.offset(3, 0).value = "Adjusted R Square" Then analysisCount = analysisCount + 1
        End If
    Next
    regressionOutput = analysisCount
    Exit Function
    
    Case 2 'returns the regression model statistic requested in param rounded to the param2 number of digits
    
    For Each searchRange In RegWkSh.Range("A1:Z1000")
        If searchRange.value = "Regression Statistics" Then
            For searchcell = 1 To 5
                outputRow = 0
                If searchRange.offset(searchcell, 0).value = param Then
                    outputRow = searchcell
                    Exit For
                End If
            Next
            If outputRow <> 0 Then
                If searchRange.offset(outputRow, 1).value <> "" Then regressionOutput = Round(searchRange.offset(outputRow, 1).value, param2)
                Exit Function
            End If
        End If
    Next
    
    Case 3 'returns the Anova stat specified in the pipe delimited string rounded to the param2 number of digits
    
    statDesired = Split(param, "|")

    For Each searchRange In RegWkSh.Range("A1:Z1000")
        If searchRange.value = "ANOVA" Then
            For searchcell = 1 To 5
                outputRow = 0
                If searchRange.offset(searchcell, 0).value = statDesired(0) Then
                    outputRow = searchcell
                    Exit For
                End If
            Next
            For searchcell = 1 To 5
                outputCol = 0
                If searchRange.offset(1, searchcell).value = statDesired(1) Then
                    outputCol = searchcell
                    Exit For
                End If
            Next
            If outputRow <> 0 And outputCol <> 0 Then
                If searchRange.offset(outputRow, outputCol).value <> "" Then regressionOutput = Round(searchRange.offset(outputRow, outputCol).value, param2)
                Exit Function
            End If
        End If
    Next

    Case 4 'independent variable used in analysis
    
    For Each searchRange In RegWkSh.Range("A1:Z1000")
        If searchRange.value = "Coefficients" Then
        If searchRange.offset(1, -1).value = "Intercept" Then
            Set searchRange = searchRange.offset(0, -1)
            For searchcell = 1 To 20
                If searchRange.offset(searchcell, 0).value = param Then
                    regressionOutput = True
                    Exit Function
                End If
            Next
        End If
        End If
    Next
    
    Case 5 'returns the stat for the variable defined in the pipe delimeted string (variableName|DesiredStat) in param rounded to param2 number of digits
    
    statDesired = Split(param, "|")

    For Each searchRange In RegWkSh.Range("A1:Z1000")
        If searchRange.value = "Coefficients" Then
        If searchRange.offset(1, -1).value = "Intercept" Then
            Set searchRange = searchRange.offset(0, -1)
            For searchcell = 1 To 20
                outputRow = 0
                If searchRange.offset(searchcell, 0).value = statDesired(0) Then
                    outputRow = searchcell
                    Exit For
                End If
            Next
            For searchcell = 1 To 10
                outputCol = 0
                If searchRange.offset(0, searchcell).value = statDesired(1) Then
                    outputCol = searchcell
                    Exit For
                End If
            Next
            If outputRow <> 0 And outputCol <> 0 Then
                If searchRange.offset(outputRow, outputCol).value <> "" Then regressionOutput = Round(searchRange.offset(outputRow, outputCol).value, param2)
                Exit Function
            End If
        End If
        End If
    Next
    
    Case 6 'specified output chart exists
    
    If RegWkSh.ChartObjects.count > 0 Then
        For Each searchChart In RegWkSh.ChartObjects
            If VBA.UCase(VBA.Replace(searchChart.Chart.ChartTitle.text, " ", "")) = VBA.UCase(VBA.Replace(param, " ", "")) Then
                regressionOutput = True
                Exit Function
            End If
        Next
    End If

End Select

Exit Function

Hell:
regressionOutput = False

End Function




Attribute VB_Name = "fill"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public id As String
Private localParamlist As String ' "sheetname|address|formula"
Private localRevert As Boolean
Private originalFormula As String
Private localDataChanged As Boolean

#If officeApplication = 2 Then ' excel
Private s As Worksheet
#End If


Public Property Get DataChanged() As Boolean
DataChanged = localDataChanged
End Property

Public Property Let DataChanged(theData As Boolean)
  localDataChanged = theData
End Property



Public Property Get paramList() As String
paramList = localParamlist
End Property

Public Property Let paramList(theData As String)
  localParamlist = theData
  DataChanged = True
End Property

Public Property Get revert() As Boolean
revert = localRevert
End Property

Public Property Let revert(theData As Boolean)
  localRevert = theData
  DataChanged = True
End Property

Public Sub process()
#If officeApplication = 2 Then ' excel
  Dim params As Variant
  params = Split(paramList, "|")
  If params(0) = "" Then
    Set s = ActiveSheet
  Else
    Set s = Sheets(params(0))
  End If
  
  originalFormula = s.Range(params(1)).formula
  s.Range(params(1)).formula = params(2)

#End If
End Sub


Public Sub restore()
#If officeApplication = 2 Then ' excel
  Dim params As Variant
  params = Split(paramList, "|")
  If revert Then
  If params(0) = "" Then
    Set s = ActiveWorkbook
  Else
    Set s = Sheets(params(0))
  End If
  s.Range(params(1)).formula = originalFormula
  End If

#End If
End Sub
Sub setProperty(propertyName As String, value As Variant)
  Select Case LCase(propertyName)
    Case "id": id = value
    Case "paramlist": localParamlist = value
    Case "revert": localRevert = value
  End Select
  localDataChanged = True
End Sub



Attribute VB_Name = "frmPassword"
Attribute VB_Base = "0{384E45DE-5B7C-408C-AAFD-B84BAA48FBE5}{0CEB364B-0CEC-4FC6-A42F-3A1471748E61}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Option Explicit
Private Sub cmdSubmit_Click()
Me.Hide
End Sub

Attribute VB_Name = "frmRibbon"
Attribute VB_Base = "0{E7355C0F-52C1-46B2-8FBB-6E41E98F9DD9}{B33F442D-86E7-40D0-80F5-705E466DB19C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




Dim ribbon() As Image
Dim Button() As Image
Dim buttonCount As Integer
Sub showButtons(Optional activeButton As Image)
  Dim x As Integer
  If activeButton Is Nothing Then
    For x = 0 To buttonCount - 1
      Button(x, 1).visible = False
    Next
  Else
    For x = 0 To buttonCount - 1
      Button(x, 1).visible = Button(x, 0).name = activeButton.name
    Next
  End If
End Sub

Private Sub imgl_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons
End Sub
Private Sub imgm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons
End Sub
Private Sub imgr_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons
End Sub
Private Sub imgh_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons
End Sub
Private Sub imgf_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons
End Sub

Private Sub imgT_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons imgT
End Sub
Private Sub imgI_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons imgI
End Sub
Private Sub imgS_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons imgS
End Sub
Private Sub imgV_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons imgV
End Sub

Private Sub imgYBS_Click()

End Sub

Private Sub imgYI_Click()
#If Mac Then
If version < 15 Then Me.Hide
#End If
xShowInBrowser
End Sub

Private Sub imgYS_Click()
#If Mac Then
If version < 15 Then Me.Hide
#End If
xSubmit
End Sub

Private Sub imgYT_Click()
#If Mac Then
If version < 15 Then Me.Hide
#End If
xShowTaskBox
End Sub

Private Sub imgYV_Click()
#If Mac Then
If version < 15 Then Me.Hide
#End If
xViewGradeSheet
End Sub

Private Sub lblMsg_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons
End Sub

Private Sub UserForm_Initialize()
Dim top As Single
Dim left As Single
Dim panelCount As Integer
Dim a As assignment
Dim s As Image
Dim ys As Image

Set a = loadassignment
'debug.print a.submissionType
If a.submissionType = "graded" Then
  Set s = imgS
  Set ys = imgYS
  imgBS.visible = False
Else
  Set s = imgBS
  Set ys = imgYBS
  imgS.visible = False
End If

buttonCount = 4
ReDim Button(buttonCount, 1)
Set Button(0, 0) = imgI
Set Button(1, 0) = imgT
Set Button(2, 0) = s
Set Button(3, 0) = imgV
Set Button(0, 1) = imgYI
Set Button(1, 1) = imgYT
Set Button(2, 1) = ys
Set Button(3, 1) = imgYV



panelCount = buttonCount + 3
ReDim ribbon(0 To panelCount, 0 To 1)
Set ribbon(0, 0) = imgF
Set ribbon(1, 0) = imgL
Set ribbon(2, 0) = imgI
Set ribbon(3, 0) = imgT
Set ribbon(4, 0) = imgM
Set ribbon(5, 0) = s
Set ribbon(6, 0) = imgV
Set ribbon(7, 0) = imgR
Set ribbon(0, 1) = imgF
Set ribbon(1, 1) = imgL
Set ribbon(2, 1) = imgYI
Set ribbon(3, 1) = imgYT
Set ribbon(4, 1) = imgM
Set ribbon(5, 1) = ys
Set ribbon(6, 1) = imgYV
Set ribbon(7, 1) = imgR

top = 0
left = 0

For x = 0 To panelCount
  ribbon(x, 0).Picture = ribbon(x, 0).Picture
Next

For x = 0 To buttonCount - 1
  Button(x, 1).Picture = Button(x, 1).Picture
Next

imgH.Picture = imgH.Picture
imgF.Picture = imgF.Picture

For y = 0 To 1
  For x = 1 To panelCount
    ribbon(x, y).top = top + imgH.height
  Next
Next

imgH.top = top
imgF.top = imgL.top + imgL.height

imgH.left = left
imgL.left = left
For y = 0 To 1
  For x = 2 To panelCount - 1
    ribbon(x, y).left = ribbon(x - 1, y).left + ribbon(x - 1, y).width
  Next
Next
imgR.left = imgH.left + imgH.width - imgR.width

imgF.left = left

lblMsg.top = imgF.top + imgF.height
lblMsg.left = left - 2
lblMsg.width = imgF.width + 4


Me.width = imgR.left + imgR.width
Do Until Me.InsideWidth >= imgR.left + imgR.width
  Me.width = Me.width + 1
Loop

Me.height = lblMsg.top + lblMsg.height
Do Until Me.InsideHeight >= lblMsg.top + lblMsg.height
  Me.height = Me.height + 1
Loop


End Sub

Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
showButtons
End Sub
Attribute VB_Name = "frmSubmit"
Attribute VB_Base = "0{67ACD44D-1ED9-4525-AF30-49F024486476}{76EE27C7-0B88-4AEA-8589-4CBB5420259D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
























Option Explicit
Const border = 10
Const minimumMessageHeight = 60
Const maximumMessageHeight = 300
Public a As New assignment
Dim progress As Single

Dim rubricPresent As Boolean
Dim optionsOpen As Boolean
Dim isAdmin As Boolean
Dim visibilityCollections As New Collection
Dim messageControls As New Collection
Dim credentialControls As New Collection
Dim professorControls As New Collection
Dim initializing As Boolean
Dim recentTool As String
Dim useAccessToken As Boolean
Public publicLabel As String
Public silentSubmit As Boolean
Public Message As String



Sub wobble()
    Static timer1 As Single
    timer1 = Timer
    If Abs(Timer - timer1) > 1 Then
    If lblPercent.ForeColor = 14737632 Then
      lblPercent.ForeColor = 16777215
    Else
      lblPercent.ForeColor = 14737632
    End If
   End If
End Sub
' updates the pogress indicator
Sub update(percent As Single, Optional words As String, Optional errorDialogTitle As String, Optional buttons As Long = vbOK)
  ' a negative number for percent is an absolute setting, so -50 will record as 50%
  ' a positive number for percent is an incremental adjustment, so when the progress bar shows 30% and we will call update with a perecnt of 7, it will change the display to 37%
  Static updatePercent  As Single
  
  If percent > 0 Then
    updatePercent = updatePercent + percent
    If updatePercent > 100 Then updatePercent = 100
  Else
    updatePercent = Abs(percent)
  End If
  
  progress = lblBackground.width * (updatePercent / 100)
  lblProgress.width = progress
  lblPercent.caption = forceRound((updatePercent), 2) & "%"
  
  If errorDialogTitle = "" Then
    txtMessage.width = Me.lblBackground.width
    txtMessage.AutoSize = False
    txtMessage.text = words
    txtMessage.AutoSize = True
    txtMessage.width = lblBackground.width
  Else
    showMessage errorDialogTitle, words, buttons, errorDialogTitle, RGB(200, 0, 0)
 End If
 
  If optionsOpen Then
  '  displayProfOptions
  Else
    Me.height = Me.height - Me.InsideHeight + txtMessage.top + txtMessage.height + border
  End If
'If Me.visible = False Then Me.Show
  DoEvents
  chkHidden.SetFocus
End Sub

Private Sub cboTool_Enter()
  Me.optTool.value = True
End Sub

Private Sub cmdCancel_Click()
Unload Me
End Sub

Private Sub cmdMessageCancel_Click()
  processStep cmdMessageCancel.Tag
End Sub

Private Sub cmdMessageCustom_Click()
  processStep cmdMessageCustom.Tag
End Sub

Private Sub cmdMessageNo_Click()
   processStep cmdMessageNo.Tag
End Sub

Private Sub cmdMessageOK_Click()
  processStep cmdMessageOK.Tag
End Sub

Private Sub cmdMessageRetry_Click()
  processStep cmdMessageRetry.Tag
End Sub

Private Sub cmdMessageYes_Click()
  processStep cmdMessageYes.Tag
End Sub

Private Sub cmdOK_Click()
  processStep "process admin options"
End Sub

Private Sub cmdPasswordCancel_Click()
  processStep cmdPasswordCancel.Tag
End Sub

Private Sub cmdPasswordOK_Click()
 
 If Not IsEmailValid(txtEmail.text) Then
   txtEmail.SetFocus
   txtEmail.backColor = RGB(255, 255, 200)
   txtMessage.text = "Data Entry Problem: Email address is not valid."
   Exit Sub
 End If
 txtEmail.backColor = RGB(255, 255, 255)
 
 If Len(txtPassword.text) = 0 Then
   txtPassword.SetFocus
   txtPassword.backColor = RGB(255, 255, 200)
   txtMessage.text = "Data Entry Problem: Password is required."
   Exit Sub
 End If
 txtPassword.backColor = RGB(255, 255, 255)
  
  processStep cmdPasswordOK.Tag
End Sub

' promots for the username and password
Sub getCredentials()
  Dim email As String
  Dim top As Single
  Dim left As Single
  
  If useAccessToken Then
    processStep "get rubric"
    Exit Sub
  End If
  
  If a.submissionType = "practice" Then
    xViewGradeSheet
    Me.Hide
    Exit Sub
  End If
  
  
  cmdPasswordOK.Tag = "password ok"
  cmdPasswordCancel.Tag = "unload"

  
  update 1, "Waiting for user input."
  
  ShowControls credentialControls
  ' position the credential controls
  top = lblMessageBG.top + border
  left = lblMessageBG.left + (lblMessageBG.width - lblEmail.width - txtEmail.width) / 2
  
  lblEmail.top = top
  lblEmail.left = left
  
  txtEmail.top = top
  txtEmail.left = left + lblEmail.width + border
  
  LblPW.top = top + lblEmail.height + border / 2
  LblPW.left = left
  
  txtPassword.left = txtEmail.left
  txtPassword.top = LblPW.top
  
  lblMessageBG.height = (txtPassword.top - lblMessageBG.top) + txtPassword.height + border
  
  cmdPasswordCancel.top = lblMessageBG.top + lblMessageBG.height + border
  cmdPasswordCancel.left = lblMessageBG.left + lblMessageBG.width - cmdPasswordCancel.width
  
  cmdPasswordOK.top = cmdPasswordCancel.top
  cmdPasswordOK.left = cmdPasswordCancel.left - cmdPasswordOK.width - border
    
  txtMessageTitle.text = publisherName & " Credentials"
  txtMessageTitle.backColor = &H808080
  
  lblMessageBG.backColor = &HE0E0E0
  
   Me.height = cmdPasswordCancel.height + cmdPasswordCancel.top + border + Me.height - Me.InsideHeight
  
  If Len(txtEmail.text) = 0 Then
     email = getValue("authEmail")
     If IsEmailValid(email) Then
       txtEmail.text = email
       txtPassword.SetFocus
     Else
       txtEmail.SetFocus
     End If
  Else
    txtPassword.SetFocus
  End If
    

End Sub
' shows the administrator options
Function showProfOptions() As Boolean
  Dim x As Integer
  Dim recentTool As String
  Dim top As Single
  Dim left As Single
  
displayProfOptions
  
  Me.cmdOK.SetFocus
  optionsOpen = True
  Me.caption = "Administrator Options"
  recentTool = getValue("recentTool")
  optNoRecord.value = True
  Select Case recentTool
    Case "proxySubmit": optRecordFor = True
    Case Else ' it must be a tool, look for a match and mark it
      For x = 0 To Me.cboTool.ListCount - 1
        If Me.cboTool.list(x) = recentTool Then
          Me.cboTool.ListIndex = x
          Me.optTool.value = True
          Exit For
        End If
      Next
  End Select

End Function
' shows the professor options portion of the form
Sub displayProfOptions()
  Dim top As Single
  Dim left As Single
  ShowControls professorControls
  ' position the professor option controls
  top = lblMessageBG.top '+ border
  left = lblMessageBG.left + ((lblMessageBG.width - ((cboTool.left + cboTool.width) - optNoRecord.left)) / 2)
  optNoRecord.top = top + border
  optNoRecord.left = left
  
  optRecordFor.top = optNoRecord.top + optNoRecord.height + border / 2
  optRecordFor.left = left
  
  txtProxyEmail.top = optRecordFor.top + optRecordFor.height
  txtProxyEmail.left = left + border * 2
  
  optTool.top = txtProxyEmail.top + txtProxyEmail.height + border / 2
  optTool.left = left
  
  cboTool.left = txtProxyEmail.left
  cboTool.top = optTool.top + optTool.height
  
    
  txtMessageTitle.text = "Administrator  Options"
  txtMessageTitle.backColor = &H808080
  
  lblMessageBG.backColor = &HE0E0E0
  lblMessageBG.height = cboTool.top - lblMessageBG.top + cboTool.height + border
   
  cmdCancel.top = lblMessageBG.top + lblMessageBG.height + border
  cmdCancel.left = lblMessageBG.left + lblMessageBG.width - cmdCancel.width
  
  cmdOK.top = cmdCancel.top
  cmdOK.left = cmdCancel.left - cmdOK.width - border
   
  Me.height = cmdCancel.height + cmdCancel.top + border + Me.height - Me.InsideHeight

End Sub
' reduces the display to just a progress bar
Sub collapseDisplay()
  Me.height = txtMessage.top + txtMessage.height + Me.height - Me.InsideHeight + 3
End Sub
' processes the professor options
Sub processProfOptions()
  Dim permissions As String
  Dim temp As String
  update 0, ""
 ' collapseDisplay
       If Me.optNoRecord.value Then ' no record
         recentTool = "local score"
            ' check to see if the rules are present
            updateValue "recentTool", "localScore"
            If getValue("assignmentType") = "key" Then
              rubricPresent = True
              localScore
            ElseIf getValue("activityID") = "EMPTY" Then
              ' file has not been uploaded.  Assume we are testing during development
              rubricPresent = True
              localScore
            ElseIf getValue("activityID") = "___Activity ID___" Then
              ' file has not been uploaded.  Assume we are testing during development
              rubricPresent = True
              localScore
            ElseIf Not rubricPresent Then
                update -9, "Getting assignment rubric."
                processStep "get rubric"
             Else
               localScore
             End If
       ElseIf Me.optRecordFor.value Then ' proxy
            recentTool = "proxy submit"
            updateValue "recentTool", "proxySubmit"
            update 0, "Initializing"
            If rubricPresent Then
              proxySubmit
            Else
               update -9, "Getting assignment rubric."
               processStep "get rubric"
            End If
       ElseIf Me.optTool.value Then ' tool
             updateValue "recentTool", Me.cboTool.value
             optionsOpen = True
             Select Case cboTool.text
               Case "Show Log"
                 update -10, "Accessing log data."
                 showLog
                 update -100, "Displaying log in default browser."
               Case "Show Collapsible Log"
                 update -10, "Accessing log data."
                 showLogIndex
                 update -100, "Displaying log in default browser."
               Case "Show Properties"
                 update -10, "Accessing properties."
                 showPropertiesInBrowser
                 update -100, "Displaying properties in default browser."
               Case "Save Password"
'                 If txtEmail.text = "gove@byu.edu" Or txtEmail.text = "nick.ball.phd@gmail.com" Then
'                   permissions = "Permissions" & Chr(30) & "author"
'                 Else
'                   permissions = "Permissions" & Chr(30) & "instructor"
'                 End If
                 writeToFile dataKeyPath, ncode("Data Key" & Chr(30) & txtEmail.text & Chr(30) & txtPassword.text, Environ$("computername") & Environ$("username")) & vbNewLine & ncode(CStr("Permissions" & Chr(30) & "instructor"))
                 update -100, "Password saved."
               Case "Clear Password"
                 deleteFile dataKeyPath
                 update -100, "Password removed."
'               Case "Open Assignment Builder"
'                 update 0, "Opening Assignment Builder."
'                 showBuilder
               Case "Import Work and Properties"
                 importWork True, Me
                  update -100, "Complete."
                  a.loadModel
               Case "Change ActivityID"
                 temp = InputBox("Enter the new ActvityID.  Caution: This will normally prevent the assignment from submitting.  Use only if your are sure what you are doing.", "New ActivityID", getValue("activityID"))
                 If temp > "" Then updateValue "activityID", temp
                  update -100, "Complete."
                  a.loadModel
               Case "Import Work"
                 importWork False, Me
                  update -100, "Complete."
               Case "Use Local Rubric"
                 rubricPresent = True
                 update -100, "Now using local rubric.  To reset, close form and re-open."
               Case "Student Login"
                 isAdmin = False
                 preChecks
               Case Else
                 ' assume that it is an application-specific or assignment-specific tool
                 ' Assignment-specific tools are located in modAssignmentSpecific
                 ' Application-specific tools are located in modApplicaiton
                 If Not runApplicationSpecificTool(Me) Then
                   runAssignmentSpecificTool Me
                 End If
                 update -100, "Waiting for user input"
                 If Message = "" Then
                   showProfOptions
                 Else
                   showMessage "message", Message
                 End If
             End Select
           
       End If

End Sub


' used to manage the flow of the form.  performs a proxy submit
Sub proxySubmit()
            submitAssignment txtProxyEmail.text
End Sub

' performs a local score
Sub localScore()
            update -50, "Evaluating work."
            a.score "", Me
            updateValue "scoreCode", a.getScoreCode
            update -100, "Complete."
              showAssignmentInBrowser True, a, silentSubmit
              showProfOptions

End Sub







Private Sub lblMessageBG_Click()

End Sub


Private Sub txtMessage_Change()

End Sub

' selects the appropriate option button when the proxy email gets the focus
Private Sub txtProxyEmail_Enter()
  Me.optRecordFor.value = True
End Sub
' used to manage the flow of the form.   runs the prechecks on the assignment
Sub preChecks()

  Dim Message As String
  Dim Button As Long
  update -7, "Checking assignment for major omissions."
  preprechecks
  
  
    Message = a.passPrecheck
    If getValue("accessToken") <> "EMPTY" Then
      Message = "This assignment will be submitted for " & getValue("downloadedByName") & vbNewLine & vbNewLine & Message
      Button = xlCustom
      useAccessToken = True
    Else
      Button = vbYesNoCancel
    End If
    
    
    
    If Message > "" Then
          update -8, "Waiting for user input."
          showMessage "answer message", Message, Button, "Are you sure you want to submit?"
    Else
        getCredentials
    End If
       
End Sub


' checks to see if the user is an administrator and if so, shows the administrator tools
Sub checkAdmin()
  Dim json As New jsonParser
  Dim userType As Collection
  Dim x As Integer
  Dim showTools As Boolean
     rubricPresent = True
    
    ' check to see if the user is a professor
    Set userType = json.parse(getValue("userType"))
    For x = 1 To userType.count
      If InStr(1, "instructor", userType(x), vbTextCompare) > 0 Then
        showTools = True
        Exit For
      ElseIf InStr(1, "assistant", userType(x), vbTextCompare) > 0 Then
        showTools = True
        Exit For
      ElseIf InStr(1, "mentor", userType(x), vbTextCompare) > 0 Then
        showTools = True
        Exit For
      ElseIf InStr(1, "manager", userType(x), vbTextCompare) > 0 Then
        showTools = True
        Exit For
      End If
    Next
    
    If showTools Then
      loadInstructorTools
      showProfOptions
    Else
       submitAssignment
    End If ' showtools

End Sub

' used to manage the flow of the form.  submits the assignment
Sub submitAssignment(Optional proxyEmail As String)
        a.score
        a.Submit Me, txtEmail.text, txtPassword.text, proxyEmail
End Sub

' used to tell of the password package has been saved to the local machine
Private Function pakcageExists() As Boolean
  On Error Resume Next
  pakcageExists = Dir(dataKeyPath) > ""
  On Error GoTo 0
End Function

' show the controls based on the specified collection.  Used to allow different parts of the form to be visible without the use of frames because access will not work with frames
Sub ShowControls(Optional coll As Collection)
    'if coll is nothing then this will hide controls
    
    Dim ctrl As Object
    Dim col As Collection
    
    lblMessageBG.visible = Not coll Is Nothing
    txtMessageTitle.visible = Not coll Is Nothing
    
    For Each col In visibilityCollections
      For Each ctrl In col
            ctrl.visible = col Is coll
      Next
    Next
End Sub

Private Sub UserForm_Activate()
  Dim datakeyFound As Boolean
  Dim data As Variant
  Dim dataline As Variant
  Dim email As String
  Dim line As Variant
  Dim x As Long
  ' code is here instead of initialize because we want to be able to see it.  Anyting that happend in initialize happens before the form is visible
    If initializing Then
            lblProgress.backColor = appColor
            Me.backColor = RGB(200, 200, 200)
            update -1, "Initializing."
            a.loadModel
            rubricPresent = False
          'Me.width = 315
          
          email = getValue("downloadedByEmail")
          If InStr(1, email, "@") > 0 Then
            txtProxyEmail.text = email
          End If
          
          If pakcageExists Then
            data = Split(getFileContents(dataKeyPath), vbNewLine)
            
            ' check for locally encoded props
            For x = LBound(data) To UBound(data)
              line = Split(dcode(CStr(data(x)), Environ$("computername") & Environ$("username")), Chr(30))
              Select Case line(0)
                Case "Data Key"
                    txtEmail.text = line(1)
                    txtPassword.text = line(2)
                    loadInstructorTools
                    datakeyFound = True
              End Select
            Next
            
            ' check for props encoded at myEducator
        '    For x = LBound(data) To UBound(data)
        '      line = Split(dcode(CStr(data(x))), Chr(30))
        '      Select Case line(0)
        '        Case "Permissions"
        '            If line(1) = "author" And datakeyFound Then
        '              cboTool.AddItem "Open Assignment Builder"
        '            End If
        '      End Select
        '    Next
          End If
          
            
        If publicLabel > "" Then
        ' doing an automatic process
        processStep publicLabel
        
        ElseIf isAdmin Then
          update -5, "Waiting for administrator options."
          showProfOptions
        ElseIf getValue("assignmentType") = "key" Then
                update -5, "Evauating workbook."
                a.score
                update -90, "Showing score."
                showAssignmentInBrowser True, a
                update -100, "Complete."
         Else
           ' normal submission.
           preChecks
         End If
         initializing = False
    End If

End Sub

Private Sub UserForm_Initialize()
  
   initializing = True
  
  ' build sets for showing different parts of form without panels
  messageControls.Add txtMessageMessage
  messageControls.Add cmdMessageRetry
  messageControls.Add cmdMessageCustom
  messageControls.Add cmdMessageNo
  messageControls.Add cmdMessageYes
  messageControls.Add cmdMessageCancel
  messageControls.Add cmdMessageOK
  
  professorControls.Add cmdOK
  professorControls.Add cmdCancel
  professorControls.Add cboTool
  professorControls.Add optTool
  professorControls.Add txtProxyEmail
  professorControls.Add optRecordFor
  professorControls.Add optNoRecord
  
  credentialControls.Add cmdPasswordOK
  credentialControls.Add cmdPasswordCancel
  credentialControls.Add txtPassword
  credentialControls.Add txtEmail
  credentialControls.Add lblEmail
  credentialControls.Add LblPW

  visibilityCollections.Add messageControls
  visibilityCollections.Add professorControls
  visibilityCollections.Add credentialControls
  
  ShowControls messageControls
  
End Sub
' puts the instructor tools in the combo box
Sub loadInstructorTools()
  isAdmin = True
  cboTool.AddItem "Show Collapsible Log"
  cboTool.AddItem "Show Log"
  cboTool.AddItem "Show Properties"
  cboTool.AddItem "Submission Record"
  cboTool.AddItem "Save Password"
  cboTool.AddItem "Clear Password"
  cboTool.AddItem "Import Work"
  cboTool.AddItem "Import Work and Properties"
  cboTool.AddItem "Use Local Rubric"
  cboTool.AddItem "Student Login"
  loadApplicationSpecificTools Me
  loadAssignmentSpecificTools Me
  cboTool.AddItem "Change ActivityID"
  cboTool.ListIndex = 0
End Sub

' used to show a message and configure how to behave after a button is clicked
Sub showMessage(context As String, Message As String, Optional buttons As Long = vbOK, Optional title As String = "Message", Optional titleColor As Long = appColor, Optional pause As Boolean = True)
  
  Dim focusControl As Object
  Dim top As Single
  
  ShowControls messageControls


      cmdMessageCustom.Tag = context & " custom"
      cmdMessageRetry.Tag = context & " retry"
      cmdMessageOK.Tag = context & " ok"
      cmdMessageYes.Tag = context & " yes"
      cmdMessageNo.Tag = context & " no"
      cmdMessageCancel.Tag = context & " cancel"

  txtMessageTitle.backColor = titleColor
  lblMessageBG.backColor = &HFFFFFF
  lblMessageBG.BorderStyle = fmBorderStyleNone
  Select Case buttons
    Case vbOK
      cmdMessageCustom.visible = False
      cmdMessageRetry.visible = False
      cmdMessageOK.visible = True
      cmdMessageYes.visible = False
      cmdMessageNo.visible = False
      cmdMessageCancel.visible = False
      cmdMessageOK.left = lblMessageBG.left + lblMessageBG.width - cmdMessageOK.width
      Set focusControl = cmdMessageOK
    Case vbYesNoCancel
      cmdMessageCustom.visible = False
      cmdMessageRetry.visible = False
      cmdMessageOK.visible = False
      cmdMessageYes.visible = True
      cmdMessageNo.visible = True
      cmdMessageCancel.visible = True
      cmdMessageCancel.left = lblMessageBG.left + lblMessageBG.width - cmdMessageCancel.width
      cmdMessageNo.left = cmdMessageCancel.left - border - cmdMessageNo.width
      cmdMessageYes.left = cmdMessageNo.left - border - cmdMessageYes.width
      Set focusControl = cmdMessageYes
    Case vbRetryCancel
      cmdMessageCustom.visible = False
      cmdMessageRetry.visible = True
      cmdMessageOK.visible = False
      cmdMessageYes.visible = False
      cmdMessageNo.visible = False
      cmdMessageCancel.visible = True
      cmdMessageCancel.left = lblMessageBG.left + lblMessageBG.width - cmdMessageCancel.width
      cmdMessageRetry.left = cmdMessageCancel.left - border - cmdMessageRetry.width
      Set focusControl = cmdMessageRetry
    Case vbYesNo
      cmdMessageCustom.visible = False
      cmdMessageRetry.visible = False
      cmdMessageOK.visible = False
      cmdMessageYes.visible = True
      cmdMessageNo.visible = True
      cmdMessageCancel.visible = False
      cmdMessageNo.left = lblMessageBG.left + lblMessageBG.width - cmdMessageNo.width
      cmdMessageYes.left = cmdMessageNo.left - border - cmdMessageYes.width
      Set focusControl = cmdMessageYes
    Case vbOKCancel
      cmdMessageCustom.visible = False
      cmdMessageRetry.visible = False
      cmdMessageOK.visible = True
      cmdMessageYes.visible = False
      cmdMessageNo.visible = False
      cmdMessageCancel.visible = True
      cmdMessageCancel.left = lblMessageBG.left + lblMessageBG.width - cmdMessageCancel.width
      cmdMessageOK.left = cmdMessageNo.left - border - cmdMessageOK.width
      Set focusControl = cmdMessageOK
    Case xlCustom
      cmdMessageCustom.visible = True
      cmdMessageCustom.caption = "Choose User"
      cmdMessageCustom.width = 65
      cmdMessageRetry.visible = False
      cmdMessageOK.visible = False
      cmdMessageYes.visible = True
      cmdMessageNo.visible = True
      cmdMessageCancel.visible = True
      cmdMessageCancel.left = lblMessageBG.left + lblMessageBG.width - cmdMessageCancel.width
      cmdMessageNo.left = cmdMessageCancel.left - border - cmdMessageNo.width
      cmdMessageYes.left = cmdMessageNo.left - border - cmdMessageYes.width
      cmdMessageCustom.left = cmdMessageYes.left - border - cmdMessageCustom.width
      Set focusControl = cmdMessageYes
  End Select
  
  txtMessageMessage.left = border
  
  txtMessageMessage.width = lblMessageBG.width - border * 2
  txtMessageMessage.AutoSize = False
  txtMessageMessage.text = Message
  txtMessageMessage.AutoSize = True

  
  txtMessageMessage.left = Me.lblMessageBG.left + (Me.lblMessageBG.width - txtMessageMessage.width) / 2
  
  If txtMessageMessage.height < minimumMessageHeight Then
    lblMessageBG.height = minimumMessageHeight
    txtMessageMessage.top = lblMessageBG.top + (minimumMessageHeight - txtMessageMessage.height) / 2 '- txtMessageMessage.Height / 2
  ElseIf txtMessageMessage.height > maximumMessageHeight Then
    txtMessageMessage.AutoSize = False
    txtMessageMessage.top = lblMessageBG.top + border
    txtMessageMessage.height = maximumMessageHeight
    txtMessageMessage.ScrollBars = fmScrollBarsVertical
    txtMessageMessage.SetFocus
    lblMessageBG.height = txtMessageMessage.height + border * 2
    txtMessageMessage.SelStart = 0
    
  Else
    lblMessageBG.height = txtMessageMessage.height + border * 2
    txtMessageMessage.top = lblMessageBG.top + border
  End If
  
  
  
  cmdMessageOK.top = lblMessageBG.top + lblMessageBG.height + border
  cmdMessageCancel.top = cmdMessageOK.top
  cmdMessageYes.top = cmdMessageOK.top
  cmdMessageNo.top = cmdMessageOK.top
  cmdMessageRetry.top = cmdMessageOK.top
  cmdMessageCustom.top = cmdMessageOK.top
  
  Me.height = cmdMessageOK.top + cmdMessageOK.height + border + (Me.height - Me.InsideHeight)
  
  'Me.width = lblMessageBG.left * 2 + lblMessageBG.width + Me.width - Me.InsideWidth
  txtMessageTitle.text = title
  
  
  focusControl.SetFocus
  
  
  
  
  
End Sub


' adjust the layout of the from when it gets resized by other code
Private Sub UserForm_Resize()
  
  Dim offset As Single
  
  offset = Me.lblPercent.top - Me.lblBackground.top
  
  Me.lblBackground.top = border
  Me.lblBackground.left = border
  Me.lblBackground.width = Me.InsideWidth - (2 * border)
  
  Me.lblFrame.top = border
  Me.lblFrame.left = border
  Me.lblFrame.width = Me.lblBackground.width
  
  Me.lblPercent.top = border + offset
  Me.lblPercent.left = border
  Me.lblPercent.width = Me.lblBackground.width
  
  Me.lblProgress.top = border
  Me.lblProgress.left = border
  
  Me.txtMessage.top = border + Me.lblBackground.height
  Me.txtMessage.left = border
  Me.txtMessage.width = Me.lblBackground.width

End Sub


' used to either unload the form or show the admin options depending on if the user is an admin
Sub adminUnload()
If isAdmin Then
  showProfOptions
Else
  Unload Me
End If
End Sub
' precess the results from a button press
Sub processStep(stepLabel As String, Optional data As String)

Select Case stepLabel
  Dim temp As String
  Case "answer message yes": getCredentials
  Case "answer message no": Unload Me
  Case "answer message cancel": Unload Me
  Case "answer message custom":   useAccessToken = False: getCredentials
  Case "process admin options": processProfOptions
  Case "password ok": processStep "get rubric"
  Case "unload": adminUnload
  Case "unload ok": adminUnload
  Case "successful upload"
  
    If getValue("accessToken") = "EMPTY" Then
      If Not silentSubmit Then followLink domain & pathForActivity & getValue("courseID") & "/" & getValue("activityID") & "/" & getValue("submissionID")
    Else
        ' not sure why this is here.  It shows the grading report immeidiately.  Disabled October 2018
        'showAssignmentInBrowser True, a, silentSubmit
    End If

    If silentSubmit Then
      Me.Hide ' used with autograde so the form closes when complete
    Else
       showMessage "unload", "Submission Complete.", vbOK, "System Message"
    End If
  Case "successful proxy submission"
       update 10, "Preparing file for upload"
       a.upload Me, txtEmail.text, txtPassword.text, saveAttachmentForUpload, txtProxyEmail.text
       
  Case "successful submission":    a.upload Me, txtEmail.text, txtPassword.text, saveAttachmentForUpload
  Case "get rubric"
    update -9, "Getting assignment rubric."
    a.downloadRules Me, txtEmail.text, txtPassword.text
  Case "got rubric"
    update -13, "Scoring assignment submission."
    Select Case recentTool
      Case "local score": localScore
      Case "proxy submit": proxySubmit
      Case Else: checkAdmin
    End Select
  Case "retry password retry": getCredentials
  Case "retry password cancel": Unload Me
  Case "server error retry": getCredentials
  Case "server error cancel": Unload Me
  Case "rules login failed"
     'update 2, "Invalid email or password."
     showMessage "retry password", "Invalid email or password.", vbRetryCancel, "Submission Error", 200
  Case "submission error"
     showMessage "server error", data, vbRetryCancel, "Submission Error", 200
  Case "submission failure"
     showMessage "server error", data, vbRetryCancel, "Submission Failure", 200
  Case "unrecognized Response"
     showMessage "server error", data, vbRetryCancel, "Submission Failure", 200
  Case "upload error": showMessage "check submission", data, vbRetryCancel, "Almost Done"
  Case "check submission retry":
      temp = fixNull(submissionDetail(Me.txtEmail.text, Me.txtPassword.text, getValue("submissionID"), getValue("courseID")).GetItem("end_time", "EMPTY"), "EMPTY")
      If temp = "EMPTY" Then
         getCredentials
     Else
      updateValue "submissionEndTime", temp
      showMessage "unload", "The submission is now complete.  To see your submission at " & publisherName & ", visit the URL below." & vbNewLine & vbNewLine & domain & pathForActivity & getValue("courseID") & "/" & getValue("activityID") & "/" & getValue("submissionID"), vbOK, "System Message"
    End If
  Case "check submission cancel":
      temp = fixNull(submissionDetail(Me.txtEmail.text, Me.txtPassword.text, getValue("submissionID"), getValue("courseID")).GetItem("end_time", "EMPTY"), "EMPTY")
      If temp = "EMPTY" Then
         adminUnload
      Else
        updateValue "submissionEndTime", temp
        showMessage "unload", "The submission is now complete.  To see your submission at " & publisherName & ", visit the URL below." & vbNewLine & vbNewLine & domain & pathForActivity & getValue("courseID") & "/" & getValue("activityID") & "/" & getValue("submissionID"), vbOK, "System Message"
      End If
  Case "retry error":  showMessage "server error", data, vbRetryCancel, "System Error", 200
  Case "message ok":  adminUnload
  Case Else
     If data = "error" Then
       showMessage "unload", stepLabel, vbOK, "System Error", 200
     Else
       showMessage "unload", stepLabel, vbOK, "System Message"
     End If
End Select
 
If silentSubmit Then Me.Hide

End Sub






Attribute VB_Name = "frmTask"
Attribute VB_Base = "0{2E9314C6-A892-4946-BACE-DCB971D1FFD8}{72E5AB01-BD78-4C5F-B09C-9BAB1EB8B682}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





















Dim submissionType As String
Dim fraTable As Object
Dim top As Single
Dim left As Single
Dim btop As Single
Dim bleft As Single
Dim initializing
Dim InHeight As Single
Dim beenActivated As Boolean
Dim lastTaskName As String

Dim tasks As New Collection
Public Sub setTask(pos As Integer)
  spnAdvance.value = pos
End Sub

Public Sub chkComplete_Click()
  Dim tt As taskType
  Set tt = tasks(spnAdvance.value + 1)
  If chkComplete.value Then
    tt.complete = True
  Else
    tt.complete = False
  End If
  recordTaskStatus tt.id, tt.complete
End Sub
Sub recordTaskStatus(id As String, complete As Boolean)
  Dim status As String
  status = getValue("completeTasks")
  If complete Then
    If InStr(1, status, "|" & id & "|") = 0 Then
      updateValue "completeTasks", status & id & "|"
    End If
  Else
    updateValue "completeTasks", Replace(status, id & "|", "")
  End If
  
End Sub
Private Sub imgDock_Click()
  DockTaskForm Me, left, top
End Sub

Private Sub imgHide_Click()
Me.imgShow.Tag = Me.height
setFormheight Me.txtBg.top + Me.txtBg.height - 1
Me.imgShow.left = Me.imgHide.left
Me.imgShow.top = Me.imgHide.top - 10
Me.imgShow.visible = True

End Sub


Private Sub imgImage_BeforeDragOver(ByVal Cancel As MSForms.ReturnBoolean, ByVal data As MSForms.DataObject, ByVal x As Single, ByVal y As Single, ByVal DragState As MSForms.fmDragState, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)

End Sub

Private Sub imgShow_Click()
Me.height = Me.imgShow.Tag
Me.imgShow.visible = False

End Sub

Private Sub spnAdvance_Change()
  If spnAdvance.value = spnAdvance.Max Then
    'submit once we reach the end
    spnAdvance.value = spnAdvance.value - 1
    If MsgBox("You have reached the end of this assignment.  To submit your work for grading, you can use the ""Submit"" button from the ""Assignment"" tab of the ribbon." & vbNewLine & vbNewLine & "Do do you want to submit this assignment now?", vbQuestion + vbYesNo, "Submit Now?") = vbYes Then
    If submissionType = "practice" Then
       xViewGradeSheet
    Else
      frmSubmit.Show
    End If
    End If
    
  Else
    showData
  End If
End Sub


Private Sub txtTask_Change()

End Sub

Private Sub txtTitle_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
If InHeight > 0 Then
  Me.height = InHeight
  InHeight = 0
Else
  InHeight = Me.height
  Me.height = 0
End If
End Sub

Private Sub UserForm_Initialize()
  Dim a As assignment
  Dim i As instruction
  Dim s As taskSet
  Dim t As task
  Dim x As Integer
  Dim taskNum As Integer
  Dim taskid As Integer
  Dim taskSetid As Integer
  Dim completeTasks As String
  Dim instructionText As String
  Dim tt As taskType
  completeTasks = getValue("completeTasks")
  initializing = True
  
  Set a = loadassignment()
  #If officeApplication = 2 Then
        #If Mac Then
              If Application.version < 15 Then
                  'only show docking button in Mac 2011 for Excel
                  imgDock.visible = True
              End If
        #End If
  #End If
  
  submissionType = a.submissionType
        instructionText = vbNewLine & "Assignment Instructions:" & vbNewLine & vbNewLine & "There are a total of " & a.pointsPossible & " points on this assignment" & vbNewLine & vbNewLine
        For Each i In a.instructions
            instructionText = instructionText & i.text & vbNewLine & vbNewLine
        Next
'        'debug.print instructionText
'assignment instructions
        Set tt = New taskType
        
        tt.id = 0
        tt.name = "Instructions"
        tt.taskid = 0
        tt.taskSetid = taskSetid
        tt.title = a.title
        tt.num = 0
        tt.text = instructionText
        tt.hint = ""
        tt.exhibit = ""
        tt.logString = "Instructions"
        tasks.Add tt
  
  For Each s In a.taskSets
    taskSetid = taskSetid + 1
    If s.title <> "precheck" Then ' skip if a precheck
     taskNum = taskNum + 1
      taskid = 0
        Set tt = New taskType
        tasks.Add tt
        tt.id = 0
        tt.name = s.title & " Context"
        tt.taskid = 0
        tt.taskSetid = taskSetid
        tt.title = "Context for " & s.title & " Tasks"
        tt.num = 0
        tt.text = s.text & vbNewLine & vbNewLine & "This set of tasks as a total of " & s.pointsPossible & " points."
        tt.hint = ""
        tt.exhibit = ""
        tt.logString = taskSetid & "-Context"
      
      For Each t In s.tasks
        taskid = taskid + 1
        Set tt = New taskType
        tasks.Add tt
        tt.id = t.id
        tt.name = taskNum & "." & taskid & " " & t.name
        tt.taskid = taskid
        tt.taskSetid = taskSetid
'        tt.title = taskNum & ". " & s.title
        tt.title = s.title
        tt.num = taskid
        If t.pointsPossible = 1 Then
            tt.text = t.text & " [1 point]"
        Else
            tt.text = t.text & " [" & t.pointsPossible & " points]"
        End If
        tt.hint = t.hint
        tt.exhibit = t.exhibit
        tt.logString = taskSetid & "-" & taskid
        If InStr(1, completeTasks, "|" & t.id & "|") > 0 Then tt.complete = True
      Next
    End If
  Next
  
  
  
  spnAdvance.Max = tasks.count
  spnAdvance.value = 0
  
  Me.chkComplete.backColor = appColor 'RGB(99, 37, 35)
  txtTitle.backColor = appColor 'RGB(99, 37, 35)
  txtBg.backColor = RGB(180, 180, 180) 'RGB(196, 198, 151)
  txtTaskNumber.backColor = txtBg.backColor
  Me.backColor = appColor 'RGB(220, 220, 220) 'RGB(221, 217, 196)
  txtTitle.width = Me.InsideWidth
  'Me.width = Me.width + 1
  Me.txtTitle.left = spnResize.left + spnResize.width + spnAdvance.left - chkComplete.left
  showData
  


End Sub

Sub setFormWidth(desiredInsideWidth As Single)
  Me.width = desiredInsideWidth + (Me.width - Me.InsideWidth)
End Sub
Sub setFormheight(desiredInsideheight As Single)
  Me.height = desiredInsideheight + (Me.height - Me.InsideHeight)
End Sub



Sub showData()
  Dim linecount As Integer
  Dim margin As Single
  Dim boxHeight As Single
  Const textLeft = 29.4
  Dim tt As taskType
  Dim tt2 As taskType
  margin = 15
  
  Set tt = tasks(Me.spnAdvance.value + 1)
  
  If lastTaskName = tt.name Then Exit Sub
  
  
  ' configure for non-taskEntries
  If tt.id = "0" Then
    Me.txtTask.left = 0
    Me.txtTaskNumber.visible = False
    Me.txtBg.visible = False
    Me.chkComplete.visible = False
    On Error Resume Next
    Set tt2 = tasks(Me.spnAdvance.value + 2)
    tt.hint = tt2.hint
    On Error GoTo 0
Else
    Me.chkComplete.visible = True
    Me.txtTask.left = textLeft
    Me.txtTaskNumber.visible = True
    Me.txtBg.visible = True
  End If
  
  lastTaskName = tt.name
  
  addLogEntry "9" & Chr(30) & lastTaskName
  
  Me.txtTitle.text = tt.title
  Me.chkComplete = tt.complete
  Me.txtTaskNumber.text = tt.num
  
  Me.txtTask.width = Me.InsideWidth - Me.txtTask.left
  Me.txtTask.text = tt.text
  Me.txtTask.width = Me.InsideWidth - Me.txtTask.left
  
  
  Me.txtTask.SelLength = 0
  Me.txtTask.SelStart = 1
  Me.txtTask.SelStart = Len(Me.txtTask.text)
  
    If tt.exhibit = "" Then
    ' hide the image panel
    setFormheight Me.txtTask.height + Me.txtTask.top
    imgImage.visible = False
    
    imgHide.visible = False
    If Not fraTable Is Nothing Then
      fraTable.visible = False
    End If
  Else
    ' show the image or table
      imgHide.visible = True
    If InStr(1, tt.exhibit, "</tr>") > 0 Then
    'show the table
      If fraTable Is Nothing Then
        Set fraTable = Me.Controls.Add("Forms.Frame.1", "tableFrame", True)
      End If
      fraTable.visible = True
      
      makeTable tt.exhibit, fraTable
      
      fraTable.top = txtTask.top + txtTask.height + margin
      fraTable.left = margin
      setFormheight fraTable.top + fraTable.height + margin * 2
      
      If fraTable.width > txtTitle.width + (margin * 2) Then
        setFormWidth fraTable.width + (margin * 2)
        fraTable.left = margin
      Else
        fraTable.left = (Me.InsideWidth - fraTable.width) / 2
      End If

    Else
      ' show the image
      imgImage.visible = True
      
      
      
      fillImage tt.exhibit
      imgImage.top = txtTask.top + txtTask.height + margin
      setFormheight imgImage.top + imgImage.height + margin * 2
      If imgImage.width > txtTitle.width + (margin * 2) Then
        setFormWidth imgImage.width + (margin * 2)
        imgImage.left = margin
      Else
        imgImage.left = (Me.InsideWidth - imgImage.width) / 2
      End If
    End If
  End If
  Me.txtTask.SelStart = 1
  
  
  'Me.Height = Me.txtTask.Height + Me.txtTitle.Height + 20
  'If txtTask.Height < 30 Then txtTask.Height = 30
  If Me.height < 50 Then
    Me.height = 50
  End If
  
  
'  Me.height = Me.txtTask.height + Me.txtTitle.height + Me.height - Me.InsideHeight
  'If Me.txtTitle.text = "IF " Then Stop
  Do Until Me.InsideHeight >= Me.txtTask.height + Me.txtTitle.height
    Me.height = CInt(Me.height + 1)
  Loop
  
  Me.txtBg.height = Me.txtTask.height '+ 3
  txtTask.top = txtBg.top
  
  Me.txtTaskNumber.top = Me.txtBg.top + (Me.txtBg.height - Me.txtTaskNumber.height) / 2
  Me.txtTaskNumber.left = (Me.txtBg.left + (Me.txtBg.width - Me.txtTaskNumber.width) / 2) - 3
  Me.txtTask.Font.size = 12

  'If Me.txtTitle.text = "IF " Then Stop

hint
' check to find the right cell to display
  Me.lblImageContainer.top = Me.txtBg.top + Me.txtBg.height - 1
  Me.lblImageContainer.width = Me.InsideWidth + 2
  
  On Error Resume Next
  Me.lblImageContainer.height = Me.InsideHeight - Me.lblImageContainer.top
  On Error GoTo 0
  Me.imgHide.top = Me.lblImageContainer.top + 3
  Me.imgHide.left = Me.lblImageContainer.width - Me.imgHide.width - 5
  Me.imgShow.visible = False
  If txtTask.left + txtTask.width < Me.InsideWidth Then
    txtTask.width = Me.InsideWidth - txtTask.left
  End If
  txtTask.SelStart = 1
  txtTask.SelLength = Len(txtTask.text)
  txtTask.SelLength = 0
  txtTask.SelStart = Len(txtTask.text)
  
  
  'debug.print Me.txtTaskNumber.top
  
End Sub
Sub hint()
  #If officeApplication = 1 Or officeApplication = 3 Then
    If Not initializing Then showHint Me, tasks
  #ElseIf officeApplication = 2 Then
    If Not initializing Then presentTaskData Me, tasks, bleft, btop
  #End If
End Sub
Private Function makeTable(tableString As String, fra As Object) As Object
  Dim table() As tableCell
  Dim r As Long
  Dim c As Long
  Dim d As Long
  Dim rows As Variant
  Dim cols As Variant
  Dim params As Variant
  Dim param As Variant
  Dim x As Integer
  Dim y As Integer
  Dim colCount As Long
  Dim rowCount As Long
  Dim maxColCount As Long
  Dim pos As Integer
  Dim endPos As Integer
  Dim rowHeight As Single
  Dim colWidths() As Single
  Dim colStarts() As Single
  Dim fontSize As Integer
  Dim cumulativeWidth As Single
  Dim tb As Object
  Dim maxCellHeight As Single
  fontSize = 8
  
  Do Until fra.Controls.count = 0
    fra.Controls.Remove 0
  Loop

  
  rows = Split(Replace(Replace(Replace(tableString, "<table>", ""), "</table>", ""), "</tr>", ""), "<tr>")
  rowHeight = 15
  'Count rows and Columns so we can redim the table array
  For r = 1 To UBound(rows)
     Cells = Split(Replace(rows(r), "</td>", ""), "<td")
     colCount = 0
     For c = 1 To UBound(Cells)
        params = Trim(Mid(Cells(c), 1, InStr(1, Cells(c), ">") - 1))
        'condense dobule spaces
        Do While InStr(1, params, "  ") > 0
          params = Replace(params, "  ", " ")
        Loop
        
        If Len(params) > 0 Then
          params = Split(params, " ")
          
          ' process the parameters
          For x = 0 To UBound(params)
            param = Split(params(x), "=")
            Select Case LCase(param(0))
              Case "rowspan": colCount = colCount + CInt(param(1)) - 1
            End Select
          Next
        End If
        colCount = colCount + 1
     Next
     If colCount > maxColCount Then maxColCount = colCount
     rowCount = rowCount + 1
  Next
  
  ReDim table(rowCount, colCount)
  ReDim colWidths(colCount)
  ReDim colStarts(colCount)
  
  
  For r = 1 To rowCount
    For c = 1 To colCount
      'defaults
      table(r, c).valign = "top"
      table(r, c).textAlign = 1
      table(r, c).backColor = 16777215
    Next
  Next
  
  
  ' table array as been allocated, now fill it with information
    'Count rows and Columns so we can redim the table array
    
  Set tb = fra.Controls.Add("Forms.TextBox.1", "txt_" & r & "_" & d, True)
  tb.fontSize = fontSize
  For r = 1 To rowCount
     Cells = Split(Replace(rows(r), "</td>", ""), "<td")
     For c = 1 To UBound(Cells)
        params = Trim(Mid(Cells(c), 1, InStr(1, Cells(c), ">") - 1))
        'condense dobule spaces
        Do While InStr(1, params, "  ") > 0
          params = Replace(params, "  ", " ")
        Loop
        
        If Len(params) > 0 Then
          params = Split(params, " ")
          ' process the parameters
          For x = 0 To UBound(params)
            param = Split(params(x), "=")
            Select Case LCase(param(0))
              Case "align": Select Case LCase(param(1))
                              Case "center": table(r, c).textAlign = 2
                              Case "right": table(r, c).textAlign = 3
                              Case Else: table(r, c).textAlign = 1
                            End Select
              Case "valign": table(r, c).valign = param(1)
              Case "rowspan": table(r, c).rowSpan = param(1)
              Case "colspan": table(r, c).colSpan = param(1)
              Case "bgcolor": param(1) = Replace(param(1), "#", ""): table(r, c).backColor = CLng("&H" & Right(param(1), 2) & Mid(param(1), 3, 2) & Mid(param(1), 1, 2))
            End Select
          Next
        End If
            table(r, c).text = Trim(Mid(Cells(c), InStr(1, Cells(c), ">") + 1))
            
           ' process expected tags
           ' check for bold
           If InStr(1, table(r, c).text, "<b>") > 0 Then
             table(r, c).bold = True
             table(r, c).text = Replace(table(r, c).text, "<b>", "")
             table(r, c).text = Replace(table(r, c).text, "</b>", "")
           End If
           
           ' check for color
           pos = InStr(1, table(r, c).text, "<font color=")
           If pos > 0 Then
             endPos = InStr(pos, table(r, c).text, ">")
             param = Mid(table(r, c).text, pos + 13, (endPos - (pos + 13)))
             table(r, c).fontColor = CLng("&H" & Right(param, 2) & Mid(param, 3, 2) & Mid(param, 1, 2))
             table(r, c).text = Mid(table(r, c).text, endPos + 1)
             table(r, c).text = Replace(table(r, c).text, "</font>", "")
           End If
             
           ' find cell text width
           tb.AutoSize = True
           pos = InStr(1, table(r, c).text, "&nbsp;")
           tb.Font.bold = table(r, c).bold
           tb.top = 10000
           If pos > 0 Then
             tb.IntegralHeight = False
             tb.text = Mid(table(r, c).text, 1, pos - 1)
             tb.AutoSize = False
             tb.text = Replace(table(r, c).text, "&nbsp;", " ")
             tb.multiline = True
             fitTextBoxVertically tb
             tb.multiline = False
             table(r, c).multiline = True
           Else
             tb.text = table(r, c).text
             tb.AutoSize = False
           End If
           table(r, c).height = tb.height
           
           
           table(r, c).width = tb.width
           ' this block adjusts for the colspan on a row, disabled to try another approach
           'If table(r, c).colSpan > 0 Then
           '  d = d + table(r, c).colSpan - 1
           'End If
      
     Next
  Next
  
  
  ' initialize spans
  For r = 1 To rowCount
    For c = 1 To colCount
    
      If table(r, c).colSpan = 0 Then table(r, c).colSpan = 1
      If table(r, c).rowSpan = 0 Then table(r, c).rowSpan = 1
    Next
  Next
  
  ' figure merges
  For r = 1 To rowCount
    For c = 1 To colCount
      If table(r, c).colSpan > 1 Or table(r, c).rowSpan > 1 Then
        For x = r To r + table(r, c).rowSpan - 1
          For y = c To c + table(r, c).colSpan - 1
            If Not (x = r And y = c) Then
              table(x, y).rowSpan = 0
              table(x, y).colSpan = 0
            End If
          Next
        Next
      End If
    Next
  Next
  
  

  'move cell data to accomodate spans
  For r = 1 To rowCount
    For c = 1 To colCount
      If table(r, c).colSpan = 0 Then
        ' move elemets of this row to the right by one
        For x = c To colCount - c
          table(r, x + 1).bold = table(r, x).bold
          table(r, x + 1).italic = table(r, x).italic
          table(r, x + 1).backColor = table(r, x).backColor
          table(r, x + 1).fontColor = table(r, x).fontColor
          table(r, x + 1).textAlign = table(r, x).textAlign
          table(r, x + 1).valign = table(r, x).valign
          table(r, x + 1).width = table(r, x).width
          table(r, x + 1).text = table(r, x).text
        Next
      End If
    Next
  Next
  
  fra.Controls.Remove 0
  
  ' calculate the column widths from non merged cells
  For c = 1 To colCount
    For r = 1 To rowCount
  ''debug.print table(r, c).colSpan, "initial width", r, c, table(r, c).width
      If table(r, c).colSpan = 1 Then
        If colWidths(c) < table(r, c).width Then colWidths(c) = table(r, c).width
      End If
    Next
  Next
  
For c = 1 To colCount
  ''debug.print "first col width " & c & "=" & colWidths(c)
Next
  
  ' Adjust widths for merged cells
  For r = 1 To rowCount
    maxCellHeight = 0
    For c = 1 To colCount
'      table(r, c).top = (r - 1) * (rowHeight)
      If table(r, c).height > maxCellHeight Then maxCellHeight = table(r, c).height
      If table(r, c).colSpan > 1 Then
        cumulativeWidth = 0
        For x = c To c + table(r, c).colSpan - 1
          cumulativeWidth = cumulativeWidth + colWidths(x)
        Next
        
        If table(r, c).width > cumulativeWidth Then
          'adjust the appropriate column widths colums
          cumulativeWidth = (table(r, c).width - cumulativeWidth) / table(r, c).colSpan
 '         'debug.print "cum=" & cumulativeWidth
          For x = c To c + table(r, c).colSpan - 1
            colWidths(x) = colWidths(x) + cumulativeWidth
          Next
        End If
      End If
''debug.print "second col width " & c & "=" & colWidths(c)
    
    Next
 '   Stop
    For c = 1 To colCount
      table(r, c).height = maxCellHeight
      If r = 1 Then
        table(r, c).top = 0
      Else
        table(r, c).top = table(r - 1, c).top + table(r - 1, c).height - 1
      End If
    Next
    ' set the row tops

  Next
  
  'set column starting postions
  cumulativeWidth = 0
  For c = 1 To colCount
    colStarts(c) = cumulativeWidth
    cumulativeWidth = cumulativeWidth + colWidths(c)
   ' 'debug.print colStarts(c)
  Next
  
  'make the textboxes
  For r = 1 To rowCount 'To 1 Step -1
    For c = 1 To colCount 'To 1 Step -1
      If table(r, c).colSpan > 0 Then
        Set table(r, c).textBox = fra.Controls.Add("Forms.TextBox.1", "txt_" & r & "_" & c, True)
        table(r, c).textBox.IntegralHeight = False
        table(r, c).textBox.SpecialEffect = 0
        table(r, c).textBox.BorderStyle = 1
        table(r, c).textBox.BorderColor = 0
        table(r, c).textBox.Font.size = 8
        table(r, c).textBox.width = colWidths(c) + 1
        table(r, c).textBox.left = colStarts(c)
        table(r, c).textBox.height = table(r, c).height
        table(r, c).textBox.top = table(r, c).top
        table(r, c).textBox.text = Replace(table(r, c).text, "&nbsp;", " ")
        table(r, c).textBox.textAlign = table(r, c).textAlign
        table(r, c).textBox.backColor = table(r, c).backColor
        table(r, c).textBox.ForeColor = table(r, c).fontColor
        table(r, c).textBox.Font.bold = table(r, c).bold
        table(r, c).textBox.multiline = table(r, c).multiline
      
        If InStr(1, table(r, c).textBox.text, vbNewLine) > 0 Then table(r, c).textBox.multiline = True
      End If
      If table(r, c).colSpan > 1 Then
        table(r, c).textBox.width = colStarts(c + table(r, c).colSpan - 1) + colWidths(c + table(r, c).colSpan - 1) - table(r, c).textBox.left + 1
        table(r, c).textBox.ZOrder 0
      End If
      If table(r, c).rowSpan > 1 Then
        table(r, c).textBox.height = table(r, c).rowSpan * rowHeight + 1
        If table(r, c).valign = "middle" Then
          Set tb = fra.Controls.Add("Forms.Label.1", "lbl_" & r & "_" & c, True)
          tb.top = table(r, c).textBox.top
          tb.left = table(r, c).textBox.left
          tb.height = table(r, c).textBox.height
          tb.width = table(r, c).textBox.width
          tb.backColor = table(r, c).textBox.backColor
          tb.BorderStyle = 1
          tb.BorderColor = 0
          table(r, c).textBox.BorderStyle = 0
          table(r, c).textBox.top = table(r, c).textBox.top + ((table(r, c).textBox.height - rowHeight) / 2)
          table(r, c).textBox.left = table(r, c).textBox.left + 2
          table(r, c).textBox.width = table(r, c).textBox.width - 4
          table(r, c).textBox.height = rowHeight
          tb.ZOrder 0
          table(r, c).textBox.ZOrder 0
        Else
          table(r, c).textBox.ZOrder 0
        End If
        
      End If
    Next
  Next
  fra.height = table(rowCount, 1).top + table(rowCount, 1).height
  fra.width = colWidths(colCount) + colStarts(colCount) + 2
  fra.SpecialEffect = 0
  fra.visible = True
  fra.backColor = 16777215

End Function

Sub fitTextBoxVertically(tb As Object)
Dim lines As Integer
Dim sbLines As Integer
Dim tbLength As Long
tb.height = 28
tb.SetFocus
tb.SelStart = Len(tb.text)
tbLength = Len(tb.text)
Do
  tb.SetFocus
  tb.ScrollBars = 0
  DoEvents
  lines = tb.CurLine
  
  tb.ScrollBars = 2
  DoEvents
  sbLines = tb.CurLine
  
  ''debug.print lines, sbLines
  If sbLines <> lines Then Exit Do
  tb.text = tb.text & " ~"
Loop


Do
  tb.ScrollBars = 0
  tb.SelStart = Len(tb.text)
  DoEvents
  lines = tb.CurLine
  
  tb.ScrollBars = 2
  tb.SelStart = Len(tb.text)
  DoEvents
  sbLines = tb.CurLine
  
  ''debug.print lines, sbLines
  If sbLines = lines Then Exit Do
  tb.height = tb.height + 10
Loop

'tb.top = 50

Do    ' shrink down excess
  tb.ScrollBars = 0
  tb.SelStart = Len(tb.text)
  DoEvents
  lines = tb.CurLine
  
  tb.ScrollBars = 2
  tb.SelStart = Len(tb.text)
  DoEvents
  sbLines = tb.CurLine
  
  ''debug.print lines, sbLines
  If sbLines > lines Then Exit Do
  tb.height = tb.height - 2

Loop

tb.height = tb.height + 3
tb.ScrollBars = 0
tb.text = Mid(tb.text, 1, tbLength)


End Sub


Function cellCount(a As Variant)
' this is the cells of an HTML table row
Dim temp As Integer
Dim text As String
Dim x As Integer
Dim pos As Integer
For x = 1 To UBound(a)
  pos = InStr(1, a(x), "colspan=")
  If pos > 0 Then
    text = Replace(a(x), ">", " ")
    temp = temp + CInt(Mid(text, pos + 8, InStr(pos, text, " ") - (pos + 8)))
  Else
    temp = temp + 1
  End If
Next


cellCount = temp
End Function
Sub fillImage(exhibit As String)
  Dim i As Object
  Dim c As Object

  On Error GoTo endsub
    Load frmImages
  On Error Resume Next

  For Each c In frmImages.Controls
    If c.Tag = exhibit Then
      Set i = c
      Exit For
    End If
  Next

  If i Is Nothing Then Exit Sub
  
  ' we have found the image
  imgImage.Picture = i.Picture

endsub:
End Sub
'  txtTaskNumber.Height = Me.InsideHeight - txtTitle.Height - spnResize.Height
'  txtPoints.Height = txtTaskNumber.Height



Private Sub spnResize_Change()
  Me.width = spnResize.value
  showData
End Sub




Private Sub UserForm_Resize()
txtTitle.width = Me.InsideWidth
spnAdvance.left = Me.InsideWidth - spnAdvance.width - 2
chkComplete.left = spnAdvance.left - 17
Me.txtTitle.width = chkComplete.left - txtTitle.left
  If txtTask.left + txtTask.width < Me.InsideWidth Then
    txtTask.width = Me.InsideWidth - txtTask.left
    Me.lblImageContainer.width = Me.InsideWidth
  End If

End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
   frmTaskMemory = Me.top & Chr(30) & Me.left & Chr(30) & Me.height & Chr(30) & Me.width & Chr(30) & spnAdvance.value & Chr(30) & spnResize.value
End Sub


Private Sub UserForm_Activate()
        Dim data As Variant
     If Not beenActivated Then
       beenActivated = True
       
       #If officeApplication = 4 Then ' access
          ' in access the count is from upper left of screen, not applicaiton window.
          ' decided it was better to let the task guide open in center rather than try to place in upper right
       
       #Else ' word powerpoint excel
         If Len(frmTaskMemory) > 0 Then
            data = Split(frmTaskMemory, Chr(30))
            Me.top = data(0)
            Me.left = data(1)
            
         Else
           Me.top = ActiveWindow.top + 45
           Me.left = ActiveWindow.left + ActiveWindow.width - Me.InsideWidth - 20
         End If
         Me.top = Me.top + 1
       #End If
       
    
    End If
  
  If initializing Then
        Me.spnAdvance.SetFocus
        If Len(frmTaskMemory) > 0 Then
          data = Split(frmTaskMemory, Chr(30))
          Me.top = data(0)
          Me.left = data(1)
            Me.height = data(2)
            Me.width = data(3)
            Me.txtTask.width = Me.InsideWidth - Me.txtTask.left
            Me.txtTask.height = Me.InsideHeight - Me.txtTask.top
            spnAdvance.value = data(4)
            Me.spnResize.value = data(5)
        End If
  End If
  
  
  hideTaskBox
  initializing = False
  showData
  hint
    txtTask.width = Me.InsideWidth - txtTask.left
End Sub





Attribute VB_Name = "instruction"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public id As String
Private localText As String
Private localTextcolor As Long
Private localDataChanged As Boolean

Public Property Get text() As String
text = localText
End Property

Public Property Let text(theData As String)
  localText = theData
  DataChanged = True
End Property

Public Property Get textcolor() As Long
  textcolor = localTextcolor
End Property

Public Property Let textcolor(theData As Long)
  localTextcolor = theData
  DataChanged = True
End Property

Public Property Get DataChanged() As Boolean
DataChanged = localDataChanged
End Property

Public Property Let DataChanged(theData As Boolean)
  localDataChanged = theData
End Property

Sub setProperty(propertyName As String, value As Variant)
  Select Case LCase(propertyName)
    Case "id": id = value
    Case "text": localText = value
    Case "textcolor": localTextcolor = value
'    Case "": local = value
  End Select
  localDataChanged = True
End Sub




Attribute VB_Name = "jsonParser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Const INVALID_JSON      As Long = 1
Const INVALID_OBJECT    As Long = 2
Const INVALID_ARRAY     As Long = 3
Const INVALID_BOOLEAN   As Long = 4
Const INVALID_NULL      As Long = 5
Const INVALID_KEY       As Long = 6

Private Sub Class_Initialize()

End Sub

Private Sub Class_Terminate()

End Sub

'
'   parse string and create JSON object (Dictionary or Collection in VB)
'
Public Function parse(ByRef str As String) As Object

    Dim index As Long
    index = 1
    
    On Error Resume Next

    Call skipChar(str, index)
    Select Case Mid(str, index, 1)
    Case "{"
            Set parse = parseObject(str, index)
    Case "["
        Set parse = parseArray(str, index)
    End Select

End Function

'
'   parse collection of key/value (Dictionary in VB)
'
Private Function parseObject(ByRef str As String, ByRef index As Long) As Object

    Set parseObject = New Dictionary
    
    ' "{"
    Call skipChar(str, index)
    If Mid(str, index, 1) <> "{" Then Err.Raise vbObjectError + INVALID_OBJECT, Description:="char " & index & " : " & Mid(str, index)
    index = index + 1
    
    Do
    
        Call skipChar(str, index)
        If "}" = Mid(str, index, 1) Then
            index = index + 1
            Exit Do
        ElseIf "," = Mid(str, index, 1) Then
            index = index + 1
            Call skipChar(str, index)
        End If
        
        Dim key As String
        
        ' add key/value pair
        parseObject.Add key:=parseKey(str, index), item:=parseValue(str, index)
        
    Loop

End Function

'
'   parse list (Collection in VB)
'
Private Function parseArray(ByRef str As String, ByRef index As Long) As Collection

    Set parseArray = New Collection
    
    ' "["
    Call skipChar(str, index)
    If Mid(str, index, 1) <> "[" Then Err.Raise vbObjectError + INVALID_ARRAY, Description:="char " & index & " : " + Mid(str, index)
    index = index + 1
    
    Do
        
        Call skipChar(str, index)
        If "]" = Mid(str, index, 1) Then
            index = index + 1
            Exit Do
        ElseIf "," = Mid(str, index, 1) Then
            index = index + 1
            Call skipChar(str, index)
        End If
        
        ' add value
        parseArray.Add parseValue(str, index)
        
    Loop

End Function

'
'   parse string / number / object / array / true / false / null
'
Private Function parseValue(ByRef str As String, ByRef index As Long)

    Call skipChar(str, index)
    
    Select Case Mid(str, index, 1)
    Case "{"
        Set parseValue = parseObject(str, index)
    Case "["
        Set parseValue = parseArray(str, index)
    Case """", "'"
        parseValue = parseString(str, index)
    Case "t", "f"
        parseValue = parseBoolean(str, index)
    Case "n"
        parseValue = parseNull(str, index)
    Case Else
        parseValue = parseNumber(str, index)
    End Select

End Function

'
'   parse string
'
Private Function parseString(ByRef str As String, ByRef index As Long) As String

    Dim quote   As String
    Dim char    As String
    Dim code    As String
    
    Call skipChar(str, index)
    quote = Mid(str, index, 1)
    index = index + 1
    Do While index > 0 And index <= Len(str)
        char = Mid(str, index, 1)
        Select Case (char)
        Case "\"
            index = index + 1
            char = Mid(str, index, 1)
            Select Case (char)
            Case """", "\\", "/"
                parseString = parseString & char
                index = index + 1
            Case "b"
                parseString = parseString & vbBack
                index = index + 1
            Case "f"
                parseString = parseString & vbFormFeed
                index = index + 1
            Case "n"
                'parseString = parseString & vbNewLine changed by gove 8/6/15
                parseString = parseString & vbLf
                index = index + 1
            Case "r"
                parseString = parseString & vbCr
                index = index + 1
            Case "t"
                parseString = parseString & vbTab
                index = index + 1
            Case "u"
                index = index + 1
                code = Mid(str, index, 4)
                parseString = parseString & ChrW(val("&h" + code))
                index = index + 4
            End Select
        Case quote
            index = index + 1
            Exit Function
        Case Else
            parseString = parseString & char
            index = index + 1
        End Select
    Loop

End Function

'
'   parse number
'
Private Function parseNumber(ByRef str As String, ByRef index As Long)

    On Error GoTo numberParseError
    Dim value   As String
    Dim char    As String

    Call skipChar(str, index)
    Do While index > 0 And index <= Len(str)
        char = Mid(str, index, 1)
        If InStr("+-0123456789.eE", char) Then
            value = value & char
            index = index + 1
        Else
            If InStr(value, ".") Or InStr(value, "e") Or InStr(value, "E") Then
                parseNumber = CDbl(value)
            Else
                parseNumber = CInt(value)
            End If
            Exit Function
        End If
    Loop

numberParseError:
    If Err.number = 6 Then
        parseNumber = value
    Else
        Err.Raise Err.number, Err.source, Err.Description, Err.HelpFile, Err.HelpContext
    End If

End Function '
'   parse true / false
'
Private Function parseBoolean(ByRef str As String, ByRef index As Long) As Boolean

    Call skipChar(str, index)
    If Mid(str, index, 4) = "true" Then
        parseBoolean = True
        index = index + 4
    ElseIf Mid(str, index, 5) = "false" Then
        parseBoolean = False
        index = index + 5
    Else
        Err.Raise vbObjectError + INVALID_BOOLEAN, Description:="char " & index & " : " & Mid(str, index)
    End If

End Function

'
'   parse null
'
Private Function parseNull(ByRef str As String, ByRef index As Long)

    Call skipChar(str, index)
    If Mid(str, index, 4) = "null" Then
        parseNull = Null
        index = index + 4
    Else
        Err.Raise vbObjectError + INVALID_NULL, Description:="char " & index & " : " & Mid(str, index)
    End If

End Function

Private Function parseKey(ByRef str As String, ByRef index As Long) As String

    Dim dquote  As Boolean
    Dim squote  As Boolean
    Dim char    As String
    
    Call skipChar(str, index)
    Do While index > 0 And index <= Len(str)
        char = Mid(str, index, 1)
       Select Case (char)
        Case """"
            dquote = Not dquote
            index = index + 1
            If Not dquote Then
                Call skipChar(str, index)
                If Mid(str, index, 1) <> ":" Then
                    Err.Raise vbObjectError + INVALID_KEY, Description:="char " & index & " : " & parseKey
                End If
            End If
        Case "'"
            squote = Not squote
            index = index + 1
            If Not squote Then
                Call skipChar(str, index)
                If Mid(str, index, 1) <> ":" Then
                    Err.Raise vbObjectError + INVALID_KEY, Description:="char " & index & " : " & parseKey
                End If
            End If
        Case ":"
            If Not dquote And Not squote Then
                index = index + 1
                Exit Do
            End If
        Case Else
'            If InStr(vbCrLf & vbCr & vbLf & vbTab & " ", char) Then 'change by gove
            If InStr(vbCrLf & vbCr & vbLf & vbTab, char) Then
            Else
                parseKey = parseKey & char
            End If
            index = index + 1
        End Select
    Loop

End Function

'
'   skip special character
'
Private Sub skipChar(ByRef str As String, ByRef index As Long)

    While index > 0 And index <= Len(str) And InStr(vbCrLf & vbCr & vbLf & vbTab & " ", Mid(str, index, 1))
        index = index + 1
    Wend

End Sub

Public Function toString(ByRef obj As Variant) As String

    Select Case VarType(obj)
        Case vbNull
            toString = "null"
        Case vbDate
            toString = """" & CStr(obj) & """"
        Case vbString
            toString = """" & encode(obj) & """"
        Case vbObject
            Dim bFI, i
            bFI = True
            If TypeName(obj) = "Dictionary" Then
                toString = toString & "{"
                Dim Keys
                Keys = obj.Keys
                For i = 0 To obj.count - 1
                    If bFI Then bFI = False Else toString = toString & ","
                    Dim key As String
                    key = Keys(i)
                    toString = toString & """" & key & """:" & toString(obj.item(key))
                Next i
                toString = toString & "}"
            ElseIf TypeName(obj) = "Collection" Then
                toString = toString & "["
                Dim value
                For Each value In obj
                    If bFI Then bFI = False Else toString = toString & ","
                    toString = toString & toString(value)
                Next value
                toString = toString & "]"
            End If
        Case vbBoolean
            If obj Then toString = "true" Else toString = "false"
        Case vbVariant, vbArray, vbArray + vbVariant
            Dim sEB
            toString = multiArray(obj, 1, "", sEB)
        Case Else
            toString = Replace(obj, ",", ".")
    End Select

End Function

Private Function encode(str) As String
    
    Dim i, j, aL1, aL2, c, p

    aL1 = Array(&H22, &H5C, &H2F, &H8, &HC, &HA, &HD, &H9)
    aL2 = Array(&H22, &H5C, &H2F, &H62, &H66, &H6E, &H72, &H74)
    For i = 1 To Len(str)
        p = True
        c = Mid(str, i, 1)
        For j = 0 To 7
            If c = Chr(aL1(j)) Then
                encode = encode & "\" & Chr(aL2(j))
                p = False
                Exit For
            End If
        Next

        If p Then
            Dim a
            a = AscW(c)
            If a > 31 And a < 127 Then
                encode = encode & c
            ElseIf a > -1 Or a < 65535 Then
                encode = encode & "\u" & String(4 - Len(Hex(a)), "0") & Hex(a)
            End If
        End If
    Next
End Function

Private Function multiArray(aBD, iBC, sPS, ByRef sPT)   ' Array BoDy, Integer BaseCount, String PoSition
    Dim iDU, iDL, i ' Integer DimensionUBound, Integer DimensionLBound
    On Error Resume Next
    iDL = LBound(aBD, iBC)
    iDU = UBound(aBD, iBC)
    
    Dim sPB1, sPB2  ' String PointBuffer1, String PointBuffer2
    If Err.number = 9 Then
        sPB1 = sPT & sPS
        For i = 1 To Len(sPB1)
            If i <> 1 Then sPB2 = sPB2 & ","
            sPB2 = sPB2 & Mid(sPB1, i, 1)
        Next
'        multiArray = multiArray & toString(Eval("aBD(" & sPB2 & ")"))
        multiArray = multiArray & toString(aBD(sPB2))
    Else
        sPT = sPT & sPS
        multiArray = multiArray & "["
        For i = iDL To iDU
            multiArray = multiArray & multiArray(aBD, iBC + 1, i, sPT)
            If i < iDU Then multiArray = multiArray & ","
        Next
        multiArray = multiArray & "]"
        sPT = left(sPT, iBC - 2)
    End If
    Err.Clear
End Function



Attribute VB_Name = "modApplicationSpecific"
' this is for all code that executes differnetly depending on the application
' if a procedure exisits in one platform, it must be in all
Option Explicit

' officeApplication is set in Tools...project properties as follows:
' Word: officeApplication = 1
' Excel: officeApplication = 2
' PowerPoint: officeApplication = 3
' Access: officeApplication = 4


'=========================== Access versus the world =============================================
'--------------------------------------Access --------------------------------------
#If officeApplication = 4 Then ' access
' Access: returns the name of the kind of the document being worked on
Function docTypeName() As String
    docTypeName = "database"
End Function
' Access: returns localpath.  Access does not have a default file path property
Function defaultFilePath() As String
    defaultFilePath = localPath
End Function

'Access: To evaluate a string expression in Access we need to use eval
Function evaluate(data As String) As Variant
  evaluate = Eval(data)
End Function

'Access: returns a handle to the custom properties of thisDocument
' ultimate this needs to be removed once all call to customproperties have been isolated away from access
Function customProperties() As Object
  Set customProperties = DBEngine(0)(0).Properties ' not sure if this approach is wise  might be better to sore in a table
End Function

'Access: returns the path to a file that needs to be generated that holds the exports of the student's work
Function pathToAttachement() As String
  pathToAttachement = ""
End Function

' Access: : reads the json version of the assignment from the properties
Function getAssignmentFromProperties() As String
   getAssignmentFromProperties = getValue("assignment")
End Function

' Access:  takes a sql statement and returns a recordset
Function execute(query As String) As Recordset
  Set execute = currentdb.OpenRecordset(query)
End Function

' Access:  gets a single value from a query result
Function getDBValue(query As String, Optional col As Integer) As Variant
  Dim rs As Recordset
  Set rs = execute(query)
  If rs.EOF Then
    getDBValue = ""
  Else
    getDBValue = rs.Fields(col).value
  End If
  rs.Close
End Function

'Access:  builds a string of all the properties for use with initializing the assignment
Function getPropertyString() As String
'debug.print "pending:  getPropertyString"
' still need to convert this one over
'    Dim data As String
'    For x = getValue("firstUploadPropLine") + 1 To getValue("assignmentLine") - 1
'      data = data & Chr(31) & getNameByIndex(x) & Chr(30) & getValueByIndex(x)
'    Next
'    getPropertyString = data
End Function

'Access:  open a table.  Only used as a helper during development
Sub opentable(tableName As String)
  DoCmd.opentable tableName
End Sub

' Access: listalltables.  Only used as a helper during development
Sub listTables()
Dim td As TableDef
For Each td In currentdb.TableDefs
  'debug.print td.name, td.attributes
Next
End Sub

'Access: shows the properties in the default browser
Sub showProperties(Optional all As Boolean)
Dim title As String
Dim path As String
Dim ff As Integer
Dim rs As Recordset
Dim t1 As Integer
Dim t2 As Integer
Dim t3 As Integer
Dim t4 As Integer
Dim x As Long
Dim name As String

' unanalyzed properties
Dim y As Long
Dim lastEntryType As String
Dim logEntryNumber As Long
Dim data As Variant
Dim logTypeName As String




path = getTempPath
title = "Assignment Properties"
  
ff = FreeFile
  Open path & "properties.html" For Output As #ff
  Print #ff, "<!DOCTYPE html><html lang=""en - US""><head><style>body{font-family:Tahoma, Geneva, sans-serif; margin-left:100px; margin-right:100px; margin-top:50px;margin-bottom:50px;}</style>"
  Print #ff, "<title>" & title & "</title></head>" & style & "<body>"
      
      
Print #ff, "<br><a href=" & domain & pathForRecord & "/" & getValue("courseID") & "/" & getValue("activityID") & "/" & getValue("downloadedByUserID") & ">Show Student Submissions</a><br><table class=ee><tr><th class=ee colspan=3>Document Properties</th></tr><tr><th class=ee1>#</th><th class=ee1>Name</th><th class=ee1>Value</th></tr>"
If all Then
  Set rs = execute("select * from customProperties order by a")
Else
  Set rs = execute("select * from customProperties where a < " & getValue("assignmentLine") & " order by a")
End If
Do Until rs.EOF
x = x + 1
Print #ff, "<tr>"
      name = dcode(rs.Fields(1).value)
      Select Case name
        Case "firstUploadPropLine"
          t1 = dcode(rs.Fields(2).value)
        Case "firstDownloadPropLine"
          t2 = dcode(rs.Fields(2).value)
        Case "firstLocalLine"
          t3 = dcode(rs.Fields(2).value)
      End Select
      
      Select Case x
        Case t1: Print #ff, "<tr><th class=ee1 colspan=3>Upload  Properties</th></tr>"
        Case t2: Print #ff, "<tr><th class=ee1 colspan=3>Download  Properties</th></tr>"
        Case t3: Print #ff, "<tr><th class=ee1 colspan=3>Local  Properties</th></tr>"
      End Select
      
      Print #ff, "<td class=taskDone>" & x & "</td>"
      Print #ff, "<td class=ee>" & name & "</td>"
      Print #ff, "<td class=ee>" & dcode(rs.Fields(2).value) & "</td>"
      Print #ff, "</tr>"
  rs.MoveNext
Loop




Print #ff, "</body></html>"
Close #ff
followLink path & "properties.html"
'Kill path & "properties.html"
End Sub

'Access: returns the number of properties
Function propertyCount() As Long
propertyCount = getDBValue("select count (*) from customProperties")
End Function


'Access: analizes the log for a submission
Function logAnalysis(Optional junk As Byte) As String
Dim data As Variant
Dim logTypeName As String
Dim lastLogTime As Double
Dim elapsed As Double
Dim opensFound As Long
Dim subIDs As String
Dim lastOpenTime As Double

Dim sql As String
Dim rs As Recordset

sql = "SELECT a as step, dcode(c) as val FROM customProperties where a > (select dcode(c) from customproperties where a=1) order by a"
Set rs = execute(sql)
 
Do Until rs.EOF
         data = Split(rs.Fields(1).value, Chr(30))
         If UBound(data) > 0 Then
                
            If UBound(data) = 0 Then  ' we have a bad log entry.  Notify the log and move on
                data = Split("2|1|log enry failed", "|")
            End If
         
               If data(1) = 6 Then ' submission
                 subIDs = subIDs & "," & data(2)
               End If
               
              If data(1) = 2 Then
                  If LCase(data(2)) = "opened" Then
                    If opensFound > 0 Then
                      elapsed = elapsed + DateDiff("s", lastOpenTime, lastLogTime)
                    End If
                    opensFound = opensFound + 1
                    lastOpenTime = fixTime(data(0))
                  Else
                    lastLogTime = fixTime(data(0))
                  End If
              Else
                  lastLogTime = fixTime(data(0))
              End If
        End If ' ubound(data)>0
    rs.MoveNext
Loop
elapsed = elapsed + DateDiff("s", lastOpenTime, lastLogTime)
rs.Close
'debug.print "elapsed: " & elapsed
logAnalysis = CLng((elapsed / 60) * 100) / 100 & Chr(30) & Mid(subIDs, 2)

End Function



#Else ' word powerpoint excel
'--------------------------------------Word PowerPoint Excel --------------------------------------
' word powerpoint excel
'---------------------activates the assignment tab when the document is opened---------------------------
Sub rbx_onLoad(ribbon As IRibbonUI)
 ribbon.ActivateTab "tabAssignment"
End Sub


' Word, Excel, powerpoint.  Follows a link
'-------------------------- modules to make the task form for work both as an excel form and as objects on the sheet ----------------------
Public Sub showTaskBox(Optional junk As Boolean)
  frmTask.Show False

End Sub


Sub reShowForm(Optional junk As Boolean)
  hideTaskBox
  Unload frmTask
  frmTask.Show False
End Sub
Sub deleteTaskBox(Optional junk As Boolean)
On Error Resume Next
#If officeApplication = 2 Then ' excel
  ActiveSheet.Shapes("taskbox").Delete
#End If
End Sub
Sub hideTaskBox(Optional junk As Boolean)
On Error Resume Next
#If officeApplication = 2 Then ' excel
  ActiveSheet.Shapes("taskbox").visible = False
#End If
End Sub
Sub naught(Optional junk As Boolean)
  ' this is to prevent the incell taskbox from being selected
End Sub
Sub taskBoxMove(Optional junk As Boolean)
#If officeApplication = 2 Then ' excel
  ActiveSheet.Shapes("taskbox").Select
#End If
'MsgBox "To move the task decription box to the location of the active cell, click the circle at the left of the title bar. ", vbInformation, "Assignment Tasks"

End Sub


Public Sub nextTask(Optional junk As Boolean)
  If frmTask.spnAdvance.value < frmTask.spnAdvance.Max Then
  frmTask.spnAdvance.value = frmTask.spnAdvance.value + 1
  End If
End Sub

Public Sub PriorTask(Optional junk As Boolean)
  If frmTask.spnAdvance.value > 0 Then
  frmTask.spnAdvance.value = frmTask.spnAdvance.value - 1
  End If
End Sub



'-------------------------- End of task form modules --------------------------------------------------------------------------------------





' Word, Excel, powerpoint.  Follows a link
Sub followLink(link As String)

#If Mac Then
 'try to use mac script to prevent the warning message from showing; if it fails, use the old way with the warning.
 Dim s As String
 On Error GoTo macFailed
' s = "do shell script ""open " & MacScript("do shell script ""/usr/bin/osascript -e 'quoted form of POSIX path of \""" & ThisWorkbook.path & ":assignment.html\""'""") & """"
  s = "do shell script ""open " & MacScript("do shell script ""/usr/bin/osascript -e 'quoted form of POSIX path of \""" & link & "\""'""") & """"
  MacScript (s)
  Exit Sub
macFailed:
  activeDocument.FollowHyperlink link
  
#Else
  ' try to use a batch file to avoid the message that accompanies the follow a hyperlink to a local file, if not , do it the old way
Dim fnum As Integer
On Error GoTo winFailed
  ' check to see if the link is contains http, if so, just use followlink
    If InStr(1, link, "http", vbTextCompare) Then GoTo winFailed

    fnum = FreeFile()
    Open writePath & "\openAssignment.bat" For Output As fnum
    Print #fnum, "start " & quotedPath(link)
    Close #fnum
    Do Until Dir(writePath & "\openAssignment.bat") > ""
      sleep 0.5
       DoEvents
    Loop
    
    'debug.print writePath & "\openAssignment.bat"
    Shell writePath & "\openAssignment.bat", vbHide
On Error Resume Next
 '  Kill writepath & "\openAssignment.bat"
   Exit Sub
winFailed:
  activeDocument.FollowHyperlink link
#End If

End Sub




' Word, Excel, powerpoint. returns the default file path
Function defaultFilePath() As String
    defaultFilePath = Application.defaultFilePath
End Function

'Word, Excel, PowerPorint: returns a handle to the custom properties of thisDocument==========================
Function customProperties() As Office.DocumentProperties
  Set customProperties = officeDocument.CustomDocumentProperties
End Function

'Word, Excel, PowerPorint:  returns the path to the current document
Function pathToAttachement() As String
  pathToAttachement = fullPath
End Function

'Word, Excel, PowerPorint:  reads the assignment from the custom propeties
Function getAssignmentFromProperties() As String
  getAssignmentFromProperties = getValueByIndex(getValueByIndex(1))
End Function

'Word, Excel, PowerPorint:  builds a string of all the properties for use with initializing the assignment
Function getPropertyString() As String
    Dim data As String
    Dim x As Long
    
    For x = getValue("firstUploadPropLine") + 1 To getValue("assignmentLine") - 1
      data = data & Chr(31) & getNameByIndex(x) & Chr(30) & getValueByIndex(x)
    Next
    
    getPropertyString = data
End Function

'Word, Excel, PowerPorint:  shows the properties in the default browser  #word powerpoint excel
Sub showProperties(Optional all As Boolean)

Dim title As String
Dim x As Long
Dim y As Long
Dim t1 As Integer
Dim t2 As Integer
Dim t3 As Integer
Dim t4 As Integer
Dim ff As Integer
Dim lastEntryType As String

Dim logEntryNumber As Long
Dim props As Office.DocumentProperties
Dim name As String
Dim data As Variant
Dim logTypeName As String
Dim lastLine As Long
Set props = customProperties
Dim path As String
path = getTempPath

title = "Assignment Properties"
  
ff = FreeFile
  Open path & "properties.html" For Output As #ff
  Print #ff, "<!DOCTYPE html><html lang=""en - US""><head><style>body{font-family:Tahoma, Geneva, sans-serif; margin-left:100px; margin-right:100px; margin-top:50px;margin-bottom:50px;}</style>"
  Print #ff, "<title>" & title & "</title></head>" & style & "<body>"
      
      
Print #ff, "<br><table class=ee><tr><th class=ee colspan=3>Document Properties</th></tr><tr><th class=ee1>#</th><th class=ee1>Name</th><th class=ee1>Value</th></tr>"

If all Then
  lastLine = CDbl(getValueByIndex(1))
Else
  lastLine = CDbl(getValueByIndex(1)) - 1
End If

For x = 1 To lastLine
Print #ff, "<tr>"
      name = getNameByIndex(x)
      Select Case name
        Case "firstUploadPropLine"
          t1 = getValueByIndex(x)
        Case "firstDownloadPropLine"
          t2 = getValueByIndex(x)
        Case "firstLocalLine"
          t3 = getValueByIndex(x)
      End Select
      
      Select Case x
        Case t1: Print #ff, "<tr><th class=ee1 colspan=3>Upload  Properties</th></tr>"
        Case t2: Print #ff, "<tr><th class=ee1 colspan=3>Download  Properties</th></tr>"
        Case t3: Print #ff, "<tr><th class=ee1 colspan=3>Local  Properties</th></tr>"
      End Select
      
      Print #ff, "<td class=taskDone>" & x & "</td>"
      Print #ff, "<td class=ee>" & name & "</td>"
      Print #ff, "<td class=ee>" & getValueByIndex(x) & "</td>"
      Print #ff, "</tr>"
Next

Print #ff, "</body></html>"
Close #ff
followLink path & "properties.html"
'Kill path & "properties.html"
End Sub

'Word, Excel, PowerPorint:  returns the number of properties
Function propertyCount() As Long
  propertyCount = customProperties.count
End Function

'Word, Excel, PowerPorint:  analizes the log for a submission
Function logAnalysis(Optional junk As Byte) As String
Dim props As Office.DocumentProperties
Dim name As String
Dim data As Variant
Dim logTypeName As String
Dim lastLogTime As Double
Dim lastOpenTime As Double
Dim elapsed As Double
Dim opensFound As Long
Dim subIDs As String
Set props = customProperties
Dim x As Long

For x = CDbl(getValueByIndex(2)) To props.count
  name = getName(x)
  If Right(name, 8) = "LogEntry" Then
    If getPriorIndex(x) = 0 Then
         data = Split(getValueByIndex(x), Chr(30))
            
            If UBound(data) = 0 Then  ' we have a bad log entry.  Notify the log and move on
              data = Split("2|1|log enry failed", "|")
            End If
         
         If data(1) = 6 Then ' submission
           subIDs = subIDs & "," & data(2)
         End If
         
        If data(1) = 2 Then
            If LCase(data(2)) = "opened" Then
              If opensFound > 0 Then
                elapsed = elapsed + DateDiff("s", lastOpenTime, lastLogTime)
              End If
              opensFound = opensFound + 1
              lastOpenTime = fixTime(data(0))
            Else
              lastLogTime = fixTime(data(0))
            End If
        Else
            lastLogTime = fixTime(data(0))
        End If

     End If
  End If
Next
elapsed = elapsed + DateDiff("s", lastOpenTime, lastLogTime)
If elapsed < 0 Then elapsed = -1
logAnalysis = CLng((elapsed / 60) * 100) / 100 & Chr(30) & Mid(subIDs, 2)

End Function
#End If
'=========================== End of Access versus the world =============================================





'=========================== Individual Apps=============================================
'--------------------------------------Word --------------------------------------
#If officeApplication = 1 Then


' Word: returns the name of the kind of the document being worked on
Function docTypeName() As String
    docTypeName = "document"
End Function


'Word: Shows assignment Tools form
Sub assignment_tools()
  frmRibbon.Show False
End Sub



'Word: Code that runs after the the submission form is closed
Function afterCloseSubmit()

End Function
'Word: Code that runs after the upload as completed or failed
Function postUploadCode(Message As String)
  Select Case Message
    Case "success"
    Case "failure"
  End Select
End Function
'Word: Code that runs at the start of each of each grading session
Function preprechecks()
  setDocument ' sets the default document for grading to be thisDocument.  if another is desired, it must be set as a preProc
#If Mac Then
  On Error Resume Next
  resetChartList ' this is to reset the home-grown chart structure for grading charts on mac
  On Error GoTo 0
#End If
End Function

'Word: Code that runs just prior to scoring
Function preScore()
  setDocument ' sets the default document for grading to be thisDocument.  if another is desired, it must be set as a preProc
End Function
'Word: Code that runs just after the document is graderd
Function postScore()
End Function

'Word: brings a student's work from a different file into this one
Function importWork(Optional importProperties As Boolean, Optional f As frmSubmit)
  Stop
End Function

'Word: returns a handle to the  document containing the code
Function officeDocument() As document
  Set officeDocument = ThisDocument
End Function

'Word: returns a string that indicates the version of the operating sytem being run
Function operatingSystem() As String
  operatingSystem = Application.System.operatingSystem & " " & Application.System.version
End Function
'Word: Save the document and return path
Function saveAttachmentForUpload() As String
  Dim oldPath As String
  Dim temp As String
  oldPath = fullPath
  temp = left(oldPath, Len(oldPath) - 5) & "_Upload" & Right(oldPath, 5) ' save with a differnt name to get around file permission problem
  ThisDocument.SaveAs temp
  ThisDocument.SaveAs oldPath
  On Error Resume Next
  Kill temp
  On Error GoTo 0
  saveAttachmentForUpload = oldPath
End Function

'Word: Exports a model from antother document asssignment
Sub ExportModelFromAnotherDocument(path As String)
  MsgBox "Not Yet Implimented"
End Sub

'Word: puts the tools specific to word in the administrator options combo box
Sub loadApplicationSpecificTools(f As frmSubmit)
End Sub

'Word: executes a word specific tool that has been loaded by loadApplicationSpecificTools
Function runApplicationSpecificTool(f As frmSubmit) As Boolean
  runApplicationSpecificTool = True
  Select Case f.cboTool.value
'    Case "Show Accountability Flags": show_Accountability_flags f
'    Case "Hide Accountability Flags": hide_Accountability_flags f
'    Case "Open Accountability Report": showAccountabilityInBrowser f
    Case Else: runApplicationSpecificTool = False
  End Select
End Function


'-------------------------------------- Excel --------------------------------------
#ElseIf officeApplication = 2 Then  'Procedures for Excel

' Excel: returns the name of the kind of the document being worked on
Function docTypeName() As String
    docTypeName = "workbook"
End Function


'Excel: Shows assignment Tools form
Sub assignment_tools()
  frmRibbon.Show False
End Sub



'Excel: Code that runs after the the submission form is closed
Function afterCloseSubmit()
  Dim prophylactic As String
  On Error Resume Next
  
  prophylactic = getValue("prophylactic")
  If prophylactic > "" And prophylactic <> "EMPTY" Then
    If getValue("submissionID") <> "EMPTY" Then
      Workbooks("status.xlsx").Close False
      If getValue("submissionEndTime") <> "EMPTY" Then officeDocument.Close True      ' the submission is complete, close the workbook
    End If
  End If
  
  On Error GoTo 0
  
  
  
End Function


'Excel: Code that runs after the upload as completed or failed
Function postUploadCode(Message As String)
  Select Case Message
    Case "success"
    Case "failure"
  End Select
  
  ' lock the workbook with the submission is if the assessment is configured for encryption after submission
  If LCase(getValue("encryptAfterSubmission")) = "true" Then
    ThisWorkbook.password = ncode(getValue("submissionID"))
    updateValue "prophylactic", ncode(getValue("submissionID"))
    'Debug.Print "password: " & ncode(getValue("submissionID"))
    ThisWorkbook.Save
  End If
 
End Function


'excel: Code that runs at the start of each of each grading session
Function preprechecks()
End Function




'Excel: Code that runs at the start of each of each grading session
Function preScore()
  ' cycle through the sheets to remove any leading or trailing spaces from sheet names
  Dim s As Object
  For Each s In ThisWorkbook.Sheets
    If s.name <> Trim(s.name) Then s.name = Trim(s.name)
  Next
  
End Function
'Excel: Code that runs just after the document is graderd
Function postScore()
End Function

'Excel: brings a student's work from a different file into this one
Function importWork(Optional importProperties As Boolean, Optional f As frmSubmit)
  Dim studentBookPath As String
  Dim wb As Workbook
  Dim s As Object
  Dim x As Long
  Dim d As Worksheet
  studentBookPath = chooseWorkFile(localPath())
  If studentBookPath = "" Then Exit Function
  
  Application.EnableEvents = False   'disable Events
  Set wb = Workbooks.Open(studentBookPath)
  Application.EnableEvents = True
  
  If importProperties Then
    Do Until customProperties.count = 0
      customProperties(1).Delete
    Loop
    For x = 1 To wb.CustomDocumentProperties.count
      customProperties.Add wb.CustomDocumentProperties(x).name, False, msoPropertyTypeString, wb.CustomDocumentProperties(x).value
    Next
  End If
  
  suspendlogging = True
  
  Set d = ThisWorkbook.Worksheets.Add
  d.name = "dummy sheet visible"
  Application.DisplayAlerts = False
  For Each s In ThisWorkbook.Sheets
    If LCase(s.name) <> "enable macros" And s.name <> "dummy sheet visible" Then
      s.Delete
    End If
  Next
  
  For Each s In wb.Sheets
    If LCase(s.name) <> "enable macros" Then
       s.Copy after:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.count)
    End If
  Next
  
  d.Delete
  wb.Close False
  suspendlogging = False
End Function
'Excel: returns a handle to the  document containing the code
Function officeDocument() As Workbook
  Set officeDocument = ThisWorkbook
End Function

'Excel: returns a string that indicates the version of the operating sytem being run
Function operatingSystem() As String
  operatingSystem = Application.operatingSystem
End Function

'Excel: Save the document and return path
Function saveAttachmentForUpload() As String
  Dim path As String
  Dim temp As String
  Dim makeLog As Boolean
  Dim logPath As String
  
  temp = getValue("prophylactic")
  makeLog = temp > "" And temp <> "EMPTY"
  
  ThisWorkbook.Save
  Application.DisplayAlerts = False
 If localPath = writePath Then
  ' we are on local file system
    If targetWB Is Nothing Then
      temp = writePath & pathSeparator & ThisWorkbook.name
    Else
      targetWB.Save
      temp = writePath & pathSeparator & targetWB.name
    End If
 Else
   'we are on onedrive, need to save a copy of the document at the write path
    If targetWB Is Nothing Then
      temp = writePath & pathSeparator & ThisWorkbook.name
        #If Mac Then
            path = fullPath
            ThisWorkbook.SaveAs temp, AccessMode:=3, ConflictResolution:=2
            ThisWorkbook.SaveAs path, AccessMode:=3, ConflictResolution:=2
        #Else
            ThisWorkbook.SaveCopyAs temp
        #End If
    Else
      temp = writePath & pathSeparator & targetWB.name
        #If Mac Then
            path = fullPath
            targetWB.SaveAs temp, AccessMode:=3, ConflictResolution:=2
            targetWB.SaveAs path, AccessMode:=3, ConflictResolution:=2
        #Else
            targetWB.SaveCopyAs temp
        #End If
    End If
   
 End If
  Application.DisplayAlerts = True
  If makeLog Then
    If targetWB Is Nothing Then
        logPath = saveLogFile(ThisWorkbook, writePath)
    Else
        logPath = saveLogFile(targetWB, writePath)
    End If
    temp = logPath & Chr(30) & temp
  End If
  saveAttachmentForUpload = temp
End Function
' excel: save the log for upload when encrypted
Function saveLogFile(wb As Workbook, path As String) As String
    Dim wblog As Workbook
    Dim x As Integer
    Dim da As Boolean
    Dim statusPath As String
    Dim searchResults As String
    
    da = Application.DisplayAlerts
    Application.DisplayAlerts = False
     statusPath = path & pathSeparator & "status.xlsx"
    
    On Error Resume Next
        searchResults = Dir(statusPath)
        Set wblog = Workbooks("status.xlsx")
    On Error GoTo 0
    
    If wblog Is Nothing Then
        If searchResults = "" Then
            Set wblog = Workbooks.Add
        Else
          Set wblog = Workbooks.Open(statusPath)
        End If
    End If
    
    wblog.Windows(1).visible = False
    
    Do Until wblog.CustomDocumentProperties.count = 0
       wblog.CustomDocumentProperties.item(1).Delete
    Loop
    
    
    For x = 1 To wb.CustomDocumentProperties.count
      wblog.CustomDocumentProperties.Add wb.CustomDocumentProperties(x).name, False, msoPropertyTypeString, wb.CustomDocumentProperties(x).value
    Next
    
    wblog.SaveAs statusPath
    saveLogFile = statusPath
    'wblog.Close False
    Application.DisplayAlerts = da
End Function


'Excel: Exports a model from antother workbook assignment
Sub ExportModelFromAnotherDocument(path As String)
Dim wb As Workbook
Set wb = Workbooks.Open(path)
Application.Run "'" & wb.name & "'!" & "saveJsonModel"
End Sub

'Excel: puts the tools specific to excel in the administrator options combo box
Sub loadApplicationSpecificTools(f As frmSubmit)
  f.cboTool.AddItem "Show Accountability Flags"
  f.cboTool.AddItem "Hide Accountability Flags"
  f.cboTool.AddItem "Open Accountability Report"
End Sub

'Excel: executes an excel specific tool that has been loaded by loadApplicationSpecificTools
Function runApplicationSpecificTool(f As frmSubmit) As Boolean
  runApplicationSpecificTool = True
  Select Case f.cboTool.value
    Case "Show Accountability Flags": show_Accountability_flags f
    Case "Hide Accountability Flags": hide_Accountability_flags f
    Case "Open Accountability Report": showAccountabilityInBrowser f
    Case Else: runApplicationSpecificTool = False
  End Select
End Function


' Excel" returns a reference to the active workbook
Function activeDocument() As Workbook
  ' not sure if this will work, just guessing
  Set activeDocument = ActiveWorkbook
End Function


'-------------------------------------- PowerPoint --------------------------------------------------------------------------------------------------------------------------------------
#ElseIf officeApplication = 3 Then  'Procedures for PowerPoint


' PowerPoint: returns the name of the kind of the document being worked on
Function docTypeName() As String
    docTypeName = "presentation"
End Function


'PowerPoint: Shows assignment Tools form
Sub assignment_tools()
  startMeUp
  frmRibbon.Show False
End Sub


'PowerPoint: Code that runs after the the submission form is closed
Function afterCloseSubmit()

End Function

'PowerPoint: Code that runs after the upload as completed or failed
Function postUploadCode(Message As String)
  Select Case Message
    Case "success"
    Case "failure"
  End Select
  ' not sure if show slides belongs in success or failure or neither
  showSlides
End Function

'PowerPoint: Code that runs at the start of each of each grading session
Function preprechecks()
End Function


'PowerPoint: Code that runs at the start of each of each grading session
Function preScore()
  
End Function
'PowerPoint: Code that runs just after the document is graderd
Function postScore()
End Function

'PowerPoint: brings a student's work from a different file into this one
Function importWork(Optional importProperties As Boolean, Optional f As frmSubmit)
  Stop
End Function

'PowerPoint:returns a handle to the  document containing the code
Function officeDocument() As Presentation
  Set officeDocument = activepresentation
End Function


'PowerPoint: returns a string that indicates the version of the operating sytem being run
Function operatingSystem() As String
  operatingSystem = Application.operatingSystem
End Function

'Powerpoint: Save the document and return path
Function saveAttachmentForUpload() As String
 activepresentation.Save
  saveAttachmentForUpload = fullPath()
End Function

'PowerPoint: Exports a model from antother Presentation asssignment
Sub ExportModelFromAnotherDocument(path As String)
  MsgBox "Not Yet Implimented"
End Sub

'PowerPoint: puts the tools specific to powerpoint in the administrator options combo box
Sub loadApplicationSpecificTools(f As frmSubmit)
  f.cboTool.AddItem "Show Accountability Flags"
  f.cboTool.AddItem "Hide Accountability Flags"
End Sub

'PowerPoint: executes a powerpoint specific tool that has been loaded by loadApplicationSpecificTools
Function runApplicationSpecificTool(f As frmSubmit) As Boolean
  runApplicationSpecificTool = True
  Select Case f.cboTool.value
    Case "Show Accountability Flags": show_Accountability_flags f
    Case "Hide Accountability Flags": hide_Accountability_flags f
'    Case "Open Accountability Report": showAccountabilityInBrowser f
    Case Else: runApplicationSpecificTool = False
  End Select
End Function

'PowerPoint: returns a reference to the active presentation
Function activeDocument() As Presentation
  ' not sure if this will work, just guessing
  Set activeDocument = activepresentation
End Function

'-------------------------------------- Access ----------------------------------------------------------------------------------------------------------------------------
#ElseIf officeApplication = 4 Then  'Procedures for Access


'Access: Shows assignment Tools form
Sub assignment_tools()
  frmRibbon.Show False
End Sub



'Access: Code that runs after the the submission form is closed
Function afterCloseSubmit()
  
End Function



'Access: Code that runs after the upload as completed or failed
Function postUploadCode(Message As String)
  Select Case Message
    Case "success"
    Case "failure"
  End Select
End Function

'Access: Code that runs at the start of each of each grading session
Function preprechecks()
End Function

'Access: Code that runs at the start of each of each grading session
Function preScore()
  closeAccessObjects
  resetInformationSchema
End Function
'Access: Code that runs just after the document is graderd
Function postScore()
  deleteGradingQueries
End Function

'Access: brings a student's work from a different file into this one
Function importWork(Optional importProperties As Boolean, Optional f As frmSubmit)
  Dim studentFilePath As String
  Dim studentDB As Database
  Dim app2 As New Access.Application
  Dim x As Long
  Dim data As Variant
  Dim rel As Object
  Dim rel2 As Object
  Dim fld As Object
  studentFilePath = chooseWorkFile(localPath())
  If studentFilePath = "" Then Exit Function
     f.update 5, "Opening Database"
  
 ' Set acc = CreateObject("Access.Application")
  app2.visible = True
  app2.OpenCurrentDatabase studentFilePath, False
  'Stop
      
    f.update 1, "Deleting Relationships"
    Do While currentdb.Relations.count > 0
      On Error Resume Next
        currentdb.Relations.Delete currentdb.Relations(0).name
       If Err.number <> 0 Then
         On Error GoTo 0
         sleep 1
         currentdb.Relations.Delete currentdb.Relations(0).name
       End If
       On Error GoTo 0
    Loop
    
      'copy Tables
      f.update 1, "Importing Tables"
      
      Dim o As Object
      For Each o In app2.currentdb.TableDefs
        If o.attributes = 0 Then
          If o.name = "customProperties" Then
            If importProperties Then importObject acTable, o.name, studentFilePath
          Else
            importObject acTable, o.name, studentFilePath
          End If
        End If
      Next
      
      f.update 1, "Importing Queries"
      For Each o In app2.currentdb.QueryDefs
         If left(o.name, 1) <> "~" Then importObject acQuery, o.name, studentFilePath
      Next
      
      f.update 1, "Importing Macros"
      For Each o In app2.CurrentProject.AllMacros
         importObject acMacro, o.name, studentFilePath
      Next
    
      f.update 1, "Importing Reports"
      For Each o In app2.CurrentProject.AllReports
         importObject acReport, o.name, studentFilePath
      Next
    
      f.update 1, "Importing Forms"
      For Each o In app2.CurrentProject.AllForms
         importObject acForm, o.name, studentFilePath
      Next
    
      
      f.update 1, "Importing relationships"
  
      For Each rel In app2.currentdb.Relations
        If Mid(rel.name, 1, 7) <> "MSysNav" Then ' skip the system relationships
          Set rel2 = currentdb.CreateRelation(name:=rel.name, table:=rel.table, foreignTable:=rel.foreignTable, attributes:=rel.attributes)
        
          For Each fld In rel.Fields
            rel2.Fields.Append rel2.CreateField(fld.name)
            rel2.Fields(fld.name).ForeignName = fld.ForeignName
            currentdb.Relations.Append rel2
          Next
        End If
      Next
      
      
      
      
      f.update 10, "Closing Database"
      
      app2.CloseCurrentDatabase
      app2.Application.Quit acQuitSaveNone
      Set app2 = Nothing
      
      

      
      
      f.update -100, "Import Complete"

  
  
End Function
'part of import work
Sub importObject(objectType As AcObjectType, objectName As String, filepath As String)
  'On Error Resume Next
  DoCmd.deleteObject objectType, objectName
  'On Error GoTo 0
  DoCmd.TransferDatabase acImport, "Microsoft Access", filepath, objectType, objectName, objectName, False, False

End Sub


'Access: returns a handle to the document containing the code
Function officeDocument() As CurrentProject
  Set officeDocument = CurrentProject
End Function


'Access: returns a string that indicates the version of the operating sytem being run
Function operatingSystem() As String
  operatingSystem = osCommand("ver")
End Function

'Access: Build and save the package that gets uploaded.  Returns the path to the file to upload
Function saveAttachmentForUpload() As String
  saveAttachmentForUpload = compressCurrentDatabase(Replace(filename, ".accdb", "_upload.accdb"))
End Function

'Access: Build and save the package that gets uploaded.  Returns the path to the file to upload
Function saveAttachmentForUpload2() As String ' old school.  this will put up warning messages for students
    Dim qdf As QueryDef
    Dim tdf As TableDef
    Dim obj As Object
    Dim destination As String
    
    
    destination = CurrentProject.path & pathSeparator & Replace(CurrentProject.name, ".accdb", "_upload.accdb")
    On Error Resume Next
      Kill destination
    On Error GoTo Error_Handler
    
    DBEngine.CreateDatabase destination, DB_LANG_GENERAL
    For Each obj In CurrentProject.AllForms
      If "frmSeer" <> obj.name Then
        DoCmd.TransferDatabase acExport, "Microsoft Access", destination, acForm, obj.name, obj.name, False
      End If
    Next obj
    
    For Each qdf In currentdb.QueryDefs
        If left(qdf.name, 1) <> "~" Then DoCmd.TransferDatabase acExport, "Microsoft Access", destination, acQuery, qdf.name, qdf.name, False
    Next qdf
    
    For Each obj In CurrentProject.AllReports
        DoCmd.TransferDatabase acExport, "Microsoft Access", destination, acReport, obj.name, obj.name, False
    Next obj

    For Each tdf In currentdb.TableDefs
        If left(tdf.name, 4) <> "MSys" Then
        
            DoCmd.TransferDatabase acExport, "Microsoft Access", destination, acTable, tdf.name, tdf.name, False
        End If
    Next tdf

      Dim app As New Access.Application
      Dim fld As Object
      Dim rel As Object
      Dim rel2 As Object
      
      app.OpenCurrentDatabase destination, False
      app.visible = True

      For Each rel In currentdb.Relations
        If Mid(rel.name, 1, 7) <> "MSysNav" Then ' skip the system relationships
          Set rel2 = app.currentdb.CreateRelation(name:=rel.name, table:=rel.table, foreignTable:=rel.foreignTable, attributes:=rel.attributes)
          For Each fld In rel.Fields
            rel2.Fields.Append rel2.CreateField(fld.name)
            rel2.Fields(fld.name).ForeignName = fld.ForeignName
            app.currentdb.Relations.Append rel2
          Next
        End If
      Next
      
      app.CloseCurrentDatabase
      app.Quit
    
    
    
 
Error_Handler_Exit:
    On Error Resume Next
    Set qdf = Nothing
    Set tdf = Nothing
    Set obj = Nothing
     saveAttachmentForUpload = destination
     
    Exit Function
 
Error_Handler:
    MsgBox "The following error has occured." & vbCrLf & vbCrLf & _
           "Error Number: " & Err.number & vbCrLf & _
           "Error Description: " & Err.Description, _
           vbCritical, "An Error has Occured!"
    Resume Error_Handler_Exit
  
 
End Function

'Access: Exports a model from antother database asssignment
Sub ExportModelFromAnotherDocument(path As String)
  MsgBox "Not Yet Implimented"
End Sub

'Access: puts the tools specific to access in the administrator options combo box
Sub loadApplicationSpecificTools(f As frmSubmit)
End Sub

'Access: executes an access specific tool that has been loaded by loadApplicationSpecificTools
Function runApplicationSpecificTool(f As frmSubmit) As Boolean
  runApplicationSpecificTool = True
  Select Case f.cboTool.value
'    Case "Show Accountability Flags": 'show_Accountability_flags f
'    Case "Hide Accountability Flags": 'hide_Accountability_flags f
'    Case "Open Accountability Report": 'showAccountabilityInBrowser f
    Case Else: runApplicationSpecificTool = False
  End Select
End Function


#End If





Attribute VB_Name = "modAssignmentSpecific"
' this module is for code that is very specific to a particular assignment,  It is not  archived to the code vault


Sub loadAssignmentSpecificTools(f As frmSubmit)
  'this proc is called by frmSubmit to build names of assignment-specific tools
  
  'f.cboTool.AddItem "Show Time"
 
End Sub
Function runAssignmentSpecificTool(f As frmSubmit) As Boolean
  runAssignmentSpecificTool = True
  Select Case f.cboTool.value
  '  Case "Show Time": show_time f
    Case Else: runAssignmentSpecificTool = False
  End Select
End Function


Sub assignmentSpecificCode(Optional junk As Boolean)

End Sub

Attribute VB_Name = "modCommon"
' This is for procedures that are common among differnt platforms

' this type is used for organizing tables in the task guide
Type tableCell
  textBox As Object
  top As Single
  left As Single
  height As Single
  width As Single
  rowSpan As Integer
  colSpan As Integer
  bold As Boolean
  italic As Boolean
  backColor As Long
  fontColor As Long
  textAlign As Byte
  valign As String
  text As String
  multiline As Boolean
End Type

' for hotkeys
Sub submitAssignment()
  xSubmit
End Sub
Sub viewReport()
      showAssignmentInBrowser True
End Sub
Sub showInstructions()
  xShowInBrowser
End Sub
Sub taskGuide()
      showTaskBox
End Sub

Function IsUserFormLoaded(ByVal UFName As String) As Boolean
    Dim UForm As Object
     
    IsUserFormLoaded = False
    For Each UForm In VBA.UserForms
        If UForm.name = UFName Then
            IsUserFormLoaded = True
            Exit For
        End If
    Next
End Function 'IsUserFormLoaded


Function IsEmailValid(strEmail) As Boolean
    Dim strArray As Variant
    Dim strItem As Variant
    Dim i As Long, c As String, blnIsItValid As Boolean
    blnIsItValid = True
     
    i = Len(strEmail) - Len(Replace(strEmail, "@", ""))
    If i <> 1 Then IsEmailValid = False: Exit Function
    ReDim strArray(1 To 2)
    strArray(1) = left(strEmail, InStr(1, strEmail, "@", 1) - 1)
    strArray(2) = Replace(Right(strEmail, Len(strEmail) - Len(strArray(1))), "@", "")
    For Each strItem In strArray
        If Len(strItem) <= 0 Then
            blnIsItValid = False
            IsEmailValid = blnIsItValid
            Exit Function
        End If
        For i = 1 To Len(strItem)
            c = LCase(Mid(strItem, i, 1))
            If InStr("abcdefghijklmnopqrstuvwxyz_-.", c) <= 0 And Not IsNumeric(c) Then
                blnIsItValid = False
                IsEmailValid = blnIsItValid
                Exit Function
            End If
        Next i
        If left(strItem, 1) = "." Or Right(strItem, 1) = "." Then
            blnIsItValid = False
            IsEmailValid = blnIsItValid
            Exit Function
        End If
    Next strItem
    If InStr(strArray(2), ".") <= 0 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
    i = Len(strArray(2)) - InStrRev(strArray(2), ".")
    If i < 2 Or i > 5 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
    If InStr(strEmail, "..") > 0 Then
        blnIsItValid = False
        IsEmailValid = blnIsItValid
        Exit Function
    End If
    IsEmailValid = blnIsItValid
End Function





Sub showAssignment(Optional showErrors As Boolean)

Dim a As assignment
Set a = loadassignment()
showAssignmentInWord , showErrors

End Sub



Function style() As String
  style = "<style>" & vbNewLine & _
  "h1.ee{color:#003399; text-align:left; border-bottom-style:solid; font-size:40px;}" & vbNewLine & _
  "h2.ee{color:#555555; text-align:left; border-bottom-style:solid;}" & vbNewLine & _
  "p.ee{ line-height:150%; font-size:20px;}" & vbNewLine & _
  "table.ee{border-collapse:collapse; border: 1px solid black; }" & vbNewLine & _
  "th.ee{padding:5px;border: 1px solid black;background-color:#003399; color:white; }" & vbNewLine & _
  "th.ee2{text-align:left; padding:5px;border: 0px solid black; background-color:#EEEEEE;color:#666666;font-weight:normal; }" & vbNewLine & _
  "th.ee1{padding:5px;border: 1px solid black;background-color:#AAAAAA; color:white; }" & vbNewLine & _
  "td.ee{padding:10px; border: 1px solid black;}" & vbNewLine & _
  "td.task{font-weight:bold; text-align:center;border: 1px solid black;}" & vbNewLine & _
  "td.points{ text-align:center;}" & vbNewLine & _
  "td.taskDone{font-weight:bold; text-align:center;background-color:#cccccc;padding:10px; border: 1px solid black;}" & vbNewLine & _
  ".eeerror{ color:#800000;margin-left: 10px;}" & vbNewLine & _
  ".comment{ color:#444444;margin-left: 10px;}" & vbNewLine & _
  "</style>"
End Function
Function buildAssignmentBody(a As assignment, Optional ShowScore As Boolean, Optional path As String) As String
  Dim body As String
  Dim s As taskSet
  Dim t As task
  Dim r As rule
  Dim i As instruction
  Dim p As fill
  Dim percent As Single
  Dim taskNo As Integer
  Dim stuentname As String
  Dim taksLink As String
  Dim lateBlock As String
  Dim lateDeduction As Variant
  Dim totalPoints As Single
  Dim percentscore As Single
  
  saveImages
  
  If ShowScore Then
    studentName = getValue("submissionStudentName")
    If studentName = "EMPTY" Then
      studentName = ""
    Else
      studentName = " (" & studentName & ")"
    End If
  End If
    
  
  body = style() & vbNewLine & _
  "<h1 class=ee>" & a.title & studentName & "</h1>" & vbNewLine & _
  "<p class=ee>This assignment has a total of " & a.pointsPossible & " points.</p>" & vbNewLine

  For Each i In a.instructions
    body = body & "<p class=ee>" & i.text & "</p>" & vbNewLine
  Next
  
  
  For Each s In a.taskSets
    If s.title <> "precheck" Then
      body = body & "<h2 class=ee>" & s.title & "</h2>" & vbNewLine & _
       "<p class=ee>" & s.text & "</p>" & vbNewLine & _
       "<table class=ee><table class=ee><tr><th class=ee>Task&nbsp;#</th><th class=ee>Points</th><th class=ee>Task Description</th></tr>" & vbNewLine
      taskNo = 0
      For Each t In s.tasks
        taskNo = taskNo + 1
        body = body & "<tr><td class=""task"
        If t.complete Then
          body = body & "Done"
        End If
        If ShowScore And t.xmlID > "" Then
          tasklink = "<a href=https://www.myeducator.com/reader/web/" & getValue("courseID") & "/" & t.xmlID & "/>" & taskNo & "<a>"
        Else
          tasklink = taskNo
        End If
        body = body & """>" & tasklink & "</td><td class=""ee points"">" & vbNewLine
        
        
      
        
        If ShowScore Then
          body = body & t.pointsEarned & "/" & t.pointsPossible
        Else
          body = body & t.pointsPossible
        End If
        
        
        body = body & "</td><td class=ee>" & vbNewLine & ConvertTextToHtml(t.text) & vbNewLine
          If t.exhibit > "" Then
            If InStr(1, t.exhibit, "</tr>") > 0 Then
              body = body & "<br><br><style> td.ee1{padding:2px; border: 1px solid black;} </style><center>" _
              & Replace(Replace(t.exhibit, "<table>", "<table class=ee>"), "<td", "<td class=ee1") & "</center>"
            Else
              If fileExists(path & t.exhibit) Then
                  body = body & "<br><center><img src=" & t.exhibit & "></center>"
              Else
                  body = body & "<br><center><img src=" & imageBase & LCase(a.platform) & "/" & t.exhibit & "></center>"
              End If
            End If
          End If

        
        If ShowScore Then
          For Each r In t.rules
            If Not Abs(r.correct) = 1 Then
             If r.points = 0 Then
               body = body & "<div class=comment>" & r.errorMessage
             Else
               body = body & "<div class=eeerror>[-" & forceRound(r.points - r.pointsEarned, 4) & "] " & r.errorMessage
             End If
              If r.messageAdendum > "" Then
                If r.errorMessage = "" Then
                  body = body & r.messageAdendum
                Else
                  If left(r.messageAdendum, 1) = "(" Or r.errorMessage = "" Then
                    body = body & " " & r.messageAdendum
                  Else
                    body = body & " (" & r.messageAdendum & ")"
                  End If
                End If
              End If
              body = body & "</div>" & vbNewLine
            End If
          Next
        End If
        body = body & "</td></tr>" & vbNewLine
      Next
      If a.taskSets.count > 1 Then
            body = body & "<tr><td class=ee>Total:</td><td class=""ee points"">" & vbNewLine
            If ShowScore Then
              If s.pointsPossible = 0 Then
                percent = 0
              Else
                percent = Round(100 * s.pointsEarned / s.pointsPossible, 1)
              End If
              body = body & forceRound(s.pointsEarned, 4) & "/" & forceRound(s.pointsPossible, 4) & vbNewLine & _
               "</td><td class=ee>" & vbNewLine & _
              "That's " & percent & " percent for this section" & vbNewLine
            Else
              body = body & s.pointsPossible & vbNewLine & "</td><td class=ee>" & vbNewLine
            End If
              body = body & "</td></tr>"
      End If ' more than one visible task set
      body = body & vbNewLine & "</table>" & vbNewLine
  End If ' precheck
Next


If ShowScore Then
  lateDeduction = getValue("lateDeduction")
  If IsNumeric(lateDeduction) Then
    If lateDeduction > 0 Then
      lateBlock = "<br><table class=ee><tr><th colspan=2 class=ee>Point Deductions</th></tr><tr><td class=ee>" & lateDeduction & "</td><td class=ee> Late Submission</td></tr></table>" & vbNewLine
    End If
  Else
    lateDeduction = 0
  End If
  If a.pointsEarned - lateDeduction < 0 Then
    totalPoints = 0
  Else
    totalPoints = a.pointsEarned - lateDeduction
  End If
  If a.pointsPossible > 0 Then
    percentscore = Round(100 * totalPoints / a.pointsPossible, 1)
  Else
    percentscore = 0
  End If
  body = body & lateBlock & "<br><table class=ee><tr><th colspan=2 class=ee>Assignment Grade</th></tr><tr><td class=ee>" & totalPoints & "/" & a.pointsPossible & "</td><td class=ee> That's " & percentscore & " percent for this Assignment</td></tr></table>" & vbNewLine
End If

buildAssignmentBody = body
End Function
Function forceRound(number As Double, digits As Byte) As Double
  Dim t As Long
  Dim divisor As Integer
  divisor = 1 & Replace(Space(digits), " ", "0")
  t = number * divisor
  forceRound = t / divisor

End Function

Sub saveImages(Optional junk As Boolean)
Dim i As Object

On Error GoTo endsub
Load frmImages
On Error GoTo 0

#If Mac Then
  ' have not figured out how to get the images for mac. savePicture is not available.
#Else
For Each i In frmImages.Controls
  If TypeName(i) = "Image" Then                    ' the control is an image
    If TypeName(i.Picture) <> "Nothing" Then       ' the control as a picture in it
      If Dir(getTempPath & i.Tag) = "" Then        ' the image file has not yet been created
        SavePicture i.Picture, getTempPath & i.Tag ' save the image to disk
      End If
    End If
  End If
Next
#End If

endsub:
End Sub




Sub showLogInBrowser(Optional junk As Boolean)
  showLog
End Sub




Sub showLog(Optional paramaterToHide As Boolean)

Dim title As String
Dim x As Long
Dim y As Long
Dim lastEntryType As String
Dim logEntryNumber As Long
Dim name As String
Dim data As Variant
Dim logTypeName As String
Dim path As String
Dim thisTime As Date
Dim lastTime As Date

path = getTempPath

title = "Log"
  
ff = FreeFile
  Open path & "log.html" For Output As #ff
  Print #ff, "<!DOCTYPE html><html lang="; en - US; "><head><style>body{font-family:Tahoma, Geneva, sans-serif; margin-left:100px; margin-right:100px; margin-top:50px;margin-bottom:50px;}</style>"
  Print #ff, "<title>" & title & "</title></head>" & style & "<body>"
 


#If officeApplication = 4 Then
' access
Dim rs As Recordset
Set rs = execute("select * from customProperties where a >= " & getValue("firstLogLine") & " order by a")
Do Until rs.EOF
name = dcode(rs.Fields("b").value)
logEntryNumber = CLng(left(name, Len(name) - 8)) + 1
data = Split(dcode(rs.Fields(2).value), Chr(30))
#Else
' word powerpoint excel
Dim props As Office.DocumentProperties
Set props = customProperties
For x = CDbl(getValueByIndex(2)) To props.count
  name = getName(x)
  If Right(name, 8) = "LogEntry" And getPriorIndex(x) = 0 Then
    logEntryNumber = CLng(left(name, Len(name) - 8)) + 1
    data = Split(getValueByIndex(x), Chr(30))
#End If

    If UBound(data) = 0 Then  ' we have a bad log entry.  Notify the log and move on
    data = Split("2|1|log enry failed", "|")
  End If
    
    If lastEntryType <> data(1) Then
        If lastEntryType > "" Then Print #ff, "</table>"
        Print #ff, "<br><table class=ee><tr><th class=ee";
      Select Case CInt(data(1))
         Case 1:  Print #ff, " colspan=5>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Description</th></tr><tr>"
         Case 2:  Print #ff, " colspan=5>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Name</th><th class=ee1>Value</th></tr><tr>"
         Case 3:  Print #ff, " unused"
         Case 4:  Print #ff, " colspan=5>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Description</th></tr><tr>"
         Case 5:  Print #ff, " colspan=8>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Worksheet</th><th class=ee1>Address</th><th class=ee1>Formula</th><th class=ee1>Value</th><th class=ee1>Step #</th></tr><tr>"
         Case 6:  Print #ff, " colspan=10>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>SubmissionID</th><th class=ee1>Email</th><th class=ee1>First Name</th><th class=ee1>Last Name</th><th class=ee1>User ID</th><th class=ee1>Clock Offset</th><th class=ee1>Path to Assignment Document</th></tr><tr>"
         Case 7:  Print #ff, " colspan=9>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Sheet Name</th><th class=ee1>Chart Name</th><th class=ee1>Chart Type</th><th class=ee1>Series 1</th><th class=ee1>Left</th><th class=ee1>Top</th></tr><tr>"
         Case 8:  Print #ff, " colspan=8>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>SheetName</th><th class=ee1>Row Fields</th><th class=ee1>Column Fields</th><th class=ee1>Data Fields</th><th class=ee1>Page Fields</th></tr><tr>"
         Case 9:  Print #ff, " colspan=4>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Task</th></tr><tr>"
         Case 10:  Print #ff, " colspan=7>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Table Name</th><th class=ee1>Time Created</th><th class=ee1>Last  Updated</th><th class=ee1>Record Count</th></tr><tr>"
         Case 11:  Print #ff, " colspan=7>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Object Type</th><th class=ee1>Name</th><th class=ee1>Time Created</th><th class=ee1>Last  Updated</th></tr><tr>"
         Case 12:  Print #ff, " colspan=7>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Object Type</th><th class=ee1>Name</th><th class=ee1>Time Created</th><th class=ee1>Last  Updated</th></tr><tr>"
         Case 13:  Print #ff, " colspan=6>" & logType(CInt(data(1))) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>Object Type</th><th class=ee1>Name</th><th class=ee1>Time Created</th></tr><tr>"
         Case Else:   Print #ff, " colspan=4>Unknown: " & data(1) & "</th></tr><tr><th class=ee1>#</th><th class=ee1>Time</th<th class=ee1>Elapsed</th>><th class=ee1>data</th></tr><tr>"
      End Select
    End If
      lastEntryType = data(1)
      thisTime = fixTime(data(0))
      Print #ff, "<td class=ee>" & logEntryNumber & "</td>"
      Print #ff, "<td class=ee>" & thisTime & "</td>"
      If CDbl(lastTime) = 0 Then
        ' first time using elapsed, must me first entry
          Print #ff, "<td class=ee>&nbsp;</td>"
      Else
          Print #ff, "<td class=ee>" & elapsed(lastTime, thisTime) & "</td>"
      End If
      lastTime = thisTime
      For y = 2 To UBound(data)
        Print #ff, "<td class=ee>" & data(y) & "</td>"
      Next
      
      Print #ff, "</tr>"
  
  
  #If officeApplication = 4 Then
' access
  rs.MoveNext
  Loop
#Else
' word powerpoint excel
  End If
  Next
#End If



Print #ff, "</tr>"
Print #ff, "</body></html>"
Close #ff
followLink path & "log.html"
End Sub
Function elapsed(time1 As Date, time2 As Date) As String
Dim s As Long
Dim m As Long
Dim h As Long
Dim d As Long

s = DateDiff("s", time1, time2)
m = s \ 60
s = s Mod 60
h = m \ 60
m = m Mod 60
d = h \ 24
h = h Mod 24

If d > 0 Then
  elapsed = d & ":" & Right("0" & h, 2) & ":" & Right("0" & m, 2) & ":" & Right("0" & s, 2)
ElseIf h > 0 Then
  elapsed = h & ":" & Right("0" & m, 2) & ":" & Right("0" & s, 2)
ElseIf m > 0 Then
  elapsed = m & ":" & Right("0" & s, 2)
Else
  elapsed = s
End If


End Function


' version of local log that is collapsable
Sub showLogIndex(Optional paramaterToHide As Boolean)
Dim logTypes As String
Dim title As String
Dim x As Long
Dim y As Long
Dim lastEntryType As String
Dim logEntryNumber As Long
Dim name As String
Dim data As Variant
Dim logTypeName As String
Dim path As String
Dim temp As String
Dim temp1 As String
path = getTempPath
Dim stepCount As Long
Dim thisTime As Date
Dim lastTime As Date

title = "Log"
logTypes = "|"
ff = FreeFile
  Open path & "log.html" For Output As #ff
  
 Print #ff, "<!DOCTYPE html><html lang=' en - US'><head><style>body{font-family:Tahoma, Geneva, sans-serif; margin-left:100px; margin-right:100px; margin-top:50px;margin-bottom:50px;}</style>"
 Print #ff, "<title>" & title & "</title>"
 Print #ff, "<script type='text/javascript' src='http://code.jquery.com/jquery-1.9.1.js'></script>"
 Print #ff, "<style type='text/css'> span.link:hover {color: red;}tr {display: table-row;} tr.log {display: none;}    </style>"
 Print #ff, "<script type='text/javascript'>//<![CDATA["
 Print #ff, "function showLog(ele,num){"
 Print #ff, "var id; if (num==0){id='.log'}else{id='.log.' + num}"
 Print #ff, "$(id).css( 'display', function(i,v){return ele.checked ? 'table-row':'none'});}"
 Print #ff, "$(window).load(function(){$('tr.header').click(function(){$(this).nextUntil('tr.header').css('display', function(i,v){return (this.style.display === 'table-row') ? 'none' : 'table-row'});});});//]]>"
 Print #ff, "</script>"
 Print #ff, "</head>" & style & "<body>"
 Print #ff, "<table class=ee><tr><td>Downloaded by</td><td><a href=""mailto:" & getValue("downloadedByEmail") & "?subject=MyEducator+Submission&body=" & Split(getValue("downloadedByName"))(0) & ":"">" & getValue("downloadedByName") & "</a></td></tr>"
 Print #ff, "<tr><td>Path to feedback</td><td>" & writePath & pathSeparator & "Assignment.html" & "</td></tr>"
 Print #ff, "<tr><td>Path to log</td><td>" & writePath & pathSeparator & "log.html" & "</td></tr>"
 Print #ff, "<tr><td>Accountability ID</td><td>" & hexColor2Dec(getValue("accountability")) & "</td></tr>"
 Print #ff, "<tr><td>Student submissions</td><td><a href=" & domain & pathForRecord & getValue("courseID") & "/" & getValue("activityID") & "/" & getValue("downloadedByUserID") & ">" & domain & pathForRecord & getValue("courseID") & "/" & getValue("activityID") & "/" & getValue("downloadedByUserID") & "</a></td></tr>"
 Print #ff, "</table><br>"
 Print #ff, "<table class=ee><tr><td colspan=10 id='controls'>controls</td></tr>"
                    


#If officeApplication = 4 Then
' access
Dim rs As Recordset
Set rs = execute("select * from customProperties where a >= " & getValue("firstLogLine") & " order by a")
Do Until rs.EOF
name = dcode(rs.Fields("b").value)
logEntryNumber = CLng(left(name, Len(name) - 8)) + 1
data = Split(dcode(rs.Fields(2).value), Chr(30))
#Else
' word powerpoint excel
Dim props As Office.DocumentProperties
Set props = customProperties
For x = CDbl(getValueByIndex(2)) To props.count
  name = getName(x)
  If Right(name, 8) = "LogEntry" Then
  If getPriorIndex(x) = 0 Then
    logEntryNumber = CLng(left(name, Len(name) - 8)) + 1
    data = Split(getValueByIndex(x), Chr(30))
#End If

  If UBound(data) = 0 Then  ' we have a bad log entry.  Notify the log and move on
    data = Split("2|1|log enry failed", "|")
  End If
  
    addValue logTypes, data(1)
    If lastEntryType <> data(1) Then
        'If lastEntryType > "" Then Print #ff, "</table>"
        Print #ff, Replace(temp, "(eeDataCount~)", stepCount)
        stepCount = 0
        temp = "<tr class='header'><th class=ee2>(eeDataCount~)</th><th class=ee2>" & thisTime & "</th><th class=ee2 colspan=8>" & logType(CInt(data(1))) & "</th></tr><tr class='log " & data(1) & "'><th class=ee1>#</th><th class=ee1>Time</th><th class=ee1>Elapsed</th><th class=ee1>"
      Select Case CInt(data(1))
         Case 1:  temp = temp & "Description</th></tr><tr class='log " & data(1) & "'>"
         Case 2:  temp = temp & "Name</th><th class=ee1>Value</th></tr><tr class='log " & data(1) & "'>"
         Case 3:  temp = temp & " unused"
         Case 4:  temp = temp & "Description</th></tr><tr class='log " & data(1) & "'>"
         Case 5:  temp = temp & "Worksheet</th><th class=ee1>Address</th><th class=ee1>Formula</th><th class=ee1>Value</th><th class=ee1>Step #</th></tr><tr class='log " & data(1) & "'>"
         Case 6:  temp = temp & "SubmissionID</th><th class=ee1>Email</th><th class=ee1>First Name</th><th class=ee1>Last Name</th><th class=ee1>User ID</th><th class=ee1>Clock Offset</th><th class=ee1>Path to Assignment Document</th></tr><tr class='log " & data(1) & "'>"
         Case 7:  temp = temp & "Sheet Name</th><th class=ee1>Chart Name</th><th class=ee1>Chart Type</th><th class=ee1>Series 1</th><th class=ee1>Left</th><th class=ee1>Top</th></tr><tr class='log " & data(1) & "'>"
         Case 8:  temp = temp & "SheetName</th><th class=ee1>Row Fields</th><th class=ee1>Column Fields</th><th class=ee1>Data Fields</th><th class=ee1>Page Fields</th></tr><tr class='log " & data(1) & "'>"
         Case 9:  temp = temp & "Task</th></tr><tr class='log " & data(1) & "'>"
         Case 10:  temp = temp & "Table Name</th><th class=ee1>Time Created</th><th class=ee1>Last  Updated</th><th class=ee1>Record Count</th></tr><tr class='log " & data(1) & "'>"
         Case 11:  temp = temp & "Object Type</th><th class=ee1>Name</th><th class=ee1>Time Created</th><th class=ee1>Last  Updated</th></tr><tr class='log " & data(1) & "'>"
         Case 12:  temp = temp & "Object Type</th><th class=ee1>Name</th><th class=ee1>Time Created</th><th class=ee1>Last  Updated</th></tr><tr class='log " & data(1) & "'>"
         Case 13:  temp = temp & "Object Type</th><th class=ee1>Name</th><th class=ee1>Time Created</th></tr><tr class='log " & data(1) & "'>"
         Case Else:   temp = temp & "data</th></tr><tr class='log " & data(1) & "'>"  ' unknown  don't ever expect this.
      End Select
    End If
    lastEntryType = data(1)
    thisTime = fixTime(data(0))
      temp1 = "<td class=ee>" & logEntryNumber & "</td>"
      temp1 = temp1 & "<td class=ee>" & thisTime & "</td>" ' time
      If lastTime = 0 Then
      temp1 = temp1 & "<td class=ee>&nbsp</td>" ' elapsed
      Else
      temp1 = temp1 & "<td class=ee>" & elapsed(lastTime, thisTime) & "</td>" ' elapsed
      End If
      lastTime = thisTime
      For y = 2 To UBound(data)
        temp1 = temp1 & "<td class=ee>" & data(y) & "</td>"
      Next
      
      temp = temp & temp1 & "</tr><tr class='log " & data(1) & "'>"
      stepCount = stepCount + 1
  
  #If officeApplication = 4 Then
' access
  rs.MoveNext
  Loop
#Else
' word powerpoint excel
    End If
  End If
  Next
#End If

        Print #ff, Replace(temp, "(eeDataCount~)", stepCount)

Print #ff, "</tr></table>"

' build the hide/show links
data = Split(logTypes, "|")
logTypes = "<form>"

For x = 1 To UBound(data) - 1
  logTypes = logTypes & "<input type='checkbox' onClick='showLog(this," & data(x) & ")'>" & logType((data(x))) & " &nbsp;&nbsp;&nbsp;"
Next

logTypes = left(logTypes, Len(logTypes) - 19) & "</form>"

'Print #ff, logTypes
Print #ff, "<script>document.getElementById('controls').innerHTML = """ & logTypes & """</script>"
Print #ff, "</body></html>"
Close #ff
If Not paramaterToHide Then
    followLink path & "log.html"
End If
End Sub

Sub addValue(ByRef list As String, ByVal value As String)
If InStr(1, list, "|" & value & "|") = 0 Then
  list = list & value & "|"
End If
End Sub






' used to correct a time recorded with a comma instead of a period
Function fixTime(data As Variant) As Date
  Dim x As Integer
  Dim badData As Variant
  Static decimalSeparator As String * 1
  
  If decimalSeparator = Chr(0) Then decimalSeparator = Mid(1 / 10, Len(CStr(1 / 10)) - 1, 1)
  
  On Error GoTo Hell
  fixTime = data
  Exit Function
Hell:
On Error GoTo 0

  badData = data
  For x = 1 To Len(badData)
    If Not IsNumeric(Mid(badData, x, 1)) Then
      Mid(badData, x, 1) = decimalSeparator
      Exit For
    End If
  Next
  fixTime = badData
End Function
Function commaToPeriod(data As Double) As String
  'Static decimalSeparator As String * 1
  
  'If decimalSeparator = Chr(0) Then decimalSeparator = Mid(1 / 10, 2, 1)
  
  'commaToPeriod = Replace(data, decimalSeparator, ".")
  commaToPeriod = left(data, 5) & "." & Mid(data, 7)
End Function
Sub showPropertiesInBrowser(Optional junk As Boolean)
  showProperties
End Sub




Sub showAssignmentInBrowser(Optional ShowScore As Boolean, Optional a As assignment, Optional suppressDisplay As Boolean)


'Dim a As assignment
Dim d As Object
Dim title As String
Dim row As Integer
Dim temp As String
Dim start As Long
Dim writtenFirstRule As Boolean
Dim path As String
Dim ScoreCode As String
Dim studentName As String ' used when showing from gradebook
path = getTempPath

If a Is Nothing Then
  Set a = loadassignment()
End If

'setCompleteForAssignment a  ' commented out on 8/3/15  seems to be old code referring to the igmodel sheet

title = "Assignment"
If ShowScore Then
  title = "Score"
  studentName = readStudentname
  If LCase(a.submissionType) = "practice" Then
    a.score
    ScoreCode = a.ScoreCode
  Else
    ScoreCode = getValue("scoreCode")
  End If
  If ScoreCode = "EMPTY" Then
    MsgBox "It appears that this assignment has not yet been submitted.  After you have completed your solution, you should submit it.  Then you will be able to view the ""Automatic Scoring Report"" "
    Exit Sub
  Else
    ' assignment has been submitted at least once
    If Not a.beenScored Then a.score ScoreCode
  End If
End If
  
  If studentName > "" Then studentName = " (" & studentName & ")"
  ff = FreeFile
  Open path & "assignment.html" For Output As #ff
  Print #ff, "<!DOCTYPE html><html lang="; en - US; "><head><style>body{font-family:Tahoma, Geneva, sans-serif; margin-left:100px; margin-right:100px; margin-top:50px;margin-bottom:50px;}</style>"
  Print #ff, "<title>" & title & "</title></head><body>"
Print #ff, buildAssignmentBody(a, ShowScore, path)
Print #ff, "</body></html>"
Close #ff
If Not suppressDisplay Then followLink path & "assignment.html"
End Sub

Function ConvertTextToHtml(theText As String) As String
Dim t As String
t = Replace(Replace(theText, vbCr, ""), vbLf, "<br>")
Do Until InStr(1, t, "  ") = 0
  t = Replace(t, "  ", "&nbsp;&nbsp;")
Loop
ConvertTextToHtml = t

End Function




Function parseJson(jsonText As String) As Collection
  Dim json As New Collection
  Dim inQuote As Boolean
  Dim onechar As String * 1
  Dim theKey As String
  Dim theVal As String
  Dim makingKey As Boolean
  Dim data As Variant
  Dim pair As Variant
  Dim theType As String * 1
  
  If Not (left(jsonText, 1) = "{" And Right(jsonText, 1) = "}") Then Exit Function
  
  
  makingKey = True
  Dim x As Long
  For x = 2 To Len(jsonText) - 1
    onechar = Mid(jsonText, x, 1)
    If onechar = """" Then
      inQuote = Not inQuote
    Else
      If Not inQuote Then
        Select Case onechar
          Case ":": Mid$(jsonText, x, 1) = Chr(1)
          Case ",": Mid$(jsonText, x, 1) = Chr(2)
        End Select
      End If
    End If
    
  Next
  data = Split(Mid(jsonText, 2, Len(jsonText) - 2), Chr(2))
  For x = 0 To UBound(data)
    pair = Split(data(x), Chr(1))
    pair(0) = Trim(pair(0))
    pair(1) = Trim(pair(1))
    If left(pair(1), 1) = """" Then
      pair(1) = Mid(pair(1), 2, Len(pair(1)) - 2)
      theType = "s"
    End If
    If left(pair(0), 1) = """" Then
      pair(0) = Mid(pair(0), 2, Len(pair(0)) - 2)
      theType = "n"
    End If
    json.Add Array(pair(0), pair(1), theType)
  Next
  
  
  Set parseJson = json


End Function

Function jsonValue(json As Collection, key As String) As Variant
  Dim x As Integer
  If json Is Nothing Then Exit Function
  For x = 1 To json.count
    If LCase(json(x)(0)) = LCase(key) Then
      jsonValue = Replace(json(x)(1), Chr(7), """")
      Exit Function
    End If
  Next


End Function
Function quotedPath(path As String) As String
  Dim data As Variant
  Dim temp As String
  Dim x As Integer
  data = Split(path, "\")
  For x = 0 To UBound(data)
    If InStr(1, data(x), " ") > 0 Then
      temp = temp & "\" & """" & data(x) & """"
    Else
      temp = temp & "\" & data(x)
    End If
  Next
  quotedPath = Mid(temp, 2)



End Function

Sub applicationRun(procName As String, Optional p As Variant)
  'p is an array that holds parameter values
  If Right(TypeName(p), 2) <> "()" Then
    Application.Run procName
  Else
  #If officeApplication = 1 Then ' not word--> becuase word for mac can't handle passing an argument to application.run
     MsgBox "Please contact the publisher and provide error code 622521.  This is an error in the configuration of a Microsoft Word assignment.", "Configuration Error"
  #Else
    Select Case UBound(p)
      Case 0: Application.Run procName, p(0)
      Case 1: Application.Run procName, p(0), p(1)
      Case 2: Application.Run procName, p(0), p(1), p(2)
      Case 3: Application.Run procName, p(0), p(1), p(2), p(3)
      Case 4: Application.Run procName, p(0), p(1), p(2), p(3), p(4)
      Case 5: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5)
      Case 6: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6)
      Case 7: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7)
      Case 8: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8)
      Case 9: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9)
      Case 10: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10)
      Case 11: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11)
      Case 12: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12)
      Case 13: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13)
      Case 14: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14)
      Case 15: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15)
      Case 16: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16)
      Case 17: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17)
      Case 18: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18)
      Case 19: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19)
      Case 20: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20)
      Case 21: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21)
      Case 22: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22)
      Case 23: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22), p(23)
      Case 24: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22), p(23), p(24)
      Case 25: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22), p(23), p(24), p(25)
      Case 26: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22), p(23), p(24), p(25), p(26)
      Case 27: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22), p(23), p(24), p(25), p(26), p(27)
      Case 28: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22), p(23), p(24), p(25), p(26), p(27), p(28)
      Case 29: Application.Run procName, p(0), p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8), p(9), p(10), p(11), p(12), p(13), p(14), p(15), p(16), p(17), p(18), p(19), p(20), p(21), p(22), p(23), p(24), p(25), p(26), p(27), p(28), p(29)
      Case Else: MsgBox "Too Many arguments sent to application.run method.  Maximum is 30."
    End Select
    #End If
  End If
End Sub

Public Function Power(ByVal number As Double, ByVal exponent As Double) As Double
  Power = number ^ exponent
End Function


' used to make a call from outside this workbook to save the json version of hte assignment specification
Sub saveJsonModel(Optional ByVal path As String, Optional ByVal a As assignment)
  Dim documentName As String
  Dim pos As Integer
  
  If a Is Nothing Then
   Set a = New assignment
   a.loadModel
  End If
  

  documentName = a.studentBookName
  pos = InStrRev(documentName, ".")
  If pos > 0 Then documentName = left(documentName, pos - 1)
  If path = "" Then
    path = writePath & pathSeparator & documentName & ".json"
  ElseIf Right(path, 1) = pathSeparator Then
   path = path & documentName & ".json"
  ElseIf LCase(Right(path, 5)) <> "'.json" Then
   path = path & pathSeparator & documentName & ".json"
  End If
  a.saveModel path
End Sub

Function loadassignment() As assignment
  Dim a As New assignment
  a.loadModel
  Set loadassignment = a
End Function

Sub importModelFromFile(Optional path As String)
  Dim a As New assignment
'  Dim json As String
  a.loadModelFromFile path
  'debug.print "Just imported, now trying to save"
  'Open path For Input As #1
 '   json = Input(LOF(1), 1)
'  Close #1
  a.saveModel , True
  
End Sub

Sub readAssignmentFromFile(Optional path As String)
  Dim a As New assignment
  a.loadModelFromFile path
  a.saveModel "KeyValue", True
End Sub

' picks a file that could contain student work
Function chooseWorkFile(Optional initPath As String) As String
      If initPath > "" Then
        Application.FileDialog(msoFileDialogFilePicker).InitialFileName = initPath
      Else
        Application.FileDialog(msoFileDialogFilePicker).InitialFileName = localPath
      End If

        Application.FileDialog(msoFileDialogFilePicker).InitialFileName = localPath & pathSeparator
      
        #If officeApplication = 1 Then 'Word
            Application.FileDialog(msoFileDialogFilePicker).Filters.Add "Word Documents", "*.docx", 1
        #ElseIf officeApplication = 2 Then 'Excel
            Application.FileDialog(msoFileDialogFilePicker).Filters.Add "Excel Workbooks", "*.xlsx; *.xlsm", 1
        #ElseIf officeApplication = 3 Then 'PowerPoint
            Application.FileDialog(msoFileDialogFilePicker).Filters.Add "PowerPoint Presentations", "*.pptx", 1
        #ElseIf officeApplication = 4 Then 'Access
            Application.FileDialog(msoFileDialogFilePicker).Filters.Add "Access Databases", "*.accdb", 1
        #End If
      
      Application.FileDialog(msoFileDialogFilePicker).Filters.Add "All Files", "*.*"
      

    If Application.FileDialog(msoFileDialogFilePicker).Show Then
      chooseWorkFile = Application.FileDialog(msoFileDialogFilePicker).SelectedItems(1)
    End If

End Function

' a hook to allow automated grading.
Sub autograde(Optional ByVal studEmail As String, Optional profEmail As String, Optional profPW As String, Optional scoreFileName As String, Optional ByVal filepath As String, Optional ByVal recordPrefix As String)
    ' Params
    ' studEmail: 'local' for a local grade without displaying
                          'show' for a localgrade that displays the scoresheet
                          'email of the student to record the grade.  Used to give credit to a student for the assignment,  If blank, will use the email address used to download the file
    ' profEmail: email to authenticate the request at MyEducator, if blank will use the email in myEducator.pkg
    ' profPW: password to authenticate the request at MyEducator,, if blank will use the password in myEducator.pkg
    ' filePath: path to file to record results.  If blank, will use the current workbook's path  & "\autograde.txt" which is a tab delimited file
    ' recordPrefix: data to place at the beginning of the row that records the results of the grading
    ' scoreFileName: used to remame assignment.txt so multiple feedback files can be generated.  if no path included, will use current path
    
    Dim pointsPossible As Single
    Dim pointsEarned As Single
    Dim data As Variant
    Dim ff As Integer
    Dim scoreFilePath As String
    Dim heading As String
    
    If filepath = "" Then
      filepath = localPath & "\autograde.txt"
    ElseIf InStr(1, filepath, "\") = 0 Then
      filepath = localPath & "\" & filepath
    End If
      
    
    If scoreFileName = "" Then
      scoreFilePath = localPath & "\assignment.html"
    ElseIf InStr(1, scoreFileName, "\") = 0 Then
      scoreFilePath = localPath & "\" & scoreFileName
    Else
      scoreFilePath = scoreFileName
    End If
    
    If recordPrefix > "" Then
      data = Split(recordPrefix, vbTab)
      For ff = 1 To UBound(data) + 1
        heading = heading & "Field" & ff & vbTab
      Next
      recordPrefix = recordPrefix & vbTab
    End If
    
    Load frmSubmit
    On Error Resume Next
    officeDocument.Activate
    On Error GoTo 0
    
    If studEmail = "show" Then
      studEmail = "local"
    Else
      frmSubmit.silentSubmit = True
    End If
    
    If studEmail = "local" Then
      frmSubmit.optNoRecord.value = True
    Else
      frmSubmit.optRecordFor.value = True
        If studEmail = "" Then
          studEmail = getValue("downloadedByEmail")
        Else
          frmSubmit.txtProxyEmail = studEmail
        End If
    End If
    frmSubmit.publicLabel = "process admin options"  '
    If profEmail > "" Then frmSubmit.txtEmail = profEmail
    If profPW > "" Then frmSubmit.txtPassword = profPW
    
    
    If Dir(localPath & "\assignment.html") > "" Then Kill localPath & "\assignment.html"
    
    xSubmit ' grade the workbook
    
    If Dir(localPath & "\assignment.html") > "" Then ' the grader produced output
     pointsEarned = frmSubmit.a.pointsEarned
     pointsPossible = frmSubmit.a.pointsPossible
     If scoreFileName > "" Then FileCopy localPath & "\assignment.html", scoreFilePath ' rename the output
    End If
    
    ff = FreeFile
    If Dir(filepath) = "" Then 'the file does note exist, open for output and add the header
      Open filepath For Output As #ff
      Print #ff, heading & "File" & vbTab & "submit_email" & vbTab & "download_email" & vbTab & "score_sheet_path" & vbTab & "points_possible" & vbTab & "points_earned"
    Else
      Open filepath For Append As #ff
    End If
      Print #ff, recordPrefix & filename & vbTab & studEmail & vbTab & getValue("downloadedByEmail") & vbTab & scoreFilePath & vbTab & pointsPossible & vbTab & pointsEarned
    Close #ff
    
    Unload frmSubmit
End Sub


Sub showModel(Optional paramToMakeHidden As Boolean)
      Dim app As New Excel.Application
      app.visible = True
      exportModel loadassignment, app.Workbooks.Add.Worksheets(1).Range("a1")
      
End Sub
Function submissionDetail(authEmail As String, password As String, submissionID As String, courseID As String) As Dictionary

  Dim a As New agent
  Dim parameters As String
  Dim json As New jsonParser

  a.clearFormData
  
  a.AddFormData "submissionid", submissionID
  a.AddFormData "auth_email", authEmail
  a.AddFormData "auth_password", password
  a.AddFormData "courseid", courseID

  If a.postdoc(domain & pathForSubmissionDetails) Then
    Set submissionDetail = json.parse(a.text)
  Else
     Set submissionDetail = json.parse("[]")
  End If


End Function

Function dataKeyPath()
#If Mac Then
  If Environ$("HOME") > "" Then
    dataKeyPath = Environ$("HOME") & pathSeparator & dataKeyFile
  Else
    dataKeyPath = dataKeyPath
  End If
#Else
  If Environ$("USERPROFILE") > "" Then
    dataKeyPath = Environ$("USERPROFILE") & pathSeparator & dataKeyFile
  Else
    dataKeyPath = dataKeyPath
  End If
#End If

End Function
Sub buildLanguage(Optional junk As Boolean)
  ' makes the set of alternate terms to serach for in serachNoErr
  If terms Is Nothing Then
    Set terms = New Dictionary
    addTerm Array("sum", "suma", "somme")
    addTerm Array("sumproduct", "sumaproducto")
    addTerm Array("alpha", "beta", "delta")
'  Stop
  End If
End Sub
  Sub addTerm(termList)
      Dim x As Integer
      terms.Add CStr(termList(0)), New Collection
      For x = 1 To UBound(termList)
        terms.Items(terms.count - 1).Add termList(x)
      Next
  End Sub

Attribute VB_Name = "modGlobals"
#If officeApplication = 1 Then 'Word
  Public Const appColor As Long = 10114859
  Public Const officeApplication = 1
#ElseIf officeApplication = 2 Then 'Excel
  Public Const appColor As Long = 4616993
  Public Const officeApplication = 2
#ElseIf officeApplication = 3 Then 'PowerPoint
  Public Const appColor As Long = 2508754
  Public Const officeApplication = 3
#ElseIf officeApplication = 4 Then 'Access
  Public Const appColor As Long = 3812516
  Public Const officeApplication = 4
#End If

Public Const dataKeyFile = "myEducator.pkg"

Public Const imageBase = "http://myeducator.com/content/g/files/atlas/"
Public Const domain = "https://www.myeducator.com"
Public Const pathForRecord = "/instructor/activity_submissions/"
Public Const pathForAuthentication = "/api/ee_activity_get_rules/"
Public Const pathForSubmissionDetails = "/api/activity_submission_detail/"
Public Const pathForSubmission = "/api/ee_activity_post_answers/"
Public Const pathForActivityDetails = "/api/ee_activity_details/"
Public Const pathForUpload = "/api/ee_activity_upload_file/"
Public Const pathForFailedUpload = "/custom/prometheus_upload/"
Public Const pathForColorToUsers = "/api/ee_color_to_users/"
Public Const publisherName = "MyEducator"
Public Const white As Long = 16777215
Public Const pathForActivity = "/course/activity/"
Public globalWritePath As String
Public Const assignmentName = "assignment.json"

Public suspendlogging As Boolean
Public serverXMLHTTPfailed As Boolean

Public frmTaskMemory As String

'Public ApplicationRunWordParams As String



Public terms As Dictionary ' used to allow searchNoErr to automatically handle multiple languages
Attribute VB_Name = "modKeyValue"
' this module holds the procedures needed for storing and recalling variables

Option Explicit
 Const alphabet6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789-abcdefghijklmnopqrstuvwxyz"
Dim searchForDeleted As Boolean

' builds a new key-value pair in the custom properties of the the current office document
Sub putNewValue(name As String, value As String)
#If officeApplication = 4 Then
  On Error Resume Next
  currentdb.execute ("insert into customProperties(b,c) values('" & ncode(name) & "','" & ncode(value) & "')")
  If Err.number <> 0 Then
    currentdb.execute ("insert into customProperties(b,c) values('" & ncode(name) & "','" & ncode("Insert Failed") & "')")
  End If
  On Error GoTo 0
#Else
  searchForDeleted = True
 ' If name = "assignment" Then Stop
  addNewValue ncode(name), ncode(value)
 #End If
End Sub
' recalls a value stored in the custom properties of the current office document
Function getValue(name As String, Optional nameEncoded As Boolean = True) As String
#If officeApplication = 4 Then
    If Not nameEncoded Then
      getValue = dcode(getDBValue("select c from customProperties where b = '" & name & "'"))
    Else
      getValue = dcode(getDBValue("select c from customProperties where b = '" & ncode(name) & "'"))
    End If
#Else
  Dim x As Long
    If nameEncoded Then
          getValue = getValueByIndex(getIndexFromName(name))
    Else
      For x = 1 To customProperties.count
        If name = customProperties(x).name Then
          getValue = customProperties(x)
          Exit For
        End If
      Next
    End If
 #End If
End Function

Sub updateValue(name As String, value As String)
  #If officeApplication = 4 Then
  currentdb.execute ("update customProperties set c='" & ncode(value) & "' where dcode(b)='" & name & "'")
  'CurrentDb.execute ("update customProperties set c='" & ncode(value) & "' where b='" & ncode(name) & "'")
#Else
Dim EntriesNeeded As Long
  Dim entriesAvailable As Long
  Dim encodedLength As Long
  Dim index As Long
  
  encodedLength = Len(ncode(value))
  EntriesNeeded = (encodedLength \ 255) + ((encodedLength Mod 255) = 0) + 1
  entriesAvailable = getEntriesUsed(name)
  If EntriesNeeded = 0 Then EntriesNeeded = 1
  
  
  If EntriesNeeded = entriesAvailable Then
    ' write over existing data
    index = getIndexFromName(name)
    If index = 0 Then
      Err.Raise 1003, "Update Value", "Key not found: " & name
    Else
      updateChain index, ncode(value)
    End If
  Else
    ' delete property and write again
    deleteKey name
    putNewValue name, value
  End If
  
  
 #End If
End Sub



Sub DeleteAllCustomProperties(Optional junk As Boolean)
#If officeApplication = 4 Then
  currentdb.execute ("drop table customProperties")
  currentdb.execute ("create table customProperties(a AUTOINCREMENT, b text(255), c memo)")
  Application.SetHiddenAttribute acTable, "customProperties", True
#Else
    Dim x As Long
    
    For x = customProperties.count To 1 Step -1
     customProperties(x).Delete
    Next
 #End If
End Sub

' prints all custom properties from the current office document
Sub printAllCustomProperties(Optional junk As Boolean)
#If officeApplication = 4 Then
    Dim rs As Recordset
    Dim name As String
    Set rs = execute("select * from customProperties")
    Do Until rs.EOF
       'debug.print "--------------------------------------------------------"
       'debug.print rs.Fields(0).name, dcode(rs.Fields(1).value) & ": " & dcode(rs.Fields(2).value)
      rs.MoveNext
    Loop
    
#Else
    Dim x As Long
    Dim name As String
    
    For x = 1 To customProperties.count
     'debug.print "--------------------------------------------------------"
     'debug.print x, getName(x) & ": " & dcode(Trim(customProperties(x).value))
    Next
 #End If

End Sub



' changes the value of an existing key-value pair in the custom properties of the the current office document


#If officeApplication = 4 Then
  ' procedures only needed by access for key value pairs




#Else
  'procedures need only by word, excel, powerpoint

' reports how many entries in the customProperties collection are used for this name-value pair
Function getEntriesUsed(name As String) As String
  Dim x As Long
  Dim counter As Long
  x = getIndexFromName(name)
  counter = 1
  Do Until Split(customProperties(x).name, ":")(1) = 0
    x = Split(customProperties(x).name, ":")(1)
    counter = counter + 1
  Loop
    
  getEntriesUsed = counter
    
End Function
'returns the index where the named key-value pair begins
Function getIndexFromName(name As String) As Long
  Dim x As Long
  Dim found As Boolean
  For x = 1 To customProperties.count
    If left(customProperties(x).name, 1) = "[" Then ' need to skip entries that start with "{" as they are marked as deleted
      If name = dcode(CStr(Split(Replace(Mid(customProperties(x).name, 2), "]", ":"), ":")(0))) Then
        found = True
        Exit For
      End If
    End If
  Next
  
  If found Then
    'now x references one of the properties
    Do Until getPriorIndex(x) = 0
      x = getPriorIndex(x)
    Loop
    getIndexFromName = x
  Else
    x = 0
  End If
End Function

' recalls a value stored in the custom properties of the current office document
Function getValueByIndex(index As Long) As String
  Dim x As Long
  
  If index = 0 Then Exit Function
  
  If left(customProperties(index).name, 1) = "[" Then
    ' find the start of a chained property in case we start in the middle
    x = index
    Do Until getPriorIndex(x) = 0
      x = getPriorIndex(x)
    Loop
      getValueByIndex = dcode(Trim(getRawValueByIndex(x)))
  Else
    getValueByIndex = customProperties(index).value
  End If
End Function

' gets the name of the poperty at a specified index from the custom properties of the current office document
Function getNameByIndex(index As Long) As String
  Dim x As Long
  
  If index = 0 Then Exit Function
  If left(customProperties(index).name, 1) = "[" Then
    getNameByIndex = dcode(CStr(Split(Mid(customProperties(index).name, 2), "]")(0)))
  Else
    getNameByIndex = customProperties(index).name
  End If

End Function

' returns the next index in a chain
Function getNextIndex(index As Long) As Long
  getNextIndex = Split(customProperties(index).name, ":")(1)
End Function
' returns the prior index in a chain
Function getPriorIndex(index As Long) As Long
  getPriorIndex = Split(Split(Replace(customProperties(index).name, "}", "]"), "]")(1), ":")(0)
End Function
' part of getValueByIndex. Assumes the values are encoded and that the property is a singleton or the start of a chain
Function getRawValueByIndex(index As Long) As String
  Dim nextIndex As Long
    nextIndex = getNextIndex(index)
    If nextIndex = 0 Then
      getRawValueByIndex = customProperties(index).value
    Else
      getRawValueByIndex = customProperties(index).value & getRawValueByIndex(nextIndex)
    End If
End Function

' marks a key-value pair as being deleted by changing the brackets to braces
Sub deleteKey(name As String)
  Dim index As Long
  index = getIndexFromName(name)
  
  Do
    On Error Resume Next
    customProperties(index).name = Replace(Replace(customProperties(index).name, "[", "{"), "]", "}")
    If Err.number <> 0 Then
      On Error GoTo 0
      customProperties(index).name = Replace(Replace(customProperties(index).name, "[", "{"), "]", "-" & index & "}")
    End If
    
    On Error GoTo 0
    index = Split(customProperties(index).name, ":")(1)
  Loop Until index = 0
  
End Sub

' part of updateValue. new value replaces old value in existing chain
Sub updateChain(index As Long, encodedValue As String)
  ' assumes that the chain being rewritten is the same size as is needed by new data
  Dim nextIndex As Long
  nextIndex = getNextIndex(index)
  If Len(encodedValue) > 255 Then
    customProperties(index).value = left(encodedValue, 255)
    updateChain nextIndex, Mid(encodedValue, 256)
  Else
    customProperties(index).value = encodedValue
  End If
End Sub
' retunrs the decoded key name from from an encoded key-value pair
Function getName(index As Long) As String
  If left(customProperties(index).name, 1) = "[" Then
    getName = dcode(Mid(Split(customProperties(index).name, "]")(0), 2))
  ElseIf left(customProperties(index).name, 1) = "{" Then
    getName = "{" & dcode(Mid(Split(customProperties(index).name, "}")(0), 2)) & "}"
  Else
    getName = customProperties(index).name
  End If
End Function




' part of putNewValue
Sub addNewValue(ByVal name As String, ByVal value As String)
  ' return value is the index number in properties collection where the value was placed.  It is used to control the recusive call
  Dim props As Office.DocumentProperties
  Dim index As Long
  Dim data As Variant
  Dim backLink As Long
  Set props = customProperties
  
Do

On Error Resume Next
  props.Add "{new property}0:0", LinkToContent:=False, Type:=msoPropertyTypeString, value:=""
  
  If Err.number = 0 Then
    On Error GoTo 0
    index = props.count
  Else
    ' could not add the property.  perhaps it arlready exists
     On Error GoTo 0
    For index = customProperties.count To 1 Step -1
      If customProperties(index).name = "{new property}0:0" Then Exit For
    Next
    If index = 0 Then  ' did not find a property by the name.
      props.Add "{new property}0:0", LinkToContent:=False, Type:=msoPropertyTypeString, value:=""  ' Try again to raise the error again--this time, unhandled
    End If
  End If
  
  If backLink > 0 Then props(backLink).name = props(backLink).name & index
  If Len(value) > 255 Then
    props(index).name = "[" & name & "]" & backLink & ":"
    props(index).value = left(value, 255)
    value = Mid(value, 256)
    backLink = index
  Else
    props(index).name = "[" & name & "]" & backLink & ":0"
    props(index).value = value
    Exit Do
  End If
  
  
  Loop
  
End Sub

' version that looks for dead values.  This was deactivited on Feb 6, 2016  we Just don't delete properties, no need to look for them
'' part of putNewValue
'Function addNewValue(name As String, value As String, Optional backLink As Long) As Long
'  ' return value is the index number in properties collection where the value was placed.  It is used to control the recusive call
'  Dim props As Office.DocumentProperties
'  Dim index As Long
'  Dim data As Variant
'  Set props = customProperties
'
'
'  If searchForDeleted Then
'        index = NewPropertyEntry()
'        If index < 0 Then
'          index = Abs(index)
'        Else
'          searchForDeleted = False
'        End If
'  Else
'        props.Add "{new property}0:0", LinkToContent:=False, Type:=msoPropertyTypeString, value:=""
'        index = props.count
'  End If
'  addNewValue = index
'  If Len(value) > 255 Then
'    props(index).name = "[" & name & "]" & backLink & ":"
'    props(index).value = left(value, 255)
'    props(index).name = props(index).name & addNewValue(name, Mid(value, 256), index)
'  Else
'    props(index).name = "[" & name & "]" & backLink & ":0"
'    props(index).value = value
'  End If
'
'End Function

'' finds a dead property line or makes a new one and returns its index number
'Function NewPropertyEntry() As Long
' ' no longer used,  We just don't delete properties in this system
'  Dim x As Long
'  Dim toggle As Integer
'  If IsNumeric(getValue("assignmentLine")) Then
'    For x = 1 To getValue("assignmentLine") - 1
'      If left(customProperties(x).name, 1) = "{" Then
'        NewPropertyEntry = x * -1
'        Exit Function
'      End If
'    Next
'  End If
'  customProperties.Add "{new property}0:0", LinkToContent:=False, Type:=msoPropertyTypeString, value:=""
'  NewPropertyEntry = customProperties.count
'End Function






#End If
' end of procedures needed by word powerpoint excel




'----------------------- needed by all for encription -----------------------------

Function alphabet(Optional key As String) As String ' scrambles the alphabet based on the key
  Dim x As Byte
  Dim i As Byte
  Dim temp As String
  Dim alpha As String
  Dim newkey As String
  
  alpha = alphabet6
  
  If key = "" Then
    alphabet = alpha
    Exit Function
  End If
  
  Do
    newkey = newkey & key
  Loop Until Len(newkey) >= Len(alpha)
  newkey = left(newkey, Len(alpha))
  
  i = Len(key)
  For x = 1 To Len(newkey) - 1
    i = (((Asc(Mid(newkey, x))) + i) Mod Len(alpha)) + 1
    temp = temp & Mid(alpha & "~", i, 1)
    alpha = left(alpha, i - 1) & Mid(alpha, i + 1)
  Next
  alphabet = temp + alpha
End Function

' performs a six-bit transcoding of data so it can be obfuscated in the custom properties of the current office document
Function ncode(data As String, Optional key As String) As String
  Dim temp As String
  Dim temp1 As String
  Dim x As Long
  Dim i As Long
  Dim newChar As String * 1
  Dim partial As String
  On Error GoTo Hell
  temp = Space(Len(data) * 8 \ 6 - CInt(CBool(Len(data) * 8 Mod 6)))
    i = 1
    For x = 1 To Len(data)
        temp1 = convertTo6(partial & dec2BinStr(Asc(Mid(data, x, 1)), 8), partial, key)
        Mid(temp, i, Len(temp1)) = temp1
         i = i + Len(temp1)
    Next
    If partial > "" Then
        temp1 = convertTo6(partial, partial, key)
        Mid(temp, i, Len(temp1)) = temp1
    End If
  ncode = temp
  Exit Function
Hell:
  ncode = "RGFoYSB80rVgZCBi0rQ5YaU5ZWt80qR-ZCs5IFBm0qJ6YaltIGZj1aVdZqs50GFiZrV6ZqU5Yq661aF82GVm1ms" ' "Data could not be encoded.  Probably foreign language characters."
End Function

' un does the six-bit transcoding of data so key-value pairs can be read back from the custom propeties of the current office document
Function dcode(data As String, Optional key As String) As String
  Dim temp As String
  Dim temp1 As String
  Dim x As Long
  Dim i As Long
  Dim newChar As String * 1
  Dim partial As String
  
  temp = Space(Len(data) * 6 \ 8)
    i = 1
    For x = 1 To Len(data)
        temp1 = convertTo8(Mid(data, x, 1), partial, key)
        If Len(temp1) > 0 Then
          Mid(temp, i, Len(temp1)) = temp1
           i = i + Len(temp1)
         End If
    Next
  dcode = temp
End Function

' part of the dcode procedure
Function convertTo8(char As String, outBitString As String, Optional key As String) As String
  Dim binstring As String
  Dim alpha As String * 64
  alpha = alphabet(key)
    On Error GoTo endfunction
    binstring = outBitString & dec2BinStr(InStr(1, alpha, char) - 1)
    If Len(binstring) < 8 Then
      outBitString = binstring
    Else
      convertTo8 = Chr(binStr2Dec(left(binstring, 8)))
      outBitString = Mid(binstring, 9)
    End If
    Exit Function
endfunction:
  
End Function

'part of the ncode procedure
Function convertTo6(ByVal bitString As String, outBitString As String, Optional key As String) As String
  Dim binstring As String
  Dim temp As String
  Dim alpha As String * 64
  alpha = alphabet(key)
  
  Do
    temp = temp & Mid(alpha, binStr2Dec(left(bitString & "000000", 6)) + 1, 1)
     
     If Len(bitString) > 12 Then
       bitString = Mid(bitString, 7)
     ElseIf Len(bitString) > 6 Then
       outBitString = Mid(bitString, 7)
       Exit Do
     Else
       outBitString = ""
       Exit Do
     End If
  Loop

  convertTo6 = temp

End Function


' needed for dcode and ncode
Function dec2BinStr(x As Byte, Optional chunksize As Byte = 6) As String
      Dim i As Integer, bin As String
      bin = Replace(Space(chunksize), " ", "0")
      For i = 0 To chunksize - 1
        If x And (2 ^ i) Then Mid(bin, chunksize - i, 1) = "1"
      Next
      dec2BinStr = bin
End Function

' needed for dcode and ncode
Function binStr2Dec(data As String) As Byte
      Dim x As Byte
      Dim i As Integer
      For i = 1 To Len(data)
        If Mid(data, (Len(data) - i) + 1, 1) = 1 Then x = x + (2 ^ (i - 1))
      Next
      binStr2Dec = x
End Function





Attribute VB_Name = "modLog"
' procedures for logging student activity




Function logType(index As Integer) As String
  Select Case index
    Case 1: logType = "single value" '---> event name
    Case 2: logType = "parameter" '---> name | value
    Case 3: logType = "unused"
    Case 4: logType = "number of hours the local clock is behind the server clock" '--->
    Case 5: logType = "range modification" '---> worksheet  | address | formula | value shown  | actionStep  "action step is a sequence number when a single activity produces several log entries
    Case 6: logType = "submission" '---> submissionID | email | Firstname | lastname | userid(MEPK) | clockOffset | pathToFileSubmitted
    Case 7: logType = "new chart" '---> chartname | chartType | series1 | left | top
    Case 8: logType = "pivot table modification" '---> rowfields | columnFields | dataFields | pageFields
    Case 9: logType = "show task" '---> taskname
    Case 10: logType = "table status" '--->   tableName | timeCreated | lastUpdated | recordCount
    Case 11: logType = "object status" '--->   objectType | name | timeCreated | lastUpdated
    Case 12: logType = "object deletion" '--->   objectType | name | timeCreated | lastUpdated
    Case 13: logType = "object creation" '--->   objectType | name | timeCreated
  End Select
End Function



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
      'Procedures For Logging student Activity'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' makes common entries in log when file is opened
Sub logOpenDocument(Optional junk As Boolean)
  addLogEntry "2" & Chr(30) & "Opened" & Chr(30) & fullPath
  addLogEntry "2" & Chr(30) & "Operating System" & Chr(30) & operatingSystem
  addLogEntry "2" & Chr(30) & "Environment Variables" & Chr(30) & environVariables
  addLogEntry "2" & Chr(30) & "Network Configuration" & Chr(30) & "<pre>" & networkConfiguration & "</pre>"

End Sub

' makes common entries in log when file is opened
Sub logSubmission(submissionID As String, email As String, firstname As String, lastname As String)
  addLogEntry "6" & Chr(30) & submissionID & Chr(30) & email & Chr(30) & firstname & Chr(30) & lastname & Chr(30) & fullPath
End Sub



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
      'General Logging Procedures'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' clears log entries from the current office document
Sub clearLog(Optional junk As Boolean)

Dim x As Long
Dim props As Office.DocumentProperties
Dim name As String

Set props = customProperties

For x = props.count To 1 Step -1
  name = getName(x)
  If InStr(1, name, "LogEntry") > 0 Then
    props(x).Delete
  End If
Next

End Sub

' records a log entry in the custom properties of the current office document
#If officeApplication = 4 Then  ' access
Function addLogEntry(value)
Dim logEntryNumber As Long

  If currentdb.Updatable Then
    logEntryNumber = getDBValue("select count(*) from customProperties where a >=(select dcode(c) from customProperties where b ='Za-m1rRM0q2M_Wt-')") ' the number of log lines in already in the custom properties
    putNewValue logEntryNumber & "LogEntry", commaToPeriod(CDbl(Now())) & Chr(30) & value
  End If
  
End Function
#Else
Function addLogEntry(value)
#If dev <> 1 Then
Dim x As Long
Dim props As Office.DocumentProperties
Dim logEntryNumber As Long
Dim name As String

Set props = customProperties

For x = props.count To 1 Step -1
  name = getName(x)
  If Right(name, 8) = "LogEntry" Then
    logEntryNumber = CLng(left(name, Len(name) - 8)) + 1
    Exit For
  End If
Next

putNewValue logEntryNumber & "LogEntry", commaToPeriod(CDbl(Now())) & Chr(30) & value
#End If
End Function
#End If
    Function environVariables()
        Dim temp As String
        Dim temp1 As String
        Dim data As Variant
        Dim i As Byte
        temp = "<table border=1 cellspacing=0 cellpadding=3>"
        For i = 1 To 255
             temp1 = Environ$(i)
            If LenB(temp1) = 0& Then Exit For
            data = Split(temp1, "=")
            temp = temp & "<tr><td>" & data(0) & "</td><td>" & data(1) & "</td></tr>" & vbNewLine
        Next
        environVariables = temp & "</table>"
    End Function

Attribute VB_Name = "modStubs"
' this module is just       to allow code to compile when the real modules are not included

Sub buildQueryResult(junk)
End Sub

Function recordCount()
End Function

Function CollapseWhiteSpace(junk)
End Function
Attribute VB_Name = "modUtilsOS"
' This module is for commands that require something specific of the  OS

#If Mac Then
Public Const encoding = "none"
' Mac: returns ":"
Function pathSeparator() As String
#If officeApplication = 3 Then ' powerpoint
  If version >= 15 Then
    pathSeparator = "/"
  Else
    pathSeparator = ":"
  End If
#Else
  pathSeparator = Application.pathSeparator
#End If
End Function

'Mac: returns the results of ifconfig
Function networkConfiguration() As String
    ' first, try to get the address without using the oscommand as sophos kills excel when this happens
    Const strComputer As String = "."   ' Computer name. Dot means local computer
    Dim objWMIService, IPConfigSet, IPConfig, IPAddress, i
    Dim strIPAddress As String
     
    On Error GoTo Hell
    ' Connect to the WMI service
    Set objWMIService = GetObject("winmgmts:" _
        & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")

    ' Get all TCP/IP-enabled network adapters
    Set IPConfigSet = objWMIService.ExecQuery _
        ("Select * from Win32_NetworkAdapterConfiguration Where IPEnabled=TRUE")

    ' Get all IP addresses associated with these adapters
    For Each IPConfig In IPConfigSet
        IPAddress = IPConfig.IPAddress
        If Not IsNull(IPAddress) Then
            strIPAddress = strIPAddress & Join(IPAddress, ", ")
        End If
    Next

    networkConfiguration = strIPAddress
    Exit Function
Hell:
  networkConfiguration = osCommand("ifconfig")
End Function

'Mac:  returns the results of the operating sytem command specified
Function osCommand(command As String) As String
   osCommand = MacScript("do shell script """ & command & """")
End Function

'Mac: returns a string that indicates the version of the operating sytem being run
Function operatingSystem2() As String
    operatingSystem2 = osCommand("uname -a")
End Function

'Mac: records that the document was opened on a mac
Function osRecordOpening() As String
    If getValue("activityID") <> "___Activity ID___" Then
      updateValue "dateOpenedMac", Now() & "|" & Application.version
    End If
End Function

'Mac: estabilishes the path to use for local file writing

Sub setWritePath(Optional junk As Boolean)
    If InStr(1, localPath, "://") = 0 Then
      ' this is a regular location in the local file system.  Use the localpath as the write path
      globalWritePath = localPath
    Else
      ' assume this is a onedrive path.
      globalWritePath = left(osCommand("echo $HOME"), Len(osCommand("echo $HOME")) - 1)
    End If
End Sub

#Else
Public Const encoding = "base64"

' Windows: returns "\"
Function pathSeparator() As String
  pathSeparator = "\"
End Function

Function networkConfiguration() As String

    Const strComputer As String = "."   ' Computer name. Dot means local computer
    Dim objWMIService, IPConfigSet, IPConfig, IPAddress, i
    Dim strIPAddress As String
     
    On Error GoTo Hell
    ' Connect to the WMI service
    Set objWMIService = GetObject("winmgmts:" _
        & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")

    ' Get all TCP/IP-enabled network adapters
    Set IPConfigSet = objWMIService.ExecQuery _
        ("Select * from Win32_NetworkAdapterConfiguration Where IPEnabled=TRUE")

    ' Get all IP addresses associated with these adapters
    For Each IPConfig In IPConfigSet
        IPAddress = IPConfig.IPAddress
        If Not IsNull(IPAddress) Then
            strIPAddress = strIPAddress & Join(IPAddress, ", ")
        End If
    Next

    networkConfiguration = strIPAddress
    Exit Function
Hell:

     networkConfiguration = osCommand("ipconfig /all")

   
End Function


'Windows: returns the results of the operating sytem command specified
Function osCommand(command As String) As String
    Dim fnum As Integer
    Dim commandFile As String
    Dim outputFile As String
    Dim doneFile As String
    
    commandFile = writePath & "\command.bat"
    outputFile = writePath & "\output.txt"
    doneFile = writePath & "\done.txt"
    
     ' make sire the files are not already in the folder to prevent reading the results of a prior run
     On Error Resume Next
       Kill doneFile
       Kill outputFile
       Kill commandFile
     On Error GoTo 0

    fnum = FreeFile()
    Open commandFile For Output As fnum
    Print #fnum, command & " > """ & outputFile & """"
    Print #fnum, "time /t > """ & doneFile & """"
    Close #fnum
    
    Do Until Dir(commandFile) > ""
      sleep 0.5
    Loop
    
    Shell """" & commandFile & """", vbHide
    
    Do Until Dir(doneFile) > ""
      sleep 0.5
    Loop

    osCommand = "Could not read operating systems command results (" & command & ")."
    On Error Resume Next
    fnum = FreeFile()
    Open outputFile For Input As fnum
      On Error Resume Next ' command fails on chineese computers.
      osCommand = Input(LOF(fnum), fnum)
      On Error GoTo 0
    Close #fnum
    On Error GoTo 0
    
    
    On Error Resume Next
     Kill doneFile
     Kill outputFile
     Kill commandFile
    On Error GoTo 0
    
End Function

'Win: records that the document was opened on a windows
Function osRecordOpening() As String
    If getValue("activityID") <> "___Activity ID___" Then
      updateValue "dateOpenedWin", Now() & "|" & Application.version
    End If
End Function

'Win: estabilishes the path to use for local file writing
Sub setWritePath(Optional junk As Boolean)
    If Mid(localPath, 2, 1) = ":" Then
      ' this is a regular location in the local file system.  Use the localpath as the write path
      globalWritePath = localPath
    Else
      ' assume this is a onedrive path.
      Select Case True
        Case Mid(defaultFilePath, 2, 1) = ":"
          globalWritePath = defaultFilePath
        Case Else
          globalWritePath = Environ$("temp")
      End Select
    End If
    
End Sub



#End If



Attribute VB_Name = "modUtilsOffice"
' This module is for utility procedures which can be used by Word, Powerpoint, Excel, and Access

'pauses the execution of the code for a specified number of seconds
Sub sleep(seconds As Single)
Dim start As Single
Dim Finish, TotalTime
    start = Timer
    Do While Timer < start + seconds
        DoEvents    ' Yield to other processes.
    Loop
End Sub


'returns the full path and name of the office document containing the code
Function fullPath() As String
  fullPath = officeDocument.path & pathSeparator & officeDocument.name
End Function

'returns the name of the document containing the code
Function filename() As String
  filename = officeDocument.name
End Function

'returns the path of the document containing the code
Function localPath() As String
  localPath = officeDocument.path
End Function

'returns the globalWritePath or sets it if blank
Function writePath() As String
  If globalWritePath = "" Then setWritePath
  writePath = globalWritePath
End Function

'returns the temporary path
Function getTempPath() As String
  getTempPath = writePath & pathSeparator
End Function


' returns the two digit version of the application
Function version() As Single
  version = Split(Application.version & ".00", Mid(3 / 2, 2, 1))(0) & Mid(3 / 2, 2, 1) & Split(Application.version & ".00", Mid(3 / 2, 2, 1))(1)
End Function
Attribute VB_Name = "modUtilsVBA"
'removes non-printable characters from beginning and ending of a string
Function superTrim(ByVal data As String) As String
  Dim x As Integer
  For x = 1 To Len(data)
    If Asc(Mid(data, x, 1)) >= 32 Then Exit For
    Mid$(data, x, 1) = " "
  Next
  For x = Len(data) To 1 Step -1
    If Asc(Mid(data, x, 1)) >= 32 Then Exit For
    Mid$(data, x, 1) = " "
  Next
  superTrim = Trim(data)
End Function

        
'returns the contents of a file
Function getFileContents(filepath As String) As String
  Dim ff As Integer
  ff = FreeFile
  If Dir(filepath) = "" Then
    getFileContents = ""
  Else
    Open filepath For Input As #ff
     getFileContents = Input(LOF(ff), ff)
    Close #ff
  End If
End Function

' writes data to file
Sub writeToFile(filepath As String, data As String)
  Dim ff As Integer
  ff = FreeFile
  Open filepath For Output As #ff
     Print #ff, data;
  Close #ff
End Sub

'delete the file.
Sub deleteFile(filepath As String)
  On Error Resume Next
    Kill filepath
  On Error GoTo 0
End Sub
' converts a hex color as expressed in the XML version of an office document file to the decimal equivalent
Function hexColor2Dec(hexColor As String) As Long
  If IsNumeric("&H" & Mid(hexColor, 3, 2)) And IsNumeric("&H" & Mid(hexColor, 5, 2)) And IsNumeric("&H" & Mid(hexColor, 7, 2)) Then
    hexColor2Dec = RGB("&H" & Mid(hexColor, 3, 2), "&H" & Mid(hexColor, 5, 2), "&H" & Mid(hexColor, 7, 2))
  Else
    hexColor2Dec = -1
  End If
End Function

'converts a long representation of a color to the hex variation used in the XML version of the office documnet
Function decColor2Hex(color As Long) As String
    decColor2Hex = "FF" & Right("0" & Hex(color Mod 256), 2) & Right("0" & Hex(color \ 256 Mod 256), 2) & Right("0" & Hex(color \ 65536 Mod 256), 2)
End Function

' returns the red, blue, or green component of the supplied color
Function getRGB3(color As Long, Optional opt As Integer) As Long
   Select Case opt
      Case 1: getRGB3 = color Mod 256
      Case 2: getRGB3 = color \ 256 Mod 256
      Case 3: getRGB3 = color \ 65536 Mod 256
      Case Else: getRGB3 = color
   End Select
End Function

'if data is null, returns replaceValue, otherwise returns data
Function fixNull(data As Variant, Optional replaceValue As Variant) As Variant
  If IsNull(data) Then
    fixNull = replaceValue
  Else
    fixNull = data
  End If
End Function

' sorts a single dimension array
Public Sub QuickSort(vArray As Variant, inLow As Long, inHi As Long)

  Dim pivot   As Variant
  Dim tmpSwap As Variant
  Dim tmpLow  As Long
  Dim tmpHi   As Long

  tmpLow = inLow
  tmpHi = inHi

  pivot = vArray((inLow + inHi) \ 2)

  While (tmpLow <= tmpHi)

     While (vArray(tmpLow) < pivot And tmpLow < inHi)
        tmpLow = tmpLow + 1
     Wend

     While (pivot < vArray(tmpHi) And tmpHi > inLow)
        tmpHi = tmpHi - 1
     Wend

     If (tmpLow <= tmpHi) Then
        tmpSwap = vArray(tmpLow)
        vArray(tmpLow) = vArray(tmpHi)
        vArray(tmpHi) = tmpSwap
        tmpLow = tmpLow + 1
        tmpHi = tmpHi - 1
     End If

  Wend

  If (inLow < tmpHi) Then QuickSort vArray, inLow, tmpHi
  If (tmpLow < inHi) Then QuickSort vArray, tmpLow, inHi

End Sub


' returns an array of files that meet the criteria specifdied in serachCriteria with the original serach criteria in the 0th position
Function getFileList(searchCriteria As String, Optional attributes As Long = 0) As Variant
  Dim list As String
  Dim fname As String
  fname = Dir(searchCriteria, attributes)
  list = searchCriteria
  Do Until fname = ""
    list = list & Chr(30) & fname
    fname = Dir()
  Loop
  getFileList = Split(list, Chr(30))
End Function


Function fileExists(path As String) As Boolean
  Dim filename As String
  On Error Resume Next
      filename = Dir(path)
  On Error GoTo 0
  fileExists = filename > ""
End Function


' converts single quotes in a string to double single quotes
Function prepSQL(data As String) As String
  prepSQL = Replace(data, "'", "''")
End Function


Attribute VB_Name = "modWebLock"
Option Explicit
Private shapesVisible As New Collection

' these two procedures are to give functionality in the list of macros
Sub startExam()
webLock_Initialize
End Sub

Sub startExamAdmin()
 frmPassword.Show
 If frmPassword.txtPassword.text > "" Then webLock_Initialize frmPassword.txtPassword.text
Unload frmPassword
End Sub



Sub webLock_afterSave(Optional hideFromMenu As Boolean)
  weblock_showsheets
  ThisWorkbook.Saved = True
End Sub



Sub webLock_beforeSave(Optional hideFromMenu As Boolean)
  Application.ScreenUpdating = False
  weblock_hidesheets
  #If Mac Then
  Application.OnTime DateAdd("s", 1, Now), "weblock_showsheets"
  ThisWorkbook.Saved = True
  #End If
End Sub


Sub webLock_Initialize(Optional password As String)
    Dim exam_on As Boolean
    Dim exam_off As Boolean
    Dim enableMacros As Worksheet
    Dim html As String
    Dim http As Object
    Dim url As String
    Dim x As Integer
    For x = 1 To ThisWorkbook.Worksheets.count
      If ThisWorkbook.Worksheets(x).name = "Enable Macros" Then
         ThisWorkbook.Worksheets(x).visible = xlSheetVisible
         If ThisWorkbook.ActiveSheet.name <> "Enable Macros" Then
             ThisWorkbook.Worksheets(x).Activate
         End If
         Exit For
      End If
    Next

  ThisWorkbook.ActiveSheet.Shapes("txtEnableMacros").visible = False
  ThisWorkbook.ActiveSheet.Shapes("txtExamOff").visible = False
  ThisWorkbook.ActiveSheet.Shapes("txtExamOn").visible = False
  ThisWorkbook.ActiveSheet.Shapes("txtEnableMacros").visible = False
  ThisWorkbook.ActiveSheet.Shapes("Picture 1").visible = False
  ThisWorkbook.ActiveSheet.Shapes("Picture 2").visible = False
  ThisWorkbook.ActiveSheet.Shapes("Picture 3").visible = False
  ThisWorkbook.ActiveSheet.Shapes("txtWait").visible = True
  ThisWorkbook.ActiveSheet.Shapes("txtExamOn").width = 447
    Application.ScreenUpdating = True
    DoEvents
    If password = "" Then
    url = domain & pathForActivityDetails & "?activityid=" & getValue("activityID") & "&access_token=" & getValue("accessToken") & "&client_id=" & getValue("downloadedByUserID")
      #If Mac Then
          html = MacScript("return do shell script ""/usr/bin/curl -s -S -m 10 '" & url & "'""")
      #Else
          Set http = CreateObject("MSXML2.serverXMLHTTP")
          http.setTimeouts 20000, 20000, 90000, 90000
          http.Open "GET", url, False
          http.Send
          html = http.responsetext
          Debug.Print html
      #End If
      exam_on = InStr(1, html, "submittable"": true") > 0
      exam_off = InStr(1, html, "submittable"": false") > 0
    Else
        If password = Chr(65) + Chr(108) + Chr(97) + Chr(115) + Chr(32) + Chr(66) + Chr(97) + Chr(98) + Chr(121) + Chr(108) + Chr(111) + Chr(110) Then
            exam_on = True
            exam_off = False
        Else
            exam_off = True
            exam_on = False
        End If
    End If
   ThisWorkbook.ActiveSheet.Shapes("txtWait").visible = False
   ThisWorkbook.ActiveSheet.Shapes("txtInternet").visible = False
   ThisWorkbook.ActiveSheet.Shapes("txtExamOn").visible = False
   ThisWorkbook.ActiveSheet.Shapes("txtExamOff").visible = False
   
   If exam_on Then
     ThisWorkbook.ActiveSheet.Shapes("txtExamOn").visible = True
     ThisWorkbook.ActiveSheet.Shapes("txtExamOn").width = 448
     weblock_showsheets
   ElseIf exam_off Then
    ThisWorkbook.ActiveSheet.Shapes("txtExamOff").visible = True
  Else
    ThisWorkbook.ActiveSheet.Shapes("txtInternet").visible = True
   End If
   
ThisWorkbook.Saved = True


End Sub


Function weblock_dataVisible() As Boolean
  weblock_dataVisible = enableMacros.Shapes("txtExamOn").width = 448
End Function

Public Sub weblock_hidesheets(Optional hideFromMenu As Boolean)
     Dim s As Object
     Dim title_on As Boolean
Dim enableMacros As Worksheet
On Error GoTo Hell
Set enableMacros = ThisWorkbook.Worksheets("enable macros")
     
        Do Until shapesVisible.count = 0
          shapesVisible.Remove 1
        Loop
        
        For Each s In enableMacros.Shapes
          shapesVisible.Add Array(s.name, s.visible)
        Next
        
        enableMacros.visible = xlSheetVisible
        For Each s In Sheets
          If s.CodeName <> "enableMacros" Then s.visible = xlVeryHidden
        Next
        enableMacros.Range("b3").Select
        enableMacros.Shapes("txtEnableMacros").visible = True
        enableMacros.Shapes("txtExamOff").visible = False
        enableMacros.Shapes("txtExamOn").visible = False
        enableMacros.Shapes("txtInternet").visible = False
        enableMacros.Shapes("txtWait").visible = False
        enableMacros.Shapes("Picture 1").visible = True
        enableMacros.Shapes("Picture 2").visible = True
        enableMacros.Shapes("Picture 3").visible = True
        updateValue "debug", "hidden"
Hell:
End Sub



Public Sub weblock_showsheets(Optional param_to_keep_hidden As String)
  Dim x As Integer
  Dim s As Object
Dim enableMacros As Worksheet

Set enableMacros = ThisWorkbook.Worksheets("enable macros")
   updateValue "debug", "visible"
  If weblock_dataVisible() Then
    For Each s In ThisWorkbook.Sheets
      s.visible = xlSheetVisible
    Next
    enableMacros.visible = xlVeryHidden
  End If
  
  For x = 1 To shapesVisible.count
    enableMacros.Shapes(shapesVisible(x)(0)).visible = shapesVisible(x)(1)
  Next


End Sub



Attribute VB_Name = "mod_office_js"
Option Explicit

Sub makeTaskGuides(Optional junk As Boolean)
Dim a As New assignment
Dim json As New jsonParser
Dim d As New Dictionary

a.loadModelFromFile "C:\Users\govea\Box\Atlas\Content\Excel\Prometheus\Assignments\Book\03 - Logic and Reference Functions\Test Your Skills\specification\assignment.json"
a.build_office_js_task_Guides "C:\Users\govea\Box\Atlas\Content\Excel\Prometheus\Assignments\Book\03 - Logic and Reference Functions\Test Your Skills\specification"


End Sub


Attribute VB_Name = "process"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public id As String
Private localParamlist As String ' "sheetname|address|formula"
Private localProcedureName As String

Private localDataChanged As Boolean

Public Property Get DataChanged() As Boolean
DataChanged = localDataChanged
End Property

Public Property Let DataChanged(theData As Boolean)
  localDataChanged = theData
End Property



Public Property Get paramList() As String
paramList = localParamlist
End Property

Public Property Let paramList(theData As String)
  localParamlist = theData
  DataChanged = True
End Property

Public Property Get ProcedureName() As String
ProcedureName = localProcedureName
End Property

Public Property Let ProcedureName(theData As String)
  localProcedureName = theData
  DataChanged = True
End Property

Public Sub executeProc(Optional prefix As String)
  executePreProcess prefix & localProcedureName, localParamlist
End Sub



Sub setProperty(propertyName As String, value As Variant)
  Select Case LCase(propertyName)
    Case "id": id = value
    Case "paramlist": localParamlist = value
    Case "procedurename": localProcedureName = value
    Case "procname": localProcedureName = value
  End Select
  localDataChanged = True

End Sub



Attribute VB_Name = "rule"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Public id As String

Private localName As String
Private localPoints As Single
Private localRuleFormula As String
Private localErrorMessage As String
Private localExhibit As String
Private localMessageAdendum As String
Private localDataChanged As Boolean

Public correct As Single
Public preFills As New Collection
Public preProcs As New Collection
Public Property Get pointsEarned() As Single
pointsEarned = (((Abs(points * correct)) * 1000) \ 1) / 1000
End Property
Public Property Get name() As String
name = localName
End Property

Public Property Let name(theData As String)
  localName = theData
  DataChanged = True
End Property

Public Property Get points() As Single
points = localPoints
End Property

Public Property Let points(theData As Single)
  localPoints = theData
  DataChanged = True
End Property

Public Property Get ruleFormula() As String
ruleFormula = localRuleFormula
End Property

Public Property Let ruleFormula(theData As String)
  localRuleFormula = theData
  localDataChanged = True
End Property

Public Property Get exhibit() As String
exhibit = localExhibit
End Property

Public Property Let exhibit(theData As String)
  localExhibit = theData
  localDataChanged = True
End Property

Public Property Get errorMessage() As String
errorMessage = localErrorMessage
End Property

Public Property Let errorMessage(theData As String)
  localErrorMessage = theData
  DataChanged = True
End Property


Public Property Get messageAdendum() As String
messageAdendum = localMessageAdendum
End Property

Public Property Let messageAdendum(theData As String)
  localMessageAdendum = theData
  DataChanged = True
End Property

Public Property Get DataChanged() As Boolean
  Dim p As fill
  DataChanged = localDataChanged
  For Each p In preFills
    If p.DataChanged Then
      DataChanged = True
      Exit For
    End If
  Next
End Property

Public Property Let DataChanged(theData As Boolean)
  Dim p As fill
  localDataChanged = theData
  If theData = False Then
    For Each p In preFills
      p.DataChanged = False
    Next
  End If
End Property

Function process() As String
  processPreProcs
  processPreFills
     evaluateRuleFormula Me  ' each environment needs differnt code for this, currently implimented in modPresentation, think about moving here with compiler directives
       ' need to think about the meanding of the return value of this function.  The old way was this:   process = vbNewLine & errorMessage
       ' not sure how or if hte old way was used  (Dec 2014)
       ' it seems like there should be a way to hold the student-level feedback for the rule here.   I don't think this function needs to return anything
  restorePreFills
  
  
' old way:
'  processPreFills
'    If Not Evaluate(ruleFormula) Then
'       process = vbNewLine & errorMessage
'    End If
'  restorePreFills
End Function

Sub setProperty(propertyName As String, value As Variant)
  Select Case LCase(propertyName)
    Case "id": id = value
    Case "name": localName = value
    Case "points": localPoints = value
    Case "ruleformula": localRuleFormula = value
    Case "exhibit": localExhibit = value
    Case "errormessage": localErrorMessage = value
  End Select
  localDataChanged = True
End Sub



Public Function addPreFill(Optional id As String, Optional paramList As String = "some param list", Optional revert As Boolean = True) As fill
  preFills.Add New fill
  
  preFills(preFills.count).setProperty "id", id
  preFills(preFills.count).setProperty "paramList", paramList
  preFills(preFills.count).setProperty "revert", revert
  Set addPreFill = preFills(preFills.count)
End Function

Public Function addPreProcess(Optional id As String, Optional procName As String = "some procName", Optional paramList As String = "|") As process
  preProcs.Add New process
  preProcs(preProcs.count).setProperty "id", id
  preProcs(preProcs.count).setProperty "ProcedureName", procName
  preProcs(preProcs.count).setProperty "paramList", paramList
  Set addPreProcess = preProcs(preProcs.count)
End Function

Public Sub processPreProcs()
  Dim p As process
  For Each p In preProcs
    p.executeProc
  Next
End Sub

Public Sub processPreFills()
  Dim pf As fill
  For Each pf In preFills
    pf.process
  Next
End Sub


Public Sub restorePreFills()
  Dim pf As fill
  For Each pf In preFills
    pf.restore
  Next
End Sub

Sub Class_Terminate()
  Do Until preFills.count = 0
    preFills.Remove 1
  Loop
End Sub



Attribute VB_Name = "task"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public id As String
Private localResponseFormula As String '  this is a function that returns what will be displayed by as the user's response at the MyEducator site.
Private localResponse As String '  this is what the responseFunction returns for a given assignment
Private localxmlid As String
Private localNote As String
Private localFeedback As String
Private localName As String
Private localText As String
Private localHint As String
Private localComplete As Boolean
Private localDataChanged As Boolean
Private localExhibit As String
Public rules As New Collection

Public Property Get response() As String
response = localResponse
End Property


Public Property Get responseFormula() As String
responseFormula = localResponseFormula
End Property

Public Property Let responseFormula(theData As String)
  localResponseFormula = theData
  DataChanged = True
End Property

Public Property Get xmlID() As String
xmlID = localxmlid
End Property

Public Property Let xmlID(theData As String)
  localxmlid = theData
  DataChanged = True
End Property

Public Property Get note() As String
note = localNote
End Property

Public Property Let note(theData As String)
  localNote = theData
  DataChanged = True
End Property

Public Property Get feedback() As String
feedback = localFeedback
End Property

Public Property Let feedback(theData As String)
  localFeedback = theData
  DataChanged = True
End Property
Public Property Get exhibit() As String
exhibit = localExhibit
End Property

Public Property Let exhibit(theData As String)
  localExhibit = theData
  DataChanged = True
End Property




Public Property Get name() As String
name = localName
End Property

Public Property Let name(theData As String)
  localName = theData
  DataChanged = True
End Property


Public Property Get text() As String
text = localText
End Property

Public Property Let text(theData As String)
  localText = theData
  DataChanged = True
End Property


Public Property Get hint() As String
hint = localHint
End Property

Public Property Let hint(theData As String)
  localHint = theData
  DataChanged = True
End Property


Public Property Get complete() As Boolean
complete = localComplete
End Property

Public Property Let complete(theData As Boolean)
  localComplete = theData
  DataChanged = True
End Property



Public Property Get DataChanged() As Boolean
Dim r As rule
DataChanged = localDataChanged
For Each r In rules
  If r.DataChanged Then
    DataChanged = True
    Exit For
  End If
Next
End Property

Public Property Let DataChanged(theData As Boolean)
  Dim r As rule
  localDataChanged = theData
  If theData = False Then
    For Each r In rules
      r.DataChanged = False
    Next
  End If
End Property



Public Function addRule(Optional id As String, Optional name As String = "New Rule", Optional points As Single = "1", Optional ruleFormula As String = "some formula", Optional errorMessage As String = "some error message") As rule
  
  rules.Add New rule
  rules(rules.count).setProperty "id", id
  rules(rules.count).setProperty "name", name
  rules(rules.count).setProperty "points", points
  rules(rules.count).setProperty "ruleFormula", ruleFormula
  rules(rules.count).setProperty "errorMessage", errorMessage
  Set addRule = rules(rules.count)
End Function

Public Property Get pointsPossible() As Single
  Dim r As rule
  Dim c As Single
  For Each r In rules
    c = c + r.points
  Next
  pointsPossible = ((c * 1000) \ 1) / 1000
End Property

Public Property Get errorMessage() As String
  Dim r As rule
  Dim m As String
  For Each r In rules
    If Not r.correct Then
      m = m & vbNewLine & r.errorMessage & " (-" & r.points & ")"
    End If
  Next
  
  errorMessage = Mid(m, Len(vbNewLine))
End Property

Public Property Get pointsEarned() As Single
  Dim r As rule
  Dim c As Single
  For Each r In rules
      c = c + r.pointsEarned
  Next
  pointsEarned = ((c * 1000) \ 1) / 1000
End Property


Public Function processRules() As String
  Dim r As rule
  Dim e As String
  For Each r In rules
    pointsPossible = pointsPossible + r.points
    e = r.process
    If e > "" Then
      errorMessage = errorMessage & e
    Else
      pointsEarned = pointsEarned + r.points
    End If
  Next
  If Len(errorMessage) > Len(vbNewLine) Then errorMessage = Mid(errorMessage, Len(vbNewLine) + 1)

End Function

Sub Class_Terminate()
  Do Until rules.count = 0
    rules.Remove 1
  Loop
End Sub

Function processResponseFormula() As String
  On Error GoTo Hell
  If localResponseFormula > "" Then
    localResponse = evaluate(responseFormula)
  End If
  Exit Function
  processResponseFormula = localResponse
Hell:
  localResponse = "Internal Error: Unable to show student response"
  processResponseFormula = localResponse
End Function


Sub setProperty(propertyName As String, value As Variant)
  Select Case LCase(propertyName)
    Case "id": id = value
    Case "name": localName = value
    Case "text": localText = value
    Case "hint": localHint = value
    Case "exhibit": localExhibit = value
    Case "responseformula": localResponseFormula = value
    Case "xmlid": localxmlid = value
    Case "note": localNote = value
    Case "feedback": localFeedback = value
  End Select
  localDataChanged = True

End Sub


Attribute VB_Name = "taskSet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public id As String

Private localTitle As String
Private localText As String
Private localDataChanged As Boolean

Public tasks As New Collection

Public Property Get title() As String
  title = localTitle
End Property

Public Property Let title(theData As String)
  localTitle = theData
  DataChanged = True
End Property


Public Property Get text() As String
  text = localText
End Property

Public Property Let text(theData As String)
  localText = theData
  DataChanged = True
End Property


Public Property Get DataChanged() As Boolean
  Dim t As task
  DataChanged = localDataChanged
  For Each t In tasks
    If t.DataChanged Then
      DataChanged = True
      Exit For
    End If
  Next
End Property
Public Property Get ruleCount() As Long
  Dim t As task
  Dim total As Long
  For Each t In tasks
    total = total + t.rules.count
  Next
  ruleCount = total
End Property

Public Property Let DataChanged(theData As Boolean)
  Dim t As task
  localDataChanged = theData
  If theData = False Then
    For Each t In tasks
      t.DataChanged = False
    Next
  End If
End Property

Sub setProperty(propertyName As String, value As Variant)
  Select Case LCase(propertyName)
    Case "id":    id = value
    Case "text": localText = value
    Case "title": localTitle = value
  End Select
    localDataChanged = True

End Sub



Public Function addTask(Optional id As String, Optional name As String = "new task", Optional text As String = "some text", Optional hint As String, Optional exhibit As String, Optional xmlID As String, Optional feedback As String, Optional responseFormula As String) As task
  Dim ttask As New task
  ttask.id = id
  ttask.setProperty "name", name
  ttask.setProperty "text", text
  ttask.setProperty "hint", hint
  ttask.setProperty "exhibit", exhibit
  ttask.setProperty "xmlID", xmlID
  ttask.setProperty "feedback", feedback
  ttask.setProperty "responseFormula", responseFormula
  
  tasks.Add ttask
  Set addTask = ttask

End Function

Public Sub score()
  Dim t As task
  For Each t In tasks
    t.processRules
    If t.pointsPossible = t.pointsEarned Then tasksCorrect = tasksCorrect + 1
    pointsEarned = pointsEarned + t.pointsEarned
  Next
End Sub

Public Property Get pointsPossible() As Single
  Dim t As task
  Dim c As Single
  For Each t In tasks
    c = c + t.pointsPossible
  Next
  pointsPossible = ((c * 1000) \ 1) / 1000
End Property
Public Property Get pointsEarned() As Single
  Dim t As task
  Dim c As Single
  For Each t In tasks
    c = c + t.pointsEarned
  Next
  pointsEarned = ((c * 1000) \ 1) / 1000
End Property
Public Property Get tasksCorrect() As Integer
  Dim t As task
  Dim c As Integer
  For Each t In tasks
    If t.pointsPossible = t.pointsEarned Then
      c = c + 1
    End If
  Next
  tasksCorrect = c
End Property

Public Property Get taskCount() As Integer
  taskCount = tasks.count
End Property

Sub Class_Terminate()
  Do Until tasks.count = 0
    tasks.Remove 1
  Loop
End Sub




Attribute VB_Name = "taskType"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
  Public title As String
  Public num As Integer
  Public text As String
  Public id As String
  Public hint As String
  Public taskSetid
  Public taskid
  Public complete As Boolean
  Public logString As String
  Public name As String
  Public exhibit As String

Attribute VB_Name = "valuePair"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public key As String
Public value As String


' InQuest injected base64 decoded content
' {Zn)b
' *'jQh
' *'v+b
' kOj*
' z{Cj
' Daha |
' `d b
' 9ek|
' d+9 Pf
' m fc

INQUEST-PP=macro
