Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_Open()
  Dim driverArray As Variant
  
  driverArray = ListODBCDrivers()
  
  Dim i As Long
  Dim y As Long
  y = 7
  For i = LBound(driverArray) To UBound(driverArray)
    Dim s As String
    s = GetDriverDLL(driverArray(i))
    If s <> "" Then
      Tabelle1.ComboBox2.AddItem driverArray(i)
      y = y + 1
    End If
  Next i
  
  Cells(4, 3) = GetDriverDLL(Tabelle1.ComboBox2)

End Sub
Attribute VB_Name = "DriverHandler"
Option Explicit

Private Const SQL_FETCH_NEXT As Long = 1
Private Const SQL_FETCH_FIRST As Long = 2
Private Const SQL_SUCCESS As Long = 0
Private Const SQL_NO_DATA_FOUND As Long = 100

Private Const SQL_NTS As Long = -3
Private Const SQL_DROP As Long = 1

Private Const SQL_MAX_DESC_LENGTH As Long = 128
Private Const SQL_MAX_DSN_LENGTH As Long = 32

Private Const SQL_NULL_HANDLE As Long = 0
Private Const SQL_HANDLE_ENV As Long = 1
Private Const SQL_HANDLE_DBC As Long = 2
Private Const SQL_HANDLE_STMT As Long = 3
Private Const SQL_HANDLE_DESC As Long = 4

Private Const SQL_ATTR_ODBC_VERSION As Long = 200
Private Const SQL_OV_ODBC3 As Long = 3
Private Const SQL_IS_INTEGER As Long = (-6)
Private Const ODBC_ADD_DSN As Long = 1
Private Const ODBC_BOTH_DSN As Long = 0
Private Const ODBC_USER_DSN As Long = 1
Private Const ODBC_SYSTEM_DSN As Long = 2
Private Const SQL_NEED_DATA As Long = 99
Private Const SQL_ERROR As Long = -1

#If Win64 Then
Private Declare PtrSafe Function SQLAllocEnv Lib "odbc32.dll" (ByRef phenv As LongPtr) As Integer
Private Declare PtrSafe Function SQLFreeEnv Lib "odbc32.dll" (ByVal hEnv As LongPtr) As Integer
Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Declare PtrSafe Function SQLDrivers Lib "odbc32.dll" _
                                    (ByVal hEnv As LongPtr, _
                                     ByVal fDirection As Integer, _
                                     ByVal szDriverDesc As String, _
                                     ByVal cbDriverDescMax As Integer, _
                                     pcbDriverDesc As Integer, _
                                     ByVal szDriverAttr As String, _
                                     ByVal cbDrvrAttrMax As Integer, _
                                     pcbDrvrAttr As Integer) As Integer

#Else
Declare Function SQLAllocEnv Lib "odbc32.dll" (phenv As Long) As Integer
Declare Function SQLFreeEnv Lib "odbc32.dll" (ByVal hEnv As Long) As Integer
Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Declare Function SQLDrivers Lib "odbc32.dll" _
                                    (ByVal hEnv As Long, _
                                     ByVal fDirection As Integer, _
                                     ByVal szDriverDesc As String, _
                                     ByVal cbDriverDescMax As Integer, _
                                     pcbDriverDesc As Integer, _
                                     ByVal szDriverAttr As String, _
                                     ByVal cbDrvrAttrMax As Integer, _
                                     pcbDrvrAttr As Integer) As Integer

#End If



'Gibt eine Liste aller im System installierten ODBC-Treiber in einem String-Array zur|fffd|ck
'Bsp.: ListODBCDrivers(0) >> "Microsoft Access-Treiber (*.mdb)"
Public Function ListODBCDrivers() As String()
    Dim ret As Long
    Dim j As Long
#If Win64 Then
    Dim hEnv As LongPtr
#Else
    Dim hEnv As Long
#End If
    Dim arrDrv() As String
    Dim strDriver As String * 512
    Dim strAttrib As String * 512
    Dim lDrv As Integer
    Dim lAtr As Integer

    ret = SQLAllocEnv(hEnv)
    Do While ret = SQL_SUCCESS
        ret = SQLDrivers(hEnv, SQL_FETCH_NEXT, strDriver, 512, lDrv, strAttrib, 512, lAtr)
        If ret <> SQL_NO_DATA_FOUND Then
            ReDim Preserve arrDrv(j)
            arrDrv(j) = Left(strDriver, lDrv)
'            Debug.Print "D:" & arrDrv(j)
            j = j + 1
        End If
    Loop
    ListODBCDrivers = arrDrv
    Call SQLFreeEnv(hEnv)

End Function




Public Function GetDriverDLL(strDriverName) As String
  Dim s As String
  s = RegKeyRead("HKEY_CURRENT_USER\SOFTWARE\ODBC\ODBC.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBC.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_CLASSES_ROOT\SOFTWARE\ODBC\ODBC.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If
  
  s = RegKeyRead("HKEY_CURRENT_USER\SOFTWARE\ODBC\ODBCINST.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_CLASSES_ROOT\SOFTWARE\ODBC\ODBCINST.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If
  
  s = RegKeyRead("HKEY_CURRENT_USER\SOFTWARE\WOW6432Node\ODBC\ODBC.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\ODBC\ODBC.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_CLASSES_ROOT\SOFTWARE\WOW6432Node\ODBC\ODBC.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If
  
  
  s = RegKeyRead("HKEY_CURRENT_USER\SOFTWARE\WOW6432Node\ODBC\ODBCINST.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\ODBC\ODBCINST.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If

  s = RegKeyRead("HKEY_CLASSES_ROOT\SOFTWARE\WOW6432Node\ODBC\ODBCINST.INI\" & strDriverName & "\DRIVER")
  If s <> "" Then
    GetDriverDLL = s
    Exit Function
  End If
  
End Function

Private Function RegKeyRead(i_RegKey As String) As String
Dim myWS As Object

  On Error Resume Next
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'read key from registry
  RegKeyRead = myWS.RegRead(i_RegKey)
End Function





Attribute VB_Name = "Globals"
Option Explicit

#If Win64 Then
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If

Public G_Y As Long

        Dim G_pw As String
        Dim G_usr As String
        


' Get Database Connection
Function GetConnection(ByRef errtxt As String, Optional ByVal waitendless As Boolean = False) As Object

        errtxt = ""
        Err.Clear
        On Error Resume Next
        
        Dim conn As Object
        Set conn = CreateObject("ADODB.Connection")
        conn.CursorLocation = 3
        Set GetConnection = Nothing
        Dim cnt As Long
        cnt = 0

        Dim tim As Single
        tim = Timer
checkAgain:
        conn.ConnectionTimeout = 5
        
        ' Read the User and the password from cell B3 and B4
        Dim conString As String
        
        
        If Tabelle1.ComboBox1.Value = "MS-SQL" Then
          conString = "Driver={" & Tabelle1.ComboBox2 & "};Server=" & Cells(5, 2) & ";Port=" & IIf(Cells(6, 2) <> "", Cells(6, 2), "1433") & ";Database=" & Cells(7, 2) & ";"
        Else
          conString = "Driver={" & Tabelle1.ComboBox2 & "};dbq=" & Cells(5, 2) & ":" & IIf(Cells(6, 2) <> "", Cells(6, 2), "1521") & IIf(Cells(7, 2) <> "", "/" & Cells(7, 2), "") & ";"
        End If
        
        If Tabelle1.Cells(8, 2) = "" Then
          G_usr = InputBox("Bitte geben Sie den Username des technischen Users der Datenbank ein", "User", G_usr)
          If G_usr = "" Then Exit Function
        Else
          G_usr = Tabelle1.Cells(8, 2)
        End If
        If Tabelle1.Cells(9, 2) = "" Then
          G_pw = InputBox("Bitte geben Sie das Passwort des technischen Users der Datenbank ein", "Passwort", G_pw)
          If G_pw = "" Then Exit Function
        Else
          G_pw = Tabelle1.Cells(9, 2)
        End If
        
        conn.Open conString, G_usr, G_pw
        
        ' Any errror? Try again!
        If Err.Number <> 0 Then
            errtxt = Err.Number & " - " & Err.Description
            Err.Clear
            Sleep 100
            cnt = cnt + 1
            If Not waitendless Then
                If cnt > 5 Then
                    Set conn = Nothing
                    Exit Function
                End If
                GoTo checkAgain
            End If
        End If
        
        ' Ok, thats it
        Err.Clear
        Set GetConnection = conn

End Function


Attribute VB_Name = "Hash"
Option Explicit

Private Const BITS_TO_A_BYTE = 8
Private Const BYTES_TO_A_WORD = 4
Private Const BITS_TO_A_WORD = 32

Function GetFileHash(ByVal uncpathfname As String) As String

    If Mid(uncpathfname, 2, 1) <> ":" Then
        GetFileHash = SHA256(uncpathfname)
'        GetFileHash = SHA256(uncpathfname & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    Else
        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName)
'        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    End If

End Function

Private Function LShift(lValue, iShiftBits)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

Dim m_l2Power
m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)


    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
    End If
End Function



Private Function RShift(lValue, iShiftBits)

  Dim m_l2Power
  m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)

    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function



Private Function AddUnsigned(lX, lY)
    Dim lX4, lY4, lX8, lY8, lResult
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function



Private Function Ch(x, y, z)
    Ch = ((x And y) Xor ((Not x) And z))
End Function



Private Function Maj(x, y, z)
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function



Private Function s(x, n)
Dim m_lOnBits, m_l2Power, k
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)
k = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)

    s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function



Private Function r(x, n)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

    r = RShift(x, CLng(n And m_lOnBits(4)))
End Function



Private Function Sigma0(x)
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function



Private Function Sigma1(x)
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function



Private Function Gamma0(x)
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor r(x, 3))
End Function



Private Function Gamma1(x)
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor r(x, 10))
End Function



Private Function ConvertToWordArray(sMessage)
    Dim lMessageLength, lNumberOfWords, lWordArray(), lBytePosition, lByteCount
    Dim lWordCount, lByte
    
    Const MODULUS_BITS = 512
    Const CONGRUENT_BITS = 448
    
    lMessageLength = Len(sMessage)
    
    lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)

    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function



Public Function SHA256(sMessage)

Dim k
k = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)
    Dim Hash, m, W(63), A, B, c, d, e, f, g, h, i, j, T1, t2
    
    Hash = Array(&H6A09E667, &HBB67AE85, &H3C6EF372, &HA54FF53A, &H510E527F, &H9B05688C, &H1F83D9AB, &H5BE0CD19)
    
    m = ConvertToWordArray(sMessage)
    
    For i = 0 To UBound(m) Step 16
        A = Hash(0)
        B = Hash(1)
        c = Hash(2)
        d = Hash(3)
        e = Hash(4)
        f = Hash(5)
        g = Hash(6)
        h = Hash(7)
        
        For j = 0 To 63
            If j < 16 Then
                W(j) = m(j + i)
            Else
                W(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(W(j - 2)), W(j - 7)), Gamma0(W(j - 15))), W(j - 16))
            End If
                
            T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), Ch(e, f, g)), k(j)), W(j))
            t2 = AddUnsigned(Sigma0(A), Maj(A, B, c))
            
            h = g
            g = f
            f = e
            e = AddUnsigned(d, T1)
            d = c
            c = B
            B = A
            A = AddUnsigned(T1, t2)
        Next
        
        Hash(0) = AddUnsigned(A, Hash(0))
        Hash(1) = AddUnsigned(B, Hash(1))
        Hash(2) = AddUnsigned(c, Hash(2))
        Hash(3) = AddUnsigned(d, Hash(3))
        Hash(4) = AddUnsigned(e, Hash(4))
        Hash(5) = AddUnsigned(f, Hash(5))
        Hash(6) = AddUnsigned(g, Hash(6))
        Hash(7) = AddUnsigned(h, Hash(7))
    Next
    
    SHA256 = LCase(Right("00000000" & Hex(Hash(0)), 8) & Right("00000000" & Hex(Hash(1)), 8) & Right("00000000" & Hex(Hash(2)), 8) & Right("00000000" & Hex(Hash(3)), 8) & Right("00000000" & Hex(Hash(4)), 8) & Right("00000000" & Hex(Hash(5)), 8) & Right("00000000" & Hex(Hash(6)), 8) & Right("00000000" & Hex(Hash(7)), 8))
End Function

Public Function Hash32Bit(ByVal s As String) As Long

    Dim h As Long
    h = 0
    
    Dim i As Long
    For i = 1 To Len(s)
      h = 31 * h + Asc(Mid(s, i, 1))
      h = h And &HFFFFF
    Next i
    Hash32Bit = h
End Function



Attribute VB_Name = "Helpers"
Option Explicit
#If Win64 Then
Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#Else
Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
#End If
Function WorksheetExists(wb As Workbook, ByVal wsname As String)
  On Error GoTo doesntExist
  WorksheetExists = False
  
  Dim s As String
  s = wb.Sheets(wsname).name
  WorksheetExists = True
  Exit Function
doesntExist:
End Function

Sub CreateNewSheet(ByVal sheetname As String)
  If WorksheetExists(ThisWorkbook, sheetname) Then
    Sheets(sheetname).Delete
  End If
  Sheets.Add After:=Sheets(Sheets.Count)
  Sheets(Sheets.Count).name = sheetname
End Sub

Public Function GetComputerName() As String
'Returns the computername
    Dim lngLen As Long, lngX As Long
    Dim strCompName As String
    lngLen = 16
    strCompName = String$(lngLen, 0)
    lngX = apiGetComputerName(strCompName, lngLen)
    If lngX <> 0 Then
        GetComputerName = Left$(strCompName, lngLen)
    Else
        GetComputerName = ""
    End If
End Function

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "TestRead, 1, 0, MSForms, CommandButton"
Attribute VB_Control = "AbortRead, 16, 1, MSForms, CommandButton"
Attribute VB_Control = "ComboBox1, 8, 2, MSForms, ComboBox"
Attribute VB_Control = "ComboBox2, 9, 3, MSForms, ComboBox"
Attribute VB_Control = "Label1, 10, 4, MSForms, Label"
Attribute VB_Control = "Label2, 11, 5, MSForms, Label"
Attribute VB_Control = "TestConnection, 13, 6, MSForms, CommandButton"
Attribute VB_Control = "Label3, 17, 7, MSForms, Label"
Attribute VB_Control = "Label4, 18, 8, MSForms, Label"
Option Explicit

Dim G_Abbruch As Boolean

Const Zeile_Status = 16
Const Zeile_AktuelleDatei = 19
Const Zeile_|fffd|ndern = 14

Const Zeile_PfadeY = 6
Const Zeile_PfadeX = 6


Public Function LongFileName(ByVal short_name As String) As _
    String
Dim pos As Integer
Dim Result As String
Dim long_name As String

    ' Start after the drive letter if any.
    If Mid$(short_name, 2, 1) = ":" Then
        Result = Left$(short_name, 2)
        pos = 3
    Else
        Result = ""
        pos = 1
    End If

    ' Consider each section in the file name.
    Do While pos > 0
        ' Find the next \.
        pos = InStr(pos + 1, short_name, "\")

        ' Get the next piece of the path.
        If pos = 0 Then
            long_name = Dir$(short_name, vbNormal + _
                vbHidden + vbSystem + vbDirectory)
            If long_name = "" Then
              pos = InStrRev(short_name, "\")
              If pos > 0 Then
                long_name = Mid(short_name, pos + 1)
                pos = 0
              End If
            End If
        Else
            long_name = Dir$(Left$(short_name, pos - 1), _
                vbNormal + vbHidden + vbSystem + _
                vbDirectory)
        End If
        Result = Result & "\" & long_name
    Loop

    LongFileName = Result
End Function


Private Sub AbortRead_Click()
  G_Abbruch = True
End Sub

Private Sub ComboBox2_Change()
  Cells(4, 3) = LongFileName(GetDriverDLL(ComboBox2))
End Sub

Private Sub TestConnection_Click()
  Dim o As Object
  Dim errstr As String
  Set o = GetConnection(errstr)
  If Not o Is Nothing Then
    Cells(11, 2).Value = "Verbindung erfolgreich! (" & Now & ")"
    o.Close
    Set o = Nothing
  Else
    Cells(11, 2).Value = "Verbindung nicht erfolgreich! (" & Now & ")" & vbCrLf & "Fehler: " & errstr
  End If
End Sub

Private Sub TestRead_Click()
  
  G_Abbruch = False
  
  
  Dim pfadAlt As String
  Dim pfadNeu As String
  Dim pfady As Long
  Dim pfadAltUnten As String
  Dim pfadyUnten As Long
  Dim pfadyNeu As Long
  
  
  ' Plausitest der Pfad ALT NEU NEU ALT!
  Tabelle1.Cells(Zeile_Status, 2) = "Plausitest Pfade..."
  
  Dim plausitestOK As Boolean
  plausitestOK = True
  
  pfady = Zeile_PfadeY
  Do While IsEmpty(Cells(pfady, Zeile_PfadeX)) = False And IsEmpty(Cells(pfady + 1, Zeile_PfadeX)) = False
      pfadAlt = UCase(Tabelle1.Cells(pfady, Zeile_PfadeX))
      If Left(pfadAlt, 1) = "'" Then pfadAlt = Mid(pfadAlt, 2, 1000)
      
      ' Jetzt alle Pfade unterhalb testen
      pfadyNeu = Zeile_PfadeY
      Do While Not IsEmpty(Cells(pfadyNeu, Zeile_PfadeX + 1))
        pfadNeu = UCase(Tabelle1.Cells(pfadyNeu, Zeile_PfadeX + 1))
        If Left(pfadNeu, 1) = "'" Then pfadNeu = Mid(pfadNeu, 2, 1000)
        
        ' Wenn der neue Pfad im alten enthalten ist oder der alte im neuen, dann kann man den Vorgang nur ein mal machen!!!
        If (Len(pfadNeu) > Len(pfadAlt) And Left(pfadNeu, Len(pfadAlt)) = pfadAlt) Or (Len(pfadNeu) <= Len(pfadAlt) And Left(pfadAlt, Len(pfadNeu)) = pfadNeu) Then
          ' MsgBox "ACHTUNG: Der Alt-Pfad in Zeile " & pfady & " (" & pfadAlt & ") ist komplett im Pfad Zeile " & pfadyNeu & " (" & pfadNeu & ") enthalten! Das w|fffd|rde dazu f|fffd|hren, dass die Zeile " & pfadyNeu & " nie ber|fffd|cksichtigt werden kann. Bitte tauschen Sie ggf. einfach die beiden Zeilen, damit der l|fffd|ngere/detaillierte Pfad zuerst Ber|fffd|cksichtigung findet. Der Vorgang wird abgebrochen."
          Dim resultprob As String
          If Len(pfadNeu) > Len(pfadAlt) And Left(pfadNeu, Len(pfadAlt)) = pfadAlt Then
            resultprob = "Alt-Pfad Zeile " & pfady & " (" & pfadAlt & ") ist im Pfad Neu Zeile " & pfadyNeu & " (" & pfadNeu & ") enthalten!"
          Else
            resultprob = "Pfad Neu Zeile " & pfadyNeu & " (" & pfadNeu & ") ist im Alt-Pfad Zeile " & pfady & " (" & pfadAlt & ") enthalten!"
          End If
          MsgBox "ACHTUNG: In Ihren Pfaden sind Pfade enthalten, bei denen ein mehrmaliges Schreiben der Werte zu Problemen f|fffd|hren wird! Testen k|fffd|nnen Sie so oft Sie m|fffd|chten, nur das Schreiben darf nur ein mal ausgef|fffd|hrt werden!" & vbCrLf & vbCrLf & _
            resultprob
          plausitestOK = False
          Exit Do
        End If
        pfadyNeu = pfadyNeu + 1
      Loop
      If plausitestOK = False Then Exit Do
      pfady = pfady + 1
  Loop
  
  
  
  ' Plausitest der Pfade!
  
  Tabelle1.Cells(Zeile_Status, 2) = "Plausitest Pfade..."
  
  plausitestOK = True
  
  pfady = Zeile_PfadeY
  Do While IsEmpty(Cells(pfady, Zeile_PfadeX)) = False And IsEmpty(Cells(pfady + 1, Zeile_PfadeX)) = False
      pfadAlt = UCase(Tabelle1.Cells(pfady, Zeile_PfadeX))
      If Left(pfadAlt, 1) = "'" Then pfadAlt = Mid(pfadAlt, 2, 1000)
      
      ' Jetzt alle Pfade unterhalb testen
      pfadyUnten = pfady + 1
      Do While Not IsEmpty(Cells(pfadyUnten, Zeile_PfadeX))
        pfadAltUnten = UCase(Tabelle1.Cells(pfadyUnten, Zeile_PfadeX))
        If Left(pfadAltUnten, 1) = "'" Then pfadAltUnten = Mid(pfadAltUnten, 2, 1000)
        
        ' Wenn der untere pfad GR|fffd|SSER als der obere ist UND der obere im unteren enthalten ist haben wir ein Problem!
        If Len(pfadAltUnten) > Len(pfadAlt) And Left(pfadAltUnten, Len(pfadAlt)) = pfadAlt Then
          ' MsgBox "ACHTUNG: Der Alt-Pfad in Zeile " & pfady & " (" & pfadAlt & ") ist komplett im Pfad Zeile " & pfadyUnten & " (" & pfadAltUnten & ") enthalten! Das w|fffd|rde dazu f|fffd|hren, dass die Zeile " & pfadyUnten & " nie ber|fffd|cksichtigt werden kann. Bitte tauschen Sie ggf. einfach die beiden Zeilen, damit der l|fffd|ngere/detaillierte Pfad zuerst Ber|fffd|cksichtigung findet. Der Vorgang wird abgebrochen."
          MsgBox "ACHTUNG: Der Alt-Pfad in Zeile " & pfady & " (" & pfadAlt & ") ist komplett im Pfad Zeile " & pfadyUnten & " (" & pfadAltUnten & ") enthalten! Dies w|fffd|rde dazu f|fffd|hren, dass die Zeile " & pfadyUnten & " nie ber|fffd|cksichtigt wird." & vbCrLf & vbCrLf & "Die Pfade werden jetzt einmalig so sortiert, sodass sich keine Fehler mehr ergeben!"
          plausitestOK = False
          Exit Do
        End If
        pfadyUnten = pfadyUnten + 1
      Loop
      If plausitestOK = False Then Exit Do
      pfady = pfady + 1
  Loop
  
  If Not plausitestOK Then
    Tabelle1.Cells(Zeile_Status, 2) = "Sortiere Pfade..."
  
goAgain:
    pfady = Zeile_PfadeY
    Do While IsEmpty(Cells(pfady, Zeile_PfadeX)) = False And IsEmpty(Cells(pfady + 1, Zeile_PfadeX)) = False
        pfadAlt = UCase(Tabelle1.Cells(pfady, Zeile_PfadeX))
        If Left(pfadAlt, 1) = "'" Then pfadAlt = Mid(pfadAlt, 2, 1000)
        
        ' Jetzt alle Pfade unterhalb testen
        pfadyUnten = pfady + 1
        Do While Not IsEmpty(Cells(pfadyUnten, Zeile_PfadeX))
          pfadAltUnten = UCase(Tabelle1.Cells(pfadyUnten, Zeile_PfadeX))
          
          If Left(pfadAltUnten, 1) = "'" Then pfadAltUnten = Mid(pfadAltUnten, 2, 1000)
          
          ' Wenn der untere pfad GR|fffd|SSER als der obere ist UND der obere im unteren enthalten ist haben wir ein Problem!
          If Len(pfadAltUnten) > Len(pfadAlt) And Left(pfadAltUnten, Len(pfadAlt)) = pfadAlt Then
            ' MsgBox "ACHTUNG: Der Alt-Pfad in Zeile " & pfady & " (" & pfadAlt & ") ist komplett im Pfad Zeile " & pfadyUnten & " (" & pfadAltUnten & ") enthalten! Das w|fffd|rde dazu f|fffd|hren, dass die Zeile " & pfadyUnten & " nie ber|fffd|cksichtigt werden kann. Bitte tauschen Sie ggf. einfach die beiden Zeilen, damit der l|fffd|ngere/detaillierte Pfad zuerst Ber|fffd|cksichtigung findet. Der Vorgang wird abgebrochen."
            Tabelle1.Cells(Zeile_Status, 2) = "Tausche Zeile " & pfady & " gegegen " & pfadyUnten
            
            pfadAlt = Cells(pfady, Zeile_PfadeX)
            pfadNeu = Cells(pfady, Zeile_PfadeX + 1)
            Cells(pfady, Zeile_PfadeX) = Cells(pfadyUnten, Zeile_PfadeX)
            Cells(pfady, Zeile_PfadeX + 1) = Cells(pfadyUnten, Zeile_PfadeX + 1)
            Cells(pfadyUnten, Zeile_PfadeX) = pfadAlt
            Cells(pfadyUnten, Zeile_PfadeX + 1) = pfadNeu
            
            GoTo goAgain
          End If
          pfadyUnten = pfadyUnten + 1
        Loop
        pfady = pfady + 1
    Loop
  End If
  
  Tabelle1.Cells(Zeile_Status, 2) = "Starte..."
  
  
  Dim aendern As Boolean
  aendern = False
  
  If Tabelle1.Cells(Zeile_|fffd|ndern, 2) = "JA" Then
    If MsgBox("ACHTUNG: Bitte best|fffd|tigen Sie, dass Sie ein aktuelles Backup der Datenbank erzeugt haben! Der Vorgang wird ansonsten abgebrochen!", vbYesNo) = vbNo Then
      Tabelle1.Cells(Zeile_Status, 2) = "ABBRUCH! Bitte erzeugen Sie ein Backup der DB!"
      Exit Sub
    End If
    aendern = True
  End If
  
  
  ' Open the connection to the database
  Dim conn As Object
  Dim errstr As String
  Set conn = GetConnection(errstr)
  
  Dim drs As Object
  Set drs = CreateObject("ADODB.Recordset")
  Dim drstest As Object
  Set drstest = CreateObject("ADODB.Recordset")

  ' Very simple open: "SELECT * FROM tablename" - Get the tablename from B5 - this is only a READ-ONLY test
  On Error GoTo nogo
  
'  drs.Open "Select idvDateiID, Dateiname, Hash, Geloescht from idvDateien where idvdateiid >= 37875", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
  drs.Open "Select idvDateiID, Dateiname, Hash, Geloescht from idvDateien", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
  
  Dim dsGeaendert As Long
  Dim dsNichtGeaendertWeilExistent As Long
  
  
  Dim y As Long
  y = 2
  Dim cnt As Long
  cnt = 0
  ' Any data in the table?
  Do While Not drs.EOF
  
    cnt = cnt + 1
    If cnt Mod 20 = 0 Then
      Tabelle1.Cells(Zeile_AktuelleDatei, 1) = "ID: " & drs("idvDateiID").Value & " - " & drs("Dateiname").Value
    End If
    
    Dim foundPfad As Boolean
    foundPfad = False
    
    pfady = Zeile_PfadeY
    
    Do While Not IsEmpty(Cells(pfady, Zeile_PfadeX))
        pfadAlt = Tabelle1.Cells(pfady, Zeile_PfadeX)
        If Left(pfadAlt, 1) = "'" Then pfadAlt = Mid(pfadAlt, 2, 1000)
        pfadNeu = Tabelle1.Cells(pfady, Zeile_PfadeX + 1)
        If Left(pfadNeu, 1) = "'" Then pfadNeu = Mid(pfadNeu, 2, 1000)
        If UCase(Left(drs("Dateiname").Value, Len(pfadAlt))) = UCase(pfadAlt) Then
          foundPfad = True
          Exit Do
        End If
        pfady = pfady + 1
    
    Loop
    
    
    ' Wenn der alte Pfad im Dateinamen vorhanden ist
    If foundPfad Then
      Dim filename As String
      ' Ist es noch ein alter UCase Dateiname???
      If UCase(drs("Dateiname").Value) = drs("Dateiname").Value Then
        filename = UCase(pfadNeu) & Mid(drs("Dateiname").Value, Len(pfadAlt) + 1, 1000)
      Else
        filename = pfadNeu & Mid(drs("Dateiname").Value, Len(pfadAlt) + 1, 1000)
      End If
      
      Dim newhash As String
      newhash = GetFileHash(filename)
      
      ' jetzt muss noch gepr|fffd|ft werden, ob es die neue Datei schon gibt! Falls ja wird NIX gemacht
      
      Dim fileEx As Boolean
      fileEx = False
      
      ' Nur pr|fffd|fen, wenn die Datei nicht gel|fffd|scht ist
      If drs("Geloescht").Value = 0 Then
        drstest.Open "Select idvDateiID, Dateiname, Hash from idvDateien where geloescht = 0 and hash = '" & newhash & "' AND idvdateiid <> " & drs("idvDateiID").Value, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
        Do While Not drstest.EOF
          If UCase(drstest("Dateiname").Value) = UCase(filename) Then
            fileEx = True
            Exit Do
          End If
          drstest.MoveNext
        Loop
        drstest.Close
      End If
      
      Tabelle2.Cells(y, 1) = drs("idvDateiID").Value
      Tabelle2.Cells(y, 3) = drs("Dateiname").Value
      Tabelle2.Cells(y, 4) = filename
      
'      Debug.Print newhash
      
      If fileEx Then
        Tabelle2.Cells(y, 2) = "Neuere Datei existiert, KEINE |fffd|NDERUNG!"
        dsNichtGeaendertWeilExistent = dsNichtGeaendertWeilExistent + 1
      Else
        dsGeaendert = dsGeaendert + 1
        If aendern Then
          Tabelle1.Cells(Zeile_Status, 2) = "Ge|fffd|ndert: " & dsGeaendert
          Tabelle2.Cells(y, 2) = "Ge|fffd|ndert"
          If aendern Then
            drs("Dateiname").Value = filename
            drs("Hash").Value = newhash
            drs.Update
          End If
        Else
          Tabelle1.Cells(Zeile_Status, 2) = "W|fffd|rde ge|fffd|ndert: " & dsGeaendert
          Tabelle2.Cells(y, 2) = "W|fffd|rde ge|fffd|ndert"
        End If
      End If
      y = y + 1
      
    End If
    drs.MoveNext
    DoEvents
    If G_Abbruch Then Exit Do
  Loop
      
  drs.Close
   
  Set drs = Nothing
  Set drstest = Nothing
  
  ' Close connection
  conn.Close
  Set conn = Nothing

  Dim restxt As String
  restxt = "FERTIG"
  
  If G_Abbruch Then
    restxt = "ABBRUCH"
  End If
  
  If aendern Then
    Tabelle1.Cells(Zeile_Status, 2) = restxt & "! Anzahl ge|fffd|nderter Dateien: " & dsGeaendert & vbCrLf & "Nicht ge|fffd|ndert weil schon existent: " & dsNichtGeaendertWeilExistent
  Else
    Tabelle1.Cells(Zeile_Status, 2) = restxt & "! Anzahl Dateien, die ge|fffd|ndert werden w|fffd|rden: " & dsGeaendert & vbCrLf & "Nicht |fffd|ndern weil schon existent: " & dsNichtGeaendertWeilExistent
  End If

  Exit Sub
nogo:
  MsgBox "FEHLER: " & Err.Description
End Sub


Function fileExists(ByVal Dateiname$) As Boolean
  If Dateiname = "" Then
    fileExists = False
    Exit Function
  End If
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo Fehler:
  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    fileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    fileExists = res
  End If
    Exit Function
Fehler:
    fileExists = False
    Resume Next
End Function
Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .Send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim s As String
        s = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        s = Left(s, Len(s) - 4)
        modDate = CDate(s)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print Err.Description
    Set Request = Nothing
End Function

Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "UNC"
Option Explicit

' Fuer CacheMappedDrives()
'Dim mMappedDrives As Collection
Dim mMappedDrives(0 To 25) As String
Dim mUsedDriveLetters(0 To 25) As String
Dim mNumUsedDrives As Integer
    


#If VBA7 Then
Public Declare PtrSafe Function WNetGetConnectionA Lib "mpr.dll" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#Else
Public Declare Function WNetGetConnectionA Lib "mpr.dll" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#End If
                                                   
                                                  

Public Function GetUNCPath(ByVal sLocalPath As String) As String
    '// -----------------------------------------------------------------
    '// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
    '// -----------------------------------------------------------------
    '// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..)
    '// -----------------------------------------------------------------
    '// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
    '//            | bei Fehler = sLocalPath
    '// -----------------------------------------------------------------
    Const NO_ERROR As Long = 0
    Dim sUNCPath As String
    Dim sResult As String
    Dim sDrive As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
    '// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = Left$(sLocalPath, 2)
    sUNCPath = Space$(260)
    If WNetGetConnectionA(sDrive, sUNCPath, Len(sUNCPath)) = NO_ERROR Then
        sResult = Left$(sUNCPath, InStr(sUNCPath, vbNullChar) - 1)
        If Len(sResult) > 0 Then
            GetUNCPath = sResult & Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Sub CacheMappedDrives()
    mNumUsedDrives = 0
    Dim i As Integer
    For i = 65 To 90
        Dim strUNCPath As String
        strUNCPath = ""
        If GetUNCPathShort(Chr(i) & ":", strUNCPath) = 0 Then
            mMappedDrives(mNumUsedDrives) = UCase(strUNCPath)
            mUsedDriveLetters(mNumUsedDrives) = Chr(i)
            mNumUsedDrives = mNumUsedDrives + 1
        Else
        
        End If
    Next i
End Sub

' Wir nehmen an uncPath ist all upper case
Public Function GetCachedMappedDrive(uncPath As String) As String
    GetCachedMappedDrive = uncPath
    Dim i As Integer
    For i = 0 To mNumUsedDrives - 1
        If mMappedDrives(i) = Left$(uncPath, Len(mMappedDrives(i))) Then
            GetCachedMappedDrive = mUsedDriveLetters(i) & ":" & Mid$(uncPath, Len(mMappedDrives(i)) + 1)
            Exit For
        End If
    Next i
End Function

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim s As String

    s = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnectionA(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        If InStr(strRemoteName, Chr(0)) > 0 Then
          strUNCPath = Left(strRemoteName, InStr(strRemoteName, Chr(0)) - 1)
        Else
          strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        End If
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function







INQUEST-PP=macro
