Attribute VB_Name = "CAutoColor"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public WithEvents App As Application
Attribute App.VB_VarHelpID = -1

Private Sub App_SheetChange(ByVal Sh As Object, ByVal Target As Range)
  On Error Resume Next
  Application.ScreenUpdating = False
  'If wksMenu.Range("AutoColor").Value Then
    AutoColorRange Target
  'End If
  Application.ScreenUpdating = True
End Sub
Attribute VB_Name = "CShortcutControls"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'' J Peltier, Peltier Technical Services, Inc., http://peltiertech.com
'' Code for shortcut key functionality

Option Explicit

Public WithEvents ChkShortcut As msforms.CheckBox
Attribute ChkShortcut.VB_VarHelpID = -1
Public WithEvents TxtShortcut As msforms.TextBox
Attribute TxtShortcut.VB_VarHelpID = -1

Public frm As Object

Private Sub ChkShortcut_Change()
  ValidateShortcuts Me.frm
End Sub

Private Sub TxtShortcut_Change()
  With TxtShortcut
    If Len(.Text) > 1 Then
      .Text = UCase$(.Text)
      .Text = Left$(.Text, 1)
      .SelStart = 1
      .SelLength = 1
    End If
  End With
  ValidateShortcuts Me.frm
End Sub

Attribute VB_Name = "FAutocolorFirstUse"
Attribute VB_Base = "0{40139DE8-4004-437B-8FB3-13E39A8C776B}{0C1EF17A-40F7-4C6D-BC19-C7AC01A7234F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub btnUndo_Click()
  ThisWorkbook.Names(sAutoColorUndoShow).RefersToRange.Value = Not Me.chkDontShowAgain.Value
  ThisWorkbook.Save
  
  Unload Me
End Sub

'Private Sub UserForm_Initialize()
'  If Not ThisWorkbook.Names(sAutoColorUndoShow).RefersToRange.Value Then
'    Unload Me
'  End If
'End Sub
Private Sub UserForm_Click()

End Sub
Attribute VB_Name = "FPrecedentAnalyzer"
Attribute VB_Base = "0{0C1AAC1E-21C9-4DC9-9869-DF57AFEBFEA6}{B7DAFE92-5699-4F14-B44F-4B016F6EFB52}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'' Required Win32 API Declarations
'Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
'Private Declare Function SetFocus Lib "user32" (ByVal hWnd As Long) As Long
'Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hWnd As Long, lpdwProcessId As Long) As Long
'Private Declare Function AttachThreadInput Lib "user32" (ByVal idAttach As Long, ByVal idAttachTo As Long, ByVal fAttach As Long) As Long
'Private Declare Function GetForegroundWindow Lib "user32" () As Long
'Private Declare Function SetForegroundWindow Lib "user32" (ByVal hWnd As Long) As Long
'Private Declare Function IsIconic Lib "user32" (ByVal hWnd As Long) As Long
'Private Declare Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
''
'' Constants used with APIs
'Private Const SW_SHOW = 5
'Private Const SW_RESTORE = 9

Private mbJump As Boolean
Private msFullAddress As String
Private msAddress As String
Private miListIndex As Long
Private mrActive As Range

Private WithEvents mWS As Worksheet
Attribute mWS.VB_VarHelpID = -1
Private WithEvents mWB As Workbook
Attribute mWB.VB_VarHelpID = -1

Public Property Set Cell(rCell As Range)
  Dim sGetAddress As String

  Set mWS = rCell.Parent
  Set mWB = mWS.Parent

  sGetAddress = GetAddress(rCell)
  msFullAddress = Left$(sGetAddress, InStr(sGetAddress, "|") - 1)
  msAddress = Mid$(sGetAddress, InStr(sGetAddress, "|") + 1)

  Me.lblCellAddress.Caption = "  " & msAddress
  Me.lblCellValue.Caption = "  " & rCell.Text
  Me.txtCellFormula.Text = rCell.Formula

  PopulatePrecedents rCell

End Property

Private Sub btnClose_Click()
  Set mWS = Nothing
  Set mWB = Nothing
  Me.Hide
End Sub

Private Sub lblCellAddress_DblClick(ByVal Cancel As msforms.ReturnBoolean)
  VisitRange Me.lblCellAddress.Caption
End Sub

Private Sub lstPrecedents_Change()
  If mbJump Then
    If Me.lstPrecedents.ListIndex >= 0 Then
      VisitRange Me.lstPrecedents.List(Me.lstPrecedents.ListIndex, 0), False
    End If
  End If
End Sub

Private Sub lstPrecedents_DblClick(ByVal Cancel As msforms.ReturnBoolean)
  VisitRange Me.lstPrecedents.List(Me.lstPrecedents.ListIndex, 0)
End Sub

Private Sub lstPrecedents_KeyDown(ByVal KeyCode As msforms.ReturnInteger, ByVal Shift As Integer)
  If KeyCode = 13 Then
    If Me.lstPrecedents.ListIndex >= 0 Then
      VisitRange Me.lstPrecedents.List(Me.lstPrecedents.ListIndex, 0)
    End If
  ElseIf KeyCode = vbKeyHome And Shift = 6 Then
    Application.OnKey "%^{HOME}", "'" & ThisWorkbook.Name & "'!ActivatePrecedentAnalyzer"
    miListIndex = Me.lstPrecedents.ListIndex
    Set mrActive = ActiveCell
    On Error Resume Next
    AppActivate Application.Caption, False
    'MoveExcelToFront
    Beep
    Application.OnTime Now + TimeValue("0:0:1"), "'" & ThisWorkbook.Name & "'!ResetTracerDialogSettings"
    ''Application.ScreenUpdating = False
  End If
End Sub

Private Sub mWB_Activate()
  Dim iList As Long

  mbJump = False
  Me.lblCellAddress.Caption = "  " & msAddress
  With Me.lstPrecedents
    If .ListCount > 0 Then
      If bOriginalCellAtEnd Then
        For iList = 0 To .ListCount - 2
          .List(iList, 2) = .List(iList, 1)
        Next
        .List(.ListCount - 1, 2) = .List(.ListCount - 1, 1) & "     original cell"
      Else
        For iList = 1 To .ListCount - 1
          .List(iList, 2) = .List(iList, 1)
        Next
        .List(0, 2) = .List(0, 1) & "     original cell"
      End If
    End If
  End With
  mbJump = True
End Sub

Private Sub mWB_Deactivate()
  Dim iList As Long

  mbJump = False
  Me.lblCellAddress.Caption = "  " & msFullAddress
  With Me.lstPrecedents
    If .ListCount > 0 Then
      If bOriginalCellAtEnd Then
        For iList = 0 To .ListCount - 2
          .List(iList, 2) = .List(iList, 0)
        Next
        .List(.ListCount - 1, 2) = .List(.ListCount - 1, 0) & "     original cell"
      Else
        For iList = 1 To .ListCount - 1
          .List(iList, 2) = .List(iList, 0)
        Next
        .List(0, 2) = .List(0, 0) & "     original cell"
      End If
    End If
  End With
  mbJump = True
End Sub

Private Sub mWS_Calculate()
  Dim sAddress As String
  Dim rCell As Range
  Dim sPrecedent As String

  sAddress = Me.lblCellAddress.Caption
  If IsRange(sAddress) Then
    Set rCell = Range(sAddress)
    Me.lblCellValue.Caption = "  " & rCell.Text
    Me.txtCellFormula.Text = rCell.Formula
    Me.lblCellValue.Caption = "  " & rCell.Text
  End If

  sPrecedent = Me.lstPrecedents.Value
  PopulatePrecedents rCell
  Me.lstPrecedents.Value = sPrecedent

End Sub

Private Sub PopulatePrecedents(rngCell As Range)
  Dim vPrecedents As Variant
  Dim iList As Long

  mbJump = False

  vPrecedents = NewPrecedents(rngCell)
  If IsArray(vPrecedents) Then
    With Me.lstPrecedents
      .List = vPrecedents
      '      If .ListIndex < 0 Then
      '        .ListIndex = 0
      '      End If
      .SetFocus
      If bOriginalCellAtEnd Then
        'If .ListIndex < 0 Then
        .ListIndex = .ListCount - 1
        'End If
        For iList = 0 To .ListCount - 2
          .List(iList, 2) = .List(iList, 1)
        Next
        .List(.ListCount - 1, 2) = .List(.ListCount - 1, 1) & "     original cell"
        .List(.ListCount - 1, 2) = .List(.ListCount - 1, 1) & "     original cell"
      Else
        'If .ListIndex < 0 Then
        .ListIndex = 0
        'End If
        For iList = 1 To .ListCount - 1
          .List(iList, 2) = .List(iList, 1)
        Next
        .List(0, 2) = .List(0, 1) & "     original cell"
        .List(0, 2) = .List(0, 1) & "     original cell"
      End If
    End With
    'VisitRange Me.lstPrecedents.List(Me.lstPrecedents.ListIndex, 0)
  Else
    Me.lstPrecedents.Clear
  End If

  Me.lstPrecedents.SetFocus
  mbJump = True

End Sub

Private Sub UserForm_Deactivate()
  Application.OnKey "%^{HOME}", "'" & ThisWorkbook.Name & "'!ActivatePrecedentAnalyzer"
End Sub

Private Sub UserForm_Initialize()
  Me.Left = Application.Left + Application.Width - Me.Width - 12
  Me.Top = Application.Top + Application.Height - Me.Height - 12
End Sub

Private Sub UserForm_KeyDown(ByVal KeyCode As msforms.ReturnInteger, ByVal Shift As Integer)
  If KeyCode = vbKeyHome And Shift = 6 Then
    'Me.lstPrecedents.SetFocus
    Application.OnKey "%^{HOME}", "'" & ThisWorkbook.Name & "'!ActivatePrecedentAnalyzer"
    miListIndex = Me.lstPrecedents.ListIndex
    Set mrActive = ActiveCell
    On Error Resume Next
    AppActivate Application.Caption
    'MoveExcelToFront
    Beep
    Application.OnTime Now + TimeValue("0:0:1"), "'" & ThisWorkbook.Name & "'!ResetTracerDialogSettings"
    ''Application.ScreenUpdating = False
  End If
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
  If CloseMode = 0 Then
    Cancel = True
    btnClose_Click
  End If
End Sub

Private Sub VisitRange(sRangeAddress As String, Optional bAppActivate As Boolean = True)

  On Error GoTo ErrorTrap

  Me.lstPrecedents.SetFocus

  Application.GoTo Range(sRangeAddress)

  If ActiveWorkbook.Name = mWB.Name Then
    mWB_Activate
  Else
    mWB_Deactivate
  End If

  If err.Number = 0 Then
    If bAppActivate Then
      AppActivate Application.Caption
    End If
  Else
    MsgBox "Error accessing '" & sRangeAddress & "'."
  End If

ExitProcedure:
  Exit Sub

ErrorTrap:
  If err.Description = "Method 'Goto' of object '_Application' failed" Then
    MsgBox "Cannot activate a range on a hidden worksheet.   ", vbOKOnly + vbExclamation, TTS_TITLE
    GoTo ExitProcedure
  End If
  Resume
End Sub

Public Sub ResetListIndex()
  mbJump = False
  Me.lstPrecedents.ListIndex = miListIndex
  Application.GoTo mrActive
  mbJump = True
End Sub

'Private Sub MoveExcelToFront()
'  Dim xlHwnd As Long
'
'  Debug.Print "w " & GetForegroundWindow
'  xlHwnd = FindWindow(vbNullString, Application.Caption)
'  Debug.Print "x " & xlHwnd
'  'ForceForegroundWindow xlHwnd
'  Debug.Print "y " & GetForegroundWindow
'  SetForegroundWindow xlHwnd
'  Debug.Print "z " & GetForegroundWindow
'
'End Sub

'Private Function ForceForegroundWindow(ByVal hWnd As Long) As Boolean
'   Dim ThreadID1 As Long
'   Dim ThreadID2 As Long
'   Dim nRet As Long
'   '
'   ' Nothing to do if already in foreground.
'   '
'
'   Debug.Print "A " & hWnd
'   Debug.Print "A " & GetForegroundWindow
'
'   If hWnd = GetForegroundWindow() Then
'      ForceForegroundWindow = True
'   Else
'      '
'      ' First need to get the thread responsible for this window,
'      ' and the thread for the foreground window.
'      '
'      ThreadID1 = GetWindowThreadProcessId(GetForegroundWindow, ByVal 0&)
'      ThreadID2 = GetWindowThreadProcessId(hWnd, ByVal 0&)
'      '
'      ' By sharing input state, threads share their concept of
'      ' the active window.
'      '
'      DoEvents
'      If ThreadID1 <> ThreadID2 Then
'         Call AttachThreadInput(ThreadID1, ThreadID2, True)
'         nRet = SetForegroundWindow(hWnd)
'         Call AttachThreadInput(ThreadID1, ThreadID2, False)
'      Else
'         nRet = SetForegroundWindow(hWnd)
'      End If
'
'      Debug.Print "B " & GetForegroundWindow
'      '
'      ' Restore and repaint
'      '
'      DoEvents
'      If IsIconic(hWnd) Then
'         Call ShowWindow(hWnd, SW_RESTORE)
'      Else
'         Call ShowWindow(hWnd, SW_SHOW)
'      End If
'      '
'      ' SetForegroundWindow return accurately reflects success.
'      '
'      Debug.Print "C " & GetForegroundWindow
'      ForceForegroundWindow = CBool(nRet)
'   End If
'End Function
Attribute VB_Name = "M2007UI"
'=========================================================================
' Module    : M2007UI
' Company   : Peltier Technical Services, Inc. for Training The Street
' Author    : Jon Peltier
' Created   : 6-16-2008
' Purpose   : Module for compatibility with Excel 2007 User Interface (Ribbon & Tabs)
'=========================================================================
Option Explicit
'=========================================================================
Function sAddIn2007() As String
  sAddIn2007 = Replace(ThisWorkbook.FullName, ".xla", ".ttsm")
End Function

Sub StartUp()
  
  CheckOldAddIns True
  
  Application.OnTime Now + TimeValue("0:0:2"), "'" & ThisWorkbook.Name & "'!StartUp1"
  
End Sub

Sub StartUp1()
  Dim lReferenceStyle As Long
  ''Dim sAddIn2007 As String

  'remove any prior Turbo Macro Versions
  'Debug.Print Timer & " Calling Add-In Checker"
  CheckOldAddIns False

  ''sAddIn2007 = Replace(ThisWorkbook.FullName, ".xla", ".ttsm")

  If Val(Application.Version) < 9 Then
    MsgBox "TTS Turbo Macros only runs in Excel versions 2000 (Office 9.0) and higher."
    ThisWorkbook.Close False
  End If

  'make sure Autocolor is set to last chosen value
  ''''#### removed JP 2010 08 26

  ''''EventTrapping wksMenu.Range("AutoColor").Value, EVENT_TRAP_AUTOCOLOR

  If Val(Application.Version) >= 12 Then
    If FileExists(sAddIn2007) Then
      lReferenceStyle = Application.ReferenceStyle
      Workbooks.Open sAddIn2007
      Application.ReferenceStyle = lReferenceStyle
    Else
      MsgBox "Cannot find the Excel 2007 version of TTS Turbo Macros."
      ThisWorkbook.Close False
    End If
  Else
    On Error GoTo 0
    AddMenus wksMenu.Range("tblcustommenu1")
  End If

  'set the F1Key - False = Disable
  If Not (wksMenu.Range("F1Key").Value) Then SetF1Key False

  If wksMenu.Range("AutoColor").Value Then
    Set gclsAutoColor.App = Application
  End If

End Sub

Sub CloseDown()
  ''Dim sAddIn2007 As String
  Dim sTBPosition(1 To 6) As String

  On Error Resume Next
  If Val(Application.Version) >= 12 Then
    DoEvents
    Application.DisplayAlerts = False
    'On Error Resume Next
    DoEvents
    ''sAddIn2007 = Replace(ThisWorkbook.Name, ".xla", ".ttsm")
    DoEvents
    Workbooks(sAddIn2007).Close  'False
    Application.DisplayAlerts = True
  Else
    SaveToolbarState
    DeleteMenu wksMenu.Range("tblCustomMenu1")
  End If

  DisableHotKeys

End Sub
'=========================================================================
Sub SaveToolbarState()
  Dim sTBPosition(1 To 6) As String
  
  If Val(Application.Version) < 12 Then
    With Application.CommandBars(TTS_TOOLBAR)
      On Error Resume Next
      sTBPosition(1) = CStr(.Visible)
      sTBPosition(2) = CStr(.Position)
      sTBPosition(3) = CStr(.RowIndex)
      sTBPosition(4) = CStr(.Left)
      sTBPosition(5) = CStr(.Top)
      sTBPosition(6) = CStr(.Width)
      On Error GoTo 0
      SaveVariable TTS_SETTINGS_FILE, TTS_TOOLBAR_POSITION, Join(sTBPosition, "|")
    End With
  End If
  
End Sub
'=========================================================================
Public Sub MenuCommandHandler2007(sCommandID As String, bParam As Boolean)
  ' 2008 June 16 Jon Peltier
  ' called by Excel 2007 add-in
  ' redirects Ribbon control click to existing add-in menu commands
  ' sCommandID:
  '   ID of Ribbon control clicked by user
  ' bParam:
  '   if btnF1Enabled then True to enable F1 help, False to disable F1
  '   otherwise: dummy variable

  Select Case sCommandID
    Case "btnFontColorToggle"
      mnuFont_Color_Toggle
    Case "btnCellInteriorToggle"
      mnuInterior_Fill_Toggle
    Case "btnBorderToggle"
      mnuBorder_Toggle
    Case "btnNumberToggle"
      mnuNumber_Toggle
    Case "btnAlignmentToggle"
      mnuAlignment_Toggle
    Case "dynmnuAutoColor"
      mnu2007SetF1Key bParam
    Case "btnAutoColorWorkbook"
      mnuAutoColorWorkbook
    Case "btnAutoColorWorksheet"
      mnuAutoColorWorksheet
    Case "btnAutoColorRange"
      mnuAutoColorSelection
    Case "btnAutoColorToggle"
      mnuAutoColorToggle ' bParam
    Case "btnIncreaseDecimal"
      mnuIncrease_Decimal
    Case "btnDecreaseDecimal"
      mnuDecrease_Decimal
    Case "btnIncreaseZoom"
      mnuView_Increase
    Case "btnDecreaseZoom"
      mnuView_Decrease
    Case "btnShow_Sheet_Control"
      mnuShow_Sheet_Control
    Case "btnTracePrecedents"
      mnuPrecedentTracer
    Case "btnF1Enabled"
      mnuSetF1Key
      'mnu2007SetF1Key bParam
    Case "btnTurboTTSOptions"
      mnuTTS_Options
    Case "btnAboutTurboTTS"
      mnuTTS_About
    Case Else
      ' error: unrecognized command ID
  End Select

End Sub
'=========================================================================
Sub mnu2007SetF1Key(bSet As Boolean)
  With wksMenu.Range("F1Key")
    .Value = bSet
    SetF1Key .Value
  End With
  Application.DisplayAlerts = False
  ThisWorkbook.Save
  Application.DisplayAlerts = True
  ReloadMenu
End Sub

Sub mnu2007SetAutoColor(bSet As Boolean)
  
  wksMenu.Range("AutoColor").Value = bSet
  
  mnuAutoColorToggle ' bSet
  
  Application.DisplayAlerts = False
  ThisWorkbook.Save
  Application.DisplayAlerts = True
  ReloadMenu
End Sub
'=========================================================================
''Sub CheckOldAddIns()
''  Dim aAddIn As AddIn
''  Dim sAddInCaps As String
''  Dim bAddIn As Boolean
''  Dim sMessage As String
''  Dim lMsg As Long
''
''  For Each aAddIn In Application.AddIns
''    sAddInCaps = UCase$(Replace(aAddIn.Title, Chr$(0), ""))
''    If InStr(sAddInCaps, "TTS") > 0 And aAddIn.Installed Then
''      If InStr(sAddInCaps, "TURBO") > 0 Or InStr(sAddInCaps, "MACRO") > 0 Then
''        If sAddInCaps <> UCase$(ThisWorkbook.Title) Then
''          bAddIn = True
''          Exit For
''        End If
''      End If
''    End If
''  Next
''
''  If bAddIn Then
''    sMessage = "An older Training the Street add-in is already installed." & vbNewLine & vbNewLine
''    sMessage = sMessage & "You should uninstall the older version before using the new version."
''
''    lMsg = MsgBox(sMessage, vbOKOnly + vbInformation, TTS_TITLE)
''  End If
''
''End Sub
'=========================================================================
Sub CheckOldAddIns(bShowMessage As Boolean)
  Dim aAddIn As AddIn
  Dim sAddInCaps As String
  Dim bAddIn As Boolean
  Dim sMessage As String
  Dim sAddInList As String
  Dim lMsg As Long

  For Each aAddIn In Application.AddIns
    sAddInCaps = UCase$(Replace(aAddIn.Title, Chr$(0), ""))
    If InStr(sAddInCaps, "TTS") > 0 And aAddIn.Installed Then
      If InStr(sAddInCaps, "TURBO") > 0 Or InStr(sAddInCaps, "MACRO") > 0 Then
        If sAddInCaps <> UCase$(ThisWorkbook.Title) Then
          bAddIn = True
          sAddInList = sAddInList & aAddIn.Title & ", "
          aAddIn.Installed = False
          If aAddIn.Installed Then
            DoEvents
            aAddIn.Installed = False
          End If
        End If
      End If
    End If
  Next

  If bAddIn And bShowMessage Then
    sAddInList = Left$(sAddInList, Len(sAddInList) - 2)
    If Len(sAddInList) - Len(Replace(sAddInList, ",", "")) > 1 Then
      sMessage = "The following Training the Street add-ins were already installed." & vbNewLine & vbNewLine
      sMessage = sMessage & "They have been uninstalled to prevent conflict with this new version."
      sMessage = sMessage & vbNewLine & vbNewLine & "--> " & sAddInList
    Else
      sMessage = "The following Training the Street add-in was already installed." & vbNewLine & vbNewLine
      sMessage = sMessage & "It has been uninstalled to prevent conflict with this new version."
      sMessage = sMessage & vbNewLine & vbNewLine & "--> " & sAddInList
    End If

    lMsg = MsgBox(sMessage, vbOKOnly + vbInformation, TTS_TITLE)
  End If

End Sub
'=========================================================================
Sub DoInvalidateControlsForScreenTips()
  Application.Run "InvalidateControlsForScreenTips"
End Sub
'=========================================================================

Attribute VB_Name = "MAutoColor"
Option Explicit

Private Enum jpLinkType
  jpLinkNothing = -1
  jpLinkConstant = 0
  jpLinkText = 1
  jpLinkSameSheet = 2
  jpLinkSameBook = 3
  jpLinkOtherBook = 4
End Enum

Private Const iColorNothing As Long = xlColorIndexAutomatic
Private Const iColorText As Long = xlColorIndexAutomatic
Private Const iColorConstant As Long = 5  ' Blue
Private Const iColorSameSheet As Long = 1  ' Black
Private Const iColorSameBook As Long = 10  ' 50 ' dark green ' 4 ' Green
Private Const iColorOtherBook As Long = 3  ' Red

Private Const sLinkNothing As String = "AutoTextConstant"
Private Const sLinkText As String = "AutoTextConstant"
Private Const sLinkConstant As String = "AutoValueConstant"
Private Const sLinkSameSheet As String = "AutoWorkbookFormula"
Private Const sLinkSameBook As String = "AutoOtherWorksheetFormula"
Private Const sLinkOtherBook As String = "AutoExternalFormula"

Private Const TTS_SETTINGS_FILE As String = "setting.ttsm"

'Private Function bColorIndex(jpLink As jpLinkType, iColorIndex As Long) As Boolean
'  Dim sLinkDescrip As String
'  Dim sValue As String
'
'  Select Case jpLink
'    Case jpLinkNothing
'      sLinkDescrip = sLinkNothing
'      iColorIndex = iColorNothing
'    Case jpLinkText
'      sLinkDescrip = sLinkText
'      iColorIndex = iColorText
'    Case jpLinkConstant
'      sLinkDescrip = sLinkConstant
'      iColorIndex = iColorConstant
'    Case jpLinkSameSheet
'      sLinkDescrip = sLinkSameSheet
'      iColorIndex = iColorSameSheet
'    Case jpLinkSameBook
'      sLinkDescrip = sLinkSameBook
'      iColorIndex = iColorSameBook
'    Case jpLinkOtherBook
'      sLinkDescrip = sLinkOtherBook
'      iColorIndex = iColorOtherBook
'  End Select
'
'  bColorIndex = GetVariable(TTS_SETTINGS_FILE, sLinkDescrip, sValue)
'
'  If bColorIndex Then
'    iColorIndex = CLng(sValue)
'  End If
'
'End Function

Private Function bColor(jpLink As jpLinkType, iColor As Long) As Boolean
  Dim sLinkDescrip As String
  Dim sValue As String

  Select Case jpLink
    Case jpLinkNothing
      sLinkDescrip = sLinkNothing
      'iColorIndex = iColorNothing
    Case jpLinkText
      sLinkDescrip = sLinkText
      'iColorIndex = iColorText
    Case jpLinkConstant
      sLinkDescrip = sLinkConstant
      'iColorIndex = iColorConstant
    Case jpLinkSameSheet
      sLinkDescrip = sLinkSameSheet
      'iColorIndex = iColorSameSheet
    Case jpLinkSameBook
      sLinkDescrip = sLinkSameBook
      'iColorIndex = iColorSameBook
    Case jpLinkOtherBook
      sLinkDescrip = sLinkOtherBook
      'iColorIndex = iColorOtherBook
  End Select

  ThisWorkbook.Colors = Workbooks(ActiveWorkbook.Name).Colors

  On Error Resume Next
  If ThisWorkbook.Names(sLinkDescrip).RefersToRange.Font.ColorIndex = xlColorIndexAutomatic Then
    iColor = xlColorIndexAutomatic
  Else
    iColor = ThisWorkbook.Names(sLinkDescrip).RefersToRange.Font.Color
  End If

  ''ThisWorkbook.ResetColors

  bColor = err.Number = 0
End Function

Sub TestAutoColorOn()
  mnuAutoColorToggle 'True
End Sub

Sub TestAutoColorOff()
  mnuAutoColorToggle 'False
End Sub

Function TestAutoColorState() As Boolean
  TestAutoColorState = TypeName(gclsAutoColor.App) = "Application"
End Function

Sub mnuAutoColorToggleMenu()
  Dim bEnable As Boolean

  'bEnable = gclsAutoColor.App Is Nothing
  'bEnable = Not wksMenu.Range("AutoColor").Value

  mnuAutoColorToggle 'bEnable
End Sub

Sub mnuAutoColorToggle() ' (blnValue As Boolean)
  
  Dim blnValue As Boolean
  
  blnValue = Not wksMenu.Range("AutoColor").Value
  
  If blnValue Then  ' True turns on event trapping
    If gclsAutoColor.App Is Nothing Then
      Set gclsAutoColor.App = Application
      
      If wksMenu.Range(sAutoColorUndoShow).Value Then
        FAutocolorFirstUse.Show
      End If
    End If
  Else  ' False disables event trapping
    Set gclsAutoColor.App = Nothing
  End If
  
  wksMenu.Range("AutoColor").Value = blnValue
  ThisWorkbook.Save
  
  ReloadMenu
  
  If Val(Application.Version) >= 12 Then
    Application.Run "InvalidateControlForCaption", "btnAutoColorToggle"
  End If
  
End Sub

Sub mnuAutoColorWorkbook()
'  disabled JP 2010 11 24
'  Dim ws As Worksheet
'
'  On Error Resume Next
'  Application.ScreenUpdating = False
'  For Each ws In ActiveWorkbook.Worksheets
'    AutoColorRange ws.UsedRange
'  Next
'  Application.ScreenUpdating = True
End Sub

Sub mnuAutoColorWorksheet()
  On Error Resume Next
  Application.ScreenUpdating = False
  If TypeName(ActiveSheet) = "Worksheet" Then
    AutoColorRange ActiveSheet.UsedRange
  End If
  Application.ScreenUpdating = True
End Sub

Sub mnuAutoColorSelection()
  On Error Resume Next
  Application.ScreenUpdating = False
  If TypeName(Selection) = "Range" Then
    AutoColorRange Selection
  End If
  Application.ScreenUpdating = True
End Sub

Sub AutoColorRange(rRange As Range)
  Dim rArea As Range
  Dim iRow As Long
  Dim iCol As Long
  Dim nRows As Long
  Dim nCols As Long
  Dim jpGetAddress As jpLinkType
  Dim sGetAddress As String
  Dim iColor As Long
  Dim bGetColor As Boolean
  Dim bScreenUpdating As Boolean

  bScreenUpdating = Application.ScreenUpdating
  Application.ScreenUpdating = False

  If rRange.Parent.Parent.Name <> ThisWorkbook.Name Then
    For Each rArea In rRange.Areas

      With rArea
        nRows = .Rows.Count
        nCols = .Columns.Count
      End With

      For iRow = 1 To nRows
        For iCol = 1 To nCols

          jpGetAddress = CheckLink(rArea.Cells(iRow, iCol))

          ' get color
          bGetColor = bColor(jpGetAddress, iColor)

          ' apply format to
          If iColor = xlColorIndexAutomatic Then
            rArea.Cells(iRow, iCol).Font.ColorIndex = xlColorIndexAutomatic
          Else
            rArea.Cells(iRow, iCol).Font.Color = iColor
          End If
          'Debug.Print rArea.Cells(iRow, iCol).Address, jpGetAddress, iColorIdx
        Next
      Next
    Next
  End If
  Application.ScreenUpdating = bScreenUpdating
End Sub

Private Function CheckLink(rRange As Range) As jpLinkType
  Dim sFmla As String
  Dim iFmla As Long
  Dim sChar As String
  Dim iChar As Long
  Dim vSplitFmla As Variant
  Dim iSplitFmla As Long
  Dim bInsideSnglQuote As Boolean
  Dim sTest As String
  Dim sRange As String
  Dim sAddress As String
  Dim sWorkbook As String
  Dim sWorksheet As String
  Dim bRange As Boolean
  Dim jpTempLink As jpLinkType
  Dim iPathChar1 As Long
  Dim iPathChar2 As Long

  Const sCharacters As String = "=+-*/&^()<>,;%"
  Const sSnglQuote As String = "'"

  If rRange.HasFormula Then

    sFmla = rRange.Formula

    bInsideSnglQuote = False
    For iFmla = 1 To Len(sFmla)
      If Mid$(sFmla, iFmla, 1) = sSnglQuote Then
        bInsideSnglQuote = Not bInsideSnglQuote
      ElseIf Not bInsideSnglQuote Then
        sChar = Mid$(sFmla, iFmla, 1)
        For iChar = 1 To Len(sCharacters)
          sChar = Replace$(sChar, Mid$(sCharacters, iChar, 1), "*")
        Next
        Mid$(sFmla, iFmla, 1) = sChar
      End If
    Next

    vSplitFmla = Split(sFmla, "*")

    For iSplitFmla = LBound(vSplitFmla, 1) To UBound(vSplitFmla, 1)
      sTest = CStr(vSplitFmla(iSplitFmla))

      bRange = IsRange(sTest)

      If bRange Then
        sRange = Range(sTest).Address(external:=True)
        sWorkbook = Mid$(sRange, InStr(sRange, "[") + 1)
        sWorkbook = Left$(sWorkbook, InStr(sWorkbook, "]") - 1)

        If sWorkbook = rRange.Parent.Parent.Name Then
          sAddress = Left$(sRange, InStr(sRange, "[") - 1) & Mid$(sRange, InStr(sRange, "]") + 1)
          sWorksheet = Left$(sAddress, InStr(sAddress, "!") - 1)
          If Left$(sWorksheet, 1) = sSnglQuote Then
            sWorksheet = Mid$(sWorksheet, 2, Len(sWorksheet) - 2)
          End If
          If sWorksheet = rRange.Parent.Name Then
            jpTempLink = jpLinkSameSheet
          Else
            jpTempLink = jpLinkSameBook
          End If

        Else
          jpTempLink = jpLinkOtherBook
        End If
      Else
        If Len(sTest) > 0 Then
          If IsNumeric(sTest) Then
            jpTempLink = jpLinkConstant
          Else
            jpTempLink = jpLinkText
          End If
  
          ' check for possible link to closed workbook
          iPathChar1 = InStr(sTest, ":\")
          If iPathChar1 = 0 Then
            iPathChar1 = InStr(sTest, "\\")
          End If
          If iPathChar1 > 0 Then
            iPathChar2 = InStr(sTest, "[")
            If iPathChar2 > iPathChar1 Then
              iPathChar1 = iPathChar2
              iPathChar2 = InStr(sTest, "]")
              If iPathChar2 > iPathChar1 Then
                iPathChar1 = iPathChar2
                iPathChar2 = InStr(sTest, "!")
                If iPathChar2 > iPathChar1 Then
                  jpTempLink = jpLinkOtherBook
                End If
              End If
            End If
          End If
        Else
          jpTempLink = jpLinkNothing
        End If
      End If

      If CheckLink < jpTempLink Then
        CheckLink = jpTempLink
      End If
    Next
  Else
    If Len(rRange.Value) > 0 Then
      If IsNumeric(rRange.Value) Then
        CheckLink = jpLinkConstant
      Else
        CheckLink = jpLinkText
      End If
    Else
      CheckLink = jpLinkNothing
    End If
  End If

End Function
Attribute VB_Name = "MPTStools"
Option Explicit
''============================================================================
Public Function FileExists(ByVal FileSpec As String) As Boolean
  ' Karl Peterson MS VB MVP
  Dim Attr As Long
  ' Guard against bad FileSpec by ignoring errors
  ' retrieving its attributes.
  On Error Resume Next
  Attr = GetAttr(FileSpec)
  If err.Number = 0 Then
    ' No error, so something was found.
    ' If Directory attribute set, then not a file.
    FileExists = Not ((Attr And vbDirectory) = vbDirectory)
  End If
End Function
''============================================================================
Function GetVariable(sFile As String, sName As String, _
    Optional sValue As String) As Boolean

  Dim iFileNum As Long
  Dim sPath As String
  Dim sVarName As String
  Dim sVarValue As String
  Dim lErrLast As Long

  ' assume false unless variable is found
  GetVariable = False

  ' open text file to read settings
  sPath = ThisWorkbook.Path
  'If Len(Dir(sPath & "\" & sFile)) > 0 Then
  If FileExists(sPath & "\" & sFile) Then
    iFileNum = FreeFile
    Open sPath & "\" & sFile For Input As iFileNum
    Do While Not EOF(iFileNum)
      Input #iFileNum, sVarName, sVarValue
      If sVarName = sName Then
        sValue = sVarValue
        GetVariable = True
        Exit Do
      End If
    Loop
    Close #iFileNum
  End If

End Function
''============================================================================
Function SaveVariable(sFile As String, sName As String, _
    Optional sValue As String) As Boolean

  Dim iFileNumA As Long
  Dim iFileNumB As Long
  Dim sPath As String
  Dim sVarName As String
  Dim sVarValue As String
  Dim lErrLast As Long

  ' assume false unless variable is found
  SaveVariable = False

  ' open text file to read settings
  sPath = ThisWorkbook.Path
  If FileExists(sPath & "\" & sFile) Then
    'replace existing settings file
    iFileNumA = FreeFile
    Open sPath & "\" & sFile For Input As iFileNumA
    iFileNumB = FreeFile
    Open sPath & "\X" & sFile For Output As iFileNumB
    Do While Not EOF(iFileNumA)
      Input #iFileNumA, sVarName, sVarValue
      If sVarName <> sName Then
        Write #iFileNumB, sVarName, sVarValue
      End If
    Loop
    Write #iFileNumB, sName, sValue
    SaveVariable = True
    Close #iFileNumA
    Close #iFileNumB
    FileCopy sPath & "\X" & sFile, sPath & "\" & sFile
    Kill sPath & "\X" & sFile
  Else
    ' make new file
    iFileNumB = FreeFile
    Open sPath & "\" & sFile For Output As iFileNumB
    Write #iFileNumB, sName, sValue
    SaveVariable = True
    Close #iFileNumB
  End If

End Function
''============================================================================
Function TestStoreVariable(sName As String, sValue As String)
  Dim bTest As Boolean

  bTest = SaveVariable(TTS_SETTINGS_FILE, sName, sValue)
End Function
''----------------------------------------------------------------------------
Function TestRetrieveVariable(sName As String) As Variant
  Dim bTest As Boolean
  Dim sValue As String

  bTest = GetVariable(TTS_SETTINGS_FILE, sName, sValue)

  If bTest Then
    TestRetrieveVariable = sValue
  Else
    TestRetrieveVariable = False
  End If
End Function
''============================================================================
'Sub TestHotkeyClass()
'  Dim clsHotKeys As CHotKeys
'
'  Set clsHotKeys = New CHotKeys
'
'  clsHotKeys.AssignHotKeys
'
'  clsHotKeys.SaveHotKeys
'
'  Set clsHotKeys = Nothing
'End Sub
''============================================================================
Attribute VB_Name = "MPrecedentAnalyzer"
Option Explicit

Dim mfrmPrecedentAnalyzer As FPrecedentAnalyzer

Public Const bOriginalCellAtEnd As Boolean = False

#If Win64 = 1 And VBA7 = 1 Then
  Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" _
      (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr
      
  Private Declare PtrSafe Function SetForegroundWindow Lib "user32" _
      (ByVal hwnd As LongPtr) As Long
#Else
  Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" _
      (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
  
  Private Declare Function SetForegroundWindow Lib "user32" (ByVal hwnd As Long) As Long
#End If

Sub mnuPrecedentTracer()
  If mfrmPrecedentAnalyzer Is Nothing Then
    Set mfrmPrecedentAnalyzer = New FPrecedentAnalyzer
  End If

  With mfrmPrecedentAnalyzer
    If Not ActiveCell Is Nothing Then
      Set .Cell = ActiveCell
    End If
    .Show vbModeless
  End With
End Sub

Sub TestGetPrecedents()
  Dim v As Variant
  v = NewPrecedents(ActiveCell)
End Sub

Function GetAddress(rRange As Range) As String
  Dim sRange As String
  Dim sAddress As String
  Dim sTemp As String
  Dim sWorkbook As String

  sRange = rRange.Address(external:=True)
  sWorkbook = Mid$(sRange, InStr(sRange, "[") + 1)
  sWorkbook = Left$(sWorkbook, InStr(sWorkbook, "]") - 1)

  If sWorkbook = ActiveWorkbook.Name Then
    sAddress = Left$(sRange, InStr(sRange, "[") - 1) & Mid$(sRange, InStr(sRange, "]") + 1)
    sTemp = Mid$(sAddress, 2, 999)
    sTemp = Replace$(sTemp, "'!", "!")
    If IsRange(sTemp) Then
      sAddress = sTemp
    End If
  Else
    sAddress = sRange
  End If

  GetAddress = sRange & "|" & sAddress
End Function

Function IsRange(sTest As String) As Boolean
  On Error Resume Next
  IsRange = (TypeName(Range(sTest)) = "Range")
End Function

Function NewPrecedents(rCell As Range) As Variant
  Dim vPrecedents As Variant
  Dim vPrecedents2 As Variant
  Dim rPrecedent As Range
  Dim iPrecedent As Long
  Dim sFmla As String
  Dim iChar As Long
  Dim sChar As String
  Dim sTest As String
  Dim iFmla As Long
  Dim vSplitFmla As Variant
  Dim iSplitFmla As Long
  Dim sAddress As String
  Dim iAddress As Long
  Dim bMatch As Boolean
  Dim bInsideSnglQuote As Boolean
  Dim sCellAddress As String

  Const sCharacters As String = "=+-*/&^()<>,;"
  Const sSnglQuote As String = "'"

  If rCell.HasFormula Then
    sFmla = rCell.Formula
    For iFmla = 1 To Len(sFmla)
      'bInsideSnglQuote = False
      If Mid$(sFmla, iFmla, 1) = sSnglQuote Then
        bInsideSnglQuote = Not bInsideSnglQuote
      ElseIf Not bInsideSnglQuote Then
        sChar = Mid$(sFmla, iFmla, 1)
        For iChar = 1 To Len(sCharacters)
          sChar = Replace$(sChar, Mid$(sCharacters, iChar, 1), "*")
        Next
        Mid$(sFmla, iFmla, 1) = sChar
      End If
    Next

    iPrecedent = 0
    ReDim vPrecedents(1 To 1)
    vSplitFmla = Split(sFmla, "*")

    For iSplitFmla = LBound(vSplitFmla, 1) To UBound(vSplitFmla, 1)
      sTest = CStr(vSplitFmla(iSplitFmla))
      ''If IsRange(sTest) Then
      Select Case True
        Case IsRange(sTest), IsRange("'" & rCell.Parent.Name & "'!" & sTest)

          If InStr(sTest, "!") = 0 Then
            sTest = "'" & rCell.Parent.Name & "'!" & sTest
          End If

          sAddress = GetAddress(Range(sTest))
          bMatch = False
          For iAddress = LBound(vPrecedents, 1) To UBound(vPrecedents, 1)
            If sAddress = vPrecedents(iAddress) Then
              bMatch = True
              Exit For
            End If
          Next
          If Not bMatch Then
            iPrecedent = iPrecedent + 1
            ReDim Preserve vPrecedents(1 To iPrecedent)
            vPrecedents(iPrecedent) = sAddress
          End If
        Case Else
      End Select
      ''End If
    Next

    If iPrecedent = 0 Then
      NewPrecedents = ""
    Else

      ReDim vPrecedents2(LBound(vPrecedents, 1) To UBound(vPrecedents, 1) + 1, 1 To 3)
      For iPrecedent = LBound(vPrecedents, 1) To UBound(vPrecedents, 1)
        If bOriginalCellAtEnd Then
          ' original cell at end
          vPrecedents2(iPrecedent, 1) = Left$(vPrecedents(iPrecedent), InStr(vPrecedents(iPrecedent), "|") - 1)
          vPrecedents2(iPrecedent, 2) = Mid$(vPrecedents(iPrecedent), InStr(vPrecedents(iPrecedent), "|") + 1)
        Else
          'original cell at beginning
          vPrecedents2(iPrecedent + 1, 1) = Left$(vPrecedents(iPrecedent), InStr(vPrecedents(iPrecedent), "|") - 1)
          vPrecedents2(iPrecedent + 1, 2) = Mid$(vPrecedents(iPrecedent), InStr(vPrecedents(iPrecedent), "|") + 1)
        End If
      Next

      sCellAddress = GetAddress(rCell)
      If bOriginalCellAtEnd Then
        ' original cell at end
        vPrecedents2(UBound(vPrecedents2, 1), 1) = Left$(sCellAddress, InStr(sCellAddress, "|") - 1)
        vPrecedents2(UBound(vPrecedents2, 1), 2) = Mid$(sCellAddress, InStr(sCellAddress, "|") + 1)
      Else
        'original cell at beginning
        vPrecedents2(1, 1) = Left$(sCellAddress, InStr(sCellAddress, "|") - 1)
        vPrecedents2(1, 2) = Mid$(sCellAddress, InStr(sCellAddress, "|") + 1)
      End If

      NewPrecedents = vPrecedents2

    End If
  Else
    NewPrecedents = ""
  End If

End Function

Public Sub ActivatePrecedentAnalyzer()
  SetForegroundWindow DialogHWnd(mfrmPrecedentAnalyzer)
End Sub

#If Win64 = 1 And VBA7 = 1 Then
  Public Function DialogHWnd(ByRef WindowObject As Object) As LongPtr
#Else
  Public Function DialogHWnd(ByRef WindowObject As Object) As Long
#End If

  ' get the hWnd value for the window.
  Select Case Val(Application.Version)
    Case 8  ' Excel 97
      DialogHWnd = GetWindowFromTitle(WindowObject.Caption, "ThunderXFrame")
    Case Is >= 9  ' Excel 2000 or later
      DialogHWnd = GetWindowFromTitle(WindowObject.Caption, "ThunderDFrame")
    Case Else
      Exit Function
  End Select

End Function

#If Win64 = 1 And VBA7 = 1 Then
  Public Function GetWindowFromTitle(ByVal WindowTitle As String, _
      Optional ByVal ClassName As String) As LongPtr
  Dim hwnd As LongPtr
#Else
  Public Function GetWindowFromTitle(ByVal WindowTitle As String, _
      Optional ByVal ClassName As String) As Long
  Dim hwnd As Long
#End If

  ' Find the window handle of the window with the class and name provided.

  If Len(ClassName) = 0 Then
    hwnd = FindWindow(vbNullString, WindowTitle)
  Else
    hwnd = FindWindow(ClassName, WindowTitle)
  End If

  GetWindowFromTitle = hwnd
End Function

Public Sub ResetTracerDialogSettings()
  With mfrmPrecedentAnalyzer
    .ResetListIndex
  End With
  Application.ScreenUpdating = True
End Sub
Attribute VB_Name = "MShortcutKeys"
'' J Peltier, Peltier Technical Services, Inc., http://peltiertech.com
'' Code for shortcut key functionality
'' Code located in this module for clarity rather than in userform

Option Explicit
''============================================
Public Const sCtrlTxt As String = "txtKey"
Public Const sCtrlChk As String = "chkKey"
Public Const iAlertBkd As Long = &HC0E0FF
Public Const iWarnBkd As Long = &H8080FF
Public Const iWarnFill As Long = &HC0C0FF
Public Const iNormalBkd As Long = &H8000000F
Public Const iNormalFill As Long = &H80000005

Const FILLCOLOR_HELP_MSG As String = "Allows you to customize the shortcut keys which activate various " & _
  "Turbo Macro functions. All shortcut key combinations require the CTRL key, but SHIFT and ALT are optional. " & _
  "You can avoid duplicate assignments within the Turbo Macro shortcuts, but it is not possible to check " & _
  "for shortcuts built into Excel or defined by other add-ins."

''============================================
'' Buttons on Options Dialog
''--------------------------------------------
Sub ShortcutKeysHelp()
  '' Help button
  MsgBox FILLCOLOR_HELP_MSG, vbOKOnly, "TTS Help"
End Sub
''--------------------------------------------
Sub ShortcutKeysShowCurrent(frm As Object)
  '' initially populating the form
  ShortcutKeysPopulate frm, ShortcutCurrentKeys
End Sub
''--------------------------------------------
Sub ShortcutKeysApplyDefault(frm As Object)
  '' Restore Default Shortcuts & Reset All Defaults buttons
  ShortcutKeysApply ShortcutDefaultKeys
  ShortcutKeysPopulate frm, ShortcutDefaultKeys
  If Val(Application.Version) >= 12 Then
    DoInvalidateControlsForScreenTips
  End If
End Sub
''--------------------------------------------
Sub ShortcutKeysApplyPrevious(frm As Object)
  '' Return to Previous button
  ShortcutKeysApply ShortcutCurrentKeys
  ShortcutKeysPopulate frm, ShortcutCurrentKeys
  If Val(Application.Version) >= 12 Then
    DoInvalidateControlsForScreenTips
  End If
End Sub
''--------------------------------------------
Sub ShortcutKeysApplyNew(frm As Object)
  '' OK button
  ''Debug.Print Timer, "ShortcutKeysApplyNew: unapplying current keys"
  ShortcutKeysUnapply ShortcutCurrentKeys
  ''Debug.Print Timer, "ShortcutKeysApplyNew: applying new keys"
  ShortcutKeysApply ShortcutNewKeys(frm)
  ''Debug.Print Timer, "ShortcutKeysApplyNew: done"
  If Val(Application.Version) >= 12 Then
    DoInvalidateControlsForScreenTips
  End If
End Sub
''============================================
'' Arrays of shortcut keys and actions
''--------------------------------------------
Function ShortcutDefaultKeys() As Variant
  Dim rKeys As Range
  Dim vKeys As Variant
  Dim vDefaultKeys As Variant
  Dim iKey As Long

  Set rKeys = ThisWorkbook.Names(sNAME_TABLE_CUSTOM).RefersToRange
  Set rKeys = rKeys.Resize(, rKeys.Columns.Count + 1)

  vKeys = rKeys.Value

  ReDim vDefaultKeys(LBound(vKeys, 1) To UBound(vKeys, 1), 1 To 4)
  For iKey = LBound(vKeys, 1) To UBound(vKeys, 1)
    vDefaultKeys(iKey, 1) = vKeys(iKey, iHOTKEY_INDEX)
    vDefaultKeys(iKey, 2) = vKeys(iKey, iHOT_KEY)
    vDefaultKeys(iKey, 3) = vKeys(iKey, iSUB_CONT_NAME)
    vDefaultKeys(iKey, 4) = vKeys(iKey, iACTION)
  Next

  ShortcutDefaultKeys = vDefaultKeys
End Function
''--------------------------------------------
Function ShortcutCurrentKeys() As Variant
  Dim vCurrentKeys As Variant
  Dim iKey As Long
  Dim bKey As Boolean
  Dim sName As String
  Dim sValue As String

  vCurrentKeys = ShortcutDefaultKeys
  For iKey = LBound(vCurrentKeys, 1) To UBound(vCurrentKeys, 1)
    If Len(vCurrentKeys(iKey, 1)) > 0 Then
      sName = "Key" & Format$(vCurrentKeys(iKey, 1), "00")
      bKey = GetVariable(TTS_SETTINGS_FILE, sName, sValue)
      If bKey Then
        If Len(sValue) > 0 Then
          vCurrentKeys(iKey, 2) = sValue
        End If
      End If
    End If
  Next

  ShortcutCurrentKeys = vCurrentKeys
End Function
''--------------------------------------------
Function ShortcutNewKeys(frm As Object) As Variant
  '' get new shortcut definitions from dialog
  Const sCtrlTxt As String = "txtKey"
  Const sCtrlChk As String = "chkKey"
  Dim iKeyIndexList() As Long
  Dim iKey1 As Long
  Dim iKey2 As Long
  Dim ctl As Control
  Dim vKeyList As Variant
  Dim sKeyCode As String
  Dim sChar As String

  vKeyList = ShortcutDefaultKeys
  For iKey2 = LBound(vKeyList, 1) To UBound(vKeyList, 1)
    vKeyList(iKey2, 2) = ""
    sKeyCode = ""
    
    Set ctl = Nothing
    On Error Resume Next
    Set ctl = frm.Controls(sCtrlChk & "C" & Format(vKeyList(iKey2, 1), "00"))
    On Error GoTo 0
    If Not ctl Is Nothing Then
      If ctl.Value Then
        sKeyCode = sKeyCode & "^"
      End If
    End If
    
    Set ctl = Nothing
    On Error Resume Next
    Set ctl = frm.Controls(sCtrlChk & "S" & Format(vKeyList(iKey2, 1), "00"))
    On Error GoTo 0
    If Not ctl Is Nothing Then
      If ctl.Value Then
        sKeyCode = sKeyCode & "+"
      End If
    End If
    
    Set ctl = Nothing
    On Error Resume Next
    Set ctl = frm.Controls(sCtrlChk & "A" & Format(vKeyList(iKey2, 1), "00"))
    On Error GoTo 0
    If Not ctl Is Nothing Then
      If ctl.Value Then
        sKeyCode = sKeyCode & "%"
      End If
    End If
    
    Set ctl = Nothing
    On Error Resume Next
    Set ctl = frm.Controls(sCtrlTxt & Format(vKeyList(iKey2, 1), "00"))
    On Error GoTo 0
    If Not ctl Is Nothing Then
      sChar = UCase$(ctl.Text)
      If Len(sChar) = 0 Then
        sKeyCode = "<none>"
      Else
        Select Case sChar
          Case "+", "&", "%", "(", ")", "{", "}", "[", "]", "^"
            sChar = "{" & sChar & "}"
        End Select
        sKeyCode = sKeyCode & sChar
      End If
    End If
    
    vKeyList(iKey2, 2) = sKeyCode
  Next

  ShortcutNewKeys = vKeyList
End Function
''============================================
'' Actions involving shortcut keys
''--------------------------------------------
Sub ShortcutKeysApply(vApplyKeys)
  Dim iKey As Long
  Dim bLookup As Boolean
  Dim sLookup As String
  Dim bSave As Boolean

  ''Debug.Print Timer, "- ShortcutKeysApply: starting"

''  ShortcutKeysUnapply ShortcutCurrentKeys

  For iKey = LBound(vApplyKeys, 1) To UBound(vApplyKeys, 1)

''    '' remove old shortcut
''    bLookup = GetVariable(TTS_SETTINGS_FILE, "Key" & Format$(vApplyKeys(iKey, 1), "00"), sLookup)
''    If Len(sLookup) > 0 Then
''      Application.OnKey sLookup
''      ' on error resume next
''      If Val(Application.Version) < 12 Then
''      Application.CommandBars("Worksheet Menu Bar").Controls(TTS_TURBO_MENU).Controls(vApplyKeys(iKey, 3)) _
''          .ShortcutText = ""
''      End If
''      ' on error goto 0
''    End If
    
    ' apply new shortcut
    If Len(vApplyKeys(iKey, 2)) > 0 And vApplyKeys(iKey, 2) <> "<none>" Then
      Application.OnKey LCase$(vApplyKeys(iKey, 2)), "'" & ThisWorkbook.Name & "'!" & vApplyKeys(iKey, 4)
      If Val(Application.Version) < 12 Then
        Application.CommandBars("Worksheet Menu Bar").Controls(TTS_TURBO_MENU).Controls(vApplyKeys(iKey, 3)) _
            .ShortcutText = ShortcutKeyText(CStr(vApplyKeys(iKey, 2)))
      End If
      bSave = SaveVariable(TTS_SETTINGS_FILE, "Key" & Format$(vApplyKeys(iKey, 1), "00"), _
          CStr(vApplyKeys(iKey, 2)))
    End If
  Next

  ''Debug.Print Timer, "- ShortcutKeysApply: done"

End Sub
''--------------------------------------------
''Sub RemoveBogusShortcutMenuHints()
''  Dim ctrl As CommandBarControl
''
''  For Each ctrl In Application.CommandBars("Worksheet Menu Bar").Controls(TTS_TURBO_MENU).Controls
''    If InStr(ctrl.Caption, "   ") > 0 Then
''      ctrl.Caption = Left$(ctrl.Caption, InStr(ctrl.Caption, "   ") - 1)
''    End If
''  Next
''End Sub
''--------------------------------------------
Sub ShortcutKeysUnapply(vUnapplyKeys)
  Dim iKey As Long
  Dim bLookup As Boolean
  Dim sLookup As String

  ''Debug.Print Timer, "- ShortcutKeysUnapplyNew: start"

  For iKey = LBound(vUnapplyKeys, 1) To UBound(vUnapplyKeys, 1)
    ' remove old shortcut
    bLookup = GetVariable(TTS_SETTINGS_FILE, "Key" & Format$(vUnapplyKeys(iKey, 1), "00"), sLookup)
    If Len(sLookup) > 0 Then
      Application.OnKey LCase$(sLookup)
      On Error Resume Next
      Application.CommandBars("Worksheet Menu Bar").Controls(TTS_TURBO_MENU).Controls(vUnapplyKeys(iKey, 3)) _
          .ShortcutText = ""
      On Error GoTo 0
    End If
    
    ' remove new shortcut
    If Len(vUnapplyKeys(iKey, 2)) > 0 Then
      Application.OnKey LCase$(vUnapplyKeys(iKey, 2))
      On Error Resume Next
      Application.CommandBars("Worksheet Menu Bar").Controls(TTS_TOOLBAR).Controls(vUnapplyKeys(iKey, 3)) _
          .ShortcutText = ""
      On Error GoTo 0
    End If
  Next

  ''Debug.Print Timer, "- ShortcutKeysUnapplyNew: end"

End Sub
''--------------------------------------------
Sub ShortcutKeysPopulate(frm As Object, vKeys As Variant)
  '' put shortcut definitions into dialog
  Const sCtrlTxt As String = "txtKey"
  Const sCtrlChk As String = "chkKey"
  Dim iKeyIndexList() As Long
  Dim iKey1 As Long
  Dim iKey2 As Long
  Dim ctl As Control
  Dim vKeyList As Variant
  Dim sKeyCode As String
  Dim sChar As String
  Dim iChar As Long

  iKey1 = 0
  ReDim iKeyIndexList(1 To 1)
  For Each ctl In frm.Controls
    If Left(ctl.Name, Len(sCtrlTxt)) = sCtrlTxt Then
      iKey1 = iKey1 + 1
      ReDim Preserve iKeyIndexList(1 To iKey1)
      iKeyIndexList(iKey1) = CLng(Mid$(ctl.Name, Len(sCtrlTxt) + 1))

      '' clear existing shortcut info
      frm.Controls(sCtrlTxt & Format$(iKeyIndexList(iKey1), "00")).Value = ""
      frm.Controls(sCtrlChk & "S" & Format$(iKeyIndexList(iKey1), "00")).Value = False
      frm.Controls(sCtrlChk & "C" & Format$(iKeyIndexList(iKey1), "00")).Value = True
      frm.Controls(sCtrlChk & "A" & Format$(iKeyIndexList(iKey1), "00")).Value = False
    End If
  Next

  For iKey1 = LBound(iKeyIndexList) To UBound(iKeyIndexList)
    For iKey2 = LBound(vKeys, 1) To UBound(vKeys, 1)
      If iKeyIndexList(iKey1) = vKeys(iKey2, 1) Then
        If vKeys(iKey2, 2) <> "<none>" Then
          '' it's a match so put it into the form
          For iChar = 1 To Len(vKeys(iKey2, 2))
            sChar = Mid$(vKeys(iKey2, 2), iChar, 1)
            Select Case sChar
              Case "+"
                frm.Controls(sCtrlChk & "S" & Format$(iKeyIndexList(iKey1), "00")).Value = True
              Case "^"
                ''frm.Controls(sCtrlChk & "C" & Format$(iKeyIndexList(iKey1), "00")).Value = True
              Case "%"
                frm.Controls(sCtrlChk & "A" & Format$(iKeyIndexList(iKey1), "00")).Value = True
              Case "{"
                sChar = Mid$(vKeys(iKey2, 2), iChar + 1, 1)
                frm.Controls(sCtrlTxt & Format$(iKeyIndexList(iKey1), "00")).Value = sChar
                Exit For
              Case Else
                frm.Controls(sCtrlTxt & Format$(iKeyIndexList(iKey1), "00")).Value = UCase$(sChar)
                Exit For
            End Select
          Next
        End If
      End If
    Next
  Next

End Sub
''--------------------------------------------
Function ShortcutKeyText(ShortcutKeyCode As String) As String
  Dim sInput As String
  Dim sOutput As String
  Dim iChar As Long
  Dim sCtrl As String
  Dim sShift As String
  Dim sAlt As String
  Dim sChar As String
  
  For iChar = 1 To Len(ShortcutKeyCode)
    sChar = Mid$(ShortcutKeyCode, iChar, 1)
    Select Case sChar
      Case "+"
        sShift = "Shift+"
      Case "^"
        sCtrl = "Ctrl+"
      Case "%"
        sAlt = "Alt+"
      Case "{"
        sChar = Mid$(ShortcutKeyCode, iChar + 1, 1)
        Exit For
      Case Else
        sChar = UCase$(sChar)
        Exit For
    End Select
  Next
  
  ShortcutKeyText = sCtrl & sShift & sAlt & sChar
  
End Function
''============================================
Public Sub ValidateShortcuts(frm As Object)
  Dim ctl As Control
  Dim vShortcut() As String
  Dim iCtl As Long
  Dim iKey1 As Long
  Dim iKey2 As Long
  Dim bDupe As Boolean
  
  ReDim vShortcut(1 To 2, 1 To 1)
  
  For Each ctl In frm.Controls
    If Left$(ctl.Name, 6) = sCtrlTxt Then
      iCtl = iCtl + 1
      ReDim Preserve vShortcut(1 To 2, 1 To iCtl)
      
      'remember control index
      vShortcut(1, iCtl) = Right$(ctl.Name, 2)
      
      If frm.Controls(sCtrlChk & "C" & vShortcut(1, iCtl)).Value Then
        vShortcut(2, iCtl) = "^"
      End If
      If frm.Controls(sCtrlChk & "S" & vShortcut(1, iCtl)).Value Then
        vShortcut(2, iCtl) = vShortcut(2, iCtl) & "+"
      End If
      If frm.Controls(sCtrlChk & "A" & vShortcut(1, iCtl)).Value Then
        vShortcut(2, iCtl) = vShortcut(2, iCtl) & "%"
      End If
      If Len(frm.Controls(sCtrlTxt & vShortcut(1, iCtl)).Text) > 0 Then
        ''' just color C because it's wide enough to sit behind all three
        ''If Len(vShortcut(2, iCtl)) = 0 Then
        ''  frm.Controls(sCtrlChk & "C" & vShortcut(1, iCtl)).BackColor = iWarnFill ' iAlertBkd
        ''Else
        ''  frm.Controls(sCtrlChk & "C" & vShortcut(1, iCtl)).BackColor = iNormalBkd
        ''End If
        vShortcut(2, iCtl) = vShortcut(2, iCtl) & UCase$(frm.Controls(sCtrlTxt & vShortcut(1, iCtl)).Text)
      Else
        vShortcut(2, iCtl) = ""
      End If
      ' just color C because it's wide enough to sit behind all three
      frm.Controls(sCtrlChk & "C" & vShortcut(1, iCtl)).BackColor = iNormalBkd
    End If
  Next
  
  For iKey1 = LBound(vShortcut, 2) To UBound(vShortcut, 2) - 1
    For iKey2 = iKey1 + 1 To UBound(vShortcut, 2)
      If UCase$(vShortcut(2, iKey1)) = UCase$(vShortcut(2, iKey2)) Then
        ' duplicates
        bDupe = True
        frm.Controls(sCtrlChk & "C" & vShortcut(1, iKey1)).BackColor = iWarnFill
        frm.Controls(sCtrlChk & "C" & vShortcut(1, iKey2)).BackColor = iWarnFill
      End If
    Next
  Next
  
  frm.lblShortcutDuplicates.Visible = bDupe
  
End Sub
''============================================
Sub TestShortcut()
  Beep
  Stop
End Sub
''============================================
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Workbook_BeforeClose(Cancel As Boolean)
  '' 2008 06 16 Jon Peltier
  '' edited to use startup and shutdown procedures in M2007UI module

  ''CloseDown
  Application.Run "'" & ThisWorkbook.Name & "'!CloseDown"

End Sub

Private Sub Workbook_Open()
  '' 2008 06 16 Jon Peltier
  '' edited to use startup and shutdown procedures in M2007UI module

  '  Debug.Print Timer & " Workbook Open"
  StartUp

End Sub
Attribute VB_Name = "frmAbout"
Attribute VB_Base = "0{04085CE3-1097-43D1-87C5-922C0A43C914}{A1F1B112-9207-487B-B1B8-471EACCA725D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Const msModule As String = "frmAbout"

Private Sub cmdOK_Click()
  Me.Tag = "OK"
  'Me.Hide
  Unload Me
End Sub

Private Sub cmdViewErrorLog_Click()
  Const sSOURCE As String = "cmdViewErrorLog_Click()"
  Dim strPath As String
  On Error GoTo ErrorHandler

  frmErrors.Show
  If frmErrors.Tag = "OK" Then
    Unload frmErrors
  End If
  '    If frmErrors.Tag = "Email" Then 'button removed due to email link problems - error log
  'becomes to large to use in the hyperlink.follow address
  '        Unload frmErrors
  '        Me.Tag = "Email"
  '        wksMenu.Range("EmailHyperlink").Hyperlinks(1).Follow NewWindow:=True
  '        'Me.Hide
  '    End If
ErrorExit:
  'Unload frmAbout
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub



Private Sub lblApplicationLog_Click()
  Const sSOURCE As String = "cmdViewErrorLog_Click()"
  Dim strPath As String
  On Error GoTo ErrorHandler

  frmErrors.Show
  If frmErrors.Tag = "OK" Then
    Unload frmErrors
  End If

ErrorExit:
  'Unload frmAbout
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Sub

Private Sub lblURL_Click()
  '    Const sSOURCE As String = "lblURL_Click()"
  '    On Error GoTo ErrorHandler
  '
  '    Me.Tag = "HTTP"
  '    wksMenu.Range("TTSHyperlink").Hyperlinks(1).Follow NewWindow:=True
  '    'Me.Hide
  '
  'ErrorExit:
  '    ' Cleanup code here.
  '    Exit Sub
  '
  'ErrorHandler:
  '    If bCentralErrorHandler(msModule, sSOURCE, , True) Then
  'Stop
  '        Resume
  '    Else
  '        Resume ErrorExit
  '    End If
End Sub

Private Sub UserForm_Initialize()
  Me.lblVersion.Caption = "Version: " & wksMenu.Range("VersionNumber").Value
  Me.lblAddInPath.BackColor = RGB(0, 88, 38)
  Me.lblAddInPath.Caption = "Code by: Peltier Technical Services, Inc. (PeltierTech.com)" & vbCr & vbCr & _
      "Add-In Location: " & ThisWorkbook.Path & "\" & ThisWorkbook.Name
End Sub
Attribute VB_Name = "frmCalendar"
Attribute VB_Base = "0{D3F21F4A-32FB-463E-85F9-FC21A286B7BC}{B10E42D7-D47A-4E14-A570-D7590B123839}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private gstrDate As String

Private Sub cbo_SelectMonth_Change()

  '   Local Events

  If Me.Tag <> "" Then Exit Sub
  Me.Tag = "Updating"

  '   Step 1 : Update calendar
  Call UpdateCalendarDisplay
  Call ReFormat_DateLabels
  Me.spb_Month.Value = Me.cbo_SelectMonth.ListIndex

  Me.Tag = ""
End Sub

Private Sub cbo_SelectYear_Change()

  '   Local Events

  If Me.Tag <> "" Then Exit Sub
  Me.Tag = "Updating"

  '   Step 1 : Update calendar
  Application.EnableEvents = False
  Call UpdateCalendarDisplay
  Call ReFormat_DateLabels
  Application.EnableEvents = True

  Me.Tag = ""
End Sub

Private Sub cboUseThisDateFormat_Change()
  If gstrDate = "" Then gstrDate = Me.txt_SelectedDate.Value
  If gstrDate <> "" Then
    Me.txt_SelectedDate.Value = Format(gstrDate, Me.cboUseThisDateFormat.Value)
  End If
End Sub


Private Sub cmd_Close_Click()
  Me.Tag = "Cancel"
  Me.Hide
End Sub

Private Sub cmd_GotoToday_Click()

  '   Local Variables

  '   Step 1 : Set the selection forms to match system date
  Me.cbo_SelectMonth.ListIndex = Month(Now()) - 1
  Me.cbo_SelectYear = Year(Now())
  Me.spb_Month = Me.cbo_SelectMonth.ListIndex
  Me.spb_Year = Me.cbo_SelectYear
  Me.txt_SelectedDate = ""
  Call UpdateCalendarDisplay
  Call ReFormat_DateLabels

End Sub

Private Sub cmd_Save_Click()
  If Me.txt_SelectedDate.Value = "" Then
    MsgBox "Please select a date by selecting a day in the calendar or press Cancel to exit.", vbOKOnly, TTS_TITLE
    Exit Sub
  End If
  Me.Hide
End Sub

Private Sub cmdClose_Click()
  Me.Width = 183
End Sub

Private Sub cmdGetRange_Click()
  frmGetRangeFromUser.Show
  If frmGetRangeFromUser.Tag Then
    lblRange.Caption = frmGetRangeFromUser.strNewRange
  End If
  Unload frmGetRangeFromUser
End Sub

Private Sub cmdHelp_Click()
  Const DATE_HELP_MSG = "To enter a series of incremented dates in a range begin by selecting " & _
      "a range to enter dates into by pressing the select button.  Then " & _
      "select date increment period to add to your start date from the 'Increment Date By' drop down box. " & _
      "Choose to enter date values or the date formulas into the selected range.  " & _
      "Using formulas is useful if you plan on changing the start date in your sheet.  " & _
      "Finally, select a date format to apply to the entered dates.  You may enter your " & _
      "own custom date formats into the 'Date Format' box, or select one from the list." & vbCr & vbCr & _
      "The date you selected in the calendar is your initial (start) date."

  MsgBox DATE_HELP_MSG, vbOKOnly, TTS_TITLE
End Sub

Private Sub cmdMore_Click()
  Me.Width = 291.75
End Sub


Private Sub lbl_Cal01_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal01

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal02_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal02

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal03_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal03

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal04_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal04

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal05_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal05

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal06_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal06

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal07_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal07

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal08_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal08

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal09_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal09

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal10_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal10

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal11_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal11

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal12_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal12

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal13_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal13

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal14_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal14

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal15_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal15

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal16_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal16

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal17_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal17

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal18_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal18

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal19_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal19

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal20_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal20

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal21_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal21

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal22_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal22

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal23_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal23

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal24_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal24

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal25_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal25

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal26_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal26

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal27_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal27

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal28_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal28

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal29_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal29

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal30_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal30

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal31_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal31

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal32_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal32

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal33_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal33

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal34_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal34

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal35_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal35

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal36_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal36

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal37_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal37

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal38_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal38

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal39_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal39

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal40_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal40

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal41_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal41

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub lbl_Cal42_Click()

  '   Local Variables
  Dim objFrmLbl As msforms.Label

  '   Step 1 : Identify this label
  Set objFrmLbl = Me.lbl_Cal42

  '   Step 2 : Post selected date
  Me.txt_SelectedDate = objFrmLbl.Tag

  '   Step 3 : Update label formats
  Call ReFormat_DateLabels

  '    Me.Hide

End Sub

Private Sub spb_Month_SpinDown()

  '   Local Variables

  If Me.Tag <> "" Then Exit Sub
  Me.Tag = "SpinButtonUpdate"

  '   Step 1 : Determine next year value to display
  If Me.spb_Month = Me.spb_Month.Min Then
    Me.spb_Month = Me.spb_Month.Max - 1
    Me.cbo_SelectMonth.ListIndex = Me.spb_Month
    If Me.cbo_SelectYear.ListIndex = 0 Then
      Me.cbo_SelectYear.ListIndex = Me.cbo_SelectYear.ListCount - 1
      Me.spb_Year = Me.cbo_SelectYear
    Else
      Me.cbo_SelectYear.ListIndex = Me.cbo_SelectYear.ListIndex - 1
      Me.spb_Year = Me.cbo_SelectYear
    End If
  Else
    Me.cbo_SelectMonth.ListIndex = Me.spb_Month.Value
  End If
  Call UpdateCalendarDisplay
  Call ReFormat_DateLabels

  Me.Tag = ""
End Sub

Private Sub spb_Month_SpinUp()

  '   Local Variables

  If Me.Tag <> "" Then Exit Sub
  Me.Tag = "SpinButtonUpdate"

  '   Step 1 : Determine next year value to display
  If Me.spb_Month = Me.spb_Month.Max Then
    Me.spb_Month = Me.spb_Month.Min + 1
    Me.cbo_SelectMonth.ListIndex = Me.spb_Month
    If Me.cbo_SelectYear = Me.spb_Year.Max - 1 Then
      Me.cbo_SelectYear.ListIndex = 0
      Me.spb_Year = Me.cbo_SelectYear
    Else
      Me.cbo_SelectYear.ListIndex = Me.cbo_SelectYear.ListIndex + 1
      Me.spb_Year = Me.cbo_SelectYear
    End If
  Else
    Me.cbo_SelectMonth.ListIndex = Me.spb_Month.Value
  End If
  Call UpdateCalendarDisplay
  Call ReFormat_DateLabels

  Me.Tag = ""
End Sub

Private Sub spb_Year_Change()

  '   Local Variables
  Dim intYear As Integer

  If Me.Tag <> "" Then Exit Sub
  Me.Tag = "SpinButtonUpdate"

  '   Step 1 : Determine next year value to display
  If Me.spb_Year = Me.spb_Year.Min Then
    Me.cbo_SelectYear = Me.spb_Year.Max - 1
    Me.spb_Year = Me.spb_Year.Max - 1
  ElseIf Me.spb_Year = Me.spb_Year.Max Then
    Me.cbo_SelectYear = Me.spb_Year.Min + 1
    Me.spb_Year = Me.spb_Year.Min + 1
  Else
    Me.cbo_SelectYear = Me.spb_Year.Value
  End If
  Call UpdateCalendarDisplay
  Call ReFormat_DateLabels

  Me.Tag = ""
End Sub

Private Sub txt_SelectedDate_Change()
  If Me.cboUseThisDateFormat.Value <> "" Then
    Me.txt_SelectedDate.Value = Format(Me.txt_SelectedDate.Value, Me.cboUseThisDateFormat.Value)
  End If
End Sub

Private Sub UserForm_Initialize()

  '   Local Variables
  Dim intCount As Integer
  Me.Width = 183
  '   Step 1 : Initialize Calendar form
  Me.Tag = "Loading"
  ' 1a : Populate selection forms
  For intCount = -10 To 30
    If 1 <= intCount And intCount <= 12 Then Me.cbo_SelectMonth.AddItem Format(DateSerial(2005, intCount, 15), "mmmm")
    Me.cbo_SelectYear.AddItem Year(Now()) + intCount
  Next intCount
  Me.spb_Year.Max = Me.cbo_SelectYear.List(Me.cbo_SelectYear.ListCount - 1) + 1
  Me.spb_Year.Min = Me.cbo_SelectYear.List(0) - 1
  ' Enter items into date entery controls
  With Me.cboIncrementDate
    .AddItem "Month"
    .AddItem "Day"
    .AddItem "Year"
    .AddItem "Quarter"
    .AddItem "Week"
  End With

  With Me.cboUseThisDateFormat
    .AddItem "m/d/yyyy;@"
    .AddItem "m/d/yy;@"
    .AddItem "mmm-d-yy;@"
    .AddItem "m-yy;@"
    .AddItem "mmm-yyyy;@"
    .AddItem "m/yyyy;@"
    .AddItem "d-m-yyyy;@"
    .AddItem "d-mmm;@"
    .AddItem "d-mmm-yy;@"
    .AddItem "d-mmm-yyyy;@"
    .AddItem "[$-409]mmmm d, yyyy;@"
  End With
  '    ' 1b : Set current month / year
  Call cmd_GotoToday_Click
  Me.Tag = ""

  '   Step 2 : Update displayed calendar
  Call UpdateCalendarDisplay
  Call ReFormat_DateLabels

End Sub

'  Form Procedures above
'
'**********************************************************************************************
'
'  General Procedures Below

Sub UpdateCalendarDisplay()

  '   Local Variables
  Dim ctrlLbl As msforms.Label
  Dim intFirstDOMDOW As Integer, intDateCount As Integer, intLblCnt As Integer
  Dim dteAnchorDate As Date

  '   Step 1 : Determine which DOW first of selected month is on
  intFirstDOMDOW = Weekday(DateSerial(CInt(Me.cbo_SelectYear), Me.cbo_SelectMonth.ListIndex + 1, 1))
  dteAnchorDate = DateSerial(CInt(Me.cbo_SelectYear), Me.cbo_SelectMonth.ListIndex + 1, 1)
  intDateCount = 1 - intFirstDOMDOW

  '   Step 2 : Fill labels with information
  For intLblCnt = 1 To 42
    Set ctrlLbl = Me.Controls("lbl_Cal" & Right("00" & intLblCnt, 2))
    ctrlLbl.Caption = Day(DateAdd("d", intDateCount, dteAnchorDate))
    ctrlLbl.ControlTipText = Format(DateAdd("d", intDateCount, dteAnchorDate), "mmm d, yyyy")
    ctrlLbl.Tag = DateAdd("d", intDateCount, dteAnchorDate)
    intDateCount = intDateCount + 1
  Next intLblCnt

End Sub

Sub ReFormat_DateLabels()

  '   Local Variables
  Static blnCrntValsStored As Boolean
  Static lngCrntBckColor As Long
  Static lngCrntForColor As Long
  Static intCrntSpcEffct As Integer
  Static blnSelValsStored As Boolean
  Static lngSelBckColor As Long
  Static lngSelForColor As Long
  Static intSelSpcEffct As Integer
  Static blnOtherValsStored As Boolean
  Static lngOtherBckColor As Long
  Static lngOtherForColor As Long
  Static intOtherSpcEffct As Integer
  Static blnGenValsStored As Boolean
  Static lngGenBckColor As Long
  Static lngGenForColor As Long
  Static intGenSpcEffct As Integer

  Dim dteSel As Date, dteThisDate As Date
  Dim intMonth As Integer, intYear As Integer, intCount As Integer
  Dim ctrlThis As msforms.Label


  '   Step 1 : Get properties of special date labels
  ' 1a : Crnt System Date ( formatting )
  If Not blnCrntValsStored Then
    lngCrntBckColor = Me.lbl_CrntDteTme.BackColor
    lngCrntForColor = Me.lbl_CrntDteTme.ForeColor
    intCrntSpcEffct = Me.lbl_CrntDteTme.SpecialEffect
  End If
  ' 1b : Selected Date    ( formatting )
  If Not blnSelValsStored Then
    lngSelBckColor = Me.lbl_SelDte.BackColor
    lngSelForColor = Me.lbl_SelDte.ForeColor
    intSelSpcEffct = Me.lbl_SelDte.SpecialEffect
  End If
  ' 1c : Other Month Date ( formatting )
  If Not blnOtherValsStored Then
    lngOtherBckColor = Me.lbl_OtherMonthDte.BackColor
    lngOtherForColor = Me.lbl_OtherMonthDte.ForeColor
    intOtherSpcEffct = Me.lbl_OtherMonthDte.SpecialEffect
  End If
  ' 1d : General Date     ( formatting )
  If Not blnGenValsStored Then
    lngGenBckColor = Me.lbl_ThisMonthGeneral.BackColor
    lngGenForColor = Me.lbl_ThisMonthGeneral.ForeColor
    intGenSpcEffct = Me.lbl_ThisMonthGeneral.SpecialEffect
  End If

  '   Step 2 : Retrieve crnt information
  ' 2a : Retrieve selected date
  If Me.txt_SelectedDate <> "" Then dteSel = CDate(Me.txt_SelectedDate)
  ' 2b : Retrieve crnt sel month
  intMonth = Me.cbo_SelectMonth.ListIndex + 1
  ' 2c : Retrieve crnt sel year
  intYear = CInt(Me.cbo_SelectYear)

  '   Step 3 : Make sure selecte date is in crnt month
  If Me.txt_SelectedDate <> "" And Me.Tag = "" Then
    If Month(dteSel) <> intMonth Then
      Me.cbo_SelectMonth.ListIndex = Month(dteSel) - 1
      Me.cbo_SelectYear = Year(dteSel)
      Call UpdateCalendarDisplay
    End If
  End If

  '   Step 4 : Set visible settings for labels
  For intCount = 1 To 42
    Set ctrlThis = Me.Controls("lbl_Cal" & Right("00" & intCount, 2))
    dteThisDate = CDate(ctrlThis.Tag)
    If dteThisDate = dteSel Then
      ctrlThis.BackColor = lngSelBckColor
      ctrlThis.ForeColor = lngSelForColor
      ctrlThis.SpecialEffect = intSelSpcEffct
    ElseIf dteThisDate = DateSerial(Year(Now()), Month(Now()), Day(Now())) Then
      ctrlThis.BackColor = lngCrntBckColor
      ctrlThis.ForeColor = lngCrntForColor
      ctrlThis.SpecialEffect = intCrntSpcEffct
    ElseIf Format(dteThisDate, "mmmm") <> Me.cbo_SelectMonth Then
      ctrlThis.BackColor = lngOtherBckColor
      ctrlThis.ForeColor = lngOtherForColor
      ctrlThis.SpecialEffect = intOtherSpcEffct
    Else
      ctrlThis.BackColor = lngGenBckColor
      ctrlThis.ForeColor = lngGenForColor
      ctrlThis.SpecialEffect = intGenSpcEffct
    End If
  Next intCount

End Sub

Sub SelectMe(objSelectedLabel As msforms.Label)

  '   Local Variables

  '   Step 1 : Determine if selected label is in current month


End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)

  If CloseMode = 0 Then
    Cancel = True
    Me.Tag = "Canceled"
    Me.Hide
  End If

End Sub
Attribute VB_Name = "frmErrors"
Attribute VB_Base = "0{459253DC-B6BA-4DB4-9ACD-9EFFEB4C5EB2}{219FCFB0-2AF3-472D-B741-E5AECD1868ED}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private Const msModule As String = "frmErrors"

'Private sEmailText As String

'Private Sub cmdEmail_Click()
'    'Build hyperlink string
'    'create a hyperlink object
'    Dim sHLink As String
'    sHLink = "mailto:David.Fontanelli@XiosTech.com?Subject=TTS Turbo Error Log?&body=" & sEmailText
'    wksMenu.Hyperlinks.Add Anchor:=wksMenu.Range("EmailHyperlink"), Address:="mailto:David.Fontanelli@XiosTech.com?Subject=TTS Turbo Error Log"
'    Me.Tag = "Email"
'    Me.Hide
'End Sub

Private Sub cmdOK_Click()
  Me.Tag = "OK"
  Me.Hide
End Sub


Private Sub UserForm_Initialize()
  Const sSOURCE As String = "UserForm_Initialize()"
  Dim sPath As String
  Dim sFileDescription As String
  On Error GoTo ErrorHandler

  sPath = ThisWorkbook.Path & "\" & "Error.log"
  sFileDescription = "Contents of file " & sPath

  'If Len(sPath) = 0 Then sPath = ThisWorkbook.Path & "\Error.log"
  'If Len(sFileDescription) = 0 Then sFileDescription = "Contents of File " & sPath
  ' Open the text file (if found), read the contents and
  ' put into the text box.
  ' Then close the text file.
  Dim InputData
  Dim sText As String
  sText = ""
  If IsValid(sPath) Then
    Open sPath For Input As #1      ' Open file for input.
    Do While Not EOF(1)             ' Check for end of file.
      Line Input #1, InputData    ' Read line of data.
      sText = sText & vbCrLf & InputData   ' Capture the text to variable.
      'sEmailText = sEmailText & "%0A" & InputData 'No longer used
    Loop
    Close #1    ' Close file.
  Else
    sFileDescription = "No errors found."
  End If

  Me.txtFileContents.Text = sText  'Place text into textbox
  Me.lblDescription.Caption = sFileDescription

ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Sub
Attribute VB_Name = "frmFillRight"
Attribute VB_Base = "0{4BCC467E-0904-4BE7-BA5D-EEE03A5C7ED0}{720D86AF-F369-407B-846D-BA3C038B1BFE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Const FILL_RIGHT_HELP_MSG As String = "Select a range by dragging your cursor over the cells of the active worksheet."
Const ENTER_RANGE_MSG As String = "Please select a valid range."
Private strNewRange As String
Private Sub cmdCancel_Click()
  Me.Tag = False
  Me.Hide
End Sub

Private Sub cmdHelp_Click()
  MsgBox FILL_RIGHT_HELP_MSG, vbOKOnly, TTS_MSG_TITLE
End Sub

Private Sub cmdOK_Click()
  strNewRange = Me.refFillRightRange.Value
  If Me.refFillRightRange.Value = "" Then MsgBox ENTER_RANGE_MSG: Exit Sub
  If Left(strNewRange, 1) <> "=" Then strNewRange = "=" & strNewRange
  ActiveSheet.Names.Add "FillRight", strNewRange
  gintLastColumn = ActiveSheet.Range("FillRight").Offset(, Range("FillRight").Columns.Count - 1).Resize(1, 1).Column
  Me.Tag = True
  Me.Hide
End Sub

Private Sub UserForm_Initialize()
  Dim r As String
  On Error Resume Next
  r = ActiveSheet.Names("FillRight")
  On Error GoTo 0

  If r <> "" Then  'set the previous range
    Me.refFillRightRange.Value = ActiveSheet.Names("FillRight")
  End If
End Sub

Attribute VB_Name = "frmGetRangeFromUser"
Attribute VB_Base = "0{2060D308-94AF-46E4-A5FF-8131361056C9}{AA44CF26-E074-439A-8001-9A968C4CE8FA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Const FILL_RIGHT_HELP_MSG As String = "Select a range by dragging your cursor over the cells of the active worksheet."
Const ENTER_RANGE_MSG As String = "Please select a valid range or press Cancel."
Public strNewRange As String
Private Sub cmdCancel_Click()
  Me.Tag = False
  Me.Hide
End Sub

Private Sub cmdHelp_Click()
  MsgBox FILL_RIGHT_HELP_MSG, vbOKOnly, TTS_MSG_TITLE
End Sub

Private Sub cmdOK_Click()
  strNewRange = Me.refSelectedRange.Value
  If Me.refSelectedRange.Value = "" Then MsgBox ENTER_RANGE_MSG: Exit Sub
  'If Left(strNewRange, 1) <> "=" Then strNewRange = "=" & sNewRange
  Me.Tag = True
  Me.Hide
End Sub

Attribute VB_Name = "frmSheetControl"
Attribute VB_Base = "0{6DAC7EFC-7D46-4D29-ABD2-2E7C955A115D}{D4B76353-B58B-4BDE-BC48-AD4A6E959943}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_Initialize()
  ' retrieve values
  Me.tbx_zoom.Value = wksMenu.Range("ZoomPctg").Value
  If wksMenu.Range("PageViewStyle").Value Then
    Me.obn_view_normal.Value = True
  Else
    Me.obn_view_pgbreak.Value = True
  End If
  If wksMenu.Range("ShowGridlines").Value Then
    Me.obn_grid_show.Value = True
  Else
    Me.obn_grid_hide.Value = True
  End If
  If wksMenu.Range("ShowRowColHeaders").Value Then
    Me.obn_header_show.Value = True
  Else
    Me.obn_header_hide.Value = True
  End If
  
End Sub

Private Sub cmd_Cancel_Click()
  Unload Me
End Sub

Private Sub cmd_OK_Click()
  Dim zoom_val As Long
  
  '/ check zoom number
  zoom_val = Me.tbx_zoom.Value
  If zoom_val < 25 Or zoom_val > 400 Then
    MsgBox "Error: Zoom percentage must be between 25 and 400!"
    Me.tbx_zoom.Value = 100
    Exit Sub
  End If

  Call TTS_Sheet_Control(Me.tbx_zoom.Value, Me.obn_grid_show.Value, Me.obn_header_show.Value, Me.obn_view_normal.Value)
  
  ' store values for next time
  wksMenu.Range("ZoomPctg").Value = Me.tbx_zoom.Value
  wksMenu.Range("PageViewStyle").Value = Me.obn_view_normal.Value
  wksMenu.Range("ShowGridlines").Value = Me.obn_grid_show.Value
  wksMenu.Range("ShowRowColHeaders").Value = Me.obn_header_show.Value
  ThisWorkbook.Save
  
  Unload Me
  
End Sub

Attribute VB_Name = "frmTTSOptions"
Attribute VB_Base = "0{EF27FC87-8925-4A2E-8128-BD8014704431}{9D411240-AE1C-479D-AB9D-7FDCD8702212}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Const SELECT_FROM_PALETTE As String = "You cannot choose a custom color, please select from the palette only."
Const ALREADY_SET_ERR_MSG As String = "That setting has already been assigned."
Const COLOR_ERR_MSG As String = "Problem getting color selection. New color not set."
Const STYLE_ERR_MSG As String = "Problem getting style selection. New style not set."
Const FONT_ERR_MSG As String = "Problem getting font color selection. New font color not set."
Const NUMBER_ERR_MSG As String = "Problem getting number format selection. New format not set."
Const DUP_FONTCOLOR_MSG As String = "You have selected duplicate font colors on the font color toggle tab, please make sure that each color is selected only once."
Const DUP_FILLCOLOR_MSG As String = "You have selected duplicate font colors on the fill color toggle tab, please make sure that each color is selected only once."
Const DUP_NUMBERFORMAT_MSG As String = "You have selected duplicate number formats on the number format toggle tab, please make sure that each number format is selected only once."
'Const UNDO_EXPLAINED_MSG As String = "All the actions performed by " & TTS_TITLE & " can be undone by " & _
 "selecting Edit>Undo, Ctrl+Z or TTS>Turbo Undo." & vbCrLf & _
 "You may want to turn this feature off if you have an extremely large " & _
 "workbook and you are running into memory contraints."
'Const EVENT_TRAPS_EXPLAINED_MSG As String = "The AutoColor feature of " & TTS_TITLE & " requires spreadsheet " & _
 "event trapping.  If you have a workbook that contains macros that rely on " & _
 "events, such as the worksheet_change events, you may experience unexpected " & _
 "behaviors due to the order of event processing.  If this is the case, turn off " & _
 "event trapping in " & TTS_TITLE & " while the other workbook is open.  You may also " & _
 "turn off event trapping if you DO NOT use the AutoColor feature."
Const ZOOM_INCREMENT_EXPLAINED_MSG As String = "Allows you to set the window zoom increments (in %) used by " & _
    "the Turbo Increase/Decrease Zoom menu options"
'Const AUTOCOLOR_APPLY_ATTRIBUTES_EXPAINED_MSG As String = "Allows you to apply only certain aspects of cell formats.  For " & vbCrLf & _
 "example, you may wish to apply the bold and color formats to a font used to denote sheet formulas, but not the font " & vbCrLf & _
 "type (arial, times new roman, etc) or its alignment."
'Const AUTOFILLRIGHT_EXPLAINED_MSG As String = "The AutoFill Right feature takes the currently selected cells and " & _
 "automatically copies them over to the right-most used column in your spreadsheet. " & _
 "This is useful on sheets that contain a header row with formulas beneath them. " & _
 "However, if there is data to the right of your header then the fill will go past your header row. " & _
 "In this case you want to explicitly set your header row.  To do this select 'Let me select the Auto Fill header range' " & _
 "You will automatically be prompted to select your header row when you select 'TTS>Turbo Fill Right' or Ctrl+Shift+R " & vbCrLf & vbCr & _
 "You can change the header row at any time by selecting the 'TTS>Turbo Set Fill Right Range' menu option. " & _
 "Each sheet in your workbook can have its own header row."
Const CUSTOM_COLORS_EXPLAINED_MSG As String = "Allows you to import a custom color palette from another workbook.  This is especially useful for users " & vbCr & _
    "that consistently use a standardized custom palette.  Importing a custom palette is required if you want the Turbo Auto Color " & vbCr & _
    "feature to work with your desired colors."
Const FILLCOLOR_HELP_MSG As String = "Allows you to select your own custom cell background colors for the Turbo Pattern Toggle menu option. " & vbCrLf & _
    "Uncheck the check box if you want to remove the color from the toggle order. If your workbook has a custom color palette, then " & vbCrLf & _
    "reselect the colors in the list to reflect your desired colors from the new palette."
Const FONTCOLOR_HELP_MSG As String = "Allows you to select your own custom cell font colors for the Font Color Toggle menu option." & vbCrLf & _
    "Uncheck the check box if you want to remove the color from the toggle order. If your workbook has a custom color palette, then " & vbCrLf & _
    "reselect the colors in the list to reflect your desired colors from the new palette."
Const NUMBERFORMAT_HELP_MSG As String = "Allows you to select your own custom number formats for the Number Toggle menu option."
Const AUTOCOLOR_HELP_MSG As String = "Allows you to make changes to the cell font color used by the AutoColor feature." & vbCrLf & vbCr & _
    "Formula (same sheet): a cell formula that contains a reference to a cell within the same sheet." & vbCr & _
    "Reference (different sheet): a cell formula that contains a reference to another sheet in the same workbook." & vbCr & _
    "Link (different file): a cell formula that contains a reference to a cell in another workbook." & vbCr & _
    "Numeric Input: a cell that contains just a number OR a formula WITHOUT references to other cells (ie. =5+5 or just 5)" & vbCr & _
    "Text Constant = a cell that just contains text."
'"Hyperlink = a cell that contains a URL link. If a cell contains both text and a hyperlink, it will format as a hyperlink."
Const HELP_TITLE As String = "TTS Help"
Private Const msModule As String = "frmTTSOptions"
''-------------------------------------------------------
Dim clsShortcutControls() As New CShortcutControls

''#######################################################
'' J Peltier - Shortcut Keys
''=======================================================
Private Sub btnKeysDefault_Click()
  ShortcutKeysApplyDefault Me
End Sub
''-------------------------------------------------------
Private Sub btnKeysPrevious_Click()
  ShortcutKeysShowCurrent Me
End Sub
''-------------------------------------------------------
Private Sub btnShortCutKeyHelp_Click()
  ShortcutKeysHelp
End Sub
''#######################################################

Private Sub cmdFillColorHelp_Click()
  MsgBox FILLCOLOR_HELP_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdFontColorHelp_Click()
  MsgBox FONTCOLOR_HELP_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdNumberHelp_Click()
  MsgBox NUMBERFORMAT_HELP_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdAutoColorHelp_Click()
  MsgBox AUTOCOLOR_HELP_MSG, vbOKOnly, HELP_TITLE
End Sub

Private Sub cmdAbout_Click()
  frmAbout.Show
End Sub
Private Sub cmdCancel_Click()
  UndoOnCancel
  Unload frmTTSOptions
  'frmTTSOptions.Hide
End Sub

Private Sub cmdResetAllDefaults_Click()
  ResetDefault "cmdResetColor"
  ResetDefault "cmdResetFontColor"
  ResetDefault "cmdResetDefaultStyle"
  ResetDefault "cmdResetNumberFormat"

  ShortcutKeysApplyDefault Me

End Sub

Private Function CheckForDuplicates() As Boolean
  CheckForDuplicates = True
  Dim c As Range, i As Integer, strRange As String

  For i = 1 To 3
    strRange = Application.WorksheetFunction.Choose(i, "FontColor", "FillColor", "NumberFormat")
    For Each c In wksMenu.Range(strRange)
      If AlreadySet(strRange, c) Then
        If (strRange = "FontColor") Then  'And c.Offset(0, -2).Value  'And c.Font.ColorIndex <> xlColorIndexAutomatic
          MsgBox DUP_FONTCOLOR_MSG, vbCritical, "Fix problem to continue"
          Exit Function
        End If
        If (strRange = "FillColor") Then  '
          'If c.Interior.ColorIndex = xlColorIndexNone And Not (c.Offset(0, -2).Value) Then GoTo NextOne:
          MsgBox DUP_FILLCOLOR_MSG, vbCritical, "Fix problem to continue"
          Exit Function
        End If
        If strRange = "NumberFormat" Then
          MsgBox DUP_NUMBERFORMAT_MSG, vbCritical, "Fix problem to continue"
          Exit Function
        End If
      End If
NextOne:
    Next
  Next
  CheckForDuplicates = False
End Function

Private Sub cmdOK_Click()
  ''Debug.Print Timer, "OK Button Pressed"
  If txtZoomIncrement.Value < 1 Or txtZoomIncrement.Value > 50 Then
    MsgBox "Please select a zoom increment value between 1 and 50.", vbOKOnly, HELP_TITLE
    Exit Sub
  End If

  If CheckForDuplicates() Then Exit Sub
  ''Debug.Print Timer, "saving changes"
  SaveChanges
  'AddStyles
  ''Debug.Print Timer, "adding styles"
  CaptureOtherOptions
  'EventTrapping chkEnableEventTrapping.Value, EVENT_TRAP_ALLTRAPS 'event trapping may have been changed

  ''Debug.Print Timer, "applying shortcut keys"
  ShortcutKeysApplyNew Me

  ''Debug.Print Timer, "unloading form"
  Unload frmTTSOptions
  'frmTTSOptions.Hide
End Sub
'========================================================
' Other Options Tab Control Events
'========================================================
Private Sub cmdExplainCustomColors_Click()
  MsgBox CUSTOM_COLORS_EXPLAINED_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdExplainEventTrapping_Click()
  'MsgBox EVENT_TRAPS_EXPLAINED_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdExplainUndo_Click()
  'MsgBox UNDO_EXPLAINED_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdExplainZoom_Click()
  MsgBox ZOOM_INCREMENT_EXPLAINED_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdExplainAutoFillRight_Click()
  'MsgBox AUTOFILLRIGHT_EXPLAINED_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdViewColorPalette_Click()
  Dim sCurWkb As String
  sCurWkb = ActiveWorkbook.Name
  ThisWorkbook.Activate
  Application.Dialogs(xlDialogColorPalette).Show
  Workbooks(sCurWkb).Activate
End Sub
'========================================================
' Fill Toggle Tab Control Events
'========================================================
Private Sub chkFillEnabled1_Click()
  wksMenu.Range("FillEnabled1").Value = chkFillEnabled1.Value
End Sub
Private Sub chkFillEnabled2_Click()
  wksMenu.Range("FillEnabled2").Value = chkFillEnabled2.Value
End Sub
Private Sub chkFillEnabled3_Click()
  wksMenu.Range("FillEnabled3").Value = chkFillEnabled3.Value
End Sub
Private Sub chkFillEnabled4_Click()
  wksMenu.Range("FillEnabled4").Value = chkFillEnabled4.Value
End Sub
Private Sub chkFillEnabled5_Click()
  wksMenu.Range("FillEnabled5").Value = chkFillEnabled5.Value
End Sub
Private Sub cmdNewColor1_Click()
  If Not GetColorFromUser(Me.txtColor1, Me.lblColor1) Then MsgBox COLOR_ERR_MSG
End Sub
Private Sub cmdNewColor2_Click()
  If Not GetColorFromUser(Me.txtColor2, Me.lblColor2) Then MsgBox COLOR_ERR_MSG
End Sub
Private Sub cmdNewColor3_Click()
  If Not GetColorFromUser(Me.txtColor3, Me.lblColor3) Then MsgBox COLOR_ERR_MSG
End Sub
Private Sub cmdNewColor4_Click()
  If Not GetColorFromUser(Me.txtColor4, Me.lblColor4) Then MsgBox COLOR_ERR_MSG
End Sub
Private Sub cmdNewColor5_Click()
  If Not GetColorFromUser(Me.txtColor5, Me.lblColor5) Then MsgBox COLOR_ERR_MSG
End Sub
Private Sub cmdResetColor_Click()
  ResetDefault Me.cmdResetColor.Name
End Sub
'========================================================
' Font Color Toggle Tab Control Events
'========================================================
Private Sub chkFontEnabled1_Click()
  wksMenu.Range("FontEnabled1").Value = chkFontEnabled1.Value
End Sub
Private Sub chkFontEnabled2_Click()
  wksMenu.Range("FontEnabled2").Value = chkFontEnabled2.Value
End Sub
Private Sub chkFontEnabled3_Click()
  wksMenu.Range("FontEnabled3").Value = chkFontEnabled3.Value
End Sub
Private Sub chkFontEnabled4_Click()
  wksMenu.Range("FontEnabled4").Value = chkFontEnabled4.Value
End Sub
Private Sub chkFontEnabled5_Click()
  wksMenu.Range("FontEnabled5").Value = chkFontEnabled5.Value
End Sub
Private Sub cmdFontColor1_Click()
  If Not GetColorFromUser(Me.txtFontColor1, Me.lblFontColor1) Then MsgBox FONT_ERR_MSG
End Sub
Private Sub cmdFontColor2_Click()
  If Not GetColorFromUser(Me.txtFontColor2, Me.lblFontColor2) Then MsgBox FONT_ERR_MSG
End Sub
Private Sub cmdFontColor3_Click()
  If Not GetColorFromUser(Me.txtFontColor3, Me.lblFontColor3) Then MsgBox FONT_ERR_MSG
End Sub
Private Sub cmdFontColor4_Click()
  If Not GetColorFromUser(Me.txtFontColor4, Me.lblFontColor4) Then MsgBox FONT_ERR_MSG
End Sub
Private Sub cmdFontColor5_Click()
  If Not GetColorFromUser(Me.txtFontColor5, Me.lblFontColor5) Then MsgBox FONT_ERR_MSG
End Sub
Private Sub cmdResetFontColor_Click()
  ResetDefault Me.cmdResetFontColor.Name
End Sub
'========================================================
' Auto Color Tab Control Events
'========================================================
Private Sub cmdExplainAutoColor_Click()
  'MsgBox AUTOCOLOR_APPLY_ATTRIBUTES_EXPAINED_MSG, vbOKOnly, HELP_TITLE
End Sub
Private Sub cmdAutoHyperlink_Click()
  If Not GetColorFromUser(Me.txtAutoHyperlink, Me.lblAutoHyperlink) Then MsgBox STYLE_ERR_MSG
End Sub
Private Sub cmdAutoTextConstant_Click()
  If Not GetColorFromUser(Me.txtAutoTextConstant, Me.lblAutoTextConstant) Then MsgBox STYLE_ERR_MSG
End Sub
Private Sub cmdAutoValueConstant_Click()
  If Not GetColorFromUser(Me.txtAutoValueConstant, Me.lblAutoValueConstant) Then MsgBox STYLE_ERR_MSG
End Sub
Private Sub cmdAutoWorkbookFormula_Click()
  If Not GetColorFromUser(Me.txtAutoWorkbookFormula, Me.lblAutoWorkbookFormula) Then MsgBox STYLE_ERR_MSG
End Sub
Private Sub cmdAutoOtherWorksheetFormula_Click()
  If Not GetColorFromUser(Me.txtAutoOtherWorksheetFormula, Me.lblAutoOtherWorksheetFormula) Then MsgBox STYLE_ERR_MSG
End Sub
Private Sub cmdAutoExternalFormula_Click()
  If Not GetColorFromUser(Me.txtAutoExternalFormula, Me.lblAutoExternalFormula) Then MsgBox STYLE_ERR_MSG
End Sub
Private Sub cmdResetDefaultStyle_Click()
  ResetDefault Me.cmdResetDefaultStyle.Name
End Sub
'========================================================
' Number Format Tab Control Events
'========================================================
Private Sub cmdNumberFormat1_Click()
  If Not GetNumberFormatFromUser(Me.lblNumberFormat1) Then MsgBox NUMBER_ERR_MSG
End Sub
Private Sub cmdNumberFormat2_Click()
  If Not GetNumberFormatFromUser(Me.lblNumberFormat2) Then MsgBox NUMBER_ERR_MSG
End Sub
Private Sub cmdNumberFormat3_Click()
  If Not GetNumberFormatFromUser(Me.lblNumberFormat3) Then MsgBox NUMBER_ERR_MSG
End Sub
Private Sub cmdNumberFormat4_Click()
  If Not GetNumberFormatFromUser(Me.lblNumberFormat4) Then MsgBox NUMBER_ERR_MSG
End Sub
Private Sub cmdNumberFormat5_Click()
  If Not GetNumberFormatFromUser(Me.lblNumberFormat5) Then MsgBox NUMBER_ERR_MSG
End Sub
Private Sub cmdResetNumberFormat_Click()
  ResetDefault Me.cmdResetNumberFormat.Name
End Sub
Private Sub chkNumEnabled1_Click()
  wksMenu.Range("NumEnabled1").Value = chkNumEnabled1.Value
End Sub
Private Sub chkNumEnabled2_Click()
  wksMenu.Range("NumEnabled2").Value = chkNumEnabled2.Value
End Sub
Private Sub chkNumEnabled3_Click()
  wksMenu.Range("NumEnabled3").Value = chkNumEnabled3.Value
End Sub
Private Sub chkNumEnabled4_Click()
  wksMenu.Range("NumEnabled4").Value = chkNumEnabled4.Value
End Sub
Private Sub chkNumEnabled5_Click()
  wksMenu.Range("NumEnabled5").Value = chkNumEnabled5.Value
End Sub
'========================================================
' Dialog Routines
'========================================================
Function GetStyleFromUser(ByRef lblLabel As Object) As Boolean
  Const sSOURCE As String = "SetLabelStyle()"
  Dim strStyleName As String
  On Error GoTo ErrorHandler
  strStyleName = Mid(lblLabel.Name, 4)
  GetStyleFromUser = GetStyleInfo(strStyleName)

  SetLabelStyle lblLabel  'set the dialog box label to reflect new style format
ErrorExit:
  ' Cleanup code here.
  Exit Function
ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Function

Function SetLabelStyle(ByRef lblLabel As Object) As Boolean
  Const sSOURCE As String = "SetLabelStyle()"
  Dim strStyle As String
  On Error GoTo ErrorHandler
  strStyle = Mid(lblLabel.Name, 4)
  'With ThisWorkbook.Styles(Mid(lblLabel.Name, 4))
  'set up the dialog box label to look like the new style (as much as possible _
   given the limitations of label formats)
  With wksMenu.Range(strStyle)
    'lblLabel.Caption = "Current Style"
    'lblLabel.BackColor = .Interior.Color
    'lblLabel.Font.Name = .Font.Name

    If .Value = xlColorIndexAutomatic Then
      lblLabel.ForeColor = RGB(Red:=0, Green:=0, Blue:=0)
      lblLabel.Caption = "Black" ' "No Color"
    Else
      lblLabel.ForeColor = .Font.Color
      lblLabel.Caption = CellColorRGB(rCell:=wksMenu.Range(strStyle), blnCell:=False)
    End If

    'lblLabel.Font.Size = .Font.Size
    'lblLabel.Font.Italic = .Font.Italic
    'lblLabel.Font.Bold = .Font.Bold
    'lblLabel.Font.Size = .Font.Size
    'lblLabel.Font.Underline = IIf(.Font.Underline <> xlUnderlineStyleNone, True, False)
    'lblLabel.Font.Strikethrough = .Font.Strikethrough
  End With
  SetLabelStyle = True

ErrorExit:
  ' Cleanup code here.
  Exit Function
ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Function
Function AlreadySet(strAttribute, rSel As Range) As Boolean
  Const sSOURCE As String = "AlreadySet()"
  Dim blnMatch As Boolean
  Dim rngAttributes As Range
  Dim rCell As Range
  On Error GoTo ErrorHandler

  Set rngAttributes = wksMenu.Range(strAttribute)
  If Not (rSel.Offset(0, -2).Value) Then Exit Function
  For Each rCell In rngAttributes
    If rCell.Address = rSel.Address Then GoTo NextCell  'don't compare cell to itself
    If Not (rCell.Offset(0, -2).Value) Then GoTo NextCell  'user has not selected the color
    Select Case UCase(strAttribute)
      Case "FILLCOLOR": blnMatch = (rSel.Interior.ColorIndex = rCell.Interior.ColorIndex)  'And (rCell.Interior.ColorIndex <> xlColorIndexNone)
      Case "FONTCOLOR": blnMatch = (rSel.Font.ColorIndex = rCell.Font.ColorIndex)  'And (rCell.Font.ColorIndex <> xlColorIndexAutomatic)
      Case "NUMBERFORMAT": blnMatch = (rSel.NumberFormat = rCell.NumberFormat)
    End Select
    If blnMatch Then Exit For
NextCell:
  Next
  AlreadySet = blnMatch

ErrorExit:
  ' Cleanup code here.
  Exit Function

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Function

Function GetColorFromUser(ByRef txtBox As Object, lblLabel As Object) As Boolean
  'Allows the user to select a new color for the cell and font toggle option tabs
  Const sSOURCE As String = "GetColorFromUser()"
  Dim intNewColor As Long, strName As String
  'Dim varColorRGB As Variant, strName As String
  Dim blnCell As Boolean, intOrigColor As Long
  Dim rngC As Range, varOrig As Variant
  On Error GoTo ErrorHandler
  GetColorFromUser = False

  ThisWorkbook.Colors = Workbooks(ActiveWorkbook.Name).Colors
  'The txtbox name determines the cell range name we need to interogate
  strName = Mid(txtBox.Name, 4)
  blnCell = (Left(strName, 5) = "Color")
  Set rngC = wksMenu.Range(strName)
  'Grab the current cell color value (to reset if necessary)
  If blnCell Then intOrigColor = rngC.Interior.ColorIndex Else intOrigColor = rngC.Font.ColorIndex
  'Get the new color from the user
  intNewColor = GetColorInfo(rngC)

  SetColorOptions txtBox, lblLabel

  GetColorFromUser = True
  ''ThisWorkbook.ResetColors
  Exit Function

  'RESET:
  '    'reset the color cell that was just changed
  '    If blnCell Then rngC.Interior.ColorIndex = intOrigColor Else rngC.Font.ColorIndex = intOrigColor
  '    rngC.Value = varOrig

ErrorExit:
  ' Cleanup code here.
  Exit Function

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Function

Sub SetNumberOptions(ByRef lblLabel As Object, ByRef chkCheck As Object)

  lblLabel.Caption = wksMenu.Range(Mid(lblLabel.Name, 4)).NumberFormat
  chkCheck.Value = wksMenu.Range(Mid(chkCheck.Name, 4)).Value

End Sub

Sub SetColorOptions(ByRef txtBox As Object, ByRef lblLabel As Object, Optional ByRef chkCheck As Object)
  'Sets the color of the textbox and color name of the label passed in.
  'This allows the user to quickly see the color currently choosen on the dialog box
  'Dim aTokens() As String
  Const sSOURCE As String = "SetColorOptions()"
  Dim strRngName As String  ', strRGB As String
  Dim rngColor As Range
  Dim intColor As Integer
  On Error GoTo ErrorHandler

  strRngName = Mid(txtBox.Name, 4)
  Set rngColor = wksMenu.Range(strRngName)

  If Left(strRngName, 4) = "Font" Or Left(strRngName, 4) = "Auto" Then  'the textbox name determines the type of color we are after (cell or font)
    If rngColor.Value = xlColorIndexAutomatic Then
      txtBox.ForeColor = RGB(Red:=0, Green:=0, Blue:=0)
      lblLabel.Caption = "Automatic"
    Else
      'txtBox.ForeColor = rngColor.Font.Color
      'aTokens() = Split(rngColor.Value, " ") 'grb the RGB values stored in the cell
      txtBox.ForeColor = rngColor.Font.Color  'RGB(Red:=aTokens(0), Green:=aTokens(1), Blue:=aTokens(2))
      'strRGB = aTokens(0) & " " & aTokens(1) & " " & aTokens(2)
      lblLabel.Caption = CellColorRGB(rCell:=rngColor, blnCell:=False)
    End If
  Else
    If rngColor.Value = xlColorIndexNone Then
      txtBox.BackColor = RGB(Red:=255, Green:=255, Blue:=255)
      lblLabel.Caption = "No Color"
    Else
      'aTokens() = Split(rngColor.Value, " ") 'grb the RGB values stored in the cell
      'txtBox.BackColor = RGB(Red:=aTokens(0), Green:=aTokens(1), Blue:=aTokens(2))
      'strRGB = aTokens(0) & " " & aTokens(1) & " " & aTokens(2)
      txtBox.BackColor = rngColor.Interior.Color  'ThisWorkbook.Colors(rngColor.Value) 'rngColor.Interior.Color
      lblLabel.Caption = CellColorRGB(rCell:=rngColor, blnCell:=True)
    End If
  End If
  If Not (IsMissing(chkCheck)) Then chkCheck.Value = wksMenu.Range(Mid(chkCheck.Name, 4)).Value
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Sub

Function GetNumberFormatFromUser(ByRef lblLabel As Object) As Boolean
  'Allows the user to select a new color for the cell and font toggle option tabs
  Const sSOURCE As String = "GetNumberFormatFromUser()"
  Dim strFormat As String, strName As String, strOrigFormat As String
  Dim rngC As Range
  On Error GoTo ErrorHandler
  GetNumberFormatFromUser = False

  strName = Mid(lblLabel.Name, 4)
  strOrigFormat = wksMenu.Range(strName).NumberFormat
  Set rngC = wksMenu.Range(strName)
  strFormat = GetNumberInfo(wksMenu.Range(strName))
  '    If AlreadySet("NumberFormat", wksMenu.Range(strName)) Then
  '        MsgBox ALREADY_SET_ERR_MSG & " To skip this format in the toggle order, uncheck the check box.", , "Choose Again"
  '        rngC.NumberFormat = strOrigFormat
  '    Else
  lblLabel.Caption = strFormat
  '    End If
  GetNumberFormatFromUser = True
ErrorExit:
  ' Cleanup code here.
  Exit Function

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Function

Private Sub CaptureCurrentState()
  Const sSOURCE As String = "CaptureCurrentState()"
  Dim sStyle As Style, strName As String
  On Error GoTo ErrorHandler

  With wksMenu
    .Range("FillColor").Copy .Range("FillColorCurrent")
    .Range("FillEnabled").Copy .Range("FillEnabledCurrent")

    .Range("FontColor").Copy .Range("FontColorCurrent")
    .Range("FontEnabled").Copy .Range("FontEnabledCurrent")

    .Range("NumberFormat").Copy .Range("NumberFormatCurrent")
    .Range("CurrencyFormatEnabled").Copy .Range("CurrencyFormatEnabledCurrent")

    .Range("AutoColorStyles").Copy .Range("AutoColorCurrent")
  End With
ErrorExit:
  ' Cleanup code here.
  Application.CutCopyMode = False
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Sub

Private Sub ResetDefault(cmdCaller As String)
  Const sSOURCE As String = "ResetDefault()"
  Dim sStyle As Style
  On Error GoTo ErrorHandler

  With wksMenu
    Select Case UCase(cmdCaller)
      Case "CMDRESETCOLOR"
        .Range("DefaultFillColor").Copy .Range("FillColor")
        .Range("DefaultFillEnabled").Copy .Range("FillEnabled")
      Case "CMDRESETNUMBERFORMAT"
        .Range("DefaultNumberFormat").Copy .Range("NumberFormat")
        .Range("DefaultCurrencyFormatEnabled").Copy .Range("CurrencyFormatEnabled")
      Case "CMDRESETFONTCOLOR"
        .Range("DefaultFontColor").Copy .Range("FontColor")
        .Range("DefaultFontEnabled").Copy .Range("FontEnabled")
      Case "CMDRESETDEFAULTSTYLE"
        .Range("DefaultAutoColor").Copy .Range("AutoColorStyles")
    End Select
  End With
ErrorExit:
  ' Cleanup code here.
  UserForm_Initialize
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Sub
Private Sub UndoOnCancel()
  Const sSOURCE As String = "UndoOnCancel()"
  Dim sStyle As Style, strName As String
  Dim intCurCalcSetting As Integer
  On Error GoTo ErrorHandler
  intCurCalcSetting = Application.Calculation
  Application.Calculation = xlCalculationManual

  With wksMenu
    .Range("FillColorCurrent").Copy .Range("FillColor")
    .Range("FillEnabledCurrent").Copy .Range("FillEnabled")

    .Range("FontColorCurrent").Copy .Range("FontColor")
    .Range("FontEnabledCurrent").Copy .Range("FontEnabled")

    .Range("NumberFormatCurrent").Copy .Range("NumberFormat")
    .Range("CurrencyFormatEnabledCurrent").Copy .Range("CurrencyFormatEnabled")

    .Range("AutoColorCurrent").Copy .Range("AutoColorStyles")
  End With
ErrorExit:
  ' Cleanup code here.
  Application.Calculation = intCurCalcSetting
  Application.CutCopyMode = False
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If

End Sub

Private Sub CaptureOtherOptions()
  Const sSOURCE As String = "CaptureOtherOptions()"
  On Error GoTo ErrorHandler
  With wksMenu
    .Range("ZoomIncrement").Value = txtZoomIncrement.Text
    .Range("EnableUndo").Value = chkEnableTTSUndo.Value
    '.Range("AppEventTrapping").Value = chkEnableEventTrapping.Value
    .Range("AutoFillRightRange").Value = Me.optSelectAutoFillRangeAutomatic.Value
    .Range("FontStyleColor").Value = Me.chkFontColor
    .Range("FontSize").Value = Me.chkFontSize
    .Range("FontStyle").Value = Me.chkFontStyle
    .Range("Pattern").Value = Me.chkPattern
    .Range("Protection").Value = Me.chkProtection
    .Range("Alignment").Value = Me.chkAlignment
    .Range("Border").Value = Me.chkBorder
    .Range("FontName").Value = Me.chkFontName
    .Range("FontUnderline").Value = Me.chkUnderline
  End With
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , False) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Private Sub UserForm_Initialize()
  'Set up the form with saved values
  Const sSOURCE As String = "UserForm_Initialize()"
  
  Dim intCurCalcSetting As Integer
  Dim i As Long
  Dim ctl As Control
  Dim iCtlShortcut As Long
  
  On Error GoTo ErrorHandler
  'intCurCalcSetting = Application.Calculation
  'Application.Calculation = xlCalculationManual
  'ThisWorkbook.Colors = Workbooks(ActiveWorkbook.Name).Colors
  With Me

    CaptureCurrentState
    'Fill Color Tab
    SetColorOptions .txtColor1, .lblColor1, .chkFillEnabled1
    SetColorOptions .txtColor2, .lblColor2, .chkFillEnabled2
    SetColorOptions .txtColor3, .lblColor3, .chkFillEnabled3
    SetColorOptions .txtColor4, .lblColor4, .chkFillEnabled4
    SetColorOptions .txtColor5, .lblColor5, .chkFillEnabled5
    'Fill Font Tab
    SetColorOptions .txtFontColor1, .lblFontColor1, .chkFontEnabled1
    SetColorOptions .txtFontColor2, .lblFontColor2, .chkFontEnabled2
    SetColorOptions .txtFontColor3, .lblFontColor3, .chkFontEnabled3
    SetColorOptions .txtFontColor4, .lblFontColor4, .chkFontEnabled4
    SetColorOptions .txtFontColor5, .lblFontColor5, .chkFontEnabled5
    'Fill Style (Auto Color)Tab
    SetColorOptions .txtAutoWorkbookFormula, .lblAutoWorkbookFormula
    SetColorOptions .txtAutoOtherWorksheetFormula, .lblAutoOtherWorksheetFormula
    SetColorOptions .txtAutoExternalFormula, .lblAutoExternalFormula
    SetColorOptions .txtAutoValueConstant, .lblAutoValueConstant
    SetColorOptions .txtAutoTextConstant, .lblAutoTextConstant
    SetColorOptions .txtAutoHyperlink, .lblAutoHyperlink
    'Set Number Format Tab
    SetNumberOptions .lblNumberFormat1, Me.chkNumEnabled1
    SetNumberOptions .lblNumberFormat2, Me.chkNumEnabled2
    SetNumberOptions .lblNumberFormat3, Me.chkNumEnabled3
    SetNumberOptions .lblNumberFormat4, Me.chkNumEnabled4
    SetNumberOptions .lblNumberFormat5, Me.chkNumEnabled5
    'Set Other Options Tab
    '.chkEnableEventTrapping = wksMenu.Range("AppEventTrapping").Value
    .chkEnableTTSUndo = wksMenu.Range("EnableUndo").Value
    .txtZoomIncrement.Text = wksMenu.Range("ZoomIncrement").Value
    .optSelectAutoFillRangeAutomatic.Value = wksMenu.Range("AutoFillRightRange").Value
    .optSelectAutoFillRangeManual.Value = Not wksMenu.Range("AutoFillRightRange").Value
    '.chkBorder = wksMenu.Range("Border").Value
    '.chkFontColor = wksMenu.Range("FontStyleColor").Value
    '.chkFontSize = wksMenu.Range("FontSize").Value
    '.chkFontStyle = wksMenu.Range("FontStyle").Value
    '.chkPattern = wksMenu.Range("Pattern").Value
    '.chkProtection = wksMenu.Range("Protection").Value
    '.chkAlignment = wksMenu.Range("Alignment").Value
    '.chkUnderline = wksMenu.Range("FontUnderline").Value
    '.chkFontName = wksMenu.Range("FontName").Value
    
    .MultiPage1.Value = 0
  End With

''  ' start with first visible tab displayed
''  With Me.MultiPage1
''    For i = 0 To .Pages.Count - 1
''      If .Pages(i).Visible Then
''        .Value = i
''        Exit For
''      End If
''    Next
''  End With
  
  ShortcutKeysShowCurrent Me
  
  ReDim clsShortcutControls(1 To 1)
  For Each ctl In Me.Controls
    Select Case Left$(ctl.Name, 6)
      Case sCtrlChk, sCtrlTxt
        iCtlShortcut = iCtlShortcut + 1
        ReDim Preserve clsShortcutControls(1 To iCtlShortcut)
        Set clsShortcutControls(iCtlShortcut).frm = Me
        Select Case Left$(ctl.Name, 6)
          Case sCtrlChk
            Set clsShortcutControls(iCtlShortcut).ChkShortcut = ctl
          Case sCtrlTxt
            Set clsShortcutControls(iCtlShortcut).TxtShortcut = ctl
        End Select
    End Select
  Next

ErrorExit:
  ' Cleanup code here.
  'On Error Resume Next
  ''ThisWorkbook.ResetColors
  'Application.Calculation = intCurCalcSetting
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub
Attribute VB_Name = "modEnvironment"
'Sets Excel application and worksheet options

Sub Auto_Calc_Itera()
Attribute Auto_Calc_Itera.VB_ProcData.VB_Invoke_Func = " \n14"
  ' Turns on auto calc. and interations

  With Application
    .Calculation = xlAutomatic
    .Iteration = True
    .MaxIterations = 100
    .MaxChange = 0.001
  End With

  ActiveWorkbook.PrecisionAsDisplayed = False

  Calculate

End Sub

Sub Edit_Move()
Attribute Edit_Move.VB_ProcData.VB_Invoke_Func = " \n14"
  ' This deselects move after edit

  Application.MoveAfterReturn = False

End Sub

Sub Comment_Indicator()
Attribute Comment_Indicator.VB_ProcData.VB_Invoke_Func = " \n14"
  On Error Resume Next

  Application.DisplayCommentIndicator = xlCommentIndicatorOnly

  On Error GoTo 0

End Sub

Sub Disable_Error_Checking()
Attribute Disable_Error_Checking.VB_ProcData.VB_Invoke_Func = " \n14"
  On Error Resume Next

  Application.ErrorCheckingOptions.BackgroundChecking = False

  On Error GoTo 0

End Sub

Sub Hide_Toolbars()
Attribute Hide_Toolbars.VB_ProcData.VB_Invoke_Func = " \n14"
  On Error Resume Next

  Application.CommandBars("Formula Auditing").Visible = False
  Application.CommandBars("Reviewing").Visible = False

  On Error GoTo 0

End Sub

Attribute VB_Name = "modErrorHandler"
Option Explicit
'Gracefully handles all untrapped errors

Public Const gbDEBUG_MODE As Boolean = False
Public Const glHANDLED_ERROR As Long = 9999
Public Const glUSER_CANCEL As Long = 18
Private Const msSILENT_ERROR As String = "UserCancel"
Private Const msFILE_ERROR_LOG As String = "Error.Log"
'

Public Function bCentralErrorHandler( _
    ByVal sModule As String, _
    ByVal sProc As String, _
    Optional ByVal sFile As String, _
    Optional ByVal bEntryPoint As Boolean) As Boolean

  Static sErrMsg As String

  Dim iFile As Integer
  Dim lErrNum As Long
  Dim sFullSource As String
  Dim sPath As String
  Dim sLogText As String

  ' Grab the error info before it's cleared by
  ' On Error Resume Next below.
  lErrNum = err.Number
  ' If this is a user cancel, set the silent error flag
  ' message. This will cause the error to be ignored.
  If lErrNum = glUSER_CANCEL Then sErrMsg = msSILENT_ERROR
  ' If this is the originating error, the static error
  ' message variable will be empty. In that case, store
  ' the originating error message in the static variable.
  If Len(sErrMsg) = 0 Then sErrMsg = err.Description

  ' We cannot allow errors in the central error handler.
  On Error Resume Next

  ' Load the default filename if required.
  If Len(sFile) = 0 Then sFile = ThisWorkbook.Name

  ' Get the application directory.
  sPath = ThisWorkbook.Path
  If Right$(sPath, 1) <> "\" Then sPath = sPath & "\"

  ' Construct the fully-qualified error source name.
  sFullSource = "[" & sFile & "]" & sModule & "." & sProc

  ' Create the error text to be logged.
  sLogText = "  " & sFullSource & ", Error " & _
      CStr(lErrNum) & ": " & sErrMsg

  ' Open the log file, write out the error information and
  ' close the log file.
  iFile = FreeFile()
  Open sPath & msFILE_ERROR_LOG For Append As #iFile
  Print #iFile, Format$(Now(), "mm/dd/yy hh:mm:ss"); sLogText
  If bEntryPoint Then Print #iFile,
  Close #iFile

  ' Do not display silent errors.
  If sErrMsg <> msSILENT_ERROR Then

    ' Show the error message when we reach the entry point
    ' procedure or immediately if we are in debug mode.
    If bEntryPoint Or gbDEBUG_MODE Then
      Application.ScreenUpdating = True
      MsgBox sErrMsg, vbCritical, TTS_TITLE
      ' Clear the static error message variable once
      ' we've reached the entry point so that we're ready
      ' to handle the next error.
      sErrMsg = vbNullString
    End If

    ' The return value is the debug mode status.
    bCentralErrorHandler = gbDEBUG_MODE

  Else
    ' If this is a silent error, clear the static error
    ' message variable when we reach the entry point.
    If bEntryPoint Then sErrMsg = vbNullString
    bCentralErrorHandler = False
  End If

End Function

'Private Const msMODULE As String = "MMyModule"
'Sample usage of above error handler
'Public Sub MyEntryPointSubroutine()
'    Const sSOURCE               As String = "MyEntryPointSubroutine()"
'    On Error GoTo ErrorHandler
'
'    ' Call the lower level function.
'    If Not bMyLowerLevelFunction() Then Err.Raise glHANDLED_ERROR
'
'ErrorExit:
'    ' Cleanup code here.
'    Exit Sub
'
'ErrorHandler:
'    If bCentralErrorHandler(msMODULE, sSOURCE, , True) Then
'Stop
'        Resume
'    Else
'        Resume ErrorExit
'    End If
'End Sub

Attribute VB_Name = "modFormat"
Option Explicit

Function ToggleAttribute(strAttribute As String) As Boolean
  ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  '' heavily modified 2010 11 24 by Jon Peltier
  '' to take into account Excel 2007's schizophrenic color system
  ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  'Main routine for setting the format toggles
  'strAttribute can be FillColor, FontColor, NumberFormat
  'Const lngNOFILLCOLOR As Long = 16777215
  'Const lngNOFONTCOLOR As Long = 0
  Dim blnMatch As Boolean, blnSetNone As Boolean
  Dim rngAttributes As Range
  Dim rCell As Range, rSel As Range
  Dim iCnt As Long, iMaxRow As Long, x As Long
  Dim blnFormatIsSet As Boolean, iLoopCtr As Long
  Dim intColor As Long, intNewColor As Long
  'Dim intColor as long, intR as long, intG as long, intB as long
  ThisWorkbook.Colors = Workbooks(ActiveWorkbook.Name).Colors
  Set rngAttributes = wksMenu.Range(strAttribute)
  iMaxRow = rngAttributes.Rows.Count  'last cell in attribute range
  'If UndoEnabled Then SetUndo Selection
  ActiveSheet.Select  'If not used, the color property returns the wrong color - XL BUG

  If UCase(strAttribute) = "FILLCOLOR" Then
    If Selection.Cells(1, 1).Interior.ColorIndex = xlColorIndexNone Then
      intColor = xlColorIndexNone
    Else
      intColor = Selection.Cells(1, 1).Interior.Color
    End If
    'Debug.Print "Current Cell Color Index = " & intColor 'CellColorRGB(rSel, True)
  Else
    If Selection.Cells(1, 1).Font.ColorIndex = xlColorIndexAutomatic Then
      intColor = xlColorIndexAutomatic
    Else
      intColor = Selection.Cells(1, 1).Font.Color
    End If
    'Debug.Print "Current Cell Color Index = " & intColor 'CellColorRGB(rSel, False)
  End If

  blnMatch = False
  iCnt = 0
  For Each rCell In rngAttributes
    Select Case UCase(strAttribute)
      Case "FILLCOLOR"
        If rCell.Interior.ColorIndex = xlColorIndexNone Then
          If intColor = xlColorIndexNone Then
            blnMatch = True  'skip all unset colors
          End If
        ElseIf intColor = rCell.Interior.Color Then
          blnMatch = True  'skip all unset colors
        End If
      Case "FONTCOLOR"
        If rCell.Font.ColorIndex = xlColorIndexAutomatic Then
          If intColor = xlColorIndexAutomatic Then
            blnMatch = True  'skip all unset colors
          End If
        ElseIf intColor = rCell.Font.Color Then
          blnMatch = True  'skip all unset colors
        End If
      Case "NUMBERFORMAT"
        blnMatch = Selection.Cells(1, 1).NumberFormat = rCell.NumberFormat
    End Select
NextOne:
    iCnt = iCnt + 1
    If blnMatch Then Exit For
  Next
  Do
    iLoopCtr = iLoopCtr + 1
    If iLoopCtr = 2 Then iCnt = 0  'start back at the first cell in the format range
    If iLoopCtr = 3 Then Exit Do  'forget it, no format will be set
    For x = iCnt To iMaxRow
      'find the next non-blank value in the range
      Select Case UCase(strAttribute)
        Case "FILLCOLOR"
          If rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).Offset(0, -3).Value Then
            
            If rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).Interior.ColorIndex = xlColorIndexNone Then
              intNewColor = xlColorIndexNone
            Else
              intNewColor = rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).Interior.Color
            End If
            
            ActiveSheet.Select
            For Each rSel In Selection
              If intNewColor = xlColorIndexNone Then
                rSel.Interior.ColorIndex = intNewColor
              Else
                rSel.Interior.Color = intNewColor
              End If
            Next
            
            blnFormatIsSet = True
          
          End If
        Case "FONTCOLOR"
          If rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).Offset(0, -3).Value Then
            
            If rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).Font.ColorIndex = xlColorIndexAutomatic Then
              intNewColor = xlColorIndexAutomatic
            Else
              intNewColor = rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).Font.Color
            End If
            
            For Each rSel In Selection
              If intNewColor = xlColorIndexAutomatic Then
                rSel.Font.ColorIndex = intNewColor
              Else
                rSel.Font.Color = intNewColor
              End If
            Next
            
            blnFormatIsSet = True
          
          End If
        Case "NUMBERFORMAT"
          If rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).Offset(0, -3).Value Then
            For Each rSel In Selection
              rSel.NumberFormat = rngAttributes.Cells(IIf(x + 1 > iMaxRow, 1, x + 1)).NumberFormat
            Next
            blnFormatIsSet = True
          End If
      End Select
      If blnFormatIsSet Then Exit For
    Next

  Loop Until blnFormatIsSet
  If iLoopCtr = 3 Then MsgBox "Could not find a color or number format to apply.", vbOKOnly, TTS_TITLE

  ''ThisWorkbook.ResetColors
  ToggleAttribute = True
  'If UndoEnabled Then Application.OnUndo "Undo Last Format Toggle", "UndoChange"
End Function

Function Border_Toggle() As Boolean
Attribute Border_Toggle.VB_ProcData.VB_Invoke_Func = " \n14"
  'Created By: Billy Chu 3/24/03
  'Modified: Billy Chu 1/29/04
  'Functionality: Borders
  'Additional Notes: Commented out code that will NOT allow you to put a top and right
  'border together in the same cell
  If UndoEnabled Then SetUndo Selection
  Border_Toggle = False
  If Selection.Borders(xlEdgeTop).LineStyle = xlNone And Selection.Borders(xlEdgeRight).LineStyle = xlNone Then
    With Selection.Borders(xlEdgeTop)
      .LineStyle = xlContinuous
      .Weight = xlThin
      .ColorIndex = xlAutomatic
    End With
  ElseIf Selection.Borders(xlEdgeTop).LineStyle <> xlNone And Selection.Borders(xlEdgeRight).LineStyle = xlNone Then
    With Selection.Borders(xlEdgeRight)
      .LineStyle = xlContinuous
      .Weight = xlThin
      .ColorIndex = xlAutomatic
    End With
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
  ElseIf Selection.Borders(xlEdgeRight).LineStyle <> xlNone And Selection.Borders(xlEdgeTop).LineStyle = xlNone Then
    With Selection.Borders(xlEdgeRight)
      .LineStyle = xlContinuous
      .Weight = xlThin
      .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeTop)
      .LineStyle = xlContinuous
      .Weight = xlThin
      .ColorIndex = xlAutomatic
    End With
  ElseIf Selection.Borders(xlEdgeRight).LineStyle <> xlNone And Selection.Borders(xlEdgeTop).LineStyle <> xlNone Then
    Selection.Borders(xlEdgeRight).LineStyle = xlNone
    Selection.Borders(xlEdgeTop).LineStyle = xlNone
  End If
  Border_Toggle = True

  If UndoEnabled Then Application.OnUndo "Undo Last Border", "UndoChange"

End Function

'Function Increase_Decimal() As Boolean
''Created By: Billy Chu 3/24/03
''Modified: Billy Chu 7/8/03
''Functionality: Decimals (increase/decrease)
''Additional Notes:
'
''Increases decimal place of number. Calls a function Increase_Decimal_Function
''to do the sorting and final format of number
'    Dim c As Range
'    Dim Format As String
'    Dim InitialFormat_To_Pass As String
'
'    If UndoEnabled Then SetUndo Selection
'    Increase_Decimal = False
'    For Each c In Selection.Cells
'        InitialFormat_To_Pass = c.NumberFormat
'        Format = Increase_Decimal_Function(InitialFormat_To_Pass)
'        c.NumberFormat = Format
'    Next
'    Increase_Decimal = True
'    If UndoEnabled Then Application.OnUndo "Undo Last Decimal", "UndoChange"
'
'End Function
'
'Private Function Increase_Decimal_Function(InitialFormat As String)
'
'    Dim Final_Format As String
'    Dim InStringTest as long
'
'    Dim TextToFind As String
'    Dim TextToFind1 As String
'    Dim TextToFind2 As String
'    Dim TextToFind3 As String
'    Dim TextToFind4 As String
'    Dim TextToFind5 As String
'    Dim TextToEnd As String
'
'    TextToFind = "0%"
'    TextToFind2 = "General"
'    TextToFind3 = "."
'    TextToFind4 = "x"
'    TextToEnd = ".0"
'    TextToFind5 = "#0_"
'
'    InStringTest = InStr(1, InitialFormat, TextToFind3)
'
'    If InitialFormat = "#0%_);(#0%)" Then
'        Final_Format = "#0.0%_);(#0.0%)"
'        GoTo EndDecimal
'    End If
'
'    If InStringTest > 0 Then
'        Final_Format = Replace(InitialFormat, ".0", ".00")
'        GoTo EndDecimal
'    End If
'
'    InStringTest = InStr(1, InitialFormat, TextToFind2)
'
'    If InStringTest > 0 Then
'        Final_Format = "0.0"
'        GoTo EndDecimal
'    End If
'
'    InStringTest = InStr(1, InitialFormat, TextToFind)
'
'    If InStringTest > 0 Then
'        Final_Format = "#0.0%_);(#0.0%)"
'        GoTo EndDecimal
'    End If
'
'    InStringTest = InStr(1, InitialFormat, TextToFind5)
'
'    If InStringTest > 0 Then
'        Final_Format = Replace(InitialFormat, "#0", "#0.0")
'        GoTo EndDecimal
'    End If
'
'    InStringTest = InStr(1, InitialFormat, TextToFind4)
'
'    If InStringTest > 0 Then
'        Final_Format = "0.0x"
'        'GoTo EndDecimal
'    Else
'        Final_Format = InitialFormat & TextToEnd
'        'GoTo EndDecimal
'    End If
'EndDecimal:
'
'    Increase_Decimal_Function = Final_Format
'
'End Function
'
''Above sub and function necessary for increase decimal
'
'Function Decrease_Decimal() As Boolean
'    Dim c As Range
'    Dim Format As String
'    Dim InitialFormat_To_Pass As String
'    Decrease_Decimal = False
'    If UndoEnabled Then SetUndo Selection
'
'    For Each c In Selection.Cells
'        InitialFormat_To_Pass = c.NumberFormat
'        Format = Decrease_Decimal_Function(InitialFormat_To_Pass)
'        c.NumberFormat = Format
'    Next
'    Decrease_Decimal = True
'    If UndoEnabled Then Application.OnUndo "Undo Last Decimal", "UndoChange"
'
'End Function
'
'
'Private Function Decrease_Decimal_Function(InitialFormat As String)
''Did not use a separate function to increase the decimal. Another way of
''doing it.
'
'
'    Dim Final_Format As String
'    Dim InStringTest as long
'    Dim InStringTest2 as long
'    Dim InStringTest3 as long
'
'    Dim TextToFind As String
'
'    TextToFind = "."
'
'    InStringTest = InStr(1, InitialFormat, TextToFind)
'
'    If InitialFormat = "#0.0%_);(#0.0%)" Then
'        Final_Format = "#0%_);(#0%)"
'        GoTo EndDecimal
'            ElseIf InitialFormat = "#0.0x" Then
'                Final_Format = "0x"
'                GoTo EndDecimal
'    End If
'
'    If InitialFormat = "0.0" Then
'        Final_Format = "0"
'        GoTo EndDecimal
'            ElseIf InitialFormat = "0.0%" Then
'                Final_Format = "#0%_);(#0%)"
'                GoTo EndDecimal
'                    ElseIf InitialFormat = "#0.0%_);(#0.0%)" Then
'                    Final_Format = "#0%_);(#0%)"
'                    GoTo EndDecimal
'                        ElseIf InitialFormat = "0.0x" Then
'                        Final_Format = "0x"
'                        GoTo EndDecimal
'                            ElseIf InitialFormat = "$#,##0.0" Then
'                            Final_Format = "$#,##0"
'                            GoTo EndDecimal
'            End If
'
'    If InStringTest = 0 Then
'        Decrease_Decimal_Function = InitialFormat
'        GoTo EndDecimal2
'    End If
'
'    If InStringTest > 0 Then
'        Final_Format = Replace(InitialFormat, ".0", ".")
'        InStringTest2 = InStr(1, Final_Format, "._")
'        InStringTest3 = InStr(1, Final_Format, ".)")
'    End If
'
'    If InStringTest2 > 0 Or InStringTest3 > 0 Then
'        Final_Format = Replace(Final_Format, "._", "_")
'        Final_Format = Replace(Final_Format, ".)", ")")
'        GoTo EndDecimal
'    End If
'
'EndDecimal:
'    Decrease_Decimal_Function = Final_Format
'
'EndDecimal2:
'
'
'End Function


Function AutoFillRight() As Boolean
  'Note: this routine assumes the right-most used column is the last column
  '       to fill toward unless the user specifies a header range.
  Dim x As Long, z As Long, r As String, blnNoRange As Boolean
  Const USER_CANCELLED_MSG As String = "Do you want " & TTS_TITLE & " to figure out the header range for you?"
  AutoFillRight = False
  On Error Resume Next
  r = ActiveSheet.Names("FillRight")
  If r = "" Then blnNoRange = True Else blnNoRange = False
  On Error GoTo 0

  If Not wksMenu.Range("AutoFillRightRange").Value Then
    If gintLastColumn = 0 Or blnNoRange Then
      'prompt user for the header range
      If Not GetHeaderRangeFromUser() Then
        If MsgBox(USER_CANCELLED_MSG, vbYesNo) = vbYes Then
          gintLastColumn = ActiveSheet.UsedRange.Offset(0, ActiveSheet.UsedRange.Columns.Count - 1).Resize(, 1).Column
          ActiveSheet.Names.Add "FillRight", ActiveCell.Resize(, gintLastColumn - ActiveCell.Column)
        Else
          Exit Function
        End If
      End If
    End If
  Else
    gintLastColumn = ActiveSheet.UsedRange.Offset(0, ActiveSheet.UsedRange.Columns.Count - 1).Resize(, 1).Column
  End If

  x = Selection.Cells(1, 1).Column  'get the current column
  If gintLastColumn > x Then
    z = gintLastColumn + 1 - x
    If UndoEnabled Then SetUndo Selection.Resize(, z)
    Selection.Resize(, z).FillRight
    If UndoEnabled Then Application.OnUndo "Undo Turbo Fill Right", "UndoChange"
  End If
  AutoFillRight = True
End Function

Function GetHeaderRangeFromUser() As Boolean
  On Error GoTo ErrorHandler:
  frmFillRight.Show
  GetHeaderRangeFromUser = frmFillRight.Tag
  Unload frmFillRight
  Exit Function
ErrorHandler:
  Unload frmFillRight
  GetHeaderRangeFromUser = False
  err.Raise err.Number
End Function

Function View_Increase() As Boolean
  'Shortcut key = Ctrl + Shift + K
  Dim Current_Zoom As Long
  View_Increase = False
  If ActiveWindow.Zoom >= 400 Then Exit Function
  Current_Zoom = ActiveWindow.Zoom
  ActiveWindow.Zoom = Current_Zoom + wksMenu.Range("ZoomIncrement").Value
  View_Increase = True
  If UndoEnabled Then gintLastZoom = Current_Zoom: Application.OnUndo "Undo Last Zoom", "UndoZoomChange"
End Function

Function View_Decrease() As Boolean
  'Shortcut key = Ctrl + Shift + L
  Dim Current_Zoom As Long
  View_Decrease = False
  If ActiveWindow.Zoom <= 10 Then Exit Function
  Current_Zoom = ActiveWindow.Zoom
  ActiveWindow.Zoom = Current_Zoom - wksMenu.Range("ZoomIncrement").Value
  View_Decrease = True
  If UndoEnabled Then gintLastZoom = Current_Zoom: Application.OnUndo "Undo Last Zoom", "UndoZoomChange"
End Function

Function Center_Across_Selection() As Boolean
  Center_Across_Selection = False
  If UndoEnabled Then SetUndo Selection

  If Selection.MergeCells = True Then
    Selection.MergeCells = False
  End If

  'Toggles General, CAS, Left
  If Selection.HorizontalAlignment = xlGeneral Then
    Selection.HorizontalAlignment = xlCenterAcrossSelection

  ElseIf Selection.HorizontalAlignment = xlCenterAcrossSelection Then
    Selection.HorizontalAlignment = xlLeft

  ElseIf Selection.HorizontalAlignment = xlLeft Then
    Selection.HorizontalAlignment = xlRight

  Else: Selection.HorizontalAlignment = xlRight
    Selection.HorizontalAlignment = xlGeneral

  End If
  Center_Across_Selection = True
  If UndoEnabled Then Application.OnUndo "Undo Last Align", "UndoChange"

End Function


Attribute VB_Name = "modGeneric"
'Contains generic subroutines and functions
Option Explicit

Sub SetF1Key(blnValue As Boolean)
  If blnValue Then  ' True, then enable native Excel 'Help' key
    Application.OnKey "{F1}"
  Else  'disable it
    Application.OnKey "{F1}", ""
  End If

End Sub

Sub GetPrecedents()

  Dim rng As Range
  Set rng = ActiveCell.Precedents
  'Debug.Print rng.Address

End Sub

Sub AddStyles()  'no longer used due to general buggy nature of styles

  Dim objStyle As Style
  'check to see if required styles already exist in the workbook
  On Error Resume Next
  If ActiveWorkbook.Name = ThisWorkbook.Name Then Exit Sub
  Application.DisplayAlerts = False
  With ActiveWorkbook
    .Styles.Merge Workbook:=ThisWorkbook  'import styles into workbook
    'delete extraneous styles
    For Each objStyle In .Styles
      If Left(objStyle.Name, 3) = "Cur" Or Left(objStyle.Name, 3) = "DEF" Then objStyle.Delete
    Next objStyle
  End With
  Application.DisplayAlerts = True

End Sub

Function UndoEnabled() As Boolean
  UndoEnabled = wksMenu.Range("EnableUndo").Value
End Function


Function CellType(c As Range)
Attribute CellType.VB_ProcData.VB_Invoke_Func = " \n14"
  '   Returns the cell type of the upper left
  '   cell in a range.

  'Application.Volatile 'only use if this will be used as a sheet function
  'means recalc formula on sheet changes
  Set c = c.Cells(1, 1)  'if a mulit cell range is passed in, check the top left

  Select Case True
    Case IsEmpty(c): CellType = "Blank"
    Case c.Hyperlinks.Count > 0: CellType = "Hyperlink"
    Case InStr(1, c.Formula, "["): CellType = "ExternalFormula"
    Case InStr(1, c.Formula, "!"): CellType = "OtherWorksheetReference"
    Case CellReferenceInFormula(c.Formula): CellType = "WorkbookFormula"
    Case Application.IsText(c): CellType = "TextConstant"
      'Case Application.IsLogical(c): CellType = "Logical"
    Case Application.IsErr(c): CellType = "Error"
    Case IsNumeric(c) Or Not CellReferenceInFormula(c.Formula): CellType = "ValueConstant"
    Case Else: CellType = "TypeNotFound"
  End Select
End Function

Function SetFormat(r As Range) As Boolean
  Dim rngLookup As Range
  Application.EnableEvents = False  'prevents events from firing when changing formats
  Select Case CellType(r)
    Case "ExternalFormula"  'WORKBOOK REFERENCE - Formula with ref to another WORKBOOK)
      Set rngLookup = wksMenu.Range("ExternalFormula")
      'R.Font.ColorIndex = 10 'blue
    Case "OtherWorksheetReference"  'WORKSHEET REFERENCE -Formula with a reference to another sheet in the workbook
      Set rngLookup = wksMenu.Range("OtherWorksheetFormula")
    Case "WorkbookFormula"  'FORMULA - SAME WORKSHEET -Formula that has a reference within the sheet
      Set rngLookup = wksMenu.Range("WorkbookFormula")
      'R.Font.ColorIndex = 1 'black
    Case "ValueConstant"  'INPUTS
      Set rngLookup = wksMenu.Range("ValueConstant")
    Case "TextConstant"  'TEXT COLOR
      Set rngLookup = wksMenu.Range("TextConstant")
    Case "Hyperlink"  'HYPERLINK
      Set rngLookup = wksMenu.Range("Hyperlink")
    Case Else
      SetFormat = True
      Application.EnableEvents = True
      Exit Function
      'do nothing cell is blank or other currently non-flagged condition
  End Select
  'Now set the cell formats
  'rngLookup.Copy
  'r.PasteSpecial (xlPasteFormats)
  'Application.CutCopyMode = xlCopy

  If wksMenu.Range("Alignment").Value Then
    With r
      .HorizontalAlignment = rngLookup.HorizontalAlignment
      .VerticalAlignment = rngLookup
      .WrapText = rngLookup.WrapText
      .Orientation = rngLookup.Orientation
      .AddIndent = rngLookup.AddIndent
      .IndentLevel = rngLookup.IndentLevel
      .ShrinkToFit = rngLookup.ShrinkToFit
      .MergeCells = rngLookup.MergeCells
    End With
  End If
  If wksMenu.Range("FontSize").Value Then
    r.Font.Size = rngLookup.Font.Size
  End If
  If wksMenu.Range("FontStyle").Value Then
    r.Font.FontStyle = rngLookup.Font.FontStyle
  End If
  If wksMenu.Range("FontStyleColor").Value Then
    r.Font.ColorIndex = rngLookup.Font.ColorIndex
  End If
  If wksMenu.Range("FontUnderline").Value Then
    r.Font.Underline = rngLookup.Font.Underline
  End If
  If wksMenu.Range("Border").Value Then
    With r
      With .Borders(xlDiagonalDown)
        .LineStyle = rngLookup.Borders(xlDiagonalDown).LineStyle
        .Weight = rngLookup.Borders(xlDiagonalDown).Weight
        .ColorIndex = rngLookup.Borders(xlDiagonalDown).ColorIndex
      End With
      With .Borders(xlDiagonalUp)
        .LineStyle = rngLookup.Borders(xlDiagonalUp).LineStyle
        .Weight = rngLookup.Borders(xlDiagonalUp).Weight
        .ColorIndex = rngLookup.Borders(xlDiagonalUp).ColorIndex
      End With
      With Selection.Borders(xlEdgeLeft)
        .LineStyle = rngLookup.Borders(xlEdgeLeft).LineStyle
        .Weight = rngLookup.Borders(xlEdgeLeft).Weight
        .ColorIndex = rngLookup.Borders(xlEdgeLeft).ColorIndex
      End With
      With Selection.Borders(xlEdgeTop)
        .LineStyle = rngLookup.Borders(xlEdgeTop).LineStyle
        .Weight = rngLookup.Borders(xlEdgeTop).Weight
        .ColorIndex = rngLookup.Borders(xlEdgeTop).ColorIndex
      End With
      With Selection.Borders(xlEdgeBottom)
        .LineStyle = rngLookup.Borders(xlEdgeBottom).LineStyle
        .Weight = rngLookup.Borders(xlEdgeBottom).Weight
        .ColorIndex = rngLookup.Borders(xlEdgeBottom).ColorIndex
      End With
      With Selection.Borders(xlEdgeRight)
        .LineStyle = rngLookup.Borders(xlEdgeRight).LineStyle
        .Weight = rngLookup.Borders(xlEdgeRight).Weight
        .ColorIndex = rngLookup.Borders(xlEdgeRight).ColorIndex
      End With
    End With
  End If
  If wksMenu.Range("Pattern").Value Then
    With r.Interior
      .ColorIndex = rngLookup.Interior.ColorIndex
      .Pattern = rngLookup.Interior.Pattern
      .PatternColorIndex = rngLookup.Interior.PatternColorIndex
    End With
  End If
  If wksMenu.Range("Protection").Value Then
    With r
      .Locked = rngLookup.Locked
      .FormulaHidden = rngLookup.FormulaHidden
    End With
  End If

  SetFormat = True
  Application.EnableEvents = True

End Function

Sub testcolor()
  Dim i As Integer, r As Integer, g As Integer, b As Integer
  Dim strColor As String
  'i = GetColorInfo(wksMenu.Range("Color1"), r, g, b)
  strColor = CellColor(wksMenu.Range("Color1"), True)
  MsgBox strColor & " " & i
End Sub

Sub StyleTest()
  Dim blnReturn As Boolean
  blnReturn = GetStyleInfo(wksMenu.Range("ExternalFormulaStyle"))
End Sub

Function GetStyleInfo(strStyle As String) As Boolean
  Dim rngCurr As Range
  Dim wkbCurr As Workbook
  Dim shtCurr As Worksheet
  'grab the currently selected active cell
  Set rngCurr = Selection
  Set shtCurr = ActiveSheet
  Set wkbCurr = ActiveWorkbook
  GetStyleInfo = False
  wksMenu.Activate
  wksMenu.Range(strStyle).Select
  Application.Dialogs(xlDialogPatterns).Show  'Currently only allow font color
  'Displays the Format Cells dilog with ALL tabs
  'Application.CommandBars.FindControl(ID:=855).Execute
  wksMenu.Range(strStyle).Font.ColorIndex = _
      IIf(wksMenu.Range(strStyle).Interior.ColorIndex = xlColorIndexNone, _
      xlColorIndexAutomatic, wksMenu.Range(strStyle).Interior.ColorIndex)
  wksMenu.Range(strStyle).Interior.ColorIndex = xlColorIndexNone
  GetStyleInfo = True
  'reset environment
  wkbCurr.Activate
  shtCurr.Activate
  rngCurr.Select
End Function

Function GetNumberInfo(ByRef rngNumberCaptureCell As Range) As String
  Dim rngCurr As Range
  Dim wkbCurr As Workbook
  Dim shtCurr As Worksheet
  'grab the currently selected active cell
  Set rngCurr = Selection
  Set shtCurr = ActiveSheet
  Set wkbCurr = ActiveWorkbook
  Application.ScreenUpdating = False

  ThisWorkbook.Sheets(rngNumberCaptureCell.Parent.Name).Activate  'activate the sheet or xlDialog will not work
  rngNumberCaptureCell.Select  'select and apply color format to named range
  Application.Dialogs(xlDialogFormatNumber).Show
  GetNumberInfo = ActiveCell.NumberFormat
  'reset environment
  wkbCurr.Activate
  shtCurr.Activate
  rngCurr.Select
  Application.ScreenUpdating = True

End Function

Function GetColorInfo(rngColorCaptureCell As Range) As Integer
  ' There is no way to return the selected color from any of the built in Excel dialogs
  ' This function alows you to return the selected color index indirectly by setting the value of
  ' a cell color in a cell then returning the color index or name (using the CellColor function below).
  '
  Dim rngCurr As Range
  Dim wkbCurr As Workbook
  Dim shtCurr As Worksheet

  'Dim intR As Integer, intG As Integer, intB As Integer
  'grab the currently selected active cell to return back to
  Set rngCurr = Selection
  Set shtCurr = ActiveSheet
  Set wkbCurr = ActiveWorkbook

  Application.ScreenUpdating = False

  ThisWorkbook.Sheets(rngColorCaptureCell.Parent.Name).Activate  'activate the sheet or xlDialog will not work
  rngColorCaptureCell.Select  'select and apply color format to named range
  Application.Dialogs(xlDialogPatterns).Show
  'If GetColorInfo = xlColorIndexAutomatic And Not blnText Then GetColorInfo = xlColorIndexNone

  If Left(rngColorCaptureCell.Name.Name, 4) = "Font" Or Left(rngColorCaptureCell.Name.Name, 4) = "Auto" Then
    If ActiveCell.Interior.ColorIndex = xlColorIndexNone Then  'we are using the patterns color dialog, so convert to Font color conventions
      ActiveCell.Value = xlColorIndexAutomatic
      ActiveCell.Font.ColorIndex = xlColorIndexAutomatic
    Else
      ActiveCell.Font.Color = ActiveCell.Interior.Color
      ActiveCell.Interior.ColorIndex = xlColorIndexNone  'clear the fill color
      'GetRGB ActiveCell.Font.Color, intR, intG, intB
      ActiveCell.Value = ActiveCell.Font.ColorIndex  'intR & " " & intG & " " & intB
    End If
  Else  'Fill
    If ActiveCell.Interior.ColorIndex = xlColorIndexNone Then
      ActiveCell.Value = xlColorIndexNone
    Else
      'GetRGB ActiveCell.Interior.Color, intR, intG, intB
      ActiveCell.Value = ActiveCell.Interior.ColorIndex  'intR & " " & intG & " " & intB
    End If
    'If GetColorInfo = xlColorIndexAutomatic And Not blnText Then GetColorInfo = xlColorIndexNone
  End If
  'ActiveCell.Value = intR & " " & intG & " " & intB
  'End If
  GetColorInfo = ActiveCell.Value
  're-set the active cell on the users sheet
  wkbCurr.Activate
  shtCurr.Activate
  rngCurr.Select
  'Set rngCurr = ActiveSheet.UsedRange
  Application.ScreenUpdating = True

End Function

Sub GetPallete()
  Dim i As Integer, r As Integer, g As Integer, b As Integer

  For i = 1 To 64
    ActiveCell.Offset(i, 0).Value = i
    ActiveCell.Offset(i, 1).Interior.ColorIndex = i
    GetRGB ActiveCell.Offset(i, 1).Interior.Color, r, g, b
    ActiveCell.Offset(i, 2).Value = r & " " & g & " " & b
    ActiveCell.Offset(i, 3).Value = CellColor(ActiveCell.Offset(i, 1), True)

  Next

End Sub

'This only works with the default Excel Palette, use CellColorRGB to determine name of color if custom palette
Function CellColor(rCell As Range, blnCell As Boolean, Optional blnColorName As Boolean = True) As Variant
  Dim strColor As String, iIndexNum As Integer, lngColor As Long
  Dim r As Integer, g As Integer, b As Integer
  'rCell: the cell to interogate for a color name/index
  'blnColorName: True to return the color string name, False to return the color index number
  'blnCell: True to interogate the cell interior (fill) color, false to return the font color
  'Returns: color name if blnColorName is true, if false returns color index

  'NOTE: Officially there are no color names for all 56 standard colors as defined by Microsoft.

  Select Case IIf(blnCell, rCell.Interior.ColorIndex, rCell.Font.ColorIndex)
    Case 1
      strColor = "Black"
      iIndexNum = 1
    Case 53
      strColor = "Brown"
      iIndexNum = 53
    Case 52
      strColor = "Olive Green"
      iIndexNum = 52
    Case 51
      strColor = "Dark Green"
      iIndexNum = 51
    Case 49
      strColor = "Dark Teal"
      iIndexNum = 49
    Case 11
      strColor = "Dark Blue"
      iIndexNum = 11
    Case 55
      strColor = "Indigo"
      iIndexNum = 55
    Case 56
      strColor = "Gray-80%"
      iIndexNum = 56
    Case 9
      strColor = "Dark Red"
      iIndexNum = 9
    Case 46
      strColor = "Orange"
      iIndexNum = 46
    Case 12
      strColor = "Dark Yellow"
      iIndexNum = 12
    Case 10
      strColor = "Green"
      iIndexNum = 10
    Case 14
      strColor = "Teal"
      iIndexNum = 14
    Case 5
      strColor = "Blue"
      iIndexNum = 5
    Case 47
      strColor = "Blue-Gray"
      iIndexNum = 47
    Case 16
      strColor = "Gray-50%"
      iIndexNum = 16
    Case 3
      strColor = "Red"
      iIndexNum = 3
    Case 45
      strColor = "Light Orange"
      iIndexNum = 45
    Case 43
      strColor = "Lime"
      iIndexNum = 43
    Case 50
      strColor = "Sea Green"
      iIndexNum = 50
    Case 42
      strColor = "Aqua"
      iIndexNum = 42
    Case 41
      strColor = "Light Blue"
      iIndexNum = 41
    Case 13
      strColor = "Violet"
      iIndexNum = 13
    Case 48
      strColor = "Gray-40%"
      iIndexNum = 48
    Case 7
      strColor = "Pink"
      iIndexNum = 7
    Case 44
      strColor = "Gold"
      iIndexNum = 44
    Case 6
      strColor = "Yellow"
      iIndexNum = 6
    Case 4
      strColor = "Bright Green"
      iIndexNum = 4
    Case 8
      strColor = "Turquoise"
      iIndexNum = 8
    Case 33
      strColor = "Sky Blue"
      iIndexNum = 33
    Case 54
      strColor = "Plum"
      iIndexNum = 54
    Case 15
      strColor = "Gray-25%"
      iIndexNum = 15
    Case 38
      strColor = "Rose"
      iIndexNum = 38
    Case 40
      strColor = "Tan"
      iIndexNum = 40
    Case 36
      strColor = "Light Yellow"
      iIndexNum = 36
    Case 35
      strColor = "Light Green"
      iIndexNum = 35
    Case 34
      strColor = "Light Turquoise"
      iIndexNum = 34
    Case 37
      strColor = "Pale Blue"
      iIndexNum = 37
    Case 39
      strColor = "Lavendar"
      iIndexNum = 39
    Case 2
      strColor = "White"
      iIndexNum = 2
    Case Else
      strColor = "Custom color or no fill"
  End Select

  If blnColorName = True Then
    If strColor = "Custom color or no fill" Then
      'Interogate the cell color to determine NONE v.s. Custom
      lngColor = IIf(blnCell, rCell.Interior.ColorIndex, rCell.Font.ColorIndex)
      If lngColor = IIf(blnCell, xlColorIndexNone, xlColorIndexAutomatic) Then
        CellColor = IIf(blnCell, "No Color", "Automatic") ' "White", "Black") '
      Else
        GetRGB lngColor, r, g, b
        CellColor = "Custom RGB:(" & r & " " & g & " " & b & ")"
      End If
    Else
      CellColor = strColor
    End If
  Else
    If strColor = "Custom color or no fill" Then
      CellColor = IIf(blnCell, xlColorIndexNone, xlColorIndexAutomatic)
    Else
      CellColor = iIndexNum
    End If
  End If

End Function

Function CellColorRGB(rCell As Range, blnCell As Boolean, Optional strRGB As Variant) As String
  'Returns the name or RGB of a passed in cell
  Dim lngColor As Long, iIndex As Integer
  Dim r As Integer, g As Integer, b As Integer, sRGB As String
  'rCell: the cell to interogate for a color name/index
  'blnCell: True to interogate the cell interior color, false to return the font color
  'Returns: color name or the RGB combo if custom color

  'NOTE: Officially there are no color names for all 56 standard colors as defined by Microsoft.
  iIndex = IIf(blnCell, rCell.Interior.ColorIndex, rCell.Font.ColorIndex)

  If IsMissing(strRGB) Then
    If iIndex = xlColorIndexNone Or iIndex = xlColorIndexAutomatic Then
      'Check to see if there is even a color for the font/interior
      CellColorRGB = IIf(blnCell, "No Color", "Automatic") ' "White", "Black") '
      Exit Function
    Else
      lngColor = IIf(blnCell, rCell.Interior.Color, rCell.Font.Color)
      GetRGB lngColor, r, g, b
      sRGB = r & " " & g & " " & b
    End If
  Else

    sRGB = strRGB
  End If

  Select Case sRGB
    Case "0 0 0": CellColorRGB = "Black": Exit Function
    Case "255 255 255": CellColorRGB = "White": Exit Function
    Case "255 0 0": CellColorRGB = "Red": Exit Function
    Case "0 255 0": CellColorRGB = "Bright Green": Exit Function
    Case "0 0 255": CellColorRGB = "Blue": Exit Function
    Case "255 255 0": CellColorRGB = "Yellow": Exit Function
    Case "255 0 255": CellColorRGB = "Pink": Exit Function
    Case "0 255 255": CellColorRGB = "Turquoise": Exit Function
    Case "128 0 0": CellColorRGB = "Dark Red": Exit Function
    Case "0 128 0": CellColorRGB = "Green": Exit Function
    Case "0 0 128": CellColorRGB = "Dark Blue": Exit Function
    Case "128 128 0": CellColorRGB = "Dark Yellow": Exit Function
    Case "128 0 128": CellColorRGB = "Violet": Exit Function
    Case "0 128 128": CellColorRGB = "Teal": Exit Function
    Case "192 192 192": CellColorRGB = "Gray-25%": Exit Function
    Case "128 128 128": CellColorRGB = "Gray-50%": Exit Function
    Case "0 204 255": CellColorRGB = "Sky Blue": Exit Function
    Case "204 255 255": CellColorRGB = "Light Turquoise": Exit Function
    Case "204 255 204": CellColorRGB = "Light Green": Exit Function
    Case "255 255 153": CellColorRGB = "Light Yellow": Exit Function
    Case "153 204 255": CellColorRGB = "Pale Blue": Exit Function
    Case "255 153 204": CellColorRGB = "Rose": Exit Function
    Case "204 153 255": CellColorRGB = "Lavendar": Exit Function
    Case "255 204 153": CellColorRGB = "Tan": Exit Function
    Case "51 102 255": CellColorRGB = "Light Blue": Exit Function
    Case "51 204 204": CellColorRGB = "Aqua": Exit Function
    Case "153 204 0": CellColorRGB = "Lime": Exit Function
    Case "255 204 0": CellColorRGB = "Gold": Exit Function
    Case "255 153 0": CellColorRGB = "Light Orange": Exit Function
    Case "255 102 0": CellColorRGB = "Orange": Exit Function
    Case "102 102 153": CellColorRGB = "Blue-Gray": Exit Function
    Case "150 150 150": CellColorRGB = "Gray-40%": Exit Function
    Case "0 51 102": CellColorRGB = "Dark Teal": Exit Function
    Case "51 153 102": CellColorRGB = "Sea Green": Exit Function
    Case "0 51 0": CellColorRGB = "Dark Green": Exit Function
    Case "51 51 0": CellColorRGB = "Olive Green": Exit Function
    Case "153 51 0": CellColorRGB = "Brown": Exit Function
    Case "153 51 102": CellColorRGB = "Plum": Exit Function
    Case "51 51 153": CellColorRGB = "Indigo": Exit Function
    Case "51 51 51": CellColorRGB = "Gray-80%": Exit Function
    Case Else
      CellColorRGB = "Custom r(" & r & ") g(" & g & ") b(" & b & ")"
  End Select

End Function

Sub GetRGB(RGB As Long, ByRef Red As Integer, ByRef Green As Integer, ByRef Blue As Integer)
  'pass in range.interior.color as first arg
  'or range.font.color
  Red = RGB And 255
  Green = RGB \ 256 And 255
  Blue = RGB \ 256 ^ 2 And 255
End Sub
Sub UndoZoomChange()
  ActiveWindow.Zoom = gintLastZoom
End Sub
Sub UndoTest()
  'Test of Undo function
  Const gblnUndo As Integer = 1
  If gblnUndo Then SetUndo ActiveCell.Resize(1, 3)

  ActiveCell.Resize(1, 3).FillRight
  If gblnUndo Then Application.OnUndo "Undo My Test Fill", "UndoChange"
End Sub
Sub SaveChanges()
  On Error Resume Next
  wksUndo.UsedRange.Clear  'to remove any links
  Application.DisplayAlerts = False
  ThisWorkbook.Save
  Application.DisplayAlerts = True
End Sub
Sub SetUndo(rngOld As Range)
  Dim r As Range
  wksUndo.UsedRange.Clear  'clear out the old range
  If wksMenu.Range("EnableUndo").Value Then
    For Each r In rngOld.Areas  'if multiple ranges selected
      r.Copy wksUndo.Range(r.AddressLocal)
    Next
    'resize the UndoRange name
    ThisWorkbook.Names.Add Name:="UndoRange", RefersToLocal:=wksUndo.Range(rngOld.AddressLocal)
  End If
End Sub

Sub UndoChange()
  Dim rngChangedValue As Range, r As Range
  Dim strAddress As String
  For Each r In wksUndo.Range("UndoRange").Areas
    strAddress = r.AddressLocal
    r.Copy ActiveSheet.Range(strAddress)
  Next
  wksUndo.Range("UndoRange").Clear
End Sub

Function CellReferenceInFormula(ByVal strCheckString As String) As Boolean
  'Returns TRUE if there are any invalid characters in the passed string
  'Invalid characters are listed in the constant
  Dim i As Integer, strChar As String
  Const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

  CellReferenceInFormula = True
  If InStr(strCheckString, "=") <> 0 Then  'make sure we have a valid cell formula
    For i = 1 To Len(LETTERS)
      strChar = Mid(LETTERS, i, 1)
      If InStr(strCheckString, strChar) <> 0 Then Exit Function       'If one found, then Exit.  Will return TRUE
    Next
  Else
    CellReferenceInFormula = False
    Exit Function
  End If
  CellReferenceInFormula = False
End Function

Function CalendarDate_ToRange(rngDateHere As Range) As Boolean
  On Error GoTo ErrorHandler:
  CalendarDate_ToRange = False

  '   Step 1 : Verify range is a single cell
  If rngDateHere.Cells.Count > 1 Then MsgBox "A single cell must be selected to enter a date", vbOKOnly, TTS_TITLE: Exit Function

  '   Step 2 : Display Calendar
  frmCalendar.Show
  If frmCalendar.Tag <> "" Then
    Unload frmCalendar
    CalendarDate_ToRange = True
    Exit Function
  End If

  If UndoEnabled Then  'set up the undo range
    If frmCalendar.lblRange.Caption <> "Select a Range" Then
      SetUndo Union(rngDateHere, Range(frmCalendar.lblRange.Caption))
    Else
      SetUndo rngDateHere
    End If
  End If

  '   Step 3 : Place date in indicated range
  If frmCalendar.txt_SelectedDate <> "" Then rngDateHere = DateValue(frmCalendar.txt_SelectedDate)
  If frmCalendar.cboUseThisDateFormat <> "" Then rngDateHere.NumberFormat = frmCalendar.cboUseThisDateFormat.Value

  '   Step 4 : Apply an incremented date series if a range was selected
  If frmCalendar.lblRange.Caption <> "Select a Range" Then
    Dim c As Range, i As Double, strIncrement As String, astrInc(1 To 5) As String, intInc As Integer
    Dim strYearPart As String, strMonthPart As String, strDayPart As String
    i = 0
    astrInc(1) = "m"
    astrInc(2) = "d"
    astrInc(3) = "yyyy"
    astrInc(4) = "q"
    astrInc(5) = "ww"
    If frmCalendar.cboIncrementDate.ListIndex = -1 Then frmCalendar.cboIncrementDate.ListIndex = 0  'choose the first item
    If frmCalendar.cboUseThisDateFormat.ListIndex = -1 And frmCalendar.cboUseThisDateFormat.Value = "" Then frmCalendar.cboUseThisDateFormat.ListIndex = 0
    strIncrement = astrInc(frmCalendar.cboIncrementDate.ListIndex + 1)
    intInc = 1
    If strIncrement = "q" Then intInc = 3
    If strIncrement = "ww" Then intInc = 7

    For Each c In Range(frmCalendar.lblRange.Caption)
      If c.Address <> rngDateHere.Address Then
        If i = 0 Then i = i + intInc  'in case the start date input cell is not part of the selected date range
        If frmCalendar.optEnterDateValues Then
          c.Value = DateAdd(strIncrement, i, DateValue(frmCalendar.txt_SelectedDate))
        Else
          strYearPart = "YEAR(" & rngDateHere.Address & ")" & IIf(strIncrement = "yyyy", "+" & i, "")
          strMonthPart = "MONTH(" & rngDateHere.Address & ")" & IIf(strIncrement = "m" Or strIncrement = "q", "+" & i, "")
          strDayPart = "DAY(" & rngDateHere.Address & ")" & IIf(strIncrement = "d" Or strIncrement = "ww", "+" & i, "")
          c.Formula = "=DATE(" & strYearPart & "," & strMonthPart & "," & strDayPart & ")"
        End If
      End If
      i = i + intInc
    Next
    'apply date format
    If frmCalendar.cboUseThisDateFormat.MatchFound Then
      Range(frmCalendar.lblRange.Caption).NumberFormat = frmCalendar.cboUseThisDateFormat.List(frmCalendar.cboUseThisDateFormat.ListIndex)
    Else  ' User has entered their own format string
      On Error Resume Next
      Range(frmCalendar.lblRange.Caption).NumberFormat = frmCalendar.cboUseThisDateFormat.Value
      If err <> 0 Then MsgBox "You entered an invalid date format.", vbOKOnly, TTS_TITLE
      Exit Function
      On Error GoTo 0  'reset error trapping
    End If

  End If

  '   Step 5 : remove the calendar from memory
  Unload frmCalendar

  CalendarDate_ToRange = True
  If UndoEnabled Then Application.OnUndo "Undo Calendar Date Entry", "UndoChange"

  Exit Function
ErrorHandler:
  Unload frmCalendar
  err.Raise err.Number  're-raise the system error so it is trapped in entry point routine
End Function

Function IsValid(strFileOrPathName As String) As Boolean
  'Tells if a given file exists (ie. 'C:\WINDOWS\WIN.INI")
  'Also tells if a given directory exists (ie. 'C:\WINDOWS\")
  Dim intType As Integer
  On Error Resume Next
  If InStr(strFileOrPathName, ".") Then intType = 0 Else intType = 16         'See what type we are looking for (directory or file)
  IsValid = Not (Dir(strFileOrPathName, intType) = "")
  If err <> 0 Then IsValid = False
End Function
Attribute VB_Name = "modMain"
'=========================================================================
' Module    : modMain
' Company   : Training The Street & Xios Technologies, LLC.
' Author    : Dave Fontanelli
' Created   : 4-14-2006
' Purpose   : Main module, contains entry points and global declarations
'=========================================================================
Option Explicit

'Global Constants
'=====================================
Public Const TTS_MSG_TITLE As String = "TTS Turbo Help"
Public Const TTS_TITLE As String = "TTS Turbo Macro 5.0"
Public Const TTS_SETTINGS_FILE As String = "setting.ttsm"
Public Const TOGGLE_PROB_MSG_FILL As String = "Could not toggle the fill colors."
Public Const TOGGLE_PROB_MSG_FONT As String = "Could not toggle the font colors."
Public Const TOGGLE_PROB_MSG_NUMBER As String = "Could not toggle the number formats."
Public Const PREVIOUS_TTS_ADDIN As String = "An older version of the TTS Turbo Macros add-in is currently selected.  Do you " & _
    "want to remove this old add-in before running the new version.  This can always " & _
    "be re-checked using Tools>Add-Ins."
Public Const sAutoColorUndoShow As String = "AutoColorUndoShow"

'Global Variables
'======================================
Public gintLastColumn As Integer  'Used by AutoFillRight()
Public gintLastZoom As Integer  'Used by UndoZoomChange
Public gclsAutoColor As New CAutoColor  'event trapping class for all open workbooks
Private Const msModule As String = "modMenu"

Sub ReloadMenu()
  'Resets the workbook menu
  If Val(Application.Version) < 12 Then
    '' 2008 06 16 Jon Peltier - added if for Excel 2007
    AddMenus wksMenu.Range("tblcustommenu1")
  End If
End Sub

Sub mnuSetF1Key()
  With wksMenu.Range("F1Key")
    .Value = Not (.Value)
    SetF1Key .Value
  End With
  ThisWorkbook.Save
  ReloadMenu
  If Val(Application.Version) >= 12 Then
    Application.Run "InvalidateControlForCaption", "btnF1Enabled"
  End If
End Sub

Sub mnuSetToolbar()
  If Val(Application.Version) < 12 Then
    With Application.CommandBars(TTS_TOOLBAR)
      .Visible = Not .Visible
      SaveToolbarState
    End With
  End If
End Sub

Sub mnuTTS_Options()
  Const sSOURCE As String = "mnuTTS_Options()"
  Dim x As Object
  Dim r As Range
  Set x = Selection
  If Not ActiveSheet Is Nothing Then
    If TypeName(x) <> "Range" Then
      ActiveSheet.Range("A1").Select
    End If
    Set r = Selection
  End If
  On Error GoTo ErrorHandler
  frmTTSOptions.Show

ErrorExit:
  ' Cleanup code here.
  On Error Resume Next
  r.Parent.Activate
  x.Select
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuInterior_Fill_Toggle()
  Const sSOURCE As String = "mnuInterior_Fill_Toggle()"
  On Error GoTo ErrorHandler

  If Not ToggleAttribute("FILLCOLOR") Then _
      MsgBox TOGGLE_PROB_MSG_FILL, , "Problem Encountered"

ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuFont_Color_Toggle()
  Const sSOURCE As String = "mnuFont_Color_Toggle()"
  On Error GoTo ErrorHandler
  If Not ToggleAttribute("FONTCOLOR") Then _
      MsgBox TOGGLE_PROB_MSG_FONT, , "Problem Encountered"
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuBorder_Toggle()
  Const sSOURCE As String = "mnuBorder_Toggle()"
  On Error GoTo ErrorHandler
  If Not Border_Toggle Then err.Raise glHANDLED_ERROR
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuNumber_Toggle()
  Const sSOURCE As String = "mnuNumber_Toggle()"
  On Error GoTo ErrorHandler
  If Not ToggleAttribute("NUMBERFORMAT") Then _
      MsgBox TOGGLE_PROB_MSG_NUMBER, , "Problem Encountered"

ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuAlignment_Toggle()
  Const sSOURCE As String = "mnuAlignment_Toggle()"
  On Error GoTo ErrorHandler
  If Not Center_Across_Selection Then err.Raise glHANDLED_ERROR
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuIncrease_Decimal()
  'HOTKEY: CTRL+SHIFT+,
  Const sSOURCE As String = "mnuIncrease_Decimal()"
  On Error Resume Next
  Application.CommandBars.FindControl(ID:=398).Execute
  If err <> 0 Then
    err = 0
    On Error GoTo ErrorHandler
    Application.CommandBars.FindControl(ID:=CommandBars("Formatting").Controls("&Increase Decimal").ID).Execute
  End If
  'If Not Increase_Decimal Then Err.Raise glHANDLED_ERROR
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuDecrease_Decimal()
  Const sSOURCE As String = "mnuDecrease_Decimal()"
  On Error Resume Next
  Application.CommandBars.FindControl(ID:=399).Execute
  'If Not Decrease_Decimal Then Err.Raise glHANDLED_ERROR
  If err <> 0 Then
    err = 0
    On Error GoTo ErrorHandler
    Application.CommandBars.FindControl(ID:=CommandBars("Formatting").Controls("&Decrease Decimal").ID).Execute
  End If

ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuView_Increase()
  Const sSOURCE As String = "mnuView_Increase()"
  On Error GoTo ErrorHandler
  If Not View_Increase Then err.Raise glHANDLED_ERROR
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuView_Decrease()
  Const sSOURCE As String = "mnuView_Decrease()"
  On Error GoTo ErrorHandler
  If Not View_Decrease Then err.Raise glHANDLED_ERROR
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuFill_Right()
  Const sSOURCE As String = "mnuFill_Right()"
  On Error GoTo ErrorHandler
  If Not AutoFillRight Then Exit Sub
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuUndo()
  'NOT USED, THE UNDO FUNCTION IS CALLED FROM EDIT>UNDO
  'because not all undo calls are made to UndoChange
  MsgBox "You can also use Edit>Undo or Ctrl + Z"
  UndoChange
End Sub

Sub mnuSetFillRightRange()
  Const sSOURCE As String = "mnuSetFillRightRange()"
  On Error GoTo ErrorHandler
  If Not GetHeaderRangeFromUser() Then Exit Sub
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub mnuTTS_About()
  Const sSOURCE As String = "mnuTTS_About()"
  On Error GoTo ErrorHandler
  frmAbout.Show

  '    Select Case frmAbout.Tag 'NOT Used, Excel crashes after hyperlink.follow
  '    Case "OK"
  '        Unload frmAbout
  '    Case "Email"
  '        Unload frmAbout
  '        Application.OnTime Now() + TimeValue("00:00:01"), "ShowEmailLink"
  '    Case "HTTP"
  '        Unload frmAbout
  '        Application.OnTime Now() + TimeValue("00:00:01"), "ShowWebPageLink"
  '    End Select

ErrorExit:
  Unload frmAbout
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub

Sub ShowEmailLink()  'NOT USED, This did not fix the crash problem
  wksMenu.Range("EmailHyperlink").Hyperlinks(1).Follow
End Sub

Sub ShowWebPageLink()  'NOT USED, This did not fix the crash problem
  wksMenu.Range("TTSHyperlink").Hyperlinks(1).Follow
End Sub

Sub mnuView_Calendar()
  Const sSOURCE As String = "mnuView_Calendar()"
  On Error GoTo ErrorHandler
  If Not CalendarDate_ToRange(Selection) Then err.Raise glHANDLED_ERROR
ErrorExit:
  ' Cleanup code here.
  Exit Sub

ErrorHandler:
  If bCentralErrorHandler(msModule, sSOURCE, , True) Then
    Stop
    Resume
  Else
    Resume ErrorExit
  End If
End Sub
Attribute VB_Name = "modMenu"
'=========================================================================
' Module    : modMenu
' Company   : Training The Street & Xios Technologies, LLC.
' Author    : Dave Fontanelli
' Created   : 4-14-2006
' Purpose   : Menu module, contains logic for creating a table-driven
'               menu.
'=========================================================================
Option Explicit

Public Const sNAME_TABLE_CUSTOM As String = "tblCustomMenu1"

'Column number for field in rngMenuTable
Public Const iBAR_NAME As Integer = 1
Public Const iCONTROL_NAME As Integer = 2
Public Const iSUB_CONT_NAME As Integer = 3
Public Const iCONTROL_TYPE As Integer = 4
Public Const iACTION As Integer = 5
Public Const iHOT_KEY As Integer = 6
Public Const iHOTKEY_INDEX As Integer = 12
Public Const iFACE_ID As Integer = 7
Public Const iVISIBLE As Integer = 8
Public Const iBEGIN_GROUP As Integer = 9
Public Const iCREATE_TOOLBUTTON As Integer = 10
Public Const iBTN_TOOLTIP As Integer = 11
Public Const TTS_TOOLBAR As String = "TTS Turbo Tool"
Public Const TTS_TOOLBAR_POSITION As String = "TTS Toolbar Position"
Public Const TTS_TURBO_MENU As String = "Turbo TT&S"

Sub AddMenus(rngMenuTable As Range)
Attribute AddMenus.VB_ProcData.VB_Invoke_Func = " \n14"
  '
  'Creates a custom menu driven off of a table on the sheet named 'Menu'
  'Currently assumes we are adding a menu control to a built-in Excel menu bar
  'Created By: Dave
  '
  'Dim cMenu1 As CommandBarControl
  Dim cbMainMenuBar As CommandBar
  Dim iHelpMenu As Integer
  Dim cbcCutomMenu As CommandBarControl
  Dim strMenuCaption As String
  Dim strSubMenuCaption As String
  Dim i As Integer, x As Integer
  Dim bTest As String
  Dim sToolbarPosition As String
  Dim vToolbarPosition As Variant
  Dim vToolbarPositionLookup As Variant
  Dim iPosition As Long

  On Error Resume Next
  rngMenuTable.Offset(0, -1).Resize(, 12).Calculate  'just in case menu has formulas and calc is turned off
  '(1)Delete any existing one menu with this name.
  Application.CommandBars(rngMenuTable.Cells(1, iBAR_NAME).Value).Controls(rngMenuTable.Cells(1, iCONTROL_NAME).Value).Delete
  Application.CommandBars(TTS_TOOLBAR).Delete
  On Error GoTo 0

  '(2)Set a CommandBar variable to Worksheet menu bar
  Set cbMainMenuBar = Application.CommandBars(rngMenuTable.Cells(1, iBAR_NAME).Value)

  '(3)Return the Index number of the Help menu. We can then use _
   this to place a custom menu before Help.
  iHelpMenu = cbMainMenuBar.Controls("Help").Index

  '(4)Add a Control to the "Menu Bar" before Help.
  'Set a CommandBarControl variable to it
  For i = 1 To rngMenuTable.Rows.Count

    strMenuCaption = rngMenuTable.Cells(i, iCONTROL_NAME).Value
    'Add the menu control to the main menu bar
    On Error Resume Next
    x = cbMainMenuBar.Controls(strMenuCaption).ID  'will trigger error if does not exist
    If err <> 0 Then
      Set cbcCutomMenu = cbMainMenuBar.Controls.Add(Type:=msoControlPopup, _
          Before:=iHelpMenu)
      'Give the control a caption
      cbcCutomMenu.Caption = strMenuCaption
    End If

    On Error GoTo 0
    '(5)Working with our control, add a sub control and give it parameters
    With cbcCutomMenu.Controls.Add(Type:=rngMenuTable.Cells(i, iCONTROL_TYPE).Value)
      .Caption = rngMenuTable.Cells(i, iSUB_CONT_NAME).Value
      .OnAction = rngMenuTable.Cells(i, iACTION).Value
      .FaceId = IIf(IsNumeric(rngMenuTable.Cells(i, iFACE_ID).Value), rngMenuTable.Cells(i, iFACE_ID).Value, 0)
      .Visible = rngMenuTable.Cells(i, iVISIBLE).Value
      .BeginGroup = rngMenuTable.Cells(i, iBEGIN_GROUP).Value
      '''.ShortcutText = "Ctrl+Shift+" & Right$(rngMenuTable.Cells(i, iHOT_KEY), 1)
    End With

    If Not (IsNumeric(rngMenuTable.Cells(i, iFACE_ID).Value)) Then
      wksMenu.Shapes(rngMenuTable.Cells(i, iFACE_ID).Value).CopyPicture
      cbcCutomMenu.Controls(rngMenuTable.Cells(i, iSUB_CONT_NAME).Value).PasteFace
    End If
    
    ''If wksMenu.Range("DisplayTTSToolbar").Value Then
    If rngMenuTable.Cells(i, iCREATE_TOOLBUTTON).Value Then MakeToolbar rngMenuTable, i
    ''End If
    
    ''''Assign a Hot Key for this new command
    '''If rngMenuTable.Cells(i, iHOT_KEY).Value <> "" Then
    '''    Application.OnKey rngMenuTable.Cells(i, iHOT_KEY).Value, rngMenuTable.Cells(i, iACTION).Value
    '''End If
  Next
  
  vToolbarPosition = Array(True, 1, 20, 0, 0, 400)
  bTest = GetVariable(TTS_SETTINGS_FILE, TTS_TOOLBAR_POSITION, sToolbarPosition)
  If bTest Then
    vToolbarPositionLookup = Split(sToolbarPosition, "|")
    For iPosition = LBound(vToolbarPosition) To UBound(vToolbarPosition)
      If Len(vToolbarPositionLookup(iPosition)) > 0 Then
        vToolbarPosition(iPosition) = vToolbarPositionLookup(iPosition)
      End If
    Next
  End If
  
  With Application.CommandBars(TTS_TOOLBAR)
    .Position = CLng(vToolbarPosition(1))
    .Left = CLng(vToolbarPosition(3))
    If .Position = msoBarFloating Then
      .Top = CLng(vToolbarPosition(4))
      .Width = CLng(vToolbarPosition(5))
    Else
      .RowIndex = CLng(vToolbarPosition(2))
    End If
    .Visible = CBool(vToolbarPosition(0))
  End With

  Application.OnTime Now + TimeValue("0:0:3"), "'" & ThisWorkbook.Name & "'!EnableHotKeys"

End Sub

Sub DeleteMenu(rngMenuTable As Range)
Attribute DeleteMenu.VB_ProcData.VB_Invoke_Func = " \n14"
  Dim i As Integer
  On Error Resume Next
  Application.CommandBars(rngMenuTable.Cells(1, iBAR_NAME).Value).Controls(rngMenuTable.Cells(1, iCONTROL_NAME).Value).Delete
  Application.CommandBars(TTS_TOOLBAR).Delete
  For i = 1 To rngMenuTable.Rows.Count
    'remove hot keys
    If rngMenuTable.Cells(i, iHOT_KEY).Value <> "" Then
      Application.OnKey rngMenuTable.Cells(i, iHOT_KEY).Value
    End If
  Next
  'On Error GoTo 0

End Sub

Sub MakeToolbar(rngMenuTable As Range, i As Integer)
  Dim cbTool As CommandBar

  'Get a reference to the Toolbar
  On Error Resume Next
  Set cbTool = CommandBars(TTS_TOOLBAR)  'will trigger error if does not exist
  If err <> 0 Then
    Set cbTool = CommandBars.Add(TTS_TOOLBAR, msoBarTop, False, True)
    cbTool.Protection = msoBarNoResize
    cbTool.Visible = False
  End If
  'Create a new button on the toolbar
  With cbTool
    With .Controls.Add(rngMenuTable.Cells(i, iCONTROL_TYPE).Value, 1)
      .OnAction = rngMenuTable.Cells(i, iACTION).Value

      If Not (IsNumeric(rngMenuTable.Cells(i, iFACE_ID).Value)) Then
        wksMenu.Shapes(rngMenuTable.Cells(i, iFACE_ID).Value).CopyPicture
        .PasteFace
      Else
        .FaceId = rngMenuTable.Cells(i, iFACE_ID).Value
      End If

      .BeginGroup = rngMenuTable.Cells(i, iBEGIN_GROUP).Value
      .TooltipText = rngMenuTable.Cells(i, iBTN_TOOLTIP).Value
    End With

  End With
End Sub
'=========================================================================
Sub EnableHotKeys()
  '  Dim i As Long
  '  Dim rngMenuTable As Range
  '
  '  Set rngMenuTable = wksMenu.Range("tblCustomMenu1")
  '  For i = 1 To rngMenuTable.Rows.Count
  '        'Assign a Hot Key for this command
  '        If rngMenuTable.Cells(i, iHOT_KEY).Value <> "" Then
  '            Application.OnKey rngMenuTable.Cells(i, iHOT_KEY).Value, rngMenuTable.Cells(i, iACTION).Value
  '        End If
  '  Next

  ShortcutKeysApply ShortcutCurrentKeys
End Sub

Sub DisableHotKeys()
  '  Dim i As Long
  '  Dim rngMenuTable As Range
  '
  '  Set rngMenuTable = wksMenu.Range("tblCustomMenu1")
  '  For i = 1 To rngMenuTable.Rows.Count
  '    'remove hot keys
  '    If rngMenuTable.Cells(i, iHOT_KEY).Value <> "" Then
  '      Application.OnKey rngMenuTable.Cells(i, iHOT_KEY).Value
  '    End If
  '  Next

  ShortcutKeysUnapply ShortcutDefaultKeys
  ShortcutKeysUnapply ShortcutCurrentKeys
End Sub
'=========================================================================
Attribute VB_Name = "modSheetControl"
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'' Info:     worksheet control tools (created for TTS)
'' Updated:  2010.04.26
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Option Explicit
Option Private Module

Sub mnuShow_Sheet_Control()
  If CheckIfNothing Then
    frmSheetControl.Show
  End If
End Sub

Function TTS_Sheet_Control(zoom_percentage As Integer, gridline_show As Boolean, header_show As Boolean, set_pg_view As Boolean)

  Dim curr_sht As String
  Dim wksht As Worksheet

  Application.ScreenUpdating = False
  Application.EnableEvents = False

  On Error GoTo errhand

  curr_sht = ActiveSheet.Name

  For Each wksht In ActiveWorkbook.Worksheets
    wksht.Activate
    Call Set_Zoom_Percentage(zoom_percentage)
    Call Hide_Sht_Gridlines(gridline_show)
    Call Hide_Sht_Headers(header_show)
    Call Set_Page_View(set_pg_view)
  Next wksht

exit_macro:
errhand:

  Sheets(curr_sht).Activate

  Application.EnableEvents = True
  Application.ScreenUpdating = True

End Function

Function Set_Zoom_Percentage(zoom_per As Integer)
  On Error GoTo err
  ActiveWindow.Zoom = Val(zoom_per)
err:
End Function

Function Hide_Sht_Gridlines(vis As Boolean)
  On Error GoTo err
  ActiveWindow.DisplayGridlines = vis
err:
End Function

Function Hide_Sht_Headers(vis As Boolean)
  On Error GoTo err
  ActiveWindow.DisplayHeadings = vis
err:
End Function

Function Set_Page_View(normal_view As Boolean)
  On Error GoTo err
  If normal_view = True Then
    ActiveWindow.View = xlNormalView
  Else
    ActiveWindow.View = xlPageBreakPreview
  End If
err:
End Function

Function CheckIfNothing() As Boolean
  '/ no worksheet
  CheckIfNothing = (TypeName(ActiveSheet) = "Worksheet")
End Function
Attribute VB_Name = "wksMenu"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "wksUndo"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

' InQuest injected base64 decoded content
' jwGjwez
' q/z{S

INQUEST-PP=macro
