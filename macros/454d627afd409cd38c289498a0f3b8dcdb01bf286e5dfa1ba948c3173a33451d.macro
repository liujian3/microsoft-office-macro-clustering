Attribute VB_Name = "AAA_ExportCode"
Option Explicit

Private Sub CreateXLAXLAM()
  Application.DisplayAlerts = False
  WBRemoveTags
  ThisWorkbook.IsAddin = True
  ThisWorkbook.SaveAs ThisWorkbook.Path & "\ECCV0.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.Saved = True
  Application.DisplayAlerts = True

End Sub
Private Sub WBRemoveTags()

    Dim nameItem As Excel.name

GoAgain:
    Dim i As Long
    If ThisWorkbook.Names.count > 0 Then
      For i = 1 To ThisWorkbook.Names.count
          If ThisWorkbook.Names(i).Visible = False Then
              If Left(ThisWorkbook.Names(i).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.Names.item(i).Delete
                  GoTo GoAgain
              End If
          End If
      Next i
    End If

End Sub



Private Sub ExportMyModules()
  Dim cm
  Dim counter As Long
  MkFullDir ThisWorkbook.Path & "\vba"
  MyKill ThisWorkbook.Path & "\vba\*.bas"
  MyKill ThisWorkbook.Path & "\vba\*.cls"
  MyKill ThisWorkbook.Path & "\vba\*.frx"
  MyKill ThisWorkbook.Path & "\vba\*.frm"
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, ThisWorkbook.Path & "\vba"
      End If
    End If
  Next

End Sub


Private Function ExportVBComponent(ByRef VBComp, _
                FolderName As String, _
                Optional Filename As String, _
                Optional OverwriteExisting As Boolean = True) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This function exports the code module of a VBComponent to a text
    ' file. If FileName is missing, the code will be exported to
    ' a file with the same name as the VBComponent followed by the
    ' appropriate extension.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim Extension As String
    Dim fname As String
    Extension = GetFileExtension(VBComp:=VBComp)
    If Trim(Filename) = vbNullString Then
        fname = VBComp.name & Extension
    Else
        fname = Filename
        If InStr(1, fname, ".", vbBinaryCompare) = 0 Then
            fname = fname & Extension
        End If
    End If
    
    If StrComp(Right(FolderName, 1), "\", vbBinaryCompare) = 0 Then
        fname = FolderName & fname
    Else
        fname = FolderName & "\" & fname
    End If
    
    If Dir(fname, vbNormal + vbHidden + vbSystem) <> vbNullString Then
        If OverwriteExisting = True Then
            Kill fname
        Else
            ExportVBComponent = False
            Exit Function
        End If
    End If
    
    VBComp.Export Filename:=fname
    ExportVBComponent = True
    
    End Function
    
Private Function GetFileExtension(ByRef VBComp) As String
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This returns the appropriate file extension based on the Type of
' the VBComponent.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case VBComp.Type
        Case 2 ' vbext_ct_ClassModule
            GetFileExtension = ".cls"
        Case 100 ' vbext_ct_Document
            GetFileExtension = ".cls"
        Case 3 ' vbext_ct_MSForm
            GetFileExtension = ".frm"
        Case 1 ' vbext_ct_StdModule
            GetFileExtension = ".bas"
        Case Else
            GetFileExtension = ".bas"
    End Select
    
End Function


Attribute VB_Name = "Analyse"
Option Explicit

Sub EinzelanalyseStarten()

  InitApp
  
  Beenden = False
  
  Dim Filename
  
  
  Filename = Application.GetOpenFileName(Texte(GSprache, TXT_XLFILES), 1, "Excel Datei laden")

  ' War die Eingabe ok?
  If Filename = False Then Exit Sub
  
  theFilename = Filename
  
  
  XLScriptInitDebug
  
'  Application.OnTime Now + TimeValue("00:00:04"), "DoEinzelanalyse"
  ShowStatusForm theFilename
  DoEinzelanalyse

End Sub



Sub MassenanalyseFortsetzen()
  
  InitApp
  
  MsgBox "Bitte w|fffd|hlen Sie jetzt eine zuvor erzeugte Ergebnisdatei aus, mit der die Analyse fortgesetzt werden soll!", vbInformation, "Excel-Sheet-Checker"
  
  Dim Filename
  Filename = Application.GetOpenFileName(Texte(GSprache, TXT_XLFILES), 1, "Excel Datei laden")

  If Filename = False Then Exit Sub
  Beenden = False
  
  
  Dim wb As Excel.Workbook
  Set wb = Application.Workbooks.Open(Filename)
  SetLiveStatus
  If Not WorksheetExists(wb, "ECCFiles") Then
    wb.Saved = True
    wb.Close False
    MsgBox "Die Datei ist keine Ergebnisdatei einer Massenanalyse! Der Vorgang wird abgebrochen.", vbCritical
    Exit Sub
  End If
  
  wb.Sheets("|fffd|bersicht").Select
  wb.Sheets("|fffd|bersicht").Range("A1").Select
  Dim r As Range
  Set r = wb.Sheets("|fffd|bersicht").Cells.Find("Abgebrochen!", wb.Sheets("|fffd|bersicht").Range("A1"), xlValues, _
      xlPart, xlByRows, xlNext, _
      False, False)
  
  If Not r Is Nothing Then
    If r.Row <> 1 Or r.Column <> 1 Then
      MsgBox "Bei dieser Ergebnisdatei wurde die Analyse manuell beendet (die Ergebnisdatei wurde finalisiert). Ein Fortsetzen des Vorgangs ist nicht mehr m|fffd|glich.", vbInformation
      wb.Saved = True
      wb.Close False
      Exit Sub
    End If
  End If
  
  wb.Saved = True
  wb.Close False
  
  Dim d As Date
  d = Now
  
  MassenanalyseStartSub Filename, d

End Sub


Sub MassenanalyseStarten()
  
  InitApp
  
  PathSelect.MyInit
  PathSelect.Show
  
  If PathSelect.WasOK = False Then Exit Sub

  If xlsDateien.count <= 0 Then
    MsgBox "Es konnte keine Dateien gefunden werden, die f|fffd|r die Analyse relevant w|fffd|ren!", vbInformation, "Excel-Sheet-Checker"
    Exit Sub
  End If


'  If MsgBox("M|fffd|chten Sie eine Schnellanalyse durchf|fffd|hren? (bei NEIN wird eine Detailanalyse auf Formelzellebene durchgef|fffd|hrt)", vbYesNo + vbExclamation, "Excel-Sheet-Checker") = vbYes Then
'    G_Schnellanalyse = True
'  Else
'    G_Schnellanalyse = False
'  End If
  
  
  MsgBox "Bitte geben Sie jetzt den Dateinamen f|fffd|r die Ergebnisdatei ein!", vbInformation, "Excel-Sheet-Checker"
  
  Dim Filename
      
  Filename = Application.GetSaveAsFilename("*.xls", "Excel (*.xls),*.xls", , Texte(GSprache, TXT_ERGEBNISSPEICHERN))

  If Filename = False Then Exit Sub
  
  Beenden = False
  
  
  
  Dim wb As Excel.Workbook
  
  If G_Schnellanalyse Then
    Set wb = Workbooks.Add(ThisWorkbook.Path & "\ECC-MassenanalyseSchnell.xltx")
  Else
    Set wb = Workbooks.Add(ThisWorkbook.Path & "\ECC-Massenanalyse.xltx")
  End If
  
  On Error Resume Next
  wb.Saved = True
  
  
  Dim sfitem As ScanFile
  Dim x As Long
  x = 0
  With wb.Sheets("ECCFiles")
  For Each sfitem In xlsDateien
    If UCase(sfitem.m_Name) <> UCase(ThisWorkbook.FullName) And UCase(sfitem.m_Name) <> UCase(Filename) Then
        .Cells(2 + WorksheetFunction.RoundDown(x / 255, 0), 1 + x Mod 255) = sfitem.m_Name
        x = x + 1
    End If
  Next sfitem
  
  .Cells(1, 1) = 1
  .Cells(1, 2) = 0
  .Cells(1, 3) = IIf(G_CheckDimension = True, "Ja", "Nein")
  .Cells(1, 4) = IIf(G_Schnellanalyse = True, "Ja", "Nein")

  End With
  
  
  wb.SaveAs Filename
  On Error GoTo 0
  
  If Not wb.Saved Then
    wb.Close False
    Set wb = Nothing
    Exit Sub
  End If
  
  XLScriptInitGlobals
  
  Dim d As Date
  d = Now
  XLScriptAddSimpleVar "STARTOFSCAN", d
  
  If PathSelect.selMonate <> 10000 Then
    XLScriptAddSimpleVar "FILTERNOTEARLIERTHAN", Texte(GSprache, TXT_NAEA) & Format(DateAdd("m", -PathSelect.selMonate, Now()), "Short Date")
  Else
    XLScriptAddSimpleVar "FILTERNOTEARLIERTHAN", "'-/-"
  End If
  
  If PathSelect.selKB <> 0 Then
    XLScriptAddSimpleVar "FILTERNOTSMALLERTHAN", Texte(GSprache, TXT_NKA) & PathSelect.selKB & " Kb"
  Else
    XLScriptAddSimpleVar "FILTERNOTSMALLERTHAN", "'-/-"
  End If
  
  If PathSelect.selUnterverzeichnisseIgnorieren = True Then
    XLScriptAddSimpleVar "FILTERIGNORESUBDIRECTORIES", Texte(GSprache, TXT_UVI)
  Else
    XLScriptAddSimpleVar "FILTERIGNORESUBDIRECTORIES", "'-/-"
    If PathSelect.selGleicheNamenIgnorieren = True Then
      XLScriptAddSimpleVar "FILTERIGNOREIDENTICALNAMES", Texte(GSprache, TXT_GLEICHENAMEN)
    Else
      XLScriptAddSimpleVar "FILTERIGNOREIDENTICALNAMES", "'-/-"
    End If
  End If
  
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESSMALLER", TotalUnusedFilesSmaller
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESSMALLERKB", TotalUnusedBytesSmaller / 1024
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESOLDER", TotalUnusedFilesOlder
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESOLDERKB", TotalUnusedBytesOlder / 1024
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESDOUBLE", TotalUnusedFilesDouble
  XLScriptAddSimpleVar "FILTERTOTALUNUSEDFILESDOUBLEKB", TotalUnusedBytesDouble / 1024
  
  Dim scannedpaths As Object
  Set scannedpaths = XLScriptAddArray("SCANPATHS")

  Dim item
  If PathSelect.Verzeichnisse.ListCount > 0 Then
    For item = 0 To PathSelect.Verzeichnisse.ListCount - 1
      scannedpaths.AddValue "", PathSelect.Verzeichnisse.Column(0, item)
    Next item
  End If
  
  
  Dim XLScriptInaccessablePaths As Object
  Set XLScriptInaccessablePaths = XLScriptAddArray("INACCESSABLEPATHS")
  
  If inaccessablePaths.count > 0 Then
    For Each item In inaccessablePaths
      XLScriptInaccessablePaths.AddValue "", CStr(item)
    Next item
  End If
    
  
  
  Dim ws As Excel.Worksheet
  For Each ws In wb.Worksheets
    XLScriptInit ws, 1
    XLScriptExecCode ws.Cells, 0, 0
    XLScriptExit
  Next ws
  
  
  XLScriptExitGlobals
  
  wb.Save
  wb.Close True
  Set wb = Nothing
  
  
  MassenanalyseStartSub Filename, d


End Sub
  
Sub MassenanalyseStartSub(fname, d As Date)
  
  SaveSetting _
   appname:="Stromwerken", _
   Section:="ECC", _
   Key:="MAErgebnis", _
   setting:=fname
  
  SaveSetting _
   appname:="Stromwerken", _
   Section:="ECC", _
   Key:="MAStart", _
   setting:=d
  
  SaveSetting _
  appname:="Stromwerken", _
  Section:="ECC", _
  Key:="MAStatus", _
  setting:="Init"
  
  SaveSetting _
  appname:="Stromwerken", _
  Section:="ECC", _
  Key:="CheckDimensions", _
  setting:=IIf(G_CheckDimension = True, "True", "False")
  
  SaveSetting _
  appname:="Stromwerken", _
  Section:="ECC", _
  Key:="Schnellanalyse", _
  setting:=IIf(G_Schnellanalyse = True, "True", "False")
  
  
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  
'  Application.OnTime Now + TimeValue("00:00:04"), "DoMassenanalyse"
  ShowStatusForm ""
  DoMassenanalyse
  
'  DoMassenanalyse

End Sub
Attribute VB_Name = "Arrows"
Option Explicit

Function GetArrows(c As Range, ByRef col As Collection, prec As Boolean, onlyAreas As Boolean) As Boolean
  On Error GoTo nogo
  Dim ac As Range
  Set ac = ActiveCell
  Set col = New Collection
    
  Dim rLast As Range, iLinkNum As Integer, iArrowNum As Integer
  Dim stMsg As String
'  c.Parent.Activate
  c.Activate
  If prec = True Then
    ActiveCell.ShowPrecedents
  Else
    ActiveCell.ShowDependents
  End If

  Set rLast = ActiveCell
  iArrowNum = 1
  iLinkNum = 1
  
  
  Dim wasNewArrow As Boolean
  
  wasNewArrow = True
  
  Do
      Do
          Application.GoTo rLast
          If Not NavArrow(ActiveCell, iArrowNum, iLinkNum, prec) Then
            If wasNewArrow Then
              rLast.Parent.ClearArrows
              Application.GoTo rLast
'              MsgBox "Precedents are" & stMsg
              Exit Function
            Else
              Exit Do
            End If
          End If
          
          ' If iLinkNum > 10 Then
          If rLast.Address(external:=True) = ActiveCell.Address(external:=True) Then
              rLast.Parent.ClearArrows
              Application.GoTo rLast
              If col.count > 0 Then GetArrows = True
              Exit Function
          End If
          
          If onlyAreas Then
            If InStr(Selection.Address, ":") > 0 Then
              col.Add Selection
            End If
          Else
            col.Add Selection
          End If
          
          iLinkNum = iLinkNum + 1  ' try another  link
          wasNewArrow = False
       Loop
       iLinkNum = 1
       wasNewArrow = True
       iArrowNum = iArrowNum + 1  'try another arrow
  Loop
  rLast.Parent.ClearArrows
  Application.GoTo rLast

  If col.count > 0 Then GetArrows = True
  
  ac.Activate
  
nogo:

End Function

Function NavArrow(c As Range, iArrowNum As Integer, iLinkNum As Integer, prez As Boolean) As Boolean
  On Error GoTo waserror
  c.NavigateArrow TowardPrecedent:=prez, ArrowNumber:=iArrowNum, LinkNumber:=iLinkNum
  NavArrow = True
  Exit Function
waserror:
  NavArrow = False
End Function

Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection

Private Function GetNextLine(ByRef s As String) As String

    Dim rs As String
    Do
        rs = GetLine(s)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(s)) <= 0 Then
            GetNextLine = ""
            s = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    Set m_Lines = New Collection
    Set m_Sec = New Collection

    If Len(txt) = 0 Then Exit Sub
    Dim s As String
    Do
        s = GetNextLine(txt)
        If Len(s) <= 0 Then Exit Do
        m_Lines.Add (s)
        m_Sec.Add (s)
    Loop
End Sub


Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function


Function GetCFG(fname As String) As Boolean
  On Error GoTo couldntOpenFile
  
  Dim ff As Long
  ff = FreeFile
  Dim s As String
  
  ' check for UTF8!
  Open fname For Binary Access Read As #ff
  Dim l As Byte
  Get #ff, 1, l
  Close ff
  
  If l = 239 Then
    GetCFG = GetCfgUTF8(fname)
    Exit Function
  End If
 
  
  Open fname For Input As #ff
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  
  Do While Not EOF(ff)
    Line Input #ff, s
    If Len(Trim(s)) > 0 Then
      m_Lines.Add s
    End If
    m_Sec.Add s
  Loop
  Close #ff
  GetCFG = True
  Exit Function
couldntOpenFile:
  GetCFG = False
End Function

Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
End Function

Function GetValue(s As String) As String
  Dim i As Long
  For i = 1 To m_Sec.count
    If Left(m_Sec(i), Len(s) + 1) = s & "=" Then
      GetValue = Trim(Mid(m_Sec(i), Len(s) + 2))
      Exit Function
    End If
  Next i
  GetValue = ""
End Function

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim i As Long
  Dim found As Boolean
  found = False
  For i = 1 To m_Lines.count
    If m_Lines(i) = "[" & sec & "]" Then
      i = i + 1
      Do While i <= m_Lines.count
        If Left(m_Lines(i), 1) <> "[" Then
          c.Add m_Lines(i)
          found = True
          i = i + 1
        Else
          Exit Do
        End If
      Loop
    End If
    If i > m_Lines.count Then Exit For
  Next i
  GetSectionValues = found
End Function




Attribute VB_Name = "CheckinStuff"
Option Explicit

Function CheckInFile(ByRef rs As Object, checkindat As Date) As Boolean

On Error GoTo nogo

  Dim logtrack As Long
  logtrack = 0

  CheckInFile = False
  
  If Len(G_cfgTemppfad) > 0 Then
      logtrack = 1
      
      'erst mal alte killen falls vorhanden
      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").Value) Then
          logtrack = 2
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").Value
          logtrack = 3
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").Value) Then
            logtrack = 4
            ' DebugPrint DebType.tERROR, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(1)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
            AddStatus "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!"
            Exit Function
          End If
          logtrack = 5
      End If
      
      logtrack = 6
      If Not PathExists(G_cfgTemppfad) Then
        ' DebugPrint DebType.tERROR, "CheckInFile: TempPathMissing '" & rs.Fields("Dateiname").Value & "'"
        AddStatus "FEHLER: Der tempor|fffd|re Pfad '" & G_cfgTemppfad & "' existiert nicht."
        Exit Function
      End If
      CopyFile GetDriveAndPathFromUNC(rs.Fields("Dateiname").Value), G_cfgTemppfad & "\" & rs.Fields("Hash").Value, 0
      logtrack = 7

      If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").Value) Then
          logtrack = 8
          If Not xlCheckInBinary(rs.Fields("idvDateiID").Value, rs.Fields("Version").Value, checkindat, G_cfgTemppfad & "\" & rs.Fields("Hash").Value) Then
            ' DebugPrint DebType.tdebug, "Die Datei '" & rs.Fields("Dateiname").Value & "' konnte nicht eingecheckt werden"
            ' MsgBox "Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
            AddStatus "FEHLER: Die Datei konnte nicht auf dem Datenbankserver eingecheckt werden! Bitte versuchen Sie es sp|fffd|ter noch einmal!"
          End If
          logtrack = 9
          MyKill G_cfgTemppfad & "\" & rs.Fields("Hash").Value
          
          If FileExists(G_cfgTemppfad & "\" & rs.Fields("Hash").Value) Then
            ' DebugPrint DebType.tdebug, "Tempor|fffd|re Datei f|fffd|r '" & rs.Fields("Dateiname").Value & "' nicht gel|fffd|scht(2)"
            ' MsgBox "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
            AddStatus "FEHLER: Die tempor|fffd|re Datei '" & G_cfgTemppfad & "\" & rs.Fields("Hash").Value & "' konnte nicht gel|fffd|scht werden. Bitte informieren Sie Ihre Administration!"
          End If

          logtrack = 19
          CheckInFile = True
          Exit Function
      Else
        ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
        ' MsgBox "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
        AddStatus "FEHLER: Die Datei konnte nicht in den tempor|fffd|ren Pfad kopiert werden! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
      End If
  Else
    ' DebugPrint DebType.tERROR, "CheckInFile: No checkin (" & logtrack & "): " & rs.Fields("Dateiname").Value
    ' MsgBox "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"
    AddStatus "FEHLER: Es ist kein tempor|fffd|rer Pfad konfiguriert! Die Datei kann nicht eingecheck werden! Bitte informieren Sie die Administration!"
  End If
  
  Exit Function
nogo:
  ' DebugPrint DebType.tERROR, "CheckInFile:" & logtrack
  ' MsgBox "FEHLER: Die Datei '" & rs.Fields("Dateiname").Value & "' kann nicht eingecheck werden!" & Err.Number & " - " & Err.Description & " - " & Err.Source, vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion & " (Build: " & app.Major & "-" & app.Minor & "-" & app.Revision & ")"

End Function

Public Function xlCheckInBinary(ByVal idvDateiID As Long, ByVal Version As Long, ByVal dat As Date, ByVal fname As String) As Boolean
        On Error GoTo fehler
        Dim cn As Object

        Set cn = GetConnection()

        If cn Is Nothing Then Exit Function
        
        LogPrint "xlCheckInBinary-Start"

        ' Erst mal eine eventuell bereits eingecheckte Datei rauswerfen!
        cn.Execute "DELETE FROM xlBin WHERE idvDateiID = " & idvDateiID & " and Version = " & Version

        Dim rs As Object
        Set rs = OpenRS("SELECT * FROM xlBin", cn, MYadOpenDynamic, MYadLockOptimistic)
        
        If rs Is Nothing Then
          cn.Close
          Set cn = Nothing
          xlCheckInBinary = False
        End If
        
        LogPrint "xlCheckInBinary-1"
        rs.AddNew
        rs.Fields("idvDateiID").Value = idvDateiID
        rs.Fields("Version").Value = Version
        rs.Fields("Datum").Value = dat
        LogPrint "xlCheckInBinary-2"

        If Not CheckInBinary("Binary", rs, fname) Then
          rs.CancelUpdate
          rs.Close
          xlCheckInBinary = False
        Else
          rs.Update
          rs.Close
          xlCheckInBinary = True
        End If
        Set rs = Nothing
        LogPrint "xlCheckInBinary-3"
        
        cn.Close
        Set cn = Nothing
        
        LogPrint "xlCheckInBinary-Finished"
        Exit Function
fehler:
'        If Not rs Is Nothing Then
'          rs.Close
          Set rs = Nothing
'        End If
        If Not cn Is Nothing Then
          cn.Close
          Set cn = Nothing
        End If
        xlCheckInBinary = False
End Function

Private Function CheckInBinary(ByVal fieldname As String, ByRef rs As Object, ByVal fname As String) As Boolean

        On Error GoTo fehler
        Dim Doc As Object
        Set Doc = CreateObject("ADODB.Stream")
        With Doc
            .Type = 1
            .Open
            .LoadFromFile fname
        End With
        rs.Fields(fieldname).Value = Doc.Read
        CheckInBinary = True
        Exit Function

fehler:
End Function

Attribute VB_Name = "CloneStuff"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_CheckSum As Long
Public m_FormulaExtractedNames As String
Public m_IF As Long
Public m_Calc As Long
Public m_Sum As Long
Public m_Array As Long
Public m_Ref As Long
Public m_HasExternalRefs As Boolean

Attribute VB_Name = "CrunchRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_Von As Long
Public m_Bis As Long


Sub Initialize(ByVal n As String, ByVal startval As Long)
  m_Name = n
  m_Von = startval
  m_Bis = startval
End Sub

Function InRange(ByVal n As String, ByVal v As Long, Optional ByVal addItem As Boolean = False) As Boolean
  If m_Name <> n Then Exit Function
  
  If v >= m_Von - 1 And v <= m_Bis + 1 Then
    InRange = True
    If addItem Then
      If v = m_Von - 1 Then
        m_Von = v
      End If
      If v = m_Bis + 1 Then
        m_Bis = v
      End If
    End If
  End If
End Function


Attribute VB_Name = "DBStuff"
Option Explicit

Public G_DBUser As String
Public G_DBUserPasswort As String
Public G_cfgConnectVia As String

Function GetConnection(Optional ByVal waitendless As Boolean = False) As Object

    DebugPrint DebType.tdebug, "Connect Start"
    Dim conn
    Set conn = CreateObject("ADODB.Connection")
    If G_Cursorlocation <> 2 And G_Cursorlocation <> 3 Then
      G_Cursorlocation = 3
    End If
    conn.CursorLocation = G_Cursorlocation
    On Error Resume Next

    Set GetConnection = Nothing
    Dim cnt As Long
    cnt = 0
checkAgain:
    
    If G_cfgConnectVia = "ODBCDSN" Or G_DBConnectionString = "" Then
      conn.Open "IDV-Tracker", G_DBUser, G_DBUserPasswort
      DebugPrint DebType.tdebug, "Connect Via: IDV-Tracker (G_cfgConnectVia=" & G_cfgConnectVia & ")"
    Else
      conn.Open G_DBConnectionString, G_DBUser, G_DBUserPasswort
      DebugPrint DebType.tdebug, "Connect Via: " & G_DBConnectionString
    End If
    
    Dim connectError As String
    If Err.Number <> 0 Then
        connectError = Err.Description
        Err.Clear
        Sleep 50
        cnt = cnt + 1
        If Not waitendless Then
            If cnt >= 100 Then
                conn = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If
    End If
    If connectError <> "" Then
      DebugPrint DebType.tdebug, "Connect Error: " & connectError
    End If

    Set GetConnection = conn

End Function


Sub GetDBUser()
    LogPrint "GetDBUser"
    
    G_DBUser = "IDVTTECHUSER"
    G_DBUserPasswort = "12SD3Ax$!d7%fd/"
    
    Dim cfg As CfgReader
    Set cfg = New CfgReader
    
    If FileExists(ThisWorkbook.Path & "\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.Path & "\..\cfg\IDV-Suite.cfg") = True Or _
        FileExists(ThisWorkbook.Path & "\..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Or _
        FileExists(ThisWorkbook.Path & "\IDV-Suite.cfg") = True Then
        
        If FileExists(ThisWorkbook.Path & "\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.Path & "\IDV-Suite.cfg")
          LogPrint "GetDBUser Cfg: " & ThisWorkbook.Path & "\IDV-Suite.cfg"
        ElseIf FileExists(ThisWorkbook.Path & "\..\cfg\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.Path & "\..\cfg\IDV-Suite.cfg")
          LogPrint "GetDBUser Cfg: " & ThisWorkbook.Path & "\..\cfg\IDV-Suite.cfg"
        ElseIf FileExists(ThisWorkbook.Path & "\..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.Path & "\..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg")
          LogPrint "GetDBUser Cfg: " & ThisWorkbook.Path & "\..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg"
        ElseIf FileExists(ThisWorkbook.Path & "\IDV-Suite.cfg") = True Then
          cfg.GetCFG (ThisWorkbook.Path & "\IDV-Suite.cfg")
          LogPrint "GetDBUser Cfg: " & ThisWorkbook.Path & "\IDV-Suite.cfg"
        End If

        Dim s As String
        If cfg.GetSection("DB") = True Then
            s = cfg.GetValue("USER")
            If s <> "" Then
                G_DBUser = Crypt(s, "uIq2%7/=}pJIi39x?", False)
                LogPrint "GetDBUser User read"
            End If
            s = cfg.GetValue("PASSWORD")
            If s <> "" Then
                G_DBUserPasswort = Crypt(s, "uIq2%7/=}pJIi39x?", False)
                LogPrint "GetDBUser PW read"
            End If
        End If
    Else
      LogPrint "GetDBUser: IDV-Suite.cfg not found"
    End If
    LogPrint "GetDBUser finished"
End Sub


Function Crypt(Inp As String, Key As String, Mode As Boolean) As String
    Dim z As String
    Dim i As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For i = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If Mode Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, i, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If i > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, i * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
        Next i
     
        Crypt = z
End Function


Function GetSafeFieldPlus(ByRef rs As Object, ByVal fieldname As String, Optional defaultVal As Variant) As Variant
  On Error Resume Next
  If Not IsNull(rs.Fields(fieldname).Value) Then
    GetSafeFieldPlus = rs.Fields(fieldname).Value
  Else
    If Not IsMissing(defaultVal) Then
      GetSafeFieldPlus = defaultVal
    End If
  End If
End Function
Attribute VB_Name = "DebugStuff"
Option Explicit

Enum DebType
    tERROR = 1
    tInfo = 2
    tTime = 3
    tdebug = 4
    tMail = 5
    tsystem = 6
End Enum

Public G_PARAM_DebugInfosLoggen As Boolean
Public G_IgnoreFutureWriteWindows As Boolean

Public G_LogThisUser As Boolean
Public G_PARAM_CollectDebug As Boolean

Public G_LogToWindow As Boolean
Public G_LogWriteIgnore As Boolean

Private L_InDebugPrint As Boolean


Public Const G_LOG_EXTERNE_KOPIE As Long = 1              ' Die Datei wurde durch eine andere Datei au|fffd|erhalb des IDV-Tracker-Systems |fffd|berschrieben. Wahrscheinlich hat der User eine Datei mit dem Explorer |fffd|ber die Originaldatei kopiert.
Public Const G_LOG_NEUE_FREIGABE_ENTFERNT As Long = 2     ' F|fffd|r die Datei wurde eine neue Version erzeugt. Dadurch wurde die Programmfreigabe aufgehoben.
Public Const G_LOG_NEUE_VERSION As Long = 3               ' F|fffd|r die Datei wurde eine neue Version erzeugt.
Public Const G_LOG_BLATSCHUTZ_ENTFERNEN_INIT As Long = 4  ' Blattschutz-Entfernung initiiert
Public Const G_LOG_BLATTSCHUTZ_ENTFERNT As Long = 5       ' Blattschutz entfernt
Public Const G_LOG_BLATTSCHUTZ_ANGEBRACHT As Long = 6     ' Blattschutz angebracht

Private Sub SetConnectTimeout(ByRef conn)
  On Error Resume Next
  conn.Execute "SET LOCK_TIMEOUT 5000"
  conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
  Err.Clear
End Sub

#If NOLOGTODB = 0 Then
Sub AddTextToLogDB(ByVal md As DebType, ByVal str As String, dur As Double, ByVal logExp As Long, ByVal idvDateiID As Long)
    
    On Error GoTo nogo
    
    Dim conn As Object
    
    Set conn = GetConnection()
    If conn Is Nothing Then Exit Sub
    SetConnectTimeout conn

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT * FROM idvDateienEventLog WHERE EventTyp = -1", conn, MYadOpenDynamic, MYadLockOptimistic
    
    If rs Is Nothing Then
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If
    
    Do While Len(str) > 0
      rs.AddNew
      rs.Fields("EventTyp").Value = md
      rs.Fields("EventLogErlaeuterungID").Value = logExp
      rs.Fields("Datum").Value = Now
      rs.Fields("Text").Value = Left(str, 255)
      rs.Fields("Zeit").Value = dur
      rs.Fields("AppID").Value = MyAppID
      rs.Fields("idvDateiID").Value = idvDateiID
      rs.Fields("userLogonId").Value = Left(GetUserName, 24)
      rs.Update
      str = Mid(str, 255, 10000)
    Loop

nogo:
'    If Not rs Is Nothing Then
'      rs.Close
      Set rs = Nothing
'    End If
    
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If


End Sub
#End If

Sub DebugPrint(ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0, Optional logToECCSCanLog As Boolean = False)

    If L_InDebugPrint Then Exit Sub

    L_InDebugPrint = True
    
    If G_LogEnabled Then
      If G_cfgLogpfad = "" Then
        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), ThisWorkbook.Path & "\ECC-Log-" & GetUserName & ".txt"
      Else
        AddTextToFile Now() & "; " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\ECC-Log-" & GetUserName & ".txt"
      End If
    End If
    
    If StartedByTracker Then
      If logToECCSCanLog Then
        If G_cfgLogpfad <> "" Then
          If FileExists(G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt") Then
            AddTextToFile Now() & ",0, Typ: 7, ID: " & idvDateiID & "," & Chr(34) & str & Chr(34), G_cfgLogpfad & "\IDV-Suite Scheduler-" & GetUserName & ".txt"
          End If
        End If
      End If
    End If
    
'    If G_AllowLoggingToStorage Then
'        If md = 1 Or _
'            (md = 2 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 3 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'            (md = 4 And (G_cfgDebugInfosLoggen = True Or (G_PARAM_DebugInfosLoggen = True And G_LogThisUser = True))) Or _
'             md = 5 Or _
'             md = 6 Then
'
'            If md = DebType.tError Then
'                AddTextToLogDB md, "Err: " & str, dur, logExp, idvDateiID
'            Else
'                AddTextToLogDB md, str, dur, logExp, idvDateiID
'            End If
'        End If
'    End If
    

    L_InDebugPrint = False

End Sub


Public Function AddTextToLogfile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    If G_LogWriteIgnore = True Then Exit Function
    
    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

GoAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToLogfile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToLogfile = False
            G_LogWriteIgnore = True
            If Not G_IgnoreFutureWriteWindows Then
              If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & fullpath & "' gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & MyVersion) = vbYes Then
                G_LogToWindow = True
                ' frmLogWindow.Caption = ProgNameLong & " " & MyVersion & " - Log..."
                ' frmLogWindow.Show vbModeless
                G_IgnoreFutureWriteWindows = True
              End If
            End If
            Exit Function
          End If
        End If
      Loop
    Else
      G_LogWriteIgnore = True
    End If
    Exit Function

CatchEx:

End Function




Private Function FOpenAppend(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Append As fn
  FOpenAppend = True
  Exit Function
nogo:
        
End Function







Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Dimension"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_X As Long
Public m_Y As Long
Public m_XY As Long
Public m_Z As Long

Sub Check(ByRef x As Long, ByRef y As Long, ByRef z As Long, ByRef xy As Long)
  If x > m_X Then m_X = x
  If y > m_Y Then m_Y = y
  If xy > m_XY Then m_XY = xy
  If z > m_Z Then m_Z = z
End Sub
Attribute VB_Name = "DirSelect"
Option Explicit


#If VBA7 Then

        Public Type BROWSEINFO
           hOwner As LongPtr
           pidlRoot As Long
           pszDisplayName As String
           lpszTitle As String
           ulFlags As Long
           lpfn As Long
           lParam As Long
           iImage As Long
        End Type
        
        Declare PtrSafe Function SHGetPathFromIDList Lib "shell32.dll" _
           Alias "SHGetPathFromIDListA" (ByVal pidl As Long, _
           ByVal pszPath As String) As Long
        
        Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" _
           Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
#Else
        Public Type BROWSEINFO
           hOwner As Long
           pidlRoot As Long
           pszDisplayName As String
           lpszTitle As String
           ulFlags As Long
           lpfn As Long
           lParam As Long
           iImage As Long
        End Type
        
        Declare Function SHGetPathFromIDList Lib "shell32.dll" _
           Alias "SHGetPathFromIDListA" (ByVal pidl As Long, _
           ByVal pszPath As String) As Long
        
        Declare Function SHBrowseForFolder Lib "shell32.dll" _
           Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
#End If

Function GetDirectory(Optional Msg) As String
   Dim bInfo As BROWSEINFO
   Dim Path As String
   Dim r As Long, x As Long, pos As Integer
   bInfo.pidlRoot = 0&
   If IsMissing(Msg) Then
      bInfo.lpszTitle = Texte(GSprache, TXT_ORDNERW|fffd|HLEN)
   Else
      bInfo.lpszTitle = Msg
   End If
   bInfo.ulFlags = &H1
   x = SHBrowseForFolder(bInfo)
   Path = Space$(512)
   r = SHGetPathFromIDList(ByVal x, ByVal Path)
   If r Then
      pos = InStr(Path, Chr$(0))
      GetDirectory = Left(Path, pos - 1)
   Else
      GetDirectory = ""
   End If
End Function
Attribute VB_Name = "ECCFindenStuff"
Option Explicit

Dim wbName As String
Dim currentWS As String
Dim currentCellx As Long
Dim currentCelly As Long

Public theSearchtext As String


Public Sub ECCFinden()

  
  On Error GoTo raffIchNet
  Dim ws As Worksheet
  Dim c As Range
  currentWS = ""
  wbName = ActiveWorkbook.name
  
  Dim ccnt As Long
  Dim rotChar
  Dim lastTime
  lastTime = Now
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tcnt As Long
  tcnt = 0
  
  Dim i As Long
  For i = 1 To Worksheets.count
    If Worksheets(i).name = ActiveSheet.name Then
      Exit For
    End If
  Next i
  
  Dim startChecking As Boolean
  startChecking = False
  Dim endIndex As Long
  endIndex = i
  
'  For Each ws In ActiveWorkbook.Worksheets
  Do
    If startChecking = True And endIndex = i Then
      Exit Do
    End If
    Set ws = ActiveWorkbook.Worksheets(i)
    currentWS = ws.name
'    If ws.ProtectContents = True Then
'      If SheetHasPassword(ws) Then
        For Each c In ws.UsedRange
          currentCelly = c.Row
          currentCellx = c.Column
          If c.Interior.ColorIndex <> xlNone Or _
            c.Borders(xlDiagonalDown).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlDiagonalUp).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeLeft).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeRight).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeTop).LineStyle <> xlLineStyleNone Or _
            c.Borders(xlEdgeBottom).LineStyle <> xlLineStyleNone Or _
            c.Interior.Pattern <> xlPatternNone Then ' = 8 Or c.Interior.ColorIndex = 4 Or c.Interior.ColorIndex = 6 Then
            ws.Activate
            c.Activate
            Application.StatusBar = ""
            Exit Sub
          End If
          If tcnt > 100 Then
            tcnt = 0
            lastTime = Now
            Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
            ccnt = ccnt + 1
            If ccnt = 4 Then ccnt = 0
          End If
          tcnt = tcnt + 1
        Next c
'      End If
'    End If
    i = i + 1
    If i > Worksheets.count Then
      i = 1
    End If
    startChecking = True
  Loop
  MsgBox "Keine Zellen gefunden.", vbInformation, "Excel-Sheet-Checker"
  currentWS = ""
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  MsgBox "Es trat ein unvorhergesehener Fehler auf (ECCFinden): " & Err.Description, vbCritical, "Excel-Sheet-Checker"
  Application.StatusBar = ""

End Sub

Public Sub ECCWFinden()
  
  On Error GoTo raffIchNet

  Dim ws As Worksheet
  Dim c As Range
  Dim ccnt As Long
  Dim rotChar
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tcnt As Long
  tcnt = 0
  
  Dim r As Range
  
  Set ws = ActiveSheet
  Set r = Selection
  Dim Start As Boolean
  Start = True
  Dim endfind As Boolean
  endfind = False
  
  Do
    For Each c In ActiveSheet.UsedRange
      If endfind Then
        If c.Row >= r.Row Or (c.Row = r.Row And c.Column >= r.Column) Then
          MsgBox "Keine Zellen gefunden", vbInformation, "Excel-Sheet-Checker"
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      If Start Then
        If c.Row > r.Row Or (c.Column > r.Column And c.Row = r.Row) Then
          Start = False
        End If
      End If
      If Not Start Then
        If c.Interior.ColorIndex <> xlNone Or _
            (c.Borders(xlEdgeLeft).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeRight).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeTop).LineStyle <> xlLineStyleNone And _
            c.Borders(xlEdgeBottom).LineStyle <> xlLineStyleNone) _
              Then ' = 8 Or c.Interior.ColorIndex = 4 Or c.Interior.ColorIndex = 6 Then
          c.Activate
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      
      If tcnt > 100 Then
        tcnt = 0
        Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
        ccnt = ccnt + 1
        If ccnt = 4 Then ccnt = 0
      End If
      tcnt = tcnt + 1
    Next c
    
    ' Ok, das aktuelle Worksheet "erh|fffd|hen"
    Dim i As Long
    For i = 1 To Worksheets.count
      If Sheets(i).name = ActiveSheet.name Then
        i = i + 1
        If i > Worksheets.count Then i = 1
        Sheets(i).Activate
        If Sheets(i) Is ws Then
          endfind = True
        End If
        Exit For
      End If
    Next i
  Loop
  
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  MsgBox "Es trat ein unvorhergesehener Fehler auf (ECCWFinden): " & Err.Description, vbCritical, "Excel-Sheet-Checker"
  Application.StatusBar = ""
End Sub

Public Sub ECCTxtFinden()
  
  On Error GoTo raffIchNet

  Dim ws As Worksheet
  Dim c As Range
  Dim ccnt As Long
  Dim rotChar
  rotChar = Array("|", "/", "-", "\")
  ccnt = 0
  Dim tcnt As Long
  tcnt = 0
  
  Dim r As Range
  
  Set ws = ActiveSheet
  Set r = Selection
  Dim Start As Boolean
  Start = True
  Dim endfind As Boolean
  endfind = False
  
  Do
    For Each c In ActiveSheet.UsedRange
      If endfind Then
        If c.Row >= r.Row Or (c.Row = r.Row And c.Column >= r.Column) Then
          MsgBox "Keine Zellen gefunden", vbInformation, "Excel-Sheet-Checker"
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      If Start Then
        If c.Row > r.Row Or (c.Column > r.Column And c.Row = r.Row) Then
          Start = False
        End If
      End If
      If Not Start Then
        If InStr(c.Formula, theSearchtext) > 0 Then
          c.Activate
          Application.StatusBar = ""
          Exit Sub
        End If
      End If
      
      If tcnt > 100 Then
        tcnt = 0
        Application.StatusBar = "Bitte warten, Suche l|fffd|uft (Tabelle '" & ws.name & "'). " & rotChar(ccnt)
        ccnt = ccnt + 1
        If ccnt = 4 Then ccnt = 0
      End If
      tcnt = tcnt + 1
    Next c
    
    ' Ok, das aktuelle Worksheet "erh|fffd|hen"
    Dim i As Long
    For i = 1 To Worksheets.count
      If Sheets(i).name = ActiveSheet.name Then
        i = i + 1
        If i > Worksheets.count Then i = 1
        Sheets(i).Activate
        If Sheets(i) Is ws Then
          endfind = True
        End If
        Exit For
      End If
    Next i
  Loop
  
  Application.StatusBar = ""
  Exit Sub
raffIchNet:
  MsgBox "Es trat ein unvorhergesehener Fehler auf (ECCTxtFinden): " & Err.Description, vbCritical, "Excel-Sheet-Checker"
  Application.StatusBar = ""
End Sub



Attribute VB_Name = "FFuncs"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_Name As String
Public m_Count As Long
Public m_Used As Boolean
Attribute VB_Name = "FileStuff"
Option Explicit

'  Shell File Operations

Private Const FO_MOVE = &H1
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_RENAME = &H4
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_SILENT = &H4                      '  don't create progress/report
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_NOCONFIRMATION = &H10             '  Don't prompt the user.
Private Const FOF_WANTMAPPINGHANDLE = &H20          '  Fill in SHFILEOPSTRUCT.hNameMappings
                                      '  Must be freed using SHFreeNameMappings
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_FILESONLY = &H80                  '  on *.*, do only files
Private Const FOF_SIMPLEPROGRESS = &H100            '  means don't show names of files
Private Const FOF_NOCONFIRMMKDIR = &H200            '  don't confirm making any needed dirs


#If VBA7 Then

Private Type SHFILEOPSTRUCT
        hWnd As LongPtr
        wFunc As LongPtr
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As LongPtr
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type


Private Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#Else

Private Type SHFILEOPSTRUCT
        hWnd As Long
        wFunc As Long
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As Long
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type

Private Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#End If

Const OFN_READONLY           As Long = &H1
Const OFN_EXPLORER           As Long = &H80000
Const OFN_LONGNAMES          As Long = &H200000
Const OFN_CREATEPROMPT       As Long = &H2000
Const OFN_NODEREFERENCELINKS As Long = &H100000
Const OFN_OVERWRITEPROMPT    As Long = &H2
Const OFN_HIDEREADONLY       As Long = &H4
Const OFN_PATHMUSTEXIST      As Long = &H800
Const OFN_ENABLEHOOK As Long = &H20
Const OFN_ENABLESIZING As Long = &H800000

Public Const OFS_FILE_OPEN_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_CREATEPROMPT _
                                    Or OFN_NODEREFERENCELINKS
Public Const OFS_FILE_SAVE_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_OVERWRITEPROMPT _
                                    Or OFN_HIDEREADONLY
Public Const OFS_FILE_SAVE_FLAGS_NO_PROMPT    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_HIDEREADONLY




Type OPENFILENAME
    nStructSize     As Long
    hwndOwner       As Long
    hInstance       As Long
    sFilter         As String
    sCustomFilter   As String
    nCustFilterSize As Long
    nFilterIndex    As Long
    sFile           As String
    nFileSize       As Long
    sFileTitle      As String
    nTitleSize      As Long
    sInitDir        As String
    sDlgTitle       As String
    Flags           As Long
    nFileOffset     As Integer
    nFileExt        As Integer
    sDefFileExt     As String
    nCustData       As Long
    fnHook          As Long
    sTemplateName   As String
End Type

Public Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type

Public Const WM_INITDIALOG As Long = &H110
Private Const SW_SHOWNORMAL As Long = 1

#If VBA7 Then
    Private Declare PtrSafe Function GetParent Lib "user32" _
      (ByVal hWnd As Long) As Long
    Private Declare PtrSafe Function SetWindowText Lib "user32" _
       Alias "SetWindowTextA" _
      (ByVal hWnd As Long, _
       ByVal lpString As String) As Long
       
    Private Declare PtrSafe Function MoveWindow Lib "user32" _
      (ByVal hWnd As Long, _
       ByVal x As Long, _
       ByVal y As Long, _
       ByVal nWidth As Long, _
       ByVal nHeight As Long, _
       ByVal bRepaint As Long) As Long
       
    Private Declare PtrSafe Function GetWindowRect Lib "user32" _
      (ByVal hWnd As Long, _
       lpRect As RECT) As Long
       
    'defined As Any to support either the
    'OSVERSIONINFO or OSVERSIONINFOEX structure
    Private Declare PtrSafe Function GetVersionEx Lib "kernel32" _
       Alias "GetVersionExA" _
      (lpVersionInformation As Any) As Long
      
    Declare PtrSafe Function GetActiveWindow Lib "user32.dll" () As Long
    Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias _
        "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias _
        "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare PtrSafe Function GetShortPathName Lib "kernel32.dll" Alias _
        "GetShortPathNameA" (ByVal lpszLongPath As String, _
                             ByVal lpszShortPath As String, _
                             ByVal cchBuffer As Long) As Long

#Else
    Private Declare Function GetParent Lib "user32" _
      (ByVal hWnd As Long) As Long
    Private Declare Function SetWindowText Lib "user32" _
       Alias "SetWindowTextA" _
      (ByVal hWnd As Long, _
       ByVal lpString As String) As Long
       
    Private Declare Function MoveWindow Lib "user32" _
      (ByVal hWnd As Long, _
       ByVal x As Long, _
       ByVal y As Long, _
       ByVal nWidth As Long, _
       ByVal nHeight As Long, _
       ByVal bRepaint As Long) As Long
       
    Private Declare Function GetWindowRect Lib "user32" _
      (ByVal hWnd As Long, _
       lpRect As RECT) As Long
       
    'defined As Any to support either the
    'OSVERSIONINFO or OSVERSIONINFOEX structure
    Private Declare Function GetVersionEx Lib "kernel32" _
       Alias "GetVersionExA" _
      (lpVersionInformation As Any) As Long
      
    Declare Function GetActiveWindow Lib "user32.dll" () As Long
    Declare Function GetOpenFileName Lib "comdlg32.dll" Alias _
        "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare Function GetSaveFileName Lib "comdlg32.dll" Alias _
        "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare Function GetShortPathName Lib "kernel32.dll" Alias _
        "GetShortPathNameA" (ByVal lpszLongPath As String, _
                             ByVal lpszShortPath As String, _
                             ByVal cchBuffer As Long) As Long
#End If



Public Sub SyncCopy(Dateiname$, zielverzeichnis$)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

filenames = Dateiname + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        .fFlags = FOF_FILESONLY + FOF_NOCONFIRMATION + FOF_NOCONFIRMMKDIR + FOF_SILENT
End With

SHFileOperation shellinfo

End Sub

' Dateioperationen

Public Sub CopyFile(Dateiname$, zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

On Error Resume Next
  Dim arr(1) As String
  arr(0) = Dateiname
  
  CopyPlus arr, zielverzeichnis, inklusiveUnterverzeichnisse

End Sub

Public Sub CopyPlus(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Sub

Public Function Move(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function

Public Function Delete(dateinamen$(), Optional inklusiveUnterverzeichnisse)
Dim filenames$
Dim i As Integer
Dim shellinfo As SHFILEOPSTRUCT

For i = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(i) + Chr(0)
Next i
filenames = filenames + Chr(0)

With shellinfo
        .hWnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_DELETE
        .pFrom = filenames
        .pTo = "" + Chr(0)
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function



Attribute VB_Name = "Func"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Public name As String
Public Trans As String
Public Desc As String
Public Head As Func
Public count As Long
Public SumCount As Long

Attribute VB_Name = "Globals"
Option Explicit

Public Const MyVersion As String = "Version 4.5b"
Public Const MyProgramReleaseDate As Date = #1/6/2015#
Public Const MyInternalVersion As Long = 24
Public Const progNameShort As String = "ECC"
Public Const ProgNameLong As String = "Excel-Sheet-Checker"
Public Const MyProgramLicenseVersion As Long = 1
Public Const MyAppID = 4

' Diese Version wird in der IDV-Suite verwendet, um mit dem "richtigen" ECC zu Scannen. Version 0 ist der "Ur-ECC". Dier Versionsnummer
' |fffd|ndert sich nur, wenn sich auch der Checksummenalogrithmus |fffd|ndert.
Public Const MyECCVersion As Long = 0

Public Const C_LeakTest As Boolean = False

Public trsLngSelect As String
Public G_ECCPro As Boolean

Public G_Schnellanalyse As Boolean

Public xlsDateien As Collection
Public inaccessablePaths As Collection
Public Funcs As Collection
Public FuncArray
Public TotalUsedBytes As Long
Public TotalUsedFiles As Long
Public TotalUnusedBytes As Long
Public TotalUnusedFiles As Long
Public TotalUnusedBytesOlder As Long
Public TotalUnusedFilesOlder As Long
Public TotalUnusedBytesSmaller As Long
Public TotalUnusedFilesSmaller As Long
Public TotalUnusedBytesDouble As Long
Public TotalUnusedFilesDouble As Long
Public TotalFilesTested As Long

Private AmountScanned As Long
Public StartedByTracker  As Boolean
Public StartedByDaemon  As Boolean
Public theTrackerShowStatusform  As Boolean
Public theTrackerFreigabe As Boolean
Public theTrackerFreigabeDatum As Date
Public theTrackerFormelnExtrahieren  As Double
Public theTrackerFachrisiko As Double

Public NextTime As Date


Public G_InternetVersion As String
Public G_InternetAvailable As Boolean
Public G_InternetInternalVersion As Long
Public G_InternetLicenseVersion As Long
Public G_UpdateAvailable As Boolean
Public G_UpdateString As String
Public G_MyLicencseVersion As Long
Public G_Wartung As Boolean
Public G_WartungBis As Date

Public G_UpdateText As String
Public G_Lizenzen As Long
Public G_FullDemoBis As Date

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String

Public G_Passworte As Collection

Public G_RiskTabs As Collection ' RiskTab
Public G_RiskContains As Collection ' RiskVal
Public G_WhiteList As Collection ' RiskVal

Public G_UserStartedProgram As Boolean

Public Const C_RISK_TYPE_ECC As Long = 1
Public Const C_RISK_TYPE_FORMULA_CONTAINS As Long = 2
Public Const C_RISK_TYPE_NOT_IN_WHITE_LIST As Long = 3
Public Const C_RISK_TYPE_WHITE_LIST As Long = 4

Public Const C_RISK_COMP_TYPE_LESS As Long = 1
Public Const C_RISK_COMP_TYPE_LESSEQUAL As Long = 2
Public Const C_RISK_COMP_TYPE_EQUAL As Long = 3
Public Const C_RISK_COMP_TYPE_LARGEREQUAL As Long = 4
Public Const C_RISK_COMP_TYPE_LARGER As Long = 5


Public G_RiskLow As Double
Public G_RiskMed As Double
Public G_RiskLowCol As Long
Public G_RiskMedCol As Long
Public G_RiskHighCol As Long
Public G_ColorCells As Boolean

Public G_CheckDimension As Boolean
Public G_CheckInputs As Boolean

Public TransToLocal As Collection
Public TransToE As Collection

Public G_conn As Object

Public Const MYadOpenDynamic As Long = 2
Public Const MYadLockPessimistic As Long = 2
Public Const MYadLockOptimistic As Long = 3
Public Const MYadLockReadOnly As Long = 1

Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgKeypfad As String
Public G_cfgPasswortpfad As String

Public G_StartScan As Date
Public G_EndScan As Date
Public G_SchedulerTimeCheckIgnore As Boolean
'Public G_ECCNoDimension As Boolean

Public G_ModulmenueDeaktivieren As Boolean

Public G_Cursorlocation As Long

Public G_DBConnectionString As String


Public Sub ECCCreateHeaderAndFooter(ws As Worksheet)
    On Error Resume Next
    ' Datum der Generierung in die Fu|fffd|zeile eintragen
    With ws.PageSetup
        Dim usr As String
        usr = Environ("USERNAME")
        If Len(usr) Then
            .LeftFooter = Texte(GSprache, TXT_GENERIERTAM) & Now() & " von " & usr
        Else
            .LeftFooter = Texte(GSprache, TXT_GENERIERTAM) & Now()
        End If
        .RightHeader = "&7" & ProgNameLong & " " & MyVersion & vbLf & MainMenu.Cop & " Norman Neubert / stromwerken"
        If Len(trsShrt) > 0 Then
          .LeftHeader = "&7 " & trsShrt
        Else
          .LeftHeader = "&7Demoversion - Einsatz nur zu Testzwecken"
        End If
    End With

End Sub

Function GenerateSheet(outputSheetName As String, Optional oldWorkbookName As String = "") As String
    
    Dim myFilename As String
    Dim i As Long
    If Len(oldWorkbookName) = 0 Then
        Workbooks.Add
        myFilename = ActiveWorkbook.name
    Else
        myFilename = oldWorkbookName
    End If
    Application.DisplayAlerts = False
    If Len(oldWorkbookName) = 0 Then
        For i = ActiveWorkbook.Sheets.count To 2 Step -1
          ActiveWorkbook.Sheets(i).Delete
        Next i
        ActiveWorkbook.Sheets(i).name = "LeeresBlatt"
        ThisWorkbook.Sheets(outputSheetName & "Leer").Activate
        ThisWorkbook.Sheets(outputSheetName & "Leer").Copy Workbooks(myFilename).Sheets(1)
        ActiveWorkbook.Sheets(outputSheetName & "Leer").name = outputSheetName
        ActiveWorkbook.Sheets("LeeresBlatt").Delete
    Else
'        ActiveWorkbook.Sheets.Add after:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count)
        ThisWorkbook.Sheets(outputSheetName & "Leer").Copy After:=Workbooks(myFilename).Sheets(Workbooks(myFilename).Sheets.count)
        Workbooks(myFilename).Sheets(outputSheetName & "Leer").name = outputSheetName
    End If
    
    Application.DisplayAlerts = True

    Globals.ECCCreateHeaderAndFooter ActiveSheet
    GenerateSheet = myFilename
End Function

Function SheetHasPassword(oXLWsheet)
    SheetHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oXLWsheet.Unprotect "12%%XXy<11!A"
    SheetHasPassword = False
password_notok:
End Function

Function WorkbookHasPassword(oxlwbook)
    WorkbookHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwbook.Unprotect "12%%XXy<11!A"
    WorkbookHasPassword = False
password_notok:
End Function

Public Function StringAdd(stringlist, txt As String) As Boolean
    StringAdd = False
    Dim item
    For Each item In stringlist
        If item = txt Then Exit Function
    Next item
    StringAdd = True
    stringlist.Add txt
End Function

Function CheckVBAAccessAllowed() As Boolean
  CheckVBAAccessAllowed = True
  On Error GoTo noVBA
  If ThisWorkbook.VBProject.Protection = 1 Then ' vbext_pp_locked
  End If
  Exit Function
noVBA:
  CheckVBAAccessAllowed = False
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.Formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function

Function TranslateFuncToLocal(s As String) As String
  On Error GoTo noTrans
  TranslateFuncToLocal = TransToLocal(s)
  Exit Function
noTrans:
  TranslateFuncToLocal = s
End Function
Function TranslateFuncToE(s As String) As String
  On Error GoTo noTrans
  TranslateFuncToE = TransToE(s)
  Exit Function
noTrans:
  TranslateFuncToE = s
End Function


Sub FreeAllMem()
'  ActiveSheet.UsedRange
  Set TransToLocal = Nothing
  Set TransToE = Nothing
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  Set Funcs = Nothing
  Set FuncArray = Nothing
End Sub

Function FilenameDoesntExistAbove(Pfad As String, name As String) As Boolean
  Dim item As ScanFile
  Dim pos As Long
  FilenameDoesntExistAbove = True
  If Len(Pfad) <= 1 Then Exit Function
  pos = Len(Pfad)
  pos = pos - 1
  Do
    pos = InStrMyRev(Pfad, "\", pos)
    If pos < 0 Then Exit Do
    For Each item In xlsDateien
      If Left(Pfad, pos) & name = item.m_Name Then
        FilenameDoesntExistAbove = False
        Exit Function
      End If
    Next item
    pos = pos - 1
  Loop While pos > 0
End Function

Sub ScanDirs(Pfad As String, nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean, infoLabel, Optional firstscan As Boolean = True)

'   .MousePointer = fmMousePointerHourGlass
'  Me.MousePointer = fmMousePointerDefault

  If firstscan Then AmountScanned = 0

  Dim name As String
  Dim Verzeichnisse As New Collection
  ' Erst mal alle Verzeichnisse holen!
  On Error GoTo inaccessablePath
  name = Dir(Pfad & "\*.*", vbDirectory) ' Ersten Eintrag abrufen.
'    On Error GoTo 0

  Dim cnt As Long
  cnt = 0

  On Error Resume Next
    Do While name <> ""    ' Schleife beginnen.
    
        If PathSelect.WasOK = False Then Exit Do
    
        
        ' Aktuelles und |fffd|bergeordnetes Verzeichnis ignorieren.
        If name <> "." And name <> ".." Then
            ' Mit bit-weisem Vergleich sicherstellen, da|fffd| name ein
            ' Verzeichnis ist.
            Err.Number = 0
            If (GetAttr(Pfad & "\" & name) And vbDirectory) = vbDirectory Then
                If Err.Number = 0 Then Verzeichnisse.Add Pfad & "\" & name  ' Eintrag nur anzeigen, wenn es sich
            Else
                TotalFilesTested = TotalFilesTested + 1
                
                If TotalFilesTested Mod 20 = 0 Then
                   infoLabel.Caption = "    " & TotalFilesTested & " gepr|fffd|ft, " & AmountScanned & " Dateien bisher gefunden..."
                   DoEvents
                End If
                ' Ansonsten ist es eine Datei! Wenn es ein Excel-Sheet ist, dann wird
                ' es in die xlsDateien - Collection mitaufgenommen
                
                If UCase(name) Like "*.XL?" Or UCase(name) Like "*.XL??" Then
                    ' Nicht die eigene Datei!!!!!
                    If ThisWorkbook.FullName <> Pfad & "\" & name Then
                      Dim used As Boolean
                      used = False
                      ' Wenn die Dateikriterien passen
                      If FileLen(Pfad & "\" & name) >= nichtkleinerals * 1024 Then
                        Dim FD As Date
                        FD = Format(FileDateTime(Pfad & "\" & name), "Short Date")
                        If Format(DateAdd("m", -nichtaelterals, Now()), "Short Date") <= FD Then
                          If gleichenamenignorieren = True Then
                            If FilenameDoesntExistAbove(Pfad, name) Then
                              AmountScanned = AmountScanned + 1
                              If Not unterverzeichnisseIgnorieren Then
                                infoLabel.Caption = "    " & TotalFilesTested & " gepr|fffd|ft, " & AmountScanned & " Dateien bisher gefunden..."
                                DoEvents
                              End If
                              
                              Debug.Print Pfad & "\" & name
                              Dim sf As ScanFile
                              Set sf = New ScanFile
                              sf.m_Name = Pfad & "\" & name
                              sf.m_OEID = 0
                              sf.m_idvDateiID = 0
                              xlsDateien.Add sf
                              used = True
                            Else
                              TotalUnusedBytesDouble = TotalUnusedBytesDouble + FileLen(Pfad & "\" & name)
                              TotalUnusedFilesDouble = TotalUnusedFilesDouble + 1
                            End If
                          Else
                            AmountScanned = AmountScanned + 1
                            Debug.Print Pfad & "\" & name
                            Set sf = New ScanFile
                            sf.m_Name = Pfad & "\" & name
                            sf.m_OEID = 0
                            sf.m_idvDateiID = 0
                            xlsDateien.Add sf
                            If Not unterverzeichnisseIgnorieren Then
                              infoLabel.Caption = "    " & TotalFilesTested & " gepr|fffd|ft, " & AmountScanned & " Dateien bisher gefunden..."
                              DoEvents
                            End If
                            used = True
                          End If
                        Else
                          TotalUnusedBytesOlder = TotalUnusedBytesOlder + FileLen(Pfad & "\" & name)
                          TotalUnusedFilesOlder = TotalUnusedFilesOlder + 1
                        End If
                      Else
                        TotalUnusedBytesSmaller = TotalUnusedBytesSmaller + FileLen(Pfad & "\" & name)
                        TotalUnusedFilesSmaller = TotalUnusedFilesSmaller + 1
                      End If
                      If Not used Then
                        TotalUnusedBytes = TotalUnusedBytes + FileLen(Pfad & "\" & name)
                        TotalUnusedFiles = TotalUnusedFiles + 1
                      Else
                        TotalUsedBytes = TotalUsedBytes + FileLen(Pfad & "\" & name)
                        TotalUsedFiles = TotalUsedFiles + 1
                      End If
                    End If
                End If
            End If
        End If
        name = Dir ' N|fffd|chsten Eintrag abrufen.
    Loop
    
    Dim item
    Dim tstring As String
    If Not unterverzeichnisseIgnorieren Then
      For Each item In Verzeichnisse
          tstring = item
          ScanDirs tstring, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren, infoLabel, False
      Next item
    End If
    
    Set Verzeichnisse = Nothing

    Exit Sub
    
inaccessablePath:
    inaccessablePaths.Add Pfad

End Sub


Sub SaveMAKriterienSettings()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="NichtAelterAls", _
     setting:=PathSelect.selMonate
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="NichtKleinerAls", _
     setting:=PathSelect.selKB
  
  If PathSelect.selGleicheNamenIgnorieren Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="GleicheNamenIgnorieren", _
       setting:=1
  Else
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="GleicheNamenIgnorieren", _
       setting:=0
  End If
  
  If PathSelect.selUnterverzeichnisseIgnorieren Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="UnterverzeichnisseIgnorieren", _
       setting:=1
  Else
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="UnterverzeichnisseIgnorieren", _
       setting:=0
  End If
  
End Sub

Function GetKriterien(Pfad As String, nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean, infoLabel)
  Set xlsDateien = New Collection
  Set inaccessablePaths = New Collection
  
  TotalUsedBytes = 0
  TotalUsedFiles = 0
  TotalUnusedBytes = 0
  TotalUnusedFiles = 0
  TotalUnusedBytesOlder = 0
  TotalUnusedFilesOlder = 0
  TotalUnusedBytesSmaller = 0
  TotalUnusedFilesSmaller = 0
  TotalUnusedBytesDouble = 0
  TotalUnusedFilesDouble = 0

  TotalFilesTested = 0
  ScanDirs Pfad, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren, infoLabel
  
  If GSprache = 1 Then
    GetKriterien = "Im Verzeichnis '" & Pfad & "' werden " & TotalUsedFiles & " Datei(en) mit " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb gescannt." & vbCrLf & vbCrLf & _
      "Insgesamt werden " & TotalUnusedFiles & " Datei(en) mit " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb ignoriert." & vbCrLf & _
      "-  " & TotalUnusedFilesSmaller & " Datei(en) mit " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gr|fffd||fffd|e'," & vbCrLf & _
      "-  " & TotalUnusedFilesOlder & " Datei(en) mit " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Monate'," & vbCrLf & _
      "-  " & TotalUnusedFilesDouble & " Datei(en) mit " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gleiche Namen'"
  Else
    GetKriterien = TotalUsedFiles & " file(s) in '" & Pfad & "' with " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb will be scanned." & vbCrLf & vbCrLf & _
      TotalUnusedFiles & " file(s) with " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb will be ignored." & vbCrLf & _
      "-  " & TotalUnusedFilesSmaller & " file(s) with " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb because of limitation 'size'," & vbCrLf & _
      "-  " & TotalUnusedFilesOlder & " file(s) with " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb because of limitation 'months'," & vbCrLf & _
      "-  " & TotalUnusedFilesDouble & " file(s) with " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb because of limitation 'same names'"
  End If
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing

End Function


Function RemoveCommentsAndLineFeeds(ByVal txt As String) As String
  Dim i As Long
  Dim nutxt As String
  For i = 1 To Len(txt)
    If Mid(txt, i, 1) = Chr(34) Then
      nutxt = nutxt + Mid(txt, i, 1)
      i = i + 1
      While Mid(txt, i, 1) <> Chr(34)
        nutxt = nutxt + Mid(txt, i, 1)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    ElseIf Mid(txt, i, 1) = "'" Then
      While Mid(txt, i, 1) <> Chr(10) And Mid(txt, i, 1) <> Chr(13) And i < Len(txt)
        i = i + 1
      Wend
      nutxt = nutxt + Mid(txt, i, 1)
    ElseIf Mid(txt, i, 1) <> vbCr And Mid(txt, i, 1) <> vbLf Then
      nutxt = nutxt + Mid(txt, i, 1)
    End If
  Next i
  RemoveCommentsAndLineFeeds = nutxt
End Function


Function GetRiskValues() As Boolean
  GetRiskValues = False
  Dim wb As Excel.Workbook
  Dim rs
  
  If Not StartedByTracker Then
    If Not GetExcelFile(ThisWorkbook.Path & "\Excel-Sheet-Checker Risk.xls", wb) Then
      MsgBox "Die Risikodatei '" & ThisWorkbook.Path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      Exit Function
    End If
    
    If Not WorksheetExists(wb, "Regeln") Then
      MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.Path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      Exit Function
    End If
    
    If Not WorksheetExists(wb, "Risiken") Then
      MsgBox "Es existiert keine Tabelle mit dem Namen 'Risiken' in der Datei '" & ThisWorkbook.Path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      Exit Function
    End If
    
    If Not WorksheetExists(wb, "Gesamtrisiko") Then
      MsgBox "Es existiert keine Tabelle mit dem Namen 'Gesamtrisiko' in der Datei '" & ThisWorkbook.Path & "\Excel-Sheet-Checker Risk.xls' fehlt. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
      Exit Function
    End If
    
    
    With wb.Sheets("Gesamtrisiko")
      
      G_RiskLow = .Cells(2, 2)
      G_RiskMed = .Cells(3, 2)
      G_RiskLowCol = .Cells(2, 3).Interior.Color
      G_RiskMedCol = .Cells(3, 3).Interior.Color
      G_RiskHighCol = .Cells(4, 3).Interior.Color
    
    End With
  Else
      If G_conn Is Nothing Then Exit Function
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ECCRisikoGesamt", G_conn, 2, 1
      If rs.EOF Then
        MsgBox "Es sind keine GesamtRisikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      G_RiskLow = rs.Fields("Gering").Value
      G_RiskMed = rs.Fields("Mittel").Value
      G_RiskLowCol = rs.Fields("GeringFarbe").Value
      G_RiskMedCol = rs.Fields("MittelFarbe").Value
      G_RiskHighCol = rs.Fields("HochFarbe").Value
      
      rs.Close
      Set rs = Nothing
  End If
  
  Set G_RiskTabs = New Collection
  Set G_RiskContains = New Collection
  Set G_WhiteList = New Collection
  
  
  If Not StartedByTracker Then
    Dim y As Long
    y = 2
    Dim rt As RiskTab
    With wb.Worksheets("Risiken")
      Do While Not IsEmpty(.Cells(y, 1))
      
        Set rt = New RiskTab
        If Not rt.Init(wb, y) Then Exit Function
        G_RiskTabs.Add rt, .Cells(y, 1)
        y = y + 1
      Loop
    End With
    wb.Close False
    Set wb = Nothing
  
  
  Else
      
      
      
      Set rs = CreateObject("ADODB.recordset")
      rs.Open "SELECT * FROM ECCRisiken", G_conn, 2, 1
      If rs.EOF Then
        MsgBox "Es sind keine Risikodaten in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
        rs.Close
        Set rs = Nothing
        Exit Function
      End If
      
      
      Do While Not rs.EOF
      
        Set rt = New RiskTab
        If Not rt.InitDB(G_conn, rs) Then Exit Function
        G_RiskTabs.Add rt, rs.Fields("Risiko").Value
        rs.movenext
      Loop
      
      rs.Close
      Set rs = Nothing
  End If
  
  GetRiskValues = True
End Function

Public Sub ResetRisks()
    Dim rtitem As RiskTab
    Dim rvitem As RiskVal
    For Each rtitem In G_RiskTabs
        For Each rvitem In rtitem.m_Vals
            rvitem.m_Hit = False
            rvitem.m_Matches = 0
            rvitem.m_FirstMatch = ""
            rvitem.m_FirstMatchAddress = ""
        Next rvitem
    Next rtitem
    
    For Each rvitem In G_RiskContains
        rvitem.m_Hit = False
        rvitem.m_Matches = 0
        rvitem.m_FirstMatch = ""
        rvitem.m_FirstMatchAddress = ""
    Next rvitem
    
    For Each rvitem In G_WhiteList
        rvitem.m_Hit = False
        rvitem.m_Matches = 0
        rvitem.m_FirstMatch = ""
        rvitem.m_FirstMatchAddress = ""
    Next rvitem
    

End Sub

Public Function CollectionItemExists(c As Collection, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(c(name))
  CollectionItemExists = True
  Exit Function
  
notReadable:
  CollectionItemExists = False
End Function


Attribute VB_Name = "Hash"
Option Explicit

Private Const BITS_TO_A_BYTE = 8
Private Const BYTES_TO_A_WORD = 4
Private Const BITS_TO_A_WORD = 32

Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long

Public Function GetComputerName() As String
'Returns the computername
    Dim lngLen As Long, lngX As Long
    Dim strCompName As String
    lngLen = 16
    strCompName = String$(lngLen, 0)
    lngX = apiGetComputerName(strCompName, lngLen)
    If lngX <> 0 Then
        GetComputerName = Left$(strCompName, lngLen)
    Else
        GetComputerName = ""
    End If
End Function

Function GetDocProp(wb As Excel.Workbook, txt As String) As String
  On Error Resume Next
  GetDocProp = ""
  GetDocProp = wb.BuiltinDocumentProperties(txt)
End Function

Function GetFileHash(ByVal uncpathfname As String) As String

    If Left(uncpathfname, 1) = "\" Or Left(uncpathfname, 1) = "/" Then
        GetFileHash = SHA256(uncpathfname)
'        GetFileHash = SHA256(uncpathfname & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    Else
        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName)
'        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    End If

End Function



Private Function LShift(lValue, iShiftBits)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

Dim m_l2Power
m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)


    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
    End If
End Function



Private Function RShift(lValue, iShiftBits)

  Dim m_l2Power
  m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)

    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function



Private Function AddUnsigned(lX, lY)
    Dim lX4, lY4, lX8, lY8, lResult
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function



Private Function Ch(x, y, z)
    Ch = ((x And y) Xor ((Not x) And z))
End Function



Private Function Maj(x, y, z)
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function



Private Function s(x, n)
Dim m_lOnBits, m_l2Power, K
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)

    s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function



Private Function r(x, n)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

    r = RShift(x, CLng(n And m_lOnBits(4)))
End Function



Private Function Sigma0(x)
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function



Private Function Sigma1(x)
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function



Private Function Gamma0(x)
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor r(x, 3))
End Function



Private Function Gamma1(x)
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor r(x, 10))
End Function



Private Function ConvertToWordArray(sMessage)
    Dim lMessageLength, lNumberOfWords, lWordArray(), lBytePosition, lByteCount
    Dim lWordCount, lByte
    
    Const MODULUS_BITS = 512
    Const CONGRUENT_BITS = 448
    
    lMessageLength = Len(sMessage)
    
    lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)

    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function



Public Function SHA256(sMessage)

Dim K
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)
    Dim Hash, M, w(63), a, b, c, d, e, f, g, h, i, j, t1, t2
    
    Hash = Array(&H6A09E667, &HBB67AE85, &H3C6EF372, &HA54FF53A, &H510E527F, &H9B05688C, &H1F83D9AB, &H5BE0CD19)
    
    M = ConvertToWordArray(sMessage)
    
    For i = 0 To UBound(M) Step 16
        a = Hash(0)
        b = Hash(1)
        c = Hash(2)
        d = Hash(3)
        e = Hash(4)
        f = Hash(5)
        g = Hash(6)
        h = Hash(7)
        
        For j = 0 To 63
            If j < 16 Then
                w(j) = M(j + i)
            Else
                w(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(j - 2)), w(j - 7)), Gamma0(w(j - 15))), w(j - 16))
            End If
                
            t1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), Ch(e, f, g)), K(j)), w(j))
            t2 = AddUnsigned(Sigma0(a), Maj(a, b, c))
            
            h = g
            g = f
            f = e
            e = AddUnsigned(d, t1)
            d = c
            c = b
            b = a
            a = AddUnsigned(t1, t2)
        Next
        
        Hash(0) = AddUnsigned(a, Hash(0))
        Hash(1) = AddUnsigned(b, Hash(1))
        Hash(2) = AddUnsigned(c, Hash(2))
        Hash(3) = AddUnsigned(d, Hash(3))
        Hash(4) = AddUnsigned(e, Hash(4))
        Hash(5) = AddUnsigned(f, Hash(5))
        Hash(6) = AddUnsigned(g, Hash(6))
        Hash(7) = AddUnsigned(h, Hash(7))
    Next
    
    SHA256 = LCase(Right("00000000" & Hex(Hash(0)), 8) & Right("00000000" & Hex(Hash(1)), 8) & Right("00000000" & Hex(Hash(2)), 8) & Right("00000000" & Hex(Hash(3)), 8) & Right("00000000" & Hex(Hash(4)), 8) & Right("00000000" & Hex(Hash(5)), 8) & Right("00000000" & Hex(Hash(6)), 8) & Right("00000000" & Hex(Hash(7)), 8))
End Function


Attribute VB_Name = "Helpers"
Option Explicit

'In ein Modul mit Namen "myLaufwerke"
#If VBA7 Then
Declare PtrSafe Function GetLogicalDrives& Lib "kernel32" ()
Private Declare PtrSafe Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare PtrSafe Function GetShortPathName Lib "kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

#Else
Declare Function GetLogicalDrives& Lib "kernel32" ()
Private Declare Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare Function GetShortPathName Lib "kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

#End If
    
    
Private Const DRIVE_CDROM = 5
Private Const DRIVE_FIXED = 3
Private Const DRIVE_RAMDISK = 6
Private Const DRIVE_REMOTE = 4
Private Const DRIVE_REMOVABLE = 2

Const NoError = 0       'The Function call was successful

Public G_LogEnabled As Boolean
Public G_Break As Boolean

   ' Declare for call to mpr.dll.

Function GetMachineName() As String
  'Returns the computername
  Dim lngLen As Long, lngX As Long
  Dim strCompName As String
  
  lngLen = 16
  strCompName = String$(lngLen, 0)
  lngX = apiGetComputerName(strCompName, lngLen)
  If lngX <> 0 Then
      GetMachineName = Left$(strCompName, lngLen)
  Else
      GetMachineName = ""
  End If
End Function


Function GetUserName() As String

   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else

      ' An error occurred.
'         MsgBox "Unable to get the name."
      lpUserName = "Unbekannt"
   End If

   ' Display the name of the person logged on to the machine.
'      MsgBox "The person logged on this machine is: " & lpUserName

    GetUserName = lpUserName

End Function


Private Sub LaufwerktypAnzeigen(a As String)
Dim Meldung As String
Select Case GetDriveType(a & ":\")
    Case DRIVE_CDROM
        Meldung = "CDROM"
    Case DRIVE_FIXED
        Meldung = "Festplatte"
    Case DRIVE_RAMDISK
        Meldung = "RAMDISK"
    Case DRIVE_REMOTE
        Meldung = "Netzlaufwerk"
    Case DRIVE_REMOVABLE
        Meldung = "Diskette"
End Select
MsgBox "Laufwerk = " & a & vbCrLf & "Typ = " & Meldung
End Sub


Public Sub PopupAnzeigen()
    Application.CommandBars("Laufwerk").ShowPopup
End Sub

Function GetWorksheet(wbName As String, sheetname As String, ByRef Beenden As Boolean) As Worksheet
    Dim objApp As Object
    On Error Resume Next
    Set objApp = GetObject(wbName)
    
    Dim ws As Worksheet
    Set ws = objApp.Sheets(sheetname)
    
    If objApp Is Nothing Or ws Is Nothing Then
      Beenden = True
      Exit Function
    End If
    
    Set GetWorksheet = ws
End Function

Function RemoveStrings(ByVal txt As String, remstr As String, remstr2 As String) As String
  Dim pos As Long
  Dim pos2 As Long
  Do
    pos = InStr(txt, remstr)
    If pos <= 0 Then Exit Do
    pos2 = InStr(pos + 1, txt, remstr2)
    If pos2 <= 0 Then Exit Do
    Dim tstr As String
    tstr = ""
    If pos > 1 Then tstr = Left(txt, pos - 1)
    If pos2 < Len(txt) Then tstr = tstr & Mid(txt, pos2 + 1)
    txt = tstr
  Loop
  RemoveStrings = txt
End Function


Function FormulaLocalOK(c As Range) As Boolean
  On Error GoTo notOK
  Dim s As String
  s = c.FormulaLocal
  FormulaLocalOK = True
  Exit Function
notOK:
  FormulaLocalOK = False
End Function

Function GetNextText(s As String, ByRef pos As Long) As String
  If Len(s) > 0 And pos > 0 Then
    Dim lastpos As Long
    lastpos = pos
      
    pos = InStr(pos, s, ",")
    If pos > 0 Then
      
      GetNextText = Trim(Mid(s, lastpos, pos - lastpos))
      pos = pos + 1
      Exit Function
    ElseIf lastpos < Len(s) Then
      GetNextText = Trim(Mid(s, lastpos))
      pos = -1
      Exit Function
    Else
      pos = -1
      GetNextText = ""
      Exit Function
    End If
  Else
    pos = -1
    GetNextText = ""
    Exit Function
  End If

End Function

Function CommentExists(ByRef c As Range) As Boolean
  Dim s As String
  On Error GoTo doesntExist
  s = c.Comment.Text
  CommentExists = True
  Exit Function
doesntExist:
End Function

Function GetRangeCount(ByRef rng) As Double
  On Error Resume Next
  
  GetRangeCount = CDbl(rng.count)
  If Err.Number <> 0 Then
    Err.Clear
    GetRangeCount = CDbl(rng.Countlarge)
  End If
  
End Function

Public Function AnwendungFuerDatei(ByVal a_Datei As String) As String
  'Datei: Pfad + Dateinamen einer existierenden Datei
  Dim Pfad As String * 255
  
  Call FindExecutable(a_Datei, vbNullString, Pfad)
  
  If "" <> Trim(Pfad) Then
     Pfad = Trim(Left(Pfad, InStr(Pfad, vbNullChar) - 1))
  End If
  AnwendungFuerDatei = Trim(Pfad)
End Function

Sub StartDatei(Filename As String)
   Dim s2 As String, s3 As String, n As Long
   
   s2 = AnwendungFuerDatei(Filename)
   If "" <> s2 Then
      s3 = Chr(34) & ShortFileName(s2) & Chr(34) & " /r " & Chr(34) & ShortFileName(Filename) & Chr(34)
      If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="TrackerShowStatusform", default:="True") = "True" Then
        n = Shell(s3, vbNormalFocus)
      Else
        n = Shell(s3, vbHide)
      End If
   Else
      MsgBox "Anwendungprogramm f|fffd|r " & Filename & " nicht gefunden/installiert!"
   End If
End Sub

Sub OpenFileWithApp(fname As String)
  If FileExists(fname) Then
    Dim s2 As String, s3 As String, n As Long
    
    s2 = AnwendungFuerDatei(fname)
    If "" <> s2 Then
       s3 = Chr(34) & ShortFileName(s2) & Chr(34) & " " & Chr(34) & ShortFileName(fname) & Chr(34)
       n = Shell(s3, vbNormalFocus)
    Else
       MsgBox "Anwendungprogramm f|fffd|r " & fname & " nicht gefunden/installiert!"
    End If
  Else
    MsgBox "Datei '" & fname & "' nicht vorhanden.", vbCritical
  End If
End Sub

Sub ClearLog()
  On Error Resume Next
  If G_cfgLogpfad = "" Then
    Kill ThisWorkbook.Path & "\ECC-Log" & GetUserName & ".txt"
  Else
    Kill G_cfgTemppfad & "\ECC-Log" & GetUserName & ".txt"
  End If
End Sub

Sub SetFileStatusInfo(nfo As String)
    Dim s As String
    s = GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo")
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="FileStatusInfo", setting:= _
      IIf(s <> "", s & vbCrLf, "") & nfo
End Sub

Sub LogPrintECCSCanLog(ByVal id As Long, ByVal status As Long, ByVal str As String)
  If StartedByTracker Then
    DebugPrint tsystem, "ECC" & MyECCVersion & " - " & str, 0, 0, id, True
    SetFileStatusInfo str
    If status > 0 Then
      SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanResult" & status, setting:=GetSetting(appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanResult" & status, default:=0) + 1
    End If
  End If
End Sub

Sub LogPrint(ByVal str As String)
  DebugPrint tInfo, str
End Sub
Function MyOpenFile(ByVal fullpath As String, ByVal fn As Long)
    On Error GoTo nogo:
    Open fullpath For Append As fn
    MyOpenFile = True
    Exit Function
nogo:
    MyOpenFile = False
End Function

Public Function AddTextToFile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    Dim fn As Long
    fn = FreeFile
    Dim s As String
    
    Dim i As Long
    i = 0

    While i < 5


      If MyOpenFile(fullpath, fn) Then
    Print #fn, strData
    Close fn

    AddTextToFile = True
    Exit Function
      End If
    i = i + 1
      Sleep 10
    Wend
    AddTextToFile = False
    Exit Function
End Function

Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim endPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              endPos = InStr(pos2 + 1, d, " ")
              If endPos <= 0 Then endPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, endPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function


Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim s As String
  If cfgpath = "" Then s = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Then
    s = cfgpath
  Else
    s = ThisWorkbook.Path & "\" & cfgpath
  End If
  
  If Not PathExists(s) Then
    MkFullDir s
    If Not PathExists(s) Then
'      If Not StartedByTracker Then
'        MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical
'      Else
        AddStatus "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden."
'      End If
    End If
  End If
  
  GetRelativePath = s
End Function

' Return the short file name for a long file name.
Public Function ShortFileName(ByVal long_name As String) As _
    String
Dim Length As Long
Dim short_name As String

    short_name = Space$(1024)
    Length = GetShortPathName( _
        long_name, short_name, _
        Len(short_name))
    ShortFileName = Left$(short_name, Length)
End Function
 
 
 
' To convert from short to long file names, break the short name into directory pieces. Use Dir$ to get the long name for each piece.
Public Function LongFileName(ByVal short_name As String) As _
    String
Dim pos As Integer
Dim Result As String
Dim long_name As String

    ' Start after the drive letter if any.
    If Mid$(short_name, 2, 1) = ":" Then
        Result = Left$(short_name, 2)
        pos = 3
    Else
        Result = ""
        pos = 1
    End If

    ' Consider each section in the file name.
    Do While pos > 0
        ' Find the next \.
        pos = InStr(pos + 1, short_name, "\")

        ' Get the next piece of the path.
        If pos = 0 Then
            long_name = Dir$(short_name, vbNormal + _
                vbHidden + vbSystem + vbDirectory)
            If long_name = "" Then
              pos = InStrRev(short_name, "\")
              If pos > 0 Then
                long_name = Mid(short_name, pos + 1)
                pos = 0
              End If
            End If
        Else
            long_name = Dir$(Left$(short_name, pos - 1), _
                vbNormal + vbHidden + vbSystem + _
                vbDirectory)
        End If
        Result = Result & "\" & long_name
    Loop

    LongFileName = Result
End Function


Function IsFullyNumeric(v As String) As Boolean
  Dim l As Long
  l = Len(v)
  If l = 0 Then Exit Function
  Dim i As Long
  For i = 1 To l
    If (Mid(v, i, 1) < "0" Or Mid(v, i, 1) > "9") And Mid(v, i, 1) <> "." Then Exit For
  Next i
  If i > l Then IsFullyNumeric = True
End Function

' Wenn d zwischen t1 und t2 liegt true, ansonsten false
' t1 und t2 sind immer die Stunden eines Tages. Wenn t2 kleiner t1 ist, dann wird |fffd|ber Mitternacht gerechnet
Function TimeInScope(d As Date, t1 As Date, t2 As Date) As Boolean
  ' Erst mal die Tagesiformationen loswerden
  t1 = GetTime(t1)
  t2 = GetTime(t2)
  d = GetTime(d)

  TimeInScope = False

  ' Z.B. zwischen 08:00:00 und 09:00:00
  If t1 < t2 Then
      If t1 <= d And d <= t2 Then
          TimeInScope = True
      End If
  Else
      If d >= t1 Or d <= t2 Then
          TimeInScope = True
      End If
  End If
End Function

Function GetTime(d As Date) As Date
  On Error Resume Next
  GetTime = CDate("00:00:00")
  GetTime = TimeValue(d)
End Function

Sub MyKill(fname As String)
  On Error Resume Next
  Kill fname
End Sub

Function GetPath(ByVal p As String) As String
  If InStrRev(p, "\") > 0 Then
    GetPath = Left(p, InStrRev(p, "\") - 1)
    Exit Function
  End If
  GetPath = p
End Function

Function GetTempPath() As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    GetTempPath = Trim(Left(pathbuffer, l))
  End If
End Function


Attribute VB_Name = "HighResTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare PtrSafe Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare PtrSafe Function timeGetTime Lib "winmm.dll" () As Long

#Else

Private Declare Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare Function timeGetTime Lib "winmm.dll" () As Long

#End If



Enum TimeState
    started
    Stopped
End Enum


Private startTime, endTime As Long
Private dur As Double
Private state As Currency
Private m_TimeCol As Collection
Private m_TimeName As Collection
Private m_TotalTimeCol As Collection

Private m_LastCount As String

Private Sub Class_Initialize()
Static started As Boolean
    If started Then
      MsgBox "HighResTimer already started!"
      Exit Sub
    End If
    started = True
    state = TimeState.Stopped
    DoStart

    StartCounting "TotalCount"

End Sub

Private Sub Class_Terminate()
    DoStop
    Set m_TimeCol = Nothing
    Set m_TotalTimeCol = Nothing
    Set m_TimeName = Nothing
    
End Sub

Public Sub StartCounting(s As String)
  
  If m_LastCount <> "" Then
    Dim d As Double
    d = m_TotalTimeCol(m_LastCount) + CDbl(timeGetTime() - m_TimeCol(m_LastCount))
    m_TotalTimeCol.Remove m_LastCount
    m_TotalTimeCol.Add d, m_LastCount
  End If
  
  
  If CollectionItemExists(m_TimeCol, s) Then
    m_TimeCol.Remove s
  End If
  m_TimeCol.Add timeGetTime(), s
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    m_TotalTimeCol.Add 0#, s
  End If
  If Not CollectionItemExists(m_TimeName, s) Then
    m_TimeName.Add s, s
  End If
End Sub
Public Sub StopCounting(s As String)
  If Not CollectionItemExists(m_TimeCol, s) Then
    MsgBox "No count for: " & s
    Exit Sub
  End If

  Dim d As Double
  d = m_TotalTimeCol(s) + CDbl(timeGetTime() - m_TimeCol(s))
  m_TotalTimeCol.Remove s
  m_TotalTimeCol.Add d, s
  
  
  m_LastCount = s & " - After"
  
  If CollectionItemExists(m_TimeCol, m_LastCount) Then
    m_TimeCol.Remove m_LastCount
  End If
  m_TimeCol.Add timeGetTime(), m_LastCount
  If Not CollectionItemExists(m_TotalTimeCol, m_LastCount) Then
    m_TotalTimeCol.Add 0#, m_LastCount
  End If
  If Not CollectionItemExists(m_TimeName, m_LastCount) Then
    m_TimeName.Add m_LastCount, m_LastCount
  End If
  
  

End Sub

Function GetCount(s As String) As Double
  If Not CollectionItemExists(m_TotalTimeCol, s) Then
    MsgBox "No count for: " & s
    Exit Function
  End If
  
  GetCount = m_TotalTimeCol(s) / 1000
End Function


Private Sub DoStart()
    If state = TimeState.started Then
        MsgBox "Cant' start, already started", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        Exit Sub
    End If
    state = TimeState.started
    startTime = timeGetTime()
    Set m_TimeCol = New Collection
    Set m_TotalTimeCol = New Collection
    Set m_TimeName = New Collection
End Sub

Private Function DoStop() As Double
    endTime = timeGetTime()
    If state = TimeState.Stopped Then
        MsgBox "Cant' start, already started", vbCritical + vbSystemModal, ProgNameLong & " " & MyVersion
        Exit Function
    End If
    state = TimeState.Stopped
    dur = CDbl((endTime - startTime) / 1000)
    DoStop = dur
End Function


Public Sub Dump()
  Dim s As String
  Dim i As Long
  Dim ts As String
  
  StopCounting "TotalCount"
  ts = ""
  
  Dim tot As Double
  tot = GetCount("TotalCount")
  
  Dim checked As Double
  checked = 0
  
  If m_TimeName.count > 0 Then
    For i = 1 To m_TimeName.count
      s = m_TimeName(i)
      ts = ts & s & ":" & IIf(Len(s) < 8, vbTab, "") & IIf(Len(s) < 16, vbTab, "") & IIf(Len(s) < 22, vbTab, "") & IIf(Len(s) < 30, vbTab, "") & vbTab & Format(GetCount(s), "000.00") & " Sec" & vbTab & Format(GetCount(s) / tot, "00.0%") & vbCrLf
      Debug.Print s & ": " & GetCount(s) & " Sec - " & Format(GetCount(s) / tot, "0.0%")
      checked = checked + GetCount(s)
    Next i
  End If
  
  ts = ts & vbCrLf & "Checked: " & Format((checked - tot) / tot, "0.0%")
 
  MyKill ThisWorkbook.Path & "\ECC-Profile.txt"
  AddTextToFile ts, ThisWorkbook.Path & "\ECC-Profile.txt"
  
End Sub
Attribute VB_Name = "INetCheckVersion"
Option Explicit

'Declares for direct ping
#If VBA7 Then
    Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
    Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
    Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
    Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
        (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
        lNumberOfBytesRead As Long) As Integer
    Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
        (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#Else
    Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
    Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
    Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
    Private Declare Function InternetReadFile Lib "wininet.dll" _
        (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
        lNumberOfBytesRead As Long) As Integer
    Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
        (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
#End If

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Dim hInet As Long
Dim hUrl As Long
Dim Flags As Long
Dim url As Variant


Public Function CheckINetConnection() As Boolean
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerke.de", vbNullString, 0, Flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Public Sub CheckVersion(checkEveryDays As Long, sec As String, fname As String, fname2 As String, currentVersion As String, internalCurrentVersion As Long)

On Error GoTo exitfunc

  G_InternetVersion = "Nicht verbunden"
  G_InternetAvailable = False
  G_UpdateAvailable = False

  Dim d As Date
 
  SaveSetting _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="VersionDate", _
     setting:=Now
     
     
  Dim ret As String
  Dim ret2 As String
  
     
  If LoadInetFile(fname, ret) = True And LoadInetFile(fname2, G_UpdateText) = True Then
  
        G_InternetVersion = GetLine(ret)
        If Left(G_InternetVersion, 2) = "<!" Then
          G_InternetAvailable = False
          G_InternetVersion = "Nicht verf|fffd|gbar"
          Exit Sub
        Else
        
          G_InternetInternalVersion = CLng(GetLine(ret))
          G_UpdateString = GetLine(ret)
          G_InternetLicenseVersion = CLng(GetLine(ret))
          
          G_InternetAvailable = True
            
          If internalCurrentVersion < G_InternetInternalVersion Then
          
            G_UpdateAvailable = True
            
            d = GetSetting( _
               appname:="Stromwerken", _
               Section:=sec, _
               Key:="VersionDate", default:=DateSerial(2000, 1, 1))
            
            If DateAdd("d", checkEveryDays, d) <= Now Then
              CheckInternetUpdateMenu
            End If
            
          End If
        End If
  End If
  Exit Sub

exitfunc:
  Exit Sub
  
End Sub

Function DoThat(t As String) As String

    Dim i As Long
    Dim s2 As String
    For i = 1 To Len(t)
        If Mid(t, i, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, i, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, i, 1) >= "0" And Mid(t, i, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "a" And Mid(t, i, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, i, 1)))
        ElseIf Mid(t, i, 1) >= "A" And Mid(t, i, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, i, 1)))
        Else
            s2 = s2 + Mid(t, i, 1)
        End If
    Next i
    
    DoThat = s2
End Function



Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Then
    Open G_cfgKeypfad & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(ThisWorkbook.Path & "\..\swres.swk") Then
    Open ThisWorkbook.Path & "\..\swres.swk" For Binary Access Read As #ff ' Len = 4
  Else
    Exit Function
  End If
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC3 - LZW
  ElseIf l = 2 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    Dim lval As Long
    Dim arr() As Long
    ReDim arr(l)
    
    For charc = 1 To l
      Get #ff, pos + 4 + charc * 4, lval
      arr(charc - 1) = lval
    Next charc
    Close ff
    
    Dim LZW As New LZW
    res = LZW.DecompressArray(l, arr)
    Set LZW = Nothing
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function

Sub GetData()
  On Error GoTo noData
  
  G_Lizenzen = -3
  G_ECCPro = False
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Or FileExists(ThisWorkbook.Path & "\..\swres.swk") Then
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    s = GetSWResItem(1000, ff)
    If InStr(s, "ECC,") > 0 Or InStr(s, "ECCPRO,") > 0 Then
    
      If InStr(s, "ECCPRO,") > 0 Then
        G_ECCPro = True
      End If
    
      G_Lizenznehmer = GetSWResItem(2000, ff)
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = Val(GetSWResItem(3000, ff))
      G_Lizenzen = Val(GetSWResItem(3100, ff))
      
      
'      s = GetSWResItem(3200, ff)
      s = ConvGermanDate(GetSWResItem(3200, ff))
      Dim hadFullDemoDate As Boolean
      If Len(s) > 0 Then
        If IsDate(s) Then
          If CDate(s) > #1/1/1900# Then
            G_FullDemoBis = CDate(s)
            hadFullDemoDate = True
          End If
        End If
      End If
      G_Wartung = IIf(UCase(GetSWResItem(3300, ff)) = "JA", True, False)
      
      If G_Wartung Then
        ' s = GetSWResItem(3400, ff)
        s = ConvGermanDate(GetSWResItem(3400, ff))
        If Len(s) > 0 Then
          If IsDate(s) Then
            G_WartungBis = CDate(s)
          End If
        End If
      End If
      
      FullVersion = True
      
      If G_Lizenzen = -1 Then
        trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trsShrt = "Full-Demo " & G_Lizenznehmer & " - Einsatz nur zu Testzwecken!"
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trsShrt = "Full-Demo bis zum " & G_FullDemoBis & " - " & G_Lizenznehmer
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trsShrt = "Demoversion " & G_Lizenznehmer
      ElseIf G_Lizenzen = -2 Then
        trs = "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trsShrt = "Gesamthauslizenz " & G_Lizenznehmer
      ElseIf G_Lizenzen = 1 Then
        trs = G_Lizenzen & " Lizenz" & IIf(hadFullDemoDate = True, " bis " & G_FullDemoBis, "") & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trsShrt = G_Lizenzen & "Lizenz " & G_Lizenznehmer
      Else
        trs = G_Lizenzen & " Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trsShrt = G_Lizenzen & "Lizenzen " & G_Lizenznehmer
      End If
      
      If G_Wartung Then
        trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", ""), "")
      End If
      
    End If
  End If
  
  
noData:
  Exit Sub
End Sub


Sub CheckInternetUpdateMenu()


  If G_MyLicencseVersion < G_InternetLicenseVersion And FullVersion = True Then
    INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Kostenpflichtig.Caption = "Die neue Version ist kostenpflichtig. Bitte wenden Sie sich an info@stromwerken.de, um eine Update-Lizenz zu erwerben. Ohne neuen Lizenz-Key l|fffd|uft das Programm als DEMO!"
  Else
    INetUpdate.Headline.Caption = "Im Internet liegt eine neue Version des Programms vor."
    INetUpdate.Kostenpflichtig.Caption = ""
  End If
  
  INetUpdate.UpdateText = G_UpdateText
  
  INetUpdate.Show
End Sub



Public Function LoadInetFile(fname As String, ByRef ret As String, Optional fsize As Long = 0) As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  LoadInetFile = False
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de/" & fname, vbNullString, 0, Flags, 0)
    If hUrl Then
        
        Dim sReadBuf As String * 1024
        Dim flagMoreData As Boolean
        Dim bytesRead As Long
        Dim wRet As Integer
        Dim lastErr As Long
        Dim s As String
        
        flagMoreData = True
        Do While flagMoreData
            sReadBuf = vbNullString
            wRet = InternetReadFile(hUrl, sReadBuf, Len(sReadBuf), bytesRead)
            If Err.LastDllError <> 0 Then
                lastErr = Err.LastDllError
                ret = "Error (wininet.dll," & lastErr & ")"
                GoTo exitfunc
            End If
            If wRet <> 1 Then
                ret = "Error"
                GoTo exitfunc
            End If
            s = s & Left$(sReadBuf, bytesRead)
            If Not CBool(bytesRead) Then flagMoreData = False
        Loop
        ret = s
        
        Call InternetCloseHandle(hUrl)
        Call InternetCloseHandle(hInet)
        LoadInetFile = True
        Exit Function
    Else
      Call InternetCloseHandle(hInet)
    End If
  End If
  Exit Function

exitfunc:
    If hUrl <> 0 Then InternetCloseHandle (hUrl)
    If hInet <> 0 Then InternetCloseHandle (hInet)
End Function



Attribute VB_Name = "INetUpdate"
Attribute VB_Base = "0{418075CE-FAB0-45A9-8C92-28203A322EAB}{93BD77BF-944B-44FD-8899-74E1A357F9E8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdAbbrechen_Click()
  Me.Hide
End Sub

Private Sub cmdDownload_Click()
  Me.Hide
  On Error Resume Next
  Call Shell("explorer.exe " & G_UpdateString, 1)
  ThisWorkbook.Close False
End Sub
Attribute VB_Name = "LForItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Prefix As String
Public m_Val As String
Public m_X As Long
Public m_Y As Long
Attribute VB_Name = "LZW"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'Private Data Members
Private flgFirstTime As Boolean
Private arr() As String
Private m_CharacterBytesCount As Integer


'Properties
Public Property Get CharacterBytesCount() As Integer
    CharacterBytesCount = m_CharacterBytesCount
End Property

Public Property Let CharacterBytesCount(ByVal vNewValue As Integer)
    m_CharacterBytesCount = vNewValue
End Property

'Private Methods
Private Function Add(ByVal Entry As String) As Long

   If flgFirstTime Then
        flgFirstTime = False
    Else
        ReDim Preserve arr(UBound(arr) + 1)
    End If
    
    arr(UBound(arr)) = Entry
    'Arr(UBound(Arr)).Code = ubund(
    
    Add = UBound(arr)
    
End Function

Private Function IsExists(ByVal Entry As String) As Boolean
    Dim i As Long
    Dim flg As Boolean
    flg = False
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            flg = True
            Exit For
        End If
    Next i
    
    IsExists = flg
    
End Function

Private Function IsIndexExists(ByVal Index As Long) As Boolean
    
    Dim flg As Boolean
    flg = False
    
    If Index <= UBound(arr) Then
        flg = True
    Else
        flg = False
    End If
    
    IsIndexExists = flg
    
End Function

Private Function GetValue(ByVal Index As Long) As String
    If IsIndexExists(Index) Then
        GetValue = arr(Index)
    Else
        GetValue = ""
    End If
End Function

Private Function GetIndexOf(ByVal Entry As String) As Long
    
    Dim i As Long
    Dim ReturnCode As Long
    ReturnCode = -1
    
    For i = LBound(arr) To UBound(arr)
        If arr(i) = Entry Then
            ReturnCode = i
            Exit For
        End If
    Next i
    
    GetIndexOf = ReturnCode
    
End Function

Private Sub Class_Initialize()
    ReDim arr(0) As String
    flgFirstTime = True
    m_CharacterBytesCount = 2
End Sub

Private Function mrtLeft(ByVal InputString As String, ByVal Length As Long) As String
    If Len(InputString) >= Length Then
        mrtLeft = Left(InputString, Length)
    Else
        mrtLeft = InputString
    End If
End Function

Private Sub InitializeDictionary()
    Dim i As Long
    For i = 0 To (2 ^ (m_CharacterBytesCount * 8)) - 1
        Add (ChrW(i))
    Next
End Sub

Private Function Length() As Long
    Length = UBound(arr)
End Function

'Public methods
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function Compress(ByVal UncompressedData As String, ByRef valam As Long, ByRef arr() As Long) As String

    Dim w As String
    Dim c As String
    Dim wc As String
    'Dim dic As New Dictionary
    Dim Output As String
    Dim code As Long
    
    Dim i As Long
    InitializeDictionary
    valam = 0
    
    ReDim arr(1024)
    Dim curarrsize As Long
    curarrsize = 1024
     
    w = ""
    For i = 1 To Len(UncompressedData)
        
        c = Mid(UncompressedData, i, 1)
        wc = w + c
        If IsExists(wc) Then
            w = wc
        Else
            code = Add(wc)
            code = GetIndexOf(w)
            Output = Output & IIf(Output = "", "", ",") & code
            arr(valam) = code
            valam = valam + 1
            If valam > curarrsize Then
              curarrsize = curarrsize + 1024
              ReDim Preserve arr(curarrsize)
            End If
            w = c
        End If
        
        '?
    
    Next i
    
    Output = Output & IIf(Output = "", "", ",") & GetIndexOf(w)
    arr(valam) = GetIndexOf(w)
    valam = valam + 1
    
    Compress = Output

End Function


Public Function DecompressArray(valam As Long, arr() As Long) As String
  Dim compresseddata As String
  Dim i As Long
  For i = 0 To valam - 1
    compresseddata = compresseddata & IIf(compresseddata = "", "", ",") & arr(i)
  Next i
  DecompressArray = Decompress(compresseddata)
End Function

Public Function Decompress(ByVal compresseddata As String) As String
    
    If compresseddata = "" Then Exit Function
    
    'Dim dic As New Dictionary
    
    InitializeDictionary

    Dim Output As String
    Dim Entry As String

    Dim K As String
    Dim w As String
    Dim i As Long
    
    Dim arrCompressedData() As String
    ListSplit arrCompressedData, compresseddata, "," '  arrCompressedData = Split(compresseddata, ",")
    
    K = arrCompressedData(0)
    Output = Output & GetValue(K)
    w = K
    
    For i = 1 To UBound(arrCompressedData)
    
        K = arrCompressedData(i)
        
        If IsIndexExists(K) Then
        
            Entry = GetValue(K)
            
        ElseIf IsIndexExists(K) = False And K = Length + 1 Then
            
            Entry = GetValue(w) + mrtLeft(GetValue(w), 1)
            
        Else
        
            MsgBox "Bad compressed."
            
        End If
        
        Output = Output + Entry
        
        Add (GetValue(w) + mrtLeft(Entry, 1))
        
        w = GetIndexOf(Entry)
        
    Next
    
    Decompress = Output
    
End Function


 Function ListSplit(ArrayReturn() As String, ByVal StringToSplit As String, _
 SplitAt As String) As Integer
   Dim intInstr As Integer
   Dim intCount As Integer
   Dim strTemp As String

   intCount = -1
   intInstr = InStr(StringToSplit, SplitAt)
   Do While intInstr > 0
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = Left(StringToSplit, intInstr - 1)
     StringToSplit = Mid(StringToSplit, intInstr + 1)
     intInstr = InStr(StringToSplit, SplitAt)
   Loop
   If Len(StringToSplit) > 0 Then
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = StringToSplit
   End If
   ListSplit = intCount
 End Function




Attribute VB_Name = "Libs"
Option Explicit

Function InitSWLib(enginename As String) As Boolean
  InitSWLib = False
  
  Dim item
  For Each item In ActiveWorkbook.VBProject.References
    If item.name = enginename Then
      ExitSWLib enginename
      Exit For
    End If
  Next item
  
'  On Error GoTo couldntInit
  If FileExists(ThisWorkbook.Path & "\" & enginename & ".xla") Then
    ThisWorkbook.VBProject.References.AddFromFile ThisWorkbook.Path & "\" & enginename & ".xla"
'    Application.VBE.ActiveVBProject.References.AddFromFile ThisWorkbook.Path & "\" & enginename & ".xla"
    InitSWLib = True
  ElseIf FileExists("d:\development\excel97\" & enginename & "\" & enginename & ".xls") Then
    ThisWorkbook.VBProject.References.AddFromFile "d:\development\excel97\" & enginename & "\" & enginename & ".xls"
'    Application.VBE.ActiveVBProject.References.AddFromFile "d:\development\excel97\" & enginename & "\" & enginename & ".xls"
    InitSWLib = True
  End If
  Exit Function
couldntInit:
End Function

Sub ExitSWLib(enginename As String)
  On Error Resume Next
  ThisWorkbook.VBProject.References.Remove ThisWorkbook.VBProject.References(enginename)
  Exit Sub
End Sub


Attribute VB_Name = "MLastCells"
Option Explicit

Private LastCells As Collection
Public Sub InitLastCells()
  Set LastCells = New Collection
End Sub
Public Sub ExitLastCells()
  Set LastCells = Nothing
End Sub

Function GetLastCell(c As Range)
  If ObjectNameExists(LastCells, c.Parent.Parent.Path & "|" & c.Parent.name & "|" & c.Address) Then
    Set GetLastCell = LastCells(c.Parent.Parent.Path & "|" & c.Parent.name & "|" & c.Address)
    Exit Function
  End If
  
  ' Jetzt erst durch jede Zeile durch, um zu schauen, ob da was ist.
  Dim y As Long
  Dim x As Long
  Dim r As Range
  SetLiveStatusFunc "SpecialCells", True
  Set r = c.SpecialCells(xlCellTypeLastCell)
  SetLiveStatusFunc "SpecialCells", False
  SetLiveStatus
  
  
  Dim found As Boolean
  
  If r.Row > c.Row Then
    For y = r.Row To c.Row + 1 Step -1
      found = False
      For x = r.Column To c.Column Step -1
        If Not IsEmpty(c.Parent.Cells(y, x)) Then
          found = True
          Exit For
        End If
      Next x
      If found Then Exit For
      Set r = c.Parent.Cells(y - 1, r.Column)
    Next y
  End If
  
  Set GetLastCell = r
  LastCells.Add r, c.Parent.Parent.Path & "|" & c.Parent.name & "|" & c.Address

End Function
Attribute VB_Name = "MainMenu"
Attribute VB_Base = "0{B0DE7E92-4048-41BA-9F7C-3436D9558096}{8865185F-98DD-4CB3-B182-22C29CD1C129}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Const StartEnums As Long = 30
Const ChecksumMod As Long = &H100000
Const Tabellen|fffd|bersichtY As Long = 6
Const StartMassenanalyseY As Long = 11

Const ProgWidth As Long = 528
Const ProgWidth2 As Long = 96

Public VBAFailure As Long


Private Sub cmdSprache_Click()
  Sprache.MyInit
  Sprache.Show
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="Sprache", _
     setting:=GSprache
  TexteInit
End Sub

Private Sub cmdUpdate_Click()
  
  CheckInternetUpdateMenu

End Sub

Private Sub HelpButton_Click()
  OpenFileWithApp ThisWorkbook.Path & "\Excel-Sheet-Checker.pdf"
  
End Sub

Private Sub Label16_Click()
  On Error Resume Next
  Call Shell("explorer.exe http://www.stromwerken.de", 1)
End Sub


Private Sub Analyse_Click()
  
  Me.Hide
  
  EinzelanalyseStarten

End Sub

 
Private Sub cmdMassenanalyseFortsetzen_Click()

  Me.Hide
  
  MassenanalyseFortsetzen

End Sub

Private Sub ProgrammBeenden_Click()
  On Error Resume Next
'    ThisWorkbook.Close
  MainMenu.Hide
End Sub




Private Sub Massenanalyse_Click()

  Me.Hide
  
  MassenanalyseStarten
    
End Sub
  

Attribute VB_Name = "MemStuff"
Option Explicit

#If VBA7 Then
  Private Declare PtrSafe Sub GlobalMemoryStatus Lib "kernel32" ( _
      lpBuffer As MEMORYSTATUS)
#Else
  Private Declare Sub GlobalMemoryStatus Lib "kernel32" ( _
      lpBuffer As MEMORYSTATUS)
#End If

Private Type MEMORYSTATUS
    dwLength As Long
    dwMemoryLoad As Long
    dwTotalPhys As Long
    dwAvailPhys As Long
    dwTotalPageFile As Long
    dwAvailPageFile As Long
    dwTotalVirtual As Long
    dwAvailVirtual As Long
End Type



Function GetFreeMem() As Long
  Dim SpeicherInfos As MEMORYSTATUS
  GlobalMemoryStatus SpeicherInfos
  GetFreeMem = SpeicherInfos.dwAvailPhys
End Function


Attribute VB_Name = "PW"
Option Explicit


Function GetFilePassword(ByVal fname As String, ByVal pwtyp As Long) As String
  Dim conn
  Set conn = GetConnection()
  If conn Is Nothing Then Exit Function
  
  Dim rs
  Set rs = CreateObject("ADODB.recordset")
  
  Dim hsh As String
  Dim uncfname As String
  uncfname = UCase(GetUNCPath(fname))
  hsh = GetFileHash(uncfname)
  
  rs.Open "SELECT Hash, Dateiname, Passwort, Tabname FROM idvDateien INNER JOIN idvDateienPW ON idvDateien.idvDateiID = idvDateienPW.idvDateiID WHERE Hash = '" & hsh & "' AND PWTyp =" & pwtyp, conn, 2, 1
  Do While rs.EOF = False
    If UCase(rs.Fields("Dateiname").Value) = uncfname Then
      GetFilePassword = Crypt(rs.Fields("Passwort").Value, "T0)7/hJy+\1TrcpI?", False)
      Exit Do
    End If
  Loop
  rs.Close
  Set rs = Nothing
  conn.Close
  Set conn = Nothing

End Function




Attribute VB_Name = "ParamAsk"
Attribute VB_Base = "0{FFF22983-FAC3-4850-978B-C3D3B3F5D274}{3B7AFAB2-A368-44A8-9587-8D9447BF11E2}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
 
Private Sub cmdOK_Click()
  Me.Hide
End Sub
Attribute VB_Name = "PathSelect"
Attribute VB_Base = "0{F4358A84-4B0E-4FD1-8A09-D9B2347CF00C}{F11F6EF8-73D1-4AEF-B0FD-A2CF59B89D62}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private InUpdate As Boolean
Public WasOK As Boolean

Public Sub MyInit()

  selMonate = Val(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="NichtAelterAls", default:="48"))
  
  selKB = Val(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="NichtKleinerAls", default:="0"))
  
  selGleicheNamenIgnorieren = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="GleicheNamenIgnorieren", default:=True) = "1"
  
  selUnterverzeichnisseIgnorieren = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="UnterverzeichnisseIgnorieren", default:=False) = "1"

  WasOK = False

  GefundeneMengen = "" ' GetKriterien(SelektierterPfad, SelMonate, SelKB, selgleichenamenignorieren, selunterverzeichnisseIgnorieren, GefundeneMengen)

  Verzeichnisse.Clear

  On Error GoTo nofile
  
  
  Dim fn As Long
  fn = FreeFile
  Dim s As String
  Open G_cfgTemppfad & "\ECCMaPaths.txt" For Input As fn
  If Not EOF(fn) Then
    Input #fn, s
    Verzeichnisse.addItem s
  End If
  Close fn
  
  Exit Sub
nofile:

End Sub


Function GetRelevantFiles(nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean, infoLabel)
  Set xlsDateien = New Collection
  Set inaccessablePaths = New Collection
  
  TotalUsedBytes = 0
  TotalUsedFiles = 0
  TotalUnusedBytes = 0
  TotalUnusedFiles = 0
  TotalUnusedBytesOlder = 0
  TotalUnusedFilesOlder = 0
  TotalUnusedBytesSmaller = 0
  TotalUnusedFilesSmaller = 0
  TotalUnusedBytesDouble = 0
  TotalUnusedFilesDouble = 0

  TotalFilesTested = 0

  Dim i As Long
  If Verzeichnisse.ListCount >= 1 Then
    For i = 0 To Verzeichnisse.ListCount - 1
      Dim p As String
      p = Verzeichnisse.Column(0, i)
      If Right(p, 1) = "\" Then
        p = Left(p, Len(p) - 1)
      End If
      ScanDirs p, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren, infoLabel
    Next i
  End If

End Function




Private Sub cmdAbbruch_Click()
  WasOK = False
  Me.Hide
End Sub


Private Sub cmdAdd_Click()
  Dim s As String
  s = GetDirectory("Pfad w|fffd|hlen...")
  If Len(s) > 0 Then
    Verzeichnisse.Clear
    Verzeichnisse.addItem s
  End If
End Sub

Private Sub cmdOK_Click()

  G_Schnellanalyse = True

  If IsNull(selMonate) Then
    MsgBox "Bitte geben Sie einen Wert >= 1 f|fffd|r 'Nicht |fffd|lter als X Monate' ein!", vbInformation
    Exit Sub
  ElseIf Not IsNumeric(selMonate) Then
    MsgBox "Bitte geben Sie einen numerischen Wert f|fffd|r 'Nicht |fffd|lter als X Monate' ein!", vbInformation
    Exit Sub
  ElseIf Val(selMonate) < 1 Then
    MsgBox "Bitte geben Sie einen Wert >= 1 f|fffd|r 'Nicht |fffd|lter als X Monate' ein!", vbInformation
    Exit Sub
  End If

  If IsNull(selKB) Then
    MsgBox "Bitte geben Sie einen Wert >= 0 f|fffd|r 'Nicht kleiner als X Kb' ein!", vbInformation
    Exit Sub
  ElseIf Not IsNumeric(selKB) Then
    MsgBox "Bitte geben Sie einen numerischen Wert f|fffd|r 'Nicht kleiner als X Kb' ein!", vbInformation
    Exit Sub
  ElseIf Val(selKB) < 0 Then
    MsgBox "Bitte geben Sie einen Wert >= 0 f|fffd|r 'Nicht kleiner als X Kb' ein!", vbInformation
    Exit Sub
  End If

  WasOK = True
  G_CheckDimension = CheckDimensions.Value

  PathSelect.selGleicheNamenIgnorieren = selGleicheNamenIgnorieren
  PathSelect.selUnterverzeichnisseIgnorieren = selUnterverzeichnisseIgnorieren
  
  
  SaveMAKriterienSettings
  
  SaveMAPath
  
  GetRelevantFiles Val(PathSelect.selMonate), Val(PathSelect.selKB), PathSelect.selGleicheNamenIgnorieren, PathSelect.selUnterverzeichnisseIgnorieren, GefundeneMengen

  
'  fn = FreeFile
'  Open g_cfgTemppfad & "\ECCMaFiles.txt" For Output As fn
  
'  Dim item
'  If xlsDateien.Count > 0 Then
'    For Each item In xlsDateien
'      If UCase(item) <> UCase(ThisWorkbook.FullName) Then
'        Write #fn, item
'      End If
'    Next item
'  End If
  
'  Close fn
  
  
  
  Me.Hide
End Sub

Sub SaveMAPath()

On Error GoTo nogo
  Dim fn As Long
  fn = FreeFile
  Dim s As String
  Open G_cfgTemppfad & "\ECCMaPaths.txt" For Output As fn
  Dim i As Long
  If Verzeichnisse.ListCount >= 1 Then
    For i = 0 To Verzeichnisse.ListCount - 1
      Write #fn, Verzeichnisse.Column(0, i)
    Next i
  End If
  Close fn
  Exit Sub
  
nogo:
  MsgBox "Auf die Datei '" & G_cfgTemppfad & "\ECCMaPaths.txt' konnte nicht schreibend zugegriffen werden (" & Err.Description & "). In dieser Datei wird der selektierte Pfad gespeichert. Erlauben Sie bitte nach M|fffd|glichkeit auf die Datei den schreibenden Zugriff. Die Analyse wird nat|fffd|rlich trotzdem durchgef|fffd|hrt.", vbExclamation
End Sub

Private Sub cmdOK2_Click()
  cmdOK_Click
  G_Schnellanalyse = False
End Sub

Private Sub MengenBerechnen_Click()
  
  WasOK = True
  
  Dim naa As Long
  naa = 10000
  Dim nka As Long
  nka = 0

  If Not IsNull(selMonate) Then
    If IsNumeric(selMonate) Then
      naa = selMonate
    End If
  End If
  If Not IsNull(selKB) Then
    If IsNumeric(selKB) Then
      nka = selKB
    End If
  End If
  
  
  Set xlsDateien = New Collection
  Set inaccessablePaths = New Collection
  
  TotalUsedBytes = 0
  TotalUsedFiles = 0
  TotalUnusedBytes = 0
  TotalUnusedFiles = 0
  TotalUnusedBytesOlder = 0
  TotalUnusedFilesOlder = 0
  TotalUnusedBytesSmaller = 0
  TotalUnusedFilesSmaller = 0
  TotalUnusedBytesDouble = 0
  TotalUnusedFilesDouble = 0
  
  TotalFilesTested = 0
  
  Dim i As Long
  If Verzeichnisse.ListCount >= 1 Then
    For i = 0 To Verzeichnisse.ListCount - 1
      ScanDirs Verzeichnisse.Column(0, i), naa, nka, selGleicheNamenIgnorieren, selUnterverzeichnisseIgnorieren, GefundeneMengen
    Next i
  End If
  
  If GSprache = 1 Then
    GefundeneMengen = "In den Verzeichnissen werden " & TotalUsedFiles & " Datei(en) mit " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb gescannt." & vbCrLf & vbCrLf & _
      "Insgesamt werden " & TotalUnusedFiles & " Datei(en) mit " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb ignoriert." & vbCrLf & _
      "-  " & TotalUnusedFilesSmaller & " Datei(en) mit " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gr|fffd||fffd|e'," & vbCrLf & _
      "-  " & TotalUnusedFilesOlder & " Datei(en) mit " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Monate'," & vbCrLf & _
      "-  " & TotalUnusedFilesDouble & " Datei(en) mit " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb wegen der Einschr|fffd|nkung 'Gleiche Namen'"
  Else
    GefundeneMengen = TotalUsedFiles & " file(s) with " & Format((TotalUsedBytes) / 1024, "##,##0") & "Kb will be scanned." & vbCrLf & vbCrLf & _
      TotalUnusedFiles & " file(s) with " & Format((TotalUnusedBytes) / 1024, "##,##0") & "Kb will be ignored." & vbCrLf & _
      "-  " & TotalUnusedFilesSmaller & " file(s) with " & Format((TotalUnusedBytesSmaller) / 1024, "##,##0") & "Kb because of limitation 'size'," & vbCrLf & _
      "-  " & TotalUnusedFilesOlder & " file(s) with " & Format((TotalUnusedBytesOlder) / 1024, "##,##0") & "Kb because of limitation 'months'," & vbCrLf & _
      "-  " & TotalUnusedFilesDouble & " file(s) with " & Format((TotalUnusedBytesDouble) / 1024, "##,##0") & "Kb because of limitation 'same names'"
  End If
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  
  
End Sub




Private Sub selUnterverzeichnisseIgnorieren_Click()
  selGleicheNamenIgnorieren.Enabled = Not selUnterverzeichnisseIgnorieren
End Sub


Attribute VB_Name = "PrgTexte"
Option Explicit

Global GSprache As Long
Const MAX_TEXTE As Long = 100
Public Texte(2, MAX_TEXTE) As String
Public STexte As Collection

Global Const TXT_BLATTSCHUTZFEHLT As Long = 1
Global Const TXT_SZENARIOSCHUTZFEHLT As Long = 2
Global Const TXT_ANS_EINZELANALYSE As Long = 3
Global Const TXT_ANS_MASSENANALYSE As Long = 4
Global Const TXT_ANS_TABELLEN|fffd|BERSICHT As Long = 5
Global Const TXT_ANS_FUNKTIONSANALYSE As Long = 6
Global Const TXT_ANS_FUNKTIONS|fffd|BERSICHT As Long = 7
Global Const TXT_ANS_FUNKTIONSEXPORT As Long = 8
Global Const TXT_NICHTGEPR|fffd|FT As Long = 9
Global Const TXT_ABBRUCH As Long = 10
Global Const TXT_FERTIG As Long = 11
Global Const TXT_KEINEZELLEN As Long = 12
Global Const TXT_TABGESCH|fffd|TZT As Long = 13
Global Const TXT_TABAUSGEBLENDET As Long = 14
Global Const TXT_DATEIPASSWORTSCHUTZ As Long = 15
Global Const TXT_VBAPR|fffd|FUNG As Long = 16
Global Const TXT_EXCEL2000 As Long = 17
Global Const TXT_ECCENTFERNEN As Long = 18
Global Const TXT_ORDNERW|fffd|HLEN As Long = 19
Global Const TXT_NAEA As Long = 20
Global Const TXT_MONATE As Long = 21
Global Const TXT_NKA As Long = 22
Global Const TXT_UVI As Long = 23
Global Const TXT_GLEICHENAMEN As Long = 24
Global Const TXT_PFADZUGRIFFVERWEIGERT As Long = 25
Global Const TXT_ABG As Long = 26
Global Const TXT_BEEN As Long = 27
Global Const TXT_DATEIENIMORDNER As Long = 28
Global Const TXT_XLFILES As Long = 29
Global Const TXT_FUNKTIONSVERTEILUNG As Long = 30
Global Const TXT_FAST As Long = 31
Global Const TXT_DEEP As Long = 32
Global Const TXT_ANALYSIERT As Long = 33
Global Const TXT_GESCH|fffd|TZT As Long = 34
Global Const TXT_GESCH|fffd|TZT2 As Long = 35
Global Const TXT_NICHTERMITTELBAR As Long = 36
Global Const TXT_NICHTERMITTELBARKURZ As Long = 37
Global Const TXT_JAOHNEPW As Long = 38
Global Const TXT_JAMITPW As Long = 39
Global Const TXT_JA As Long = 40
Global Const TXT_SB As Long = 41
Global Const TXT_USB As Long = 42
Global Const TXT_SV As Long = 43
Global Const TXT_DATEVGESCH As Long = 44
Global Const TXT_TABK As Long = 45
Global Const TXT_ZEILEK As Long = 46
Global Const TXT_SPALTEK As Long = 47
Global Const TXT_CHECKSUMME As Long = 48
Global Const TXT_STARTECC As Long = 49
Global Const TXT_REMOVEECC As Long = 50
Global Const TXT_README As Long = 51
Global Const TXT_GENERIERTAM As Long = 52
Global Const TXT_UNTERVERZEICHNISSEIGNORIEREN As Long = 53
Global Const TXT_GLEICHENAMENIGNORIEREN As Long = 54
Global Const TXT_LEEREFELDER As Long = 55
Global Const TXT_MENGENBERECHNEN As Long = 56
Global Const TXT_ABBRUCHCMD As Long = 57
Global Const TXT_LAUFWERKE As Long = 58
Global Const TXT_SPRACHE As Long = 59
Global Const TXT_PFAD As Long = 60
Global Const TXT_XLSFILES As Long = 61
Global Const TXT_ERRORFORMATTING As Long = 62
Global Const TXT_ELTFILES As Long = 63
Global Const TXT_ELTXLSFILES As Long = 64
Global Const TXT_DATEI_FEHLT As Long = 65
Global Const TXT_DATEI_|fffd|BERSCHREIBEN As Long = 66

Global Const TXT_LADEN As Long = 67
Global Const TXT_SPEICHERN As Long = 68
Global Const TXT_LISTEDERZUSCANNENDENDATEIEN As Long = 69
Global Const TXT_EINZELANALYSEANZEIGEN As Long = 70
Global Const TXT_AUSWAHLANALYSE As Long = 71
Global Const TXT_ERGEBNISSPEICHERN As Long = 72
Global Const TXT_NEIN As Long = 73
Global Const TXT_FERTIG2 As Long = 74


Function TextExists(str As String) As Boolean
On Error GoTo doesntExist
  Dim s As String
  s = STexte(str)
  TextExists = True
  Exit Function
doesntExist:
  TextExists = False
End Function

Function TranslateText(str As String) As String
On Error GoTo doesntExist
  TranslateText = STexte(str)
  Exit Function
doesntExist:
  TranslateText = str
End Function



Sub TexteInit()

  Set STexte = New Collection
  Dim y As Long
  y = 2
  With ThisWorkbook.Sheets("Texte")
    Do While Not IsEmpty(.Cells(y, 1))
      STexte.Add .Cells(y, 1 + GSprache), .Cells(y, 1)
      y = y + 1
    Loop
  End With

  
  Texte(1, TXT_BLATTSCHUTZFEHLT) = "B "
  Texte(2, TXT_BLATTSCHUTZFEHLT) = "S "
  Texte(1, TXT_SZENARIOSCHUTZFEHLT) = "S "
  Texte(2, TXT_SZENARIOSCHUTZFEHLT) = "C "
  Texte(1, TXT_ANS_EINZELANALYSE) = "Einzelanalyse"
  Texte(2, TXT_ANS_EINZELANALYSE) = "SingleFileAnalysis"
  Texte(1, TXT_ANS_MASSENANALYSE) = "Massenanalyse"
  Texte(2, TXT_ANS_MASSENANALYSE) = "MassAnalysis"
  Texte(1, TXT_ANS_TABELLEN|fffd|BERSICHT) = "Tabellen|fffd|bersicht"
  Texte(2, TXT_ANS_TABELLEN|fffd|BERSICHT) = "SheetOverview"
  Texte(1, TXT_ANS_FUNKTIONSANALYSE) = "Funktionsanalyse"
  Texte(2, TXT_ANS_FUNKTIONSANALYSE) = "FunctionAnalysis"
  Texte(1, TXT_ANS_FUNKTIONS|fffd|BERSICHT) = "Funktions|fffd|bersicht"
  Texte(2, TXT_ANS_FUNKTIONS|fffd|BERSICHT) = "FunctionOverview"
  Texte(1, TXT_ANS_FUNKTIONSEXPORT) = "Funktionsexport"
  Texte(2, TXT_ANS_FUNKTIONSEXPORT) = "FunctionExport"
  Texte(1, TXT_NICHTGEPR|fffd|FT) = "Nicht gepr|fffd|ft"
  Texte(2, TXT_NICHTGEPR|fffd|FT) = "Not tested"
  
  Texte(1, TXT_ABBRUCH) = "Analyse abgebrochen! Zeit: "
  Texte(2, TXT_ABBRUCH) = "Aborted! Time: "
  Texte(1, TXT_FERTIG) = "Fertig! Zeit: "
  Texte(2, TXT_FERTIG) = "Finished! Time: "
  Texte(1, TXT_KEINEZELLEN) = "Diese Excel-Datei hat keine Tabellenb|fffd|tter mit genutzten Zellen."
  Texte(2, TXT_KEINEZELLEN) = "This Excel-file doesnt have any sheets with used cells."
  
  Texte(1, TXT_TABGESCH|fffd|TZT) = "VORSICHT!!!!" & vbCrLf & _
                "Einige Tabellen waren mit Passw|fffd|rtern gesch|fffd|tzt. " & _
                "Die Einf|fffd|rbung funktioniert bei diesen Tabellen nicht. Sollten Sie die Einf|fffd|rbung ben|fffd|tigen, muss der Passwortschutz entfernt werden!"
  Texte(2, TXT_TABGESCH|fffd|TZT) = "ATTENTION!!!!" & vbCrLf & _
                "Some sheets were protected with passwords. " & _
                "Colouring these sheets is not possible. If you need colouring then please remove the passwords!"
  
  Texte(1, TXT_TABAUSGEBLENDET) = "VORSICHT!!!!" & vbCrLf & _
                "Einige Tabellen waren ausgeblendet! Da der Arbeitsmappenschutz aktiv ist, " & _
                "kann der ECC diese Tabellen nicht einblenden! Bitte besorgen Sie sich das Passwort und entfernen den Schutz!"
  Texte(2, TXT_TABAUSGEBLENDET) = "ATTENTION!!!!" & vbCrLf & _
                "Some sheets were hidden! Due to the fact that the workbook protection is active " & _
                "these sheets cannot be made visible! Please remove the passwords first!"
                
  Texte(1, TXT_DATEIPASSWORTSCHUTZ) = "Die Datei ist evtl. Passwortgesch|fffd|tzt. Bitte entfernen Sie ggfs. den Schutz." & vbCrLf & _
        "Bitte beachten Sie hierzu den folgenden Fehlertext!"
  Texte(2, TXT_DATEIPASSWORTSCHUTZ) = "The file is probably password protected. Please remove the password." & vbCrLf & _
        "Please note the following text!"
        
  Texte(1, TXT_VBAPR|fffd|FUNG) = "MS-Excel l|fffd|sst eine |fffd|berpr|fffd|fung auf VBA-Programmcode nicht zu. Es kann nicht ermittelt werden, ob es Programmcode innerhalb der Datei gibt oder nicht. Bitte pr|fffd|fen Sie dies selbst!"
  Texte(2, TXT_VBAPR|fffd|FUNG) = "Access to VBA-Code is prohibited by MS-Excel due to the current settings. It is not possible to detect whether there is VBA-Code or not. Please check this yourself!"
      
  Texte(1, TXT_EXCEL2000) = "Sie benutzen eine Excel-Version (ab Excel2000), die den Zugriff auf VBA-Code nur beschr|fffd|nkt zul|fffd|sst. Um den vollen Funktionsumfag des ECC nutzen zu k|fffd|nnen, m|fffd|ssen Sie unter Extras/Makro/Sicherheit im Reiter " & _
          "'Vertrauensw|fffd|rdige Quellen' den Punkt 'Zugriff auf Visual Basic Projekt vertrauen' anschalten. Danach ist erst die volle Analyse m|fffd|glich! Bitte schalten Sie die Funktion bei Bedarf danach wieder aus!"
  Texte(2, TXT_EXCEL2000) = "You are using an Excel version (Excel2000 or later) that limits VBA-Code access. To be able to use the full analyzing functionality of the " & ProgNameLong & " you will have to turn on the access switch via 'Extras/Macro/Security', slider " & _
          "'trusted sources' and there 'Trust access for visual basic projects'. Turn off the switch again if you wish to after you are finished analyzing!"

  Texte(1, TXT_ECCENTFERNEN) = "Sind Sie sicher, dass Sie den ECC aus Ihrer Men|fffd|leiste entfernen m|fffd|chten?"
  Texte(2, TXT_ECCENTFERNEN) = "Are you sure that you want to remove the ECC from your menu bar?"
  
  Texte(1, TXT_ORDNERW|fffd|HLEN) = "W|fffd|hlen Sie bitte einen Ordner aus."
  Texte(2, TXT_ORDNERW|fffd|HLEN) = "Please select a folder."

  Texte(1, TXT_NAEA) = "Nicht |fffd|lter als "
  Texte(2, TXT_NAEA) = "Not older than "
  Texte(1, TXT_MONATE) = " Monate."
  Texte(2, TXT_MONATE) = " months."
  
  Texte(1, TXT_NKA) = "Nicht kleiner als "
  Texte(2, TXT_NKA) = "Not smaller than "
  
  Texte(1, TXT_UVI) = "Unterverzeichnisse wurden ignoriert!"
  Texte(2, TXT_UVI) = "Subfolders were ignored!"
  
  Texte(1, TXT_GLEICHENAMEN) = "Dateien mit gleichen Namen in Unterverzeichnissen ignorieren."
  Texte(2, TXT_GLEICHENAMEN) = "Ignore files with same names in subfolders."

  Texte(1, TXT_PFADZUGRIFFVERWEIGERT) = "Zugriff auf Pfad wurde verweigert!"
  Texte(2, TXT_PFADZUGRIFFVERWEIGERT) = "Access to path denied!"
  
  Texte(1, TXT_ABG) = "Abgebrochen!"
  Texte(2, TXT_ABG) = "Aborted!"

  Texte(1, TXT_BEEN) = "Beendet!"
  Texte(2, TXT_BEEN) = "Finished!"
  
  Texte(1, TXT_DATEIENIMORDNER) = " Dateie(n) im Ordner '"
  Texte(2, TXT_DATEIENIMORDNER) = " file(s) in folder '"
  
  Texte(1, TXT_XLFILES) = "Excel-Dateien,*.xl*"
  Texte(2, TXT_XLFILES) = "Excel-files,*.xl*"
  
  Texte(1, TXT_XLSFILES) = "Excel-Dateien,*.xls"
  Texte(2, TXT_XLSFILES) = "Excel-files,*.xls"
  
  Texte(1, TXT_FUNKTIONSVERTEILUNG) = "Funktionsverteilung"
  Texte(2, TXT_FUNKTIONSVERTEILUNG) = "Function distribution"
  
  Texte(1, TXT_FAST) = "Schnell"
  Texte(2, TXT_FAST) = "Fast"
  
  Texte(1, TXT_DEEP) = "Ausf|fffd|hrlich"
  Texte(2, TXT_DEEP) = "Deep"
  
  Texte(1, TXT_ANALYSIERT) = "Analysiert!"
  Texte(2, TXT_ANALYSIERT) = "Analyzed!"
  
  Texte(1, TXT_GESCH|fffd|TZT) = "Gesch"
  Texte(2, TXT_GESCH|fffd|TZT) = "Prot"
  Texte(1, TXT_GESCH|fffd|TZT2) = "Gesch"
  Texte(2, TXT_GESCH|fffd|TZT2) = "Prot"
  
  Texte(1, TXT_NICHTERMITTELBAR) = "NE"
  Texte(2, TXT_NICHTERMITTELBAR) = "NA"
  Texte(1, TXT_NICHTERMITTELBARKURZ) = "NE"
  Texte(2, TXT_NICHTERMITTELBARKURZ) = "NA"
  
  Texte(1, TXT_JAMITPW) = "Ja, mit PW"
  Texte(2, TXT_JAMITPW) = "Yes, w. pw"
  Texte(1, TXT_JAOHNEPW) = "Ja, ohne PW"
  Texte(2, TXT_JAOHNEPW) = "Yes, w/o pw"
  Texte(1, TXT_JA) = "Ja"
  Texte(2, TXT_JA) = "Yes"
  
  Texte(1, TXT_SB) = "SB"
  Texte(2, TXT_SB) = "VB"
  Texte(1, TXT_USB) = "USB"
  Texte(2, TXT_USB) = "IVB"
  
  Texte(1, TXT_SV) = " SV"
  Texte(2, TXT_SV) = " VH"
  
  Texte(1, TXT_DATEVGESCH) = "Die Datei ist evtl. Passwortgesch|fffd|tzt."
  Texte(2, TXT_DATEVGESCH) = "File might be password protected."

  Texte(1, TXT_TABK) = "T"
  Texte(2, TXT_TABK) = "S"
  Texte(1, TXT_ZEILEK) = "Z"
  Texte(2, TXT_ZEILEK) = "R"
  Texte(1, TXT_SPALTEK) = "Sp"
  Texte(2, TXT_SPALTEK) = "Cl"
  Texte(1, TXT_CHECKSUMME) = "Checksumme"
  Texte(2, TXT_CHECKSUMME) = "Checksum"
  
  Texte(1, TXT_STARTECC) = "Startet den " & ProgNameLong & "."
  Texte(2, TXT_STARTECC) = "Starts the " & ProgNameLong & "."

  Texte(1, TXT_REMOVEECC) = "Entfernt den " & ProgNameLong & " aus der Men|fffd|leiste."
  Texte(2, TXT_REMOVEECC) = "Removes the " & ProgNameLong & " from the menu bar."
  
  Texte(1, TXT_README) = "Bitte lesen Sie erst die Datei 'ReadMeDemo.txt'"
  Texte(2, TXT_README) = "Please read the instructions in the 'ReadMeDemo.txt'-file first."
  
  Texte(1, TXT_GENERIERTAM) = "Generiert am "
  Texte(2, TXT_GENERIERTAM) = "Generated "

  Texte(1, TXT_UNTERVERZEICHNISSEIGNORIEREN) = "Unterverzeichnisse ignorieren"
  Texte(2, TXT_UNTERVERZEICHNISSEIGNORIEREN) = "Ignore subpaths"
  
  Texte(1, TXT_GLEICHENAMENIGNORIEREN) = "Dateien mit gleichen Namen in Unterverzeichnissen ignorieren"
  Texte(2, TXT_GLEICHENAMENIGNORIEREN) = "Ignore files with same names in subpaths"
  
  Texte(1, TXT_LEEREFELDER) = "Wenn Sie keine Werte erfassen, dann werden alle Dateien ber|fffd|cksichtigt."
  Texte(2, TXT_LEEREFELDER) = "If you do not enter any values all files will be analyzed."
  
  Texte(1, TXT_MENGENBERECHNEN) = "Mengen berechnen"
  Texte(2, TXT_MENGENBERECHNEN) = "Calculate amount"
  
  Texte(1, TXT_ABBRUCHCMD) = "Abbruch"
  Texte(2, TXT_ABBRUCHCMD) = "Abort"

  Texte(1, TXT_LAUFWERKE) = "Laufwerke:"
  Texte(2, TXT_LAUFWERKE) = "Drives:"

  Texte(1, TXT_SPRACHE) = "Sprache"
  Texte(2, TXT_SPRACHE) = "Language"
  
  Texte(1, TXT_PFAD) = "Pfad:"
  Texte(2, TXT_PFAD) = "Path:"
  
  Texte(1, TXT_ERRORFORMATTING) = "Es konnte nicht alle Felder coloriert werden, da Excel f|fffd|r diese Funktion nicht mehr gen|fffd|gend Speicher zur Verf|fffd|gung hat. Bitte nutzen Sie bei der Auswertung der Datei ausschlie|fffd|lich die Ergebnistabellen und nicht die eingef|fffd|rbte Datei!"
  Texte(2, TXT_ERRORFORMATTING) = "Not all cells could be coloured because Excel does not provide enough memory for this operation. Please do not use the coloured workbook for analysis but only refer to the figures displayed in the result sheets!"

  Texte(1, TXT_ELTFILES) = "ECC-List-Dateien (*.elt),*.elt"
  Texte(2, TXT_ELTFILES) = "ECC list files (*.elt),*.elt"
  
  Texte(1, TXT_ELTXLSFILES) = "ECC-List-Dateien (*.elt),*.elt,Excel-Dateien (*.xls),*.xls"
  Texte(2, TXT_ELTXLSFILES) = "ECC list files (*.elt),*.elt,Excel files (*.xls),*.xls"
  
  Texte(1, TXT_DATEI_FEHLT) = "Datei existiert nicht."
  Texte(2, TXT_DATEI_FEHLT) = "File missing"
  
  Texte(1, TXT_DATEI_|fffd|BERSCHREIBEN) = "Die Datei existiert bereits. Soll Sie |fffd|berschrieben werden?"
  Texte(2, TXT_DATEI_|fffd|BERSCHREIBEN) = "The selected file already exists. Do you want to overwrite it?"


  Texte(1, TXT_LADEN) = "Laden"
  Texte(2, TXT_LADEN) = "Load"
  Texte(1, TXT_SPEICHERN) = "Speichern"
  Texte(2, TXT_SPEICHERN) = "Save"
  Texte(1, TXT_LISTEDERZUSCANNENDENDATEIEN) = "Liste der zu scannenden Dateien"
  Texte(2, TXT_LISTEDERZUSCANNENDENDATEIEN) = "List of files to be scanned"
  Texte(1, TXT_EINZELANALYSEANZEIGEN) = "Jede Datei auch als einzelanalyse anzeigen?"
  Texte(2, TXT_EINZELANALYSEANZEIGEN) = "Show single file report for each file?"
  
  Texte(1, TXT_ERGEBNISSPEICHERN) = "Ergebnisdatei speichern..."
  Texte(2, TXT_ERGEBNISSPEICHERN) = "Save result file..."

  Texte(1, TXT_NEIN) = "Nein"
  Texte(2, TXT_NEIN) = "No"

  Texte(1, TXT_FERTIG2) = "Fertig!"
  Texte(2, TXT_FERTIG2) = "Finished!"

  If GSprache = 2 Then
    MainMenu.Massenanalyse.Caption = "Mass analysis"
    MainMenu.Analyse.Caption = "Single file analysis"
    MainMenu.ProgrammBeenden.Caption = "Quit"
  Else
    MainMenu.Massenanalyse.Caption = "Massenanalyse"
    MainMenu.Analyse.Caption = "Einzelanalyse"
    MainMenu.ProgrammBeenden.Caption = "Beenden"
  End If

'  MainMenu.cmdSprache.Caption = Texte(GSprache, TXT_SPRACHE)

  ' Selektion
  PathSelect.NKAtxt.Caption = Texte(GSprache, TXT_NKA)
  PathSelect.N|fffd|Atxt.Caption = Texte(GSprache, TXT_NAEA)
  PathSelect.Monatetxt.Caption = Texte(GSprache, TXT_MONATE)
  PathSelect.selUnterverzeichnisseIgnorieren.Caption = Texte(GSprache, TXT_UNTERVERZEICHNISSEIGNORIEREN)
  PathSelect.selGleicheNamenIgnorieren.Caption = Texte(GSprache, TXT_GLEICHENAMENIGNORIEREN)
'  PathSelect.KeineWertetxt.Caption = Texte(GSprache, TXT_LEEREFELDER)
  PathSelect.MengenBerechnen.Caption = Texte(GSprache, TXT_MENGENBERECHNEN)
  PathSelect.cmdAbbruch.Caption = Texte(GSprache, TXT_ABBRUCHCMD)
  
End Sub


Attribute VB_Name = "RegStuff"
Option Explicit

'API Function and Constant Declarations
'--------------------------------------


'***Declare the value data types
Global Const REG_SZ As Long = 1 '***Registry string
Global Const REG_DWORD As Long = 4 '***Registry number (32-bit number)

'***Declare the keys that should exist.
'***Typically applications will put information under HKEY_CURRENT_USER
Global Const HKEY_CLASSES_ROOT = &H80000000
Global Const HKEY_CURRENT_USER = &H80000001
Global Const HKEY_LOCAL_MACHINE = &H80000002
Global Const HKEY_USERS = &H80000003

'***Errors
Global Const ERROR_NONE = 0
Global Const ERROR_BADDB = 1
Global Const ERROR_BADKEY = 2
Global Const ERROR_CANTOPEN = 3
Global Const ERROR_CANTREAD = 4
Global Const ERROR_CANTWRITE = 5
Global Const ERROR_OUTOFMEMORY = 6
Global Const ERROR_INVALID_PARAMETER = 7
Global Const ERROR_ACCESS_DENIED = 8
Global Const ERROR_INVALID_PARAMETERS = 87
Global Const ERROR_NO_MORE_ITEMS = 259

'***Gives all users full access to the key
Global Const KEY_ALL_ACCESS = &H3F

'***Creates a key that is persistent
Global Const REG_OPTION_NON_VOLATILE = 0

Global gstrAppVersion As String

'***Registry API declarations

#If VBA7 Then
  Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" ( _
      ByVal hKey As Long _
  ) As Long
  
  Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal Reserved As Long, _
      ByVal lpClass As String, _
      ByVal dwOptions As Long, _
      ByVal samDesired As Long, _
      ByVal lpSecurityAttributes As Long, _
      phkResult As Long, _
      lpdwDisposition As Long _
  ) As Long
  
  Declare PtrSafe Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal ulOptions As Long, _
      ByVal samDesired As Long, _
      phkResult As Long _
  ) As Long
  
  Declare PtrSafe Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
      ByVal hKey As Long, _
      ByVal lpValueName As String, _
      ByVal lpReserved As Long, _
      lpType As Long, _
      ByVal lpData As String, _
      lpcbData As Long _
  ) As Long
  
  Declare PtrSafe Function RegQueryValueExLong Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, lpData As _
  Long, lpcbData As Long) As Long
  
  Declare PtrSafe Function RegQueryValueExNULL Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
  As Long, lpcbData As Long) As Long
  
  Declare PtrSafe Function RegSetValueExString Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As _
  String, ByVal cbData As Long) As Long
  
  Declare PtrSafe Function RegSetValueExLong Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, _
  ByVal cbData As Long) As Long
#Else
  Declare Function RegCloseKey Lib "advapi32.dll" ( _
      ByVal hKey As Long _
  ) As Long
  
  Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal Reserved As Long, _
      ByVal lpClass As String, _
      ByVal dwOptions As Long, _
      ByVal samDesired As Long, _
      ByVal lpSecurityAttributes As Long, _
      phkResult As Long, _
      lpdwDisposition As Long _
  ) As Long
  
  Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
      ByVal hKey As Long, _
      ByVal lpSubKey As String, _
      ByVal ulOptions As Long, _
      ByVal samDesired As Long, _
      phkResult As Long _
  ) As Long
  
  Declare Function RegQueryValueExString Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
      ByVal hKey As Long, _
      ByVal lpValueName As String, _
      ByVal lpReserved As Long, _
      lpType As Long, _
      ByVal lpData As String, _
      lpcbData As Long _
  ) As Long
  
  Declare Function RegQueryValueExLong Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, lpData As _
  Long, lpcbData As Long) As Long
  
  Declare Function RegQueryValueExNULL Lib "advapi32.dll" Alias _
  "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _
  String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
  As Long, lpcbData As Long) As Long
  
  Declare Function RegSetValueExString Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As _
  String, ByVal cbData As Long) As Long
  
  Declare Function RegSetValueExLong Lib "advapi32.dll" Alias _
  "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, _
  ByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, _
  ByVal cbData As Long) As Long

#End If


Public Function SetValueEx( _
    ByVal hKey As Long, _
    sValueName As String, _
    lType As Long, _
    vValue As Variant _
) As Long

'*** Called By: SetKeyValue
'*** Description: Wrapper function around the registry API calls
'*** RegSetValueExString/Long. Determines if the value
'*** is a string or a long and calls the appropriate API.
'*** Return Value: Returns the API call's return value, which is its
'*** status (successful, error).

Dim lValue As Long
Dim sValue As String

    Select Case lType
        '***String
        Case REG_SZ
            sValue = vValue
            SetValueEx = RegSetValueExString(hKey, sValueName, 0&, lType, sValue, Len(sValue))
        '***32-bit number
        Case REG_DWORD
            lValue = vValue
            SetValueEx = RegSetValueExLong(hKey, sValueName, 0&, lType, lValue, 4)
    End Select
    
End Function

Private Function QueryValueEx( _
    ByVal lhKey As Long, _
    ByVal szValueName As String, _
    vValue As Variant _
) As Long

'*** Called By: QueryValue
'*** Description: Wrapper function around the registry API calls to
'*** RegQueryValueExLong and RegQueryValueExString.
'*** Determines size and type of data to be read.
'*** Determines if the value is a string or a long
'*** and calls the appropriate API.
'*** Return Value: Returns the API call's return value, which is its
'*** status (successful, error). The parameter vValue
'*** contains the value queried.

Dim cch As Long
Dim lrc As Long
Dim lType As Long
Dim lValue As Long
Dim sValue As String

On Error GoTo QueryValueExError

    ' Determine the size and type of data to be read
    lrc = RegQueryValueExNULL(lhKey, szValueName, 0&, lType, 0&, cch)
    
    If lrc <> ERROR_NONE Then Error 5
    
    Select Case lType
        ' For strings
        Case REG_SZ:
            sValue = String(cch, 0)
            lrc = RegQueryValueExString(lhKey, szValueName, 0&, lType, sValue, cch)
            If lrc = ERROR_NONE Then
                If Mid(sValue, cch, 1) = Chr(0) Then
                vValue = Left$(sValue, cch - 1) ' get rid of trailing AsciiZ
            Else
                vValue = Left$(sValue, cch)
            End If
            Else
                vValue = Empty
            End If
            ' For DWORDS
        Case REG_DWORD:
            lrc = RegQueryValueExLong(lhKey, szValueName, 0&, lType, lValue, cch)
            If lrc = ERROR_NONE Then vValue = lValue
        Case Else
            'all other data types not supported
            lrc = -1
    End Select

QueryValueExExit:
QueryValueEx = lrc

Exit Function

QueryValueExError:
    Resume QueryValueExExit ' Hmmmm
End Function

Public Sub CreateNewKey(sNewKeyName As String, lPredefinedKey As Long)
'***With this procedure a call of
'*** CreateNewKey "TestKey", HKEY_CURRENT_USER
'***will create a key called TestKey immediately under HKEY_CURRENT_USER.
'***Calling CreateNewKey like this
'*** CreateNewKey "TestKey\SubKey1\SubKey2", HKEY_CURRENT_USER
'***will create a three-nested keys beginning with TestKey immediately under
'***HKEY_CURRENT_USER, Subkey1 subordinate to TestKey, and SubKey3 under
'***SubKey2.

'*** Called by: your own code to create keys
'*** Description: Wrapper around the RegCreateKeyEx API call.

Dim hNewKey As Long 'handle to the new key
Dim lRetVal As Long 'result of the RegCreateKeyEx function

    lRetVal = RegCreateKeyEx( _
        lPredefinedKey, _
        sNewKeyName, _
        0&, _
        vbNullString, _
        REG_OPTION_NON_VOLATILE, _
        KEY_ALL_ACCESS, _
        0&, _
        hNewKey, _
        lRetVal _
    )
    
    RegCloseKey hNewKey

End Sub

Public Sub SetKeyValue( _
    ByVal lpParentKey As Long, _
    sKeyName As String, _
    sValueName As String, _
    vValueSetting As Variant, _
    lValueType As Long _
)

'*** Called By: Your code when you want to set a KeyValue
'*** Description: Opens the key you want to set, calls the wrapper
'*** function SetValueEx, and closes key.
'*** ADD ERROR HANDLING!!

Dim lRetVal As Long 'result of the SetValueEx function
Dim hKey As Long 'handle of open key

    'open the specified key
    lRetVal = RegOpenKeyEx(lpParentKey, sKeyName, 0, KEY_ALL_ACCESS, hKey)
    ' write the value
    lRetVal = SetValueEx(hKey, sValueName, lValueType, vValueSetting)
    ' close the key
    RegCloseKey (hKey)
    
End Sub
Public Function QueryValue( _
    ByVal lpParentKey As Long, _
    sKeyName As String, _
    sValueName As String _
) As Variant

'*** Called By: Your code when you want to set a read a KeyValue
'*** Description: Opens the key you want to set, calls the wrapper
'*** function QueryValueEx, closes key.
'*** Return Value: The value you are querying
'*** ADD ERROR HANDLING!!

Dim lRetVal As Long 'result of the API functions
Dim hKey As Long 'handle of opened key
Dim vValue As Variant 'setting of queried value

    ' open the key
    lRetVal = RegOpenKeyEx(lpParentKey, sKeyName, 0, KEY_ALL_ACCESS, hKey)
    ' get the value
    lRetVal = QueryValueEx(hKey, sValueName, vValue)
    ' close the key
    RegCloseKey (hKey)
    
    QueryValue = vValue
    
End Function

Public Sub TestRegModule()

'
' This procedure demonstrates the use of this module
' All code below here is demo code
'
    CreateKeyDriver
    Debug.Print "Created key Cosmic Example and TestVals"
    
    SetStringValueDriver
    Debug.Print "Created the TestStringVal"
    
    SetNumberValueDriver
    Debug.Print "Created the TestNumVal"
    
    ReadValueDriver

End

End Sub

Sub CreateKeyDriver()

'
' demo code
'

'*** Calls the CreateNewKey procedure
'*** Description: Creates Cosmic Example key and TestVals subkey under
'*** HKEY_CURRENT_USER\Software\VB and VBA Program Settings
'*** If Software and/or VB and VBA Program Settings do not
'*** exist, they are created.
'*** Usage: Use this as an example of how you would use the CreateNewKey
'*** procedure.

Dim sNewKey As String
Dim lPredefinedKeyValue As Long

    sNewKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    lPredefinedKeyValue = HKEY_CURRENT_USER
    
    CreateNewKey sNewKey, lPredefinedKeyValue
    
End Sub

Sub SetStringValueDriver()

'
' demo code
'

'*** Calls the SetKeyValue procedure
'*** Description: Sets the value TestStringVal under the
'*** Cosmic Example\TestVals key and sets it to
'*** VB App Created. If it doesn't exist, it creates it.
'*** Usage: Use this as an example of how you would use the SetKeyValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant '***What to set the Value to
Dim sType As Long '***Value type -- string or number

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestStringVal"
    vSetting = "VB App Created"
    sType = REG_SZ

    SetKeyValue HKEY_CURRENT_USER, sKey, sValue, vSetting, sType

End Sub
Sub SetNumberValueDriver()

'
' demo code
'

'*** Calls the SetKeyValue procedure
'*** Description: Sets the value TestNumVal under the
'*** Cosmic Example\TestVals key and sets it to 5.
'*** If it doesn't exist, it creates it.
'*** Usage: Use this as an example of how you would use the SetKeyValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant '***Wht to set the Value to
Dim sType As Long '***Value type -- string or number

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestNumVal"
    vSetting = 5
    sType = REG_DWORD
    
    SetKeyValue HKEY_CURRENT_USER, sKey, sValue, vSetting, sType

End Sub

Sub ReadValueDriver()

'
' demo code
'

'*** Calls the QueryValue function
'*** Description: Reads the value TestNumVal and TestStringVal under
'*** the Cosmic Example\TestVals key.
'*** Usage: Use this as an example of how you would use the QueryValue
'*** procedure.

Dim sKey As String '***Key under which to create the value
Dim sValue As String '***Value name to set
Dim vSetting As Variant

    sKey = "Software\VB and VBA Program Settings\Cosmic Example\TestVals"
    sValue = "TestStringVal"
    
    '***Read the String value
    vSetting = QueryValue(HKEY_CURRENT_USER, sKey, sValue)
    Debug.Print "TestStringVal is " & vSetting
    
    sValue = "TestNumVal"
    '***Read the number value
    vSetting = QueryValue(HKEY_CURRENT_USER, sKey, sValue)
    Debug.Print "TestNumVal is " & vSetting

End Sub

Sub TestKey()
  
  CreateNewKey "Software\Microsoft\Office\12.0\Excel\Options", HKEY_CURRENT_USER
  SetKeyValue HKEY_CURRENT_USER, "Software\Microsoft\Office\12.0\Excel\Options", "NoShowCnvMsg", 1, REG_DWORD
  Debug.Print "Test:" & QueryValue(HKEY_CURRENT_USER, "Software\Microsoft\Office\12.0\Excel\Options", "NoShowCnvMsg")
End Sub
Attribute VB_Name = "RemovePassword"
Option Explicit

Dim LastPassword As String
Const EncodeString As String = "AbC37cGh!%9sdfP'#N'S'|fffd||fffd|PI|fffd|ip|fffd|ff034(=4324f"

Function DecodePassword(s As String)
  Dim i As Long
  Dim ret As String
  Dim t As String
  Dim pos As Long
  pos = 1
  i = 1
  Do While pos > 0
    t = GetNextText(s, pos)
    If Len(t) > 0 Then
      ret = ret & Chr(Val(t) Xor Asc(Mid(EncodeString, i, 1)))
    End If
    i = i + 1
  Loop
  
  DecodePassword = ret
  
End Function

Sub StorePasswordToFile(s As String)

  AddPasswort s
  
  Dim FileNumber

'  FileNumber = FreeFile
'  Do
'    Err.Clear
'    Open g_cfgPasswortpfad & "\ECCPW.bin" For Append As #FileNumber   ' Create file name.
'  Loop While Err.Number <> 0
'  Write #FileNumber, LastPassword
'  Close #FileNumber

  FileNumber = FreeFile
  On Error Resume Next
  
  
  Err.Clear
  Open G_cfgPasswortpfad & "\ECCPW.bin" For Append As #FileNumber    ' Create file name.
  If Err.Number <> 0 Then
    Exit Sub
  End If
  
  Dim enc As String
  Dim i As Long
  For i = 1 To Len(s)
    If Len(enc) > 0 Then
      enc = enc & "," & CStr(Asc(Mid(s, i, 1)) Xor Asc(Mid(EncodeString, i, 1)))
    Else
      enc = CStr(Asc(Mid(s, i, 1)) Xor Asc(Mid(EncodeString, i, 1)))
    End If
  Next i
  
  Write #FileNumber, enc
  Close #FileNumber

End Sub

Sub RemovePWWorkbook(oxlwbook As Excel.Workbook)
  
  If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
    Exit Sub
  End If
  
  On Error Resume Next
  Dim Pwc As Long
  
  AddStatus "Entferne Passwort aus Excel-Mappe"
  If Len(LastPassword) > 0 Then
    oxlwbook.Unprotect LastPassword
    If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
        If StartedByTracker Then
          TrackerStorePassword "#Workbook", LastPassword
        End If
        UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!"
        Exit Sub
    End If
  End If
  
  
  Dim pwCnt As Long
  For pwCnt = 1 To G_Passworte.count
    oxlwbook.Unprotect G_Passworte(pwCnt)
    If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
      If StartedByTracker Then
        TrackerStorePassword "#Workbook", G_Passworte(pwCnt)
      End If
      UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!"
      Exit Sub
    End If
  Next pwCnt

  Dim a(0 To 17) As Byte, i&, K%, b
  For i = 0 To 2 ^ 17
      For K = 0 To 17
          a(17 - K) = Asc(CStr(Abs((i And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 500 = 0 Then
        SetLiveStatus
        DoEvents
      End If
      If Pwc Mod 1000 = 0 Then
        UpdateStatus "Entferne Passwort aus Excel-Mappe (" & Pwc & " Versuche)"
      End If
      oxlwbook.Unprotect StrConv(a, vbUnicode)
      If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
        LastPassword = StrConv(a, vbUnicode)
        UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig! (" & Pwc & " Versuche)"
        If StartedByTracker Then
          TrackerStorePassword "#Workbook", LastPassword
        End If
        StorePasswordToFile LastPassword
        Exit Sub
      End If
  Next


  UpdateStatus "Entferne Passwort aus Excel-Mappe (Fehlgeschlagen)"

End Sub

Sub RemovePW(oXLWsheet As Excel.Worksheet)
  On Error Resume Next
  Dim Pwc As Long
  
  oXLWsheet.Activate
  
  If oXLWsheet.ProtectContents = False Then
    UpdateStatus "Tabelle '" & oXLWsheet.name & "' ungesch|fffd|tzt!"
    Exit Sub
  End If
  
  UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "'"
  If Len(LastPassword) > 0 Then
    oXLWsheet.Unprotect LastPassword
    If oXLWsheet.ProtectContents = False Then
        If StartedByTracker Then
          TrackerStorePassword oXLWsheet.name, LastPassword
        End If
        UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!"
        Exit Sub
    End If
  End If
  
  Dim pwCnt As Long
  For pwCnt = 1 To G_Passworte.count
      oXLWsheet.Unprotect G_Passworte(pwCnt)
      If oXLWsheet.ProtectContents = False Then
        If StartedByTracker Then
          TrackerStorePassword oXLWsheet.name, G_Passworte(pwCnt)
        End If
        UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!"
        Exit Sub
      End If
  Next pwCnt

  Dim a(0 To 17) As Byte, i&, K%, b
  For i = 0 To 2 ^ 17
      For K = 0 To 17
          a(17 - K) = Asc(CStr(Abs((i And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 500 = 0 Then
        SetLiveStatus
        DoEvents
      End If
      If Pwc Mod 1000 = 0 Then
        UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (" & Pwc & " Versuche)"
        SetLiveStatus
      End If
      oXLWsheet.Unprotect StrConv(a, vbUnicode)
      If oXLWsheet.ProtectContents = False Then
        LastPassword = StrConv(a, vbUnicode)
        UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig! (" & Pwc & " Versuche)"
        If StartedByTracker Then
          TrackerStorePassword oXLWsheet.name, LastPassword
        End If
        StorePasswordToFile LastPassword
        Exit Sub
      End If
  Next


  UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (Fehlgeschlagen)"

End Sub

Sub TestRemovePWVBA()
  RemovePWVBA Workbooks("PWCrack.xls")
End Sub

Sub CheckVBAPassword(oxlwbook As Workbook, PW As String)

  oxlwbook.Activate
  
'  Application.EnableEvents = True
  If Left(Application.Version, 3) = "8.0" Then
'    SendKeys "%{F11}%Xs{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%{F11}%Xs" & PW & "{enter}{esc}{esc}%{F4}", True
  ElseIf Left(Application.Version, 3) = "9.0" Then
'    SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%xkv%xi" & PW & "{enter}{esc}{esc}%{F4}", True
  ElseIf Left(Application.Version, 4) = "10.0" Then
'    SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%xkv%xi" & PW & "{enter}{esc}{esc}%{F4}", True
  End If
'  Application.EnableEvents = False
  
End Sub
  

Sub RemovePWVBA(oxlwbook As Excel.Workbook)
  On Error Resume Next
  Dim Pwc As Long
  
  If oxlwbook.VBProject.Protection <> 1 Then
    UpdateStatus "VBA ungesch|fffd|tzt!"
    Exit Sub
  End If
  
'  oxlwbook.Application.ScreenUpdating = False
   
  If Len(LastPassword) > 0 Then CheckVBAPassword oxlwbook, LastPassword
  
  UpdateStatus "Entferne VBA-Passwort aus Projekt"
  If oxlwbook.VBProject.Protection <> 1 Then
        If StartedByTracker Then
          TrackerStorePassword "#VBA", LastPassword
        End If
      UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig!"
'      oxlwbook.Application.ScreenUpdating = True
      Exit Sub
  End If
  
  Dim pwCnt As Long
  For pwCnt = 1 To G_Passworte.count
      CheckVBAPassword oxlwbook, G_Passworte(pwCnt)
      If oxlwbook.VBProject.Protection <> 1 Then
        If StartedByTracker Then
          TrackerStorePassword "#VBA", G_Passworte(pwCnt)
        End If
        UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig!"
'        oxlwbook.Application.ScreenUpdating = True
        Exit Sub
      End If
  Next pwCnt

  Dim a(0 To 17) As Byte, i&, K%, b
  For i = 0 To 2 ^ 17
      For K = 0 To 17
          a(17 - K) = Asc(CStr(Abs((i And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 500 = 0 Then
        SetLiveStatus
        DoEvents
      End If
      If Pwc Mod 1000 = 0 Then
        UpdateStatus "Entferne VBA-Passwort aus Projekt (" & Pwc & " Versuche)"
      End If
      
      CheckVBAPassword oxlwbook, StrConv(a, vbUnicode)
'      SendKeys StrConv(a, vbUnicode) & "{enter}", True
      If oxlwbook.VBProject.Protection <> 1 Then
        LastPassword = StrConv(a, vbUnicode)
        UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig! (" & Pwc & " Versuche)"
        If StartedByTracker Then
          TrackerStorePassword "#VBA", LastPassword
        End If
        StorePasswordToFile LastPassword
'        oxlwbook.Application.ScreenUpdating = True
        Exit Sub
      End If
  Next

  UpdateStatus "Entferne VBA-Passwort aus Projekt (Fehlgeschlagen)"

'  oxlwbook.Application.ScreenUpdating = True

End Sub

Sub TrackerStorePassword(n As String, v As String)

  If Not theTrackerPasswordLog Then Exit Sub

  Dim rs As Object
  On Error Resume Next
'  If Err.Number <> 0 Then Exit Sub
  If G_conn Is Nothing Then Exit Sub
  
  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT * FROM ECCPasswort", G_conn, 2, 3
  rs.AddNew
  rs.Fields("idvDateiID").Value = theidvDateiID
  rs.Fields("Datum").Value = FileDateTime(theFilename)
  rs.Fields("Name").Value = Left(n, 20)
  rs.Fields("Wert").Value = Left(v, 18)
  rs.Update
  rs.Close
  Set rs = Nothing

End Sub


Sub AddPasswort(PW As String)
  On Error Resume Next
  G_Passworte.Add PW, PW
End Sub

Sub GetPasswoerter()
  On Error Resume Next ' Damit wir auch sch|fffd|n doppelte Passw|fffd|rter ignorieren k|fffd|nnen
  Set G_Passworte = New Collection
  
  ' Passw|fffd|rter aus der Datenbank holen
  
  If StartedByTracker Then
    Dim rs As Object
    On Error Resume Next
  '  If Err.Number <> 0 Then Exit Sub
    Dim conn As Object
    
    
    Set conn = GetConnection()
    If conn Is Nothing Then Exit Sub
    
    Set rs = CreateObject("ADODB.recordset")
    rs.Open "SELECT Wert FROM ECCPasswort GROUP BY Wert", conn, MYadOpenDynamic, MYadLockReadOnly
    
    Do While Not rs.EOF
      G_Passworte.Add rs.Fields("Wert").Value, rs.Fields("Wert").Value
      rs.movenext
    Loop
    rs.Close
    Set rs = Nothing
    conn.Close
    Set conn = Nothing
  End If
  
  
  
  ' Nur die aus der Datei ECCPW.bin holen
  
  Dim MyIndex, FileNumber
  Dim tpw As String
  If FileExists(G_cfgPasswortpfad & "\ECCPW.bin") Then
    FileNumber = FreeFile
    Do
      Err.Clear
      Open G_cfgPasswortpfad & "\ECCPW.bin" For Input As #FileNumber   ' Create file name.
    Loop While Err.Number <> 0
    
    Do While Not EOF(FileNumber)
      Input #FileNumber, tpw
      If Len(tpw) = 0 Then Exit Do
      tpw = DecodePassword(tpw)
      G_Passworte.Add tpw, tpw
    Loop
    Close #FileNumber   ' Close file.
  End If
  
  
  
End Sub
Attribute VB_Name = "Result"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' #Const DoProfile = True

Public Filename As String
Public Mode As Long

Public oxlwbook As Workbook
  ' Die Anzahl aller gefundenen Formeln
Public foundFormulaAmount        As Long
  ' Die Anzahl aller gefundenen Matrix-Funktionen
Public foundMatrixFuncs          As Long
  ' Die Anzahl aller replizierten Matrix-Funktionen
Public foundMatrixDuplicateFuncs As Long
  ' Die Anzahl aller gefundenen "gezogenen" Formeln
Public foundFormulaDuplicateAmount As Long
  ' Die Anzahl aller gefundener Summen
Public foundSumAmount            As Long
  ' Gezogene Summen
Public foundSumDuplicateAmount   As Long
  ' Die Anzahl aller gefundenen arithmetischen Formeln
Public foundCalcAmount           As Long
  ' Gezogenen arithmetische Funktionen
Public foundCalcDuplicateAmount    As Long
  ' Die Anzahl aller gefundenen unsichtbaren Spalten
Public foundHiddenColumnAmount   As Long
Public foundHiddenColumnAmountCount   As Long
  ' Die Anzahl aller gefundenen unsichtbaren Zeilen
Public foundHiddenRowAmount      As Long
Public foundHiddenRowAmountCount      As Long
  ' Die Anzahl aller gefundenen Formeln, die WENN-Bedingungen ethalten
Public foundIfAmount             As Long
  ' Gezogene If Bedingungen
Public foundIfDuplicateAmount    As Long
  ' Die Anzahl aller gefundenen Zellen mit Formeln, die
  ' keinen Zellschutz haben!
Public foundUnlockedFormulas     As Long
  ' Zellen, die zwar gesch|fffd|tzt sind (= locked), deren Schutz aber durch den fehlenden Blattschutz nicht
  ' aktiv ist!
Public foundLockedFormulasMissingSheetprotect As Long
  ' Zellen, die zwar gesch|fffd|tzt sind, deren Tabelle aber kein Passwort hat
Public foundLockedFormulasWithoutSheetpassword As Long
  ' Die Anzahl aller gefundenen Zellen mit Formeln, die
  ' keinen Zellschutz haben aber ausgeblendet sind!
Public foundUnlockedFormulasNotVisible     As Long
  
  ' Alle versteckten Bl|fffd|tter
Public foundHiddenWorksheetsAmount     As Long
  ' Alle sehr versteckten Bl|fffd|tter
Public foundVeryHiddenWorksheetsAmount As Long
  ' Alle Code Module
Public foundCodeModules          As Long


  ' Anzahl der Zellen in der Datei
Public totalCellAmount           As Long
  
  ' Anzahl der Zellen in einer Datei, die wirklich mit Text, Formeln o.|fffd|. belegt sind
Public totalUsedCellAmount       As Long
  
  ' Anzahl aller Zellen, die gepr|fffd|ft werden
Public totalWorkbookCheckAmount As Long
  
  ' Die Anzahl aller Zellen, die externe Dateien referenzieren
Public foundCellsWithExternalReferences As Long
  ' Die Anzahl aller Dateien, die referenziert werden
Public foundExternalReferences As Long
  
  ' Alle Formelzellen, die einen Fehler haben
Public foundNonAnalyzableCells As Long
  
  ' Alle diagramme
Public foundDiagrams As Long

Public foundHyperlinks As Long
Public foundInternalHyperlinks As Long
Public foundExternalHyperlinks As Long
  
  ' Checksumme f|fffd|r die Unver|fffd|nderbarkeit der Dateien
Public checksum As Long

  ' Collection, die aufnimmt, ob und wie die Sheets gesch|fffd|tzt waren
Public protectedSheetsColl As Collection

Public longestFormula As Long
Public maxopenbracam As Long

  ' Die Anzahl aller gesch|fffd|tzten Worksheets
Public protectedWorksheets As Long
Public unprotectedWorksheets As Long
Public protectedWorksheetsWithPassword As Long
Public crackedWorksheetsWithPassword As Long
Public protectedWorksheetsWithoutPassword As Long
  


Public m_Clones As Collection
Public m_FoundFuncs As Collection

Public wbvars As XLScriptArray2D
Public tabProt As Object
Public unlockedFormulaAreas As Object
Public errorFormulaCells As Object
Public errorFormulaValueCells As Object
Public hiddenSheets As Object
Public hiddenColumns As Object
Public hiddenRows As Object
Public hiddenColumnsRanges As Object
Public hiddenRowsRanges As Object
Public externalFiles As Object
Public missingexternalFiles As Object
Public mods As Object
Public sda As Object
Public dda As Object
Public nonAnalyzableCells As Object
Public circref As XLScriptArray2D

Public foundCellreferencesAmount As Long
Public foundCellreferencesDuplicateAmount As Long



' -----------------------------------------------
' TAB Stuff
' -----------------------------------------------

  Public tabTotalUsedCellAmount As Long
  Public tabFoundFormulaAmount As Long
  Public tabFoundIfAmount As Long
  Public tabFoundCalcAmount As Long
  Public tabFoundSumAmount As Long
  Public tabFoundMatrixFuncs As Long
  Public tabFoundMatrixDuplicateFuncs As Long
  Public tabFoundUnlockedFormulas As Long
  Public tabFoundLockedFormulasMissingSheetprotect As Long
  Public tabFoundLockedFormulasWithoutSheetpassword As Long
  Public tabFoundUnlockedFormulasNotVisible As Long
  Public tabFoundHiddenColumnAmount As Long
  Public tabFoundHiddenRowAmount As Long
  Public tabFoundHiddenWorksheetsAmount As Long
  Public tabFoundVeryHiddenWorksheetsAmount As Long
  Public tabFoundCellsWithExternalReferences As Long
  Public tabFoundFormulaDuplicateAmount As Long
  Public tabFoundIfDuplicateAmount As Long
  Public tabFoundCalcDuplicateAmount As Long
  Public tabFoundSumDuplicateAmount As Long
  Public tabFoundDiagrams As Long
  Public tabFoundHyperlinks As Long
  Public tabFoundInternalHyperlinks As Long
  Public tabFoundExternalHyperlinks As Long
  Public tabFoundNonAnalyzableCells As Long
  Public tabLongestFormula As Long
  Public tabMaxopenbracam As Long
  Public tabFoundCellreferencesAmount As Long
  Public tabFoundCellreferencesDuplicateAmount As Long


  Public m_Dimension As Dimension
  Public m_TabDimension As Dimension
  
  Public m_CUnlockedFormulas As Collection
  Public m_CErrorFormulas As Collection
  Public m_CErrorFormulaValues As Collection

Function IsErrorItemValue(item) As Boolean
On Error GoTo yeserror
  Dim s As String
  s = CStr(item.Value)
  IsErrorItemValue = False
  Exit Function

yeserror:
  IsErrorItemValue = True
End Function

Public Sub InitWB(owbook As Workbook)
  Set oxlwbook = owbook

  Dim item
  
  Dim arr As XLScriptArray
  Set arr = wbvars.AddXLScriptArray("BUILTINPROPERTIES")
  For Each item In oxlwbook.BuiltinDocumentProperties
'    Debug.Print item.name
    If Not IsErrorItemValue(item) Then
      If Len(CStr(item.Value)) > 0 Then
        If TextExists(item.name) Then
          arr.AddNameAndValue STexte(item.name), CStr(item.Value)
        Else
          arr.AddNameAndValue item.name, CStr(item.Value)
        End If
      End If
    End If
  Next item
    
  Set arr = wbvars.AddXLScriptArray("CUSTOMDOCUMENTPROPERTIES")
  For Each item In oxlwbook.CustomDocumentProperties
'    Debug.Print item.name
    If Not IsErrorItemValue(item) Then
      If Len(CStr(item.Value)) > 0 Then
        If TextExists(item.name) Then
          arr.AddNameAndValue STexte(item.name), CStr(item.Value)
        Else
          arr.AddNameAndValue item.name, CStr(item.Value)
        End If
      End If
    End If
  Next item




End Sub

Public Sub Init(fname As String, M As Long)

  Filename = fname
  Mode = M
  
  Set m_Dimension = New Dimension
  Set m_TabDimension = New Dimension
  
  Set m_CUnlockedFormulas = New Collection
  Set m_CErrorFormulas = New Collection
  Set m_CErrorFormulaValues = New Collection
  
  m_Dimension.m_X = 0
  m_Dimension.m_Y = 0
  m_Dimension.m_XY = 0
  m_Dimension.m_Z = 0

  ' Initialisierung f|fffd|r Z|fffd|hlvariablen
  foundFormulaAmount = 0
  foundMatrixFuncs = 0
  foundMatrixDuplicateFuncs = 0
  foundFormulaDuplicateAmount = 0
  foundSumDuplicateAmount = 0
  foundCalcDuplicateAmount = 0
  foundIfDuplicateAmount = 0
  ' Alle Summenformeln (z.B. =SUMME(A4:A7)
  foundSumAmount = 0
  ' Alle mathematischen Formeln (z.B. A3 + A5 * A9)
  foundCalcAmount = 0
  ' Versteckte Zeilen, Spalten und Tabellen
  foundHiddenColumnAmount = 0
  foundHiddenRowAmount = 0
  foundHiddenColumnAmountCount = 0
  foundHiddenRowAmountCount = 0
  foundUnlockedFormulas = 0
  foundLockedFormulasMissingSheetprotect = 0
  foundLockedFormulasWithoutSheetpassword = 0
  foundUnlockedFormulasNotVisible = 0
  foundHiddenWorksheetsAmount = 0
  foundVeryHiddenWorksheetsAmount = 0
  foundCellreferencesAmount = 0
  ' Code Module
  foundCodeModules = 0
  ' Wieviele Formeln mit WENN-Bedingungen gibt es
  foundIfAmount = 0
  
  ' Z|fffd|hler f|fffd|r externe Referenzen initialisieren
  foundCellsWithExternalReferences = 0
  foundExternalReferences = 0
  
  foundNonAnalyzableCells = 0
  
  ' Alles was mit Schutz zu tun hat
  protectedWorksheets = 0
  unprotectedWorksheets = 0
  protectedWorksheetsWithPassword = 0
  crackedWorksheetsWithPassword = 0
  protectedWorksheetsWithoutPassword = 0
  foundDiagrams = 0
  foundHyperlinks = 0
  foundInternalHyperlinks = 0
  foundExternalHyperlinks = 0

  
  checksum = 0
  
  ' Initialisierung Laufvariablen
  totalCellAmount = 0
  totalUsedCellAmount = 0
  totalWorkbookCheckAmount = 0
  
  longestFormula = 0
  maxopenbracam = 0
  


  Set protectedSheetsColl = New Collection
  
  Set m_Clones = New Collection
  Set m_FoundFuncs = New Collection

  ' --------------------------------------------------------
  ' Script Engine stuff
  ' --------------------------------------------------------

  ' SpecialCells Zeug
  XLScriptAddSimpleVar "NUMBERAMOUNT", ""
  XLScriptAddSimpleVar "TEXTAMOUNT", ""
  XLScriptAddSimpleVar "BOOLAMOUNT", ""
  XLScriptAddSimpleVar "FORMULANUMBERAMOUNT", ""
  XLScriptAddSimpleVar "FORMULATEXTAMOUNT", ""
  XLScriptAddSimpleVar "FORMULABOOLAMOUNT", ""
  XLScriptAddSimpleVar "FORMULAERRORAMOUNT", "0"
  XLScriptAddSimpleVar "FORMULAVALUEERRORAMOUNT", "0"
  XLScriptAddSimpleVar "ERRORNULLAM", "0"
  XLScriptAddSimpleVar "ERRORDIV0AM", "0"
  XLScriptAddSimpleVar "ERRORVALUEAM", "0"
  XLScriptAddSimpleVar "ERRORREFAM", "0"
  XLScriptAddSimpleVar "ERRORNAMEAM", "0"
  XLScriptAddSimpleVar "ERRORNUMAM", "0"
  XLScriptAddSimpleVar "ERRORNAAM", "0"
  
  XLScriptAddSimpleVar "FILE", Filename
  XLScriptAddSimpleVar "NAME", Filename
  XLScriptAddSimpleVar "SAVEDATE", Format(FileDateTime(Filename), "Short Date") & " - " & Format(FileDateTime(Filename), "Short Time")
  XLScriptAddSimpleVar "FILESIZEKB", CLng(FileLen(Filename) / 1024)
  XLScriptAddSimpleVar "FILESIZE", FileLen(Filename)


  Set wbvars = XLScriptAddArray2D("WB")
  
  
  
  
  
  Set tabProt = XLScriptAddArray("TABLEPROTECTION")
  Set unlockedFormulaAreas = XLScriptAddArray("UNLOCKEDFORMULAAREAS")
  
  ' XXX EINBAUEN
  Set errorFormulaCells = XLScriptAddArray("ERRORFORMULAAREAS")
  Set errorFormulaValueCells = XLScriptAddArray("ERRORFORMULAVALUEAREAS")
  ' XXX EINBAUEN
  Set nonAnalyzableCells = XLScriptAddArray("NONANALYZABLECELLS")
  
  Set hiddenSheets = XLScriptAddArray("HIDDENSHEETS")
  Set hiddenColumns = XLScriptAddArray("HIDDENCOLUMNS")
  Set hiddenRows = XLScriptAddArray("HIDDENROWS")
  
  Set hiddenColumnsRanges = New Collection
  Set hiddenRowsRanges = New Collection
  
  Set externalFiles = XLScriptAddArray("EXTERNALFILES")
  ' XXX EINBAUEN
  Set missingexternalFiles = XLScriptAddArray("MISSINGEXTERNALFILES")
  ' XXX EINBAUEN
  Set mods = XLScriptAddArray("MODULES")
  
  Set sda = XLScriptAddArray2D("SHEETS")
  ' XXX EINBAUEN
  Set dda = XLScriptAddArray2D("DIAGRAMS")
  
  Set circref = XLScriptAddArray2D("SHEETSWITHCIRCULARREFERENCES")
  
End Sub



Public Sub SetTab()

    m_TabDimension.m_X = 0
    m_TabDimension.m_Y = 0
    m_TabDimension.m_XY = 0
    m_TabDimension.m_Z = 0

    tabTotalUsedCellAmount = totalUsedCellAmount
    tabFoundFormulaAmount = foundFormulaAmount
    tabFoundIfAmount = foundIfAmount
    tabFoundCalcAmount = foundCalcAmount
    tabFoundSumAmount = foundSumAmount
    tabFoundMatrixFuncs = foundMatrixFuncs
    tabFoundMatrixDuplicateFuncs = foundMatrixDuplicateFuncs
    tabFoundCellreferencesAmount = foundCellreferencesAmount
    tabFoundCellreferencesDuplicateAmount = foundCellreferencesDuplicateAmount
    tabFoundUnlockedFormulas = foundUnlockedFormulas
    tabFoundLockedFormulasMissingSheetprotect = foundLockedFormulasMissingSheetprotect
    tabFoundLockedFormulasWithoutSheetpassword = foundLockedFormulasWithoutSheetpassword
    tabFoundUnlockedFormulasNotVisible = foundUnlockedFormulasNotVisible
    tabFoundHiddenColumnAmount = foundHiddenColumnAmount
    tabFoundHiddenRowAmount = foundHiddenRowAmount
    tabFoundHiddenWorksheetsAmount = foundHiddenWorksheetsAmount
    tabFoundVeryHiddenWorksheetsAmount = foundVeryHiddenWorksheetsAmount
    tabFoundCellsWithExternalReferences = foundCellsWithExternalReferences
    tabFoundFormulaDuplicateAmount = foundFormulaDuplicateAmount
    tabFoundIfDuplicateAmount = foundIfDuplicateAmount
    tabFoundCalcDuplicateAmount = foundCalcDuplicateAmount
    tabFoundSumDuplicateAmount = foundSumDuplicateAmount
    tabFoundDiagrams = foundDiagrams
    tabFoundHyperlinks = foundHyperlinks
    tabFoundInternalHyperlinks = foundInternalHyperlinks
    tabFoundExternalHyperlinks = foundExternalHyperlinks
    tabFoundNonAnalyzableCells = foundNonAnalyzableCells
    tabLongestFormula = 0
    tabMaxopenbracam = 0

End Sub





Sub AnalyzeCodeModules()
  On Error GoTo nogo
  ' Bevor irgendetwas berchnet wird, kann gleich ausgegeben werden,
  ' ob es sich hier um ein Sheet mit Programmmodulen handelt.
  ' Wenn dies der Fall ist, hat sich die gesamte Berechnung
  ' eigentlich erledigt.
  Dim cm
  Dim counter As Long
  If VBAFailure = 0 Then
    For Each cm In oxlwbook.VBProject.VBComponents
      If Not IsNull(cm) Then
        If cm.CodeModule.CountOfLines > 0 Then
          Dim tLine As String
          tLine = cm.CodeModule.Lines(1, cm.CodeModule.CountOfLines)
          For counter = 1 To Len(tLine)
            checksum = (checksum + CLng(Asc(Mid(tLine, counter, 1))) * counter) Mod ChecksumMod
          Next counter
          Dim red As String
          red = Trim(RemoveCommentsAndLineFeeds(tLine))
          If Len(red) > 0 Then
            If UCase(Left(red, 15)) <> "OPTION EXPLICIT" Or Len(red) <> 15 Then
              foundCodeModules = foundCodeModules + 1
            End If
          End If
        End If
      End If
    Next
  
    XLScriptAddSimpleVar "MODULEAMOUNT", foundCodeModules
  ElseIf VBAFailure = 1 Then
    XLScriptAddSimpleVar "MODULEAMOUNT", "Gesch" ' Texte(GSprache, TXT_GESCH|fffd|TZT)
  Else
    XLScriptAddSimpleVar "MODULEAMOUNT", "NE" ' Texte(GSprache, TXT_NICHTERMITTELBAR)
  End If
  
  AddStatus "Module analysiert"
  Exit Sub
nogo:
  XLScriptAddSimpleVar "MODULEAMOUNT", "NE" ' Texte(GSprache, TXT_NICHTERMITTELBAR)
End Sub



Function CountCells() As Boolean

  '-------------------------------------
  ' Zellen z|fffd|hlen
  '-------------------------------------
  totalCellAmount = 0
  Dim oXLWsheet As Worksheet
  For Each oXLWsheet In oxlwbook.Worksheets
    ' und wird auch nur dann ausgef|fffd|hrt, wenn es wirklich
    ' ein Worksheet ist.
    If TypeName(oXLWsheet) = "Worksheet" Then
        totalCellAmount = totalCellAmount + oXLWsheet.UsedRange.count
    End If
  Next
  
  If totalCellAmount = 0 Then
    XLScriptAddSimpleVar "USEDCELLAMOUNT", "Texte(GSprache, TXT_KEINEZELLEN)"
    CountCells = False
  Else
    CountCells = True
  End If
End Function


Sub CheckProtectedWorkbook()
  
  '-------------------------------------
  ' Workbook gesch|fffd|tzt?
  '-------------------------------------
  If oxlwbook.ProtectStructure = True Or oxlwbook.ProtectWindows = True Then
    If WorkbookHasPassword(oxlwbook) Then
      XLScriptAddSimpleVar "WBPROTECTED", Texte(GSprache, TXT_JAMITPW)
    Else
      XLScriptAddSimpleVar "WBPROTECTED", Texte(GSprache, TXT_JAOHNEPW)
    End If
    
    ' Struturschutz
    If oxlwbook.ProtectStructure = True Then
      XLScriptAddSimpleVar "STRUCTUREPROTECTED", Texte(GSprache, TXT_JA)
    Else
      XLScriptAddSimpleVar "STRUCTUREPROTECTED", Texte(GSprache, TXT_NEIN)
    End If
      
    ' Fensterschutz
    If oxlwbook.ProtectWindows = True Then
      XLScriptAddSimpleVar "WINDOWSPROTECTED", Texte(GSprache, TXT_JA)
    Else
      XLScriptAddSimpleVar "WINDOWSPROTECTED", Texte(GSprache, TXT_NEIN)
    End If
  Else
    XLScriptAddSimpleVar "WBPROTECTED", Texte(GSprache, TXT_NEIN)
    XLScriptAddSimpleVar "STRUCTUREPROTECTED", Texte(GSprache, TXT_NEIN)
    XLScriptAddSimpleVar "WINDOWSPROTECTED", Texte(GSprache, TXT_NEIN)
  End If
End Sub


Sub GetNames()
  '---------------------------------------
  ' Namensliste ausgeben
  '---------------------------------------
  Dim nameItem As name
  Dim da As Object
  Set da = XLScriptAddArray2D("NAMES")
  
  If FullVersion Then
    For Each nameItem In oxlwbook.Names
      If Left(nameItem.name, 11) <> "_IDVTracker" Then
        da.AddLine
        da.AddValue "NAME", nameItem.Parent.name & " - " & nameItem.NameLocal
  '      da.AddValue "TYPE", "N"
        If nameItem.Visible = True Then
          da.AddValue "VISIBLE", Texte(GSprache, TXT_SB)
        Else
          da.AddValue "VISIBLE", Texte(GSprache, TXT_USB)
        End If
        da.AddValue "REFERSTO", "'" & nameItem.RefersToLocal
        
        
        If nameItem.Visible = True Then
          If Right(nameItem.name, Len("!Print_Area")) <> "!Print_Area" Then
            Dim counter As Long
            For counter = 1 To Len(nameItem.RefersToLocal)
              checksum = (checksum + CLng(Asc(Mid(nameItem.RefersToLocal, counter, 1))) * counter) Mod ChecksumMod
            Next counter
          End If
        End If
      End If
    Next nameItem
  End If
End Sub



Sub CheckExternalReferences()
  On Error GoTo nogo
  Dim aLinks
  Dim i As Long
  aLinks = ActiveWorkbook.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
        If Not FileExists(GetUNCPath(CStr(aLinks(i)))) Then
          If FullVersion = True Or missingexternalFiles.items.count <= 3 Then
            missingexternalFiles.AddValue "", LongFileName(GetUNCPath(CStr(aLinks(i))))
          Else
            missingexternalFiles.AddValue "", "Demo"
          End If
        Else
          If FullVersion = True Or i <= 3 Then
            externalFiles.AddValue "", LongFileName(GetUNCPath(CStr(aLinks(i))))
          Else
            externalFiles.AddValue "", "Demo"
          End If
        End If
      Next i
      foundExternalReferences = UBound(aLinks)
  End If
  Exit Sub
nogo:
  foundExternalReferences = 0
  
End Sub

Sub RemoveSheetPasswords()
  
  ' Passw|fffd|rter von allen Sheets entfernen
  Dim xlsheetamount As Long
  xlsheetamount = 0
  
  AddStatus "Entferne Passwort aus Tabellen"
  Dim oXLWsheet As Worksheet
  For Each oXLWsheet In oxlwbook.Worksheets
    If TypeName(oXLWsheet) = "Worksheet" Then
      xlsheetamount = xlsheetamount + 1
      ' Ist ein Blattschutz vorhanden?
      If oXLWsheet.ProtectContents = True Then
        ' Sehr sch|fffd|n, dann schaun wir mal, ob auch ein Passwort daf|fffd|r eingesetzt wurde
        If Not SheetHasPassword(oXLWsheet) Then
          protectedSheetsColl.Add 1, oXLWsheet.name
        Else
          protectedSheetsColl.Add 2, oXLWsheet.name
      
          ' Die Tabelle cracken!
          If Left(Application.Version, 3) = "8.0" Then
            CrackSheet oXLWsheet
          End If
          
          If oXLWsheet.ProtectContents = True Then
            RemovePW oXLWsheet
          End If
    
          If oXLWsheet.ProtectContents = False Then
            crackedWorksheetsWithPassword = crackedWorksheetsWithPassword + 1
          End If
        
        End If
      Else
        protectedSheetsColl.Add 0, oXLWsheet.name
      End If
    
'      Dim formulaCells As Range
'      Set formulaCells = GetFormulaRange(oXLWsheet)
'      If Not formulaCells Is Nothing Then
'        totalWorkbookCheckAmount = totalWorkbookCheckAmount + formulaCells.count
'      End If
    
    End If
  Next oXLWsheet
  
'  AddStatus "Passw|fffd|rter entfernen beendet"
  
End Sub

Sub CheckSheetProtection(oXLWsheet As Worksheet)
      
  Dim protectionString As String
  protectionString = ""
  ' Ist ein Blattschutz vorhanden?
  If protectedSheetsColl(oXLWsheet.name) > 0 Then
    protectedWorksheets = protectedWorksheets + 1
    ' Sehr sch|fffd|n, dann schaun wir mal, ob auch ein Passwort daf|fffd|r eingesetzt wurde
    If protectedSheetsColl(oXLWsheet.name) = 1 Then
        ' Wenn's bis hierhin durchgeht, dann war kein Passwort drauf!!!!
        protectionString = protectionString + "P "
        protectedWorksheetsWithoutPassword = protectedWorksheetsWithoutPassword + 1
    Else
        protectedWorksheetsWithPassword = protectedWorksheetsWithPassword + 1
    End If
  Else
    protectionString = protectionString + Texte(GSprache, TXT_BLATTSCHUTZFEHLT)
    unprotectedWorksheets = unprotectedWorksheets + 1
  End If
  
  ' Objekte
  If oXLWsheet.ProtectDrawingObjects = False Then
    protectionString = protectionString + "O "
  End If
  
  ' Szenarios
  If oXLWsheet.ProtectScenarios = False Then
    protectionString = protectionString + Texte(GSprache, TXT_SZENARIOSCHUTZFEHLT)
  End If
  
  If Len(protectionString) > 0 Then
    If FullVersion = True Or tabProt.items.count <= 3 Then
      tabProt.AddValue "", oXLWsheet.name & " (" & Left(protectionString, Len(protectionString) - 1) & ")"
    Else
      tabProt.AddValue "", "Demo"
    End If
  End If

End Sub

Sub CalculateSheetNameChecksum(oXLWsheet As Worksheet)
  ' Checksumme auf Namen berechnen
  Dim nameItem As name
  For Each nameItem In oxlwbook.Names
      If Left(nameItem.name, 11) <> "_IDVTracker" Then
          Dim counter As Long
          For counter = 1 To Len(nameItem.RefersToLocal)
            checksum = (checksum + CLng(Asc(Mid(nameItem.RefersToLocal, counter, 1))) * counter) Mod ChecksumMod
          Next counter
      End If
  Next nameItem
End Sub


Sub CheckDiagrams(oXLWsheet As Worksheet)
      
   ' Diagramme betrachten
   Dim coitem As ChartObject
   Dim cgitem As ChartGroup
   Dim scitem As Series
   
   If oXLWsheet.ChartObjects.count > 0 Then
     For Each coitem In oXLWsheet.ChartObjects
       foundDiagrams = foundDiagrams + 1
       
'       Dim dda As XLScriptArray2D
'       Set dda = da.AddArr("DIAGRAMS")
       
       
       For Each cgitem In coitem.Chart.ChartGroups
         For Each scitem In cgitem.SeriesCollection
           If IsReadableFormula(scitem) Then
             Dim counter As Long
             For counter = 1 To Len(scitem.Formula)
               checksum = (checksum + CLng(Asc(Mid(scitem.Formula, counter, 1))) * counter) Mod ChecksumMod
             Next counter
             dda.AddLine
             dda.AddValue "NAME", coitem.Chart.name
'                dda.AddValue "TYPE", "D"
             dda.AddValue "REFERSTO", "'" & scitem.Formula
'                Write #myOutputFile, "NextName", ""
           End If
         Next scitem
       Next cgitem
     Next coitem
   End If
End Sub



Function StoreErrorType(ByRef c As Range, analysetyp As String) As Long
  On Error Resume Next
  StoreErrorType = 0
  Select Case c.Value
    Case CVErr(xlErrNull)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNULLAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNULLAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNULLAM").m_Value) + 1)
      StoreErrorType = 1
    Case CVErr(xlErrDiv0)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORDIV0AM", 1
      End If
      XLScriptGetSimpleVar("ERRORDIV0AM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORDIV0AM").m_Value) + 1)
      StoreErrorType = 2
    Case CVErr(xlErrValue)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORVALUEAM", 1
      End If
      XLScriptGetSimpleVar("ERRORVALUEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORVALUEAM").m_Value) + 1)
      StoreErrorType = 2
    Case CVErr(xlErrRef)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORREFAM", 1
      End If
      XLScriptGetSimpleVar("ERRORREFAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORREFAM").m_Value) + 1)
      StoreErrorType = 1
    Case CVErr(xlErrName)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNAMEAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNAMEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAMEAM").m_Value) + 1)
      StoreErrorType = 1
    Case CVErr(xlErrNum)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNUMAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNUMAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNUMAM").m_Value) + 1)
      StoreErrorType = 2
    Case CVErr(xlErrNA)
      If analysetyp <> "m" Then
        sda.AddValue "ERRORNAAM", 1
      End If
      XLScriptGetSimpleVar("ERRORNAAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAAM").m_Value) + 1)
      StoreErrorType = 2
  End Select
End Function



'#If DoProfile Then
'Sub StoreSheetCellTypeNumbers(oXLWsheet As Worksheet, analysetyp As String, ByRef hrt As HighResTimer)
'#Else
Sub StoreSheetCellTypeNumbers(oXLWsheet As Worksheet, analysetyp As String)
  Exit Sub
'#End If
  '**************************************************
  ' Special Cells Zeug
  '**************************************************
  
  Dim numberamount As Long
  Dim textamount As Long
  Dim boolamount As Long
  Dim formulanumberamount As Long
  Dim formulatextamount As Long
  Dim formulaboolamount As Long
  Dim formulaerroramount As Long
  
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeConstants1"
' #End If
'   numberamount = GetAmountType(oXLWsheet, xlCellTypeConstants, 1)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeConstants1"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeConstants2"
' #End If
'   textamount = GetAmountType(oXLWsheet, xlCellTypeConstants, 2)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeConstants2"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeConstants4"
' #End If
'   boolamount = GetAmountType(oXLWsheet, xlCellTypeConstants, 4)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeConstants4"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeFormulas1"
' #End If
'   formulanumberamount = GetAmountType(oXLWsheet, xlCellTypeFormulas, 1)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeFormulas1"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeFormulas2"
' #End If
'   formulatextamount = GetAmountType(oXLWsheet, xlCellTypeFormulas, 2)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeFormulas2"
' #End If
'   DoEvents
'   SetLiveStatus
  
' #If DoProfile Then
'   hrt.StartCounting "xlCellTypeFormulas4"
' #End If
'   formulaboolamount = GetAmountType(oXLWsheet, xlCellTypeFormulas, 4)
' #If DoProfile Then
'   hrt.StopCounting "xlCellTypeFormulas4"
' #End If
'   DoEvents
'   SetLiveStatus
  
  Dim nullam As Long, div0am  As Long, valueam As Long, refam As Long, nameam As Long, numam As Long, naam As Long
  formulaerroramount = GetAmountErrors(oXLWsheet, nullam, div0am, valueam, refam, nameam, numam, naam)
 
  DoEvents
  SetLiveStatus
  
  XLScriptGetSimpleVar("NUMBERAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("NUMBERAMOUNT").m_Value) + numberamount)
  XLScriptGetSimpleVar("TEXTAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("TEXTAMOUNT").m_Value) + textamount)
  XLScriptGetSimpleVar("BOOLAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("BOOLAMOUNT").m_Value) + boolamount)
  XLScriptGetSimpleVar("FORMULANUMBERAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULANUMBERAMOUNT").m_Value) + formulanumberamount)
  XLScriptGetSimpleVar("FORMULATEXTAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULATEXTAMOUNT").m_Value) + formulatextamount)
  XLScriptGetSimpleVar("FORMULABOOLAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULABOOLAMOUNT").m_Value) + formulaboolamount)
  XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value) + formulaerroramount)
  
  XLScriptGetSimpleVar("ERRORNULLAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNULLAM").m_Value) + nullam)
  XLScriptGetSimpleVar("ERRORDIV0AM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORDIV0AM").m_Value) + div0am)
  XLScriptGetSimpleVar("ERRORVALUEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORVALUEAM").m_Value) + valueam)
  XLScriptGetSimpleVar("ERRORREFAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORREFAM").m_Value) + refam)
  XLScriptGetSimpleVar("ERRORNAMEAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAMEAM").m_Value) + nameam)
  XLScriptGetSimpleVar("ERRORNUMAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNUMAM").m_Value) + numam)
  XLScriptGetSimpleVar("ERRORNAAM").m_Value = CStr(Val(XLScriptGetSimpleVar("ERRORNAAM").m_Value) + naam)
  
  
  If analysetyp <> "m" Then
    sda.AddValue "NUMBERAMOUNT", CStr(numberamount)
    sda.AddValue "TEXTAMOUNT", CStr(textamount)
    sda.AddValue "BOOLAMOUNT", CStr(boolamount)
    sda.AddValue "FORMULANUMBERAMOUNT", CStr(formulanumberamount)
    sda.AddValue "FORMULATEXTAMOUNT", CStr(formulatextamount)
    sda.AddValue "FORMULABOOLAMOUNT", CStr(formulaboolamount)
    sda.AddValue "FORMULAERRORAMOUNT", CStr(formulaerroramount)
  
    sda.AddValue "ERRORNULLAM", CStr(nullam)
    sda.AddValue "ERRORDIV0AM", CStr(div0am)
    sda.AddValue "ERRORVALUEAM", CStr(valueam)
    sda.AddValue "ERRORREFAM", CStr(refam)
    sda.AddValue "ERRORNAMEAM", CStr(nameam)
    sda.AddValue "ERRORNUMAM", CStr(numam)
    sda.AddValue "ERRORNAAM", CStr(naam)
  
  End If
  
End Sub


Sub CheckSheetVisibility(oXLWsheet As Worksheet)
      
  ' Existiert ein "unsichtbares" worksheet?
  If oXLWsheet.Visible <> xlSheetVisible Then
    
    If oXLWsheet.Visible = xlSheetVeryHidden Then
      foundVeryHiddenWorksheetsAmount = foundVeryHiddenWorksheetsAmount + 1
    End If
    
    ' Text speichern
    If StartEnums + foundHiddenWorksheetsAmount <= 65536 Then
      If FullVersion = True Or hiddenSheets.items.count <= 3 Then
        If oXLWsheet.Visible = xlSheetVeryHidden Then
          hiddenSheets.AddValue "", oXLWsheet.name & Texte(GSprache, TXT_SV)
        Else
          hiddenSheets.AddValue "", oXLWsheet.name
        End If
      Else
          hiddenSheets.AddValue "", "Demo"
      End If
    End If
  
    ' Und einblenden...
'          If Not oXLWbook.ProtectStructure Then
      oXLWsheet.Visible = xlSheetVisible
'          End If
    
    foundHiddenWorksheetsAmount = foundHiddenWorksheetsAmount + 1
  End If
End Sub

Function GetColumString(ByVal c As Long) As String

  Dim r As Range
  Set r = Cells(1, c)
  GetColumString = StripChars(r.Address, "$0123456789")
End Function

Sub CreateHiddenStuff()
  Dim c As Collection
  Dim i As Long
  Dim cr As CrunchRange
  Dim found As Boolean
  
  If FullVersion = False Then
    hiddenColumns.AddValue "", "Demo"
  Else
    For Each cr In hiddenColumnsRanges
      hiddenColumns.AddValue "", Texte(GSprache, TXT_TABK) & ": '" & cr.m_Name & "', " & Texte(GSprache, TXT_SPALTEK) & ": " & IIf(cr.m_Von = cr.m_Bis, GetColumString(cr.m_Von), GetColumString(cr.m_Von) & ":" & GetColumString(cr.m_Bis))
    Next cr
  End If


  If FullVersion = False Then
    hiddenRows.AddValue "", "Demo"
  Else
    For Each cr In hiddenRowsRanges
      hiddenRows.AddValue "", Texte(GSprache, TXT_TABK) & ": '" & cr.m_Name & "', " & Texte(GSprache, TXT_ZEILEK) & ": " & IIf(cr.m_Von = cr.m_Bis, cr.m_Von, cr.m_Von & ":" & cr.m_Bis)
    Next cr
  End If
End Sub


Sub CheckHiddenColumns(oXLWsheet As Worksheet)
  
  Dim c As Range
  Dim tColumn                   As String
  
  For Each c In oXLWsheet.Columns
    ' Ist die Spalte des Textes sichtbar???
    If c.ColumnWidth <= 0 Then
      
      Dim cr As CrunchRange
      Dim found As Boolean
      found = False
      For Each cr In hiddenColumnsRanges
        If cr.InRange(oXLWsheet.name, c.Column, True) Then
            found = True
            Exit For
        End If
      Next cr
      If Not found Then
        Set cr = New CrunchRange
        cr.Initialize oXLWsheet.name, c.Column
        hiddenColumnsRanges.Add cr
      End If

      foundHiddenColumnAmountCount = foundHiddenColumnAmountCount + 1
      foundHiddenColumnAmount = foundHiddenColumnAmount + 1
    End If
  Next c
End Sub


Sub CheckHiddenRows(oXLWsheet As Worksheet)
  
  Dim c As Range
  For Each c In oXLWsheet.UsedRange.Rows
    If c.RowHeight <= 0 Then
      If c.Column = 1 Then
        
        Dim cr As CrunchRange
        Dim found As Boolean
        found = False
        For Each cr In hiddenRowsRanges
          If cr.InRange(oXLWsheet.name, c.Row, True) Then
              found = True
              Exit For
          End If
        Next cr
        If Not found Then
          Set cr = New CrunchRange
          cr.Initialize oXLWsheet.name, c.Row
          hiddenRowsRanges.Add cr
        End If
        
        foundHiddenRowAmountCount = foundHiddenRowAmountCount + 1
        foundHiddenRowAmount = foundHiddenRowAmount + 1
      End If
    End If
  Next c
End Sub

Function FormulaR1C1Readable(ByRef c As Range) As Boolean
  Dim s As String
  On Error GoTo notReadable
  s = c.FormulaR1C1
  FormulaR1C1Readable = True
  Exit Function
  
notReadable:
  FormulaR1C1Readable = False
End Function

Function IsClone(ByRef c As Range, ByRef cs As CloneStuff) As Boolean
  
  If Not FormulaR1C1Readable(c) Then
    IsClone = False
    Exit Function
  End If

  On Error GoTo notExistant
  Dim a As String
  a = c.FormulaR1C1
  Set cs = m_Clones(a)
  IsClone = True
  Exit Function
notExistant:
  IsClone = False
  Set cs = New CloneStuff
  m_Clones.Add cs, a
End Function


Sub StoreCellList(oXLWsheet As Worksheet, ByRef c As Collection, ByRef xlsarr As XLScriptArray)
    Dim item As Range
    Dim cs As String
    Dim r As Range
    If c.count > 0 Then
      For Each item In c
        If r Is Nothing Then
          Set r = item
         Else
          Set r = Union(r, item)
        End If
      Next item
      Dim r2 As Range
      For Each r2 In r.Areas
        If FullVersion = True Or xlsarr.items.count <= 3 Then
          xlsarr.AddValue "", oXLWsheet.name & "!" & StripChars(r2.Address, "$")
        Else
          xlsarr.AddValue "", "Demo"
        End If
      Next r2
    End If

End Sub

Sub StoreSheetResulsts(oXLWsheet As Worksheet)

    StoreCellList oXLWsheet, m_CUnlockedFormulas, unlockedFormulaAreas
    Set m_CUnlockedFormulas = New Collection
    
    StoreCellList oXLWsheet, m_CErrorFormulas, errorFormulaCells
    Set m_CErrorFormulas = New Collection
    
    StoreCellList oXLWsheet, m_CErrorFormulaValues, errorFormulaValueCells
    Set m_CErrorFormulaValues = New Collection
    
    ' Die Ergebnisse
    sda.AddValue "NAME", oXLWsheet.name
    sda.AddValue "USEDCELLAMOUNT", totalUsedCellAmount - tabTotalUsedCellAmount
    sda.AddValue "FORMULAAMOUNT", foundFormulaAmount - tabFoundFormulaAmount
    
      
    ' *********************
    ' Und die Tabellenmappe
    ' *********************
    sda.AddValue "IFAMOUNT", foundIfAmount - tabFoundIfAmount
    sda.AddValue "CALCAMOUNT", foundCalcAmount - tabFoundCalcAmount
    If FullVersion Then
      sda.AddValue "SUMAMOUNT", foundSumAmount - tabFoundSumAmount
    Else
      sda.AddValue "SUMAMOUNT", "Demo"
    End If
    sda.AddValue "MATRIXAMOUNT", foundMatrixFuncs - tabFoundMatrixFuncs
    sda.AddValue "CELLREFERENCESAMOUNT", foundCellreferencesAmount - tabFoundCellreferencesAmount
    sda.AddValue "UNLOCKEDFORMULAS", foundUnlockedFormulas - tabFoundUnlockedFormulas
    sda.AddValue "UNLOCKEDFORMULASMISSINGSHEETPROTECTION", foundLockedFormulasMissingSheetprotect - tabFoundLockedFormulasMissingSheetprotect
    sda.AddValue "LOCKEDFORMULASWITHOUTSHEETPASSWORD", foundLockedFormulasWithoutSheetpassword - tabFoundLockedFormulasWithoutSheetpassword
    sda.AddValue "UNLOCKEDFORMULASNOTVISIBLE", foundUnlockedFormulasNotVisible - tabFoundUnlockedFormulasNotVisible
    sda.AddValue "HIDDENCOLUMNAMOUNT", foundHiddenColumnAmount - tabFoundHiddenColumnAmount
    sda.AddValue "HIDDENROWAMOUNT", foundHiddenRowAmount - tabFoundHiddenRowAmount
    If FullVersion Then
      sda.AddValue "HIDDENSHEETAMOUNT", foundHiddenWorksheetsAmount - tabFoundHiddenWorksheetsAmount - (foundVeryHiddenWorksheetsAmount - tabFoundVeryHiddenWorksheetsAmount)
    Else
      sda.AddValue "HIDDENSHEETAMOUNT", "Demo"
    End If
    
    sda.AddValue "VERYHIDDENSHEETAMOUNT", foundVeryHiddenWorksheetsAmount - tabFoundVeryHiddenWorksheetsAmount
    
    sda.AddValue "CELLSWITHEXTERNALREFERENCESAMOUNT", foundCellsWithExternalReferences - tabFoundCellsWithExternalReferences
    
    If FullVersion Then
      sda.AddValue "FORMULADUPAMOUNT", foundFormulaDuplicateAmount - tabFoundFormulaDuplicateAmount
      sda.AddValue "FORMULAINDIVAMOUNT", foundFormulaAmount - tabFoundFormulaAmount - (foundFormulaDuplicateAmount - tabFoundFormulaDuplicateAmount)
    Else
      sda.AddValue "FORMULADUPAMOUNT", "Demo"
      sda.AddValue "FORMULAINDIVAMOUNT", "Demo"
    End If
    
    sda.AddValue "IFDUPAMOUNT", foundIfDuplicateAmount - tabFoundIfDuplicateAmount
    sda.AddValue "IFINDIVAMOUNT", foundIfAmount - tabFoundIfAmount - (foundIfDuplicateAmount - tabFoundIfDuplicateAmount)
    
    sda.AddValue "CALCDUPAMOUNT", foundCalcDuplicateAmount - tabFoundCalcDuplicateAmount
    sda.AddValue "CALCINDIVAMOUNT", foundCalcAmount - tabFoundCalcAmount - (foundCalcDuplicateAmount - tabFoundCalcDuplicateAmount)
    
    If FullVersion Then
      sda.AddValue "SUMDUPAMOUNT", foundSumDuplicateAmount - tabFoundSumDuplicateAmount
      sda.AddValue "SUMINDIVAMOUNT", foundSumAmount - tabFoundSumAmount - (foundSumDuplicateAmount - tabFoundSumDuplicateAmount)
      
      sda.AddValue "MATRIXDUPAMOUNT", foundMatrixDuplicateFuncs - tabFoundMatrixDuplicateFuncs
      sda.AddValue "MATRIXINDIVAMOUNT", foundMatrixFuncs - tabFoundMatrixFuncs - (foundMatrixDuplicateFuncs - tabFoundMatrixDuplicateFuncs)
    
      sda.AddValue "CELLREFERENCESDUPAMOUNT", foundCellreferencesAmount - tabFoundCellreferencesDuplicateAmount
      sda.AddValue "CELLREFERENCESINDIVAMOUNT", foundCellreferencesAmount - tabFoundCellreferencesAmount - (foundCellreferencesDuplicateAmount - tabFoundCellreferencesDuplicateAmount)
    
    Else
      sda.AddValue "SUMDUPAMOUNT", "Demo"
      sda.AddValue "MATRIXDUPAMOUNT", "Demo"
      sda.AddValue "SUMINDIVAMOUNT", "Demo"
      sda.AddValue "MATRIXINDIVAMOUNT", "Demo"
      sda.AddValue "CELLREFERENCESDUPAMOUNT", "Demo"
      sda.AddValue "CELLREFERENCESINDIVAMOUNT", "Demo"
    End If
    
    sda.AddValue "NONANALYZABLECELLSAMOUNT", foundNonAnalyzableCells - tabFoundNonAnalyzableCells
        
    If FullVersion Then
      sda.AddValue "LONGESTFORMULA", CStr(tabLongestFormula)
    Else
      sda.AddValue "LONGESTFORMULA", "Demo"
    End If
    sda.AddValue "MAXOPENBRACCOUNT", CStr(tabMaxopenbracam)
        
    If G_CheckDimension Then
        sda.AddValue "DIMENSIONX", CStr(m_TabDimension.m_X)
        sda.AddValue "DIMENSIONY", CStr(m_TabDimension.m_Y)
        sda.AddValue "DIMENSION2D", CStr(m_TabDimension.m_XY)
        sda.AddValue "DIMENSION3D", CStr(m_TabDimension.m_Z)
    Else
        sda.AddValue "DIMENSIONX", "'-/-"
        sda.AddValue "DIMENSIONY", "'-/-"
        sda.AddValue "DIMENSION2D", "'-/-"
        sda.AddValue "DIMENSION3D", "'-/-"
    End If
        
End Sub


Sub StoreResults()

  XLScriptAddSimpleVar "SHEETAMOUNT", oxlwbook.Worksheets.count
  XLScriptAddSimpleVar "USEDCELLAMOUNT", totalUsedCellAmount
  XLScriptAddSimpleVar "NONANALYZABLECELLSAMOUNT", foundNonAnalyzableCells
  
  XLScriptAddSimpleVar "DIAGRAMAMOUNT", dda.items.count
  
  XLScriptAddSimpleVar "LONGESTFORMULA", longestFormula
  XLScriptAddSimpleVar "MAXOPENBRACCOUNT", maxopenbracam
  
  XLScriptAddSimpleVar "FORMULAAMOUNT", foundFormulaAmount
  XLScriptAddSimpleVar "FORMULAAMOUNTNOREFS", foundFormulaAmount - foundCellreferencesAmount
  XLScriptAddSimpleVar "IFAMOUNT", foundIfAmount
  XLScriptAddSimpleVar "CALCAMOUNT", foundCalcAmount
  XLScriptAddSimpleVar "SUMAMOUNT", foundSumAmount
  If FullVersion Then
    XLScriptAddSimpleVar "FORMULADUPAMOUNT", foundFormulaDuplicateAmount
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", foundFormulaAmount - foundFormulaDuplicateAmount
    XLScriptAddSimpleVar "FORMULADUPAMOUNTNOREFS", foundFormulaDuplicateAmount - foundCellreferencesDuplicateAmount
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNTNOREFS", foundFormulaAmount - foundFormulaDuplicateAmount - (foundCellreferencesAmount - foundCellreferencesDuplicateAmount)
    XLScriptAddSimpleVar "IFDUPAMOUNT", foundIfDuplicateAmount
    XLScriptAddSimpleVar "IFINDIVAMOUNT", foundIfAmount - foundIfDuplicateAmount
    XLScriptAddSimpleVar "CALCDUPAMOUNT", foundCalcDuplicateAmount
    XLScriptAddSimpleVar "CALCINDIVAMOUNT", foundCalcAmount - foundCalcDuplicateAmount
    XLScriptAddSimpleVar "SUMDUPAMOUNT", foundSumDuplicateAmount
    XLScriptAddSimpleVar "SUMINDIVAMOUNT", foundSumAmount - foundSumDuplicateAmount
  Else
    XLScriptAddSimpleVar "FORMULADUPAMOUNT", "Demo"
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", "Demo"
    XLScriptAddSimpleVar "FORMULADUPAMOUNTNOREFS", "Demo"
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNTNOREFS", "Demo"
    XLScriptAddSimpleVar "CALCDUPAMOUNT", "Demo"
    XLScriptAddSimpleVar "SUMDUPAMOUNT", "Demo"
    XLScriptAddSimpleVar "FORMULAINDIVAMOUNT", "Demo"
    XLScriptAddSimpleVar "IFINDIVAMOUNT", "Demo"
    XLScriptAddSimpleVar "CALCINDIVAMOUNT", "Demo"
    XLScriptAddSimpleVar "SUMINDIVAMOUNT", "Demo"
  End If
  
  
  ' SpecialCells Zeug
'  XLScriptAddSimpleVar "SUMDUPAMOUNT", foundSumDuplicateAmount
  XLScriptAddSimpleVar "MATRIXAMOUNT", foundMatrixFuncs
  XLScriptAddSimpleVar "MATRIXDUPAMOUNT", foundMatrixDuplicateFuncs
  XLScriptAddSimpleVar "MATRIXINDIVAMOUNT", foundMatrixFuncs - foundMatrixDuplicateFuncs
  
  XLScriptAddSimpleVar "CELLREFERENCESAMOUNT", foundCellreferencesAmount
  XLScriptAddSimpleVar "CELLREFERENCESDUPAMOUNT", foundCellreferencesDuplicateAmount
  XLScriptAddSimpleVar "CELLREFERENCESINDIVAMOUNT", foundCellreferencesAmount - foundCellreferencesDuplicateAmount
  
  
  XLScriptAddSimpleVar "UNLOCKEDFORMULAS", foundUnlockedFormulas
  XLScriptAddSimpleVar "UNLOCKEDFORMULASMISSINGSHEETPROTECTION", foundLockedFormulasMissingSheetprotect
  XLScriptAddSimpleVar "LOCKEDFORMULASWITHOUTSHEETPASSWORD", foundLockedFormulasWithoutSheetpassword
  XLScriptAddSimpleVar "UNLOCKEDFORMULASNOTVISIBLE", foundUnlockedFormulasNotVisible
  XLScriptAddSimpleVar "HIDDENCOLUMNAMOUNT", foundHiddenColumnAmount
  XLScriptAddSimpleVar "HIDDENROWAMOUNT", foundHiddenRowAmount
  
  If FullVersion Then
    XLScriptAddSimpleVar "HIDDENSHEETAMOUNT", foundHiddenWorksheetsAmount
    XLScriptAddSimpleVar "VERYHIDDENSHEETAMOUNT", foundVeryHiddenWorksheetsAmount
  Else
    XLScriptAddSimpleVar "HIDDENSHEETAMOUNT", "Demo"
    XLScriptAddSimpleVar "VERYHIDDENSHEETAMOUNT", "Demo"
  End If
  XLScriptAddSimpleVar "DIAGRAMAMOUNT", foundDiagrams
  XLScriptAddSimpleVar "CELLSWITHHYPERLINKSAMOUNT", foundHyperlinks
  XLScriptAddSimpleVar "CELLSWITHINTERNALHYPERLINKSAMOUNT", foundInternalHyperlinks
  XLScriptAddSimpleVar "CELLSWITHEXTERNALHYPERLINKSAMOUNT", foundExternalHyperlinks
  XLScriptAddSimpleVar "CELLSWITHEXTERNALREFERENCESAMOUNT", foundCellsWithExternalReferences
  
  If FullVersion Then
    XLScriptAddSimpleVar "EXTERNALREFERENCESAMOUNT", foundExternalReferences
    XLScriptAddSimpleVar "MISSINGEXTERNALREFERENCESAMOUNT", missingexternalFiles.items.count
  Else
    XLScriptAddSimpleVar "EXTERNALREFERENCESAMOUNT", "Demo"
    XLScriptAddSimpleVar "MISSINGEXTERNALREFERENCESAMOUNT", "Demo"
  End If
  
  XLScriptAddSimpleVar "SHEETSWITHCIRCULARREFERENCESAMOUNT", circref.items.count
  XLScriptAddSimpleVar "PROTECTEDWORKSHEETS", protectedWorksheets
  XLScriptAddSimpleVar "UNPROTECTEDWORKSHEETS", unprotectedWorksheets
  XLScriptAddSimpleVar "PROTECTEDWORKSHEETSWITHPASSWORD", protectedWorksheetsWithPassword
  If FullVersion Then
    XLScriptAddSimpleVar "PROTECTEDWOKRSHEETSWITHOUTPASSWORD", protectedWorksheetsWithoutPassword
  Else
    XLScriptAddSimpleVar "PROTECTEDWOKRSHEETSWITHOUTPASSWORD", "Demo"
  End If
  
  XLScriptAddSimpleVar "NAMEAMOUNT", GetNameCount(oxlwbook)
  
  If G_CheckDimension Then
      XLScriptAddSimpleVar "DIMENSIONX", CStr(m_Dimension.m_X)
      XLScriptAddSimpleVar "DIMENSIONY", CStr(m_Dimension.m_Y)
      XLScriptAddSimpleVar "DIMENSION2D", CStr(m_Dimension.m_XY)
      XLScriptAddSimpleVar "DIMENSION3D", CStr(m_Dimension.m_Z)
  Else
      XLScriptAddSimpleVar "DIMENSIONX", "'-/-"
      XLScriptAddSimpleVar "DIMENSIONY", "'-/-"
      XLScriptAddSimpleVar "DIMENSION2D", "'-/-"
      XLScriptAddSimpleVar "DIMENSION3D", "'-/-"
  End If
  
  ' Ans Ende der mitprotokollierten Zellen, Spalten und Tabellen
  ' ein Endekennzeichen setzen.
    
  ' 18.4.03 - Nt - Checksummenausgabe
  XLScriptAddSimpleVar "CHECKSUM", Hex(checksum)
End Sub

Function GetNameCount(oxlwbook As Excel.Workbook) As Long
  Dim item As name
  Dim cnt As Long
  cnt = 0
  For Each item In oxlwbook.Names
    If Left(item.name, 11) <> "_IDVTracker" Then
      cnt = cnt + 1
    End If
  Next item
  GetNameCount = cnt
End Function

Sub CreateGlobalFuncArray()
  
  If Funcs Is Nothing Then Exit Sub
  
  Dim FuncArray
  Set FuncArray = XLScriptAddArray2D("XLFunctions")
  Dim item
  Dim first As Boolean
  first = True
  
  Dim res As Long
  For Each item In Funcs
    If Left(item.name, 4) <> "### " Then
      res = GetFuncResult(item.name)
      If res > 0 Then
        If Not item.Head Is Nothing Then
          item.Head.count = item.Head.count + res
          item.Head.SumCount = item.Head.SumCount + res
        End If
        item.count = item.count + res
      End If
    End If
  Next item
  
  FuncArray.AddXLScriptArray "Sonstige", "0"
  
  For Each item In Funcs
    If TypeName(item.Head) = "Nothing" Then
      If item.count > 0 Then
        FuncArray.AddXLScriptArray item.Trans, item.count ' Mid(item.name, 5), item.Count
      End If
    Else
      If item.count > 0 Then
        FuncArray.CurrentLine.AddNameAndValue item.Trans, item.count
      End If
    End If
  Next item
'  XLScriptRegisterGlobalObject "XLFunctions", FuncArray
  
  For Each item In m_FoundFuncs
    If Not item.m_Used Then
      XLScriptGetArray2D("XLFunctions").items( _
          "Sonstige").AddToValue "VAL", item.m_Count
      XLScriptGetArray2D("XLFunctions").items( _
          "Sonstige").AddNameAndValue item.m_Name, item.m_Count
    End If
  Next item
  
'  For Each funcItem In Funcs
'    If Left(funcItem.name, 4) <> "### " Then
'      res = GetFuncResult(funcItem.name)
'      If res > 0 Then
'        XLScriptGetArray2D("XLFunctions").items( _
'          Mid(funcItem.Head.name, 5)).items(funcItem.name).AddToValue "VAL", res
'      End If
'    End If
'  Next funcItem
  
  
  
End Sub

Sub CheckFunc(s As String)
  
  On Error GoTo notExistant
  Dim l As Long
  m_FoundFuncs(s).m_Count = m_FoundFuncs(s).m_Count + 1
  Exit Sub
notExistant:
  Dim ff As New FFuncs
  ff.m_Name = s
  ff.m_Count = 1
  m_FoundFuncs.Add ff, s
End Sub

Function GetFuncResult(s As String) As Long
  
  On Error GoTo notExistant
  Dim l As Long
  GetFuncResult = m_FoundFuncs(s).m_Count
  m_FoundFuncs(s).m_Used = True
  Exit Function
notExistant:
  GetFuncResult = 0
End Function



Sub StoreCircle(oXLWsheet As Worksheet)
      
  Dim c
  c = oXLWsheet.Parent.Parent.Calculation
  oXLWsheet.Parent.Parent.Calculation = xlCalculationAutomatic
      
  If Not oXLWsheet.CircularReference Is Nothing Then
    sda.AddValue "SHEETSWITHCIRCULARREFERENCESAMOUNT", "1"
    circref.AddLine
    circref.AddValue "TABLENAME", oXLWsheet.name
    circref.AddValue "FIRSTCIRCLE", StripChars(oXLWsheet.CircularReference.Address, "$")
  Else
    sda.AddValue "SHEETSWITHCIRCULARREFERENCESAMOUNT", "0"
  End If
  oXLWsheet.Parent.Parent.Calculation = c

End Sub


Sub CheckRiskContains(ByRef c As Range, uformula As String)

    If G_RiskContains Is Nothing Then Exit Sub

    Dim item As RiskVal
    For Each item In G_RiskContains
    
      Dim i As Long
      
      
      Dim truecnt As Long
      truecnt = 0
      For i = 1 To item.m_ParameterList.count
        Dim pos As Long
        pos = 1
        Do
          If Left(item.m_ParameterList(i), 1) = "$" Then
            pos = InStr(pos, uformula, Mid(item.m_ParameterList(i), 2))
          Else
            pos = InStr(pos, uformula, item.m_ParameterList(i) & "(")
          End If
          If pos <= 0 Then Exit Do
          pos = pos + 1
          truecnt = truecnt + 1
        Loop
      Next i
    
      If truecnt >= item.m_IdenticalAm Then
        item.m_Matches = item.m_Matches + 1
        If item.m_Matches = 1 Then
          item.m_FirstMatch = uformula
          item.m_FirstMatchAddress = StripChars(c.Address, "$")
        End If
      End If
                
        
    Next item
    

End Sub
Function CheckOpenBracAm(ByRef c As Range, ByRef cs As CloneStuff) As Long
    Dim pos As Long
    Dim posopen As Long
    Dim posclose As Long
    Dim bracam As Long
    
    bracam = 0
    pos = 1
    
    
    Dim formulaStr As String
    formulaStr = RemoveStrings(c.Formula, Chr(34), Chr(34))
    formulaStr = RemoveStrings(formulaStr, "'", "'")
'    formulaStr = RemoveStrings(formulaStr, "[", "]")
    
    ' Sehr sch|fffd|n, wenn jetzt eine Klammer drin ist, dann ist es keine Referenz
    If InStr(formulaStr, "(") <= 0 Then
      ' So, jetzt d|fffd|rfen nur noch Buchstaben, der underscore, Zahlen und das Ausrufungszeichen enthalten sein
      Dim i As Long
      Dim ok As Boolean
      ok = True
      For i = 2 To Len(formulaStr)
        Dim tval As String
        tval = Mid(formulaStr, i, 1)
        If Not ((tval >= "a" And tval <= "z") Or _
                (tval >= "A" And tval <= "Z") Or _
                (tval >= "0" And tval <= "9") Or _
                tval = "_" Or _
                tval = "$" Or _
                tval = "!") Then
                ok = False
                Exit For
        End If
      Next i
      If ok Then
        foundCellreferencesAmount = foundCellreferencesAmount + 1
        cs.m_Ref = 1
      End If
    End If
    
    
    Do
      
      
      posopen = InStr(pos, formulaStr, "(")
      posclose = InStr(pos, formulaStr, ")")
      
      If posopen <= 0 Then
        Exit Do
      ElseIf posopen < posclose Then
        bracam = bracam + 1
        pos = posopen + 1
      ElseIf posclose > 0 And posclose < posopen Then
        bracam = bracam - 1
        pos = posclose + 1
      End If
      
      If bracam > maxopenbracam Then
        maxopenbracam = bracam
      End If
      If bracam > tabMaxopenbracam Then
        tabMaxopenbracam = bracam
      End If
    Loop
    
    CheckOpenBracAm = bracam

End Function



Sub CheckDimensions(ByRef wb As Workbook, ByRef c As Range, ByRef x As Long, ByRef y As Long, ByRef z As Long, ByRef xy As Long)
  
  x = 0
  y = 0
  z = 0
  xy = 0
  Dim deps As Collection
  
  Set deps = Nothing
  If GetArrows(c, deps, True, False) Then
    If Not deps Is Nothing Then
      Dim cc As Range
      For Each cc In deps
        If Abs(c.Column - cc.Column) > x Then x = Abs(c.Column - cc.Column)
        If Abs(c.Row - cc.Row) > y Then y = Abs(c.Row - cc.Row)
        
        Dim txy As Long
        If x = 0 And y = 0 Then
          txy = 0
        Else
          txy = IIf(Abs(c.Column - cc.Column) <= 0, 1, Abs(c.Column - cc.Column)) * IIf(Abs(c.Row - cc.Row) <= 0, 1, Abs(c.Row - cc.Row))
        End If
        
        If txy > xy Then xy = txy
        
        Dim pos1 As Long
        Dim pos2 As Long
        Dim s As Worksheet
        Dim i As Long
        i = 1
        pos1 = 0
        pos2 = 0
        
        Dim cnt As Long
        For cnt = 1 To wb.Sheets.count
'          Set s = wb.Sheets(cnt)
          If wb.Sheets(cnt).name = c.Parent.name Then pos1 = i
          If wb.Sheets(cnt).name = cc.Parent.name Then pos2 = i
          If pos1 > 0 And pos2 > 0 Then Exit For
          i = i + 1
        Next cnt
        If Abs(pos1 - pos2) > z Then z = Abs(pos1 - pos2)
        
        
      Next cc
    End If
  End If

End Sub

Attribute VB_Name = "RiskRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Comparison As Long
Public m_Value As Long
Public m_Risk As Double

Attribute VB_Name = "RiskTab"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_TabName As String
Public m_Vals As Collection

Public m_Weight As Double
Public m_Low As Double
Public m_LowColour As Long
Public m_LowMulti As Double
Public m_Med As Double
Public m_MedColour As Long
Public m_MedMulti As Double
Public m_HighColour As Long
Public m_HighMulti As Double

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub

Public Function Init(wb As Workbook, y As Long)
  Init = False
  
  m_TabName = wb.Worksheets("Risiken").Cells(y, 1)
  
  If Not WorksheetExists(wb, "Regeln") Then
    MsgBox "Es existiert keine Tabelle mit dem Namen 'Regeln' in der Datei '" & ThisWorkbook.Path & "\Excel-Sheet-Checker Risk.xls' fehlt. F|fffd|r den Bereich '" & m_TabName & "' kann keine Risikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
    Exit Function
  End If
  
  Dim y2 As Long
  y2 = 2
  Dim rv As RiskVal
  Do While Not IsEmpty(wb.Sheets("Regeln").Cells(y2, 1)) Or Not IsEmpty(wb.Sheets("Regeln").Cells(y2 + 1, 1)) Or Not IsEmpty(wb.Sheets("Regeln").Cells(y2 + 2, 1))
    If Not IsEmpty(wb.Sheets("Regeln").Cells(y2, 1)) Then
      If wb.Sheets("Regeln").Cells(y2, 1) = m_TabName Then
        Set rv = New RiskVal
        If Not rv.Init(wb.Sheets("Regeln"), y2) Then
          Exit Function
        End If
        m_Vals.Add rv
      End If
    End If
    y2 = y2 + 1
  Loop
  
  With wb.Worksheets("Risiken")
    m_Weight = .Cells(y, 2)
    m_Low = .Cells(y, 3)
    m_LowColour = .Cells(y, 4).Interior.Color
    m_LowMulti = .Cells(y, 5)
    m_Med = .Cells(y, 6)
    m_MedColour = .Cells(y, 7).Interior.Color
    m_MedMulti = .Cells(y, 8)
    m_HighColour = .Cells(y, 9).Interior.Color
    m_HighMulti = .Cells(y, 10)
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  Init = True
End Function


Public Function InitDB(conn, riskrs)
  InitDB = False
  
  m_TabName = riskrs.Fields("Risiko").Value
  
  Dim rs
  Set rs = CreateObject("ADODB.recordset")
  rs.Open "SELECT * FROM ECCRegeln WHERE ECCRisikoID = " & riskrs.Fields("ECCRisikoID").Value, conn, 2, 1
  If rs.EOF Then
    MsgBox "Es sind keine Regeln f|fffd|r das Risiko '" & riskrs.Fields("ECCRisikoID").Value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
    rs.Close
    Set rs = Nothing
    Exit Function
  End If
  
  Dim rv As RiskVal
  Do While Not rs.EOF
    Set rv = New RiskVal
    If Not rv.InitDB(conn, rs) Then
      Exit Function
    End If
    m_Vals.Add rv
    rs.movenext
  Loop
  
  rs.Close
  Set rs = Nothing
  
  With riskrs
    m_Weight = .Fields("Gewichtung").Value
    m_Low = .Fields("Gering").Value
    m_LowColour = .Fields("GeringFarbe").Value
    m_LowMulti = .Fields("GeringMultiplikator").Value
    m_Med = .Fields("Mittel").Value
    m_MedColour = .Fields("MittelFarbe").Value
    m_MedMulti = .Fields("MittelMultiplikator").Value
    m_HighColour = .Fields("HochFarbe").Value
    m_HighMulti = .Fields("HochMultiplikator").Value
  End With
  
  ' Und dann noch die Einzelwerte besorgen
  
  
  
  InitDB = True
End Function

Attribute VB_Name = "RiskVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Type As Long
Public m_Parameter As String
Public m_Vals As Collection
Public m_ParameterList As Collection
Public m_IdenticalAm As Long
Public m_Matches As Long
Public m_FirstMatch As String
Public m_FirstMatchAddress As String
Public m_Hit As Boolean

Private Sub Class_Initialize()
  Set m_Vals = New Collection
End Sub


Public Function Init(ws As Worksheet, line As Long) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  Init = False
  Select Case ws.Cells(line, 2)
    Case "ECC"
          m_Type = C_RISK_TYPE_ECC
    Case "Formula contains", "Formel enth|fffd|lt"
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = ws.Cells(line, 3)
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Excel-Sheet-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Excel-Sheet-Checker"
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            MsgBox "ERROR: 'Formel enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Datei 'Excel-Sheet-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Excel-Sheet-Checker"
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case "In list", "Not in list", "Nicht in Liste"
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          If ws.Cells(line, 2) = "Whitelist" Then
            m_Type = C_RISK_TYPE_WHITE_LIST
          Else
            m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST
          End If
          
          param = ws.Cells(line, 3)
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      MsgBox "ERROR: Unbekannter Typ '" & ws.Cells(line, 2) & "' in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & ws.name & " Zeile " & line, vbCritical, "Excel-Sheet-Checker"
      Exit Function
  End Select
  
  m_Parameter = ws.Cells(line, 3)
  Dim x As Long
  x = 4
  With ws
    Do While Not IsEmpty(.Cells(line, x))
      If Not AddVal(ws, x, .Cells(line, x), .Cells(line, x + 1), .Cells(line, x + 2), ws.name, line) Then Exit Function
      x = x + 3
    Loop
  End With
  Init = True
  
End Function

Public Function AddVal(ws As Worksheet, x As Long, comp As String, v As String, risk As Double, sheetname As String, line As Long) As Boolean
  AddVal = False
  Dim rr As New RiskRange
  Select Case comp
    Case "<"
      rr.m_Comparison = C_RISK_COMP_TYPE_LESS
    Case "<="
      rr.m_Comparison = C_RISK_COMP_TYPE_LESSEQUAL
    Case "="
      rr.m_Comparison = C_RISK_COMP_TYPE_EQUAL
    Case ">="
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGEREQUAL
    Case ">"
      rr.m_Comparison = C_RISK_COMP_TYPE_LARGER
    Case Else
      MsgBox "ERROR: Unbekannter Vergleichsoperator '" & comp & "' in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x).Address, vbCritical, "Excel-Sheet-Checker"
      Exit Function
  End Select
  
  If Not IsNumeric(v) Then
    MsgBox "ERROR: Nicht numerischer Wert in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Excel-Sheet-Checker"
    Exit Function
  End If
  
  If Not IsNumeric(risk) Then
    MsgBox "ERROR: Nicht numerischer Wert in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 2).Address, vbCritical, "Excel-Sheet-Checker"
    Exit Function
  End If
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in 'Excel-Sheet-Checker Risk.xls' Tabelle '" & sheetname & " Zelle " & ws.Cells(line, x + 1).Address, vbCritical, "Excel-Sheet-Checker"
    Exit Function
  End If
  
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddVal = True
End Function




Sub CheckFunc(s As String)
  Dim i As Long
  If m_ParameterList.count <= 0 Then Exit Sub
  Dim foundone As Boolean
  For i = 1 To m_ParameterList.count
    If m_ParameterList(i) = s Then
      foundone = True
      Exit For
    End If
  Next i

  If foundone Then
    If m_Type = C_RISK_TYPE_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  Else
    If m_Type = C_RISK_TYPE_NOT_IN_WHITE_LIST Then
      m_Hit = True
      m_Matches = m_Matches + 1
    End If
  End If

End Sub


Public Function InitDB(conn, rs) As Boolean
  
  Dim pos As Long
  Dim param As String
  
  InitDB = False
  
  Select Case rs.Fields("ECCTypID").Value
    Case C_RISK_TYPE_ECC
          m_Type = C_RISK_TYPE_ECC
    Case C_RISK_TYPE_FORMULA_CONTAINS
          m_Type = C_RISK_TYPE_FORMULA_CONTAINS
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          param = rs.Fields("Parameter").Value
    
          pos = InStr(param, ",")
          If pos <= 0 Then
            MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ECCRegeln'", vbCritical, "Excel-Sheet-Checker"
            Exit Function
          End If
          If Not IsNumeric(Trim(Left(param, pos - 1))) Then
            MsgBox "ERROR: 'Formul enth|fffd|lt' muss als ersten Wert in 'Parameter / Schl|fffd|ssewort' einen numerischen Wert aufweisen! Tabelle 'ECCRegeln'", vbCritical, "Excel-Sheet-Checker"
            Exit Function
          End If
          
          m_IdenticalAm = CLng(Trim(Left(param, pos - 1)))
          param = Mid(param, pos + 1)
          
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          G_RiskContains.Add Me
      
    Case C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
          
          m_Type = rs.Fields("ECCTypID").Value
          
          Set m_ParameterList = New Collection
          
          m_Matches = 0
          m_FirstMatch = ""
          
          m_Type = rs.Fields("ECCTypID").Value
          
          param = rs.Fields("Parameter").Value
    
          Do
            pos = InStr(param, ",")
            If pos <= 0 Then Exit Do
            If Left(Trim(Left(param, pos - 1)), 1) = "$" Or Left(Trim(Left(param, pos - 1)), 1) = "|" Then
              m_ParameterList.Add UCase(Trim(Left(param, pos - 1)))
            Else
              m_ParameterList.Add UCase(TranslateFuncToE(Trim(Left(param, pos - 1))))
            End If
            param = Mid(param, pos + 1)
          Loop
                
          If Len(param) > 0 Then
            m_ParameterList.Add Trim(param)
          End If
          
          
          G_WhiteList.Add Me
      
    Case Else
      MsgBox "ERROR: Unbekannter Typ in Tabelle 'ECCRegeln'", vbCritical, "Excel-Sheet-Checker"
      Exit Function
  End Select
  
  m_Parameter = rs.Fields("Parameter").Value
  
  
  Dim errs
  Set errs = CreateObject("ADODB.recordset")
  errs.Open "SELECT * FROM ECCEinzelregeln WHERE ECCRegelID = " & rs.Fields("ECCRegelID").Value & " ORDER BY id", conn, 2, 1
  If errs.EOF Then
    MsgBox "Es sind keine Einzelregeln f|fffd|r die Regel '" & rs.Fields("ECCRegelID").Value & "' in der Datenbank des IDV-Trackers enthalten. Es kann keine Gesamtrisikoanalyse vorgenommen werden!", vbCritical, "Excel-Sheet-Checker"
    errs.Close
    Set errs = Nothing
    Exit Function
  End If
  
  
  Do While Not errs.EOF
    If Not AddValDB(errs.Fields("OperatorID").Value, errs.Fields("GefundeneZellen").Value, errs.Fields("Risiko").Value) Then Exit Function
    errs.movenext
  Loop
  InitDB = True
  
End Function


Public Function AddValDB(comp As String, v As String, risk As Double) As Boolean
  AddValDB = False
  Dim rr As New RiskRange
  
  rr.m_Comparison = comp
  
  If Val(risk) < 0 Or Val(risk) > 1 Then
    MsgBox "ERROR: Risiko muss zwischen 0% und 100% liegen in Tabelle 'ECCEinzelregeln', Spalte 'Risiko'", vbCritical, "Excel-Sheet-Checker"
    Exit Function
  End If
  
  rr.m_Value = v
  rr.m_Risk = risk
  
  m_Vals.Add rr
  
  AddValDB = True
End Function

Attribute VB_Name = "SWFuncsHelpers"
Option Explicit

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Private Const PROCESS_QUERY_INFORMATION = &H400
Private Const PROCESS_ALL_ACCESS = &H1F0FFF
Private Const STILL_ACTIVE = &H103

Private Const NORMAL_PRIORITY_CLASS = &H20
Private Const IDLE_PRIORITY_CLASS = &H40
Private Const HIGH_PRIORITY_CLASS = &H80
Private Const REALTIME_PRIORITY_CLASS = &H100

#If VBA7 Then
        Private Declare PtrSafe Function SetPriorityClass Lib _
          "kernel32" (ByVal hProcess As Long, _
          dwPriorityClass As Long) As Long
        
        Private Declare PtrSafe Function GetExitCodeProcess Lib _
          "kernel32" (ByVal hProcess As Long, _
          lpExitCode As Long) As Long
        
        Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)
        
        Private Declare PtrSafe Function OpenProcess Lib "kernel32" _
          (ByVal dwDesiredAccess As Long, _
          ByVal bInheritHandle As Long, _
          ByVal dwProcessId As Long) As Long
        
        Private Declare PtrSafe Function TerminateProcess Lib "kernel32" ( _
            ByVal hProcess As Long, _
            ByVal uExitCode As Long _
            ) As Long
            
        Public Declare PtrSafe Function CloseHandle Lib "kernel32" ( _
            ByVal hObject As Long _
            ) As Long

#Else

        Private Declare Function SetPriorityClass Lib _
          "kernel32" (ByVal hProcess As Long, _
          dwPriorityClass As Long) As Long
        
        Private Declare Function GetExitCodeProcess Lib _
          "kernel32" (ByVal hProcess As Long, _
          lpExitCode As Long) As Long
        
        Public Declare Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)
        
        Private Declare Function OpenProcess Lib "kernel32" _
          (ByVal dwDesiredAccess As Long, _
          ByVal bInheritHandle As Long, _
          ByVal dwProcessId As Long) As Long
        
        Private Declare Function TerminateProcess Lib "kernel32" ( _
            ByVal hProcess As Long, _
            ByVal uExitCode As Long _
            ) As Long
            
        Public Declare Function CloseHandle Lib "kernel32" ( _
            ByVal hObject As Long _
            ) As Long
#End If
Public trs As String
Public trsShrt As String
Public FullVersion As Boolean

Public CurrentEnableEvents As Boolean
Public Oldscreenupdating As Boolean
Public Oldstatusbar
Public CurrentDisplayAlerts As Boolean



Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function

Function FileExists(Dateiname$) As Boolean
'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:
  Dim res As Boolean
  res = Dir$(Dateiname) <> ""
  If res = False Then
    res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
  End If
  FileExists = res
  Exit Function
fehler:
    FileExists = False
    Resume Next
End Function

Function MySpc(l As Long) As String
  If l > 0 Then
    Dim i As Long
    For i = 1 To l
      MySpc = MySpc + " "
    Next i
  End If
End Function

Function MakeFileName(n As String)
  Dim newn As String
  Dim i As Long
  If Len(i) > 0 Then
    For i = 1 To Len(n)
      Select Case Mid(n, i, 1)
        Case ":"
          newn = newn & "-"
        Case "\", "/", "*", "?", Chr(34), "<", ">", "|"
          newn = newn & "_"
        Case Else
          newn = newn + Mid(n, i, 1)
      End Select
    Next i
  End If
  MakeFileName = newn
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim i As Long
  If Not IsMissing(pos) And pos > 0 Then
    i = pos
  Else
    i = Len(str)
  End If
  Do While i > 0
    If Mid(str, i, Len(v)) = v Then
      InStrMyRev = i
      Exit Function
    End If
    i = i - 1
  Loop
  InStrMyRev = 0
End Function

Function FileUpToDate(dst As String, src As String)
  FileUpToDate = True
'  If Not FileExists(dst) Then
'    FileUpToDate = False
'    Exit Function
'  ElseIf FileDateTime(dst) < FileDateTime(src) Then
  On Error GoTo dstFileMissing
  
  If FileDateTime(dst) < FileDateTime(src) Then
    FileUpToDate = False
    Exit Function
  End If
  
  Exit Function
dstFileMissing:
  FileUpToDate = False
  
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function


Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub

Public Sub CallAndWaitForProg(Programmname As String)
  Dim hwndShell As Long, hwndProzess As Long
  Dim lngL|fffd|uft As Long
  hwndShell = Shell(Programmname, 1)
  hwndProzess = OpenProcess(PROCESS_ALL_ACCESS, _
    0&, hwndShell)
  Do While ProgStillActive(hwndProzess)
    Sleep 10
  Loop
  CloseHandle hwndProzess
End Sub

Public Function CallProg(Programmname As String) As Long
  Dim hwndShell As Long
  Dim lngL|fffd|uft As Long
  hwndShell = Shell(Programmname, vbMinimizedNoFocus)
  CallProg = OpenProcess(PROCESS_ALL_ACCESS, 0&, hwndShell)
  SetPriorityClass CallProg, HIGH_PRIORITY_CLASS
End Function

Public Function ProgStillActive(ByVal hwndProzess As Long) As Long
  Dim lngL|fffd|uft As Long
  
  GetExitCodeProcess hwndProzess, lngL|fffd|uft
  If lngL|fffd|uft = STILL_ACTIVE Then
    ProgStillActive = True
  Else
    ProgStillActive = False
  End If
    
End Function

Public Sub KillProg(ByVal hwndProzess As Long)
  TerminateProcess hwndProzess, 0&
'  CloseHandle hwndProzess
End Sub


Sub EnableExcel(oXLapp As Excel.Application, onoff As Boolean)

  Exit Sub

  If onoff = False Then
'    If cfgVisible = 1 Then
'      oldcalculationmode = TheXLAPP.Calculation
'      TheXLAPP.Calculation = xlCalculationManual
'    End If
    oXLapp.EnableEvents = False
    CurrentEnableEvents = False
    Oldscreenupdating = oXLapp.ScreenUpdating
    oXLapp.ScreenUpdating = False
    Oldstatusbar = oXLapp.StatusBar
    oXLapp.StatusBar = False
    oXLapp.DisplayAlerts = False
    CurrentDisplayAlerts = False
  Else
'    If cfgVisible = 1 Then
'      TheXLAPP.Calculation = oldcalculationmode
'    End If
    oXLapp.EnableEvents = True
    CurrentEnableEvents = True
    oXLapp.ScreenUpdating = Oldscreenupdating
    oXLapp.StatusBar = Oldstatusbar
    oXLapp.DisplayAlerts = True
    CurrentDisplayAlerts = True
  End If
End Sub

Function WorksheetExists(wb As Workbook, wsname As String)
  On Error GoTo doesntExist
  WorksheetExists = False
  
  Dim s As String
  s = wb.Sheets(wsname).name
  WorksheetExists = True
  Exit Function
doesntExist:
End Function

Function StripChars(txt As String, charstobestripped As String)
  If Len(txt) <= 0 Or Len(charstobestripped) <= 0 Then
    StripChars = ""
    Exit Function
  End If
  Dim n As String
  Dim i As Long
  For i = 1 To Len(txt)
    If InStr(charstobestripped, Mid(txt, i, 1)) <= 0 Then
      n = n & Mid(txt, i, 1)
    End If
  Next i
  StripChars = n
End Function

Function GetCellRange(oXLWsheet, t As Long, Optional t2)
  Set GetCellRange = Nothing
  Application.DisplayAlerts = False
  On Error Resume Next
  SetLiveStatusFunc "SpecialCells", True
  If Not IsMissing(t2) Then
    Set GetCellRange = oXLWsheet.Cells.SpecialCells(t, t2)
  Else
    Set GetCellRange = oXLWsheet.Cells.SpecialCells(t)
  End If
  SetLiveStatusFunc "SpecialCells", False
  Application.DisplayAlerts = True
  SetLiveStatus
End Function

Function CountCellRange(wb As Workbook, wsname As String, t As Long, Optional t2) As Long
  Dim am As Long
  am = 0
  Application.DisplayAlerts = False
  On Error GoTo finsihed
  Dim rng As Range
  SetLiveStatusFunc "SpecialCells", True
  If Not IsMissing(t2) Then
    Set rng = wb.Worksheets(wsname).Cells.SpecialCells(t, t2)
  Else
    Set rng = wb.Worksheets(wsname).Cells.SpecialCells(t)
  End If
  SetLiveStatusFunc "SpecialCells", False
  am = rng.count
finsihed:
  Application.DisplayAlerts = True
  SetLiveStatus
  CountCellRange = am
End Function


Public Function VarValueExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(par(name))
  VarValueExists = True
  Exit Function
  
notReadable:
  VarValueExists = False
End Function


Public Function PropertyNameExists(par, name As String) As Boolean
  On Error Resume Next
  PropertyNameExists = True
  Dim s As String
  s = CStr(par.Properties(UCase(name)))
  If Err.Number = 0 Then Exit Function
  
  Err.Clear
  Dim t
  Set t = par.Properties(UCase(name))
  If Err.Number = 0 Then Exit Function
  
  PropertyNameExists = False
End Function

Attribute VB_Name = "Scan"
Option Explicit

#Const DoProfile = False


Dim cfgAusf|fffd|hrlich As Long
Dim cfgProgressVisible As Long
Dim cfgFunktionenAuswerten As Long

Dim CurrentStatus As Long
Public VBAFailure As Long
Public Beenden As Boolean

Public theFilename As String
Public theidvDateiID As Long
Public theOEID As Long
Public theFreigabekommentar As String
Public theFreigabeCCListe  As String
Public theFreigabeuser As String


Public theTrackerPasswordLog As Boolean

Private LastProgText As String
Private ProgText As String


Global Const ChecksumMod As Long = &H100000
Global Const StartEnums As Long = 30
Const StartMassenanalyseY As Long = 11


#If VBA7 Then

Private Declare PtrSafe Function GetCurrentProcess Lib "kernel32" () As Long

Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" _
      (ByVal lpClassName As String, ByVal lpWindowName As String) As Long

#Else
Private Declare Function GetCurrentProcess Lib "kernel32" () As Long

Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" _
      (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
#End If

Public LastTimeStamp As Date

Const C_MarkRisk As Long = 13158600


Sub GetTrans()
  Dim ty As Long
  ty = 4
  Set TransToLocal = New Collection
  Set TransToE = New Collection
  With ThisWorkbook.Sheets("Translate")
      Do While Not IsEmpty(.Cells(ty, 1))
          TransToLocal.Add .Cells(ty, GSprache + 1).Value, .Cells(ty, 1).Value
          TransToE.Add UCase(CStr(.Cells(ty, 1).Value)), UCase(CStr(.Cells(ty, GSprache + 1).Value))
          ty = ty + 1
      Loop
  End With

End Sub

Sub DoMassenanalyse()

  LogPrintECCSCanLog 0, 0, "V" & MyVersion & "(Rel: " & MyECCVersion & ") Start!"
  
  G_ColorCells = False
  G_CheckInputs = False
        
  Dim sp|fffd|terfortsetzen As Boolean
  sp|fffd|terfortsetzen = False
  
  
  Dim resultWB As Workbook
  ' Und jetzt die RiskValues holen
  
  GetTrans
  
  If Not GetRiskValues Then
    EndDaemon
    Exit Sub
  End If
  LogPrint "DoMassenanalyse Start 1"
  
  GetPasswoerter
    
'  DoEvents
  LogPrint "DoMassenanalyse Start 1.1"
  
  cfgAusf|fffd|hrlich = 1
  cfgProgressVisible = 1
  cfgFunktionenAuswerten = 1
    
  Dim startTime

  ' Die Excel-Tabelle
  LogPrint "DoMassenanalyse Start 1.2"
  Dim oXLWsheet                 As New Excel.Worksheet
   
  ' Zeit holen
  Dim v As String
  Dim resultFileName As String

  LogPrint "DoMassenanalyse Start 1.3"
  resultFileName = GetSetting( _
   appname:="Stromwerken", _
   Section:="ECC", _
   Key:="MAErgebnis", _
   default:="")

  LogPrint "DoMassenanalyse Start 2"
  
  Dim currentEntry As Long

  Dim totalFileAm As Long
  totalFileAm = 0

  Set xlsDateien = New Collection
  
  LogPrint "DoMassenanalyse Start 3"
  
  Dim rs
  
  G_CheckDimension = False
  
  If StartedByTracker Then
  
          Set rs = CreateObject("ADODB.recordset")
          rs.Open "SELECT ECCScan.idvDateiID, ECCScan.Dateiname, ECCScan.OEID, ECCScan.ScanStatus, idvDateien.LetzterScan, idvDateien.FreigabeStatus, idvDateien.CheckerVersion, idvDateien.CheckerSettings FROM ECCScan INNER JOIN idvDateien ON ECCScan.idvDateiID = idvDateien.idvDateiID WHERE idvDateien.CheckerVersion = " & MyECCVersion & " OR idvDateien.CheckerVersion = -1 OR idvDateien.CheckerVersion is NULL", G_conn, MYadOpenDynamic, MYadLockOptimistic
          
          currentEntry = 1
          Do While Not rs.EOF
              Dim sf As ScanFile
              Set sf = New ScanFile
              sf.m_Name = GetDriveAndPathFromUNC(rs.Fields("Dateiname").Value)
              If Not IsNull(rs.Fields("OEID").Value) Then
                sf.m_OEID = rs.Fields("OEID").Value
              Else
                sf.m_OEID = 0
              End If
              If IsNull(rs.Fields("idvDateiID").Value) Then
                sf.m_idvDateiID = 0
              Else
                sf.m_idvDateiID = rs.Fields("idvDateiID").Value
              End If
              xlsDateien.Add sf
              totalFileAm = totalFileAm + 1
              If totalFileAm > 100 And Not FullVersion Then
                Exit Do
              End If
              rs.movenext
          Loop
          rs.Close
          Set rs = Nothing
          
'          If G_ECCNoDimension = True Or theTrackerFreigabe = True Then
'            G_CheckDimension = False
'          Else
'            G_CheckDimension = True
'          End If
          G_CheckInputs = False
          G_Schnellanalyse = False
  
  Else
          LogPrint "DoMassenanalyse Start 4"
          Set resultWB = Application.Workbooks.Open(resultFileName)
          SetLiveStatus
          Dim x As Long
          x = 0
          LogPrint "DoMassenanalyse Start 5"
          With resultWB.Sheets("ECCFiles")
            Do While Not IsEmpty(.Cells(2 + WorksheetFunction.RoundDown(x / 255, 0), 1 + x Mod 255))
              LogPrint "DoMassenanalyse Start 5.1 y:" & 2 + WorksheetFunction.RoundDown(x / 255, 0) & " x:" & 1 + x Mod 255
              Set sf = New ScanFile
              sf.m_Name = .Cells(2 + WorksheetFunction.RoundDown(x / 255, 0), 1 + x Mod 255)
              LogPrint "DoMassenanalyse Start 5.2 F:" & sf.m_Name
              sf.m_OEID = 0
              sf.m_idvDateiID = 0
              xlsDateien.Add sf
              totalFileAm = totalFileAm + 1
              x = x + 1
            Loop
            
            currentEntry = .Cells(1, 1)
            If .Cells(1, 3) = "Ja" Then
              G_CheckDimension = True
            Else
              G_CheckDimension = False
            End If
            If .Cells(1, 4) = "Ja" Then
              G_Schnellanalyse = True
            Else
              G_Schnellanalyse = False
            End If
          End With
          LogPrint "DoMassenanalyse Start 6"
  End If
  
  
  
  Dim item
  Dim tstring As String
  Dim i As Long
  Dim analyseResult As Boolean
  
  LogPrint "DoMassenanalyse 0"
  StartDaemon
  LogPrint "DoMassenanalyse 1"
  If currentEntry <= xlsDateien.count Then
      
      
      
      LogPrint "DoMassenanalyse CurEntry: " & currentEntry
      
      
      Dim memu As Long
'      Dim memf As Long
      
      If Application.Version = "11.0" Then
        memu = Application.MemoryUsed
      Else
        memu = 0
      End If
      
'      memf = Application.MemoryFree
      
      If C_LeakTest Then
        If Application.Version = "11.0" Then
          AddStatus "Genutzter Speicher: " & memu
        Else
          AddStatus "Datei #: " & memu
        End If
'        AddStatus "Freier Speicher:    " & memf
      End If
      
      For i = currentEntry To xlsDateien.count
        
        If Not TrackerTimeInScope() Then Exit For
        
        If Beenden = False Then
          
          
          Dim currentscanstatus As Long
          
          If StartedByTracker Then
          
            Set rs = CreateObject("ADODB.recordset")
            rs.Open "SELECT ECCScan.idvDateiID, ECCScan.Dateiname, ECCScan.OEID, ECCScan.ScanStatus, idvDateien.LetzterScan, idvDateien.CheckerVersion, idvDateien.CheckerSettings FROM ECCScan INNER JOIN idvDateien ON ECCScan.idvDateiID = idvDateien.idvDateiID WHERE idvDateien.CheckerVersion = " & MyECCVersion & " OR idvDateien.CheckerVersion = -1 OR idvDateien.CheckerVersion is NULL", G_conn, MYadOpenDynamic, MYadLockReadOnly
            currentscanstatus = rs.Fields("ScanStatus").Value
'            theIDVTFileID = rs.fields("idvDateiID").Value
            rs.Close
            Set rs = Nothing
          
          Else
          
            currentscanstatus = resultWB.Sheets("ECCFiles").Cells(1, 2).Value
            
          End If
          
          
          
          ResetRisks
          
          theFilename = xlsDateien(i).m_Name
          theidvDateiID = xlsDateien(i).m_idvDateiID
          LogPrintECCSCanLog theidvDateiID, 0, theFilename & " (ID: " & theidvDateiID & ") - Starte Analyse"
          
          If IsNull(xlsDateien(i).m_OEID) Then
            theOEID = 0
          Else
            theOEID = xlsDateien(i).m_OEID
          End If
          StatusForm.Filename.Caption = theFilename
          DoEvents
          
          If StartedByTracker Then
            StoreComm True
          End If
          
          XLScriptInitDebug
          
          XLScriptInitGlobals
          
          analyseResult = False
          
          ' Wenn der letzte Scan schief ging, dann muss die Zeile als fehlerhaft markiert werden!!!!
          If GetSetting( _
              appname:="Stromwerken", _
              Section:="ECC", _
              Key:="MAStatus", _
              default:="") = "Start" And currentscanstatus >= 1 Then
              
              XLScriptAddSimpleVar "FILE", theFilename
              XLScriptAddSimpleVar "NAME", theFilename
              XLScriptAddSimpleVar "SAVEDATE", Format(FileDateTime(theFilename), "Short Date") & " - " & Format(FileDateTime(theFilename), "Short Time")
              XLScriptAddSimpleVar "FILESIZEKB", CLng(FileLen(theFilename) / 1024)
              XLScriptAddSimpleVar "FILESIZE", FileLen(theFilename)
              XLScriptAddSimpleVar "STATUS", "Datei/Analyse fehlerhaft"
              XLScriptAddSimpleVar "STATUSID", "1"
              If StartedByTracker Then
                XLStoreValsToDB False
              End If
              LogPrintECCSCanLog theidvDateiID, 1, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Analyse mehrfach fehlerhaft, Analyse wird abgebrochen"
          Else
          
              SaveSetting _
              appname:="Stromwerken", _
              Section:="ECC", _
              Key:="MAStatus", _
              setting:="Start"
              
              If StartedByTracker Then
                    Set rs = CreateObject("ADODB.recordset")
                    rs.Open "SELECT * FROM ECCScan WHERE idvDateiID=" & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic
                    If Not rs.EOF Then
                      rs.Fields("ScanStatus").Value = rs.Fields("ScanStatus").Value + 1
                      rs.Update
                    End If
                    rs.Close
                    Set rs = Nothing
              Else
              
                    resultWB.Sheets("ECCFiles").Cells(1, 2).Value = resultWB.Sheets("ECCFiles").Cells(1, 2).Value + 1
                    resultWB.Sheets("ECCFiles").Cells(1, 1).Value = i
              
                    Application.DisplayAlerts = False
                    resultWB.Save
                    Application.DisplayAlerts = True
              
              End If
              
              
              Application.ScreenUpdating = False
    '          Dim oldcalc
    '          oldcalc = Application.Calculation
    '          Application.Calculation = xlCalculationManual
    
              If Not FileExists(xlsDateien(i).m_Name) Then
                  XLScriptAddSimpleVar "FILE", theFilename
                  XLScriptAddSimpleVar "NAME", theFilename
                  XLScriptAddSimpleVar "STATUS", "Gel|fffd|scht"
                  XLScriptAddSimpleVar "STATUSID", "1"
                  If StartedByTracker Then
                    XLStoreValsToDB False
                  End If
                  LogPrintECCSCanLog theidvDateiID, 1, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Datei gel|fffd|scht, Analyse wird abgebrochen"
              Else
                LogPrint "DoMassenanalyse: " & xlsDateien(i).m_Name
                Dim oldenev As Boolean
                oldenev = Application.EnableEvents
                Application.EnableEvents = False
                analyseResult = DoAnalyse("m", Texte(GSprache, TXT_ANS_MASSENANALYSE), GetDriveAndPathFromUNC(xlsDateien(i).m_Name), False)
                Application.EnableEvents = oldenev
              End If
    '          Application.Calculation = oldcalc
              Application.ScreenUpdating = True
              
              If Not StartedByTracker Then
                If Beenden = True Then
                  EndDaemon
                  If MsgBox("Sie haben die Analyse abgebrochen." & vbCrLf & vbCrLf & "Falls Sie die Analyse zu einem sp|fffd|teren Zeitpunkt fortsetzen m|fffd|chten, dr|fffd|cken Sie bitte auf 'Ja'. Falls Sie die Analyseergebnisse finalisieren m|fffd|chten (ein sp|fffd|teres Fortsetzen der Analyse ist NICHT m|fffd|glich!!!), dann dr|fffd|cken Sie bitte auf 'Nein'.", vbYesNo + vbCritical) = vbYes Then
                    sp|fffd|terfortsetzen = True
                  End If
                Else
                  resultWB.Sheets("ECCFiles").Cells(1, 2).Value = 0
                End If
              End If
          
          
          End If
          
          SaveSetting _
          appname:="Stromwerken", _
          Section:="ECC", _
          Key:="MAStatus", _
          setting:="End"
          
          
          If totalFileAm > 0 Then
            StatusForm.ProgressBT.Width = i / totalFileAm * StatusForm.Filename.Width
          End If
          DoEvents
          
          If Not sp|fffd|terfortsetzen Then
            SaveSetting _
               appname:="Stromwerken", _
               Section:=progNameShort, _
               Key:="LiveStatusCaption", _
               setting:=Application.Caption
          End If
          
          If Not StartedByTracker Then
            If Not sp|fffd|terfortsetzen Then
              Application.Calculation = xlCalculationManual
              Application.ScreenUpdating = False
              
              Dim ws As Worksheet
              For Each ws In resultWB.Worksheets
                UpdateStatus "Generiere Ergebnisbl|fffd|tter (" & ws.name & ")"
                XLScriptInit ws, 2
                XLScriptExecCode ws.Cells, 0, 0
                XLScriptExit
                XLScriptInit ws, 3
                XLScriptExecCode ws.Cells, 0, 0
                XLScriptExit
              Next ws
            
              Application.ScreenUpdating = True
              Application.Calculation = xlCalculationAutomatic
            End If
          End If
          
          
'          XLDumpNonprinted


          If StartedByTracker Then
            If Beenden = False Then
              XLStoreValsToDB analyseResult
              If analyseResult = False Then
                AddStatus "Der Vorgang war fehlerhaft und wurde beendet"
              End If
            Else
              AddStatus "Der Vorgang wurde abgebrochen"
            End If
          End If
          
          XLScriptExitGlobals
          
        Else
          Exit For
        End If
        
        
    '      MainMenu.Progress2.Width = ProgWidth2 / xlsDateien.Count * itemcount
        LogPrint "ECCScan Tabelle l|fffd|schen"
        If StartedByTracker Then
            If TrackerTimeInScope() Then
              Set rs = CreateObject("ADODB.recordset")
              rs.Open "SELECT * FROM ECCScan WHERE idvDateiID=" & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic
              rs.Delete
              rs.Close
              Set rs = Nothing
            End If
        End If
        
        LogPrint "LeakTest"
      
        If C_LeakTest Then
          If Application.Version = "11.0" Then
            AddStatus "Genutzter Speicher: " & Application.MemoryUsed & " - Ver|fffd|nderung: " & memu - Application.MemoryUsed
          End If
'          AddStatus "Freier Speicher:    " & Application.MemoryFree & " - Ver|fffd|nderung: " & memf - Application.MemoryFree
'          If memf - Application.MemoryUsed <> 0 Then
'            MsgBox "Leak"
'          End If
        End If
        
        LogPrint "LeakTest Ende"
        
        AddStatus "-----------------------------------------------------------------------------------------------------------------------------------------------"
        
        If Application.Version = "11.0" Then
            Debug.Print memu - Application.MemoryUsed
            If memu - Application.MemoryUsed < -1000000 Then
              AddStatus "Schlie|fffd|e ECC f|fffd|r Neustart!"
              SaveSetting _
                 appname:="Stromwerken", _
                 Section:="ECC", _
                 Key:="StartedByDaemon", _
                 setting:="True"
               
              GConnClose
              LogPrintECCSCanLog 0, 0, "Restart"
              SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
              StartDatei ThisWorkbook.FullName
              ThisWorkbook.Saved = True
              Application.EnableEvents = True
              Application.Quit
              Exit Sub
            End If
        Else
            memu = memu + 1
            If memu > 30 Then
              AddStatus "Schlie|fffd|e ECC f|fffd|r Neustart!"
              SaveSetting _
                 appname:="Stromwerken", _
                 Section:="ECC", _
                 Key:="StartedByDaemon", _
                 setting:="True"
               
              GConnClose
              LogPrintECCSCanLog 0, 0, "Restart"
              SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
              StartDatei ThisWorkbook.FullName
              ThisWorkbook.Saved = True
              Application.EnableEvents = True
              Application.Quit
              Exit Sub
            End If
        End If
        
      
      Next i
  End If
    
'  If Beenden = True Then
'      resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(5, 2).Value = Texte(GSprache, TXT_ABG)
'  Else
'      resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(5, 2).Value = Texte(GSprache, TXT_BEEN)
'  End If
'  resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(1, 2).Value = MainMenu.Verzeichnis
'  resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(3, 2).Value = Now
'  resultWB.Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(4, 2).Value = Format(Time - starttime, "hh:mm:ss")
'    MainMenu.Progress2.Width = ProgWidth2
'  Beep
  
'  MsgBox "EndDaemon"
  EndDaemon
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  
  If Not StartedByTracker Then
        
        Application.Calculation = xlCalculationManual
        Application.ScreenUpdating = False
        
        If Not sp|fffd|terfortsetzen Then
          XLScriptInitGlobals
          If Beenden = True Then
            XLScriptAddSimpleVar "SCANSTATUS", Texte(GSprache, TXT_ABG)
          Else
            XLScriptAddSimpleVar "SCANSTATUS", Texte(GSprache, TXT_FERTIG2)
          End If
          XLScriptAddSimpleVar "ENDOFSCAN", Now
          For Each ws In resultWB.Worksheets
            XLScriptInit ws, 4
            XLScriptExecCode ws.Cells, 0, 0
            XLScriptCleanUpTags ws.Cells
            XLScriptExit
          Next ws
          XLScriptExitGlobals
          
          For Each ws In resultWB.Worksheets
            ECCCreateHeaderAndFooter ws
          Next ws
        End If
        
      
      '  If Beenden = True Then
      '      MsgBox Now & vbCrLf & Texte(GSprache, TXT_ABBRUCH) & Format(Now - starttime, "hh:mm:ss")
      '  Else
      '      MsgBox Now & vbCrLf & Texte(GSprache, TXT_FERTIG) & Format(Now - starttime, "hh:mm:ss")
      '  End If
        
        Application.ScreenUpdating = True
        Application.Calculation = xlCalculationAutomatic
        resultWB.Application.DisplayAlerts = False
        resultWB.Activate
        resultWB.Worksheets(1).Activate
        resultWB.Save
        resultWB.Application.DisplayAlerts = True
        
        resultWB.Activate
        resultWB.Worksheets(1).Activate
        If sp|fffd|terfortsetzen Then
          resultWB.Close False
        End If
        
        Set resultWB = Nothing
  End If
  
  
  FreeAllMem
  
  ThisWorkbook.Saved = True
  
  StatusForm.Hide
  
  
  If StartedByTracker Then
    
    StoreComm False
    LogPrintECCSCanLog 0, 0, "Schlie|fffd|e ECC, alle Analysen beendet"
    SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:="ECCScanFinished", setting:="1"
    
    GConnClose
    
    If Not C_IDVTrackerTest Then
        LogPrint "StartedByTracker=False"
        SaveSetting _
           appname:="Stromwerken", _
           Section:=progNameShort, _
           Key:="StartedByTracker", _
           setting:="False"
        SaveSetting _
           appname:="Stromwerken", _
           Section:=progNameShort, _
           Key:="TrackerFreigabe", _
           setting:="False"
    End If
    
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
    If Not C_IDVTrackerTest Then
      Application.EnableEvents = True
      Application.Quit
    End If
  End If
  
  
  
End Sub


Sub DoEinzelanalyse()

  Dim resultWB As Workbook
  ' Und jetzt die RiskValues holen
  
  GetTrans
  GetRiskValues
  
  GetPasswoerter
    
  DoEvents
  
  cfgAusf|fffd|hrlich = 1
  cfgProgressVisible = 1
  cfgFunktionenAuswerten = 1
  
  
  If cfgFunktionenAuswerten = 1 Then
    GetFuncs
  End If
  
  G_ColorCells = False
  G_CheckInputs = True
  
  G_Schnellanalyse = False
  If Not StartedByTracker Then
  
      ParamAsk.Show vbModal
      
      G_ColorCells = ParamAsk.ColorCells
      G_CheckDimension = ParamAsk.CheckDimension
      
      Dim app As Excel.Application
      Set app = New Excel.Application
      Set resultWB = app.Workbooks.Add(ThisWorkbook.Path & "\ECC-Einzelanalyse.xltx")
      app.Calculation = xlCalculationManual
      
  End If
  
  XLScriptInitGlobals
  
  XLScriptAddSimpleVar "STARTOFSCAN", Now
  
  Dim ws As Excel.Worksheet
'  For Each ws In resultWB.Worksheets
'    XLScriptInit ws, "S"
'    XLScriptExecCode ws.Cells, 0,0
'    XLScriptExit
'  Next ws
  
  If Not StartedByTracker Then
    app.Visible = False
    app.ScreenUpdating = False
  End If
  Application.ScreenUpdating = False
'  Dim oldcalc
'  oldcalc = Application.Calculation
'  Application.Calculation = xlCalculationManual

  If StartedByTracker Then
'      If G_ECCNoDimension = True Then
        G_CheckDimension = False
'      Else
'        G_CheckDimension = True
'      End If
      G_Schnellanalyse = False
  End If
  
  LogPrint "DoEinzelanalyse-Start"
  
  Dim analyseResult As Boolean
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  Application.EnableEvents = False
  analyseResult = DoAnalyse("e", Texte(GSprache, TXT_ANS_EINZELANALYSE), GetDriveAndPathFromUNC(theFilename), True)
  Application.EnableEvents = oldenev
  
'  Application.Calculation = oldcalc
  Application.ScreenUpdating = True
  


  If Beenden = True Then
    XLScriptAddSimpleVar "SCANSTATUS", Texte(GSprache, TXT_ABG)
  Else
    XLScriptAddSimpleVar "SCANSTATUS", Texte(GSprache, TXT_FERTIG2)
  End If
  XLScriptAddSimpleVar "ENDOFSCAN", Now

  LogPrint "DoEinzelanalyse-1"

  If Not StartedByTracker Then

        For Each ws In resultWB.Worksheets
          UpdateStatus "Generiere Ergebnisbl|fffd|tter (" & ws.name & ")"
          XLScriptInit ws, 1
          XLScriptExecCode ws.Cells, 0, 1
          XLScriptExit
        Next ws
        For Each ws In resultWB.Worksheets
          XLScriptInit ws, 2
          XLScriptExecCode ws.Cells, 0, 0
          XLScriptExit
        Next ws
      '  For Each ws In resultWB.Worksheets
      '    XLScriptInit ws, 3
      '    XLScriptExecCode ws.Cells,0,0
      '    XLScriptExit
      '    ws.Cells(1, 1).Select
      '  Next ws
        
      '  For Each ws In resultWB.Worksheets
      '    XLScriptInit ws, "E"
      '    XLScriptExecCode ws.Cells,0,0
      '    XLScriptCleanUpTags ws.Cells
      '    XLScriptExit
      '  Next ws
       
        For Each ws In resultWB.Worksheets
          ECCCreateHeaderAndFooter ws
        Next ws
       
'        If Not StartedByTracker Then
'            AddStatus "F|fffd|ge Kommentare hinzu"
'            AddKommentare resultWB
'        End If
       
        app.Visible = True
        app.ScreenUpdating = True
        
        app.Calculation = xlCalculationAutomatic
  End If

  LogPrint "DoEinzelanalyse-2"
  XLDumpNonprinted
  LogPrint "DoEinzelanalyse-3"
  
  If StartedByTracker Then
    If analyseResult = True And Beenden = False Then
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
      XLStoreValsToDB True
    
    ElseIf analyseResult = False Then
      AddStatus "Der Vorgang war fehlerhaft und wurde beendet"
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
    ElseIf Beenden = True Then
      AddStatus "Der Vorgang wurde abgebrochen"
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=Right(StatusForm.ProgText, 2048)
    End If
  End If
  
  LogPrint "DoEinzelanalyse-4"
  XLScriptExitGlobals
  
  StatusForm.Hide
  LogPrint "DoEinzelanalyse-5"

  FreeAllMem
  
  LogPrint "DoEinzelanalyse-6"
  
  ThisWorkbook.Saved = True

  If Not StartedByTracker Then
      resultWB.Worksheets(1).Activate
      If G_Command = "SCAN" Then
        If Not C_IDVTrackerTest Then
          ThisWorkbook.Close False
          Exit Sub
        End If
      End If
  End If
  
  If Not StartedByTracker Then
      If Beenden Then
        MsgBox "Die Analyse wurde abgebrochen! Die Ergebnisse wurden dadurch nicht vollst|fffd|ndig ermittelt / ausgegeben!", vbCritical, "Excel-Sheet-Checker"
      End If
  Else
    GConnClose
    
    If Not C_IDVTrackerTest Then
        LogPrint "StartedByTracker=False"
        SaveSetting _
           appname:="Stromwerken", _
           Section:=progNameShort, _
           Key:="StartedByTracker", _
           setting:="False"
        SaveSetting _
           appname:="Stromwerken", _
           Section:=progNameShort, _
           Key:="TrackerFreigabe", _
           setting:="False"
    End If
    
    LogPrint "DoEinzelanalyse-Finished"
    
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
    If Not C_IDVTrackerTest Then
      Application.EnableEvents = True
      Application.Quit
    End If
  End If
End Sub


Sub CloseWB(ByRef subWB As Workbook)
  On Error Resume Next
  subWB.Close False
  Set subWB = Nothing

End Sub


Public Function DoAnalyse(ByVal outputsheet As String, ByVal outputSheetName As String, ByVal Filename As String, ByVal modifyOriginal As Boolean) As Boolean
' Die Zeile "On Error Resume Next" kann bei Bedarf wieder
' eingesetzt werden, hier wurde darauf verzichtet um eventuelle
' Programmfehler auch mitzubekommen :)
'  On Error Resume Next
  
' Alternativ kann ich diese Zeile genutzt werden, die
' Fehler geregelt abf|fffd|ngt
  On Error GoTo cmdExcel_Err
  
  Dim subWB As Workbook
  DoAnalyse = True

  cfgAusf|fffd|hrlich = 1
  cfgProgressVisible = 1
  cfgFunktionenAuswerten = 1

  Dim ignoreAllFurtherErrors As Boolean
  
  ' Die Excel-Datei
  Dim oxlwbook                  As Excel.Workbook
  ' Die Excel-Tabelle
  Dim oXLWsheet                 As Excel.Worksheet
  ' Eine Zelle
  Dim c                         As Range
  
  Dim res As New Result
  
  Dim startOfScan As Date
  startOfScan = Now
  
  ' Berechnungsmodus schnell oder langsam?
  Dim Mode As Long
  
  
  ' Eine Laufvariable
  Dim cellCount                 As Long
  
  ' Zeit f|fffd|r die Updates
  Dim lastTime As Date
  
  ' Eine Laufvariable
  Dim threshCount               As Long
  ' Eine Laufvariable
  Dim threshSubCunt             As Long
    
  ' Die Uhrzeit des Starts der Auswertung
  Dim startTime
  
  
  
  Dim counter As Long
  
  Dim formulaCells As Range
  
  Dim i As Long
  
  ' Zeit holen
  startTime = Time
  
  
  ignoreAllFurtherErrors = False
  
  
  cellCount = 0
  threshCount = 0
  
  
  ' Ausf|fffd|hrlich oder kurz????
  If cfgAusf|fffd|hrlich = 0 Then
    XLScriptAddSimpleVar "MODE", Texte(GSprache, TXT_FAST)
    Mode = 0
  Else
    XLScriptAddSimpleVar "MODE", Texte(GSprache, TXT_DEEP)
    Mode = 1
  End If
  
  
  res.Init Filename, Mode
  
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "FILE", Filename
  
  CurrentStatus = 1
  If UCase(GetUNCPath(ThisWorkbook.FullName)) = UCase(GetUNCPath(Filename)) Then
    XLScriptAddSimpleVar "STATUS", "Keine Analyse"
    XLScriptAddSimpleVar "STATUSID", "2"
    XLScriptAddSimpleVar "ENDOFFILESCAN", Now
    AddStatus "Wird nicht analysiert"
    AddStatus "-"
'    GetIDVTIDs Nothing, Filename, G_conn
    Set res = Nothing
    DoAnalyse = False
    LogPrintECCSCanLog theidvDateiID, 2, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Die Datei wird nicht analysiert!"
    Exit Function
  ElseIf GetFile(Filename, oxlwbook, outputsheet) = False Then
    XLScriptAddSimpleVar "STATUS", "Passwortgesch|fffd|tzt / defekt"
    XLScriptAddSimpleVar "STATUSID", "5"
    XLScriptAddSimpleVar "ENDOFFILESCAN", Now
    AddStatus "Datei passwortgesch|fffd|tzt / Defekt"
    AddStatus "-"
      If StartedByTracker Then
        XLStoreValsToDB False
      End If
      LogPrintECCSCanLog theidvDateiID, 5, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: FEHLER: Datei Passwortgesch|fffd|tzt / defekt!"
'    GetIDVTIDs Nothing, Filename, G_conn
    Set res = Nothing
    DoAnalyse = False
    Exit Function
  End If
  
  Dim subWBs As Collection
  Set subWBs = New Collection
  If (outputsheet <> "m" And StartedByTracker = False) Or G_UserStartedProgram = True Then
    Dim openRefsErr As String
    If Not OpenExternalReferences(oxlwbook, outputsheet, subWBs, openRefsErr) Then
      XLScriptAddSimpleVar "INFOREFFILES", openRefsErr
    End If
  End If
  
  XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
  XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
  
'  If Not GetIDVTIDs(oxlwbook, Filename, G_conn) Then
'    XLScriptAddSimpleVar "STATUS", "Kein Eintrag"
'    XLScriptAddSimpleVar "STATUSID", "2"
'    XLScriptAddSimpleVar "ENDOFFILESCAN", Now
'    XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
'    XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
'    Exit Sub
'  End If
  res.InitWB oxlwbook
  
  CurrentStatus = 2
  AddStatus "Datei geladen"
  
  
  
  
  '---------------------------------------
  ' Funktionsexport vorbereiten
  '---------------------------------------
  Dim funcEx As Object
  Set funcEx = XLScriptAddArray2D("FORMULAS")
  
  Dim inputs As Object
  Set inputs = XLScriptAddArray2D("INPUTS")
  
  Dim todos As Object
  Set todos = XLScriptAddArray2D("TODOS")
  
  
  '-------------------------------------
  '-------------------------------------
  '-------------------------------------
  ' Analyse
  '-------------------------------------
  '-------------------------------------
  '-------------------------------------
  
#If DoProfile Then
  Dim hrt As New HighResTimer
#End If

  
#If DoProfile Then
  hrt.StartCounting "Prestuff"
#End If
  
  res.AnalyzeCodeModules
  
  If Not res.CountCells() Then GoTo closeAndLeave
  
  res.CheckProtectedWorkbook
  
  RemovePWWorkbook oxlwbook

  res.GetNames
  
  res.CheckExternalReferences
  
  '-------------------------------------
  
  
  
'  AddStatus "Passw|fffd|rter entfernen wird vorbereitet"
  
  res.RemoveSheetPasswords
  
  
  oxlwbook.Worksheets(oxlwbook.Worksheets.count).Activate
  
  
  Dim analyzestarttime
  analyzestarttime = Time
  
  ' Die Schleife l|fffd|uft |fffd|ber alle Worksheets (Tabellen)...
  AddStatus "Zellanalyse"
  
#If DoProfile Then
  hrt.StopCounting "Prestuff"
#End If
  
  Dim sheetCnt As Long
  sheetCnt = 0
  
  For Each oXLWsheet In oxlwbook.Worksheets
  
    If Not TrackerTimeInScope() Then Exit For
  
    ' Wir setzen die Clones neu pro Tabellenblatt!
    Set res.m_Clones = New Collection
  
    ' Neue Zeile f|fffd|r das Tabellenblatt einf|fffd|gen
    res.sda.AddLine
 
    ' Zwischensummen setzen
    res.SetTab
    
    ' und wird auch nur dann ausgef|fffd|hrt, wenn es wirklich
    ' ein Worksheet ist.
    If TypeName(oXLWsheet) = "Worksheet" Then
      oXLWsheet.Activate
      
'      AddStatus "Analysiere '" & oXLWSheet.name & "'" '  (" & oXLWSheet.UsedRange.Count & " Zellen)"
      
#If DoProfile Then
      hrt.StartCounting "GetFormulaRange"
#End If
      Set formulaCells = GetFormulaRange(oXLWsheet)
#If DoProfile Then
      hrt.StopCounting "GetFormulaRange"
#End If

      Dim tFormulaCount As Long
      tFormulaCount = 0
      If Not formulaCells Is Nothing Then
        tFormulaCount = formulaCells.count
      End If
      
#If DoProfile Then
  hrt.StartCounting "GetAmount"
#End If
      res.totalUsedCellAmount = res.totalUsedCellAmount + GetAmount(oXLWsheet, xlCellTypeConstants) + tFormulaCount ' GetAmount(oXLWsheet, xlCellTypeFormulas)
#If DoProfile Then
  hrt.StopCounting "GetAmount"
#End If
'      foundFormulaAmount = foundFormulaAmount + GetAmount(oXLWSheet, xlCellTypeFormulas)
      
      res.CheckSheetProtection oXLWsheet
      
'      res.CalculateSheetNameChecksum oXLWsheet
      
      res.CheckDiagrams oXLWsheet
      
      res.foundHyperlinks = res.foundHyperlinks + oXLWsheet.Hyperlinks.count
      
      Dim tc As Long
      Dim interneLinks As Long
      Dim externeLinks As Long
      For tc = 1 To oXLWsheet.Hyperlinks.count
        If oXLWsheet.Hyperlinks(tc).Address = "" Then
          res.foundInternalHyperlinks = res.foundInternalHyperlinks + 1
        Else
          res.foundExternalHyperlinks = res.foundExternalHyperlinks + 1
        End If
      Next tc
      
      
'#If DoProfile Then
'  hrt.StartCounting "StoreSheetCellTypeNumbers"
'#End If

'#If DoProfile Then
'      res.StoreSheetCellTypeNumbers oXLWsheet, outputsheet, hrt
'#Else
'      res.StoreSheetCellTypeNumbers oXLWsheet, outputsheet
'#End If
      
'#If DoProfile Then
'  hrt.StopCounting "StoreSheetCellTypeNumbers"
'#End If
      
#If DoProfile Then
  hrt.StartCounting "SheetStuff"
#End If
      res.StoreCircle oXLWsheet
              
    
      res.CheckSheetVisibility oXLWsheet
             
      ' Nur in dem vom Benutzer genutzten Bereich wird
      ' etwas gemacht
      
      UpdateStatus "Zellanalyse '" & oXLWsheet.name & "'"
      
      res.CheckHiddenColumns oXLWsheet
      
      res.CheckHiddenRows oXLWsheet
        
      If G_ColorCells Then
          With oXLWsheet.Cells
'                  .ClearComments
'                  .ClearFormats
            .Interior.Pattern = xlPatternNone
            .Interior.ColorIndex = xlNone
            .Font.ColorIndex = xlColorIndexAutomatic
            .ClearComments
            .Borders.ColorIndex = xlNone
            .Borders.LineStyle = xlLineStyleNone
            .Borders(xlDiagonalUp).LineStyle = xlLineStyleNone
          End With
      End If
#If DoProfile Then
  hrt.StopCounting "SheetStuff"
#End If
  
    
      Dim checkCellAmount As Long
      checkCellAmount = 0
      Dim totalSheetCheckAmount As Long
      
      If Not G_Schnellanalyse Then
        Dim comCells As Range
        Set comCells = GetCommentRange(oXLWsheet)
        If Not comCells Is Nothing Then
        
          ' Erst mal nach den Todos suchen...
          For Each c In comCells
            If CommentExists(c) Then
              
              Dim tpos As Long
              tpos = InStr(UCase(c.Comment.Text), "TODO:")
              If tpos > 0 Then
                todos.AddLine
                todos.AddValue "NAME", oXLWsheet.name
                todos.AddValue "ADDRESS", StripChars(c.Address, "$")
                todos.AddValue "COMMENT", "'" & Trim(Mid(c.Comment.Text, tpos + 5))
              End If
            End If
          Next c
           
          ' Und dann noch die Input-Felder checken
          If G_CheckInputs Then
              For Each c In comCells
                If c.Locked = False Then
                  inputs.AddLine
                  inputs.AddValue "NAME", oXLWsheet.name
                  inputs.AddValue "ADDRESS", StripChars(c.Address, "$")
                  If CommentExists(c) Then
                    inputs.AddValue "COMMENT", "'" & c.Comment.Text
                  End If
                End If
              Next c
            End If
        End If
        Set comCells = Nothing
      End If
      
      
#If DoProfile Then
      hrt.StartCounting "GetFormulaRange"
#End If
      Set formulaCells = GetFormulaRange(oXLWsheet)
#If DoProfile Then
      hrt.StopCounting "GetFormulaRange"
#End If
      
      lastTime = Now
      DoEvents
      SetLiveStatus
      DoEvents
      
      
      If Not formulaCells Is Nothing Then
        totalSheetCheckAmount = formulaCells.count
        If G_Schnellanalyse Then
          res.foundFormulaAmount = res.foundFormulaAmount + formulaCells.count
      
        Else
          For Each c In formulaCells
            If c.HasFormula Then
                  #If DoProfile Then
                    hrt.StartCounting "formulaCells"
                  #End If
                  checkCellAmount = checkCellAmount + 1
                  
        '          If checkCellAmount Mod 100 = 0 Then
                  If lastTime + TimeValue("0:00:02") < Now Then
                    UpdateStatus "Zellanalyse '" & oXLWsheet.name & "' (" & Format(CDbl(checkCellAmount) / CDbl(totalSheetCheckAmount), "percent") & ")"
                    lastTime = Now
                    SetLiveStatus
                  End If
                  cellCount = cellCount + 1
                  
                  If cellCount Mod 100 = 0 Then
                    If cfgProgressVisible = 1 Then
                      StatusForm.VergangeneZeit.Caption = Format(Time - startTime, "hh:mm:ss")
      '                If cellCount > 0 Then
      '                  If res.totalWorkbookCheckAmount > 0 Then
      '                    StatusForm.ProgressTxt.Caption = Format(100 / res.totalWorkbookCheckAmount * cellCount, "###0") & "%"
      '                    StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width / res.totalWorkbookCheckAmount * cellCount
      '                  End If
      '                End If
        '            Else
        '              SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "VZ", Format(Time - starttime, "hh:mm:ss")
        '              SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "RD", Format((Time - analyzestarttime) / cellCount * (totalWorkbookCheckAmount - cellCount), "hh:mm:ss")
        '              SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "PT", Format(100 / totalWorkbookCheckAmount * cellCount, "###0") & "%"
                    End If
                  End If
                  
                  
                  If Beenden = True Then
                    oxlwbook.Saved = True
                    oxlwbook.Close False
                    
                    ' Die Datei wieder freigeben
                    Set oxlwbook = Nothing
                    
        '            XLScriptAddSimpleVar "SCANSTATUS", Texte(GSprache, TXT_ABG)
                    XLScriptAddSimpleVar "STATUS", Texte(GSprache, TXT_ABG)
                    XLScriptAddSimpleVar "STATUSID", "3"
                    XLScriptAddSimpleVar "ENDOFFILESCAN", Now
                    XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
                    XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
                    Set res = Nothing
      
                    #If DoProfile Then
                                  hrt.Dump
                                  Set hrt = Nothing
                    #End If
                    If (outputsheet <> "m" And StartedByTracker = False) Or G_UserStartedProgram = True Then
                      For Each subWB In subWBs
                        CloseWB subWB
                      Next subWB
                      Set subWBs = Nothing
                    End If
                    Set subWBs = Nothing
                    Exit Function
                  End If
                  
                  #If DoProfile Then
                    hrt.StopCounting "formulaCells"
                  #End If
                  
                  
                  res.foundFormulaAmount = res.foundFormulaAmount + 1
                  
                  If Not FormulaAnalyzable(c) Then
                    #If DoProfile Then
                      hrt.StartCounting "FormulaAnalyzable"
                    #End If
                    If G_ColorCells Then
                        c.Interior.ColorIndex = 7
                        AddMyComment c, "Zelle nicht analysierbar"
                    End If
                    res.foundNonAnalyzableCells = res.foundNonAnalyzableCells + 1
                    res.nonAnalyzableCells.AddValue "", oXLWsheet.name & "!" & StripChars(c.Address, "$")
                    #If DoProfile Then
                      hrt.StopCounting "FormulaAnalyzable"
                    #End If
                  Else
                               
                    #If DoProfile Then
                      hrt.StartCounting "FormulaPart1"
                    #End If
                    ' If IsError(c) Then
                      ' If InStr(c.Formula, "#") Then
                      '  res.m_CErrorFormulas.Add c
                      '  XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value) + 1)
                      ' End If
                    
                    '  If G_ColorCells Then
                    '      With c.Borders(xlDiagonalUp)
                    '          .LineStyle = xlContinuous
                    '          .Weight = xlThick
                    '          .ColorIndex = 3
                    '      End With
                    '      AddMyComment c, "Fehlerzelle"
                    '  End If
                    
                    ' End If
                    If IsError(c) Then
                      Dim errType As Long
                      errType = res.StoreErrorType(c, outputsheet)
                      If errType > 0 Then
                        res.m_CErrorFormulas.Add c
                        XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULAERRORAMOUNT").m_Value) + 1)
                        
                        If G_ColorCells Then
                            With c.Borders(xlDiagonalUp)
                                .LineStyle = xlContinuous
                                .Weight = xlThick
                                .ColorIndex = 3
                            End With
                            AddMyComment c, "Formel mit Fehler"
                        End If
'                      ElseIf errType = 2 Then
'                        res.m_CErrorFormulaValues.Add c
'                        XLScriptGetSimpleVar("FORMULAVALUEERRORAMOUNT").m_Value = CStr(Val(XLScriptGetSimpleVar("FORMULAVALUEERRORAMOUNT").m_Value) + 1)
'
'                        If G_ColorCells Then
'                            With c.Borders(xlDiagonalUp)
'                                .LineStyle = xlContinuous
'                                .Weight = xlThick
'                                .ColorIndex = 3
'                            End With
'                            AddMyComment c, "Formel mit Fehler im Ergebnis"
'                        End If
                      End If
                    End If
                
                
                    
                    Dim clocked As Boolean
                    clocked = c.Locked
        
                
                    ' Ist das Ding gelockt?
                    If clocked = False Or res.protectedSheetsColl(oXLWsheet.name) <= 1 Then
                      
                      If (c.Width = 0 Or c.Height = 0) And clocked = False Then
                        If G_ColorCells Then
                          With c.Interior
                              .ColorIndex = 0
                              .Pattern = xlLightHorizontal
                              .PatternColorIndex = 3
                          End With
                          AddMyComment c, "Formel nicht gesch|fffd|tzt aber ausgeblendet"
                        End If
                        res.foundUnlockedFormulasNotVisible = res.foundUnlockedFormulasNotVisible + 1
                        res.foundUnlockedFormulas = res.foundUnlockedFormulas + 1
                        
                        res.m_CUnlockedFormulas.Add c
                      
                      Else
                        
                        If clocked = True Then
                          If res.protectedSheetsColl(oXLWsheet.name) = 1 Then
                            res.foundLockedFormulasWithoutSheetpassword = res.foundLockedFormulasWithoutSheetpassword + 1
                            If G_ColorCells Then
                                With c.Interior
                                    .ColorIndex = 0
                                    .Pattern = xlLightVertical
                                    .PatternColorIndex = 3
                                End With
                                AddMyComment c, "Ungesch|fffd|tzte Formel (Blattschutz ohne Passwort)"
                            End If
                          Else
                            res.foundLockedFormulasMissingSheetprotect = res.foundLockedFormulasMissingSheetprotect + 1
                            If G_ColorCells Then
                                With c.Interior
                                    .ColorIndex = 0
                                    .Pattern = xlLightVertical
                                    .PatternColorIndex = 3
                                End With
                                AddMyComment c, "Ungesch|fffd|tzte Formel (Blattschutz fehlt)"
                            End If
                          End If
                        
                        Else
                        
                          res.foundUnlockedFormulas = res.foundUnlockedFormulas + 1
                          
                          res.m_CUnlockedFormulas.Add c
                        
                          If G_ColorCells Then
                              With c.Interior
                                  .ColorIndex = 0
                                  .Pattern = xlLightVertical
                                  .PatternColorIndex = 3
                              End With
                              AddMyComment c, "Ungesch|fffd|tzte Formel"
                          End If
                        
                        End If
                      End If
                    
                    End If
                  
                  ' ******************************************************
                  ' FORMELANALYSE
                  ' ******************************************************
                      
                    Dim tformula As String
                    tformula = c.Formula
                    #If DoProfile Then
                      hrt.StopCounting "FormulaPart1"
                    #End If
                    
                    ' --------------------------------------------------
                    ' Clone identifizieren
                    ' --------------------------------------------------
                    
                    Dim abweichung As Boolean
                    Dim cs As CloneStuff
                    #If DoProfile Then
                      hrt.StartCounting "IsClone"
                    #End If
                    
                    abweichung = Not res.IsClone(c, cs)
                    
                    #If DoProfile Then
                      hrt.StopCounting "IsClone"
                    #End If
                    
                    ' --------------------------------------------------
                    ' Wenn Clon
                    ' --------------------------------------------------
                    ' Wenns keine Abweichung gibt ist es ein Replikat
                    If Not abweichung Then
                      
                      If G_ColorCells Then
                          If c.Interior.ColorIndex = xlNone Then
                            c.Interior.ColorIndex = 4
                          End If
                          AddMyComment c, "Gesch|fffd|tzte Formel (Klon)"
                      End If
                      
                      #If DoProfile Then
                        hrt.StartCounting "CloneStuff"
                      #End If
                      res.foundFormulaDuplicateAmount = res.foundFormulaDuplicateAmount + 1
                    
                      res.checksum = (res.checksum + cs.m_CheckSum) Mod ChecksumMod
                    
                      res.foundIfDuplicateAmount = res.foundIfDuplicateAmount + cs.m_IF
                      res.foundCalcDuplicateAmount = res.foundCalcDuplicateAmount + cs.m_Calc
                      res.foundSumDuplicateAmount = res.foundSumDuplicateAmount + cs.m_Sum
                      res.foundMatrixDuplicateFuncs = res.foundMatrixDuplicateFuncs + cs.m_Array
                      res.foundCellreferencesDuplicateAmount = res.foundCellreferencesDuplicateAmount + cs.m_Ref
                    
                      res.foundIfAmount = res.foundIfAmount + cs.m_IF
                      res.foundCalcAmount = res.foundCalcAmount + cs.m_Calc
                      res.foundSumAmount = res.foundSumAmount + cs.m_Sum
                      res.foundMatrixFuncs = res.foundMatrixFuncs + cs.m_Array
                      res.foundCellreferencesAmount = res.foundCellreferencesAmount + cs.m_Ref
                      #If DoProfile Then
                        hrt.StopCounting "CloneStuff"
                      #End If
                    
                    ' --------------------------------------------------
                    ' Wenn NICHT Clon
                    ' --------------------------------------------------
                    Else
                        #If DoProfile Then
                          hrt.StartCounting "NotCloneStart"
                        #End If
                        If G_ColorCells Then
                            If c.Interior.ColorIndex = xlNone Then
                              c.Interior.ColorIndex = 15
                              AddMyComment c, "Gesch|fffd|tzte Formel"
                            End If
                        End If
                        
                        Dim openbracam As Long
                        openbracam = res.CheckOpenBracAm(c, cs)  ' XXX Ber|fffd|cksichtigt mit Absicht keine Namen!
                        
                        ' Der Funktionsexporter!
                        funcEx.AddLine
                        funcEx.AddValue "NAME", oXLWsheet.name
                        funcEx.AddValue "ADDRESS", StripChars(c.Address, "$")
                        If c.HasArray = True Then
                          funcEx.AddValue "TYPE", "M"
                        Else
                          funcEx.AddValue "TYPE", "F"
                        End If
                        funcEx.AddValue "FORMULALEN", Len(tformula)
                        funcEx.AddValue "OPENBRACAM", CStr(openbracam)
                        funcEx.AddValue "FORMULA", "'" & GetFormulaText(c, tformula) ' IIf(IsError(c), tFormula, c.FormulaLocal)
                        
                        If Not G_ColorCells Then
                          If CommentExists(c) Then
                            funcEx.AddValue "COMMENT", "'" & c.Comment.Text
                          Else
                            ' So, jetzt schauen wir noch mal, ob in der Zelle dar|fffd|ber KEINE formel ist und ein Kommentar angebracht wurde, dann nehmen wir den
                            Dim foundComment As Boolean
                            foundComment = False
                            If c.Row > 1 Then
                              Dim tr As Range
                              Set tr = Cells(c.Row - 1, c.Column)
                              If tr.HasFormula = False Then
                                If CommentExists(tr) Then
                                  funcEx.AddValue "COMMENT", "'" & tr.Comment.Text
                                  foundComment = True
                                End If
                              End If
                            End If
                            If Not foundComment Then funcEx.AddValue "COMMENT", ""
                          End If
                        End If
                        
                        
                        funcEx.AddValue "ERROR", "'" & IIf(IsError(c), "X", "")
                        ' res.funcExportLine = res.funcExportLine + 1
        
                        If Not IsError(c) Then
                                    ' tformula = c.FormulaLocal
                                    If Len(tformula) > res.longestFormula Then
                                      res.longestFormula = Len(tformula)
                                    End If
                                    If Len(tformula) > res.tabLongestFormula Then
                                      res.tabLongestFormula = Len(tformula)
                                    End If
                                    
                        End If
                        #If DoProfile Then
                          hrt.StopCounting "NotCloneStart"
                        #End If
      
                                
                        #If DoProfile Then
                          hrt.StartCounting "CheckDimensions"
                        #End If
                        If G_CheckDimension Then
                              Dim x As Long
                              Dim y As Long
                              Dim z As Long
                              Dim xy As Long
                              
                              res.CheckDimensions oxlwbook, c, x, y, z, xy
                              
                              funcEx.AddValue "DIMENSIONX", CStr(x)
                              funcEx.AddValue "DIMENSIONY", CStr(y)
                              funcEx.AddValue "DIMENSION2D", CStr(xy)
                              funcEx.AddValue "DIMENSION3D", CStr(z)
                              
                              res.m_Dimension.Check x, y, z, xy
                              res.m_TabDimension.Check x, y, z, xy
                        Else
                              funcEx.AddValue "DIMENSIONX", "'-/-"
                              funcEx.AddValue "DIMENSIONY", "'-/-"
                              funcEx.AddValue "DIMENSION2D", "'-/-"
                              funcEx.AddValue "DIMENSION3D", "'-/-"
                        End If
                        #If DoProfile Then
                          hrt.StopCounting "CheckDimensions"
                        #End If
                        
                    
                        ' --------------------------------------------------
                        ' 18.4.03 - Nt - Checksummenberechnung f|fffd|r Formeln
                        ' --------------------------------------------------
                        #If DoProfile Then
                          hrt.StartCounting "ChecksumFormula"
                        #End If
                        Dim tchecksum As Long
                        tchecksum = 0
                        For counter = 1 To Len(tformula)
                          tchecksum = (tchecksum + CLng(Asc(Mid(tformula, counter, 1))) * counter) Mod ChecksumMod
                        Next counter
                        cs.m_CheckSum = tchecksum
                        res.checksum = (res.checksum + cs.m_CheckSum) Mod ChecksumMod
                        #If DoProfile Then
                          hrt.StopCounting "ChecksumFormula"
                        #End If
                    
                    
                        #If DoProfile Then
                          hrt.StartCounting "FormulaPart2"
                        #End If
                    
                        Dim thisFormulaWithNamesExtracted As String
                        thisFormulaWithNamesExtracted = tformula
                        
                        ' --------------------------------------------------
                        ' Namen ersetzen
                        ' --------------------------------------------------
                        Dim nameItem As name
                        For Each nameItem In oxlwbook.Names
                          If Left(nameItem.name, 11) <> "_IDVTracker" Then
                            thisFormulaWithNamesExtracted = MyReplace(thisFormulaWithNamesExtracted, nameItem.name, Mid(nameItem.RefersTo, 2), True, "'", Chr(34))
                          End If
                        Next nameItem
                        
                        cs.m_FormulaExtractedNames = thisFormulaWithNamesExtracted
                        
                        Dim posStartRef As Long
                        Dim posEndRef As Long
                        Dim posStartBrac As Long
                        Dim posEndBrac As Long
                        
                        posStartRef = InStr(thisFormulaWithNamesExtracted, "('")
                        If posStartRef > 0 Then
                          posEndRef = InStr(posStartRef + 2, thisFormulaWithNamesExtracted, "'")
                          posStartBrac = InStr(posStartRef + 2, thisFormulaWithNamesExtracted, "[")
                          If posStartBrac > 0 Then
                            posEndBrac = InStr(posStartRef + 2, thisFormulaWithNamesExtracted, "]")
                            If posStartBrac > posStartRef And posEndBrac > posStartRef And posEndBrac > posStartBrac And posStartBrac < posEndRef And posEndBrac < posEndRef Then
                              cs.m_HasExternalRefs = True
                            End If
                          End If
                        End If
                        
                        Dim thisFormulaWithNamesExtractedNoRef As String
                        thisFormulaWithNamesExtractedNoRef = RemoveStrings(thisFormulaWithNamesExtracted, Chr(34), Chr(34))
                        thisFormulaWithNamesExtractedNoRef = RemoveStrings(thisFormulaWithNamesExtractedNoRef, "'", "'")
                    
                        ' --------------------------------------------------
                        ' Gibt es WENN Bedingungen
                        ' --------------------------------------------------
                        If InStr(thisFormulaWithNamesExtractedNoRef, "IF(") <> 0 Then
                            res.foundIfAmount = res.foundIfAmount + 1
                            cs.m_IF = 1
                        End If
                        
                        ' --------------------------------------------------
                        ' Gibt es darin plus und minus etc...
                        ' --------------------------------------------------
                        If InStr(thisFormulaWithNamesExtractedNoRef, "+") <> 0 Or InStr(thisFormulaWithNamesExtractedNoRef, "-") <> 0 Or _
                           InStr(thisFormulaWithNamesExtractedNoRef, "*") <> 0 Or InStr(thisFormulaWithNamesExtractedNoRef, "/") <> 0 Or InStr(thisFormulaWithNamesExtractedNoRef, "^") <> 0 Then
                            res.foundCalcAmount = res.foundCalcAmount + 1
                            cs.m_Calc = 1
                        End If
                        
                        ' --------------------------------------------------
                        ' nach Summen suchen
                        ' --------------------------------------------------
                        If InStr(thisFormulaWithNamesExtractedNoRef, "SUM(") Then
                          res.foundSumAmount = res.foundSumAmount + 1
                          cs.m_Sum = 1
                        End If
                        
                        ' --------------------------------------------------
                        ' Ist es eine Matrix??
                        ' --------------------------------------------------
                        If c.HasArray = True Then
                          res.foundMatrixFuncs = res.foundMatrixFuncs + 1
                          cs.m_Array = 1
                        End If
                    
      #If DoProfile Then
        hrt.StopCounting "FormulaPart2"
      #End If
                    
                    End If
                    
                    
                  End If
                    
      
                    
                  ' --------------------------------------------------
                  ' Alle extern referenzierten Dateien werden gez|fffd|hlt
                  ' --------------------------------------------------
      #If DoProfile Then
        hrt.StartCounting "HasExternalRefs"
      #End If
                  If cs.m_HasExternalRefs Then
                    res.foundCellsWithExternalReferences = res.foundCellsWithExternalReferences + 1
                    If G_ColorCells Then
                        With c.Borders(xlDiagonalUp)
                          .LineStyle = xlContinuous
                          .Weight = xlThick
                          .ColorIndex = 14
                        End With
                        AddMyComment c, "Verlinkte Datei"
                    End If
                  End If
                  
                  
                  res.CheckRiskContains c, cs.m_FormulaExtractedNames
                  
                  
                  ' --------------------------------------------------
                  ' Funktionsauswertung
                  ' --------------------------------------------------
                  ' Wenn funcs an ist
      
                  If cfgFunktionenAuswerten = 1 And Mode = 1 Then
                      Dim pos As Long
                      pos = 1
                      
                      Dim rv As RiskVal
                      For Each rv In G_WhiteList
                        rv.m_Hit = False
                      Next rv
                      
                      Do
                        pos = InStr(pos, cs.m_FormulaExtractedNames, "(")
                        If pos <= 0 Then Exit Do
                        Dim endPos As Long
                        endPos = pos
                        pos = pos - 1
                        Do While pos > 1 And IsCharOrNumber(Mid(cs.m_FormulaExtractedNames, pos, 1))
                          pos = pos - 1
                        Loop
                        If endPos - pos > 1 Then
                          Dim testfuc As String
                          testfuc = UCase(Mid(cs.m_FormulaExtractedNames, pos + 1, endPos - pos - 1))
                          res.CheckFunc testfuc
                          For Each rv In G_WhiteList
                            If Not rv.m_Hit Then
                              rv.CheckFunc testfuc
                            End If
                          Next rv
                        End If
                        
                        pos = endPos + 1
                        
                      Loop
                  End If
      #If DoProfile Then
        hrt.StopCounting "HasExternalRefs"
      #End If
            End If
          Next c
        End If
      End If 'Next
      
#If DoProfile Then
  hrt.StartCounting "Output"
#End If
      
      If G_ColorCells Then
        oXLWsheet.Cells.EntireRow.Hidden = False
        oXLWsheet.Cells.Rows.AutoFit
        oXLWsheet.Cells.EntireColumn.Hidden = False
        oXLWsheet.Cells.Columns.AutoFit
      End If
      
      
      If cfgProgressVisible = 1 Then
        StatusForm.VergangeneZeit.Caption = Format(Time - startTime, "hh:mm:ss")
        If cellCount > 0 Then
'          StatusForm.Restdauer.Caption = Format((Time - analyzestarttime) * (res.totalWorkbookCheckAmount - cellCount) / cellCount, "hh:mm:ss")
          If res.totalWorkbookCheckAmount > 0 Then
            StatusForm.ProgressTxt.Caption = Format(100 / res.totalWorkbookCheckAmount * cellCount, "###0") & "%"
            StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width / res.totalWorkbookCheckAmount * cellCount
          End If
        End If
      End If
      UpdateStatus "Zellanalyse '" & oXLWsheet.name & "' (100%)"
    
    End If
    
    res.StoreSheetResulsts oXLWsheet
    
    sheetCnt = sheetCnt + 1
    If cfgProgressVisible = 1 Then
        StatusForm.ProgressTxt.Caption = Format(100 / oxlwbook.Worksheets.count * sheetCnt, "###0") & "%"
        StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width / oxlwbook.Worksheets.count * sheetCnt
    End If
    
    
  Next oXLWsheet
#If DoProfile Then
  hrt.StopCounting "Output"
#End If
  
  res.CreateHiddenStuff
  
#If DoProfile Then
  hrt.Dump
  Set hrt = Nothing
#End If
  
  
  
'  If Not XLScriptGetArray2D("TODOS") Is Nothing Then
'    If XLScriptGetArray2D("TODOS").items.count > 0 Then
'      Dim ti As Long
'      For ti = 1 To XLScriptGetArray2D("TODOS").items.count
'        Debug.Print XLScriptGetArray2D("TODOS").items(ti)("COMMENT")
'        Debug.Print XLScriptGetArray2D("TODOS").items(ti)("NAME") & "!" & XLScriptGetArray2D("TODOS").items(ti)("ADDRESS")
'      Next ti
'    End If
'  End If

  If (outputsheet <> "m" And StartedByTracker = False) Or G_UserStartedProgram = True Then
    For Each subWB In subWBs
      CloseWB subWB
    Next subWB
    Set subWBs = Nothing
  End If
  
  
  ' ------------------------------------------
  ' Ergebnisse speichern
  ' ------------------------------------------
  
  res.StoreResults
  
  If cfgAusf|fffd|hrlich = 1 And Mode = 1 Then
      res.CreateGlobalFuncArray
  End If
  
  XLScriptAddSimpleVar "AUTHOR", GetDocProp(oxlwbook, "Author")
  XLScriptAddSimpleVar "CREATIONDATE", GetDocProp(oxlwbook, "Creation date")
  
  oxlwbook.Saved = True
  
  ' Die Datei wieder freigeben
  If Not G_ColorCells Then
    oxlwbook.Close False
    Set oxlwbook = Nothing
  Else
    oxlwbook.Saved = True
    MsgBox "ACHTUNG! Die analysierte Datei ist jetzt ge|fffd|ffnet und eingef|fffd|rbt!" & vbCrLf & vbCrLf & "SPEICHERN SIE DIESE DATEI UNTER KEINEN UMST|fffd|NDEN |fffd|BER DAS ORIGINAL!!!", vbCritical, "Excel-Sheet-Checker"
  End If
  
  XLScriptAddSimpleVar "TIMEELAPSED", Format(Time - startTime, "hh:mm:ss")
  XLScriptAddSimpleVar "ENDOFFILESCAN", Now
  
  XLScriptAddSimpleVar "STATUS", Texte(GSprache, TXT_ANALYSIERT)
  XLScriptAddSimpleVar "STATUSID", "4"
  LogPrintECCSCanLog theidvDateiID, 4, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Analyse erfolgreich beendet, Checksumme: " & XLScriptGetSimpleVar("CHECKSUM").m_Value
  If G_Break Then
    MsgBox "Break possibility Analyse beendet"
  End If
  
  CreateRisk
  
  Set res = Nothing
  
  LogPrint "DoAnalyse-Finished"
  
  Exit Function
  
cmdExcel_Err:

  CurrentStatus = 99
  Debug.Print "Fehler in der ECC-Analyse: " & Err.Number
  LogPrintECCSCanLog theidvDateiID, 6, theFilename & " (ID: " & theidvDateiID & ") - Ergebnis: Fehler in der Analyse: " & Err.Number
  
  If Err.Number = 0 Then Resume Next
  
  Dim errnr As Long
  errnr = Err.Number
  Dim errdesc As String
  errdesc = Err.Description
  Dim errsrc As String
  errsrc = Err.Source
  
  AddStatus Err.Description
  If cfgProgressVisible = 1 Then
    If StartedByTracker = False And StartedByDaemon = False Then
      If outputsheet = "e" Or GetUserName() = "norman" Or GetUserName() = "S0014443" Then
        If ignoreAllFurtherErrors = False Then
          MsgBox errdesc & vbCrLf & errnr & vbCrLf & errsrc, vbCritical, "Excel-Sheet-Checker"
          If MsgBox("Wollen Sie die Verarbeitung abbrechen?", vbYesNo, "Excel-Sheet-Checker") = vbYes Then
            Beenden = True
            Exit Function
          Else
            If GetUserName() = "norman" Or GetUserName() = "S0014443" Then
              If MsgBox("RESUME NEXT NORMAN?", vbYesNo) = vbYes Then
                Resume Next
              End If
            End If
            If MsgBox("Sollen weitere Fehler ignoriert werden?", vbYesNo, "Excel-Sheet-Checker") = vbYes Then
              ignoreAllFurtherErrors = True
            End If
          End If
        End If
      End If
    End If
    Resume Next
  End If
  
  Exit Function

closeAndLeave:
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  Application.EnableEvents = False
  oxlwbook.Close False
  Application.EnableEvents = oldenev
  Exit Function
End Function

Sub AddStatus(txt As String, Optional col As Long = 196)
  LastProgText = ProgText
  If Len(ProgText) > 0 Then
    ProgText = ProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
'  Debug.Print txt
  If cfgProgressVisible = 1 Then
    StatusForm.ProgText = Right(ProgText, 16000)
    StatusForm.Repaint
    StatusForm.ProgText.SelStart = Len(ProgText)
'    StatusForm.ProgText.CurLine = 10000
  Else
'    SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "STATUS", ProgText
  End If
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
  
  WriteTimeStamp
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt, col
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus), col

'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "SSTATUS", txt
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "CURSTATUS", CStr(CurrentStatus)

End Sub

Function OpenExternalReferences(ByRef wb As Workbook, outputsheet As String, ByRef subWBs As Collection, ByRef errTxt As String) As Boolean
  On Error GoTo nogo
  Dim aLinks
  Dim i As Long
  Dim Result As Boolean
  Result = True
  aLinks = wb.LinkSources(xlExcelLinks)
  If Not IsEmpty(aLinks) Then
      For i = 1 To UBound(aLinks)
        If FileExists(CStr(aLinks(i))) Then
          Dim wbsub As Workbook
          If GetFile(CStr(aLinks(i)), wbsub, outputsheet) Then
            subWBs.Add wbsub
            If Not OpenExternalReferences(wbsub, outputsheet, subWBs, errTxt) Then
              Result = False
            End If
          Else
            errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & "Die Datei '" & CStr(aLinks(i)) & "' konnte nicht ge|fffd|ffnet werden."
            Result = False
          End If
        Else
          errTxt = errTxt & IIf(errTxt <> "", vbLf, "") & "Die Datei '" & CStr(aLinks(i)) & "' existiert nicht."
          Result = False
        End If
      Next i
  End If
  OpenExternalReferences = Result
  
  Exit Function
nogo:
  
End Function


Function GetFile(Filename As String, ByRef oxlwbook As Excel.Workbook, outputsheet As String) As Boolean
  Dim msgBoxText                As String
  
  GetFile = True
  ' |fffd|ffnen der Datei - Bei Error auf Passwort pr|fffd|fen
  On Error GoTo hatPasswort
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  Application.EnableEvents = False
  Dim oldalert As Boolean
  oldalert = ThisWorkbook.Application.DisplayAlerts
  ThisWorkbook.Application.DisplayAlerts = False
  ThisWorkbook.Application.AskToUpdateLinks = False
  Dim oldAutomation As Long
  oldAutomation = ThisWorkbook.Application.AutomationSecurity
  ThisWorkbook.Application.AutomationSecurity = msoAutomationSecurityLow

'  If UCase(right(Filename, 5)) = ".XLSX" Then
'    GetFile = False
'    Exit Function
'  End If
  
  SetLiveStatusFunc "WorkbooksOpen", True
  
  Dim PW As String
  If StartedByTracker Then
    PW = GetFilePassword(Filename, 1)
  End If
  
  AddStatus "|fffd|ffne " & Filename
  If (outputsheet <> "m" And StartedByTracker = False) Or G_UserStartedProgram = True Then
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
  Else
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , IIf(PW = "", "Testpasswort", PW), , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , "Testpasswort", , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
  End If
  ThisWorkbook.Application.AutomationSecurity = oldAutomation
  SetLiveStatusFunc "WorkbooksOpen", False
  SetLiveStatus
    
  ThisWorkbook.Application.AskToUpdateLinks = True
  ThisWorkbook.Application.DisplayAlerts = oldalert
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Application.EnableEvents = oldenev
  GoTo openOk
  
hatPasswort:

    ' Sollte die Datei ein Passwort haben, dann geben wir einen enstprechenden Text aus
    If (outputsheet <> "m" And StartedByTracker = False) Or G_UserStartedProgram = True Then
      If Not StartedByTracker Then
        msgBoxText = Texte(GSprache, TXT_DATEIPASSWORTSCHUTZ) & vbCrLf & Err.Description
        MsgBox msgBoxText, vbCritical, "Excel-Sheet-Checker"
      Else
        AddStatus Texte(GSprache, TXT_DATEIPASSWORTSCHUTZ) & vbCrLf & Err.Description
      End If
    Else
      AddStatus Texte(GSprache, TXT_DATEIPASSWORTSCHUTZ) & vbCrLf & Err.Description
    End If
'    If Len(MassenMappe) > 0 Then
        ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'        Workbooks(MassenMappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, tabxM2).Value = Texte(GSprache, TXT_DATEVGESCH) & " (" & Err.Description & ")"
'    End If
    On Error GoTo 0
    
    GetFile = False
    Exit Function
openOk:
  ' On Error wieder zur|fffd|cksetzen
  On Error GoTo 0
      
  ' 3.4.03 - Nt
  ' Wenn das Projekt gesch|fffd|tzt ist, muss ein gesonderter Warnvermerk ausgegeben werden!
  VBAFailure = 0
  On Error GoTo CheckNewerVersion
  
'  If Not CheckVBAAccessAllowed() Then
'  End If
  
  
  If oxlwbook.VBProject.Protection = 1 Then ' vbext_pp_locked
      VBAFailure = 1
    
    
Debug.Print "XXX Hier muss noch der VBA-Test rein"
'    If Len(EinzelMappe) > 0 Then
'      msgBoxText = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'      MsgBox msgBoxText
'    Else
        ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'        Workbooks(massenmappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, 2).Value = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'    End If
'    oXLWBook.Close False
'    Exit Sub
  End If
  GoTo continueCheck

CheckNewerVersion:
Debug.Print "XXX Hier muss noch der VBA-Test raus"
  On Error GoTo 0
'  If Len(EinzelMappe) > 0 And Len(MassenMappe) = 0 Then
'    msgBoxText = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'    MsgBox msgBoxText
'  End If
'  If Len(MassenMappe) > 0 Then
    ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'    Workbooks(MassenMappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, tabxM2).Value = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'  End If
  VBAFailure = 2
  
continueCheck:

End Function

Function GetExcelFile(Filename As String, ByRef oxlwbook As Excel.Workbook) As Boolean
  Dim msgBoxText                As String
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  GetExcelFile = True
  On Error GoTo fehler
  Application.EnableEvents = False
  Set oxlwbook = Workbooks.Open(ShortFileName(Filename))
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Application.EnableEvents = oldenev
  Exit Function
  
fehler:
  GetExcelFile = False
End Function


Function IsChar(t As String) As Boolean
    IsChar = False
    If (t >= "A" And t <= "Z") Or (t >= "a" And t <= "z") Then IsChar = True
End Function
Function IsCharOrNumber(t As String) As Boolean
    IsCharOrNumber = False
    If (t >= "A" And t <= "Z") Or (t >= "a" And t <= "z") Or IsNumeric(t) Then IsCharOrNumber = True
End Function

Sub CrackSheet(oXLWsheet)
  On Error Resume Next
  oXLWsheet.Protect "", userinterfaceonly:=True
  CrackSheet2 (oXLWsheet)
End Sub
Sub CrackSheet2(oXLWsheet)
  On Error Resume Next
  oXLWsheet.[A1].Copy oXLWsheet.[A1]
  oXLWsheet.[B1].Copy oXLWsheet.[B1]
  oXLWsheet.[A2].Copy oXLWsheet.[A2]
  oXLWsheet.[A3].Copy oXLWsheet.[A3]
  oXLWsheet.[AA2].Copy oXLWsheet.[AA2]
End Sub

Function GetCommentRange(oXLWsheet)
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  Set GetCommentRange = Nothing
  Application.DisplayAlerts = False
  On Error Resume Next
  Dim xlCalc As Long
  xlCalc = Application.Calculation
  Application.Calculation = xlCalculationManual
  SetLiveStatusFunc "SpecialCells", True
  Set GetCommentRange = oXLWsheet.Cells.SpecialCells(xlCellTypeComments)
  SetLiveStatusFunc "SpecialCells", False
  Application.Calculation = xlCalc
  Application.DisplayAlerts = olddisplayalerts
  SetLiveStatus
End Function


Function GetFormulaRange(oXLWsheet)
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  Set GetFormulaRange = Nothing
  Application.DisplayAlerts = False
  On Error Resume Next
  Dim xlCalc As Long
  xlCalc = Application.Calculation
  Application.Calculation = xlCalculationManual
  SetLiveStatusFunc "SpecialCells", True
  Set GetFormulaRange = oXLWsheet.Cells.SpecialCells(xlCellTypeFormulas)
  SetLiveStatusFunc "SpecialCells", False
  Application.Calculation = xlCalc
  Application.DisplayAlerts = olddisplayalerts
  SetLiveStatus
End Function

Function GetAmount(ByRef oXLWsheet As Excel.Worksheet, t As Long) As Long
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  GetAmount = 0
  Dim xlCalc As Long
  xlCalc = Application.Calculation
  Application.Calculation = xlCalculationManual
  Application.DisplayAlerts = False
  SetLiveStatusFunc "SpecialCells", True
  GetAmount = oXLWsheet.Cells.SpecialCells(t).count
  SetLiveStatusFunc "SpecialCells", False
  Application.DisplayAlerts = olddisplayalerts
  Application.Calculation = xlCalc
  SetLiveStatus
End Function
Function GetAmountType(ByRef oXLWsheet As Excel.Worksheet, t As Long, v As Long) As Long
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  GetAmountType = 0
  Dim xlCalc As Long
  xlCalc = Application.Calculation
  Application.Calculation = xlCalculationManual
  Application.DisplayAlerts = False
  SetLiveStatusFunc "SpecialCells", True
  GetAmountType = oXLWsheet.Cells.SpecialCells(t, v).count
  SetLiveStatusFunc "SpecialCells", False
  Application.DisplayAlerts = olddisplayalerts
  Application.Calculation = xlCalc
  SetLiveStatus
End Function

Function GetAmountErrors(ByRef oXLWsheet As Excel.Worksheet, ByRef nullam As Long, ByRef div0am As Long, ByRef valueam As Long, ByRef refam As Long, ByRef nameam As Long, ByRef numam As Long, ByRef naam As Long) As Long
  On Error Resume Next
  Dim olddisplayalerts As Boolean
  olddisplayalerts = Application.DisplayAlerts
  GetAmountErrors = 0
  Dim r As Range
  Dim xlCalc As Long
  xlCalc = Application.Calculation
  Application.Calculation = xlCalculationManual
  Application.DisplayAlerts = False
  SetLiveStatusFunc "SpecialCells", True
  Set r = oXLWsheet.Cells.SpecialCells(xlCellTypeFormulas, 16)
  SetLiveStatusFunc "SpecialCells", False
  Application.DisplayAlerts = olddisplayalerts
  Application.Calculation = xlCalc
  SetLiveStatus
  GetAmountErrors = r.count
  nullam = 0
  div0am = 0
  valueam = 0
  refam = 0
  nameam = 0
  numam = 0
  naam = 0
  
  Dim c As Range
  For Each c In r
    Select Case c.Value
      Case CVErr(xlErrNull)
        nullam = nullam + 1
      Case CVErr(xlErrDiv0)
        div0am = div0am + 1
      Case CVErr(xlErrValue)
        valueam = valueam + 1
      Case CVErr(xlErrRef)
        refam = refam + 1
      Case CVErr(xlErrName)
        nameam = nameam + 1
      Case CVErr(xlErrNum)
        numam = numam + 1
      Case CVErr(xlErrNA)
        naam = naam + 1
    End Select
  Next c

End Function
  


Sub UpdateStatus(txt As String)
  If Len(LastProgText) > 0 Then
    ProgText = LastProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
'  Debug.Print txt
  If cfgProgressVisible = 1 Then
    StatusForm.ProgText = Right(ProgText, 16000)
    StatusForm.Repaint
    StatusForm.ProgText.SelStart = Len(ProgText)
'    StatusForm.ProgText.CurLine = 10000
  Else
'    SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "STATUS", ProgText
  End If
  
  If theTrackerFreigabe Then
    StoreUserCommunicateValue "TU", ProgText
  End If
  
  WriteTimeStamp
  DoEvents
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus)
  
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "SSTATUS", txt
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "CURSTATUS", CStr(CurrentStatus)
End Sub

Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn1 As String = "", Optional ignoreIn2 As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore1 As Boolean
  Dim inIgnore2 As Boolean
  
  inIgnore1 = False
  inIgnore2 = False
  
  Dim lenIgnoreIn1 As Long
  Dim lenIgnoreIn2 As Long
  
  lenIgnoreIn1 = Len(ignoreIn1)
  lenIgnoreIn2 = Len(ignoreIn2)
  
  
  For txtPos = 1 To Len(txt)
    If Mid(txt, txtPos, lenIgnoreIn1) = ignoreIn1 Then
      If Not inIgnore1 Then
        inIgnore1 = True
      Else
        inIgnore1 = False
      End If
    End If
    
    If Mid(txt, txtPos, lenIgnoreIn2) = ignoreIn2 Then
      If Not inIgnore2 Then
        inIgnore2 = True
      Else
        inIgnore2 = False
      End If
    End If
    
    If inIgnore1 = False And inIgnore2 = False Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function




Function MyReplace2(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim ok As Boolean
  txtPos = 1
  Do
    txtPos = InStr(txtPos, txt, searchtxt)
    If txtPos > 0 Then
      ok = True
      Dim tval As String
      If checkStartAndEnd Then
        If txtPos > 1 Then
          tval = Mid(txt, txtPos - 1, 1)
          If (tval >= "a" And tval <= "z") Or _
             (tval >= "A" And tval <= "Z") Or _
             (tval >= "0" And tval <= "9") Or _
             tval = "_" Then
              ok = False
          End If
        End If
        If txtPos + Len(searchtxt) <= Len(txt) Then
          tval = Mid(txt, txtPos + Len(searchtxt), 1)
          If (tval >= "a" And tval <= "z") Or _
             (tval >= "A" And tval <= "Z") Or _
             (tval >= "0" And tval <= "9") Or _
             tval = "_" Then
              ok = False
          End If
        End If
      End If
      If ok Then
          If txtPos - 1 > 0 Then
              tStringRep = Left(txt, txtPos - 1)
          Else
              tStringRep = ""
          End If
          tStringRep = tStringRep + replacetxt
          tStringRep = tStringRep + Mid(txt, txtPos + Len(searchtxt))
          txt = tStringRep
          txtPos = 1
      Else
        txtPos = txtPos + 1
      End If
    End If
  Loop While txtPos > 0 And txtPos < Len(txt)
  MyReplace2 = txt
End Function


Sub StripExcelSpecificStuff(ByRef tName As String)
  Dim tpos As Long
  tpos = InStr(tName, "[")
  If tpos > 0 Then
    Dim t As String
    If tpos > 1 Then
      t = Left(tName, tpos - 1)
    End If
    Dim tPosR As Long
    
    tPosR = InStr(tName, "]")
    If tPosR > 0 Then
      t = t + Mid(tName, tpos + 1, tPosR - tpos - 1)
      tName = t
    End If
  End If
  
End Sub

Public Sub WriteTimeStamp()
  On Error Resume Next
  ' Alle 30 Sekunden wird ein Timestamp gesetzt
  If LastTimeStamp + TimeValue("0:00:30") > Now Then Exit Sub
  LastTimeStamp = Now
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "TIMESTAMP", CStr(LastTimeStamp)

'  Open ThisWorkbook.Path & "\ECCEngineTimeStamp" & cfgSlotID & ".Cfg" For Output As #1
'  Write #1, LastTimeStamp
'  Close #1
End Sub

Sub GetFuncs()
  Set Funcs = New Collection
  Dim f As Func
  Dim lastHeadF As Func
  Set lastHeadF = Nothing
  Dim oxlwbook As Excel.Workbook
  On Error GoTo FuncIsMissing
  Set oxlwbook = Workbooks.Open(ThisWorkbook.Path & "\ECCFuncs.xls")
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  Dim y As Long
  y = 2
  While Not IsEmpty(oxlwbook.Worksheets("Funktionen").Cells(y, 2))
    If Not IsEmpty(oxlwbook.Worksheets("Funktionen").Cells(y, 1)) Then
        Set f = New Func
        f.name = oxlwbook.Worksheets("Funktionen").Cells(y, 2)
        If Not IsEmpty(oxlwbook.Worksheets("Funktionen").Cells(y, 2 + GSprache)) Then
          f.Trans = oxlwbook.Worksheets("Funktionen").Cells(y, 2 + GSprache)
        Else
          f.Trans = TranslateFuncToLocal(oxlwbook.Worksheets("Funktionen").Cells(y, 2))
        End If
        If Left(f.name, 4) = "### " Then
            Set lastHeadF = f
            Set f.Head = Nothing
        Else
            If Not TypeName(lastHeadF) = "Nothing" Then
                Set f.Head = lastHeadF
            End If
        End If
        Funcs.Add f
        Set f = Nothing
    End If
    y = y + 1
  Wend
  oxlwbook.Close
  Set oxlwbook = Nothing

FuncIsMissing:
End Sub
  
Function GetFormulaText(c As Range, tformula As String)
  
  On Error Resume Next
  GetFormulaText = tformula
  
  If Not IsError(c) Then
    GetFormulaText = c.FormulaLocal
  End If

End Function

Sub ShowStatusForm(Headline As String)
  StatusForm.ProgressB.Width = 0
  StatusForm.ProgressBT.Width = 0
  StatusForm.Filename = Headline
  StatusForm.VergangeneZeit = ""
'  StatusForm.Restdauer = ""
  StatusForm.ProgText = ""
  LastProgText = ""
  ProgText = ""
  
  If StartedByTracker Then
    If Not G_SchedulerTimeCheckIgnore Then
      If Not theTrackerFreigabe Then
        ' ProgText = "Scanzeitraum: " & G_StartScan & " - " & G_EndScan
      End If
    End If
                 
    StatusForm.ProgText = ProgText
  End If
  
'  StatusForm.BitteWarten.Visible = False
  DoEvents
  
'  If StartedByTracker Then
'    StatusForm.cmdAbbrechen.Visible = False
'    StatusForm.BitteWarten.Visible = True
'  Else
'    StatusForm.cmdAbbrechen.Visible = True
'  End If
  
  If StartedByTracker = True Then
    If theTrackerShowStatusform = True Then
      StatusForm.Show vbModeless
    End If
  Else
    StatusForm.Show vbModeless
  End If
  
End Sub

Sub StartDaemon()

  LogPrint "StartDaemon 1"
  
  Application.Caption = "Excel-Sheet-Checker"
  AddStatus "Starte ECCDaemon"
'  SaveECCDaemon
  SetLiveStatus
  LogPrint "StartDaemon 2"
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusCaption", _
     setting:=Application.Caption
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusExec", _
     setting:=ThisWorkbook.name
  
  LogPrint "StartDaemon 3"
  
'  Debug.Print "APPHWND: " & Application.Hwnd
'  Debug.Print "PROCESS: " & GetCurrentProcess
  
'  Dim L_HWND As Long
  
  'Microsoft Excel - Mappe1.xls = Caption der Excelanwendung
'  L_HWND = FindWindow("XLMain", Application.Caption)
'  Debug.Print "PROCESS: " & L_HWND

'  Debug.Print ThisWorkbook.Path & "\ECCDaemon.exe "
  
  SetLiveStatus
  
  
  LogPrint "StartDaemon 4"
'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name & " 1", vbMinimizedNoFocus)
  If Not FileExists(ThisWorkbook.Path & "\ECCDaemonV0.exe") Then
    AddStatus "Datei '" & ThisWorkbook.Path & "\ECCDaemonV0.exe' nicht vorhanden, der ECCDaemon kann nicht gestartet werden!"
  Else
    Call Shell(ThisWorkbook.Path & "\ECCDaemonV0.exe " & Chr(34) & Application.Caption & Chr(34) & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  End If
'  Call Shell(ThisWorkbook.Path & "\ECCDaemon.exe " & GetCurrentProcess & " " & ThisWorkbook.name, vbMinimizedNoFocus)
  LogPrint "StartDaemon End"
End Sub

Sub EndDaemon()
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatus", _
     setting:="Finished"
  
  On Error Resume Next
'  Application.OnTime NextTime, "SetLiveStatus", , False
End Sub

Sub SetLiveStatus()

  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusTime", _
     setting:=Now
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatus", _
     setting:="Alive"

  NextTime = Now + TimeValue("00:10:00")
'  Application.OnTime NextTime, "SetLiveStatus"
  
End Sub

Sub SetLiveStatusFunc(funcname As String, enab As Boolean)
  If enab Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="LiveStatusFunc", _
       setting:=funcname
  Else
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="LiveStatusFunc", _
       setting:=""
  End If
End Sub


Sub CreateRisk()
  Dim rt As RiskTab
  
  Dim ri As XLScriptArray2D
  Set ri = XLScriptAddArray2D("RiskItems")
  
  Dim totalrisk As Double
  
  Debug.Print "CreateRisk starten"
  LogPrint "CreateRisk starten"
  
  totalrisk = 0
  
  For Each rt In G_RiskTabs
    Debug.Print "AddLine " & rt.m_TabName
    LogPrint "AddLine " & rt.m_TabName

    ri.AddLine UCase(rt.m_TabName)
    
    ri.AddValue "Tabname", TranslateText(rt.m_TabName)
    
    Dim risk As Double
    risk = 0
    
    
    Dim rv As RiskVal
    For Each rv In rt.m_Vals
    
        Debug.Print "Eval " & rv.m_Parameter
        LogPrint "Eval " & rv.m_Parameter
        
      Select Case rv.m_Type
      
        Case C_RISK_TYPE_ECC
      
'              Dim xlssv As XLScriptSimpleVar
'              Set xlssv = XLScriptGetSimpleVar(rv.m_Parameter)
              
              Dim v As String
              v = XLScriptGetVarValue(rv.m_Parameter, Nothing)
              
              If v = "" Then v = "0"
              
              If v = "" Then
                Debug.Print "Unknown risk var: " & rv.m_Parameter
                MsgBox "Unknown risk var: " & rv.m_Parameter, vbCritical, "Excel-Sheet-Checker"
              Else
                  
                  If Len(v) > 0 Then
                      
                        Dim rr As RiskRange
                        For Each rr In rv.m_Vals
                            
                            Select Case rr.m_Comparison
                              Case C_RISK_COMP_TYPE_LESS
                                If Val(v) < rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LESSEQUAL
                                If Val(v) <= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_EQUAL
                                If Val(v) = rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGER
                                If Val(v) > rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                              Case C_RISK_COMP_TYPE_LARGEREQUAL
                                If Val(v) >= rr.m_Value Then
                                  risk = risk + rr.m_Risk
                                  XLScriptAddSimpleVar rv.m_Parameter & "BC", IIf(rr.m_Risk < rt.m_Low, rt.m_LowColour, IIf(rr.m_Risk < rt.m_Med, rt.m_MedColour, rt.m_HighColour))
                                  Exit For
                                End If
                            End Select
                            
                        Next rr
                  
                  
                  End If
              End If
        Case C_RISK_TYPE_FORMULA_CONTAINS, C_RISK_TYPE_WHITE_LIST, C_RISK_TYPE_NOT_IN_WHITE_LIST
        
              For Each rr In rv.m_Vals
                  
                  Select Case rr.m_Comparison
                    Case C_RISK_COMP_TYPE_LESS
                      If rv.m_Matches < rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LESSEQUAL
                      If rv.m_Matches <= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_EQUAL
                      If rv.m_Matches = rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGER
                      If rv.m_Matches > rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                    Case C_RISK_COMP_TYPE_LARGEREQUAL
                      If rv.m_Matches >= rr.m_Value Then
                        risk = risk + rr.m_Risk
                        Exit For
                      End If
                  End Select
                  
              Next rr
        
      End Select
    Next rv
    
    Debug.Print "Riskio ist " & CStr(risk)
    LogPrint "Risiko ist " & CStr(risk)
    
    ri.AddValue "Risk", CStr(IIf(risk > 1, 1, risk * 1))
    
    Dim multi As Double
    
    If risk < rt.m_Low Then
      ri.AddValue "Col", rt.m_LowColour
      multi = rt.m_LowMulti
    ElseIf risk < rt.m_Med Then
      ri.AddValue "Col", rt.m_MedColour
      multi = rt.m_MedMulti
    Else
      ri.AddValue "Col", rt.m_HighColour
      multi = rt.m_HighMulti
    End If
    
    
    totalrisk = totalrisk + multi * risk * rt.m_Weight
    
  Next rt
  
  Debug.Print "TotalRisiko ist " & CStr(totalrisk)
  LogPrint "TotalRisiko ist " & CStr(totalrisk)
  
  XLScriptAddSimpleVar "TotalRisk", CStr(IIf(totalrisk > 1, 1, totalrisk))
  
  If totalrisk < G_RiskLow Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskLowCol)
  ElseIf totalrisk < G_RiskMed Then
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskMedCol)
  Else
    XLScriptAddSimpleVar "TotalRiskCol", CStr(G_RiskHighCol)
  End If
  
  Debug.Print "CreateRisk Ende"
  LogPrint "CreateRisk Ende"
  ' Und das Gesamtrisiko ermitteln
  
End Sub

Sub AddKommentare(ByRef wb As Workbook)
  ' Kommentare einf|fffd|gen
  Dim y As Long
  
  With Sheets("Kommentare")
    y = 1
    Do While .Cells(y, 1) <> ""
        Dim c As Range
        Dim fc As Range
        Dim first As Boolean
        first = True
        wb.Sheets(1).Activate
        Do
          Set c = wb.ActiveSheet.Cells.Find(What:=CStr(.Cells(y, 1).Value), _
            LookIn:=xlValues, LookAt:=xlPart, SearchOrder:=xlByRows, _
            SearchDirection:=IIf(first, xlFirst, xlNext), MatchCase:=False, SearchFormat:=False)
            
          If c Is Nothing Then
            Exit Do
          Else
            If first Then
              Set fc = c
              first = False
            Else
              If c = fc Then Exit Do
            End If
            If CommentExists(c) Then
              c.Comment.Delete
            End If
            c.AddComment .Cells(y, 2).Value
            If Len(.Cells(y, 2).Value) > 50 Then
              c.Comment.Shape.Width = 240
              c.Comment.Shape.Height = 500
            End If
          End If
        Loop
        y = y + 1
    Loop
  End With
End Sub

Sub AddMyComment(c As Range, txt As String)

  Dim w As Long
  Dim h As Long
  
  w = IIf(Len(txt) > 30, IIf(Len(txt) > 60, 600, 320), 160)
  h = 12

  If c.Comment Is Nothing Then
    With c.AddComment
      .Text txt
      .Shape.Width = w
      .Shape.Height = h
    End With
  Else
    Dim neww As Long
    If c.Comment.Shape.Width < w Then
      neww = w
    Else
      neww = c.Comment.Shape.Width
    End If
    Dim newh As Long
    newh = h + c.Comment.Shape.Height '  + 12
    Dim newtxt As String
    newtxt = c.Comment.Text & vbLf & txt
    c.Comment.Delete
    With c.AddComment
      .Text newtxt
      .Shape.Width = neww
      .Shape.Height = newh
    End With
  End If
End Sub

Sub StoreComm(ison As Boolean)
  On Error Resume Next
  
  If G_conn Is Nothing Then Exit Sub
  
  Dim rsECCScan As Object
  Dim count As Long
  
  Set rsECCScan = OpenRS("select Count(idvDateiId) as count from ECCScan", G_conn, MYadOpenDynamic, MYadLockReadOnly)
  count = rsECCScan.Fields("count").Value
  rsECCScan.Close
  
  Set rsECCScan = OpenRS("select * FROM gCommunicate WHERE Interface = 'ECC'", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsECCScan Is Nothing Then
    If rsECCScan.EOF Then
      rsECCScan.AddNew
      rsECCScan.Fields("Interface").Value = "ECC"
    End If
    rsECCScan.Fields("COMM").Value = "SCAN=" & IIf(ison, "ON", "OFF") & vbCrLf & "RESTSCAN=" & count & vbCrLf & "DATE=" & Now & vbCrLf & "FILENAME=" & theFilename
    rsECCScan.Update
    rsECCScan.Close
    Set rsECCScan = Nothing
  End If

End Sub

Sub StoreUserCommunicateValue(prefix As String, s As String)

  On Error Resume Next
  
  If G_conn Is Nothing Then Exit Sub
  
  Dim rsECCScan As Object
  Dim count As Long
  
  Set rsECCScan = OpenRS("select * FROM gCommunicate WHERE Interface = '" & prefix & "-" & IIf(theTrackerFreigabe, theFreigabeuser, GetUserName) & "'", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  If Not rsECCScan Is Nothing Then
    If rsECCScan.EOF Then
      rsECCScan.AddNew
      rsECCScan.Fields("Interface").Value = prefix & "-" & IIf(theTrackerFreigabe, theFreigabeuser, GetUserName)
    End If
    rsECCScan.Fields("COMM").Value = s
    rsECCScan.Update
    rsECCScan.Close
    Set rsECCScan = Nothing
  End If

End Sub


Function TrackerTimeInScope() As Boolean
  
  TrackerTimeInScope = True
  
  If Not StartedByTracker Then Exit Function
  
  If theTrackerFreigabe Then Exit Function
  
  If G_SchedulerTimeCheckIgnore Then Exit Function
    
  If TimeInScope(Now, G_StartScan, G_EndScan) Then Exit Function
    
  TrackerTimeInScope = False
  
End Function
Sub GConnClose()
  On Error Resume Next
  If Not G_conn Is Nothing Then
    G_conn.Close
    Set G_conn = Nothing
  End If
End Sub
Attribute VB_Name = "ScanFile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_OEID As Long
Public m_idvDateiID As Long

Attribute VB_Name = "ScanFuncs"
Option Explicit


Attribute VB_Name = "SpeedTest"
Option Explicit


Private Const L_FileLoadSecurityMultiplier = 3#
Private Const L_FormulaAccessSecurityMultiplier = 3#

Sub SpeedTest()
  
  If Not FileExists(ThisWorkbook.Path & "\Speedtest.xls") Then Exit Sub
  
  Dim wb As Workbook
  
  Dim fsize As Double
  fsize = FileLen(ThisWorkbook.Path & "\Speedtest.xls")
  
  If fsize = 0 Then Exit Sub
  
  
#If DoProfile = False Then
  Dim hrt As New HighResTimer
#End If
  
  Dim res As Boolean
  hrt.StartCounting "Speedtest1"
  res = GetExcelFile(ThisWorkbook.Path & "\Speedtest.xls", wb)
  hrt.StopCounting "Speedtest1"
  Dim loadTime As Double
  loadTime = hrt.GetCount("Speedtest1")
  
  If Not res Then
#If DoProfile = False Then
  Set hrt = Nothing
#End If
    Exit Sub
  End If
  
  
  Debug.Print " 2MB LoadTime: " & loadTime / fsize * CDbl(2) * CDbl(1024) * CDbl(1024) & " sec"
  Debug.Print "10MB LoadTime: " & loadTime / fsize * CDbl(10) * CDbl(1024) * CDbl(1024) & " sec"
  Debug.Print "20MB LoadTime: " & loadTime / fsize * CDbl(20) * CDbl(1024) * CDbl(1024) & " sec"
  Debug.Print "50MB LoadTime: " & loadTime / fsize * CDbl(50) * CDbl(1024) * CDbl(1024) & " sec"
  
  
  Dim formulaAccessTime As Double
  Dim r As Range
  
  wb.Sheets(1).Unprotect
  hrt.StartCounting "Speedtest2"
  Set r = wb.Sheets(1).Cells.SpecialCells(xlCellTypeFormulas)
  hrt.StopCounting "Speedtest2"
  
  formulaAccessTime = hrt.GetCount("Speedtest2")
  
  If Not r Is Nothing Then
    If r.count > 0 Then
    
      Debug.Print r.count & " formulas access time: " & formulaAccessTime & " sec"
      Debug.Print 10 * r.count & " formulas access time: " & 10 * formulaAccessTime & " sec"
      Debug.Print 20 * r.count & " formulas access time: " & 20 * formulaAccessTime & " sec"
    
    End If
  End If
  
  wb.Saved = True
  Set wb = Nothing
  
    
#If DoProfile = False Then
  Set hrt = Nothing
#End If
    
End Sub
Attribute VB_Name = "Sprache"
Attribute VB_Base = "0{AD7CB415-4CF1-47DE-AC79-AC56D917D38C}{BBDDC435-A8BE-4AC1-8BF3-4BBC5796B3C9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Sub MyInit()
  ComboBox1.Clear
  ComboBox1.addItem "Deutsch"
  ComboBox1.addItem "English"
  If GSprache = 1 Then
    ComboBox1.Value = "Deutsch"
  Else
    ComboBox1.Value = "English"
  End If
End Sub

Private Sub cmdOK_Click()
  If ComboBox1 = "English" Then
    GSprache = 2
  Else
    GSprache = 1
  End If
  Me.Hide
End Sub
Attribute VB_Name = "Start"
Option Explicit

Public Const C_IDVTrackerTest As Boolean = False
Public G_Command As String

#If VBA7 Then
    Private Declare PtrSafe Function SetForegroundWindow Lib "user32" _
               (ByVal hWnd As LongPtr) As LongPtr
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
    Private Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
#Else
    Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
    Private Declare Function SetForegroundWindow Lib "user32" _
               (ByVal hWnd As Long) As Long
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
#End If

Sub Auto_Open()

  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=GetCurrentProcessId
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessIDTime", setting:=Now
  If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="StartedByTracker", default:="False") = "True" Then
    StartedByTracker = True
  End If

  Set G_conn = Nothing
  
  If GetSetting(appname:="Stromwerken", Section:="ECC", Key:="UserStartedProgram", default:=0) = 1 Then
    G_UserStartedProgram = True
    SaveSetting appname:="Stromwerken", Section:="ECC", Key:="UserStartedProgram", setting:=0
  End If
  

  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcResult", setting:=""
  G_Command = ""

  GetDBUser

  G_SchedulerTimeCheckIgnore = IIf(GetSetting( _
               appname:="Stromwerken", _
               Section:="ECC", _
               Key:="SchedulerTimeCheckIgnore", default:=0) = 0, False, True)
  SaveSetting appname:="Stromwerken", Section:="ECC", Key:="SchedulerTimeCheckIgnore", setting:="0"


  InitApp
  
  
  Dim commandString As String
  commandString = GetSetting( _
      appname:="Stromwerken", _
      Section:="ECC", _
      Key:="COMMAND", _
      default:="")
      
  If commandString <> "" Then
  
      SaveSetting _
             appname:="Stromwerken", _
             Section:="ECC", _
             Key:="COMMAND", _
             setting:=""
      
      SetMenuBar
      
      If Left(commandString, 5) = "SCAN " Then
        G_SchedulerTimeCheckIgnore = True
        G_Command = "SCAN"
        theFilename = Mid(commandString, 6)
        XLScriptInitDebug
'        Application.OnTime Now + TimeValue("00:00:04"), "DoEinzelanalyse"
        ShowStatusForm theFilename
        DoEinzelanalyse
      End If
      Exit Sub
  End If
  
  
  
  
  LogPrint "DaemonCheck"
  ' ---------------------------------------------------------
  ' Daemon
  ' ---------------------------------------------------------
  If GetSetting( _
      appname:="Stromwerken", _
      Section:="ECC", _
      Key:="StartedByDaemon", _
      default:="False") = "True" Then

          SaveSetting _
             appname:="Stromwerken", _
             Section:=progNameShort, _
             Key:="StartedByDaemon", _
             setting:="False"
          
          LogPrint "StartedByDaemon"
          If GetSetting( _
              appname:="Stromwerken", _
              Section:="ECC", _
              Key:="StartedByTracker", _
              default:="False") = "True" Then
          
              LogPrint "StartedByTracker"
              SaveSetting _
                 appname:="Stromwerken", _
                 Section:="ECC", _
                 Key:="StartedByTrackerFirstTime", _
                 setting:="True"
              StartedByTracker = True
          Else
              StartedByTracker = False
              StartedByDaemon = True
'              Application.OnTime Now + TimeValue("00:00:04"), "DoMassenanalyse"
              ShowStatusForm ""
              DoMassenanalyse
              LogPrint "Start Done 1"
              Exit Sub
          End If
  End If
  
  ' ---------------------------------------------------------
  ' IDV-Suite
  ' ---------------------------------------------------------
  If GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTracker", _
            default:="False") = "True" And _
 _
            GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTrackerFirstTime", _
            default:="False") = "True" _
 _
            Then
            
            LogPrint "StartedByTrackerFirstTime"
            SaveSetting _
                   appname:="Stromwerken", _
                   Section:="ECC", _
                   Key:="StartedByTrackerFirstTime", _
                   setting:="False"
            
            GetTrackerSettings
            
            StartedByTracker = True
            
            GetStartEndTime
            
            If Len(theFilename) = 0 Then
              LogPrint "Filename korrupt"
              ThisWorkbook.Saved = True
              Application.EnableEvents = True
              SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
              SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
              Application.Quit
              Exit Sub
            End If
            
            ' Wenn es mit der aktuellen Dateizeit schon einen Eintrag gibt, dann ist hier schluss
'            Set G_conn = CreateObject("ADODB.Connection")
'            G_conn.Open "IDV-Tracker", "IDVTTechUser", "12SD3Ax$!d7%fd/"
            
            LogPrint "TrackerDo 1"
            Set G_conn = GetConnection()
            
            If G_conn Is Nothing Then
              LogPrintECCSCanLog 0, 0, "ERROR: Keine DB-Connection vorhanden"
              ThisWorkbook.Saved = True
              Application.EnableEvents = True
              SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
              SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
              Application.Quit
              Exit Sub
            End If
            
            StoreUserCommunicateValue "TU", ""
            StoreUserCommunicateValue "FG", ""
            
            ' Einzelanalyse?
            If theFilename <> "@" Then
            
                  LogPrint "TrackerDo Einzel"
                  XLScriptInitDebug
                  
                  If Not FileExists(theFilename) Then
                    LogPrint "Die Datei '" & theFilename & "' ist vom Rechner '" & GetMachineName & "' mit dem User '" & GetUserName & "' nicht erreichbar oder wurde gel|fffd|scht!"
                    StoreUserCommunicateValue "TU", "Die Datei '" & theFilename & "' ist vom Rechner '" & GetMachineName & "' mit dem User '" & GetUserName & "' nicht erreichbar oder wurde gel|fffd|scht!"
                    Application.EnableEvents = True
                    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=""
                    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="LiveStatusTime", setting:=#1/1/1900#
                    Application.Quit
                    Exit Sub
                  End If
                  
                  
'                  Application.OnTime Now + TimeValue("00:00:04"), "DoEinzelanalyse"
                  ShowStatusForm theFilename
                  DoEinzelanalyse
            Else
            
                  ' N|fffd|, massen!
                  LogPrint "TrackerDo Massen"
'                  Application.OnTime Now + TimeValue("00:00:04"), "DoMassenanalyse"
                  ShowStatusForm ""
                  DoMassenanalyse
            End If
            
            LogPrint "Start Done 2"
            Exit Sub
   
  
  Else
      ' ---------------------------------------------------------
      ' Standard
      ' ---------------------------------------------------------
    
        LogPrint "StandardStart"
  
        SaveSetting _
               appname:="Stromwerken", _
               Section:="ECC", _
               Key:="StartedByTracker", _
               setting:="False"
    
    
        StartedByTracker = False
        StartedByDaemon = False
        
        SetMenuBar
        
        LogPrint "ShowMainMenu"
        If UCase(ThisWorkbook.name) = UCase(ProgNameLong) & ".XLS" Or UCase(ThisWorkbook.name) = UCase(ProgNameLong) & ".XLA" Then
            ExcelSheetCheckShowMainMenu
        End If
  End If
  LogPrint "Start Done 3"
End Sub

Private Sub SetMenuBar()
        Dim found As Boolean
        Dim c
        LogPrint "Commandbar Check"
        For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
            If c.Caption = "ECC" Then
                Application.CommandBars("Worksheet Menu Bar").Controls("ECC").Delete
                Exit For
            End If
        Next c
        For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
            If c.Caption = "SSC" Then
                Application.CommandBars("Worksheet Menu Bar").Controls("SSC").Delete
                Exit For
            End If
        Next c
        
        Dim cbb As CommandBarPopup
        Dim scbb As CommandBarButton
        
        LogPrint "Commandbar Add"
        Set cbb = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup)
        
        LogPrint "Commandbar Button 1"
        cbb.Caption = progNameShort
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        scbb.Caption = "Start"
        scbb.OnAction = "ExcelSheetCheckShowMainMenuFromMenu"
        scbb.TooltipText = Texte(GSprache, TXT_STARTECC)
        
        LogPrint "Commandbar Button 2"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        scbb.Caption = "Aus Men|fffd| entfernen"
        scbb.OnAction = "ExcelSheetCheckRemoveMenu"
        scbb.TooltipText = Texte(GSprache, TXT_REMOVEECC)
        
        LogPrint "Commandbar Button 3"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        scbb.Caption = "Einzelanalyse"
        scbb.OnAction = "EinzelanalyseStarten"
    '    scbb. =
        scbb.TooltipText = "Startet die Einzelanalyse"
        
        LogPrint "Commandbar Button 4"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        scbb.Caption = "Massenanalyse"
        scbb.OnAction = "MassenanalyseStarten"
        scbb.TooltipText = "Startet die Massenanalyse"
        
        LogPrint "Commandbar Button 5"
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        scbb.Caption = "Massenanalyse forsetzen"
        scbb.OnAction = "MassenanalyseFortsetzen"
        scbb.TooltipText = "Startet eine bereits begonnene Massenanalyse"
        
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        scbb.Caption = "Suchleiste anzeigen"
        scbb.OnAction = "ECCShowBar"
        scbb.DescriptionText = "Zeigt eine Leiste an, mit der Sie eingef|fffd|rbte Ergebniszellen finden k|fffd|nnen."
        
        Set scbb = cbb.Controls.Add
        scbb.BeginGroup = False
        scbb.Style = msoButtonCaption
        scbb.Caption = "Dokumentation"
        scbb.OnAction = "ECCShowDoku"
        scbb.DescriptionText = "Zeigt die Dokumentation des Programms an."
        
End Sub


Sub InitApp()

  Dim cfg As New CfgReader
  Dim s As String
  
  G_cfgConnectVia = "ODBCDSN"
  
  
  Set cfg = New CfgReader
  
  G_cfgKeypfad = ThisWorkbook.Path
  G_cfgLogpfad = ThisWorkbook.Path
  G_cfgTemppfad = ThisWorkbook.Path
  G_cfgPasswortpfad = ThisWorkbook.Path
  
'  ElseIf FileExists(ThisWorkbook.Path & "\..\swres.swk") Then
'    Open ThisWorkbook.Path & "\..\swres.swk" For Binary Access Read As #ff ' Len = 4
'  ElseIf FileExists(ThisWorkbook.Path & "\..\idv-suite\key\swres.swk") Then
'    Open ThisWorkbook.Path & "\..\idv-suite\key\swres.swk" For Binary Access Read As #ff ' Len = 4
  
  If FileExists(ThisWorkbook.Path & "\ECC.cfg") = True Or FileExists(ThisWorkbook.Path & "\..\cfg\IDV-Suite.cfg") = True Or FileExists(ThisWorkbook.Path & "\..\..\cfg\IDV-Suite.cfg") = True Then

      If FileExists(ThisWorkbook.Path & "\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCFG (ThisWorkbook.Path & "\..\cfg\IDV-Suite.cfg")
      ElseIf FileExists(ThisWorkbook.Path & "\..\..\cfg\IDV-Suite.cfg") Then
        cfg.GetCFG (ThisWorkbook.Path & "\..\..\cfg\IDV-Suite.cfg")
      ElseIf FileExists(ThisWorkbook.Path & "\ECC.cfg") = True Then
        cfg.GetCFG (ThisWorkbook.Path & "\ECC.cfg")
      End If
      
      If cfg.GetSection("DBCONNECT") = True Then
        G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING")
      End If
      
      If cfg.GetSection("ECC") = True Then
          s = cfg.GetValue("HELLOWORLD")
          If UCase(s) = "JA" Then
            MsgBox "Hinweis: Der Excel-Sheet-Checker wurde gestartet. Sie k|fffd|nnen diesen Hinweis in der Datei ECC.cfg deaktivieren. Stellen Sie dort bitte den Parameter HELLOWORLD auf Nein", vbInformation
          End If
          s = cfg.GetValue("LOG")
          If UCase(s) = "JA" Then
            G_LogEnabled = True
          ElseIf UCase(s) = "LAB" Then
            G_LogEnabled = True
            G_Break = True
          End If
      End If
      
      If cfg.GetSection("GLOBALS") = True Then
          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
          
          If Not StartedByTracker Then
            If UCase(cfg.GetValue("CONNECTVIA")) = "DBCONNECT.CFG" Then
              G_cfgConnectVia = "DBCONNECT.CFG"
            End If
          End If
          
          s = cfg.GetValue("CURSORLOCATION")
          If UCase(s) = "SERVER" Then
            G_Cursorlocation = 2 ' ADODB.adUseServer
          Else
            G_Cursorlocation = 3 ' ADODB.adUseClient
          End If
          
          If UCase(cfg.GetValue("MODULMEN|fffd|")) = "NEIN" Then
            G_ModulmenueDeaktivieren = True
          End If
          
      End If
  
      If StartedByTracker Then
        If cfg.GetSection("IDV-Suite Scheduler") = True Then
            If cfg.GetValue("KEYPFAD") <> "" Then
              G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
            End If
            If cfg.GetValue("LOGPFAD") <> "" Then
              G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
            End If
            If cfg.GetValue("TEMPPFAD") <> "" Then
              G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
            End If
            If cfg.GetValue("PASSWORTPFAD") <> "" Then
              G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
            End If
        End If
      End If
  
  End If
  
  If GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTrackerFirstTime", _
            default:="False") = "True" Then
  ClearLog
  End If
  LogPrint "ECC Start"

  DebugPrint tInfo, "Keypfad: " & G_cfgKeypfad
  DebugPrint tInfo, "Logpfad: " & G_cfgLogpfad
  DebugPrint tInfo, "Temppfad: " & G_cfgTemppfad
  DebugPrint tInfo, "Passwortpfad: " & G_cfgPasswortpfad
  Set G_conn = Nothing
  
  
  LogPrint "Programmteilpr|fffd|fung"
  Dim tmpfname As String
'  tmpfname = ThisWorkbook.Path & "\ECC-Einzelanalyse.xlt"
'  If Not FileExists(tmpfname) Then
'    MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
'    Exit Sub
'  End If
'  tmpfname = ThisWorkbook.Path & "\ECC-Massenanalyse.xlt"
'  If Not FileExists(tmpfname) Then
'    MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
'    Exit Sub
'  End If
'  tmpfname = ThisWorkbook.Path & "\Excel-Sheet-Checker Risk.xls"
'  If Not FileExists(tmpfname) Then
'    MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
'    Exit Sub
'  End If
  tmpfname = ThisWorkbook.Path & "\EccFuncs.xls"
  If Not FileExists(tmpfname) Then
    MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
    Exit Sub
  End If
  tmpfname = ThisWorkbook.Path & "\ECCDaemonV0.exe"
  If Not FileExists(tmpfname) Then
    MsgBox "Die Datei '" & tmpfname & "' existiert nicht, der Excel-Sheet-Checker kann nicht ausgef|fffd|hrt werden!"
    Exit Sub
  End If
  
  LogPrint "Caption setzen"
  Application.Caption = "Excel-Sheet-Checker"
  
  theTrackerShowStatusform = True
    
    
  G_MyLicencseVersion = 0
  G_UpdateAvailable = False
  
  FullVersion = False
  LogPrint "GetData"
  GetData
  LogPrint "CheckLicense"
  CheckLicense
      
  LogPrint "CheckVersion"
  DebugPrint tInfo, "Started by Tracker: " & GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTracker", _
            default:="False") = "True"
  DebugPrint tInfo, "Started by Tracker first time: " & GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTrackerFirstTime", _
            default:="False") = "True"
  If GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTracker", _
            default:="False") = "True" Or _
 _
            GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTrackerFirstTime", _
            default:="False") = "True" _
 _
            Then
      CheckVersion 1, "ECC", "ECCVersionN.txt", "ECCVersionN2.txt", MyVersion, MyInternalVersion
  End If
'  CheckVersion 0, progNameShort, progNameShort & "\SWUpdate" & progNameShort & ".txt", MyInternalVersion
      
      
  LogPrint "Label"
  If Len(trs) Then MainMenu.Label1 = trs
  
  LogPrint "Language"
  GSprache = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="Sprache", default:=0)
    
  If GSprache = 0 Then
'    If trsLngSelect = "Ja" Or FullVersion = True Then
'      Sprache.MyInit
'      Sprache.Show
'      If GSprache = 0 Then GSprache = 2
'      SaveSetting _
'         appName:="Stromwerken", _
'         section:=progNameShort, _
'         key:="Sprache", _
'         Setting:=GSprache
'    Else
      GSprache = 1
      SaveSetting _
         appname:="Stromwerken", _
         Section:=progNameShort, _
         Key:="Sprache", _
         setting:=GSprache
'    End If
  End If
  
  LogPrint "TexteInit"
  TexteInit
  
  Beenden = False
  LogPrint "InitPhase Finished"

End Sub

Sub Auto_Close()
    On Error Resume Next
    If G_ModulmenueDeaktivieren Then
      Application.CommandBars("Worksheet Menu Bar").Controls(progNameShort).Delete
    End If
End Sub


Sub GetTrackerSettings()
On Error Resume Next
            
            ' Wenn der Tracker mich aufgerufen hat...
            theFilename = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerFile", _
                default:="")
            
            theTrackerPasswordLog = IIf(GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerLogPassword", _
                default:="False") = "True", True, False)
                
            theTrackerShowStatusform = IIf(GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerShowStatusform", _
                default:="False") = "True", True, False)

            theTrackerFreigabe = IIf(GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerFreigabe", _
                default:="False") = "True", True, False)
            
            ' Und wieder raus, sonst wird alles eine Freigabe!!!!!
            SaveSetting _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerFreigabe", _
                setting:="False"
                
            theTrackerFreigabeDatum = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerFreigabedatum", _
                default:=#1/1/1900#)
                
            theidvDateiID = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="DateiID", _
                default:=0)
                
            theFreigabekommentar = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="Freigabekommentar", _
                default:="")
            
            theFreigabeCCListe = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="FreigabeCCListe", _
                default:="")
                
            theFreigabeuser = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="Freigabeuser", _
                default:="")
                
            theTrackerFormelnExtrahieren = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerFormelnExtrahieren", _
                default:=-1)
                
            theTrackerFachrisiko = GetSetting( _
                appname:="Stromwerken", _
                Section:="ECC", _
                Key:="TrackerFachrisiko", _
                default:=-1)
                
            ' theOEID = xlsDateien(i).m_OEID


End Sub


Public Sub ExcelSheetCheckShowMainMenuFromMenu()
  InitApp
  ExcelSheetCheckShowMainMenu
End Sub

Public Sub ExcelSheetCheckShowMainMenu()
  
'  CheckVersion 0, progNameShort, progNameShort & "\SWUpdate" & progNameShort & ".txt", MyInternalVersion
    
  G_MyLicencseVersion = 0
  
  FullVersion = False
  LogPrint "GetData 2"
  GetData
  
  
  If G_Lizenzen = 0 And Now > G_FullDemoBis And GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTracker", _
            default:="False") <> "True" Then
    FullVersion = False
  End If
    
  LogPrint "Wartungscheck"
  If G_Wartung = True And Now > G_WartungBis Then
    If G_WartungBis < MyProgramReleaseDate = True And G_MyLicencseVersion < MyProgramLicenseVersion Then
      FullVersion = False
    End If
  Else
    If G_MyLicencseVersion < MyProgramLicenseVersion And FullVersion = True Then
      FullVersion = False
    End If
  End If
      
  If Len(trs) Then MainMenu.Label1 = trs
  
  
  LogPrint "Version"
  MainMenu.CVersion = MyVersion & " vom " & MyProgramReleaseDate & vbCrLf & IIf(MyInternalVersion <> G_InternetInternalVersion, IIf(G_InternetVersion <> "", "Internet: " & G_InternetVersion & vbCrLf, ""), "") & _
      IIf(G_InternetAvailable, _
            IIf(FullVersion = False, _
                  "Demoversion", _
                  IIf(MyInternalVersion < G_InternetInternalVersion, _
                          IIf(G_MyLicencseVersion >= G_InternetLicenseVersion, "Kostenfreies Update", "Kostenpflichtiges Update"), _
                          "" _
                  ) _
            ), _
            "" _
      )
  
  If G_UpdateAvailable And MyInternalVersion < G_InternetInternalVersion Then MainMenu.cmdUpdate.Visible = True
  
  LogPrint "Sprache 2"
  GSprache = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="Sprache", default:=0)
    
    
  GSprache = 1
    
'  If GSprache = 0 Then
'    If trsLngSelect = "Ja" Or FullVersion = True Then
'      Sprache.MyInit
'      Sprache.Show
'      If GSprache = 0 Then GSprache = 2
'      SaveSetting _
'         appName:="Stromwerken", _
'         section:=progNameShort, _
'         key:="Sprache", _
'         Setting:=GSprache
'    Else
'      GSprache = 1
'      SaveSetting _
'         appName:="Stromwerken", _
'         section:=progNameShort, _
'         key:="Sprache", _
'         Setting:=GSprache
'    End If
'  End If
  
  LogPrint "TexteInit 2"
  TexteInit
  
'  If trsLngSelect = "Ja" Then
'    MainMenu.cmdSprache.Visible = True
'  End If

'  If Not FullVersion Then
'    MainMenu.cmdSprache.Visible = True
'  End If
  
  LogPrint "VBA-Check"
  If Not CheckVBAAccessAllowed Then
      If StartedByTracker = False And StartedByDaemon = False Then
        MsgBox Texte(GSprache, TXT_EXCEL2000), vbCritical, "Excel-Sheet-Checker"
      End If
  End If
    
  MainMenu.Headline = ProgNameLong
  MainMenu.Cop = "|fffd|2001 - " & year(Now)
  LogPrint "MainMenu.Show"
  MainMenu.Show
End Sub

Sub ExcelSheetCheckRemoveMenu()
    On Error Resume Next
    InitApp
    If MsgBox(Texte(GSprache, TXT_ECCENTFERNEN), vbYesNo, "Excel-Sheet-Checker") = vbYes Then
        Application.CommandBars("Worksheet Menu Bar").Controls("ECC").Delete
        Application.CommandBars("Worksheet Menu Bar").Controls("SSC").Delete
        ThisWorkbook.Close
    End If
End Sub


Function GetxlDateiRS(wb As Excel.Workbook, uncpathfname As String, conn As Object, openMode As Long) As Object

  Set GetxlDateiRS = Nothing
  
  Dim s As String
  s = GetFileHash(uncpathfname)
  
  Dim rs

  Set rs = OpenRS("SELECT * FROM xlDateien WHERE Hash='" & s & "'", conn, MYadOpenDynamic, openMode)

  If rs Is Nothing Then Exit Function

  Do While Not rs.EOF
      If rs.Fields("Dateiname").Value = uncpathfname Then
          '        If rs!Rechnerkennung = machineName Then
          Set GetxlDateiRS = rs
          Exit Function
      End If
      rs.movenext
  Loop

End Function


Function OpenRS(ByVal sqlstring As String, ByRef conn As Object, ByVal cursorytype As Long, ByVal locktype As Long) As Object
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        On Error Resume Next

        Set OpenRS = Nothing
        Dim cnt As Long
        cnt = 0
checkAgain:
        rs.Open sqlstring, conn, cursorytype, locktype
        If Err.Number <> 0 Then
            Debug.Print Err.Description
            Err.Clear
            Sleep 50
            cnt = cnt + 1
            If cnt >= 100 Then
                rs = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If

        Set OpenRS = rs
End Function


Function ShowBar() As Boolean
  On Error GoTo barMissing
  Application.CommandBars("ECCZellenFinden").Visible = True
  ShowBar = True
  Exit Function

barMissing:
  ShowBar = False
End Function

Sub ECCShowDoku()
  OpenFileWithApp ThisWorkbook.Path & "\Excel-Sheet-Checker.pdf"
End Sub

Sub ECCShowBar()
    On Error GoTo ignore
    
    If ShowBar Then Exit Sub
    
    Dim myBar As CommandBar
    Set myBar = Application.CommandBars.Add(name:="ECCZellenFinden", Position:=msoBarFloating, Temporary:=True)
    ' Und die Buttons hinzuf|fffd|gen
    Dim myControl
    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
    With myControl
        .FaceId = 141
        .Caption = "Erste Zelle finden"
        .OnAction = "ECCFinden"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
        .Style = msoButtonIconAndCaption
    End With
    
    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
    With myControl
        .FaceId = 570
        .Caption = "Weitere finden"
        .OnAction = "ECCWFinden"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
        .Style = msoButtonIconAndCaption
    End With
    
'    Set myControl = myBar.Controls.Add(Type:=msoControlButton)
    ' Speicherbutton mit Grafik
'    With myControl
'        .FaceId = 570
'        .Caption = "Text in Formeln"
'        .OnAction = "ECCTextInFormelnSuchen"  ' Funktion, die Aufgerufen werden soll, siehe Modul1
'        .Style = msoButtonIconAndCaption
'    End With
    
    
    ' Mich einschalten und den Schutz an
    With myBar
        .Visible = True
'        .Protection = 31 ' Mich kann man auch nicht zumachen :)
    End With
ignore:
End Sub

Sub CheckLicense()
  If G_Lizenzen = 0 And Now > G_FullDemoBis And GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTracker", _
            default:="False") <> "True" Then
    MsgBox "Die Full-Demo f|fffd|r dieses Programm ist abgelaufen. Wenden Sie sich bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
    FullVersion = False
  ElseIf G_Lizenzen > 0 And Now > G_FullDemoBis And G_FullDemoBis <> 0 And GetSetting( _
            appname:="Stromwerken", _
            Section:="ECC", _
            Key:="StartedByTracker", _
            default:="False") <> "True" Then
    MsgBox "Die Lizenz f|fffd|r das Programm ist abgelaufen, wenn Sie das Programm weiter als Vollversion nutzen m|fffd|chten, k|fffd|nnen Sie eine Lizenz per formloser Mail |fffd|ber info@stromwerken.de bestellen. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
    FullVersion = False
  End If
    
  If G_Wartung = True And Now > G_WartungBis Then
    If G_WartungBis < MyProgramReleaseDate = True And G_MyLicencseVersion < MyProgramLicenseVersion Then
      MsgBox "Ihr Wartungsvertrag umfasst diese Programmversion nicht mehr. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
      FullVersion = False
    End If
  Else
    If G_MyLicencseVersion < MyProgramLicenseVersion And FullVersion = True Then
      MsgBox "Ihr Lizenzkey f|fffd|r dieses Programm ist veraltet. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-Sheet-Checker"
      FullVersion = False
    End If
  End If
End Sub


Sub GetStartEndTime()
  G_StartScan = "00:00:00"
  G_EndScan = "00:00:00"
  
  If IsDate(GetSetting(appname:="Stromwerken", Section:="ECC", Key:="StartScan", default:="00:00:00")) Then
    G_StartScan = GetSetting(appname:="Stromwerken", Section:="ECC", Key:="StartScan", default:="00:00:00")
  End If
  If IsDate(GetSetting(appname:="Stromwerken", Section:="ECC", Key:="EndScan", default:="00:00:00")) Then
    G_EndScan = GetSetting(appname:="Stromwerken", Section:="ECC", Key:="EndScan", default:="00:00:00")
  End If
  
  If Not StartedByTracker Then Exit Sub
  
  LogPrint "ECCScan: " & G_StartScan & " - " & G_EndScan
  
End Sub
Attribute VB_Name = "StatusForm"
Attribute VB_Base = "0{783BB03C-F5A5-4566-BE3B-3DAA79D25498}{F3FC7A81-2D2E-4791-8DD1-64C79CC07572}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub cmdAbbrechen_Click()
  cmdAbbrechen.Caption = "Bitte warten..."
  DoEvents
  Beenden = True
End Sub

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "CommandButton21, 1, 0, MSForms, CommandButton2"
Private Sub CommandButton21_Click()
  Auto_Open
End Sub
Attribute VB_Name = "Tabelle11"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle21"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False









Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle31"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Attribute VB_Name = "Tabelle6"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub CommandButton1_Click()
  TestRemovePWVBA
End Sub

Private Sub CommandButton2_Click()
  ExcelSheetCheckShowMainMenuFromMenu
End Sub
Attribute VB_Name = "UNC"
Option Explicit

#If VBA7 Then
Public Declare PtrSafe Function WNetGetConnection Lib "mpr.dll" Alias _
                       "WNetGetConnectionA" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#Else
Public Declare Function WNetGetConnection Lib "mpr.dll" Alias _
                       "WNetGetConnectionA" (ByVal lpszLocalName As String, _
                                             ByVal lpszRemoteName As String, _
                                                   cbRemoteName As Long) As Long
#End If


Public Function GetUNCPath(ByVal sLocalPath As String) As String '// -----------------------------------------------------------------
'// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
'// -----------------------------------------------------------------
'// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..) '// -----------------------------------------------------------------
'// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
'//            | bei Fehler = sLocalPath
'// -----------------------------------------------------------------
    Const NO_ERROR  As Long = 0
    Dim sUNCPath    As String
    Dim sResult     As String
    Dim sDrive      As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If VBA.Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
'// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = VBA.Left$(sLocalPath, 2)
    sUNCPath = VBA.String(260, 0)
    If WNetGetConnection(sDrive, sUNCPath, VBA.Len(sUNCPath)) = NO_ERROR Then
        sResult = VBA.Left$(sUNCPath, VBA.InStr(sUNCPath, vbNullChar) - 1)
        If VBA.Len(sResult) > 0 Then
            GetUNCPath = sResult & VBA.Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Function testShortUNC()
    Debug.Print GetDriveAndPathFromUNC("\\TABLET\C\01234567890123456789012345678901234567890123456789\01234567890123456789012345678901234567890123456789\01234567890123456789012345678901234567890123456789\01234567890123456789012345678901234567890123456789\012345678901234567890123456789\MAPPE0123456789012345678901234567890123456789012345678901234567890123456789.XLS")
End Function

' .Net

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim i As Integer
    Dim s As String

    s = strFullPath

    For i = 65 To 90
        If GetUNCPathShort(Chr(i) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(i) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next i
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnection(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function


' .Net END
Attribute VB_Name = "XLFldVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Value As Long
Public m_Txt As String

Attribute VB_Name = "XLForNext"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Name As String
Public m_Ref
Public m_Current As Long
Public m_Width As Long
Public m_WidthCurrent As Long
Attribute VB_Name = "XLScript"
Option Explicit

' Public m_LogY As Long
Private m_WS As Excel.Worksheet
Public m_Flds As Collection
Private m_FN As Collection
Private m_CodeStart As String
Private m_Log As Collection

Private m_SimpleVars As Collection
Private m_Vars As Collection
Private m_VarArray As Collection
Private m_VarArray2D As Collection
Private m_GlobalObjects As Collection

#Const USE_LATE_BINDING_MDB = True
#Const USE_LATE_BINDING_XLS = False

#If USE_LATE_BINDING_MDB <> False Then
  Public m_App As Object
  Public m_DB As Object
  Public m_Workspace As Object
#Else
  Public m_App As Access.Application
  Public m_DB As database
  Public m_Workspace As Workspace
#End If

#If USE_LATE_BINDING_XLS = True Then
  Global m_Workbook As Object
  Global m_Excel As Object
#Else
  Global m_Workbook As Excel.Workbook
  Global m_Excel As Excel.Application
#End If

Public Const XLSCript_Debug As Boolean = False
Private m_InPrint As Boolean

Public m_AllVars As Collection

Private MyLastTime As Date

Public Function XLScriptCreateAccessApp(v As Long) As Object
  Set XLScriptCreateAccessApp = CreateObject("Access.Application." & v)
End Function

Public Function XLScriptCheckAccessVersion(v As Long) As Boolean
XLScriptCheckAccessVersion = False
On Error Resume Next
  Dim o As Object
  Set o = CreateObject("Access.Application." & v)
  If Not o Is Nothing Then
    XLScriptCheckAccessVersion = True
    o.CloseCurrentDatabase
    o.Quit
    Set o = Nothing
  End If
End Function

Public Sub XLScriptStore(fn As String)
  Dim ff As Integer
  ff = FreeFile
  Open fn For Output As #ff
    Dim item
    If m_VarArray2D.count > 0 Then
      For Each item In m_VarArray2D
        item.Store ff
      Next item
    End If
    If m_VarArray.count > 0 Then
      For Each item In m_VarArray
        item.Store ff
      Next item
    End If
    If m_Vars.count > 0 Then
      For Each item In m_Vars
        item.Store ff
      Next item
    End If
  Close #ff
End Sub

Public Sub XLScriptRegisterGlobalObject(n As String, o As Variant)
  
  On Error Resume Next
  m_GlobalObjects.Remove n
  
  Dim gob As XLScriptGlobalObject
  Set gob = New XLScriptGlobalObject
  gob.m_Name = n
  gob.m_Object = o
  m_GlobalObjects.Add gob, CStr(n)

End Sub

Public Function XLScriptGetGlobalObject(n As String) As Variant
  On Error GoTo NoObject
  Set XLScriptGetGlobalObject = Nothing
  Set XLScriptGetGlobalObject = m_GlobalObjects(n)
  
  Exit Function
NoObject:
  If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetGlobalObject: Object '" & n & "' not found!", vbCritical, "XLScript"
End Function

Public Sub XLScriptInitDebug()
  If XLSCript_Debug = True Or StartedByTracker = True Then
    Set m_AllVars = New Collection
  End If
End Sub

Public Sub XLDumpNonprinted()
  If XLSCript_Debug Then
    Dim item
    For Each item In m_AllVars
      If Not item.m_WasPrinted Then
        Select Case TypeName(item)
          Case "XLScriptArray"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptArray2D"
            Debug.Print TypeName(item), item.m_SortName
          Case "XLScriptSimpleVar"
            Debug.Print TypeName(item), item.m_Txt, item.m_Value
          Case "XLScriptVar"
            Debug.Print TypeName(item), item.m_SortName
          Case Else
            Debug.Print "Unknown Type: " & TypeName(item)
        End Select
      End If
    Next item
  End If
End Sub

Public Sub XLScriptInitGlobals()
'  If m_LogY <= 0 Then m_LogY = 1
  Set m_GlobalObjects = New Collection
  Set m_FN = New Collection
  Set m_Flds = New Collection
  Set m_VarArray2D = New Collection
  Set m_VarArray = New Collection
  Set m_Vars = New Collection
  Set m_SimpleVars = New Collection
  Set m_Log = New Collection
End Sub
Public Sub XLScriptExitGlobals()
  Set m_FN = Nothing
  Set m_Flds = Nothing
  Set m_VarArray2D = Nothing
  Set m_VarArray = Nothing
  Set m_Vars = Nothing
  Set m_SimpleVars = Nothing
  Set m_Log = Nothing
  Set m_GlobalObjects = Nothing
End Sub

Public Sub XLScriptInit(ByRef ws As Excel.Worksheet, passstring As String)
  Set m_WS = ws
  m_WS.Activate
  m_CodeStart = "<!" & passstring & " "
End Sub
Public Sub XLScriptExit()
  Set m_WS = Nothing
End Sub

Public Function XLScriptCreateArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init n
  Set XLScriptCreateArray2D = da
  
End Function

Public Function XLScriptAddArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = XLScriptCreateArray2D(n)
  m_VarArray2D.Add da, CStr(n)
  Set XLScriptAddArray2D = da

  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddArray(n As String) As XLScriptArray
  Dim da As XLScriptArray
  Set da = New XLScriptArray
  da.Init n
  m_VarArray.Add da, CStr(n)
  Set XLScriptAddArray = da

  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetArray(n As String) As XLScriptArray
On Error GoTo notFound
  Set XLScriptGetArray = Nothing
  Set XLScriptGetArray = m_VarArray(CStr(n))
  Exit Function
notFound:
  If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetArray: Array '" & n & "' not found!", vbCritical, "XLScript"
End Function

Public Function XLScriptGetArray2D(n As String) As XLScriptArray2D
On Error GoTo notFound
  Set XLScriptGetArray2D = Nothing
  Set XLScriptGetArray2D = m_VarArray2D(CStr(n))
  Exit Function
notFound:
  If Not StartedByTracker Then MsgBox "ERROR: XLScriptGetArray2D: Array '" & n & "' not found!", vbCritical, "XLScript"
End Function


Public Function XLScriptAddVar(n As String) As XLScriptVar
  Dim da As XLScriptVar
  Set da = New XLScriptVar
  da.Init n
  m_Vars.Add da, CStr(n)
  Set XLScriptAddVar = da
  
  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptAddSimpleVar(n As String, v) As XLScriptSimpleVar
  Dim da As XLScriptSimpleVar
  
  If ObjectNameExists(m_SimpleVars, n) Then
    m_SimpleVars.Remove n
  End If
  
  Set da = New XLScriptSimpleVar
  da.m_Txt = n
  da.m_Value = CStr(v)
  m_SimpleVars.Add da, CStr(n)
  Set XLScriptAddSimpleVar = da

  If XLSCript_Debug = True Or StartedByTracker = True Then
    If Not m_AllVars Is Nothing Then m_AllVars.Add da
  End If
End Function

Public Function XLScriptGetSimpleVar(n As String) As XLScriptSimpleVar
  Set XLScriptGetSimpleVar = Nothing
  On Error Resume Next
  Set XLScriptGetSimpleVar = m_SimpleVars(n)
End Function

' Public Sub XLScriptSetValues(c As Collection, ByRef rng As Range)
'   Dim item
'   For Each item In c
'     SetValue rng, item.m_Txt, CStr(item.m_Value)
'   Next item
' End Sub

' Private Sub SetValue(ByRef rng As Range, varTag As String, cellVal As String)
'   On Error GoTo 0
'   Dim c
'   Do
'     Set c = rng.Find(What:="<<" & varTag & ">>", LookIn:=xlValues, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Value = MyReplace(c.Value, "<<" & varTag & ">>", cellVal)
'     End If
'   Loop While Not c Is Nothing
'   Do
'     Set c = rng.Find(What:="__" & varTag & "__", LookIn:=xlFormulas, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Formula = MyReplace(c.Formula, "__" & varTag & "__", cellVal)
'     End If
'   Loop While Not c Is Nothing
' End Sub

Private Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore As Boolean
  
  inIgnore = False
  
  For txtPos = 1 To Len(txt)
    If Len(ignoreIn) > 0 Then
      If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
        If Not inIgnore Then
          inIgnore = True
        Else
          inIgnore = False
        End If
      End If
    End If
    
    If Not inIgnore Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function

Sub XLScriptCleanUpTags(rng As Range)
'  On Error GoTo 0
  
  Dim c As Range
  Do
    Set c = rng.Find(What:="<!? INSERTLINEABOVE", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Parent.Rows(c.Row).Delete Shift:=xlUp
  Loop
  
  Do
    Set c = rng.Find(What:="<!? PB", LookIn:=xlValues, LookAt:= _
      xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
    If c Is Nothing Then Exit Do
    c.Delete Shift:=xlUp
  Loop
End Sub


Function XLScriptExecCode(rng As Range, reclevel As Long, rightoffset As Long) As Long
  Dim addedLines As Long
  addedLines = 0
  
  On Error GoTo 0
  Dim c As Range
  Dim tstring As String
  Dim tleft As String
  Dim tRight As String
  Set c = Nothing
  
  Dim firstC As Range
  Set firstC = Nothing
  Dim nextC As Range
  
  Do
    
'    Cells.Find(What:=m_CodeStart, After:=ActiveCell, LookIn:=xlValues, LookAt:= _
'        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, _
'        SearchFormat:=False).Activate
    
    If GetRangeCount(rng) = 1 Then
      If InStr(rng.Value, m_CodeStart) > 0 Then
        Set c = rng
      Else
        Set c = Nothing
      End If
    Else
      
      ' Erste gefundene Zelle abfragen
      If Not c Is Nothing And IsValid(c) And Not firstC Is Nothing And IsValid(firstC) = True Then
        If firstC.Row = c.Row And firstC.Column = c.Column Then
          Set c = Nothing
        End If
      ElseIf c Is Nothing Or Not IsValid(c) Then
        Set c = rng.Find(What:=m_CodeStart, LookIn:=xlValues, LookAt:= _
            xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
        ' Erste gefundene Zelle speichern
        If Not c Is Nothing And firstC Is Nothing Then
          Set firstC = c
        End If
      Else
        Exit Do
      End If
    End If
    
    If Not c Is Nothing And IsValid(c) Then
    
      Set nextC = rng.FindNext(c)
        
      Dim pos As Long
      Dim pos2 As Long
      pos = 0
      ' ---------------------------------------------------
      
      Do
        
        If c Is Nothing Then Exit Do
        If Not IsValid(c) Then Exit Do
        
        pos = InStr(pos + 1, c.Value, m_CodeStart)
        If pos = 0 Then Exit Do
        
        pos2 = InStr(pos, c.Value, "!>")
        
        Dim codeVal As String
        Dim code As String
        If pos2 > 0 Then
          code = Mid(c.Value, pos + Len(m_CodeStart), pos2 - pos - Len(m_CodeStart))
        Else
          code = Mid(c.Value, pos + Len(m_CodeStart))
        End If
        
        codeVal = code
        
        Dim newcellval As String
        newcellval = ""
        
        Dim dontdeleteentry As Boolean
        dontdeleteentry = False
        
        Do
          Dim tok As String
          tok = GetToken(codeVal)
          If Len(tok) > 0 Then
            Select Case UCase(tok)
              Case "ADDRIGHT"
                tstring = GetExpression(codeVal, c)
                c.Parent.Cells(c.Row, c.Column + 1).Value = _
                  c.Parent.Cells(c.Row, c.Column + 1).Value + _
                  Val(MyReplace(tstring, ",", "."))
                  
              Case "INSERTLINEABOVE"
                If firstC.Row = c.Row Then
                  Set firstC = c.Parent.Cells(c.Row + 1, c.Column)
                End If
                m_WS.Rows(c.Row).Insert
                c.Value = ""
                Set c = c.Parent.Cells(c.Row + 1, c.Column)
                dontdeleteentry = True
              Case "BACKCOL"
                tstring = GetExpression(codeVal, c)
                
                If IsNumeric(tstring) Then
                  c.Interior.Color = Val(tstring)
                End If
                
              Case "P"
                newcellval = DoPrint(codeVal, c, rightoffset)
              
              Case "PB"
                DoPrintBelow codeVal, c, rightoffset
                dontdeleteentry = True
              
              Case "PRINTBITFIELD"
                DoPrintBitfield codeVal, c
              
              Case "FOR"
                addedLines = addedLines + DoFor(codeVal, c, rng, reclevel + 1)
                If Beenden Then Exit Function
              
              Case "LFOR"
                addedLines = addedLines + DoLFor(codeVal, c, rng, reclevel + 1)
                If Beenden Then Exit Function
              
              Case "ROWAUTOFIT"
                c.Parent.Cells.EntireRow.AutoFit
              
              Case "COLUMNAUTOFIT"
                c.Parent.Cells.EntireColumn.AutoFit
              
              Case "DEBUG"
                Err.Raise vbObjectError + 1, "XLScript", "DEBUG forced by XLScript"
                Debug.Print "Debug forced"
              
              Case "DIAGDATA"
                addedLines = addedLines - 2
                DoDiagData codeVal, c, rng
              
              Case Else
                XLScriptAddLogEntry "Error: Unknown command '" & tok & "' in '" & code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
                ' MsgBox "Error: Unknown command '" & tok & "' in '" & code & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value, vbCritical, "XLScript"
                ' Beenden = True
                tok = ""
                ' Exit Function
            
            End Select
          End If
        Loop While tok <> ""
        
        ' Und jetzt den neuen Zellwert in die Zelle schreiben
        Dim l As String
        Dim r As String
        
        l = ""
        If pos > 1 Then
          l = Left(c.Value, pos - 1)
        End If
        
        r = ""
        If pos2 > 0 Then
          If pos + 2 < Len(c.Value) Then
            r = Mid(c.Value, pos2 + 2)
          End If
        End If
        
        If dontdeleteentry = False Then
          If Not c Is Nothing Then
            If IsValid(c) Then
          
              If IsNumeric(MyReplace(l & newcellval & r, ",", ".")) Then
                c.Value = Val(MyReplace(l & newcellval & r, ",", "."))
              ElseIf IsDate(l & newcellval & r) Then
                c.Value = CStr(CDate(l & newcellval & r))
              Else
                c.Value = l & newcellval & r
              End If
              pos = Len(l & newcellval) - 1
              If pos < 0 Then pos = 0
            End If
          End If
        End If
      Loop
      
    End If
  
    If Not GetRangeCount(rng) = 1 And Not c Is Nothing Then
      Set c = nextC
    End If
  
  Loop While Not c Is Nothing
  
  XLScriptExecCode = addedLines
End Function

Private Sub OverreadLine(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While i < Len(codeValRet) And Mid(codeValRet, i, 1) <> vbCr And Mid(codeValRet, i, 1) <> vbLf
    i = i + 1
  Loop
  Do While i < Len(codeValRet) And (Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf)
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim i As Long
  i = 1
  Do While Mid(codeValRet, i, 1) = " " Or Mid(codeValRet, i, 1) = vbCr Or Mid(codeValRet, i, 1) = vbLf
    i = i + 1
  Loop
  If i > 1 Then
    codeValRet = Mid(codeValRet, i)
  End If
End Sub

Private Sub GetComma(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) <> "," Then
    XLScriptAddLogEntry "Error: Missing comma! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  End If
  codeValRet = Mid(codeValRet, 2)
End Sub

Private Function GetDef(ByRef codeValRet As String, ByRef c As Range) As xlFld
  On Error GoTo 0
  OverreadBlanks codeValRet
  
  Dim tok As String
  tok = GetToken(codeValRet)
  
  Dim item As xlFld
  For Each item In m_Flds
    If item.m_Name = tok Then
      Set GetDef = item
      Exit Function
    End If
  Next item
  
  XLScriptAddLogEntry "Error: Undefined Def '" & tok & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
End Function

Private Function GetNumber(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  
  Do While ((Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
    (Mid(codeValRet, i + 1, 1) = ".")) And i < Len(codeValRet)
    i = i + 1
  Loop
  If i > 0 Then
    token = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
    OverreadBlanks codeValRet
  End If
  
  GetNumber = token
End Function

Private Function GetLine(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  Dim i As Long
  i = 0
  Do While i < Len(codeValRet) - 1 And Mid(codeValRet, i + 1, 1) <> vbCr And Mid(codeValRet, i + 1, 1) <> vbLf
    i = i + 1
  Loop
  If i > 0 Then
    GetLine = Left(codeValRet, i)
    codeValRet = Mid(codeValRet, i + 1)
  End If
End Function

Private Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Function GetString(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  End If
  
  GetString = token
End Function


Private Function GetToken(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim i As Long
  i = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, i + 1, 1) <> Chr(34) And i < Len(codeValRet)
      i = i + 1
    Loop
    If i > 0 Then
      token = Left(codeValRet, i)
      codeValRet = Mid(codeValRet, i + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  Else
    If ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
      (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z")) And i < Len(codeValRet) Then
      Do While ((Mid(codeValRet, i + 1, 1) >= "a" And Mid(codeValRet, i + 1, 1) <= "z") Or _
        (Mid(codeValRet, i + 1, 1) >= "A" And Mid(codeValRet, i + 1, 1) <= "Z") Or _
        (Mid(codeValRet, i + 1, 1) >= "0" And Mid(codeValRet, i + 1, 1) <= "9") Or _
         Mid(codeValRet, i + 1, 1) = "_" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" Or _
         Mid(codeValRet, i + 1, 1) = "|fffd|" _
         ) And i < Len(codeValRet)
        i = i + 1
      Loop
      If i > 0 Then
        token = Left(codeValRet, i)
        codeValRet = Mid(codeValRet, i + 1)
        OverreadBlanks codeValRet
      End If
    Else
      token = GetNextChar(codeValRet)
    End If
  End If
  
  GetToken = token
End Function

Private Function DoPrint(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0) As String
  On Error GoTo 0
  Dim res As String
  m_InPrint = True
  
  CheckSubParams codeValRet, c
  
  res = GetExpression(codeValRet, c)
  m_InPrint = False
  If res = "" Then
    DoPrint = "'-/-"
'    c.Parent.Cells(c.Row, c.Column + rightoffset).Value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  DoPrint = res
'  c.Parent.Cells(c.Row, c.Column + rightoffset).Value = res
End Function

Private Sub DoPrintBelow(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0)
  On Error GoTo 0
  Dim res As String
  
  Dim y As Long
  y = c.Row + 1
  Do While Not IsEmpty(m_WS.Cells(y, c.Column))
    y = y + 50
  Loop
  
  If y > 1 Then
    Do While IsEmpty(m_WS.Cells(y, c.Column))
      y = y - 1
    Loop
    y = y + 1
  End If
  
'  Debug.Print codeValRet
  CheckSubParams codeValRet, m_WS.Cells(y, c.Column)
  
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    m_WS.Cells(y, c.Column).Value = "'-/-"
    Exit Sub
  End If
  
  If IsFullyNumeric(MyReplace(res, ",", ".")) Then
    m_WS.Cells(y, c.Column).Value = Val(MyReplace(res, ",", "."))
  Else
    m_WS.Cells(y, c.Column).Value = res
  End If
'  m_WS.Cells(y, c.Column).NumberFormat = c.NumberFormat
'  m_WS.Cells(y, c.Column).Interior.Color = c.Interior.Color
'  m_WS.Cells(y, c.Column).Font.Color = c.Font.Color
End Sub

Sub CheckSubParams(ByRef codeValRet As String, ByRef c As Range)
  Dim s As String
  If Left(codeValRet, 1) <> "(" Then Exit Sub
  codeValRet = Mid(codeValRet, 2)
  s = GetToken(codeValRet)
  Select Case s
    Case "BC"
      If Left(codeValRet, 1) <> ":" Then
        XLScriptAddLogEntry "BC must be followed by ':' in " & m_WS.name & "!" & c.Address & " Value: " & c.Value
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      s = GetExpression(codeValRet, c)
      If IsNumeric(s) Then
        c.Interior.Color = Val(s)
      Else
        c.Interior.Color = RGB(255, 255, 255)
      End If
      If Left(codeValRet, 1) <> ")" Then
        XLScriptAddLogEntry "Sub param must be followed by ')' or ';' in " & m_WS.name & "!" & c.Address & " Value: " & c.Value
        Exit Sub
      End If
      codeValRet = Mid(codeValRet, 2)
      OverreadBlanks codeValRet
  End Select
End Sub


Private Sub DoPrintBitfield(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  Dim res As String
  Dim tCodeValRet As String
  tCodeValRet = codeValRet
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    XLScriptAddLogEntry "Error: Expression not found (" & tCodeValRet & ")! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  End If
  GetComma codeValRet, c
  
  Dim f As xlFld
  Set f = GetDef(codeValRet, c)
  GetComma codeValRet, c
  
  Dim sep As String
  sep = GetExpression(codeValRet, c)
  
  Dim onlyExistant As Boolean
  onlyExistant = True
  
  Dim foundone As Boolean
  foundone = False
  c.Value = ""
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = False
  x = &H80000000
  
  If Not onlyExistant Then
    c.Value = "0x" & Hex(CLng(res)) & " (" & res & ")"
  End If
  
  Dim i As Long
  
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundone = False
      For Each item In f.m_Col
        If x = item.m_Value Then
          foundone = True
          If Len(c.Value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.Value = c.Value & vbLf
              Else
                c.Value = c.Value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          If onlyExistant Then
            c.Value = c.Value & item.m_Txt
          Else
            c.Value = c.Value & "0x" & Hex(item.m_Value) & " - " & item.m_Txt
          End If
          
        End If
      Next item
      
      If Not onlyExistant Then
        If Not foundone Then
          If Len(c.Value) > 0 Then
            For i = 1 To Len(sep)
              If Mid(sep, i, 1) = "n" Then
                c.Value = c.Value & vbLf
              Else
                c.Value = c.Value & Mid(sep, i, 1)
              End If
            Next i
          End If
          
          c.Value = c.Value & "0x" & Hex(x) & " - ???"
        End If
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(c.Value) = 0 Then
   c.Value = "'-"
  End If
'  If Not foundOne Then c.Value = res
End Sub

Private Function ValToBin(v As Long) As String
  Dim i As Long
  Dim x As Long
  Dim rv As String
  Dim first As Boolean
  first = True
  x = &H80000000
  rv = "b"
  For i = 1 To 32
    If (v And x) <> 0 Then
      first = False
      rv = rv & "1"
    Else
      If Not first Then
        rv = rv & "0"
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next i
  If first Then
    rv = "b0"
  End If
  ValToBin = rv
End Function

Private Function DoFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.Value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "NEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    If ref.count > 0 Then
      For cnt = 1 To ref.count
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            UpdateStatus ("Generiere Ergebnisbl|fffd|tter (" & m_WS.name & ") - " & fn.m_Current & " / " & ref.count)
            MyLastTime = Now
          End If
          If Beenden Then Exit Function
        End If
        
        If fn.m_WidthCurrent = 0 Then
          m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column), _
                m_WS.Cells(cEnd.Row + 1 + addedLines + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
          maxAddLines = -10000
        End If
        
        m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
        m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth).PasteSpecial xlPasteAll
        
        Dim newlines As Long
        newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
        If newlines > maxAddLines Then
          maxAddLines = newlines
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
    
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoFor = addedLines
End Function

Private Function DoLFor(ByRef codeValRet As String, ByRef c As Range, rng As Range, reclevel As Long) As Long
  
  DoLFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.Value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  Dim ref
  m_InPrint = True
  Set ref = GetRef(codeValRet, c)
  m_InPrint = False
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "LNEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  
  
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If reclevel = 1 Then MyLastTime = Now
    
    
    If ref.count > 0 Then
    
      Dim lforlines As Long
      lforlines = CLng(ref.count / widthAm) + IIf(ref.count Mod widthAm = 0, 0, 1)
      
      Dim wasCut As Boolean
      wasCut = False
      
      If cEnd.Row + 1 + lforlines - 1 > 65000 Then
        lforlines = 10
        wasCut = True
      End If
      
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), m_WS.Cells(cEnd.Row + 1 + lforlines - 1, c.Column + forwidth * widthAm - 1)).PasteSpecial xlPasteAll
      
      cnt = 1
      Dim lforam As Long
      lforam = lforlines * widthAm
      
      Dim printvals As New Collection
      Dim tc As Range
      Dim xlf As LForItem
      For Each tc In m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column))
        ' F<!1 P item.FNCOUNT
        Dim tpos As Long
        Dim tleft As String
        tpos = InStr(tc.Value, m_CodeStart & "P " & res)
        If tpos > 0 Then
          Set xlf = New LForItem
          xlf.m_Prefix = ""
          If tpos > 1 Then
            xlf.m_Prefix = Left(tc.Value, tpos - 1)
          End If
          xlf.m_Val = Mid(tc.Value, tpos + Len(m_CodeStart & "P " & res & "."))
          xlf.m_X = tc.Column - c.Column
          xlf.m_Y = tc.Row - c.Row - 1
          printvals.Add xlf
          
        End If
      Next tc
      
      
      
      For cnt = 1 To lforam
      
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If reclevel = 1 Then
          If MyLastTime + TimeValue("0:00:02") < Now Then
            UpdateStatus ("Generiere Ergebnisbl|fffd|tter (" & m_WS.name & ") - " & fn.m_Current & " / " & ref.count)
            MyLastTime = Now
          End If
          If Beenden Then Exit Function
        End If
        
        Dim newlines As Long
        
        maxAddLines = 0
        If wasCut = True And cnt = lforam Then
          For Each xlf In printvals
            m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X).Value = "[...]"
          Next xlf
        ElseIf cnt > ref.count Then
          For Each xlf In printvals
            m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X).Value = ""
          Next xlf
        Else
'          newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), reclevel + 1, fn.m_WidthCurrent)
          For Each xlf In printvals
          
            Dim tstring As String
            tstring = xlf.m_Val
            Set tc = m_WS.Cells(cEnd.Row + 1 + addedLines + xlf.m_Y, c.Column + fn.m_WidthCurrent * forwidth + xlf.m_X)
            If tstring = "" Then
              tc.Value = xlf.m_Prefix & ref(cnt)
            ElseIf tstring = "FNCOUNT" Then
              tc.Value = xlf.m_Prefix & cnt
            Else
              If VarValueExists(ref(cnt), tstring) Then
                tc.Value = xlf.m_Prefix & ref(cnt)(tstring)
              End If
            End If
          Next xlf
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
    
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoLFor = addedLines
End Function


Private Sub DoDiagData(ByRef codeValRet As String, ByRef c As Range, rng As Range)
  
  On Error GoTo 0
  
  Dim endofline As String
  endofline = codeValRet
  Dim tok As String
  tok = GetToken(codeValRet)
  
  ' OK, jetzt das Ende des DIAGDATA Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "DIAGDATAEND " & endofline, LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: DIAGDATA " & tok & " missing DIAGDATAEND " & tok & "! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    c.EntireRow.Delete
    Exit Sub
  End If
  
  Dim coitem As ChartObject
  Dim cgitem As ChartGroup
  Dim scitem As Series
  If m_WS.ChartObjects.count > 0 Then
    For Each coitem In m_WS.ChartObjects
      If UCase(coitem.name) = UCase(tok) Then
        For Each cgitem In coitem.Chart.ChartGroups
          Set scitem = cgitem.SeriesCollection(1)
'          If IsReadableFormula(scitem) Then
            scitem.Formula = "=SERIES(," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, c.Column).Address & _
              ":" & m_WS.Cells(cEnd.Row - 1, c.Column).Address & _
              "," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, cEnd.Column).Address & ":" & _
              m_WS.Cells(cEnd.Row - 1, cEnd.Column).Address & ",1)"
'          End If
        Next cgitem
      End If
    Next coitem
  End If
  
  cEnd.EntireRow.Delete
  c.EntireRow.Delete
  
End Sub


Private Function GetCollectionStart(c)
  On Error GoTo start1
  If IsObject(c(0)) Then
  End If
  GetCollectionStart = 0
  Exit Function
start1:
  GetCollectionStart = 1
End Function

Private Function GetExpression(ByRef codeValRet As String, c As Range) As String
  Dim pos As Long
  On Error GoTo 0
  OverreadBlanks codeValRet
  ' Summe auf eine Variable eines Arrays bilden
  If UCase(Left(codeValRet, 4)) = "SUM " Then
    codeValRet = Mid(codeValRet, 4)
    Dim ref
    Set ref = GetRef(codeValRet, c)
    GetComma codeValRet, c
      Dim tok As String
    tok = GetToken(codeValRet)
    If Not ref Is Nothing Then
      Dim item
      Dim s As Long
      s = 0
      For Each item In ref
        If PropertyNameExists(item, tok) Then
          s = s + CLng(item.Properties(UCase(tok)))
        Else
          XLScriptAddLogEntry "Warning: Variable '" & tok & "' not existant! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
        End If
      Next item
      GetExpression = s
      Exit Function
    End If
'  ElseIf Left(codeValRet, 1) >= "0" And Left(codeValRet, 1) <= "9" Then
  ElseIf (Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z") Then
    GetExpression = XLScriptGetVarValue(codeValRet, c)
    Exit Function
  ElseIf (Left(codeValRet, 1) = "*") Then
    pos = InStr(codeValRet, ")")
    If pos > 0 Then
      Dim endstr As String
      endstr = Mid(codeValRet, 2, pos - 2)
      Dim tp As String
      tp = Mid(codeValRet, pos + 1) & endstr
      GetExpression = GetExpression(tp, c)
      codeValRet = Mid(codeValRet, pos)
    End If
    Exit Function
  ElseIf Left(codeValRet, 1) = Chr(34) Then
    pos = InStr(2, codeValRet, Chr(34))
    If pos > 0 Then
      GetExpression = Mid(codeValRet, 2, pos - 2)
      codeValRet = Mid(codeValRet, pos + 1)
      Exit Function
    Else
      XLScriptAddLogEntry "Error: " & Chr(22) & " missing! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    End If
  End If
End Function

Private Function GetVarName(ByRef codeValRet As String, ByRef c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(tok, 1) >= "a" Or Left(tok, 1) <= "z" Or Left(tok, 1) >= "A" Or Left(tok, 1) <= "Z" Then
      GetVarName = tok
      Exit Function
    End If
  End If
  XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
End Function

Function XLScriptGetVarValue(ByRef codeValRet As String, c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  Dim wasdot As Boolean
  wasdot = False
  
  Dim goitem As XLScriptGlobalObject
  
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
  
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    Select Case UCase(tok)
   
'      Case "DB"
'        res = XLScriptGetDBVarValue(codeValRet, m_DB, c)
'      Case "WS"
'        res = XLScriptGetDBVarValue(codeValRet, m_Workspace, c)
'      Case "APP"
'        res = XLScriptGetDBVarValue(codeValRet, m_App, c)
      Case "XL"
        res = XLScriptGetDBVarValue(codeValRet, m_Excel, c)
      Case "XLWB"
        res = XLScriptGetDBVarValue(codeValRet, m_Workbook, c)
      Case Else
    
        Dim found As Boolean
        found = False
        
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = XLScriptGetDBVarValue(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
        
        If Not found Then
          Dim item As XLForNext
          For Each item In m_FN
            If UCase(item.m_Name) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, item.m_Ref(item.m_Current), c, item)
'              If m_InPrint = True And XLSCript_Debug = True Then
'                item.m_Ref(item.m_Current).m_WasPrinted = True
'              End If
              found = True
              Exit For
            End If
          Next item
        End If
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem2d As XLScriptArray2D
          For Each vaitem2d In m_VarArray2D
            If UCase(vaitem2d.Properties("NAME")) = UCase(tok) Then
              
              res = XLScriptGetDBVarValue(codeValRet, vaitem2d.items, c, vaitem2d)
              
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem2d.m_WasPrinted = True
              End If
'              If wasdot Then
'                Set res = vaitem2d.items(codeValRet).items
'              End If
              found = True
              Exit For
            End If
          Next vaitem2d
        End If
        
            
        If Not found Then
          Dim svitem As XLScriptSimpleVar
          For Each svitem In m_SimpleVars
            If UCase(svitem.m_Txt) = UCase(tok) Then
              res = svitem.m_Value
              If m_InPrint = True And XLSCript_Debug = True Then
                svitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next svitem
        End If
        
        
        If Not found Then
          Dim vaitem As XLScriptArray
          For Each vaitem In m_VarArray
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              res = XLScriptGetDBVarValue(codeValRet, vaitem.items, c, vaitem)
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vaitem
        End If
        
        
        If Not found Then
          
          If IsValid(c) Then
            XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name!"
          End If
        
          Do While wasdot
            wasdot = False
            tok = GetToken(codeValRet)
            If Len(tok) > 0 Then
              If Left(codeValRet, 1) = "." Then
                codeValRet = Mid(codeValRet, 2)
                wasdot = True
              End If
            
            End If
            
          Loop
        End If
    End Select
  End If
  XLScriptGetVarValue = res
End Function

Function XLScriptGetDBVarValue(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing) As String
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    XLScriptGetDBVarValue = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res As String
  
'  If Left(codeValRet, 1) = "(" Then
'    codeValRet = Mid(codeValRet, 2)
'    res = GetExpression(codeValRet, c)
  
'    If Not Left(codeValRet, 1) = ")" Then
'      XLScriptAddLogEntry "Error: '" & tok & "(' is missing ')'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
'    End If
    
  
  tok = GetToken(codeValRet)
  Dim wasdot As Long
  wasdot = False
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
      wasdot = True
    End If
    
    If VarValueExists(par, tok) Then
      res = par(tok)
    ElseIf wasdot = True And ObjectNameExists(par, tok) = True Then
      res = XLScriptGetDBVarValue(codeValRet, par(tok), c)
    ElseIf PropertyNameExists(par, tok) = True Then
      res = par.Properties(tok)
    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
          End If
        Case "ADAPTIVEMENUS"
          res = par.AdaptiveMenus
        Case "ADAPTIVEMENU"
          res = par.AdaptiveMenu
        Case "BUILD"
          res = par.Build
        Case "BUILTIN"
          res = par.BuiltIn
        Case "COMADDINS"
          res = XLScriptGetDBVarValue(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          res = XLScriptGetDBVarValue(codeValRet, par.CommandBars, c)
        Case "CONNECT"
          res = par.Connect
        Case "CONTEXT"
          res = par.Context
        Case "COUNT"
          res = par.count
        Case "CREATOR"
          res = par.Creator
        Case "DBENGINE"
          res = XLScriptGetDBVarValue(codeValRet, par.DBEngine, c)
        Case "DESCRIPTION"
          res = par.Description
        Case "DISABLEASKAQUESTIONDROPDOWN"
          res = par.DisableAskAQuestionDropdown
        Case "DISABLECUSTOMIZE"
          res = par.DisableCustomize
        Case "DISPLAYFONTS"
          res = par.DisplayFonts
        Case "DISPLAYKEYSINTOOLTIPS"
          res = par.DisplayKeysInTooltips
        Case "DISPLAYTOOLTIPS"
          res = par.DisplayTooltips
        Case "ENABLED"
          res = par.Enabled
        Case "FIELDS"
          res = XLScriptGetDBVarValue(codeValRet, par.Fields, c)
        Case "FULLPATH"
          res = par.fullpath
        Case "GUID"
          res = par.Guid
        Case "INDEXES"
          res = XLScriptGetDBVarValue(codeValRet, par.Indexesm, c)
        Case "ISBROKEN"
          res = par.isbroken
        Case "ISCOMPILED"
          res = par.IsCompiled
        Case "ITEMS"
          res = par.items
        Case "NAME"
          res = par.name
        Case "NAMELOCAL"
          res = par.NameLocal
        Case "PRINTERS"
          res = XLScriptGetDBVarValue(codeValRet, par.Printers, c)
        Case "PRODUCTCODE"
          res = par.ProductCode
        Case "PROGID"
          res = par.ProgId
        Case "REFERENCES"
          res = XLScriptGetDBVarValue(codeValRet, par.References, c)
        Case "REFERSTO"
          res = par.RefersToLocal
        Case "RELATIONS"
          res = XLScriptGetDBVarValue(codeValRet, par.Relations, c)
        Case "SHEETS"
          res = par.Worksheets
        Case "VERSION"
          res = par.Version
        Case "VISIBLE"
          res = par.Visible

        Case Else
          res = XLScriptGetDBVarValue(codeValRet, par.Properties(UCase(tok)), c)
      End Select
    End If
  End If
  XLScriptGetDBVarValue = res
  Exit Function
getError:
  If Len(tok) > 0 Then
    XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  Else
    XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  End If
  
End Function

Private Function GetRef(ByRef codeValRet As String, c As Range)
  On Error GoTo 0
  Dim tok As String
  Dim res
  Dim wasdot As Boolean
  wasdot = False
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Trim(Mid(codeValRet, 2))
      wasdot = True
    End If
    Select Case UCase(tok)
'      Case "DB"
'        Set res = GetDBRef(codeValRet, m_DB, c)
'      Case "WS"
'        Set res = GetDBRef(codeValRet, m_Workspace, c)
'      Case "APP"
'        Set res = GetDBRef(codeValRet, m_App, c)
      Case "XL"
        Set res = GetDBRef(codeValRet, m_Excel, c)
      Case "XLWB"
        Set res = GetDBRef(codeValRet, m_Workbook, c)
      Case Else
        Dim found As Boolean
        found = False
        
        Dim goitem As XLScriptGlobalObject
        For Each goitem In m_GlobalObjects
          If UCase(goitem.m_Name) = UCase(tok) Then
            res = GetDBRef(codeValRet, goitem.m_Object, c)
            found = True
            Exit For
          End If
        Next goitem
            
            
        ' Ansonsten muss es eigentlich eine Variable sein...
        Dim item As XLForNext
        For Each item In m_FN
          If UCase(item.m_Name) = UCase(tok) Then
            Set res = GetDBRef(codeValRet, item.m_Ref(item.m_Current), c, item)
            found = True
            Exit For
          End If
        Next item
        
        ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
        If Not found Then
          Dim vaitem As XLScriptArray2D
          For Each vaitem In m_VarArray2D
            If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
              Set res = vaitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vaitem.m_WasPrinted = True
              End If
              If wasdot Then
                If ObjectNameExists(vaitem.items, codeValRet) Then
                  Set res = vaitem.items(codeValRet).items
                Else
                  Set res = Nothing
                End If
              End If
              If Not res Is Nothing Then
                found = True
              End If
              Exit For
            End If
          Next vaitem
        End If
        
        If Not found Then
          Dim vasitem As XLScriptArray
          For Each vasitem In m_VarArray
            If UCase(vasitem.Properties("NAME")) = UCase(tok) Then
              Set res = vasitem.items
              If m_InPrint = True And XLSCript_Debug = True Then
                vasitem.m_WasPrinted = True
              End If
              found = True
              Exit For
            End If
          Next vasitem
        End If
        
        If Not found Then
          XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
        End If
    End Select
  End If
  If Not IsEmpty(res) Then
    Set GetRef = res
  Else
    Set GetRef = Nothing
  End If
End Function

Private Function GetDBRef(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing)
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    Set GetDBRef = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
    End If
    
    
'    If PropertyNameExists(par, tok) Then
'      Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
'    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
          End If
        Case "CONTAINERS"
          Set res = GetDBRef(codeValRet, par.Containers, c)
        Case "DBENGINE"
          Set res = GetDBRef(codeValRet, par.DBEngine, c)
        Case "REFERENCES"
          Set res = GetDBRef(codeValRet, par.References, c)
        Case "RELATIONS"
          Set res = GetDBRef(codeValRet, par.Relations, c)
        Case "FIELDS"
          Set res = GetDBRef(codeValRet, par.Fields, c)
        Case "INDEXES"
          Set res = GetDBRef(codeValRet, par.Indexes, c)
        Case "PRINTERS"
          Set res = GetDBRef(codeValRet, par.Printers, c)
        Case "COMADDINS"
          Set res = GetDBRef(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          Set res = GetDBRef(codeValRet, par.CommandBars, c)
        Case "COUNT"
          Set res = par.count
        Case "BUILD"
          Set res = par.Build
        Case "ISCOMPILED"
          Set res = par.IsCompiled
        Case "PRODUCTCODE"
          Set res = par.ProductCode
        Case "VERSION"
          Set res = par.Version
        Case "TABLEDEFS"
          Set res = GetDBRef(codeValRet, par.TableDefs, c)
        Case "GROUPS"
          Set res = GetDBRef(codeValRet, par.Groups, c)
        Case "USERS"
          Set res = GetDBRef(codeValRet, par.Users, c)
        Case "NAMES"
          Set res = GetDBRef(codeValRet, par.Names, c)
        Case "ITEMS"
          Set res = par.items
          
        Case Else
          If PropertyNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
          ElseIf ObjectNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par(UCase(tok)), c)
          End If
      End Select
'    End If
  End If
  Set GetDBRef = res
  Exit Function
getError:
  
  If Len(tok) > 0 Then
    XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  Else
    XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.Value
  End If
  Set GetDBRef = Nothing
End Function


Public Sub XLScriptAddLogEntry(s As String)
'  If Not m_ResultWorkbook Is Nothing Then
'    m_ResultWorkbook.Sheets("Log").Cells(m_LogY, 1) = s
'    m_LogY = m_LogY + 1
'  End If
  Debug.Print s
  m_Log.Add s
End Sub


Private Function CountReadable(ref) As Boolean
  On Error GoTo notReadable
  Dim i As Long
  i = ref.count
  CountReadable = True
  Exit Function
  
notReadable:
  CountReadable = False
End Function


Public Function IsReadableFormula(anything) As Boolean
  On Error GoTo nopeNotReadable
  Debug.Print anything.Formula
  IsReadableFormula = True
  Exit Function
nopeNotReadable:
  IsReadableFormula = False
End Function

Function XLScriptGetNewObject(s As String) As Object
  Select Case s
    Case "XLScriptVar"
      Set XLScriptGetNewObject = New XLScriptVar
      Exit Function
    Case "XLScriptSimpleVar"
      Set XLScriptGetNewObject = New XLScriptSimpleVar
      Exit Function
    Case Else
      Err.Raise vbObjectError + 27, "XLScript.XLScript", "Unknown XLScriptGetNewObject type '" & s & "'"
  End Select
End Function


Function IsValid(c As Range) As Boolean
  IsValid = False
  On Error GoTo notValid
  Dim tstr
  tstr = c.Value
  IsValid = True
  Exit Function
notValid:
End Function
Public Function VarValueExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(par(name))
  VarValueExists = True
  Exit Function
  
notReadable:
  VarValueExists = False
End Function

Public Function ObjectNameExists(par, name As String) As Variant
  On Error GoTo notReadable
  Dim s As Variant
  Set s = par(name)
  ObjectNameExists = True
  Exit Function
  
notReadable:
  ObjectNameExists = False
End Function

Public Function PropertyNameExists(par, name As String) As Boolean
  On Error Resume Next
  PropertyNameExists = True
  Dim s As String
  s = CStr(par.Properties(UCase(name)))
  If Err.Number = 0 Then Exit Function
'XXX
  Err.Clear
  Dim t
  Set t = par.Properties(UCase(name))
  If Err.Number = 0 Then Exit Function
  
  PropertyNameExists = False
End Function

Function GetValueFromField(ByRef rs As Object, fieldname As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetValueFromField = defvalue
  If Not IsNull(rs.Fields(fieldname).Value) Then
    GetValueFromField = rs.Fields(fieldname).Value
  End If
  
nogo:
  
End Function

Function FieldItemExists(ByRef rs As Object, txt As String) As Boolean

  On Error GoTo nogo
  Dim v
  v = rs.Fields(txt).Value
  FieldItemExists = True
  
nogo:

End Function

Function TranslateDBField(fn As String) As String
  Select Case UCase(fn)
    Case "UNLOCKEDFORMULASMISSINGSHEETPROTECTION"
      TranslateDBField = "UNLOCKEDFORMULASMISSSHEETPROT"
    Case "LOCKEDFORMULASWITHOUTSHEETPASSWORD"
      TranslateDBField = "LOCKEDFORMULASWOUTSHEETPWD"
    Case "CELLSWITHEXTERNALREFERENCESAMOUNT"
      TranslateDBField = "CELLSWITHEXTERNALREFAMT"
    Case "PROTECTEDWORKSHEETSWITHPASSWORD"
      TranslateDBField = "PROTECTEDWORKSHEETSWITHPWD"
    Case "PROTECTEDWOKRSHEETSWITHOUTPASSWORD"
      TranslateDBField = "PROTECTEDWOKRSHEETSWOUTPWD"
    Case "MISSINGEXTERNALREFERENCESAMOUNT"
      TranslateDBField = "MISSINGEXTERNALREFERENCESAMT"
    Case "SHEETSWITHCIRCULARREFERENCESAMOUNT"
      TranslateDBField = "SHEETSWITHCIRCULARREFAMT"
    Case "MISSINGEXTERNALREFERENCESAMOUNTBC"
      TranslateDBField = "MISSINGEXTERNALREFERENCESAMTBC"
    Case "SHEETSWITHCIRCULARREFERENCESAMOUNTBC"
      TranslateDBField = "SHEETSWITHCIRCULARREFAMTBC"
    Case "UNLOCKEDFORMULASMISSINGSHEETPROTECTIONBC"
      TranslateDBField = "UNLOCKEDFORMULASMISSHEETPROTBC"
    Case "LOCKEDFORMULASWITHOUTSHEETPASSWORDBC"
      TranslateDBField = "LOCKEDFORMULASWOUTSHEETPWDBC"
    Case "CELLSWITHEXTERNALREFERENCESAMOUNTBC"
      TranslateDBField = "CELLSWITHEXTERNALREFAMTBC"
    Case "PROTECTEDWORKSHEETSWITHPASSWORDBC"
      TranslateDBField = "PROTECTEDWORKSHEETSWITHPWDBC"
    Case "PROTECTEDWOKRSHEETSWITHOUTPASSWORDBC"
      TranslateDBField = "PROTECTEDWOKRSHEETSWOUTPBC"
    
    Case Else
      TranslateDBField = fn
  End Select
End Function


Sub XLStoreValsToDB(ByVal analyseWarErfolgreich As Boolean)

On Error GoTo nogo
  LogPrint "XLStoreValsToDB"
  
  If theidvDateiID <= 0 Then Exit Sub
  LogPrint "XLStoreValsToDB-Start"
  
  
  Dim rs As Object
  Dim rsecc As Object
  Dim rslinks As Object
  
  If G_conn Is Nothing Then Exit Sub
  
  G_conn.Execute "DELETE FROM idvDateienTodo WHERE idvDateiID=" & theidvDateiID
  
  Dim riskrs As Object
  Dim rsFormeln As Object
  Dim rsParam As Object
  Dim rsTodos As Object

  LogPrint "XLStoreValsToDB-1"

  Set riskrs = OpenRS("SELECT * FROM ECCDateienRisiko WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rs = OpenRS("SELECT * FROM ECCAnalyse WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsecc = OpenRS("SELECT * FROM idvDateien WHERE idvDateiID = " & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rslinks = OpenRS("SELECT * FROM ECCVerknuepfungen WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsFormeln = OpenRS("SELECT * FROM ECCDateienFormeln WHERE idvDateiID = 0", G_conn, MYadOpenDynamic, MYadLockOptimistic)
  Set rsParam = OpenRS("SELECT * FROM gParameter", G_conn, MYadOpenDynamic, MYadLockReadOnly)
  Set rsTodos = OpenRS("SELECT * FROM idvDateienTodo WHERE idvDateiID = " & theidvDateiID, G_conn, MYadOpenDynamic, MYadLockOptimistic)
  
  LogPrint "XLStoreValsToDB-2"
  
  If riskrs Is Nothing Or rs Is Nothing Or rsecc Is Nothing Or rsFormeln Is Nothing Or rsParam Is Nothing Or rsTodos Is Nothing Then
    If Not riskrs Is Nothing Then
      riskrs.Close
      Set riskrs = Nothing
    End If
    If Not rs Is Nothing Then
      rs.Close
      Set rs = Nothing
    End If
    If Not rsecc Is Nothing Then
      rsecc.Close
      Set rsecc = Nothing
    End If
    If Not rslinks Is Nothing Then
      rslinks.Close
      Set rslinks = Nothing
    End If
    If Not rsFormeln Is Nothing Then
      rsFormeln.Close
      Set rsFormeln = Nothing
    End If
    If Not rsParam Is Nothing Then
      rsParam.Close
      Set rsParam = Nothing
    End If
    If Not rsTodos Is Nothing Then
      rsTodos.Close
      Set rsTodos = Nothing
    End If
    Exit Sub
  End If
  
  LogPrint "XLStoreValsToDB-3"
  
  rs.AddNew
  rs.Fields("idvDateiID").Value = theidvDateiID
  Dim nowdate As Date
  If theTrackerFreigabe Then
    nowdate = theTrackerFreigabeDatum
  Else
    nowdate = Now
  End If
  rs.Fields("Datum").Value = nowdate
  If FileExists(theFilename) Then
    rs.Fields("Dateigroesse").Value = FileLen(theFilename)
  End If
  If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
    rs.Fields("Ersteller").Value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
  Else
    rs.Fields("Ersteller").Value = ""
  End If
  If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
    Dim d As Date
    d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
    If d < #1/1/1900# Then d = #1/1/1900#
    rs.Fields("Erstellungsdatum").Value = d
  Else
    rs.Fields("Erstellungsdatum").Value = DateSerial(1900, 1, 1)
  End If
  
  On Error Resume Next
  
  Dim i As Long
  LogPrint "XLStoreValsToDB-4"
  
  If Not XLScriptGetArray("EXTERNALFILES") Is Nothing Then
    If XLScriptGetArray("EXTERNALFILES").items.count > 0 Then
      For i = 1 To XLScriptGetArray("EXTERNALFILES").items.count
        rslinks.AddNew
        
        rslinks.Fields("idvDateiID").Value = theidvDateiID
        rslinks.Fields("Datum").Value = nowdate
        If FullVersion = True Or i <= 3 Then
          rslinks.Fields("Dateiname").Value = XLScriptGetArray("EXTERNALFILES").items(i).m_SortName
        Else
          rslinks.Fields("Dateiname").Value = "Demo"
        End If
        rslinks.Update
      Next i
    End If
  End If
  LogPrint "XLStoreValsToDB-5"
  
  
  rslinks.Close
  Set rslinks = Nothing
  
  
  If Not XLScriptGetArray2D("TODOS") Is Nothing Then
    If XLScriptGetArray2D("TODOS").items.count > 0 Then
      For i = 1 To XLScriptGetArray2D("TODOS").items.count
        rsTodos.AddNew
        rsTodos.Fields("idvDateiID").Value = theidvDateiID
        rsTodos.Fields("Todo").Value = XLScriptGetArray2D("TODOS").items(i)("COMMENT")
        rsTodos.Fields("Location").Value = Left(XLScriptGetArray2D("TODOS").items(i)("NAME") & "!" & XLScriptGetArray2D("TODOS").items(i)("ADDRESS"), 70)
        rsTodos.Update
      Next i
    End If
  End If
  LogPrint "XLStoreValsToDB-6"
  
  i = 1
  Dim item
  Dim litem
  Dim cnt As Long
  For Each item In m_AllVars
'    Debug.Print "AllVars: " & item.m_SortName
    Select Case TypeName(item)
      Case "XLScriptArray2D"
        If theTrackerFreigabe = True Or (theTrackerFormelnExtrahieren >= 0 And (theTrackerFormelnExtrahieren <= CDbl(XLScriptGetSimpleVar("TotalRisk").m_Value) Or theTrackerFormelnExtrahieren <= theTrackerFachrisiko)) Then
            If item.m_SortName = "NAMES" Then
              cnt = 1
              For Each litem In item.items
                rsFormeln.AddNew
                rsFormeln.Fields("idvDateiID").Value = theidvDateiID
                rsFormeln.Fields("Datum").Value = nowdate
                rsFormeln.Fields("Position").Value = cnt
                rsFormeln.Fields("Tabellenname").Value = Left(litem(1), 31)
                rsFormeln.Fields("Formel").Value = IIf(Left(litem(3), 1) = "'", Mid(litem(3), 2), litem(3))
                rsFormeln.Fields("Typ").Value = "N"
                rsFormeln.Update
                cnt = cnt + 1
              Next litem
            ElseIf item.m_SortName = "FORMULAS" Then
              cnt = 1
              For Each litem In item.items
                rsFormeln.AddNew
                rsFormeln.Fields("idvDateiID").Value = theidvDateiID
                rsFormeln.Fields("Datum").Value = nowdate
                rsFormeln.Fields("Position").Value = cnt
                rsFormeln.Fields("Tabellenname").Value = Left(litem(1), 31)
                rsFormeln.Fields("Addresse").Value = Left(litem(2), 15)
                rsFormeln.Fields("Typ").Value = litem(3)
                rsFormeln.Fields("Kommentar").Value = IIf(Left(litem(7), 1) = "'", Mid(litem(7), 2), litem(7))
                rsFormeln.Fields("Formel").Value = IIf(Left(litem(6), 1) = "'", Mid(litem(6), 2), litem(6))
    '            rsFormeln.fields("Kommentar").Value = IIf(Left(litem(6), 1) = "'", Mid(litem(6), 2), litem(6)) & IIf(Len(litem(7)) > 0, vbCrLf & vbCrLf & "Erl|fffd|uterung: " & vbCrLf & IIf(Left(litem(7), 1) = "'", Mid(litem(7), 2), litem(7)), "")
    '            rsFormeln.fields("Kommentar").Value = IIf(Left(litem(6), 1) = "'", Mid(litem(6), 2), litem(6))
    '            rsFormeln.fields("Formel").Value = IIf(Left(litem(7), 1) = "'", Mid(litem(7), 2), litem(7))
    '            rsFormeln.fields("Comment").Value = "GAGA"
                rsFormeln.Update
                cnt = cnt + 1
              Next litem
            ElseIf item.m_SortName = "DIAGRAMS" Then
              cnt = 1
              For Each litem In item.items
                rsFormeln.AddNew
                rsFormeln.Fields("idvDateiID").Value = theidvDateiID
                rsFormeln.Fields("Datum").Value = nowdate
                rsFormeln.Fields("Position").Value = cnt
                rsFormeln.Fields("Tabellenname").Value = Left(litem(1), 31)
                rsFormeln.Fields("Typ").Value = "D"
                rsFormeln.Fields("Formel").Value = IIf(Left(litem(2), 1) = "'", Mid(litem(2), 2), litem(2))
    '            rsFormeln.fields("Kommentar").Value = "Test"
                rsFormeln.Update
                cnt = cnt + 1
              Next litem
            End If
        End If
        If item.m_SortName = "RiskItems" Then
          For Each litem In item.items
            riskrs.AddNew
            riskrs.Fields("idvDateiID").Value = theidvDateiID
            riskrs.Fields("Datum").Value = nowdate
            riskrs.Fields("Name").Value = Left(litem(1), 20)
            riskrs.Fields("Wert").Value = litem(2)
            riskrs.Fields("Farbe").Value = litem(3)
            riskrs.Update
          Next litem
        End If
      Case "XLScriptSimpleVar"
'        Debug.Print TypeName(item), item.m_Txt, item.m_Value
'        If FieldItemExists(rs, item.m_Txt) Then
'          If rs.fields(item.m_Txt).Type = 0 Then
'            If CDate(item.m_Value) < #1/1/1900# Then
'              rs.fields(item.m_Txt).Value = 0
'            Else
'              rs.fields(item.m_Txt).Value = item.m_Value
'            End If
'          Else
            If item.m_Txt = "TotalRisk" Then
                rs.Fields(TranslateDBField(item.m_Txt)).Value = CDbl(item.m_Value)
            Else
                rs.Fields(TranslateDBField(item.m_Txt)).Value = item.m_Value
            End If

'          End If
'        End If
        
      Case "XLScriptVar"
        Debug.Print TypeName(item), item.m_SortName
    End Select
    i = i + 1
  Next item
  LogPrint "XLStoreValsToDB-7"
  
  rs.Update
  rs.Close
  Set rs = Nothing
  
  riskrs.Close
  Set riskrs = Nothing
  
  
  If FieldItemExists(rsecc, "CheckerVersion") Then rsecc.Fields("CheckerVersion").Value = MyECCVersion
  rsecc.Fields("LetzterScan").Value = nowdate
  rsecc.Fields("ScanRisiko").Value = CDbl(XLScriptGetSimpleVar("TotalRisk").m_Value)
'  rsecc.fields("Formelanzahl").Value = XLScriptGetSimpleVar("FORMULAAMOUNT").m_Value
'  rsecc.fields("AnzahlNichtAbgesicherteFormeln").Value = CLng(XLScriptGetSimpleVar("UNLOCKEDFORMULAS").m_Value) + CLng(XLScriptGetSimpleVar("UNLOCKEDFORMULASMISSINGSHEETPROTECTION").m_Value) + CLng(XLScriptGetSimpleVar("LOCKEDFORMULASWITHOUTSHEETPASSWORD").m_Value)
  rsecc.Fields("ECCFormelnGesamt").Value = XLScriptGetSimpleVar("FORMULAAMOUNT").m_Value
  rsecc.Fields("ECCFormelnIndividuell").Value = XLScriptGetSimpleVar("FORMULAINDIVAMOUNT").m_Value
  rsecc.Fields("Checksumme").Value = XLScriptGetSimpleVar("CHECKSUM").m_Value
  If Not XLScriptGetSimpleVar("AUTHOR") Is Nothing Then
    rsecc.Fields("Ersteller").Value = Left(XLScriptGetSimpleVar("AUTHOR").m_Value, 24)
  Else
    rsecc.Fields("Ersteller").Value = ""
  End If
  If Not XLScriptGetSimpleVar("CREATIONDATE") Is Nothing Then
    d = IIf(IsDate(XLScriptGetSimpleVar("CREATIONDATE").m_Value) = True, XLScriptGetSimpleVar("CREATIONDATE").m_Value, DateSerial(1900, 1, 1))
    If d < #1/1/1900# Then d = #1/1/1900#
    rsecc.Fields("Erstellungsdatum").Value = d
  Else
    rsecc.Fields("Erstellungsdatum").Value = DateSerial(1900, 1, 1)
  End If
  
  LogPrint "XLStoreValsToDB-8"
  
  If FileExists(theFilename) Then
    rsecc.Fields("Dateidatum").Value = FileDateTime(theFilename)
  End If
  
  If theTrackerFreigabe Then
    
    Dim ok As Boolean
    ok = True
    
    If analyseWarErfolgreich Then
      If (rsecc.Fields("Risikowert").Value >= GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) And GetValueFromField(rsParam, "DateienVersionierenAbRisk", 1) <> -1) Or _
        GetValueFromField(rsParam, "EincheckenBeiPrgfreigabe", False) <> False Then
         ok = CheckInFile(rsecc, theTrackerFreigabeDatum)
      End If
    Else
      ok = False
    End If
    
    If ok Then
      
      ' Neu, der Checker setzt auch die Freigaben!
      ' Freigaben werden wegen Major Minor nicht mehr gel|fffd|scht
'      G_conn.Execute "DELETE FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.fields("Version")
'      G_conn.Execute "Insert into idvDateienFreigaben (idvDateiID,Version,Datum,FreigebenderUser,Kommentar,Status,FreigabeChecksumme,CCEmpfaenger) Values( '" & theidvDateiID & _
'        "', '" & rsecc.Fields("Version") & "', '" & Format(theTrackerFreigabeDatum, "YYYY-MM-DD hh:mm:ss") & "', '" & theFreigabeuser & "', '" & theFreigabekommentar & "', '0', '" & XLScriptGetSimpleVar("CHECKSUM").m_Value & "', '" & theFreigabeCCListe & "')"
      
      LogPrint "XLStoreValsToDB-9"
      
      Dim trs As Object
      Set trs = OpenRS("SELECT * FROM idvDateienFreigaben WHERE idvDateiID=" & theidvDateiID & " AND Version = " & rsecc.Fields("Version").Value, G_conn, MYadOpenDynamic, MYadLockOptimistic)
      If trs Is Nothing Then
        ok = False
      Else
        If trs.EOF Then
          trs.AddNew
          trs.Fields("idvDateiID").Value = theidvDateiID
          trs.Fields("Version").Value = rsecc.Fields("Version").Value
          ' Major/Minor
          trs.Fields("MajorVersion").Value = rsecc.Fields("MajorVersion").Value
          trs.Fields("MinorVersion").Value = rsecc.Fields("MinorVersion").Value
          ' Freigabe Initiierung speichern
          trs.Fields("FreigabeInitiierung").Value = rsecc.Fields("FreigabeInitiierung").Value
          trs.Fields("FreigabeInitiierendeUser").Value = rsecc.Fields("SpeichernderUserLogonID").Value
        End If
        If FieldItemExists(trs, "CheckerVersion") Then trs.Fields("CheckerVersion").Value = MyECCVersion
        trs.Fields("Datum").Value = theTrackerFreigabeDatum
        trs.Fields("FreigebenderUser").Value = Left(theFreigabeuser, 50)
        trs.Fields("Kommentar").Value = theFreigabekommentar
        trs.Fields("Status").Value = 0
        trs.Fields("FreigabeChecksumme").Value = XLScriptGetSimpleVar("CHECKSUM").m_Value
        trs.Fields("CCEmpfaenger").Value = ""
        trs.Update
        trs.Close
      End If
      Set trs = Nothing
      
      LogPrint "XLStoreValsToDB-10"
      
      If ok Then
          rsecc.Fields("FreigabeChecksumme").Value = XLScriptGetSimpleVar("CHECKSUM").m_Value
          rsecc.Fields("FreigabeStatus").Value = 2
          rsecc.Fields("FreigabeidvDateiID").Value = theidvDateiID
          rsecc.Fields("FreigabeVersion").Value = rsecc.Fields("Version")
          
          SaveSetting _
             appname:="Stromwerken", _
             Section:=progNameShort, _
             Key:="FreigabeErteilt", _
             setting:=1
          AddStatus "Freigabe erfolgreich durchgef|fffd|hrt!"
          StoreUserCommunicateValue "FG", "1"
      Else
          AddStatus "Freigabe nicht erfolgreich!"
          StoreUserCommunicateValue "FG", "0"
      End If
    Else
      AddStatus "Freigabe nicht erfolgreich!"
      StoreUserCommunicateValue "FG", "0"
    End If
                
  LogPrint "XLStoreValsToDB-11"
    
  End If
  rsecc.Update
  
nogo:
On Error Resume Next

  CloseRs rsecc
  CloseRs rsFormeln
  CloseRs rsParam
  CloseRs rsTodos
  
  LogPrint "XLStoreValsToDB-Finished"
  
End Sub

Sub CloseRs(ByRef rs)
On Error Resume Next
  If rs.EditMode <> 0 Then
    rs.CancelUpdate
  End If
  rs.Close
  Set rs = Nothing
End Sub

Attribute VB_Name = "XLScriptArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public items As Collection
Public Properties As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
'  assert 0
  Write #nr, "XLScriptArray"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.count
  Dim i As Long
  For i = 1 To items.count
    Select Case TypeName(items(i))
      Case "XLScriptVar"
        items(i).Store nr
      Case Else
        Debug.Print "Unknown type: " & TypeName(items(i))
    End Select
  Next i
  Write #nr, Properties.count
  For Each item In Properties
    item.Store nr
  Next item
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next i
End Sub

Public Sub Init(Optional n As String = "", Optional v As String = "")
  Set Properties = New Collection
  m_SortName = n
  Properties.Add n, "NAME"
  Properties.Add v, "VAL"
  Set items = New Collection
End Sub

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items.Add v, UCase(n)
  Else
    items.Add v
  End If
End Sub

Function AddNameAndValue(n As String, v As String) As XLScriptVar
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add n, "NAME"
  dv.Properties.Add v, "VAL"
  items.Add dv, CStr(n)
  Set AddNameAndValue = dv
End Function

Sub AddXLScriptVar(ByRef xlsv As XLScriptVar)
  items.Add xlsv
End Sub

Public Sub AddToValue(propertyName As String, v)
'  On Error GoTo wasMissing
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName) + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
  Exit Sub
'wasMissing:
'    Properties.Add nv, v
End Sub


Attribute VB_Name = "XLScriptArray2D"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public m_SortName As String
Public items As Collection
Public itemKeys As Collection
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
'  assert 0
'  Close #1
  Write #nr, "XLScriptArray2D"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.count
  Dim i As Long
  If items.count > 0 Then
    For i = 1 To items.count
      Select Case TypeName(items(i))
        Case "Collection"
          Dim tcoll As Collection
          Set tcoll = items(i)
          Dim tcollkeys As Collection
          Set tcollkeys = itemKeys(i)
          Dim ti As Long
          If tcoll.count > 0 Then
            For ti = 1 To tcoll.count
              Select Case TypeName(tcoll(ti))
                Case "String"
                  Write #nr, tcollkeys(ti), tcoll(ti)
                Case Else
                  Debug.Print "Unknown type: " & TypeName(tcoll(ti))
              End Select
            Next ti
          End If
          Set tcoll = Nothing
          Set tcollkeys = Nothing
        Case "XLScriptArray"
          items(i).Store nr
        Case Else
          Debug.Print "Unknown type: " & TypeName(items(i))
      End Select
  '    Write #nr, itemKeys(i)
  '    Write #nr, items(i)
    Next i
  End If
  Write #nr, Properties.count
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next i
End Sub


Public Sub Init(Optional name As String = "")
  m_SortName = name
  Set items = New Collection
  Set itemKeys = New Collection
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  Properties.Add name, "NAME"
  PropertyKeys.Add "NAME", "NAME"
End Sub

Public Sub AddLine(Optional linename As String = "")
  Dim al As Collection
  Set al = New Collection
  If Len(linename) = 0 Then
    items.Add al
  Else
    items.Add al, linename
  End If
  Set al = New Collection
  itemKeys.Add al
End Sub

Public Function CurrentLine() As Variant
  Set CurrentLine = items(items.count)
End Function

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items(items.count).Add v, UCase(n)
    itemKeys(items.count).Add UCase(n), UCase(n)
  Else
    items(items.count).Add v
    itemKeys(items.count).Add ""
  End If
End Sub

Public Sub AddToValue(n As String, v)
'  On Error Resume Next
  If Len(n) > 0 Then
    Dim nv
    nv = items(items.count).item(UCase(n)) + v
    items(items.count).Remove UCase(n)
    items(items.count).Add nv, UCase(n)
  End If
End Sub

Public Sub AddNameAndValue(n As String, v As String)
  items(items.count).AddNameAndValue n, v
End Sub

Public Function AddXLScriptArray(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items.Add dsa, UCase(n)
  itemKeys.Add UCase(n), UCase(n)
  
  Set AddXLScriptArray = dsa

End Function

Public Function AddXLScriptArray2D(n As String) As XLScriptArray2D
' TODO: Funktionsname falsch, hier wird beim letzten Objekt eine 2D array geadded
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.count).Add da, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  AddXLScriptArray2D = da

End Function

Public Function AddXLScriptArray2DToCurrentLine(n As String) As XLScriptArray2D
' TODO: Funktionsname falsch, hier wird beim letzten Objekt eine 2D array geadded
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.count).Add da, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  AddXLScriptArray2DToCurrentLine = da

End Function

Public Function AddXLScriptArrayToCurrentLine(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items(items.count).Add dsa, UCase(n)
  itemKeys(items.count).Add UCase(n), UCase(n)
  
  Set AddXLScriptArrayToCurrentLine = dsa

End Function

Attribute VB_Name = "XLScriptGlobalObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_Object As Variant
Public m_Name As String

Attribute VB_Name = "XLScriptSimpleVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Option Explicit

Public m_Value As String
Public m_Txt As String
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptSimpleVar"
  Write #nr, m_Value
  Write #nr, m_Txt
End Sub
Public Sub ReStore(nr As Integer)
  Input #nr, m_Value
  Input #nr, m_Txt
End Sub

Attribute VB_Name = "XLScriptVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Public m_SortName As String
Public Properties As Collection
Public PropertyKeys As Collection
Public m_WasPrinted As Boolean

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptVar"
  Write #nr, m_SortName
  Write #nr, Properties.count
  Dim i As Long
  If Properties.count > 0 Then
    For i = 1 To Properties.count
      Write #nr, PropertyKeys(i), Properties(i)
    Next i
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim i As Long
  Set Properties = New Collection
  For i = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    PropertyKeys.Add sortname, sortname
    tObject.ReStore nr
  Next i
End Sub
Public Sub Init(ByVal n As String)
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  m_SortName = n
End Sub

Function GetScriptVar(n As String) As XLScriptVar
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptVar
    Set tsv = New XLScriptVar
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptVar = Properties(UCase(n))
End Function

Function GetScriptArray(n As String) As XLScriptArray
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptArray
    Set tsv = New XLScriptArray
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptArray = Properties(UCase(n))
End Function

Function ScriptVarExists(n As String) As Boolean
  On Error GoTo doesntExist
  ScriptVarExists = True
  Dim tobj
  Set tobj = Properties(UCase(n))
doesntExist:
  ScriptVarExists = False
End Function

Public Sub AddToValue(propertyName As String, v)
'  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName) + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
End Sub


Attribute VB_Name = "xlFld"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Name As String
Public m_Col As Collection

Public Sub Init(n As String)
  m_Name = n
  Set m_Col = New Collection
End Sub

' InQuest injected base64 decoded content
' DI@C!
' x(^rB 
' z{Uz
' rgLj
'  cND
' -V+"nW
' (^r@&
' jT^}
' tLmz
' tLmz
' ^uj+
' ^uj+
' RyhrG
' RyhrG
' ']zp
' ']zth
' ']zu
' ']zu
' DD4!
' y(^z
' DADDCB
' 9CS4
' 53NDAR
' DADDCB
' DD4!
' L\zT
' DD4!
' $zp^
' zw^R
' W-'+

INQUEST-PP=macro
