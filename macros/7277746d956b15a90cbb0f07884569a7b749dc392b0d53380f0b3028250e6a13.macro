Attribute VB_Name = "AboutDialogHandlers"
' AboutDialog constants
' ---------------------------------------------------
Const AboutDialog_BaseName = "AboutDialog"
Const AboutDialog_TotalControls = 0

' AboutDialog first time initialization
' ---------------------------------------------------
Sub AboutDialog_Init()
Attribute AboutDialog_Init.VB_ProcData.VB_Invoke_Func = " \n14"

    On Error GoTo LErrReturn

    SP_AboutDialog1_Initialize

    Exit Sub
LErrReturn:
    On Error GoTo 0
End Sub

' AboutDialog finish routines
' ---------------------------------------------------
Function AboutDialog_CanFinish() As Boolean
Attribute AboutDialog_CanFinish.VB_ProcData.VB_Invoke_Func = " \n14"
    AboutDialog_CanFinish = True
       
    On Error GoTo LErrReturn
    
    Dim pDialogSheet As DialogSheet
    
    Set pDialogSheet = GetDialogSheet(Trim$(AboutDialog_BaseName) + "1")
    With pDialogSheet
    End With
    
    Exit Function

LErrReturn:
    AboutDialog_CanFinish = False
End Function

Sub AboutDialog_Finish()
Attribute AboutDialog_Finish.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    If (AboutDialog_TotalControls <= 0) Then
        Exit Sub
    End If
    
    Dim sValueArray(AboutDialog_TotalControls) As String
    
    If (AboutDialog_CanFinish() = False) Then
        GoTo LErrReturn
    End If
    
    ' Collect control values into string array
    Dim pDialogSheet As DialogSheet
    
    Set pDialogSheet = GetDialogSheet(Trim$(AboutDialog_BaseName) + "1")
    With pDialogSheet
    End With
    
'    ' Use string array
'    Dim sMsg As String
'    sMsg = "The following values were entered:" + Chr$(13) + Chr$(10)
'    For i = LBound(sValueArray) To UBound(sValueArray)
'        sMsg = sMsg + sValueArray(i) + Chr$(13) + Chr$(10)
'    Next i
'    MsgBox sMsg
           
    Exit Sub

LErrReturn:
End Sub

' AboutDialog1 routines
' ---------------------------------------------------
Sub SP_AboutDialog1_Initialize()
Attribute SP_AboutDialog1_Initialize.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sAddInTitle As String
    sAddInTitle = GetDefineString("Title")
    
    If (Len(sAddInTitle) <= 0) Then
        GoTo LErrReturn
    End If
    Dim sAddInTargetTitle As String
    sAddInTargetTitle = GetDefineString("TargetTitle")
    
    If (Len(sAddInTargetTitle) <= 0) Then
        GoTo LErrReturn
    End If
    
    'Set next dialog to none
    SetNextDialog AboutDialog_BaseName, 0

    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(AboutDialog_BaseName) + "1")
    With pDialogSheet
        .Buttons("OKButton").Enabled = AboutDialog_CanFinish()
    
        .Labels("StaticText1").Text = sAddInTitle + Chr$(13) + Chr$(10) + sAddInTargetTitle + " Wizards which assist you in creating and modifying " + sAddInTargetTitle + " graphs."
        .DialogFrame.Caption = "About " + sAddInTitle
    End With
    
    Exit Sub
LErrReturn:
    On Error GoTo 0
End Sub

Sub SP_AboutDialog1_OKButton_Click()
Attribute SP_AboutDialog1_OKButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog AboutDialog_BaseName, 0
End Sub

Attribute VB_Name = "CreateGraphHandlers"
' CreateGraphDialog constants
' ---------------------------------------------------
Const CreateGraphDialog_BaseName = "CreateGraphDialog"
Const CreateGraphDialog_TotalControls = 5

' Session values
' ---------------------------------------------------
Global CreateGraphDialog_sGraphTypeSelected As Variant, CreateGraphDialog_sPlotTypeSelected As Variant
Global CreateGraphDialog_bShowChooser As Boolean

' CreateGraphDialog first time initialization
' ---------------------------------------------------
Sub CreateGraphDialog_Init()
Attribute CreateGraphDialog_Init.VB_ProcData.VB_Invoke_Func = " \n14"

    On Error GoTo LErrReturn

    SP_CreateGraphDialog1_Initialize
    SP_CreateGraphDialog2_Initialize
    SP_CreateGraphDialog3_Initialize

    Exit Sub
LErrReturn:
    On Error GoTo 0
End Sub

' CreateGraphDialog finish routines
' ---------------------------------------------------
Function CreateGraphDialog_CanFinish() As Boolean
Attribute CreateGraphDialog_CanFinish.VB_ProcData.VB_Invoke_Func = " \n14"
    CreateGraphDialog_CanFinish = True
       
    On Error GoTo LErrReturn
    
    Dim pDialogSheet As DialogSheet
    
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "1")
    With pDialogSheet
        If (Len(Trim$(.EditBoxes("SourceRange").Text)) <= 0) Then
            GoTo LErrReturn
        End If
        If (DoesRangeContainMoreThanOneCell(Trim$(.EditBoxes("SourceRange").Text)) = False) Then
            GoTo LErrReturn
        End If
    End With
    
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "2")
    With pDialogSheet
        Dim sConditioningRange As String
        sConditioningRange = Trim$(.EditBoxes("ConditioningRange").Text)
    End With
    
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "3")
    With pDialogSheet
        If (Len(Trim$(.EditBoxes("TargetRange").Text)) <= 0) Then
            GoTo LErrReturn
        End If
        If (Len(Trim$(.DropDowns("TargetWorksheet").List(.DropDowns("TargetWorksheet").ListIndex))) <= 0) Then
            GoTo LErrReturn
        End If
    End With
    
    If (Len(Trim$(CreateGraphDialog_sGraphTypeSelected)) <= 0 Or _
        Len(Trim$(CreateGraphDialog_sPlotTypeSelected)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Exit Function

LErrReturn:
    CreateGraphDialog_CanFinish = False
End Function

Function CreateGraphDialog_PreFinish() As Boolean
Attribute CreateGraphDialog_PreFinish.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    If (CreateGraphDialog_CanFinish() = False Or _
        CreateGraphDialog_bShowChooser <> False) Then
        ' Get a reference to the application
        Set pSPlusAppReference = CreateObject(GetDefineString("TargetTitle") + ".Application")
        
        Dim vGraphTypeSelected As Variant, vPlotTypeSelected As Variant
        vGraphTypeSelected = CVar("")
        vPlotTypeSelected = CVar("")
        If (Len(Trim$(CreateGraphDialog_sGraphTypeSelected)) > 0) Then
            vGraphTypeSelected = CVar(CreateGraphDialog_sGraphTypeSelected)
        End If
        If (Len(Trim$(CreateGraphDialog_sPlotTypeSelected)) > 0) Then
            vPlotTypeSelected = CVar(CreateGraphDialog_sPlotTypeSelected)
        End If
        
' MODAL APPROACH CAUSES ERROR MESSAGE IN EXCEL97 AFTER ABOUT 90SECS OF DISPLAY OF DIALOG
' AND 100% CPU USAGE ACCORDING TO V.SEU (CRD)
'        ' Get the graph and plot type from the user
'        Dim bChooserSuccess As Boolean
'        bChooserSuccess = pSPlusAppReference.ChooseGraphAndPlotType( _
'            vGraphTypeSelected, _
'            vPlotTypeSelected, _
'            GetExcelHwnd())
'        If (bChooserSuccess = False) Then
'            GoTo LErrReturn
'        Else
'            CreateGraphDialog_sGraphTypeSelected = CStr(vGraphTypeSelected)
'            CreateGraphDialog_sPlotTypeSelected = CStr(vPlotTypeSelected)
'        End If
    
' MODELESS APPROACH IS BETTER SINCE IT CAUSES NO ERROR MESSAGE AFTER 90SECS BUT STILL
' USES 100% CPU DURING DIALOG DISPLAY ACCORDING TO V.SEU (CRD)
        ' Get the graph and plot type from the user
        Dim lDialogHandle As Long
        lDialogHandle = pSPlusAppReference.ChooseGraphAndPlotTypeModeless(vGraphTypeSelected, vPlotTypeSelected, GetExcelHwnd())
        If (lDialogHandle > 0) Then
            Dim hWndDialog As Long
            hWndDialog = pSPlusAppReference.GetHwndForModelessDialog(lDialogHandle)
            Do
                DoEvents
            Loop While IsWindow(hWndDialog) <> 0
        
            Dim bChooserSuccess As Boolean
            bChooserSuccess = pSPlusAppReference.GetSelectedGraphAndPlotType(lDialogHandle, vGraphTypeSelected, vPlotTypeSelected)
            pSPlusAppReference.CloseModelessDialog (lDialogHandle)
        
            If (bChooserSuccess = False) Then
                GoTo LErrReturn
            Else
                CreateGraphDialog_sGraphTypeSelected = CStr(vGraphTypeSelected)
                CreateGraphDialog_sPlotTypeSelected = CStr(vPlotTypeSelected)
            End If
        Else
            GoTo LErrReturn
        End If

    End If
    
    CreateGraphDialog_PreFinish = True
    Exit Function

LErrReturn:
    CreateGraphDialog_PreFinish = False
End Function

Sub CreateGraphDialog_Finish()
Attribute CreateGraphDialog_Finish.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sValueArray(1 To CreateGraphDialog_TotalControls) As String
    
    If (CreateGraphDialog_CanFinish() = False) Then
        GoTo LErrReturn
    End If
    
    ' Collect control values into string array
    Dim pDialogSheet As DialogSheet
    
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "1")
    With pDialogSheet
        sValueArray(1) = Trim$(.EditBoxes("SourceRange").Text)
    End With
    
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "2")
    With pDialogSheet
        sValueArray(4) = Trim$(.EditBoxes("ConditioningRange").Text)
        sValueArray(5) = Trim$(.DropDowns("ConditioningWorksheet").List(.DropDowns("ConditioningWorksheet").ListIndex))
    End With
    
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "3")
    With pDialogSheet
        sValueArray(2) = Trim$(.EditBoxes("TargetRange").Text)
        sValueArray(3) = Trim$(.DropDowns("TargetWorksheet").List(.DropDowns("TargetWorksheet").ListIndex))
    End With
    
    ' Use string array
'    Dim sMsg As String
'    sMsg = "The following values were entered:" + Chr$(13) + Chr$(10)
'    For i = LBound(sValueArray) To UBound(sValueArray)
'        sMsg = sMsg + sValueArray(i) + Chr$(13) + Chr$(10)
'    Next i
'    MsgBox sMsg
    
    ' Set cursor to hour glass
    Dim hCurrentCursor As Long
    hCurrentCursor = SetCursorToWait()
           
    ' Create the S-PLUS plot
    Dim pSourceRange As Range
    Set pSourceRange = ActiveWorkbook.ActiveSheet.Range(sValueArray(1))
    
    Dim pConditioningRange As Range
    If (Len(Trim$(sValueArray(4))) > 0) Then
        On Error GoTo SkipConditioning
        Dim pConditioningSheet As Worksheet
        Set pConditioningSheet = ActiveWorkbook.Sheets(sValueArray(5))
        Set pConditioningRange = pConditioningSheet.Range(sValueArray(4))
SkipConditioning:
        On Error GoTo LErrReturn
    End If
    
    ' Create the plots and the graphs
    CreateSPlusPlot _
        CreateGraphDialog_sGraphTypeSelected, _
        CreateGraphDialog_sPlotTypeSelected, _
        pSourceRange, _
        pConditioningRange, _
        sValueArray(3), _
        sValueArray(2)
    
    ' Restore the cursor
    RestoreCursor hCurrentCursor
           
    Exit Sub

LErrReturn:
End Sub

' CreateGraphDialog1 routines
' ---------------------------------------------------
Sub SP_CreateGraphDialog1_Initialize()
Attribute SP_CreateGraphDialog1_Initialize.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sAddInTargetTitle As String
    sAddInTargetTitle = GetDefineString("TargetTitle")
    
    If (Len(sAddInTargetTitle) <= 0) Then
        GoTo LErrReturn
    End If
    
    ' Reset chooser display flag
    CreateGraphDialog_bShowChooser = False
    
    'Set next dialog to none
    SetNextDialog CreateGraphDialog_BaseName, 0

    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "1")
    With pDialogSheet
        
        ' Initialize the graph type and plot type selected values on first time through wizard only
        If (HasWizardBeenTouched(CreateGraphDialog_BaseName) = False) Then
            CreateGraphDialog_sGraphTypeSelected = ""
            CreateGraphDialog_sPlotTypeSelected = ""
        End If
      
        .EditBoxes("SourceRange").Text = GetCurrentSelectionAsString()
        
        If (ExcelHasFocusBug() = False) Then
            On Error Resume Next
                .Focus = "SourceRange"
            On Error GoTo LErrReturn
        End If
        
        .Buttons("BackButton").Enabled = False
        .Buttons("NextButton").Enabled = DoesRangeContainMoreThanOneCell(Trim$(.EditBoxes("SourceRange").Text))
        .Buttons("FinishButton").Enabled = CreateGraphDialog_CanFinish()
    
        .DialogFrame.Caption = "Create " + sAddInTargetTitle + " Graph - Step 1 of 4 (Data to Graph)"
    End With
    
    Exit Sub
LErrReturn:
    On Error GoTo 0
End Sub

Sub SP_CreateGraphDialog1_SourceRange_Change()
Attribute SP_CreateGraphDialog1_SourceRange_Change.VB_ProcData.VB_Invoke_Func = " \n14"
    SetWizardBeenTouched CreateGraphDialog_BaseName, True
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "1")
    With pDialogSheet
        .Buttons("NextButton").Enabled = DoesRangeContainMoreThanOneCell(Trim$(.EditBoxes("SourceRange").Text))
        .Buttons("FinishButton").Enabled = CreateGraphDialog_CanFinish()
    End With
End Sub

Sub SP_CreateGraphDialog1_NextButton_Click()
Attribute SP_CreateGraphDialog1_NextButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog CreateGraphDialog_BaseName, 2
End Sub

Sub SP_CreateGraphDialog1_FinishButton_Click()
Attribute SP_CreateGraphDialog1_FinishButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    SetNextDialog CreateGraphDialog_BaseName, 0
End Sub

' CreateGraphDialog2 routines
' ---------------------------------------------------
Sub SP_CreateGraphDialog2_Initialize()
Attribute SP_CreateGraphDialog2_Initialize.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sAddInTargetTitle As String
    sAddInTargetTitle = GetDefineString("TargetTitle")
    
    If (Len(sAddInTargetTitle) <= 0) Then
        GoTo LErrReturn
    End If
    
    ' Set next dialog to none
    SetNextDialog CreateGraphDialog_BaseName, 0
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "2")
    With pDialogSheet
        InitializeDropDownWithWorksheetNames .DropDowns("ConditioningWorksheet")
        If (HasWizardBeenTouched(CreateGraphDialog_BaseName) = False) Then
            .EditBoxes("ConditioningRange").Text = ""
        End If
        
        If (ExcelHasFocusBug() = False) Then
            On Error Resume Next
                .Focus = "ConditioningRange"
            On Error GoTo LErrReturn
        End If
        
        .Buttons("BackButton").Enabled = True
        .Buttons("NextButton").Enabled = True
        
        Dim sConditioningRange As String
        sConditioningRange = Trim$(.EditBoxes("ConditioningRange").Text)
        If (Len(sConditioningRange) > 0) Then
            .Buttons("NextButton").Enabled = DoesRangeContainMoreThanOneCell(sConditioningRange)
        End If
        
        .Buttons("FinishButton").Enabled = CreateGraphDialog_CanFinish()
        
        .DialogFrame.Caption = "Create " + sAddInTargetTitle + " Graph - Step 2 of 4 (Conditioning)"
    End With
    
    Exit Sub

LErrReturn:
    On Error GoTo 0
End Sub

Sub SP_CreateGraphDialog2_ConditioningRange_Change()
Attribute SP_CreateGraphDialog2_ConditioningRange_Change.VB_ProcData.VB_Invoke_Func = " \n14"
    SetWizardBeenTouched CreateGraphDialog_BaseName, True
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "2")
    With pDialogSheet
        .Buttons("NextButton").Enabled = True
        
        Dim sConditioningRange As String
        sConditioningRange = Trim$(.EditBoxes("ConditioningRange").Text)
        If (Len(sConditioningRange) > 0) Then
            .Buttons("NextButton").Enabled = DoesRangeContainMoreThanOneCell(sConditioningRange)
        End If
        
        .Buttons("FinishButton").Enabled = CreateGraphDialog_CanFinish()
    End With
End Sub

Sub SP_CreateGraphDialog2_BackButton_Click()
Attribute SP_CreateGraphDialog2_BackButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog CreateGraphDialog_BaseName, 1
End Sub

Sub SP_CreateGraphDialog2_NextButton_Click()
Attribute SP_CreateGraphDialog2_NextButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog CreateGraphDialog_BaseName, 3
End Sub

Sub SP_CreateGraphDialog2_FinishButton_Click()
Attribute SP_CreateGraphDialog2_FinishButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    SetNextDialog CreateGraphDialog_BaseName, 0
End Sub

' CreateGraphDialog3 routines
' ---------------------------------------------------
Sub SP_CreateGraphDialog3_Initialize()
Attribute SP_CreateGraphDialog3_Initialize.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sAddInTargetTitle As String
    sAddInTargetTitle = GetDefineString("TargetTitle")
    
    If (Len(sAddInTargetTitle) <= 0) Then
        GoTo LErrReturn
    End If
    
    ' Set next dialog to none
    SetNextDialog CreateGraphDialog_BaseName, 0
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "3")
    With pDialogSheet
        InitializeDropDownWithWorksheetNames .DropDowns("TargetWorksheet")
        
        If (HasWizardBeenTouched(CreateGraphDialog_BaseName) = False) Then
            .EditBoxes("TargetRange").Text = GetActiveWorksheetTopLeftAsString()
        End If
        
        If (ExcelHasFocusBug() = False) Then
            On Error Resume Next
                .Focus = "TargetRange"
            On Error GoTo LErrReturn
        End If

        .Buttons("BackButton").Enabled = True
        
        .Buttons("NextButton").Enabled = False
        Dim sTargetRange As String
        Dim sTargetWorksheet As String
        sTargetRange = Trim$(.EditBoxes("TargetRange").Text)
        sTargetWorksheet = Trim$(.DropDowns("TargetWorksheet").List(.DropDowns("TargetWorksheet").ListIndex))
        .Buttons("NextButton").Enabled = IsValidRange(sTargetRange, sTargetWorksheet)
        
        .Buttons("FinishButton").Enabled = CreateGraphDialog_CanFinish()
    
        .DialogFrame.Caption = "Create " + sAddInTargetTitle + " Graph - Step 3 of 4"
    End With
    
    Exit Sub
LErrReturn:
    On Error GoTo 0
End Sub

Sub SP_CreateGraphDialog3_TargetRange_Change()
Attribute SP_CreateGraphDialog3_TargetRange_Change.VB_ProcData.VB_Invoke_Func = " \n14"
    SetWizardBeenTouched CreateGraphDialog_BaseName, True
        
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "3")
    With pDialogSheet
        .Buttons("NextButton").Enabled = False
        Dim sTargetRange As String
        Dim sTargetWorksheet As String
        sTargetRange = Trim$(.EditBoxes("TargetRange").Text)
        sTargetWorksheet = Trim$(.DropDowns("TargetWorksheet").List(.DropDowns("TargetWorksheet").ListIndex))
        .Buttons("NextButton").Enabled = IsValidRange(sTargetRange, sTargetWorksheet)
        
        .Buttons("FinishButton").Enabled = CreateGraphDialog_CanFinish()
    End With
End Sub

Sub SP_CreateGraphDialog3_TargetWorksheet_Change()
Attribute SP_CreateGraphDialog3_TargetWorksheet_Change.VB_ProcData.VB_Invoke_Func = " \n14"
    SetWizardBeenTouched CreateGraphDialog_BaseName, True
        
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(CreateGraphDialog_BaseName) + "3")
    With pDialogSheet
        .Buttons("FinishButton").Enabled = CreateGraphDialog_CanFinish()
    End With
End Sub

Sub SP_CreateGraphDialog3_BackButton_Click()
Attribute SP_CreateGraphDialog3_BackButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog CreateGraphDialog_BaseName, 2
End Sub

Sub SP_CreateGraphDialog3_NextButton_Click()
Attribute SP_CreateGraphDialog3_NextButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog CreateGraphDialog_BaseName, 0
    
    ' Set flag indicating user wants to see graph and plot type chooser dialog
    CreateGraphDialog_bShowChooser = True
End Sub

Sub SP_CreateGraphDialog3_FinishButton_Click()
Attribute SP_CreateGraphDialog3_FinishButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog CreateGraphDialog_BaseName, 0
End Sub


Attribute VB_Name = "ModifyPlotHandlers"
' ModifyPlotDialog constants
' ---------------------------------------------------
Const ModifyPlotDialog_BaseName = "ModifyPlotDialog"
Const ModifyPlotDialog_TotalControls = 2

' ModifyPlotDialog first time initialization
' ---------------------------------------------------
Sub ModifyPlotDialog_Init()
Attribute ModifyPlotDialog_Init.VB_ProcData.VB_Invoke_Func = " \n14"
    
    On Error GoTo LErrReturn
    
    SP_ModifyPlotDialog1_Initialize
    
    Exit Sub
LErrReturn:
    On Error GoTo 0
End Sub

' ModifyPlotDialog finish routines
' ---------------------------------------------------
Function ModifyPlotDialog_CanFinish() As Boolean
Attribute ModifyPlotDialog_CanFinish.VB_ProcData.VB_Invoke_Func = " \n14"
    ModifyPlotDialog_CanFinish = True
       
    On Error GoTo LErrReturn
    
    Dim pDialogSheet As DialogSheet
    
    Set pDialogSheet = GetDialogSheet(Trim$(ModifyPlotDialog_BaseName) + "1")
    With pDialogSheet
        If (Len(Trim$(.ListBoxes("GraphToEdit").List(.ListBoxes("GraphToEdit").ListIndex))) <= 0) Then
            GoTo LErrReturn
        End If
        If (Len(Trim$(.ListBoxes("PlotToEdit").List(.ListBoxes("PlotToEdit").ListIndex))) <= 0) Then
            GoTo LErrReturn
        End If
    End With
    
    Exit Function

LErrReturn:
    ModifyPlotDialog_CanFinish = False
End Function

Sub ModifyPlotDialog_Finish()
Attribute ModifyPlotDialog_Finish.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sValueArray(1 To ModifyPlotDialog_TotalControls) As String
    
    If (ModifyPlotDialog_CanFinish() = False) Then
        GoTo LErrReturn
    End If
    
    ' Collect control values into string array
    Dim pDialogSheet As DialogSheet
    
    Set pDialogSheet = GetDialogSheet(Trim$(ModifyPlotDialog_BaseName) + "1")
    With pDialogSheet
        sValueArray(1) = Trim$(.ListBoxes("GraphToEdit").List(.ListBoxes("GraphToEdit").ListIndex))
        sValueArray(2) = Trim$(.ListBoxes("PlotToEdit").List(.ListBoxes("PlotToEdit").ListIndex))
    End With
    
'    ' Use string array
'    Dim sMsg As String
'    sMsg = "The following values were entered:" + Chr$(13) + Chr$(10)
'    For i = LBound(sValueArray) To UBound(sValueArray)
'        sMsg = sMsg + sValueArray(i) + Chr$(13) + Chr$(10)
'    Next i
'    MsgBox sMsg
    
    ' Set cursor to hour glass
    Dim hCurrentCursor As Long
    hCurrentCursor = SetCursorToWait()
           
    ' Get the plot selected for editing and bring up its dialog
    Dim sPlotClassSelected As String, sPlotPathNameSelected As String
    If (GetClassAndPathNameFromString(sPlotClassSelected, sPlotPathNameSelected, sValueArray(2)) = True) Then
        On Error GoTo SkipEdit
            Dim pGraphSheet As Object
            Set pGraphSheet = GetSelectedSPLUSGraphSheet()
            Dim pPlot As Object
            Set pPlot = pGraphSheet.GetObject(sPlotClassSelected, sPlotPathNameSelected)
            
            Dim bSuccess As Boolean
            bSuccess = pPlot.ShowDialogInParentModeless(GetExcelHwnd())
SkipEdit:
        On Error GoTo LErrReturn
    End If
    
    ' Restore the cursor
    RestoreCursor hCurrentCursor
           
    Exit Sub

LErrReturn:
End Sub

' ModifyPlotDialog1 routines
' ---------------------------------------------------
Sub ModifyPlotDialog1_InitPlotFromGraph()
Attribute ModifyPlotDialog1_InitPlotFromGraph.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn

    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(ModifyPlotDialog_BaseName) + "1")
    With pDialogSheet
        Dim sGraphSelected As String
        sGraphSelected = .ListBoxes("GraphToEdit").List(.ListBoxes("GraphToEdit").ListIndex)
        
        Dim sGraphClassSelected As String, sGraphPathNameSelected As String
        If (GetClassAndPathNameFromString(sGraphClassSelected, sGraphPathNameSelected, sGraphSelected) = False) Then
            GoTo LErrReturn
        End If

        Dim pApp As Object
        Set pApp = CreateObject(GetDefineString("TargetTitle") + ".Application")
        
        Dim pGraph As Object
        Set pGraph = pApp.GetObject(sGraphClassSelected, sGraphPathNameSelected)
        
        InitializeListBoxWithPlotsForGraph pGraph, .ListBoxes("PlotToEdit")
    End With
    
    Exit Sub

LErrReturn:
    On Error GoTo 0
End Sub

Sub SP_ModifyPlotDialog1_Initialize()
Attribute SP_ModifyPlotDialog1_Initialize.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sAddInTargetTitle As String
    sAddInTargetTitle = GetDefineString("TargetTitle")
    
    If (Len(sAddInTargetTitle) <= 0) Then
        GoTo LErrReturn
    End If
    
    'Set next dialog to none
    SetNextDialog ModifyPlotDialog_BaseName, 0

    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(ModifyPlotDialog_BaseName) + "1")
    With pDialogSheet
        Dim pGraphSheet As Object
        Set pGraphSheet = GetSelectedSPLUSGraphSheet()
        InitializeListBoxWithGraphsForSheet pGraphSheet, .ListBoxes("GraphToEdit")
        ModifyPlotDialog1_InitPlotFromGraph
        
        .Buttons("BackButton").Enabled = False
        .Buttons("NextButton").Enabled = ModifyPlotDialog_CanFinish()
        .Buttons("FinishButton").Enabled = False
    
        .DialogFrame.Caption = "Modify " + sAddInTargetTitle + " Plots - Step 1 of 2"
    End With
    
    Exit Sub
LErrReturn:
    On Error GoTo 0
End Sub

Sub SP_ModifyPlotDialog1_NextButton_Click()
Attribute SP_ModifyPlotDialog1_NextButton_Click.VB_ProcData.VB_Invoke_Func = " \n14"
    ' Set next dialog index
    SetNextDialog ModifyPlotDialog_BaseName, 0
End Sub

Attribute VB_Name = "OLESupport"
' ----------------------------------------------------------------------------------
' Main routine to create an S-PLUS plot
' ----------------------------------------------------------------------------------

Sub CreateSPlusPlot(ByVal sGraphType As String, ByVal sPlotType As String, pSourceRange As Range, pConditioningRange As Range, TargetSheet As String, sTargetCell As String)
Attribute CreateSPlusPlot.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    If (Len(Trim$(sGraphType)) <= 0 Or Len(Trim$(sPlotType)) <= 0) Then
        GoTo LErrReturn
    End If
    
    ' Variants representing arrays of data column names and conditioning column names
    Dim vDataNames As Variant, vConditioningNames As Variant
    vDataNames = Empty
    vConditioningNames = Empty
    
    ' Get a reference to the application
    Set pSPlusAppReference = CreateObject(GetDefineString("TargetTitle") + ".Application")

If (IsDefined("_DEBUG") = True) Then
    ClearSPLUSHistoryLog
End If

    ' Redirect any output during graphing process to this client
    RedirectSPlusOutput GetExcelHwnd()
    
    ' Insert an embedded S-PLUS graphsheet in worksheet
    Dim pGraphSheetItem As OLEObject
    Set pGraphSheetItem = InsertSPLUSGraphSheet(TargetSheet, sTargetCell)
    
    ' Convert source range to data array
    Dim pDataValues As Variant
    ConvertRangeToNameAndDataArray pDataValues, vDataNames, pSourceRange

    ' Convert conditioning source range to data array
    Dim pConditioningValues As Variant
    pConditioningValues = Empty
    Dim nConditioningValues As Integer
    nConditioningValues = 0
    On Error GoTo SkipConditioningValues
    ConvertRangeToNameAndDataArray pConditioningValues, vConditioningNames, pConditioningRange
SkipConditioningValues:

    Dim pGraphSheet As Object
    Set pGraphSheet = pGraphSheetItem.Object
    Dim bSuccess As Boolean
    bSuccess = pGraphSheet.CreateConditionedPlotsSeparateData( _
        sGraphType, _
        sPlotType, _
        pDataValues, _
        pConditioningValues, _
        vDataNames, _
        vConditioningNames)
    If (bSuccess <> True) Then
        pGraphSheetItem.Delete
        GoTo LErrReturn
    End If

    'Reset output redirection
    RedirectSPlusOutput 0
    
    Exit Sub
    
LErrReturn:
    'Reset output redirection
    RedirectSPlusOutput 0
    
    MsgBox "Error occurred while creating graph."
End Sub

Function InsertSPLUSGraphSheet(sSheetName As String, sInsertAtCell As String) As OLEObject
Attribute InsertSPLUSGraphSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim pTargetSheet As Worksheet, pCurrentSheet As Worksheet
    Set pCurrentSheet = ActiveWorkbook.ActiveSheet
    
    On Error GoTo LBadSheetName
        Set pTargetSheet = ActiveWorkbook.Sheets(sSheetName)
    On Error GoTo LErrReturn
    
    With pTargetSheet
        .Activate
        
        On Error GoTo LBadInsertAtCell
            .Range(sInsertAtCell).Select
        On Error GoTo LErrReturn
        
        Dim pOleObject As OLEObject
        Set pOleObject = .OLEObjects.Add( _
            ClassType:=GetDefineString("TargetFileType"), Link:=False, DisplayAsIcon:=False)
        
        Set InsertSPLUSGraphSheet = pOleObject
    End With
    
    pCurrentSheet.Activate
    Exit Function

LErrReturn:
    Set InsertSPLUSGraphSheet = Nothing
    Exit Function
LBadSheetName:
    Set pTargetSheet = pCurrentSheet
    Resume Next
LBadInsertAtCell:
    pTargetSheet.Cells(1, 1).Select
    Resume Next
End Function

Function GetSelectedSPLUSGraphSheet() As Object
Attribute GetSelectedSPLUSGraphSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    ' Get a reference to the application
    Static pSPlusAppReference As Object
    Set pSPlusAppReference = CreateObject(GetDefineString("TargetTitle") + ".Application")
    
    Dim sSelectionType As String
    sSelectionType = TypeName(Selection)
    
    Dim pOleObject As OLEObject
    Set pOleObject = Selection
    
    If UCase$(Trim$(sSelectionType)) = "OLEOBJECT" Then
        On Error GoTo ActivateInServer
            Set GetSelectedSPLUSGraphSheet = pOleObject.Object
        On Error GoTo LErrReturn
    
        Dim sOLETypeName As String
        sOLETypeName = pOleObject.Object.OLETypeName
        If (sOLETypeName <> GetDefineString("TargetFileType")) Then
            GoTo LErrReturn
        End If
    End If

    Exit Function

ActivateInServer:
    On Error GoTo LErrReturn
        pOleObject.Activate
        ActiveSheet.Range("A1").Select
        pOleObject.Select
        Set GetSelectedSPLUSGraphSheet = pOleObject.Object
        Resume

LErrReturn:
    Set GetSelectedSPLUSGraphSheet = Nothing
End Function

Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "SheetUtilities"
Function GetCurrentSelectionAsString() As String
Attribute GetCurrentSelectionAsString.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sSelectedRange As String
    Dim pSelectedRange As Range
    Set pSelectedRange = Selection
    
    sSelectedRange = pSelectedRange.Address()
    GetCurrentSelectionAsString = sSelectedRange
    
    Exit Function

LErrReturn:
    GetCurrentSelectionAsString = ""
End Function

Function GetCurrentSelectionAsRange() As Range
Attribute GetCurrentSelectionAsRange.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim pSelectedRange As Range
    Set pSelectedRange = Selection
    
    Set GetCurrentSelectionAsRange = pSelectedRange
End Function

Function GetActiveWorksheetTopLeftAsString() As String
Attribute GetActiveWorksheetTopLeftAsString.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sTopLeft As String
    Dim pTopLeft As Range
    Set pTopLeft = ActiveSheet.Cells(1, 1)
   
    sTopLeft = pTopLeft.Address()
    GetActiveWorksheetTopLeftAsString = sTopLeft
    
    Exit Function

LErrReturn:
    GetActiveWorksheetTopLeftAsString = ""
End Function

Function GetWorksheetCount() As Integer
Attribute GetWorksheetCount.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim pSheet As Object
    Dim nCount As Integer
    Dim sWorksheetName As String
    
    nCount = 0
    For Each pSheet In ActiveWorkbook.Worksheets
        sWorksheetName = Trim$(pSheet.Name)
        If (Len(sWorksheetName) > 0) Then
            nCount = nCount + 1
        End If
    Next pSheet

    GetWorksheetCount = nCount
End Function

Function GetWorksheetNames(sArrayWorksheetNames() As String) As Integer
Attribute GetWorksheetNames.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim pSheet As Object
    Dim nCount As Integer
    Dim sWorksheetName As String
    
    On Error GoTo LErrReturn
    
    nCount = GetWorksheetCount()
    
    If (nCount <= 0) Then
        GoTo LErrReturn
    End If
    
    ReDim sArrayWorksheetNames(1 To nCount)
    
    Dim i As Integer
    i = 0
    For Each pSheet In ActiveWorkbook.Worksheets
        sWorksheetName = Trim$(pSheet.Name)
        If (Len(sWorksheetName) > 0) Then
            sArrayWorksheetNames(i + LBound(sArrayWorksheetNames)) = sWorksheetName
            i = i + 1
        End If
    Next pSheet
    
    GetWorksheetNames = nCount
    Exit Function

LErrReturn:
    GetWorksheetNames = -1
    On Error GoTo 0
End Function

Function GetCurrentWorksheetName() As String
Attribute GetCurrentWorksheetName.VB_ProcData.VB_Invoke_Func = " \n14"
    GetCurrentWorksheetName = ActiveSheet.Name
End Function

Sub ConvertSheetRangeToArray(pArray As Variant, ByRef rangeToConvert As Range)
Attribute ConvertSheetRangeToArray.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim nRangeAreaCount As Long
    nRangeAreaCount = rangeToConvert.Areas.Count
    
    Dim maxCols As Long, maxRows As Long
    maxCols = 0
    maxRows = 0
    For i = 1 To nRangeAreaCount
        Dim bGotRowCount As Boolean
        bGotRowCount = False
        On Error GoTo LSkipRowCount
            Dim nRowCount As Long
            nRowCount = rangeToConvert.Areas(i).Rows.Count
            bGotRowCount = True
            If (nRowCount > maxRows) Then
                maxRows = nRowCount
            End If
LSkipRowCount:
        On Error GoTo 0
        
        Dim nColsInArea As Long
        nColsInArea = rangeToConvert.Areas(i).Columns.Count
        
        If (bGotRowCount = False) Then
            For z = 1 To nColsInArea
                Dim nLength As Integer
                nLength = 0
                For Each cell In rangeToConvert.Areas(i).Columns(z).Cells
                    If Len(cell.Value) > 0 Then
                        nLength = nLength + 1
                    Else
                        Exit For
                    End If
                Next cell
                If (nLength > maxRows) Then
                    maxRows = nLength
                End If
            Next z
        End If
        maxCols = maxCols + nColsInArea
    Next i
    
    Application.DisplayAlerts = False
    On Error Resume Next
        ThisWorkbook.Worksheets("TempWorkSheet").Delete
    On Error GoTo 0
    Application.DisplayAlerts = True

    Dim pWorksheet As Worksheet
    Set pWorksheet = ThisWorkbook.Sheets.Add
    pWorksheet.Name = "TempWorkSheet"
    
    Dim nextTargetCol As Long
    nextTargetCol = 1
    For i = 1 To nRangeAreaCount
        Dim pSubRange As Range
        Set pSubRange = rangeToConvert.Areas(i)
        
        Dim colsInArea As Long
        colsInArea = pSubRange.Columns.Count
        
        Dim sTargetRange As String
        sTargetRange = Chr(Asc(UCase$("A")) + (Trim(Str(nextTargetCol)) - 1)) + "1"

'        pSubRange.Copy destination:=pWorksheet.Range(sTargetRange)
        pSubRange.Copy
        pWorksheet.Range(sTargetRange).PasteSpecial Paste:=xlValues, Operation:=xlNone
        
        nextTargetCol = nextTargetCol + colsInArea
    Next i
    
    Dim pCopyRange As Range
    Dim sCopyRange As String
    sCopyRange = Trim("A") + Trim(Str(1)) + ":" + _
        Chr(Asc(UCase$("A")) + (Trim(Str(maxCols)) - 1)) + Trim(Str(maxRows))
    Set pCopyRange = pWorksheet.Range(sCopyRange)

    pArray = pCopyRange.Value
    
    Application.DisplayAlerts = False
    On Error Resume Next
        ThisWorkbook.Worksheets("TempWorkSheet").Delete
    On Error GoTo 0
    Application.DisplayAlerts = True
End Sub

Sub ConvertRangeToNameAndDataArray(pDataArray As Variant, pNamesArray As Variant, ByRef rangeToConvert As Range)
Attribute ConvertRangeToNameAndDataArray.VB_ProcData.VB_Invoke_Func = " \n14"
    pDataArray = Empty
    pNamesArray = Empty

    On Error GoTo LErrReturn

    Dim nRangeAreaCount As Long
    nRangeAreaCount = rangeToConvert.Areas.Count
    Dim maxCols As Long, maxRows As Long
    maxCols = 0
    maxRows = 0
    For i = 1 To nRangeAreaCount
        Dim bGotRowCount As Boolean
        bGotRowCount = False
        On Error GoTo LSkipRowCount
            Dim nRowCount As Long
            nRowCount = rangeToConvert.Areas(i).Rows.Count
            bGotRowCount = True
            If (nRowCount > maxRows) Then
                maxRows = nRowCount
            End If
LSkipRowCount:
        On Error GoTo LErrReturn
        
        Dim nColsInArea As Long
        nColsInArea = rangeToConvert.Areas(i).Columns.Count
        
        If (bGotRowCount = False) Then
            For z = 1 To nColsInArea
                Dim nLength As Long
                nLength = 0
                For Each cell In rangeToConvert.Areas(i).Columns(z).Cells
                    If Len(cell.Value) > 0 Then
                        nLength = nLength + 1
                    Else
                        Exit For
                    End If
                Next cell
                If (nLength > maxRows) Then
                    maxRows = nLength
                End If
            Next z
        End If
        maxCols = maxCols + nColsInArea
    Next i
    
    Application.DisplayAlerts = False
    On Error Resume Next
        ThisWorkbook.Worksheets("TempWorkSheet").Delete
    On Error GoTo LErrReturn
    Application.DisplayAlerts = True

    Dim pWorksheet As Worksheet
    Set pWorksheet = ThisWorkbook.Sheets.Add
    pWorksheet.Name = "TempWorkSheet"
    
    Dim nextTargetCol As Long
    nextTargetCol = 1
    For i = 1 To nRangeAreaCount
        Dim pSubRange As Range
        Set pSubRange = rangeToConvert.Areas(i)
        Dim colsInArea As Long
        colsInArea = pSubRange.Columns.Count
        
        Dim sTargetRange As String
        sTargetRange = Chr(Asc(UCase$("A")) + (Trim(Str(nextTargetCol)) - 1)) + "1"

'        pSubRange.Copy destination:=pWorksheet.Range(sTargetRange)
        pSubRange.Copy
        pWorksheet.Range(sTargetRange).PasteSpecial Paste:=xlValues, Operation:=xlNone
        
        nextTargetCol = nextTargetCol + colsInArea
    Next i
    
    Dim pCopyRange As Range
    Dim sCopyRange As String
    sCopyRange = Trim("A") + Trim(Str(1)) + ":" + _
        Chr(Asc(UCase$("A")) + (Trim(Str(maxCols)) - 1)) + Trim(Str(maxRows))
    Set pCopyRange = pWorksheet.Range(sCopyRange)

    Dim pNameRowRange As Range
    Set pNameRowRange = pCopyRange.Rows(1)
    Dim vIsTextArray As Variant
    vIsTextArray = Application.IsText(pNameRowRange)
    Dim bIsFirstRowText As Boolean
    If (IsArray(vIsTextArray)) Then
        bIsFirstRowText = Not Application.IsError(Application.Match(True, vIsTextArray, 0))
    Else
        bIsFirstRowText = vIsTextArray
    End If
    If (bIsFirstRowText) Then
        pNamesArray = pNameRowRange.Value
        
        Dim pDataRange As Range
        Set pDataRange = Intersect(pCopyRange, pCopyRange.Offset(1))
        pDataArray = pDataRange.Value
    Else
        pDataArray = pCopyRange.Value
    End If
    
    Application.DisplayAlerts = False
    On Error Resume Next
        ThisWorkbook.Worksheets("TempWorkSheet").Delete
    On Error GoTo LErrReturn
    Application.DisplayAlerts = True
    
    Exit Sub
LErrReturn:
End Sub

Sub ShowArrayInDialog(pArray As Variant)
Attribute ShowArrayInDialog.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim sMsg As String
    sMsg = ""
    
    If (IsArray(pArray)) Then
        Dim lBound1 As Integer, lBound2 As Integer
        Dim uBound1 As Integer, uBound2 As Integer
    
        lBound1 = LBound(pArray, 1)
        lBound2 = LBound(pArray, 2)
        uBound1 = UBound(pArray, 1)
        uBound2 = UBound(pArray, 2)
    
        For i = lBound1 To uBound1
            For j = lBound2 To uBound2
                sMsg = sMsg + CStr(pArray(i, j))
                If j < uBound2 Then
                    sMsg = sMsg + ", "
                End If
            Next j
            sMsg = sMsg + Chr$(13) + Chr$(10)
        Next i
    Else
        sMsg = CStr(pArray)
    End If
    MsgBox sMsg
End Sub

Function FindStringInArray(sArray() As String, sStringToFind As String) As Integer
Attribute FindStringInArray.VB_ProcData.VB_Invoke_Func = " \n14"
    FindStringInArray = -1
    
    On Error GoTo LErrReturn
    
    If (Len(Trim$(sStringToFind)) <= 0) Then
        GoTo LErrReturn
        Exit Function
    End If
    
    Dim nUpperBound As Integer, nLowerBound As Integer, nElements As Integer
    nUpperBound = UBound(sArray)
    nLowerBound = LBound(sArray)
    nElements = nUpperBound - nLowerBound + 1
    If (nElements <= 0) Then
        GoTo LErrReturn
        Exit Function
    End If
    
    Dim i As Integer
    For i = nLowerBound To nUpperBound
        Dim sStringFound As String
        sStringFound = sArray(i)
        If (Trim$(UCase$(sStringToFind)) = Trim$(UCase$(sStringFound))) Then
            Exit For
        End If
    Next i
    
    If (i <= nUpperBound) Then
        FindStringInArray = i
    End If
    Exit Function
    
LErrReturn:
    FindStringInArray = -1
    On Error GoTo 0
End Function

Function LengthOfColumn(sSheetName As String, sColumnName As String)
Attribute LengthOfColumn.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    If (Len(Trim$(sSheetName)) <= 0) Then
        GoTo LErrReturn
    End If
    If (Len(Trim$(sColumnName)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim nLength As Integer
    nLength = 0
    For Each cell In ThisWorkbook.Worksheets(sSheetName).Columns(sColumnName).Cells
        If Len(cell.Value) > 0 Then
            nLength = nLength + 1
        Else
            Exit For
        End If
    Next cell
    LengthOfColumn = nLength
    
    Exit Function
    
LErrReturn:
    LengthOfColumn = -1
End Function

Function FindStringInColumn(sStringToFind As String, sSheetName As String, sColumnName As String) As Range
Attribute FindStringInColumn.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim foundCell As Range
    Set foundCell = ThisWorkbook.Worksheets(sSheetName).Columns(sColumnName).Find(sStringToFind, lookAt:=xlWhole)
    
    Dim firstFoundCell As Range
    If (foundCell Is Nothing) Then
    Else
        Set firstFoundCell = foundCell
    End If
    
    Do While Not (foundCell Is Nothing)
        If (UCase$(Trim$(CStr(foundCell.Value))) = UCase$(Trim$(sStringToFind))) Then
            Exit Do
        End If
        Set foundCell = ThisWorkbook.Worksheets(sSheetName).Columns(sColumnName).FindNext(after:=foundCell)
        
        If (foundCell = firstFoundCell) Then
            Exit Do
        End If
    Loop

    If foundCell Is Nothing Then
        GoTo LErrReturn
    End If
    Set FindStringInColumn = foundCell
    Exit Function
LErrReturn:
    Set FindStringInColumn = Nothing
End Function

Sub ShowDataRangeInDialog(pRange As Range, sMessage As String)
Attribute ShowDataRangeInDialog.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sMsg As String
    sMsg = sMessage + Chr$(13) + Chr$(10) + Chr$(13) + Chr$(10)
    
    Dim nCols As Integer, nRows As Integer
    nCols = pRange.Columns.Count
    nRows = pRange.Rows.Count
    For i = 1 To nRows
        For j = 1 To nCols
            sMsg = sMsg + CStr(pRange.Cells(i, j).Value)
            If (j <> nCols) Then
                sMsg = sMsg + ", "
            End If
        Next j
        sMsg = sMsg + Chr$(13) + Chr$(10)
    Next i
    
    MsgBox sMsg, vbOKOnly, "ShowDataRangeInDialog"
    
    Exit Sub
LErrReturn:
End Sub

Function DoesRangeContainMoreThanOneCell(sRange As String)
Attribute DoesRangeContainMoreThanOneCell.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    If (Len(Trim$(sRange)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim pRange As Range
    Set pRange = ActiveWorkbook.ActiveSheet.Range(sRange)
    
    Dim nCols As Integer, nRows As Integer
    nCols = 0
    nRows = 0
    On Error GoTo LSkipCols
        nCols = pRange.Columns.Count
LSkipCols:
    On Error GoTo LSkipRows
        nRows = pRange.Rows.Count
LSkipRows:
    On Error GoTo LErrReturn
    
    If (nCols > 1 Or nRows > 1) Then
        DoesRangeContainMoreThanOneCell = True
    End If
    
    Exit Function
LErrReturn:
    DoesRangeContainMoreThanOneCell = False
End Function

Function IsValidRange(sRange As String, sWorksheet As String)
Attribute IsValidRange.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    If (Len(Trim$(sRange)) <= 0) Then
        GoTo LErrReturn
    End If
    If (Len(Trim$(sWorksheet)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim pSheet As Worksheet
    Set pSheet = ActiveWorkbook.Worksheets(sWorksheet)
    Dim pRange As Range
    Set pRange = pSheet.Range(sRange)
    
    Dim nCols As Integer, nRows As Integer
    nCols = pRange.Columns.Count
    nRows = pRange.Rows.Count
    
    If (nCols >= 1 Or nRows >= 1) Then
        IsValidRange = True
    End If
    
    Exit Function
LErrReturn:
    IsValidRange = False
End Function

Function IsDefined(sDefineLabel As String) As Boolean
Attribute IsDefined.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    IsDefined = False
    
    Dim pRange As Range
    Set pRange = FindStringInColumn(sDefineLabel, "Defines", "A")
    
    Dim sRange As String
    sRange = Trim$(pRange.Address())
    If (Len(sRange) > 0) Then
        IsDefined = True
    End If
    
    Exit Function
LErrReturn:
    IsDefined = False
End Function

Function GetDefineString(sDefineLabel As String) As String
Attribute GetDefineString.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    GetDefineString = ""
    
    Dim pRange As Range
    Set pRange = FindStringInColumn(sDefineLabel, "Defines", "D")
    
    GetDefineString = Trim$(CStr(pRange.Offset(0, 1).Value))
    Exit Function
LErrReturn:
End Function
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "WizardHandlers"
' Session values
' ---------------------------------------------------
Global pSPlusAppReference As Object

Sub SP_ShowCreateGraphWizard()
Attribute SP_ShowCreateGraphWizard.VB_ProcData.VB_Invoke_Func = " \n14"
    Const sDialogBaseName = "CreateGraphDialog"

    Dim bIsInplace As Boolean
    bIsInplace = False
    On Error GoTo LSkipInplaceDetect
    If (StrComp(ActiveWorkbook.IsInPlace, "True", 1) = 0) Then
        bIsInplace = True
    End If
LSkipInplaceDetect:
    If (bIsInplace) Then
        MsgBox "The " + GetDefineString("TargetTitle") + " add-in is not available when editing a workbook in-place in another program."
        Exit Sub
    End If
    
' NEW STUFF (CRD)
    Set pSPlusAppReference = CreateObject(GetDefineString("TargetTitle") + ".Application")
    Dim sEdition As String
    sEdition = pSPlusAppReference.Edition
    If (Trim$(LCase$(sEdition)) = "student") Then
        MsgBox "This feature does not function with S-PLUS Student edition."
        GoTo LErrReturn
    End If

    On Error GoTo LErrReturn
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(sDialogBaseName) + "1")
    
    Dim bOK As Boolean
    bOK = pDialogSheet.Show

    Do
        On Error GoTo StopDialogCycle
        Set pDialogSheet = GetNextDialog(sDialogBaseName)
        bOK = pDialogSheet.Show
    Loop While (1 = 1)

StopDialogCycle:
    If (bOK) Then
        If (CreateGraphDialog_PreFinish() <> False) Then
            CreateGraphDialog_Finish
        End If
    End If
    Exit Sub

LErrReturn:
End Sub

Sub SP_ShowModifyGraphLayoutDialog()
Attribute SP_ShowModifyGraphLayoutDialog.VB_ProcData.VB_Invoke_Func = " \n14"
    
    Dim bIsInplace As Boolean
    bIsInplace = False
    On Error GoTo LSkipInplaceDetect
    If (StrComp(ActiveWorkbook.IsInPlace, "True", 1) = 0) Then
        bIsInplace = True
    End If
LSkipInplaceDetect:
    If (bIsInplace) Then
        MsgBox "The " + GetDefineString("TargetTitle") + " add-in is not available when editing a workbook in-place in another program."
        Exit Sub
    End If
    
' NEW STUFF (CRD)
    Set pSPlusAppReference = CreateObject(GetDefineString("TargetTitle") + ".Application")
    Dim sEdition As String
    sEdition = pSPlusAppReference.Edition
    If (Trim$(LCase$(sEdition)) = "student") Then
        MsgBox "This feature does not function with S-PLUS Student edition."
        GoTo LErrReturn
    End If

    On Error GoTo LErrReturn
    
    Dim pGraphSheet As Object
    Set pGraphSheet = GetSelectedSPLUSGraphSheet()

    Dim bSuccess As Boolean
    bSuccess = pGraphSheet.ShowDialogInParentModeless(GetExcelHwnd())
    
    Exit Sub

LErrReturn:
    MsgBox "Failed to display the graph layout dialog for the selected graph. This might be caused by selecting a graph that was not created by " + GetDefineString("TargetTitle")
End Sub

Sub SP_ShowModifyPlotDialog()
Attribute SP_ShowModifyPlotDialog.VB_ProcData.VB_Invoke_Func = " \n14"
    Const sDialogBaseName = "ModifyPlotDialog"
    
    Dim bIsInplace As Boolean
    bIsInplace = False
    On Error GoTo LSkipInplaceDetect
    If (StrComp(ActiveWorkbook.IsInPlace, "True", 1) = 0) Then
        bIsInplace = True
    End If
LSkipInplaceDetect:
    If (bIsInplace) Then
        MsgBox "The " + GetDefineString("TargetTitle") + " add-in is not available when editing a workbook in-place in another program."
        Exit Sub
    End If
    
' NEW STUFF (CRD)
    Set pSPlusAppReference = CreateObject(GetDefineString("TargetTitle") + ".Application")
    Dim sEdition As String
    sEdition = pSPlusAppReference.Edition
    If (Trim$(LCase$(sEdition)) = "student") Then
        MsgBox "This feature does not function with S-PLUS Student edition."
        GoTo LErrReturn
    End If
    
    On Error GoTo LErrReturn
    
    Dim pGraphSheet As Object
    Set pGraphSheet = GetSelectedSPLUSGraphSheet()
    sName = pGraphSheet.NewName
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(sDialogBaseName) + "1")
    Dim bOK As Boolean
    bOK = pDialogSheet.Show()

    Do
        On Error GoTo StopDialogCycle
        Set pDialogSheet = GetNextDialog(sDialogBaseName)
        bOK = pDialogSheet.Show()
    Loop While (1 = 1)

StopDialogCycle:
    If (bOK) Then
        ModifyPlotDialog_Finish
    End If
    Exit Sub

LErrReturn:
    MsgBox "Failed to display the modify plots dialog for the selected graph. This might be caused by selecting a graph that was not created by " + GetDefineString("TargetTitle")
End Sub

Sub SP_ShowAboutDialog()
Attribute SP_ShowAboutDialog.VB_ProcData.VB_Invoke_Func = " \n14"
    Const sDialogBaseName = "AboutDialog"

    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(Trim$(sDialogBaseName) + "1")
    Dim bOK As Boolean
    bOK = pDialogSheet.Show()

    Do
        On Error GoTo StopDialogCycle
        Set pDialogSheet = GetNextDialog(sDialogBaseName)
        bOK = pDialogSheet.Show()
    Loop While (1 = 1)

StopDialogCycle:
End Sub

Sub Auto_Open()
Attribute Auto_Open.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn

    Set splusAddIn = AddIns(GetDefineString("Title"))
    If splusAddIn.Installed = True Then
        AddMenus
    End If
    
    Const sDialogBaseName = "CreateGraphDialog"
    InitWizardDialogs sDialogBaseName
    
    Exit Sub
    
LErrReturn:
End Sub

Sub Auto_Close()
Attribute Auto_Close.VB_ProcData.VB_Invoke_Func = " \n14"
End Sub

'Required routine that gets called by Excel when add-in is added
Sub Auto_Add()
Attribute Auto_Add.VB_ProcData.VB_Invoke_Func = " \n14"
'    Application.ScreenUpdating = False
    AddToolbarsAndMenus
End Sub

'Required routine that gets called by Excel when add-in is removed
Sub Auto_Remove()
Attribute Auto_Remove.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error Resume Next
    RemoveToolbarsAndMenus
'    Application.ScreenUpdating = True
End Sub
        
Attribute VB_Name = "WizardUtilities"
Public Const IDC_WAIT = 32514&
Declare Function LoadCursor Lib "user32" Alias "LoadCursorA" _
    (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
Attribute LoadCursor.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
Attribute SetCursor.VB_ProcData.VB_Invoke_Func = " \n14"

Declare Function GetActiveWindow% Lib "user32" ()
Attribute GetActiveWindow.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As Any) As Long
Attribute FindWindow.VB_ProcData.VB_Invoke_Func = " \n14"
Declare Function IsWindow Lib "user32" (ByVal hWnd As Long) As Long
Attribute IsWindow.VB_ProcData.VB_Invoke_Func = " \n14"

Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Attribute GetPrivateProfileString.VB_ProcData.VB_Invoke_Func = " \n14"

' Routine to get an hwnd in Excel for use as the parent of flying dialogs
Function GetExcelHwnd() As Long
Attribute GetExcelHwnd.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim hWndExcel As Long
    hWndExcel = FindWindow("XLMAIN", 0&)
    If (IsWindow(hWndExcel) <= 0) Then
        hWndExcel = GetActiveWindow()
    End If
    GetExcelHwnd = hWndExcel
End Function

Function ExcelHasFocusBug() As Boolean
Attribute ExcelHasFocusBug.VB_ProcData.VB_Invoke_Func = " \n14"
    ExcelHasFocusBug = False
    Dim sVersion As String
    sVersion = Application.Version
    Dim dVersion As Double
    dVersion = Val(sVersion)
    If (dVersion >= 8) Then
        ExcelHasFocusBug = True
    End If
End Function

' Routine to get a particular dialog sheet by name
Function GetDialogSheet(sDialogName As String) As DialogSheet
Attribute GetDialogSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    If (Len(Trim$(sDialogName)) <= 0) Then
        Set GetDialogSheet = Nothing
        Exit Function
    End If
    Set GetDialogSheet = ThisWorkbook.DialogSheets(sDialogName)
End Function

'Routine to copy a toolbar button face to the clipboard
Sub CopyToolbarButtonFaceToClipboard(toolbarIndex As Integer, buttonNumber As Integer)
Attribute CopyToolbarButtonFaceToClipboard.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim pSheet As Worksheet
    Set pSheet = GetToolbarSheet(toolbarIndex)
    pSheet.Pictures("Button" + Trim$(Str$(buttonNumber))).CopyPicture format:=xlBitmap
End Sub

'Routine to count number of toolbar worksheets in application
Function ToolbarCount() As Integer
Attribute ToolbarCount.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim pSheet As Object
    Dim nToolbarCount As Integer
    
    nToolbarCount = 0
    For Each pSheet In ThisWorkbook.Worksheets
        Dim sWorksheetName As String
        sWorksheetName = Trim$(UCase$(pSheet.Name))
        If (InStr(sWorksheetName, "TOOLBAR") = 1) Then
            nToolbarCount = nToolbarCount + 1
        End If
    Next pSheet
    
    ToolbarCount = nToolbarCount
End Function

'Routine to count number of menu worksheets in application
Function MenuCount() As Integer
Attribute MenuCount.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim pSheet As Object
    Dim nMenuCount As Integer
    
    nMenuCount = 0
    For Each pSheet In ThisWorkbook.Worksheets
        Dim sWorksheetName As String
        sWorksheetName = Trim$(UCase$(pSheet.Name))
        If (InStr(sWorksheetName, "MENU") = 1) Then
            nMenuCount = nMenuCount + 1
        End If
    Next pSheet
    
    MenuCount = nMenuCount
End Function

'Routine to get a toolbar worksheet
Function GetToolbarSheet(nIndex As Integer) As Worksheet
Attribute GetToolbarSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    If (nIndex <= 0 Or nIndex > ToolbarCount()) Then
        Set GetToolbarSheet = Nothing
        Exit Function
    End If
    
    Dim sSheetName As String
    sSheetName = "Toolbar" + Trim$(Str$(nIndex))
    Set GetToolbarSheet = ThisWorkbook.Worksheets(sSheetName)
End Function

'Routine to get a menu worksheet
Function GetMenuSheet(nIndex As Integer) As Worksheet
Attribute GetMenuSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    If (nIndex <= 0 Or nIndex > MenuCount()) Then
        Set GetMenuSheet = Nothing
        Exit Function
    End If
    
    Dim sSheetName As String
    sSheetName = "Menu" + Trim$(Str$(nIndex))
    Set GetMenuSheet = ThisWorkbook.Worksheets(sSheetName)
End Function

' Routine to count number of buttons in toolbar sheet
Function GetToolbarButtonCount(nIndex As Integer) As Integer
Attribute GetToolbarButtonCount.VB_ProcData.VB_Invoke_Func = " \n14"
    GetToolbarButtonCount = -1
    
    Dim pSheet As Object
    Set pSheet = GetToolbarSheet(nIndex)
    
    Dim sValueFound As String
    sValueFound = ""
    Dim nItemsFound As Integer
    nItemsFound = 0
    With pSheet
        Do
            sValueFound = CStr(.Cells(nItemsFound + 1, 2).Value)
            If (Len(Trim$(sValueFound)) > 0) Then
                nItemsFound = nItemsFound + 1
            End If
        Loop While Len(Trim$(sValueFound)) > 0
    End With
    GetToolbarButtonCount = nItemsFound
End Function

' Routine to count number of items in menu sheet
Function GetMenuItemCount(nIndex As Integer) As Integer
Attribute GetMenuItemCount.VB_ProcData.VB_Invoke_Func = " \n14"
    GetMenuItemCount = -1
    
    Dim pSheet As Object
    Set pSheet = GetMenuSheet(nIndex)

    Dim sValueFound As String
    sValueFound = ""
    Dim nItemsFound As Integer
    nItemsFound = 0
    With pSheet
        Do
            sValueFound = CStr(.Cells(nItemsFound + 1, 2).Value)
            If (Len(Trim$(sValueFound)) > 0) Then
                nItemsFound = nItemsFound + 1
            End If
        Loop While Len(Trim$(sValueFound)) > 0
    End With
    GetMenuItemCount = nItemsFound
End Function

'Routine to add the add-in toolbars
Sub AddToolbars()
Attribute AddToolbars.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim i As Integer, j As Integer

    Dim nToolbars As Integer
    nToolbars = ToolbarCount()
    For i = 1 To nToolbars
        Dim pToolbarSheet As Worksheet
        Set pToolbarSheet = GetToolbarSheet(i)
            
        Dim sToolbarName As String
        sToolbarName = ParseStringForKeys(pToolbarSheet.Cells(1, 1).Value)
            
        'Search for add-in toolbar
        Dim Tbar As Object
        Dim TbarExists As Boolean
        TbarExists = False
        For Each Tbar In Application.Toolbars
            If Tbar.Name = sToolbarName Then
                TbarExists = True
            End If
        Next Tbar
            
        'If add-in toolbar does not exist, then add it
        If Not TbarExists Then
            ' Add toolbar
            Application.Toolbars.Add Name:=sToolbarName
            Application.Toolbars(sToolbarName).Visible = True
        
            ' Add buttons
            Dim nButtons As Integer
            nButtons = GetToolbarButtonCount(i)
            For j = 1 To nButtons
                Dim nButtonID As Integer
                Dim sButtonName As String, sButtonStatus As String, sButtonAction As String
                nButtonID = pToolbarSheet.Cells(j, 2).Value
                sButtonName = ParseStringForKeys(pToolbarSheet.Cells(j, 3).Value)
                sButtonStatus = ParseStringForKeys(pToolbarSheet.Cells(j, 4).Value)
                sButtonAction = pToolbarSheet.Cells(j, 5).Value
                
                Application.Toolbars(sToolbarName).ToolbarButtons.Add (nButtonID)
                CopyToolbarButtonFaceToClipboard i, j
                With Application.Toolbars(sToolbarName).ToolbarButtons(j)
                    .PasteFace
                    .Name = sButtonName
                    If (Len(Trim$(sButtonAction)) > 0) Then
                        .OnAction = sButtonAction
                    End If
                    If (Len(Trim$(sButtonStatus)) > 0) Then
                        .StatusBar = sButtonStatus
                    End If
                End With
            Next j
            
            'Change width of toolbar to force it to show horizontally
            Application.Toolbars(sToolbarName).Width = nButtons * 50
        End If
    Next i
End Sub

'Routine to add the add-in menus
Sub AddMenus()
Attribute AddMenus.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim i As Integer, j As Integer

    Dim nMenus As Integer
    nMenus = MenuCount()
    For i = 1 To nMenus
        Dim pMenuSheet As Worksheet
        Set pMenuSheet = GetMenuSheet(i)
            
        Dim sMenuName As String
        sMenuName = ParseStringForKeys(pMenuSheet.Cells(1, 1).Value)
            
        'Search for add-in menu
        Dim mb As Object
        Dim MenuExists As Boolean
        MenuExists = False
        For Each mb In Application.MenuBars
            Dim mn As Object
            For Each mn In mb.Menus
                If (mn.Caption = sMenuName) Then
                    MenuExists = True
                End If
            Next mn
        Next mb
            
        'If add-in menu does not exist, then add it
        If Not MenuExists Then
            With Application.MenuBars(xlWorksheet)
                
                'Add menu
                Dim nInsertPoint As Integer
                nInsertPoint = .Menus.Count - 1
                If (nInsertPoint <= 0) Then
                    nInsertPoint = 1
                End If
                .Menus.Add sMenuName, nInsertPoint
                
                ' Add items
                Dim nItems As Integer
                nItems = GetMenuItemCount(i)
                For j = 1 To nItems
                    Dim sItemName As String, sItemStatus As String, sItemAction As String
                    sItemName = ParseStringForKeys(pMenuSheet.Cells(j, 2).Value)
                    sItemStatus = ParseStringForKeys(pMenuSheet.Cells(j, 3).Value)
                    sItemAction = pMenuSheet.Cells(j, 4).Value
                
                    .Menus(sMenuName).MenuItems.Add sItemName
                    If (Trim$(UCase$(sItemName)) <> "-") Then
                        With .Menus(sMenuName).MenuItems(sItemName)
                            If (Len(Trim$(sItemAction)) > 0) Then
                                .OnAction = sItemAction
                            End If
                            If (Len(Trim$(sItemStatus)) > 0) Then
                                .StatusBar = sItemStatus
                            End If
                        End With
                    End If
                Next j
            End With
        End If
    Next i
End Sub

'Routine to add the add-in toolbars and menus as needed
Sub AddToolbarsAndMenus()
Attribute AddToolbarsAndMenus.VB_ProcData.VB_Invoke_Func = " \n14"
    AddToolbars
    AddMenus
End Sub

' Routine to remove all added add-in menus and toolbars
Sub RemoveToolbarsAndMenus()
Attribute RemoveToolbarsAndMenus.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim i As Integer
    
    ' Remove toolbars
    Dim nToolbars As Integer
    nToolbars = ToolbarCount()
    For i = 1 To nToolbars
        Dim pToolbarSheet As Worksheet
        Set pToolbarSheet = GetToolbarSheet(i)
        With pToolbarSheet
            Dim sToolbarName As String
            sToolbarName = ParseStringForKeys(.Cells(i, 1).Value)
            Application.Toolbars(sToolbarName).Delete
        End With
    Next i
    
    'Remove menus
    Dim nMenus As Integer
    nMenus = MenuCount()
    For i = 1 To nMenus
        Dim pMenuSheet As Worksheet
        Set pMenuSheet = GetMenuSheet(i)
        With pMenuSheet
            Dim sMenuName As String
            sMenuName = ParseStringForKeys(.Cells(i, 1).Value)
            Application.MenuBars(xlWorksheet).Menus(sMenuName).Delete
        End With
    Next i
End Sub

'Routine to get the next dialog in a wizard
Function GetNextDialog(sDialogBaseName As String) As DialogSheet
Attribute GetNextDialog.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn

    If (Len(Trim$(sDialogBaseName)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim nNextDialog As Integer
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(sDialogBaseName + "1")
    With pDialogSheet
        nNextDialog = Val(.EditBoxes("NextDialog").Text)
    End With
    
    If (nNextDialog <= 0) Then
        GoTo LErrReturn
    End If

    Set GetNextDialog = GetDialogSheet(sDialogBaseName + Trim$(Str$(nNextDialog)))
    Exit Function
    
LErrReturn:
    Set GetNextDialog = Nothing
End Function

'Routine to set the next dialog in a wizard
Sub SetNextDialog(sDialogBaseName As String, nNextDialogIndex As Integer)
Attribute SetNextDialog.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn

    If (Len(Trim$(sDialogBaseName)) <= 0) Then
        GoTo LErrReturn
    End If
    
    If (nNextDialogIndex < 0) Then
        GoTo LErrReturn
    End If
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(sDialogBaseName + "1")
    With pDialogSheet
        .EditBoxes("NextDialog").Text = Trim$(Str$(nNextDialogIndex))
    End With
    
    Exit Sub
LErrReturn:
End Sub

' Routine to test whether a wizard dialog has ever been edited by user
Function HasWizardBeenTouched(sDialogBaseName As String) As Boolean
Attribute HasWizardBeenTouched.VB_ProcData.VB_Invoke_Func = " \n14"
    HasWizardBeenTouched = False
    On Error GoTo LErrReturn

    If (Len(Trim$(sDialogBaseName)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(sDialogBaseName + "1")
    With pDialogSheet
        Dim sTouched As String
        sTouched = Trim$(.EditBoxes("Touched").Text)
        If (Val(sTouched) > 0) Then
            HasWizardBeenTouched = True
        End If
    End With
    
    Exit Function
LErrReturn:
    HasWizardBeenTouched = False
End Function

' Routine to set whether a wizard dialog has ever been edited by user
Sub SetWizardBeenTouched(sDialogBaseName As String, bTouched As Boolean)
Attribute SetWizardBeenTouched.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn

    If (Len(Trim$(sDialogBaseName)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim pDialogSheet As DialogSheet
    Set pDialogSheet = GetDialogSheet(sDialogBaseName + "1")
    With pDialogSheet
        Dim nTimesTouched As Integer
        nTimesTouched = 0
        If (bTouched) Then
            nTimesTouched = Val(Trim$(.EditBoxes("Touched").Text))
            nTimesTouched = nTimesTouched + 1
        End If
        .EditBoxes("Touched").Text = Str(nTimesTouched)
    End With
    
    Exit Sub
LErrReturn:
End Sub

' Routine to initialize a drop down control with worksheet names
Sub InitializeDropDownWithWorksheetNames(pDropDown As DropDown)
Attribute InitializeDropDownWithWorksheetNames.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn

    Dim nTargetWorksheets As Integer
    Dim sTargetWorksheets() As String
    nTargetWorksheets = GetWorksheetNames(sTargetWorksheets)
    If (nTargetWorksheets > 0) Then
        Dim sCurrentWorksheetName As String
        sCurrentWorksheetName = GetCurrentWorksheetName()
        
        Dim nDefaultWorksheetIndex As Integer
        nDefaultWorksheetIndex = FindStringInArray(sTargetWorksheets, sCurrentWorksheetName)
        If (nDefaultWorksheetIndex < 0) Then
            nDefaultWorksheetIndex = 1
        End If
            
        pDropDown.RemoveAllItems
        pDropDown.List = sTargetWorksheets
        pDropDown.Value = nDefaultWorksheetIndex
    End If
    
    Exit Sub

LErrReturn:
End Sub

Sub InitializeListBoxWithSheetRange(pListBox As ListBox, sSheetName As String, sColumn As String, nStartRow As Integer)
Attribute InitializeListBoxWithSheetRange.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
           
    Dim nColLength As Integer
    nColLength = LengthOfColumn(Trim$(sSheetName), Trim$(sColumn))
    
    Dim sColRange As String
    sColRange = Trim$(sColumn) + Trim$(Str(nStartRow)) + ":" + Trim$(sColumn) + Trim$(Str(nColLength))

    Dim pListFillArray As Variant
    Dim pRange As Range
    Set pRange = ThisWorkbook.Worksheets(sSheetName).Range(sColRange)
    ConvertSheetRangeToArray pListFillArray, pRange
    
    pListBox.RemoveAllItems
    pListBox.List = pListFillArray
    pListBox.Value = 1

    Exit Sub

LErrReturn:
End Sub

Sub InitializeListBoxWithPlotsForGraph(pGraph As Object, pListBox As ListBox)
Attribute InitializeListBoxWithPlotsForGraph.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    pListBox.RemoveAllItems
    
    Dim arrayContainees As Variant
    arrayContainees = pGraph.Containees("Plot")
    
    Dim nFirstContainee As Integer, nLastContainee As Integer
    nFirstContainee = LBound(arrayContainees)
    nLastContainee = UBound(arrayContainees)
    
    Dim pListFillArray() As String
    ReDim pListFillArray(nFirstContainee To nLastContainee)
    
    For i = nFirstContainee To nLastContainee
        Dim pContainee As Object
        Set pContainee = arrayContainees(i)
        
        Dim sContaineePathName As String
        sContaineePathName = pContainee.PathName()
        
        Dim sContaineeClassName As String
        sContaineeClassName = pContainee.ClassName()
        
        pListFillArray(i) = "[" + Trim$(sContaineeClassName) + "]" + Trim$(sContaineePathName)
    Next i
    
    pListBox.List = pListFillArray
    pListBox.Value = 1

    Exit Sub
LErrReturn:
End Sub

Sub InitializeListBoxWithGraphsForSheet(pGraphSheet As Object, pListBox As ListBox)
Attribute InitializeListBoxWithGraphsForSheet.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    pListBox.RemoveAllItems
    
    Dim arrayContainees As Variant
    arrayContainees = pGraphSheet.Containees("Graph")
    
    Dim nFirstContainee As Integer, nLastContainee As Integer
    nFirstContainee = LBound(arrayContainees)
    nLastContainee = UBound(arrayContainees)
    
    Dim pListFillArray() As String
    ReDim pListFillArray(nFirstContainee To nLastContainee)
    
    For i = nFirstContainee To nLastContainee
        Dim pContainee As Object
        Set pContainee = arrayContainees(i)
        
        Dim sContaineePathName As String
        sContaineePathName = pContainee.PathName()
        
        Dim sContaineeClassName As String
        sContaineeClassName = pContainee.ClassName()
        
        pListFillArray(i) = "[" + Trim$(sContaineeClassName) + "]" + Trim$(sContaineePathName)
    Next i
    
    pListBox.List = pListFillArray
    pListBox.Value = 1

    Exit Sub
LErrReturn:
End Sub

' Routine to get the class name and pathname for an object from a specially constructed string
' used in wizard dialogs
Function GetClassAndPathNameFromString(sClass As String, sPathName As String, sString As String) As Boolean
Attribute GetClassAndPathNameFromString.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    sClass = ""
    sPathName = ""
    If (Len(Trim$(sString)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim sUseString As String
    sUseString = Trim$(sString)
    
    Dim nFoundLeftBracket As Integer, nFoundRightBracket As Integer
    nFoundLeftBracket = InStr(sUseString, "[")
    nFoundRightBracket = InStr(sUseString, "]")
    If (nFoundLeftBracket <= 0 Or nFoundRightBracket <= nFoundLeftBracket) Then
        GoTo LErrReturn
    End If
    
    sClass = Trim$(Mid(sUseString, nFoundLeftBracket + 1, (nFoundRightBracket - (nFoundLeftBracket + 1))))
    sPathName = Trim$(Mid(sUseString, (nFoundRightBracket + 1)))
    If (Len(sClass) <= 0 Or Len(sPathName) <= 0) Then
        GoTo LErrReturn
    End If
    
    GetClassAndPathNameFromString = True
    Exit Function
LErrReturn:
    GetClassAndPathNameFromString = False
End Function

' Routine to initialize all dialogs in a wizard
Sub InitWizardDialogs(sDialogBaseName As String)
Attribute InitWizardDialogs.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn

    If (Len(Trim$(sDialogBaseName)) <= 0) Then
        GoTo LErrReturn
    End If
    
    SetWizardBeenTouched sDialogBaseName, False
    Application.Run Trim$(sDialogBaseName) + "_Init"

    Exit Sub

LErrReturn:
    On Error GoTo 0
End Sub

' Set cursor to hour glass
Function SetCursorToWait() As Long
Attribute SetCursorToWait.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim hNewCursor As Long
    hNewCursor = LoadCursor(0, IDC_WAIT)
    SetCursorToWait = SetCursor(hNewCursor)
End Function

' Restore cursor
Sub RestoreCursor(hOldCursor As Long)
Attribute RestoreCursor.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim returnValue As Long
    returnValue = SetCursor(hOldCursor)
End Sub

Function MakeLegalObjectName(sObjectName As String) As String
Attribute MakeLegalObjectName.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    If (Len(Trim$(sObjectName)) <= 0) Then
        GoTo LErrReturn
    End If
    
    Dim nLengthOfObjectName As Integer
    nLengthOfObjectName = Len(sObjectName)
    Dim sTmpName As String
    sTmpName = ""
    For i = 1 To nLengthOfObjectName
        Dim sObjectChar As String
        sObjectChar = Mid$(sObjectName, i, 1)
        If (sObjectChar = " " Or _
            sObjectChar = "/" Or _
            sObjectChar = "\" Or _
            sObjectChar = "-") Then
            sObjectChar = "_"
        End If
        sTmpName = sTmpName + sObjectChar
    Next i

    MakeLegalObjectName = sTmpName
    
    Exit Function
LErrReturn:
    MakeLegalObjectName = ""
End Function

Sub ClearSPLUSHistoryLog()
Attribute ClearSPLUSHistoryLog.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sHistoryLogClearCommand As String
    sHistoryLogClearCommand = "//AXUM" + Chr$(13) + Chr$(10) + "ExecuteBuiltIn( " + _
        Chr$(34) + "$$SPlusMenuBar$Script_File$Window$History$Clear" + Chr$(34) + ", 0 );"
        
    Dim pApp As Object
    Set pApp = CreateObject(GetDefineString("TargetTitle") + ".Application")
    
    Dim bSuccess As Boolean
    bSuccess = pApp.ExecuteString(sHistoryLogClearCommand)
    Exit Sub
LErrReturn:
End Sub

Sub RedirectSPlusOutput(hWnd As Long)
Attribute RedirectSPlusOutput.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim pApp As Object
    Set pApp = CreateObject(GetDefineString("TargetTitle") + ".Application")
    
    Dim sTextOutputDestination As String
    sTextOutputDestination = "Dialog"
    If (hWnd <= 0) Then
        sTextOutputDestination = "Default"
    End If
    
    Dim sSetTextOutputRoutingCmd As String
    sSetTextOutputRoutingCmd = "setTextOutputRouting(" + _
        Chr$(34) + Trim$(sTextOutputDestination) + Chr$(34) + ", " + _
        Chr$(34) + Trim$(sTextOutputDestination) + Chr$(34) + ")"
    
    Dim vCurrentOpt1 As Variant, vCurrentOpt2 As Variant
    vCurrentOpt1 = pApp.GetOptionValue("EchoExecuteStringInCmdWnd")
    vCurrentOpt2 = pApp.GetOptionValue("DisplayExecuteStringOutput")
    bSuccess = pApp.SetOptionValue("EchoExecuteStringInCmdWnd", False)
    bSuccess = pApp.SetOptionValue("DisplayExecuteStringOutput", False)
    
    bSuccess = pApp.ExecuteString(sSetTextOutputRoutingCmd)
    bSuccess = pApp.SetOptionValue("TextRoutingOutputDialogParent", CStr(hWnd))
    
    bSuccess = pApp.SetOptionValue("EchoExecuteStringInCmdWnd", vCurrentOpt1)
    bSuccess = pApp.SetOptionValue("DisplayExecuteStringOutput", vCurrentOpt2)
    
    Exit Sub
LErrReturn:
End Sub

Function GetIniValue(ByVal theIniPath As String, _
    ByVal theSection As String, _
    ByVal theKey As String) As String
Attribute GetIniValue.VB_ProcData.VB_Invoke_Func = " \n14"

    '* Declare local variables
    Dim lpDefault$
    Dim lpReturnString$
    Dim Size%
    Dim Valid%
    Dim i%

    '* Setup the pathname for the ini file
    If Len(Trim$(theIniPath$)) <= 0 Then
        GetIniValue = ""
        Exit Function
    End If

    '* Search for user-specified values in INI file
    lpDefault$ = ""
    lpReturnString$ = Space$(128)
    Size% = Len(lpReturnString$)
    Valid% = GetPrivateProfileString(ByVal theSection$, ByVal theKey$, lpDefault$, lpReturnString$, Size%, theIniPath$)

    If Valid% Then
        GetIniValue = Trim$(Left$(lpReturnString$, Valid%))
    Else
        GetIniValue = ""
    End If
End Function

Function Slash(sString As String) As String
Attribute Slash.VB_ProcData.VB_Invoke_Func = " \n14"
    Dim nLengthString As Integer
    nLengthString = Len(sString)
    Slash = ""
    
    If (nLengthString <= 0) Then
        Exit Function
    End If
    
    If (Right$(sString, Len(Application.PathSeparator)) <> Application.PathSeparator) Then
        Slash = Application.PathSeparator
    End If
End Function

Function GetStartupPath() As String
Attribute GetStartupPath.VB_ProcData.VB_Invoke_Func = " \n14"
    On Error GoTo LErrReturn
    
    Dim sSPlusCmdPath As String
    sSPlusCmdPath = Trim$(ThisWorkbook.Path)
    GetStartupPath = Trim$(sSPlusCmdPath)
    Exit Function
LErrReturn:
    GetStartupPath = ""
End Function

Function GetAddInINIPathName() As String
Attribute GetAddInINIPathName.VB_ProcData.VB_Invoke_Func = " \n14"
    GetAddInINIPathName = ""
    On Error GoTo ErrorHandler

    Dim sINIPathName As String
    sINIPathName = GetStartupPath()
    sINIPathName = sINIPathName + Slash(sINIPathName) + "insightful.ini"

    GetAddInINIPathName = sINIPathName
    Exit Function
ErrorHandler:
    GetAddInINIPathName = ""
End Function

Function GetAddInTitle() As String
Attribute GetAddInTitle.VB_ProcData.VB_Invoke_Func = " \n14"
    GetAddInTitle = ""
    On Error GoTo ErrorHandler
    
    Dim sINIPathName As String
    sINIPathName = GetAddInINIPathName()
    If (Len(sINIPathName) <= 0) Then
        Exit Function
    End If
    GetAddInTitle = GetIniValue(sINIPathName, "Add-In Info", "Title")
    Exit Function
ErrorHandler:
    GetAddInTitle = ""
End Function

Function GetAddInTargetTitle() As String
Attribute GetAddInTargetTitle.VB_ProcData.VB_Invoke_Func = " \n14"
    GetAddInTargetTitle = ""
    On Error GoTo ErrorHandler
    
    Dim sINIPathName As String
    sINIPathName = GetAddInINIPathName()
    If (Len(sINIPathName) <= 0) Then
        Exit Function
    End If
    GetAddInTargetTitle = GetIniValue(sINIPathName, "Add-In Info", "TargetTitle")
    Exit Function
ErrorHandler:
    GetAddInTargetTitle = ""
End Function

Function GetAddInTargetFileType() As String
Attribute GetAddInTargetFileType.VB_ProcData.VB_Invoke_Func = " \n14"
    GetAddInTargetFileType = ""
    On Error GoTo ErrorHandler
    
    Dim sINIPathName As String
    sINIPathName = GetAddInINIPathName()
    If (Len(sINIPathName) <= 0) Then
        Exit Function
    End If
    GetAddInTargetFileType = GetIniValue(sINIPathName, "Add-In Info", "TargetFileType")
    Exit Function
ErrorHandler:
    GetAddInTargetFileType = ""
End Function

Function ParseStringForKeys(sOriginalString As String) As String
Attribute ParseStringForKeys.VB_ProcData.VB_Invoke_Func = " \n14"
    ParseStringForKeys = sOriginalString
    On Error GoTo LErrReturn
    
    If (Len(Trim$(sOriginalString)) <= 0) Then
        Exit Function
    End If
    
    Dim arrayKeys(0 To 0) As String
    arrayKeys(0) = "[TargetAppName]"
    
    Dim sTmp1 As String
    sTmp1 = sOriginalString
    For i = LBound(arrayKeys) To UBound(arrayKeys)
        Dim sKeyToFind As String
        sKeyToFind = arrayKeys(i)
        
        Dim nFoundKey As Integer
        Do
            nFoundKey = InStr(sTmp1, sKeyToFind)
            If (nFoundKey > 0) Then
                Dim sTmp2 As String
                If (StrComp(sKeyToFind, "[TargetAppName]") = 0) Then
                    sTmp2 = Left(sTmp1, nFoundKey - 1) + GetDefineString("TargetTitle") + Mid(sTmp1, nFoundKey + Len(sKeyToFind))
                End If
                sTmp1 = sTmp2
            End If
        Loop While (nFoundKey > 0)
    Next i
    ParseStringForKeys = sTmp1
    
    Exit Function
LErrReturn:
End Function

' InQuest injected base64 decoded content
' Kk*.

INQUEST-PP=macro
