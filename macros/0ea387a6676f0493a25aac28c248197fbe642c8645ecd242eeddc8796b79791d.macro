Attribute VB_Name = "CommandBarImages"
Attribute VB_Base = "0{D3B990F0-5E01-4EBA-AE1F-441FB057F66C}{B3DBEB50-9BA1-48A6-880B-0051C68AD846}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public Sub AssignCommandBarImages(ByVal p_Menu As Office.CommandBarPopup)
   Dim oneItem As Office.CommandBarControl
                  
   On Error Resume Next
   For Each oneItem In p_Menu.Controls
      If oneItem.Type = msoControlButton Then
         AssignOneCommandBarImage oneItem
         
      ElseIf oneItem.Type = msoControlPopup Then
         If oneItem.Parameter <> "RiskMenu_InsertFunction" Then AssignCommandBarImages oneItem
         
      End If
   Next
   
   
   On Error GoTo 0
End Sub

Public Function AssignOneCommandBarImage(ByVal p_Control As Office.CommandBarButton)
   Dim ctrlName As String
   Dim p As Integer
   Dim imgCtrl As Image
   Dim maskCtrl As Image
   
   ctrlName = Replace(p_Control.Parameter, "RiskCommand_", "")
   ctrlName = Replace(ctrlName, "RiskDNCommand_", "")
   p = InStr(ctrlName, "@")
   If (p > 0) Then ctrlName = Left(ctrlName, p - 1)
      
   On Error Resume Next
   Set imgCtrl = Controls("Image" & ctrlName)
   Set maskCtrl = Controls("Mask" & ctrlName)
   On Error GoTo 0
    
   If Not (imgCtrl Is Nothing) Then p_Control.Picture = imgCtrl.Picture
   If Not (maskCtrl Is Nothing) Then p_Control.Mask = maskCtrl.Picture
End Function


Attribute VB_Name = "DtoolsCallbacks"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'Most of the calls here are simply wrappers for calling into Dtools.xll (thus the name of this class).  However, over time, the role of this object has expanded to include
'other functionality where we simply need to call things from within Excel's process.  This is better than having a bunch of public calls in a public module for many reasons.
'Among them: They are not publically visible as UDFs or macros, and their error handling will propagate back to the caller.

Dim m_XLLLoaded As Boolean


#If Win64 Then

   'WINDOWS API DECLARES:
   Private Declare PtrSafe Function AllowSetForegroundWindow Lib "user32" (ByVal dwProcessId As Long) As Long
   Private Declare PtrSafe Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As LongPtr
   Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
   Private Declare PtrSafe Function CreateMutex Lib "kernel32" Alias "CreateMutexA" (ByVal lpMutexAttributes As LongPtr, ByVal bInitialOwner As Long, ByVal lpName As String) As LongLong
   Private Declare PtrSafe Function OpenMutex Lib "kernel32" Alias "OpenMutexA" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal lpName As String) As LongLong
   Private Declare PtrSafe Function SetForegroundWindowAPI Lib "user32" Alias "SetForegroundWindow" (ByVal hwnd As LongPtr) As Long
   Private Const MUTEX_ALL_ACCESS As Long = &H1F0001
   
   'DTOOLS DECLARES:
   Private Declare PtrSafe Sub Dtools_DeleteRsklibDataFromWorkbook Lib "DTOOLS7_x64.XLL" Alias "DeleteRsklibDataFromWorkbook" (ByVal wb As Workbook)
   Private Declare PtrSafe Sub Dtools_DeleteSwappedHiddenSheets Lib "DTOOLS7_x64.XLL" Alias "DeleteSwappedHiddenSheets" ()
   Private Declare PtrSafe Function Dtools_ExtractSimNumFromFormulaVB& Lib "DTOOLS7_x64.XLL" Alias "ExtractSimNumFromFormulaVB" (ByVal sourceCell As Range, ByVal formula As LongPtr, ByVal formulaIsInLocalLanguage As Long, ByRef simNum As Long)
   Private Declare PtrSafe Function DtoolsW_GenerateCorrelatedDataFromInputs& Lib "DTOOLS7_x64.XLL" Alias "GenerateCorrelatedDataFromInputsW" (ByVal inputName1String As LongPtr, ByVal inputName2String As LongPtr, ByVal numPoints&, ByVal corrCoeff#, ByRef data1#(), ByRef data2#())
   Private Declare PtrSafe Function DtoolsW_GenerateSnapshotFromRiskCompound Lib "DTOOLS7_x64.XLL" Alias "GenerateSnapshotFromRiskCompoundW" (ByVal compoundDistNameString As LongPtr, ByVal frequencyDistNameString As LongPtr, ByVal severityDistNameString As LongPtr, ByVal frequencyValue#, ByVal numPoints&, ByRef snapshotHandle#) As Long
   Private Declare PtrSafe Function Dtools_GetCellRefFunctionRanges Lib "DTOOLS7_x64.XLL" Alias "GetCellRefFunctionRanges" (ByVal channelNum%, ByVal functionTokenTypes&, ByRef rangeObjs() As Range) As Long
   Private Declare PtrSafe Function Dtools_GetDtoolsInstanceId Lib "DTOOLS7_x64.XLL" Alias "GetDtoolsInstanceId" () As Long
   Private Declare PtrSafe Function DtoolsW_GetExceptionInfoVB Lib "DTOOLS7_x64.XLL" Alias "GetExceptionInfoWVB" (ByVal exceptionId As Long, ByVal exceptionNameString As LongPtr, ByVal methodNameString As LongPtr, ByVal messageString As LongPtr) As Long
   Private Declare PtrSafe Function Dtools_GetExcelModelCellsWithTokenTypesRanges Lib "DTOOLS7_x64.XLL" Alias "GetExcelModelCellsWithTokenTypesRanges" (ByVal channelNum As Integer, ByVal tokenTypes As Long, ByRef rangeObjs() As Range) As Long
   Private Declare PtrSafe Function Dtools_GetInputOrOutputRanges Lib "DTOOLS7_x64.XLL" Alias "GetInputOrOutputRanges" (ByVal channelNum As Integer, ByVal dataType As Integer, ByRef p_Ranges() As Range) As Long
   Private Declare PtrSafe Function Dtools_GetRsklibDataSize& Lib "DTOOLS7_x64.XLL" Alias "GetRsklibDataSize" (ByRef fileSize#)
   Private Declare PtrSafe Function DtoolsW_IdentifyDataSource% Lib "DTOOLS7_x64.XLL" Alias "IdentifyDataSourceW" (ByVal hVars&, ByVal channelNum%, ByVal dataSourceString As LongPtr, ByVal dataSourceIsCellReference%, ByRef dataType%, ByRef dataIndex&, ByRef found As Integer)
   Private Declare PtrSafe Sub DtoolsW_InitializeXlaInformation Lib "DTOOLS7_x64.XLL" Alias "InitializeXlaInformationW" (ByVal xlApplication As Object, ByVal ObjectLibrary As Object, ByVal appId As Integer, ByVal fullyQualifiedXlaFileNameString As LongPtr, ByVal languageID As Long, ByVal appVersionString As LongPtr, ByVal p_AuthorizationHandle As Long, ByVal p_RemoveCOMMessageFilter As Long)
   Private Declare PtrSafe Function DtoolsW_MakeAllInputsIdentifiers Lib "DTOOLS7_x64.XLL" Alias "MakeAllInputsIdentifiersW" (ByVal badCellAddrString As LongPtr, ByVal badInput1String As LongPtr, ByVal badInput2String As LongPtr) As Long
   Private Declare PtrSafe Function Dtools_ReadRsklibDataFromWorkbook& Lib "DTOOLS7_x64.XLL" Alias "ReadRsklibDataFromWorkbook" (ByVal wb As Workbook, ByRef successCode%)
   Private Declare PtrSafe Function DtoolsW_ResolveFormulaVB Lib "DTOOLS7_x64.XLL" Alias "ResolveFormulaWVB" (ByVal p_Range As Range, ByVal p_FormulaString As LongPtr, ByVal p_RemovePropertyFunctions As Long, ByVal p_FormulaInLocalLanguage As Long) As Long
   Private Declare PtrSafe Function DtoolsW_Risk4FindLabelVB Lib "DTOOLS7_x64.XLL" Alias "Risk4FindLabelWVB" (ByVal inputCell As Range, ByVal defaultNameString As LongPtr, ByRef rowHeaderCell As Range, ByRef colHeaderCell As Range) As Integer
   Private Declare PtrSafe Sub Dtools_Risk5SetCellLabelSearchRanges Lib "DTOOLS7_x64.XLL" Alias "Risk5SetCellLabelSearchRanges" (ByRef searchRanges() As Range)
   Private Declare PtrSafe Sub Dtools_RiskAboutToDisplayFunctionWizard Lib "DTOOLS7_x64.XLL" Alias "RiskAboutToDisplayFunctionWizard"()
   Private Declare PtrSafe Function Dtools_RiskCellIsFormattedAsDate Lib "DTOOLS7_x64.XLL" Alias "RiskCellIsFormattedAsDate" (ByVal cell As Range) As Boolean
   Private Declare PtrSafe Function Dtools_RiskCellTokenTestingState& Lib "DTOOLS7_x64.XLL" Alias "RiskCellTokenTestingState" (ByVal newState As Boolean)
   Private Declare PtrSafe Function Dtools_RiskCheckCorrelationMatrix Lib "DTOOLS7_x64.XLL" Alias "RiskCheckCorrelationMatrix" (ByVal matrixDim As Long, ByRef corrmat As Double, ByRef weights As Double, ByRef correctedMatrix As Double, ByRef wasCorrected As Integer) As Long
   Private Declare PtrSafe Function Dtools_RiskDoingEvaluate Lib "DTOOLS7_x64.XLL" Alias "RiskDoingEvaluate" (ByVal p_Evaluating As Integer) As Integer
   Private Declare PtrSafe Function Dtools_RiskFindInputsAndOutputs Lib "DTOOLS7_x64.XLL" Alias "RiskFindInputsAndOutputs" (ByVal startingSimulation%, ByVal collectState%) As Long
   Private Declare PtrSafe Function Dtools_RiskGetCurrentSimResultsAppId Lib "DTOOLS7_x64.XLL" Alias "RiskGetCurrentSimResultsAppId" () As Integer '0 = @RISK
   Private Declare PtrSafe Sub DtoolsW_RiskGetDistributionDescriptionString Lib "DTOOLS7_x64.XLL" Alias "RiskGetDistributionDescriptionStringW" (ByVal p_DistNameString As LongPtr, ByVal p_LanguageID As Long, ByVal p_DescriptionString As LongPtr)
   Private Declare PtrSafe Sub Dtools_RiskGetFunctionWizardFormulaVB Lib "DTOOLS7_x64.XLL" Alias "RiskGetFunctionWizardFormulaVB" (ByVal startingFormulaBarText$, ByRef functionWizardWindowHandle As Long, ByRef functionWizardFormula$, ByRef functionWizardFormulaName$, ByRef functionWizardFormulaUnits$, ByRef formulaBarWindowHandle As Long, ByRef formulaBarText$, ByRef unresolvedDistributionFormula$)
   Private Declare PtrSafe Function Dtools_RiskGetFunctionWizardWindowHandle Lib "DTOOLS7_x64.XLL" Alias "RiskGetFunctionWizardWindowHandle" () As Long
   Private Declare PtrSafe Function DtoolsW_RiskGetInputNameAndAddressFromIndex% Lib "DTOOLS7_x64.XLL" Alias "RiskGetInputNameAndAddressFromIndexW" (ByVal Index&, ByVal theNameString As LongPtr, ByVal cellAddrString As LongPtr)
   Private Declare PtrSafe Function DtoolsW_RiskInsertFormulaBarText& Lib "DTOOLS7_x64.XLL" Alias "RiskInsertFormulaBarTextW" (ByVal TextString As LongPtr, ByVal where%, ByVal charPos%)
   Private Declare PtrSafe Function Dtools_RiskGetNumCPUs Lib "DTOOLS7_x64.XLL" Alias "RiskGetNumCpus" () As Long
   Private Declare PtrSafe Function DtoolsW_RiskGetOutputNameAndAddressFromIndex% Lib "DTOOLS7_x64.XLL" Alias "RiskGetOutputNameAndAddressFromIndexW" (ByVal Index&, ByVal theNameString As LongPtr, ByVal cellAddrString As LongPtr)
   Private Declare PtrSafe Sub Dtools_RiskUpdateWorkbookGuids Lib "DTOOLS7_x64.XLL" Alias "RiskUpdateWorkbookGuids" (ByVal channelNum%)
   Private Declare PtrSafe Function Dtools_RiskSetEffectiveSimNum Lib "DTOOLS7_x64.XLL" Alias "RiskSetEffectiveSimNum" (ByVal effectiveSimNum As Long) As Long
   Private Declare PtrSafe Function Dtools_RiskSetProjectFieldValueDataVB% Lib "DTOOLS7_x64.XLL" Alias "RiskSetProjectFieldValueDataVB" (ByVal initializeOrUpdate%, ByVal startingCell As Range, ByRef data() As Variant)
   'Private Declare PtrSafe Sub DtoolsW_RiskSetProjectIgnoredRanges Lib "DTOOLS7_x64.XLL" Alias "RiskSetProjectIgnoredRangesW" (ByRef projectIgnoredRangeNames() As Variant)
   Private Declare PtrSafe Sub DtoolsW_RiskSetProjectIgnoredRanges Lib "DTOOLS7_x64.XLL" Alias "RiskSetProjectIgnoredRangesW" (ByVal projectIgnoredRangeNames As Variant)
   
   Private Declare PtrSafe Function Dtools_RunSim5 Lib "DTOOLS7_x64.XLL" Alias "RunSim5" (ByRef ResultsAvailable As Integer, ByRef Cancelled As Integer) As Long
   Private Declare PtrSafe Sub DtoolsW_SetArrayFormulaEnglishVB Lib "DTOOLS7_x64.XLL" Alias "SetArrayFormulaEnglishWVB" (ByVal arrayRange As Range, ByVal FormulaString As LongPtr)
'   Private Declare PtrSafe Function DtoolsW_SetupSim75 Lib "DTOOLS7_x64.XLL" Alias "SetupSim75" (ByVal p_MultiCoreUsage As Long, ByVal NumSimulations As Long, _
'      ByRef SimulationNamesStringArray() As Variant, ByVal NumIterations As Long, ByVal BeforeSimulationMacroString As LongPtr, _
'      ByVal BeforeIterationMacroString As LongPtr, ByVal AfterIterationMacroString As LongPtr, ByVal AfterSimulationMacroString As LongPtr, _
'      ByVal AfterSimulationPrivateMacroString As LongPtr, ByVal PauseOnErr As Long, ByVal UpdateDisplay As Long, ByVal RandomNumberGenerator As Long, _
'      ByVal Seed As Long, ByVal useSameRandomNumberStreamForEachSim As Long, ByVal SamplingType As Long, ByVal SaveSamplesMode As Long, _
'      ByVal RealTimeUpdatePeriod As Long, ByVal ConvergenceTestingEnabled As Long, ByVal ConvergenceTestingPeriod As Long, _
'      ByVal ConvergenceTestAllOutputs As Long, ByVal ConvergenceTolerance As Double, ByVal ConvergenceConfidenceLevel As Double, ByVal ConvergenceMeanTest As Long, _
'      ByVal ConvergenceStdDeviationTest As Long, ByVal ConvergencePercentileTest As Long, ByVal ConvergencePercentileToTest As Double, ByVal IsAdvancedAnalysis As Long, _
'      ByVal SmartSensitivityAnalysisEnabled As Long, ByVal UpdateStatisticFunctionsMethod As Long, ByVal MacroRecalcSamplingMode As Long, _
'      ByVal p_ShowProgressOnStatusBar As Long, ByRef Cancelled As Integer _
'   ) As Long
   
   Private Declare PtrSafe Function DtoolsW_SetupSim75 Lib "DTOOLS7_x64.XLL" Alias "SetupSim75" (ByVal p_MultiCoreUsage As Long, ByVal NumSimulations As Long, _
      ByVal SimulationNamesStringArray As Variant, ByVal NumIterations As Long, ByVal BeforeSimulationMacroString As LongPtr, _
      ByVal BeforeIterationMacroString As LongPtr, ByVal AfterIterationMacroString As LongPtr, ByVal AfterSimulationMacroString As LongPtr, _
      ByVal AfterSimulationPrivateMacroString As LongPtr, ByVal PauseOnErr As Long, ByVal UpdateDisplay As Long, ByVal RandomNumberGenerator As Long, _
      ByVal Seed As Long, ByVal useSameRandomNumberStreamForEachSim As Long, ByVal SamplingType As Long, ByVal SaveSamplesMode As Long, _
      ByVal RealTimeUpdatePeriod As Long, ByVal ConvergenceTestingEnabled As Long, ByVal ConvergenceTestingPeriod As Long, _
      ByVal ConvergenceTestAllOutputs As Long, ByVal ConvergenceTolerance As Double, ByVal ConvergenceConfidenceLevel As Double, ByVal ConvergenceMeanTest As Long, _
      ByVal ConvergenceStdDeviationTest As Long, ByVal ConvergencePercentileTest As Long, ByVal ConvergencePercentileToTest As Double, ByVal IsAdvancedAnalysis As Long, _
      ByVal SmartSensitivityAnalysisEnabled As Long, ByVal UpdateStatisticFunctionsMethod As Long, ByVal MacroRecalcSamplingMode As Long, _
      ByVal p_ShowProgressOnStatusBar As Long, ByRef Cancelled As Integer _
   ) As Long
   
   
   Private Declare PtrSafe Function Dtools_SwapFunctionsVB Lib "DTOOLS7_x64.XLL" Alias "SwapFunctionsVB" (ByVal isSwapOut&, ByVal samplingMode&, ByVal hiddenMode&, ByRef completed&) As Long
   Private Declare PtrSafe Sub Dtools_UninitializeXlaInformation Lib "DTOOLS7_x64.XLL" Alias "UninitializeXlaInformation2" (ByVal appId As Integer, ByVal restoreCOMMessageFilter As Long)
   Private Declare PtrSafe Function Dtools_WriteRsklibDataIntoWorkbook& Lib "DTOOLS7_x64.XLL" Alias "WriteRsklibDataIntoWorkbook" (ByVal wb As Workbook, ByRef successCode%)
   Private Declare PtrSafe Function Dtools_RiskFindInputPrecedentsForCellVB Lib "DTOOLS7_x64.XLL" Alias "RiskFindInputPrecedentsForCellVB" (ByVal cell As Range) As Long()
   Private Declare PtrSafe Function Dtools_RiskGetModelCellTokenTypes& Lib "DTOOLS7_x64.XLL" Alias "RiskGetModelCellTokenTypes" (ByVal channelNum%, ByRef cellAddrs() As Range, ByRef cellTokenTypes() As Long)
   Private Declare PtrSafe Sub Dtools_RiskOptSaveAdjustableCellRanges Lib "DTOOLS7_x64.XLL" Alias "RiskOptSaveAdjustableCellRanges" (ByRef adjustableCells() As Range)
   Private Declare PtrSafe Sub Dtools_DtoolsReregisterFunctions Lib "DTOOLS7_x64.XLL" Alias "DtoolsReregisterFunctions" (ByVal p_ApplicationID As Integer)
   
#Else
   
   'WINDOWS API DECLARES:
   Private Declare Function AllowSetForegroundWindow Lib "user32" (ByVal dwProcessId&) As Long
   Private Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
   Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
   Private Declare Function CreateMutex Lib "kernel32" Alias "CreateMutexA" (ByVal lpMutexAttributes As Long, ByVal bInitialOwner As Long, ByVal lpName As String) As Long
   Private Declare Function OpenMutex Lib "kernel32" Alias "OpenMutexA" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal lpName As String) As Long
   Private Declare Function SetForegroundWindowAPI Lib "user32" Alias "SetForegroundWindow" (ByVal hwnd As Long) As Long
   Private Const MUTEX_ALL_ACCESS As Long = &H1F0001

   'DTOOLS DECLARES:
   Private Declare Sub Dtools_DeleteRsklibDataFromWorkbook Lib "DTOOLS7_x86.XLL" Alias "DeleteRsklibDataFromWorkbook" (ByVal wb As Workbook)
   Private Declare Sub Dtools_DeleteSwappedHiddenSheets Lib "DTOOLS7_x86.XLL" Alias "DeleteSwappedHiddenSheets" ()
   Private Declare Function Dtools_ExtractSimNumFromFormulaVB& Lib "DTOOLS7_x86.XLL" Alias "ExtractSimNumFromFormulaVB" (ByVal sourceCell As Range, ByVal formula As Long, ByVal formulaIsInLocalLanguage As Long, ByRef simNum As Long)
   Private Declare Function DtoolsW_GenerateCorrelatedDataFromInputs& Lib "DTOOLS7_x86.XLL" Alias "GenerateCorrelatedDataFromInputsW" (ByVal inputName1String As Long, ByVal inputName2String As Long, ByVal numPoints&, ByVal corrCoeff#, ByRef data1#(), ByRef data2#())
   Private Declare Function DtoolsW_GenerateSnapshotFromRiskCompound Lib "DTOOLS7_x86.XLL" Alias "GenerateSnapshotFromRiskCompoundW" (ByVal compoundDistNameString As Long, ByVal frequencyDistNameString As Long, ByVal severityDistNameString As Long, ByVal frequencyValue#, ByVal numPoints&, ByRef snapshotHandle#) As Long
   Private Declare Function Dtools_GetCellRefFunctionRanges Lib "DTOOLS7_x86.XLL" Alias "GetCellRefFunctionRanges" (ByVal channelNum%, ByVal functionTokenTypes&, ByRef rangeObjs() As Range) As Long
   Private Declare Function Dtools_GetDtoolsInstanceId Lib "DTOOLS7_x86.XLL" Alias "GetDtoolsInstanceId" () As Long
   Private Declare Function Dtools_GetExcelModelCellsWithTokenTypesRanges Lib "DTOOLS7_x86.XLL" Alias "GetExcelModelCellsWithTokenTypesRanges" (ByVal channelNum As Integer, ByVal tokenTypes As Long, ByRef rangeObjs() As Range) As Long
   Private Declare Function DtoolsW_GetExceptionInfoVB Lib "DTOOLS7_x86.XLL" Alias "GetExceptionInfoWVB" (ByVal exceptionId As Long, ByVal exceptionNameString As Long, ByVal methodNameString As Long, ByVal messageString As Long) As Long
   Private Declare Function Dtools_GetInputOrOutputRanges Lib "DTOOLS7_x86.XLL" Alias "GetInputOrOutputRanges" (ByVal channelNum As Integer, ByVal dataType As Integer, ByRef p_Ranges() As Range) As Long
   Private Declare Function Dtools_GetRsklibDataSize Lib "DTOOLS7_x86.XLL" Alias "GetRsklibDataSize" (ByRef fileSize As Double) As Long
   Private Declare Function DtoolsW_IdentifyDataSource% Lib "DTOOLS7_x86.XLL" Alias "IdentifyDataSourceW" (ByVal hVars&, ByVal channelNum%, ByVal dataSourceString As Long, ByVal dataSourceIsCellReference%, ByRef dataType%, ByRef dataIndex&, ByRef found As Integer)
   Private Declare Sub DtoolsW_InitializeXlaInformation Lib "DTOOLS7_x86.XLL" Alias "InitializeXlaInformationW" (ByVal xlApplication As Object, ByVal ObjectLibrary As Object, ByVal appId As Integer, ByVal fullyQualifiedXlaFileNameString As Long, ByVal languageID As Long, ByVal appVersionString As Long, ByVal p_AuthorizationHandle As Long, ByVal p_RemoveCOMMessageFilter As Long)
   Private Declare Function DtoolsW_MakeAllInputsIdentifiers Lib "DTOOLS7_x86.XLL" Alias "MakeAllInputsIdentifiersW" (ByVal badCellAddrString As Long, ByVal badInput1String As Long, ByVal badInput2String As Long) As Long
   Private Declare Function Dtools_ReadRsklibDataFromWorkbook& Lib "DTOOLS7_x86.XLL" Alias "ReadRsklibDataFromWorkbook" (ByVal wb As Workbook, ByRef successCode%)
   Private Declare Function DtoolsW_ResolveFormulaVB Lib "DTOOLS7_x86.XLL" Alias "ResolveFormulaWVB" (ByVal p_Range As Range, ByVal p_FormulaString As Long, ByVal p_RemovePropertyFunctions As Long, ByVal p_FormulaInLocalLanguage As Long) As Long
   Private Declare Sub Dtools_RiskAboutToDisplayFunctionWizard Lib "DTOOLS7_x86.XLL" Alias "RiskAboutToDisplayFunctionWizard" ()
   Private Declare Function DtoolsW_Risk4FindLabelVB Lib "DTOOLS7_x86.XLL" Alias "Risk4FindLabelWVB" (ByVal inputCell As Range, ByVal defaultNameString As Long, ByRef rowHeaderCell As Range, ByRef colHeaderCell As Range) As Integer
   Private Declare Sub Dtools_Risk5SetCellLabelSearchRanges Lib "DTOOLS7_x86.XLL" Alias "Risk5SetCellLabelSearchRanges" (ByRef searchRanges() As Range)
   Private Declare Function Dtools_RiskCellIsFormattedAsDate Lib "DTOOLS7_x86.XLL" Alias "RiskCellIsFormattedAsDate" (ByVal cell As Range) As Boolean
   Private Declare Function Dtools_RiskCellTokenTestingState& Lib "DTOOLS7_x86.XLL" Alias "RiskCellTokenTestingState" (ByVal newState As Boolean)
   Private Declare Function Dtools_RiskCheckCorrelationMatrix Lib "DTOOLS7_x86.XLL" Alias "RiskCheckCorrelationMatrix" (ByVal matrixDim As Long, ByRef corrmat As Double, ByRef weights As Double, ByRef correctedMatrix As Double, ByRef wasCorrected As Integer) As Long
   Private Declare Function Dtools_RiskDoingEvaluate Lib "DTOOLS7_x86.XLL" Alias "RiskDoingEvaluate" (ByVal p_Evaluating As Integer) As Integer
   Private Declare Function Dtools_RiskFindInputsAndOutputs Lib "DTOOLS7_x86.XLL" Alias "RiskFindInputsAndOutputs" (ByVal startingSimulation%, ByVal collectState%) As Long
   Private Declare Function Dtools_RiskGetCurrentSimResultsAppId Lib "DTOOLS7_x86.XLL" Alias "RiskGetCurrentSimResultsAppId" () As Integer  '0 = @RISK
   Private Declare Sub DtoolsW_RiskGetDistributionDescriptionString Lib "DTOOLS7_x86.XLL" Alias "RiskGetDistributionDescriptionStringW" (ByVal p_DistNameString As Long, ByVal p_LanguageID As Long, ByVal p_DescriptionString As Long)
   Private Declare Sub Dtools_RiskGetFunctionWizardFormulaVB Lib "DTOOLS7_x86.XLL" Alias "RiskGetFunctionWizardFormulaVB" (ByVal startingFormulaBarText$, ByRef functionWizardWindowHandle As Long, ByRef functionWizardFormula$, ByRef functionWizardFormulaName$, ByRef functionWizardFormulaUnits$, ByRef formulaBarWindowHandle&, ByRef formulaBarText$, ByRef unresolvedDistributionFormula$)
   Private Declare Function Dtools_RiskGetFunctionWizardWindowHandle Lib "DTOOLS7_x86.XLL" Alias "RiskGetFunctionWizardWindowHandle" () As Long
   Private Declare Function Dtools_RiskGetInputNameAndAddressFromIndex% Lib "DTOOLS7_x86.XLL" Alias "RiskGetInputNameAndAddressFromIndex" (ByVal Index&, ByVal theName$, ByVal cellAddr$)
   Private Declare Function DtoolsW_RiskGetInputNameAndAddressFromIndex% Lib "DTOOLS7_x86.XLL" Alias "RiskGetInputNameAndAddressFromIndexW" (ByVal Index&, ByVal theNameString As Long, ByVal cellAddrString As Long)
   Private Declare Function Dtools_RiskGetNumCPUs Lib "DTOOLS7_x86.XLL" Alias "RiskGetNumCpus" () As Long
   Private Declare Function DtoolsW_RiskGetOutputNameAndAddressFromIndex% Lib "DTOOLS7_x86.XLL" Alias "RiskGetOutputNameAndAddressFromIndexW" (ByVal Index&, ByVal theNameString As Long, ByVal cellAddrString As Long)
   Private Declare Function Dtools_RiskInsertFormulaBarText& Lib "DTOOLS7_x86.XLL" Alias "RiskInsertFormulaBarText" (ByVal Text$, ByVal where%, ByVal charPos%)
   Private Declare Function DtoolsW_RiskInsertFormulaBarText& Lib "DTOOLS7_x86.XLL" Alias "RiskInsertFormulaBarTextW" (ByVal TextString As Long, ByVal where%, ByVal charPos%)
   Private Declare Sub Dtools_RiskUpdateWorkbookGuids Lib "DTOOLS7_x86.XLL" Alias "RiskUpdateWorkbookGuids" (ByVal channelNum%)
   Private Declare Function Dtools_RunSim5 Lib "DTOOLS7_x86.XLL" Alias "RunSim5" (ByRef ResultsAvailable As Integer, ByRef Cancelled As Integer) As Long
   Private Declare Sub DtoolsW_SetArrayFormulaEnglishVB Lib "DTOOLS7_x86.XLL" Alias "SetArrayFormulaEnglishWVB" (ByVal arrayRange As Range, ByVal FormulaString As Long)
   Private Declare Function Dtools_RiskSetEffectiveSimNum Lib "DTOOLS7_x86.XLL" Alias "RiskSetEffectiveSimNum" (ByVal effectiveSimNum As Long) As Long
   Private Declare Function Dtools_RiskSetProjectFieldValueDataVB% Lib "DTOOLS7_x86.XLL" Alias "RiskSetProjectFieldValueDataVB" (ByVal initializeOrUpdate%, ByVal startingCell As Range, ByRef data() As Variant)
   'Private Declare Sub DtoolsW_RiskSetProjectIgnoredRanges Lib "DTOOLS7_x86.XLL" Alias "RiskSetProjectIgnoredRangesW" (ByRef projectIgnoredRangeNames() As Variant)
   Private Declare Sub DtoolsW_RiskSetProjectIgnoredRanges Lib "DTOOLS7_x86.XLL" Alias "RiskSetProjectIgnoredRangesW" (ByVal projectIgnoredRangeNames As Variant)

'   'MultiCoreUsage: 0 = No, -1 = Auto (I pick whether to use multiple cores or not, and if so, how many), 1, 2, 3... = use that many cores.
'   Private Declare Function DtoolsW_SetupSim75 Lib "DTOOLS7_x86.XLL" Alias "SetupSim75" (ByVal p_MultiCoreUsage As Long, ByVal NumSimulations As Long, _
'      ByRef SimulationNamesStringArray() As Variant, ByVal NumIterations As Long, ByVal BeforeSimulationMacroString As Long, ByVal BeforeIterationMacroString As Long, ByVal AfterIterationMacroString As Long, _
'      ByVal AfterSimulationMacroString As Long, ByVal AfterSimulationPrivateMacroString As Long, ByVal PauseOnErr As Long, ByVal UpdateDisplay As Long, _
'      ByVal RandomNumberGenerator As Long, ByVal Seed As Long, ByVal useSameRandomNumberStreamForEachSim As Long, ByVal SamplingType As Long, ByVal SaveSamplesMode As Long, _
'      ByVal RealTimeUpdatePeriod As Long, ByVal ConvergenceTestingEnabled As Long, ByVal ConvergenceTestingPeriod As Long, _
'      ByVal ConvergenceTestAllOutputs As Long, ByVal ConvergenceTolerance As Double, ByVal ConvergenceConfidenceLevel As Double, ByVal ConvergenceMeanTest As Long, _
'      ByVal ConvergenceStdDeviationTest As Long, ByVal ConvergencePercentileTest As Long, ByVal ConvergencePercentileToTest As Double, ByVal IsAdvancedAnalysis As Long, _
'      ByVal SmartSensitivityAnalysisEnabled As Long, ByVal UpdateStatisticFunctionsMethod As Long, ByVal MacroRecalcSamplingMode As Long, _
'      ByVal p_ShowProgressOnStatusBar As Long, ByRef Cancelled As Integer _
'   ) As Long
   
   'MultiCoreUsage: 0 = No, -1 = Auto (I pick whether to use multiple cores or not, and if so, how many), 1, 2, 3... = use that many cores.
   Private Declare Function DtoolsW_SetupSim75 Lib "DTOOLS7_x86.XLL" Alias "SetupSim75" (ByVal p_MultiCoreUsage As Long, ByVal NumSimulations As Long, _
      ByVal SimulationNamesStringArray As Variant, ByVal NumIterations As Long, ByVal BeforeSimulationMacroString As Long, ByVal BeforeIterationMacroString As Long, ByVal AfterIterationMacroString As Long, _
      ByVal AfterSimulationMacroString As Long, ByVal AfterSimulationPrivateMacroString As Long, ByVal PauseOnErr As Long, ByVal UpdateDisplay As Long, _
      ByVal RandomNumberGenerator As Long, ByVal Seed As Long, ByVal useSameRandomNumberStreamForEachSim As Long, ByVal SamplingType As Long, ByVal SaveSamplesMode As Long, _
      ByVal RealTimeUpdatePeriod As Long, ByVal ConvergenceTestingEnabled As Long, ByVal ConvergenceTestingPeriod As Long, _
      ByVal ConvergenceTestAllOutputs As Long, ByVal ConvergenceTolerance As Double, ByVal ConvergenceConfidenceLevel As Double, ByVal ConvergenceMeanTest As Long, _
      ByVal ConvergenceStdDeviationTest As Long, ByVal ConvergencePercentileTest As Long, ByVal ConvergencePercentileToTest As Double, ByVal IsAdvancedAnalysis As Long, _
      ByVal SmartSensitivityAnalysisEnabled As Long, ByVal UpdateStatisticFunctionsMethod As Long, ByVal MacroRecalcSamplingMode As Long, _
      ByVal p_ShowProgressOnStatusBar As Long, ByRef Cancelled As Integer _
   ) As Long
   
   Private Declare Function Dtools_SwapFunctionsVB Lib "DTOOLS7_x86.XLL" Alias "SwapFunctionsVB" (ByVal isSwapOut&, ByVal samplingMode&, ByVal hiddenMode&, ByRef completed&) As Long
   Private Declare Sub Dtools_UninitializeXlaInformation Lib "DTOOLS7_x86.XLL" Alias "UninitializeXlaInformation2" (ByVal appId As Integer, ByVal restoreCOMMessageFilter As Long)
   Private Declare Function Dtools_WriteRsklibDataIntoWorkbook& Lib "DTOOLS7_x86.XLL" Alias "WriteRsklibDataIntoWorkbook" (ByVal wb As Workbook, ByRef successCode%)
   Private Declare Function Dtools_RiskFindInputPrecedentsForCellVB Lib "DTOOLS7_x86.XLL" Alias "RiskFindInputPrecedentsForCellVB" (ByVal cell As Range) As Long()
   Private Declare Function Dtools_RiskGetModelCellTokenTypes& Lib "DTOOLS7_x86.XLL" Alias "RiskGetModelCellTokenTypes" (ByVal channelNum%, ByRef cellAddrs() As Range, ByRef cellTokenTypes() As Long)
   Private Declare Sub Dtools_RiskOptSaveAdjustableCellRanges Lib "DTOOLS7_x86.XLL" Alias "RiskOptSaveAdjustableCellRanges" (ByRef adjustableCells() As Range)
   Private Declare Sub Dtools_DtoolsReregisterFunctions Lib "DTOOLS7_x86.XLL" Alias "DtoolsReregisterFunctions" (ByVal p_ApplicationID As Integer)
   
#End If

''Convert an array of Strings to an array of Variants each holding an array of Integers.
''This is used to pass arrays of string to DLLs without being subject to the ANSIfication process normally applied to strings in declared functions.
''The array of Integers all start at index = 1.
''The array of VARIANTS starts at the same index as the original array of Strings.
''The output arrays of Integers do NOT have a trailing NULL.
'Private Function IntegerArrayFromStringArray(ByRef a() As String) As Variant()
'   Dim t() As Variant
'   Dim i As Long
'   Dim j As Long
'   Dim w() As Integer
'
'
'   On Error Resume Next
'   ReDim t(LBound(a) To UBound(a)) As Variant
'   If Err <> 0 Then GoTo exitPoint 'An empty array
'   On Error GoTo 0
'
'   For i = LBound(a) To UBound(a)
'      ReDim w(1 To Len(a(i))) As Integer
'      For j = 1 To Len(a(i))
'         w(j) = AscW(Mid$(a(i), j, 1))
'      Next j
'      t(i) = w
'   Next i
'
'exitPoint:
'   IntegerArrayFromStringArray = t
'End Function



'***********************************************************************************************************************************************
'Initialization and Shutdown:

'This function loads the dtools xll and returns its instance HVars to the caller, or zero if it failed to load.
Public Function InitializeXLL(ByVal p_XLLPath As String, ByVal p_RequiredDtoolsVersion As Long, ByVal p_DtoolsProgramIdentifier As Long, ByVal p_ProgramVersion As String, ByVal p_ProgramLanguage As Long, ByVal p_AuthorizationHandle As Long, ByVal p_ObjectLibraryIsInExcelProcess As Boolean, ByVal p_ObjectLibraryReference As Object) As Long
   Dim rc As Long
   Dim dtVersion As Long
   Dim errOccurred As Boolean
                                                                                                                                                                                  
   'Get the currently loaded version of Dtools (if any).  If version 0, this means no version is loaded, and I can proceed to load the xll.  If its returns the version I know I want,
   'it means what I want is already loaded.  I simply skip the step of loading Dtools and proceed to initialize the addin.  Anything else is an error:
   dtVersion = LoadedDtoolsVersion()
   If Not ((dtVersion = 0) Or (dtVersion = p_RequiredDtoolsVersion)) Then GoTo exitPoint
                        
   'If Dtools isn't loaded, load it and register it:
   If (dtVersion = 0) Then
      On Error Resume Next
      LoadLibrary p_XLLPath
      Application.RegisterXLL p_XLLPath
      errOccurred = (Err <> 0)
      On Error GoTo 0
      If errOccurred Then GoTo exitPoint
      If (LoadedDtoolsVersion() <> p_RequiredDtoolsVersion) Then GoTo exitPoint
   End If

   'Now tell the XLL about the add-in loading it so it knows I'm here.
   '2/4/2015.  I now use a version of this call that let's me turn off the "COMMEssageFilter".  This should only be done in RISKOL is in out of process mode:
   'Dtools_InitializeXlaInformation Application, p_ObjectLibraryReference, p_DtoolsProgramIdentifier, ThisWorkbook.FullName, p_ProgramLanguage, p_ProgramVersion, p_AuthorizationHandle, IIf(p_ObjectLibraryIsInExcelProcess, 0, 1)
   DtoolsW_InitializeXlaInformation Application, p_ObjectLibraryReference, p_DtoolsProgramIdentifier, VarPtr(ThisWorkbook.FullName), p_ProgramLanguage, VarPtr(p_ProgramVersion), p_AuthorizationHandle, IIf(p_ObjectLibraryIsInExcelProcess, 0, 1)
            
   m_XLLLoaded = True
      
   'Finally, we are done and things were successful.  Return the non-zero hVars to the caller:
   rc = Dtools_GetDtoolsInstanceId()
   
exitPoint:
   InitializeXLL = rc
End Function

'2/4/2015.  I now use a version of this call that let's me restore the "COMMEssageFilter".  This should only be done in RISKOL is in out of process mode:
Public Sub InformXLLOfShutDown(ByVal p_DtoolsProgramIdentifier As Long, ByVal p_ObjectLibraryIsInExcelProcess As Boolean)
   If m_XLLLoaded Then
      Dtools_UninitializeXlaInformation p_DtoolsProgramIdentifier, IIf(p_ObjectLibraryIsInExcelProcess, 0, 1)
      m_XLLLoaded = False
   End If
End Sub

'Returns the currently loaded version of Dtools if any.
'If this returns 0 -> no version is loaded, 3 -> Dtools32.xll is loaded, 5 -> Dtools5.xll is loaded, 6 -> Dtools6.xll is loaded, etc.
Private Function LoadedDtoolsVersion() As Long
   Dim rc As Long
      
   'Check if Dtools5.XLL is already loaded in the Excel application.  I do this by calling a test UDF function.
   On Error Resume Next
   rc = Application.Evaluate("=DtoolsVersion()")
   If (Err <> 0) Then rc = 0
   On Error GoTo 0
   
   'The DtoolsVersion() UDF didn't exist in the older Dtools32.xll, so I must look for it explicitly
   If (rc = 0) Then
      On Error Resume Next
      rc = Application.Evaluate("=RiskUniform(0,1)")
      If (Err = 0) Then rc = 3
      On Error GoTo 0
   End If
      
exitPoint:
   LoadedDtoolsVersion = rc
End Function

Public Property Get XLLLoaded() As Boolean
   XLLLoaded = m_XLLLoaded
End Property


'This routine is not strictly a call to the Dtools library, but it is very convenient to have it here.  It creates a mutex with the given name owned by the
'Excel process.  This is useful for "survival checking".  That is, a remote process can check for the existence of that mutex to see if the Excel process has
'died.  The return code is FALSE if the mutex could not be created.
Public Function CreateSurvivalMutex(ByVal p_MutexName As String) As Variant
   Dim rc As Variant
   
   rc = CreateMutex(0, 0, p_MutexName)
   
exitPoint:
   CreateSurvivalMutex = rc
End Function

Public Sub DestroySurvivalMutex(ByVal p_MutexHandle As Variant)
   If p_MutexHandle <> 0 Then CloseHandle p_MutexHandle
End Sub



'******************************************************************************************************************************************************************************************************
'Exception Handling:

Public Function GetExceptionInfoVB(ByVal exceptionId As Long, ByRef exceptionName As String, ByRef methodName As String, ByRef message As String) As Long
   'GetExceptionInfoVB = Dtools_GetExceptionInfoVB(exceptionId, exceptionName, methodName, message)
   GetExceptionInfoVB = DtoolsW_GetExceptionInfoVB(exceptionId, VarPtr(exceptionName), VarPtr(methodName), VarPtr(message))
End Function


'******************************************************************************************************************************************************************************************************
'Wrappers for Dtools Functions:

Public Sub DeleteRsklibDataFromWorkbook(ByVal p_Workbook As Workbook)
   Dtools_DeleteRsklibDataFromWorkbook p_Workbook
End Sub

Public Sub DeleteSwappedHiddenSheets()
   Dtools_DeleteSwappedHiddenSheets
End Sub

Public Sub DtoolsReregisterFunctions()
   If m_XLLLoaded Then Dtools_DtoolsReregisterFunctions 0 '0 = @RISK
End Sub

Public Function ExtractSimNumFromFormulaVB(ByVal sourceCell As Range, ByVal formula As String, ByVal formulaIsInLocalLanguage As Long, ByRef simNum As Long)
  ExtractSimNumFromFormulaVB = Dtools_ExtractSimNumFromFormulaVB(sourceCell, VarPtr(formula), formulaIsInLocalLanguage, simNum)
End Function

Public Function GenerateCorrelatedDataFromInputs(ByVal inputName1 As String, ByVal inputName2 As String, ByVal numPoints As Long, ByVal corrCoeff As Double, ByRef data1() As Double, ByRef data2() As Double) As Long
  'GenerateCorrelatedDataFromInputs = Dtools_GenerateCorrelatedDataFromInputs(inputName1, inputName2, numPoints, corrCoeff, data1, data2)
  GenerateCorrelatedDataFromInputs = DtoolsW_GenerateCorrelatedDataFromInputs(VarPtr(inputName1), VarPtr(inputName2), numPoints, corrCoeff, data1, data2)
End Function

Public Function GenerateSnapshotFromRiskCompound(ByVal compoundDistName As String, ByVal frequencyDistName As String, ByVal severityDistName As String, ByVal frequencyValue As Double, ByVal numPoints As Long, ByRef snapshotHandle As Double) As Long
   'GenerateSnapshotFromRiskCompound = Dtools_GenerateSnapshotFromRiskCompound(compoundDistName, frequencyDistName, severityDistName, frequencyValue, numPoints, snapshotHandle)
   GenerateSnapshotFromRiskCompound = DtoolsW_GenerateSnapshotFromRiskCompound(VarPtr(compoundDistName), VarPtr(frequencyDistName), VarPtr(severityDistName), frequencyValue, numPoints, snapshotHandle)
End Function

Public Function GetCellRefFunctionRanges(ByVal p_ChannelNum As Integer, ByVal p_FunctionTokenTypes As Long, ByRef p_RangeObjs() As Range) ' NEW
   GetCellRefFunctionRanges = Dtools_GetCellRefFunctionRanges(p_ChannelNum, p_FunctionTokenTypes, p_RangeObjs)
End Function

Public Function GetExcelModelCellsWithTokenTypesRanges(ByVal p_ChannelNum As Integer, ByVal p_TokenTypes As Long, ByRef p_RangeObjs() As Range) As Long
   GetExcelModelCellsWithTokenTypesRanges = Dtools_GetExcelModelCellsWithTokenTypesRanges(p_ChannelNum, p_TokenTypes, p_RangeObjs)
End Function

Public Function GetInputOrOutputRanges(ByVal p_ChannelNum As Integer, ByVal p_DataType As Integer, ByRef p_Ranges() As Range) As Long
   GetInputOrOutputRanges = Dtools_GetInputOrOutputRanges(p_ChannelNum, p_DataType, p_Ranges)
End Function

Public Function GetRsklibDataSize(ByRef fileSize As Double) As Long
   GetRsklibDataSize = Dtools_GetRsklibDataSize(fileSize)
End Function

Public Function IdentifyDataSource(ByVal hVars&, ByVal channelNum%, ByVal dataSource$, ByVal dataSourceIsCellReference%, ByRef dataType%, ByRef dataIndex&, ByRef found As Integer) As Integer
   'IdentifyDataSource = Dtools_IdentifyDataSource(hVars, channelNum, dataSource, dataSourceIsCellReference, dataType, dataIndex, found)
   IdentifyDataSource = DtoolsW_IdentifyDataSource(hVars, channelNum, VarPtr(dataSource), dataSourceIsCellReference, dataType, dataIndex, found)
End Function

Public Function MakeAllInputsIdentifiers(ByRef badCellAddr As String, ByRef badInput1 As String, ByRef badInput2 As String) As Long
   'MakeAllInputsIdentifiers = Dtools_MakeAllInputsIdentifiers(badCellAddr, badInput1, badInput2)
   MakeAllInputsIdentifiers = DtoolsW_MakeAllInputsIdentifiers(VarPtr(badCellAddr), VarPtr(badInput1), VarPtr(badInput2))
End Function

Public Function ReadRsklibDataFromWorkbook(ByVal p_Workbook As Workbook, ByRef successCode As Integer) As Long
   ReadRsklibDataFromWorkbook = Dtools_ReadRsklibDataFromWorkbook(p_Workbook, successCode)
End Function

Public Function ResolveFormulaVB(ByVal p_Range As Range, ByRef p_Formula As String, ByVal p_RemovePropertyFunctions As Long, ByVal p_FormulaInLocalLanguage As Long) As Long
   'ResolveFormulaVB = Dtools_ResolveFormulaVB(p_Range, p_Formula, p_RemovePropertyFunctions, p_FormulaInLocalLanguage)
   ResolveFormulaVB = DtoolsW_ResolveFormulaVB(p_Range, VarPtr(p_Formula), p_RemovePropertyFunctions, p_FormulaInLocalLanguage)
End Function

Public Function Risk4FindLabelVB(ByVal p_InputCell As Range, ByRef p_DefaultName As String, ByRef p_RowHeaderCell As Range, ByRef p_ColHeaderCell As Range) As Integer
   'Risk4FindLabelVB = Dtools_Risk4FindLabelVB(p_InputCell, p_DefaultName, p_RowHeaderCell, p_ColHeaderCell)
   Risk4FindLabelVB = DtoolsW_Risk4FindLabelVB(p_InputCell, VarPtr(p_DefaultName), p_RowHeaderCell, p_ColHeaderCell)
End Function

Public Function RiskAboutToDisplayFunctionWizard()
   Dtools_RiskAboutToDisplayFunctionWizard
End Function

Public Sub Risk5SetCellLabelSearchRanges(ByRef searchRanges() As Range)
  Dtools_Risk5SetCellLabelSearchRanges searchRanges
End Sub

Public Function RiskCellIsFormattedAsDate(ByVal theCell As Range) As Boolean
  RiskCellIsFormattedAsDate = Dtools_RiskCellIsFormattedAsDate(theCell)
End Function

Public Function RiskCellTokenTestingState&(ByVal newState As Boolean)
   RiskCellTokenTestingState = Dtools_RiskCellTokenTestingState(newState)
End Function

Public Function RiskCheckCorrelationMatrix(ByVal matrixDim As Long, ByRef corrmat As Double, ByRef weights As Double, ByRef correctedMatrix As Double, ByRef wasCorrected As Integer) As Long
   RiskCheckCorrelationMatrix = Dtools_RiskCheckCorrelationMatrix(matrixDim, corrmat, weights, correctedMatrix, wasCorrected)
End Function

Public Function RiskDoingEvaluate(ByVal p_Evaluating As Integer) As Integer
   RiskDoingEvaluate = Dtools_RiskDoingEvaluate(p_Evaluating)
End Function

Public Function RiskFindInputPrecedentsForCellVB(ByVal theCell As Range) As Long()
   RiskFindInputPrecedentsForCellVB = Dtools_RiskFindInputPrecedentsForCellVB(theCell)
End Function

Public Function RiskFindInputsAndOutputs(ByVal channelNum As Integer, ByVal collectState As Integer) As Long
   RiskFindInputsAndOutputs = Dtools_RiskFindInputsAndOutputs(channelNum, collectState)
End Function

Public Sub RiskGetFunctionWizardFormulaVB(ByVal startingFormulaBarText As String, ByRef functionWizardWindowHandle As Long, ByRef functionWizardFormula As String, ByRef functionWizardFormulaName As String, ByRef functionWizardFormulaUnits As String, ByRef formulaBarWindowHandle As Long, ByRef formulaBarText As String, ByRef unresolvedDistributionFormula As String)
   'A Unicode enabled version of this function exists in Dtools, but I'm not sure if anyone calls this function, so I didn't convert it over (since I had no way to test it.)
   Dtools_RiskGetFunctionWizardFormulaVB startingFormulaBarText, functionWizardWindowHandle, functionWizardFormula, functionWizardFormulaName, functionWizardFormulaUnits, formulaBarWindowHandle, formulaBarText, unresolvedDistributionFormula
End Sub

Public Function RiskGetCurrentSimResultsAppId() As Integer
   If m_XLLLoaded Then RiskGetCurrentSimResultsAppId = Dtools_RiskGetCurrentSimResultsAppId()
End Function

Public Function RiskGetDistributionDescriptionString(ByVal p_DistName As String, ByVal p_LanguageID As Long) As String
   'RiskGetDistributionDescriptionString = Dtools_RiskGetDistributionDescriptionString(p_DistName, p_LanguageID)
   Dim rc As String
   DtoolsW_RiskGetDistributionDescriptionString VarPtr(p_DistName), p_LanguageID, VarPtr(rc)
   RiskGetDistributionDescriptionString = rc
End Function

Public Function RiskGetFunctionWizardWindowHandle() As Long
   RiskGetFunctionWizardWindowHandle = Dtools_RiskGetFunctionWizardWindowHandle()
End Function

Public Function RiskGetInputNameAndAddressFromIndex(ByVal Index As Long, ByRef theName As String, ByRef cellAddr As String) As Integer
   'RiskGetInputNameAndAddressFromIndex = Dtools_RiskGetInputNameAndAddressFromIndex(Index, theName, cellAddr)
   RiskGetInputNameAndAddressFromIndex = DtoolsW_RiskGetInputNameAndAddressFromIndex(Index, VarPtr(theName), VarPtr(cellAddr))
End Function

Public Function RiskGetModelCellTokenTypes(ByVal channelNum%, ByRef cellAddrs() As Range, ByRef cellTokenTypes() As Long) As Long
   RiskGetModelCellTokenTypes = Dtools_RiskGetModelCellTokenTypes(channelNum, cellAddrs, cellTokenTypes)
End Function

Public Function RiskGetNumCPUs() As Long
   RiskGetNumCPUs = Dtools_RiskGetNumCPUs()
End Function

Public Function RiskGetOutputNameAndAddressFromIndex(ByVal Index As Long, ByRef theName As String, ByRef cellAddr As String) As Integer
   'RiskGetOutputNameAndAddressFromIndex = Dtools_RiskGetOutputNameAndAddressFromIndex(Index, theName, cellAddr)
   RiskGetOutputNameAndAddressFromIndex = DtoolsW_RiskGetOutputNameAndAddressFromIndex(Index, VarPtr(theName), VarPtr(cellAddr))
End Function

Public Function RiskInsertFormulaBarText(ByVal Text As String, ByVal where As Integer, ByVal charPos As Integer) As Long
   'RiskInsertFormulaBarText = Dtools_RiskInsertFormulaBarText(Text, where, charPos)
   RiskInsertFormulaBarText = DtoolsW_RiskInsertFormulaBarText(VarPtr(Text), where, charPos)
End Function

Public Sub RiskOptSaveAdjustableCellRanges(ByRef adjustableCells() As Range)
  Dtools_RiskOptSaveAdjustableCellRanges adjustableCells
End Sub

Public Function RiskSetEffectiveSimNum(ByVal effectiveSimNum As Long) As Long
   If m_XLLLoaded Then
      RiskSetEffectiveSimNum = Dtools_RiskSetEffectiveSimNum(effectiveSimNum)
   End If
End Function

Public Function RiskSetProjectFieldValueDataVB(ByVal initializeOrUpdate%, ByVal startingCell As Range, ByRef data() As Variant) As Integer
   RiskSetProjectFieldValueDataVB = Dtools_RiskSetProjectFieldValueDataVB(initializeOrUpdate%, startingCell, data)
End Function

Public Sub RiskSetProjectIgnoredRanges(ByRef projectIgnoredRangeNames() As String)
  
  'DtoolsW_RiskSetProjectIgnoredRanges IntegerArrayFromStringArray(projectIgnoredRangeNames)
  DtoolsW_RiskSetProjectIgnoredRanges CVar(projectIgnoredRangeNames)
End Sub

Public Sub RiskUpdateWorkbookGuids(ByVal channelNum As Integer)
   Dtools_RiskUpdateWorkbookGuids channelNum
End Sub

Public Function RunSim5(ByRef ResultsAvailable As Integer, ByRef Cancelled As Integer) As Long
   RunSim5 = Dtools_RunSim5(ResultsAvailable, Cancelled)
End Function

Public Sub SetArrayFormulaEnglishVB(ByVal p_ArrayRange As Range, ByVal p_Formula As String)
   'Dtools_SetArrayFormulaEnglishVB p_ArrayRange, p_Formula
   DtoolsW_SetArrayFormulaEnglishVB p_ArrayRange, VarPtr(p_Formula)
End Sub

Public Function SetupSim75(ByVal p_MultiCoreUsage As Long, ByVal NumSimulations As Long, ByRef SimulationNames() As String, ByVal NumIterations As Long, ByVal BeforeSimulationMacro As String, ByVal BeforeIterationMacro As String, ByVal AfterIterationMacro As String, ByVal AfterSimulationMacro As String, ByVal AfterSimulationPrivateMacro As String, _
   ByVal PauseOnErr As Long, UpdateDisplay As Long, RandomNumberGenerator As Long, ByVal Seed As Long, ByVal useSameRandomNumberStreamForEachSim As Long, ByVal SamplingType As Long, _
   ByVal SaveSamplesMode As Long, ByVal RealTimeUpdatePeriod As Long, ByVal ConvergenceTestingEnabled As Long, ByVal ConvergenceTestingPeriod As Long, _
   ByVal ConvergenceTestAllOutputs As Long, ByVal ConvergenceTolerance As Double, ByVal ConvergenceConfidenceLevel As Double, ByVal ConvergenceMeanTest As Long, _
   ByVal ConvergenceStdDeviationTest As Long, ByVal ConvergencePercentileTest As Long, ByVal ConvergencePercentileToTest As Double, ByVal IsAdvancedAnalysis As Long, _
   ByVal SmartSensitivityAnalysisEnabled As Long, ByVal UpdateStatisticFunctionsMethod As Long, ByVal MacroRecalcSamplingMode As Long, ByVal ShowProgressOnStatusBar As Long, ByRef Cancelled As Integer) As Long

   
'   SetupSim75 = DtoolsW_SetupSim75( _
'      p_MultiCoreUsage, NumSimulations, IntegerArrayFromStringArray(SimulationNames), NumIterations, VarPtr(BeforeSimulationMacro), VarPtr(BeforeIterationMacro), _
'      VarPtr(AfterIterationMacro), VarPtr(AfterSimulationMacro), VarPtr(AfterSimulationPrivateMacro), PauseOnErr, UpdateDisplay, RandomNumberGenerator, Seed, _
'      useSameRandomNumberStreamForEachSim, SamplingType, SaveSamplesMode, RealTimeUpdatePeriod, ConvergenceTestingEnabled, ConvergenceTestingPeriod, _
'      ConvergenceTestAllOutputs, ConvergenceTolerance, ConvergenceConfidenceLevel, ConvergenceMeanTest, ConvergenceStdDeviationTest, ConvergencePercentileTest, _
'      ConvergencePercentileToTest, IsAdvancedAnalysis, SmartSensitivityAnalysisEnabled, UpdateStatisticFunctionsMethod, MacroRecalcSamplingMode, ShowProgressOnStatusBar, Cancelled _
'   )
   
   SetupSim75 = DtoolsW_SetupSim75( _
      p_MultiCoreUsage, NumSimulations, CVar(SimulationNames), NumIterations, VarPtr(BeforeSimulationMacro), VarPtr(BeforeIterationMacro), _
      VarPtr(AfterIterationMacro), VarPtr(AfterSimulationMacro), VarPtr(AfterSimulationPrivateMacro), PauseOnErr, UpdateDisplay, RandomNumberGenerator, Seed, _
      useSameRandomNumberStreamForEachSim, SamplingType, SaveSamplesMode, RealTimeUpdatePeriod, ConvergenceTestingEnabled, ConvergenceTestingPeriod, _
      ConvergenceTestAllOutputs, ConvergenceTolerance, ConvergenceConfidenceLevel, ConvergenceMeanTest, ConvergenceStdDeviationTest, ConvergencePercentileTest, _
      ConvergencePercentileToTest, IsAdvancedAnalysis, SmartSensitivityAnalysisEnabled, UpdateStatisticFunctionsMethod, MacroRecalcSamplingMode, ShowProgressOnStatusBar, Cancelled _
   )
   
End Function

Public Function SwapFunctionsVB(ByVal isSwapOut As Long, ByVal samplingMode As Long, ByVal hiddenMode As Long, ByRef completed As Long) As Long
   SwapFunctionsVB = Dtools_SwapFunctionsVB(isSwapOut&, samplingMode&, hiddenMode&, completed&)
End Function

Public Function WriteRskLibDataIntoWorkbook(ByVal p_Workbook As Workbook, ByRef p_SuccessCode As Integer) As Long
   WriteRskLibDataIntoWorkbook = Dtools_WriteRsklibDataIntoWorkbook(p_Workbook, p_SuccessCode)
End Function




'***********************************************************************************************************************************************
'Miscellaneous Helper Functions:

'Register the specified processID as one that is allowed to grab the foreground from this process:
Public Sub AllowProcessToComeToForeground(ByVal p_ProcessID As Long)
   AllowSetForegroundWindow p_ProcessID
End Sub

'For reasons I don't understand, I can't do this from VB6.  I must do this in VBA.
Public Function CBCUpdateName(ByVal p_Workbook As Workbook, ByVal p_Name As String, ByVal p_NewRefersTo As String) As Boolean
   Dim rc As Boolean
   
   On Error Resume Next
   p_Workbook.Names(p_Name).RefersTo = p_NewRefersTo
   rc = (Err = 0)
   On Error GoTo 0
   
exitPoint:
   CBCUpdateName = rc
End Function

Public Sub ExecuteDoEvents()
   DoEvents
End Sub

Public Function SetForegroundWindow(ByVal p_Hwnd As Variant) As Long
   #If Win64 Then
      SetForegroundWindow = SetForegroundWindowAPI(CLngPtr(p_Hwnd))
   #Else
      SetForegroundWindow = SetForegroundWindowAPI(CLng(p_Hwnd))
   #End If
End Function

Public Sub AddImagesToCommandBar(ByVal p_CommandBar As Object)
   On Error Resume Next
   CommandBarImages.AssignCommandBarImages p_CommandBar
   On Error GoTo 0
End Sub

'This routine was added to make this operation faster in 64-bit for Sam's RiskModel component (3/24/2016)
Public Sub ClearFormatCondition(ByRef p_Range As Range, p_ConditionName As String)
        
    Dim theFormatCondition As FormatCondition
    Dim thisCell As Range
    
    On Error Resume Next
    
    For Each thisCell In p_Range.Cells
        For Each theFormatCondition In thisCell.FormatConditions
          If Not theFormatCondition Is Nothing Then
            If theFormatCondition.Formula1 = "=" + p_ConditionName Then theFormatCondition.Delete
          End If
        Next
    Next
        
End Sub

'This routine was added to make this operation faster in 64-bit for Sam's RiskModel component (3/24/2016)
Public Function UnionRange(ByRef p_RangeObjs() As Range) As Range
   Dim newRange As Range
   Dim i As Long
   
   On Error Resume Next
   For i = 1 To UBound(p_RangeObjs)
     If newRange Is Nothing Then
       Set newRange = p_RangeObjs(i)
     Else
       Set newRange = Application.Union(newRange, p_RangeObjs(i))
     End If
   Next
   On Error GoTo 0
   
   Set UnionRange = newRange
End Function

'This routine was added to make this operation faster in 64-bit for Sam's RiskModel component (3/24/2016)
Public Sub UpdateCellColorsOnOpen()
   On Error Resume Next
   Risk.Internal.ModelServer.CellColoringOptionsChanged
   On Error GoTo 0
End Sub


'********************************************************************************************************************************************************************************
'Making calls directly from an out-of-process RISKOL to DN7 to display interface elements seems to have problems with things freezing intermittently, presumably due
'to threading issues.  These problems go away if instead RISKOL calls Excel via an out-of-process call, and Excel then makes the call to .NET.  That is the purpose of these calls.
'Basically, I now have the rule that ALL calls from RiskOL to DN7 must go through this interface.

Public Sub ExecuteRiskDNCommand(ByVal p_CommandName As String, Optional ByVal p_CommandParameter As Variant)
   On Error Resume Next
   RiskDN.ExecuteCommand p_CommandName, p_CommandParameter
   On Error GoTo 0
End Sub

Attribute VB_Name = "Internal"
Option Explicit
Option Private Module
                                                                                                                                                                                                                                               
Public Const VERSION_MAJOR As String = "7"
                                                                                                                                                                                                                                               
'***********************************************************************************************************************************
'Windows API
                                                                                                                                                                                                                                                
Private Const MUTEX_ALL_ACCESS As Long = &H1F0001
#If Win64 Then
   Private Declare PtrSafe Function OpenMutex Lib "kernel32" Alias "OpenMutexA" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal lpName As String) As LongLong
   Private Declare PtrSafe Function MessageBoxW Lib "user32" (ByVal hwnd As Long, ByVal lpTextStr As LongPtr, ByVal lpCaptionStr As LongPtr, ByVal wType As Long) As Long
#Else
   Private Declare Function OpenMutex Lib "kernel32" Alias "OpenMutexA" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal lpName As String) As Long
   Private Declare Function MessageBoxW Lib "user32" (ByVal hwnd As Long, ByVal lpTextStr As Long, ByVal lpCaptionStr As Long, ByVal wType As Long) As Long
#End If
                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                
'***********************************************************************************************************************************
'Module Level Variables:

Dim m_OOPS As Object
Dim m_RiskOL As AtRiskOL7.RiskOL
Dim m_Risk As AtRiskOL7.Risk
Dim m_RiskDN As Palisade_DecisionTools_RiskDN7.Root

'***********************************************************************************************************************************
'Library Initialization and Disposal:

Public Property Get AtRiskLibraryIsInitialized() As Boolean
   AtRiskLibraryIsInitialized = Not (m_RiskOL Is Nothing)
End Property

'This routine is responsible for the initial setup of the @RISK object library.
Public Sub InitializeAtRiskObjectLibrary()
   Dim makeOLInExcelProcess As Boolean
   
   'Create and initialize the @RISK Object Library (OL) Reference.
   'It can be loaded either in-process or out-of-process.  If it's the later, we need to make an "out-of-process" .EXE to host it.
   makeOLInExcelProcess = OLShouldBeInProcessWithExcel()
   If makeOLInExcelProcess Then
      Set m_RiskOL = CreateObject("AtRiskOL7.RiskOL")
   Else
      Set m_OOPS = CreateObject("RiskOutOfProcessServer7.ObjectCreator")
      Set m_RiskOL = m_OOPS.CreateCOMObject("AtRiskOL7.RiskOL")
   End If
   
   Dim dtCallbacks As New DtoolsCallbacks
   m_RiskOL.Initialize makeOLInExcelProcess, False, Application, ThisWorkbook, dtCallbacks
         
   'Store a reference to the frequently used .Risk child object:
   Set m_Risk = m_RiskOL.Risk
      
   'Create and initialize the @RISK .NET component.  This component is new for version 7.x of @RISK:
   If dtCallbacks.XLLLoaded Then
      Set m_RiskDN = New Palisade_DecisionTools_RiskDN7.Root
      m_RiskDN.Initialize m_RiskOL, Application
   End If
End Sub

Public Sub DisposeAtRiskLibrary()
   If Not (m_RiskDN Is Nothing) Then m_RiskDN.Dispose: Set m_RiskDN = Nothing
   Set m_Risk = Nothing
   If Not (m_RiskOL Is Nothing) Then m_RiskOL.Dispose: Set m_RiskOL = Nothing
   Set m_OOPS = Nothing
End Sub


'***********************************************************************************************************************************
'Property Functions to Get Library Objects:

Public Property Get RiskOL() As AtRiskOL7.RiskOL
   Set RiskOL = m_RiskOL
End Property

Public Property Get RiskObj() As AtRiskOL7.Risk
   Set RiskObj = m_Risk
End Property

Public Property Get RiskDN() As Palisade_DecisionTools_RiskDN7.Root
   Set RiskDN = m_RiskDN
End Property

Public Property Get RiskOOPsObj() As Object
   Set RiskOOPsObj = m_OOPS
End Property


'***********************************************************************************************************************************
'Miscellaneous:

Public Sub UnicodeMsgBox(ByVal p_Message As String)
   MessageBoxW Application.hwnd, StrPtr(p_Message), StrPtr("@RISK"), 0
End Sub

Public Sub ThrowException(ByVal p_Message As String, Optional ByVal p_ErrorCode As Long = 19)
   Err.Raise vbObjectError + p_ErrorCode, "@RISK", p_Message
End Sub

Public Function ExcelApplicationVersion() As Long
   Dim rc As Long
   Dim versionString As String
   Dim p As Integer
   
   versionString = Application.Version
   p = InStr(versionString, ".")
   If p <= 0 Then rc = 0: GoTo exitPoint
   
   On Error Resume Next
   rc = CInt(Left(versionString, p - 1))
   If Err <> 0 Then rc = 0
   On Error GoTo 0
   
exitPoint:
   ExcelApplicationVersion = rc
End Function

'Decide whether we are in- or out- of process.  64-bit versions of Excel are ALWAYS out-of-process.  Version 2010 of Excel and before are in-process,
'while 2013 is out-of-process.  We did this because 2013 adds a layer of security that doesn't allow the #Grid control (which we use extensively) to be
'used in it's process, while using it in an external process is fine.
Private Function OLShouldBeInProcessWithExcel() As Boolean
   Dim rc As Boolean
   
   #If Win64 Then
      rc = False
   #Else
      '7.5.2, 20170207, DEP-compatible grid
      'rc = (ExcelApplicationVersion <= 14)
      'rc = True
      rc = Not AppSettingsForceOutOfProcessServer_32BitExcel
   #End If
   
exitPoint:
   OLShouldBeInProcessWithExcel = rc
End Function
Attribute VB_Name = "MainModule"
Option Explicit
                                                                          
                                                                          
'************************************************************************************************************************************
'Addin Initialization:
                                                                                                                                                                                                                              
'This is the first routine that is called when @RISK opens.  The actual initialization of the product is deferred via an asynchronous timer
'to the "RiskInitialize" routine.  I do this because Excel can be very picky about what it lets you do during an Auto_Open routine.
Public Sub Auto_Open()
   
   'If I'm not actually an add-in (presumably because I'm debugging the source-code) the initialization doesn't happen:
   If Not ThisWorkbook.IsAddin Then Exit Sub
   
   'Make sure not to do anything here if the add-in is already initialized.  This can happen, for example, when the user checks the addin in the
   'Excel add-ins list to make it load automatically whenever Excel is launched.  Stupidly, Excel will call the initializer of the add-in a second time:
   If AtRiskLibraryIsInitialized Then Exit Sub
   
   'Call the deferred routine to actually do the initialization:
   Application.OnTime Now(), ThisWorkbook.Name & "!RiskInitialize"
End Sub

'This is the main routine that really initializes the progam.  (This must be public, since it is called via an OnTime macro.)
Public Sub RiskInitialize()
   
   On Error GoTo exitPoint
   Application.EnableCancelKey = xlDisabled
                              
   InitializeAtRiskObjectLibrary
                                                                            
exitPoint:
   'If an intialization error occurred, display the error to the user and then close down the add-in.  If the error is a "cancelled" error
   '(PalUtility's cancelled exception = objError+22), the user has asked not to boot the product for some reason, and the error should not be shown.
   If Err.Number <> 0 Then
      'If (Err.Number <> vbObjectError + 22) Then MsgBox Err.Description, vbOKOnly, "@RISK"
      If (Err.Number <> vbObjectError + 22) Then UnicodeMsgBox Err.Description
      Auto_Close
   End If
End Sub

'This callback occurs after the initialization is completed and control has returned to Excel.
'A few application setup tasks need to be performed only when this return of control to Excel has occurred.
Public Sub RiskCallback_InitializationCompleted()
   RiskOL.InitializationCompletedCallback
End Sub

Private Function CreateWorkbook() As Object
   Set CreateWorkbook = Application.Workbooks.Add()
End Function


'************************************************************************************************************************************
'Shutdown:

'This routine is called when the @RISK library is closed because because the user has done something in the Excel interface to do so.
'For example, closing down Excel, or unchecking the @RISK addin, etc.  Never do anything if I am not an add-in:
Public Sub Auto_Close()
   If ThisWorkbook.IsAddin Then ShutdownApplication True
End Sub

'This routine is called during the manual shutdown of @RISK by the user having chosen the Unload Addin command on the @RISK menu:
Public Sub RiskShutdown()
   ShutdownApplication False
End Sub

Private Sub ShutdownApplication(ByVal p_CalledFromAutoClose As Boolean)
   Static s_ShutdownInProgress As Boolean
   
   Application.EnableCancelKey = xlDisabled
   
   'It is possible that this routine can be called twice, which can lead to all sorts of trouble.  Block that from happening:
   If s_ShutdownInProgress Then Exit Sub
   s_ShutdownInProgress = True
         
   On Error Resume Next
                                   
   'Shutdown the @RISK object library:
   DisposeAtRiskLibrary
           
   '(10-20-2008) As part of the fix for Bug #2824, I hit Excel with a recalc here.
   '(12-11-2008) To address Bug #4382, I must not do this recalc when this is automatically closed
   If Not p_CalledFromAutoClose Then Application.CalculateFull
         
   'This routine can be called by the UnloadAddin function of RiskOL.dll, in which case at the end of it, the workbook won't actually be
   'closed.  Here I make sure this .xla file is indeed is closed.  This can trigger a recursive call to this routine.  But that's okay
   'because the s_ShutdownInProgress flag will be set.
   ThisWorkbook.Close
   
   On Error GoTo 0
End Sub


'************************************************************************************************************************************
'Public Interface:

'This returns the root @RISK automation object.  This is meant for internal Palisade use, so other components or applications can perform @RISK automation tasks:
Public Function RiskGetAutomationObject() As Object
   On Error Resume Next
   Set RiskGetAutomationObject = RiskObj
   On Error GoTo 0
End Function

'This routine is fired whenever an @RISK 2003-style CommandBar style menu or toolbar item is clicked.  Even though @RISK 7 no longer supports 2003,
'there are still old-style CommandBar menus (say the right-click menu cell popup menu, for example, or Sam's insert function menu from
'on his quick access toolbar) that still need this interface.
Public Sub RiskEvent_ExecuteCommand()
   Application.EnableCancelKey = xlDisabled
   DispatchCommand CommandBars.ActionControl.Parameter
End Sub

'This routine is fired off when a user clicks an @RISK item in the Excel 2007 or higher Ribbon command:
Public Sub RiskXLARibbonEvent_ExecuteCommand(ByVal p_ControlID As String)
   Application.EnableCancelKey = xlDisabled
   DispatchCommand p_ControlID
End Sub

'This routine is fired off when a user changes what is in a combo-box in the @RISK-Ribbon:
Public Sub RiskXLARibbonEvent_ComboBoxChanged(ByVal p_ControlID As String, ByVal p_NewValue As String)
   On Error Resume Next
   Application.EnableCancelKey = xlDisabled
   RiskOL.ExecuteRiskCommand p_ControlID & "@" & p_NewValue
   On Error GoTo 0
End Sub

'New with @RISK 7.0, some commands are now sent directly to RiskDN instead of RiskOL.  These all contain the prefix "RiskDNCommand_"
'This has the advantage for 64-bit Excel and 2013 in both 32- and 64-bit of being entirely in-process without going through an out-of-process layer in RiskOL.
Private Sub DispatchCommand(ByVal p_CommandName As String)
   If InStr(1, p_CommandName, "RiskDNCommand", vbTextCompare) > 0 Then
      RiskDN.ExecuteCommand p_CommandName
   Else
      RiskOL.ExecuteRiskCommand p_CommandName
   End If
End Sub

'This routine is fired off when the @RISK ribbon requests the contents of a dynamic menu:
Public Function RiskXLARibbonQuery_GetDynamicMenuContent(ByVal p_ControlID As String) As String
   RiskXLARibbonQuery_GetDynamicMenuContent = RiskOL.GetRibbonDynamicMenuContent(p_ControlID)
End Function

'This event fires off when the user clicks the TabKey in Excel (but only if that key has been designated as being "captured").
'This handler is turned on in RiskOL when appropriate.
Public Sub RiskEvent_TabKeyPressed()
   On Error Resume Next
   Application.EnableCancelKey = xlDisabled
   RiskOL.ExecuteRiskCommand "RiskEvent_TabKeyPressed@0", Nothing, False
   On Error GoTo 0
End Sub

'This event fires off when the user clicks the Shift/TabKey combination in Excel (but only if that key has been designated as being "captured")
'This handler is turned on in RiskOL when appropriate.
Public Sub RiskEvent_ShiftTabKeyPressed()
   On Error Resume Next
   Application.EnableCancelKey = xlDisabled
   RiskOL.ExecuteRiskCommand "RiskEvent_TabKeyPressed@1", Nothing, False
   On Error GoTo 0
End Sub

'When the user clicks on a Excel format graph with a watermark, this event is fired.
Public Sub RiskGraphClickEvent()
   On Error Resume Next
   Application.EnableCancelKey = xlDisabled
   RiskOL.ExecuteRiskCommand "RiskEvent_GraphWatermarkClick", , False
   On Error GoTo 0
End Sub

'This fires off when the user closes a workbook that has been specially marked by the RiskModel component (via RISKOL).  It is a "special" before save because
'this event fires off BEFORE the normal workbook close event.  Early enough that it is before certain warning messages that Excel displays on save when a workbook
'contains Excel 4.0 macros or names.
Public Sub RiskWorkbookSpecialBeforeSave()
   On Error Resume Next
   Risk.Internal.WorkbookSpecialBeforeSaveEventOccurred
   On Error GoTo 0
End Sub

'This event is called by Dtools.xll periodically during a simulation to inform @RISK when it should upate its live simulation windows.
Public Sub RiskEvent_UpdateSimulationWindows()
   On Error Resume Next
   RiskObj.Internal.UpdateSimulationWindows
   On Error GoTo 0
End Sub

Public Sub RiskCallback_AdvToolsBetweenSimulations()
   On Error Resume Next
   RiskObj.Internal.AdvToolsBetweenSimulations
   On Error GoTo 0
End Sub

Public Function RiskUnprotectSheet(ByVal p_WorkbookName As String, ByVal p_WorksheetName As String) As Boolean
   RiskUnprotectSheet = RiskObj.Internal.UnprotectSheet(p_WorkbookName, p_WorksheetName)
End Function

Public Sub RiskCallback_ConvertCBModel()
   Application.EnableCancelKey = xlDisabled
   RiskOL.ExecuteRiskCommand "RiskCallback_ConvertCBModel", , True
End Sub

Public Sub RiskDoEvents()
   DoEvents
End Sub

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Utilities"
Option Explicit
Option Private Module

Public Const ROOT_REGISTRY_PATH As String = "Software\Palisade\@RISK for Excel\" & VERSION_MAJOR & ".0"

#If Win64 Then
#Else
'7.5.2, need to determine whether to run in-process with 32-bit Excel 2013+
Private Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
Private Declare Function RegQueryValueExW Lib "advapi32.dll" (ByVal hKey As Long, ByVal lpValueNameString As Long, ByVal lpReserved As Long, lpType As Long, ByVal lpDataString As Long, lpcbData As Long) As Long
Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Private Const HKEY_CLASSES_ROOT As Long = &H80000000
Private Const HKEY_CURRENT_USER As Long = &H80000001
Private Const HKEY_LOCAL_MACHINE As Long = &H80000002
Private Const SYNCHRONIZE As Long = &H100000
Private Const REG_OPTION_NON_VOLATILE As Long = 0
Private Const REG_SZ As Long = 1
Private Const REG_EXPAND_SZ As Long = 2
Private Const REG_BINARY As Long = 3
Private Const REG_DWORD_LITTLE_ENDIAN As Long = 4
Private Const READ_CONTROL As Long = &H20000
Private Const STANDARD_RIGHTS_READ As Long = (READ_CONTROL)
Private Const STANDARD_RIGHTS_ALL As Long = &H1F0000
Private Const KEY_QUERY_VALUE As Long = &H1
Private Const KEY_SET_VALUE As Long = &H2
Private Const KEY_ENUMERATE_SUB_KEYS As Long = &H8
Private Const KEY_NOTIFY As Long = &H10
Private Const KEY_CREATE_LINK As Long = &H20
Private Const KEY_CREATE_SUB_KEY As Long = &H4
Private Const KEY_ALL_ACCESS As Long = ((STANDARD_RIGHTS_ALL Or KEY_QUERY_VALUE Or KEY_SET_VALUE Or KEY_CREATE_SUB_KEY Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY Or KEY_CREATE_LINK) And (Not SYNCHRONIZE))
Private Const KEY_READ As Long = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
Private Const ERROR_SUCCESS As Long = 0&
Private Const MAX_REG_DATA_SIZE As Integer = 2048
Private Const KEY_WOW64_64KEY As Long = &H100

Private Enum PalRegistryRootKey
   PalRegistryClassesRoot = HKEY_CLASSES_ROOT
   PalRegistryCurrentUser = HKEY_CURRENT_USER
   PalRegistryLocalMachine = HKEY_LOCAL_MACHINE
End Enum


' 7.5.2
Public Function AppSettingsForceOutOfProcessServer_32BitExcel() As Boolean
   Dim keyPath As String
   Dim theValue As Long
   Dim l_Answer As Boolean
   
On Error GoTo exitPoint
   
   keyPath = ROOT_REGISTRY_PATH & "\Application Settings\Advanced Options"
   theValue = ReadLong(PalRegistryCurrentUser, keyPath, "OperatingMode", -1)
   
   l_Answer = (theValue = 1)

   
exitPoint:
   AppSettingsForceOutOfProcessServer_32BitExcel = l_Answer
End Function


' Assumed DWORD value
Private Function ReadLong(ByVal rootKey As PalRegistryRootKey, ByVal keyPath As String, ByVal itemName As String, Optional ByVal defaultValue As Long = 0) As Long
   Dim rc As Long
   Dim strValue As String
   Dim hKey As Long
   Dim SIZE As Long
                  
   'Assign the default value as the result.  If the function exits abnormally, this will be the return value:
   rc = defaultValue
   
   rc = defaultValue
   SIZE = 4
   If RegOpenKeyEx(rootKey, keyPath, 0, KEY_READ, hKey) <> ERROR_SUCCESS Then GoTo exitPoint
   If RegQueryValueEx(hKey, itemName, 0, REG_DWORD_LITTLE_ENDIAN, rc, SIZE) <> ERROR_SUCCESS Then GoTo exitPoint
      
         
exitPoint:
   If hKey <> 0 Then RegCloseKey hKey: hKey = 0
   ReadLong = rc
End Function


#End If

Attribute VB_Name = "WSConstants"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "XDK"
Option Explicit

'These are all the public constants that @RISK exposes for XDK control.  These are also available in Risk.Constants for internal development,
'.NET deverlopers, and also for people who want to automate @RISK without making a a direct reference to Risk.xla (because they want to
'delay-load @RISK, for example.)
Public Const RiskAutoNumIterations As Long = -1
Public Const RiskAutoNumSeconds As Long = -1
Public Const RiskAutomaticSeed As Long = -1
Public Const RiskAutoBaseValue As Double = 1.01E+300
Public Const RiskAutoNumChiSqBins As Integer = -1
Public Const RiskAutoNumHistogramBins As Long = -1
Public Const RiskAutomaticText As String = "{DEFAULT}"
Public Const RiskNegativeInfinity As Double = -1E+300
Public Const RiskPositiveInfinity As Double = 1E+300
Public Const RiskNaN As Double = 1.01E+300
    
'This property returns the root @RISK object for automation developers.
'It makes sure that the edition of @RISK is not Standard before proceeding, since the users of the Standard Edition do not have the license to run automation code.
Public Function Risk() As AtRiskOL7.Risk
   Dim rc As AtRiskOL7.Risk
   Static s_EditionChecked As Boolean
   
   Set rc = RiskObj
   If (rc Is Nothing) Then ThrowException "@RISK not initialized."
   
   If Not s_EditionChecked Then
      If (rc.ProductInformation.Edition = RiskStandardEdition) Then ThrowException "The standard edition of @RISK may not be automated."
      s_EditionChecked = True
   End If

exitPoint:
   Set Risk = RiskObj
End Function

'This property returns the root RISKOptimizer object for automation developers.
Public Function RISKOptimizer() As RISKOptOL7.RISKOptimizerRoot
   Set RISKOptimizer = RiskObj.Internal.RISKOptimizer
End Function

'4/18/2018: Added this so external vba code can get the root OOPs server, if there is one.
'I added this for @RISK for Project, which was incorrectly making its own OOPS.
Public Function RiskOOps() As Object
   Set RiskOOps = RiskOOPsObj
End Function

' InQuest injected base64 decoded content
' &F+$
' BzYQy
' ek!n
' *'Z,
' *'Z,
' F+$"{
' F+$R
' F+$I
' F+$I
' bzWUj[
' F+$I
' F+$I
' F+$:
' +bjX
' F+$:
' BjY[i
' *'Z)

INQUEST-PP=macro
