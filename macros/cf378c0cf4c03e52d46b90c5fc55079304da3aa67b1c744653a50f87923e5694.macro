Attribute VB_Name = "JYCORE_Array"
Option Explicit

'This function converts a two dimensional array to a string.
Function twoDimArrayToString(arr As Variant, rowDelimiter As String, colDelimiter As String, escChar As String) As String
    
    Dim rows As Variant
    rows = separateRowsInArray(arr, False)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rows, lwr, upr
    
    Dim rowStrings As Variant
    ReDim rowStrings(lwr To upr)
    
    Dim r As Long
    For r = lwr To upr
        rowStrings(r) = arrayToString(rows(r), colDelimiter, escChar)
    Next
    
    
    '------------------
    
    twoDimArrayToString = arrayToString(rowStrings, rowDelimiter, escChar)
    
End Function

Function twoDimArrayToOneDimArray(twoDimArr As Variant) As Variant

    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D twoDimArr, lwrRow, uprRow, lwrCol, uprCol
    
    Dim coll As Collection
    Set coll = New Collection
    
    Dim r As Long
    For r = lwrRow To uprRow
        Dim c As Long
        For c = lwrCol To uprCol
            coll.add twoDimArr(r, c)
        Next
    Next
    
    twoDimArrayToOneDimArray = collectionToArray(coll)

End Function

Function stringTo2DArray(theString As String, rowDelim As String, colDelim As String, escChar As String, desiredLowerBoundRow As Long, desirdLowerBondCol As Long) As Variant
    
    
    Dim rowStrings As Variant
    rowStrings = stringToArray(theString, rowDelim, escChar, desiredLowerBoundRow)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rowStrings, lwr, upr
    
    Dim rowArrs As Variant
    ReDim rowArrs(lwr To upr)
    
    Dim r As Long
    For r = lwr To upr
    
        Dim rowString As String
        rowString = rowStrings(r)
    
        Dim rowArr As Variant
        rowArr = stringToArray(rowString, colDelim, escChar, desirdLowerBondCol)
        
        rowArrs(r) = rowArr
    Next
    
    Dim twoDimArray As Variant
    twoDimArray = concatenateArrayRowsInto2DArray(rowArrs)
    
    stringTo2DArray = twoDimArray
    
End Function

Function stringToArray(theString As String, delim As String, escChar As String, desiredLowerBound As Long) As Variant
    
    Dim coll As Collection
    Set coll = stringToCollection(theString, delim, escChar)
    
    If coll.count = 0 Then
        stringToArray = createEmptyArray()
    Else
        stringToArray = collectionToArray_customLowerBound(coll, desiredLowerBound)
    End If
    
End Function

Function arrayToString(theArr As Variant, delim As String, escChar As String) As String
    
    If isNothing(theArr) Then
        elwp "Please pass in an array."
        arrayToString = ""
    Else
    
        Dim lower As Long
        Dim upper As Long
        lower = LBound(theArr, 1)
        upper = UBound(theArr, 1)
        
        Dim st As String
        st = ""
        
        Dim c As Long
        For c = lower To upper
            Dim curKey As Variant
            curKey = addEscapeCharactersWhereNecessary(CStr(theArr(c)), delim, escChar)
            If c = lower Then
                st = curKey
            Else
                st = st & delim & curKey
            End If
        Next
        
        arrayToString = st
    End If
End Function


Function arrToString(arr As Variant, delimiter As String) As String
    arrToString = arrayToString(arr, delimiter, "")
End Function

Function rlai_2d(arr As Variant, rowIndx As Long, colIndx As Long) As Variant
    atr rlai_2d, arr(LBound(arr, 1) + rowIndx - 1, LBound(arr, 2) + colIndx - 1)
End Function

Function srai_2d(arr As Variant, rowIndx As Long, colIndx As Long, value As Variant)
    atr arr(LBound(arr, 1) + rowIndx - 1, LBound(arr, 2) + colIndx - 1), value
End Function



'rlai stands for 'relativeArrayIndex'
Function rlai(arr As Variant, index As Long) As Variant
    atr rlai, arr(LBound(arr, 1) + index - 1)
End Function

'srai stands for 'setRelativeArrayIndex'
Function srai(arr As Variant, index As Long, value As Variant)
    atr arr(LBound(arr, 1) + index - 1), value
End Function


Function arraysToCollections(listOfArrays As Variant) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs listOfArrays, lwr, upr
    
    Dim newList As Variant
    ReDim newList(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim curArray As Variant
        curArray = listOfArrays(c)
        
        Set newList(c) = arrayToCollection(curArray)
    Next
    
    arraysToCollections = newList
    
End Function

Function arrayToCollection(arr As Variant) As Collection
    
    Dim size As Long
    size = dimSize(arr, 1)
    
    Dim coll As Collection
    Set coll = New Collection
    
    Dim c As Long
    For c = 1 To size
        coll.add rlai(arr, c)
    Next
    Set arrayToCollection = coll
End Function

Function createEmptyArray() As Variant
    Dim tempDict As Variant
    Set tempDict = CreateObject("Scripting.dictionary")
    
    createEmptyArray = tempDict.keys

End Function

Function stripRowFrom2DArrayIntoItsOwn1DArray(the2DArray As Variant, whichRow As Long) As Variant
    
    Dim numCols As Long
    numCols = dimSize(the2DArray, 2)
    
    Dim dataForThisEntry As Variant
    ReDim dataForThisEntry(1 To numCols)
    
    Dim lowestCol As Long
    lowestCol = LBound(the2DArray, 2)
    
    Dim k As Long
    For k = 1 To numCols
        dataForThisEntry(k) = CStr(the2DArray(whichRow, lowestCol + k - 1))
    Next
    stripRowFrom2DArrayIntoItsOwn1DArray = dataForThisEntry

End Function

Function numDims(arr As Variant) As Long
On Error GoTo ehs

    Dim dimsSoFar As Long
    dimsSoFar = 0
    
    While True
        Dim lwr As Long
        lwr = LBound(arr, dimsSoFar + 1)
        
        dimsSoFar = dimsSoFar + 1
    Wend

GoTo ehe
ehs:
ehe:
On Error GoTo 0

    numDims = dimsSoFar

End Function

'JY20110209a - deprecate, use dimSize instead - start
'Function arrSize(arr As Variant) As Long
'    arrSize = dimSize(arr, 1)
'End Function
'JY20110209a - deprecate, use dimSize instead - end

Function dimSize(arr As Variant, dimension As Long) As Long

    If Not IsArray(arr) Then
        elwp "Please pass in an array!"
        dimSize = 0
    Else

        Dim lowest As Long
        Dim highest As Long
        lowest = LBound(arr, dimension)
        highest = UBound(arr, dimension)
        
        dimSize = highest - lowest + 1
    End If
End Function

Function concatenateArrayRowsInto2DArray(arr As Variant) As Variant

    Dim numRows As Long
    numRows = dimSize(arr, 1)
    
    Dim maxColLength As Long
    maxColLength = 0
    
    Dim c As Long
    For c = 1 To numRows
        Dim arrRow As Variant
        arrRow = rlai(arr, c)
        
        Dim numColsThisRow As Long
        numColsThisRow = dimSize(arrRow, 1)
        
        maxColLength = wsFunctionMax(maxColLength, numColsThisRow)
    Next
    
    If numRows = 0 Or maxColLength = 0 Then
        elwp "No data exists in this array!"
        Set concatenateArrayRowsInto2DArray = Nothing
    Else
        Dim twoDimArray As Variant
        ReDim twoDimArray(1 To numRows, 1 To maxColLength)
        
        Dim d As Long
        For d = 1 To numRows
            Dim thisRow As Variant
            thisRow = rlai(arr, d)
            
            Dim thisRowNumCols As Long
            thisRowNumCols = dimSize(thisRow, 1)
            
            Dim e As Long
            For e = 1 To thisRowNumCols
                atr twoDimArray(d, e), rlai(thisRow, e)
            Next
            
            Dim f As Long
            For f = thisRowNumCols + 1 To maxColLength
                twoDimArray(d, f) = Empty
            Next
        Next
        concatenateArrayRowsInto2DArray = twoDimArray
    End If
End Function

Function sumOfArrayContents(arr As Variant, ByRef mod_emsgs As Variant, logErrorsIfEncounterNonNumerics As Boolean, valueForDivZero As Variant) As Variant
    sumOfArrayContents = sumOrAvgOfArrayContents(arr, mod_emsgs, logErrorsIfEncounterNonNumerics, True, Nothing, valueForDivZero)
End Function

Function avgOfArrayContents(arr As Variant, ByRef mod_emsgs As Variant, logErrorsIfEncounterNonNumerics As Boolean, valueForDivZero As Variant) As Variant
    avgOfArrayContents = sumOrAvgOfArrayContents(arr, mod_emsgs, logErrorsIfEncounterNonNumerics, False, Nothing, valueForDivZero)
End Function

Function weightedAvgOfCPRCDRInArrayContents(arr As Variant, ByRef mod_emsgs As Variant, ignoreNonnumerics As Boolean, weights As Variant, valueForDivZero As Variant) As Variant
    If isNothing(weights) Then
        mod_emsgs.add "You did not pass in any weights!"
    End If
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(arr, 1)
    upper = UBound(arr, 1)
    
    If lower = upper Then
        'There is only one element.
        weightedAvgOfCPRCDRInArrayContents = arr(lower)
    Else
    
        Dim deAnnualizedNumbers As Variant
        ReDim deAnnualizedNumbers(lower To upper)
        
        Dim c As Long
        For c = lower To upper
            Dim annualizedNumber As Variant
            annualizedNumber = arr(c)
            
            Dim deannualizedNumber As Variant
            If isNumber(annualizedNumber) Then
                deannualizedNumber = cprcdrToSMMMDR(CDbl(annualizedNumber))
            Else
                deannualizedNumber = annualizedNumber
            End If
            
            deAnnualizedNumbers(c) = deannualizedNumber
        Next
        
        Dim weightedAverage As Variant
        weightedAverage = sumOrAvgOfArrayContents(deAnnualizedNumbers, mod_emsgs, ignoreNonnumerics, False, weights, valueForDivZero)
        
        If isNumber(weightedAverage) Then
            weightedAvgOfCPRCDRInArrayContents = smmmdrToCPRCDR(CDbl(weightedAverage))
        Else
            weightedAvgOfCPRCDRInArrayContents = "ERROR: " & weightedAverage
        End If
    End If
End Function

Function computeWeightedAvgOfCollectionContents(numsToAvg As Collection, ByRef mod_emsgs As Variant, logErrorsIfEncounteredNonNumeric As Boolean, weights As Collection, divZeroValue As Variant) As Variant
    
    Dim wtdAvg As Variant
    If isNothing(weights) Then
        wtdAvg = "-"
    Else
        Dim daSz As Long
        daSz = ccsz(Array(numsToAvg, weights), True)
        
        If daSz <= 0 Then
            wtdAvg = "?"
        Else
            wtdAvg = weightedAvgOfArrayContents(collectionToArray(numsToAvg), mod_emsgs, logErrorsIfEncounteredNonNumeric, collectionToArray(weights), divZeroValue)
        End If
    End If
    computeWeightedAvgOfCollectionContents = wtdAvg

End Function


Function weightedAvgOfArrayContents(arr As Variant, ByRef mod_emsgs As Variant, logErrorsIfEncounterNonNumerics As Boolean, weights As Variant, valueForDivZero As Variant) As Variant
    If isNothing(weights) Then
        mod_emsgs.add "You did not pass in any weights!"
    End If
    weightedAvgOfArrayContents = sumOrAvgOfArrayContents(arr, mod_emsgs, logErrorsIfEncounterNonNumerics, False, weights, valueForDivZero)
End Function

Function getSomeComponentsUsedInWtdAvgCalculation(nums As Collection, ByRef mod_emsgs As Variant, logErrorsIfEncounterNonNumerics As Boolean, weights As Collection, valueForDivZero As Variant, ByRef out_adjustments As Collection, ByRef out_sumOfWeights As Variant) As Variant
    
    Dim adjustments As Collection
    Dim incrementalWeights As Collection
    Dim sumOfWeights As Variant
    If isNothing(weights) Then
        mod_emsgs.add "No weights passed in!"
        Set incrementalWeights = Nothing
        Set adjustments = Nothing
        Set sumOfWeights = Nothing
    ElseIf isNothing(nums) Then
        mod_emsgs.add "No numbers passed in!"
        Set incrementalWeights = Nothing
        Set adjustments = Nothing
        Set sumOfWeights = Nothing
    ElseIf weights.count = 0 Then
        mod_emsgs.add "Zero weights were passed in!"
        Set incrementalWeights = Nothing
        Set adjustments = Nothing
        Set sumOfWeights = Nothing
    ElseIf nums.count = 0 Then
        mod_emsgs.add "Zero numbers were passed in!"
        Set incrementalWeights = Nothing
        Set adjustments = Nothing
        Set sumOfWeights = Nothing
    Else
        Dim daSz As Long
        daSz = ccsz(Array(nums, weights), True)
        
        If daSz <= 0 Then
            mod_emsgs.add "An inconsistent number of weights and numbers were passed in!"
            Set incrementalWeights = Nothing
            Set adjustments = Nothing
            Set sumOfWeights = Nothing
        Else
            Dim sumOfWts As Double
            Set incrementalWeights = incrementalWeightsForWtdAvgOfArrayContents(collectionToArray(nums), mod_emsgs, logErrorsIfEncounterNonNumerics, collectionToArray(weights), valueForDivZero, adjustments, sumOfWts)
            
            sumOfWeights = sumOfWts
        End If
    End If
    out_sumOfWeights = sumOfWeights
    Set out_adjustments = adjustments
    Set getSomeComponentsUsedInWtdAvgCalculation = incrementalWeights

End Function

Function getAdjustmentsNeededToComputeWeightedAverages(weights As Variant, logErrorsIfEncounterNonNumerics As Boolean, ByRef mod_emsgs As Variant, valueForDivZero As Variant, ByRef out_sumOfWeights As Double) As Collection

    Dim sumOfWeights As Variant
    sumOfWeights = sumOfArrayContents(weights, mod_emsgs, logErrorsIfEncounterNonNumerics, valueForDivZero)

    Dim sz As Long
    sz = dimSize(weights, 1)
    
    Dim adjustments As Collection
    Set adjustments = New Collection
    Dim d As Long
    For d = 1 To sz
        Dim curWt As Variant
        atr curWt, rlai(weights, d)
    
        Dim curWeight As Double
        If Not isNumber(curWt) Then
            curWeight = 0
            If Not logErrorsIfEncounterNonNumerics Then
                mod_emsgs.add "Encountered a non-numeric weight '" & curWt & "' in the array!"
            End If
        Else
            curWeight = CDbl(curWt)
        End If
        
        Dim currentAdjustment As Variant
        If sumOfWeights = 0 Then
            currentAdjustment = valueForDivZero
        Else
            currentAdjustment = (curWeight / sumOfWeights)
        End If
        
        adjustments.add currentAdjustment
    Next
    
    out_sumOfWeights = sumOfWeights
    Set getAdjustmentsNeededToComputeWeightedAverages = adjustments
End Function

Function incrementalWeightsForWtdAvgOfArrayContents(arr As Variant, ByRef mod_emsgs As Variant, logErrorsIfEncounterNonNumerics As Boolean, weights As Variant, valueForDivZero As Variant, ByRef out_adjustments As Collection, ByRef out_sumOfWeights As Double) As Variant

    Dim adjustments As Collection
    Dim sumOfWeights As Double
    Set adjustments = getAdjustmentsNeededToComputeWeightedAverages(weights, logErrorsIfEncounterNonNumerics, mod_emsgs, valueForDivZero, sumOfWeights)
    
    Dim sz As Long
    sz = commonVectorSize(Array(arr, adjustments), False, COL_DATA_TYPE_COLLECTION_OR_ONE_DIM_ARRAY)
    
    Dim incrementalWeights As Collection
    If sz = -1 Then
        mod_emsgs.add "number of numbers is different than number of adjustments!"
        Set incrementalWeights = Nothing
    Else
        
        Set incrementalWeights = New Collection
        Dim c As Long
        For c = 1 To sz
            Dim curVal As Variant
            Dim curAdjustment As Variant
            atr curVal, rlai(arr, c)
            atr curAdjustment, adjustments.item(c)
            
            Dim curNum As Double
            If Not isNumber(curVal) Then
                curNum = 0
                If Not logErrorsIfEncounterNonNumerics Then
                    mod_emsgs.add "Encountered a non-numeric value '" & curVal & "' in the array!"
                End If
            Else
                curNum = CDbl(curVal)
            End If
            
            Dim curIncrementalWeight As Variant
            If curAdjustment = valueForDivZero Then
                curIncrementalWeight = valueForDivZero
            ElseIf Not isNumber(curAdjustment) Then
                Dim emsg5 As String
                emsg5 = "Could not figure out how to compute an adjustment probably because it is non-numeric!"
                mod_emsgs.add emsg5
                curIncrementalWeight = emsg5
            Else
                curIncrementalWeight = curNum * curAdjustment
            End If
            incrementalWeights.add curIncrementalWeight
        Next
        
        'Dim wtdAvgFromIncrements As Variant
        'Dim wtdAvgThruNormalCalc As Variant
        'wtdAvgFromIncrements = sumOfCollectionElements(incrementalWeights)
        'wtdAvgThruNormalCalc = weightedAvgOfArrayContents(arr, mod_emsgs, logErrorsIfEncounterNonNumerics, weights, valueForDivZero)
        '
        'If wtdAvgFromIncrements <> wtdAvgThruNormalCalc Then
        '    mod_emsgs.add "Found a difference in computed weighted averages between our two methods... [" & wtdAvgFromIncrements & "] and [" & wtdAvgThruNormalCalc & "]"
        'End If
    
    End If
    out_sumOfWeights = sumOfWeights
    Set out_adjustments = adjustments
    Set incrementalWeightsForWtdAvgOfArrayContents = incrementalWeights
End Function

Function sumOrAvgOfArrayContents(arr As Variant, ByRef mod_emsgs As Variant, logErrorsIfEncounterNonNumerics As Boolean, sumVsAvg As Boolean, optWeights As Variant, valueForDivZero As Variant) As Variant

    Dim numElements As Long
    numElements = dimSize(arr, 1)
    
    Dim weights As Variant
    atr weights, optWeights
    If Not isNothing(optWeights) Then
        If dimSize(optWeights, 1) <> numElements Then
            mod_emsgs.add "You passed in an unexpected number of weights!"
            Set weights = Nothing
        End If
    End If
    
    Dim sumSoFar As Double
    Dim numItems As Long
    Dim sumOfWeights As Double
    Dim weightedSumSoFar As Double
    sumSoFar = 0
    numItems = 0
    sumOfWeights = 0
    weightedSumSoFar = 0
    
    Dim c As Long
    For c = 1 To numElements
        Dim curVal As Variant
        curVal = rlai(arr, c)
        
        If isNumber(curVal) Then
            sumSoFar = sumSoFar + CDbl(curVal)
            numItems = numItems + 1
            
            If Not isNothing(weights) Then
                Dim curWeight As Variant
                curWeight = rlai(weights, c)
                
                If isNumber(curWeight) Then
                    sumOfWeights = sumOfWeights + CDbl(curWeight)
                    weightedSumSoFar = weightedSumSoFar + (CDbl(curWeight) * CDbl(CDbl(curVal)))
                Else
                    If logErrorsIfEncounterNonNumerics Then
                        mod_emsgs.add "Encountered a non-numeric weight '" & curWeight & "' in the array!"
                    End If
                End If
            End If
        Else
            If logErrorsIfEncounterNonNumerics Then
                mod_emsgs.add "Encountered a non-numeric value '" & CStr(curVal) & "' in the array!"
            End If
        End If
    Next
    
    If sumVsAvg Then
        sumOrAvgOfArrayContents = sumSoFar
    Else
        If Not isNothing(optWeights) Then
            If numElements = 1 Then
                sumOrAvgOfArrayContents = rlai(arr, 1)
            ElseIf sumOfWeights = 0 Then
                sumOrAvgOfArrayContents = valueForDivZero
            Else
                sumOrAvgOfArrayContents = weightedSumSoFar / sumOfWeights
            End If
        Else
            If numItems = 0 Then
                sumOrAvgOfArrayContents = valueForDivZero
            Else
                sumOrAvgOfArrayContents = sumSoFar / numItems
            End If
        End If
    End If
End Function

Function oneDimArrayTo2DArray(arr As Variant, rowVsCol As Boolean) As Variant

    If Not IsArray(arr) Then
        elwp "Please pass in an array!"
        Set oneDimArrayTo2DArray = Nothing
    Else
    
        Dim lower As Long
        Dim upper As Long
        lower = LBound(arr, 1)
        upper = UBound(arr, 1)
        
        Dim NewArr As Variant
        If rowVsCol Then
            ReDim NewArr(lower To lower, lower To upper)
        Else
            ReDim NewArr(lower To upper, lower To lower)
        End If
        
        Dim c As Long
        For c = lower To upper
            Dim theVal As Variant
            atr theVal, arr(c)
            
            If rowVsCol Then
                atr NewArr(lower, c), theVal
            Else
                atr NewArr(c, lower), theVal
            End If
        Next
        oneDimArrayTo2DArray = NewArr
    End If
End Function

Function copyArr(arr As Variant) As Variant
    Dim lower As Long
    Dim upper As Long
    glaubs arr, lower, upper
    
    Dim NewArr As Variant
    ReDim NewArr(lower To upper)
    
    copyArrIntoAnotherArrAtSameIndexes arr, NewArr, lower, upper
    
    copyArr = NewArr
End Function

Function copyArrIntoAnotherArrAtSameIndexes(ByRef arr As Variant, ByRef mod_arrToCopyInto As Variant, lwr As Long, upr As Long) 'byref on "arr" is to possibly improve performance by not having to values-copy an array.  I didn't test this out to see if it really does impact performance.  Just trying it just in case.

    Dim c As Long
    For c = lwr To upr
        atr mod_arrToCopyInto(c), arr(c)
    Next
    
End Function

Function copy2DArr(arr As Variant) As Variant
    
    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D arr, lwrRow, uprRow, lwrCol, uprCol
    
    Dim NewArr As Variant
    ReDim NewArr(lwrRow To uprRow, lwrCol To uprCol)
    
    copy2DArrInto arr, NewArr
    
    copy2DArr = NewArr
End Function

Function copy2DArrInto(srcArr As Variant, ByRef mod_destArr As Variant)

    Dim lwrRow_src As Long
    Dim uprRow_src As Long
    Dim lwrCol_src As Long
    Dim uprCol_src As Long
    glaubs2D srcArr, lwrRow_src, uprRow_src, lwrCol_src, uprCol_src

    Dim lwrRow_dest As Long
    Dim uprRow_dest As Long
    Dim lwrCol_dest As Long
    Dim uprCol_dest As Long
    glaubs2D mod_destArr, lwrRow_dest, uprRow_dest, lwrCol_dest, uprCol_dest

    If lwrRow_src < lwrRow_dest Or lwrCol_src < lwrCol_dest Or uprRow_src > uprRow_dest Or uprCol_src > uprCol_dest Then
        elwp "Could not copy one array into another because the dimensions of the source array are not contained within those of the destination array!"
    Else
        Dim r As Long
        For r = lwrRow_src To uprRow_src
            Dim c As Long
            For c = lwrCol_src To uprCol_src
                atr mod_destArr(r, c), srcArr(r, c)
            Next
        Next
    End If
    

End Function

'NOTE: Before the offsetVersusAbsoluteIndx param was available, this method was essentially treating it as TRUE
Function searchArrayLinearly(arr As Variant, searchValue As Variant, offsetVersusAbsoluteIndx As Boolean) As Long

    Dim lower As Long
    Dim upper As Long
    lower = LBound(arr, 1)
    upper = UBound(arr, 1)
    
    Dim indxRepresentingNothing As Long
    If offsetVersusAbsoluteIndx Then
        indxRepresentingNothing = 0
    Else
        indxRepresentingNothing = lower - 1
    End If
    Dim foundIndx As Long
    foundIndx = indxRepresentingNothing
    
    
    Dim c As Long
    c = lower
    
    While (c <= upper) And (foundIndx = indxRepresentingNothing)
    
        Dim element As Variant
        atr element, arr(c)
    
        If valuesAreEqual(element, searchValue) Then
            If offsetVersusAbsoluteIndx Then
                foundIndx = c - lower + 1
            Else
                foundIndx = c
            End If
        End If
        
        c = c + 1
    Wend

    searchArrayLinearly = foundIndx

End Function

Function searchArrayRowLinearly(twoDimArr As Variant, searchValue As Variant, row As Long) As Long
    searchArrayRowLinearly = searchRowOrColumnLinearlyIn2DArray(twoDimArr, searchValue, row, True)
End Function

Function searchArrayColLinearly(twoDimArr As Variant, searchValue As Variant, col As Long) As Long
    searchArrayColLinearly = searchRowOrColumnLinearlyIn2DArray(twoDimArr, searchValue, col, False)
End Function

Function searchRowOrColumnLinearlyIn2DArray(twoDimArr As Variant, searchValue As Variant, rowOrColToSearchLinearly As Long, searchARowVsAColumn As Boolean) As Long

    Dim dimensionNotToSearch_akaDimensionOfList As Long
    If searchARowVsAColumn Then
        dimensionNotToSearch_akaDimensionOfList = 2 'Since we are searching a row, we need to search every COLUMN within the row
    Else
        dimensionNotToSearch_akaDimensionOfList = 1 'Since we are searching a column, we need to search every ROW in that column
    End If
    

    Dim lower As Long
    Dim upper As Long
    lower = LBound(twoDimArr, dimensionNotToSearch_akaDimensionOfList)
    upper = UBound(twoDimArr, dimensionNotToSearch_akaDimensionOfList)
    
    Dim foundIndx As Long
    foundIndx = lower - 1
    
    Dim c As Long
    c = lower
    While (c <= upper) And (foundIndx = 0)
    
        Dim element As Variant
        If searchARowVsAColumn Then
            atr element, twoDimArr(rowOrColToSearchLinearly, c)
        Else
            atr element, twoDimArr(c, rowOrColToSearchLinearly)
        End If
        
        If valuesAreEqual(element, searchValue) Then
            foundIndx = c
        End If
    
        c = c + 1
    Wend
    
    searchRowOrColumnLinearlyIn2DArray = foundIndx

End Function

Function writeDataToNonConsecutiveRows(dataByDestRN As Dictionary, indexByRow_lowestIndexIsOne As Dictionary, optWS As Worksheet, fillInOnlyBlankAndZeroCells As Boolean, srgsDuringWrites As Boolean, defaultValueToUseForBlanks_orNothingToJustShowBlank As Variant) As Collection

    If dataByDestRN.count = 0 Then
        Set writeDataToNonConsecutiveRows = Nothing
    Else
    
        Dim rows As Variant
        rows = indexByRow_lowestIndexIsOne.keys()
        
        Dim sortedRows As Variant
        sortedRows = sortArray(rows)
        
        Dim numRows As Long
        numRows = dimSize(sortedRows, 1)
        
        Dim firstRow As Long
        Dim lastRow As Long
        firstRow = rlai(sortedRows, 1)
        lastRow = rlai(sortedRows, numRows)
        
        Dim colIndx As Long
        colIndx = 1
        
        Dim colArrByDestRN As Dictionary
        Set colArrByDestRN = createDictionaryWhereEachValueIsANewlyCreatedArrayColumn(dataByDestRN.keys, firstRow, lastRow, colIndx)
        
        Dim destRNs As Variant
        destRNs = colArrByDestRN.keys()
    
        Dim lower As Long
        Dim upper As Long
        glaubs destRNs, lower, upper
        
        Dim x As Long
        For x = lower To upper
        
            Dim destRN As String
            destRN = destRNs(x)
            
            Dim colArrOfDataPassedInForWriting As Variant
            colArrOfDataPassedInForWriting = vfd(dataByDestRN, destRN, True)
            
            Dim indexToUseForColumn As Long
            indexToUseForColumn = LBound(colArrOfDataPassedInForWriting, 2)
            
            If indexToUseForColumn <> UBound(colArrOfDataPassedInForWriting, 2) Then
                elwp "Please pass in a single data column!"
            End If
            
            Dim colArrToWriteSoFar As Variant
            colArrToWriteSoFar = vfd(colArrByDestRN, destRN, True)
            
            Dim row As Long
            For row = firstRow To lastRow
                
                Dim rowExists As Boolean
                rowExists = indexByRow_lowestIndexIsOne.exists(row)
            
                Dim existingValue As Variant
                existingValue = gvl(gcicsr(rnge(destRN, optWS), row))
            
                Dim valueForThisRow As Variant
                
    
                If rowExists And ((Trim(CStr(existingValue)) = "") Or (Trim(CStr(existingValue)) = "0") Or (Not fillInOnlyBlankAndZeroCells)) Then
                    
                    Dim index As Long
                    index = vfd(indexByRow_lowestIndexIsOne, row, True)
                    
                    
                    
                    Dim dataValuePassedInForWriting As Variant
                    dataValuePassedInForWriting = colArrOfDataPassedInForWriting(LBound(colArrOfDataPassedInForWriting, 1) + index - 1, indexToUseForColumn)
                    
                    If Not isNothing(defaultValueToUseForBlanks_orNothingToJustShowBlank) Then
                        If Trim(dataValuePassedInForWriting) = "" Then
                            atr dataValuePassedInForWriting, defaultValueToUseForBlanks_orNothingToJustShowBlank
                        End If
                    End If
                
                    atr valueForThisRow, dataValuePassedInForWriting
                    
                Else
                    atr valueForThisRow, existingValue
                End If
                
                atr colArrToWriteSoFar(row, colIndx), valueForThisRow
            
            
            Next
            
            'commit our change
            atd colArrByDestRN, destRN, colArrToWriteSoFar
            
        Next
        
        Set writeDataToNonConsecutiveRows = writeArraysToColumnsBetweenSpecificRows(colArrByDestRN, optWS, firstRow, lastRow, srgsDuringWrites, True, False)
    End If
End Function

'valuesVsFormulas = true
'selectAsWeSet = False
Function writeArraysToColumnsBetweenSpecificRows(colArrByRN As Dictionary, optWS As Worksheet, firstRow As Long, lastRow As Long, srgsDuringWrites As Boolean, valuesVsFormulas As Boolean, selectAsWeSet As Boolean) As Collection

    Dim rnges As Collection
    Set rnges = New Collection
    
    Dim rns As Variant
    rns = colArrByRN.keys
    
    Dim lower As Long
    Dim upper As Long
    glaubs rns, lower, upper
    
    Dim c As Long
    For c = lower To upper
        Dim rn As String
        rn = rns(c)
        
        Dim arr As Variant
        arr = vfd(colArrByRN, rn, True)
        
        Dim anyCellInColumn As Range
        Set anyCellInColumn = rnge(rn, optWS)
        
        Dim dataRnge As Range
        Set dataRnge = writeArrToColumnBetweenSpecificRows(anyCellInColumn, arr, firstRow, lastRow, False, valuesVsFormulas, selectAsWeSet)
        
        If srgsDuringWrites Then
            srg dataRnge
        End If
        
        rnges.add dataRnge
    Next
    
    Set writeArraysToColumnsBetweenSpecificRows = rnges
End Function

'valuesVsFormulas = true
'selectAsWeSet = False
Function writeArrToColumnBetweenSpecificRows(anyCellInColumn As Range, theArr As Variant, firstRow As Long, lastRow As Long, shouldWrapText As Boolean, valuesVsFormulas As Boolean, selectAsWeSet As Boolean) As Range
        
    Dim destRnge As Range
    Set destRnge = rngeToRnge(gcicsr(anyCellInColumn, firstRow), gcicsr(anyCellInColumn, lastRow))
    
    writeArrayToRngeOfExactlySameSize destRnge, theArr, valuesVsFormulas, selectAsWeSet
    setWrapText destRnge, shouldWrapText
    
    Set writeArrToColumnBetweenSpecificRows = destRnge
End Function

Function writeArrayToScreen(firstCellToWriteTo As Range, matrixValues As Variant, valuesVsFormulas As Boolean, seletAsWeSet As Boolean) As Range

    Dim writtenArea As Range
    Set writtenArea = resizeRnge(firstCellToWriteTo, dimSize(matrixValues, 1), dimSize(matrixValues, 2))
    
    writeArrayToRngeOfExactlySameSize writtenArea, matrixValues, valuesVsFormulas, seletAsWeSet
    Set writeArrayToScreen = writtenArea
End Function

Sub writeArrayToRngeOfExactlySameSize_slowWay(theRnge As Range, arr As Variant, valuesVsFormulas As Boolean, selectAsWeSet As Boolean)

    Dim origSel As Range
    Set origSel = getCurSel()
    
    Dim numRows As Long
    Dim numCols As Long
    numRows = dimSize(arr, 1)
    numCols = dimSize(arr, 2)
    
    If numRows <> theRnge.rows.count Or numCols <> theRnge.Columns.count Then
        elwp "Cannot write an array to a range, because they do not match in size!"
    Else
    
        Dim r As Long
        For r = 1 To numRows
            Dim c As Long
            For c = 1 To numCols
                Dim curCell As Range
                Set curCell = theRnge.cells(r, c)
                
                If selectAsWeSet Then
                    srg curCell
                End If
                
                Dim theVal As Variant
                theVal = arr(LBound(arr, 1) + r - 1, LBound(arr, 2) + c - 1)
                
                If valuesVsFormulas Then
                    svl curCell, theVal
                Else
                    setCellFormula curCell, theVal, False
                End If
            Next
        Next
    
    End If
    
    sris origSel

End Sub

Sub writeListValuesIntoArrayAreaAsMuchAsCanPossiblyFit(trancheNamesArea As Range, trancheNamesToShow As Collection)

    Dim numRows As Long
    numRows = trancheNamesArea.rows.count
    
    Dim numCols As Long
    numCols = trancheNamesArea.Columns.count
    
    Dim totalCells As Long
    totalCells = numRows * numCols
    
    Dim adjTrancheNames As Collection
    Set adjTrancheNames = copyCollection(trancheNamesToShow)
    padCollectionToSize adjTrancheNames, totalCells, ""
    
    Dim arrayToWrite As Variant
    ReDim arrayToWrite(1 To numRows, 1 To numCols)
    
    Dim row As Long
    For row = 1 To numRows
        Dim col As Long
        For col = 1 To numCols
            Dim indx As Long
            indx = ((row - 1) * numCols) + col
            
            arrayToWrite(row, col) = adjTrancheNames.item(indx)
        Next
    Next
    
    writeArrayToRngeOfExactlySameSize trancheNamesArea, arrayToWrite, True, False

End Sub
Sub writeArrayToRngeOfExactlySameSize(rnge As Range, arr As Variant, valuesVsFormulas As Boolean, selectAsWeSet As Boolean)
    writeArrayToRngeOfExactlySameSize_optionallyTroubleshootProblems rnge, arr, valuesVsFormulas, False, selectAsWeSet
End Sub

Sub writeArrayToRngeOfExactlySameSize_optionallyTroubleshootProblems(rnge As Range, arr As Variant, valuesVsFormulas As Boolean, troubleshootProblems As Boolean, selectAsWeSet As Boolean)

    Dim numRows As Long
    Dim numCols As Long
    numRows = dimSize(arr, 1)
    numCols = dimSize(arr, 2)
    
    If numRows <> rnge.rows.count Or numCols <> rnge.Columns.count Then
        elwp "Cannot write an array to a range, because they do not match in size!"
    Else
        If selectAsWeSet Then
            sris rnge
        End If
        If tryToWriteArrayToRnge(rnge, arr, valuesVsFormulas) Then
            'DO NOTHING
        Else
            'Try the long way
            
            If Not troubleshootProblems Then
                'DO NOTHING
            Else
            
                Dim newSize As Long
                newSize = numRows
                
                Dim success As Boolean
                success = False
                
                While (newSize > 1) And (Not success)
                
                    newSize = newSize - 1
                
                    Dim tempRnge As Range
                    Set tempRnge = resizeRnge(rnge, newSize, rnge.Columns.count)
                    Dim tempArr As Variant
                    ReDim tempArr(1 To newSize, 1 To numCols)
                    Dim r As Long
                    For r = 1 To newSize
                        Dim c As Long
                        For c = 1 To numCols
                            tempArr(r, c) = arr(r, c)
                        Next
                    Next
                    
                    success = tryToWriteArrayToRnge(tempRnge, arr, valuesVsFormulas)
                
                Wend
                
                If success Then
                    newSize = newSize + 1
                End If
                
                elwp "Unable to write array to rnge the quick way (and the problem might be at row index " & newSize
            End If
            
            writeArrayToRngeOfExactlySameSize_slowWay rnge, arr, valuesVsFormulas, selectAsWeSet
        End If
    End If

End Sub

Function tryToWriteArrayToRnge(rnge As Range, arr As Variant, valuesVsFormulas As Boolean) As Boolean

    Dim success As Boolean
    success = False

On Error GoTo ehs
    If valuesVsFormulas Then
        rnge.value = arr
    Else
        rnge.formula = arr
    End If
    success = True
    
GoTo ehe
ehs:
    
    elg "Could not write array to range.  Msg=" & Err.description
ehe:
On Error GoTo 0

    tryToWriteArrayToRnge = success

End Function

Function writeArrayToRngeStartingAt(arr As Variant, topLeftCell As Range) As Range
    Dim numRows As Long
    Dim numCols As Long
    numRows = dimSize(arr, 1)
    numCols = dimSize(arr, 2)
    
    Dim destRnge As Range
    If numRows > 0 And numCols > 0 Then
        Set destRnge = resizeRnge(topLeftCell, numRows, numCols)
    Else
        Set destRnge = Nothing
    End If
    
    If Not isNothing(destRnge) Then
        destRnge.value = arr
    End If
    
    Set writeArrayToRngeStartingAt = destRnge
    
End Function

Sub writeArrayToWSStartingAt(wkSheet As Worksheet, firstRow As Long, firstColumn As Long, arr As Variant)
    writeArrayToRngeStartingAt arr, wkSheet.cells(firstRow, firstColumn)
End Sub

Function sortArray(theArr As Variant) As Variant

    Dim copyOfArr As Variant
    copyOfArr = theArr
    
    If dimSize(theArr, 1) = 0 Then
        'DO NOTHING
    Else
        QSortInPlace copyOfArr
    End If
    
    sortArray = copyOfArr
End Function


'Picture that each array is a row, and each index in the array is a column.
'Well then, with this analogy, this function sorts the rows according to the values in a particular column.
'BUT, we do not just do an alphabetical/numerical sort.  We expect certain values to be in this column,
'and we want these values in a particular order.
Function sortListOfArraysByArrayIndx_withCustomOrderingScheme(listOfArrays As Collection, rlaiIndxToSearch As Long, desiredOrder As Variant) As Collection

    Dim largestPossibleIndx As Long
    largestPossibleIndx = UBound(desiredOrder, 1) + 1
    
    Dim listOfOffsetsByValue As Dictionary
    Set listOfOffsetsByValue = createArrayOffsetListByArrayValue(desiredOrder, True)
    
    Dim listOfIndxAndArray As Collection
    Set listOfIndxAndArray = New Collection
    
    Dim c As Long
    For c = 1 To listOfArrays.count
    
        Dim arr As Variant
        arr = listOfArrays.item(c)
        
        Dim searchValue As Variant
        searchValue = rlai(arr, rlaiIndxToSearch)
        
        Dim indx As Long
        If listOfOffsetsByValue.exists(searchValue) Then
            Dim indxes As Collection
            Set indxes = vfd(listOfOffsetsByValue, searchValue, True)
            
            If indxes.count < 1 Then
                elwp_se
                indx = largestPossibleIndx
            Else
                indx = indxes.item(1) 'Just take the first one
            End If
            
        Else
            indx = largestPossibleIndx
        End If
        
        Dim indxAndArray As Variant
        indxAndArray = Array(indx, arr)
    
        listOfIndxAndArray.add indxAndArray
    Next
    
    Dim sorted As Collection
    Set sorted = sortListOfArraysByArrayIndx(listOfIndxAndArray, 1)
    
    Dim returnValue As Collection
    Set returnValue = New Collection
    
    Dim r As Long
    For r = 1 To sorted.count
        Dim thisIndxAndArray As Variant
        thisIndxAndArray = sorted.item(r)
        
        Dim theArr As Variant
        theArr = rlai(thisIndxAndArray, 2)
        
        returnValue.add theArr
    Next
    
    Set sortListOfArraysByArrayIndx_withCustomOrderingScheme = returnValue

End Function

'Picture that each array is a row, and each index in the array is a column.
'Well then, with this analogy, this function sorts the rows according to the values in a particular column.
Function sortListOfArraysByArrayIndx(listOfArrays As Collection, rlaiIndxToSearch As Long) As Collection
    
    Dim listOfArraysBySortValue As Dictionary
    Set listOfArraysBySortValue = New Dictionary
    
    Dim c As Long
    For c = 1 To listOfArrays.count
        Dim thisArray As Variant
        thisArray = listOfArrays.item(c)
        
        Dim searchValue
        searchValue = rlai(thisArray, rlaiIndxToSearch)
        
        Dim subList As Collection
        If listOfArraysBySortValue.exists(searchValue) Then
            Set subList = listOfArraysBySortValue.item(searchValue)
        Else
            Set subList = New Collection
            listOfArraysBySortValue.add searchValue, subList
        End If
        
        subList.add thisArray
        
    Next
    
    Dim ourKeys As Variant
    ourKeys = listOfArraysBySortValue.keys()
    
    Dim sortedKeys As Variant
    sortedKeys = sortArray(ourKeys)
    
    Dim newList As Collection
    Set newList = New Collection
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(sortedKeys, 1)
    upper = UBound(sortedKeys, 1)
    
    Dim r As Long
    For r = lower To upper
        Dim curKey As Variant
        atr curKey, sortedKeys(r)
        
        Dim subArrList As Collection
        Set subArrList = listOfArraysBySortValue.item(curKey)
        
        acltcl newList, subArrList
    Next
    
    Set sortListOfArraysByArrayIndx = newList
End Function

Function vailan_ifAllAreBlankThenSetToBlank(ByRef mod_valueBeingSet As Variant, fieldsToValidate As Variant) As Boolean
    Dim everythingIsOK As Boolean
    If allInArrayListAreBlank(fieldsToValidate) Then
        everythingIsOK = False
        mod_valueBeingSet = ""
    Else
        everythingIsOK = vaialan(mod_valueBeingSet, fieldsToValidate)
    End If
    
    vailan_ifAllAreBlankThenSetToBlank = everythingIsOK
End Function

'stands for "validateAllInArrayListAreNumbers"
Function vaialan(ByRef mod_valueBeingSet As Variant, fieldsToValidate As Variant) As Boolean
    Dim everythingIsOK As Boolean
    If aialan(fieldsToValidate) Then
        everythingIsOK = True
    Else
        everythingIsOK = False
        mod_valueBeingSet = "Cannot compute because some inputs to the equation were not numbers."
    End If
    vaialan = everythingIsOK
End Function


'stands for "allInArrayListAreNumbers"
Function aialan(arrayList As Variant) As Variant
    Dim lower As Long
    Dim upper As Long
    lower = LBound(arrayList, 1)
    upper = UBound(arrayList, 1)
    
    Dim c As Long
    c = lower
    
    Dim foundNonNumeric As Boolean
    foundNonNumeric = False
    
    While (c <= upper) And (Not foundNonNumeric)
        Dim curItem As Variant
        atr curItem, arrayList(c)
        
        If Not isNumber(curItem) Then
            foundNonNumeric = True
        End If
        c = c + 1
    Wend
    
    aialan = (Not foundNonNumeric)
End Function

Function allInArrayListAreNumbersOrBlank(arrayList As Variant) As Variant
    Dim lower As Long
    Dim upper As Long
    lower = LBound(arrayList, 1)
    upper = UBound(arrayList, 1)
    
    Dim c As Long
    c = lower
    
    Dim foundNonNumericNonBlank As Boolean
    foundNonNumericNonBlank = False
    
    While (c <= upper) And (Not foundNonNumericNonBlank)
        Dim curItem As Variant
        atr curItem, arrayList(c)
        
        If Not isNumber(curItem) Then
            If Not isBlankValue(curItem) Then
                foundNonNumericNonBlank = True
            End If
        End If
        c = c + 1
    Wend
    
    allInArrayListAreNumbersOrBlank = (Not foundNonNumericNonBlank)
End Function

'this method has been replaced with 'sumOfArrayContents
'Function sumOfArray(theArr As Variant) As Variant
'    Dim lower As Long
'    Dim upper As Long
'    lower = LBound(theArr, 1)
'    upper = UBound(theArr, 1)
'
'    Dim sumSoFar As Double
'    sumSoFar = 0
'
'    Dim c As Long
'    For c = lower To upper
'        sumSoFar = sumSoFar + theArr(c)
'    Next
'
'    sumOfArray = sumSoFar
'End Function

Function replicateArrayRowsInto2DArray(arrayRow As Variant, numRows As Long) As Variant
    
    Dim origLower As Long
    Dim origUpper As Long
    origLower = LBound(arrayRow, 1)
    origUpper = LBound(arrayRow, 2)
    
    If origLower <> origUpper Then
        elwp "Please pass in an array with 1 row!"
        Set replicateArrayRowsInto2DArray = Nothing
    Else
    
        Dim origRowIndx As Long
        origRowIndx = origUpper
    
        Dim lower As Long
        Dim upper As Long
        lower = LBound(arrayRow, 2)
        upper = UBound(arrayRow, 2)
        
        Dim NewArr As Variant
        ReDim NewArr(1 To numRows, lower To upper)
        
        Dim r As Long
        For r = 1 To numRows
            Dim c As Long
            For c = lower To upper
                NewArr(r, c) = arrayRow(origRowIndx, c)
            Next
        Next
        
        
        replicateArrayRowsInto2DArray = NewArr
    End If
    
End Function

Sub getLowerAndUpperBounds(arr As Variant, ByRef out_lower As Long, ByRef out_upper As Long)
    glaubs_customDim arr, out_lower, out_upper, 1
End Sub

Sub glaubs2(arr As Variant, ByRef out_lower As Long, ByRef out_upper As Long)
    glaubs_customDim arr, out_lower, out_upper, 2
End Sub

Sub glaubs_customDim(arr As Variant, ByRef out_lower As Long, ByRef out_upper As Long, dimension As Long)
    If Not IsArray(arr) Then
        errorLogWithPopup "Please pass in an array."
        out_lower = -1
        out_upper = -1
    Else
        out_lower = LBound(arr, dimension)
        out_upper = UBound(arr, dimension)
    End If
End Sub

Sub glaubs2D(arr As Variant, ByRef out_lwrRow As Long, ByRef out_uprRow As Long, ByRef out_lwrCol As Long, ByRef out_uprCol As Long)
    glaubs_customDim arr, out_lwrRow, out_uprRow, 1
    glaubs_customDim arr, out_lwrCol, out_uprCol, 2
End Sub


'colDataType = COL_DATA_TYPE_COLLECTION
Function convertListOfColumnDataIntoListOfArrayRows(colDataCollectionOrArrayOfColDataCollectionsOrListOfColDataCollections As Variant, lowerBound As Long, collectionDataType As String) As Collection
    Set convertListOfColumnDataIntoListOfArrayRows = convertListOfColumnDataIntoListOfArrayRws(colDataCollectionOrArrayOfColDataCollectionsOrListOfColDataCollections, lowerBound, collectionDataType, Nothing)
End Function

'colDataType = COL_DATA_TYPE_COLLECTION
Function convertListOfColumnDataIntoListOfArrayRws(colDataCollectionOrArrayOfColDataCollectionsOrListOfColDataCollections As Variant, lowerBound As Long, collectionDataType As String, allValuesAreObjectsVsAllValuesArePrimitives__orNothingIfWeDoNotKnowOrIfThereMightBeAMix As Variant) As Collection

    Dim isObjectVsPrimitiveOrNothingIfWeDoNotKnow As Variant
    atr isObjectVsPrimitiveOrNothingIfWeDoNotKnow, allValuesAreObjectsVsAllValuesArePrimitives__orNothingIfWeDoNotKnowOrIfThereMightBeAMix

    Dim arrOfColDataCollections As Variant
    arrOfColDataCollections = ensureValueIsAnArray(colDataCollectionOrArrayOfColDataCollectionsOrListOfColDataCollections)

    Dim arrayRows As Collection
    Set arrayRows = New Collection
    
    Dim sz As Long
    sz = commonVectorSize(arrOfColDataCollections, True, collectionDataType)
    
    If sz = VALUE_REPRESENTING_INCONSISTENT_SIZES Then
        elwp "Please pass in columns that have the same length!"
    Else
        Dim c As Long
        For c = 1 To sz
         
            Dim numCollections As Long
            numCollections = dimSize(arrOfColDataCollections, 1)
        
            Dim curArrRow As Variant
            ReDim curArrRow(lowerBound To lowerBound + numCollections - 1)
            
            Dim d As Long
            For d = 1 To numCollections
            
                Dim curItem As Variant
                doAssignToReference curItem, rlai(arrOfColDataCollections, d), isObjectVsPrimitiveOrNothingIfWeDoNotKnow
                
                Dim curVal As Variant
                If collectionDataType = COL_DATA_TYPE_COLLECTION_OR_ONE_DIM_ARRAY Then
                    If isCollection(curItem) Then
                        Dim curColl As Collection
                        Set curColl = curItem
                        
                        doAssignToReference curVal, curColl.item(c), isObjectVsPrimitiveOrNothingIfWeDoNotKnow
                    Else
                        Dim curArr As Variant
                        curArr = curItem
                        
                        doAssignToReference curVal, rlai(curArr, c), isObjectVsPrimitiveOrNothingIfWeDoNotKnow
                    End If
                ElseIf collectionDataType = COL_DATA_TYPE_COLLECTION Then
                    Dim curCl As Collection
                    Set curCl = curItem
                    
                    doAssignToReference curVal, curCl.item(c), isObjectVsPrimitiveOrNothingIfWeDoNotKnow
                Else
                    If collectionDataType = COL_DATA_TYPE_ONE_DIM_ARRAY Then
                        Dim crAr As Variant
                        crAr = curItem
                        
                        doAssignToReference curVal, rlai(crAr, c), isObjectVsPrimitiveOrNothingIfWeDoNotKnow
                    ElseIf collectionDataType = COL_DATA_TYPE_TWO_DIM_ARRAY_BUT_SINGLE_ROW Then
                        Dim twoDimArrButSingleRow As Variant
                        twoDimArrButSingleRow = curItem
                        
                        doAssignToReference curVal, rlai_2d(twoDimArrButSingleRow, 1, c), isObjectVsPrimitiveOrNothingIfWeDoNotKnow
                        
                    ElseIf collectionDataType = COL_DATA_TYPE_TWO_DIM_ARRAY_BUT_SINGLE_COL Then
                        Dim twoDimArrButSingleCol As Variant
                        twoDimArrButSingleCol = curItem
                        
                        doAssignToReference curVal, rlai_2d(twoDimArrButSingleCol, c, 1), isObjectVsPrimitiveOrNothingIfWeDoNotKnow
                    
                    Else
                        elwp "Unknown data type: " & collectionDataType
                        curVal = ""
                    End If
                End If
                
                Dim curIndx As Long
                curIndx = lowerBound + d - 1
                
                If IsObject(curVal) Then
                    Set curArrRow(curIndx) = curVal
                Else
                    curArrRow(curIndx) = curVal
                End If
            Next
            
            arrayRows.add copyArr(curArrRow) 'not sure of the copy is required; I put it in for now just to be safe
        Next
    End If
    Set convertListOfColumnDataIntoListOfArrayRws = arrayRows
End Function

Function removeArrayRowsWhereAllValuesAreBlank(listOfArrayRows As Collection) As Collection

    Dim newList As Collection
    Set newList = New Collection
    
    Dim c As Long
    For c = 1 To listOfArrayRows.count
        Dim arrRow As Variant
        arrRow = listOfArrayRows.item(c)
        
        Dim lwr As Long
        Dim upr As Long
        glaubs arrRow, lwr, upr
        
        Dim nonBlankWasFound As Boolean
        nonBlankWasFound = False
        
        Dim d As Long
        d = lwr
        While (d <= upr) And (Not nonBlankWasFound)
        
            Dim curEntry As Variant
            atr curEntry, arrRow(d)
            
            If Not isBlankValue(curEntry) Then
                nonBlankWasFound = True
            End If
            d = d + 1
        Wend
        
        If nonBlankWasFound Then
            newList.add arrRow
        End If
    Next
    
    Set removeArrayRowsWhereAllValuesAreBlank = newList

End Function

Function removeArrayRowsWhereFirstFieldIsBlankString(listOfArrayRows As Collection) As Collection
    Dim adjList As Collection
    Set adjList = New Collection
    Dim c As Long
    For c = 1 To listOfArrayRows.count
        Dim rnToCompareTo_rnForStorage As Variant
        rnToCompareTo_rnForStorage = listOfArrayRows.item(c)
        
        If rlai(rnToCompareTo_rnForStorage, 1) = "" Then
            'DO NOTHING
        Else
            adjList.add rnToCompareTo_rnForStorage
        End If
    Next

    Set removeArrayRowsWhereFirstFieldIsBlankString = adjList
End Function


Function getMappingOfTwoColumnsInTableToEachOtherAndFilterOutBlankInstancesOfTheFirstColumn(listOfArrayRows As Collection, indexForFirstColumn As Long, indexForSecondColumn As Long)


    Dim listOf__firstColValue_secondColValue As Collection
    Set listOf__firstColValue_secondColValue = New Collection
    
    Dim c As Long
    For c = 1 To listOfArrayRows.count
        Dim curArrayRow As Variant
        curArrayRow = listOfArrayRows.item(c)
        
        Dim firstColValue As String
        Dim secondColValue As String
        firstColValue = rlai(curArrayRow, indexForFirstColumn)
        secondColValue = rlai(curArrayRow, indexForSecondColumn)
        
        If firstColValue = "" Then
            'DO NOTHING
        Else
            listOf__firstColValue_secondColValue.add Array(firstColValue, secondColValue)
        End If
    Next



    Set getMappingOfTwoColumnsInTableToEachOtherAndFilterOutBlankInstancesOfTheFirstColumn = listOf__firstColValue_secondColValue

End Function

'allBoundsAreExpectedToBeAlike = true
Function separateColumnsInListOfArrayRows(allBoundsAreExpectedToBeAlike As Boolean, listOf_1dArray As Collection) As Collection
    atr separateColumnsInListOfArrayRows, doSepColumnsInListOfArrayRows(allBoundsAreExpectedToBeAlike, listOf_1dArray)
End Function

Function doSepColumnsInListOfArrayRows(allBoundsAreExpectedToBeAlike As Boolean, listOf_1dArray As Collection) As Collection
    
    Dim retValue As Collection
    If isNothing(listOf_1dArray) Then
        Set retValue = Nothing
    ElseIf listOf_1dArray.count = 0 Then
        Set retValue = New Collection
    Else
        
    
        Dim emsgs As JYCORE_Set
        Set emsgs = New JYCORE_Set
    
        Dim coll As Variant
        Set coll = New Collection
        
        Dim firstRow As Variant
        firstRow = listOf_1dArray.item(1)
            
        Dim expectedLBound As Long
        Dim expectedUBound As Long
        expectedLBound = LBound(firstRow, 1)
        expectedUBound = UBound(firstRow, 1)
            
        Dim x As Long
        For x = expectedLBound To expectedUBound
            coll.add New Collection
        Next
        
        Dim c As Long
        For c = 1 To listOf_1dArray.count
            Dim curRow As Variant
            curRow = listOf_1dArray.item(c)
            
            Dim lwr As Long
            Dim upr As Long
            glaubs curRow, lwr, upr
            
            If lwr <> expectedLBound And allBoundsAreExpectedToBeAlike Then
                emsgs.add "Unexpected lower bound: " & lwr
            ElseIf upr <> expectedUBound And allBoundsAreExpectedToBeAlike Then
                emsgs.add "Unexpected upper bound: " & upr
            Else
            
                Dim y As Long
                For y = 1 To coll.count
                    Dim curColl As Collection
                    Set curColl = coll.item(y)
                    
                    Dim daVal As Variant
                    atr daVal, rlai(curRow, y)
                    
                    curColl.add daVal
                Next
            End If
        Next
            
        If emsgs.count <> 0 Then
            elwp emsgs.toString(CHAR_CRLF, "")
    'JY20121205a - start
        End If
    'JY20121205a - end
    'JY20121205a - start
    '        Set retValue = Nothing
    '    Else
    'JY20121205a - end
            Set retValue = coll
    'JY20121205a - start
    '    End If
    'JY20121205a - end
    End If
    
    Set doSepColumnsInListOfArrayRows = retValue
            
End Function

'Before we added this parameter, separatedColumnsShouldRemainIn2DFormat was essentially set to true
Function separateColumnsInArray(data As Variant, separatedColumnsShouldRemainIn2DFormat As Boolean) As Variant
    separateColumnsInArray = separateRowsOrColumnsInArray(data, True, separatedColumnsShouldRemainIn2DFormat)
End Function

'Before we added this parameter, separatedRowsShouldRemainIn2DFormat was essentially set to true
Function separateRowsInArray(data As Variant, separatedRowsShouldRemainIn2DFormat As Boolean) As Variant
    separateRowsInArray = separateRowsOrColumnsInArray(data, False, separatedRowsShouldRemainIn2DFormat)
End Function

'Before we added this parameter, separatedArraysShouldRemainIn2DFormat was essentially set to true
Function separateRowsOrColumnsInArray(data As Variant, columnsVsRows As Boolean, separatedArraysShouldRemainIn2DFormat As Boolean) As Variant

    Dim dimensionThatWeAreSeparating As Long
    Dim dimensionThatWeAreKeeping As Long
    If columnsVsRows Then
        dimensionThatWeAreSeparating = 2
        dimensionThatWeAreKeeping = 1
    Else
        dimensionThatWeAreSeparating = 1
        dimensionThatWeAreKeeping = 2
    End If
    
    Dim lowestIndxForDimensionWeAreKeeping As Long
    Dim highestIndxForDimensionWeAreKeeping As Long
    glaubs_customDim data, lowestIndxForDimensionWeAreKeeping, highestIndxForDimensionWeAreKeeping, dimensionThatWeAreKeeping
    
    Dim lowestIndxForDimensionWeAreSeparating As Long
    Dim highestIndxForDimensionWeAreSeparating As Long
    glaubs_customDim data, lowestIndxForDimensionWeAreSeparating, highestIndxForDimensionWeAreSeparating, dimensionThatWeAreSeparating
    
    
   
    Dim separatedRowsOrCols As Variant
    ReDim separatedRowsOrCols(lowestIndxForDimensionWeAreSeparating To highestIndxForDimensionWeAreSeparating)
    
    Dim y As Long
    For y = lowestIndxForDimensionWeAreSeparating To highestIndxForDimensionWeAreSeparating
        
        Dim Temp As Variant
        If separatedArraysShouldRemainIn2DFormat Then
            If columnsVsRows Then
                ReDim Temp(lowestIndxForDimensionWeAreKeeping To highestIndxForDimensionWeAreKeeping, 1 To 1)
            Else
                ReDim Temp(1 To 1, lowestIndxForDimensionWeAreKeeping To highestIndxForDimensionWeAreKeeping)
            End If
        Else
            ReDim Temp(lowestIndxForDimensionWeAreKeeping To highestIndxForDimensionWeAreKeeping)
        End If
        separatedRowsOrCols(y) = Temp
    Next
    
    Dim curIndxInDimensionWeAreKeeping As Long
    For curIndxInDimensionWeAreKeeping = lowestIndxForDimensionWeAreKeeping To highestIndxForDimensionWeAreKeeping
        
        Dim x As Long
        For x = lowestIndxForDimensionWeAreSeparating To highestIndxForDimensionWeAreSeparating
            
            
            Dim currentDataValue As Variant
            If columnsVsRows Then
                currentDataValue = data(curIndxInDimensionWeAreKeeping, x)
            Else
                currentDataValue = data(x, curIndxInDimensionWeAreKeeping)
            End If
            
            If separatedArraysShouldRemainIn2DFormat Then
                If columnsVsRows Then
                    separatedRowsOrCols(x)(curIndxInDimensionWeAreKeeping, 1) = currentDataValue
                Else
                    separatedRowsOrCols(x)(1, curIndxInDimensionWeAreKeeping) = currentDataValue
                End If
            Else
                separatedRowsOrCols(x)(curIndxInDimensionWeAreKeeping) = currentDataValue
            End If
            
        Next
    Next
    separateRowsOrColumnsInArray = separatedRowsOrCols
    
End Function

Function appendValueToEndOfEachArrayRow(listOfArrayRows As Collection, valueToAppend As Variant) As Collection

    If listOfArrayRows.count = 0 Then
        Set appendValueToEndOfEachArrayRow = New Collection
    Else
        Set appendValueToEndOfEachArrayRow = arrayToCollection(addValueToEndOfEachArray(collectionToArray(listOfArrayRows), valueToAppend))
    End If

End Function

Function selectColumnFromListOfArrayRows(indx As Long, listOfArrayRows As Collection) As Collection
    Set selectColumnFromListOfArrayRows = selectColumnFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike(indx, listOfArrayRows, True)
End Function

Function selectColumnFromListOfArrayRows_unequalBoundsAreAccepted(indx As Long, listOfArrayRows As Collection) As Collection
    Set selectColumnFromListOfArrayRows_unequalBoundsAreAccepted = selectColumnFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike(indx, listOfArrayRows, False)
End Function

Function selectColumnFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike(indx As Long, listOfArrayRows As Collection, allBoundsAreExpectedToBeAlike As Boolean) As Collection
    If isNothing(listOfArrayRows) Then
        elwp "Please pass in a list of array rows!"
        Set selectColumnFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike = Nothing
    Else
        Set selectColumnFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike = selectCertainColumnsFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike(Array(indx), listOfArrayRows, allBoundsAreExpectedToBeAlike).item(1)
    End If
End Function

Function selectCertainColumnsFromListOfArrayRows_unequalBoundsAreAccepted(indxesInOrderToSelect As Variant, listOfArrayRows As Collection) As Collection
    Set selectCertainColumnsFromListOfArrayRows_unequalBoundsAreAccepted = selectCertainColumnsFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike(indxesInOrderToSelect, listOfArrayRows, False)
End Function

Function selectCertainColumnsFromListOfArrayRows(indxesInOrderToSelect As Variant, listOfArrayRows As Collection) As Collection
    Set selectCertainColumnsFromListOfArrayRows = selectCertainColumnsFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike(indxesInOrderToSelect, listOfArrayRows, True)
End Function

Function selectCertainColumnsFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike(indxesInOrderToSelect As Variant, listOfArrayRows As Collection, allBoundsAreExpectedToBeAlike As Boolean) As Collection
    Set selectCertainColumnsFromListOfArrayRows_specifyWhetherBoundsAreExpectedToBeAlike = doSelectCertainIndexesFromListOfArrayRows(indxesInOrderToSelect, listOfArrayRows, allBoundsAreExpectedToBeAlike, False)
End Function

Function selectCertainIndexesFromListOfArrayRows(indxesInOrderToSelect As Variant, listOfArrayRows As Collection) As Collection
    Set selectCertainIndexesFromListOfArrayRows = doSelectCertainIndexesFromListOfArrayRows(indxesInOrderToSelect, listOfArrayRows, True, True)
End Function

Function selectCertainIndexesFromListOfArrayRows_unequalBoundsAccepted(indxesInOrderToSelect As Variant, listOfArrayRows As Collection) As Collection
    Set selectCertainIndexesFromListOfArrayRows_unequalBoundsAccepted = doSelectCertainIndexesFromListOfArrayRows(indxesInOrderToSelect, listOfArrayRows, False, True)
End Function

Function selectedCertainRelativeIndexesFromArrayRow(arrRow As Variant, indxesInOrderToSelect As Variant) As Variant
    
    Dim indxsInOrderToSelect As Variant
    indxsInOrderToSelect = ensureValueIsAnArray(indxesInOrderToSelect)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs indxsInOrderToSelect, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
    
        Dim newArrRow As Variant
        ReDim newArrRow(lwr To upr)
        
        atr newArrRow(c), rlai(arrRow, CLng(indxsInOrderToSelect(c)))
    Next
    Set selectedCertainRelativeIndexesFromArrayRow = newArrRow
    
End Function

'returnListOfArrayRowsWithLowerBound1AsOpposedToListOfArrayColumns = true
Function doSelectCertainIndexesFromListOfArrayRows(indxesInOrderToSelect As Variant, listOfArrayRows As Collection, allBoundsAreExpectedToBeAlike As Boolean, returnListOfArrayRowsWithLowerBound1AsOpposedToListOfArrayColumns As Boolean) As Collection

    Dim indxsInOrderToSelect As Variant
    indxsInOrderToSelect = ensureValueIsAnArray(indxesInOrderToSelect)
    
    Dim retValue As Collection
    If isNothing(listOfArrayRows) Then
        elwp "Please pass in a list of array rows!"
        Set retValue = Nothing
    ElseIf listOfArrayRows.count = 0 Then
    
        If returnListOfArrayRowsWithLowerBound1AsOpposedToListOfArrayColumns Then
            Set retValue = New Collection
        Else
        
            Dim listOfBlankCols As Collection
            Set listOfBlankCols = New Collection
            
            Dim numCols As Long
            numCols = dimSize(indxsInOrderToSelect, 1)
        
            Dim dd As Long
            For dd = 1 To numCols
                listOfBlankCols.add New Collection
            Next
        
            Set retValue = listOfBlankCols
        End If
    
    Else
    

        Dim origListOfColumnVectors As Collection
        Set origListOfColumnVectors = doSepColumnsInListOfArrayRows(allBoundsAreExpectedToBeAlike, listOfArrayRows)
        
        Dim newListOfColumnVectors As Collection
        Set newListOfColumnVectors = New Collection
        
        Dim lwr As Long
        Dim upr As Long
        glaubs indxsInOrderToSelect, lwr, upr
        
        Dim c As Long
        For c = lwr To upr
        
            Dim indxToInclude As Long
            indxToInclude = indxsInOrderToSelect(c)
        
            newListOfColumnVectors.add origListOfColumnVectors.item(indxToInclude)
        Next
        
        If returnListOfArrayRowsWithLowerBound1AsOpposedToListOfArrayColumns Then
            Set retValue = clocdiloar(newListOfColumnVectors, 1)
        Else
            Set retValue = newListOfColumnVectors
        End If
    End If
    Set doSelectCertainIndexesFromListOfArrayRows = retValue
End Function


Function createArrayWithInitializedValues(lowerRow As Long, upperRow As Long, initValue As Variant)
    Dim resultArrSoFar As Variant
    ReDim resultArrSoFar(lowerRow To upperRow)
    
    fillRngeInArrWithValue resultArrSoFar, lowerRow, upperRow, initValue
    
    createArrayWithInitializedValues = resultArrSoFar
End Function


Function create2DArrayWithInitializedValues(lowerRow As Long, upperRow As Long, lowerCol As Long, upperCol As Long, initValue As Variant)

    Dim resultArrSoFar As Variant
    ReDim resultArrSoFar(lowerRow To upperRow, lowerCol To upperCol)
    
    fillRngeIn2DArrWithValue resultArrSoFar, lowerRow, upperRow, lowerCol, upperCol, initValue
    
    create2DArrayWithInitializedValues = resultArrSoFar
End Function

Function filterRowsIn2DArray_whereFirstRowInArrayIsHeaderRow(dataArr As Variant, setOfAllowedValuesByHeaderName As Dictionary, includeHeaderRow As Boolean) As Collection
    
    Dim rows As Variant
    rows = separateRowsInArray(dataArr, False)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rows, lwr, upr
    
    Dim filteredRows As Collection
    If setOfAllowedValuesByHeaderName.count = 0 Then
        'There is no filter criteria, so we won't filter.
        Set filteredRows = arrayToCollection(rows)
    ElseIf lwr >= upr Then
        'There is either one row, or no row.
        'Since we expect the first row to be our header row, we know there is nothing to filter.
        
        Set filteredRows = arrayToCollection(rows)
    Else
    
        Dim headerRow As Variant
        headerRow = rows(lwr)
        
        Set filteredRows = New Collection
    
        Dim listOf_headerNameAndIndxValue As Collection
        getHeaderNamesAndIndxValues headerRow, listOf_headerNameAndIndxValue, setOfAllowedValuesByHeaderName, rows
        
        Dim c As Long
        For c = lwr To upr
        
            Dim row As Variant
            row = rows(c)
            
            Dim shouldInclude As Boolean
            If c = lwr Then
                shouldInclude = includeHeaderRow
            Else
                shouldInclude = True
                
                Dim x As Long
                x = 1
                
                While (shouldInclude) And (x <= listOf_headerNameAndIndxValue.count)
                    
                    Dim headerNameAndIndxValue As Variant
                    headerNameAndIndxValue = listOf_headerNameAndIndxValue.item(x)
                    
                    Dim curHdrName As String
                    Dim indxValue As Long
                    curHdrName = rlai(headerNameAndIndxValue, 1)
                    indxValue = rlai(headerNameAndIndxValue, 2)
                    
                    Dim allowedValues As JYCORE_Set
                    Set allowedValues = vfd(setOfAllowedValuesByHeaderName, curHdrName, True)
                    
                    Dim valueToTest As Variant
                    atr valueToTest, row(indxValue)
                    
                    If Not allowedValues.exists(valueToTest) Then
                        shouldInclude = False
                    End If
                    
                    x = x + 1
                Wend
            End If
            If shouldInclude Then
                filteredRows.add row
            End If
            
        Next
    End If
    
    Set filterRowsIn2DArray_whereFirstRowInArrayIsHeaderRow = filteredRows
End Function

Sub getHeaderNamesAndIndxValues(headerRow As Variant, ByRef out_listOf_headerNameAndIndxValue As Collection, setOfAllowedValuesByHeaderName As Dictionary, rows As Variant)
    
    Dim desiredHeaderNames As Variant
    desiredHeaderNames = setOfAllowedValuesByHeaderName.keys()

    Dim lwrHdrNames As Long
    Dim uprHdrNames As Long
    glaubs desiredHeaderNames, lwrHdrNames, uprHdrNames
    
    Dim listOf_headerNameAndIndxValue As Collection
    Set listOf_headerNameAndIndxValue = New Collection

    Dim r As Long
    For r = lwrHdrNames To uprHdrNames
        Dim curHdr As String
        curHdr = desiredHeaderNames(r)
        
        Dim indx As Long
        indx = searchArrayLinearly(headerRow, curHdr, True)
        
        If indx = 0 Then
            elwp "Cannot filter by the '" & curHdr & "' field, because it does not exist in our data array!"
        Else
            listOf_headerNameAndIndxValue.add Array(curHdr, indx)
        End If
    Next
    
    Set out_listOf_headerNameAndIndxValue = listOf_headerNameAndIndxValue

End Sub

Function mergeTwoArrays_columnsSideBySide(theBlackRockDataArr As Variant, theRiskSpanDataArr As Variant, throwErrorIfNumRowsAreDifferent As Boolean) As Variant
    Dim mergedArr As Variant
    If dimSize(theBlackRockDataArr, 2) <> dimSize(theRiskSpanDataArr, 2) Then
        elwp "The two arrays do not have the same number of columns!"
        Set mergedArr = Nothing
    
    'JY20101206a - start - This is actually not necessarily an error, because if the last rows in BlackRock cannot be found in RiskSpan, then they will all be blank in the VLookup page, thus making it seem like there are less rows when there are really blank rows.
    'ElseIf dimSize(theBlackRockDataArr, 1) <> dimSize(theriskSpanDataArr, 1) Then
    ElseIf dimSize(theBlackRockDataArr, 1) <> dimSize(theRiskSpanDataArr, 1) And throwErrorIfNumRowsAreDifferent Then
    'JY20101206a - end
        elwp "The two Arrays do not have the same number of rows!"
        Set mergedArr = Nothing
    Else
    
        Dim riskSpanDataArr As Variant
        Dim blackRockDataArr As Variant
        riskSpanDataArr = theRiskSpanDataArr
        blackRockDataArr = theBlackRockDataArr
        
        'JY20101206a - start
        Dim brNumRows As Long
        brNumRows = dimSize(blackRockDataArr, 1)
        
        Dim rsNumRows As Long
        rsNumRows = dimSize(riskSpanDataArr, 1)
        
        If brNumRows < rsNumRows Then
            blackRockDataArr = addRowsTo2DArray(blackRockDataArr, rsNumRows - brNumRows, "")
        ElseIf rsNumRows < brNumRows Then
            riskSpanDataArr = addRowsTo2DArray(riskSpanDataArr, brNumRows - rsNumRows, "")
        End If
        
        
        'JY20101206 - end
    
        Dim br_lwrRow As Long
        Dim br_uprRow As Long
        Dim br_lwrCol As Long
        Dim br_uprCol As Long
        glaubs2D blackRockDataArr, br_lwrRow, br_uprRow, br_lwrCol, br_uprCol
        
        Dim rs_lwrRow As Long
        Dim rs_uprRow As Long
        Dim rs_lwrCol As Long
        Dim rs_uprCol As Long
        glaubs2D riskSpanDataArr, rs_lwrRow, rs_uprRow, rs_lwrCol, rs_uprCol
    
    
        ReDim mergedArr(br_lwrRow To br_uprRow, br_lwrCol To br_lwrCol + 2 * (br_uprCol - br_lwrCol + 1) - 1)
        
        Dim brRow As Long
        For brRow = br_lwrRow To br_uprRow
        
            Dim rsRow As Long
            rsRow = rs_lwrRow + brRow - br_lwrRow
            
            Dim brCol As Long
            For brCol = br_lwrCol To br_uprCol
            
                Dim rsCol As Long
                rsCol = rs_lwrCol + brCol - br_lwrCol
            
                Dim baseCol As Long
                baseCol = (brCol - 1) * 2 + 1
                
                mergedArr(brRow, baseCol) = blackRockDataArr(brRow, brCol)
                mergedArr(brRow, baseCol + 1) = riskSpanDataArr(rsRow, rsCol)
            Next
        Next
    End If
    
    atr mergeTwoArrays_columnsSideBySide, mergedArr
End Function

Function getDictionaryFromColumnInTwoDimArrayWhereTopRowIsHeaderRow(dataArr As Variant, fieldNameForKey As String, fieldNameForValue As String, showEMsgIfDuplicateKeysFound As Boolean, ignoreBlankValues As Boolean) As Dictionary
    
    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D dataArr, lwrRow, uprRow, lwrCol, uprCol
    
    Dim indxOfKeyCol As Long
    Dim key_emsg As String
    indxOfKeyCol = getCusipIndxInArray(dataArr, fieldNameForKey, key_emsg)
    
    Dim indxOfValCol As Long
    Dim val_emsg As String
    indxOfValCol = getCusipIndxInArray(dataArr, fieldNameForValue, val_emsg)
    
    Dim dict As Dictionary
    Set dict = New Dictionary
    
    If key_emsg <> "" Then
        elwp key_emsg
    ElseIf val_emsg <> "" Then
        elwp val_emsg
    Else
        Dim row As Long
        For row = lwrRow To uprRow
            If row = lwrRow Then
                'This is the header row, so no data values here.
                
                'DO NOTHING
            Else
                Dim theKey As Variant
                atr theKey, dataArr(row, indxOfKeyCol)
                
                Dim theVal As Variant
                atr theVal, dataArr(row, indxOfValCol)
                
                If ignoreBlankValues And isBlankValue(theVal) Then
                    'DO NOTHING
                ElseIf dict.exists(theKey) Then
                    If showEMsgIfDuplicateKeysFound Then
                        elwp "The key '" & theKey & "' was encountered more than once!"
                    End If
                Else
                    atd dict, theKey, theVal
                End If
            
            End If
        Next
    End If
    Set getDictionaryFromColumnInTwoDimArrayWhereTopRowIsHeaderRow = dict
End Function

Function getDistinctFieldValuesFromColumnInTwoDimArrayWhereTopRowIsHeaderRow(dataArr As Variant, fieldNameToRetrieve As String) As JYCORE_Set
    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D dataArr, lwrRow, uprRow, lwrCol, uprCol
    
    Dim indxOfChosenCol As Long
    Dim emsg As String
    indxOfChosenCol = getCusipIndxInArray(dataArr, fieldNameToRetrieve, emsg)
    
    Dim distinctValues As JYCORE_Set
    Set distinctValues = New JYCORE_Set
    
    If emsg <> "" Then
        elwp emsg
    Else
        Dim row As Long
        For row = lwrRow To uprRow
            If row = lwrRow Then
                'This is the header row, so no data values here.
                
                'DO NOTHING
            Else
                Dim searchValue As Variant
                atr searchValue, dataArr(row, indxOfChosenCol)
                
                distinctValues.add searchValue
            
            End If
        Next
    End If
    Set getDistinctFieldValuesFromColumnInTwoDimArrayWhereTopRowIsHeaderRow = distinctValues
End Function

Function addRowsTo2DArray(theArr As Variant, numRows As Long, initialValue As Variant) As Variant

    If numRows <= 0 Then
        elwp "Please specify a positive number for the number of rows you want to add!"
    Else
    
        Dim lwrRow As Long
        Dim uprRow As Long
        Dim lwrCol As Long
        Dim uprCol As Long
        glaubs2D theArr, lwrRow, uprRow, lwrCol, uprCol
        
        Dim NewArr As Variant
        ReDim NewArr(lwrRow To uprRow + numRows, lwrCol To uprCol)
        
        copy2DArrInto theArr, NewArr
        fillRngeIn2DArrWithValue NewArr, uprRow + 1, uprRow + numRows, lwrCol, uprCol, initialValue
        
    End If
    
    atr addRowsTo2DArray, NewArr
    
End Function

Sub fillRngeIn2DArrWithValue(ByRef mod_arr As Variant, startRow As Long, endRow As Long, startCol As Long, endCol As Long, theVal As Variant)
    Dim r As Long
    For r = startRow To endRow
        Dim c As Long
        For c = startCol To endCol
            atr mod_arr(r, c), theVal
        Next
    Next
End Sub

Function convertArrayToCollectionUnlessAlreadyCollection(row As Variant)
    If isCollection(row) Then
        Set convertArrayToCollectionUnlessAlreadyCollection = copyCollection(castToCollection(row))
    Else
        Set convertArrayToCollectionUnlessAlreadyCollection = arrayToCollection(row)
    End If
End Function


Sub fillRngeInArrWithValue(ByRef mod_arr As Variant, startRow As Long, endRow As Long, theVal As Variant)
    Dim r As Long
    For r = startRow To endRow
        atr mod_arr(r), theVal
    Next
End Sub

Function maxSizeOfArrays(arrays As Variant) As Long
    Dim maxSizeSoFar As Long
    maxSizeSoFar = 0
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrays, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim curArr As Variant
        curArr = arrays(c)
        
        Dim curSize As Long
        curSize = dimSize(curArr, 1)
        
        maxSizeSoFar = wsFunctionMax(maxSizeSoFar, curSize)
    Next
    
    maxSizeOfArrays = maxSizeSoFar
    
End Function

Function appendColumnToListOfArrayRows(origListOfArrayRows As Collection, columnOfValuesToAppend As Collection) As Collection
    
    Dim adjListOfArrayRows As Collection
    Set adjListOfArrayRows = New Collection
    
    Dim sz As Long
    sz = ccsz(Array(origListOfArrayRows, columnOfValuesToAppend), True)
    
    Dim dx As Long
    For dx = 1 To origListOfArrayRows.count
        Dim origArrayRow As Variant
        origArrayRow = origListOfArrayRows.item(dx)
        
        Dim valueToAppend As Variant
        atr valueToAppend, columnOfValuesToAppend.item(dx)

        adjListOfArrayRows.add allocateAndAddOneItemToEndOfArray(origArrayRow, valueToAppend)
    Next
    
    Set appendColumnToListOfArrayRows = adjListOfArrayRows
End Function

Function dropLastColumnInCollectionOfArrayRows(listOfArrayRows As Collection) As Collection

    Dim numCols As Long
    numCols = casz(kta(listOfArrayRows), True)
    
    If numCols = -1 Then
        Set dropLastColumnInCollectionOfArrayRows = Nothing
    Else
        
        Dim newColl As Collection
        Set newColl = New Collection
        
        Dim c As Long
        For c = 1 To listOfArrayRows.count
            Dim curRow As Variant
            curRow = listOfArrayRows.item(c)
            
            Dim adjustedRow As Variant
            adjustedRow = removeLastElementFromArrayRow(curRow)
            
            newColl.add adjustedRow
        Next
        
        Set dropLastColumnInCollectionOfArrayRows = newColl
        
    End If
        
    
End Function

'removeLastElementFromArray(termInMonths_fee_wam_grossCoupon_netCoupon_balanceToDistribute, termInMonths_fee_wam_grossCoupon_netCoupon)
Function removeLastElementFromArrayRow_returnValueOfLastElement(curRow As Variant, ByRef out_newArrRow As Variant) As Variant
    
    If isNothing(curRow) Then
        elwp "Please pass in an array row."
        Set removeLastElementFromArrayRow_returnValueOfLastElement = Nothing
    Else
    
        Dim lwr As Long
        Dim upr As Long
        glaubs curRow, lwr, upr
        
        Dim NewArr As Variant
        ReDim NewArr(lwr To upr - 1)
        
        Dim c As Long
        For c = lwr To upr - 1
            atr NewArr(c), curRow(c)
        Next
        
        Dim lastElement As Variant
        atr lastElement, curRow(upr)
        
        out_newArrRow = NewArr
        atr removeLastElementFromArrayRow_returnValueOfLastElement, lastElement
    End If
End Function
Function removeLastElementFromArrayRow(curRow As Variant) As Variant

    Dim NewArr As Variant
    Dim lastElement As Variant
    atr lastElement, removeLastElementFromArrayRow_returnValueOfLastElement(curRow, NewArr)
    
    atr removeLastElementFromArrayRow, NewArr
    
End Function

Function concatenateTwoArrays(array1 As Variant, array2 As Variant) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs array1, lwr, upr
    
    Dim szArr2 As Long
    szArr2 = dimSize(array2, 1)
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To upr + szArr2)
    
    Dim c As Long
    For c = lwr To upr
        NewArr(c) = array1(c)
    Next
    
    Dim d As Long
    For d = 1 To szArr2
        NewArr(upr + d) = rlai(array2, d)
    Next
    
    concatenateTwoArrays = NewArr

End Function

Function removeXElementsFromBeginningOfArray(theArr As Variant, numToRemove As Long)

    Dim lwr As Long
    Dim upr As Long
    glaubs theArr, lwr, upr
    
    Dim newLwr As Long
    newLwr = lwr + numToRemove
    
    Dim NewArr As Variant
    ReDim NewArr(newLwr To upr)
    
    Dim c As Long
    For c = newLwr To upr
        NewArr(c) = theArr(c)
    Next
    
    removeXElementsFromBeginningOfArray = NewArr

End Function

Function removeXElementsFromEndOfArray(theArr As Variant, numToRemove As Long)

    Dim lwr As Long
    Dim upr As Long
    glaubs theArr, lwr, upr
    
    Dim newUpr As Long
    newUpr = upr - numToRemove
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To newUpr)
    
    Dim c As Long
    For c = lwr To newUpr
        NewArr(c) = theArr(c)
    Next
    
    removeXElementsFromEndOfArray = NewArr

End Function

Function anyInArrayListAreBlank(arrayList As Variant) As Boolean
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrayList, lwr, upr
    
    Dim found As Boolean
    found = False
    
    Dim c As Long
    c = lwr
    
    While (Not found) And (c <= upr)
    
        If isBlankValue(arrayList(c)) Then
            found = True
        End If
    
        c = c + 1
    Wend
    
    anyInArrayListAreBlank = found
    
End Function

Function anyInArrayListAreNotBlank(arrayList As Variant) As Boolean
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrayList, lwr, upr
    
    Dim found As Boolean
    found = False
    
    Dim c As Long
    c = lwr
    
    While (Not found) And (c <= upr)
    
        If Not isBlankValue(arrayList(c)) Then
            found = True
        End If
    
        c = c + 1
    Wend
    
    anyInArrayListAreNotBlank = found
    
End Function

Function allInArrayListAreBlank(arrayList As Variant) As Boolean
    allInArrayListAreBlank = Not anyInArrayListAreNotBlank(arrayList)
End Function

Function allIArrayAreBlank(arr As Variant) As Boolean
    allIArrayAreBlank = eitherCheckIfAllArrayElementsAreBlankOrcheckIfTheyAreArrays(arr, False)
End Function

Function allArrayElementsAreArrays(arr As Variant) As Boolean
    allArrayElementsAreArrays = eitherCheckIfAllArrayElementsAreBlankOrcheckIfTheyAreArrays(arr, True)
End Function

Function checkIfIsArrayOrIfIsBlank(val As Variant, checkForArraysVsBlanks As Boolean) As Boolean
    If checkForArraysVsBlanks Then
        checkIfIsArrayOrIfIsBlank = IsArray(val)
    Else
        checkIfIsArrayOrIfIsBlank = isBlankValue(val)
    End If
End Function

Function eitherCheckIfAllArrayElementsAreBlankOrcheckIfTheyAreArrays(arr As Variant, checkForArraysVsBlanks As Boolean) As Boolean

    Dim dimensionsOfOrigArray As Long
    dimensionsOfOrigArray = numDims(arr)
    
    Dim adjArray As Variant
    If dimensionsOfOrigArray = 1 Then
        adjArray = arr
    ElseIf dimensionsOfOrigArray = 2 Then
        adjArray = twoDimArrayToOneDimArray(arr)
    Else
        Set adjArray = Nothing
    End If
    
    Dim numDimensions As Long
    numDimensions = numDims(adjArray)
    
    Dim result As Boolean
    If isNothing(adjArray) Then
        elwp "Cannot yet support arrays of dimension '" & numDimensions & "'!"
        result = False 'arbitrary

    Else
        Dim daResult As Boolean
        daResult = True
        
        Dim lwr As Long
        Dim upr As Long
        glaubs adjArray, lwr, upr
        
        Dim curIndx As Long
        curIndx = lwr
        
        While daResult And (curIndx <= upr)
            Dim curElement As Variant
            atr curElement, adjArray(curIndx)
            
            If Not checkIfIsArrayOrIfIsBlank(curElement, checkForArraysVsBlanks) Then
                daResult = False
            End If
            
            curIndx = curIndx + 1
        Wend
        
        result = daResult
    End If
    
    eitherCheckIfAllArrayElementsAreBlankOrcheckIfTheyAreArrays = daResult

End Function

Sub setAllValuesInArrayToSingleValue(ByRef mod_arr As Variant, theValue As Variant)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs mod_arr, lwr, upr

    Dim c As Long
    For c = lwr To upr
        If IsObject(theValue) Then
            Set mod_arr(c) = theValue
        Else
            mod_arr(c) = theValue
        End If
    Next
End Sub

Function removeArrayRowsWhereValueInCertainIndexIsBlank(indx As Long, listOfArrayRows As Collection)

    Dim newList As Collection
    Set newList = New Collection

    Dim c As Long
    For c = 1 To listOfArrayRows.count
        Dim arrRow As Variant
        arrRow = listOfArrayRows.item(c)
        
        If isBlankValue(arrRow(indx)) Then
            'DO NOTHING
        Else
            newList.add arrRow
        End If
    Next

    Set removeArrayRowsWhereValueInCertainIndexIsBlank = newList
End Function

Function convertTwoDimArrayRowToOneDimArray(arr As Variant)

    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D arr, lwrRow, uprRow, lwrCol, uprCol
    
    If lwrRow <> uprRow Then
        elwp "Please pass in a two-dim array ROW!!!"
        Set convertTwoDimArrayRowToOneDimArray = Nothing
    Else
    
        Dim row As Long
        row = lwrRow
    
        Dim oneDimArr As Variant
        ReDim oneDimArr(lwrCol To uprCol)
        
        Dim c As Long
        For c = lwrCol To uprCol
            atr oneDimArr(c), arr(row, c)
        Next
        
        convertTwoDimArrayRowToOneDimArray = oneDimArr
    End If

End Function

Function addElementToBeginningOfArray(theArr As Variant, valueToAdd As Variant)

    Dim lwr As Long
    Dim upr As Long
    glaubs theArr, lwr, upr
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To upr + 1)
    
    atr NewArr(lwr), valueToAdd
    
    Dim c As Long
    For c = lwr To upr
        atr NewArr(c + 1), theArr(c)
    Next

    addElementToBeginningOfArray = NewArr
End Function

Function allocateAndAddOneItemToEndOfArray(arr As Variant, theValToAdd As Variant) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To upr + 1)
    
    copyArrIntoAnotherArrAtSameIndexes arr, NewArr, lwr, upr
    
    atr NewArr(upr + 1), theValToAdd
    
    allocateAndAddOneItemToEndOfArray = NewArr

End Function

Function convertAllInArrayToLongsIfPossible(arr As Variant) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim theVal As Variant
        atr theVal, arr(c)
        
        Dim newVal As Variant
        If isInteger(theVal) Then
            newVal = CLng(theVal)
        Else
            atr newVal, theVal
        End If
        
        atr NewArr(c), newVal
    Next
    
    convertAllInArrayToLongsIfPossible = NewArr
End Function

Function extractNumberFromArray(arr As Variant, convToDoubles As Boolean) As Collection

    Dim nums As Collection
    Set nums = New Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim theVal As Variant
        theVal = arr(c)
        
        If isNumber(theVal) Then
        
            If convToDoubles Then
                nums.add CDbl(theVal)
            Else
                nums.add theVal
            End If
        End If
    Next
    
    Set extractNumberFromArray = nums
    
End Function

Function padNumbersInArray(arr As Variant, padChar As String) As Variant
    
    Dim extractedNumbers As Collection
    Set extractedNumbers = extractNumberFromArray(arr, True)
    
    Dim padLength As Long
    padLength = maxStringLength(kta(extractedNumbers))
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim element As Variant
        element = arr(c)
        
        Dim adjElement As Variant
        If isNumber(element) Then
            Dim elementAsNum As Double
            elementAsNum = element
            
            Dim prefix As String
            If elementAsNum < 0 Then
                prefix = "-"
            Else
                prefix = ""
            End If
            
            Dim chosenPadLength As Long
            chosenPadLength = padLength - Len(prefix)
            
            adjElement = prefix & padLeft(CStr(element), chosenPadLength, padChar)
        Else
            adjElement = element
        End If
           
        NewArr(c) = adjElement
    Next
    
    padNumbersInArray = NewArr
End Function

Function wrapEachArrayElementInItsOwnArray(arr As Variant) As Variant
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim arr2 As Variant
    ReDim arr2(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        arr2(c) = Array(arr(c))
    Next
    
    wrapEachArrayElementInItsOwnArray = arr2
End Function

'ignoreNonNumerics = false
Function maxOfArray(arr As Variant, ByRef mod_emsgs__orNothingToIgnoreNonNumericValues As Variant) As Variant

    Dim maxSoFar As Variant
    Set maxSoFar = Nothing
    
    If Not IsArray(arr) Then
        elwp "Please pass in an array!"
    Else

        Dim lwr As Long
        Dim upr As Long
        glaubs arr, lwr, upr
        
        
        Dim c As Long
        For c = lwr To upr
            Dim curItem As Variant
            atr curItem, arr(c)
            
            If Not isNumberOrDate(curItem) Then
                If isNothing(mod_emsgs__orNothingToIgnoreNonNumericValues) Then
                    'DO NOTHING
                Else
                    mod_emsgs__orNothingToIgnoreNonNumericValues.add "Encountered a non-numeric value: " & representAsString(curItem)
                End If
            Else
                If isNothing(maxSoFar) Then
                    atr maxSoFar, curItem
                Else
                    If curItem > maxSoFar Then
                        atr maxSoFar, curItem
                    Else
                        'DO NOTHING
                    End If
                End If
            End If
        Next
    End If
    
    atr maxOfArray, maxSoFar
End Function

Function isNumberOrDate(thng As Variant) As Boolean
    isNumberOrDate = (isNumber(thng) Or IsDate(thng))
End Function

Function minOfArray(arr As Variant, ByRef mod_emsgs__orNothingToIgnoreNonNumericValues As Variant)

    Dim minSoFar As Variant
    Set minSoFar = Nothing
    
    If Not IsArray(arr) Then
        elwp "Please pass in an array!"
    Else
    
        Dim lwr As Long
        Dim upr As Long
        glaubs arr, lwr, upr
        
        Dim c As Long
        For c = lwr To upr
            Dim curItem As Variant
            atr curItem, arr(c)
            
            If Not isNumberOrDate(curItem) Then
                If isNothing(mod_emsgs__orNothingToIgnoreNonNumericValues) Then
                    'DO NOTHING
                Else
                    mod_emsgs__orNothingToIgnoreNonNumericValues.add "Encountered a non-numeric value: " & representAsString(curItem)
                End If
            Else
                If isNothing(minSoFar) Then
                    minSoFar = curItem
                Else
                
                    Dim Temp As Variant
                    If IsDate(curItem) Then
                        Temp = CDate(curItem)
                    Else
                        Temp = curItem
                    End If
                
                    minSoFar = wsFunctionMin(CDbl(minSoFar), CDbl(Temp))
                End If
            End If
        Next
    End If
    atr minOfArray, minSoFar

End Function

Function normalizeLowerBoundOfArrays(listOfArrays As Collection, desiredLowerBound As Long) As Collection
    Dim newList As Collection
    Set newList = New Collection
    
    Dim c As Long
    For c = 1 To listOfArrays.count
        Dim oldArr As Variant
        oldArr = listOfArrays.item(c)
        
        Dim NewArr As Variant
        NewArr = changeLowerBoundOfArray(oldArr, desiredLowerBound)
        
        newList.add NewArr
    Next
    
    Set normalizeLowerBoundOfArrays = newList

End Function

Function changeLowerBoundOfArray(oldArr As Variant, desiredLowerBound As Long) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs oldArr, lwr, upr

    Dim NewArr As Variant
    If lwr = desiredLowerBound Then
        NewArr = oldArr
    Else
        Dim size As Long
        size = dimSize(oldArr, 1)
        
        ReDim NewArr(desiredLowerBound To desiredLowerBound + size - 1)
        
        Dim c As Long
        For c = 1 To size
            srai NewArr, c, rlai(oldArr, c)
        Next
            
    End If
    changeLowerBoundOfArray = NewArr
    
End Function

Function addValueToEndOfEachArray(arrOfArrs As Variant, val As Variant) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs arrOfArrs, lwr, upr
    
    Dim newArrOfArrs As Variant
    ReDim newArrOfArrs(lwr To upr)

    Dim c As Long
    For c = lwr To upr
        
        Dim arr As Variant
        arr = arrOfArrs(c)
        
        Dim NewArr As Variant
        NewArr = allocateAndAddOneItemToEndOfArray(arr, val)
        
        newArrOfArrs(c) = NewArr
        
    Next
    
    addValueToEndOfEachArray = newArrOfArrs
    
End Function

Function lcaseAllArrElementsWherePossible(oneDimentionalArray As Variant) As Variant
    Dim lwr As Long
    Dim upr As Long
    glaubs oneDimentionalArray, lwr, upr
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        atr NewArr(c), lcaseIfPossible(oneDimentionalArray(c))
    Next
    
    lcaseAllArrElementsWherePossible = NewArr
End Function

Function wrapInArrayIfNotAlreadyAnArray(keyNameOrArrOfKeyNames As Variant) As Variant
    Dim arrOfKeyNames As Variant
    If Not IsArray(keyNameOrArrOfKeyNames) Then
        arrOfKeyNames = Array(keyNameOrArrOfKeyNames)
    Else
        arrOfKeyNames = keyNameOrArrOfKeyNames
    End If
    
    wrapInArrayIfNotAlreadyAnArray = arrOfKeyNames
End Function


Function convertListOfArrayRowsIntoTransposed2DArray(listOfArrayRows As Collection) As Variant
    Dim listOfColumnData As Collection
    Set listOfColumnData = sciloar(True, listOfArrayRows)
    
    Dim numCols As Long
    numCols = listOfColumnData.count
    
    Dim theArray As Variant
    ReDim theArray(1 To numCols, 1 To listOfArrayRows.count)
    Dim c As Long
    For c = 1 To numCols
        setRowIn2dArray theArray, c, collectionToArray(listOfColumnData.item(c))
    Next
    
    convertListOfArrayRowsIntoTransposed2DArray = theArray
End Function


Function convertListOfArrayRowsInto2DArray(listOfArrayRows As Collection) As Variant

    Dim numRows As Long
    numRows = listOfArrayRows.count
    
    Dim numCols As Long
    numCols = casz(collectionToArray(listOfArrayRows), True)
    
    Dim theArray As Variant
    ReDim theArray(1 To numRows, 1 To numCols)
    Dim r As Long
    For r = 1 To numRows
        setRowIn2dArray theArray, r, listOfArrayRows.item(r)
    Next
    
    convertListOfArrayRowsInto2DArray = theArray
End Function

Function convertListOfArrayColsInto2DArray(listOfArrayCols As Collection) As Variant

    Dim numCols As Long
    numCols = listOfArrayCols.count
    
    Dim numRows As Long
    numRows = casz(collectionToArray(listOfArrayCols), True)
    
    Dim theArray As Variant
    ReDim theArray(1 To numRows, 1 To numCols)
    Dim c As Long
    For c = 1 To numCols
        setColIn2dArray theArray, c, listOfArrayCols.item(c)
    Next
    
    convertListOfArrayColsInto2DArray = theArray
End Function

Sub setColIn2dArray(ByRef mod_arr2D As Variant, whichCol As Long, arrayCol As Variant)

    Dim lwr As Long
    Dim upr As Long
    glaubs arrayCol, lwr, upr
    
    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D mod_arr2D, lwrRow, uprRow, lwrCol, uprCol
    
    If whichCol > uprCol Or whichCol < lwrCol Then
        elwp "Invalid col: " & whichCol
    Else
        If upr - lwr + 1 <> uprRow - lwrRow + 1 Then
            elwp "The passed-in array is not the same height as the array that you are writing to!"
        Else
    
            Dim r As Long
            For r = lwr To upr
                atr mod_arr2D(r - lwr + lwrRow, whichCol), arrayCol(r)
            Next
        End If
    End If

End Sub

'Moved from JYYB_CMOsInAddIn.bas
Sub setRowIn2dArray(ByRef mod_arr2D As Variant, whichRow As Long, arrayRow As Variant)

    Dim lwr As Long
    Dim upr As Long
    glaubs arrayRow, lwr, upr
    
    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D mod_arr2D, lwrRow, uprRow, lwrCol, uprCol
    
    If whichRow > uprRow Or whichRow < lwrRow Then
        elwp "Invalid row: " & whichRow
    Else
        If upr - lwr + 1 <> uprCol - lwrCol + 1 Then
            elwp "The passed-in array is not the same width as the array that you are writing to!"
        Else
    
            Dim c As Long
            For c = lwr To upr
                atr mod_arr2D(whichRow, c - lwr + lwrCol), arrayRow(c)
            Next
        End If
    End If

End Sub


Function filterOutRowsIfAnyOneOfCertainIndexesAreBlank(listOfArrayRows As Collection, arrOfIndxesToCheckForBlanks As Variant) As Collection
    Dim newList As Collection
    Set newList = New Collection
    
    Dim c As Long
    For c = 1 To listOfArrayRows.count
        Dim arrRow As Variant
        arrRow = listOfArrayRows.item(c)
        
        Dim lwr As Long
        Dim upr As Long
        glaubs arrOfIndxesToCheckForBlanks, lwr, upr
        
        Dim shouldAdd As Boolean
        shouldAdd = True
        
        Dim d As Long
        For d = lwr To upr
            
            Dim indxToCheck As Long
            indxToCheck = arrOfIndxesToCheckForBlanks(d)
            
            Dim theValue As Variant
            theValue = rlai(arrRow, indxToCheck)
            
            If isBlankValue(theValue) Then
                shouldAdd = False
            Else
                'DO NOTHING
            End If
            
        Next
        
        If shouldAdd Then
            newList.add arrRow
        End If
        
    Next
    
    Set filterOutRowsIfAnyOneOfCertainIndexesAreBlank = newList
End Function


Function convertAllDatesIn2DArrayToYYYYMMDD(twoDimArray As Variant, delimiter As String, strictVsFlexible As Boolean) As Variant

    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D twoDimArray, lwrRow, uprRow, lwrCol, uprCol
    
    Dim NewArr As Variant
    ReDim NewArr(lwrRow To uprRow, lwrCol To uprCol)
    
    Dim r As Long
    For r = lwrRow To uprRow
        Dim c As Long
        For c = lwrCol To uprCol
            NewArr(r, c) = dateToYYYYMMDD_ifPossible_customDelimiter(twoDimArray(r, c), delimiter, strictVsFlexible)
        Next
    Next
    
    convertAllDatesIn2DArrayToYYYYMMDD = NewArr

End Function

Function splitArraysVerticallyOrHorizontally(twoDimArray As Variant, splitarrayshorizontallyvsVertically As Boolean, maxArraySize As Long) As Collection

    Dim listOfArrays As Collection
    Set listOfArrays = New Collection
    
    Dim curArrayToSplit As Variant
    curArrayToSplit = twoDimArray
    
    
    Dim sizeOfDimensionToSplit As Long
    sizeOfDimensionToSplit = getNumRowsOrNumColumnsOfTwoDimArray(curArrayToSplit, splitarrayshorizontallyvsVertically)
    
    While sizeOfDimensionToSplit > maxArraySize
    
        
        Dim newFirstArray As Variant
        Dim newSecondArray As Variant
        splitArrayInTwo newFirstArray, newSecondArray, curArrayToSplit, maxArraySize, splitarrayshorizontallyvsVertically
    
        curArrayToSplit = newSecondArray
        listOfArrays.add newFirstArray
    
        sizeOfDimensionToSplit = getNumRowsOrNumColumnsOfTwoDimArray(curArrayToSplit, splitarrayshorizontallyvsVertically)
    
    Wend
    
    listOfArrays.add curArrayToSplit
    
    Set splitArraysVerticallyOrHorizontally = listOfArrays

End Function

Function splitArrayInTwo(ByRef out_newFirstArray As Variant, ByRef out_newSecondArray As Variant, curArrayToSplit As Variant, maxArraySize As Long, splitarrayshorizontallyvsVertically As Boolean)
    
    Dim lwrRow As Long
    Dim uprRow As Long
    Dim lwrCol As Long
    Dim uprCol As Long
    glaubs2D curArrayToSplit, lwrRow, uprRow, lwrCol, uprCol
    
    Dim firstRelRow As Long
    Dim firstRelCol As Long
    firstRelRow = 1
    firstRelCol = 1
    
    
    
    Dim lastRelRow As Long
    Dim lastRelCol As Long
    Dim second_firstRelCol As Long
    Dim second_lastRelCol As Long
    Dim second_firstRelRow As Long
    Dim second_lastRelRow As Long
    If splitarrayshorizontallyvsVertically Then
        lastRelRow = maxArraySize - lwrRow + 1
        lastRelCol = uprCol - lwrCol + 1
        
        second_firstRelCol = firstRelCol
        second_lastRelCol = lastRelCol
        second_firstRelRow = lastRelRow + 1
        second_lastRelRow = uprRow - lwrRow + 1
    Else
        lastRelCol = maxArraySize - lwrCol + 1
        lastRelRow = uprRow - lwrRow + 1
        second_firstRelRow = firstRelRow
        second_lastRelRow = lastRelRow
        second_firstRelCol = lastRelCol + 1
        second_lastRelCol = uprCol - lwrCol + 1
    End If
    
    out_newFirstArray = getSubsetOfTwoDimArray(curArrayToSplit, firstRelRow, lastRelRow, firstRelCol, lastRelCol)
    out_newSecondArray = getSubsetOfTwoDimArray(curArrayToSplit, second_firstRelRow, second_lastRelRow, second_firstRelCol, second_lastRelCol)

End Function

Function getNumRowsOrNumColumnsOfTwoDimArray(curArr As Variant, rowsVsCols As Boolean) As Long
    If rowsVsCols Then
        getNumRowsOrNumColumnsOfTwoDimArray = dimSize(curArr, 1) 'numRows
    Else
        getNumRowsOrNumColumnsOfTwoDimArray = dimSize(curArr, 2) 'numCols
    End If
End Function

Function getSubsetOfTwoDimArray(srcArray As Variant, firstRelRow As Long, lastRelRow As Long, firstRelCol As Long, lastRelCol As Long) As Variant
    
    Dim NewArr As Variant
    ReDim NewArr(firstRelRow To lastRelRow, firstRelCol To lastRelCol)
    
    Dim row As Long
    For row = firstRelRow To lastRelRow
    
        Dim col As Long
        For col = firstRelCol To lastRelCol
        
            atr NewArr(row, col), rlai_2d(srcArray, row, col)
        Next
    Next
    
    getSubsetOfTwoDimArray = NewArr
End Function

Function removeDuplicateArrayRows(listOfArrayRowsWhereEachArrayRowIsAssumedToBeOfTheSameLength As Collection) As Collection
    
    Dim blankStringByNestedPath As Dictionary
    Set blankStringByNestedPath = New Dictionary
    
    Dim c As Long
    For c = 1 To listOfArrayRowsWhereEachArrayRowIsAssumedToBeOfTheSameLength.count
        Dim arrRow As Variant
        arrRow = listOfArrayRowsWhereEachArrayRowIsAssumedToBeOfTheSameLength.item(c)
        
        setValueForNestedDictionaryPath blankStringByNestedPath, arrRow, "", False, True
    Next
    Set removeDuplicateArrayRows = getNestedDictionaryPaths(blankStringByNestedPath, False)
End Function

Function convertTableArrayToDictionaryOfColData(arrayContainingHeaderAndData As Variant) As Variant
    
    Dim tableRows As Long
    Dim tableCols As Long
    tableRows = dimSize(arrayContainingHeaderAndData, 1)
    tableCols = dimSize(arrayContainingHeaderAndData, 2)
    
    Dim colDataByFieldName_orEMsg As Variant
    If tableRows <= 0 Then
        colDataByFieldName_orEMsg = "No rows were returned!"
    ElseIf tableCols <= 0 Then
        colDataByFieldName_orEMsg = "No cols were returned!"
    Else
    
        Dim colDataByFieldName As Dictionary
        Set colDataByFieldName = New Dictionary

        Dim c As Long
        For c = 1 To tableCols
            Dim fieldName As String
            fieldName = rlai_2d(arrayContainingHeaderAndData, 1, c)
            
            Dim colData As Collection
            Set colData = New Collection
            
            Dim d As Long
            For d = 2 To tableRows
                colData.add rlai_2d(arrayContainingHeaderAndData, d, c)
            Next
            
            atd colDataByFieldName, fieldName, colData
            
        Next
        
        Set colDataByFieldName_orEMsg = colDataByFieldName
    End If
    
    Set convertTableArrayToDictionaryOfColData = colDataByFieldName_orEMsg
End Function

Attribute VB_Name = "JYCORE_CastingAndTypeChecking"
Option Explicit

Function isRnge(potential As Variant) As Boolean
    isRnge = TypeName(potential) = "Range"
End Function

Function isCollection(potential As Variant) As Boolean
    isCollection = TypeName(potential) = "Collection"
End Function

Function isSet(potential As Variant) As Boolean
    isSet = TypeName(potential) = "JYCORE_Set"
End Function

Function castToCollection(coll As Variant) As Collection
    Set castToCollection = coll
End Function

Function castToSet(theSet As Variant) As JYCORE_Set
    Set castToSet = theSet
End Function

Function isString(potential As Variant) As Boolean
    isString = TypeName(potential) = "String"
End Function

Function isBoolean(potential As Variant) As Boolean
    isBoolean = TypeName(potential) = "Boolean"
End Function

Function isNumber(potential As Variant) As Boolean
    isNumber = (Not IsEmpty(potential)) And IsNumeric(potential)
End Function

'JY20140718a - start - tagging of changes from Reza's Dev Build
'Function isInteger(potential As Variant) As Boolean
Function isInteger_popupOptional(potential As Variant, showPopup As Boolean) As Boolean
'JY20140718a - end

On Error GoTo ehs

   If Not isNumber(potential) Then
                'JY20140718a - start - tagging of changes from Reza's Dev Build
                'isInteger = False
        isInteger_popupOptional = False
                'JY20140718a - end - tagging of changes from Reza's Dev Build
    Else
                'JY20140718a - start - tagging of changes from Reza's Dev Build
                'isInteger = CDbl(potential) = CLng(potential)
        isInteger_popupOptional = CDbl(potential) = CLng(potential)
                'JY20140718a - end - tagging of changes from Reza's Dev Build
    End If
    
GoTo ehe
ehs:

    Dim errDesc As String
    errDesc = Err.description
    
        'JY20140718a - start - tagging of changes from Reza's Dev Build
    'If errDesc = "Overflow" Then
    '    elwp "The number '" & potential & "' seems to be an integer, but is too big... so the system will not recognize it as an integer."
    'Else
    '    elwp "Could not determine if a number was an integer.  Msg:  " & Err.Description & CHAR_CRLF & CHAR_CRLF & "(we will assume NO)"
    'End If
        '
    'isInteger = False
    Dim emsg As String
    If errDesc = "Overflow" Then
        emsg = "The number '" & potential & "' seems to be an integer, but is too big... so the system will not recognize it as an integer."
    Else
        emsg = "Could not determine if a number was an integer.  Msg:  " & Err.description & CHAR_CRLF & CHAR_CRLF & "(we will assume NO)"
    End If
    
    If showPopup Then
        elwp emsg
    Else
        elg emsg
    End If

    isInteger_popupOptional = False
        
        'JY20140718a - end - tagging of changes from Reza's Dev Build
ehe:
On Error GoTo 0
'JY20140718a - start - tagging of changes from Reza's Dev Build
End Function

Function isInteger(potential As Variant) As Boolean
    isInteger = isInteger_popupOptional(potential, True)
'JY20140718a - end - tagging of changes from Reza's Dev Build
End Function

Function castToDictionary(potential As Variant) As Dictionary
    Set castToDictionary = potential
End Function

Function isDictionary(potential As Variant) As Boolean
    isDictionary = TypeName(potential) = "Dictionary"
End Function

Function castToWorkbook(potential As Variant) As Workbook
    Set castToWorkbook = potential
End Function

Function castToWorksheet(potential As Variant) As Worksheet
    Set castToWorksheet = potential
End Function

Function isWorkbook(potential As Variant) As Boolean
    isWorkbook = TypeName(potential) = "Workbook"
End Function

Function isWorksheet(potential As Variant) As Boolean
    isWorksheet = TypeName(potential) = "Worksheet"
End Function

Function castToRnge(potential As Variant) As Range
    Set castToRnge = potential
End Function

Function convertToNumIfPossible(theVal As Variant) As Variant
    If isNumber(theVal) Then
        convertToNumIfPossible = CDbl(theVal)
    Else
        convertToNumIfPossible = theVal
    End If
End Function

Function castToVariant(potential As Variant) As Variant
    Set castToVariant = potential
End Function

Attribute VB_Name = "JYCORE_FilesAndFolders"
Option Explicit

Public Const WEB_SITE_DELIMITER_IF_SHOULD_OPEN_AS_TEXT As String = ""
Public Const WEB_SITE_READ_ONLY As Boolean = True
Public Const WEB_SITE_UPDATE_LINKS As Boolean = False
Public Const WEB_SITE_WB_VS_WEB_SITE As Boolean = False

Public Const EXTENSION_DELIMITER As String = "."

Sub selectFolderAndWritePathToRnge(rnge As Range, title As String)

    Dim existingPath As String
    existingPath = gvl(rnge)
    
    Dim folderPath As String
    folderPath = getFolderPathFromFilePath(existingPath)
    
    If folderPath <> "" Then
        ChDir folderPath
    End If
    
    Dim folder As Variant
    folder = selectFolder(title, folderPath)
    
    If folder = "" Then
        'The user cancelled the operation.
        
        'DO NOTHING
    Else
        svl rnge, folder
    End If
    

End Sub

Sub selectFileAndWritePathToRnge(rnge As Range, title As String)

    
    Dim existingPath As String
    existingPath = gvl(rnge)
    
    Dim fullPath As Variant
    fullPath = askUserForFileName(existingPath, title)
    
    If fullPath = False Then
        'The user cancelled the operation.
        
        'DO NOTHING
    Else
        svl rnge, fullPath
    End If

End Sub

Sub selectFileAndWriteFolderAndFileNameToCells(folderNameCell As Range, fileNameCell As Range, title As String)

    
    Dim existingFolderName As String
    Dim existingFileName As String
    existingFolderName = gvl(folderNameCell)
    existingFileName = gvl(fileNameCell)
    
    Dim existingPath As String
    existingPath = appendToPath(existingFolderName, existingFileName)
    
    Dim fullPath As Variant
    fullPath = askUserForFileName(existingPath, title)
    
    If fullPath = False Then
        'The user cancelled the operation.
        
        'DO NOTHING
    Else
    
        Dim folderPath As String
        Dim fileName As String
        separateFilePathIntoFolderPathAndFileName CStr(fullPath), folderPath, fileName
    
        svl folderNameCell, folderPath
        svl fileNameCell, fileName
    End If

End Sub

Function askUserForFileName(optExistingPath As String, title As String) As Variant

    Dim folderPath As String
    folderPath = getFolderPathFromFilePath(optExistingPath)
    
    If folderPath <> "" Then
        changeDir folderPath
    End If
    
    Dim fileName As Variant
    fileName = Application.GetOpenFilename(title:=title)

    atr askUserForFileName, fileName

End Function

'This method was taken from: http://www.your-save-time-and-improve-quality-technologies-online-resource.com/vba-select-folder.html
Function selectFolder(Optional title As String, Optional topFolder As String) As String
    Dim objShell As New Shell32.Shell

'If you use 16384 instead of 1 on the next line,
'files are also displayed
    Dim objFolder As Shell32.folder
    Set objFolder = objShell.BrowseForFolder _
                            (0, title, 1, topFolder)
    If Not objFolder Is Nothing Then
        selectFolder = objFolder.Items.item.path
    End If
    
    'For Excel 2002 and above, uncomment this:

'    Dim fileDlg As FileDialog
'    Set fileDlg = Application.FileDialog(msoFileDialogFolderPicker)
'
'    With fileDlg
'        .title = "Select a Folder"
'        .AllowMultiSelect = False
'        .InitialFileName = topFolder
'    End With
'
'    Dim sItem As String
'    If fileDlg.Show <> -1 Then
'        sItem = ""
'    Else
'        sItem = fileDlg.SelectedItems(1)
'    End If
'
'    Set fileDlg = Nothing
'
'    SelectFolder = sItem
    
End Function

Function getFilesInFolder(folderPath As String, showStatusBarUpdates As Boolean) As Variant

    Dim fso As Scripting.FileSystemObject
    Set fso = New Scripting.FileSystemObject
    
    Dim SourceFolder As Scripting.folder
    Set SourceFolder = fso.GetFolder(folderPath)
    
    Dim SubFolder As Scripting.folder
    
    Dim FileItem As Scripting.File
    Dim r As Long
    
    Dim counter As Long
    counter = 1
    
    Dim fileList As files
    Set fileList = SourceFolder.files
    
    Dim names As Variant
    ReDim names(1 To fileList.count)
    
    For Each FileItem In fileList
        If showStatusBarUpdates Then
            ssbm "Getting a list of the files in a folder.  Examining file item #" & counter & "..."
        End If
        ' display file properties
'        Cells(r, 1).Formula = FileItem.path & FileItem.Name
'        Cells(r, 2).Formula = FileItem.Size
'        Cells(r, 3).Formula = FileItem.Type
'        Cells(r, 4).Formula = FileItem.DateCreated
'        Cells(r, 5).Formula = FileItem.DateLastAccessed
'        Cells(r, 6).Formula = FileItem.DateLastModified
'        Cells(r, 7).Formula = FileItem.Attributes
'        Cells(r, 8).Formula = FileItem.ShortPath & FileItem.ShortName
        ' use file methods (not proper in this example)
'        FileItem.Copy "C:\FolderName\Filename.txt", True
'        FileItem.Move "C:\FolderName\Filename.txt"
'        FileItem.Delete True
        names(counter) = FileItem.name
        counter = counter + 1 ' next row number
    Next FileItem
    If showStatusBarUpdates Then
        ssbm "Done retrieving the data we were looking for!"
    End If
    getFilesInFolder = names
'    If IncludeSubfolders Then
'        For Each SubFolder In SourceFolder.SubFolders
'            ListFilesInFolder SubFolder.path, True
'        Next SubFolder
'    End If
'    Columns("A:H").AutoFit
'    Set FileItem = Nothing
'    Set SourceFolder = Nothing
'    Set FSO = Nothing
'    ActiveWorkbook.Saved = True
End Function

Function getIndxForFinalFileSeparator(filePath As String) As Long
    
    Dim fileSeparator As String
    fileSeparator = Application.PathSeparator
    
    getIndxForFinalFileSeparator = lstIndxOf(fileSeparator, filePath)
    
End Function


Function getFilenameFromFilePath(filePath As String) As String

    Dim indx As Long
    indx = getIndxForFinalFileSeparator(filePath)

    getFilenameFromFilePath = Right(filePath, Len(filePath) - indx)
    
End Function

Function getFolderPathFromFilePath(filePath As String) As String

    Dim indx As Long
    indx = getIndxForFinalFileSeparator(filePath)

    getFolderPathFromFilePath = left(filePath, indx)

End Function

Sub separateFilePathIntoFolderPathAndFileName(filePath As String, ByRef out_folderPath As String, ByRef out_fileName As String)

    out_folderPath = getFolderPathFromFilePath(filePath)
    out_fileName = getFilenameFromFilePath(filePath)

End Sub

Function addFolderToFileNames(folder As String, fileNames As Collection)

    Dim filePaths As Collection
    Set filePaths = New Collection
    Dim c As Long
    For c = 1 To fileNames.count
        Dim fileName As String
        fileName = fileNames.item(c)
        
        Dim filePath As String
        filePath = appendToPath(folder, fileName)
        
        filePaths.add filePath
    Next

    Set addFolderToFileNames = filePaths

End Function
Function appendToPath(path As String, pathToAppend As String) As String
    
    Dim sep As String
    sep = Application.PathSeparator
    
    appendToPath = appendToPath_customSeparator(path, pathToAppend, sep)
    
End Function

Function appendToPath_customSeparator(path As String, pathToAppend As String, sep As String)
    
    Dim separatorExists As Boolean
    separatorExists = (Right(path, Len(sep)) = sep)
    
    Dim pathSoFar As String
    pathSoFar = path
    
    If separatorExists Then
        'DO NOTHING
    Else
        pathSoFar = pathSoFar & sep
    End If
    
    pathSoFar = pathSoFar & pathToAppend
    appendToPath_customSeparator = pathSoFar
End Function

Function folderExists(path As String) As Boolean

    If Trim(path) = "" Then
        folderExists = False
    Else

        Dim fso As Object
        Set fso = CreateObject("Scripting.FileSystemObject")
        
        Dim exists As Boolean
        exists = fso.folderExists(path)
    
        Set fso = Nothing
        
        folderExists = exists
    End If
End Function

Sub ensureFolderPathExists(folderPath As String)
    ensureFolderPathExists_recognizeSpecificPathAndTreatAsFirstPathElement folderPath, ""
End Sub

Sub ensureFolderPathExists_recognizeSpecificPathAndTreatAsFirstPathElement(theFolderPath As String, optPathToRecognize As String)
    
    If Trim(theFolderPath) = "" Then
        elwp "You specified a blank folder path!"
    Else
    
        Dim sep As String
        sep = Application.PathSeparator
            
        Dim folderPath As String
        folderPath = theFolderPath
        
        Dim optFirstPathElement As Variant
        Set optFirstPathElement = Nothing
        
        If optPathToRecognize <> "" Then
            If startsWith(folderPath, optPathToRecognize, True) Then
                optFirstPathElement = optPathToRecognize
            End If
        End If
        
        If Not isNothing(optFirstPathElement) Then
            'We have already recognized the first part of our path.
            'DO NOTHING
        Else
            'Maybe we can recognize a machine name and shared folder in the first part of our path.
            
            Dim machineDenoter As String
            machineDenoter = sep & sep
            
            If Not startsWith(folderPath, sep & sep, True) Then
                'DO NOTHING
                
                'We do not see a machine name
            Else
                'The absolute first path element will be a machine name.
                'The second will be the first shared folder within that machine.
                
                Dim tempFolderPath As String
                tempFolderPath = Right(folderPath, Len(folderPath) - Len(machineDenoter)) 'Drop the machine denoter
                
                Dim tempTkns As Collection
                Set tempTkns = gtkns(tempFolderPath, sep)
                
                
                Dim desriedFirstElementSoFar As String
                desriedFirstElementSoFar = machineDenoter
                If tempTkns.count > 0 Then
                    desriedFirstElementSoFar = desriedFirstElementSoFar & tempTkns.item(1) & sep 'add the machine name
                End If
                If tempTkns.count > 1 Then
                    desriedFirstElementSoFar = desriedFirstElementSoFar & tempTkns.item(2) & sep 'add the first shared folder.
                End If
                
                If startsWith(folderPath, desriedFirstElementSoFar, True) Then
                    optFirstPathElement = desriedFirstElementSoFar
                End If
            End If
        End If
        
        If Not isNothing(optFirstPathElement) Then
            folderPath = Right(folderPath, Len(folderPath) - Len(optFirstPathElement))
        End If
        
        Dim pathElements As Collection
        Set pathElements = gtkns(folderPath, sep)
        
        If Not isNothing(optFirstPathElement) Then
            pathElements.add optFirstPathElement, before:=1
        End If
        
        Dim path As String
        path = ""
        
        Dim c As Long
        For c = 1 To pathElements.count
            If c <> 1 Then
                path = path & sep
            End If
            path = path & pathElements.item(c)
        
            If Not folderExists(path) Then
                MkDir path
            End If
        Next
    End If
End Sub

Function getExtension(fName As String) As String
    Dim root As String
    Dim ext As String
    separateExtensionFromFileName fName, root, ext

    getExtension = ext
End Function

Sub separateExtensionFromFileName(fName As String, ByRef out_root As String, ByRef out_extension As String)
    Dim indx As Long
    indx = lstIndxOf(EXTENSION_DELIMITER, fName)
    
    If indx = 0 Then
        out_root = fName
        out_extension = ""
    Else
        out_root = left(fName, indx - 1)
        out_extension = Right(fName, Len(fName) - indx + 1)
    End If
End Sub

Function removeExtension(fName As String) As String
    Dim root As String
    Dim ext As String
    separateExtensionFromFileName fName, root, ext
    
    removeExtension = root
End Function

Sub deleteFile(path As String, forceDeleteReadOnly As Boolean)

    Dim fso As Scripting.FileSystemObject
    Set fso = New Scripting.FileSystemObject

    fso.deleteFile path, forceDeleteReadOnly
    
    Set fso = Nothing

End Sub

Sub deleteFolder(path As String, forceDeleteReadOnly As Boolean)
    Dim fso As Scripting.FileSystemObject
    Set fso = New Scripting.FileSystemObject

    fso.deleteFolder path, forceDeleteReadOnly
    
    Set fso = Nothing
End Sub

Function openWorkbookByCopyingItToTemporaryFileFirst(pathToWorkbookThatShouldBeCopiedThenOpened As String) As Variant

    Dim tempPath As String
    tempPath = getWindowsTemporaryPath()

    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    'This method was created orgiinally to be absolutely sure that no locks are placed on the file (thus preventing a person or system from altering or overwriting it).
    'I'm not 100% sure if this is required, when EXPLICITLY opening a file as read-only (vs. by opening it as read-only by default only because someone else got to it first), but we'll do it this way to play it safe.
    
    Dim fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile As Variant
    If folderExists(tempPath) Then
        
        Dim pathForTemporaryFile As String
        pathForTemporaryFile = appendToPath(tempPath, getFilenameFromFilePath(pathToWorkbookThatShouldBeCopiedThenOpened))
        
        Dim fileWasCopied As Boolean
        fileWasCopied = copyFile(pathToWorkbookThatShouldBeCopiedThenOpened, pathForTemporaryFile, False)
        
        If Not fileWasCopied Then
            emsgs.add "We were unable to create our temporary file for '" & pathToWorkbookThatShouldBeCopiedThenOpened & "' for some reason.  We had attempted to create the file '" & pathForTemporaryFile & "'."
            Set fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile = Nothing
        Else
            fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile = pathForTemporaryFile
        End If
    Else
        emsgs.add "Unable to create a temporary file for '" & pathToWorkbookThatShouldBeCopiedThenOpened & "' because the windows temporary folder does not exist ('" & tempPath & "'), so we will just open it from its original location."
        Set fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile = Nothing
    End If
    
    Dim fileToOpen As String
    Dim emsgPrefixIfCannotOpenFile As String
    If isNothing(fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile) Then
        emsgPrefixIfCannotOpenFile = "Cannot open '" & pathToWorkbookThatShouldBeCopiedThenOpened & "'), because: "
        fileToOpen = pathToWorkbookThatShouldBeCopiedThenOpened
    Else
        If getFilenameFromFilePath(pathToWorkbookThatShouldBeCopiedThenOpened) <> getFilenameFromFilePath(CStr(fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile)) Then
            emsgs.add "Somehow, our file name is unexpectedly inconsistent!"
        End If
        emsgPrefixIfCannotOpenFile = "Cannot open '" & getFilenameFromFilePath(pathToWorkbookThatShouldBeCopiedThenOpened) & "' (originally in '" & getFolderPathFromFilePath(pathToWorkbookThatShouldBeCopiedThenOpened) & "' but temporarily copied to '" & getFolderPathFromFilePath(CStr(fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile)) & "'), because: "
        fileToOpen = fullPathToTemporaryFileOrNothingIfShouldUseOriginalFile
    End If
        
    Dim wbOrEMsg As Variant '
    Dim wasOpened As Boolean
    ewio fileToOpen, False, True, wbOrEMsg, wasOpened, ""
     
    Dim openedWB As Workbook
    If isString(wbOrEMsg) Then
        emsgs.add emsgPrefixIfCannotOpenFile & CStr(wbOrEMsg)
        Set openedWB = Nothing
    Else
        Set openedWB = wbOrEMsg
    End If
    
    Dim finalWBOrEMsg As Variant
    If emsgs.count <> 0 Then
        finalWBOrEMsg = emsgs.toString(CHAR_CRLF, "")
    ElseIf isNothing(openedWB) Then
        finalWBOrEMsg = "Could not open the workbook for some unknown reason."
    Else
        Set finalWBOrEMsg = openedWB
    End If
    
    atr openWorkbookByCopyingItToTemporaryFileFirst, finalWBOrEMsg
End Function


Sub ensureWorkbookIsOpen(filePath As String, updateLinksIfOpened As Boolean, readOnlyIfOpened As Boolean, ByRef out_wbOrEmsg As Variant, ByRef out_wasOpened As Boolean, delimiterIfShouldOpenAsTextOrBlankStringOtherwise As String)
    ensureWorkbookOrWebsiteIsOpen filePath, updateLinksIfOpened, readOnlyIfOpened, out_wbOrEmsg, out_wasOpened, delimiterIfShouldOpenAsTextOrBlankStringOtherwise, True
End Sub

Sub ensureWebSiteIsOpen(filePath As String, ByRef out_wbOrEmsg As Variant, ByRef out_wasOpened As Boolean)
    ensureWorkbookOrWebsiteIsOpen filePath, WEB_SITE_UPDATE_LINKS, WEB_SITE_READ_ONLY, out_wbOrEmsg, out_wasOpened, WEB_SITE_DELIMITER_IF_SHOULD_OPEN_AS_TEXT, WEB_SITE_WB_VS_WEB_SITE
End Sub

Sub ensureWorkbookOrWebsiteIsOpen(filePath As String, updateLinksIfOpened As Boolean, readOnlyIfOpened As Boolean, ByRef out_wbOrEmsg As Variant, ByRef out_wasOpened As Boolean, delimiterIfShouldOpenAsTextOrBlankStringOtherwise As String, wbVsWebSite As Boolean)
    
    Dim origWB As Workbook
    Set origWB = ActiveWorkbook
    
    Dim wb As Workbook
    Set wb = getWB(filePath)
    
    If isNothing(wb) Then
        Dim openedWB As Workbook
        Dim emsg As String
        Set openedWB = openWBOrWebSite(filePath, emsg, updateLinksIfOpened, readOnlyIfOpened, delimiterIfShouldOpenAsTextOrBlankStringOtherwise, wbVsWebSite)
        
        If emsg <> "" Then
            out_wbOrEmsg = emsg
            out_wasOpened = False
        ElseIf isNothing(openedWB) Then
            out_wbOrEmsg = ensureEmsg("")
            out_wasOpened = False
        Else
            Set out_wbOrEmsg = openedWB
            out_wasOpened = True
        End If
    Else
        Set out_wbOrEmsg = wb
        out_wasOpened = False
    End If
    
    origWB.Activate
End Sub

Function openWB(filePath As String, ByRef out_emsg As String, updateLinks As Boolean, readOnly As Boolean, delimiterIfShouldOpenAsTextOrBlankStringOtherwise As String) As Workbook
    atr openWB, openWBOrWebSite(filePath, out_emsg, updateLinks, readOnly, delimiterIfShouldOpenAsTextOrBlankStringOtherwise, True)
End Function

Function openWebSite(filePath As String, ByRef out_emsg As String) As Workbook
    atr openWebSite, openWBOrWebSite(filePath, out_emsg, WEB_SITE_UPDATE_LINKS, WEB_SITE_READ_ONLY, WEB_SITE_DELIMITER_IF_SHOULD_OPEN_AS_TEXT, WEB_SITE_WB_VS_WEB_SITE)
End Function

Function openWBOrWebSite(filePath As String, ByRef out_emsg As String, updateLinks As Boolean, readOnly As Boolean, delimiterIfShouldOpenAsTextOrBlankStringOtherwise As String, wbVsWebSite As Boolean) As Workbook
    
    Dim wb As Workbook
    Set wb = Nothing
    
    Dim emsg As String
    emsg = ensureEmsg("")
    
    
    If wbVsWebSite And (Not fileExists(filePath)) Then
        emsg = "The file '" & filePath & "' does not exist!"
    ElseIf (Not wbVsWebSite) And Not lengthOfWebsitePathIsAcceptableForExcelToOpen(filePath) Then
        emsg = "Excel doesn't allow us to open websites with paths greater than " & MAX_LENGTH_THAT_EXCEL_SEEMS_TO_ACCEPT_FOR_PATH_WHEN_OPENING_A_WEBSITE & " characters!"
    Else
    
    On Error GoTo ehs
        If delimiterIfShouldOpenAsTextOrBlankStringOtherwise = "" Then
            Set wb = Application.Workbooks.Open(filePath, updateLinks, readOnly)
        Else
            Workbooks.OpenText filePath, startRow:=1, dataType:=xlDelimited, TextQualifier:=xlDoubleQuote, ConsecutiveDelimiter:=False, Tab:=False, _
                           Semicolon:=False, Comma:=False, Space:=False, Other:=True, OtherChar:=delimiterIfShouldOpenAsTextOrBlankStringOtherwise
            Set wb = ActiveWorkbook
        End If
        emsg = ""
GoTo ehe
ehs:
        emsg = ensureEmsg(Err.description)
ehe:
On Error GoTo 0
    
    End If
    
    Set openWBOrWebSite = wb
    out_emsg = emsg
End Function

Function isTemporaryFile(fileName As String) As Boolean
    isTemporaryFile = startsWith(fileName, "~", True)
End Function

Function fileExists(fileName As String) As Boolean
    
    'fileExists = (Dir(fileName) > "")
    
    Dim fso As Variant
    Set fso = CreateObject("Scripting.FileSystemObject")
    fileExists = fso.fileExists(fileName)
End Function

'JagatShah20130501 - start

Function createTextFile(fileName As String) As Boolean
        ' Create File
            Dim fso As Variant
            Set fso = CreateObject("Scripting.FileSystemObject")
            fso.createTextFile fileName
End Function

 
' Some code was pulled from: http://www.vbforums.com/showthread.php?409954-RESOLVED-Creating-Text-Files-From-Excel-s-VBA
Function saveOrAppendToTextFile(filePathAndName As String, sText As String, ByRef out_emsg As String, outputVsAppend As Boolean) As Boolean

    Dim emsg As String
    emsg = ""
    
    Dim saveSuccess As Boolean
    saveSuccess = True
    
On Error GoTo ehs

    Dim ifileNum As Long
    ifileNum = FreeFile 'Use FreeFile to supply a file number that is not already in use
    
    If (Not fileExists(filePathAndName)) Then
        Call createTextFile(filePathAndName)
    End If
    
    If outputVsAppend Then
        Open filePathAndName For Output As ifileNum
    Else
        Open filePathAndName For Append As ifileNum
    End If
    Print #ifileNum, sText
        
    
GoTo ehe
ehs:
    emsg = "Error while saving '" & filePathAndName & "': " & Err.description
    saveSuccess = False
ehe:
On Error GoTo 0

    Close #ifileNum
    
    out_emsg = emsg
    saveOrAppendToTextFile = saveSuccess

End Function

Function appendToTextFile(filePathAndName As String, sText As String, ByRef out_emsg As String) As Boolean
    appendToTextFile = saveOrAppendToTextFile(filePathAndName, sText, out_emsg, False)
End Function

Public Function SaveFileWithText(filePathAndName As String, sText As String, ByRef out_emsg As String) As Boolean
    SaveFileWithText = saveOrAppendToTextFile(filePathAndName, sText, out_emsg, True)
End Function
 'JagatShah20130501 - end

'This function is based on code from: http://www.vbaexpress.com/kb/getarticle.php?kb_id=699
Public Function readTextFileIntoString(pathToFile As String, ByRef out_emsg As String) As String
    Dim emsg As String
    emsg = ""
    
    Dim stringToReturn As String
    stringToReturn = "ERROR: NOT SET!"
    
On Error GoTo ehs

    Dim fileNum As Long
    fileNum = FreeFile 'Use FreeFile to supply a file number that is not already in use
    
    Open pathToFile For Input As #fileNum
    stringToReturn = Input$(LOF(fileNum), fileNum)
    
    
GoTo ehe
ehs:
    emsg = "Error while loading '" & pathToFile & "': " & Err.description
    stringToReturn = ""
ehe:
On Error GoTo 0

    Close #fileNum

    out_emsg = emsg
    readTextFileIntoString = stringToReturn

    
End Function

 
Function getLinesFromFile(pathToFile As String, ByRef out_emsg As String) As Collection
    Dim emsg As String
    emsg = ""
    
    Dim coll As Collection
    Set coll = New Collection
    
On Error GoTo ehs

    Dim fileNum As Long
    fileNum = FreeFile 'Use FreeFile to supply a file number that is not already in use

    Open pathToFile For Input As #fileNum
    
    While Not EOF(fileNum)
        
        Dim curLine As String
        Line Input #fileNum, curLine
        
        acltcl coll, separateStringIntoLines(curLine)
        
    Wend

GoTo ehe
ehs:
    emsg = "Error while loading '" & pathToFile & "': " & Err.description
ehe:
On Error GoTo 0

    Close #fileNum

    out_emsg = emsg
    Set getLinesFromFile = coll

    
End Function
 
'Function getDelimitedFileDataAsTable(strFile As String, delimiter As String, ByRef out_emsg As String) As JYUT_VectorBasedTable
'
'    Dim emsg As String
'    emsg = ""
'
'    Dim data As JYUT_VectorBasedTable
'    Set data = New JYUT_VectorBasedTable
'
'On Error GoTo ehs
'
'    Open strFile For Input As #1
'
'    While Not EOF(1)
'        Dim curLine As String
'        Line Input #1, curLine
'
'        Dim tkns As Collection
'        Set tkns = gtkns(curLine, delimiter)
'
'        data.addRow tkns
'
'    Wend
'
'GoTo ehe
'ehs:
'    emsg = "Error while loading '" & strFile & "': " & Err.description
'ehe:
'On Error GoTo 0
'
'    Close #1
'
'    out_emsg = emsg
'    Set getDelimitedFileDataAsTable = data
'
'End Function

Sub writeLinesToFile(outputFileName As String, outputLines As Collection, ByRef out_emsg As String)

    Dim emsg As String
    emsg = ""

On Error GoTo ehs

    Open outputFileName For Output As #1
    
    printLinesToFileNumberOne outputLines

GoTo ehe
ehs:
    emsg = Err.description
ehe:
On Error GoTo 0

    Close #1
    
    out_emsg = emsg

End Sub
Sub printLinesToFileNumberOne(lines As Collection)
    Dim f As Long
    For f = 1 To lines.count
        Print #1, lines.item(f)
    Next
End Sub

Function ifFileExistsThenCheckWithUserToConfirmOverwrite(filePath As String) As Boolean

    Dim sdCnt As Boolean
    If Not fileExists(filePath) Then
        sdCnt = True
    Else
        sdCnt = (vbYes = MsgBox("The file '" & filePath & "' already exists.  Overwrite?", vbYesNo))
    End If
    ifFileExistsThenCheckWithUserToConfirmOverwrite = sdCnt

End Function

Sub changeDir(folderPath As String)
    
On Error GoTo ehs
    ChDir folderPath
GoTo ehe
ehs:
    elwp "Could not fin the folder: " & folderPath
ehe:
On Error GoTo 0

End Sub

'fileFormat = xlCSV.  For more options, see: http://msdn.microsoft.com/en-us/library/office/ff198017.aspx
Sub saveWSAs(exportWS As Worksheet, filePath As String, fileFormat As Variant, ByRef out_unusualErrorMessageOrBlankStringForNoUnusualErrorMessage As String, ByRef out_fileSaveSuccessful As Boolean)
    saveWSOrWBAs exportWS, filePath, fileFormat, out_unusualErrorMessageOrBlankStringForNoUnusualErrorMessage, out_fileSaveSuccessful
End Sub

'fileFormat = xlCSV.  For more options, see: http://msdn.microsoft.com/en-us/library/office/ff198017.aspx
Sub saveWSOrWBAs(exportWSOrWB As Variant, filePath As String, fileFormat As Variant, ByRef out_unusualErrorMessageOrBlankStringForNoUnusualErrorMessage As String, ByRef out_fileSaveSuccessful As Boolean)
    
    Dim emsg As String
    emsg = "ERROR: Not Set!"
    
    Dim fileSaveSuccessful As Boolean
    fileSaveSuccessful = False
    
    On Error GoTo ehs
    exportWSOrWB.SaveAs filePath, fileFormat
    
    emsg = ""
    fileSaveSuccessful = True
    GoTo ehe
ehs:
    Dim tempEmsg As String
    tempEmsg = Err.description
    
    
    If Trim(LCase(tempEmsg)) = Trim(LCase("Method 'SaveAs' of object '_Worksheet' failed")) Then
        emsg = ""
    Else
        emsg = tempEmsg
    End If
        
    
    
ehe:
    On Error GoTo 0
    
    out_unusualErrorMessageOrBlankStringForNoUnusualErrorMessage = emsg
    out_fileSaveSuccessful = fileSaveSuccessful
End Sub

Function waitSynchronouslyUntilFilesArePresent(whichFiles As Variant, timeOutSeconds As Double) As Boolean

    Dim startTime As Variant
    startTime = Timer
    
    Dim secondsElapsed As Double
    secondsElapsed = 0
    
    While Not (allFilesExist(whichFiles)) And (secondsElapsed < timeOutSeconds)
    
        Dim sleepInterval_seconds As Long
        sleepInterval_seconds = 1
        
        Dim numMilliseconds
        numMilliseconds = sleepInterval_seconds * 1000
        
        Sleep numMilliseconds
    
        secondsElapsed = Timer - startTime
    Wend
    
    secondsElapsed = Timer - startTime
    
    Dim allFilesPresent As Boolean
    allFilesPresent = allFilesExist(whichFiles)
    
    If allFilesPresent Then
        ilg "Detected all " & dimSize(whichFiles, 1) & " file(s) at " & secondsElapsed & " elapsed seconds."
    Else
        ilg "Timeout occurred at " & secondsElapsed & " elapsed seconds."
    End If
    waitSynchronouslyUntilFilesArePresent = allFilesPresent

End Function

Function allFilesExist(whichFiles As Variant) As Boolean
    
    Dim lwr As Long
    Dim upr As Long
    glaubs whichFiles, lwr, upr
    
    Dim allFilesExistSoFar As Boolean
    allFilesExistSoFar = True
    
    Dim c As Long
    c = lwr
    
    While (c <= upr) And allFilesExistSoFar
    
        Dim curFilePath As String
        curFilePath = whichFiles(c)
        
        If Not fileExists(curFilePath) Then
            allFilesExistSoFar = False
        End If
    
        c = c + 1
    Wend
    
    allFilesExist = allFilesExistSoFar
End Function

Function allWorksheetsExistInWorkbook(wsNames As Variant, wb As Workbook) As Boolean
    allWorksheetsExistInWorkbook = (figureOutWhichWorksheetsDoNotExistInWorkbook(wsNames, wb).count = 0)
End Function

Function figureOutWhichWorksheetsDoNotExistInWorkbook(wsNames As Variant, wb As Workbook) As Collection
    
    Dim missingWorksheets As Collection
    Set missingWorksheets = New Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs wsNames, lwr, upr
    
    Dim allWorksheetsExistSoFar As Boolean
    allWorksheetsExistSoFar = True
    
    Dim c As Long
    For c = lwr To upr
    
        Dim curWSName As String
        curWSName = wsNames(c)
        
        Dim ws As Worksheet
        Set ws = getWorksheet(wb, curWSName)
        
        If isNothing(ws) Then
            missingWorksheets.add curWSName
        End If
    
    Next
    
    Set figureOutWhichWorksheetsDoNotExistInWorkbook = missingWorksheets
    
End Function

Function copyFile(srcPath As String, destPath As String, confirmWithUserThatItIsOKToOverwrite) As Boolean

    Dim fileWasCopied As Boolean
    fileWasCopied = False

On Error GoTo ehs
    
    Dim okToProceed As Boolean
    If confirmWithUserThatItIsOKToOverwrite Then
        okToProceed = ifFileExistsThenCheckWithUserToConfirmOverwrite(destPath)
    Else
        okToProceed = True
    End If
    
    If Not okToProceed Then
        'DO NOTHING
        '(The user cancelled)
    Else
    
        FileCopy srcPath, destPath
        
        If Not fileExists(destPath) Then
            elwp "Unexpectedly could not find our file, even though we thought we wrote it!"
        Else
            fileWasCopied = True
        End If
        
    End If


GoTo ehe
ehs:
    elwp "Could not copy '" & srcPath & "' to '" & destPath & "'.  Msg=" & Err.description
ehe:
On Error GoTo 0

    copyFile = fileWasCopied

End Function

Function figureOutWhichWorksheetsContainRNs(candidateSheets As Collection, rnOrListOfRNs As Variant, andVsOr As Boolean) As Collection

    Dim list As Collection
    Set list = New Collection
    
    Dim c As Long
    For c = 1 To candidateSheets.count
        Dim ws As Worksheet
        Set ws = candidateSheets.item(c)
        
        Dim rnList As Variant
        rnList = ensureValueIsAnArray(rnOrListOfRNs)

        Dim lwr As Long
        Dim upr As Long
        glaubs rnList, lwr, upr
        
        Dim atLeastOneIsMissing As Boolean
        Dim atLeastOneIsFound As Boolean
        atLeastOneIsMissing = False
        atLeastOneIsFound = False
        
        Dim d As Long
        For d = lwr To upr
            Dim rn As String
            rn = rnList(d)
            
            Dim rng As Range
            Set rng = rnge_noLogging(rn, ws)
            
            If isNothing(rng) Then
                atLeastOneIsMissing = True
            ElseIf rng.Worksheet Is ws Then
                atLeastOneIsFound = True
            Else
                atLeastOneIsMissing = True
            End If
            
        Next
            
        Dim shouldAdd As Boolean
        If andVsOr Then
            If atLeastOneIsMissing Then
                shouldAdd = False
            Else
                shouldAdd = True
            End If
        Else
            If atLeastOneIsFound Then
                shouldAdd = True
            Else
                shouldAdd = False
            End If
        End If
        
        If shouldAdd Then
            list.add ws
        End If
    Next
    
    Set figureOutWhichWorksheetsContainRNs = list
    
End Function

Function getWorksheetsInApplicationThatContainRNs(rnOrListOfRNs As Variant, andVsOr As Boolean) As Collection
    Set getWorksheetsInApplicationThatContainRNs = figureOutWhichWorksheetsContainRNs(getAllWorksheetsInAllWorkbooksOfApplication(), rnOrListOfRNs, andVsOr)
End Function

Function getWorksheetsInWBThatContainRNs(wb As Workbook, rnOrListOfRNs As Variant, andVsOr As Boolean) As Collection
    Set getWorksheetsInWBThatContainRNs = figureOutWhichWorksheetsContainRNs(getAllWorksheetsInWorkbook(wb), rnOrListOfRNs, andVsOr)
End Function


Attribute VB_Name = "JYCORE_Logs"
Option Explicit

Public Const MAX_NUM_CHARS_THAT_SHOW_UP_IN_MSGBOX As Long = 1023
'Public Const MAX_NUM_CHARS_THAT_SHOW_UP_IN_MSGBOX As Long = 1000 'Thought it was 1023 at first, but then I started seeing truncated messages.  So arbitrarily just decreasing it a little.

Public DISABLE_POPUPS_IN_LOGGING As Boolean

Private logFileIfShouldWriteToLogFile As String

Public Sub setLogFile(logFile As String)
    logFileIfShouldWriteToLogFile = logFile
End Sub

Sub elwp_se()
    elwp "An unexpected error occurred."
End Sub

Sub errorLogWithPopup(msg As String)
    writeErrorMsg msg, True
End Sub

Sub infoLogWithPopup(msg As String)
    writeInfoMsg msg, True
End Sub

Function msgBoxAndOfferToCancelIfAppropriate(priorResultOrNothingIfIsFirstOne As Variant, isAppropriate As Boolean, msg As String) As Variant
    
    Dim priorResult As Variant
    If isNothing(priorResultOrNothingIfIsFirstOne) Then
        priorResult = vbOK
    Else
        priorResult = priorResultOrNothingIfIsFirstOne
    End If
    
    Dim result As Variant
    If isAppropriate And priorResult = vbOK Then
        result = mbox(msg, vbOKCancel)
    Else
        result = priorResult
    End If
    msgBoxAndOfferToCancelIfAppropriate = result
End Function

Function mbox(msg As String, buttonsForExampleVBOKCancel As Variant) As Variant
    
    writeInfoMsg "Msgbox[buttons " & buttonsForExampleVBOKCancel & "] To User: " & msg, False
    
    Dim result As Variant
    result = MsgBox(msg, buttonsForExampleVBOKCancel)
    
    writeInfoMsg "User Response: " & result, False
    
    mbox = result
End Function

'"elg" stands for "errorLog"
Sub elg(msg As String)
    writeErrorMsg msg, False
End Sub

'"ilg" stands for "infoLog"
Sub ilg(msg As String)
    writeInfoMsg msg, False
End Sub

Sub writeErrorMsg(msg As String, showPopup As Boolean)
    writeLogMsg msg, "ERROR", showPopup
End Sub
Sub writeInfoMsg(msg As String, showPopup As Boolean)
    writeLogMsg msg, "INFO", showPopup
End Sub

Function getLogMsg(msg As String, msgType As String) As String

    Dim rightNow As Date
    rightNow = Now
    
    Dim yyyy As String
    Dim mm As String
    Dim dd As String
    Dim hh As String
    Dim mins As String
    yyyy = padLeft(year(rightNow), 4, "0")
    mm = padLeft(month(rightNow), 2, "0")
    dd = padLeft(day(rightNow), 2, "0")
    hh = padLeft(Hour(rightNow), 2, "0")
    mins = padLeft(Minute(rightNow), 2, "0")
    
    Dim timestamp As String
    timestamp = yyyy & mm & dd & "-" & hh & mins
    
    getLogMsg = timestamp & " " & msgType & " " & msg

End Function

Sub writeLogMsg(msg As String, msgType As String, showPopup As Boolean)

    Dim logMsg As String
    logMsg = getLogMsg(msg, msgType)
    
    Dim msgToWriteToOutput As String
    If DISABLE_POPUPS_IN_LOGGING Then
        msgToWriteToOutput = "POPUP SUPPRESSED --> " & logMsg
    Else
        msgToWriteToOutput = logMsg
    End If
    
    Debug.Print msgToWriteToOutput
    
    writeToLogFileIfAppropriate msgToWriteToOutput
    
    If DISABLE_POPUPS_IN_LOGGING Then
        'DO NOTHING
    ElseIf Not showPopup Then
        'DO NOTHING
    Else
    
        Dim adjustedMsg As String
        adjustedMsg = removeNullCharacters(msg)
    
        Dim listOfMsgScreens As Collection
        Set listOfMsgScreens = divideStringIntoSegmentsNoLargerThanParticularLength(adjustedMsg, MAX_NUM_CHARS_THAT_SHOW_UP_IN_MSGBOX, True)
    
        Dim adjListOfMsgScreens As Collection
        
        If listOfMsgScreens.count = 0 Then
            Set adjListOfMsgScreens = New Collection
            adjListOfMsgScreens.add msg
        Else
            Set adjListOfMsgScreens = listOfMsgScreens
        End If
        
    
        Dim numScreensToShowBeforeGivingUserAbilityToCancel As Long
        numScreensToShowBeforeGivingUserAbilityToCancel = 5 'arbitrary
    
        Dim btns As Variant
        If adjListOfMsgScreens.count > numScreensToShowBeforeGivingUserAbilityToCancel Then
            btns = vbOKCancel
        Else
            btns = vbOKOnly
        End If
    
        Dim c As Long
        c = 1
            
        Dim rslt As Variant
        rslt = vbOK
        
        While (c <= adjListOfMsgScreens.count) And rslt = vbOK
            rslt = MsgBox(adjListOfMsgScreens.item(c), btns, msgType)
            
            c = c + 1
            
        Wend
        
        If rslt <> vbOK Then
            ilwp "You elected to stop seeing the rest of this long error message."
        End If
        
        
    End If
End Sub

Sub writeToLogFileIfAppropriate(msgToWrite As String)
    If logFileIfShouldWriteToLogFile = "" Then
        'DO NOTHING
    Else
        Dim emsg As String
        appendToTextFile logFileIfShouldWriteToLogFile, msgToWrite, emsg
        
        If emsg <> "" Then
            Debug.Print getLogMsg("Could not write to log file '" & logFileIfShouldWriteToLogFile & "'.  Msg=" & emsg, "ERROR")
        End If
    End If
End Sub

Attribute VB_Name = "JYCORE_Ranges"
Option Explicit


Function moveRnges(rngeOrArrayOfRngesOrCollectionOfRnges As Variant, row_orNothingToNotSwitch As Variant, col_orNothingToNotSwitch As Variant)
    Dim arr As Variant
    arr = ensureValueIsAnArray(rngeOrArrayOfRngesOrCollectionOfRnges)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim Res As Variant
    ReDim Res(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Set Res(c) = moveRnge(castToRnge(arr(c)), row_orNothingToNotSwitch, col_orNothingToNotSwitch)
    Next

    moveRnges = Res
End Function


Function shiftRnges(rngeOrArrayOfRngesOrCollectionOfRnges As Variant, numRows As Long, numCols As Long) As Variant
    Dim arr As Variant
    arr = ensureValueIsAnArray(rngeOrArrayOfRngesOrCollectionOfRnges)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim Res As Variant
    ReDim Res(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Set Res(c) = shiftRnge(castToRnge(arr(c)), numRows, numCols)
    Next
    
    shiftRnges = Res
End Function

Function shiftRnge(rnge As Range, numRows As Long, numCols As Long) As Range
    Set shiftRnge = moveRnge(rnge, rnge.row + numRows, rnge.column + numCols)
End Function

Function expandRnge(rnge As Range, numRows As Long, numCols As Long) As Range

    Dim topLeft As Range
    Set topLeft = tlcor(rnge)
    
    Dim bottomRight As Range
    Set bottomRight = topLeft.offset(rnge.rows.count + numRows - 1, rnge.Columns.count + numCols - 1)

    Set expandRnge = rngeToRnge(topLeft, bottomRight)

End Function

Function moveRnge(rnge As Range, row_orNothingToNotSwitch As Variant, col_orNothingToNotSwitch As Variant) As Range
    
    Dim row As Long
    Dim col As Long
    If isNothing(row_orNothingToNotSwitch) Then
        row = rnge.row
    Else
        row = row_orNothingToNotSwitch
    End If
    If isNothing(col_orNothingToNotSwitch) Then
        col = rnge.column
    Else
        col = col_orNothingToNotSwitch
    End If
    
    Dim topLeft As Range
    Set topLeft = rnge.Worksheet.cells(row, col)
    
    Dim bottomRight As Range
    Set bottomRight = resizeRnge(topLeft, rnge.rows.count, rnge.Columns.count)
    
    Set moveRnge = rngeToRnge(topLeft, bottomRight)
End Function
Function rnge_noLogging(rngeDef As String, optWS As Worksheet) As Range

    Dim daRnge As Range
    Set daRnge = Nothing

On Error GoTo ehs
    
    If isNothing(optWS) Then
        Set daRnge = Range(rngeDef)
    Else
        Set daRnge = optWS.Range(rngeDef)
    End If
    
GoTo ehe
ehs:
    'DO NOTHING
ehe:
On Error GoTo 0
    
    Set rnge_noLogging = daRnge
    
End Function

Function rnge(rngeDef As String, optWS As Worksheet) As Range
    
    Dim daRnge As Range
    Set daRnge = rnge_noLogging(rngeDef, optWS)

    If daRnge Is Nothing Then
        elg "Could not find the range defined as: " & rngeDef
    End If
    
    Set rnge = daRnge
End Function
Function resizeRnge(rnge As Range, numRows As Long, numCols As Long) As Range

    Dim topLeft As Range
    Set topLeft = tlcor(rnge)
    
    Dim bottomRight As Range
    Set bottomRight = topLeft.Worksheet.cells(topLeft.row + numRows - 1, topLeft.column + numCols - 1)

    Set resizeRnge = rngeToRnge(topLeft, bottomRight)

End Function
Function topLeftCellOfRnge(theRnge As Range) As Range
    Set topLeftCellOfRnge = theRnge.cells(1, 1)
End Function

Function bottomRightCellOfRnge(theRnge As Range) As Range
    Set bottomRightCellOfRnge = theRnge.cells(theRnge.rows.count, theRnge.Columns.count)
End Function

Function rngeToRnge(rnge1 As Range, rnge2 As Range) As Range
    
    Dim ws1 As Worksheet
    Dim ws2 As Worksheet
    Set ws1 = rnge1.Worksheet
    Set ws2 = rnge2.Worksheet
    
    If Not ws1 Is ws2 Then
        elwp "The two ranges you specified are not on the same worksheet!"
    End If
    Set rngeToRnge = rnge1.Worksheet.Range(rnge1, rnge2)
End Function

Sub srgAndTryToCenterAroundIt(theRnge As Range)
    srg brcor(theRnge)
    srg theRnge
End Sub

Sub srgIfSomething(rnge As Range)
    If isNothing(rnge) Then
        'DO NOTHING
    Else
        srg rnge
    End If
End Sub

Sub selectRnge(rnge As Range)
    rnge.Worksheet.Activate
    rnge.Select
End Sub

Sub setCellColors(theCell As Range, fontColor As String, bgColor As String)

    setColor theCell, fontColor
    setBackground theCell, bgColor

End Sub

Sub setCellValueAndColors(theCell As Range, theVal As Variant, fontColor As String, bgColor As String)
    svl theCell, theVal
    setCellColors theCell, fontColor, bgColor
End Sub


Sub svl_logErrors(rnge As Range, theVal As Variant, ByRef mod_emsgsIfShouldLog As Variant)
On Error GoTo ehs
    rnge.value = theVal
GoTo ehe
ehs:
    
    'elwp "Could not set the value for a cell.  Msg=" & Err.Description
    checkIfCellValueLooksLikeOurExpectedValueAndIfSoThenLogAnErrorMessageWithoutPopupButIfNotThenUsePopup rnge, theVal, "Could not set the value for a cell.  Msg=" & Err.description, mod_emsgsIfShouldLog
ehe:
On Error GoTo 0
End Sub

Sub svl(rnge As Range, theVal As Variant)
    svl_logErrors rnge, theVal, Nothing
End Sub

Private Sub checkIfCellValueLooksLikeOurExpectedValueAndIfSoThenLogAnErrorMessageWithoutPopupButIfNotThenUsePopup(rnge As Range, expectedVal As Variant, emsg As String, ByRef mod_emsgsIfShouldLog As Variant)

On Error GoTo ehs

    If valuesAreEqual(gvl(rnge), expectedVal) Then
        elg emsg
    Else
        Dim daMsg As String
        daMsg = emsg & CHAR_CRLF & "We had tried to write: " & representAsString(expectedVal)
        If isNothing(mod_emsgsIfShouldLog) Then
            elwp daMsg
        Else
            mod_emsgsIfShouldLog.add daMsg
        End If
    End If
    
GoTo ehe
ehs:
    
    Dim myMsg As String
    myMsg = "An error occurred while trying to display the error message: " & emsg & CHAR_CRLF & CHAR_CRLF & "Our error was: " & Err.description
    If isNothing(mod_emsgsIfShouldLog) Then
        elwp myMsg
    Else
        mod_emsgsIfShouldLog.add myMsg
    End If


ehe:
On Error GoTo 0

End Sub


Attribute VB_Name = "JYCORE_Set"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private dict As Dictionary

Private Sub Class_Initialize()
    Set dict = New Dictionary
End Sub

Function add(item As Variant) As Boolean
    If Me.exists(item) Then
        'DO NOTHING
        add = False
    Else
        dict.add item, ""
        add = True
    End If
End Function

Function remove(item As Variant) As Boolean
    If Me.exists(item) Then
        dict.remove item
        remove = True
    Else
        remove = False
    End If
End Function

Function removeCollectionContents(coll As Collection) As Collection

    Dim listOf_successfullyRemoved As Collection
    Set listOf_successfullyRemoved = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim thisVal As Variant
        thisVal = coll.item(c)
        
        listOf_successfullyRemoved.add Me.remove(thisVal)
        
    Next
    
    Set removeCollectionContents = listOf_successfullyRemoved

End Function

Function addCollectionContents(coll As Collection) As Collection
    
    Dim overridden As Collection
    Set overridden = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim thisVal As Variant
        atr thisVal, coll.item(c)
        If Not Me.add(thisVal) Then
            overridden.add thisVal
        End If
    Next
    
    Set addCollectionContents = overridden
End Function

Function exists(item As Variant)
    exists = dict.exists(item)
End Function

'escChar = ""
Function toString(delim As String, escChar As String) As String
    toString = arrayToString(dict.keys, delim, escChar)
End Function

Function count() As Long
    count = dict.count()
End Function

Function toCollection() As Collection
    Set toCollection = arrayToCollection(dict.keys)
End Function

Function clone() As JYCORE_Set
    Set clone = collectionToSet(Me.toCollection())
End Function

Function equalsSet(otherSet As JYCORE_Set) As Boolean

    If Me.count <> otherSet.count Then
        equalsSet = False
    Else
        Dim list As Collection
        Set list = Me.toCollection()
        
        Dim cloned As JYCORE_Set
        Set cloned = otherSet.clone()
        
        Dim c As Long
        c = 1
        
        Dim foundInconsistency As Boolean
        foundInconsistency = False
        
        While c <= list.count And (Not foundInconsistency)
        
            Dim curItem As Variant
            atr curItem, list.item(c)
        
            Dim wasRemoved As Boolean
            wasRemoved = cloned.remove(curItem)
            
            If Not wasRemoved Then
                foundInconsistency = True
            End If
            
            c = c + 1
        Wend
        
        If cloned.count <> 0 Then
            foundInconsistency = True
        End If
        
        equalsSet = (Not foundInconsistency)
    End If

End Function

Function containsAllOf(list As Collection) As Boolean

    Dim encounteredOneThatWasNotFound As Boolean
    encounteredOneThatWasNotFound = False
    
    Dim c As Long
    c = 1
    
    While (c <= list.count) And (Not encounteredOneThatWasNotFound)
    
        If Me.exists(list.item(c)) Then
            'DO NOTHING
        Else
            encounteredOneThatWasNotFound = True
        End If
    
        c = c + 1
    Wend
    
    containsAllOf = (Not encounteredOneThatWasNotFound)

End Function

Function containsAnyOf(list As Collection) As Boolean

    Dim found As Boolean
    found = False
    
    Dim c As Long
    c = 1
    
    While (c <= list.count) And (Not found)
    
        If Me.exists(list.item(c)) Then
            found = True
        End If
    
        c = c + 1
    Wend
    
    containsAnyOf = found

End Function

Function commonElementsWith(otherSet As JYCORE_Set) As JYCORE_Set

    Dim comm As JYCORE_Set
    Set comm = New JYCORE_Set

    Dim lst As Collection
    Set lst = otherSet.toCollection()
    
    Dim d As Long
    For d = 1 To lst.count
        Dim obj As Variant
        atr obj, lst.item(d)
        
        If Me.exists(obj) Then
            comm.add obj
        End If
    Next
    
    Set commonElementsWith = comm

End Function
Attribute VB_Name = "JYCORE_Shorthand"
Option Explicit

'brcor stands for "bottomRightCellOfRnge"
Function brcor(theRnge As Range) As Range
    Set brcor = bottomRightCellOfRnge(theRnge)
End Function

'tlcor stands for "topLeftCellOfRnge"
Function tlcor(theRnge As Range) As Range
    Set tlcor = topLeftCellOfRnge(theRnge)
End Function

'"elwp" stands for "errorLogWithPopup"
Sub elwp(msg As String)
    errorLogWithPopup msg
End Sub

'"ilwp" stands for "infoLogWithPopup"
Sub ilwp(msg As String)
    infoLogWithPopup msg
End Sub

'sris stands for "srgIfSomething"
Sub sris(rnge As Range)
    srgIfSomething rnge
End Sub

'srg stands for 'selectRnge'
Sub srg(rnge As Range)
    selectRnge rnge
End Sub

Attribute VB_Name = "JYCORE_Strings"
Option Explicit

Public Const MAX_CHARS_THAT_CAN_FIT_IN_CELL As Long = 32766
Public Const MAX_CHARS_THAT_WE_WILL_EVER_TRY_TO_FIT_IN_CELL As Long = 30000

Function CHAR_CR() As String
    CHAR_CR = Chr(13)
End Function

Function CHAR_LF() As String
    CHAR_LF = Chr(10)
End Function

Function CHAR_TAB() As String
    CHAR_TAB = Chr(9)
End Function

'Carriage Return followed by a Line Feed
Function CHAR_CRLF() As String
    CHAR_CRLF = CHAR_CR & CHAR_LF
End Function

Function removeLineBreakChars(s As String) As String

    Dim soFar As String
    soFar = s
    soFar = replaceInString(soFar, CHAR_CRLF, "", True)
    soFar = replaceInString(soFar, CHAR_CR, "", True)
    soFar = replaceInString(soFar, CHAR_LF, "", True)
    removeLineBreakChars = soFar

End Function

Function commonPrefixInMultipleStrings(listOfStrings As Collection) As String

    
    If listOfStrings.count = 0 Then
        commonPrefixInMultipleStrings = ""
    ElseIf listOfStrings.count = 1 Then
        commonPrefixInMultipleStrings = listOfStrings.item(1)
    Else
            
        Dim controlString As String
                'JY20130531a - not sure why it was "2", so I switched it to "1"
        'controlString = listOfStrings.item(2)
        controlString = listOfStrings.item(1)
        
        If controlString = "" Then
            commonPrefixInMultipleStrings = ""
        Else
        
            Dim indx As Long
            Dim done As Boolean
            indx = 0
            done = False
            
            While (indx < Len(controlString)) And (Not done)
            
                Dim soFar As String
                soFar = left(controlString, indx + 1)
                
                Dim allStartsWithSoFar As Boolean
                allStartsWithSoFar = True
                
                Dim x As Long
                x = 2
                
                While (allStartsWithSoFar) And (x <= listOfStrings.count)
                    Dim cur As String
                    cur = listOfStrings.item(x)
                    
                    If Not startsWith(cur, soFar, True) Then
                        allStartsWithSoFar = False
                    End If
                    
                    x = x + 1
                Wend
                
                If allStartsWithSoFar Then
                    indx = indx + 1
                Else
                    done = True
                End If
            Wend
    
            commonPrefixInMultipleStrings = left(controlString, indx)
        End If
    End If

End Function

Function startsWithAnyOf(st As String, stringsToCheck As Collection) As Boolean
    
    Dim found As Boolean
    found = False
    
    Dim c As Long
    c = 1
    
    While (Not found) And (c <= stringsToCheck.count)
        
        Dim curString As String
        curString = stringsToCheck.item(c)
        
        If startsWith(st, curString, True) Then
            found = True
        End If
        
        c = c + 1
    Wend
    
    startsWithAnyOf = found
    
End Function

Function startsWithAndEndsWith(st As String, startsWithToCheck As String, endsWithToCheck As String) As Boolean
    
    Dim caseSensitive As Boolean
    caseSensitive = True

    startsWithAndEndsWith = (startsWith(st, startsWithToCheck, caseSensitive) And endsWith(st, endsWithToCheck, caseSensitive))
End Function

Function startsOrEndsWith(st As String, stringToCheck As String) As Boolean
    Dim caseSensitive As Boolean
    caseSensitive = True
    
    startsOrEndsWith = startsWith(st, stringToCheck, caseSensitive) Or endsWith(st, stringToCheck, caseSensitive)
End Function

Function startsAndEndsWith(st As String, stringToCheck As String) As Boolean
    Dim caseSensitive As Boolean
    caseSensitive = True
    
    startsAndEndsWith = startsWith(st, stringToCheck, caseSensitive) And endsWith(st, stringToCheck, caseSensitive)
End Function

Function adjustCaseIfAppropriate(st As String, isAppropriate As Boolean) As String
    If isAppropriate Then
        adjustCaseIfAppropriate = LCase(st)
    Else
        adjustCaseIfAppropriate = st
    End If
End Function

'caseSensitive = true
Function startsWith(st As String, stringToCheck As String, caseSensitive As Boolean) As Boolean

    Dim adjSt As String
    Dim adjStringToChck As String
    adjSt = adjustCaseIfAppropriate(st, Not caseSensitive)
    adjStringToChck = adjustCaseIfAppropriate(stringToCheck, Not caseSensitive)

    startsWith = left(adjSt, Len(adjStringToChck)) = adjStringToChck
End Function

'caseSensitive = true
Function endsWith(st As String, stringToCheck As String, caseSensitive As Boolean) As Boolean
    
    Dim adjSt As String
    Dim adjStringToChck As String
    adjSt = adjustCaseIfAppropriate(st, Not caseSensitive)
    adjStringToChck = adjustCaseIfAppropriate(stringToCheck, Not caseSensitive)
    
    endsWith = Right(adjSt, Len(adjStringToChck)) = adjStringToChck
End Function

Function padLeft(st As String, numChars As Long, padChar As String) As String
    padLeft = getPadBlock(st, numChars, padChar) & st
End Function

Function getPadBlock(st As String, numChars As Long, padChar As String) As String
    
'JY20140226a - start
'    Dim soFar As String
'    soFar = ""
'JY20140226a - end

    Dim curLength As Long
    curLength = Len(st)

'JY20140226a - start
'    Dim c As Long
'    For c = 1 To numChars - curLength
'        soFar = soFar & padChar
'    Next
'    getPadBlock = soFar
    Dim numToAdd As Long
    numToAdd = numChars - curLength
    
    If numToAdd <= 0 Then
        getPadBlock = ""
    Else
       getPadBlock = Application.WorksheetFunction.Rept(padChar, numToAdd)
    End If
'JY20140226a - end
End Function

Function padRightOrTruncToLength(theString As String, desiredLength As Long) As String
    padRightOrTruncToLength = padRight(left(theString, desiredLength), desiredLength, " ")
End Function

Function padLeftOrTruncToLength(theString As String, desiredLength As Long) As String
    padLeftOrTruncToLength = padLeft(left(theString, desiredLength), desiredLength, " ")
End Function

Function padRight(st As String, numChars As Long, padChar As String) As String
    padRight = st & getPadBlock(st, numChars, padChar)
End Function

Function padRightEverythingInArr(arr As Variant, numChars As Long, padChar As String) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim NewArr As Variant
    ReDim NewArr(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim element As Variant
        element = arr(c)
        
        Dim adj As Variant
        adj = padRight(CStr(element), numChars, padChar)
        
        NewArr(c) = adj
    Next
    
    padRightEverythingInArr = NewArr

End Function
'Renamed this from "lastIndxOf" to avoid name conflicts that we encountered somehow while running the Implied Roll Tracker Report
Function doLstIndxOf(stringToFind As String, stringToSearch As String, ByRef mod_foundIndexes_orNothingToNotKeepTrack As Collection) As Long

    If Len(stringToFind) = 0 Then
        doLstIndxOf = 0
    Else
        Dim testStr As String
        testStr = stringToSearch
        
        Dim indx As Long
        indx = 0
        
        Dim lastValidIndx As Long
        lastValidIndx = 0
        
        Do
            Dim start As Long
            start = indx + 1
        
            indx = InStr(start, stringToSearch, stringToFind)
            
            If indx <> 0 Then
            
                If Not isNothing(mod_foundIndexes_orNothingToNotKeepTrack) Then
                    mod_foundIndexes_orNothingToNotKeepTrack.add indx
                End If
            
                lastValidIndx = indx
            End If
        Loop While indx <> 0
        
        doLstIndxOf = lastValidIndx
    End If
End Function

Function lastIndxOfLastCharOfSubstringInString(subString As String, stringToSearch As String) As Long
    
    Dim lastIndexOfPlusOrMinusInstringToSearch As Long
    lastIndexOfPlusOrMinusInstringToSearch = lstIndxOf(subString, stringToSearch)
    
    Dim lastIndxOfLastCharOfSubstringInTheStringToSearch As Long
    If lastIndexOfPlusOrMinusInstringToSearch = 0 Then
        lastIndxOfLastCharOfSubstringInTheStringToSearch = 0
    Else
        lastIndxOfLastCharOfSubstringInTheStringToSearch = lastIndexOfPlusOrMinusInstringToSearch + Len(subString) - 1
    End If
    
    lastIndxOfLastCharOfSubstringInString = lastIndxOfLastCharOfSubstringInTheStringToSearch

End Function


Function lstIndxOf(stringToFind As String, stringToSearch As String) As Long
    lstIndxOf = doLstIndxOf(stringToFind, stringToSearch, Nothing)
End Function

Function validIndxesOf(stringToFind As String, stringToSearch As String) As Collection
    Dim coll As Collection
    Set coll = New Collection
    
    Dim lastIndx As Long
    lastIndx = doLstIndxOf(stringToFind, stringToSearch, coll)
    
    Set validIndxesOf = coll
End Function


Function replaceInString_multipleReplacements(theText As String, listOf__textToFind_replacementText_recursive As Collection) As String

    Dim textSoFar As String
    textSoFar = theText

    Dim c As Long
    For c = 1 To listOf__textToFind_replacementText_recursive.count
        Dim textToFind_replacementText_recursive As Variant
        textToFind_replacementText_recursive = listOf__textToFind_replacementText_recursive.item(c)
        
        Dim textToFind As String
        Dim replacementText As String
        Dim recursive As Boolean
        textToFind = rlai(textToFind_replacementText_recursive, 1)
        replacementText = rlai(textToFind_replacementText_recursive, 2)
        recursive = rlai(textToFind_replacementText_recursive, 3)
        
        textSoFar = replaceInString(textSoFar, textToFind, replacementText, recursive)
        
    Next
 
    replaceInString_multipleReplacements = textSoFar
End Function

'Created this function to avoid name overlap with ticks converter add-in
Function replaceInStrng(st As String, toReplace As String, replaceWith As String, recursive As Boolean)
    replaceInStrng = replaceInString(st, toReplace, replaceWith, recursive)
End Function

Function replaceInString_showStatusBarMessage(st As String, toReplace As String, replaceWith As String, recursive As Boolean)
    replaceInString_showStatusBarMessage = doReplaceInString(st, toReplace, replaceWith, recursive, True)
End Function

Function replaceInString(st As String, toReplace As String, replaceWith As String, recursive As Boolean)
    replaceInString = doReplaceInString(st, toReplace, replaceWith, recursive, False)
End Function

Function doReplaceInString(st As String, toReplace As String, replaceWith As String, recursive_pleaseNoteThatRecursiveModeHasNotBeenSpedUpYetButTheOtherModeHas As Boolean, showStatusBarMessages As Boolean)

    Dim oldWayVersusNewerFasterWay As Boolean
    If recursive_pleaseNoteThatRecursiveModeHasNotBeenSpedUpYetButTheOtherModeHas Then
        oldWayVersusNewerFasterWay = True
    Else
        oldWayVersusNewerFasterWay = False
    End If
    
    Dim retVal As Variant
    If Not oldWayVersusNewerFasterWay Then
        retVal = Replace(st, toReplace, replaceWith)
    Else

        If toReplace = "" Then
            retVal = st
        Else
    
            Dim startIndx As Long
            startIndx = 1
            
            Dim indx As Long
            indx = InStr(startIndx, st, toReplace)
            
            Dim stringSoFar As String
            stringSoFar = st
            
            While indx <> 0
            
                If showStatusBarMessages Then
                    ssbm "Replacing in string... cur index = " & indx & "..."
                End If
                
                stringSoFar = left(stringSoFar, indx - 1) & replaceWith & Right(stringSoFar, Len(stringSoFar) - (indx + Len(toReplace) - 1))
                
                startIndx = indx + 1 + Len(replaceWith) - 1
                
                If recursive_pleaseNoteThatRecursiveModeHasNotBeenSpedUpYetButTheOtherModeHas Then
                    indx = InStr(1, stringSoFar, toReplace)
                Else
                    indx = InStr(startIndx, stringSoFar, toReplace)
                End If
                
            Wend
            If showStatusBarMessages Then
                ssbm "Done replacing in string!"
            End If
            retVal = stringSoFar
        End If
    End If
    
    doReplaceInString = retVal
End Function
Function gtknsWIthSpacesAsDelimitersAndOptionalQuotationMarksToDemarcateWholeStrings(description As String) As Collection

    Dim tknsWhereEveryEvenNumberedTknIsAWholeString As Collection
    Set tknsWhereEveryEvenNumberedTknIsAWholeString = gtkns(description, """")
    
    Dim tknsSoFar As Collection
    Set tknsSoFar = New Collection
    
    Dim c As Long
    For c = 1 To tknsWhereEveryEvenNumberedTknIsAWholeString.count
    
        Dim tkn As String
        tkn = Trim(tknsWhereEveryEvenNumberedTknIsAWholeString.item(c))
        If isEven(c) Then
            tknsSoFar.add tkn
        Else
            addCollectionToCollection tknsSoFar, gtkns_treatConsecutiveTknsAsOne(tkn, " ")
        End If
    Next
    
    If isEven(tknsWhereEveryEvenNumberedTknIsAWholeString.count) Then
        elwp " Found un-closed quotation!"
    End If

    Set gtknsWIthSpacesAsDelimitersAndOptionalQuotationMarksToDemarcateWholeStrings = tknsSoFar
End Function

Function gtkns_treatConsecutiveTknsAsOne(st As String, delim As String) As Collection
    
    Dim newSt As String
    newSt = replaceInString(st, delim & delim, delim, True)
    
    Set gtkns_treatConsecutiveTknsAsOne = gtkns(newSt, delim)
End Function

Function nextIndxOfChoiceOfStrings(st As String, searchValues As Variant, ByRef out_correspondingSearchValue As String) As Long

    Dim lwr As Long
    Dim upr As Long
    glaubs searchValues, lwr, upr
    
    Dim valueForError As Long
    valueForError = 0
    
    Dim correspondingSearchValue As String
    Dim minFound As Long
    correspondingSearchValue = ""
    minFound = valueForError
    
    Dim c As Long
    For c = lwr To upr
        Dim curSearchValue As String
        curSearchValue = searchValues(c)
        
        If curSearchValue = "" Then
            'DO NOTHING
        Else
            Dim indx As Long
            indx = InStr(1, st, curSearchValue)
            
            If indx <> valueForError Then
                'We found it
                
                Dim shouldTake As Boolean
                If minFound = valueForError Then
                    shouldTake = True
                ElseIf indx < minFound Then
                    shouldTake = True
                Else
                    shouldTake = False
                End If
                
                If shouldTake Then
                    minFound = indx
                    correspondingSearchValue = curSearchValue
                End If
                    
            End If
            
        End If
        
    Next
    
    out_correspondingSearchValue = correspondingSearchValue
    nextIndxOfChoiceOfStrings = minFound

End Function

Function gtkns_multDelimiters(st As String, delims As Variant) As Collection

    Dim theString As String
    theString = st

    Dim lower As Long
    Dim upper As Long
    getLowerAndUpperBounds delims, lower, upper
    
    Dim masterDelim As String
    masterDelim = delims(lower)
    
    Dim c As Long
    For c = lower + 1 To upper
        Dim curDelim As String
        curDelim = delims(c)
        
        If InStr(1, masterDelim, curDelim) <> 0 Then
            errorLogWithPopup "Encountered a case where the gtkns_multDelimiters method might fail!"
        End If
        
        theString = replaceInString(theString, curDelim, masterDelim, False)
    Next
    
    Set gtkns_multDelimiters = gtkns(theString, masterDelim)
    
End Function

'NOTE: 'gtkns' stands for "getTokens"
Function gtkns(st As String, delim As String) As Collection

    Dim tkns As Collection
    Set tkns = New Collection
    
    Dim start As Long
    start = 1
    
    Dim indx As Long
    indx = InStr(start, st, delim)
    
    While indx <> 0
    
        Dim tkn As String
        tkn = Mid(st, start, indx - start)
        
        tkns.add tkn
        
        start = indx + Len(delim)
    
        indx = InStr(start, st, delim)
        
    Wend
    
    tkns.add Right(st, Len(st) - start + 1)
    
    Set gtkns = tkns

End Function

Function representAllInCollectionAsStrings(coll As Collection, listDelimiter As String, listDelimiter2 As String, escChar As String, showTypeName As Boolean) As Collection
    Dim cl As Collection
    Set cl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim curEntry As Variant
        atr curEntry, coll.item(c)
        
        cl.add doRepresentAsString(curEntry, listDelimiter, listDelimiter2, escChar, showTypeName)
        
    Next
    
    Set representAllInCollectionAsStrings = cl
End Function

Function collectionToString(coll As Collection, delim As String, escCharacter As String) As String
    
    If coll.count = 0 Then
        collectionToString = ""
    Else
        Dim st As String
        st = addEscapeCharactersWhereNecessary(coll.item(1), delim, escCharacter)
        
        Dim c As Long
        For c = 2 To coll.count
            st = st & delim & addEscapeCharactersWhereNecessary(coll.item(c), delim, escCharacter)
        Next
        collectionToString = st
    End If
End Function

Function stringToCollection(theString As String, delim As String, escCharacter As String) As Collection

    Dim adjString As String
    adjString = replaceInString(theString, escCharacter & escCharacter, escCharacter, False)
    
    Dim tkns As Collection
    Set tkns = gtkns(adjString, delim)
    
    Dim newTkns As Collection
    If escCharacter = "" Then
        Set newTkns = tkns
    Else
        Set newTkns = New Collection
        
        If tkns.count > 0 Then
        
            Dim stringSoFar As String
            stringSoFar = tkns.item(1)
            
            Dim x As Long
            For x = 2 To tkns.count
                
                Dim curTkn As String
                curTkn = tkns.item(x)
                
                If endsWith(stringSoFar, escCharacter, True) Then
                    stringSoFar = dropLastXCharacters(stringSoFar, Len(escCharacter)) & delim & curTkn
                Else
                    newTkns.add stringSoFar
                    stringSoFar = curTkn
                End If
            Next
            
            newTkns.add stringSoFar
        End If
    End If

    Set stringToCollection = newTkns

End Function

Function addEscapeCharactersWhereNecessary(theString As String, delim As String, escChar As String) As String

    Dim st As String
    st = theString
    
    If escChar <> "" Then
        st = replaceInString(st, escChar, escChar & escChar, False)
        st = replaceInString(st, delim, escChar & delim, False)
    End If
    
    addEscapeCharactersWhereNecessary = st
    
End Function

Function removeEnclosingParenthesisIfThisWillNotChangeOurExpression(st As Variant)
    Dim theStr As String
    theStr = CStr(st)
    
    Dim caseSensitive As Boolean
    caseSensitive = True
    
    If startsWith(theStr, "(", caseSensitive) And endsWith(theStr, ")", caseSensitive) Then
        
        'Let's see what happens when we remove the parenthesis.
        Dim candidate As String
        candidate = dropFirstAndLastCharacter(theStr)
        
        Dim emsgsFromExpressionParsing As JYCORE_Set
        Set emsgsFromExpressionParsing = New JYCORE_Set
        
        Dim blocks As Collection
        Dim opsInBetween As Collection
        Set blocks = getExpressionBlocks(candidate, opsInBetween, emsgsFromExpressionParsing)
        
        'Dim firstIndxOfOpenParen As Long
        'Dim firstIndxOfClosingParen As Long
        'Dim lastIndxOfOpenParen As Long
        'Dim lastIndxOfClosingParen As Long
        'firstIndxOfOpenParen = InStr(1, candidate, "(")
        'firstIndxOfClosingParen = InStr(1, candidate, ")")
        'lastIndxOfOpenParen = lstIndxOf("(", candidate)
        'lastIndxOfClosingParen = lstIndxOf(")", candidate)
       '
        'Dim firstIndexesLookValid As Boolean
        'Dim lastIndexesLookValid As Boolean
        'firstIndexesLookValid = validateParenthesisSituation(firstIndxOfOpenParen, firstIndxOfClosingParen)
        'lastIndexesLookValid = validateParenthesisSituation(lastIndxOfOpenParen, lastIndxOfClosingParen)
        '
        'If firstIndexesLookValid And lastIndexesLookValid Then
        
        If emsgsFromExpressionParsing.count = 0 Then
            'Our expression is still valid.  We didn't break anything.  So go with this.
            removeEnclosingParenthesisIfThisWillNotChangeOurExpression = candidate
        Else
            'We wound up with a bad expression, and this may or may not be due to our removing the enclosing parenthesis.
            'Eithre way, we will choose to retain the original value.
            'Retain original value.
            atr removeEnclosingParenthesisIfThisWillNotChangeOurExpression, st
        End If
    
        
    Else
        atr removeEnclosingParenthesisIfThisWillNotChangeOurExpression, st
    End If
    
End Function

Function recursivelyRemoveEnclosingParentheses(s As String) As String
    
    Dim newSoFar As String
    newSoFar = s
    
    Dim oldString As String
    oldString = "" 'arbitrary
    
    Do
        oldString = newSoFar
        newSoFar = removeEnclosingParenthesisIfThisWillNotChangeOurExpression(newSoFar)
        
    Loop While oldString <> newSoFar
    
    recursivelyRemoveEnclosingParentheses = newSoFar
End Function



Function removeEnclosingParenthesis(recursive As Boolean, expression As String) As String
    
    Dim removedParenthesis As String
    removedParenthesis = expression
    
    Dim caseSensitive As Boolean
    caseSensitive = True
    
    If recursive Then
        removedParenthesis = recursivelyRemoveEnclosingParentheses(expression)
    Else
        removedParenthesis = removeEnclosingParenthesisIfThisWillNotChangeOurExpression(expression)
    End If
    
    removeEnclosingParenthesis = removedParenthesis
End Function

Function capitalizeFirstXLetters(desc As String, numLetters As Long) As String
    capitalizeFirstXLetters = UCase(left(desc, numLetters)) & Right(desc, Len(desc) - numLetters)
End Function

Function removeQuotesIfWrappedInQuotes(st As Variant) As String 'input 'st' is a variant, not a string, to allow for passing in of numbers and other data types and still allow this function to work
    
    Dim theStr As String
    theStr = CStr(st)
    
    Dim caseSensitive As Boolean
    caseSensitive = True
    
    If startsWith(theStr, """", caseSensitive) And endsWith(theStr, """", caseSensitive) Then
        removeQuotesIfWrappedInQuotes = dropFirstAndLastCharacter(theStr)
    Else
        atr removeQuotesIfWrappedInQuotes, st
    End If
End Function

Function wrapInQuotes(st As String) As String
    wrapInQuotes = """" & st & """"
End Function

Function removeFromEnd(st As String, stToRemove As String) As String
    If Right(st, Len(stToRemove)) = stToRemove Then
        removeFromEnd = Trim(left(st, Len(st) - Len(stToRemove)))
    Else
        removeFromEnd = st
    End If
End Function

Function removeFromStart(st As String, stToRemove As String) As String
    If left(st, Len(stToRemove)) = stToRemove Then
        removeFromStart = Trim(Right(st, Len(st) - Len(stToRemove)))
    Else
        removeFromStart = st
    End If
End Function

Function dropFirstXCharacters(st As String, numCharsToDrop As Long) As String
    dropFirstXCharacters = Right(st, wsFunctionMax(0, Len(st) - numCharsToDrop))
End Function

Function dropLastXCharacters(st As String, numCharsToDrop As Long) As String
    dropLastXCharacters = left(st, wsFunctionMax(0, Len(st) - numCharsToDrop))
End Function

Function dropFirstAndLastCharacter(st As String) As String
    If Len(st) <= 1 Then
        dropFirstAndLastCharacter = ""
    Else
        'JY20110214a
        'dropFirstAndLastCharacter = Right(Left(st, Len(st) - 1), Len(st) - 2)
        dropFirstAndLastCharacter = Mid(st, 2, Len(st) - 2)
    End If
End Function

Function separateStringIntoLines(s As String) As Collection
    Set separateStringIntoLines = gtkns_multDelimiters(s, Array(CHAR_CR, CHAR_CRLF, CHAR_LF))
End Function

Function representArrayAsString(theArr As Variant, delim As String) As String
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(theArr, 1)
    upper = UBound(theArr, 1)
    
    Dim st As String
    st = ""
    
    Dim c As Long
    For c = lower To upper
        Dim curKey As Variant
        atr curKey, theArr(c)
        
        Dim curKeyString As String
        curKeyString = representAsString(curKey)
        
        If c = lower Then
            st = curKeyString
        Else
            st = st & delim & curKeyString
        End If
    Next
    
    representArrayAsString = st
End Function

Function representAsString(value As Variant) As String
    representAsString = representAsString_customDelimiter(value, ",")
End Function

Function representAsString_customDelimiter(value As Variant, listDelimiter As String) As String
    representAsString_customDelimiter = doRepresentAsString(value, listDelimiter, listDelimiter, "\", True)
End Function

Function doRepresentAsString(value As Variant, listDelimiter As String, listDelimiter2 As String, escChar As String, showTypeName As Boolean) As String

    Dim dataType As String
    dataType = TypeName(value)
    
    Dim representation As String
    If isCollection(value) Then
        representation = "[" & cltstr(castToCollection(value), listDelimiter, "") & "]"
    ElseIf isSet(value) Then
        representation = "[" & castToSet(value).toString(listDelimiter, "") & "]"
    ElseIf IsObject(value) Then
        representation = "[OBJECT]"
        
    ElseIf IsArray(value) Then
        Dim numDimensions As Long
        numDimensions = numDims(value)
        If numDimensions = 1 Then
            representation = "{" & representArrayAsString(value, listDelimiter) & "}"
        ElseIf numDimensions = 2 Then
            representation = "{ [" & twoDimArrayToString(value, "] | [", listDelimiter, "\") & "] }"
        Else
            representation = "[" & numDimensions & "-DIMENSIONAL ARRAY]"
        End If
    Else
        If isString(value) Then
            representation = """" & replaceInString(CStr(value), """", """""", False) & """"
        Else
            representation = CStr(value)
        End If
    End If
    
    doRepresentAsString = IIf(showTypeName, dataType & ":", "") & representation

End Function
Sub splitStringInTwo_aroundIndx(ByRef out_leftSide As String, ByRef out_rightSide As String, equation As String, indx As Long, delimLength As Long)

    Dim leftSide As String
    Dim rightSide As String
    If indx = 0 Then
        'This is not a name-value pair.
        leftSide = Trim(equation)
        rightSide = ""
    Else
        leftSide = Trim(left(equation, indx - 1))
        rightSide = Trim(dropFirstXCharacters(CStr(equation), indx + delimLength - 1))
    End If
    out_leftSide = leftSide
    out_rightSide = rightSide

End Sub

'ifNoDelimiterFoundThenAssignValueToLeftSideVsRightSide = true
Sub splitStringInTwo_aroundDelimiter(ByRef out_leftSide As String, ByRef out_rightSide As String, equation As String, delimiter As String, firstDelimiterVsLastDelimiter As Boolean, ifNoDelimiterFoundThenAssignValueToLeftSideVsRightSide As Boolean)
    Dim leftSide As String
    Dim rightSide As String
    If equation = "" Then
        leftSide = ""
        rightSide = ""
    Else
    
        Dim indxOfEquals As Long
        If firstDelimiterVsLastDelimiter Then
            indxOfEquals = InStr(1, equation, delimiter)
        Else
            indxOfEquals = lstIndxOf(delimiter, equation)
        End If
        
        If indxOfEquals = 0 Then
            If ifNoDelimiterFoundThenAssignValueToLeftSideVsRightSide Then
                leftSide = equation
                rightSide = ""
            Else
                leftSide = ""
                rightSide = equation
            End If
        Else
            splitStringInTwo_aroundIndx leftSide, rightSide, equation, indxOfEquals, Len(delimiter)
        End If
    End If
    
    out_leftSide = leftSide
    out_rightSide = rightSide

End Sub

Sub separateLeftSideAndRightSideOfEquation(ByRef out_leftSide As String, ByRef out_rightSide As String, equation As String)
    splitStringInTwo_aroundDelimiter out_leftSide, out_rightSide, equation, "=", True, True
End Sub

Function joinLeftAndRightSidesOfEquation(leftSide As String, rightSide As String)
    joinLeftAndRightSidesOfEquation = leftSide & " = " & rightSide
End Function

Function getIndxOfFirstNonNumericalCharacter(text As String, countPeriodsAsNumerical As Boolean) As Long

    Dim indxOfFirstNonNumericalChar As Long
    indxOfFirstNonNumericalChar = 0
    
    Dim d As Long
    d = 1
    While (d <= Len(text)) And (indxOfFirstNonNumericalChar = 0)
    
        Dim curChar As String
        curChar = Mid(text, d, 1)
        
       If Not isNumericalChar(curChar, countPeriodsAsNumerical) Then
            indxOfFirstNonNumericalChar = d
        End If
    
        d = d + 1
    Wend
    
    getIndxOfFirstNonNumericalCharacter = indxOfFirstNonNumericalChar

End Function

Function getIndxOfFirstNumericalCharacter(text As String) As Long

    Dim indxOfFirstNumericalChar As Long
    indxOfFirstNumericalChar = 0
    
    Dim d As Long
    d = 1
    While (d <= Len(text)) And (indxOfFirstNumericalChar = 0)
    
        Dim curChar As String
        curChar = Mid(text, d, 1)
        
        If isNumericalChar(curChar, countPeriodsAsNumerical) Then
            indxOfFirstNumericalChar = d
        End If
    
        d = d + 1
    Wend
    
    getIndxOfFirstNumericalCharacter = indxOfFirstNumericalChar

End Function

Function isNumericalChar(curChar As String, countPeriodsAsNumerical As Boolean) As Boolean
    isNumericalChar = (isNumber(curChar) Or (countPeriodsAsNumerical And curChar = "."))
End Function

Function getIndxOfFirstNonBlankSpace(text As String) As Long

    Dim indxOfFirstNonBlankSpace As Long
    indxOfFirstNonBlankSpace = 0
    
    Dim d As Long
    d = 1
    While (d <= Len(text)) And (indxOfFirstNonBlankSpace = 0)
    
        Dim curChar As String
        curChar = Mid(text, d, 1)
        
        If curChar <> " " Then
            indxOfFirstNonBlankSpace = d
        End If
    
        d = d + 1
    Wend
    
    getIndxOfFirstNonBlankSpace = indxOfFirstNonBlankSpace
End Function

Function stringsAreEqual2(S1 As String, S2 As String, caseSensistive As Boolean, trimBeforeComparing As Boolean) As Boolean

    Dim st1 As String
    Dim st2 As String
    st1 = S1
    st2 = S2
    
    If Not caseSensistive Then
        st1 = LCase(st1)
        st2 = LCase(st2)
    End If
    
    If trimBeforeComparing Then
        st1 = Trim(st1)
        st2 = Trim(st2)
    End If
    
    stringsAreEqual2 = (st1 = st2)

End Function

Function stringContains(theString As String, stringToCheckFor As String) As Boolean
    stringContains = (InStr(1, theString, stringToCheckFor) <> 0)
End Function

Function breakStringIntoSegments(bigString As String, maxSegmentSize As Long) As Variant
    Dim remaining As String
    remaining = bigString
    
    Dim segs As Collection
    Set segs = New Collection
    
    Dim lenSoFar As Long
    lenSoFar = 0
    
    While remaining <> ""
        Dim segment As String
        segment = left(remaining, maxSegmentSize)
        
        segs.add segment
        lenSoFar = lenSoFar + Len(segment)
        remaining = Right(remaining, wsFunctionMax(0, Len(remaining) - maxSegmentSize))
    Wend
    
    If Len(bigString) <> lenSoFar Then
        elwp_se
    End If
    
    breakStringIntoSegments = kta(segs)
End Function

'Added this function because when displaying a pop-up window ("msgbox" command), nothing seems to be displayed after a null character is encountered
Function removeNullCharacters(theString As String) As String

    Dim newString As String
    newString = ""
    
    Dim c As Long
    For c = 1 To Len(theString)
        Dim curChar As String
        curChar = Mid(theString, c, 1)
        
        If Asc(curChar) = 0 Then
            'DO NOTHING
        Else
            newString = newString & curChar
        End If
    Next

    removeNullCharacters = newString

End Function


Function maxStringLength(stringArray As Variant) As Long
    Dim lwr As Long
    Dim upr As Long
    glaubs stringArray, lwr, upr
    
    Dim maxLengthSoFar As Long
    maxLengthSoFar = 0
    
    Dim cnt As Long
    For cnt = lwr To upr
        Dim curStr As String
        curStr = stringArray(cnt)
        
        maxLengthSoFar = wsFunctionMax(maxLengthSoFar, Len(CStr(curStr)))
        
    Next
    maxStringLength = maxLengthSoFar
End Function


Function getSubStringBetweenTwoValues(stringToSearch As String, firstVal As String, secondVal As String) As String
        
    Dim indx1 As Long
    indx1 = InStr(1, stringToSearch, firstVal)
    
    Dim indx2 As Long
    If indx1 = 0 Then
        indx2 = 0
    Else
        indx2 = InStr(indx1 + 1, stringToSearch, secondVal)
    End If
    
    If indx1 = 0 Or indx2 = 0 Then
        getSubStringBetweenTwoValues = ""
    Else
        getSubStringBetweenTwoValues = Mid(stringToSearch, indx1 + 1, indx2 - indx1 - 1)
    End If
End Function

Function wrapTextInStringToNewLines_returnCollection(theText As String, maxCharLength As Long) As Collection
    Dim lines As Collection
    Set lines = New Collection
    
    Dim curString As String
    curString = theText
    
    While curString <> ""
        
        Dim extractedLine As String
        Dim remainingLine As String
        If Len(curString) <= maxCharLength Then
            extractedLine = curString
            remainingLine = ""
        Else
        
            Dim indxes As Collection
            Set indxes = validIndxesOf(" ", curString)
            
            Dim c As Long
            c = 1
            
            Dim valueForNotFoundYet As Long
            valueForNotFoundYet = -1
            
            Dim indxToSplitStringAtSoFar As Long
            indxToSplitStringAtSoFar = valueForNotFoundYet
            
            Dim done As Boolean
            done = False
            
            While (c <= indxes.count) And (Not done)
            
                Dim curIndx As Long
                curIndx = indxes.item(c)
                
                If curIndx < maxCharLength Then
                    indxToSplitStringAtSoFar = curIndx
                Else
                    done = True
                End If
            
                c = c + 1
            Wend
            
            Dim splitPoint As Long
            Dim splitOnDelimiter As Boolean
            If indxToSplitStringAtSoFar = valueForNotFoundYet Then
                splitPoint = maxCharLength
                splitOnDelimiter = False
            Else
                splitPoint = indxToSplitStringAtSoFar
                splitOnDelimiter = True
            End If
        
            extractedLine = left(curString, splitPoint - IIf(splitOnDelimiter, 1, 0))
            remainingLine = Right(curString, Len(curString) - splitPoint)
        End If
        
        curString = remainingLine
        lines.add extractedLine
    Wend
    
    Set wrapTextInStringToNewLines_returnCollection = lines
    
End Function

Function wrapTextInStringToNewLines(theText As String, maxCharLength As Long) As String
    Dim lines As Collection
    Set lines = wrapTextInStringToNewLines_returnCollection(theText, maxCharLength)
    wrapTextInStringToNewLines = cltstr(lines, CHAR_CRLF, "")
    
    
End Function
Function wrapTextInStringsToNewLines(listOfComments As Collection, maxCharLength As Long) As Collection
    
    Dim listOfCommentsWrapped As Collection
    Set listOfCommentsWrapped = New Collection
    Dim dd As Long
    For dd = 1 To listOfComments.count
        listOfCommentsWrapped.add wrapTextInStringToNewLines(listOfComments.item(dd), maxCharLength)
    Next
    
    Set wrapTextInStringsToNewLines = listOfCommentsWrapped
End Function


Function repeatedlyAddValueToString(ByRef origString As String, value As String, numTimes As Long) As String
    Dim msg As String
    msg = origString
    
    Dim c As Long
    For c = 1 To numTimes
        msg = msg & value
    Next
    
    repeatedlyAddValueToString = msg
End Function

Function lcaseIfPossible(candidate As Variant) As Variant
    If isString(candidate) Then
        lcaseIfPossible = LCase(CStr(candidate))
    Else
        atr lcaseIfPossible, candidate
    End If
        
End Function

Function getNextSegmentOfParticularLengthButAvoidDividingLinesAndWordsIfPossible(theStrng As String, startingAt As Long, size As Long, linesAndWordsVsJustWords As Boolean) As String
    
    Dim strng As String
    strng = Right(theStrng, Len(theStrng) - startingAt + 1)
    
    Dim linesOrWords As Collection
    Dim delim As String
    If linesAndWordsVsJustWords Then
        delim = CHAR_CRLF
        Set linesOrWords = separateStringIntoLines(strng)
    Else
        delim = " "
        Set linesOrWords = gtkns(strng, delim)
    End If
    
    Dim c As Long
    c = 1
    
    Dim resultSoFar As String
    resultSoFar = ""
    
    Dim done As Boolean
    done = False
    While (c <= linesOrWords.count) And (Not done)
    
        Dim nextPart As String
        If c = 1 Then
            nextPart = linesOrWords.item(c)
        Else
            nextPart = delim & linesOrWords.item(c)
        End If
            
    
        If Len(resultSoFar) + Len(nextPart) > size Then
            done = True
        Else
            resultSoFar = resultSoFar & nextPart
        End If
        c = c + 1
    Wend
    
    Dim nextSegment As String
    
    'JY20140509a
    'If c > linesOrWords.count Then
    If (c > linesOrWords.count) And (resultSoFar <> "") Then
    
        'All lines/words fit.
        nextSegment = resultSoFar
    ElseIf resultSoFar = "" Then
        'Not even one line/word fits
        
        If linesAndWordsVsJustWords Then
            nextSegment = getNextSegmentOfParticularLengthButAvoidDividingLinesAndWordsIfPossible(strng, 1, size, False)
        Else
            nextSegment = left(strng, size)
        End If
    Else
        'Some lines/words fit.
        nextSegment = resultSoFar
    End If
    
    getNextSegmentOfParticularLengthButAvoidDividingLinesAndWordsIfPossible = nextSegment

End Function
Function divideStringIntoSegmentsNoLargerThanParticularLength(strng As String, size As Long, keepLinesAndWordsTogetherWhenPossible As Boolean) As Collection

    Dim coll As Collection
    Set coll = New Collection
    
    Dim curIndx As Long
    curIndx = 1
    
    Dim stringLength As Long
    stringLength = Len(strng)
    
    While curIndx <= stringLength
    
        Dim segment As String
        If keepLinesAndWordsTogetherWhenPossible Then
            segment = getNextSegmentOfParticularLengthButAvoidDividingLinesAndWordsIfPossible(strng, curIndx, size, True)
        Else
            segment = Mid(strng, curIndx, size)
        End If
        
        coll.add segment
        
        curIndx = curIndx + Len(segment)
        
        If Len(segment) <= 0 Then
            elwp_se
        End If
    Wend
    
    Set divideStringIntoSegmentsNoLargerThanParticularLength = coll

End Function

Function capitalizeFirstLetter(strng As String) As String
    Dim numCharsToCapitalize As Long
    numCharsToCapitalize = 1
    capitalizeFirstLetter = UCase(left(strng, numCharsToCapitalize)) & Right(strng, Len(strng) - numCharsToCapitalize)
End Function

Function ensureThatExactlyOneSetOfEnclosingParenthesisExistsAroundExpression(expression As String) As String
    
    Dim withoutEnclosingParentheses As String
    withoutEnclosingParentheses = recursivelyRemoveEnclosingParentheses(expression)

    ensureThatExactlyOneSetOfEnclosingParenthesisExistsAroundExpression = "(" & withoutEnclosingParentheses & ")"
End Function

Function countNumberOfCharsInString(theString As String, character As String) As Long

    Dim count As Long
    count = 0
    
    Dim substringLength As Long
    substringLength = Len(character)
    
    Dim size As Long
    size = Len(theString) - substringLength + 1
    
    Dim c As Long
    For c = 1 To size
        Dim curChar As String
        curChar = Mid(theString, c, substringLength)
        
        If curChar = character Then
            count = count + 1
        End If
    Next
    
    countNumberOfCharsInString = count
    

End Function

Function createRepeatingString(toRepeat As String, numTimes As Long)
    
    Dim soFar As String
    soFar = ""
    
    Dim c As Long
    For c = 1 To numTimes
        soFar = soFar & toRepeat
    Next
    
    createRepeatingString = soFar
End Function

Function validateParenthesisSituation(firstIndxOfOpenParen As Long, firstIndxOfClosingParen As Long) As Boolean
    
    Dim kosher As Boolean
    If firstIndxOfOpenParen = 0 And firstIndxOfClosingParen = 0 Then
        'There are no parenthesis in there.
        'So everything is kosher.
        kosher = True
    ElseIf firstIndxOfOpenParen = 0 Or firstIndxOfClosingParen = 0 Then
        'Mismatched parentheses exist in the expression.
        kosher = False
    ElseIf firstIndxOfOpenParen < firstIndxOfClosingParen Then
        'Our first set of parenthesis looks ok.  So far, it looks like we didn't seem to break anything by removing the enclosing parenthesis.
    
        kosher = True
    Else
        'Not Kosher!
        kosher = False
    End If
    validateParenthesisSituation = kosher
End Function

Attribute VB_Name = "JYCORE_Utils"
Option Explicit

Public Const DELETE_MODE_DELETE As String = "delete"
Public Const DELETE_MODE_CLEAR As String = "clear"
Public Const DELETE_MODE_CLEAR_CONTENTS As String = "clearContents"
Public Const DELETE_MODE_DELETE_ROWS_AND_SHIFT_UP As String = "deleteRows"
Public Const DELETE_MODE_MANUALLY_DELETE_ROWS_AND_SHIFT_UP As String = "ManuallyDeleteRowsAndShiftUp"
Public Const DELETE_MODE_DELETE_COLUMNS_AND_SHIFT_LEFT As String = "deleteCols"


'ssbm stands for setStatusBarMessage
Sub ssbm(msg As Variant)
On Error GoTo ehs

    Application.StatusBar = msg

GoTo ehe
ehs:
    elg "Could not set the status bar message to: " & msg
ehe:
On Error GoTo 0

End Sub

Sub deleteRnge(theSpecialRnge As Range, deleteMode As String)
    If deleteMode = DELETE_MODE_DELETE Then
        theSpecialRnge.Delete
    ElseIf deleteMode = DELETE_MODE_CLEAR Then
        theSpecialRnge.Clear
    ElseIf deleteMode = DELETE_MODE_DELETE_ROWS_AND_SHIFT_UP Then
        deleteRows theSpecialRnge, xlShiftUp
    ElseIf deleteMode = DELETE_MODE_MANUALLY_DELETE_ROWS_AND_SHIFT_UP Then
        'We can use this instead of DELETE_MODE_DELETE_ROWS_AND_SHIFT_UP when in shared worksheet mode.
        'When in shared worksheet mode, we can't  use the "delete" command.
        
        Dim ws As Worksheet
        Set ws = theSpecialRnge.Worksheet
        
        Dim topLeft As Range
        Dim bottomRight As Range
        Set topLeft = tlcor(theSpecialRnge)
        Set bottomRight = brcor(theSpecialRnge)
        
        Dim firstCol As Long
        Dim lastCol As Long
        firstCol = topLeft.column
        lastCol = bottomRight.column
        
        Dim firstRow As Long
        Dim lastRow As Long
        firstRow = topLeft.row
        lastRow = bottomRight.row
        
        Dim c As Long
        For c = firstCol To lastCol
            Dim ankForDataToKeep As Range
            Set ankForDataToKeep = ws.cells(lastRow, c)
            
            Dim dataToKeep As Collection
            Set dataToKeep = getColumnData(ankForDataToKeep)
            
            Dim ankForDataToDelete As Range
            Set ankForDataToDelete = ws.cells(firstRow - 1, c)
            
            clearColumnData ankForDataToDelete
            
            scd ankForDataToDelete, dataToKeep
            
        Next
        
    ElseIf deleteMode = DELETE_MODE_DELETE_COLUMNS_AND_SHIFT_LEFT Then
        deleteRows theSpecialRnge, xlToLeft
    Else
        If deleteMode <> DELETE_MODE_CLEAR_CONTENTS Then
            elwp "Unknown delete mode: " & deleteMode
        End If
        theSpecialRnge.ClearContents
    End If
End Sub



Sub clearAllRowsStartingAt(topLeftOfClearArea As Range, deleteMode As String)
    
    Dim botRight As Range
    Set botRight = topLeftOfClearArea.SpecialCells(xlLastCell)
    
    clearAllDataWithinArea topLeftOfClearArea, botRight, deleteMode
    
End Sub

Sub clearAllDataWithinArea(topLeftOfClearArea As Range, bottomRightOfClearArea As Range, deleteMode As String)
    
    If bottomRightOfClearArea.row < topLeftOfClearArea.row Then
        Set bottomRightOfClearArea = moveRnge(bottomRightOfClearArea, topLeftOfClearArea.row, bottomRightOfClearArea.column)
    End If
    If bottomRightOfClearArea.column < topLeftOfClearArea.column Then
        Set bottomRightOfClearArea = moveRnge(bottomRightOfClearArea, bottomRightOfClearArea.row, topLeftOfClearArea.column)
    End If
    
    
    Dim theSpecialRnge As Range
    Set theSpecialRnge = rngeToRnge(topLeftOfClearArea, bottomRightOfClearArea)
    
    deleteRnge theSpecialRnge, deleteMode
    
    
End Sub

Sub deleteRows(rnge As Range, shift As Variant)
    rnge.Delete shift
End Sub

Function isNothing(obj As Variant) As Boolean
On Error GoTo ehs
    isNothing = (obj Is Nothing)
GoTo ehe
ehs:
    isNothing = False
ehe:
On Error GoTo 0
End Function

Function valuesAreEqual(V1 As Variant, V2 As Variant) As Boolean

    If isNumber(V1) And isNumber(V2) Then
        valuesAreEqual = CDbl(V1) = CDbl(V2)
    ElseIf TypeName(V1) <> TypeName(V2) Then
        valuesAreEqual = False
    ElseIf isCollection(V1) And isCollection(V2) Then
        valuesAreEqual = collectionsAreEqual(castToCollection(V1), castToCollection(V2))
    ElseIf isSet(V1) And isSet(V2) Then
        valuesAreEqual = castToSet(V1).equalsSet(castToSet(V2))
    ElseIf IsObject(V1) And IsObject(V2) Then
        valuesAreEqual = (V1 Is V2)
    ElseIf IsArray(V1) And IsArray(V2) Then
        valuesAreEqual = arraysAreEqual(V1, V2)
    ElseIf (Not IsObject(V1)) And (Not IsObject(V2)) Then
        valuesAreEqual = (V1 = V2)
    Else
        valuesAreEqual = False
    End If

End Function
Attribute VB_Name = "JYUT_AdvancedDictionary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private internalDictionary As Dictionary
Private preferredCapitalizationByKey As Dictionary

Public ignoreSpacesBetweenWords As Boolean
Public caseInsensitive As Boolean
Public shouldTrimKey As Boolean

Private Sub Class_Initialize()
    Set internalDictionary = New Dictionary
    Set preferredCapitalizationByKey = New Dictionary
End Sub


Function add(key As Variant, value As Variant) As Variant
    
    Dim adjKy As Variant
    atr adjKy, adjKey(key)
    
    atr add, atd(internalDictionary, adjKy, value)
    
    atd preferredCapitalizationByKey, adjKy, key
    
End Function

Function exists(key As Variant) As Boolean
    exists = internalDictionary.exists(adjKey(key))
End Function

Function remove(key As Variant) As Variant
    
    Dim theAdjKey As Variant
    atr theAdjKey, adjKey(key)
    
    Dim adjKy As Variant
    atr adjKy, theAdjKey

    atr remove, rfd(internalDictionary, adjKy)
    rfd preferredCapitalizationByKey, adjKy
End Function

Function adjKey(key As Variant)
    
    Dim caseAdjustedKey As Variant
    If caseInsensitive Then
        caseAdjustedKey = lcaseIfPossible(key)
    Else
        caseAdjustedKey = key
    End If
    
    Dim trimmedKey As Variant
    If shouldTrimKey Then
        trimmedKey = Trim(caseAdjustedKey)
    Else
        trimmedKey = caseAdjustedKey
    End If
    
    Dim caseAdjustedAndSpaceBetweenWordsAndTrimAdjustedKey As Variant
    If ignoreSpacesBetweenWords Then
        caseAdjustedAndSpaceBetweenWordsAndTrimAdjustedKey = removeSpacesInBetweenWords(CStr(trimmedKey))
    Else
        caseAdjustedAndSpaceBetweenWordsAndTrimAdjustedKey = trimmedKey
    End If
    
    atr adjKey, caseAdjustedAndSpaceBetweenWordsAndTrimAdjustedKey
End Function

Function item(key As Variant) As Variant
    atr item, vfd(internalDictionary, adjKey(key), False)
End Function

Function keys() As Variant
    Dim coll As Collection
    Set coll = getDictionaryValues(preferredCapitalizationByKey)
    
    If coll.count = 0 Then
        keys = internalDictionary.keys()
    Else
        keys = collectionToArray(coll)
    End If
End Function

Function toDictionary() As Dictionary

    Dim intDictKeys As Variant
    intDictKeys = internalDictionary.keys()
        
    Dim capitalizationKeys As Variant
    capitalizationKeys = preferredCapitalizationByKey.keys()
    
    If dimSize(intDictKeys, 1) <> dimSize(capitalizationKeys, 1) Then
        elwp_se
        Set toDictionary = Nothing
    Else
        Dim numKeys As Variant
        numKeys = dimSize(intDictKeys, 1)
        
        If numKeys = 0 Then
            Set toDictionary = New Dictionary
        Else
            If Not collectionToSet(arrayToCollection(intDictKeys)).equalsSet(collectionToSet(arrayToCollection(capitalizationKeys))) Then
                elwp_se
                Set toDictionary = Nothing
            Else
            
                Dim newDict As Dictionary
                Set newDict = New Dictionary
            
                Dim lwr As Long
                Dim upr As Long
                glaubs intDictKeys, lwr, upr
                
                Dim c As Long
                For c = lwr To upr
                    Dim curKey As Variant
                    curKey = intDictKeys(c)
                    
                    Dim curVal As Variant
                    Dim keyWithCapitalization As Variant
                    atr curVal, vfd(internalDictionary, curKey, True)
                    atr keyWithCapitalization, vfd(preferredCapitalizationByKey, curKey, True)
                    
                    If Not isNothing(atd(newDict, keyWithCapitalization, curVal)) Then
                        elwp_se
                    End If
                Next
                
                Set toDictionary = newDict
            End If
        End If
    End If
End Function

Function count() As Long
    If preferredCapitalizationByKey.count <> internalDictionary.count Then
        elwp_se
    End If
    count = internalDictionary.count
End Function

Function clone()
    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    Dim advDict As JYUT_AdvancedDictionary
    Set advDict = createAdvancedDictionaryFromDictionary(Me.toDictionary(), emsgs, ignoreSpacesBetweenWords, caseInsensitive, shouldTrimKey)
    
    If emsgs.count <> 0 Then
        elwp emsgs.toString(CHAR_CRLF, "")
    End If
    
    
    Set clone = advDict
    
    
End Function
Attribute VB_Name = "JYUT_Aggregations"
Option Explicit

Public Const AGG_TYPE_NONE As String = "no aggregation"
Public Const AGG_TYPE_DISTINCT_VALUE As String = "distinct value"
Public Const AGG_TYPE_WEIGHTED_AVERAGE As String = "wtd average"
Public Const AGG_TYPE_WEIGHTED_AVERAGE_OF_CPR_OR_CDR As String = "wtd average of CPR/CDR"
Public Const AGG_TYPE_AVERAGE As String = "average"
Public Const AGG_TYPE_SUM As String = "sum"

Function extractColumnOfValuesFromDataRowList(dataRows As Collection, col As Long, expectedNumCols As Long, ByRef mod_emsgs As Variant) As Variant
    
    Dim numRows As Long
    numRows = dataRows.count
    
    Dim valsToAggregate As Variant
    ReDim valsToAggregate(1 To numRows)
    
    Dim y As Long
    For y = 1 To numRows
        Dim dataRow As Variant
        dataRow = dataRows.item(y)
        
        Dim numColsInRow As Long
        numColsInRow = dimSize(dataRow, 1)
        
        If numColsInRow <> expectedNumCols Then
            mod_emsgs.add "We expected " & expectedNumCols & " columns in our data row, but found " & numColsInRow & "!"
        End If
        
        Dim disVal As Variant
        If col <= numColsInRow Then
            disVal = rlai(dataRow, col)
        Else
            disVal = ""
        End If
        valsToAggregate(y) = disVal
    Next
    extractColumnOfValuesFromDataRowList = valsToAggregate
End Function

Function getWeightsToAggregateOrNothingIfWeightsAreNotNeeded(fieldNameForWeightInWtdAvg As String, fieldNamesForDataRetrieval As Collection, dataRows As Collection, expectedNumCols As Long, ByRef mod_emsgs As Variant) As Variant
    
    Dim weightsToAggregate As Variant
    If Trim(fieldNameForWeightInWtdAvg) = "" Then
        Set weightsToAggregate = Nothing
    Else
        Dim colNumForWeightInWtdAvg As Long
        colNumForWeightInWtdAvg = searchCollectionLinearly(fieldNamesForDataRetrieval, fieldNameForWeightInWtdAvg)
    
        If colNumForWeightInWtdAvg <= 1 Then
            mod_emsgs.add "Could not find our weights field, '" & fieldNameForWeightInWtdAvg & "', in our source data!"
            weightsToAggregate = Nothing
        Else
            weightsToAggregate = extractColumnOfValuesFromDataRowList(dataRows, colNumForWeightInWtdAvg, expectedNumCols, mod_emsgs)
        End If
    End If
    
    atr getWeightsToAggregateOrNothingIfWeightsAreNotNeeded, weightsToAggregate
End Function

Function aggregateValues(dataRows As Collection, colToAggregate As Long, expectedNumCols As Long, ByRef mod_emsgs As Variant, aggType As String, fieldNamesForDataRetrieval As Collection, fieldNameForWeightInWtdAvg As String)

    Dim weightsToAggregate As Variant
    atr weightsToAggregate, getWeightsToAggregateOrNothingIfWeightsAreNotNeeded(fieldNameForWeightInWtdAvg, fieldNamesForDataRetrieval, dataRows, expectedNumCols, mod_emsgs)
    
    Dim aggregateValue As String
    If aggType = AGG_TYPE_NONE Then
        aggregateValue = ""
    Else
        
        Dim valsToAggregate As Variant
        valsToAggregate = extractColumnOfValuesFromDataRowList(dataRows, colToAggregate, expectedNumCols, mod_emsgs)
        
        Dim ignoreNonnumerics As Boolean
        Dim valueForDivZero As Variant
        ignoreNonnumerics = True
        valueForDivZero = 0
        
        If aggType = AGG_TYPE_DISTINCT_VALUE Then
            Dim distinctValues As JYCORE_Set
            Set distinctValues = collectionToSet(arrayToCollection(valsToAggregate))
            
            If distinctValues.count = 1 Then
                aggregateValue = CStr(distinctValues.toCollection().item(1))
            Else
                aggregateValue = ""
            End If
        ElseIf aggType = AGG_TYPE_SUM Then
            aggregateValue = sumOfArrayContents(valsToAggregate, mod_emsgs, ignoreNonnumerics, valueForDivZero)
        ElseIf aggType = AGG_TYPE_AVERAGE Then
            aggregateValue = avgOfArrayContents(valsToAggregate, mod_emsgs, ignoreNonnumerics, valueForDivZero)
        ElseIf aggType = AGG_TYPE_WEIGHTED_AVERAGE Then
            aggregateValue = CStr(weightedAvgOfArrayContents(valsToAggregate, mod_emsgs, ignoreNonnumerics, weightsToAggregate, valueForDivZero))
        ElseIf aggType = AGG_TYPE_WEIGHTED_AVERAGE_OF_CPR_OR_CDR Then
            aggregateValue = CStr(weightedAvgOfCPRCDRInArrayContents(valsToAggregate, mod_emsgs, ignoreNonnumerics, weightsToAggregate, valueForDivZero))
        ElseIf Trim(aggType) = "" Then
            aggregateValue = ""
        Else
            aggregateValue = ""
            mod_emsgs.add "Unknown agg type: " & aggType
        End If
            
    End If
    
    aggregateValues = aggregateValue
End Function

Function aggregateRows(dataRows As Collection, aggTypes As Collection, weightsFields As Collection, ByRef mod_emsgs As Variant, fieldNamesForDataRetrieval As Collection) As Variant

    Dim numCols As Long
    numCols = aggTypes.count
    
    Dim numRows As Long
    numRows = dataRows.count
    
    Dim aggregateRow As Variant
    ReDim aggregateRow(1 To numCols)
    
    Dim c As Long
    For c = 1 To numCols
    
        Dim aggType As String
        aggType = aggTypes.item(c)
        
        Dim fieldNameForWeightInWtdAvg As String
        fieldNameForWeightInWtdAvg = weightsFields.item(c)
        
        Dim aggregateValue As String
        aggregateValue = aggregateValues(dataRows, c, numCols, mod_emsgs, aggType, fieldNamesForDataRetrieval, fieldNameForWeightInWtdAvg)
        
        aggregateRow(c) = aggregateValue
    
    Next
    
    aggregateRows = aggregateRow
    

End Function

Function sortGroupOfRows(fieldNamesForDataRetrieval As Collection, atLowestLevelSortBy As String, unsortedDataRows As Collection) As Collection
    Dim dataRows As Collection
    If Trim(atLowestLevelSortBy) = "" Then
        Set dataRows = unsortedDataRows
    Else
        Dim indx As Long
        indx = searchCollectionLinearly(fieldNamesForDataRetrieval, atLowestLevelSortBy)
        
        If indx = 0 Then
            elwp "Could not sort by the field '" & atLowestLevelSortBy & "' because we could not find it in our data!"
            Set dataRows = unsortedDataRows
        Else
            Set dataRows = sortListOfArraysByArrayIndx(unsortedDataRows, indx)
        End If
    End If
    
    Set sortGroupOfRows = dataRows
    
End Function

Sub getSectionForOurReport(ByRef out_aggregateRow As Variant, ByRef out_dataRows As Collection, dataRowsByNestedKeys As Dictionary, nestedKey As Variant, fieldNamesForDataRetrieval As Collection, optAtLowestLevelSortBy As String, aggTypes As Collection, weightsFields As Collection, ByRef mod_emsgs As Variant)
    
    Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
    shouldCastKeyToStringIfHelpsFindValue = False
    
    Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
    assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True 'true, because we are expecting to get back a Collection
    
    Dim unsortedDataRows As Collection
    Set unsortedDataRows = getValueForNestedDictionaryPath(dataRowsByNestedKeys, nestedKey, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    
    Dim dataRows As Collection
    If optAtLowestLevelSortBy = "" Then
        Set dataRows = unsortedDataRows
    Else
        Set dataRows = sortGroupOfRows(fieldNamesForDataRetrieval, optAtLowestLevelSortBy, unsortedDataRows)
    End If
    
    Dim aggregateRow As Variant
    aggregateRow = aggregateRows(dataRows, aggTypes, weightsFields, mod_emsgs, fieldNamesForDataRetrieval)
    
    Set out_dataRows = dataRows
    
    out_aggregateRow = aggregateRow
    
End Sub

Function getReportValues(dataRowsByNestedKeys As Dictionary, fieldNamesForDataRetrieval As Collection, optAtLowestLevelSortBy As String, aggTypes As Collection, weightsFields As Collection, ByRef mod_emsgs As Variant) As Collection
    
    Dim listOf_nestedKeyAndAggregateRowAndDataRows As Collection
    Set listOf_nestedKeyAndAggregateRowAndDataRows = New Collection
    
    Dim nestedKeys As Collection
    Set nestedKeys = getNestedDictionaryPaths(dataRowsByNestedKeys, True)
    
    Dim z As Long
    For z = 1 To nestedKeys.count
    
        Dim nestedKey2 As Variant
        nestedKey2 = nestedKeys.item(z)
    
        Dim dataRows2 As Collection
        Dim aggregateRow2 As Variant
        getSectionForOurReport aggregateRow2, dataRows2, dataRowsByNestedKeys, nestedKey2, fieldNamesForDataRetrieval, optAtLowestLevelSortBy, aggTypes, weightsFields, mod_emsgs
        
        listOf_nestedKeyAndAggregateRowAndDataRows.add Array(nestedKey2, aggregateRow2, dataRows2)
    Next
    
    Set getReportValues = listOf_nestedKeyAndAggregateRowAndDataRows
End Function

Function constructReportFromSpreadsheet(dataHeaders As Range, ByRef mod_emsgs As Variant, fieldNamesForGrouping As Collection, optAtLowestLevelSortBy As String, listOf__fieldNameForDataRetrieval_aggType_weightFieldIfAppropriate As Collection) As Collection

    Dim fieldNamesForDataRetrieval_aggTypes_weightFieldsIfAppropriate As Collection
    Set fieldNamesForDataRetrieval_aggTypes_weightFieldsIfAppropriate = sciloar(True, listOf__fieldNameForDataRetrieval_aggType_weightFieldIfAppropriate)
    
    Dim fieldNamesForDataRetrieval As Collection
    Dim aggTypes As Collection
    Dim weightsFields As Collection
    Set fieldNamesForDataRetrieval = fieldNamesForDataRetrieval_aggTypes_weightFieldsIfAppropriate.item(1)
    Set aggTypes = fieldNamesForDataRetrieval_aggTypes_weightFieldsIfAppropriate.item(2)
    Set weightsFields = fieldNamesForDataRetrieval_aggTypes_weightFieldsIfAppropriate.item(3)
    
    Dim dataRowsByNestedKeys As Dictionary
    Set dataRowsByNestedKeys = gatherAndCollateData(dataHeaders, mod_emsgs, fieldNamesForGrouping, fieldNamesForDataRetrieval)
    
    Dim listOf_nestedKeyAndAggregateRowAndDataRows As Collection
    Set listOf_nestedKeyAndAggregateRowAndDataRows = getReportValues(dataRowsByNestedKeys, fieldNamesForDataRetrieval, optAtLowestLevelSortBy, aggTypes, weightsFields, mod_emsgs)

    Set constructReportFromSpreadsheet = listOf_nestedKeyAndAggregateRowAndDataRows

End Function

Function gatherAndCollateData(dataHeaders As Range, ByRef mod_emsgs As Variant, fieldNamesForGrouping As Collection, fieldNamesForDataRetrieval As Collection) As Dictionary
    
    Dim dataRowsByNestedKeys As Dictionary
    Set dataRowsByNestedKeys = New Dictionary
    
    Dim rngObjFieldNamesForData As Collection
    Dim rngObjFieldNamesForGrouping As Collection
    Dim dataRangesObj As JYUT_RngeIncrementer
    createTheDataRangesObj dataRangesObj, rngObjFieldNamesForData, rngObjFieldNamesForGrouping, fieldNamesForDataRetrieval, fieldNamesForGrouping, dataHeaders, mod_emsgs
    
    Dim numFieldsForGrouping As Long
    Dim numFieldsToRetrieve As Long
    numFieldsForGrouping = rngObjFieldNamesForGrouping.count
    numFieldsToRetrieve = rngObjFieldNamesForData.count
    
    Dim listOf_groupingKeyAndDataRow As Collection
    Set listOf_groupingKeyAndDataRow = getGroupingKeysAndDataRows(dataRangesObj, numFieldsForGrouping, rngObjFieldNamesForGrouping, numFieldsToRetrieve, rngObjFieldNamesForData)
    
    Dim z As Long
    For z = 1 To listOf_groupingKeyAndDataRow.count
        
        Dim groupingKeyAndDataRow As Variant
        groupingKeyAndDataRow = listOf_groupingKeyAndDataRow.item(z)
        
        Dim groupingKey As Variant
        Dim dataRow As Variant
        groupingKey = rlai(groupingKeyAndDataRow, 1)
        dataRow = rlai(groupingKeyAndDataRow, 2)
        
        Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
        assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = False '<-- not sure, so will assume false for now (we will decline the optimization for now)
        
        addToListOfValuesByNestedKey dataRowsByNestedKeys, groupingKey, dataRow, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
        
        
        
    Next
    
    Set gatherAndCollateData = dataRowsByNestedKeys
End Function

Sub createTheDataRangesObj(ByRef out_dataRangesObj As JYUT_RngeIncrementer, ByRef out_rngObjFieldNamesForData As Collection, ByRef out_rngObjFieldNamesForGrouping As Collection, fieldNamesForDataRetrieval As Collection, fieldNamesForGrouping As Collection, dataHeaders As Range, ByRef mod_emsgs As Variant)

    Dim allFieldNamesThatShouldBeRetrieved As Collection
    Set allFieldNamesThatShouldBeRetrieved = copyCollection(fieldNamesForDataRetrieval)
    acltcl allFieldNamesThatShouldBeRetrieved, fieldNamesForGrouping
    
    
    
    
    Dim rngObjFieldNames As Collection
    Dim dataRangesObj As JYUT_RngeIncrementer
    Set dataRangesObj = getDataRangesObj(allFieldNamesThatShouldBeRetrieved, rngObjFieldNames, dataHeaders, mod_emsgs)
        
    Dim numDataFieldsForDisplay As Long
    Dim numFieldsForGrouping As Long
    numDataFieldsForDisplay = fieldNamesForDataRetrieval.count
    numFieldsForGrouping = fieldNamesForGrouping.count
    
    If (allFieldNamesThatShouldBeRetrieved.count <> rngObjFieldNames.count) Or (rngObjFieldNames.count <> numDataFieldsForDisplay + numFieldsForGrouping) Then
        elwp_se
    End If
    
    Dim rngObjFieldNamesForData As Collection
    Dim rngObjFieldNamesForGrouping As Collection
    Set rngObjFieldNamesForData = New Collection
    Set rngObjFieldNamesForGrouping = New Collection
    Dim x As Long
    For x = 1 To numDataFieldsForDisplay
        rngObjFieldNamesForData.add rngObjFieldNames.item(x)
    Next
    
    Dim y As Long
    For y = numDataFieldsForDisplay + 1 To allFieldNamesThatShouldBeRetrieved.count
        rngObjFieldNamesForGrouping.add rngObjFieldNames.item(y)
    Next
    
    Set out_dataRangesObj = dataRangesObj
    Set out_rngObjFieldNamesForData = rngObjFieldNamesForData
    Set out_rngObjFieldNamesForGrouping = rngObjFieldNamesForGrouping
End Sub

Function getGroupingKeysAndDataRows(theDataRangesObj As JYUT_RngeIncrementer, numFieldsForGrouping As Long, rngObjFieldNamesForGrouping As Collection, numFieldsToRetrieve As Long, rngObjFieldNamesForData As Collection) As Collection
    
    Dim dataRangesObj As JYUT_RngeIncrementer
    Set dataRangesObj = theDataRangesObj.clone()
    
    Dim listOf_groupingKeyAndDataRow As Collection
    Set listOf_groupingKeyAndDataRow = New Collection
    While dataRangesObj.moreDataRemaining
    
        Dim groupingKey As Variant
        ReDim groupingKey(1 To numFieldsForGrouping)
        Dim p As Long
        For p = 1 To numFieldsForGrouping
            groupingKey(p) = tryToGetValFromRngesObj(rngObjFieldNamesForGrouping.item(p), dataRangesObj)
        Next
    
        Dim dataRow As Variant
        ReDim dataRow(1 To numFieldsToRetrieve)
        Dim t As Long
        For t = 1 To numFieldsToRetrieve
            
            Dim rangeObjRN As String
            rangeObjRN = rngObjFieldNamesForData.item(t)
            
            dataRow(t) = tryToGetValFromRngesObj(rangeObjRN, dataRangesObj)
        Next
        
        listOf_groupingKeyAndDataRow.add Array(groupingKey, dataRow)
        
        dataRangesObj.increment
    Wend
    
    Set getGroupingKeysAndDataRows = listOf_groupingKeyAndDataRow
    
End Function


Function getDataRangesObj(fieldNamesForDataRetrieval As Collection, ByRef out_rngeObjFieldNames As Collection, dataHeaders As Range, ByRef mod_emsgs As Variant) As JYUT_RngeIncrementer

    Dim matchCase As Boolean
    matchCase = True
    
    Dim dataRangesObj As JYUT_RngeIncrementer
    Set dataRangesObj = New JYUT_RngeIncrementer
    
    Dim rngeObjFieldNames As Collection
    Set rngeObjFieldNames = New Collection

    Dim c As Long
    For c = 1 To fieldNamesForDataRetrieval.count
        
        Dim dataField As String
        dataField = fieldNamesForDataRetrieval.item(c)
        
        Dim theRnge As Range
        Set theRnge = findCell(dataHeaders, dataField, matchCase, True)
        
        Dim rngObjName As String
        If dataField = "" Then
            rngObjName = ""
        ElseIf isNothing(theRnge) Then
            rngObjName = ""
            mod_emsgs.add "Could not find the data column named '" & dataField & "'!"
        Else
            rngObjName = "rn" & c
            dataRangesObj.addRnge rngObjName, theRnge, False
        End If
        
        rngeObjFieldNames.add rngObjName
    Next
    
    
    Set out_rngeObjFieldNames = rngeObjFieldNames
    Set getDataRangesObj = dataRangesObj
    
End Function

Function tryToGetValFromRngesObj(rangeObjRN As String, dataRangesObj As JYUT_RngeIncrementer) As Variant
    Dim dataVal As Variant
    If rangeObjRN = "" Then
        dataVal = Empty
    Else
        dataVal = dataRangesObj.getValue(rangeObjRN)
    End If
    tryToGetValFromRngesObj = dataVal
End Function

'rowAboveHeaderRow = topLeft.EntireRow
'deleteMode = DELETE_MODE_CLEAR
'optTitleHighlightColor = COLOR_AUTOMATIC_AND_NO_FILL
'optHighlightColorForData = COLOR_AUTOMATIC_AND_NO_FILL
'clearOnly = false
Function writeReportData(anchorForReportArea As Range, colTitles As Collection, ByRef mod_emsgs As Variant, listOf_nestedKeyAndAggregateRowAndDataRows As Collection, optConvertToTicks As Collection, rowHeightOrNothingIfNoBorderRowDesired As Variant, optRowHeightToSetClearedAreaTo As Variant, optFontSizeToSetClearedAreaTo As Variant, colOffsetForData As Long, deleteMode As String, optTitleHighlightColor As String, optHighlightColorForData As String, showDataRows As Boolean, clearOnly As Boolean) As Long
    
    Dim rptWS As Worksheet
    Set rptWS = anchorForReportArea.Worksheet
    
    Dim areaToClear As Range
    Set areaToClear = rngeToRnge(shiftRnge(anchorForReportArea, 2, 0), gcicsr(brcor(anchorForReportArea), anchorForReportArea.SpecialCells(xlLastCell).row))
    
    If isNothing(optRowHeightToSetClearedAreaTo) Then
        'DO NOTHING
    Else
        areaToClear.RowHeight = CDbl(optRowHeightToSetClearedAreaTo)
    End If
    
    If isNothing(optFontSizeToSetClearedAreaTo) Then
        'DO NOTHING
    Else
        setFontSize areaToClear, CDbl(optFontSizeToSetClearedAreaTo)
    End If
    
    deleteRnge areaToClear, deleteMode
    If optHighlightColorForData = "" Then
        'DO NOTHING
    Else
        setBackground areaToClear, optHighlightColorForData
    End If
    
    'clearAllRowsStartingAt shiftRnge(anchorForReportArea, 2, 0)
    
    Dim firstCol As Long
    firstCol = anchorForReportArea.column + colOffsetForData
    
    Dim firstRow As Long
    firstRow = anchorForReportArea.row + 1
    
    Dim row As Long
    row = firstRow
    
    shiftRnge(anchorForReportArea, 1, 0).ClearContents 'Clear the headers
    
    If clearOnly Then
        'DO NOTHING
    Else

        
        row = writeRow(kta(colTitles), optTitleHighlightColor, True, firstCol, row, rptWS, Nothing, mod_emsgs, Nothing)
        
        Dim lastFirstKey As Variant
        lastFirstKey = ""
        
        Dim c As Long
        For c = 1 To listOf_nestedKeyAndAggregateRowAndDataRows.count
            
            Dim nestedKeyAndAggregateRowAndDataRows As Variant
            nestedKeyAndAggregateRowAndDataRows = listOf_nestedKeyAndAggregateRowAndDataRows.item(c)
            
            Dim nestedKey As Variant
            Dim aggregateRow As Variant
            Dim dataRows As Collection
            nestedKey = rlai(nestedKeyAndAggregateRowAndDataRows, 1)
            aggregateRow = rlai(nestedKeyAndAggregateRowAndDataRows, 2)
            Set dataRows = rlai(nestedKeyAndAggregateRowAndDataRows, 3)
            
            Dim numKeys As Long
            numKeys = dimSize(nestedKey, 1)
            
            Dim firstKey As Variant
            If numKeys = 0 Then
                firstKey = ""
            Else
                firstKey = rlai(nestedKey, 1)
            End If
            
            If isNothing(rowHeightOrNothingIfNoBorderRowDesired) Then
                'DO NOTHING
            Else
                If lastFirstKey <> "" Then
                    If Trim(firstKey) <> Trim(lastFirstKey) Then
                        Dim frst As Range
                        Set frst = rptWS.cells(row, firstCol)
                        
                        Dim daRnge As Range
                        Set daRnge = rngeToRnge(frst, brcor(frst.EntireRow))
                        
                        setBackground daRnge, COLOR_BLUE_ACCENT_1_DARKER_25_PCT
                        daRnge.RowHeight = CDbl(rowHeightOrNothingIfNoBorderRowDesired)
                        
                        row = row + 1
                    End If
                End If
            End If
            
            If numKeys > dimSize(aggregateRow, 1) Then
                mod_emsgs.add "More keys exist than data columns!  This is likely a bug."
            Else
                Dim x As Long
                For x = 1 To numKeys
                    
                    'srai aggregateRow, x, "'" & rlai(nestedKey, x) 'Apostrophe is to ensure text data format
                    srai aggregateRow, x, rlai(nestedKey, x)
                Next
            End If
            
            Dim highlightColor As String
            Dim sectionRowsShouldBeInBold As Boolean
            If showDataRows Then
                'We SHOULD highlight the section rows
                
                If isOdd(c) Then
                    highlightColor = COLOR_TAN_BACKGROUND_2
                Else
                    highlightColor = COLOR_WHITE_BACKGROUND_1_DARKER_15_PCT
                End If
                
                sectionRowsShouldBeInBold = True
            Else
                'No need to highlight the section rows
                
                highlightColor = ""
                sectionRowsShouldBeInBold = False
            End If
            
            row = writeRow(aggregateRow, highlightColor, sectionRowsShouldBeInBold, firstCol, row, rptWS, optConvertToTicks, mod_emsgs, Nothing)
            
            If showDataRows Then
                Dim r As Long
                For r = 1 To dataRows.count
                    Dim dRow As Variant
                    dRow = dataRows.item(r)
                    
                    row = writeRow(dRow, optHighlightColorForData, False, firstCol, row, rptWS, optConvertToTicks, mod_emsgs, Nothing)
                Next
            End If
            
            lastFirstKey = firstKey
            
        Next
    
        
    End If
    
    Dim rowAfterEndOfWrittenData As Long
    rowAfterEndOfWrittenData = row
    
    writeReportData = rowAfterEndOfWrittenData
End Function

Function writeRow(rowVals As Variant, optHighlightColor As String, shouldBold As Boolean, col As Long, row As Long, ws As Worksheet, optConvertToTicks As Collection, ByRef mod_emsgs As Variant, optFontSize As Variant) As Long
    
    Dim numCols As Long
    numCols = dimSize(rowVals, 1)
    
    If numCols = 0 Then
        'DO NOTHING
    Else
    
        Dim size As Long
        size = dimSize(rowVals, 1)
        
        Dim convToTicks As Collection
        Set convToTicks = handleOptVector(optConvertToTicks, mod_emsgs, size)
        
        Dim theRow As Variant
        If isNothing(convToTicks) Then
            theRow = rowVals
        Else
            theRow = copyArr(rowVals)
            Dim y As Long
            For y = 1 To size
                Dim conv As Boolean
                conv = convToTicks.item(y)
                
                If conv Then
                    Dim converted As Variant
                    converted = rlai(theRow, y)
                    
                    If Not isNumber(converted) Then
                        'DO NOTHING
                    Else
                        'JY20110523a
                        'converted = "'" & DecTic(CDbl(converted), 32) 'The apostrophe is to gaurantee text format (no misinterpretation as a date, etc.)
                        converted = "'" & convertDecimalsToTicks(CDbl(converted), True)  'The apostrophe is to gaurantee text format (no misinterpretation as a date, etc.)
                    End If
                    srai theRow, y, converted
                End If
            Next
        End If

        
        Dim leftCell As Range
        Set leftCell = ws.cells(row, col)
        
        Dim rngeToWrite As Range
        Set rngeToWrite = resizeRnge(leftCell, 1, numCols)
        
        srg rngeToWrite
    
        Dim twoDimArray As Variant
        twoDimArray = oneDimArrayTo2DArray(theRow, True)
        
        If optHighlightColor <> "" Then
            setBackground rngeToWrite, optHighlightColor
        End If
        
        setBold rngeToWrite, shouldBold
        If Not isNothing(optFontSize) Then
            setFontSize rngeToWrite, CLng(optFontSize)
        End If
    
        rngeToWrite.value = twoDimArray
    End If

    writeRow = row + 1
End Function


Function handleOptVector(optVector As Collection, ByRef mod_emsgs As Variant, expectedSize As Long) As Collection
    Dim nvect As Collection
    Set nvect = optVector
    If Not isNothing(optVector) Then
        If optVector.count <> expectedSize Then
            mod_emsgs.add "Invalid number of params were encountered!"
            Set nvect = Nothing
        End If
    End If
    Set handleOptVector = nvect
End Function
Attribute VB_Name = "JYUT_Array"
'This module has been moved to the JYCORE library.
Attribute VB_Name = "JYUT_Base64"
Option Explicit

Private Const clOneMask = 16515072          '000000 111111 111111 111111
Private Const clTwoMask = 258048            '111111 000000 111111 111111
Private Const clThreeMask = 4032            '111111 111111 000000 111111
Private Const clFourMask = 63               '111111 111111 111111 000000

Private Const clHighMask = 16711680         '11111111 00000000 00000000
Private Const clMidMask = 65280             '00000000 11111111 00000000
Private Const clLowMask = 255               '00000000 00000000 11111111

Private Const cl2Exp18 = 262144             '2 to the 18th power
Private Const cl2Exp12 = 4096               '2 to the 12th
Private Const cl2Exp6 = 64                  '2 to the 6th
Private Const cl2Exp8 = 256                 '2 to the 8th
Private Const cl2Exp16 = 65536              '2 to the 16th

Public Function Encode64(sString As String) As String

    Dim bTrans(63) As Byte, lPowers8(255) As Long, lPowers16(255) As Long, bOut() As Byte, bIn() As Byte
    Dim lChar As Long, lTrip As Long, iPad As Integer, lLen As Long, lTemp As Long, lPos As Long, lOutSize As Long

    For lTemp = 0 To 63                                 'Fill the translation table.
        Select Case lTemp
            Case 0 To 25
                bTrans(lTemp) = 65 + lTemp              'A - Z
            Case 26 To 51
                bTrans(lTemp) = 71 + lTemp              'a - z
            Case 52 To 61
                bTrans(lTemp) = lTemp - 4               '1 - 0
            Case 62
                bTrans(lTemp) = 43                      'Chr(43) = "+"
            Case 63
                bTrans(lTemp) = 47                      'Chr(47) = "/"
        End Select
    Next lTemp

    For lTemp = 0 To 255                                'Fill the 2^8 and 2^16 lookup tables.
        lPowers8(lTemp) = lTemp * cl2Exp8
        lPowers16(lTemp) = lTemp * cl2Exp16
    Next lTemp

    iPad = Len(sString) Mod 3                           'See if the length is divisible by 3
    If iPad Then                                        'If not, figure out the end pad and resize the input.
        iPad = 3 - iPad
        sString = sString & String(iPad, Chr(0))
    End If

    bIn = StrConv(sString, vbFromUnicode)               'Load the input string.
    lLen = ((UBound(bIn) + 1) \ 3) * 4                  'Length of resulting string.
    lTemp = lLen \ 72                                   'Added space for vbCrLfs.
    lOutSize = ((lTemp * 2) + lLen) - 1                 'Calculate the size of the output buffer.
    ReDim bOut(lOutSize)                                'Make the output buffer.

    lLen = 0                                            'Reusing this one, so reset it.

    For lChar = LBound(bIn) To UBound(bIn) Step 3
        lTrip = lPowers16(bIn(lChar)) + lPowers8(bIn(lChar + 1)) + bIn(lChar + 2)    'Combine the 3 bytes
        lTemp = lTrip And clOneMask                     'Mask for the first 6 bits
        bOut(lPos) = bTrans(lTemp \ cl2Exp18)           'Shift it down to the low 6 bits and get the value
        lTemp = lTrip And clTwoMask                     'Mask for the second set.
        bOut(lPos + 1) = bTrans(lTemp \ cl2Exp12)       'Shift it down and translate.
        lTemp = lTrip And clThreeMask                   'Mask for the third set.
        bOut(lPos + 2) = bTrans(lTemp \ cl2Exp6)        'Shift it down and translate.
        bOut(lPos + 3) = bTrans(lTrip And clFourMask)   'Mask for the low set.
        If lLen = 68 Then                               'Ready for a newline
            bOut(lPos + 4) = 13                         'Chr(13) = vbCr
            bOut(lPos + 5) = 10                         'Chr(10) = vbLf
            lLen = 0                                    'Reset the counter
            lPos = lPos + 6
        Else
            lLen = lLen + 4
            lPos = lPos + 4
        End If
    Next lChar

    If bOut(lOutSize) = 10 Then lOutSize = lOutSize - 2 'Shift the padding chars down if it ends with CrLf.

    If iPad = 1 Then                                    'Add the padding chars if any.
        bOut(lOutSize) = 61                             'Chr(61) = "="
    ElseIf iPad = 2 Then
        bOut(lOutSize) = 61
        bOut(lOutSize - 1) = 61
    End If

    Encode64 = StrConv(bOut, vbUnicode)                 'Convert back to a string and return it.

End Function

Public Function Decode64(sString As String) As String

    Dim bOut() As Byte, bIn() As Byte, bTrans(255) As Byte, lPowers6(63) As Long, lPowers12(63) As Long
    Dim lPowers18(63) As Long, lQuad As Long, iPad As Integer, lChar As Long, lPos As Long, sOut As String
    Dim lTemp As Long

    sString = Replace(sString, vbCr, vbNullString)      'Get rid of the vbCrLfs.  These could be in...
    sString = Replace(sString, vbLf, vbNullString)      'either order.

    lTemp = Len(sString) Mod 4                          'Test for valid input.
    If lTemp Then
        Call Err.Raise(vbObjectError, "MyDecode", "Input string is not valid Base64.")
    End If

    If InStrRev(sString, "==") Then                     'InStrRev is faster when you know it's at the end.
        iPad = 2                                        'Note:  These translate to 0, so you can leave them...
    ElseIf InStrRev(sString, "=") Then                  'in the string and just resize the output.
        iPad = 1
    End If

    For lTemp = 0 To 255                                'Fill the translation table.
        Select Case lTemp
            Case 65 To 90
                bTrans(lTemp) = lTemp - 65              'A - Z
            Case 97 To 122
                bTrans(lTemp) = lTemp - 71              'a - z
            Case 48 To 57
                bTrans(lTemp) = lTemp + 4               '1 - 0
            Case 43
                bTrans(lTemp) = 62                      'Chr(43) = "+"
            Case 47
                bTrans(lTemp) = 63                      'Chr(47) = "/"
        End Select
    Next lTemp

    For lTemp = 0 To 63                                 'Fill the 2^6, 2^12, and 2^18 lookup tables.
        lPowers6(lTemp) = lTemp * cl2Exp6
        lPowers12(lTemp) = lTemp * cl2Exp12
        lPowers18(lTemp) = lTemp * cl2Exp18
    Next lTemp

    bIn = StrConv(sString, vbFromUnicode)               'Load the input byte array.
    ReDim bOut((((UBound(bIn) + 1) \ 4) * 3) - 1)       'Prepare the output buffer.

    For lChar = 0 To UBound(bIn) Step 4
        lQuad = lPowers18(bTrans(bIn(lChar))) + lPowers12(bTrans(bIn(lChar + 1))) + _
                lPowers6(bTrans(bIn(lChar + 2))) + bTrans(bIn(lChar + 3))           'Rebuild the bits.
        lTemp = lQuad And clHighMask                    'Mask for the first byte
        bOut(lPos) = lTemp \ cl2Exp16                   'Shift it down
        lTemp = lQuad And clMidMask                     'Mask for the second byte
        bOut(lPos + 1) = lTemp \ cl2Exp8                'Shift it down
        bOut(lPos + 2) = lQuad And clLowMask            'Mask for the third byte
        lPos = lPos + 3
    Next lChar

    sOut = StrConv(bOut, vbUnicode)                     'Convert back to a string.
    If iPad Then sOut = left$(sOut, Len(sOut) - iPad)   'Chop off any extra bytes.
    Decode64 = sOut

End Function



Attribute VB_Name = "JYUT_BondClassification"
Option Explicit

'NOTE AS OF 3/7/2013 - the classification algorithm in this module (the "classifyBond" function) is a re-factored version of the formula-based logic that was in Indranil's BWIC spreadsheet

Public Const TRNCH_TYPE_VADM As String = "VADM"
Public Const TRNCH_TYPE_SUPPORT As String = "SUP"
Public Const TRNCH_TYPE_PAC As String = "PAC"
Public Const TRNCH_TYPE_Z As String = "Z"
Public Const TRNCH_TYPE_PT As String = "PT"
Public Const TRNCH_TYPE_SEQ As String = "SEQ"

Function pacBandsLookValid(pacBands As Variant) As Boolean

    If isNumber(Right(pacBands, 1)) Then
        pacBandsLookValid = True
    Else
        pacBandsLookValid = False
    End If

End Function

Function classifyBond(trancheStructure As String, mtg_start_princ_wndw_mty As Variant, mtg_princ_win_u300 As String, mtg_final_pay_dt As Variant, wamInYears As Variant, speedRange As Range, mtg_pac_collars As Variant, mtg_orig_pac_collars As Variant, mtg_princ_win_d300 As Variant) As String

    Dim retValue As String
    retValue = "ERROR: NOT SET!"

On Error GoTo ehs

    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    Dim mtgPrincWinUp300 As Variant
    Dim mtgPrincWindowDown300 As Variant
    Dim mtgStartPrincWndwMty As Variant
    Dim origPacBands As Variant
    Dim currentPacBands As Variant
    Dim mtgFinalPayDate As Variant
    mtgPrincWinUp300 = mtg_princ_win_u300 'The month and year of the first and last principal payments, calculated using the up 300 basis points prepayment assumption
    mtgPrincWindowDown300 = mtg_princ_win_d300
    mtgStartPrincWndwMty = mtg_start_princ_wndw_mty 'The month, day, and year of the starting Mortgage principal window to call
    origPacBands = mtg_orig_pac_collars
    currentPacBands = mtg_pac_collars
    mtgFinalPayDate = mtg_final_pay_dt 'Projected final payment date

    Dim trancheTypeImpliedByAnalyzingStructureTagsAndPacBands As String
    trancheTypeImpliedByAnalyzingStructureTagsAndPacBands = analyzeStructureTagsAndPacBandsToDetermineTrancheType(trancheStructure, origPacBands, currentPacBands)
    
    Dim speedRngesIndicateThatStructureIsPAC As Boolean
    speedRngesIndicateThatStructureIsPAC = analyzeSpeedRangesToDetermineIfStructureLooksLikePAC(speedRange)
    
    Dim tranchTypeImpliedByAnalyzingPrincipalWindows As String
    tranchTypeImpliedByAnalyzingPrincipalWindows = analyzethePrincipalWindowInUp300AndDown300ScenariosAlongWithWAMFinalPayDateAndPrincWindowMaturityToDetermineTrancheType(mtgPrincWinUp300, mtgPrincWindowDown300, mtgFinalPayDate, mtgStartPrincWndwMty, wamInYears, emsgs)
    
    Dim bondClassification As String
    If trancheTypeImpliedByAnalyzingStructureTagsAndPacBands <> "" Then
        bondClassification = trancheTypeImpliedByAnalyzingStructureTagsAndPacBands
    ElseIf speedRngesIndicateThatStructureIsPAC Then
        bondClassification = TRNCH_TYPE_PAC
    ElseIf tranchTypeImpliedByAnalyzingPrincipalWindows <> "" Then
        bondClassification = tranchTypeImpliedByAnalyzingPrincipalWindows
    Else
        bondClassification = TRNCH_TYPE_PT
    End If
    
    If emsgs.count <> 0 Then
        retValue = emsgs.toString(" | ", "")
    Else
        retValue = bondClassification
    End If
    
GoTo ehe
ehs:
    retValue = "UNEXPECTED ERROR: " & Err.description
ehe:
On Error GoTo 0


    classifyBond = retValue

End Function




Function figureOutIfCurrentPacBandLooksReal(currentPACBandsLookValid As Boolean, currentPacBands As Variant) As Boolean
       
    Dim pacBandsLookReal As Boolean
    If Not currentPACBandsLookValid Then
        pacBandsLookReal = False
    Else
        Dim indx As Long
        indx = InStr(1, currentPacBands, ",")
        
        If indx = 0 Then
            pacBandsLookReal = False
        Else
        
            Dim theStr As String
            theStr = left(currentPacBands, indx - 1)
            
            If Not isNumber(theStr) Then
                pacBandsLookReal = False
            Else
                If CDbl(theStr) > 700 Then
                    pacBandsLookReal = False
                Else
                    pacBandsLookReal = True
                End If
            End If
            
        End If
        
    End If
    figureOutIfCurrentPacBandLooksReal = pacBandsLookReal
End Function

Function figureOutIfCurrentBandIsZero(currentPACBandsLookValid As Boolean, bandsExist As Boolean, currentPacBands As Variant) As Boolean
       
    Dim isBandZero As Boolean
    If (Not currentPACBandsLookValid) Or (Not bandsExist) Then
        isBandZero = False
    Else
        Dim firstChar As String
        firstChar = left(currentPacBands, 1)
        If firstChar = " " Or firstChar = 0 Or firstChar = "0" Then
            isBandZero = True
        Else
            isBandZero = False
        End If
    End If
    
    figureOutIfCurrentBandIsZero = isBandZero
    
End Function

Function structureStringIncludes(trancheStructure As String, stringToCheck As String) As Boolean
    structureStringIncludes = (InStr(1, UCase(trancheStructure), UCase(stringToCheck)) <> 0)
End Function

Function analyzeStructureTagsAndPacBandsToDetermineTrancheType(trancheStructure As String, origPacBands As Variant, currentPacBands As Variant) As String
    
    Dim structureIsSupportOrTAC As Boolean
    structureIsSupportOrTAC = structureStringIncludes(trancheStructure, "SUP") Or structureStringIncludes(trancheStructure, "TAC")
    
    Dim originalPACBandsLookValid As Boolean
    originalPACBandsLookValid = pacBandsLookValid(origPacBands)
    
    Dim currentPACBandsLookValid As Boolean
    currentPACBandsLookValid = pacBandsLookValid(currentPacBands)
    
    Dim pacBandsLookReal As Boolean
    pacBandsLookReal = figureOutIfCurrentPacBandLooksReal(currentPACBandsLookValid, currentPacBands)
    
    Dim bandsExist As Boolean
    bandsExist = originalPACBandsLookValid Or pacBandsLookReal
       
    Dim isBandZero As Boolean
    isBandZero = figureOutIfCurrentBandIsZero(currentPACBandsLookValid, bandsExist, currentPacBands)
    
    Dim pacVadmOrSupportOrNeither As String
    If Not bandsExist Then
        pacVadmOrSupportOrNeither = ""
    ElseIf Not pacBandsLookReal Then
        pacVadmOrSupportOrNeither = ""
    ElseIf isBandZero Then
        pacVadmOrSupportOrNeither = TRNCH_TYPE_VADM
    ElseIf structureIsSupportOrTAC Then
        pacVadmOrSupportOrNeither = TRNCH_TYPE_SUPPORT
    Else
        pacVadmOrSupportOrNeither = TRNCH_TYPE_PAC
    End If
    
    Dim pacOrVadmOrSupportOrZOrNone As String
    If pacVadmOrSupportOrNeither <> "" Then
        pacOrVadmOrSupportOrZOrNone = pacVadmOrSupportOrNeither
    Else
    
        Dim structureIsZ As Boolean
        structureIsZ = structureStringIncludes(trancheStructure, "Z")
        
        If structureIsZ Then
            pacOrVadmOrSupportOrZOrNone = TRNCH_TYPE_Z
        Else
            pacOrVadmOrSupportOrZOrNone = ""
        End If
    End If
    
    analyzeStructureTagsAndPacBandsToDetermineTrancheType = pacVadmOrSupportOrNeither
End Function

Function parsePrincWindowDateToGetMonthAndYearAndAndUseAlternateDateForTheDayOrUseAlternateDateFullyIfUnableToParseThePrincWindowDate(princWindowDateToParse As Variant, dateToUseEitherAsSubstituteOrForTheDay As Variant) As Variant
    
    Dim chosenDate As Variant
    If princWindowDateToParse = "" Then
        chosenDate = dateToUseEitherAsSubstituteOrForTheDay
    ElseIf Not cbcd(princWindowDateToParse) Then
        chosenDate = "????????"
    Else
        chosenDate = createDate(2000 + CDbl(Right(princWindowDateToParse, 2)), CDbl(left(princWindowDateToParse, 2)), day(dateToUseEitherAsSubstituteOrForTheDay))
    End If
    parsePrincWindowDateToGetMonthAndYearAndAndUseAlternateDateForTheDayOrUseAlternateDateFullyIfUnableToParseThePrincWindowDate = chosenDate
End Function

Sub splitPrincipalWindowIntoStartAndEnd(ByRef out_princWindowStart As Variant, ByRef out_princWindowEnd As Variant, princWnidow As Variant)
        
    Dim princWindowStart As String
    Dim princWindowEnd As Variant
    If left(princWnidow, 1) = "#" Then
        princWindowStart = ""
        princWindowEnd = ""
    Else
        princWindowStart = left(princWnidow, 5)
        princWindowEnd = Right(princWnidow, 5)
    End If
    
    out_princWindowStart = princWindowStart
    out_princWindowEnd = princWindowEnd
    
End Sub


Sub determinePrincipalWindowStartAndEndDates(bbgPrincWindowForShiftScenario As Variant, mtgStartPrincWndwMty As Variant, ByRef out_princWindowStartDateForShiftScenario As Variant, ByRef out_princWindowEndDateForShiftScenario As Variant)
        
    Dim bbgPrincWinStartForShiftScenarioIfNotError As String
    Dim bbgPrincWinEndForShiftScenarioIfNotError As Variant
    splitPrincipalWindowIntoStartAndEnd bbgPrincWinStartForShiftScenarioIfNotError, bbgPrincWinEndForShiftScenarioIfNotError, bbgPrincWindowForShiftScenario
    
    Dim princWindowStartDateForShiftScenario As Variant
    princWindowStartDateForShiftScenario = parsePrincWindowDateToGetMonthAndYearAndAndUseAlternateDateForTheDayOrUseAlternateDateFullyIfUnableToParseThePrincWindowDate(bbgPrincWinStartForShiftScenarioIfNotError, mtgStartPrincWndwMty)
    
    Dim princWindowEndDateForShiftScenario As Variant
    princWindowEndDateForShiftScenario = parsePrincWindowDateToGetMonthAndYearAndAndUseAlternateDateForTheDayOrUseAlternateDateFullyIfUnableToParseThePrincWindowDate(bbgPrincWinEndForShiftScenarioIfNotError, mtgStartPrincWndwMty)
    
    out_princWindowStartDateForShiftScenario = princWindowStartDateForShiftScenario
    out_princWindowEndDateForShiftScenario = princWindowEndDateForShiftScenario
    
End Sub

Function figureOutPrincipalWindowLength(princWindowStartDate, princWindowEndDate) As Variant
    
    Dim princWindowLength As Variant
    If cbcd(princWindowEndDate) And cbcd(princWindowStartDate) Then
        princWindowLength = year(princWindowEndDate) - year(princWindowStartDate)
    Else
        princWindowLength = ""
    End If
    
    figureOutPrincipalWindowLength = princWindowLength
    
End Function

Sub figureOutPrincipalWindowStartDateAndLength(ByRef out_princWindowStartDate As Variant, ByRef out_lengthOfPrincipalWindow As Variant, bbgPrincWinForShiftScenario As Variant, mtgStartPrincWndwMty As Variant)
        
    Dim princWindowStartDateForShiftScenario As Variant
    Dim princWindowEndDateForShfitScenario As Variant
    determinePrincipalWindowStartAndEndDates bbgPrincWinForShiftScenario, mtgStartPrincWndwMty, princWindowStartDateForShiftScenario, princWindowEndDateForShfitScenario
    
    Dim lengthOfPrincipalWindow As Variant
    lengthOfPrincipalWindow = figureOutPrincipalWindowLength(princWindowStartDateForShiftScenario, princWindowEndDateForShfitScenario)
    
    out_princWindowStartDate = princWindowStartDateForShiftScenario
    out_lengthOfPrincipalWindow = lengthOfPrincipalWindow
    
End Sub


Function analyzethePrincipalWindowInUp300AndDown300ScenariosAlongWithWAMFinalPayDateAndPrincWindowMaturityToDetermineTrancheType(mtgPrincWinUp300 As Variant, mtgPrincWindowDown300 As Variant, mtgFinalPayDate As Variant, mtgStartPrincWndwMty As Variant, wamInYears As Variant, ByRef mod_emsgs As Variant) As Variant
    
    Dim princWindowStartDateForUp300Scenario As Variant
    Dim lengthOfPrincipalWindowForUp300Scenario As Variant
    figureOutPrincipalWindowStartDateAndLength princWindowStartDateForUp300Scenario, lengthOfPrincipalWindowForUp300Scenario, mtgPrincWinUp300, mtgStartPrincWndwMty
    
    Dim princWindowStartDateForDown300Scenario As Variant
    Dim lengthOfPrincipalWindowForDown300Scenario As Variant
    figureOutPrincipalWindowStartDateAndLength princWindowStartDateForDown300Scenario, lengthOfPrincipalWindowForDown300Scenario, mtgPrincWindowDown300, mtgStartPrincWndwMty
    
    Dim analysis As String
    
    If Not cbcd(princWindowStartDateForUp300Scenario) Then
        mod_emsgs.add "Bad principal window (" & princWindowStartDateForUp300Scenario & ") for the up300 scenario."
        analysis = ""
    ElseIf Not cbcd(mtgStartPrincWndwMty) Then
        mod_emsgs.add "Bad principal window start date: " & mtgStartPrincWndwMty
        analysis = ""
    Else
    
        Dim princWindowStartDateYearForUp300ScenarioIsSameAsStartYearOfPrincWindowMTY As Boolean
        If year(princWindowStartDateForUp300Scenario) = year(mtgStartPrincWndwMty) Then
            princWindowStartDateYearForUp300ScenarioIsSameAsStartYearOfPrincWindowMTY = True
        Else
            princWindowStartDateYearForUp300ScenarioIsSameAsStartYearOfPrincWindowMTY = False
        End If
            
        Dim principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent As Boolean
        If Not cbcd(mtgFinalPayDate) Then
            principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent = False
        ElseIf Not cbcd(mtgStartPrincWndwMty) Then
            principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent = False
        Else
            Dim thePrincWindow As Double
            thePrincWindow = year(mtgFinalPayDate) - year(mtgStartPrincWndwMty)
        
            If Not isNumber(wamInYears) Then
                principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent = False
            Else
                
                If thePrincWindow = 0 Then
                    principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent = False
                Else
                    
                    Dim principalWindowSizeAsPercentageOfWAM As Variant
                    principalWindowSizeAsPercentageOfWAM = divideAndRepresentInfinityAsText(Abs(wamInYears - thePrincWindow), CDbl(thePrincWindow))
                    
                    If Not isNumber(principalWindowSizeAsPercentageOfWAM) Then
                        principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent = False
                    ElseIf CDbl(principalWindowSizeAsPercentageOfWAM) < 0.5 Then
                        principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent = True
                    Else
                        principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent = False
                    End If
                End If
            End If
        End If
                
        Dim upDown As Variant
        If vaialan(upDown, Array(lengthOfPrincipalWindowForUp300Scenario, lengthOfPrincipalWindowForDown300Scenario)) Then
            If lengthOfPrincipalWindowForUp300Scenario = 0 Then
                upDown = 0
            Else
                upDown = divideAndRepresentInfinityAsText(lengthOfPrincipalWindowForUp300Scenario - lengthOfPrincipalWindowForDown300Scenario, CDbl(lengthOfPrincipalWindowForDown300Scenario))
            End If
        End If
        
        Dim looksLikeASupport As Boolean
        If Not isNumber(upDown) Then
            looksLikeASupport = False
        ElseIf upDown = 0 Then
            looksLikeASupport = False
        ElseIf upDown > 6 Then
            looksLikeASupport = True
        Else
            looksLikeASupport = False
        End If
            
        If looksLikeASupport Then
            analysis = ""
        ElseIf principalWindowSizeAsPercentageOfWAMCanBeComputedAndIsLessthan50Percent Then
            If princWindowStartDateYearForUp300ScenarioIsSameAsStartYearOfPrincWindowMTY = False Then
                analysis = TRNCH_TYPE_SEQ
            Else
                analysis = TRNCH_TYPE_PT
            End If
        Else
            If princWindowStartDateYearForUp300ScenarioIsSameAsStartYearOfPrincWindowMTY = False Then
                analysis = TRNCH_TYPE_SUPPORT
            Else
                analysis = TRNCH_TYPE_SEQ
            End If
        End If
    End If
    
    analyzethePrincipalWindowInUp300AndDown300ScenariosAlongWithWAMFinalPayDateAndPrincWindowMaturityToDetermineTrancheType = analysis
End Function

Function analyzeSpeedRangesToDetermineIfStructureLooksLikePAC(speedRange As Range) As Boolean

    Dim speedRnges As Collection
    Set speedRnges = New Collection
    
    Dim c As Long
    For c = 1 To speedRange.count
        speedRnges.add speedRange.item(c)
    Next
    
    Dim isPac As Boolean
    isPac = False
    
    Dim leftind As Boolean
    Dim midind As Boolean
    Dim rightind As Boolean
    leftind = False
    midind = False
    rightind = False
    
    Dim startingValue As Long
    startingValue = 1
    
    Dim i As Long
    i = startingValue
    
    While (i <= speedRnges.count - 1) And (left(speedRnges.item(i), 1) <> "#") And (Not isPac)
        
        Dim curValue As Variant
        curValue = speedRnges.item(i)
        
        Dim nextValue As Variant
        nextValue = speedRnges.item(i + 1)
        
        If (leftind = True And rightind = False And curValue >= nextValue) Then
            rightind = True
        End If
        
        If (leftind = True And midind = False) Then
            If i > startingValue Then
                Dim prevValue As Variant
                prevValue = speedRnges.item(i - 1)
                
                If prevValue <= WorksheetFunction.Min(nextValue + 0.05, nextValue * 1.01) Then
                    midind = True
                Else
                    'DO NOTHING
                End If
            End If
        End If
        
        If (leftind = False And curValue <= WorksheetFunction.Min(nextValue + 0.05, nextValue * 1.01)) Then
            leftind = True
        End If
      
        If (leftind And rightind And midind) Then
            isPac = True
        End If
        
        i = i + 1
    Wend
    
    analyzeSpeedRangesToDetermineIfStructureLooksLikePAC = isPac

End Function

Attribute VB_Name = "JYUT_CONSTANTS"
Option Explicit

Public Const ENV_DEV As String = "DEV"
Public Const ENV_UAT As String = "UAT"
Public Const ENV_TEST As String = "TEST"
Public Const ENV_PROD As String = "PROD"

Public Const MAX_LENGTH_OF_TAB_NAME As Long = 31

Public Const BBG_NA_NA_MSG_FROM_BDP As String = "#N/A N/A"
Public Const BBG_NA_NA_MSG_FROM_SYNCH_CALL As String = "#N/A N.A."

Public Const ERROR_STRING_FOR_HASH_NAME As String = "Error 2029"

Function formatToMakeTabNameComplient(theName As String) As String
    formatToMakeTabNameComplient = left(replaceInString(theName, "/", "_", False), MAX_LENGTH_OF_TAB_NAME)
End Function

Attribute VB_Name = "JYUT_CaseInsensitiveDictionary"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'As of 2012-Oct-04, This class has been renamed to "JYUT_AdvancedDictionary".
Attribute VB_Name = "JYUT_CastingAndTypeChecking"
'This module has been moved to the JYCORE library.
Attribute VB_Name = "JYUT_ChainableDataCBObj"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public data As Variant
Public cbObj As Variant

Implements JYUT_ExecutableInterface

Sub JYUT_ExecutableInterface_execute(theData As Variant)
    atr data, theData
    If Not isNothing(cbObj) Then
        cbObj.execute data
    End If
End Sub

Sub execute(theData As Variant)
    Me.JYUT_ExecutableInterface_execute theData
End Sub

Private Sub Class_Initialize()
    Set data = Nothing
End Sub
Attribute VB_Name = "JYUT_ChartSpec"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public chartName As String
Public chartTitle As String
Public optXAxisTitle As String
Public optXAxisNumberFormat As String
Public yAxisTitle As String
Public secondaryYAxisTitle As String
Public chartType As Variant
Public topLeftCellForGraph As Range
Public bottomRightCellForGraph As Range
Public xValuesDef As Variant
Public listOf__seriesName_yValuesDef_secondaryVsPrimaryAxis_overrideChartTypeOrNothingToNotOverride As Collection
Public yAxisNumberFormat As Variant
Public optYAxisMinScale As Variant
Public optYAxisMaxScale As Variant
Attribute VB_Name = "JYUT_Charts"
Option Explicit

Function getChartObject(objName As String, ws As Worksheet, ByRef out_emsg As String) As ChartObject
    Dim returnVal As Variant
    Set returnVal = Nothing
    
    Dim emsg As String
    emsg = "ERROR: NOT SET!"

On Error GoTo ehs
    Set returnVal = ws.ChartObjects(objName)
    emsg = ""
GoTo ehe
ehs:
    emsg = Err.description
    
    If emsg = "The item with the specified name wasn't found." Then
        emsg = ""
    End If
ehe:
On Error GoTo 0

    out_emsg = emsg
    atr getChartObject, returnVal

End Function

Function navigateUpParentChainUntilWeGetToWorksheetObject(chartObj As Variant) As Worksheet

    Dim curObj As Variant
    Set curObj = chartObj
    
On Error GoTo ehs
    
    While (Not isNothing(curObj)) And (Not isWorksheet(curObj))
        Set curObj = curObj.Parent
    Wend
    
GoTo ehe:
ehs:
    'The object probably does not have a 'parent property'.
    
    Dim emsg As String
    emsg = Err.description
    
    Set curObj = Nothing
    
    If emsg = "Object doesn't support this property or method" Then
        'DO NOTHING
    Else
        elwp emsg
    End If
    
    
ehe:
On Error GoTo 0

    Set navigateUpParentChainUntilWeGetToWorksheetObject = curObj

End Function

Function getChartTitle(chartObj As Chart) As chartTitle

    Dim rv As Variant
    Set rv = Nothing
    
On Error GoTo ehs

    Set rv = chartObj.chartTitle

GoTo ehe
ehs:
    Dim emsg As String
    emsg = Err.description
    If emsg = "This object has no title." Then
        'DO NOTHING
    Else
        elwp emsg
    End If
    
    
ehe:
On Error GoTo 0

    atr getChartTitle, rv

End Function

Sub addSeriesToChart(seriesName As String, chartObj As Chart, xValuesDefRN As String, valuesDef As String, includeDataLabels As Boolean, secondaryVsPrimaryAxis As Boolean, overrideChartType As Variant)
    
    
    Dim ws As Worksheet
    Set ws = navigateUpParentChainUntilWeGetToWorksheetObject(chartObj)
    

On Error GoTo ehs
   
    'chartObj.Activate
    
    Dim origTitle As chartTitle
    atr origTitle, getChartTitle(chartObj)
    
    Dim origText As Variant
    If isNothing(origTitle) Then
        Set origText = Nothing
    Else
        origText = origTitle.text
    End If
    
    Dim theSeries As Series
    Set theSeries = chartObj.SeriesCollection.NewSeries()
    theSeries.name = seriesName
    
    Dim adjustedXDef As String
    Dim adjustedYDef As String
    adjustedXDef = adjustSeriesDef(xValuesDefRN, ws)
    adjustedYDef = adjustSeriesDef(valuesDef, ws)

    
    
    theSeries.xValues = adjustedXDef
    theSeries.values = adjustedYDef
    
    If secondaryVsPrimaryAxis Then
        theSeries.axisGroup = 2
    Else
        theSeries.axisGroup = 1
    End If
    
    If isNothing(overrideChartType) Then
        'DO NOTHING
    Else
        theSeries.chartType = overrideChartType
    End If
    
    
    'Readjust title in case it was chanegd
    Dim newTitle As chartTitle
    Set newTitle = getChartTitle(chartObj)
    If isNothing(newTitle) Then
        If isNothing(origText) Then
            'DO NOTHING
        Else
            elwp "Our title got deleted and we don't know how to restore it!"
        End If
    Else
        Dim newTitleText As String
        newTitleText = newTitle.text
        
        If isNothing(origText) Then
            newTitle.Delete
        ElseIf newTitleText <> origText Then
            newTitle.text = origText
        End If
    End If
    
    If includeDataLabels Then
        theSeries.ApplyDataLabels
    End If
    
GoTo ehe
ehs:
    elwp Err.description
ehe:
On Error GoTo 0
    


End Sub

Function createChart(title As String, optXAxisTitle As String, optXAxisNumberFormat As String, ws As Worksheet, objName As String, chartType As Variant, topLeftCellAtWhichToPlaceIt As Range, bottomRightCellForGraph As Range, showLegend As Boolean) As Shape
'xlColumnClustered
    Dim height As Long
    Dim width As Long
    height = bottomRightCellForGraph.top + bottomRightCellForGraph.height - topLeftCellAtWhichToPlaceIt.top
    width = bottomRightCellForGraph.left + bottomRightCellForGraph.width - topLeftCellAtWhichToPlaceIt.left

On Error GoTo ehs
    
    Dim chrt As Shape
    Set chrt = ws.Shapes.AddChart(chartType)
    
    chrt.name = objName
    chrt.left = topLeftCellAtWhichToPlaceIt.left
    chrt.top = topLeftCellAtWhichToPlaceIt.top
    chrt.height = height
    chrt.width = width
    
    Dim cObj As Chart
    Set cObj = chrt.Chart
    
    If Trim(title) = "" Then
        'DO NOTHING
    Else
        'cobj.SetElement (msoElementChartTitleCenteredOverlay)
        chrt.Select
        cObj.Axes(xlValue).Select
        cObj.SetElement (msoElementChartTitleCenteredOverlay)
        cObj.SetElement (msoElementChartTitleAboveChart)
        cObj.chartTitle.text = title
    End If

    If Trim(optXAxisTitle) <> "" Then
        setCategoryAxisTitle cObj, optXAxisTitle
    Else
        'DO NOTHING
        'removeCategoryAxisTitle cObj
    End If
    If Trim(optXAxisNumberFormat) <> "" Then
        setCategoryAxisNumberFormat cObj, optXAxisNumberFormat
    End If
    
    Dim seriesColl As SeriesCollection
    Set seriesColl = cObj.SeriesCollection
    
    While seriesColl.count <> 0
        seriesColl.item(1).Delete
    Wend

    If showLegend Then
        cObj.Legend.Position = xlBottom
        'cObj.Legend.Position = xlRight
    Else
        cObj.Legend.Delete
    End If
    
    
    
    'If gfrd(getBottomRightCellForChartThatICreatedThroughMyVBALibraries(chrt), True, True, True, False) = gfrd(bottomRightCellForGraph, True, True, True, False) Then
    '    'DO NOTHING
    'Else
    '    elwp "The created chart was not an exact fit!"
    'End If
    'ActiveChart.chartType = xlColumnClustered
GoTo ehe
ehs:
    elwp Err.description
ehe:
On Error GoTo 0
    
    Set createChart = chrt
End Function

'Function getBottomRightCellForChartThatICreatedThroughMyVBALibraries(chrt As Shape) As Range
'    Set getBottomRightCellForChartThatICreatedThroughMyVBALibraries = chrt.BottomRightCell.Offset(-1, -1)
'End Function



Sub deleteShapeIfExists(objName As String, ws As Worksheet)
    
On Error GoTo ehs
    
    Dim cObj As ChartObject
    Dim emsg As String
    Set cObj = getChartObject(objName, ws, emsg)
    
    If emsg <> "" Then
        elwp emsg
    ElseIf Not isNothing(cObj) Then
        cObj.Delete
    End If
GoTo ehe
ehs:
    elwp Err.description
ehe:
On Error GoTo 0

End Sub

Function adjustSeriesDef(seriesDefRN As String, ws As Worksheet)
    If InStr(1, seriesDefRN, "!") = 0 Then
        adjustSeriesDef = appendWSName(ws.name, seriesDefRN)
    Else
        adjustSeriesDef = seriesDefRN
    End If
End Function
Sub setYAxisMaxScale(maxScale As Double)
    ActiveChart.Axes(xlValue).MaximumScale = maxScale
End Sub

Sub setYAxisMinScale(minScale As Double)
    ActiveChart.Axes(xlValue).MinimumScale = minScale
End Sub

Sub removeCategoryAxisTitle(cObj As Chart)
On Error GoTo ehs

    cObj.Axes(xlCategory).Select
    'cObj.SetElement (msoElementPrimaryCategoryAxisTitleAdjacentToAxis)
    cObj.Axes(xlCategory).Delete

GoTo ehe
ehs:
    elwp "Could not set the category axis title.  Msg=" & Err.description
ehe:
On Error GoTo 0

End Sub

Sub setCategoryAxisTitle(cObj As Chart, xAxisTitle As String)
On Error GoTo ehs
    cObj.Axes(xlCategory).Select
    cObj.SetElement (msoElementPrimaryCategoryAxisTitleAdjacentToAxis)
    cObj.Axes(xlCategory, xlPrimary).AxisTitle.text = xAxisTitle
GoTo ehe
ehs:
    elwp "Could not set the category axis title.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Sub setCategoryAxisNumberFormat(cObj As Chart, numberFormat As String)
On Error GoTo ehs
    cObj.Axes(xlCategory).Select
    'cObj.SetElement (msoElementPrimaryCategoryAxisTitleAdjacentToAxis)
    cObj.Axes(xlCategory, xlPrimary).TickLabels.numberFormat = numberFormat
GoTo ehe
ehs:
    elwp "Could not set the category axis number format.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Sub setSecondaryYAxisTitle(cObj As Chart, yAxisTitle As String)
    setYAxisTitle cObj, yAxisTitle, xlSecondary, msoElementSecondaryValueAxisTitleRotated
    
End Sub

Sub setPrimaryYAxisTitle(cObj As Chart, yAxisTitle As String)
    setYAxisTitle cObj, yAxisTitle, xlPrimary, msoElementPrimaryValueAxisTitleRotated
End Sub

Sub setYAxisTitle(cObj As Chart, yAxisTitle As String, axisGroup As Variant, theElement As Variant)
On Error GoTo ehs
    'cObj.Axes(xlValue).Select
    
    'cobj.SetElement (msoElementPrimaryValueAxisTitleVertical)
    'cobj.SetElement (msoElementPrimaryValueAxisTitleRotated)
    'cobj.SetElement (msoElementPrimaryValueAxisTitleHorizontal)
    cObj.SetElement (theElement)
    cObj.Axes(xlValue, axisGroup).AxisTitle.text = yAxisTitle

GoTo ehe
ehs:
    elwp "Could not set the y-axis title.  Msg=" & Err.description
ehe:

End Sub

Function convertChartToPicture(chrt As Chart) As Boolean

    Dim success As Boolean
    success = False

On Error GoTo ehs

    Dim chrtObj As ChartObject
    Set chrtObj = chrt.Parent
    
    Dim left As Long
    Dim top As Long
    left = chrtObj.left
    top = chrtObj.top
    
    Dim tlCell As Range
    Set tlCell = chrtObj.topLeftCell
    
    Dim ws As Worksheet
    Set ws = navigateUpParentChainUntilWeGetToWorksheetObject(chrtObj)
    
    chrtObj.Activate
    
    chrtObj.CopyPicture
    
    'Dim prnt As Variant
    'Set prnt = chrtObj.Parent
    
    ws.Paste tlCell
    
    'chrt.Delete
    chrtObj.Delete

    success = True
GoTo ehe:
ehs:

    elg "Could not convert chart to picture.  Msg=" & Err.description

ehe:
On Error GoTo 0

    convertChartToPicture = success

End Function

Sub attemptToConvertChartsToPictures_mightNeedToPopUpSomeMessagesAlongTheWayToFacilitateChartConversions(listOfCharts As Collection, ByRef mod_emsgs As Variant)
    
    Dim xx As Long
    For xx = 1 To listOfCharts.count
        Dim curChart As Chart
        Set curChart = listOfCharts.item(xx)
        
        Dim chartName As String
        chartName = curChart.name
        
        Dim numTimesToTry As Long
        numTimesToTry = 5
        
        Dim attemptNum As Long
        attemptNum = 1
        
        Dim success As Boolean
        success = False
        
        While (attemptNum <= numTimesToTry) And (Not success)
            
            If attemptNum = 1 Then
                'DO NOTHING
            Else
                'Somehow, the act of showing this popup message will help us make it work the next time.
                elwp "Could not convert chart to picture.  Let's try again... (attempt #" & attemptNum & ")"
            End If
            
            'We try this multiple times because sometimes it fails for some reason.
            success = convertChartToPicture(curChart)
            
            attemptNum = attemptNum + 1
        Wend
    
        If Not success Then
            mod_emsgs.add "Could not convert chart '" & chartName & "' to a picture for some reason."
        End If
    
    Next
End Sub
Attribute VB_Name = "JYUT_Collection"
Option Explicit

Public Const NUM_REPRESENTING_NOT_FOUND_DURING_LINEAR_COLLECTION_SEARCH As Long = 0
Public Const VALUE_REPRESENTING_INCONSISTENT_SIZES As Long = -1

Public Const COL_DATA_TYPE_COLLECTION As String = "Collection"
Public Const COL_DATA_TYPE_ONE_DIM_ARRAY As String = "OneDimensionalArray"
Public Const COL_DATA_TYPE_COLLECTION_OR_ONE_DIM_ARRAY As String = "CollectionOrOneDimensionalArray"
Public Const COL_DATA_TYPE_TWO_DIM_ARRAY_BUT_SINGLE_ROW As String = "TwoDimensionalArrayButSingleRow"
Public Const COL_DATA_TYPE_TWO_DIM_ARRAY_BUT_SINGLE_COL As String = "TwoDimensionalArrayButSingleCol"

Function multiplyOrDivideOrAddEachElementInCollectionByCorrespondingElementInAnotherCollection(collOne As Collection, collTwo As Collection, ByRef mod_emsgs As Variant, logErrorsWhenNonNumericsAreEncountered As Boolean, multiplyVsDivide_orNothingIfShouldAdd As Variant) As Collection
    Dim sz As Long
    sz = ccsz(Array(collOne, collTwo), False)
    
    Dim result As Collection
    If sz = -1 Then
        Set result = Nothing
        mod_emsgs.add "Please pass in two collections of the same size!"
    Else
    
        Set result = New Collection
    
        Dim c As Long
        For c = 1 To sz
            Dim valOne As Variant
            Dim valTwo As Variant
            valOne = collOne.item(c)
            valTwo = collTwo.item(c)
            
            Dim finalVal As Variant
            If Not isNumber(valOne) Then
                mod_emsgs.add "Non-numeric value encountered in the first collection"
                finalVal = "?"
            ElseIf Not isNumber(valTwo) Then
                mod_emsgs.add "Non-numeric value encountered in the second collection"
                finalVal = "??"
            Else
                If isNothing(multiplyVsDivide_orNothingIfShouldAdd) Then
                    finalVal = valOne + valTwo
                ElseIf multiplyVsDivide_orNothingIfShouldAdd Then
                    finalVal = valOne * valTwo
                Else
                    finalVal = valOne / valTwo
                End If
            End If
            
            result.add finalVal
        Next
                
    End If
    
    Set multiplyOrDivideOrAddEachElementInCollectionByCorrespondingElementInAnotherCollection = result

End Function

Function addEachElementInCollectionByCorrespondingElementInAnotherCollection(collOne As Collection, collTwo As Collection, ByRef mod_emsgs As Variant, logErrorsWhenNonNumericsAreEncountered As Boolean) As Collection
    Set addEachElementInCollectionByCorrespondingElementInAnotherCollection = multiplyOrDivideOrAddEachElementInCollectionByCorrespondingElementInAnotherCollection(collOne, collTwo, mod_emsgs, logErrorsWhenNonNumericsAreEncountered, Nothing)
End Function

Function divideEachElementInCollectionByCorrespondingElementInAnotherCollection(collOne As Collection, collTwo As Collection, ByRef mod_emsgs As Variant, logErrorsWhenNonNumericsAreEncountered As Boolean) As Collection
    Set divideEachElementInCollectionByCorrespondingElementInAnotherCollection = multiplyOrDivideOrAddEachElementInCollectionByCorrespondingElementInAnotherCollection(collOne, collTwo, mod_emsgs, logErrorsWhenNonNumericsAreEncountered, False)
End Function

Function multiplyEachElementInCollectionByCorrespondingElementInAnotherCollection(collOne As Collection, collTwo As Collection, ByRef mod_emsgs As Variant, logErrorsWhenNonNumericsAreEncountered As Boolean) As Collection
    Set multiplyEachElementInCollectionByCorrespondingElementInAnotherCollection = multiplyOrDivideOrAddEachElementInCollectionByCorrespondingElementInAnotherCollection(collOne, collTwo, mod_emsgs, logErrorsWhenNonNumericsAreEncountered, True)
End Function

Function substituteWholeStringsInCollection(coll As Collection, stringToReplace As String, substituteString As String) As Collection

    Dim coll2 As Collection
    Set coll2 = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim element As Variant
        atr element, coll.item(c)
        
        If isString(element) Then
            element = CStr(element)
            If element = stringToReplace Then
                element = substituteString
            End If
        End If
        
        coll2.add element
    Next

    Set substituteWholeStringsInCollection = coll2

End Function

Function maxSizeOfCollections(collectionOrArrayOfCollectionsOrCollectionOfCollections As Variant) As Long
    
    Dim arrOfCollections As Variant
    arrOfCollections = ensureValueIsAnArray(collectionOrArrayOfCollectionsOrCollectionOfCollections)
    
    Dim maxSizeSoFar As Long
    maxSizeSoFar = 0
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrOfCollections, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim curColl As Collection
        Set curColl = arrOfCollections(c)
        
        Dim curSize As Long
        curSize = curColl.count
        
        maxSizeSoFar = wsFunctionMax(maxSizeSoFar, curSize)
    Next
    
    maxSizeOfCollections = maxSizeSoFar
End Function

Sub padBlankCollectionsToCommonSizeOfNonBlankCollections(mod_collections As Collection, padValue As Variant, ByRef out_commonSizePaddedTo As Long, ByRef out_numCollectionsPadded As Long)

    Dim blankCollections As Collection
    Set blankCollections = New Collection
    
    Dim nonBlankCollections As Collection
    Set nonBlankCollections = New Collection
    
    Dim c As Long
    For c = 1 To mod_collections.count
        Dim coll As Collection
        Set coll = mod_collections.item(c)
        
        If coll.count = 0 Then
            blankCollections.add coll
        Else
            nonBlankCollections.add coll
        End If
    Next
    
    Dim sz As Long
    If nonBlankCollections.count = 0 Then
        sz = 0
    Else
        sz = ccsz(collectionToArray(nonBlankCollections), True)
    End If
    
    
    If blankCollections.count = 0 Then
        'DO NOTHING
    Else
        padCollectionsToSize collectionToArray(blankCollections), sz, padValue
    End If
    
    Dim numCollectionsPadded As Long
    numCollectionsPadded = blankCollections.count
    
    out_commonSizePaddedTo = sz
    out_numCollectionsPadded = numCollectionsPadded
    
End Sub
Function doPadCollectionsToMakeThemAllSameSize(mod_arrayOrCollectionOfCollections As Variant, padValue As Variant, padToBottomVsTop As Boolean) As Long

    Dim arrs As Variant
    arrs = ensureValueIsAnArray(mod_arrayOrCollectionOfCollections)

    Dim maxSize As Long
    maxSize = maxSizeOfCollections(arrs)

    Dim lwr As Long
    Dim upr As Long
    glaubs arrs, lwr, upr

    Dim c As Long
    For c = lwr To upr
        Dim curColl As Collection
        Set curColl = arrs(c)
    
        doPadCollectionToSize curColl, maxSize, padValue, padToBottomVsTop
        
        'Set arrs(c) = curColl
    Next
    
    

    doPadCollectionsToMakeThemAllSameSize = maxSize
End Function

Function padCollectionsToMakeThemAllSameSize(mod_arrayOrCollectionOfCollections As Variant, padValue As Variant) As Long
    
    padCollectionsToMakeThemAllSameSize = doPadCollectionsToMakeThemAllSameSize(mod_arrayOrCollectionOfCollections, padValue, True)
    
End Function

Sub padCollectionsToSize(ByRef mod_collections As Variant, desiredSize As Long, padValue As Variant)

    Dim lwr As Long
    Dim upr As Long
    glaubs mod_collections, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim coll As Collection
        Set coll = mod_collections(c)
        
        padCollectionToSize coll, desiredSize, padValue
    Next

End Sub

Function doPadCollectionToSize(ByRef mod_collection As Collection, desiredSize As Long, padValue As Variant, padToBottomVsTop As Boolean) As Collection
    Dim origSize As Long
    origSize = mod_collection.count
    
    Dim origCopy_orNothingIfShouldPadToBottom As Collection
    If padToBottomVsTop Then
       Set origCopy_orNothingIfShouldPadToBottom = Nothing
    Else
        Set origCopy_orNothingIfShouldPadToBottom = copyCollection(mod_collection)
        clearCollection mod_collection
    End If
    Dim c As Long
    For c = origSize + 1 To desiredSize
        mod_collection.add padValue
    Next
    
    If isNothing(origCopy_orNothingIfShouldPadToBottom) Then
        'DO NOTHING
    Else
        addCollectionToCollection mod_collection, origCopy_orNothingIfShouldPadToBottom
    End If
    
    Set doPadCollectionToSize = mod_collection

End Function
Function padCollectionToSize(ByRef mod_collection As Collection, desiredSize As Long, padValue As Variant) As Collection
    Set padCollectionToSize = doPadCollectionToSize(mod_collection, desiredSize, padValue, True)
End Function

Function addToCollection(ByRef mod_collToAddTo As Collection, theVal As Variant) As Collection
    mod_collToAddTo.add theVal
    Set addToCollection = mod_collToAddTo
End Function

Function addCollectionToCollection(ByRef mod_collToAddTo As Variant, collectionToAdd As Collection) As Collection
    Set addCollectionToCollection = addCollectionContentsToObject(mod_collToAddTo, collectionToAdd)
End Function

Function intersperseCollectionElements(collectinoOrArrayOfCollectionsOrCollectionOfCollections As Variant)

    Dim newColl As Collection
    Set newColl = New Collection

    Dim arr As Variant
    arr = ensureValueIsAnArray(collectinoOrArrayOfCollectionsOrCollectionOfCollections)
    
    Dim maxSize As Long
    maxSize = maxSizeOfCollections(arr)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim s As Long
    For s = 1 To maxSize
    
        Dim c As Long
        For c = lwr To upr
            Dim curColl As Collection
            Set curColl = arr(c)
            
            If s > curColl.count Then
                'DO NOTHING
            Else
                newColl.add curColl.item(s)
            End If
        Next
    Next
    
    Set intersperseCollectionElements = newColl

End Function

Function collectionTo2DArrayColumn_showStatusBarMessages(data As Collection) As Variant
    collectionTo2DArrayColumn_showStatusBarMessages = doCollectionTo2DArrayColumn(data, True)
End Function

Function collectionTo2DArrayColumn(data As Collection) As Variant
    collectionTo2DArrayColumn = doCollectionTo2DArrayColumn(data, False)
End Function

Function doCollectionTo2DArrayColumn(data As Collection, showStatusBarMessages As Boolean) As Variant

    Dim numRows As Long
    numRows = data.count
    
    Dim arr As Variant
    ReDim arr(1 To numRows, 1 To 1)
    
    Dim c As Long
    For c = 1 To data.count
        If showStatusBarMessages Then
            ssbm "Adding row #" & c & " of " & data.count & " to a new array."
        End If
        atr arr(c, 1), data.item(c)
    Next
    If showStatusBarMessages Then
        ssbm "Done converting our collection to an array!"
    End If
    doCollectionTo2DArrayColumn = arr

End Function

Function collectionTo2DArrayRow(data As Collection) As Variant

    Dim numCols As Long
    numCols = data.count
    
    Dim arr As Variant
    ReDim arr(1 To 1, 1 To numCols)
    
    Dim c As Long
    For c = 1 To data.count
        arr(1, c) = data.item(c)
    Next
    
    collectionTo2DArrayRow = arr

End Function

Function collectionToArrayOrNothing(coll As Collection) As Variant
    Dim arrForSumOf_fieldName_and_valueOrCellContainingTheValue As Variant
    If coll.count = 0 Then
        Set collectionToArrayOrNothing = Nothing
    Else
        collectionToArrayOrNothing = kta(coll)
    End If
End Function

Function collectionToArray_customLowerBound(data As Collection, desiredLowerBound As Long) As Variant
    Dim numRows As Long
    numRows = data.count
    
    If numRows = 0 Then
        collectionToArray_customLowerBound = createEmptyArray()
    Else
        
        Dim arr As Variant
        ReDim arr(desiredLowerBound To desiredLowerBound + numRows - 1)
        
        Dim c As Long
        For c = 1 To data.count
            atr arr(desiredLowerBound + c - 1), data.item(c)
        Next
    End If
    collectionToArray_customLowerBound = arr
End Function

Function collectionsToArrays(listOfCollections As Variant, desiredLowerBound As Long) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs listOfCollections, lwr, upr
    
    Dim newList As Variant
    ReDim newList(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim curColl As Collection
        Set curColl = listOfCollections(c)
        
        newList(c) = collectionToArray_customLowerBound(curColl, desiredLowerBound)
    Next
    
    collectionsToArrays = newList
    
End Function

Function collectionToArray(data As Collection) As Variant
    collectionToArray = collectionToArray_customLowerBound(data, 1)
End Function

Function copyCollectionIfSomething(coll As Collection) As Collection
    If isNothing(copyCollectionIfSomething) Then
        Set copyCollectionIfSomething = Nothing
    Else
        Set copyCollectionIfSomething = copyCollection(coll)
    End If
End Function

Function copyCollection(coll As Collection) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        newColl.add coll.item(c)
    Next
    
    Set copyCollection = newColl
End Function

'"ccsz" stands for "commonCollectionSize"
Function ccsz(arrayOfCollections As Variant, popupErrorIfInconsistent As Boolean) As Long
    ccsz = commonVectorSize(arrayOfCollections, popupErrorIfInconsistent, COL_DATA_TYPE_COLLECTION)
End Function

'"casz" stands for "commonArraySize"
Function casz(arrayOfSingleDimensionArrays As Variant, popupErrorIfInconsistent As Boolean) As Long
    casz = commonVectorSize(arrayOfSingleDimensionArrays, popupErrorIfInconsistent, COL_DATA_TYPE_ONE_DIM_ARRAY)
End Function

Function commonArraySizeOfValuesInDictionary(dict As Dictionary) As Long
    commonArraySizeOfValuesInDictionary = casz(kta(getDictionaryValues(dict)), True)
End Function

Function padZeroLengthCollectionsToSameCommonSizeAsOtherCollections(arrayOfCollections As Variant, popupErrorIfInconsistent As Boolean, padValue As Variant) As Long

    Dim zeroLengthCollections As Collection
    Dim nonZeroLengthCollections As Collection
    Dim commonSize As Long
    commonSize = doPadZeroLengthCollectionsToSameCommonSizeAsOtherCollections(arrayOfCollections, popupErrorIfInconsistent, padValue, zeroLengthCollections, nonZeroLengthCollections)
    
    padZeroLengthCollectionsToSameCommonSizeAsOtherCollections = commonSize

End Function

Function doPadZeroLengthCollectionsToSameCommonSizeAsOtherCollections(arrayOfCollections As Variant, popupErrorIfInconsistent As Boolean, padValue As Variant, ByRef out_zeroLengthCollections As Collection, ByRef out_nonZeroLengthCollections As Collection) As Long

    Dim zeroLengthCollections As Collection
    Dim nonZeroLengthCollections As Collection
    Set zeroLengthCollections = New Collection
    Set nonZeroLengthCollections = New Collection
    
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrayOfCollections, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim curColl As Collection
        Set curColl = arrayOfCollections(c)
        
        If curColl.count = 0 Then
            zeroLengthCollections.add curColl
        Else
            nonZeroLengthCollections.add curColl
        End If
    Next
    
    Dim sz As Long
    sz = ccsz(kta(nonZeroLengthCollections), popupErrorIfInconsistent)
    
    If sz = VALUE_REPRESENTING_INCONSISTENT_SIZES Then
        'DO NOTHING
    Else
        Dim d As Long
        For d = 1 To zeroLengthCollections.count
            Dim zeroLengthCollection As Collection
            Set zeroLengthCollection = zeroLengthCollections.item(d)
            
            repeatedlyAddValueToCollection zeroLengthCollection, padValue, sz
        Next
        
    End If

    If sz <> ccsz(arrayOfCollections, False) Then
        elwp_se
    End If
    

    Set out_zeroLengthCollections = zeroLengthCollections
    Set out_nonZeroLengthCollections = nonZeroLengthCollections
    doPadZeroLengthCollectionsToSameCommonSizeAsOtherCollections = sz
    
End Function

'JY20140416e - start
'Function commonCollectionOrArraySize(arrayOfCollectionsOrArrayOfArrays As Variant, popupErrorIfInconsistent As Boolean, collectionDataType As String) As Long
Function commonVectorSize(arrayOfCollectionsOrArrayOfArrays As Variant, popupErrorIfInconsistent As Boolean, collectionDataType As String) As Long
'JY20140416e - end
    
    Dim numElements As Long
    numElements = dimSize(arrayOfCollectionsOrArrayOfArrays, 1)
    
    Dim sizeSoFar As Variant
    Set sizeSoFar = Nothing
    
    Dim c As Long
    For c = 1 To numElements
    
        Dim curItem As Variant
        atr curItem, rlai(arrayOfCollectionsOrArrayOfArrays, c)
        
        If isNothing(curItem) Then
            elwp "You passed in NOTHING!"
        Else
        
            
            Dim sizeOfCollOrArray As Long
            If collectionDataType = COL_DATA_TYPE_COLLECTION_OR_ONE_DIM_ARRAY Then
                If isCollection(curItem) Then
                    Dim curCollection As Collection
                    Set curCollection = curItem
                    
                    sizeOfCollOrArray = curCollection.count
                Else
                    Dim curArray As Variant
                    curArray = curItem
                    
                    sizeOfCollOrArray = dimSize(curArray, 1)
                End If
            ElseIf collectionDataType = COL_DATA_TYPE_COLLECTION Then
                Dim crColl As Collection
                Set crColl = curItem
                
                sizeOfCollOrArray = crColl.count
            ElseIf collectionDataType = COL_DATA_TYPE_ONE_DIM_ARRAY Or collectionDataType = COL_DATA_TYPE_TWO_DIM_ARRAY_BUT_SINGLE_COL Then
                Dim curArry As Variant
                curArry = curItem
                
                sizeOfCollOrArray = dimSize(curArry, 1)
            ElseIf collectionDataType = COL_DATA_TYPE_TWO_DIM_ARRAY_BUT_SINGLE_ROW Then
                Dim crArry As Variant
                crArry = curItem
                
                sizeOfCollOrArray = dimSize(crArry, 2)
            Else
                elwp "Unknown data type: " & collectionDataType
                sizeOfCollOrArray = VALUE_REPRESENTING_INCONSISTENT_SIZES
            End If
            
            
            
            If isNothing(sizeSoFar) Then
                sizeSoFar = sizeOfCollOrArray
            ElseIf sizeSoFar = VALUE_REPRESENTING_INCONSISTENT_SIZES Then
                'DO NOTHING
                
                'Sizes are already inconsistent.
            ElseIf sizeSoFar <> sizeOfCollOrArray Then
                sizeSoFar = VALUE_REPRESENTING_INCONSISTENT_SIZES
            Else
                'DO NOTHING
                
                'Size is consistent.
            End If
        End If
    Next
    
    Dim chosenSize As Long
    If isNothing(sizeSoFar) Then
        elwp "You must not have passed in any vectors!"
        chosenSize = VALUE_REPRESENTING_INCONSISTENT_SIZES
    Else
        chosenSize = sizeSoFar
    End If
    
    If popupErrorIfInconsistent Then
        If chosenSize = VALUE_REPRESENTING_INCONSISTENT_SIZES Then
            elwp "The vectors you passed in are unexpectedly different sizes!"
        End If
    End If
    
    commonVectorSize = chosenSize
End Function


Function maxOfCollection(coll As Collection, ByRef mod_emsgs__orNothingToIgnoreNonNumericValues As Variant) As Variant
    If coll.count = 0 Then
        Set maxOfCollection = Nothing
    Else
        atr maxOfCollection, maxOfArray(collectionToArray(coll), mod_emsgs__orNothingToIgnoreNonNumericValues)
    End If
End Function

Function minOfCollection(coll As Collection, ByRef mod_emsgs__orNothingToIgnoreNonNumericValues As Variant) As Variant
    atr minOfCollection, getMinOfCollection(coll, mod_emsgs__orNothingToIgnoreNonNumericValues)
End Function

Function getMinOfCollection(coll As Collection, ByRef mod_emsgs__orNothingToIgnoreNonNumericValues As Variant) As Variant
    If coll.count = 0 Then
        Set getMinOfCollection = Nothing
    Else
        atr getMinOfCollection, minOfArray(collectionToArray(coll), mod_emsgs__orNothingToIgnoreNonNumericValues)
    End If
End Function

Function replaceAllInstancesInCollection(coll As Collection, itemToFind As Variant, replacementItem As Variant) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim item As Variant
        item = coll.item(c)
        
        If item = itemToFind Then
            item = replacementItem
        End If
        
        newColl.add item
    Next
    
    Set replaceAllInstancesInCollection = newColl
End Function

Function anyInCollectionAreBlank(coll As Collection) As Boolean
    
    Dim found As Boolean
    found = False
    
    Dim c As Long
    c = 1
    
    While (Not found) And (c <= coll.count)
    
        If isBlankValue(coll.item(c)) Then
            found = True
        End If
    
        c = c + 1
    Wend
    
    anyInCollectionAreBlank = found
    
End Function

Function anyInCollectionAreNotBlank(coll As Collection) As Boolean
    
    Dim found As Boolean
    found = False
    
    Dim c As Long
    c = 1
    
    While (Not found) And (c <= coll.count)
    
        If Not isBlankValue(coll.item(c)) Then
            found = True
        End If
    
        c = c + 1
    Wend
    
    anyInCollectionAreNotBlank = found
    
End Function

Function allInCollectionAreIntegers(coll As Collection) As Boolean
    Dim allAreIntegersSoFar As Boolean
    allAreIntegersSoFar = True
    
    Dim c As Long
    c = 1
    
    Dim expectedObject As Variant
    Set expectedObject = Nothing
    
    While allAreIntegersSoFar And c <= coll.count
    
        Dim item As Variant
        atr item, coll.item(c)
        
        If Not isInteger(item) Then
            allAreIntegersSoFar = False
        End If
        
        c = c + 1
    Wend
    
    allInCollectionAreIntegers = allAreIntegersSoFar
End Function

Function allInCollectionAreNumbers(coll As Collection) As Boolean

    If isNothing(coll) Then
        elwp "Please pass in a collection!"
    Else
    
        Dim allAreNumbersSoFar As Boolean
        allAreNumbersSoFar = True
        
        Dim c As Long
        c = 1
        
        Dim expectedObject As Variant
        Set expectedObject = Nothing
        
        While allAreNumbersSoFar And c <= coll.count
        
            Dim item As Variant
            atr item, coll.item(c)
            
            If Not isNumber(item) Then
                allAreNumbersSoFar = False
            End If
            
            c = c + 1
        Wend
    End If
    allInCollectionAreNumbers = allAreNumbersSoFar
End Function


Function convertAllInCollectionToIntegersWherePossible(coll As Collection) As Collection

    Dim converted As Collection
    Set converted = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim itm As Variant
        atr itm, coll.item(c)
        
        If isInteger(itm) Then
            itm = CLng(itm)
        End If
        
        converted.add itm
    Next
    
    Set convertAllInCollectionToIntegersWherePossible = converted

End Function

Function allInCollectionAreBlank(coll As Collection) As Boolean
    allInCollectionAreBlank = Not anyInCollectionAreNotBlank(coll)
End Function

Function allObjectsInCollectionAreTheSameObject(coll As Collection) As Boolean
    
    Dim allSameObjectSoFar As Boolean
    allSameObjectSoFar = True
    
    Dim c As Long
    c = 1
    
    Dim expectedObject As Variant
    Set expectedObject = Nothing
    
    While allSameObjectSoFar And c <= coll.count
    
        Dim item As Variant
        atr item, coll.item(c)
        
        If isNothing(expectedObject) Then
            Set expectedObject = item
        End If
        
        If isNothing(item) Then
            'DO NOTHING
        ElseIf item Is expectedObject Then
            'DO NOTHING
        Else
            allSameObjectSoFar = False
        End If
    
        c = c + 1
    Wend
    
    allObjectsInCollectionAreTheSameObject = allSameObjectSoFar
    
End Function

Function allElementsInCollectionAreEqual(coll As Collection) As Boolean

    Dim allSameObjectSoFar As Boolean
    allSameObjectSoFar = True
    
    Dim c As Long
    c = 1
    
    Dim expectedVal As Variant
    Set expectedVal = Nothing
    
    While allSameObjectSoFar And c <= coll.count
    
        Dim item As Variant
        atr item, coll.item(c)
        
        If c = 1 Then
            atr expectedVal, item
        Else
            If valuesAreEqual(expectedVal, item) Then
                'DO NOTHING
            Else
                allSameObjectSoFar = False
            End If
        End If
        c = c + 1
    Wend
    
    allElementsInCollectionAreEqual = allSameObjectSoFar
    
End Function

Function allItemsInCollectionAreBlankString(coll As Collection) As Boolean

    Dim allBlankStringSoFar As Boolean
    allBlankStringSoFar = True
    
    Dim c As Long
    c = 1
    
    While allBlankStringSoFar And c <= coll.count
    
        Dim item As Variant
        item = coll.item(c)
        
        If Trim(item) <> "" Then
            allBlankStringSoFar = False
        End If
    
        c = c + 1
    Wend
    
    allItemsInCollectionAreBlankString = allBlankStringSoFar
End Function
Function lcaseAllElementsInCollection(coll As Collection) As Collection

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim element As Variant
        element = coll.item(c)
        
        If isString(element) Then
            element = LCase(element)
        End If
        
        newColl.add element
    Next
    
    Set lcaseAllElementsInCollection = newColl

End Function

Function ucaseAllElementsInCollection(coll As Collection) As Collection

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim element As Variant
        element = coll.item(c)
        
        If isString(element) Then
            element = UCase(element)
        End If
        
        newColl.add element
    Next
    
    Set ucaseAllElementsInCollection = newColl

End Function

Function removeQuotesIfWrappedInQuotesForAllElementsInCollection(coll As Collection) As Collection
    
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim element As Variant
        element = coll.item(c)
        
        If isString(element) Then
            element = removeQuotesIfWrappedInQuotes(CStr(element))
        End If
        
        newColl.add element
    Next
    
    Set removeQuotesIfWrappedInQuotesForAllElementsInCollection = newColl

End Function

Function trimAllElementsInCollection(coll As Collection) As Collection

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim element As Variant
        element = coll.item(c)
        
        If isString(element) Then
            element = Trim(element)
        End If
        
        newColl.add element
    Next
    
    Set trimAllElementsInCollection = newColl
    
End Function

Function collectionToSet(coll As Collection) As JYCORE_Set
    Dim dupes As Collection
    Set collectionToSet = doCollectionToSet_trackDupes(coll, dupes)
End Function

Function collectionToSet_trackDupes(coll As Collection, ByRef out_dupes As JYCORE_Set) As JYCORE_Set
    
    Dim dupes As Collection
    Dim theSet As JYCORE_Set
    Set theSet = doCollectionToSet_trackDupes(coll, dupes)
    
    Set collectionToSet_trackDupes = theSet
    Set out_dupes = collectionToSet(dupes)
    
End Function

Function doCollectionToSet_trackDupes(coll As Collection, ByRef out_dupes As Collection) As JYCORE_Set

    Dim st As JYCORE_Set
    Set st = New JYCORE_Set
    
    Dim overridden As Collection
    If isNothing(coll) Then
        elwp "You passed in a blank collection!"
        Set overridden = Nothing
    Else
        Set overridden = st.addCollectionContents(coll)
    End If
    
    Set out_dupes = overridden
    Set doCollectionToSet_trackDupes = st
    
End Function

Function nothingToSet(st As JYCORE_Set) As JYCORE_Set
    If isNothing(st) Then
        Set nothingToSet = New JYCORE_Set
    Else
        Set nothingToSet = st
    End If
End Function

Function nothingToAdvancedDictionary(dict As JYUT_AdvancedDictionary, caseInsensitive As Boolean, ignoreSpacesBetweenWords As Boolean, shouldTrimKey As Boolean) As JYUT_AdvancedDictionary
    
    If isNothing(dict) Then
        Set nothingToAdvancedDictionary = createAdvancedDictionary(caseInsensitive, ignoreSpacesBetweenWords, shouldTrimKey)
    Else
        Set nothingToAdvancedDictionary = dict
    End If

End Function

Function nothingToDictionary(dict As Dictionary) As Dictionary
    If isNothing(dict) Then
        Set nothingToDictionary = New Dictionary
    Else
        Set nothingToDictionary = dict
    End If
End Function

Function nothingToCollection(coll As Collection) As Collection
    If isNothing(coll) Then
        Set nothingToCollection = New Collection
    Else
        Set nothingToCollection = coll
    End If
End Function

Function setItemInCollection(ByRef mod_coll As Collection, indx As Long, theVal As Variant) As Variant

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim itemsToAdd As Collection
    Set itemsToAdd = New Collection
    
    Dim c As Long
    For c = indx + 1 To mod_coll.count
        itemsToAdd.add mod_coll.item(c)
    Next
    
    Dim collLength As Long
    collLength = mod_coll.count
    
    Dim overriddenValue As Variant
    atr overriddenValue, mod_coll.item(indx)
    
    Dim d As Long
    For d = collLength To indx Step -1
        mod_coll.remove d
    Next
    
    mod_coll.add theVal
    
    Dim e As Long
    For e = 1 To itemsToAdd.count
        mod_coll.add itemsToAdd.item(e)
    Next
        
    atr setItemInCollection, overriddenValue

End Function

Function searchCollection(coll As Collection, searchValue As Variant) As Collection

    Dim foundIndexes As Collection
    Set foundIndexes = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        If valuesAreEqual(coll.item(c), searchValue) Then
            foundIndexes.add c
        End If
    Next
    
    Set searchCollection = foundIndexes

End Function

Function searchCollectionLinearly(coll As Collection, searchValue As Variant) As Long

    Dim foundIndx As Long
    foundIndx = NUM_REPRESENTING_NOT_FOUND_DURING_LINEAR_COLLECTION_SEARCH
    
    Dim c As Long
    c = 1
    While (c <= coll.count) And (foundIndx = 0)
    
        Dim element As Variant
        atr element, coll.item(c)
        
        If valuesAreEqual(element, searchValue) Then
            foundIndx = c
        End If
    
        c = c + 1
    Wend
    
    searchCollectionLinearly = foundIndx

End Function

Function collectionsAreEqual(firstCollection As Collection, secondCollection As Collection) As Boolean

    Dim size As Long
    size = ccsz(Array(firstCollection, secondCollection), False)
    
    If size = -1 Then
        collectionsAreEqual = False
    Else
        Dim foundDifference As Boolean
        foundDifference = False
        
        Dim c As Long
        c = 1
        
        While (c <= size) And (Not foundDifference)
        
            Dim val1 As Variant
            Dim val2 As Variant
            atr val1, firstCollection.item(c)
            atr val2, secondCollection.item(c)
            
            If Not valuesAreEqual(val1, val2) Then
                foundDifference = True
            End If
        
            c = c + 1
        Wend
        
        collectionsAreEqual = Not foundDifference
    End If
    

End Function

Function repeatedlyAddValueToCollection(ByRef mod_coll As Collection, value As Variant, numTimes As Long) As Collection

    Dim c As Long
    For c = 1 To numTimes
        mod_coll.add value
    Next

    Set repeatedlyAddValueToCollection = mod_coll

End Function


Function appendToEachCollectionInCollection(coll As Collection, something As Variant) As Collection

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim subColl As Collection
        Set subColl = coll.item(c)
        
        Dim newSubColl As Collection
        Set newSubColl = copyCollection(subColl)
        
        newSubColl.add something
        
        newColl.add newSubColl
    Next
    
    Set appendToEachCollectionInCollection = newColl

End Function

Function convertCollectionOfArrayRowsToCollectionOfCollections(coll As Collection) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim arrayRow As Variant
        arrayRow = coll.item(c)
        
        newColl.add arrayToCollection(arrayRow)
    Next
    
    Set convertCollectionOfArrayRowsToCollectionOfCollections = newColl
    
End Function

Function convertCollectionOfCollectionsToCollectionOfArrayRows(coll As Collection) As Collection
    
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim subColl As Collection
        Set subColl = coll.item(c)
        
        newColl.add collectionToArray(subColl)
    Next
    
    Set convertCollectionOfCollectionsToCollectionOfArrayRows = newColl
    
End Function

Function appendToEachArrayRowInCollection(collectionOfArrayRows As Collection, itmToAppend As Variant) As Collection

    Dim collectionOfCollections As Collection
    Set collectionOfCollections = convertCollectionOfArrayRowsToCollectionOfCollections(collectionOfArrayRows)
    
    Dim newColl As Collection
    Set newColl = appendToEachCollectionInCollection(collectionOfCollections, itmToAppend)
    
    Dim newCollectionOfArrayRows As Collection
    Set newCollectionOfArrayRows = convertCollectionOfCollectionsToCollectionOfArrayRows(newColl)
    
    Set appendToEachArrayRowInCollection = newCollectionOfArrayRows

End Function


'JY20120322 - start - Use "appendToAllCollectionElements" instead, this was a duplicate function
'Function appendToEachCollectionElement(coll As Collection, value As String) As Collection
'
'    Dim newColl As Collection
'    Set newColl = New Collection
'
'    Dim c As Long
'    For c = 1 To coll.count
'        Dim theVal As String
'        theVal = CStr(coll.item(c))
'
'        newColl.add theVal & value
'    Next
'
'    Set appendToEachCollectionElement = newColl
'
'End Function
'JY20120322 - end

Function ensureThatEachItemInCollectionIsWrappedByExactlyOneSetOfEnclosingParentheses(expressions As Collection) As Collection
    Dim ret As Collection
    Set ret = New Collection
    Dim c As Long
    For c = 1 To expressions.count
        Dim exp As String
        exp = expressions.item(c)
        
        ret.add ensureThatExactlyOneSetOfEnclosingParenthesisExistsAroundExpression(exp)
    Next
    
    Set ensureThatEachItemInCollectionIsWrappedByExactlyOneSetOfEnclosingParentheses = ret
End Function


Function prependToEachLineInEachCollectionElement(coll As Collection, strng As String, finalLineDelimToUse As String) As Collection
    
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
    
        Dim entry As Variant
        atr entry, coll.item(c)
        
        Dim newEntry As Variant
        If Not isString(entry) Then
            atr newEntry, entry
        Else
            Dim lines As Collection
            Set lines = prependToEachCollectionElement(separateStringIntoLines(CStr(entry)), strng)
            
            newEntry = cltstr(lines, finalLineDelimToUse, "")
        End If
        
        newColl.add newEntry
        
    Next
    
    Set prependToEachLineInEachCollectionElement = newColl
End Function

Function wrapEachCollectionElementWithCharacter(coll As Collection, char As String) As Collection
    Set wrapEachCollectionElementWithCharacter = appendToEachCollectionElement(prependToEachCollectionElement(coll, char), char)
End Function

Function prependToEachCollectionElement(coll As Collection, value As String) As Collection
    Set prependToEachCollectionElement = prependAndAppendToEachCollectionElement(value, coll, "")
End Function

Function appendToEachCollectionElement(coll As Collection, value As String) As Collection
    Set appendToEachCollectionElement = prependAndAppendToEachCollectionElement("", coll, value)
End Function

Function prependAndAppendToEachCollectionElement(valueToPrepend As String, coll As Collection, valueToAppend As String) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim theVal As String
        theVal = CStr(coll.item(c))
        
        newColl.add valueToPrepend & theVal & valueToAppend
    Next
    
    Set prependAndAppendToEachCollectionElement = newColl
End Function

Function concatenateArrays(list As Variant, desiredLowerBound As Long) As Variant
    concatenateArrays = collectionToArray_customLowerBound(concatenateCollections(arraysToCollections(list)), desiredLowerBound)
End Function

Function concatenateCollections(list As Variant) As Collection

    Dim lower As Long
    Dim upper As Long
    glaubs list, lower, upper
    
    Dim coll As Collection
    Set coll = New Collection
    
    Dim c As Long
    For c = lower To upper
        Dim curColl As Collection
        Set curColl = list(c)
        
        acltcl coll, curColl
    Next
    
    Set concatenateCollections = coll
End Function

'skipBlankValuesInConcatenation = false
Function concatenateCollectionElements(collectionsToConcatenate As Variant, delimiter As String, skipBlankValuesInConcatenation As Boolean) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs collectionsToConcatenate, lwr, upr
    
    Dim size As Long
    size = ccsz(collectionsToConcatenate, True)
    
    Dim results As Variant
    If size <= 0 Then
        'DO NOTHING
        Set results = Nothing
        
    Else
    
        ReDim results(1 To size)
        
        Dim c As Long
        For c = 1 To size
        
            Dim strSoFar As String
            strSoFar = ""
            
            Dim firstTknCreated As Boolean
            firstTknCreated = False
            
            Dim d As Long
            For d = lwr To upr
                Dim thisTkn As Variant
                atr thisTkn, collectionsToConcatenate(d).item(c)
                
                If isBlankValue(thisTkn) And skipBlankValuesInConcatenation Then
                    'DO NOTHING
                Else
                
                    If firstTknCreated Then
                        strSoFar = strSoFar & delimiter
                    Else
                        firstTknCreated = True
                    End If
                    strSoFar = strSoFar & thisTkn
                    
                    
                End If
            Next
            
            results(c) = strSoFar
            
        Next
        
    End If
    atr concatenateCollectionElements, results

End Function

Function reorderArrayAccordingToDesiredOrdering(theArr As Variant, desiredOrder As Collection) As Variant
    reorderArrayAccordingToDesiredOrdering = kta(reorderCollectionAccordingToDesiredOrdering(arrayToCollection(theArr), desiredOrder))
End Function
        
Function reorderCollectionAccordingToDesiredOrdering(theColl As Collection, desiredOrder As Collection)
    Dim reorderedCollection As Collection
    If isNothing(desiredOrder) Then
        Set reorderedCollection = theColl
    Else

        Set reorderedCollection = New Collection
        
        Dim itemsLeftToAdd As JYCORE_Set
        Set itemsLeftToAdd = collectionToSet(theColl)
        
        Dim y As Long
        For y = 1 To desiredOrder.count
            Dim curItem As String
            curItem = desiredOrder.item(y)
            
            If Not itemsLeftToAdd.exists(curItem) Then
                elwp "The item '" & curItem & "' was specified in the desired display order, but we do not know what it is!  We will therefore skip."
            Else
                itemsLeftToAdd.remove curItem
                reorderedCollection.add curItem
            End If
        Next
        
        'At this point, we have accounted for all of our desired ordering, and now just need to add back any tranches that were not specified in the ordering.
        
        If itemsLeftToAdd.count > 0 Then
            ilwp "Please note that some tranches were not specified in the desired display order: " & CHAR_CRLF & CHAR_CRLF & "    " & itemsLeftToAdd.toString(CHAR_CRLF & "    ", "")
            acltcl reorderedCollection, itemsLeftToAdd.toCollection()
        End If
        
    End If
    Set reorderCollectionAccordingToDesiredOrdering = reorderedCollection
End Function

Function appendToAllCollectionElements(coll As Collection, st As String) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        newColl.add CStr(coll.item(c)) & st
    Next
    
    Set appendToAllCollectionElements = newColl
End Function

Function addObjectToCollectionIfNotThereAlready(ByRef mod_coll As Collection, theObj As Object) As Boolean

    Dim found As Boolean
    found = False
    
    Dim c As Long
    c = 1
    
    While (c <= mod_coll.count) And (Not found)
        Dim theItem As Variant
        atr theItem, mod_coll.item(c)
        
        If IsObject(theItem) Then
            If theItem Is theObj Then
                found = True
            End If
        End If
        c = c + 1
    Wend
    
    Dim wasAdded As Boolean
    If found Then
        wasAdded = False
    Else
        mod_coll.add theObj
        wasAdded = True
    End If
    addObjectToCollectionIfNotThereAlready = wasAdded
End Function

Function createCollection() As Collection
    Set createCollection = New Collection
End Function

Function sortCollection(coll As Collection) As Collection
    If coll.count = 0 Then
        Set sortCollection = New Collection
    Else
        Set sortCollection = arrayToCollection(sortArray(kta(coll)))
    End If
End Function

Function convertBlankValuesInCollectionToDefaultValue(coll As Collection, substituteValue As Variant) As Collection
    
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim vl As Variant
        atr vl, coll.item(c)
        
        Dim newVal As Variant
        If isBlankValue(vl) Then
            newVal = substituteValue
        Else
            atr newVal, vl
        End If
        newColl.add newVal
    Next
    Set convertBlankValuesInCollectionToDefaultValue = newColl
End Function

Function removeNonNumericElementsFromCollection(ByRef mod_coll As Collection) As Collection

    Dim c As Long
    For c = mod_coll.count To 1 Step -1
        Dim theVal As Variant
        atr theVal, mod_coll.item(c)
        
        If Not isNumber(theVal) Then
            mod_coll.remove c
        End If
    Next

    Set removeNonNumericElementsFromCollection = mod_coll

End Function

Function removeBlankValuesFromCollection(ByRef mod_coll As Collection) As Collection
    
    Dim c As Long
    For c = mod_coll.count To 1 Step -1
        Dim theVal As Variant
        atr theVal, mod_coll.item(c)
        
        If isBlankValue(theVal) Then
            mod_coll.remove c
        End If
    Next

    Set removeBlankValuesFromCollection = mod_coll
End Function

Function multiplyAllNumbersInCollectionBy(coll As Collection, multiplier As Double) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim cur As Variant
        cur = multiplyIfIsNumber(coll.item(c), multiplier)
        
        newColl.add cur
    Next
    
    Set multiplyAllNumbersInCollectionBy = newColl
End Function

Function createCollectionOfBlankCollections(amount As Long) As Collection
    
    Dim columnsOfData As Collection
    Set columnsOfData = New Collection
    Dim x As Long
    For x = 1 To amount
        columnsOfData.add New Collection
    Next
    
    Set createCollectionOfBlankCollections = columnsOfData
    
End Function

Sub clearCollection(ByRef mod_coll As Collection)

    Dim c As Long
    For c = mod_coll.count To 1 Step -1
        mod_coll.remove c
    Next

End Sub

Sub extractFirstTokenFromListOfTokens(ByRef out_firstTkn, ByRef out_restOfTkns, tkns As Collection)
    out_firstTkn = tkns.item(1)
    Set out_restOfTkns = removeElementButInCopyOfCollectionNotInOrigCollection(tkns, 1)
End Sub

Function removeElementButInCopyOfCollectionNotInOrigCollection(coll As Collection, indx As Long) As Collection

    Dim nc As Collection
    Set nc = copyCollection(coll)
    
    nc.remove indx
    
    Set removeElementButInCopyOfCollectionNotInOrigCollection = nc

End Function

Sub removeElementAtParticularIndxInCollectionAndReplaceItWithListOfElements(ByRef mod_coll As Collection, indxOfElementToReplace As Long, replacementElements As Collection)
    Dim origValuesInCollection As Collection
    Set origValuesInCollection = copyCollection(mod_coll)
    
    clearCollection mod_coll
    
    Dim found As Boolean
    found = False
    
    Dim z As Long
    For z = 1 To origValuesInCollection.count
        If z = indxOfElementToReplace Then
            found = True
            
            acltcl mod_coll, replacementElements
            
        Else
            mod_coll.add origValuesInCollection.item(z)
        End If
    Next
    
    If Not found Then
        elwp "We did not make any modifications, but we had intended to.  What went wrong?"
    End If
End Sub

Function convertCollectionColumnsToArrayRows(collectionColumns As Variant) As Collection
    
    Dim arrayRows As Collection
    Set arrayRows = New Collection
    
    Dim numEntities As Long
    numEntities = ccsz(collectionColumns, True)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs collectionColumns, lwr, upr
    
    Dim dd As Long
    For dd = 1 To numEntities
    
        Dim curCollRow As Collection
        Set curCollRow = New Collection
        
        Dim c As Long
        For c = lwr To upr
            Dim curCol As Collection
            Set curCol = collectionColumns(c)
            
            curCollRow.add curCol.item(dd)
            
        Next
            
        arrayRows.add kta(curCollRow)
    Next
    
    Set convertCollectionColumnsToArrayRows = arrayRows
End Function

Function convertCollectionsToArrays(listOfCollections As Variant) As Variant
    
    Dim lwr As Long
    Dim upr As Long
    glaubs listOfCollections, lwr, upr
    
    Dim listOfArrays As Variant
    ReDim listOfArrays(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim curColl As Collection
        Set curColl = listOfCollections(c)
        
        listOfArrays(c) = kta(curColl)
    Next
    
    convertCollectionsToArrays = listOfArrays
End Function

Function convertArraysToCollections(listOfArrays As Variant) As Variant
    
    Dim lwr As Long
    Dim upr As Long
    glaubs listOfArrays, lwr, upr
    
    Dim listOfCollections As Variant
    ReDim listOfCollections(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim curArray As Variant
        curArray = listOfArrays(c)
        
        Set listOfCollections(c) = arrayToCollection(curArray)
    Next
    
    convertArraysToCollections = listOfArrays
End Function

Sub insertIntoCollection(ByRef mod_coll As Collection, indx As Long, theVal As Variant)
    Dim coll As Collection
    Set coll = copyCollection(mod_coll)
    
    clearCollection mod_coll
    
    Dim c As Long
    For c = 1 To indx - 1
        mod_coll.add coll.item(c)
    Next
    
    mod_coll.add theVal
    
    Dim d As Long
    For d = indx To coll.count
        mod_coll.add coll.item(d)
    Next

End Sub

Function fillAllBlankValuesWithLastAbove(disDataCol As Collection) As Collection
    
    Dim Temp As Collection
    Set Temp = New Collection
    
    Dim rr As Long
    For rr = 1 To disDataCol.count
        Dim disVal As Variant
        disVal = disDataCol.item(rr)
        
        If isBlankValue(disVal) And rr > 1 Then
            disVal = Temp.item(rr - 1)
        End If
        
        Temp.add disVal
            
    Next
    
    Set fillAllBlankValuesWithLastAbove = Temp
End Function

Sub fillAllBlankValuesWithLastAbove_inPlace(ByRef mod_disDataCol As Collection)

    Dim Temp As Collection
    Set Temp = fillAllBlankValuesWithLastAbove(mod_disDataCol)
    
    clearCollection mod_disDataCol
    acltcl mod_disDataCol, Temp
End Sub

Function prependToEachArrayListInCollectionOfArrayLists(collectionOfArrayLists As Collection, arrayListWhoseElementsShouldBePrepended As Variant) As Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrayListWhoseElementsShouldBePrepended, lwr, upr
    
    Dim coll As Collection
    Set coll = New Collection
    
    Dim c As Long
    For c = 1 To collectionOfArrayLists.count
        Dim arrList As Variant
        arrList = collectionOfArrayLists.item(c)
        
        coll.add concatenateArrays(Array(arrayListWhoseElementsShouldBePrepended, arrList), lwr)
            
    Next
    
    Set prependToEachArrayListInCollectionOfArrayLists = coll
    
End Function


Function verifyThatCollectionIsConsecutiveAndStartsWithExpectedValue(coll As Collection, expectedStartingIndex As Long) As Boolean

    Dim consecutiveSoFarAndStartsWithExpectedIndexValue As Boolean
    consecutiveSoFarAndStartsWithExpectedIndexValue = True
    
    Dim xx As Long
    xx = 1
    
    While (xx <= coll.count) And (consecutiveSoFarAndStartsWithExpectedIndexValue)
        Dim curValue As Variant
        curValue = coll.item(xx)
        
        Dim expectedValue As Long
        expectedValue = xx + expectedStartingIndex - 1
        
        If curValue <> expectedValue Then
            consecutiveSoFarAndStartsWithExpectedIndexValue = False
        End If
        
        xx = xx + 1
    Wend
    verifyThatCollectionIsConsecutiveAndStartsWithExpectedValue = consecutiveSoFarAndStartsWithExpectedIndexValue

End Function

Function createCollectionOfBlankDictionaries(length As Long) As Collection
    
    Dim listOfDictionaries As Collection
    Set listOfDictionaries = New Collection
    
    Dim x As Long
    For x = 1 To length
        listOfDictionaries.add New Dictionary
    Next
    
    Set createCollectionOfBlankDictionaries = listOfDictionaries
End Function

Function getItemAtIndexOrNothingIfIndexDoesNotExist(coll As Collection, indx As Long) As Variant

    If indx <= coll.count Then
        atr getItemAtIndexOrNothingIfIndexDoesNotExist, coll.item(indx)
    Else
        Set getItemAtIndexOrNothingIfIndexDoesNotExist = Nothing
    End If

End Function

Function consolidateCollectionsIntoOne(listOfCollections As Collection) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To listOfCollections.count
        Dim coll As Collection
        Set coll = listOfCollections.item(c)
        
        acltcl newColl, coll
    Next
    
    Set consolidateCollectionsIntoOne = newColl
End Function

Function sumOfCollectionElementsOrEMsg(coll As Collection) As Variant

    Dim sumSoFar As Variant
    sumSoFar = 0
    
    Dim c As Long
    c = 1
    While (c <= coll.count) And isNumber(sumSoFar)
        Dim itm As Variant
        atr itm, coll.item(c)
        
        If isNumber(itm) Then
            sumSoFar = sumSoFar + CDbl(itm)
        Else
            sumSoFar = "Could not add, because at least one element was not a number!"
        End If
        c = c + 1
    Wend
    sumOfCollectionElementsOrEMsg = sumSoFar

End Function

Function sumOfCollectionElements(coll As Collection) As Double

    Dim sumSoFar As Double
    sumSoFar = 0
    
    Dim c As Long
    For c = 1 To coll.count
        sumSoFar = sumSoFar + CDbl(coll.item(c))
    Next
    sumOfCollectionElements = sumSoFar
End Function

Function reverseCollection(coll As Collection) As Collection

    Dim coll2 As Collection
    Set coll2 = New Collection
    
    Dim c As Long
    For c = coll.count To 1 Step -1
        coll2.add coll.item(c)
    Next
    
    Set reverseCollection = coll2
End Function

Function wrapAllNonSetValuesInSet(coll As Collection) As Collection
    
    Dim newColl As Collection
    Set newColl = New Collection
    Dim xy As Long
    For xy = 1 To coll.count
        Dim theValue As Variant
        atr theValue, coll.item(xy)
        
        Dim theSet As JYCORE_Set
        If isSet(theValue) Then
            Set theSet = theValue
        Else
            Set theSet = collectionToSet(arrayToCollection(Array(theValue)))
        End If
        newColl.add theSet
    Next
    
    Set wrapAllNonSetValuesInSet = newColl
End Function

Function removeEntriesFromCollectionsWhereAllCollectionsHaveBlankValueAtThatIndex(ByRef mod_theCollections As Variant) As Collection
    
    Dim sz As Long
    sz = ccsz(mod_theCollections, True)
    
    Dim indexesToRemove As Collection
    Set indexesToRemove = figureOutIndexesAtWhichValueIsBlankInAllCollections(arrayToCollection(mod_theCollections))
    
    removeEntriesFromCollectionsAtSpecificIndexes mod_theCollections, indexesToRemove
    
    Set removeEntriesFromCollectionsWhereAllCollectionsHaveBlankValueAtThatIndex = indexesToRemove
End Function
Sub removeEntriesFromCollectionsAtSpecificIndexes(ByRef mod_theCollections, indexesToRemove As Collection)
   
    Dim indexesAtWhichValueIsBlankInAllCollections As Collection
    Set indexesAtWhichValueIsBlankInAllCollections = sortCollection(indexesToRemove)
    
    Dim upr As Long
    upr = indexesAtWhichValueIsBlankInAllCollections.count
    
    Dim c As Long
    For c = upr To 1 Step -1
        Dim indxToDelete As Long
        indxToDelete = indexesAtWhichValueIsBlankInAllCollections.item(c)
        
        Dim d As Long
        For d = 1 To mod_theCollections.count
            Dim curColl As Collection
            Set curColl = mod_theCollections.item(d)
            
            curColl.remove indxToDelete
        Next
    Next
End Sub

Function figureOutIndexesAtWhichValueIsBlankInAllCollections(theCollections As Collection) As Collection
    Dim indexesAtWhichValueIsBlankInAllCollections As Collection
    Set indexesAtWhichValueIsBlankInAllCollections = New Collection
    
    Dim sz As Long
    sz = ccsz(kta(theCollections), True)
    
    Dim e As Long
    For e = 1 To sz
        Dim foundNonBlank As Boolean
        foundNonBlank = False
        
        Dim f As Long
        f = 1
        
        While (Not foundNonBlank) And (f <= theCollections.count)
        
            Dim curColl As Collection
            Set curColl = theCollections.item(f)
            
            If (Not isBlankValue(curColl.item(e))) Then
                foundNonBlank = True
            End If
        
            f = f + 1
        Wend
        
        If foundNonBlank Then
            'DO NOTHING
        Else
            indexesAtWhichValueIsBlankInAllCollections.add e
        End If
    Next
    
    Set figureOutIndexesAtWhichValueIsBlankInAllCollections = indexesAtWhichValueIsBlankInAllCollections
End Function

Function convertAllInCollectionToYYYYMMDDIfPossible(coll As Collection) As Collection

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        newColl.add dateToYYYYMMDD_ifPossible(coll.item(c))
    Next
    
    Set convertAllInCollectionToYYYYMMDDIfPossible = newColl
    
End Function

Function replaceBlanksWithNAs(coll As Collection) As Collection

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim itm As Variant
        itm = coll.item(c)
        
        If Trim(CStr(itm)) = "" Then
            itm = "=na()"
        End If
        
        newColl.add itm
    Next
    
    Set replaceBlanksWithNAs = newColl
End Function

Function constructCollectionContainingSequentialListOfNumbers(lwr As Long, upr As Long) As Collection
    
    Dim coll As Collection
    Set coll = New Collection
    Dim r As Long
    For r = lwr To upr
        coll.add r
    Next
    
    Set constructCollectionContainingSequentialListOfNumbers = coll
    
End Function

Function removeSpacesInBetweenWords(strng As String) As String
    removeSpacesInBetweenWords = replaceInString(strng, "  ", " ", True)
End Function

Function replaceInStringForAllCollectionElements(coll As Collection, toReplace As String, replaceWith As String, recursive As Boolean) As Collection

    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        Dim item As Variant
        atr item, coll.item(c)
        
        Dim newItem As Variant
        If isNothing(item) Then
            Set newItem = Nothing
        ElseIf IsObject(item) Then
            Set newItem = item
        Else
            newItem = replaceInString(CStr(item), toReplace, replaceWith, recursive)
        End If
        newColl.add newItem
    Next
    
    Set replaceInStringForAllCollectionElements = newColl
End Function

Function convertBooleanToTextWherePossibleForAllElementsInCollection(coll As Collection) As Collection
    Dim newColl As Collection
    Set newColl = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        newColl.add convertBooleanToTextIfPossible(coll.item(c))
    Next
    
    Set convertBooleanToTextWherePossibleForAllElementsInCollection = newColl
End Function
Function findDupesInCollection(rns As Collection) As JYCORE_Set
    Dim encountered As JYCORE_Set
    Set encountered = New JYCORE_Set

    Dim dupes As JYCORE_Set
    Set dupes = New JYCORE_Set

    Dim c As Long
    For c = 1 To rns.count
        Dim rn As String
        rn = rns.item(c)
        
        If encountered.exists(rn) Then
            dupes.add rn
        End If
        
        encountered.add rn
    Next
    
    Set findDupesInCollection = dupes
End Function

Function copyCollectionButExcludeIndex(coll As Collection, indx As Long) As Collection
    Dim coll2 As Collection
    Set coll2 = New Collection
    
    Dim c As Long
    For c = 1 To coll.count
        If c = indx Then
            'DO NOTHING
        Else
            coll2.add coll.item(c)
        End If
    Next
    
    Set copyCollectionButExcludeIndex = coll2
    
End Function

Function gtknsForEveryListItem(list As Collection, delimiter As String) As Collection
    Dim listOf__tknList As Collection
    Set listOf__tknList = New Collection
    
    Dim c As Long
    For c = 1 To list.count
        Dim curString As Variant
        curString = list.item(c)
        
        listOf__tknList.add gtkns(CStr(curString), delimiter)
    Next
    
    Set gtknsForEveryListItem = listOf__tknList
    
    
End Function

Function andOfAll(booleanOrArrayOfBooleansOrColletionOfBooleans As Variant) As Boolean
    
    Dim arrOfBooleans As Variant
    arrOfBooleans = ensureValueIsAnArray(booleanOrArrayOfBooleansOrColletionOfBooleans)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrOfBooleans, lwr, upr
    
    Dim soFar As Boolean
    soFar = arrOfBooleans(lwr)
    
    Dim c As Long
    For c = lwr + 1 To upr
        soFar = soFar And arrOfBooleans(c)
    Next
    
    andOfAll = soFar
    
End Function

Function orOfAll(booleanOrArrayOfBooleansOrColletionOfBooleans As Variant) As Boolean
    
    Dim arrOfBooleans As Variant
    arrOfBooleans = ensureValueIsAnArray(booleanOrArrayOfBooleansOrColletionOfBooleans)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrOfBooleans, lwr, upr
    
    Dim soFar As Boolean
    soFar = arrOfBooleans(lwr)
    
    Dim c As Long
    For c = lwr + 1 To upr
        soFar = soFar Or arrOfBooleans(c)
    Next
    
    orOfAll = soFar
    
End Function

Function popFromEnd(ByRef mod_collection As Collection) As Variant
    Dim theVal As Variant
    atr theVal, mod_collection.item(mod_collection.count)
    mod_collection.remove (mod_collection.count)
    atr popFromEnd, theVal
End Function

Function getPortionOfCollection(coll As Collection, start As Long, last As Long) As Collection
    Dim list As Collection
    Set list = New Collection
    
    Dim c As Long
    For c = start To last
        list.add coll.item(c)
    Next
    
    Set getPortionOfCollection = list
    
End Function
Attribute VB_Name = "JYUT_ColsAndRows"
Option Explicit

Sub clearRowData(headerOrListOfHeaders As Variant)
    clearColumnOrRowData headerOrListOfHeaders, False, False
End Sub

Sub clearColumnData_optionallyForSelectedRowRnge(selOrNothingForEverything As Range, headerOrListOfHeaders As Variant)
    
    If isNothing(selOrNothingForEverything) Then
        clearColumnData headerOrListOfHeaders  'Clear all bbg columns
    Else
        Dim colAnks As Variant
        atr colAnks, ensureValueIsAnArray(headerOrListOfHeaders) ''clear all bbg columns within a specified range of rows
        
        Dim lwr As Long
        Dim upr As Long
        glaubs colAnks, lwr, upr
        
        Dim startRow As Long
        Dim endRow As Long
        startRow = tlcor(selOrNothingForEverything).row
        endRow = brcor(selOrNothingForEverything).row
        
        Dim c As Long
        For c = lwr To upr
            Dim ank As Range
            Set ank = colAnks(c)
            
            Dim topCell As Range
            Dim botCell As Range
            Set topCell = gcicsr(ank, startRow)
            Set botCell = gcicsr(ank, endRow)
            
            Dim dataRnge As Range
            Set dataRnge = rngeToRnge(topCell, botCell)
            
            dataRnge.ClearContents
            
        Next
        
    End If
End Sub


Sub clearColumnData_specifyLastPossibleRow(headerOrListOfHeaders As Variant, lastPossibleRow As Long, selectAsWeClear As Boolean)
    clearColumnOrRowData_specifyLastPossibleRowOrCol headerOrListOfHeaders, False, True, lastPossibleRow, selectAsWeClear
End Sub

Sub clearColumnData_selectAsWeClear(headerOrListOfHeaders As Variant)
    clearColumnData_specifyLastPossibleRow headerOrListOfHeaders, LAST_POSSIBLE_ROW, True
End Sub

Sub clearColumnData(headerOrListOfHeaders As Variant)
    clearColumnData_specifyLastPossibleRow headerOrListOfHeaders, LAST_POSSIBLE_ROW, False
End Sub

Sub clearColumnOrRowData(headerOrListOfHeaders As Variant, clearHeaderToo As Boolean, colDataVsRowData As Boolean)

    Dim lastPossibleRowOrCol As Long
    If colDataVsRowData Then
        lastPossibleRowOrCol = LAST_POSSIBLE_ROW
    Else
        lastPossibleRowOrCol = LAST_POSSIBLE_COL
    End If

    clearColumnOrRowData_specifyLastPossibleRowOrCol headerOrListOfHeaders, clearHeaderToo, colDataVsRowData, lastPossibleRowOrCol, False
End Sub

Sub clearColumnOrRowData_specifyLastPossibleRowOrCol(headerOrListOfHeaders As Variant, clearHeaderToo As Boolean, colDataVsRowData As Boolean, lastPossibleRowOrCol As Long, selectWhileClearing As Boolean)

    If isRnge(headerOrListOfHeaders) Then

        Dim header As Range
        Set header = headerOrListOfHeaders
        
        Dim numHeaders As Long
        If colDataVsRowData Then
            numHeaders = header.Columns.count
        Else
            numHeaders = header.rows.count
        End If
        
        If numHeaders > 1 Then
            clearColumnOrRowData_specifyLastPossibleRowOrCol getCellsInRnge(header), clearHeaderToo, colDataVsRowData, lastPossibleRowOrCol, selectWhileClearing
        Else
        
            Dim firstCell As Range
            If clearHeaderToo Then
                Set firstCell = header
            Else
                Set firstCell = firstDataCellInColumnOrRow(header, colDataVsRowData)
            End If
            
            Dim dataRnge As Range
            If colDataVsRowData Then
                Set dataRnge = getColumnDataRngeStartingWithCell_specifyLastPossibleRow(firstCell, lastPossibleRowOrCol)
            Else
                Set dataRnge = getRowDataRngeStartingWithCell_specifyLastPossibleCol(firstCell, lastPossibleRowOrCol)
            End If
            
            If selectWhileClearing Then
                srg dataRnge
            End If
            dataRnge.ClearContents
        End If
    ElseIf isNothing(headerOrListOfHeaders) Then
        elwp_se
    Else
    
        Dim list As Variant
        If isCollection(headerOrListOfHeaders) Then
            list = kta(castToCollection(headerOrListOfHeaders))
        Else
            list = headerOrListOfHeaders
        End If
        
        Dim lower As Long
        Dim upper As Long
        lower = LBound(list, 1)
        upper = UBound(list, 1)
        
        Dim origCalc As Variant
        origCalc = Application.Calculation
        
        If Application.Calculation <> xlCalculationManual Then
            Application.Calculation = xlCalculationManual
        End If
        
        Dim c As Long
        For c = lower To upper
            clearColumnOrRowData_specifyLastPossibleRowOrCol list(c), clearHeaderToo, colDataVsRowData, lastPossibleRowOrCol, selectWhileClearing
        Next
        
        If origCalc <> Application.Calculation Then
            Application.Calculation = origCalc
        End If
    End If
End Sub

Function firstDataCellInColumnOrRow(header As Range, colVsRow As Boolean) As Range
    If colVsRow Then
        Set firstDataCellInColumnOrRow = header.offset(1, 0)
    Else
        Set firstDataCellInColumnOrRow = header.offset(0, 1)
    End If
End Function

Function firstDataCellInColumn(header As Range) As Range
    Set firstDataCellInColumn = firstDataCellInColumnOrRow(header, True)
End Function

Function firstDataCellInRow(header As Range) As Range
    Set firstDataCellInRow = firstDataCellInColumnOrRow(header, False)
End Function

Function getHypotheticalRngeForColumnData(header As Range, dataCollectionOrArrayOrRnge As Variant) As Range
    Set getHypotheticalRngeForColumnData = doSetColDataOrFormulas(header, dataCollectionOrArrayOrRnge, True, True, False)
End Function

Sub scdFromListOfDataRows(rns As Collection, listOf_dataRowArrays As Collection, optWS As Worksheet, selectAsWeSet As Boolean, ByRef out_pastedRnges As Variant)

    Dim pastedRnges As Variant
    scdFromListOfDataRows_optionallySpecifyStartRow rns, listOf_dataRowArrays, optWS, selectAsWeSet, Nothing, pastedRnges
    
    atr out_pastedRnges, pastedRnges
End Sub

Sub scdFromListOfDataRows_optionallySpecifyStartRow(rns As Collection, listOf_dataRowArrays As Collection, optWS As Worksheet, selectAsWeSet As Boolean, optionalStartRow As Variant, ByRef out_pastedRnges As Variant)
    
    Dim anchors As Variant
    anchors = getAnchorsForListOfRNs(kta(rns), optWS)
    
    Dim pastedRnges As Variant
    scdFromListOfDataRows_passInColumnAnchors anchors, listOf_dataRowArrays, selectAsWeSet, optionalStartRow, pastedRnges
    
    atr out_pastedRnges, pastedRnges
End Sub

Sub scdFromListOfDataRows_passInColumnAnchors(anchors As Variant, listOf_dataRowArrays As Collection, selectAsWeSet As Boolean, optionalStartRow As Variant, ByRef out_pastedRnges As Variant)

    Dim pastedRnges As Variant
    scdFromListOfDataRows_passInColumnAnchors_specifyLastPossibleRow anchors, listOf_dataRowArrays, selectAsWeSet, optionalStartRow, LAST_POSSIBLE_ROW, pastedRnges
    
    atr out_pastedRnges, pastedRnges
End Sub
Sub scdFromListOfDataRows_passInColumnAnchors_specifyLastPossibleRow(anchors As Variant, listOf_dataRowArrays As Collection, selectAsWeSet As Boolean, optionalStartRow As Variant, lastPossibleRow As Long, ByRef out_pastedRnges As Variant)
    
    Dim pastedRnges As Variant
    setColumnOrRowDataFromListOfDataVectors_passInAnchors_specifyLastPossibleRowOrCol anchors, listOf_dataRowArrays, selectAsWeSet, optionalStartRow, lastPossibleRow, True, True, pastedRnges
    
    atr out_pastedRnges, pastedRnges
End Sub

Sub setColumnOrRowDataFromListOfDataVectors_passInAnchors_specifyLastPossibleRowOrCol(anchors As Variant, listOf_dataRowOrColArrays As Collection, selectAsWeSet As Boolean, optionalStartRowOrCol As Variant, lastPossibleRowOrCol As Long, colDataVsRowData As Boolean, passedInDataIsFieldBasedVsEntityBased As Boolean, ByRef out_pastedRnges As Variant)

    Dim pastedRnges As Variant
    If listOf_dataRowOrColArrays.count = 0 Then
    
        'There is no data so we should just clear all of our columns
        clearColumnData_specifyLastPossibleRow anchors, lastPossibleRowOrCol, False
        Set pastedRnges = Nothing
    Else
    
        
        Dim listOf_colData As Collection
        If passedInDataIsFieldBasedVsEntityBased Then
            Set listOf_colData = sciloar(True, listOf_dataRowOrColArrays)
        Else
            Set listOf_colData = listOf_dataRowOrColArrays
        End If
        
        setColumnOrRowDataForMultipleColumnsOrRows_specifyLastPossibleRowOrCol anchors, listOf_colData, optionalStartRowOrCol, selectAsWeSet, lastPossibleRowOrCol, colDataVsRowData, pastedRnges
    End If

    atr out_pastedRnges, pastedRnges

End Sub

Sub writeValueByRNToWorksheetOnCertainRow(rowToOverwrite As Long, optWS As Worksheet, valueByDestRN As Dictionary, selectAsWeSet As Boolean)

    Dim destRNs As Variant
    destRNs = valueByDestRN.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs destRNs, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim rn As String
        rn = destRNs(c)
        
        Dim theVal As Variant
        atr theVal, vfd(valueByDestRN, rn, True)
    
        Dim theCell As Range
        Set theCell = gcicsr(rnge(rn, optWS), rowToOverwrite)
        
        If selectAsWeSet Then
            sris theCell
        End If
        
        svl theCell, theVal
    Next

End Sub

Function scdForMultipleColumns_passInColAnchors(anchorOrArrayOfAnchorsOrCollectionOfAnchors As Variant, dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors As Variant, optionalStartRow As Variant, selectAsWeSet As Boolean) As Variant
    atr scdForMultipleColumns_passInColAnchors, scdForMultipleColumns_passInColAnchors_specifyLastPossibleRow(anchorOrArrayOfAnchorsOrCollectionOfAnchors, dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors, optionalStartRow, selectAsWeSet, LAST_POSSIBLE_ROW)
End Function

Function scdForMultipleColumns_passInColAnchors_specifyLastPossibleRow(anchorOrArrayOfAnchorsOrCollectionOfAnchors As Variant, dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors As Variant, optionalStartRow As Variant, selectAsWeSet As Boolean, lastPossibleRow As Long) As Variant
    Dim pastedRnges As Variant
    setColumnOrRowDataForMultipleColumnsOrRows_specifyLastPossibleRowOrCol anchorOrArrayOfAnchorsOrCollectionOfAnchors, dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors, optionalStartRow, selectAsWeSet, lastPossibleRow, True, pastedRnges
    
    atr scdForMultipleColumns_passInColAnchors_specifyLastPossibleRow, pastedRnges
End Function

Sub setColumnOrRowDataForMultipleColumnsOrRows_specifyLastPossibleRowOrCol(anchorOrArrayOfAnchorsOrCollectionOfAnchors As Variant, dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors As Variant, optionalStartRowOrCol As Variant, selectAsWeSet As Boolean, lastPossibleRowOrCol As Long, colDataVsRowData As Boolean, ByRef out_pastedRnges As Variant)

    Dim arrOfAnchors As Variant
    Dim arrOfDataVectors As Variant
    arrOfAnchors = ensureValueIsAnArray(anchorOrArrayOfAnchorsOrCollectionOfAnchors)
    arrOfDataVectors = ensureValueIsAnArray(dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors)

    Dim sz As Long
    sz = casz(Array(arrOfAnchors, arrOfDataVectors), True)
    
    Dim pastedRnges As Variant
    If sz = 0 Then
        Set pastedRnges = Nothing
    Else
        ReDim pastedRnges(1 To sz)
    
        Dim c As Long
        For c = 1 To sz
            
            Dim dataVector As Collection
            Set dataVector = rlai(arrOfDataVectors, c)
        
            Dim curAnchor As Range
            Set curAnchor = rlai(arrOfAnchors, c)
            
            Dim rngePastedThisTime As Range
            If isNothing(curAnchor) Then
                Set rngePastedThisTime = Nothing
            Else
                'JY20140228c - start
                'If selectAsWeSet Then
                '    srg curAnchor
                'End If
                'JY20140228c - end
                
                Dim firstCell As Range
                If isNothing(optionalStartRowOrCol) Then
                    Set firstCell = firstDataCellInColumnOrRow(curAnchor, colDataVsRowData)
                Else
                    If colDataVsRowData Then
                        Set firstCell = gcicsr(curAnchor, CLng(optionalStartRowOrCol))
                    Else
                        Set firstCell = gcirsc(curAnchor, CLng(optionalStartRowOrCol))
                    End If
                End If
                
                
                
                
                
                'JY20140228c
                'Set rngePastedThisTime = setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol(firstCell, dataVector, True, False, colDataVsRowData, lastPossibleRowOrCol)
                Set rngePastedThisTime = setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol(firstCell, dataVector, True, False, colDataVsRowData, lastPossibleRowOrCol, selectAsWeSet)
                
            End If
            
            Set pastedRnges(c) = rngePastedThisTime
        Next
    End If
    
    atr out_pastedRnges, pastedRnges
End Sub

'allBoundsAreExpectedToBeAlike = true
Function scdForMultipleColumns(allBoundsAreExpectedToBeAlike As Boolean, listOf__rn_dataCollection As Collection, optWS As Worksheet, selectAsWeSet As Boolean) As Variant

    Dim rns_dataCollections As Collection
    Set rns_dataCollections = sciloar(allBoundsAreExpectedToBeAlike, listOf__rn_dataCollection)

    Dim rns As Collection
    Dim dataCollections As Collection
    Set rns = rns_dataCollections.item(1)
    Set dataCollections = rns_dataCollections.item(2)
    
    atr scdForMultipleColumns, scdForMultipleColumns_passInRangeNames(rns, dataCollections, optWS, selectAsWeSet)
    
End Function

Function scdForMultipleColumns_passInRangeNames(arrayOrCollectionOfRNs As Variant, dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors As Variant, optWS As Worksheet, selectAsWeSet As Boolean) As Variant
    
    Dim anchors As Variant
    anchors = getCellsForListOfRNs(arrayOrCollectionOfRNs, optWS)
    
    atr scdForMultipleColumns_passInRangeNames, scdForMultipleColumns_passInColAnchors(anchors, dataVectorOrArrayOfDataVectorsOrCollectionOfDataVectors, Nothing, selectAsWeSet)
    
End Function


Function setColumnData(header As Range, dataCollectionOrArrayOrRnge As Variant) As Range
    Set setColumnData = setColumnData_optionallySelectAsWeSet(header, dataCollectionOrArrayOrRnge, False)
End Function

Function setColumnData_optionallySelectAsWeSet(header As Range, dataCollectionOrArrayOrRnge As Variant, selectAsWeSet As Boolean) As Range
    Set setColumnData_optionallySelectAsWeSet = doSetColDataOrFormulas(header, dataCollectionOrArrayOrRnge, True, False, selectAsWeSet)
End Function

Function setRowData(header As Range, dataCollectionOrArrayOrRnge As Variant) As Range
    Set setRowData = doSetRowDataOrFormulas(header, dataCollectionOrArrayOrRnge, True, False)
End Function

Function scdOrFormulas(header As Range, dataCollectionOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean) As Range
    Set scdOrFormulas = doSetColDataOrFormulas(header, dataCollectionOrArrayOrRnge, valuesVersusFormulas, False, False)
End Function

Function doSetColDataOrFormulas(header As Range, dataCollectionOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean, selectAsWeSet As Boolean) As Range

    Dim firstCell As Range
    Set firstCell = firstDataCellInColumn(header)
    
    Set doSetColDataOrFormulas = setColDataOrFormulasStartingInCell_selectAsWeSet(firstCell, dataCollectionOrArrayOrRnge, valuesVersusFormulas, hypothetical, selectAsWeSet, True)
End Function

Function doSetRowDataOrFormulas(header As Range, dataCollectionOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean) As Range

    Dim firstCell As Range
    Set firstCell = firstDataCellInRow(header)
    
    Set doSetRowDataOrFormulas = setRowDataOrFormulasStartingInCell(firstCell, dataCollectionOrArrayOrRnge, valuesVersusFormulas, hypothetical)
End Function

Function setColDataOrFormulasStartingInCell(firstCell As Range, dataCollOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean) As Range
    Set setColDataOrFormulasStartingInCell = setColDataOrFormulasStartingInCell_selectAsWeSet(firstCell, dataCollOrArrayOrRnge, valuesVersusFormulas, hypothetical, False, True)
End Function

'colDataVsRow = true
Function setColDataOrFormulasStartingInCell_selectAsWeSet(firstCell As Range, dataCollOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean, selectAsWeSet As Boolean, colDataVsRow As Boolean) As Range
    Set setColDataOrFormulasStartingInCell_selectAsWeSet = setColOrRowDataOrFormulasStartingInCell_selectAsWeSet(firstCell, dataCollOrArrayOrRnge, valuesVersusFormulas, hypothetical, colDataVsRow, selectAsWeSet)
End Function

Function setRowDataOrFormulasStartingInCell(firstCell As Range, dataCollOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean) As Range
    Set setRowDataOrFormulasStartingInCell = setColOrRowDataOrFormulasStartingInCell_selectAsWeSet(firstCell, dataCollOrArrayOrRnge, valuesVersusFormulas, hypothetical, False, False)
End Function

Function setColOrRowDataOrFormulasStartingInCell_selectAsWeSet(firstCell As Range, dataCollOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean, colDataVsRow As Boolean, selectAsWeSet As Boolean) As Range
    Set setColOrRowDataOrFormulasStartingInCell_selectAsWeSet = setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol(firstCell, dataCollOrArrayOrRnge, valuesVersusFormulas, hypothetical, colDataVsRow, LAST_POSSIBLE_ROW_OR_COL(colDataVsRow), selectAsWeSet)
End Function

'selectAsWeSet = false
Function setColOrRowDataOrFormulasStartingInCell(firstCell As Range, dataCollOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean, colDataVsRow As Boolean, selectAsWeSet As Boolean) As Range
    Set setColOrRowDataOrFormulasStartingInCell = setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol(firstCell, dataCollOrArrayOrRnge, valuesVersusFormulas, hypothetical, colDataVsRow, LAST_POSSIBLE_ROW_OR_COL(colDataVsRow), selectAsWeSet)
End Function

Function LAST_POSSIBLE_ROW_OR_COL(colDataVsRow As Boolean)
    If colDataVsRow Then
        LAST_POSSIBLE_ROW_OR_COL = LAST_POSSIBLE_ROW
    Else
        LAST_POSSIBLE_ROW_OR_COL = LAST_POSSIBLE_COL
    End If
End Function

'JY20140228c - start
'Function setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol(firstCell As Range, dataCollOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean, colDataVsRow As Boolean, lastPossibleRowOrCol As Long) As Range
'Set setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol = setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol_selectAsWeSet(firstCell, dataCollOrArrayOrRnge, valuesVersusFormulas, hypothetical, colDataVsRow, lastPossibleRowOrCol, selectAsWeSet)
Function setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol(firstCell As Range, dataCollOrArrayOrRnge As Variant, valuesVersusFormulas As Boolean, hypothetical As Boolean, colDataVsRow As Boolean, lastPossibleRowOrCol As Long, selectAsWeSet As Boolean) As Range
    clearColumnOrRowData_specifyLastPossibleRowOrCol firstCell, True, colDataVsRow, lastPossibleRowOrCol, False

    Dim vectorSize As Long
    Dim oneDimensionalDataRngeOrCollection As Variant

        'JY20120917a
        'Dim data As Collection
    Dim data As Variant
    
    If isNothing(dataCollOrArrayOrRnge) Then
        vectorSize = 0
        Set oneDimensionalDataRngeOrCollection = Nothing
        Set data = Nothing
    ElseIf isRnge(dataCollOrArrayOrRnge) Then
        
        Dim theRnge As Range
        Set theRnge = castToRnge(dataCollOrArrayOrRnge)
        
        If colDataVsRow And (theRnge.Columns.count <> 1) Then
            elwp "Please pass in a single-column range!  This time, we will just take your first column of data."
            Set oneDimensionalDataRngeOrCollection = resizeRnge(theRnge, theRnge.rows.count, 1)
        ElseIf (Not colDataVsRow) And (theRnge.rows.count <> 1) Then
            elwp "Please pass in a single-row range!  This time, we will just take your first row of data."
            Set oneDimensionalDataRngeOrCollection = resizeRnge(theRnge, 1, theRnge.Columns.count)
        
        Else
            Set oneDimensionalDataRngeOrCollection = theRnge
        End If
        
        If colDataVsRow Then
            vectorSize = oneDimensionalDataRngeOrCollection.rows.count
        Else
            vectorSize = oneDimensionalDataRngeOrCollection.Columns.count
        End If
        Set data = Nothing
    Else
        'JY20120917a - start
        'If IsArray(dataCollOrArrayOrRnge) Then
        '    Set data = arrayToCollection(dataCollOrArrayOrRnge)
        'Else
        '    Set data = dataCollOrArrayOrRnge
        'End If
        'vectorSize = data.count


        If isCollection(dataCollOrArrayOrRnge) Then
            'JY20121008c - start
            If dataCollOrArrayOrRnge.count = 0 Then
                vectorSize = 0
                Set data = Nothing
            Else
            'JY20121008c - end
                If colDataVsRow Then
                    data = collectionTo2DArrayColumn(castToCollection(dataCollOrArrayOrRnge))
                Else
                    data = collectionTo2DArrayRow(castToCollection(dataCollOrArrayOrRnge))
                End If
                vectorSize = castToCollection(dataCollOrArrayOrRnge).count
            End If 'JY20121008c
        ElseIf isRnge(dataCollOrArrayOrRnge) Then
            Set data = dataCollOrArrayOrRnge
            vectorSize = castToRnge(dataCollOrArrayOrRnge).count
        Else
            Dim dims As Long
            dims = numDims(dataCollOrArrayOrRnge)
            
            If dims = 1 Then
                data = oneDimArrayTo2DArray(dataCollOrArrayOrRnge, Not colDataVsRow)
                vectorSize = dimSize(data, 1)
            ElseIf dims = 2 Then
                
                If dimSize(dataCollOrArrayOrRnge, 2) <> 1 Then
                    elwp "Unsupported number of columns!"
                    Set data = Nothing
                    vectorSize = -1
                Else
                    data = dataCollOrArrayOrRnge
                    vectorSize = dimSize(data, 1)
                End If
                
                
            Else
                elwp "Unsupported number of dimensions!"
                Set data = Nothing
                vectorSize = -1
            End If
        End If
        'JY20120917a - end
        
        'JY20121008b - looks like this was missing
        Set oneDimensionalDataRngeOrCollection = Nothing
    End If
    
    Dim rngeToWrite As Range
    If vectorSize = 0 Then
        Set rngeToWrite = firstCell
    Else
        Dim lastCell As Range
        If colDataVsRow Then
            Set lastCell = firstCell.offset(vectorSize - 1, 0)
        Else
            Set lastCell = firstCell.offset(0, vectorSize - 1)
        End If
        
        Set rngeToWrite = rngeToRnge(firstCell, lastCell)
        'JY20120917a - start
        'Dim arr As Variant
        'If isRnge(oneDimensionalDataRngeOrCollection) Then
        '    If oneDimensionalDataRngeOrCollection.rows.count = 1 And oneDimensionalDataRngeOrCollection.Columns.count = 1 Then
        '
        '        ReDim arr(1 To 1, 1 To 1)
        '        arr(1, 1) = oneDimensionalDataRngeOrCollection.value
        '    Else
        '        arr = oneDimensionalDataRngeOrCollection.value
        '    End If
        'Else
        '    If colDataVsRow Then
        '        arr = collectionTo2DArrayColumn(data)
        '    Else
        '        arr = collectionTo2DArrayRow(data)
        '    End If
        'End If
        
        'If Not hypothetical Then

        
        If Not hypothetical Then
        
            If selectAsWeSet Then
                srg rngeToWrite
            End If
            
            'Dim useClipboardToSpeedThingsUp As Boolean
            'useClipboardToSpeedThingsUp = True
            
            Dim arr As Variant
            If isRnge(oneDimensionalDataRngeOrCollection) Then
                If oneDimensionalDataRngeOrCollection.rows.count = 1 And oneDimensionalDataRngeOrCollection.Columns.count = 1 Then
                    
                    ReDim arr(1 To 1, 1 To 1)
                    arr(1, 1) = oneDimensionalDataRngeOrCollection.value
                Else
                    arr = oneDimensionalDataRngeOrCollection.value
                End If
            Else
                arr = data
            End If
            
        'JY20120917a - end
        
            'JY20110927a - start
            'If valuesVersusFormulas Then
            '    svl rngeToWrite, arr
            'Else
            '    setCellFormula rngeToWrite, arr, False
            'End If
            'JY20110927a - end
            
            If selectAsWeSet Then
                sris rngeToWrite
            End If
            writeArrayToRngeOfExactlySameSize rngeToWrite, arr, valuesVersusFormulas, selectAsWeSet
        End If
    End If
    Set setColOrRowDataOrFormulasStartingInCell_specifyLastPossibleRowOrCol = rngeToWrite
'JY20140228c - end
    
End Function

Function setColumnFormulas(header As Range, data As Collection) As Range
    Set setColumnFormulas = scdOrFormulas(header, data, False)
End Function

Function getRowData_specifyLastPossibleColumn(header As Range, lastPossibleCol As Long) As Collection
    Set getRowData_specifyLastPossibleColumn = getData_specifyLastPossibleIndx(header, lastPossibleCol, True)
End Function

Function getColumnData_specifyLastPossibleRow(header As Range, lastPossibleRow As Long) As Collection
    Set getColumnData_specifyLastPossibleRow = getData_specifyLastPossibleIndx(header, lastpossbilerow, False)
End Function

Function getData_specifyLastPossibleIndx(header As Range, lastPossibleIndx As Long, rowDataVsColumnData As Boolean) As Collection
    Dim rnge As Range
    Set rnge = getRowOrColDataRnge_specifyLastPossibleIndex(header, lastPossibleIndx, rowDataVsColumnData)
    
    Set getData_specifyLastPossibleIndx = convertRowOrColumnRngeToData(rnge, rowDataVsColumnData)
End Function

Function convertRowOrColumnRngeToData(rnge As Range, rowDataVsColumnData As Boolean) As Collection
    If isNothing(rnge) Then
        Set convertRowOrColumnRngeToData = New Collection
    Else
    
        Dim brCell As Range
        Set brCell = brcor(rnge)
    
        Dim firstIndx As Long
        Dim lastIndx As Long
        If rowDataVsColumnData Then
            firstIndx = rnge.column
            lastIndx = brCell.column
        Else
            firstIndx = rnge.row
            lastIndx = brCell.row
        End If
        
        Dim theData As Collection
        Set theData = getDataFromIndxToIndx(tlcor(rnge), firstIndx, lastIndx, rowDataVsColumnData)
        
        
        If theData.count = 1 Then
            If CStr(theData.item(1)) = "" Then
                'This is not data.
                theData.remove 1
            End If
        End If
        
        Set convertRowOrColumnRngeToData = theData
    End If
End Function

Function getColumnDataForEachAnchor(anchorsToCopy As Collection) As Collection
    
    Dim listOf_colData As Collection
    Set listOf_colData = New Collection
    
    Dim c As Long
    For c = 1 To anchorsToCopy.count
    
        Dim curAnchor As Range
        Set curAnchor = anchorsToCopy.item(c)
        
        listOf_colData.add rngeToRnge(curAnchor, getColumnDataRnge(curAnchor))
        
    Next
    
    Set getColumnDataForEachAnchor = listOf_colData
End Function

Function writeListOfColDataStartingAtAnchor(firstCol As Range, listOf_colData As Collection) As Range

    Dim curCol As Range
    Set curCol = firstCol
    
    Dim incrementSize As Long
    incrementSize = 1
    
    Dim x As Long
    For x = 1 To listOf_colData.count
        
        srg curCol
        
        Dim colData As Range
        Set colData = listOf_colData.item(x)
        
        setColDataOrFormulasStartingInCell curCol, colData, True, False
        
        Set curCol = curCol.offset(0, incrementSize)
    Next

    Dim headerForWrittenData As Range
    Set headerForWrittenData = rngeToRnge(firstCol, curCol.offset(0, -incrementSize))
    
    Set writeListOfColDataStartingAtAnchor = headerForWrittenData
End Function

Function getColumnData(header As Range) As Collection
    Set getColumnData = getRowOrColumnData(header, False)
End Function

Function getRowData(header As Range) As Collection
    Set getRowData = getRowOrColumnData(header, True)
End Function

Function getRowOrColumnData(header As Range, rowVsColData As Boolean) As Collection
    Dim lastPossibleIndx As Long
    If rowVsColData Then
        lastPossibleIndx = LAST_POSSIBLE_COL
    Else
        lastPossibleIndx = LAST_POSSIBLE_ROW
    End If
    Set getRowOrColumnData = getData_specifyLastPossibleIndx(header, lastPossibleIndx, rowVsColData)
End Function

Function getColumnDataFromRowToRow(header As Range, firstIndx As Long, lastIndx As Long) As Collection
    Set getColumnDataFromRowToRow = getDataFromIndxToIndx(header, firstIndx, lastIndx, False)
End Function

Function getRowDataFromColumnToColumn(header As Range, firstIndx As Long, lastIndx As Long) As Collection
    Set getColumnDataFromRowToRow = getDataFromIndxToIndx(header, firstIndx, lastIndx, True)
End Function

Function getDataFromIndxToIndx(anyCellInRowOrColumn As Range, firstIndx As Long, lastIndx As Long, rowDataVsColumnData As Boolean) As Collection
    
    Dim data As Collection
    
    'JY20110316a - start
    'Set data = New Collection
    '
    'Dim r As Long
    'For r = firstIndx To lastIndx
    '    data.add gvl(gcicsr(anyCellInRowOrColumn, r))
    'Next
    '
    
    Dim theRnge As Range
    If rowDataVsColumnData Then
        Set theRnge = getRowDataRngeFromColToCol(anyCellInRowOrColumn, firstIndx, lastIndx)
    Else
        Set theRnge = getColDataRngeFromRowToRow(anyCellInRowOrColumn, firstIndx, lastIndx)
    End If
    
    Set data = getRowOrColDataFromRnge(theRnge, rowDataVsColumnData)
    


    'JY20110316a - end
    
    Set getDataFromIndxToIndx = data
End Function

Function getRowDataRngeFromColToCol(anyCellInRow As Range, firstCol As Long, lastCol As Long) As Range
 Set getRowDataRngeFromColToCol = rngeToRnge(gcirsc(anyCellInRow, firstCol), gcirsc(anyCellInRow, lastCol))
End Function

Function getColDataRngeFromRowToRow(anyCellInColumn As Range, firstRow As Long, lastRow As Long) As Range
    Set getColDataRngeFromRowToRow = rngeToRnge(gcicsr(anyCellInColumn, firstRow), gcicsr(anyCellInColumn, lastRow))
End Function

Function getColumnDataRnge_specifyLastPossibleRow(header As Range, lastPossibleRow As Long) As Range
    Set getColumnDataRnge_specifyLastPossibleRow = getRowOrColDataRnge_specifyLastPossibleIndex(anyCellInColumn, lastPossibleRow, False)
End Function

Function getRowDataRnge_specifyLastPossibleCol(header As Range, lastPossibleCol As Long) As Range
    Set getRowDataRnge_specifyLastPossibleCol = getRowOrColDataRnge_specifyLastPossibleIndex(header, lastPossibleCol, True)
End Function

Function getRowOrColDataRnge_specifyLastPossibleIndex(header As Range, lastPossibleIndex As Long, rowVsColData As Boolean) As Range
    
    Dim firstDataCell As Range
    If rowVsColData Then
        Set firstDataCell = firstDataCellInRow(header)
    Else
        Set firstDataCell = firstDataCellInColumn(header)
    End If
    
    Set getRowOrColDataRnge_specifyLastPossibleIndex = getRowOrColDataRngeStartingWithCell_specifyLastPossibleIndex(firstDataCell, lastPossibleIndex, rowVsColData)
    
End Function

Function getRowDataRnge(header As Range) As Range
    Set getRowDataRnge = getRowOrColDataRnge_specifyLastPossibleIndex(header, LAST_POSSIBLE_COL, True)
End Function

Function getColumnDataRnge(header As Range) As Range
    Set getColumnDataRnge = getRowOrColDataRnge_specifyLastPossibleIndex(header, LAST_POSSIBLE_ROW, False)
End Function

Function getRowDataRngeStartingWithCell(firstCell As Range) As Range
    Set getRowDataRngeStartingWithCell = getRowDataRngeStartingWithCell_specifyLastPossibleCol(firstCell, lastPossibleCol)
End Function

Function getRowDataRngeStartingWithCell_specifyLastPossibleCol(firstCell As Range, lastPossibleCol As Long) As Range
    Set getRowDataRngeStartingWithCell_specifyLastPossibleCol = getRowOrColDataRngeStartingWithCell_specifyLastPossibleIndex(firstCell, lastPossibleCol, True)
End Function

Function getColumnDataRngeStartingWithCell_specifyLastPossibleRow(firstCell As Range, lastPossibleRow As Long) As Range
    Set getColumnDataRngeStartingWithCell_specifyLastPossibleRow = getRowOrColDataRngeStartingWithCell_specifyLastPossibleIndex(firstCell, lastPossibleRow, False)
End Function

Function getRowOrColDataRngeStartingWithCell_specifyLastPossibleIndex(firstCell As Range, lastPossibleIndex As Long, rowDataVsColData As Boolean) As Range

    Dim lastCell As Range
    Dim indexOfLastCell As Long
    Dim indexOfFirstCell As Long
    If rowDataVsColData Then
        Set lastCell = lastCellInRow_specifyLastPossibleCol(firstCell, False, lastPossibleIndex)
        indexOfFirstCell = firstCell.column
        indexOfLastCell = lastCell.column
    Else
        Set lastCell = lastCellInColumn_ignoreColumnHeaderLocation_specifyAbsoluteLastRowAssumption(firstCell, False, lastPossibleIndex, True)
        indexOfFirstCell = firstCell.row
        indexOfLastCell = lastCell.row
    End If
    
    
    If indexOfLastCell < indexOfFirstCell Then
        Set lastCell = firstCell
    End If

    Set getRowOrColDataRngeStartingWithCell_specifyLastPossibleIndex = rngeToRnge(firstCell, lastCell)

End Function

Function getColumnDataRngeStartingWithCell(firstCell As Range) As Range
    Set getColumnDataRngeStartingWithCell = getColumnDataRngeStartingWithCell_specifyLastPossibleRow(firstCell, LAST_POSSIBLE_ROW)
End Function

Function getColumnOrRowDataRngeStartingWithCell(firstCell As Range, colVsRow As Boolean) As Range
    If colVsRow Then
        Set getColumnOrRowDataRngeStartingWithCell = getColumnDataRngeStartingWithCell_specifyLastPossibleRow(firstCell, LAST_POSSIBLE_ROW)
    Else
        Set getColumnOrRowDataRngeStartingWithCell = getRowDataRngeStartingWithCell(firstCell, LAST_POSSIBLE_ROW)
    End If
        
End Function

'"gcicsr" stands for "getCellInColumnAtSpecificRow"
Function gcicsr(anyCellInColumn As Range, row As Long) As Range
    Set gcicsr = moveRngeToRow(tlcor(anyCellInColumn), row)
End Function

'"gcirsc" stands for "getCellInRowAtSpecificColumn"
Function gcirsc(anyCellInRow As Range, col As Long) As Range
    Set gcirsc = moveRngeToColumn(tlcor(anyCellInRow), col)
End Function
        
Sub clearCellsFromRowToRow(anyCellInColumn As Range, firstRow As Long, lastRow As Long)
    Dim rngeToClear As Range
    Set rngeToClear = getColumnCellsFromRowToRow(anyCellInColumn, firstRow, lastRow)
    
    rngeToClear.ClearContents
End Sub

Function getColumnCellsFromRowToRow(anyCellInColumn As Range, firstRow As Long, lastRow As Long) As Range
    
    Dim col As Long
    col = anyCellInColumn.column
    
    Dim top As Range
    Dim bottom As Range
    Set top = anyCellInColumn.Worksheet.cells(firstRow, col)
    Set bottom = anyCellInColumn.Worksheet.cells(lastRow, col)
    
    Set getColumnCellsFromRowToRow = rngeToRnge(top, bottom)
End Function

Function toCollection(candidate As Variant) As Collection
    If isCollection(candidate) Then
        Set toCollection = candidate
    Else
        Set toCollection = candidate.toCollection()
    End If
End Function

Function getRowDataFromRowRnge(rowRnge As Range) As Collection
    Set getRowDataFromRowRnge = getRowOrColDataFromRnge(rowRnge, True)
End Function

Function getColDataFromColRnge(colRnge As Range) As Collection
    Set getColDataFromColRnge = getRowOrColDataFromRnge(colRnge, False)
End Function

Function getRowOrColDataFromRnge(theRnge As Range, rowDataVsColumnData As Boolean) As Collection
    
    Dim dataArr As Variant
    dataArr = theRnge.value
    
    If Not IsArray(dataArr) Then
        Dim tmp As Variant
        ReDim tmp(1 To 1, 1 To 1)
        tmp(1, 1) = dataArr
        
        dataArr = tmp
    End If
    
    Dim columnsVsRows As Boolean
    columnsVsRows = Not rowDataVsColumnData
    
    Set getRowOrColDataFromRnge = arrayToCollection(rlai(separateRowsOrColumnsInArray(dataArr, columnsVsRows, False), 1))
    
    
End Function

Function getCellAtIntersectionOfTwoNamedAnchors(rnForRowAnchor As String, rnForColAnchor As String, optWS As Worksheet)

    Dim rowAnchor As Range
    Set rowAnchor = rnge(rnForRowAnchor, optWS)
    
    Dim colAnchor As Range
    Set colAnchor = rnge(rnForColAnchor, optWS)
    
    Set getCellAtIntersectionOfTwoNamedAnchors = getCellAtIntersectionOfTwoAnchors(rowAnchor, colAnchor)
    
End Function

Function getCellAtIntersectionOfTwoAnchors(rowAnchor As Range, colAnchor As Range)

    If rowAnchor.Worksheet Is colAnchor.Worksheet Then
        Dim wsToUse As Worksheet
        Set wsToUse = rowAnchor.Worksheet 'pick one arbitrarily
        
        Set getCellAtIntersectionOfTwoAnchors = wsToUse.cells(rowAnchor.row, colAnchor.column)
    Else
        elwp "Please pass in two cells from the same worksheet!"
        Set getCellAtIntersectionOfTwoAnchors = Nothing
    End If

End Function
Sub deleteRowsInWS(ws As Worksheet, fromRow As Long, toRow As Long)
    
    Dim numRowsToDelete As Long
    numRowsToDelete = toRow - fromRow + 1
    
    Dim delRnge As Range
    Set delRnge = rngeToRnge(ws.cells(fromRow, 1), ws.cells(toRow, 1)).EntireRow
    
    delRnge.Delete
    
End Sub

Function deleteRowsWithinRowRangeDependingOnFilterCriteria(lastRow As Long, firstDataRow As Long, ws As Worksheet, listOf__setOfDesiredValues_filtrCellAnchor As Collection) As Long

    Dim newLastRow As Long
    newLastRow = lastRow
    
    Dim startRowToDeleteIfInDeleteMode As Variant
    Set startRowToDeleteIfInDeleteMode = Nothing

    Dim theStep As Long
    theStep = -1
    
    Dim curRow As Long
    For curRow = lastRow To firstDataRow Step theStep
        Dim shouldDeleteRow As Boolean
        If isNothing(listOf__setOfDesiredValues_filtrCellAnchor) Then
            shouldDeleteRow = False
        ElseIf listOf__setOfDesiredValues_filtrCellAnchor.count = 0 Then
            shouldDeleteRow = False
        Else
            
            shouldDeleteRow = False
            
            Dim cnt As Long
            cnt = 1
            
            While (Not shouldDeleteRow) And (cnt <= listOf__setOfDesiredValues_filtrCellAnchor.count)
                
                Dim setOfDesiredValues_filtrCellAnchor As Variant
                setOfDesiredValues_filtrCellAnchor = listOf__setOfDesiredValues_filtrCellAnchor.item(cnt)
                
                Dim setOfDesiredValues As JYCORE_Set
                Dim filterCellAnchor As Range
                Set setOfDesiredValues = rlai(setOfDesiredValues_filtrCellAnchor, 1)
                Set filterCellAnchor = rlai(setOfDesiredValues_filtrCellAnchor, 2)
                
                Dim filterValue As Variant
                filterValue = gvl(gcicsr(filterCellAnchor, curRow))
                
                If Not setOfDesiredValues.exists(filterValue) Then
                    shouldDeleteRow = True
                End If
                
                cnt = cnt + 1
            Wend
        
            
        End If
        
        If shouldDeleteRow Then
            If isNothing(startRowToDeleteIfInDeleteMode) Then
                startRowToDeleteIfInDeleteMode = curRow
            Else
                'DO NOTHING
            End If
        Else
            deleteAnyRowsFlaggedForDeletionSoFar newLastRow, curRow - theStep, startRowToDeleteIfInDeleteMode, ws
        End If
    Next
    
    deleteAnyRowsFlaggedForDeletionSoFar newLastRow, firstDataRow, startRowToDeleteIfInDeleteMode, ws
    
    deleteRowsWithinRowRangeDependingOnFilterCriteria = newLastRow


End Function

Function getLastNonBlankRowInListOfColumnsDenotedByRN(optWS As Worksheet, rns As Collection, firstRow As Long) As Long

    Dim lastRow As Long
    lastRow = firstRow
    
    Dim c As Long
    For c = 1 To rns.count
        Dim curRN As String
        curRN = rns.item(c)
        
        Dim anchor As Range
        Set anchor = rnge(curRN, optWS)
        
        Dim lastCell As Range
        Set lastCell = lastCellInColumn(anchor, False)
        
        While (lastCell.row > anchor.row) And (Trim(gvl(lastCell)) = "")
            Set lastCell = lastCell.offset(-1, 0)
        Wend
        
        Dim lastRowInCol As Long
        lastRowInCol = wsFunctionMax(firstRow, lastCell.row)
        
        
        
        
        lastRow = wsFunctionMax(lastRow, lastRowInCol)
    Next
    
    getLastNonBlankRowInListOfColumnsDenotedByRN = lastRow

End Function

Attribute VB_Name = "JYUT_CondFmtBackgrndSetter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Implements JYUT_CondFormatApplierInterface

Public backgroundColor As Long

Sub JYUT_CondFormatApplierInterface_applyFormatToFormatConditions(theFormatCondition As FormatCondition)

    With theFormatCondition.Interior
        .Color = backgroundColor
    End With

End Sub


Attribute VB_Name = "JYUT_CondFormatApplierInterface"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'THIS CLASS IS AN INTERFACE!

Option Explicit

Sub applyFormatToFormatConditions(theFormatCondition As FormatCondition)

    'STUB METHOD, SINCE THIS CLASS IS AN INTERFACE
    'DO NOTHING

End Sub




Attribute VB_Name = "JYUT_CutAndPasteDataSources"
Option Explicit

'JYUT_CutAndPasteDataSources

'deleteColsAndShiftLeftToo = false
Sub clearImportArea(sectionCols As Range, pasteHereText As String, deleteColsAndShiftLeftToo As Boolean)
    
    Dim areaToClear As Range
    Set areaToClear = getImportAreaToClear(sectionCols)

    deleteRnge areaToClear, DELETE_MODE_DELETE_ROWS_AND_SHIFT_UP
    If deleteColsAndShiftLeftToo Then
        Dim areaToClear2 As Range
        Set areaToClear2 = getImportAreaToClear(sectionCols)
        
        If areaToClear2.Columns.count <= 1 Then
            'DO NOTHING
        Else
            'Chop off the left column because there might be a border we don't want to screw up.
            
            Dim areaToClear3 As Range
            Set areaToClear3 = shiftRnge(expandRnge(areaToClear2, 0, -1), 0, 1)
            
            deleteRnge areaToClear3, DELETE_MODE_DELETE_COLUMNS_AND_SHIFT_LEFT
        End If
    End If
    
    svl shiftRnge(tlcor(sectionCols), 2, 1), "<" & pasteHereText & ">"

End Sub

Function getImportAreaToClear(sectionCols As Range) As Range
    Dim ws As Worksheet
    Set ws = sectionCols.Worksheet
    
    Dim lastPossibleRow As Long
    lastPossibleRow = brcor(ws.UsedRange).row
    
    Dim areaToClear As Range
    Set areaToClear = rngeToRnge(shiftRnge(tlcor(sectionCols), 1, 0), gcicsr(brcor(sectionCols), lastPossibleRow))
    
    Set getImportAreaToClear = areaToClear
End Function


Attribute VB_Name = "JYUT_Date"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public yr As Long
Public mnth As Long
Public dy As Long

Attribute VB_Name = "JYUT_Dates"
Option Explicit

Public Const STANDARD_DATE_DELIMITER As String = "/"

Public Const DEFAULT_YYYYMMDD_DELIMITER As String = ""
Public Const DEFAULT_DELIM_BETWEEN_DATE_AND_TIME As String = "-"
Public Const DEFAULT_DELIMITER_BETWEEN_HHMM_AND_SS As String = "-"
Public Const YYYYMMDD_LENGTH As Long = 8

Public Const MIN_POSSIBLE_LAST_DAY_OF_MONTH As Long = 27 'This happens in February, which is the shortest month of the year.

Function HHMMSS_WITH_DELIMITER_LENGTH() As Long
    HHMMSS_WITH_DELIMITER_LENGTH = 6 + (Len(DEFAULT_DELIMITER_BETWEEN_HHMM_AND_SS))
End Function

Function dateTimeToDate(dateTime As Date) As Date
    dateTimeToDate = createDate(year(dateTime), month(dateTime), day(dateTime))
End Function

Function dateTimeToTime(dateTime As Date) As Date
    dateTimeToTime = dateTime - dateTimeToDate(dateTime)
End Function

Function createDateTimeIfPossible(yr As Variant, mnth As Variant, dy As Variant, hh As Variant, mm As Variant, ss As Variant) As Variant
    createDateTimeIfPossible = yyyymmddhhmmssToDateTimeIfPossible(constructYYYYMMDDHHMMSS(yr, mnth, dy, hh, mm, ss))
End Function

Function createDateIfPossible(yr As Variant, mnth As Variant, dy As Variant) As Variant
    atr createDateIfPossible, yyyymmddToDateIfPossible(constructYYYYMMDD(yr, mnth, dy))
End Function

Function createDate(yr As Variant, mnth As Variant, dy As Variant) As Date
    createDate = yyyymmddToDate(constructYYYYMMDD(yr, mnth, dy))
End Function

Function isBusinessDay(theDate As Date, holidayDates As JYCORE_Set) As Boolean
    isBusinessDay = (isWeekday(theDate) And Not (holidayDates.exists(theDate)))
End Function

Function countTheBizDaysIfPossible(theFirstDay As Variant, theLastDay As Variant, holidayDates As JYCORE_Set) As Variant
    If IsDate(theFirstDay) And IsDate(theLastDay) Then
        Dim firstDay As Date
        Dim lastDay As Date
        firstDay = CDate(theFirstDay)
        lastDay = CDate(theLastDay)
        
        countTheBizDaysIfPossible = countNumBusinessDaysInclusive(firstDay, wsFunctionMax(lastDay, firstDay), holidayDates)
    Else
        countTheBizDaysIfPossible = "?"
    End If
End Function

Function computeLastDayOfMonth(monthNum As Long, yr As Long) As Long
    Dim dte As Date
    dte = createDate(yr, monthNum, 1)
    
    Dim nxt As Date
    nxt = addMonths(dte, 1)
    
    Dim lastDayOfMonth As Date
    lastDayOfMonth = nxt - 1
    
    computeLastDayOfMonth = day(lastDayOfMonth)
End Function

Function computeLastBusinessDayOfTheMonth(anyDateInTheMonthWeWantToComputeFor As Date, holidayDates As JYCORE_Set) As Date
    
    Dim firstDayOfMonth As Date
    firstDayOfMonth = createDate(year(anyDateInTheMonthWeWantToComputeFor), month(anyDateInTheMonthWeWantToComputeFor), 1)
    
    Dim mnth As Long
    mnth = month(anyDateInTheMonthWeWantToComputeFor)
    
    Dim lastBizDayFound As Variant
    Set lastBizDayFound = Nothing
    
    Dim curDate As Date
    curDate = firstDayOfMonth
    
    While month(curDate) = mnth
    
        If isBusinessDay(curDate, holidayDates) Then
            lastBizDayFound = curDate
        End If
    
        curDate = curDate + 1
    Wend
    
    If isNothing(lastBizDayFound) Then
        elwp "Something went wrong here.  We couldn't figure out the last business day of the month, so we have just returned the first day of the month instead.  This is a programming error."
        computeLastBusinessDayOfTheMonth = firstDayOfMonth
    Else
        computeLastBusinessDayOfTheMonth = lastBizDayFound
    End If
    
    
End Function

Function countNumBusinessDaysInclusive(startDate As Date, recentDate As Date, holidayDates As JYCORE_Set) As Long
    
    Dim minDate As Date
    Dim maxDate As Date
    minDate = startDate
    maxDate = recentDate
    
    Dim cnt As Long
    cnt = 0
    
    Dim c As Date
    For c = minDate To maxDate
        If isBusinessDay(c, holidayDates) Then
            cnt = cnt + 1
        End If
    Next
    
    countNumBusinessDaysInclusive = cnt
    
End Function

Function getXthPreviousBusinessDay(theDate As Date, holidayDates As JYCORE_Set, x As Long) As Date
    
    Dim soFar As Date
    soFar = theDate
    
    Dim c As Long
    For c = 1 To x
        soFar = getPreviousBusinessDay(soFar, holidayDates)
    Next
    
    getXthPreviousBusinessDay = soFar
    
End Function

Function getPreviousBusinessDay(theDate As Date, holidayDates As JYCORE_Set) As Date
    
    Dim candidate As Date
    candidate = theDate - 1
    
    While Not isBusinessDay(candidate, holidayDates)
        candidate = candidate - 1
    Wend
    
    getPreviousBusinessDay = candidate
End Function

Function getEarliestWeekdayBeforeOrAfterSpecifiedWeekdayOrReturnBlankIfWeekend(dte As Variant, beforeVsAfter As Boolean, inclusiveVsExclusive As Boolean, ByRef mod_emsgs As Variant) As Variant
    
    Dim retVal As Variant
    If Not IsDate(dte) Then
        mod_emsgs.add "Invalid date: " & dte
        retVal = "???"
    Else
    
        Dim baseDate As Date
        baseDate = CDate(dte)
        
        If isWeekend(baseDate) Then
            retVal = ""
        Else
        
            Dim increment As Long
            If beforeVsAfter Then
                increment = -1
            Else
                increment = 1
            End If
            
            Dim candidateSoFar As Date
            If inclusiveVsExclusive Then
                candidateSoFar = baseDate
            Else
                candidateSoFar = baseDate + increment
            End If
            
            Dim nextOne As Date
            nextOne = candidateSoFar + increment
            
            While Not (isWeekday(candidateSoFar) And isWeekend(nextOne))
                candidateSoFar = nextOne
                nextOne = nextOne + increment
            Wend
            
            Dim found As Variant
            found = candidateSoFar
            
            retVal = found
        End If
    End If
    getEarliestWeekdayBeforeOrAfterSpecifiedWeekdayOrReturnBlankIfWeekend = retVal
End Function

Function isWeekend(theDate As Date) As Boolean
    isWeekend = Not isWeekday(theDate)
End Function

Function isWeekday(theDate As Date) As Boolean
    Dim dayOfWeek As Variant
    dayOfWeek = Application.WorksheetFunction.Weekday(theDate, 1)

    If dayOfWeek = 1 Or dayOfWeek = 7 Then
        isWeekday = False
    Else
        isWeekday = True
    End If

End Function

Function dateToDayOfWeek(theDate As Date) As String
    
    Dim dayOfWeek As Variant
    dayOfWeek = Application.WorksheetFunction.Weekday(theDate, 1)
    
    Dim theDay As String
    If dayOfWeek = 1 Then
        theDay = "Sunday"
    ElseIf dayOfWeek = 2 Then
        theDay = "Monday"
    ElseIf dayOfWeek = 3 Then
        theDay = "Tuesday"
    ElseIf dayOfWeek = 4 Then
        theDay = "Wednesday"
    ElseIf dayOfWeek = 5 Then
        theDay = "Thursday"
    ElseIf dayOfWeek = 6 Then
        theDay = "Friday"
    ElseIf dayOfWeek = 7 Then
        theDay = "Saturday"
    Else
        theDay = "????"
    End If
    
    
    dateToDayOfWeek = theDay
End Function

Function getDateRnge(startDate As Date, endDate As Date) As Collection

    Dim dates As Collection
    Set dates = New Collection
    
    Dim curDate As Date
    For curDate = startDate To endDate
        dates.add curDate
    Next
    
    Set getDateRnge = dates
End Function

Function convertNumSecondsToTimeValueConvertibleHHMMSS_showPopupAndDefaultToZeroIfInvalidValueEntered(numSeconds As Variant, desc As String) As String
    
    Dim hhmmss As String
    hhmmss = "ERROR: NOT SET!"

On Error GoTo ehs

    Dim defValue As Long
    defValue = 0
    
    Dim totalSeconds As Long
    If Not isInteger(numSeconds) Then
        elwp "You did not specify an integer for the number of seconds you want to " & desc & ".  We will assume " & defValue & " seconds."
        totalSeconds = defValue
    Else
        totalSeconds = CLng(numSeconds)
    End If
        
    Dim hrs As Long
    Dim mins As Long
    Dim secs As Long
    hrs = totalSeconds \ (60 * 60)
    
    totalSeconds = totalSeconds Mod (60 * 60)
    
    mins = totalSeconds \ 60
    totalSeconds = totalSeconds Mod 60
    
    secs = totalSeconds
    
    hhmmss = padLeft(CStr(hrs), 2, "0") & ":" & padLeft(CStr(mins), 2, "0") & ":" & padLeft(CStr(secs), 2, "0")

    Dim converted As Variant
    converted = TimeValue(hhmmss) 'might throw an error if we get an invalid value

GoTo ehe
ehs:

    elwp "'" & totalSeconds & "' converts to '" & hhmmss & "', which does not convert into a valid time value.  So we will assume '" & defValue & "' seconds instead."

    hhmmss = "00:00:00"
ehe:
On Error GoTo 0
    
    convertNumSecondsToTimeValueConvertibleHHMMSS_showPopupAndDefaultToZeroIfInvalidValueEntered = hhmmss
End Function

Function getTimeOffsetImpliedBySecondsString(numSeconds As Variant, desc As String) As Variant
    
    Dim multiplier As Long
    If isNumber(numSeconds) Then
        If CDbl(numSeconds) < 0 Then
            multiplier = -1
        Else
            multiplier = 1
        End If
    Else
        multiplier = 1
    End If
    
    Dim numSecondsToUse As Variant
    If isNumber(numSeconds) Then
        numSecondsToUse = multiplier * CDbl(numSeconds)
    Else
        numSecondsToUse = numSeconds
    End If
    
    Dim mmddss As String
    mmddss = convertNumSecondsToTimeValueConvertibleHHMMSS_showPopupAndDefaultToZeroIfInvalidValueEntered(numSecondsToUse, desc)
    
    Dim timeOffset As Variant
    timeOffset = multiplier * TimeValue(mmddss)

    getTimeOffsetImpliedBySecondsString = timeOffset
End Function


Function convertTwoDigitYearToFourDigits(yy As String) As String
    
    Dim yyyy As String
    If Len(yy) = 2 Then
        'Assume the 21st century
        yyyy = "20" & yy
    Else
        yyyy = padLeft(yy, 4, "0")
    End If
    convertTwoDigitYearToFourDigits = yyyy

End Function

Function convertToMMDDYYYYFormat(dateStr As String) As String
    Dim tkns As Collection
    Set tkns = gtkns(dateStr, "/")
    
    Dim result As String
    If tkns.count <> 3 Then
        'Unknown format
        result = dateStr
    Else
        Dim mm As String
        Dim dd As String
        Dim yyyy As String
        mm = padLeft(tkns.item(1), 2, "0")
        dd = padLeft(tkns.item(2), 2, "0")
        yyyy = convertTwoDigitYearToFourDigits(tkns.item(3))
        
        result = mm & "/" & dd & "/" & yyyy
    End If
    convertToMMDDYYYYFormat = result
    
End Function

Function yyyymmddhhmmssToDateTimeIfPossible(candidate As Variant) As Variant
    If isYYYYMMDDHHMMSSFormat(candidate) Then
On Error GoTo ehs
        yyyymmddhhmmssToDateTimeIfPossible = yyyymmddhhmmssToDateTime(CStr(candidate))
GoTo ehe
ehs:
        atr yyyymmddhhmmssToDateTimeIfPossible, candidate
ehe:
On Error GoTo 0
    Else
        atr yyyymmddhhmmssToDateTimeIfPossible, candidate
    End If

End Function

Function yyyymmddToDateIfPossible(candidate As Variant) As Variant

    If isYYYYMMDDFormat(candidate) Then
On Error GoTo ehs
        yyyymmddToDateIfPossible = yyyymmddToDate(CStr(candidate))
GoTo ehe
ehs:
        atr yyyymmddToDateIfPossible, candidate
ehe:
On Error GoTo 0
    Else
        atr yyyymmddToDateIfPossible, candidate
    End If
End Function

Function yyyymmddhhmmssToDateTime(yyyymmddhhmmss As String) As Date

    Dim yyyymmdd As String
    Dim hhmmssWithDefaultDelimiter As String
    Dim success As Boolean
    parseYYYYMMDDHHMMSSIntoDateAndTime yyyymmddhhmmss, yyyymmdd, hhmmssWithDefaultDelimiter, success
    
    Dim dteTime As Date
    If Not success Then
        elwp "Invalid format for yyyymmddhhmmss: " & yyyymmddhhmmss
        dteTime = 0
    Else
        Dim dte As Date
        dte = yyyymmddToDate(yyyymmdd)
        
        Dim tme As Date
        tme = hhmmssToTime(hhmmssWithDefaultDelimiter)
        
        dteTime = dte + tme
    End If
    
    yyyymmddhhmmssToDateTime = dteTime
End Function

Function hhmmssToTime(hhmmssWithDefaultDelimiter As String) As Date
        
        Dim hh As String
        Dim mm As String
        Dim ss As String
        parseHHMMSS hhmmssWithDefaultDelimiter, hh, mm, ss
        
        hhmmssToTime = CDate(hh & ":" & mm & ":" & ss)

End Function

Function yyyymmddToDate(yyyymmdd As String) As Date

    Dim yyyy As String
    Dim mm As String
    Dim dd As String
    parseYYYYMMDD yyyymmdd, yyyy, mm, dd
    
    yyyymmddToDate = CDate(mm & "/" & dd & "/" & yyyy)

End Function

Sub parseHHMMSS(hhmmssWithDefaultDelimiter As String, ByRef out_hh As String, ByRef out_mm As String, ByRef out_ss As String)
    out_hh = left(hhmmssWithDefaultDelimiter, 2)
    out_mm = Mid(hhmmssWithDefaultDelimiter, 3, 2)
    out_ss = Right(hhmmssWithDefaultDelimiter, 2)

End Sub

Sub parseYYYYMMDD(yyyymmdd As String, ByRef out_yyyy As String, ByRef out_mm As String, ByRef out_dd As String)
    out_yyyy = left(yyyymmdd, 4)
    out_mm = Mid(yyyymmdd, 5, 2)
    out_dd = Right(yyyymmdd, 2)
End Sub

Function isYYYYMMDDHHMMSSFormat(candidate As Variant) As Boolean
    If IsObject(candidate) Then
        isYYYYMMDDHHMMSSFormat = False
    Else
        Dim cand As String
        cand = CStr(candidate)
        
        If Len(cand) <> YYYYMMDD_LENGTH + Len(DEFAULT_DELIM_BETWEEN_DATE_AND_TIME) + HHMMSS_WITH_DELIMITER_LENGTH Then
            isYYYYMMDDHHMMSSFormat = False
        Else
            
            Dim yyyymmddCandidate As String
            Dim hhmmssCandidate As String
            Dim success As Boolean
            parseYYYYMMDDHHMMSSIntoDateAndTime cand, yyyymmddCandidate, hhmmssCandidate, success
            
            If Not success Then
                isYYYYMMDDHHMMSSFormat = False
            Else
                
                If Not isYYYYMMDDFormat(yyyymmddCandidate) Then
                    isYYYYMMDDHHMMSSFormat = False
                Else
                    Dim hh As String
                    Dim mm As String
                    Dim ss As String
                    parseHHMMSS hhmmssCandidate, hh, mm, ss
                    
                    If Not isNumber(hh) Or Not isNumber(mm) Or Not isNumber(ss) Then
                        isYYYYMMDDHHMMSSFormat = False
                    Else
                        isYYYYMMDDHHMMSSFormat = True
                    End If
                End If
            End If
            
        End If
    End If
End Function

Function isYYYYMMDDFormat(candidate As Variant) As Boolean
    
    If IsObject(candidate) Then
        isYYYYMMDDFormat = False
    Else
        
        Dim cand As String
        cand = CStr(candidate)
        
        If Len(cand) <> YYYYMMDD_LENGTH Then
            isYYYYMMDDFormat = False
        Else
            Dim yyyy As String
            Dim mm As String
            Dim dd As String
            parseYYYYMMDD cand, yyyy, mm, dd
            
            If Not isInteger(yyyy) Or Not isInteger(mm) Or Not isInteger(dd) Then
                isYYYYMMDDFormat = False
            Else
                isYYYYMMDDFormat = True
            End If
        End If
    End If
End Function

Function diffInMonths_yyyymm(yyyymmHigher As Variant, yyyymmLower As Variant) As Long
    
    Dim yyyyLower As Double
    Dim mmLower As Double
    Dim yyyyHigher As Double
    Dim mmHigher As Double
    yyyyLower = CDbl(left(yyyymmLower, 4))
    mmLower = CDbl(Right(yyyymmLower, 2))
    yyyyHigher = CDbl(left(yyyymmHigher, 4))
    mmHigher = CDbl(Right(yyyymmHigher, 2))
    
    Dim yearDiff As Long
    yearDiff = yyyyHigher - yyyyLower
    
    Dim monthDiff As Long
    monthDiff = mmHigher - mmLower
    
    While monthDiff < 0
        monthDiff = monthDiff + 12
        yearDiff = yearDiff - 1
    Wend
    
    diffInMonths_yyyymm = (yearDiff * 12) + monthDiff
End Function

Function dateToYYYYMMDDHHMMSS_ifPossible_customDelimiter(possibleDate As Variant, delimiter As String) As Variant

    If IsDate(possibleDate) Then
        Dim hh As String
        Dim mm As String
        Dim ss As String
        hh = padLeft(CStr(Hour(possibleDate)), 2, "0")
        mm = padLeft(CStr(Minute(possibleDate)), 2, "0")
        ss = padLeft(CStr(Second(possibleDate)), 2, "0")
        
        Dim yyyymmdd As String
        yyyymmdd = dateToYYYYMMDD_ifPossible(possibleDate)
        
        dateToYYYYMMDDHHMMSS_ifPossible_customDelimiter = yyyymmdd & delimiter & hh & mm & delimiter & ss
        
    Else
        dateToYYYYMMDDHHMMSS_ifPossible_customDelimiter = possibleDate
    End If

End Function


Function dateToYYYYMMDDHHMMSS_ifPossible(possibleDate As Variant) As Variant
    dateToYYYYMMDDHHMMSS_ifPossible = dateToYYYYMMDDHHMMSS_ifPossible_customDelimiter(possibleDate, "-")
End Function

Function dateToMMDDYYYYHHMMSS_ifPossible(possibleDate As Variant) As Variant

    If IsDate(possibleDate) Then
        Dim hh As String
        Dim mm As String
        Dim ss As String
        hh = padLeft(CStr(Hour(possibleDate)), 2, "0")
        mm = padLeft(CStr(Minute(possibleDate)), 2, "0")
        ss = padLeft(CStr(Second(possibleDate)), 2, "0")
        
        Dim yyyymmdd As String
        yyyymmdd = dateToMMDDYYYY_ifPossible(possibleDate, True)
        
        dateToMMDDYYYYHHMMSS_ifPossible = yyyymmdd & "-" & hh & mm & "-" & ss
        
    Else
        dateToMMDDYYYYHHMMSS_ifPossible = possibleDate
    End If

End Function

Function checkIfIsDate(strictVsFlexible As Boolean, possibleDate As Variant) As Boolean

    Dim itIsDate As Boolean
    If strictVsFlexible Then
        itIsDate = IsDate(possibleDate)
    Else
        itIsDate = cbcd(possibleDate)
    End If
    
    checkIfIsDate = itIsDate

End Function

'strictVsFlexible = true
Function dateToYYYYMMDD_ifPossible_customDelimiter(possibleDate As Variant, customDelimiter As String, strictVsFlexible As Boolean) As Variant

    Dim itIsDate As Boolean
    itIsDate = checkIfIsDate(strictVsFlexible, possibleDate)
    
    If itIsDate Then
    
        dateToYYYYMMDD_ifPossible_customDelimiter = constructYYYYMMDD_customDelimiter(year(possibleDate), month(possibleDate), day(possibleDate), customDelimiter)
    Else
        dateToYYYYMMDD_ifPossible_customDelimiter = possibleDate
    End If

End Function

Function dateToNiceFormatIfPossible(possibleDate As Variant) As Variant

    If IsDate(possibleDate) Then
        Dim yyyy As String
        Dim mm As String
        Dim dd As String
        yyyy = padLeft(CStr(year(possibleDate)), 4, "0")
        mm = padLeft(CStr(month(possibleDate)), 2, "0")
        dd = padLeft(CStr(day(possibleDate)), 2, "0")
        
        Dim mmm As String
        mmm = monthNumToStringIfPossible(mm)
        
        Dim hh As String
        Dim mins As String
        Dim ss As String
        hh = padLeft(CStr(Hour(possibleDate)), 2, "0")
        mins = padLeft(CStr(Minute(possibleDate)), 2, "0")
        ss = padLeft(CStr(Second(possibleDate)), 2, "0")
        
        dateToNiceFormatIfPossible = mmm & " " & dd & ", " & yyyy & "  " & hh & ":" & mins & ":" & ss
    Else
        dateToNiceFormatIfPossible = possibleDate
    End If

End Function

Function dateToYYYYMMDD_ifPossible(possibleDate As Variant) As Variant
    atr dateToYYYYMMDD_ifPossible, dateToYYYYMMDD_ifPossible_customDelimiter(possibleDate, "", True)
End Function

Function dateToYYYYMMDD_ifPossible_flexible(possibleDate As Variant) As Variant
    atr dateToYYYYMMDD_ifPossible_flexible, dateToYYYYMMDD_ifPossible_customDelimiter(possibleDate, "", False)
End Function

Function checkIfItIsDate(possibleDate As Variant, strictVsFlexible As Boolean) As Boolean

    Dim itIsDate As Boolean
    If strictVsFlexible Then
        itIsDate = IsDate(possibleDate)
    Else
        itIsDate = cbcd(possibleDate)
    End If
    checkIfItIsDate = itIsDate

End Function

Function dateToMonthDayAndYearFormat_ifPossible_customDelimiter(possibleDate As Variant, strictVsFlexible As Boolean, delimiter As String, padMonthAndYearToTwoDigits As Boolean) As Variant

    If checkIfItIsDate(possibleDate, strictVsFlexible) Then
    
        Dim yyyy As String
        Dim monthString As String
        Dim dayString As String
        yyyy = padLeft(CStr(year(possibleDate)), 4, "0")
        monthString = CStr(month(possibleDate))
        dayString = CStr(day(possibleDate))
        
        
        Dim mm As String
        Dim dd As String
        If padMonthAndYearToTwoDigits Then
            mm = padLeft(monthString, 2, "0")
            dd = padLeft(dayString, 2, "0")
        Else
            mm = monthString
            dd = dayString
        End If
        
        dateToMonthDayAndYearFormat_ifPossible_customDelimiter = mm & delimiter & dd & delimiter & yyyy
    Else
        dateToMonthDayAndYearFormat_ifPossible_customDelimiter = possibleDate
    End If

End Function
'strictVsFlexible = true
Function dateToMMDDYYYY_ifPossible_customDelimiter(possibleDate As Variant, strictVsFlexible As Boolean, delimiter As String) As Variant
    atr dateToMMDDYYYY_ifPossible_customDelimiter, dateToMonthDayAndYearFormat_ifPossible_customDelimiter(possibleDate, strictVsFlexible, delimiter, True)
End Function

'strictVsFlexible = true
Function dateToMMDDYYYY_ifPossible(possibleDate As Variant, strictVsFlexible As Boolean) As Variant

    atr dateToMMDDYYYY_ifPossible, dateToMonthDayAndYearFormat_ifPossible_customDelimiter(possibleDate, strictVsFlexible, STANDARD_DATE_DELIMITER, True)
    
End Function

Function dateToMDYYYY_ifPossible(possibleDate As Variant, strictVsFlexible As Boolean) As Variant
    atr dateToMDYYYY_ifPossible, dateToMonthDayAndYearFormat_ifPossible_customDelimiter(possibleDate, strictVsFlexible, STANDARD_DATE_DELIMITER, False)
End Function

Function addMonths(startingDate As Date, numMonths As Long) As Date

    Dim daYear As Long
    Dim daMonth As Long
    Dim theDay As Long
    daYear = year(startingDate)
    daMonth = month(startingDate)
    theDay = day(startingDate)
    
    Dim theMonth As Long
    Dim theYear As Long
    addMonthsToMonthAndYear numMonths, daMonth, daYear, theMonth, theYear
    
    Dim roundedDownDate_orNothing As Variant
    atr roundedDownDate_orNothing, ifDateHasDayThatExceedsLastDayInMonthThenRoundToLastDayOfthatMonth(theYear, theMonth, theDay)
    
    If isNothing(roundedDownDate_orNothing) Then
        elwp "Could not add months to your date!  This is a bug."
        addMonths = startingDate
    Else
        addMonths = roundedDownDate_orNothing
    End If

End Function

Function ifDateHasDayThatExceedsLastDayInMonthThenRoundToFirstdayOfTheNextMonth(theYear As Long, theMonth As Long, theDay As Long) As Variant

    Dim candidate As Variant
    candidate = createtheDate(theMonth, theDay, theYear)
    
    Dim retValue As Variant
    If IsDate(candidate) Then
        atr retValue, candidate
    Else

        Dim roundedDownDate_orNothing As Variant
        atr roundedDownDate_orNothing, ifDateHasDayThatExceedsLastDayInMonthThenRoundToLastDayOfthatMonth(theYear, theMonth, theDay)
        
        If isNothing(roundedDownDate_orNothing) Then
            Set retValue = Nothing
        Else
            Dim roundedDwnIfNec As Date
            roundedDwnIfNec = CDate(roundedDownDate_orNothing)
            
            Dim oneMonthLater As Date
            oneMonthLater = addMonths(roundedDwnIfNec, 1)
            
            retValue = createDate(year(oneMonthLater), month(oneMonthLater), 1)
        End If
    End If
    atr ifDateHasDayThatExceedsLastDayInMonthThenRoundToFirstdayOfTheNextMonth, retValue

End Function

Function ifDateHasDayThatExceedsLastDayInMonthThenRoundUpOrDown(theYear As Long, theMonth As Long, theDay As Long, roundUpVsDown As Boolean) As Variant
    If roundUpVsDown Then
        atr ifDateHasDayThatExceedsLastDayInMonthThenRoundUpOrDown, ifDateHasDayThatExceedsLastDayInMonthThenRoundToFirstdayOfTheNextMonth(theYear, theMonth, theDay)
    Else
        atr ifDateHasDayThatExceedsLastDayInMonthThenRoundUpOrDown, ifDateHasDayThatExceedsLastDayInMonthThenRoundToLastDayOfthatMonth(theYear, theMonth, theDay)
    End If
End Function

Function createtheDate(theMonth As Variant, theDay As Variant, theYear As Variant) As Variant
    createtheDate = theMonth & "/" & theDay & "/" & theYear
End Function

Function ifDateHasDayThatExceedsLastDayInMonthThenRoundToLastDayOfthatMonth(theYear As Long, theMonth As Long, theDay As Long) As Variant
    
    Dim newDate As Variant
    newDate = createtheDate(theMonth, theDay, theYear)
    
    While (Not IsDate(newDate)) And (theDay > 1)
        theDay = theDay - 1
        newDate = theMonth & "/" & theDay & "/" & theYear
    Wend
    
    Dim roundedDownDate_orNothing As Variant
    If IsDate(newDate) Then
        roundedDownDate_orNothing = CDate(newDate)
    Else
        Set roundedDownDate_orNothing = Nothing
    End If
    
    atr ifDateHasDayThatExceedsLastDayInMonthThenRoundToLastDayOfthatMonth, roundedDownDate_orNothing

End Function

Sub addMonthsToMonthAndYear(numMonthsToAdd As Long, startingMonth As Long, startingYear As Long, ByRef out_resultMonth As Long, ByRef out_resultYear As Long)
    
    Dim monthSoFar As Long
    Dim yearSoFar As Long
    monthSoFar = startingMonth
    yearSoFar = startingYear
    
    monthSoFar = monthSoFar + numMonthsToAdd
    
    While monthSoFar <= 0
        monthSoFar = monthSoFar + 12
        yearSoFar = yearSoFar - 1
    Wend
    
    While monthSoFar > 12
        monthSoFar = monthSoFar - 12
        yearSoFar = yearSoFar + 1
    Wend
    
    out_resultMonth = monthSoFar
    out_resultYear = yearSoFar
End Sub

'JY20130221j - start - not sure if this function actually works correctly.  Don't think we use it, so I'll just comment it out for now.
'Function weAreInUKVsUSMode() As Boolean
'
'    Dim testDate As String
'    testDate = "2012/04/30" 'Note that 'testDate' cannot be anything... it must be something that in which there is no ambiguity in terms
'                            'of which field is the year, month, and day.  For example, under UK regional settings, '2012/05/01' will convert
'                            'into "January 5, 2012", while '2012/04/30' will convert into "April 30, 2012".
'
'    Dim dte As Date
'    dte = CDate(testDate)
'
'    Dim dateString As String
'    dateString = CStr(dte)
'
'
'
'
'end Function
'JY20130221j - end

Function convertToDateIfPossible(dte As Variant) As Variant
    'JY20130115a
    'If IsDate(dte) Then
    If cbcd(dte) Then
        convertToDateIfPossible = CDate(dte)
    Else
        convertToDateIfPossible = dte
    End If
End Function

Function decrementMonth(daMonth As Long) As Long
    Dim mnth As Long
    If daMonth < 1 Then
        elwp_se
        mnth = 12
    ElseIf daMonth = 1 Then
        mnth = 12
    Else
        mnth = daMonth - 1
    End If
    decrementMonth = mnth
End Function

Function incrementMonth(daMonth As Long) As Long
    Dim mnth As Long
    If daMonth > 12 Then
        elwp_se
        mnth = 12
    ElseIf daMonth = 12 Then
        mnth = 1
    Else
        mnth = daMonth + 1
    End If
    incrementMonth = mnth
End Function

Sub decrementMonthYear(ByRef out_month As Long, ByRef out_year As Long, mnth As Long, yr As Long)

    Dim newMonth As Long
    newMonth = decrementMonth(mnth)
    
    Dim newYear As Long
    
'JY20120309a - start
'    If mnth <= 1 Then
'        If mnth < 1 Then
    If newMonth >= 12 Then
        If newMonth > 12 Then
'JY20120309a - end
            elwp_se
        End If
        newYear = yr - 1
    Else
        newYear = yr
    End If
    
    out_month = newMonth
    out_year = newYear

End Sub

Sub incrementMonthYear(ByRef out_month As Long, ByRef out_year As Long, mnth As Long, yr As Long)

    Dim newMonth As Long
    newMonth = incrementMonth(mnth)
    
    Dim newYear As Long
    If newMonth <= 1 Then
        If mnth < 1 Then
            elwp_se
        End If
        newYear = yr + 1
    Else
        newYear = yr
    End If
    
    out_month = newMonth
    out_year = newYear

End Sub

Function constructYYYYMMDD_customDelimiter(year As Variant, month As Variant, day As Variant, delim As String) As String
    constructYYYYMMDD_customDelimiter = padLeft(CStr(year), 4, "0") & delim & padLeft(CStr(month), 2, "0") & delim & padLeft(CStr(day), 2, "0")
End Function

Function constructHHMMSS_customDelimiter(hours As Variant, minutes As Variant, seconds As Variant, delim As String) As String
    constructHHMMSS_customDelimiter = padLeft(CStr(hours), 2, "0") & delim & padLeft(CStr(minutes), 2, "0") & delim & padLeft(CStr(seconds), 2, "0")
End Function

Function constructYYYYMMDDHHMMSS(year As Variant, month As Variant, day As Variant, hours As Variant, mins As Variant, seconds As Variant) As String
    Dim yyyymmdd As String
    yyyymmdd = constructYYYYMMDD_customDelimiter(year, month, day, DEFAULT_YYYYMMDD_DELIMITER)
    
    Dim hhmmss As String
    hhmmss = constructHHMMSS_customDelimiter(hours, mins, seconds, DEFAULT_DELIMITER_BETWEEN_HHMM_AND_SS)
    
    constructYYYYMMDDHHMMSS = yyyymmdd & DEFAULT_DELIM_BETWEEN_DATE_AND_TIME & hhmmss
    
End Function

Function constructYYYYMMDD(year As Variant, month As Variant, day As Variant) As String
    constructYYYYMMDD = constructYYYYMMDD_customDelimiter(year, month, day, DEFAULT_YYYYMMDD_DELIMITER)
End Function

Function getAppropriateCashflowDate(desiredYear As Long, desiredMonth As Long, dayAtWhichThisCashflowIsSupposedToOccurEveryMonth As Long, ByRef mod_emsgs As Variant) As Variant
    
    Dim nextDate As Variant
    Set nextDate = Nothing
    
    Dim dayNumToTry As Long
    dayNumToTry = dayAtWhichThisCashflowIsSupposedToOccurEveryMonth
    
    Do
        nextDate = yyyymmddToDateIfPossible(constructYYYYMMDD(desiredYear, desiredMonth, dayNumToTry))
        dayNumToTry = dayNumToTry - 1
    
    'JY20130618a - I think it should be greater than or equal to
    'Loop While (Not IsDate(nextDate)) And (dayNumToTry > MIN_POSSIBLE_LAST_DAY_OF_MONTH)
    Loop While (Not IsDate(nextDate)) And (dayNumToTry >= MIN_POSSIBLE_LAST_DAY_OF_MONTH)
    
    If Not IsDate(nextDate) Then
        mod_emsgs.add "Could not convert '" & nextDate & "' to a date!"
    End If
    
    atr getAppropriateCashflowDate, nextDate
End Function

'JY20130327a - start - Deprecated.  Use 'dateTimeToDate' instead!
'Function extractDateFromDateTime(dteTime As Date) As Date
'    extractDateFromDateTime = yyyymmddToDate(dateToYYYYMMDD_ifPossible(dteTime))
'End Function
'JY20130327a - end
    
Sub parseYYYYMMDDHHMMSSIntoDateAndTime(candidate As String, ByRef out_yyyymmdd As String, ByRef out_hhmmssWithDefaultDelimiter As String, ByRef out_success As Boolean)
    
    Dim indx As Long
    indx = InStr(1, candidate, DEFAULT_DELIM_BETWEEN_DATE_AND_TIME)
    
    Dim yyyymmdd As String
    Dim hhmmss As String
    Dim success As Boolean
    If indx = 0 Then
        yyyymmdd = ""
        hhmmss = ""
        success = False
    Else
        yyyymmdd = left(candidate, indx - 1)
        hhmmss = Right(candidate, Len(candidate) - (indx - 1) - Len(DEFAULT_DELIM_BETWEEN_DATE_AND_TIME))
        success = True
    End If
    
    out_yyyymmdd = yyyymmdd
    out_hhmmssWithDefaultDelimiter = hhmmss
    out_success = success
End Sub

Function dateToMonthDayYear(dte As Date, includeComma As Boolean) As String
    Dim monthNum As Long
    Dim yr As Long
    Dim dy As Long
    monthNum = month(dte)
    yr = year(dte)
    dy = day(dte)
    
    Dim optComma As String
    If includeComma Then
        optComma = ","
    Else
        optComma = ""
    End If
    dateToMonthDayYear = monthNumToThreeLetterAbbreviation(monthNum) & " " & padLeft(CStr(dy), 2, "0") & optComma & " " & padLeft(CStr(yr), 4, "0")
    
End Function

'Based on Chris Obara's function
Function monthNumToThreeLetterAbbreviation(mon As Long) As String

    Select Case (mon)
    
    Case 1
        monthNumToThreeLetterAbbreviation = "Jan"
    Case 2
        monthNumToThreeLetterAbbreviation = "Feb"
    Case 3
        monthNumToThreeLetterAbbreviation = "Mar"
    Case 4
        monthNumToThreeLetterAbbreviation = "Apr"
    Case 5
        monthNumToThreeLetterAbbreviation = "May"
    Case 6
        monthNumToThreeLetterAbbreviation = "Jun"
    Case 7
        monthNumToThreeLetterAbbreviation = "Jul"
    Case 8
        monthNumToThreeLetterAbbreviation = "Aug"
    Case 9
        monthNumToThreeLetterAbbreviation = "Sep"
    Case 10
        monthNumToThreeLetterAbbreviation = "Oct"
    Case 11
        monthNumToThreeLetterAbbreviation = "Nov"
    Case 12
        monthNumToThreeLetterAbbreviation = "Dec"
    Case Else
        monthNumToThreeLetterAbbreviation = "???"
    End Select
    
End Function

Function createDateWrapper(yr As Long, mnth As Long, dy As Long) As JYUT_Date
    Dim obj As JYUT_Date
    Set obj = New JYUT_Date
    With obj
        .yr = yr
        .mnth = mnth
        .dy = dy
    End With
    Set createDateWrapper = obj
End Function

Attribute VB_Name = "JYUT_DelayedExecution"
Option Explicit

Dim listOf__cmd_expectedTime As Collection

Public outstandingExecuteLaters As Long

Public Const DEFAULT_FALLBACK_SECONDS As Long = 10
Public Const NAME_OF_TIME_TO_EXECUTE_FUNCTION As String = "timeToExecute"

Sub executeLater(cmd As String, desc As String, timeOffset As Variant)
    Dim curTime As Variant
    curTime = Now()
    
    Dim expectedTime As Variant
    expectedTime = curTime + timeOffset
    
    executeAtCertainTime cmd, desc, expectedTime
End Sub

Sub executeAtCertainTime(cmd As String, desc As String, expectedTime As Variant)

    ilg "It is now " & Now() & ".  We plan to " & desc & " at: " & expectedTime
    
    If isNothing(listOf__cmd_expectedTime) Or IsEmpty(listOf__cmd_expectedTime) Then
        Set listOf__cmd_expectedTime = New Collection
    End If
    
    outstandingExecuteLaters = outstandingExecuteLaters + 1
    listOf__cmd_expectedTime.add Array(cmd, expectedTime)
    Application.OnTime expectedTime, NAME_OF_TIME_TO_EXECUTE_FUNCTION

End Sub

Sub timeToExecute()

    outstandingExecuteLaters = outstandingExecuteLaters - 1
    
    If outstandingExecuteLaters < 0 Then
        'elg "Somehow we have a negative number of outstanding delayed executes!"
        outstandingExecuteLaters = 0
    End If
    
    
    Dim theList As Collection
    Set theList = listOf__cmd_expectedTime
    
    If isNothing(theList) Or IsEmpty(theList) Then
        'DO NOTHING
    Else

        Dim cmdsToExecute As Collection
        Set cmdsToExecute = removeItemsAssociatedWithTimeThatHasPast(theList)
    
        Dim c As Long
        For c = 1 To cmdsToExecute.count
            Dim cmd As String
            cmd = cmdsToExecute.item(c)
            
            applicationRun cmd
        Next
        
        If theList.count = 0 Then
            ssbm Now() & " --> All outstanding messages have been accounted for."
        ElseIf outstandingExecuteLaters = 0 And theList.count <> 0 Then
            
            Dim soonestExpectedTime As Variant
            soonestExpectedTime = Now() + getTimeOffsetImpliedBySecondsString(DEFAULT_FALLBACK_SECONDS, "default fallback")
            
            Dim foundSoonest As Boolean
            foundSoonest = False
            
            Dim dd As Long
            For dd = 1 To theList.count
                Dim daExpectedTime As Variant
                daExpectedTime = rlai(theList.item(dd), 2)
                
                If soonestExpectedTime > daExpectedTime Then
                    soonestExpectedTime = daExpectedTime
                    foundSoonest = True
                End If
                
                
                
                
            Next
            
            Dim optSuffix As String
            If foundSoonest Then
                optSuffix = " (The time of the unaccounted-for message)"
            Else
                optSuffix = ""
            End If
            'Always make sure we have a thread running, when there are outstanding requests
            ssbm Now() & " --> " & theList.count & " requests unaccounted for, so we will check them out at: " & CDate(soonestExpectedTime) & optSuffix
            outstandingExecuteLaters = outstandingExecuteLaters + 1
            Application.OnTime soonestExpectedTime, NAME_OF_TIME_TO_EXECUTE_FUNCTION
        End If
        
        
        
    End If
End Sub

Sub cancelAllTheOutstandingTimerEvents()
    cancelAllOutstandingTimerEvents
    GlobalDataWriterReminderService_shutOff
    
End Sub

Sub cancelAllOutstandingTimerEvents()
    
    If isNothing(listOf__cmd_expectedTime) Then
        'DO NOTHING
    Else
        Dim listCopy As Collection
        Set listCopy = copyCollection(listOf__cmd_expectedTime)
        
        While listCopy.count <> 0
            Dim cmd_expectedTime As Variant
            cmd_expectedTime = listCopy.item(1)
            
            listCopy.remove 1
            
            Dim cmd As String
            Dim expectedTime As Variant
            cmd = rlai(cmd_expectedTime, 1)
            expectedTime = rlai(cmd_expectedTime, 2)
            
            cancelTimerEvent NAME_OF_TIME_TO_EXECUTE_FUNCTION, expectedTime
        Wend
        
    End If
    outstandingExecuteLaters = 0
End Sub

Function removeItemsAssociatedWithTimeThatHasPast(ByRef mod____listOf__item_time As Collection) As Collection
    
    Dim numWriters As Long
    numWriters = mod____listOf__item_time.count
    
    Dim indexesToRemove As Collection
    Set indexesToRemove = New Collection
    
    Dim qualifiedItems As Collection
    Set qualifiedItems = New Collection

    Dim nextReminderShouldOccurAt As Variant
    Set nextReminderShouldOccurAt = Nothing
    
    'Identify them
    
    Dim daTime As Variant
    daTime = Now()
    
    Dim c As Long
    For c = 1 To numWriters
        
        Dim theItem_associatedTime As Variant
        theItem_associatedTime = mod____listOf__item_time.item(c)
        
        Dim theItem As Variant
        Dim timeReminderShouldBeSent As Variant
        atr theItem, rlai(theItem_associatedTime, 1)
        timeReminderShouldBeSent = rlai(theItem_associatedTime, 2)
        
        If daTime >= timeReminderShouldBeSent Then
            indexesToRemove.add c
            qualifiedItems.add theItem
        Else
            'DO NOTHING
        End If
        
    Next
    
    'Claim them
    Dim d As Long
    For d = indexesToRemove.count To 1 Step -1
        mod____listOf__item_time.remove indexesToRemove.item(d)
    Next
    
    Set removeItemsAssociatedWithTimeThatHasPast = qualifiedItems
End Function

Sub cancelTimerEvent(cmd As String, expectedTime As Variant)

On Error GoTo ehs

    ilg "Attempting to cancel '" & cmd & "', scheduled for '" & expectedTime & "' (right now it is '" & Now() & "')."
    Application.OnTime earliesttime:=expectedTime, procedure:=cmd, schedule:=False
    ilg "Cancellation successful!"

GoTo ehe
ehs:
    elg "Could not cancel '" & cmd & "' at '" & expectedTime & "'.  Perhaps it has already passed.  Msg=" & Err.description
ehe:
On Error GoTo 0


End Sub
Attribute VB_Name = "JYUT_Dictionary"
Option Explicit

Public Const SHLD_CAST_KEY_TO_STRING_WHEN_PERFORMING_DICT_SERIALIZATION As Boolean = False

Public Const TO_STRING_COLLECTION_DELIMITER As String = "|"
Public Const TO_STRING_COLLECTION_ESC_CHAR As String = "\"

Function dictionariesAreEqual_nullsAreAcceptedAsParameters(dict1 As Dictionary, dict2 As Dictionary) As Boolean

    If isNothing(dict1) Then
        dictionariesAreEqual_nullsAreAcceptedAsParameters = isNothing(dict2)
    ElseIf isNothing(dict2) Then
        dictionariesAreEqual_nullsAreAcceptedAsParameters = False
    Else
        dictionariesAreEqual_nullsAreAcceptedAsParameters = dictionariesAreEqual(dict1, dict2)
    End If

End Function

Function dictionariesAreEqual(dict1 As Dictionary, dict2 As Dictionary) As Boolean

    Dim keys1 As Variant
    Dim keys2 As Variant
    keys1 = dict1.keys
    keys2 = dict2.keys
    
    Dim keySet1 As JYCORE_Set
    Dim keySet2 As JYCORE_Set
    Set keySet1 = collectionToSet(arrayToCollection(keys1))
    Set keySet2 = collectionToSet(arrayToCollection(keys2))
    
    Dim eq As Boolean
    If Not keySet1.equalsSet(keySet2) Then
        eq = False
    Else
        Dim masterKeys As Variant
        masterKeys = keys1
        
        Dim lwr As Long
        Dim upr As Long
        glaubs masterKeys, lwr, upr
        
        Dim allValuesEqualSoFar As Boolean
        allValuesEqualSoFar = True
        
        Dim c As Long
        c = lwr
        While (allValuesEqualSoFar) And (c <= upr)
            
            Dim curKey As Variant
            curKey = masterKeys(c)
            
            If dict1.exists(curKey) And dict2.exists(curKey) Then
            
                Dim val1 As Variant
                Dim val2 As Variant
                val1 = vfd(dict1, curKey, True)
                val2 = vfd(dict2, curKey, True)
                
                If valuesAreEqual(val1, val2) Then
                    'DO NOTHING
                Else
                    allValuesEqualSoFar = False
                End If
            
            Else
                allValuesEqualSoFar = False
            End If
            
            
            c = c + 1
        Wend
        
        eq = allValuesEqualSoFar
    End If
    
    dictionariesAreEqual = eq

End Function

Function addListOfKeysAndValuesToDictionary(ByRef mod_dict As Dictionary, listOf_keyAndValue As Collection) As JYCORE_Set

    Dim setOfOverriddenKeys As JYCORE_Set
    Set setOfOverriddenKeys = New JYCORE_Set
    
    Dim c As Long
    For c = 1 To listOf_keyAndValue.count
        
        Dim keyAndValue As Variant
        keyAndValue = listOf_keyAndValue.item(c)
        
        Dim theKey As Variant
        Dim theValue As Variant
        theKey = rlai(keyAndValue, 1)
        theValue = rlai(keyAndValue, 2)
        
        Dim overriddenValueOrNothing As Variant
        atr overriddenValueOrNothing, atd(mod_dict, theKey, theValue)
        
        If Not isNothing(overriddenValueOrNothing) Then
            setOfOverriddenKeys.add theKey
        End If
        
    Next
    Set addListOfKeysAndValuesToDictionary = setOfOverriddenKeys

End Function

Sub getKeysAndValues(dict As Dictionary, ByRef out_keys As Variant, ByRef out_values As Variant, ByRef out_lowerBound As Long, ByRef out_upperBound As Long)
    
    Dim keys As Variant
    keys = dict.keys()
    
    Dim lower As Long
    Dim upper As Long
    glaubs keys, lower, upper
    
    Dim values As Variant
    If upper < lower Then
        If dict.count <> 0 Then
            elwp_se
        End If
        values = createEmptyArray()
    Else
        ReDim values(lower To upper)
    End If
    
    Dim c As Long
    For c = lower To upper
        Dim key As Variant
        atr key, keys(c)
        
        Dim theVal As Variant
        theVal = vfd(dict, key, True)
        
        values(c) = theVal
    Next
    
    out_keys = keys
    out_values = values
    out_lowerBound = lower
    out_upperBound = upper
End Sub

Sub convertDictToListsOfKeyAndValue_whereKeysCanAppearMoreThanOnceWhenValuesAreACollection(ByRef out_keys As Collection, ByRef out_values As Collection, dict As Dictionary)
    
    Dim finalKeys As Collection
    Dim finalValues As Collection
    Set finalKeys = New Collection
    Set finalValues = New Collection
    
    Dim keys As Variant
    keys = dict.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs keys, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim thisKey As String
        thisKey = keys(c)
        
        Dim list As Collection
        Set list = vfd(dict, thisKey, True)
        
        Dim d As Long
        For d = 1 To list.count
            Dim thisValue As String
            thisValue = list.item(d)
            
            finalKeys.add thisKey
            finalValues.add thisValue
        Next
    Next
    
    Set out_keys = finalKeys
    Set out_values = finalValues
End Sub

Sub convertDictToListOfKeysAndListOfValues(ByRef out_keys As Collection, ByRef out_values As Collection, dict As Dictionary, ifValueIsArrayThenBreakIntoTopmostArray As Boolean)
    
    Dim listOfKeyAndValue As Collection
    Set listOfKeyAndValue = convertDictToListOfKeyAndValue(dict, ifValueIsArrayThenBreakIntoTopmostArray, True)
    
    Dim keys_values As Collection
    Set keys_values = sciloar(True, listOfKeyAndValue)
    
    Set out_keys = keys_values.item(1)
    Set out_values = keys_values.item(2)
    
End Sub

Function convertDictToListOfKeyAndValue(dict As Dictionary, ifValueIsArrayThenBreakIntoTopmostArray As Boolean, returnCollectionVsArray As Boolean) As Collection
    
    If isNothing(dict) Then
        elwp "Please pass in a dictionary!"
        Set convertDictToListOfKeyAndValue = Nothing
    Else
        
        Dim keys As Variant
        keys = dict.keys()
        Dim lower As Long
        Dim upper As Long
        lower = LBound(keys, 1)
        upper = UBound(keys, 1)
        
        Dim listOf_keyAndValue As Variant
        If returnCollectionVsArray Then
            Set listOf_keyAndValue = New Collection
        Else
            ReDim listOf_keyAndValue(lower To upper)
        End If
        
        Dim c As Long
        For c = lower To upper
            Dim curKey As Variant
            curKey = keys(c)
            
            Dim curVal As Variant
            atr curVal, dict.item(curKey)
            
            Dim itemToAdd As Variant
            If IsArray(curVal) And ifValueIsArrayThenBreakIntoTopmostArray Then
            
                Dim numElements As Long
                numElements = dimSize(curVal, 1)
                
                Dim arrayRow As Variant
                ReDim arrayRow(0 To numElements)
                
                arrayRow(0) = curKey
                
                Dim xx As Long
                For xx = 1 To numElements
                    atr arrayRow(xx), rlai(curVal, xx)
                Next
                
                itemToAdd = arrayRow
            Else
                itemToAdd = Array(curKey, curVal)
            End If
            
            If returnCollectionVsArray Then
                listOf_keyAndValue.add itemToAdd
            Else
                atr listOf_keyAndValue(c), itemToAdd
            End If
            
        Next
        
        atr convertDictToListOfKeyAndValue, listOf_keyAndValue
    End If
End Function

Function convertDictToListOfNVPStrings(dict As Dictionary, delimiter As String) As Collection

    Dim listOfArrayRows As Collection
    Set listOfArrayRows = sciloar(True, convertDictToListOfKeyAndValue(dict, False, True))
    
    If listOfArrayRows.count = 0 Then
        Set convertDictToListOfNVPStrings = listOfArrayRows
    Else
        Set convertDictToListOfNVPStrings = arrayToCollection(concatenateCollectionElements(kta(listOfArrayRows), delimiter, False))
    End If

    
End Function


Function copyDictionary_viaNestedDictionaryPaths(dict As Dictionary) As Dictionary

    Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
    assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True '<-- true because the nested paths are obtained from "getNestedDictionaryPaths"
    
    Dim nestedPaths As Collection
    Set nestedPaths = getNestedDictionaryPaths(dict, False)
    
    Dim newDict As Dictionary
    Set newDict = New Dictionary
    
    Dim c As Long
    For c = 1 To nestedPaths.count
        Dim nestedPath As Variant
        nestedPath = nestedPaths.item(c)
        
        Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
        shouldCastKeyToStringIfHelpsFindValue = False
        
        Dim curVal As Variant
        atr curVal, getValueForNestedDictionaryPath(dict, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
        
        setValueForNestedDictionaryPath newDict, nestedPath, curVal, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
    Next
    
    Set copyDictionary_viaNestedDictionaryPaths = newDict

End Function

Function copyDictionary(dict As Dictionary) As Dictionary
    If isNothing(dict) Then
        elwp "Please pass in a Dictionary!"
        Set copyDictionary = Nothing
    Else
        Dim keys As Variant
        keys = dict.keys()
        
        Dim lower As Long
        Dim upper As Long
        lower = LBound(keys, 1)
        upper = UBound(keys, 1)
        
        Dim newDict As Dictionary
        Set newDict = New Dictionary
        
        Dim c As Long
        For c = lower To upper
            Dim curKey As Variant
            curKey = keys(c)
            
            Dim curVal As Variant
            atr curVal, dict.item(curKey)
            
            newDict.add curKey, curVal
        Next
        
        Set copyDictionary = newDict
    End If
End Function


'shouldCastKeyToStringIfHelpsFindValue = false
'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = false
Function getValueForNestedDictionaryPath(dict As Dictionary, nestedPath As Variant, shouldCastKeyToStringIfHelpsFindValue As Boolean, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Variant
    atr getValueForNestedDictionaryPath, nestedPathExistsOrGetValueForNestedDictionaryPath(dict, nestedPath, False, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
End Function

Function nestedPathExists(dict As Dictionary, nestedPath As Variant, shouldCastKeyToStringIfHelpsFindValue As Boolean, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Boolean
    atr nestedPathExists, nestedPathExistsOrGetValueForNestedDictionaryPath(dict, nestedPath, True, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
End Function


'shouldCastKeyToStringIfHelpsFindValue = false
'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = false
Function nestedPathExistsOrGetValueForNestedDictionaryPath(dict As Dictionary, nestedPath As Variant, nestedPathVersusGetValue As Boolean, shouldCastKeyToStringIfHelpsFindValue As Boolean, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Variant

    If isNothing(dict) Then
        elwp "Please pass in a Dictionary!"
    End If

    Dim curNode As Dictionary
    Dim overwritten As Variant
    
    'JY20120315a
    'Set curNode = findFinalNodeForNestedDictionaryPath(dict, nestedPath, True, overwritten,shouldCastKeyToStringIfHelpsFindValue,assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    Set curNode = findFinalNodeForNestedDictionaryPath(dict, nestedPath, False, overwritten, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    
    If isNothing(curNode) Then
        If nestedPathVersusGetValue Then
            nestedPathExistsOrGetValueForNestedDictionaryPath = False
        Else
            Set nestedPathExistsOrGetValueForNestedDictionaryPath = Nothing
        End If
    Else
    
        Dim lastKey As Variant
        atr lastKey, nestedPath(UBound(nestedPath, 1))
    
        Dim adjustedLastKeyOrNothingIfDoesNotExist As Variant
        If curNode.exists(lastKey) Then
            atr adjustedLastKeyOrNothingIfDoesNotExist, lastKey
        Else
            If (shouldCastKeyToStringIfHelpsFindValue) And conversionToStringIsAppropriateInContextOfDictionary(lastKey) Then
            
                If curNode.exists(CStr(lastKey)) Then
                    atr adjustedLastKeyOrNothingIfDoesNotExist, CStr(lastKey)
                Else
                    Set adjustedLastKeyOrNothingIfDoesNotExist = Nothing
                End If
            Else
                Set adjustedLastKeyOrNothingIfDoesNotExist = Nothing
            End If
        End If
        
        Dim pathExists As Boolean
        pathExists = (Not isNothing(adjustedLastKeyOrNothingIfDoesNotExist))
        
        If nestedPathVersusGetValue Then
            nestedPathExistsOrGetValueForNestedDictionaryPath = pathExists
        Else
            If pathExists Then
                atr nestedPathExistsOrGetValueForNestedDictionaryPath, curNode.item(adjustedLastKeyOrNothingIfDoesNotExist)
            Else
                Set nestedPathExistsOrGetValueForNestedDictionaryPath = Nothing
            End If
        End If
    End If
End Function


''shouldCastKeyToStringIfHelpsFindValue = false
''depthOfLeafNodeOrNothingIfWeDoNotKnow = nothing
'Function assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree(dict As Dictionary, nestedPath As Variant, shouldCastKeyToStringIfHelpsFindValue As Boolean, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Boolean
'    atr nestedPathExists, nestedPathExistsOrGetValueForNestedDictionaryPath(dict, nestedPath, True, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
'End Function

'shouldCastKeyToStringIfHelpsFindValue = false
'depthOfLeafNodeorNothingIfWeDoNotKnow = nothing
'JY20130326f - start - try to speed this up, since the isDictionary command seems to be taking significant time when this method is called in a long loop
'Function findFinalNodeForNestedDictionaryPath(ByRef dict As Dictionary, nestedPath As Variant, ensureExistance As Boolean, ByRef out_overwritten As Variant, shouldCastKeyToStringIfHelpsFindValue_and_shouldCastKeyToStringWhenPossibleDuringSetting As Boolean) As Dictionary
Function findFinalNodeForNestedDictionaryPath(ByRef dict As Dictionary, nestedPath As Variant, ensureExistance As Boolean, ByRef out_overwritten As Variant, shouldCastKeyToStringIfHelpsFindValue_and_shouldCastKeyToStringWhenPossibleDuringSetting As Boolean, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Dictionary

    Dim depthOfLeafNodeOrNothingIfWeDoNotKnow As Variant
    If assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree Then
        depthOfLeafNodeOrNothingIfWeDoNotKnow = dimSize(nestedPath, 1)
    Else
        Set depthOfLeafNodeOrNothingIfWeDoNotKnow = Nothing
    End If

'JY20130326f - end
    Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
    Dim shouldCastKeyToStringWhenPossibleDuringSetting As Boolean
    shouldCastKeyToStringIfHelpsFindValue = shouldCastKeyToStringIfHelpsFindValue_and_shouldCastKeyToStringWhenPossibleDuringSetting
    shouldCastKeyToStringWhenPossibleDuringSetting = shouldCastKeyToStringIfHelpsFindValue_and_shouldCastKeyToStringWhenPossibleDuringSetting
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(nestedPath, 1)
    upper = UBound(nestedPath, 1)
    
    Dim overwritten As Dictionary
    Set overwritten = Nothing
    
    Dim curNode As Dictionary
    Set curNode = dict
    
    Dim c As Long
    c = lower
    While (c <= upper - 1) And (Not isNothing(curNode))
    
        'JY20130326f - start - try to speed this up, since the isDictionary command seems to be taking significant time when this method is called in a long loop
        Dim curDepth As Long
        curDepth = c - lower + 1
        'JY20130326f - end
    
        Dim origCurKey As Variant
        origCurKey = nestedPath(c)
        
        Dim curKey_orNothingIfNotFound As Variant
        If curNode.exists(origCurKey) Then
            atr curKey_orNothingIfNotFound, origCurKey
        ElseIf shouldCastKeyToStringIfHelpsFindValue And conversionToStringIsAppropriateInContextOfDictionary(origCurKey) Then
            If curNode.exists(CStr(origCurKey)) Then
                curKey_orNothingIfNotFound = CStr(origCurKey)
            Else
                Set curKey_orNothingIfNotFound = Nothing
            End If
        Else
            Set curKey_orNothingIfNotFound = Nothing
        End If
            
        
        
        Dim potentialNode As Variant
        If Not isNothing(curKey_orNothingIfNotFound) Then
            atr potentialNode, curNode.item(curKey_orNothingIfNotFound)
            
            Dim weAreAtInterimNode As Boolean
            'JY20130326f - start - try to speed this up, since the isDictionary command seems to be taking significant time when this method is called in a long loop
            'If isDictionary(potentialNode) Then
            If Not isNothing(depthOfLeafNodeOrNothingIfWeDoNotKnow) Then
                'We already know the depth of the leaf node, and so we don't have to perofrm our isDictionary check.
                If Not isInteger(depthOfLeafNodeOrNothingIfWeDoNotKnow) Then
                    elwp "You were supposed to pass in an integer, if anything at all!"
                End If
                If CLng(depthOfLeafNodeOrNothingIfWeDoNotKnow) > curDepth Then
                    weAreAtInterimNode = True
                Else
                    If CLng(depthOfLeafNodeOrNothingIfWeDoNotKnow) < curDepth Then
                        elwp "Our assumptions are wrong!  We are beyond the assumed depth of the tree!"
                    End If
                    weAreAtInterimNode = False
                End If
            ElseIf isDictionary(potentialNode) Then
            'JY20130326f - end
            
            
                weAreAtInterimNode = True
            Else
                weAreAtInterimNode = False
            End If
            
            If weAreAtInterimNode Then
                Set curNode = potentialNode
            Else
                If Not isNothing(overwritten) Then
                    elwp_se
                End If
                
                If ensureExistance Then
                    atr overwritten, potentialNode
                    Set potentialNode = New Dictionary
                    curNode.add curKey_orNothingIfNotFound, potentialNode
                    
                    Set curNode = potentialNode
                Else
                    Set curNode = Nothing
                End If
            End If
        Else
            If ensureExistance Then
                Set potentialNode = New Dictionary
                
                Dim curKeyToSet As Variant
                If shouldCastKeyToStringWhenPossibleDuringSetting And conversionToStringIsAppropriateInContextOfDictionary(origCurKey) Then
                    curKeyToSet = CStr(origCurKey)
                Else
                    atr curKeyToSet, origCurKey
                End If
                
                curNode.add curKeyToSet, potentialNode
                Set curNode = potentialNode
            Else
                Set curNode = Nothing
            End If
        End If
        c = c + 1
    Wend
    
    Set out_overwritten = overwritten
    Set findFinalNodeForNestedDictionaryPath = curNode
End Function

'shouldCastKeyToStringIfHelpsFindValue = false
'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = false
Function removeValueForNestedDictionaryPath(ByRef mod_dict As Dictionary, nestedPath As Variant, shouldCastKeyToStringIfHelpsFindValue As Boolean, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Variant
    If Not nestedPathExists(mod_dict, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree) Then
        Set removeValueForNestedDictionaryPath = Nothing
    Else
    
        Dim maxLevelsDeep_orNothingForNoMax As Long
        maxLevelsDeep_orNothingForNoMax = szof(nestedPath)
    
        Dim nestedPaths As Collection
        Set nestedPaths = getNestedDictionaryPaths_customMaxLevels(mod_dict, False, maxLevelsDeep_orNothingForNoMax)
        
        Dim newDict As Dictionary
        Set newDict = New Dictionary
        
        Dim numFoundPaths As Long
        numFoundPaths = 0
        
        Dim foundValue As Variant
        Set foundValue = Nothing
        
        Dim c As Long
        For c = 1 To nestedPaths.count
            Dim curPath As Variant
            curPath = nestedPaths.item(c)
            
            
            Dim daVal As Variant
            atr daVal, getValueForNestedDictionaryPath(mod_dict, curPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
            
            If arraysAreEqual_ignoreBoundMismatches(nestedPath, curPath) Then
            
                atr foundValue, daVal
                numFoundPaths = numFoundPaths + 1
                
            Else
            
                'ilg arrayToString(nestedPath, "|", "") & " <> " & arrayToString(curPath, "|", "")
                setValueForNestedDictionaryPath newDict, curPath, daVal, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
            End If
        Next
        
        mod_dict.RemoveAll
        addDictionaryToDictionary mod_dict, newDict
        
        If numFoundPaths <> 1 Then
            elwp_se
        End If
        
        atr removeValueForNestedDictionaryPath, foundValue
        
    End If
    
End Function

'shouldCastKeysToStringsWhenPossible = false
'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = false
Function setValueForNestedDictionaryPath(ByRef mod_dict As Dictionary, nestedPath As Variant, value As Variant, shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue As Boolean, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Variant
    
    'At this point, curNode points to the place we want to add our info.
    
    Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
    Dim shouldCastKeysToStringsWhenPossible As Boolean
    shouldCastKeyToStringIfHelpsFindValue = shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue
    shouldCastKeysToStringsWhenPossible = shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue
    
    
    Dim curNode As Dictionary
    Dim overwritten As Variant
    Set curNode = findFinalNodeForNestedDictionaryPath(mod_dict, nestedPath, True, overwritten, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    
    If isNothing(curNode) Then
        elwp_se
    End If
    
    Dim finalKey As Variant
    atr finalKey, nestedPath(UBound(nestedPath, 1))
    
    If Not IsObject(finalKey) And Not IsDate(finalKey) And shouldCastKeysToStringsWhenPossible Then
        finalKey = CStr(finalKey)
    End If
    
    If curNode.exists(finalKey) Then
        If Not isNothing(overwritten) Then
            elwp_se
        End If
        atr overwritten, curNode.item(finalKey)
        curNode.remove (finalKey)
    End If
    curNode.add finalKey, value

    atr setValueForNestedDictionaryPath, overwritten
    
End Function
Function containsNestedDictionaryPath(dict As Dictionary, nestedPath As Variant)
    
    Dim valSoFar As Variant
    Set valSoFar = dict
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(nestedPath, 1)
    upper = UBound(nestedPath, 1)
    
    Dim c As Long
    c = lower
    
    Dim ourTravelPathWasStopped As Boolean
    ourTravelPathWasStopped = False
    
    While (c <= upper) And (Not ourTravelPathWasStopped)
        Dim nextKey As Variant
        nextKey = nestedPath(c)
        
        If isDictionary(valSoFar) Then
            Dim thisDict As Dictionary
            Set thisDict = valSoFar
            
            If thisDict.exists(nextKey) Then
                atr valSoFar, thisDict.item(nextKey)
            Else
                ourTravelPathWasStopped = True
            End If
        
        Else
            ourTravelPathWasStopped = True
        End If
        
        c = c + 1
    Wend
    
    containsNestedDictionaryPath = (Not ourTravelPathWasStopped)
    
End Function

Function getNestedDictionaryPaths(dict As Dictionary, sortKeys As Boolean) As Collection

    Set getNestedDictionaryPaths = getNestedDictionaryPaths_customMaxLevels(dict, sortKeys, Nothing)

End Function

'assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeInTheTree = false
Function getValuesForNestedDictionaryPaths(dict As Dictionary, paths As Collection, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree As Boolean) As Collection
    
    Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
    shouldCastKeyToStringIfHelpsFindValue = False
    
    Dim listOfValues As Collection
    Set listOfValues = New Collection
    
    Dim y As Long
    For y = 1 To paths.count
        Dim nestedPath As Variant
        nestedPath = paths.item(y)
        
        Dim listOfDataLines As Collection
        Set listOfDataLines = getValueForNestedDictionaryPath(dict, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree)
        
        listOfValues.add listOfDataLines
    Next
    
    Set getValuesForNestedDictionaryPaths = listOfValues
End Function


Function getNestedDictionaryPaths_customMaxLevels(dict As Dictionary, sortKeys As Boolean, maxLevelsDeep_orNothingForNoMax As Variant) As Collection
    Dim coll As Collection
    Set coll = New Collection
    
    addPathsRecursively dict, coll, New Collection, sortKeys, maxLevelsDeep_orNothingForNoMax, 1
    
    Set getNestedDictionaryPaths_customMaxLevels = coll
End Function

Sub addPathsRecursively(node As Dictionary, ByRef mod_paths As Collection, ByRef mod_pathToCurrentNode As Collection, sortKeys As Boolean, maxLevelsDeep_orNothingForNoMax As Variant, curLevel As Long)

    Dim daKys As Variant
    daKys = node.keys()
    
    Dim kys As Variant
    If sortKeys Then
        kys = sortArray(daKys)
    Else
        kys = daKys
    End If
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(kys, 1)
    upper = UBound(kys, 1)
    
    Dim c As Long
    For c = lower To upper
        Dim curKey As Variant
        atr curKey, kys(c)
        
        Dim curVal As Variant
        atr curVal, node.item(curKey)
        
        mod_pathToCurrentNode.add curKey
        
        Dim weWouldNotBreachLimit As Boolean
        If isNothing(maxLevelsDeep_orNothingForNoMax) Then
            weWouldNotBreachLimit = True
        ElseIf curLevel < maxLevelsDeep_orNothingForNoMax Then
            weWouldNotBreachLimit = True
        Else
            weWouldNotBreachLimit = False
        End If
        
        If isDictionary(curVal) And weWouldNotBreachLimit Then
            addPathsRecursively castToDictionary(curVal), mod_paths, mod_pathToCurrentNode, sortKeys, maxLevelsDeep_orNothingForNoMax, curLevel + 1
        Else
            mod_paths.add kta(mod_pathToCurrentNode)
        End If
        
        mod_pathToCurrentNode.remove mod_pathToCurrentNode.count
        
    Next

End Sub

'variant type is used in case we pass in a JYUT_AdvancedDictionary
Function getDictionaryValues(dict As Variant) As Collection
    
    Dim dictKeys As Variant
    dictKeys = dict.keys()
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(dictKeys, 1)
    upper = UBound(dictKeys, 1)
    
    Dim dictValues As Collection
    Set dictValues = New Collection
    
    Dim dd As Long
    For dd = lower To upper
        'JY20121205b
        'Dim theKey As String
        Dim theKey As Variant
        
        theKey = dictKeys(dd)
        
        Dim theVal As Variant
        atr theVal, dict.item(theKey)
        
        dictValues.add theVal
    Next
    
    Set getDictionaryValues = dictValues
    
End Function

Function swapKeysAndValues(dict As Dictionary) As Dictionary
    
    Dim keys As Variant
    keys = dict.keys()
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(keys, 1)
    upper = UBound(keys, 1)
    
    
    Dim newDict As Dictionary
    Set newDict = New Dictionary
    
    Dim c As Long
    For c = lower To upper
        Dim thisKey As Variant
        thisKey = keys(c)
        
        Dim thisVal As Variant
        atr thisVal, dict.item(thisKey)
        
        If newDict.exists(thisVal) Then
            elwp "Duplicate encountered!"
        Else
            newDict.add thisVal, thisKey
        End If
        
    Next
    
    Set swapKeysAndValues = newDict
    
End Function

'relativeIndxVersusAbsolute = true
Function replaceDictionaryValueArrayWithValueFromCertainOffsetInThatArray(dict As Dictionary, whichIndx As Long, relativeIndxVersusAbsolute As Boolean) As Dictionary

    Dim newDict As Dictionary
    Set newDict = New Dictionary
    
    Dim calculatedFieldByFieldID As Dictionary
    Set calculatedFieldByFieldID = New Dictionary
    
    Dim fieldIDs As Variant
    fieldIDs = dict.keys()
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(fieldIDs, 1)
    upper = UBound(fieldIDs, 1)
    
    Dim c As Long
    For c = lower To upper
    
        Dim fieldID As String
        fieldID = fieldIDs(c)
    
        Dim theArray As Variant
        theArray = dict.item(fieldID)
        
        Dim calculatedField As Variant
        If relativeIndxVersusAbsolute Then
            atr calculatedField, rlai(theArray, whichIndx)
        Else
            atr calculatedField, theArray(whichIndx)
        End If
        
        newDict.add fieldID, calculatedField
        
    Next
    
    Set replaceDictionaryValueArrayWithValueFromCertainOffsetInThatArray = newDict
    
End Function


'assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeInTheTree = false
Function removeEntriesFromDictionary_byNestedPath(ByRef mod_dict As Dictionary, nestedPaths As Collection, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Collection

    Dim removedValues As Collection
    Set removedValues = New Collection
    
    Dim c As Long
    For c = 1 To nestedPaths.count
        Dim nestedPath As Variant
        atr nestedPath, nestedPaths.item(c)
        
        Dim theVal As Variant
        atr theVal, removeValueForNestedDictionaryPath(mod_dict, nestedPath, False, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
        
        removedValues.add theVal
    Next
    Set removeEntriesFromDictionary_byNestedPath = removedValues


End Function

Function removeEntriesFromDictionary(ByRef mod_dict As Dictionary, keys As Collection) As Collection
    
    Dim removedValues As Collection
    Set removedValues = New Collection
    
    Dim c As Long
    For c = 1 To keys.count
        Dim key As Variant
        key = keys.item(c)
        
        Dim theVal As Variant
        atr theVal, rfd(mod_dict, key)
        
        removedValues.add theVal
    Next
    Set removeEntriesFromDictionary = removedValues
    
End Function


'rfd stands for "removeFromDictionary"
'mod_dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Function rfd(ByRef mod_dict As Variant, key As Variant) As Variant
    
    Dim theVal As Variant
    If mod_dict.exists(key) Then
        atr theVal, vfd(mod_dict, key, True)
        mod_dict.remove key
    Else
        Set theVal = Nothing
    End If
    
    atr rfd, theVal
End Function

'JY20120905a - start - Why are we passing out the same thing we are passing in?
'Function valuesFromDictionary(dict As Dictionary, fieldNames As Collection, popupMsgIfNotThere As Boolean, ByRef out_correspondingFieldNames As Collection) As Collection
Function valuesFromDictionary(dict As Dictionary, fieldNames As Collection, popupMsgIfNotThere As Boolean) As Collection
'JY20120905a - end

    'JY20120905a - start - Why are we passing out the same thing we are passing in?
    'Dim correspondingFieldNames As Collection
    'Set correspondingFieldNames = New Collection
    'JY20120905a - end

    Dim list As Collection
    Set list = New Collection
    
    Dim c As Long
    For c = 1 To fieldNames.count
        Dim fieldName As String
        fieldName = fieldNames.item(c)
        
        list.add vfd(dict, fieldName, popupMsgIfNotThere)
        
        'JY20120905a - start - Why are we passing out the same thing we are passing in?
        'correspondingFieldNames.add fieldName
        'JY20120905a - end
    Next
    
    'JY20120905a - start - Why are we passing out the same thing we are passing in?
    'Set out_correspondingFieldNames = correspondingFieldNames
    'JY20120995a - end
    Set valuesFromDictionary = list

End Function

Function vfd_nothingToBlankString(dict As Dictionary, key As Variant) As Variant
    Dim result As Variant
    atr result, vfd(dict, key, False)
    
    atr vfd_nothingToBlankString, nothingToBlankString(result)
End Function

'This function exists because I don't like the fact that by calling "item" with a key that doesn't exist, the key gets added to the dictionary
'dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Function valueFromDictionary(dict As Variant, key As Variant, popupMsgIfNotThere As Boolean)

    If dict.exists(key) Then
        atr valueFromDictionary, dict.item(key)
    Else
        If popupMsgIfNotThere Then
            elwp "Could not find the requested key [" & key & "] in the dictionary, but we exxpected to be able to find it."
        End If
        Set valueFromDictionary = Nothing
    End If
End Function

Function getSetOfDistinctNestedPaths(listOfDictionariesWhosePathsWeShouldRetrieve As Variant) As Dictionary
    
    Dim listOf__nestedPaths As Collection
    Set listOf__nestedPaths = getListOfDistinctNestedPaths(listOfDictionariesWhosePathsWeShouldRetrieve)

    Dim blankStringByNestedPath As Dictionary
    Set blankStringByNestedPath = New Dictionary

    Dim d As Long
    For d = 1 To list_Of__nestedPaths.count
        
        Dim assumeThatNestedPathIsSupposedToBringUsToLeafNodeInTheTree As Boolean
        assumeThatNestedPathIsSupposedToBringUsToLeafNodeInTheTree = False
    
        Dim nestedPath As Collection
        Set nestedPath = listOf__cycle_prod_coupon.item(d)
        setValueForNestedDictionaryPath masterList__blankStringByCouponByProdByCycle, nestedPath, "", False, assumeThatNestedPathIsSupposedToBringUsToLeafNodeInTheTree
    Next
    
    Set getSetOfDistinctNestedPaths = blankStringByNestedPath
End Function

'assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeInTheTree = false
Function getThosePathsWhichAreNotInDictionary(listOfNestedPaths As Collection, dict As Dictionary, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree As Boolean) As Collection

    Dim listOfPaths As Collection
    Set listOfPaths = New Collection

    Dim c As Long
    For c = 1 To listOfNestedPaths.count
        Dim nestedPath As Collection
        Set nestedPath = listOfNestedPaths.item(c)
        If nestedPathExists(dict, nestedPath, False, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree) Then
            'DO NOTHING
        Else
            listOfPaths.add nestedPath
        End If
    Next

    Set getThosePathsWhichAreNotInDictionary = listOfPaths

End Function

'mod_dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Sub atdIfNotBlank(ByRef mod_dict As Variant, key As Variant, theVal As Variant)
    If Not isBlankValue(theVal) Then
        atd mod_dict, key, theVal
    End If
End Sub

Sub addToDictionaryAndLogErrorIfOverwriteOccurs(ByRef mod_dict As Dictionary, key As String, theVal As Variant, ByRef mod_emsgs As Variant)
    If mod_dict.exists(key) Then
        mod_emsgs.add "Found a duplicate field name: " & key
    End If
    atd mod_dict, key, theVal
End Sub


'mod_dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Function addToDictionary(ByRef mod_dict As Variant, key As Variant, value As Variant) As Variant

    Dim overridden As Variant
    If mod_dict.exists(key) Then
        atr overridden, mod_dict.item(key)
        mod_dict.remove key
    Else
        Set overridden = Nothing
    End If
    
    mod_dict.add key, value
    atr addToDictionary, overridden
    
End Function

Function addToDictionary_popupEmsgWhenOverrideOccurs(ByRef mod_dict As Variant, emsgToShow As String, key As Variant, value As Variant) As Variant
    Dim overridden As Variant
    atr overridden, addToDictionary(mod_dict, key, value)
    
    If Not isNothing(overridden) Then
        elwp emsgToShow
    End If
    
    atr addToDictionary_popupEmsgWhenOverrideOccurs, overridden
End Function

Function combineDictionariesByMergingTheirValuesIntoArrayListsOfValues(dictionaries As Variant, valueForMissingValue_orArrayOfvaluesOnePerDictionary As Variant) As Dictionary

    Dim distinctKeys As Collection
    Set distinctKeys = getCombinedKeysFromDictionaries(dictionaries).toCollection()
    
    Dim lower As Long
    Dim upper As Long
    glaubs dictionaries, lower, upper
    
    Dim arrayOfvaluesOnePerDictionary As Variant
    If IsArray(valueForMissingValue_orArrayOfvaluesOnePerDictionary) Then
        arrayOfvaluesOnePerDictionary = valueForMissingValue_orArrayOfvaluesOnePerDictionary
    Else
        arrayOfvaluesOnePerDictionary = createArrayWithInitializedValues(lower, upper, valueForMissingValue_orArrayOfvaluesOnePerDictionary)
    End If
    
    Dim newDict As Dictionary
    Set newDict = New Dictionary
    
    Dim d As Long
    For d = 1 To distinctKeys.count
        Dim curKey As Variant
        atr curKey, distinctKeys.item(d)
        
        Dim arrRow As Variant
        ReDim arrRow(lower To upper)
        
        Dim c As Long
        For c = lower To upper
            Dim dict As Dictionary
            Set dict = dictionaries(c)
            
            Dim daVal As Variant
            If dict.exists(curKey) Then
                atr daVal, vfd(dict, curKey, True)
            Else
                atr daVal, rlai(arrayOfvaluesOnePerDictionary, c - lower + 1)
            End If
            
            atr arrRow(c), daVal
            
            
            
        Next
        
        newDict.add curKey, arrRow
        
    Next
    
    
    Set combineDictionariesByMergingTheirValuesIntoArrayListsOfValues = newDict

End Function

Function getCombinedKeysFromDictionaries(dictionariesArrOrCollectionOrSingle As Variant) As JYCORE_Set

    Dim dictionaries As Variant
    dictionaries = ensureValueIsAnArray(dictionariesArrOrCollectionOrSingle)

    Dim lower As Long
    Dim upper As Long
    glaubs dictionaries, lower, upper
    
    Dim distinctKeys As JYCORE_Set
    Set distinctKeys = New JYCORE_Set
    
    Dim c As Long
    For c = lower To upper
        Dim dict As Variant 'variant instead of Dictionary because we might be expecting a JYUT_AdvancedDictionary
        Set dict = dictionaries(c)
        
        If isNothing(dict) Then
            elwp "Please pass in a dictionary!"
        Else
            
            Dim localKeys As Variant
            localKeys = dict.keys()
            
            Dim lwr As Long
            Dim upr As Long
            glaubs localKeys, lwr, upr
            
            Dim d As Long
            For d = lwr To upr
                distinctKeys.add localKeys(d)
            Next
        End If
    Next
    Set getCombinedKeysFromDictionaries = distinctKeys
End Function

'gcfdcin stands for: "getCollectionFromDictionary_createIfNecessary("
Function gcfdcin(ByRef mod_dict As Dictionary, key As Variant) As Collection
    
    Dim existingColl As Collection
    Set existingColl = vfd(mod_dict, key, False)
    
    If isNothing(existingColl) Then
        Set existingColl = New Collection
        atd mod_dict, key, existingColl
    End If
    
    Set gcfdcin = existingColl
    
End Function

'gsfdcin stands for: "getSetFromDictionary_createIfNecessary("
Function gsfdcin(ByRef mod_dict As Dictionary, key As Variant) As JYCORE_Set
    
    Dim existingColl As JYCORE_Set
    Set existingColl = vfd(mod_dict, key, False)
    
    If isNothing(existingColl) Then
        Set existingColl = New JYCORE_Set
        atd mod_dict, key, existingColl
    End If
    
    Set gsfdcin = existingColl
    
End Function

Function createDictionaryWhereEachValueIsANewlyCreatedArrayColumn(desiredKeys As Variant, lowerBound As Long, upperBound As Long, colIndx As Long)
    
    Dim dataToWriteByDestRN As Dictionary
    Set dataToWriteByDestRN = New Dictionary
    
    Dim lower As Long
    Dim upper As Long
    glaubs desiredKeys, lower, upper
    
    Dim c As Long
    For c = lower To upper
        Dim desiredKey As Variant
        desiredKey = desiredKeys(c)
        
        Dim tempArr As Variant
        ReDim tempArr(lowerBound To upperBound, colIndx To colIndx)
        
        atd dataToWriteByDestRN, desiredKey, tempArr
    Next
    Set createDictionaryWhereEachValueIsANewlyCreatedArrayColumn = dataToWriteByDestRN
End Function

'optCustomEMsg = ""
'suppressDupeErrorWhenDupeKeysPointToSameValue = false
Function convertListOfArrayRowsToDictionaryWhereLastElementInArrayIsValueAndTheOtherElementsAreTheNestedKey(listOfArrayRows As Collection, ByRef optEMsgsIfShouldLogDuplicatesRatherThanPopUpMsg As Variant, optCustomEMsg_orBlankStringToUseDefaultMsg_orNothingToNotSHowError As Variant, suppressDupeErrorWhenDupeKeysPointToSameValue As Boolean, delimiterAndEscCharToUseForDupesOrNothingToJustKeepFirstValue As Variant) As Dictionary

    Dim delimiterToUseForDupesOrBlankStringToJustKeepFirstValue As String
    Dim escChar As String
    If isNothing(delimiterAndEscCharToUseForDupesOrNothingToJustKeepFirstValue) Then
        delimiterToUseForDupesOrBlankStringToJustKeepFirstValue = ""
        escChar = ""
    Else
        delimiterToUseForDupesOrBlankStringToJustKeepFirstValue = rlai(delimiterAndEscCharToUseForDupesOrNothingToJustKeepFirstValue, 1)
        escChar = rlai(delimiterAndEscCharToUseForDupesOrNothingToJustKeepFirstValue, 2)
    End If

    Dim dict As Dictionary
    Set dict = New Dictionary

    Dim c As Long
    For c = 1 To listOfArrayRows.count
        Dim arrayRow As Variant
        arrayRow = listOfArrayRows.item(c)
        
        Dim rowSize As Long
        rowSize = dimSize(arrayRow, 1)
        
        Dim assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree As Boolean
        assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree = False '<-- false, because we don't know whether the row size is the same for all rows.  If it is, then we can say true.  But for now, we'll just assume false.
        
        Dim numKeys As Long
        numKeys = rowSize - 1
        
        Dim nestedKey As Variant
        Dim value As Variant
        nestedKey = removeLastElementFromArrayRow(arrayRow)
        value = rlai(arrayRow, rowSize)
        If nestedPathExists(dict, nestedKey, False, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree) Then
        
            Dim showErr As Boolean
            If Not suppressDupeErrorWhenDupeKeysPointToSameValue Then
                showErr = True
            Else
                Dim existing As Variant
                atr existing, getValueForNestedDictionaryPath(dict, nestedKey, False, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree)
                
                If valuesAreEqual(existing, value) Then
                    showErr = False
                Else
                    showErr = True
                End If
            End If
            If Not showErr Then
                'DO NOTHING
            Else
            
                Dim theExisting As Variant
                atr theExisting, getValueForNestedDictionaryPath(dict, nestedKey, False, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree)
                
                Dim actionTaken As String
                If delimiterToUseForDupesOrBlankStringToJustKeepFirstValue = "" Then
                    actionTaken = "  We will ignore all but the first one."
                ElseIf IsObject(theExisting) Or IsObject(value) Then
                    actionTaken = "  We will ignore all but the first one (we can't combine the values because we are dealing with objects)."
                Else
                    actionTaken = "  We will combine the values, using '" & delimiterToUseForDupesOrBlankStringToJustKeepFirstValue & "' as a delimiter."
                    
                    Dim existingVals As JYCORE_Set
                    Set existingVals = collectionToSet(stringToCollection(CStr(theExisting), delimiterToUseForDupesOrBlankStringToJustKeepFirstValue, escChar))
                    existingVals.add value
                    
                    Dim newValToUse As String
                    newValToUse = existingVals.toString(delimiterToUseForDupesOrBlankStringToJustKeepFirstValue, escChar)
                    
                    setValueForNestedDictionaryPath dict, nestedKey, newValToUse, False, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree
                End If
            
                
                If isNothing(optCustomEMsg_orBlankStringToUseDefaultMsg_orNothingToNotSHowError) Then
                    'DO NOTHING
                Else
                    Dim emsg As String
                    If optCustomEMsg_orBlankStringToUseDefaultMsg_orNothingToNotSHowError = "" Then
                        emsg = "One or more duplicate nested keys were encountered!" & actionTaken
                    Else
                        emsg = optCustomEMsg_orBlankStringToUseDefaultMsg_orNothingToNotSHowError & actionTaken
                    End If
                    If isNothing(optEMsgsIfShouldLogDuplicatesRatherThanPopUpMsg) Then
                        elwp emsg
                    Else
                        optEMsgsIfShouldLogDuplicatesRatherThanPopUpMsg.add emsg
                    End If
                End If
            End If
        Else
            setValueForNestedDictionaryPath dict, nestedKey, value, False, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree
        End If
        
    Next
    
    Set convertListOfArrayRowsToDictionaryWhereLastElementInArrayIsValueAndTheOtherElementsAreTheNestedKey = dict

End Function

'ifOnlyOneValueElementShouldKeepUnwrapped = false
'mod_emsgs____orNothingToShowPopupsInsteadOfLogging = nothing
Function convertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey_overridesAreOk(listOf_arrayRows As Collection, ifOnlyOneValueElementShouldKeepUnwrapped As Boolean, ByRef mod_emsgs____orNothingToShowPopupsInsteadOfLogging As Variant) As Dictionary
    atr convertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey_overridesAreOk, doConvertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey(True, listOf_arrayRows, ifOnlyOneValueElementShouldKeepUnwrapped, mod_emsgs____orNothingToShowPopupsInsteadOfLogging)
End Function

'mod_emsgs____orNothingToShowPopupsInsteadOfLogging = nothing
Function convertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey(listOf_arrayRows As Collection, ifOnlyOneValueElementShouldKeepUnwrapped As Boolean, ByRef mod_emsgs____orNothingToShowPopupsInsteadOfLogging As Variant) As Dictionary
    atr convertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey, doConvertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey(False, listOf_arrayRows, ifOnlyOneValueElementShouldKeepUnwrapped, mod_emsgs____orNothingToShowPopupsInsteadOfLogging)
End Function

'mod_emsgs____orNothingToShowPopupsInsteadOfLogging = nothing
Function doConvertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey(overridesAreOk As Boolean, listOf_arrayRows As Collection, ifOnlyOneValueElementShouldKeepUnwrapped As Boolean, ByRef mod_emsgs____orNothingToShowPopupsInsteadOfLogging As Variant) As Dictionary
    
    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    If isNothing(listOf_arrayRows) Then
        emsgs.add "Please pass in a list of array rows."
        Set doConvertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey = Nothing
    Else
    
        Dim returnValue As Dictionary
        Set returnValue = New Dictionary
        
        Dim d As Long
        For d = 1 To listOf_arrayRows.count
            Dim arrRow As Variant
            arrRow = listOf_arrayRows.item(d)
            
            Dim size As Long
            size = dimSize(arrRow, 1)
            
            If size <= 0 Then
                emsgs.add "Encountered an array row with zero elements!  Therefore, cannot derive key value."
            Else
                
                Dim numKeys As Long
                numKeys = 1
                
                Dim keyValue As Variant
                atr keyValue, rlai(arrRow, 1)
            
                Dim theValue As Variant
                If size = 1 Then
                    emsgs.add "Encountered an array row with one element!  Therefore, cannot derive the value for our key."
                    Set theValue = Nothing
                Else
                
                    
                    Dim numVals As Long
                    numVals = size - 1
                
                    If numVals = 1 And ifOnlyOneValueElementShouldKeepUnwrapped Then
                        atr theValue, rlai(arrRow, 1 + numKeys)
                    Else
                
                        ReDim theValue(1 To numVals)
                        
                        Dim t As Long
                        For t = 1 To numVals
                            atr theValue(t), rlai(arrRow, t + numKeys)
                        Next
                    End If
                End If
                
                Dim overridden As Variant
                atr overridden, atd(returnValue, keyValue, theValue)
            
                If Not isNothing(overridden) Then
                    If overridesAreOk Then
                        'DO NOTHING
                    Else
                        emsgs.add "The key '" & keyValue & "' was defined more than once!  We will use the latest definition that we encounter."
                    End If
                End If
            End If
        Next
    End If
    
    If isNothing(mod_emsgs____orNothingToShowPopupsInsteadOfLogging) Then
        If emsgs.count <> 0 Then
            elwp emsgs.toString(CHAR_CRLF, "")
        End If
    Else
        addToEmsgsObject mod_emsgs____orNothingToShowPopupsInsteadOfLogging, emsgs
    End If
    Set doConvertListOfArrayRowsToDictionaryWhereFirstElementInArrayRowBecomesKey = returnValue
End Function

'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = false
Function ensureCollectionOrSetExistsInDict_byNestedKey(collectionVsSet As Boolean, ByRef mod_listOfValuesByKey As Dictionary, theNestedKey As Variant, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Variant

    
    Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
    shouldCastKeyToStringIfHelpsFindValue = False
    
    Dim listOfValues As Variant
    Set listOfValues = getValueForNestedDictionaryPath(mod_listOfValuesByKey, theNestedKey, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    
    If isNothing(listOfValues) Then
        If collectionVsSet Then
            Set listOfValues = New Collection
        Else
            Set listOfValues = New JYCORE_Set
        End If
        
        setValueForNestedDictionaryPath mod_listOfValuesByKey, theNestedKey, listOfValues, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
    End If
    
    Set ensureCollectionOrSetExistsInDict_byNestedKey = listOfValues

End Function

'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeIntheTree = false
Function ensureCollectionExistsInDict_byNestedKey(ByRef mod_listOfValuesByKey As Dictionary, theNestedKey As Variant, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As Collection
    atr ensureCollectionExistsInDict_byNestedKey, ensureCollectionOrSetExistsInDict_byNestedKey(True, mod_listOfValuesByKey, theNestedKey, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
End Function

'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeIntheTree = false
Function ensureSetExistsInDict_byNestedKey(ByRef mod_listOfValuesByKey As Dictionary, theNestedKey As Variant, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean) As JYCORE_Set
    atr ensureSetExistsInDict_byNestedKey, ensureCollectionOrSetExistsInDict_byNestedKey(False, mod_listOfValuesByKey, theNestedKey, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
End Function


Function ensureCollectionExistsInDict(ByRef mod_listOfValuesByKey As Dictionary, theKey As Variant) As Collection

    Dim listOfValues As Collection
    Set listOfValues = vfd(mod_listOfValuesByKey, theKey, False)
    
    If isNothing(listOfValues) Then
        Set listOfValues = New Collection
        atd mod_listOfValuesByKey, theKey, listOfValues
    End If
    
    Set ensureCollectionExistsInDict = listOfValues

End Function

Function ensureSetExistsInDict(ByRef mod_listOfValuesByKey As Dictionary, theKey As Variant) As JYCORE_Set

    Dim listOfValues As JYCORE_Set
    Set listOfValues = vfd(mod_listOfValuesByKey, theKey, False)
    
    If isNothing(listOfValues) Then
        Set listOfValues = New JYCORE_Set
        atd mod_listOfValuesByKey, theKey, listOfValues
    End If
    
    Set ensureSetExistsInDict = listOfValues

End Function
Function convertDictionaryOfCollectionsOrSetsToDictionaryOfStrings(dict As Dictionary, delim As String, escChar As String) As Dictionary

    Dim newDict As Dictionary
    Set newDict = New Dictionary

    Dim nestedPaths As Collection
    Set nestedPaths = getNestedDictionaryPaths(dict, False)
    
    Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
    assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True '<-- true, because our nested paths came from "getNestedDictionaryPaths"
    
    Dim c As Long
    For c = 1 To nestedPaths.count
        Dim path As Variant
        path = nestedPaths.item(c)
        
        Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
        shouldCastKeyToStringIfHelpsFindValue = False
        
        Dim theCollOrSet As Variant
        Set theCollOrSet = getValueForNestedDictionaryPath(dict, path, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
        
        Dim theColl As Collection
        If isCollection(theCollOrSet) Then
            Set theColl = theCollOrSet
        Else
            Set theColl = theCollOrSet.toCollection()
        End If
        setValueForNestedDictionaryPath newDict, path, cltstr(theColl, delim, escChar), shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
    Next

    Set convertDictionaryOfCollectionsOrSetsToDictionaryOfStrings = newDict

End Function

Function convertDictionaryOfCollectionsToDictionaryOfsets(dict As Dictionary) As Dictionary
    Set convertDictionaryOfCollectionsToDictionaryOfsets = convertDictionaryOfCollectionsOrArraysToDictionaryOfSets(dict, True)
End Function

Function convertDictionaryOfCollectionsOrArraysToDictionaryOfSets(dict As Dictionary, allAreExpectedToBeCollections As Boolean) As Dictionary

    Dim newDict As Dictionary
    Set newDict = New Dictionary
    
    Dim keys As Variant
    keys = dict.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs keys, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim curKey As Variant
        curKey = keys(c)
        
        Dim theList As Variant
        atr theList, vfd(dict, curKey, True)
        
        Dim list As Collection
        If isCollection(theList) Then
            Set list = vfd(dict, curKey, True)
        Else
            If allAreExpectedToBeCollections Then
                elwp "Encountered a non-collection unexpectedly!"
            End If
            
            If IsArray(theList) Then
                Set list = arrayToCollection(theList)
            Else
                elwp "Unexpected object type!  We will ignore it."
                Set list = New Collection
            End If
        End If
        
        Dim theSet As JYCORE_Set
        Set theSet = collectionToSet(list)
        
        atd newDict, curKey, theSet
    Next
    
    Set convertDictionaryOfCollectionsOrArraysToDictionaryOfSets = newDict

End Function

Sub addListOfValuesByKeyToListOfValuesByKey(ByRef mod_dictOfCollections As Dictionary, dictOfCollectionsToAdd As Dictionary)
    Dim thisRoundYBPortFileNames As Variant
    thisRoundYBPortFileNames = dictOfCollectionsToAdd.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs thisRoundYBPortFileNames, lwr, upr
    
    Dim x As Long
    For x = lwr To upr
        Dim disFileName As String
        disFileName = thisRoundYBPortFileNames(x)
        
        Dim list As Collection
        Set list = vfd(dictOfCollectionsToAdd, disFileName, True)
        
        addMultipleValuesToListOfValuesByKey mod_dictOfCollections, disFileName, list
        
    Next
End Sub

Sub addMultipleValuesToListOfValuesByKey(ByRef mod_dict As Dictionary, key As String, list As Collection)

    
    Dim z As Long
    For z = 1 To list.count
        addToListOfValuesByKey mod_dict, key, list.item(z)
    Next
    
End Sub


Sub addToListOfValuesByNestedKey(ByRef mod_listOfValuesByNestedKey As Dictionary, theNestedKey As Variant, theValue As Variant, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)

    Dim listOfValues As Collection
    Set listOfValues = ensureCollectionExistsInDict_byNestedKey(mod_listOfValuesByNestedKey, theNestedKey, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    
    listOfValues.add theValue

End Sub

'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeIntheTree  = false
Sub addToSetOfValuesByNestedKey(ByRef mod_setOfValuesByNestedKey As Dictionary, theNestedKey As Variant, theValue As Variant, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean)

    Dim listOfValues As JYCORE_Set
    Set listOfValues = ensureSetExistsInDict_byNestedKey(mod_setOfValuesByNestedKey, theNestedKey, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    
    listOfValues.add theValue
    
End Sub

Sub addToListOfValuesByKey(ByRef mod_listOfValuesByKey As Dictionary, theKey As Variant, theValue As Variant)

    Dim listOfValues As Collection
    Set listOfValues = ensureCollectionExistsInDict(mod_listOfValuesByKey, theKey)
    
    listOfValues.add theValue
    
End Sub

Function countTotalListEntriesInListOfValuesByKey(listOfValuesByKey As Dictionary)

    Dim keys As Variant
    keys = listOfValuesByKey.keys

    Dim lwr As Long
    Dim upr As Long
    glaubs keys, lwr, upr
    
    Dim cnt As Long
    cnt = 0
    
    Dim c As Long
    For c = lwr To upr
        Dim key As Variant
        key = keys(c)
        
        Dim list As Collection
        Set list = vfd(listOfValuesByKey, key, True)
        
        cnt = cnt + list.count
    Next
    
    countTotalListEntriesInListOfValuesByKey = cnt

End Function


Sub addToSetOfValuesByKey(ByRef mod_setOfValuesByKey As Dictionary, theKey As Variant, theValue As Variant)

    Dim listOfValues As JYCORE_Set
    Set listOfValues = ensureSetExistsInDict(mod_setOfValuesByKey, theKey)
    
    listOfValues.add theValue
    
End Sub

'allowMultipleIndexesPerValue = true
Function createArrayOffsetListByArrayValue(arr As Variant, allowMultipleIndexesPerValue As Boolean) As Dictionary
    Dim arrOffsetListByArrValue As Dictionary
    Set arrOffsetListByArrValue = New Dictionary
    
    Dim lw As Long
    Dim up As Long
    glaubs arr, lw, up
    
    Dim c As Long
    For c = lw To up
        Dim sec As String
        sec = arr(c)
        
        addToListOfValuesByKey arrOffsetListByArrValue, sec, c
    Next
    
    Dim arrOffsetListByArrVal As Dictionary
    
    If allowMultipleIndexesPerValue Then
        Set arrOffsetListByArrVal = arrOffsetListByArrValue
    Else
        Set arrOffsetListByArrVal = New Dictionary
    
        Dim arrVals As Variant
        arrVals = arrOffsetListByArrValue.keys()
        
        Dim lwr As Long
        Dim upr As Long
        glaubs arrVals, lwr, upr
        
        Dim d As Long
        For d = lwr To upr
            Dim curVal As Variant
            curVal = arrVals(d)
            
            Dim theOffsets As Collection
            atr theOffsets, vfd(arrOffsetListByArrValue, curVal, True)
            
            Dim e As Long
            For e = 1 To theOffsets.count
            
                If arrOffsetListByArrVal.exists(curVal) Then
                    elwp "Duplicate value detected: " & curVal
                Else
                    atd arrOffsetListByArrVal, curVal, theOffsets.item(e)
                End If
            Next
        Next
    End If
    
    Set createArrayOffsetListByArrayValue = arrOffsetListByArrVal
    
End Function

Function toString(obj As Variant) As String
    If isDictionary(obj) Then
        toString = dictToString(castToDictionary(obj), "=", "~", "\")
    ElseIf isCollection(obj) Then
        toString = cltstr(castToCollection(obj), TO_STRING_COLLECTION_DELIMITER, TO_STRING_COLLECTION_ESC_CHAR)
    ElseIf isSet(obj) Then
        Dim daSet As JYCORE_Set
        Set daSet = obj
        toString = daSet.toString("`", "\")
    ElseIf IsObject(obj) Then
        toString = "[object]"
    ElseIf IsArray(obj) Then
        'JY20120316a
        'toString = arrayToString(obj, "`", "")
        toString = arrayToString(obj, "`", "\")
    Else
        toString = CStr(obj)
    End If
        
End Function

Function stringToDict_allValuesRemainStrings(strng As String, nvpDelim As String, entryDelim As String, escCharacter As String, ByRef mod_emsgs As Variant) As Dictionary

    Dim nvps As Collection
    Set nvps = stringToCollection(strng, entryDelim, escCharacter)
    
    Dim dict As Dictionary
    Set dict = New Dictionary
    
    Dim c As Long
    For c = 1 To nvps.count
        Dim nvp As String
        nvp = nvps.item(c)
        
        Dim keyAndValue As Variant
        keyAndValue = stringToArray(nvp, nvpDelim, escCharacter, 1)
        
        If dimSize(keyAndValue, 1) <> 2 Then
            mod_emsgs.add "Unable to parse out the key and value from text!"
        Else
            Dim keyText As String
            Dim valueText As String
            keyText = rlai(keyAndValue, 1)
            valueText = rlai(keyAndValue, 2)
            
            Dim nestedKeyDelim As String
            nestedKeyDelim = nvpDelim
            
            Dim nestedPath As Variant
            nestedPath = stringToArray(keyText, nestedKeyDelim, escCharacter, 1)
            
            Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
            assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True
             
            If nestedPathExists(dict, nestedPath, SHLD_CAST_KEY_TO_STRING_WHEN_PERFORMING_DICT_SERIALIZATION, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree) Then
                mod_emsgs.add "Encountered a duplicate nested key when serializing from text to a dictionary!"
            Else
                setValueForNestedDictionaryPath dict, nestedPath, valueText, SHLD_CAST_KEY_TO_STRING_WHEN_PERFORMING_DICT_SERIALIZATION, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
            End If
            
        End If
    Next
    
    Set stringToDict_allValuesRemainStrings = dict

End Function

Function dictToString(dict As Dictionary, nvpDelim As String, entryDelim As String, escCharacter As String) As String
    
    Dim nestedPaths As Collection
    Set nestedPaths = getNestedDictionaryPaths(dict, False)
    
    Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
    assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True '<-- true because we got the paths from the getNestedDictionaryPaths method
    
    Dim nvps As Collection
    Set nvps = New Collection
    
    Dim c As Long
    For c = 1 To nestedPaths.count
        
        Dim curPath As Variant
        atr curPath, nestedPaths.item(c)
        
        Dim curVal As Variant
        atr curVal, getValueForNestedDictionaryPath(dict, curPath, SHLD_CAST_KEY_TO_STRING_WHEN_PERFORMING_DICT_SERIALIZATION, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
        
        Dim curKey As Variant
        If szof(curPath) = 1 Then
            atr curKey, itm(curPath, 1)
        Else
            Dim nestedKeyDelim As String
            nestedKeyDelim = nvpDelim
        
            curKey = arrayToString(curPath, nestedKeyDelim, escCharacter)
        End If
        
        nvps.add arrayToString(Array(toString(curKey), toString(curVal)), nvpDelim, escCharacter)
    Next
    
    dictToString = cltstr(nvps, entryDelim, escCharacter)
    
End Function

'mod_dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Function addDictionaryToDictionary_elwpIfOverridesOccurs(ByRef mod_dict As Variant, dictWhoseValuesShouldBeAdded As Dictionary) As Dictionary
    Dim overrideNVPs As Dictionary
    Set overrideNVPs = addDictionaryToDictionary(mod_dict, dictWhoseValuesShouldBeAdded)
    
    If overrideNVPs.count <> 0 Then
        elwp "One or more overrides occurred!"
    End If
End Function

Function combineDictionaries_viaNestedPaths(dict1 As Dictionary, dict2 As Dictionary) As Dictionary

    Dim newDict As Dictionary
    Set newDict = copyDictionary_viaNestedDictionaryPaths(dict1)
    
    Dim listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides As Collection
    Set listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides = addDictionaryToDictionary_viaNestedDictionaryPaths(newDict, dict2)
    
    Dim retValue As Dictionary
    If Not isNothing(listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides) Then
        elwp "Could not combine dictionaries because one or more duplicate keys were found!"
        Set retValue = Nothing
    Else
        Set retValue = newDict
    End If

    Set combineDictionaries_viaNestedPaths = newDict

End Function

Function addDictionaryToDictionary_viaNestedDictionaryPaths(ByRef mod_dict As Dictionary, dictWhoseValuesShouldBeAdded As Dictionary) As Collection

    Dim listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides As Collection
    Set listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides = Nothing
    

    Dim shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue As Boolean
    shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue = False

    Dim nestedPaths As Collection
    Set nestedPaths = getNestedDictionaryPaths(dictWhoseValuesShouldBeAdded, False)
    
    Dim c As Long
    For c = 1 To nestedPaths.count
        Dim nestedPath As Variant
        nestedPath = nestedPaths.item(c)
        
        Dim theValue As Variant
        atr theValue, getValueForNestedDictionaryPath(dictWhoseValuesShouldBeAdded, nestedPath, shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue, True)
        
        Dim assumeThatNestedPathIsSpposedToBringUsToLeafNodeInThisDestinationTree As Boolean
        assumeThatNestedPathIsSpposedToBringUsToLeafNodeInThisDestinationTree = False
        
        Dim doesExist As Boolean
        doesExist = nestedPathExists(mod_dict, nestedPath, shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSpposedToBringUsToLeafNodeInThisDestinationTree)
        
        Dim overwritten As Variant
        atr overwritten, setValueForNestedDictionaryPath(mod_dict, nestedPath, theValue, shouldCastKeysToStringsWhenPossible_and_shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSpposedToBringUsToLeafNodeInThisDestinationTree)
        
        If doesExist Then
            If isNothing(listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides) Then
                Set listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides = New Collection
            End If
            listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides.add Array(nestedPath, overwritten)
        End If
        
    Next
    
    atr addDictionaryToDictionary_viaNestedDictionaryPaths, listOf__nestedPath_overwrittenValue____orNothingIfThereWereNoOverrides

End Function

'mod_dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Function addDictionaryToDictionary(ByRef mod_dict As Variant, dictWhoseValuesShouldBeAdded As Dictionary) As Dictionary

    Dim overrideNVPs As Dictionary
    Set overrideNVPs = New Dictionary
    
    Dim keys As Variant
    keys = dictWhoseValuesShouldBeAdded.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs keys, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim curKey As Variant
        curKey = keys(c)
        
        Dim curVal As Variant
        atr curVal, vfd(dictWhoseValuesShouldBeAdded, curKey, True)
        
        Dim overridden As Variant
        atr overridden, atd(mod_dict, curKey, curVal)
        
        If Not isNothing(overridden) Then
            Dim overriddenOverride As Variant
            atr overriddenOverride, atd(overrideNVPs, curKey, overridden)
            
            If Not isNothing(overriddenOverride) Then
                elwp_se
            End If
        End If
    Next
    
    Set addDictionaryToDictionary = overrideNVPs

End Function
Function findFirstValueInListThatAppearsAsKeyInDictionary(dict As Dictionary, list As Collection) As Variant

    Dim c As Long
    c = 1
    
    Dim foundKey As Variant
    Set foundKey = Nothing
    
    While (c <= list.count) And isNothing(foundKey)
        Dim curKeyToTry As Variant
        atr curKeyToTry, list.item(c)
        
        If dict.exists(curKeyToTry) Then
            atr foundKey, curKeyToTry
        End If
        c = c + 1
    Wend
    
    atr findFirstValueInListThatAppearsAsKeyInDictionary, foundKey

End Function

'popupMsgIfNotThere = true
'used to be called "getValsFromDictionaryForListOfRNs"
Function getValsFromDictionaryForListOfKeys(rns As Variant, valByRN As Dictionary, popupMsgIfNotThere As Boolean) As Collection
    
    Dim theVals As Collection
    Set theVals = New Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rns, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim disRN As String
        disRN = rns(c)
    
        theVals.add vfd(valByRN, disRN, popupMsgIfNotThere)
    Next
    Set getValsFromDictionaryForListOfKeys = theVals

End Function

Function replaceKeysInDictionaryWithOtherKeys(origDict As Dictionary, listOf_origKeyAndReplacementKey As Collection, weExpectAllExistingKeysToShowUpInOurMapping As Boolean) As Dictionary
    
    Dim replacementKeyByOrigKey As Dictionary
    Set replacementKeyByOrigKey = New Dictionary
    
    Dim overridden As JYCORE_Set
    Set overridden = addListOfKeysAndValuesToDictionary(replacementKeyByOrigKey, listOf_origKeyAndReplacementKey)
    
    If overridden.count <> 0 Then
        elwp "Duplicate original keys exist!  We will ignore some of your entries."
    End If
    
    Dim newDict As Dictionary
    Set newDict = New Dictionary
    
    Dim existingKeys As Variant
    existingKeys = origDict.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs existingKeys, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim curKey As Variant
        curKey = existingKeys(c)
        
        Dim theValue As Variant
        atr theValue, vfd(origDict, curKey, True)
        
        Dim replacementKey As Variant
        If Not replacementKeyByOrigKey.exists(curKey) Then
            If weExpectAllExistingKeysToShowUpInOurMapping Then
                elwp "Could not find the key '" & CStr(curKey) & "' in your passed-in mapping!"
            End If
            replacementKey = curKey
        Else
            replacementKey = vfd(replacementKeyByOrigKey, curKey, True)
        End If
        
        atd newDict, replacementKey, theValue
        
    Next
    
    Set replaceKeysInDictionaryWithOtherKeys = newDict

End Function
Function getCountByValue(listOfValues As Collection) As Dictionary

    Dim countByValue As Dictionary
    Set countByValue = New Dictionary
    
    Dim c As Long
    For c = 1 To listOfValues.count
        Dim theVal As Variant
        theVal = listOfValues.item(c)
        
        Dim curCnt As Long
        If countByValue.exists(theVal) Then
            curCnt = rfd(countByValue, theVal)
        Else
            curCnt = 0
        End If
        
        atd countByValue, theVal, curCnt + 1
    Next
    
    Set getCountByValue = countByValue
End Function

Function removeEntriesWithBlankValuesFromDictionary(dict As Dictionary) As Dictionary

    Dim newDict As Dictionary
    Set newDict = New Dictionary
    
    Dim keys As Variant
    keys = dict.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs keys, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim theKey As Variant
        theKey = keys(c)
        
        Dim theVal As Variant
        atr theVal, rfd(dict, theKey)
        
        If isBlankValue(theVal) Then
            'DO NOTHING
        Else
            atd newDict, theKey, theVal
        End If
    Next
    
    Set removeEntriesWithBlankValuesFromDictionary = newDict

End Function

Private Function conversionToStringIsAppropriateInContextOfDictionary(lastKey As Variant) As Boolean
    conversionToStringIsAppropriateInContextOfDictionary = (Not IsObject(lastKey)) And (Not IsDate(lastKey))
End Function
Sub writeDictionaryToSpreadsheet_whereValueIsArrayListThatShouldBeDisplayedInMultipleColumns(dict As Dictionary, rnForKeys As String, rnsForValues As Variant, optWS As Worksheet)
    Dim keyAnk As Range
    Set keyAnk = rnge(rnForKeys, optWS)
    
    Dim valAnks As Collection
    Set valAnks = New Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rnsForValues, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        valAnks.add rnge(CStr(rnsForValues(c)), optWS)
    Next
    
    clearColumnData keyAnk
    clearColumnData valAnks
    
    Dim listOfKeysAndValues As Collection
    Set listOfKeysAndValues = convertDictToListOfKeyAndValue(dict, False, True)
    
    Dim keys As Collection
    Dim valuesColDatas As Variant
    ReDim valuesColDatas(lwr To upr)
    If listOfKeysAndValues.count = 0 Then
        Set keys = New Collection
        
        Dim d As Long
        For d = lwr To upr
            Set valuesColDatas(d) = New Collection
        Next
    Else
    
        Dim keys_values As Collection
        Set keys_values = sciloar(True, listOfKeysAndValues)
        
        Dim listOf_arrayListOfValues As Collection
        Set keys = keys_values.item(1)
        Set listOf_arrayListOfValues = keys_values.item(2)
        
        Dim listOf_valueColDatas As Collection
        Set listOf_valueColDatas = sciloar(True, listOf_arrayListOfValues)
        
        Dim e As Long
        For e = lwr To upr
            
            Dim curValue As Collection
            If listOf_valueColDatas.count <> (upr - lwr + 1) Then
                elwp "Invalid array size"
                Set curValue = New Collection
            Else
                Set curValue = listOf_valueColDatas.item(e - lwr + 1)
            End If
            
            Set valuesColDatas(e) = curValue
        Next
        
    End If
    
    scd keyAnk, keys
    
    Dim origSel As Range
    Set origSel = getCurSel()
    
    scdForMultipleColumns_passInColAnchors valAnks, valuesColDatas, Nothing, True
    
    sris origSel
    
    
End Sub

Sub writeDictionaryToSpreadsheet(dict As Dictionary, rnForKeys As String, rnForValues As String, optWS As Worksheet)

    Dim keyAnk As Range
    Dim valAnk As Range
    Set keyAnk = rnge(rnForKeys, optWS)
    Set valAnk = rnge(rnForValues, optWS)
    
    clearColumnData keyAnk
    clearColumnData valAnk
    
    Dim listOfKeysAndValues As Collection
    If isNothing(dict) Then
        Set listOfKeysAndValues = New Collection
    Else
        Set listOfKeysAndValues = convertDictToListOfKeyAndValue(dict, False, True)
    End If
    
    Dim keys As Collection
    Dim values As Collection
    If listOfKeysAndValues.count = 0 Then
        Set keys = New Collection
        Set values = New Collection
    Else
    
        Dim keys_values As Collection
        Set keys_values = sciloar(True, listOfKeysAndValues)
        
        Set keys = keys_values.item(1)
        Set values = keys_values.item(2)
    End If
    scd keyAnk, keys
    scd valAnk, values
    

End Sub

Function getListOfDistinctNestedPaths(dictionaryList As Variant) As Collection
    
    Dim allPaths As Collection
    Set allPaths = New Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs dictionaryList, lwr, upr
    
    Dim x As Long
    For x = lwr To upr
        Dim dict As Dictionary
        Set dict = dictionaryList(x)
        
        acltcl allPaths, getNestedDictionaryPaths(dict, False)
    Next
    
    Dim allPathsSet As JYCORE_Set
    Set allPathsSet = New JYCORE_Set
    
    Dim c As Long
    For c = 1 To allPaths.count
        Dim curPath As Variant
        curPath = allPaths.item(c)
        
        Dim delim As String
        Dim escChar As String
        delim = "`" 'arbitrary
        escChar = "\" 'arbitrary
        
        Dim stringRep As String
        stringRep = arrayToString(curPath, delim, escChar)
        
        allPathsSet.add stringRep
        
    Next
    
    Dim list As Collection
    Set list = allPathsSet.toCollection()
    
    Dim distinctPathsList As Collection
    Set distinctPathsList = New Collection
    
    Dim d As Long
    For d = 1 To list.count
        Dim strngRep As String
        strngRep = list.item(d)
        
        Dim daPath As Variant
        daPath = stringToArray(strngRep, delim, escChar, 1)
        
        distinctPathsList.add daPath
    Next
    
    Set getListOfDistinctNestedPaths = distinctPathsList
End Function

'assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree = false
Sub addValueToDictionaryForMultipleNestedPaths(ByRef mod_dict As Dictionary, listOfNestedKeys As Collection, valueToAdd As Variant, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree As Boolean)
    
    If isNothing(listOfNestedKeys) Then
        elwp "Please pass in a list of nested keys!"
    Else
    
        Dim c As Long
        For c = 1 To listOfNestedKeys.count
            Dim nestedKey As Variant
            nestedKey = listOfNestedKeys.item(c)
            setValueForNestedDictionaryPath mod_dict, nestedKey, valueToAdd, False, assumeThatAllNestedPathsAreSupposedToBringUsToTheLeafNodeIntheTree
        Next
    End If
End Sub

'dict is variant in case we decide to pass in a JYUT_AdvancedDictionary
Function createDictionaryBasedOnAnotherDictionaryButOnlyIncludingCertainKeysWhereAvailable(dict As Variant, keyNameOrArrOfKeyNames As Variant, ByRef out_keysNotFound As Collection)

    Dim valueRetrievedByParamName As Dictionary
    Set valueRetrievedByParamName = New Dictionary
    If isNothing(dict) Then
        elwp "Please pass in a dictionary"
    Else
    
        Dim arrOfKeyNames As Variant
        arrOfKeyNames = wrapInArrayIfNotAlreadyAnArray(keyNameOrArrOfKeyNames)
            
        Dim lwr As Long
        Dim upr As Long
        glaubs arrOfKeyNames, lwr, upr
        
        Dim keysNotFound As Collection
        Set keysNotFound = New Collection
        
        Dim c As Long
        For c = lwr To upr
            Dim curKey As Variant
            curKey = arrOfKeyNames(c)
            
            If Not dict.exists(curKey) Then
                keysNotFound.add curKey
            Else
                Dim theValue As Variant
                atr theValue, vfd(dict, curKey, True)
                
                atd valueRetrievedByParamName, curKey, theValue
            End If
            
        Next
    End If
    
    Set out_keysNotFound = keysNotFound
    Set createDictionaryBasedOnAnotherDictionaryButOnlyIncludingCertainKeysWhereAvailable = valueRetrievedByParamName
    
End Function

'mod_dict is variant in case we decide to pass in a JYUT_AdvancedDictionary
Function extractAndRemoveValuesFromDictionary(ByRef mod_dict As Variant, keyNameOrArrOfKeyNames As Variant, valueToUseWhenNotFound As Variant, ByRef out_keysNotFound As Collection) As Variant

    Dim arrOfKeyNames As Variant
    arrOfKeyNames = wrapInArrayIfNotAlreadyAnArray(keyNameOrArrOfKeyNames)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrOfKeyNames, lwr, upr
    
    Dim keysNotFound As Collection
    Set keysNotFound = New Collection
    
    Dim extractedValues As Variant
    ReDim extractedValues(lwr To upr)
    
    Dim d As Long
    For d = lwr To upr
        Dim curKey As Variant
        curKey = arrOfKeyNames(d)
    
        Dim theValue As Variant
        If mod_dict.exists(curKey) Then
            atr theValue, rfd(mod_dict, curKey)
        Else
            keysNotFound.add curKey
            atr theValue, valueToUseWhenNotFound
        End If
        atr extractedValues(d), theValue
    
    Next
    
    Set out_keysNotFound = keysNotFound
    extractAndRemoveValuesFromDictionary = extractedValues

End Function

Function lcaseKeysInDictionary(dict As Dictionary, ByRef out_duplicateKeys As JYCORE_Set) As Dictionary
    Dim newDict As Dictionary
    Set newDict = New Dictionary
        
    Dim keys As Variant
    Dim values As Variant
    Dim lwr As Long
    Dim upr As Long
    getKeysAndValues dict, keys, values, lwr, upr
    
    Dim duplicateKeys As JYCORE_Set
    Set duplicateKeys = New JYCORE_Set
    
    Dim c As Long
    For c = lwr To upr
        Dim curKey As Variant
        Dim curVal As Variant
        atr curKey, keys(c)
        atr curVal, values(c)
        
        Dim adjKey As Variant
        adjKey = lcaseIfPossible(curKey)
        
        If newDict.exists(adjKey) Then
            duplicateKeys.add curKey
        Else
            atd newDict, adjKey, curVal
        End If
        
    Next
    
    Set out_duplicateKeys = duplicateKeys
    Set lcaseKeysInDictionary = newDict
    
    
End Function

Function createInitializedDictionaryOfCollections(keysToAssociateBlankCollectionsTo As Variant) As Dictionary

    Dim dict As Dictionary
    Set dict = New Dictionary
    
    Dim lwr As Long
    Dim upr As Long
    glaubs keysToAssociateBlankCollectionsTo, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim key As Variant
        atr key, keysToAssociateBlankCollectionsTo(c)
    
        atd dict, key, New Collection
    Next
    
    Set createInitializedDictionaryOfCollections = dict
End Function

Sub convertNVPsToCollectionOfFieldNamesAndCollectionsOfValuesOnePerNVP(ByRef out_fieldNames As Collection, ByRef out_listOf__fieldValuesOneCollectionPerNVP As Collection, listOfNVPsArrOrCollectionOrSingle As Collection)
    
    Dim listOfNVPs As Variant
    listOfNVPs = ensureValueIsAnArray(listOfNVPsArrOrCollectionOrSingle)
    
    Dim fieldNames As Collection
    Set fieldNames = getCombinedKeysFromDictionaries(listOfNVPs).toCollection()
    
    Dim listOf__fieldValuesOneCollectionPerNVP As Collection
    Set listOf__fieldValuesOneCollectionPerNVP = New Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs listOfNVPs, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
    
        Dim nvps As Dictionary
        Set nvps = listOfNVPs(c)
    
        Dim trancheSpecificFieldValues As Collection
        Set trancheSpecificFieldValues = New Collection
        
        Dim d As Long
        For d = 1 To fieldNames.count
            Dim fName As String
            fName = fieldNames.item(d)
            
            Dim fValue As Variant
            atr fValue, vfd(nvps, fName, True)
            
            trancheSpecificFieldValues.add fValue
        Next
        
        listOf__fieldValuesOneCollectionPerNVP.add trancheSpecificFieldValues
    Next
    
    Set out_fieldNames = fieldNames
    Set out_listOf__fieldValuesOneCollectionPerNVP = listOf__fieldValuesOneCollectionPerNVP
    
End Sub

'emsg = "Encountered a situation with non-unique IDs that we are not currently equipped to handle."
'Sub tryTheAssign(ByRef theDict As Dictionary, theKey As Variant, theValueToAdd As Variant, emsg As String)
Sub atd_showEMsgIfSomethingIsOverridden(ByRef theDict As Dictionary, theKey As Variant, theValueToAdd As Variant, emsg As String)
    Dim ovr As Variant
    atr ovr, atd(theDict, theKey, theValueToAdd)
    If Not isNothing(ovr) Then
        elwp emsg
    End If
End Sub

Function checkWhichKeysExistInDictionary(nvp As Dictionary, fieldNmesToTry As Variant) As Collection

    Dim fieldNamesToTry As Variant
    fieldNamesToTry = ensureValueIsAnArray(fieldNmesToTry)

    Dim whichOnes As Collection
    Set whichOnes = New Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs fieldNamesToTry, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim fName As String
        fName = fieldNamesToTry(c)
        
        If nvp.exists(fName) Then
            whichOnes.add fName
        End If
    Next
    
    Set checkWhichKeysExistInDictionary = whichOnes
End Function

Function groupArrayRowsByIndex(indx As Long, listOfArrayRows As Collection, forceKeyToBeString As Boolean) As Dictionary

    Dim listOfArrayRowsByKey As Dictionary
    Set listOfArrayRowsByKey = New Dictionary

    Dim c As Long
    For c = 1 To listOfArrayRows.count
        Dim arrayRow As Variant
        arrayRow = listOfArrayRows.item(c)
        
        Dim cand As Variant
        cand = rlai(arrayRow, indx)
        
        Dim key As Variant
        If forceKeyToBeString Then
            key = CStr(cand)
        Else
            key = cand
        End If
        
        addToListOfValuesByKey listOfArrayRowsByKey, key, arrayRow
    Next
    
    Set groupArrayRowsByIndex = listOfArrayRowsByKey

End Function
Attribute VB_Name = "JYUT_EquationParsing"
Option Explicit

Function getDenominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot(equation As String) As String
    
    Dim leftSide As String
    Dim rightSide As String
    separateLeftSideAndRightSideOfEquation leftSide, rightSide, equation
    
    Dim expression As String
    expression = rightSide
    
    Dim numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot As String
    Dim denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot As String
    separateExpressionIntoNumeratorAndDenominatorIfItIsASingleFraction numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot, denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot, expression
    
    getDenominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot
    
End Function

Sub separateExpressionIntoNumeratorAndDenominatorIfItIsASingleFraction(ByRef out_numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot As String, ByRef out_denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot As String, expression As String)
    
    Dim blocks As Collection
    Dim operators As Collection
    Set blocks = getExpressionBlocks(expression, operators, Nothing)
    
    Dim numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot As String
    Dim denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot As String
    If blocks.count = 2 Then
        If operators.count <> 1 Then
            elwp_se
            numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = ""
            denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = ""
        Else
            If operators.item(1) = "/" Then
                numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = blocks.item(1)
                denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = blocks.item(2)
            Else
                numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = ""
                denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = ""
            End If
        End If
    Else
        numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = ""
        denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = ""
    End If
    
    out_numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = numeratorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot
    out_denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot = denominatorIfWeCanTellThatRightSideOfequationIsSingleFraction_orBlankStringIfNot
    
End Sub

'There may be a more recent version of this function
Function getOperatorsIncludingParens() As Collection
    Dim ops As Collection
    Set ops = getOperators()
    With ops
        .add "("
        .add ")"
    End With
    Set getOperatorsIncludingParens = ops
End Function

'mod_emsgs____orNothingToPopUpRatherThanLog = nothing
Function getExpressionBlocks(expression As String, ByRef out_operatorsInBetween As Collection, ByRef mod_emsgs____orNothingToPopUpRatherThanLog As Variant) As Collection

    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set

    Dim blocks As Collection
    Set blocks = New Collection
    
    Dim opsIncludingParens As Variant
    opsIncludingParens = kta(getOperatorsIncludingParens())
    
    Dim operatorsOnly As Variant
    'operatorsOnly = kta(getOperators().toCollection())
    operatorsOnly = kta(getOperators())
    
    Dim remaining As String
    remaining = expression
    
    Dim levelsDeep As Long
    levelsDeep = 0
    
    Dim foundValue As String
    Dim nextIndx As Long
    nextIndx = nextIndxOfChoiceOfStrings(remaining, opsIncludingParens, foundValue)
    
    Dim curTkn As String
    curTkn = ""
    
    Dim operatorsInBetween As Collection
    Set operatorsInBetween = New Collection
    
    While nextIndx <> 0
        
        Dim leftSide As String
        Dim rightSide As String
        splitStringInTwo_aroundIndx leftSide, rightSide, remaining, nextIndx, 1
        
        If levelsDeep <= 0 Then
            If levelsDeep < 0 Then
                emsgs.add "Something uenxpected happened!"
            End If
            
            If curTkn <> "" Then
                emsgs.add "Something should not have happened, but did."
            End If
            
            blocks.add leftSide
            
            If foundValue = "(" Then
                levelsDeep = levelsDeep + 1
                curTkn = curTkn & foundValue
            ElseIf foundValue = ")" Then
                emsgs.add "Equation has mismatched parentheses!"
                
                addToLastBlockIfExists blocks, foundValue
                
            Else
                operatorsInBetween.add foundValue
            End If
            
        Else
            curTkn = curTkn & leftSide & foundValue
            
            If foundValue = "(" Then
                levelsDeep = levelsDeep + 1
            ElseIf foundValue = ")" Then
                levelsDeep = levelsDeep - 1
                If levelsDeep < 0 Then
                    levelsDeep = 0
                    emsgs.add "Mismatched parentheses detected!"
                End If
                
                If levelsDeep = 0 Then
                
                    
                    If blocks.count > operatorsInBetween.count Then
                        'There was no operator between this block and the last so we should combine
                        'this block with the last
                        
                        addToLastBlockIfExists blocks, curTkn
                        
                    Else
                        'Time to add a new block!
                        blocks.add curTkn
                    End If
                    
                    
                    curTkn = ""
                
                End If
                
            Else
                'DO NOTHING
            End If
        
        End If
        
        remaining = rightSide
        nextIndx = nextIndxOfChoiceOfStrings(remaining, opsIncludingParens, foundValue)
        
    Wend
    
    If levelsDeep <> 0 Or curTkn <> "" Then
        emsgs.add "Definitely have mismatched parentheses"
        blocks.add curTkn
    End If
    
    blocks.add remaining
    
    Dim expressionBlocks As Collection
    Set expressionBlocks = removeBlankValuesFromCollection(trimAllElementsInCollection(blocks))
    
    If operatorsInBetween.count <> (expressionBlocks.count - 1) Then
        emsgs.add "Something bad and weird happened."
    End If
    
    If isNothing(mod_emsgs____orNothingToPopUpRatherThanLog) Then
        elwp emsgs.toString(CHAR_CRLF, "")
    Else
        addToEmsgsObject mod_emsgs____orNothingToPopUpRatherThanLog, emsgs
    End If
    
    Set out_operatorsInBetween = operatorsInBetween
    Set getExpressionBlocks = expressionBlocks

End Function

Function reformatEquationSoThatOperatorsAreSeparatedByExactlyOneSpaceFromSurroundingElements(theEquationText As String, operators As JYCORE_Set) As String

    Dim indxOfFirstNonBlankSpace As Long
    indxOfFirstNonBlankSpace = getIndxOfFirstNonBlankSpace(theEquationText)
    
    Dim numLeadingSpaces
    If indxOfFirstNonBlankSpace = 0 Then
        numLeadingSpaces = Len(theEquationText)
    Else
        numLeadingSpaces = indxOfFirstNonBlankSpace - 1
    End If
    
    Dim leadingSpaces As String
    leadingSpaces = left(theEquationText, numLeadingSpaces)
    
    If Trim(leadingSpaces) <> "" Then
        elwp_se
    End If
    
    Dim equationText As String
    equationText = Right(theEquationText, Len(theEquationText) - numLeadingSpaces)
    
    Dim operatorsList As Collection
    Set operatorsList = operators.toCollection()
    
    Dim textSoFar As String
    textSoFar = equationText
    
    Dim c As Long
    For c = 1 To operatorsList.count
        Dim curOp As String
        curOp = operatorsList.item(c)
        
        textSoFar = replaceInString(textSoFar, curOp, " " & curOp & " ", False)
    Next
    
    'Now, remove consecutive spaces
    textSoFar = removeSpacesInBetweenWords(textSoFar)
    
    reformatEquationSoThatOperatorsAreSeparatedByExactlyOneSpaceFromSurroundingElements = leadingSpaces & textSoFar
    
End Function

Sub addToLastBlockIfExists(ByRef mod_blocks As Collection, valueToAdd As String)
    
    Dim lastBlock As String
    If mod_blocks.count > 0 Then
        lastBlock = mod_blocks.item(mod_blocks.count)
        mod_blocks.remove mod_blocks.count
    Else
        lastBlock = ""
    End If
    lastBlock = lastBlock & valueToAdd
    mod_blocks.add lastBlock
End Sub

Attribute VB_Name = "JYUT_ExecutableInterface"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'THIS IS AN INTERFACE!

Sub execute(data As Variant)
    'THIS IS A STUB METHOD, SINCE THE CURRENT CLASS IS AN INTERFACE!
    'DO NOTHING
End Sub
Attribute VB_Name = "JYUT_FilesAndFolders"
'This module has been moved to the JYCORE library.
Attribute VB_Name = "JYUT_Format"
Option Explicit

Public Const COLOR_ORANGE_FROM_THE_STANDARD_HEXAGON_CHART As String = "Orange from the standard hexagon chart"
Public Const COLOR_STEPHANO_CUSTOM_YELLOW____RED_244_GREEN_238_BLUE_0 As String = "Stephano's custom yellow.  Red=244, Green=238, Blue=0"

Public Const COLOR_WHITE_BACKGROUND_1 As String = "White, Background 1"
Public Const COLOR_ORANGE_ACCENT_6_DARKER_25_PCT As String = "Orange, Accent 6, Darker 25%"
Public Const COLOR_ORANGE_ACCENT_6_DARKER_50_PCT As String = "Orange, Accent 6, Darker 50%"
Public Const COLOR_ORANGE_ACCENT_6_LIGHTER_80_PCT As String = "Orange, Accent 6, Lighter 80%"
Public Const COLOR_WHITE_BACKGROUND_1_DARKER_15_PCT As String = "White, Background 1, Darker 15%"
Public Const COLOR_WHITE_BACKGROUND_1_DARKER_35_PCT As String = "White, Background 1, Darker 35%"
Public Const COLOR_TAN_BACKGROUND_2_DARKER_10_PCT As String = "Tan, Background 2, Darker 10%"
Public Const COLOR_TAN_BACKGROUND_2_DARKER_50_PCT As String = "Tan, Background 2, Darker 50%"
Public Const COLOR_TAN_BACKGROUND_2 As String = "Tan, Background 2"

Public Const COLOR_OLIVE_GREEN_ACCENT_3_LIGHTER_40_PCT As String = "Olive Green, Accent 3, Lighter 40%"

Public Const COLOR_DARK_BLUE_TEXT_2_LIGHTER_40_PCT As String = "Dark Blue, Text 2, Lighter 40%"
Public Const COLOR_YELLOW As String = "Yellow"
Public Const COLOR_AUTOMATIC_AND_NO_FILL As String = "Automatic, No Fill"
Public Const COLOR_BLUE As String = "Blue"
Public Const COLOR_BLUE_ACCENT_1_DARKER_25_PCT As String = "Blue, Accent 1, Darker 25%"
Public Const COLOR_BLUE_ACCENT_1_LIGHTER_80_PCT As String = "Blue, Accent 1, Lighter 80%"
Public Const COLOR_BLUE_ACCENT_1_LIGHTER_40_PCT As String = "Blue, Accent 1, Lighter 40%"
Public Const COLOR_RED_ACCENT_2_LIGHTER_80_PCT As String = "Red, Accent 2, Lighter 80%"
Public Const COLOR_RED_ACCENT_2_LIGHTER_40_PCT As String = "Red, Accent 2, Lighter 40%"
Public Const COLOR_BLACK_TEXT_1_LIGHTER_50_PCT As String = "Black, Text 1, Lighter 50%"
Public Const COLOR_PURPLE_ACCENT_4_DARKER_25_PCT As String = "Purple, Accent 4, Darker 25%"
Public Const COLOR_RED As String = "Red"
Public Const COLOR_LIGHT_GREEN As String = "Light Green"

Public Const NUMBER_FORMAT_GENERAL As String = "General"
Public Const NUMBER_FORMAT_TEXT As String = "@"
Public Const NUMBER_FORMAT_MMDDYYYY As String = "mm/dd/yyyy;@"
Public Const NUMBER_FORMAT_PCT_DECIMALS As String = "#,##0.00%;[Red](#,##0.00%)"
Public Const NUMBER_FORMAT_ZERO_DECIMALS As String = "#,##0_);[Red](#,##0)"
Public Const NUMBER_FORMAT_ONE_DECIMAL As String = "#,##0.0_);[Red](#,##0.0)"
Public Const NUMBER_FORMAT_TWO_DECIMALS As String = "#,##0.00_);[Red](#,##0.00)"
Public Const NUMBER_FORMAT_THREE_DECIMALS As String = "#,##0.000_);[Red](#,##0.000)"
Public Const NUMBER_FORMAT_DOLLAR_TWO_DECIMALS As String = "$#,##0.00_);[Red]($#,##0.00)"
Public Const NUMBER_FORMAT_TIME_WITH_AMPM As String = "[$-409]hh:mm:ss AM/PM;@"
Public Const NUMBER_FORMAT_DATE_WITH_TIME As String = "m/d/yyyy h:mm"
Public Const NUMBER_FORMAT_DATE_WITH_AMPM_TIME As String = "m/d/yyyy [$-409]hh:mm:ss AM/PM;@"
'Public Const NUMBER_FORMAT_DATE_WITHOUT_YEAR_WITH_AMPM_TIME As String = "m/d [$-409]hh:mm AM/PM;@"
Public Const NUMBER_FORMAT_AMPM_TIME As String = "[$-409]hh:mm:ss AM/PM;@"

'forExcelVsVBA = true
Function NUMBER_FORMAT_X_DECIMALS(numDecimals As Long, forExcelVsVBA As Boolean)
    Dim prefix As String
    prefix = "#,##0"
    
    Dim suffix As String
    If numDecimals <= 0 Then
        If numDecimals < 0 Then
            elwp "Please note that you specified a negative number of decimals."
        End If
        suffix = ""
    Else
    
        Dim suffixSoFar As String
        suffixSoFar = "."
        
        Dim c As Long
        For c = 1 To numDecimals
            suffixSoFar = suffixSoFar & "0"
        Next
    
        suffix = suffixSoFar
    End If
    
    Dim prefixSuffix As String
    prefixSuffix = prefix & suffix
    If forExcelVsVBA Then
        NUMBER_FORMAT_X_DECIMALS = prefixSuffix & "_);[Red](" & prefixSuffix & ")"
    Else
        NUMBER_FORMAT_X_DECIMALS = prefixSuffix & ";(" & prefixSuffix & ")"
    End If
End Function

Sub colorToFullSpecs(colorIndication As String, ByRef out_pattern As Variant, ByRef out_patternColorIndx As Variant, ByRef out_fontColor As Variant, ByRef out_backgroundColor As Variant, ByRef out_themeColor As Variant, ByRef out_tintAndShade As Variant, ByRef out_patternTintAndShade As Variant, ByRef out_fontColorIndx As Variant, ByRef out_backgroundColorIndx As Variant)
    
    Dim pattern As Variant
    Dim patternColorIndx As Variant
    Dim themeColor As Variant
    Dim fontColor As Variant
    Dim backgroundColor As Variant
    Dim tintAndShade As Variant
    Dim patternTintAndShade As Variant
    Dim fontColorIndx As Variant
    Dim backgroundColorIndx As Variant
    If colorIndication = COLOR_BLUE Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        Set themeColor = Nothing
        fontColor = 12611584
        backgroundColor = 12611584
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_BLUE_ACCENT_1_DARKER_25_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent1
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -0.249977111117893
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_BLUE_ACCENT_1_LIGHTER_80_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent1
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.799981688894314
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_BLUE_ACCENT_1_LIGHTER_40_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent1
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.399975585192419
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_RED_ACCENT_2_LIGHTER_80_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent2
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.799981688894314
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_LIGHT_GREEN Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        Set themeColor = Nothing
        fontColor = 5296274
        backgroundColor = -11480942
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_RED_ACCENT_2_LIGHTER_40_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent2
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.399975585192419
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_DARK_BLUE_TEXT_2_LIGHTER_40_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorLight2
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.399975585192419
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_YELLOW Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        Set themeColor = Nothing
        fontColor = -16711681
        backgroundColor = -16711681
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_OLIVE_GREEN_ACCENT_3_LIGHTER_40_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent3
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.399975585192419
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_TAN_BACKGROUND_2 Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorDark2
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_TAN_BACKGROUND_2_DARKER_10_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorDark2
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -9.99786370433668E-02
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_TAN_BACKGROUND_2_DARKER_50_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorDark2
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -0.499984740745262
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_WHITE_BACKGROUND_1_DARKER_35_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorDark1
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -0.349986266670736
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    
    ElseIf colorIndication = COLOR_WHITE_BACKGROUND_1_DARKER_15_PCT Then
    
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorDark1
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -0.149998474074526
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_RED Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        Set themeColor = Nothing
        fontColor = 255
        backgroundColor = 255
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_PURPLE_ACCENT_4_DARKER_25_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent4
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -0.249977111117893
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_BLACK_TEXT_1_LIGHTER_50_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorLight1
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.499984740745262
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_WHITE_BACKGROUND_1 Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorDark1
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_ORANGE_ACCENT_6_DARKER_25_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent6
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -0.249946592608417
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_ORANGE_ACCENT_6_DARKER_50_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent6
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = -0.499984740745262
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_ORANGE_ACCENT_6_LIGHTER_80_PCT Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        themeColor = xlThemeColorAccent6
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0.799981688894314
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_AUTOMATIC_AND_NO_FILL Then
        pattern = xlNone
        Set patternColorIndx = Nothing
        Set themeColor = Nothing
        Set fontColor = Nothing
        Set backgroundColor = Nothing
        tintAndShade = 0
        patternTintAndShade = 0
        fontColorIndx = xlAutomatic
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_ORANGE_FROM_THE_STANDARD_HEXAGON_CHART Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        Set themeColor = Nothing
        fontColor = -16737793
        backgroundColor = 39423
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    ElseIf colorIndication = COLOR_STEPHANO_CUSTOM_YELLOW____RED_244_GREEN_238_BLUE_0 Then
        pattern = xlSolid
        patternColorIndx = xlAutomatic
        Set themeColor = Nothing
        fontColor = -16716044
        backgroundColor = 61172
        tintAndShade = 0
        patternTintAndShade = 0
        Set fontColorIndx = Nothing
        Set backgroundColorIndx = Nothing
    Else
        elwp "Unknown color:" & Color
    End If
    
    atr out_pattern, pattern
    atr out_patternColorIndx, patternColorIndx
    atr out_themeColor, themeColor
    atr out_fontColor, fontColor
    atr out_backgroundColor, backgroundColor
    atr out_tintAndShade, tintAndShade
    atr out_patternTintAndShade, patternTintAndShade
    atr out_fontColorIndx, fontColorIndx
    atr out_backgroundColorIndx, backgroundColorIndx
End Sub

Sub setBackground(theRnge As Range, colorIndication As String)
    
On Error GoTo ehs
    
    Dim pattern As Variant
    Dim patternColorIndx As Variant
    Dim fontColor As Variant
    Dim backgroundColor As Variant
    Dim themeColor As Variant
    Dim tintAndShade As Variant
    Dim patternTintAndShade As Variant
    Dim fontColorIndx As Variant
    Dim backgroundColorIndx As Variant
    colorToFullSpecs colorIndication, pattern, patternColorIndx, fontColor, backgroundColor, themeColor, tintAndShade, patternTintAndShade, fontColorIndx, backgroundColorIndx
    
    With theRnge.Interior
        If Not isNothing(pattern) Then
            .pattern = pattern
        End If
        If Not isNothing(patternColorIndx) Then
            .PatternColorIndex = patternColorIndx
        End If
        If Not isNothing(backgroundColor) Then
            .Color = backgroundColor
        End If
        If Not isNothing(themeColor) Then
            .themeColor = themeColor
        End If
        If Not isNothing(tintAndShade) Then
            .tintAndShade = tintAndShade
        End If
        If Not isNothing(patternTintAndShade) Then
            .patternTintAndShade = patternTintAndShade
        End If
        If Not isNothing(backgroundColorIndx) Then
            .ColorIndex = backgroundColorIndx
        End If
    End With
    
GoTo ehe
ehs:
    elg getFormatEMsg("background", Err.description)
ehe:
On Error GoTo 0

    
End Sub

Function getFontColorSpec(fontColorCell As Range) As Variant
    
    Dim fontColorIndx As Variant
    Dim fontColor As Variant
    Dim themeColor As Variant
    Dim tintAndShade As Variant
    getFontColorFromCell fontColorCell, fontColorIndx, fontColor, themeColor, tintAndShade
    
    getFontColorSpec = Array(fontColorIndx, fontColor, themeColor, tintAndShade)
End Function

Sub doSetColor(theRnge As Range, fontColorIndx As Variant, fontColor As Variant, themeColor As Variant, tintAndShade As Variant)

    With theRnge.Font
        If Not isNothing(fontColorIndx) Then
            .ColorIndex = fontColorIndx
        End If
        If Not isNothing(fontColor) Then
            setFontColor theRnge, fontColor
        End If
        If Not isNothing(themeColor) Then
            .themeColor = themeColor
        End If
        If Not isNothing(tintAndShade) Then
            .tintAndShade = tintAndShade
        End If
    End With

End Sub

Sub setFontColor(theRnge As Range, fontColor As Variant)
On Error GoTo ehs
    theRnge.Font.Color = fontColor
GoTo ehe
ehs:
    ilg "Could not set the font color for some reason!  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Sub getFontColorFromCell(theRnge As Range, ByRef out_fontColorIndx As Variant, ByRef out_fontColor As Variant, ByRef out_themeColor As Variant, ByRef out_tintAndShade As Variant)
    
    atr out_fontColorIndx, getFontColorIndex(theRnge.Font)
    atr out_fontColor, getFontColor(theRnge.Font)
    atr out_themeColor, getFontThemeColor(theRnge.Font)
    atr out_tintAndShade, getFontTintAndShade(theRnge.Font)
    
End Sub

Function getFontColorIndex(theFont As Font) As Variant

    Dim retValue As Variant
    Set retValue = Nothing

On Error GoTo ehs

    atr retValue, theFont.ColorIndex

GoTo ehe
ehs:
    elg "Could not obtain font color index.  Msg=" & Err.description
ehe:
On Error GoTo 0

    atr getFontColorIndex, retValue

End Function
Function getFontColor(theFont As Font)
    Dim retValue As Variant
    Set retValue = Nothing

On Error GoTo ehs

    atr retValue, theFont.Color

GoTo ehe
ehs:
    elg "Could not obtain font color.  Msg=" & Err.description
ehe:
On Error GoTo 0

    atr getFontColor, retValue

End Function
Function getFontThemeColor(theFont As Font)
    Dim retValue As Variant
    Set retValue = Nothing

On Error GoTo ehs

    atr retValue, theFont.themeColor

GoTo ehe
ehs:
    elg "Could not obtain font theme color.  Msg=" & Err.description
ehe:
On Error GoTo 0

    atr getFontThemeColor, retValue

End Function
Function getFontTintAndShade(theFont As Font)
    Dim retValue As Variant
    Set retValue = Nothing

On Error GoTo ehs

    atr retValue, theFont.tintAndShade

GoTo ehe
ehs:
    elg "Could not obtain font tint and shade.  Msg=" & Err.description
ehe:
On Error GoTo 0

    atr getFontTintAndShade, retValue

End Function

Sub setColor(theRnge As Range, colorIndication As String)
    
    Dim pattern As Variant
    Dim patternColorIndx As Variant
    Dim fontColor As Variant
    Dim backgroundColor As Variant
    Dim themeColor As Variant
    Dim tintAndShade As Variant
    Dim patternTintAndShade As Variant
    Dim fontColorIndx As Variant
    Dim backgroundColorIndx As Variant
    colorToFullSpecs colorIndication, pattern, patternColorIndx, fontColor, backgroundColor, themeColor, tintAndShade, patternTintAndShade, fontColorIndx, backgroundColorIndx
    
    doSetColor theRnge, fontColorIndx, fontColor, themeColor, tintAndShade
    
End Sub

Sub setPattern(theRnge As Range, pattern As Variant)
On Error GoTo ehs
    theRnge.Interior.pattern = pattern
GoTo ehe
ehs:
    elg getFormatEMsg("interior pattern property", Err.description)
ehe:
On Error GoTo 0
    
End Sub

Sub insertIndentInRnge(theRnge As Range, insertAmount As Long)
On Error GoTo ehs
    
    theRnge.InsertIndent insertAmount

GoTo ehe
ehs:
    elg getFormatEMsg("indentation", Err.description)
ehe:
On Error GoTo 0

End Sub

Sub setItalic(theRnge As Range, italics As Boolean)

On Error GoTo ehs
    theRnge.Font.Italic = italics

GoTo ehe
ehs:
    elg getFormatEMsg("italic property", Err.description)
ehe:
On Error GoTo 0

End Sub

Sub setStrikethrough(theRnge As Range, strikeThrough As Boolean)
On Error GoTo ehs
    theRnge.Font.strikeThrough = strikeThrough
GoTo ehe
ehs:
    elg getFormatEMsg("strikethrough property", Err.description)
ehe:
On Error GoTo 0
End Sub

Sub setBold(theRnge As Range, bold As Boolean)
On Error GoTo ehs
    theRnge.Font.bold = bold

GoTo ehe
ehs:
    elg getFormatEMsg("bold property", Err.description)
ehe:
On Error GoTo 0
    
End Sub

Sub setFontSize(theRnge As Range, fontSize As Long)
On Error GoTo ehs
    theRnge.Font.size = fontSize

GoTo ehe
ehs:
    elg getFormatEMsg("bold property", Err.description)
ehe:
On Error GoTo 0
    
End Sub

Function getFormatEMsg(formatType As String, emsg As String) As String
    getFormatEMsg = "Could not set a range's " & formatType & ".  Reason: " & emsg
End Function

Sub setWrapText(theRnge As Range, wrapText As Boolean)
On Error GoTo ehs
    Dim preExistingWrapText As Variant
    preExistingWrapText = theRnge.wrapText
    
    Dim shouldAdj As Boolean
    If IsNull(preExistingWrapText) Then
        shouldAdj = True
    ElseIf preExistingWrapText = wrapText Then
        shouldAdj = False
    Else
        shouldAdj = True
    End If
    
    If shouldAdj Then
        theRnge.wrapText = wrapText
    End If
GoTo ehe
ehs:
    elg getFormatEMsg("wrapText property", Err.description)
ehe:
On Error GoTo 0

End Sub

Sub setNumberFormatsForTableData(headerRnge As Range, listOfNumFormats As Collection)
    
    Dim lastCell As Range
    Set lastCell = brcor(headerRnge)
    
    Dim firstCell As Range
    Set firstCell = gcicsr(tlcor(headerRnge), lastCell.row)
    
    Dim colsInHeader As Long
    colsInHeader = lastCell.column - firstCell.column + 1

    If colsInHeader <> listOfNumFormats.count Then
        elwp "Could not set column formats.  We expected & " & listOfNumFormats.count & " columns to be in our header, but there are only " & colsInHeader & "."
    Else
        Dim c As Long
        For c = firstCell.column To lastCell.column
            
            Dim indx As Long
            indx = c - firstCell.column + 1
            
            Dim numFormat As String
            numFormat = listOfNumFormats.item(indx)
            
            If Trim(numFormat) = "" Then
                'DO NOTHING
            Else
                Dim ank As Range
                Set ank = gcirsc(firstCell, c)
                
                setNumberFormat getColumnDataRnge(ank), numFormat
            End If
        Next
    End If
End Sub


Sub setNumberFormat(theRnge As Range, numberFormat As String)
On Error GoTo ehs
    theRnge.numberFormat = numberFormat
GoTo ehe
ehs:
    elg getFormatEMsg("number format property", Err.description)
ehe:
On Error GoTo 0
End Sub

Sub turnAllBordersOn(rnge As Range)
    turnAllBordersOn_customColorSettings rnge, Nothing, Nothing, Nothing
    
End Sub

Sub turnAllBordersOn_customColorSettings(rnge As Range, optColorIndex As Variant, optThemeColor As Variant, optTintAndShade As Variant)
    rnge.borders(xlDiagonalDown).LineStyle = xlNone
    rnge.borders(xlDiagonalUp).LineStyle = xlNone
    
    Dim colorIndx As Variant
    If isNothing(optColorIndex) Then
        colorIndx = xlAutomatic
    Else
        colorIndx = optColorIndex
    End If
    
    Dim themeColor As Variant
    If isNothing(optThemeColor) Then
        Set themeColor = Nothing
    Else
        themeColor = optThemeColor
    End If
    
    Dim tintAndShade As Variant
    If isNothing(optTintAndShade) Then
        tintAndShade = 0
    Else
        tintAndShade = optTintAndShade
    End If
     
    setStandardBorder_customColorSettings rnge.borders(xlEdgeLeft), colorIndx, themeColor, tintAndShade
    setStandardBorder_customColorSettings rnge.borders(xlEdgeTop), colorIndx, themeColor, tintAndShade
    setStandardBorder_customColorSettings rnge.borders(xlEdgeBottom), colorIndx, themeColor, tintAndShade
    setStandardBorder_customColorSettings rnge.borders(xlEdgeRight), colorIndx, themeColor, tintAndShade
    setStandardBorder_customColorSettings rnge.borders(xlInsideVertical), colorIndx, themeColor, tintAndShade
    setStandardBorder_customColorSettings rnge.borders(xlInsideVertical), colorIndx, themeColor, tintAndShade

End Sub

Sub clearBorder(borders As Variant)
    With borders
        .LineStyle = xlNone
    End With
End Sub


Sub setOutsideBorders(sel As Range)
    setStandardBorder sel.borders(xlEdgeLeft)
    setStandardBorder sel.borders(xlEdgeTop)
    setStandardBorder sel.borders(xlEdgeBottom)
    setStandardBorder sel.borders(xlEdgeRight)
End Sub

Sub setAllBorders(sel As Range)
    setOutsideBorders sel
    setInsideVerticalBorders sel
    setOutsideVerticalBorders sel
End Sub

Sub setStandardBorder_WHITE_BACKGROUND_1_DARKER_25PCT(borders As Variant)
    setStandardBorder_customColorSettings borders, Nothing, 1, -0.249946592608417
End Sub

Sub setStandardBorder_customColorSettings(borders As Variant, optColorIndex As Variant, optThemeColor As Variant, optTintAndShade As Variant)

    With borders
        .LineStyle = xlContinuous
        
        If Not isNothing(optColorIndex) Then
            .ColorIndex = optColorIndex
        End If
        
        If Not isNothing(optThemeColor) Then
            .themeColor = optThemeColor
        End If
        
        If Not isNothing(optTintAndShade) Then
            .tintAndShade = optTintAndShade
        End If
        
        .Weight = xlThin
    End With

End Sub

Sub setStandardBorder(borders As Variant)
    setStandardBorder_customColorSettings borders, 0, Nothing, 0
End Sub

Sub setHairlineBorder(borders As Variant)
    With borders
        .LineStyle = xlContinuous
        .ColorIndex = 0
        .tintAndShade = 0
        .Weight = xlHairline
    End With
End Sub

Sub setInsideVerticalBorders(sel As Range)
    setStandardBorder sel.borders(xlInsideVertical)
End Sub

Sub setOutsideVerticalBorders(sel As Range)
    setStandardBorder sel.borders(xlInsideHorizontal)
End Sub

'JY20140425a - start
'Sub setToGenericHeaderFormat(sel As Range)
'
'    With sel.Font
'        .themeColor = xlThemeColorDark1
'        .tintAndShade = -4.99893185216834E-02
'    End With
'    With sel.Interior
'        .pattern = xlSolid
'        .PatternColorIndex = xlAutomatic
'        .Color = 12611584
'        .tintAndShade = 0
'        .patternTintAndShade = 0
'    End With
'End Sub
'JY20140425a - end


'Sub copyBorders(srcRnge As Range, destRnge As Range)
'
'    Dim borderIndexes As Collection
'    Set borderIndexes = getAllBorderIndexes()
'
'    Dim c As Long
'    For c = 1 To borderIndexes.count
'        Dim indx As Variant
'        indx = borderIndexes.item(c)
'
'        Dim srcBorder As border
'        Set srcBorder = srcRnge.borders(indx)
'
'        Dim destBorder As border
'        Set destBorder = destRnge.borders(indx)
'
'        srcBorder.Color = destBorder.Color
'        srcBorder.ColorIndex = destBorder.ColorIndex
'        srcBorder.LineStyle = destBorder.LineStyle
'        setBorderThemeColorToMatchIfPossible srcBorder, destBorder
'        srcBorder.tintAndShade = destBorder.tintAndShade
'        srcBorder.Weight = destBorder.Weight
'
'    Next
'
'
'End Sub
'
'Function setBorderThemeColorToMatchIfPossible(ByRef mod_border As border, srcBorder As border)
'
'On Error GoTo ehs
'    atr mod_border.themeColor, srcBorder.themeColor
'GoTo ehe
'ehs:
'    'DO NOTHING
'ehe:
'On Error GoTo 0
'End Function
'
'Function getAllBorderIndexes() As Collection
'    Dim list As Collection
'    Set list = New Collection
'    With list
'        .add xlDiagonalDown
'        .add xlDiagonalUp
'        .add xlEdgeBottom
'        .add xlEdgeLeft
'        .add xlEdgeRight
'        .add xlEdgeTop
'        .add xlInsideHorizontal
'        .add xlInsideVertical
'    End With
'
'    Set getAllBorderIndexes = list
'End Function

Function canBeConvertedToNumber(possibleNumber As Variant) As Boolean
On Error GoTo ehs

    Dim canBeConverted As Boolean
    canBeConverted = False
    
    Dim tmp As Variant
    tmp = CDbl(possibleNumber)
    
    canBeConverted = True

GoTo ehe
ehs:
    'DO NOTHING
ehe:
On Error GoTo 0

    canBeConvertedToNumber = canBeConverted

End Function


'"cbcd" stands for "canBeConvertedToDate"
Function cbcd(possibleDate As Variant) As Boolean
On Error GoTo ehs

    Dim canBeConverted As Boolean
    canBeConverted = False
    
    Dim tmp As Variant
    tmp = CDate(possibleDate)
    
    canBeConverted = True

GoTo ehe
ehs:
    'DO NOTHING
ehe:
On Error GoTo 0

    cbcd = canBeConverted

End Function

Function convertToCouponWithPercentageSignIfPossible(candidate As Variant) As String
    If isNumber(candidate) Then
        convertToCouponWithPercentageSignIfPossible = (100 * candidate) & "%"
    Else
        convertToCouponWithPercentageSignIfPossible = candidate
    End If
End Function

Function formatIfPossibleByAddingCommasToSeparateNumbers(candidate As Variant) As String
    If isNumber(candidate) Then
        
        Dim daNum As String
        daNum = CStr(candidate)
        
        Dim indxOfDecimal As Long
        indxOfDecimal = InStr(1, daNum, ".")
        
        Dim firstPart As String
        Dim secondPart As String
        If indxOfDecimal = 0 Then
            firstPart = daNum
            secondPart = ""
        Else
            firstPart = left(daNum, indxOfDecimal - 1)
            secondPart = Right(daNum, Len(daNum) - Len(firstPart))
        End If
        
        Dim soFar As String
        soFar = ""
        
        Dim cnt As Long
        cnt = 0
        
        Dim c As Long
        For c = Len(firstPart) To 1 Step -1
            cnt = cnt + 1
            If cnt = 4 Then
                cnt = 1
                soFar = "," & soFar
            End If
            
            soFar = Mid(firstPart, c, 1) & soFar
            
        Next
    
        formatIfPossibleByAddingCommasToSeparateNumbers = soFar & secondPart
    Else
        formatIfPossibleByAddingCommasToSeparateNumbers = candidate
    End If
End Function

'--------------------------------------------------------------------------------------------------------------
'Conditional Formatting
'--------------------------------------------------------------------------------------------------------------
Sub deleteConditionalFormats(rng As Range)
    rng.formatConditions.Delete
End Sub

Sub deleteConditionalFormatsFromEntireSheet(ws As Worksheet)
    ssbm "Deleting conditional formats from the worksheet '" & ws.name & "'..."
    deleteConditionalFormats ws.cells
    ssbm "Conditional formats deleted from the worksheet '" & ws.name & "'!"
End Sub

Sub applyListOfConditionalFormatsInOrderThatResultInBackgroundColorGettingSet(rngeToSetFormatsOn As Range, listOf__formula_bgColor As Collection, stopIfTrue As Boolean)
    
    Dim d As Long
    For d = 1 To listOf__formula_bgColor.count
    
        Dim formula_bgColor As Variant
        formula_bgColor = listOf__formula_bgColor.item(d)
        
        Dim formula As String
        Dim bgColor As Long
        formula = rlai(formula_bgColor, 1)
        bgColor = rlai(formula_bgColor, 2)
    
        Dim isFirst As Boolean
        isFirst = (d = 1)
    
        addConditionalFormattingWhereBackgroundColorIsSet rngeToSetFormatsOn, formula, bgColor, False, stopIfTrue, isFirst
    Next
End Sub
Sub addConditionalFormattingWhereBackgroundColorIsSet(rng As Range, equation As String, desiredBGColor As Long, setAsFirstPriority As Boolean, stopIfTrue, deletePreExistingConditionalFormats As Boolean)

    Dim setter As JYUT_CondFmtBackgrndSetter
    Set setter = New JYUT_CondFmtBackgrndSetter
    With setter
        .backgroundColor = desiredBGColor
    End With
    
    addConditionalFormatting rng, equation, setter, setAsFirstPriority, stopIfTrue, deletePreExistingConditionalFormats

End Sub

'"=TRIM(LOWER($Z$54))=""y"""
'stopIfTrue = false
Sub addConditionalFormatting(rng As Range, equation As String, formatApplier As JYUT_CondFormatApplierInterface, setAsFirstPriority As Boolean, stopIfTrue, deletePreExistingConditionalFormats As Boolean)

    If deletePreExistingConditionalFormats Then
        deleteConditionalFormats rng
    End If

    Dim formatConditions As formatConditions
    Set formatConditions = rng.formatConditions
    
    formatConditions.add Type:=xlExpression, Formula1:=equation
    
    Dim theFormatCondition As FormatCondition
    atr theFormatCondition, formatConditions(formatConditions.count)
    
    formatApplier.applyFormatToFormatConditions theFormatCondition
    
    If setAsFirstPriority Then
        theFormatCondition.SetFirstPriority
    End If
    theFormatCondition.stopIfTrue = stopIfTrue
 
End Sub

'==============================================================================================================

'example: xlCenter
'example: xlHAlignRight
Sub setHorizAlignment(rng As Range, alignment As Variant)
    rng.HorizontalAlignment = alignment
End Sub

'example: xlCenter
Sub setVerticalAlignment(rng As Range, alignment As Variant)
    rng.VerticalAlignment = alignment
End Sub

Function combineCellsIntoRnge(listOfCells As Collection) As Range

    Dim listOfRngeDefs As Collection
    Set listOfRngeDefs = New Collection
    
    Dim ws As Worksheet
    Set ws = listOfCells.item(1).Worksheet
    
    Dim c As Long
    For c = 1 To listOfCells.count
        Dim curCell As Range
        Set curCell = listOfCells.item(c)
        
        If Not worksheetsAreTheSame(curCell.Worksheet, ws) Then
            elwp "Please pass in cells from the same worksheet!"
        End If
        
        listOfRngeDefs.add getFullRngeDefinition(curCell, False, False, False, False)
    Next
    
    Dim finalRngeDef As String
    finalRngeDef = cltstr(listOfRngeDefs, ",", "\")
    
    Dim finalRnge As Range
    Set finalRnge = rnge(finalRngeDef, ws)
    
    Set combineCellsIntoRnge = finalRnge
    

End Function

Function combineCellsIntoFewerRngeObjects(listOfCells As Collection, ByRef mod_emsgs As Variant) As Collection

    Dim maxNumOfCellsPerRnge As Long
    maxNumOfCellsPerRnge = 20 '<-- arbitrary, the higher the better, but there is some limit somewhere and I don't remember what it is

    Dim listOfRnges As Collection
    Set listOfRnges = New Collection
    
    Dim chain As Collection
    Set chain = New Collection
    
    Dim c As Long
    For c = 1 To listOfCells.count
    
        chain.add listOfCells.item(c)
    
        If chain.count >= maxNumOfCellsPerRnge Then
            Dim daRnge As Range
            Set daRnge = combineCellsIntoRnge(chain)
            
            If isNothing(daRnge) Then
                mod_emsgs.add "Some cells could not be shaded."
            Else
                listOfRnges.add daRnge
                Set chain = New Collection
            End If
        End If
        
    Next
    If chain.count > 0 Then
        listOfRnges.add combineCellsIntoRnge(chain)
    End If

    Set combineCellsIntoFewerRngeObjects = listOfRnges
End Function
Attribute VB_Name = "JYUT_Formulas"
Option Explicit

Public Const STRING_FOR_UNKNOWN_MONTH_NUM As String = "???"

Function numberFormat(theRnge As Range) As String
    numberFormat = theRnge.numberFormat
End Function

Function concatCellValues(theCells As Range, delimiter As String) As String
    
    Dim daCells As Collection
    Set daCells = getCellsInRnge(theCells)
    
    Dim vals As Collection
    Set vals = New Collection
    
    Dim c As Long
    For c = 1 To daCells.count
        vals.add gvl(daCells.item(c))
    Next
    
    concatCellValues = cltstr(vals, delimiter, "")
End Function

Function distinctValues(rng As Range, delimiter As String) As String
    
    Dim daCells As Collection
    Set daCells = getCellsInRnge(rng)
    
    Dim st As JYCORE_Set
    Set st = New JYCORE_Set
    
    Dim c As Long
    For c = 1 To daCells.count
        st.add gvl(daCells.item(c))
    Next
    
    distinctValues = st.toString(delimiter, "")

End Function

Function monthNumToStringIfPossible(mm As Variant) As String

    If isInteger(mm) Then
        Dim candidate As String
        candidate = monthNumToName(CLng(mm))
        
        If candidate = STRING_FOR_UNKNOWN_MONTH_NUM Then
            monthNumToStringIfPossible = mm
        Else
            monthNumToStringIfPossible = candidate
        End If
    Else
        monthNumToStringIfPossible = mm
    End If
End Function

Function monthNumToName(num As Long) As String

    Dim result As String
    If num = 1 Then
        result = "January"
    ElseIf num = 2 Then
        result = "February"
    ElseIf num = 3 Then
        result = "March"
    ElseIf num = 4 Then
        result = "April"
    ElseIf num = 5 Then
        result = "May"
    ElseIf num = 6 Then
        result = "June"
    ElseIf num = 7 Then
        result = "July"
    ElseIf num = 8 Then
        result = "August"
    ElseIf num = 9 Then
        result = "September"
    ElseIf num = 10 Then
        result = "October"
    ElseIf num = 11 Then
        result = "November"
    ElseIf num = 12 Then
        result = "December"
    Else
        result = STRING_FOR_UNKNOWN_MONTH_NUM
    End If
    monthNumToName = result
End Function

Function getExcelFormulaForConvertingDateToYYYYMMDD(rnForDate As String) As String
    getExcelFormulaForConvertingDateToYYYYMMDD = "=YEAR(" & rnForDate & ")&IF(MONTH(" & rnForDate & ")<10,""0"","""")&MONTH(" & rnForDate & ")&IF(DAY(" & rnForDate & ")<10,""0"","""")&DAY(" & rnForDate & ")"
End Function
Function getDynamicColRngeDef(rnForFirstDataCell As String, rnForNumEntries As String) As String
    getDynamicColRngeDef = "OFFSET(" & rnForFirstDataCell & ",0,0," & rnForNumEntries & ",1)"
End Function

Function getTabName(cellOnTab As Range) As String
    getTabName = cellOnTab.Worksheet.name
End Function

Function getPrevBizDay_noCalendar(theDate As Date) As Date

    getPrevBizDay_noCalendar = getPreviousBusinessDay(theDate, New JYCORE_Set)

End Function

Private Function convertHolidayDatesRngeToHolidayDatesSet(holidaydatesrnge As Range) As JYCORE_Set

    Dim tlRow As Long
    Dim tlCol As Long
    Dim brRow As Long
    Dim brCol As Long
    getRngeBounds holidaydatesrnge, tlRow, tlCol, brRow, brCol
    
    Dim ws As Worksheet
    Set ws = holidaydatesrnge.Worksheet
    
    Dim usedRnge As Range
    Set usedRnge = ws.UsedRange
    
    Dim urTlRow As Long
    Dim urTlCol As Long
    Dim urBrRow As Long
    Dim urBrCol As Long
    getRngeBounds usedRnge, urTlRow, urTlCol, urBrRow, urBrCol
    
    Dim finalTLRow As Long '
    Dim finalTLCol As Long
    Dim finalBRRow As Long
    Dim finalBRCol As Long
    finalTLRow = wsFunctionMax(urTlRow, tlRow)
    finalTLCol = wsFunctionMax(urTlCol, tlCol)
    finalBRRow = wsFunctionMin(urBrRow, brRow)
    finalBRCol = wsFunctionMin(urBrCol, brCol)
    
    Dim finalRnge As Range
    Set finalRnge = rngeToRnge(ws.cells(finalTLRow, finalTLCol), ws.cells(finalBRRow, finalBRCol))

    Dim holidayDatesArr As Variant
    holidayDatesArr = finalRnge.value
    If Not IsArray(holidayDatesArr) Then
        holidayDatesArr = Array(holidayDatesArr)
    End If

    Dim holidayDates As JYCORE_Set
    Set holidayDates = collectionToSet(arrayToCollection(twoDimArrayToOneDimArray(holidayDatesArr)))
    
    Set convertHolidayDatesRngeToHolidayDatesSet = holidayDates

End Function

Function getPrevBizDay(theDate As Date, Optional holidaydatesrnge As Range) As Date

    Dim holidayDates As JYCORE_Set
    If IsMissing(holidaydatesrnge) Then
        Set holidayDates = New JYCORE_Set
    Else
        Set holidayDates = convertHolidayDatesRngeToHolidayDatesSet(holidaydatesrnge)
    End If

    getPrevBizDay = getPreviousBusinessDay(theDate, holidayDates)
End Function

Function getLastBizDayOfTheMonth(anyDateInTheMonthWeWantToComputeFor As Date, Optional holidaydatesrnge As Range) As Date
    Dim holidayDates As JYCORE_Set
    If IsMissing(holidaydatesrnge) Then
        Set holidayDates = New JYCORE_Set
    Else
        Set holidayDates = convertHolidayDatesRngeToHolidayDatesSet(holidaydatesrnge)
    End If
    
    getLastBizDayOfTheMonth = computeLastBusinessDayOfTheMonth(anyDateInTheMonthWeWantToComputeFor, holidayDates)


End Function

Function getXthPrevBusinessDay(fromDte As Date, x As Long, Optional holidaydatesrnge As Range) As Date
    
    Dim holidayDates As JYCORE_Set
    If IsMissing(holidaydatesrnge) Then
        Set holidayDates = New JYCORE_Set
    Else
        Set holidayDates = convertHolidayDatesRngeToHolidayDatesSet(holidaydatesrnge)
    End If
    
    getXthPrevBusinessDay = getXthPreviousBusinessDay(fromDte, holidayDates, x)
    
End Function


Function convertToDateOrValueIfPossible(val As Variant) As Variant
    
    Dim retVal As Variant
    If isNumber(val) Then
        retVal = CDbl(val)
    ElseIf IsDate(val) Then
        retVal = CDate(val)
    Else
        retVal = val
    End If
    
    convertToDateOrValueIfPossible = retVal
End Function

Function getPrevBizDay_noHolidays(theDate As Date) As Date
    getPrevBizDay_noHolidays = getPreviousBusinessDay(theDate, New JYCORE_Set)
End Function

Function dteDiff(interval As String, date1 As Variant, date2 As Variant) As Variant
    dteDiff = DateDiff(interval, date1, date2)
End Function

Function dteAdd(interval As String, num As Double, dte As Variant) As Variant
    dteAdd = DateAdd(interval, num, dte)
End Function

Function getEarliestWeekdayBeforeOrAfterSpecifiedWeekdayOrReturnBlnkIfWeekend(dte As Variant, beforeVsAfter As Boolean, inclusiveVsExclusive As Boolean) As Variant

    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    Dim retVal As Variant
    atr retVal, getEarliestWeekdayBeforeOrAfterSpecifiedWeekdayOrReturnBlankIfWeekend(dte, beforeVsAfter, inclusiveVsExclusive, emsgs)
    
    If emsgs.count <> 0 Then
        getEarliestWeekdayBeforeOrAfterSpecifiedWeekdayOrReturnBlnkIfWeekend = emsgs.toString(" ... ", "")
    Else
        atr getEarliestWeekdayBeforeOrAfterSpecifiedWeekdayOrReturnBlnkIfWeekend, retVal
    End If

End Function

Attribute VB_Name = "JYUT_Grammar"
Option Explicit

Sub getAppropriateSingularOrPluralGrammar(numRequestsRepresented As Long, ByRef out_isOrAre As String, ByRef out_hasOrHave As String, ByRef out_optS As String, ByRef out_wasWere As String)
    If numRequestsRepresented = 1 Then
        out_isOrAre = "is"
        out_hasOrHave = "has"
        out_optS = ""
        out_wasWere = "was"
    Else
        out_isOrAre = "are"
        out_hasOrHave = "have been"
        out_optS = "s"
        out_wasWere = "were"
    End If
End Sub


Attribute VB_Name = "JYUT_Interp"
Option Explicit

'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
'Function getBackMaturity(al As Double) As Double
'
'    If (al = Sheets("TSY Data").Range("AL_3M").value Or al = Sheets("TSY Data").Range("AL_6M").value Or al = Sheets("TSY Data").Range("AL_1Y").value Or al = Sheets("TSY Data").Range("AL_2Y").value Or al = Sheets("TSY Data").Range("AL_3Y").value Or al = Sheets("TSY Data").Range("AL_5Y").value Or al = Sheets("TSY Data").Range("AL_7Y").value Or al = Sheets("TSY Data").Range("AL_10Y").value Or al = Sheets("TSY Data").Range("AL_30Y").value) Then
'        getBackMaturity = al
'    ElseIf (al > Sheets("TSY Data").Range("AL_10Y").value) Then
'        al = Sheets("TSY Data").Range("AL_30Y").value
'    ElseIf (al > Sheets("TSY Data").Range("AL_7Y").value And al < Sheets("TSY Data").Range("AL_10Y").value) Then
'        al = Sheets("TSY Data").Range("AL_10Y").value
'    ElseIf (al > Sheets("TSY Data").Range("AL_5Y").value And al < Sheets("TSY Data").Range("AL_7Y").value) Then
'        al = Sheets("TSY Data").Range("AL_7Y").value
'    ElseIf (al > Sheets("TSY Data").Range("AL_3Y").value And al < Sheets("TSY Data").Range("AL_5Y").value) Then
'        al = Sheets("TSY Data").Range("AL_5Y").value
'    ElseIf (al > Sheets("TSY Data").Range("AL_2Y").value And al < Sheets("TSY Data").Range("AL_3Y").value) Then
'        al = Sheets("TSY Data").Range("AL_3Y").value
'    ElseIf (al > Sheets("TSY Data").Range("AL_1Y").value And al < Sheets("TSY Data").Range("AL_2Y").value) Then
'        al = Sheets("TSY Data").Range("AL_2Y").value
'    ElseIf (al > Sheets("TSY Data").Range("AL_6M").value And al < Sheets("TSY Data").Range("AL_1Y").value) Then
'        al = Sheets("TSY Data").Range("AL_1Y").value
'    ElseIf (al > Sheets("TSY Data").Range("AL_3M").value And al < Sheets("TSY Data").Range("AL_6M").value) Then
'        al = Sheets("TSY Data").Range("AL_6M").value
'    Else
'        'MsgBox ("Not a valid Front spot on the curve")
'
'    End If
'getBackMaturity = al

Function getBackMaturity(al As Double, listOfAvailMaturitiesInAscendingOrder As Collection) As Double

    Dim chosen As Variant
    atr chosen, getFrontOrBackMaturity(listOfAvailMaturitiesInAscendingOrder, False, al)
    
    Dim backMat As Variant
    If isNothing(chosen) Then
        backMat = Empty
    Else
        backMat = chosen
    End If

    getBackMaturity = backMat

'JY20130627d - end


End Function

Function getFrontOrBackMaturity(listOfAvailMaturitiesInAscendingOrder As Collection, frontVsBack As Boolean, al As Double) As Variant
    
    Dim chosen As Variant
    Set chosen = Nothing
    
    Dim listOfMaturitiesInSelectedOrder As Collection
    If frontVsBack Then
        Set listOfMaturitiesInSelectedOrder = listOfAvailMaturitiesInAscendingOrder
    Else
        Set listOfMaturitiesInSelectedOrder = reverseCollection(listOfAvailMaturitiesInAscendingOrder)
    End If
    
    
    Dim y As Long
    y = listOfMaturitiesInSelectedOrder.count
    
    While y >= 1 And isNothing(chosen)
        Dim curMat As Variant
        curMat = listOfMaturitiesInSelectedOrder.item(y)
        
        Dim found As Boolean
        If frontVsBack Then
            found = (al >= curMat)
        Else
            found = (al <= curMat)
        End If
        
        If found Then
            chosen = curMat
        End If
        
        y = y - 1
    Wend
    
    atr getFrontOrBackMaturity, chosen
    
End Function


'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
'Function getFrontMaturity(al As Double) As Double
'
'    Dim al3M As Variant
'    Dim al6M As Variant
'    Dim al1Y As Variant
'    Dim al2Y As Variant
'    Dim al3Y As Variant
'    Dim al5Y As Variant
'    Dim al7Y As Variant
'    Dim al10Y As Variant
'    Dim al30Y As Variant
'    al3M = Sheets("TSY Data").Range("AL_3M").value
'    al6M = Sheets("TSY Data").Range("AL_6M").value
'    al1Y = Sheets("TSY Data").Range("AL_1Y").value
'    al2Y = Sheets("TSY Data").Range("AL_2Y").value
'    al3Y = Sheets("TSY Data").Range("AL_3Y").value
'    al5Y = Sheets("TSY Data").Range("AL_5Y").value
'    al7Y = Sheets("TSY Data").Range("AL_7Y").value
'    al10Y = Sheets("TSY Data").Range("AL_10Y").value
'    al30Y = Sheets("TSY Data").Range("AL_30Y").value
'
'    If (al = al3M Or al = al6M Or al = al1Y Or al = al2Y Or al = al3Y Or al = al5Y Or al = al7Y Or al = al10Y Or al = al30Y) Then
'        getFrontMaturity = al
'    ElseIf (al > al10Y) Then
'        al = al10Y
'    ElseIf (al > al7Y And al < al10Y) Then
'        al = al7Y
'    ElseIf (al > al5Y And al < al7Y) Then
'        al = al5Y
'    ElseIf (al > al3Y And al < al5Y) Then
'        al = al3Y
'    ElseIf (al > al2Y And al < al3Y) Then
'        al = al2Y
'    ElseIf (al > al1Y And al < al2Y) Then
'        al = al1Y
'    ElseIf (al > al6M And al < al1Y) Then
'        al = al6M
'    ElseIf (al > al3M And al < al6M) Then
'        al = al3M
'    Else
'        'MsgBox ("Not a valid Front spot on the curve")
'    End If
'    getFrontMaturity = al
'
Function getFrontMaturity(al As Double, listOfAvailMaturitiesInAscendingOrder As Collection) As Double
    
    Dim chosen As Variant
    atr chosen, getFrontOrBackMaturity(listOfAvailMaturitiesInAscendingOrder, True, al)
    
    Dim frontMat As Variant
    If isNothing(chosen) Then
        frontMat = Empty
    Else
        frontMat = chosen
    End If
    
    getFrontMaturity = frontMat
'JY20130627d - end - genericize offering sheet interpolation logic for use in Structure Optimizer

End Function

'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
'Function getFrontYield(frontMat As Double) As Double
'
'    If (frontMat = Sheets("TSY Data").Range("AL_3M").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CB3_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_6M").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CB6_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_1Y").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CB12_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_2Y").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CT2_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_3Y").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CT3_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_5Y").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CT5_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_7Y").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CT7_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_10Y").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CT10_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_30Y").value) Then
'        getFrontYield = Sheets("TSY Data").Range("CT30_Yield_Current").value
'    Else
'
'    End If
'
'End Function
'
'Function getBackYield(frontMat As Double) As Double
'
'
'    If (frontMat = Sheets("TSY Data").Range("AL_3M").value) Then
'        getBackYield = Sheets("TSY Data").Range("CB3_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_6M").value) Then
'        getBackYield = Sheets("TSY Data").Range("CB6_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_1Y").value) Then
'        getBackYield = Sheets("TSY Data").Range("CB12_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_2Y").value) Then
'        getBackYield = Sheets("TSY Data").Range("CT2_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_3Y").value) Then
'        getBackYield = Sheets("TSY Data").Range("CT3_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_5Y").value) Then
'        getBackYield = Sheets("TSY Data").Range("CT5_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_7Y").value) Then
'        getBackYield = Sheets("TSY Data").Range("CT7_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_10Y").value) Then
'        getBackYield = Sheets("TSY Data").Range("CT10_Yield_Current").value
'    ElseIf (frontMat = Sheets("TSY Data").Range("AL_30Y").value) Then
'        getBackYield = Sheets("TSY Data").Range("CT30_Yield_Current").value
'    Else
'
'    End If
'
'End Function
'
'

Function getYieldByMaturity() As Dictionary

    Dim al3M As Variant
    Dim al6M As Variant
    Dim al1Y As Variant
    Dim al2Y As Variant
    Dim al3Y As Variant
    Dim al5Y As Variant
    Dim al7Y As Variant
    Dim al10Y As Variant
    Dim al30Y As Variant
    al3M = Sheets("TSY Data").Range("AL_3M").value
    al6M = Sheets("TSY Data").Range("AL_6M").value
    al1Y = Sheets("TSY Data").Range("AL_1Y").value
    al2Y = Sheets("TSY Data").Range("AL_2Y").value
    al3Y = Sheets("TSY Data").Range("AL_3Y").value
    al5Y = Sheets("TSY Data").Range("AL_5Y").value
    al7Y = Sheets("TSY Data").Range("AL_7Y").value
    al10Y = Sheets("TSY Data").Range("AL_10Y").value
    al30Y = Sheets("TSY Data").Range("AL_30Y").value

    Dim yieldByMat As Dictionary
    Set yieldByMat = New Dictionary
    
    atd yieldByMat, al3M, Sheets("TSY Data").Range("CB3_Yield_Current").value
    atd yieldByMat, al6M, Sheets("TSY Data").Range("CB6_Yield_Current").value
    atd yieldByMat, al1Y, Sheets("TSY Data").Range("CB12_Yield_Current").value
    atd yieldByMat, al2Y, Sheets("TSY Data").Range("CT2_Yield_Current").value
    atd yieldByMat, al3Y, Sheets("TSY Data").Range("CT3_Yield_Current").value
    atd yieldByMat, al5Y, Sheets("TSY Data").Range("CT5_Yield_Current").value
    atd yieldByMat, al7Y, Sheets("TSY Data").Range("CT7_Yield_Current").value
    atd yieldByMat, al10Y, Sheets("TSY Data").Range("CT10_Yield_Current").value
    atd yieldByMat, al30Y, Sheets("TSY Data").Range("CT30_Yield_Current").value
    
    Set getYieldByMaturity = yieldByMat

End Function

'JY20130627d - end - genericize offering sheet interpolation logic for use in Structure Optimizer


Function getICurveSpot(avelife As Double) As Double

    Dim theResult As Variant
    theResult = "ERROR: NOT SET!!!"

On Error GoTo ehs

    Dim frontMat As Double   ' The TSY Maturity closer to the front of the curve
    Dim backMat As Double    ' The TSY Maturity closer to the back of the curve
    Dim frontYield As Double ' The Current Yield on the front maturity TSY
    Dim backYield As Double  ' The Current Yield on the back maturity TSY
    Dim ICurveSpot As Double '
    Dim al As Double
       
    frontMat = 0
    backMat = 0
    
    al = avelife
    
'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
    
    'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
    Dim yieldByMaturity As Dictionary
    Set yieldByMaturity = getYieldByMaturity()
    'JY20130627d - end - genericize offering sheet interpolation logic for use in Structure Optimizer
    
    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    theResult = computeICurveSpot(yieldByMaturity, al, emsgs)
    
    If emsgs.count <> 0 Then
        elwp emsgs.toString(CHAR_CRLF, "")
    End If
    
GoTo ehe
ehs:
    theResult = 0
ehe:
On Error GoTo 0
    
    getICurveSpot = theResult

End Function


Function computeICurveSpot(yieldByMaturity As Dictionary, al As Double, ByRef mod_emsgs As Variant) As Variant
    
'JY20130627e - start - genericize offering sheet interpolation logic for use in Structure Optimizer
'    Dim al3M As Variant
'    Dim al6M As Variant
'    Dim al1Y As Variant
'    Dim al2Y As Variant
'    Dim al3Y As Variant
'    Dim al5Y As Variant
'    Dim al7Y As Variant
'    Dim al10Y As Variant
'    Dim al30Y As Variant
'    al3M = Sheets("TSY Data").Range("AL_3M").value
'    al6M = Sheets("TSY Data").Range("AL_6M").value
'    al1Y = Sheets("TSY Data").Range("AL_1Y").value
'    al2Y = Sheets("TSY Data").Range("AL_2Y").value
'    al3Y = Sheets("TSY Data").Range("AL_3Y").value
'    al5Y = Sheets("TSY Data").Range("AL_5Y").value
'    al7Y = Sheets("TSY Data").Range("AL_7Y").value
'    al10Y = Sheets("TSY Data").Range("AL_10Y").value
'    al30Y = Sheets("TSY Data").Range("AL_30Y").value
'
'    Dim listOfAvailMaturitiesInAscendingOrder As Collection
'    Set listOfAvailMaturitiesInAscendingOrder = New Collection
'    With listOfAvailMaturitiesInAscendingOrder
'        .add al3M
'        .add al6M
'        .add al1Y
'        .add al2Y
'        .add al3Y
'        .add al5Y
'        .add al7Y
'        .add al10Y
'        .add al30Y
'    End With
    
    Dim listOfAvailMaturitiesInAscendingOrder As Collection
    Set listOfAvailMaturitiesInAscendingOrder = getListOfAvailMaturitiesInAscendingOrder(yieldByMaturity)
'JY20130627e - end

    Dim frontMat As Double
    Dim backMat As Double
    Dim frontYield As Variant
    Dim backYield As Variant
    
'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
    
    'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
    'frontMat = getFrontMaturity(al)
    frontMat = getFrontMaturity(al, listOfAvailMaturitiesInAscendingOrder)
    'JY20130627d - end - genericize offering sheet interpolation logic for use in Structure Optimizer
    
    'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
    'frontYield = getFrontYield(frontMat)
    frontYield = vfd(yieldByMaturity, frontMat, False)
    'JY20130627d - end - genericize offering sheet interpolation logic for use in Structure Optimizer

    'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
    'al = avelife
    'backMat = getBackMaturity(al)
    backMat = getBackMaturity(al, listOfAvailMaturitiesInAscendingOrder)
    'JY20130627d - end - genericize offering sheet interpolation logic for use in Structure Optimizer
    
    'JY20130627d - start - genericize offering sheet interpolation logic for use in Structure Optimizer
    'backYield = getBackYield(backMat)
    backYield = vfd(yieldByMaturity, backMat, False)
    'JY20130627d - end - genericize offering sheet interpolation logic for use in Structure Optimizer
    
    Dim daYldWhereOneIs100Pct As Variant
    If Not isNumber(frontYield) Then
        mod_emsgs.add "Non-numeric front yield: " & frontYield
        daYldWhereOneIs100Pct = "???"
    ElseIf Not isNumber(backYield) Then
        mod_emsgs.add "Non-numeric back yield: " & backYield
        daYldWhereOneIs100Pct = "???"
    ElseIf (frontMat <> backMat) Then
        daYldWhereOneIs100Pct = CalculateICurveSpot(frontMat, backMat, CDbl(frontYield), CDbl(backYield), al)
    Else
        daYldWhereOneIs100Pct = frontYield
    End If
    
    computeICurveSpot = daYldWhereOneIs100Pct
End Function

Function CalculateICurveSpot(frontMat As Double, backMat As Double, frontYield As Double, backYield As Double, al As Double) As Double
    
    Dim MatDiff As Double       ' Difference between the front and back Maturities (in terms of years)
    Dim YieldDiff As Double     '
    Dim YldChgPerYear As Double '
    Dim ALDiff As Double        ' Difference between the back TSY Maturity and the Bond Average Life (in terms of years)
    Dim ALSpot As Double        '

    MatDiff = (backMat - frontMat)
    YieldDiff = (backYield - frontYield)
    YldChgPerYear = YieldDiff / MatDiff
    
    ALDiff = (backMat - al)
    ALSpot = backYield - (ALDiff * YldChgPerYear)

    CalculateICurveSpot = ALSpot

End Function


Function getListOfAvailMaturitiesInAscendingOrder(yieldByMaturity As Dictionary) As Collection

    Dim list As Collection
    Set list = sortCollection(arrayToCollection(yieldByMaturity.keys()))
    
    Set getListOfAvailMaturitiesInAscendingOrder = list
    

End Function



Attribute VB_Name = "JYUT_Logs"
'This module has been moved to the JYCORE library.

Attribute VB_Name = "JYUT_MTGRelatedPxTypeStrings"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public nomuraPricingType As String
Public eSpreadPricingType As String
Public nSpreadPricingType As String
Public yieldPricingType As String
Public dmPricingType As String


Attribute VB_Name = "JYUT_Math"
Option Explicit

Public Const INFINITY As String = "infinity"
Public Const POSITIVE_INFINITY As String = "positive infinity"
Public Const NEGATIVE_INFINITY As String = "negative infinity"

Public Const RETURN_VALUE_FOR_UNCONVERTABLE_NUMBERS As String = "?"

Function getRequiredNumDigitsToRepresentDecimalNumberInDifferentBase(numberToRepresent As Long, desiredBase As Long) As Long

    Dim numDigitsSoFar As Long
    numDigitsSoFar = 1
    
    Dim maxNumberSupportedSoFar As Long
    maxNumberSupportedSoFar = desiredBase ^ numDigitsSoFar - 1
    
    While maxNumberSupportedSoFar < numberToRepresent
        numDigitsSoFar = numDigitsSoFar + 1
        maxNumberSupportedSoFar = desiredBase ^ numDigitsSoFar - 1
    Wend
    
    getRequiredNumDigitsToRepresentDecimalNumberInDifferentBase = numDigitsSoFar

End Function

Function numberToBase(num As Long, base As Long, roundNegativeNumbersDownVsUp As Boolean) As Collection
    
    If num < 0 Then
        elwp "Cannot process a number less than zero"
        Set numberToBase = Nothing
    Else
        Dim valSoFar As Collection
        Set valSoFar = New Collection
        
        Dim requiredNumDigits As Long
        requiredNumDigits = getRequiredNumDigitsToRepresentDecimalNumberInDifferentBase(num, base)
        
        Dim numRemaining As Long
        numRemaining = num
        
        Dim digit As Long
        For digit = requiredNumDigits To 1 Step -1
        
            Dim incrementThisRound As Long
            incrementThisRound = base ^ (digit - 1)
            
            Dim howMany As Long
            howMany = removeDecimalPortion(numRemaining / incrementThisRound, roundNegativeNumbersDownVsUp)
            
            valSoFar.add howMany
            
            numRemaining = numRemaining - howMany * incrementThisRound
        
        Next
            
        Set numberToBase = valSoFar
    End If
End Function

Function isEven(num As Variant) As Boolean
    isEven = (num / 2 = num \ 2)
End Function

Function isOdd(num As Variant) As Boolean
    isOdd = Not isEven(num)
End Function

Function cprcdrToSMMMDR(cprcdr As Double) As Variant
    Dim subResult As Variant
    subResult = pow(1 - cprcdr / 100, 1 / 12)
    
    If isNumber(subResult) Then
        cprcdrToSMMMDR = 100 * (1 - subResult)
    Else
        cprcdrToSMMMDR = "ERROR: " & subResult
    End If
End Function

Function smmmdrToCPRCDR(smmmdr As Double) As Variant
    Dim subResult As Variant
    subResult = pow(1 - smmmdr / 100, 12)
    
    If isNumber(subResult) Then
        smmmdrToCPRCDR = 100 * (1 - subResult)
    Else
        smmmdrToCPRCDR = "ERROR: " & subResult
    End If
End Function

Function pow(base As Double, exp As Double) As Variant
    pow = Application.Evaluate("(" & base & ")^(" & exp & ")")
End Function
Function convertPctStringToNumberIfAppropriate(thePossibleNum As Variant) As Variant
    Dim possibleNum As Variant
    possibleNum = thePossibleNum
    
    Dim isPercentage As Boolean
    If endsWith(CStr(possibleNum), "%", True) Then
        possibleNum = dropLastXCharacters(CStr(possibleNum), Len("%"))
        isPercentage = True
    Else
        isPercentage = False
    End If
    
    If isNumber(possibleNum) Then
        If isPercentage Then
            possibleNum = CDbl(possibleNum) / 100
        End If
    End If
    convertPctStringToNumberIfAppropriate = possibleNum
End Function

'Based on code from SPPA
Public Function convertDecimalsToTicks(ByVal cellVal, showNegativeSignAsBrackets As Boolean, Optional includeSixteenths As Boolean) As String

On Error GoTo ehs
    
    If IsError(cellVal) = False Then   ' boris move it up
        If Len(Trim(cellVal)) > 0 Then   'Check if value is blank or space - if not, continue
        
            Dim lenR, ticks
            convertDecimalsToTicks = "0"
            cellVal = Format(cellVal, "#0.00000000000000")
        
            Dim origCell As Double
            origCell = cellVal
            
            convertDecimalsToTicks = convertDecimalNumberToTicksFormat(origCell, showNegativeSignAsBrackets, includeSixteenths)
            
        End If
    End If
GoTo ehe
ehs:
    convertDecimalsToTicks = RETURN_VALUE_FOR_UNCONVERTABLE_NUMBERS
ehe:
On Error GoTo 0
End Function

Function convertDecimalNumberToTicksFormat_toggle(numToConvert As Variant, showNegativeSignAsBrackets As Boolean, performConversion As Boolean) As Variant
    If performConversion Then
        convertDecimalNumberToTicksFormat_toggle = convertDecimalNumberToTicksFormatIfPossible(numToConvert, showNegativeSignAsBrackets)
    Else
        convertDecimalNumberToTicksFormat_toggle = numToConvert
    End If
End Function

Function convertDecimalNumberToTicksFormatIfPossible(numToConvert As Variant, showNegativeSignAsBrackets As Boolean) As Variant
    If isNumber(numToConvert) Then
        convertDecimalNumberToTicksFormatIfPossible = convertDecimalNumberToTicksFormat(CDbl(numToConvert), showNegativeSignAsBrackets)
    Else
        convertDecimalNumberToTicksFormatIfPossible = numToConvert
    End If
End Function


Function convertDecimalNumberToTicksFormat(numToConvert As Double, showNegativeSignAsBrackets As Boolean, Optional includeSixteenths As Boolean) As String
    
    Dim absoluteValueOfNumberToConvert As Double
    absoluteValueOfNumberToConvert = Abs(numToConvert)

    Dim roundNegativeNumbersDownVsUp2 As Boolean
    roundNegativeNumbersDownVsUp2 = True 'arbitrary, doesn't matter because we know we are dealing with a positive number.

    Dim wholeNumber As Long
    Dim numberOf32nds As Double
    convertNumberIntoWholeNumberAndFraction absoluteValueOfNumberToConvert, wholeNumber, numberOf32nds, 32, roundNegativeNumbersDownVsUp2
    
    Dim numberOfWhole32nds As Long
    Dim truncatedEightsOfA32nd As Long
    Dim truncatedSixteenthsOfA32nd As Long
    If includeSixteenths Then
        
        If numberOf32nds < 0 Then
            elwp_se
        End If
        
        Dim sixteenthsOfA32nd As Double
        convertNumberIntoWholeNumberAndFraction numberOf32nds, numberOfWhole32nds, sixteenthsOfA32nd, 16, roundNegativeNumbersDownVsUp2
    
        Dim sixteenthsOfA32ndBeforeTakingOutTheEighths As Long
        sixteenthsOfA32ndBeforeTakingOutTheEighths = Application.WorksheetFunction.Round(sixteenthsOfA32nd, 0)
        
        Dim roundNegativeNumbersDownVsUp As Boolean
        roundNegativeNumbersDownVsUp = True 'arbitrary, doesn't matter because we know we are dealing with a positive number.
        If sixteenthsOfA32ndBeforeTakingOutTheEighths < 0 Then
            elwp_se
        End If
        
        truncatedEightsOfA32nd = removeDecimalPortion(sixteenthsOfA32ndBeforeTakingOutTheEighths / 2, roundNegativeNumbersDownVsUp)
        truncatedSixteenthsOfA32nd = sixteenthsOfA32ndBeforeTakingOutTheEighths - (truncatedEightsOfA32nd * 2)
        
    Else
        
        If numberOf32nds < 0 Then
            elwp_se
        End If
        
        Dim eighthsOfA32nd As Double
        convertNumberIntoWholeNumberAndFraction numberOf32nds, numberOfWhole32nds, eighthsOfA32nd, 8, roundNegativeNumbersDownVsUp2
        
        truncatedEightsOfA32nd = Application.WorksheetFunction.Round(eighthsOfA32nd, 0)
        truncatedSixteenthsOfA32nd = 0
    End If
    
    'JY20131127a - start
    If truncatedSixteenthsOfA32nd >= 2 Then
        truncatedSixteenthsOfA32nd = truncatedSixteenthsOfA32nd - 2
        truncatedEightsOfA32nd = truncatedEightsOfA32nd + 1
    End If
    
    If (truncatedEightsOfA32nd >= 8) Then
        truncatedEightsOfA32nd = truncatedEightsOfA32nd - 8
        numberOfWhole32nds = numberOfWhole32nds + 1
    End If
    
    If numberOfWhole32nds >= 32 Then
        numberOfWhole32nds = numberOfWhole32nds - 32
        wholeNumber = wholeNumber + 1
    End If
    'JY20131127a - end
    
    
    
    
    
    Dim stringRepresentingEightsOfA32nd As String
    If truncatedEightsOfA32nd = "4" Then
        stringRepresentingEightsOfA32nd = "+"
    Else
        stringRepresentingEightsOfA32nd = Trim(CStr(truncatedEightsOfA32nd))
    End If
    
    Dim stringRepresentingSixteenthsOfA32nd As String
    If truncatedSixteenthsOfA32nd = 0 Then
        stringRepresentingSixteenthsOfA32nd = ""
    Else
        stringRepresentingSixteenthsOfA32nd = Trim(CStr(truncatedSixteenthsOfA32nd))
    End If
        
    Dim stringRepresentingNumberOfWhole32nds As String
    stringRepresentingNumberOfWhole32nds = padLeft(Trim(CStr(numberOfWhole32nds)), 2, "0")
    
    Dim stringRepresentingWholeNumber As String
    stringRepresentingWholeNumber = Trim(CStr(wholeNumber))
    
    Dim stringRepresentingFractionsOf32nd As String
    If stringRepresentingSixteenthsOfA32nd <> "" Then
        stringRepresentingFractionsOf32nd = IIf(Trim(stringRepresentingEightsOfA32nd) = "", "0", stringRepresentingEightsOfA32nd) & stringRepresentingSixteenthsOfA32nd
    Else
        stringRepresentingFractionsOf32nd = stringRepresentingEightsOfA32nd
    End If
    
    Dim ticks As String
    ticks = stringRepresentingWholeNumber & "-" & stringRepresentingNumberOfWhole32nds & stringRepresentingFractionsOf32nd

    If numToConvert < 0 Then
        If showNegativeSignAsBrackets Then
            ticks = "(" & ticks & ")"
        Else
            ticks = "-" & ticks
        End If
    End If
    
    convertDecimalNumberToTicksFormat = ticks
End Function

Public Function convertTicksToDecs(ByVal theCellVal) As Double
    Dim returnValue As Variant
    returnValue = convertTicksToDecs_passInDefaultValue(theCellVal, 0)
    
    convertTicksToDecs = CDbl(returnValue)
End Function

Function convTicksToDecsIfPossible(theCellVal As Variant) As Variant

    Dim candidateResult As Variant
    candidateResult = convertTicksToDecs_passInDefaultValue(theCellVal, RETURN_VALUE_FOR_UNCONVERTABLE_NUMBERS)
    
    If candidateResult = RETURN_VALUE_FOR_UNCONVERTABLE_NUMBERS Then
        convTicksToDecsIfPossible = theCellVal
    Else
        convTicksToDecsIfPossible = candidateResult
    End If

End Function

Public Function convTicksToDecs(ByVal theCellVal) As Variant
    convTicksToDecs = convertTicksToDecs_passInDefaultValue(theCellVal, RETURN_VALUE_FOR_UNCONVERTABLE_NUMBERS)
End Function

Public Function convertTicksToDecs_passInDefaultValue(ByVal theCellVal, defaultValue As Variant) As Variant

    'We want to convert the passed-in value from "ticks" notation to "decimals" notation.
    'We don't even know whether the passed-in value is in ticks notation, so if it's not, then
    'we will simply return a default value to the caller of the function.
    'But if it IS in ticks notation, then we'll convert it to decimals!
    
    
    'So let's try converting it.
    'The following line of code performs the conversion and assigns the result back to "result".
    Dim result As Variant
    assignToReference result, convertTicksToDecimalsOrReturnNothingIfUnableTo(theCellVal)
    
    'If we got back Nothing, then that means
    'we were not able to perform the conversion.
    
    If isNothing(result) Then
    
        'We got back nothing
    
        result = defaultValue
    End If
    
    convertTicksToDecs_passInDefaultValue = result

End Function

''This function takes a positive value that's represented in "ticks" format, and
''converts it into a negative value.  The method caller can specify how negative values
''should be represented.
'Function makeNegative(ticks As String, showNegativeSignAsBrackets As Boolean) As Variant
'    If showNegativeSignAsBrackets Then
'        makeNegative = "(" & ticks & ")"
'    Else
'        makeNegative = "-" & ticks
'    End If
'End Function

Public Function convertTicksToDecimals_withMoreFlexibilityTowardsOtherFormats(theNumberInTicks As Variant) As Variant
    
    Dim isNeg As Boolean
    Dim numberInTicksWithoutNegativeSign As Variant
    checkForNegativeSign isNeg, numberInTicksWithoutNegativeSign, theNumberInTicks
    
    Dim numberInDecimals As Variant
    If Not isNumber(numberInTicksWithoutNegativeSign) Then
    
        Dim tkns As Collection
        Set tkns = gtkns(CStr(numberInTicksWithoutNegativeSign), "-")
        
        If tkns.count = 2 Then
        
            Dim wholeNumberSection As String
            Dim ticksAndFractionOfTicksSection As String
            wholeNumberSection = Trim(tkns.item(1))
            ticksAndFractionOfTicksSection = Trim(tkns.item(2))
            
            Dim tkns2 As Collection
            Set tkns2 = gtkns(removeSpacesInBetweenWords(ticksAndFractionOfTicksSection), " ")
            
            Dim ticksSection As String
            Dim fractionOfTicksSection As String
            If tkns2.count = 2 Then
                ticksSection = tkns2.item(1)
                fractionOfTicksSection = tkns2.item(2)
            Else
                ticksSection = ticksAndFractionOfTicksSection
                fractionOfTicksSection = ""
            End If
            
            Dim convertedOrNothingIfNotSuccessfullyParsed As Variant
            atr convertedOrNothingIfNotSuccessfullyParsed, tryToParseTicksSection(wholeNumberSection, ticksSection)
            
            Dim valueFromFractionSectionOrNothingIfNotSuccessfullyParsed As Variant
            atr valueFromFractionSectionOrNothingIfNotSuccessfullyParsed, tryToParseFractionOfTicksSection(fractionOfTicksSection)
            
            If isNothing(convertedOrNothingIfNotSuccessfullyParsed) Or isNothing(valueFromFractionSectionOrNothingIfNotSuccessfullyParsed) Then
                numberInDecimals = numberInTicksWithoutNegativeSign
            Else
                numberInDecimals = CDbl(convertedOrNothingIfNotSuccessfullyParsed) + CDbl(valueFromFractionSectionOrNothingIfNotSuccessfullyParsed)
            End If
        Else
            numberInDecimals = numberInTicksWithoutNegativeSign
        End If
    Else
        numberInDecimals = numberInTicksWithoutNegativeSign
    End If
    
    Dim result As Variant
    If Not isNumber(numberInDecimals) Then
        If isNeg Then
            result = "-" & numberInDecimals
        Else
            result = numberInDecimals
        End If
    Else
        If isNeg Then
            result = -1 * CDbl(numberInDecimals)
        Else
            result = numberInDecimals
        End If
    End If
    
    convertTicksToDecimals_withMoreFlexibilityTowardsOtherFormats = result

End Function


'Based on code from SPPA
Public Function convertTicksToDecimals(ByVal theCellVal) As Double
    convertTicksToDecimals = convertTicksToDecs(theCellVal)
End Function

Function convertTicksToDecimalsOrReturnNothingIfUnableTo(ByVal daCellVal) As Variant
    
    Dim theCellVal As Variant
    If isRnge(daCellVal) Then
        theCellVal = gvl(castToRnge(daCellVal))
    Else
        theCellVal = daCellVal
    End If
    
    Dim str As String
    If IsEmpty(theCellVal) Then
        str = ""
    Else
        str = Trim(CStr(theCellVal))
    End If
    
    Dim isNeg As Boolean
    Dim passedInValueWithoutNegativeSign As Variant
    checkForNegativeSign isNeg, passedInValueWithoutNegativeSign, str
    
    Dim hyphenPlace As Long
    hyphenPlace = InStr(passedInValueWithoutNegativeSign, "-")
    
    
    Dim totalAmountInDecimalsFromWholeNumberPortion As Variant
    Dim totalAmountInDecimalsFromTicksPortion As Variant
    If hyphenPlace = 0 Then
        Set totalAmountInDecimalsFromWholeNumberPortion = Nothing
        Set totalAmountInDecimalsFromTicksPortion = Nothing
    Else
    
        Dim wholeNumberPortionOfString As String
        Dim ticksPortionOfString As String
        wholeNumberPortionOfString = Trim(left(passedInValueWithoutNegativeSign, hyphenPlace - 1))
        ticksPortionOfString = Trim(Right(passedInValueWithoutNegativeSign, Len(passedInValueWithoutNegativeSign) - (hyphenPlace)))
        
        If Not isNumber(wholeNumberPortionOfString) Then
            Set totalAmountInDecimalsFromWholeNumberPortion = Nothing
        Else
            totalAmountInDecimalsFromWholeNumberPortion = val(wholeNumberPortionOfString)
        End If
        
        Dim ticksPortionOfStringButNotIncludingTheSixteenthsSpot As String
        Dim totalAmountIn32ndsFromSixteenthsOfATickPortion As Variant
        If Len(ticksPortionOfString) = 4 Then
            Dim ticksPortionOfStringFromSixteenthsSpot As String
            ticksPortionOfStringFromSixteenthsSpot = Right(ticksPortionOfString, 1)
            
            If isNumber(ticksPortionOfStringFromSixteenthsSpot) Then
                totalAmountIn32ndsFromSixteenthsOfATickPortion = CDbl(ticksPortionOfStringFromSixteenthsSpot) / 16
                ticksPortionOfStringButNotIncludingTheSixteenthsSpot = left(ticksPortionOfString, Len(ticksPortionOfString) - 1)
            Else
                totalAmountIn32ndsFromSixteenthsOfATickPortion = 0
                ticksPortionOfStringButNotIncludingTheSixteenthsSpot = ticksPortionOfString
            End If
            
        Else
            totalAmountIn32ndsFromSixteenthsOfATickPortion = 0
            ticksPortionOfStringButNotIncludingTheSixteenthsSpot = ticksPortionOfString
        End If
        
        
        Dim numCharsInTicksPortionOfStringButNotIncludingTheSixteenthSpot As Long
        numCharsInTicksPortionOfStringButNotIncludingTheSixteenthSpot = Len(ticksPortionOfStringButNotIncludingTheSixteenthsSpot)
        
        If numCharsInTicksPortionOfStringButNotIncludingTheSixteenthSpot <> 2 And numCharsInTicksPortionOfStringButNotIncludingTheSixteenthSpot <> 3 Then
            Set totalAmountInDecimalsFromTicksPortion = Nothing
        Else
        
            Dim rightmostChar As String
            rightmostChar = Right(ticksPortionOfStringButNotIncludingTheSixteenthsSpot, 1)
            
            Dim totalAmountIn32ndsFromWholeTicksPortion As String
            Dim totalAmountIn32ndsFromEighthsOfATickPortion As Variant
            If rightmostChar = "+" Then
                totalAmountIn32ndsFromEighthsOfATickPortion = 0.5
                totalAmountIn32ndsFromWholeTicksPortion = dropLastXCharacters(CStr(ticksPortionOfStringButNotIncludingTheSixteenthsSpot), Len(rightmostChar))
            ElseIf Len(ticksPortionOfStringButNotIncludingTheSixteenthsSpot) = 3 Then
                If Not isNumber(rightmostChar) Then
                    Set totalAmountIn32ndsFromEighthsOfATickPortion = Nothing
                    totalAmountIn32ndsFromWholeTicksPortion = ticksPortionOfStringButNotIncludingTheSixteenthsSpot
                Else
                    totalAmountIn32ndsFromEighthsOfATickPortion = val(rightmostChar) / 8
                    totalAmountIn32ndsFromWholeTicksPortion = dropLastXCharacters(ticksPortionOfStringButNotIncludingTheSixteenthsSpot, Len(rightmostChar))
                End If
            Else
                totalAmountIn32ndsFromEighthsOfATickPortion = 0
                totalAmountIn32ndsFromWholeTicksPortion = ticksPortionOfStringButNotIncludingTheSixteenthsSpot
            End If
            
            If isNothing(totalAmountIn32ndsFromEighthsOfATickPortion) Then
                Set totalAmountInDecimalsFromTicksPortion = Nothing
            Else
                If Not isNumber(totalAmountIn32ndsFromWholeTicksPortion) Then
                    Set totalAmountInDecimalsFromTicksPortion = Nothing
                Else
                    totalAmountInDecimalsFromTicksPortion = (CDbl(totalAmountIn32ndsFromWholeTicksPortion) + CDbl(totalAmountIn32ndsFromEighthsOfATickPortion) + CDbl(totalAmountIn32ndsFromSixteenthsOfATickPortion)) / 32
                End If
            End If
        End If
        
    End If



    Dim finalValue As Variant
    If isNothing(totalAmountInDecimalsFromWholeNumberPortion) Or isNothing(totalAmountInDecimalsFromTicksPortion) Then
        Set finalValue = Nothing
    Else
    
        Dim multiplier As Double
        If isNeg = True Then
            multiplier = -1
        Else
            multiplier = 1
        End If
        
        finalValue = multiplier * (CDbl(totalAmountInDecimalsFromWholeNumberPortion) + CDbl(totalAmountInDecimalsFromTicksPortion)) '- (0.125 / 32)
    End If
    
    atr convertTicksToDecimalsOrReturnNothingIfUnableTo, finalValue
End Function

Function convertFromPercent(yourPctString As String) As Double
    If Right(yourPctString, 1) = "%" Then
        convertFromPercent = CDbl(left(yourPctString, Len(yourPctString) - 1)) / 100
    Else
        convertFromPercent = "not a percent!"
    End If
End Function

Sub splitNumberAroundDecimalPlace(theNumber As String, indxOfDecimalPlace As Long, ByRef out_integerPortion As Long, ByRef out_decimalPortionOfNumber As Long)
    out_integerPortion = Trim(left(theNumber, indxOfDecimalPlace - 1))
    out_decimalPortionOfNumber = Right(theNumber, Len(theNumber) - (indxOfDecimalPlace - 1))
End Sub

Sub convertNumberIntoWholeNumberAndFraction(numberToConvert As Double, ByRef out_wholeNumber As Long, ByRef out_numerator As Double, desiredDenominator As Long, roundNegativeNumbersDownVsUp As Boolean)
    
    Dim wholeNumber As Long
    wholeNumber = removeDecimalPortion(numberToConvert, roundNegativeNumbersDownVsUp)
    
    Dim numerator As Double
    numerator = (numberToConvert - wholeNumber) * desiredDenominator
    
    out_wholeNumber = wholeNumber
    out_numerator = numerator
    
End Sub
    
Function computeSlopeAndYIntercept(x1 As Double, y1 As Double, x2 As Double, y2 As Double, ByRef out_yIntercept As Variant) As Variant

    Dim slope As Variant
    slope = computeSlope(x1, y1, x2, y2)
    
    Dim yIntercept As Variant
    If Not isNumber(slope) Then
        yIntercept = slope
    Else
    
        Dim xForComputingYIntercept As Double
        Dim yForComputingYIntercept As Double
        xForComputingYIntercept = x1 'could have been x2, doesn't matter
        yForComputingYIntercept = y1 'could have been y2, doesn't matter
        
        yIntercept = yForComputingYIntercept - CDbl(slope) * xForComputingYIntercept
    End If
    
    out_yIntercept = yIntercept
    computeSlopeAndYIntercept = slope

End Function
    
Function computeSlope(x1 As Double, y1 As Double, x2 As Double, y2 As Double) As Variant
    Dim denominator As Double
    denominator = (x2 - x1)
    
    computeSlope = divideAndRepresentInfinityAsText(y2 - y1, denominator) 'Note: it doesn't matter whether we subtract the second from the first, or the first from the second.  The result comes out the same either way
End Function

Function divideAndRepresentInfinityAsText(numerator As Double, denominator As Double) As Variant
    If denominator = 0 Then
        If numerator = 0 Then
            divideAndRepresentInfinityAsText = INFINITY
        ElseIf numerator > 0 Then
            divideAndRepresentInfinityAsText = POSITIVE_INFINITY
        Else 'numerator < 0
            divideAndRepresentInfinityAsText = NEGATIVE_INFINITY
        End If
    Else
        divideAndRepresentInfinityAsText = numerator / denominator
    End If
        
End Function

Function numberIsBetweenTwoNumbers(numToCheck As Double, oneNum As Double, otherNum As Double, inclusiveVersusExclusive As Boolean) As Boolean

    Dim smaller As Double
    Dim larger As Double
    larger = wsFunctionMax(oneNum, otherNum)
    smaller = wsFunctionMin(oneNum, otherNum)
    
    If inclusiveVersusExclusive Then
         numberIsBetweenTwoNumbers = (smaller <= numToCheck) And (numToCheck <= larger)
    Else
         numberIsBetweenTwoNumbers = (smaller < numToCheck) And (numToCheck < larger)
    End If
    

End Function

Function roundUp(theNum As Double, roundNegativeNumbersDownVsUp As Boolean) As Long
    Dim rndedNum As Long
    If isInteger(theNum) Then
        rndedNum = theNum
    Else
        rndedNum = removeDecimalPortion(theNum + 1, roundNegativeNumbersDownVsUp)
    End If
    roundUp = rndedNum
End Function

Function removeDecimalPortion(theNum As Variant, roundNegativeNumbersDownVsUp As Boolean) As Variant
    'If isNumber(theNum) Then
    '    If theNum < 0 Then
    '        elwp "Not sure how we should handle negative numbers (FIX or INT).  What do you prefer?"
    '    End If
    'End If
    If roundNegativeNumbersDownVsUp Then
        removeDecimalPortion = Int(theNum) 'or should we use FIX instead?
    Else
        removeDecimalPortion = Fix(theNum) 'or should we use FIX instead?
    End If

End Function
Function ensureNumDecimalPlacesShownInNumber(curBal As Double, numDigitsToRoundTo As Long) As String
    Dim rounded As String
    rounded = CStr(Round(curBal, numDigitsToRoundTo))
    
    Dim indxOfDecimal As Long
    indxOfDecimal = InStr(1, rounded, ".")
    
    If indxOfDecimal = 0 Then
        rounded = rounded & "."
        indxOfDecimal = InStr(1, rounded, ".")
    End If
    
    If indxOfDecimal = 0 Then
        elwp_se
    End If
    
    Dim numCharsAfterDecimal As Long
    numCharsAfterDecimal = Len(rounded) - indxOfDecimal
    
    Dim numZeroesToAdd As Long
    numZeroesToAdd = numDigitsToRoundTo - numCharsAfterDecimal
    
    Dim x As Long
    For x = 1 To numZeroesToAdd
        rounded = rounded & "0"
    Next
    
    ensureNumDecimalPlacesShownInNumber = rounded
End Function

Function roundToNearest(numToRound As Double, toNearest As Double) As Double
    
    If toNearest = 0 Then
        elwp "Cannot round to zero!"
        roundToNearest = numToRound
    Else
        roundToNearest = Application.WorksheetFunction.Round(numToRound / toNearest, 0) * toNearest
    End If
    
    
End Function

Function tryToParseTicksSection(wholeNumberSection As String, ticksSection As String) As Variant
    
    Dim priceToPassIntoConverter As Variant
    If Len(ticksSection) = 1 And isNumber(ticksSection) Then
        priceToPassIntoConverter = wholeNumberSection & "-" & "0" & ticksSection
    Else
        priceToPassIntoConverter = wholeNumberSection & "-" & ticksSection
    End If
    
    Dim converted As Double
    converted = convertTicksToDecimals(priceToPassIntoConverter)
    
    Dim convertedOrNothingIfNotSuccessfullyParsed As Variant
    If Trim(CStr(converted)) <> "0" Then
        convertedOrNothingIfNotSuccessfullyParsed = converted
    Else
        Set convertedOrNothingIfNotSuccessfullyParsed = Nothing
    End If
    
    atr tryToParseTicksSection, convertedOrNothingIfNotSuccessfullyParsed
End Function

Function tryToParseFractionOfTicksSection(fractionOfTicksSection As String) As Variant
    
    If Trim(fractionOfTicksSection) = "" Then
        tryToParseFractionOfTicksSection = 0
    Else
    
        Dim tkns As Collection
        Set tkns = gtkns(fractionOfTicksSection, "/")
        
        If tkns.count = 2 Then
            Dim numerator As Variant
            Dim denominator As Variant
            numerator = Trim(tkns.item(1))
            denominator = Trim(tkns.item(2))
            
            If isNumber(numerator) And isNumber(denominator) Then
                If denominator = 0 Then
                    Set tryToParseFractionOfTicksSection = Nothing
                Else
                    tryToParseFractionOfTicksSection = (CDbl(numerator) / CDbl(denominator)) / 32
                End If
            Else
                Set tryToParseFractionOfTicksSection = Nothing
            End If
        Else
            Set tryToParseFractionOfTicksSection = Nothing
        End If
    End If
    
End Function

Function getOperators() As Collection

    Dim operators As Collection
    Set operators = New Collection
    With operators
        .add "*"
        .add "^"
        .add "/"
        .add "\"
        .add "+"
        .add "-"
        .add ","
    End With
    
    Set getOperators = operators

End Function

Function identifyFunctionsAndVariablesAndConstantsInExpression(expression As String, nameToUseForFunctionThatRepresentsNormalParenthesisPooling As String) As JYCORE_Set

    Dim operators As Collection
    Set operators = getOperators()
    
    Dim arbitraryOperator As String
    arbitraryOperator = operators.item(1)

    Dim soFar As String
    soFar = expression
    soFar = replaceInString(soFar, " ", "", True)
    soFar = replaceInString(soFar, "((", "(" & nameToUseForFunctionThatRepresentsNormalParenthesisPooling & "(", True)
    soFar = replaceInString(soFar, "(", arbitraryOperator, True)
    soFar = replaceInString(soFar, ")", arbitraryOperator, True)
    
    Dim c As Long
    For c = 1 To operators.count
        Dim op As String
        op = operators.item(c)
        
        If op <> arbitraryOperator Then
            soFar = replaceInString(soFar, op, arbitraryOperator, False)
        End If
    Next
    
    soFar = replaceInString(soFar, arbitraryOperator & arbitraryOperator, arbitraryOperator, True)
    
    Dim tkns As Collection
    Set tkns = gtkns(soFar, arbitraryOperator)
    
    Dim dist As JYCORE_Set
    Set dist = collectionToSet(tkns)
    
    dist.remove nameToUseForFunctionThatRepresentsNormalParenthesisPooling
    
    Set identifyFunctionsAndVariablesAndConstantsInExpression = dist

End Function


'Function identifyVariablesInEquation(predicate As String) As Collection
'    Dim noMoreSpaces As String
'    noMoreSpaces = replaceInString(predicate, "  ", "", True)
'
'    Dim stack As Collection
'    Set stack = New Collection
'
'    Dim stringWeAreLookingAt As String
'    stringWeAreLookingAt = noMoreSpaces
'
'
'
'    Dim indexOfOpenBracket As Long
'    Dim indexOfCloseBracket As Long
'    indexOfOpenBracket = InStr(1, stringWeAreLookingAt, "(")
'    indexOfCloseBracket = InStr(1, stringWeAreLookingAt, ")")
'
'    Dim mode As String
'    mode = figureOutNextStep(stringWeAreLookingAt)
'
'    While mode <> SHOULD_EVALUATE_EXPRESSION
'    Wend
'
'    stringSoFar = replaceInString(stringSoFar, "/", " / ", False)
'    stringSoFar = replaceInString(stringSoFar, "*", " * ", False)
'    stringSoFar = replaceInString(stringSoFar, "+", " + ", False)
'    stringSoFar = replaceInString(stringSoFar, "-", " - ", False)
'    stringSoFar = replaceInString(stringSoFar, "-", " - ", False)
'
'
'    Set identifyVariablesInEquation = removeBlankValuesFromCollection(gtkns_multDelimiters(predicate, Array("(", ")", " ", "*", "/", "+", "-")))
'End Function
'
'Private Function figureOutNextStep(stringWeAreLookingAt As String) As String
'    If indexOfOpenBracket = 0 And indexOfCloseBracket = 0 Then
'        mode = SHOULD_EVALUATE_EXPRESSION
'    ElseIf indexOfOpenBracket = 0 And indexOfCloseBracket <> 0 Then
'        mode = SHOULD_CLOSE_OUT
'    ElseIf indexOfOpenBracket <> 0 And indexOfCloseBracket = 0 Then
'        mode = SHOULD_EVALUATE_EXPRESSION
'        elwp "Unbalanced open bracket!"
'    ElseIf indexOfOpenBracket < indexOfCloseBracket Then
'        mode = SHOULD_EVALUATE_PARENTHESIS_BLOCK
'    Else
'        If indexOfOpenBracket = indexOfCloseBracket Then
'            elwp_se
'        Else
'            'At this point we know that indexofclosebracket < indexofopenbracket
'
'            'DO NOTHING
'        mode = SHOULD_CLOSE_OUT
'        elwp "Unbalanced close bracket!"
'    End If
'    figureOutNextStep = mode
'End Function


Function multiplyIfIsNumber(candidate As Variant, multiplier As Double) As Variant
    Dim retVal As Variant
    If isNumber(candidate) Then
        retVal = candidate * multiplier
    Else
        atr retVal, candidate
    End If
    
    atr multiplyIfIsNumber, retVal

End Function

Function getNumDecimalPlaces(num As Double) As Long

    Dim numText As String
    numText = CStr(num)
    
    Dim decimalIndx As Long
    decimalIndx = InStr(1, numText, ".")
    
    Dim numDecimals As Long
    If decimalIndx = 0 Then
        numDecimals = 0
    Else
        numDecimals = Len(numText) - decimalIndx
    End If
    getNumDecimalPlaces = numDecimals

End Function

Function computeAreaOfTriangle(width As Double, height As Double) As Double
    computeAreaOfTriangle = width * height / 2
End Function

Sub checkForNegativeSign(ByRef out_isNeg As Boolean, ByRef out_passedInValueWithoutNegativeSign As Variant, theVal As Variant)

    Dim trimmedVal As String
    trimmedVal = Trim(theVal)
    
    Dim passedInValueWithoutNegativeSign As Variant
    Dim isNeg As Boolean
    If left(trimmedVal, 1) = "-" Then
        passedInValueWithoutNegativeSign = Right(trimmedVal, Len(trimmedVal) - 1)
        isNeg = True
    ElseIf startsWith(trimmedVal, "(", False) And endsWith(trimmedVal, ")", False) Then
        passedInValueWithoutNegativeSign = dropFirstAndLastCharacter(trimmedVal)
        isNeg = True
    Else
        passedInValueWithoutNegativeSign = trimmedVal
        isNeg = False
    End If
    out_passedInValueWithoutNegativeSign = passedInValueWithoutNegativeSign
    out_isNeg = isNeg
End Sub

Function medianOfNumbers(arrOfNumbers As Variant) As Double

    Dim size As Long
    size = dimSize(arrOfNumbers, 1)
    
    If size = 0 Then
        medianOfNumbers = 0
    Else
    
        Dim indx As Long
        indx = wsFunctionMin(1, wsFunctionMax(size, (size / 2) + 1))
        
        medianOfNumbers = rlai(arrOfNumbers, indx)
    End If
End Function
Function wsFunctionMin(numOne As Variant, numTwo As Variant) As Variant

    Dim theMin As Variant

On Error GoTo ehs
    theMin = Application.WorksheetFunction.Min(numOne, numTwo)

GoTo ehe
ehs:
    Dim emsg As String
    emsg = "Could not run the native 'Min' function in Excel!  Msg=" & Err.description
    elg emsg
    
    If Not isNumber(numOne) Or Not isNumber(numTwo) Then
        theMin = emsg
    ElseIf CDbl(numOne) <= CDbl(numTwo) Then
        theMin = CDbl(numOne)
    Else
        theMin = CDbl(numTwo)
        
    End If
ehe:
On Error GoTo 0
    
    wsFunctionMin = theMin

End Function
Function wsFunctionMax(numOne As Variant, numTwo As Variant) As Variant
    
    Dim theMax As Variant

On Error GoTo ehs
    theMax = Application.WorksheetFunction.Max(numOne, numTwo)

GoTo ehe
ehs:
    Dim emsg As String
    emsg = "Could not run the native 'Max' function in Excel!  Msg=" & Err.description
    elg emsg
    
    If Not isNumber(numOne) Or Not isNumber(numTwo) Then
        theMax = emsg
    ElseIf CDbl(numOne) >= CDbl(numTwo) Then
        theMax = CDbl(numOne)
    Else
        theMax = CDbl(numTwo)
        
    End If
ehe:
On Error GoTo 0
    
    wsFunctionMax = theMax
    
End Function

Function computeSumProduct(listOfFirstVals As Collection, listOfSecondVals As Collection, ByRef mod_emsgs As Variant) As Variant

    Dim sz As Long
    sz = ccsz(Array(listOfFirstVals, listOfSecondVals), False)
    
    Dim result As Variant
    If sz = VALUE_REPRESENTING_INCONSISTENT_SIZES Then
        Dim emsg As String
        emsg = "ERROR: Mismatched Lengths!"
        mod_emsgs.add emsg
        result = emsg
    Else
    
        Dim ermsg As String
        ermsg = ""
    
        Dim c As Long
        c = 1
        
        Dim soFar As Double
        soFar = 0
        
        While (c <= sz) And (ermsg = "")
            
            Dim firstVal As Variant
            Dim secondVal As Variant
            atr firstVal, listOfFirstVals.item(c)
            atr secondVal, listOfSecondVals.item(c)
            
            If Not isNumber(firstVal) Or Not isNumber(secondVal) Then
                ermsg = "ERROR: Non-Numeric value(s) encountered!"
            Else
                soFar = soFar + (CDbl(firstVal) * CDbl(secondVal))
            End If
            c = c + 1
        Wend
        
        If ermsg <> "" Then
            mod_emsgs.add ermsg
            result = ermsg
        Else
            result = soFar
        End If

    End If
    computeSumProduct = soFar

End Function
Attribute VB_Name = "JYUT_Menus"
Option Explicit

Sub addItemToMenu(menu As CommandBarControl, caption As String, macro As String)
    
    Dim menuButton As Variant
    Set menuButton = menu.Controls.add(Type:=msoControlButton)
    
    menuButton.caption = caption
    menuButton.OnAction = macro

End Sub

Function deleteMenu(menuName As String) As Boolean

    Dim menuDeleted As Boolean
    menuDeleted = False

On Error GoTo ehs

    getMenuBar().Controls(menuName).Delete
    menuDeleted = True
GoTo ehe
ehs:
    elg "Could not delete menu.  Msg=" & Err.description
ehe:
On Error GoTo 0

    deleteMenu = menuDeleted

End Function

Function getMenuBar() As CommandBar
    Set getMenuBar = Application.CommandBars("Worksheet Menu Bar")
End Function

Function addMenuBeforeHelp(menuName As String) As CommandBarControl
    Dim menuBar As CommandBar
    Set menuBar = getMenuBar()
    
    Dim helpMenuIndx As Integer
    helpMenuIndx = menuBar.Controls("Help").index

    Dim customMenu As CommandBarControl
    Set customMenu = menuBar.Controls.add(Type:=msoControlPopup, before:=helpMenuIndx)
    
    customMenu.caption = menuName
    
    Set addMenuBeforeHelp = customMenu
End Function

Attribute VB_Name = "JYUT_Metrics"
Option Explicit

Public Const EMAIL_ADDRESS_TO_SEND_TO_FOR_METRICS As String = "jason.yuen@nomura.com"

'This module relies upon the JYEMAIL library.

'ssName=KozoRisk.TraderVsModelVsBeta
Public Sub LogOpen(ssName As String, emailAddressOrNothingToNotSendEmail As Variant, wb As Workbook, environment As String)
   
On Error GoTo ehs
   
    Dim shortActionName  As String
    Dim actionTaken As String
    Dim successOrerrorMessagesDisplayed As Collection
    shortActionName = "SSOpen"
    actionTaken = "open the spreadsheet"
    Set successOrerrorMessagesDisplayed = Nothing
    
    logActivity ssName, emailAddressOrNothingToNotSendEmail, wb, environment, shortActionName, actionTaken, successOrerrorMessagesDisplayed, Nothing, Nothing
    
GoTo ehe
ehs:
    elg "The following error occurred when we tried to log our worksheet open event: " & Err.description
ehe:
On Error GoTo 0
    
End Sub

Sub logActivityForGenericTypeOfSpreadsheet(anyRNInWorkbook As String, spreadsheetName As String, spreadsheetEmailAddress As String, env As String, shortActionName As String, actionTaken As String, optWSForPage As Worksheet, additionalLinesAtBeginningOrNothingToSkip As Collection, successOrerrorMessagesDisplayed As Collection)
    Dim anyRngeInWB As Range
    Set anyRngeInWB = rnge(anyRNInWorkbook, Nothing)
    
    Dim wb_orNothingIfNotKnown As Workbook
    If isNothing(anyRngeInWB) Then
        Set wb_orNothingIfNotKnown = Nothing
    Else
        Dim ws As Variant
        Set ws = anyRngeInWB.Worksheet
        
        If Not isWorksheet(ws) Then
            Set wb_orNothingIfNotKnown = Nothing
        Else
            Set wb_orNothingIfNotKnown = ws.Parent
        End If
    End If

    logActivity spreadsheetName, spreadsheetEmailAddress, wb_orNothingIfNotKnown, env, shortActionName, actionTaken, successOrerrorMessagesDisplayed, optWSForPage, additionalLinesAtBeginningOrNothingToSkip
End Sub

Sub logActivity(ssName As String, emailAddressOrNothingToNotSendEmail As Variant, wb_orNothingIfNotKnown As Workbook, environment As String, shortActionName As String, actionTaken As String, successOrerrorMessagesDisplayed As Collection, optWSForPage As Worksheet, additionalLinesAtBeginningOrNothingToSkip As Collection)

On Error GoTo ehs

    Dim linesForEmail As Collection
    Dim subject As String
    If isNothing(emailAddressOrNothingToNotSendEmail) Then
        Set linesForEmail = arrayToCollection(Array("Detail is currently not supported when email-logging is disabled."))
        subject = ""
    Else
        
        Dim emsgsFromEmailSending As JYCORE_Set
        Set emsgsFromEmailSending = New JYCORE_Set
        Dim theLinesForEmail As Collection
        Dim theSubject As String
        sendOutEmailDescribingResultOfUserActionOnSpreadsheetThatHasMultipleEnvironments environment, CStr(emailAddressOrNothingToNotSendEmail), ssName, shortActionName, actionTaken, successOrerrorMessagesDisplayed, additionalLinesAtBeginningOrNothingToSkip, Nothing, Nothing, arrayToCollection(Array(EMAIL_ADDRESS_TO_SEND_TO_FOR_METRICS)), wb_orNothingIfNotKnown, emsgsFromEmailSending, theLinesForEmail, theSubject, optWSForPage
        
        If emsgsFromEmailSending.count <> 0 Then
            elg "The following errors occurred when we tried to log our activity via emails: " & emsgsFromEmailSending.toString("|", "\")
        End If
        
        Set linesForEmail = theLinesForEmail
        subject = theSubject
    End If

   
    ' Log open
    
    Dim ssNamePath As String
    ssNamePath = replaceInString(replaceInString(ssName, "\", "_", False), "/", "_", False)
    
    Dim nmeToUse As String
    nmeToUse = constructSubjectLineForEmailLogging(ssNamePath, shortActionName, optWSForPage)
    
    Dim fileName As String
    fileName = dateToYYYYMMDDHHMMSS_ifPossible(Now) & " - " & nmeToUse & ".txt"
    
    Dim pathToRecognize As String
    'JY20130626a - the location is changing
    'pathToRecognize = "\\njfas06b.us.nomura.com\mbsdata$\"
    pathToRecognize = "\\global.nomura.com\fi\AM\NYC\Apps\SPGUser\"
    
    Dim path As String
        'JY20130626a - the location is changing
        'path = appendToPath(appendToPath(pathToRecognize, "PROD\Metrics"), ssNamePath)
    path = appendToPath(appendToPath(pathToRecognize, "prod\sheets\Metrics"), ssNamePath)
    
    ensureFolderPathExists_recognizeSpecificPathAndTreatAsFirstPathElement path, pathToRecognize
    
    Dim textToLog As String
    textToLog = cltstr(nothingToCollection(linesForEmail), CHAR_CRLF, "")
    
    Dim emsgs As String
    Call SaveFileWithText(appendToPath(path, fileName), textToLog, emsgs)
    
    If emsgs <> "" Then
        elg "The following errors occurred when we tried to log our activity via text file: " & emsgsFromEmailSending.toString("|", "\")
    End If

GoTo ehe
ehs:
    elg "The following error occurred when we tried to log our '" & shortActionName & "': " & Err.description
ehe:
On Error GoTo 0

End Sub

Attribute VB_Name = "JYUT_Misc"
Option Explicit

Public Const WEB_PATH_SEPARATOR As String = "/"

Public Const SIMPLE_VALUE_FOR_YES As String = "y"
Public Const SIMPLE_VALUE_FOR_NO As String = "n"

Public Const MAX_TAB_NAME_LENGTH As Long = 31

Public Const FLAG_STRING_TRUE As String = "1"
Public Const FLAG_STRING_FALSE As String = "0"


Public Const DELIM_FOR_UNIQUE_IDS_ON_MAPPINGS_TAB As String = "`"

Sub updateUniqueIDColumn_passInIDAnk(idAnk As Range, rnsInOrderForUniqueIDSubComponents As Variant)

    Dim optWS As Worksheet
    Set optWS = idAnk.Worksheet
    
    clearColumnData idAnk
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rnsInOrderForUniqueIDSubComponents, lwr, upr
    
    Dim listOfSubComponentColData As Collection
    Set listOfSubComponentColData = New Collection
    
    Dim c As Long
    For c = lwr To upr
    
        Dim rn As String
        rn = rnsInOrderForUniqueIDSubComponents(c)
    
        listOfSubComponentColData.add getColumnData(rnge(rn, optWS))
    Next
    
    padCollectionsToMakeThemAllSameSize listOfSubComponentColData, ""
    
    Dim listOfUniqueIDs As Collection
    Set listOfUniqueIDs = arrayToCollection(concatenateCollectionElements(collectionToArray(listOfSubComponentColData), DELIM_FOR_UNIQUE_IDS_ON_MAPPINGS_TAB, False))
    
    scd idAnk, listOfUniqueIDs

End Sub
Sub updateUniqueIDColumn(rnForUniqueIDAnk As String, rnsInOrderForUniqueIDSubComponents As Variant, optWS As Worksheet)

    Dim idAnk As Range
    Set idAnk = rnge(rnForUniqueIDAnk, optWS)
    
    updateUniqueIDColumn_passInIDAnk idAnk, rnsInOrderForUniqueIDSubComponents
    
End Sub


Sub doAssignToReference(ByRef mod_ref As Variant, itemToAssign As Variant, isObjectVsPrimitiveOrNothingIfWeDoNotKnow As Variant)

    Dim isObjectVsPrimitive As Boolean
    If isNothing(isObjectVsPrimitiveOrNothingIfWeDoNotKnow) Then
        isObjectVsPrimitive = IsObject(itemToAssign)
    Else
        isObjectVsPrimitive = CBool(isObjectVsPrimitiveOrNothingIfWeDoNotKnow)
    End If

    If isObjectVsPrimitive Then
        Set mod_ref = itemToAssign
    'ElseIf IsArray(itemToAssign) Then
    '    ReDim mod_ref(1 To 1)
    '    mod_ref = itemToAssign
    Else
        mod_ref = itemToAssign
    End If

End Sub

Sub assignToReference(ByRef mod_ref As Variant, itemToAssign As Variant)
    
    doAssignToReference mod_ref, itemToAssign, Nothing
    
End Sub

Function ensureEmsg(emsg As String) As String
    If Trim(emsg) = "" Then
        ensureEmsg = "An unspecified error has occurred."
    Else
        ensureEmsg = emsg
    End If
End Function

Sub setEnableEvents(enableEvents As Variant)

On Error GoTo ehs

    Application.enableEvents = enableEvents

GoTo ehe
ehs:
    elwp "Could not set enableEvents.  Msg=" & Err.description
ehe:
On Error GoTo 0

End Sub

Sub setDisplayAlerts(dispAlerts As Variant)

On Error GoTo ehs

    Application.DisplayAlerts = dispAlerts
    
GoTo ehe
ehs:
    elwp "Could not set displayAlerts.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Sub closeWB(wb As Workbook, saveChanges As Boolean)

    'JY20120411a - start - for some reason, sometimes when I close a workbook that is not the active workbook, my active workbook changes to something else.  This change is to prevent this.
    Dim origWB As Workbook
    Set origWB = ActiveWorkbook
    
    Dim wbThatShouldBeVisibleAfterwards As Workbook
    If origWB Is wb Then
        'We are closing the active workbook.
        'We therefore have no opinion as to what workbook should be visible afterwards.
        Set wbThatShouldBeVisibleAfterwards = Nothing
    Else
        Set wbThatShouldBeVisibleAfterwards = ActiveWorkbook
    End If
    
'JY20121212a - start - for some reason, the saveChanges parameter stopped suppressing Excel's prompt to save worksheet changes, so I will use the DisplayAlerts method as well.  I think in my case it was the enableEvents that fixed it, but I left the displayAlerts code in there as well just to cover everything.

    Dim origDisplayAlerts As Variant
    Dim origEnableEvents As Variant
    origDisplayAlerts = Application.DisplayAlerts
    origEnableEvents = Application.enableEvents

On Error GoTo ehs
    setDisplayAlerts False
    setEnableEvents False

'JY20121212a - end


    'JY20120411a - end

'JY20140414a - start
'    wb.Close saveChanges

    Dim saveChangesToUse As Boolean
    If wb.IsAddin Then
        'Temporarily set it to NOT be an add-in, that way when we call "close" on it, it will really close
'        Unload wb.Parent
        wb.IsAddin = False
        If saveChanges = True Then
            elwp "Cannot save changes to an add-in!  Not implemented yet."
        End If
        saveChangesToUse = False
    Else
        saveChangesToUse = saveChanges
    End If
        
    wb.Close saveChangesToUse
'JY20140414a - end
    
'JY20121212a - start - for some reason, the saveChanges parameter stopped suppressing Excel's prompt to save worksheet changes, so I will use the DisplayAlerts method as well.  I think in my case it was the enableEvents that fixed it, but I left the displayAlerts code in there as well just to cover everything.
GoTo ehe
ehs:
    elwp Err.description
ehe:
On Error GoTo 0

    setDisplayAlerts origDisplayAlerts
    setEnableEvents origEnableEvents

'JY20121212a - end


    'JY20120411a - start - for some reason, sometimes when I close a workbook that is not the active workbook, my active workbook changes to something else.  This change is to prevent this.
    If isNothing(origWB) Then
        'DO NOTHING
    Else
        If Not origWB Is wb Then
            origWB.Activate
        End If
    End If
    'JY20120411a - end
End Sub

Function getWB(wbName As String) As Workbook

    Dim wb As Workbook
    Set wb = Nothing
    
    Dim candidate As Workbook
    For Each candidate In Application.Workbooks
        If candidate.FullName = wbName Then
            Set wb = candidate
        End If
    Next
        
    Set getWB = wb
End Function

Function columnNumberToLetter(colNum As Long) As String
    
    Dim columnLetter As String
    columnLetter = ""
    
    Dim i As Long, x As Long
    For i = Int(Log(CDbl(25 * (CDbl(colNum) + 1))) / Log(26)) - 1 To 0 Step -1
        x = (26 ^ (i + 1) - 1) / 25 - 1
        If colNum > x Then
            columnLetter = columnLetter & Chr(((colNum - x - 1) \ 26 ^ i) Mod 26 + 65)
        End If
    Next i
    
    columnNumberToLetter = columnLetter

End Function

'setBackgroundColorToWhite = true
Sub createNewWBAndInitForNewProjectAndSetTabToDesiredName(ByRef out_exportWS As Worksheet, ByRef out_emsg As String, desiredTabName As String, setBackgroundColorToWhite As Boolean)
    
    Dim exportWB As Workbook
    Dim emsg As String
    Set exportWB = createNewWBAndInitForNewProject(emsg, setBackgroundColorToWhite).Parent
    
    Dim exportWS As Worksheet
    If emsg <> "" Then
        'DO NOTHING
        Set exportWS = Nothing
    Else
        Set exportWS = exportWB.worksheets(1)
        setTabName exportWS, desiredTabName
        
    End If
    
    Set out_exportWS = exportWS
    out_emsg = emsg
End Sub

Function createNewWBAndInitForNewProject(ByRef out_emsg As String, setBackgroundColorToWhite As Boolean) As Worksheet

    Dim exportWB As Workbook
    Set exportWB = createNewWB(1)
    
    Dim emsg As String
    initWBForNewProject exportWB, emsg, setBackgroundColorToWhite
    
    Set createNewWBAndInitForNewProject = exportWB.worksheets(1)
End Function

Function createNewWB(numSheets As Long) As Workbook

    Dim origWS As Worksheet
    Set origWS = ActiveSheet

    Dim wb As Workbook
    Set wb = Workbooks.add()
    
    Dim startingNumSheets As Long
    startingNumSheets = wb.worksheets.count
    
    Dim c As Long
    For c = startingNumSheets To numSheets + 1 Step -1
        Dim ws As Worksheet
        Set ws = wb.worksheets(c)
        
        deleteWS ws
    Next
    
    Dim d As Long
    For d = startingNumSheets + 1 To numSheets
        wb.worksheets.add
    Next
    origWS.Activate
    
    Set createNewWB = wb

End Function

Function getWorksheetOrLogError(wb As Workbook, wsName As String, ByRef mod_emsgs As Variant)

    Dim ws As Worksheet
    Set ws = getWorksheet(wb, wsName)
    
    If isNothing(ws) Then
        mod_emsgs.add "Could not find the worksheet named '" & wsName & "'!"
    End If
    
    Set getWorksheetOrLogError = ws

End Function

Function getNamesOfWorksheetsInWB(wb As Workbook) As JYCORE_Set
    
    Dim distinctWSNames As JYCORE_Set
    Set distinctWSNames = New JYCORE_Set
    
    Dim ws As Worksheet
    For Each ws In wb.worksheets
        Dim wsName As String
        wsName = ws.name
        
        If distinctWSNames.exists(wsName) Then
            elwp "Duplicate worksheet names detected!"
        Else
            distinctWSNames.add wsName
        End If
    Next
    
    Set getNamesOfWorksheetsInWB = distinctWSNames
    
End Function

Function getWorkbookAssociatedWithReferenceRN(referenceRN As String) As Workbook
    
    Dim anyCellInWB As Range
    Set anyCellInWB = rnge(referenceRN, Nothing)
    
    Dim wb As Workbook
    If isNothing(anyCellInWB) Then
        Set wb = Nothing
    Else
        Dim anyWSInWB As Worksheet
        Set anyWSInWB = anyCellInWB.Worksheet
        
        If isNothing(anyWSInWB) Then
            Set wb = Nothing
            elg "Unable to resolve reference to workbook, because we unexpectedly were not able to resolve the worksheet of our reference range named '" & referenceRN & "'!"
        Else
            Dim theParent As Variant
            Set theParent = anyWSInWB.Parent
            
            If isNothing(theParent) Then
                elg "Unable to resolve reference to workbook, because we unexpectedly were not able to resolve the parent of our reference range's worksheet!"
                Set wb = Nothing
            ElseIf Not isWorkbook(theParent) Then
                elg "Unable to resolve reference to workbook, because we unexpectedly found that the parent of our reference range's worksheet is NOT a workbook!"
                Set wb = Nothing
            Else
                Set wb = theParent
            End If
        End If
    End If
    
    Set getWorkbookAssociatedWithReferenceRN = wb
End Function

Function getWorksheet(wb As Workbook, wsName As String) As Worksheet

    Dim ws As Worksheet
    Set ws = Nothing
    
On Error GoTo ehs
    Set ws = wb.worksheets(wsName)
GoTo ehe
ehs:
    'DO NOTHING
    
    'The worksheet must not exist
ehe:
On Error GoTo 0
    
    Set getWorksheet = ws
End Function

Function addWorksheet(wb As Workbook) As Worksheet
    Set addWorksheet = addWorksheetToSpecificLocation(wb, Nothing, True)
End Function

'beforeVsAfter = true
Function addWorksheetToSpecificLocation(wb As Workbook, beforeOrAfterWhere As Variant, beforeVsAfter As Boolean) As Worksheet

    Dim ws As Worksheet
    Set ws = Nothing

On Error GoTo ehs

    If isNothing(beforeOrAfterWhere) Then
        Set ws = wb.worksheets.add()
    Else
        If beforeVsAfter Then
            Set ws = wb.worksheets.add(beforeOrAfterWhere)
        Else
            Set ws = wb.worksheets.add(, beforeOrAfterWhere)
        End If
    End If
    
GoTo ehe
ehs:
    elwp "Could not create a new worksheet.  Reason: " & Err.description
ehe:
On Error GoTo 0

    Set addWorksheetToSpecificLocation = ws

End Function

Function copyWorksheetToSpecificLocation(wsToCopy As Worksheet, wsToInsertItBefore_orNothingIfToNewWB As Worksheet) As Worksheet
    
    Dim origDispAlerts As Variant
    origDispAlerts = Application.DisplayAlerts
    
    If origDispAlerts <> False Then
        Application.DisplayAlerts = False
    End If
    
    Dim ws As Worksheet
    Set ws = Nothing

On Error GoTo ehs
    If isNothing(wsToInsertItBefore_orNothingIfToNewWB) Then
        'Copy to new workbook
        wsToCopy.Copy
    Else
        'Copy to specific location
        wsToCopy.Copy before:=wsToInsertItBefore_orNothingIfToNewWB
    End If
    
    Set ws = ActiveSheet
    
GoTo ehe
ehs:
    elwp "Could not copy a worksheet.  Reason: " & Err.description
ehe:
On Error GoTo 0

    If Application.DisplayAlerts <> origDispAlerts Then
        Application.DisplayAlerts = origDispAlerts
    End If

    Set copyWorksheetToSpecificLocation = ws
    
End Function


Function copyWorksheet(wsToCopy As Worksheet, intoNewWB As Boolean) As Worksheet

    Dim ws As Worksheet
    If intoNewWB Then
        Set ws = copyWorksheetToSpecificLocation(wsToCopy, Nothing)
    Else
        Set ws = copyWorksheetToSpecificLocation(wsToCopy, wsToCopy)
    End If
    
    Set copyWorksheet = ws
End Function

Sub deleteWS(ws As Worksheet)
    
    Dim origDispAlerts As Boolean
    origDispAlerts = Application.DisplayAlerts

    Application.DisplayAlerts = False

On Error GoTo ehs

    ws.Delete

GoTo ehe
ehs:
    elwp "An error occurred while deleting a worksheet.  Msg=" & Err.description
ehe:
On Error GoTo 0

    Application.DisplayAlerts = origDispAlerts

End Sub

Sub saveWBAs(wb As Workbook, pathAndFileName As String, Optional fileFormat As Variant)

    Dim origDispAlerts As Boolean
    origDispAlerts = Application.DisplayAlerts

    Application.DisplayAlerts = False

On Error GoTo ehs
    If IsMissing(fileFormat) Then
        wb.SaveAs pathAndFileName
    Else
        wb.SaveAs pathAndFileName, fileFormat
    End If
GoTo ehe
ehs:
    elwp "An error occurred while saving a workbook.  Msg=" & Err.description
ehe:

On Error GoTo 0

    Application.DisplayAlerts = origDispAlerts

End Sub

Function getTimeElapsedString(startTime As Variant, endTime As Variant) As String

    Dim seconds As Variant
    seconds = endTime - startTime
    
    Dim secondsInMinute As Long
    Dim secondsInHour As Long
    secondsInMinute = 60
    secondsInHour = 60 * secondsInMinute
    
    
    Dim hours As Long
    hours = removeDecimalPortion(seconds / secondsInHour, False)
    
    seconds = seconds - (hours * secondsInHour)
    
    Dim minutes As Long
    minutes = removeDecimalPortion(seconds / secondsInMinute, False)
    
    seconds = seconds - (minutes * secondsInMinute)
    
    Dim elements As Collection
    Set elements = New Collection
    If hours <> 0 Then
        elements.add hours & " hours"
    End If
    If minutes <> 0 Then
        elements.add minutes & " minutes"
    End If
    If seconds <> 0 Then
        elements.add Application.WorksheetFunction.Round(seconds, 0) & " seconds"
    End If
    
    Dim elapsedTimeStr As String
    elapsedTimeStr = cltstr(elements, ", ", "")
    
    getTimeElapsedString = elapsedTimeStr

End Function

Function getTimeCompletedMessage(startTime As Variant, endTime As Variant, msg As String) As String
    
    Dim elapsedTimeStr As String
    elapsedTimeStr = getTimeElapsedString(startTime, endTime)
    
    Dim timeElapsedMsg As String
    If elapsedTimeStr = "" Then
        timeElapsedMsg = ""
    Else
        timeElapsedMsg = elapsedTimeStr
    End If
    
    Dim timeCompletedMsg As String
    If timeElapsedMsg = "" Then
        timeCompletedMsg = ""
    Else
        timeCompletedMsg = CHAR_CRLF & CHAR_CRLF & "(elapsed time: " & timeElapsedMsg & ")"
    End If
    
    getTimeCompletedMessage = msg & timeCompletedMsg
End Function

Sub showTimeCompletedMesssage(startTime As Variant, endTime As Variant, msg As String)

    
    Dim daMsg As String
    daMsg = getTimeCompletedMessage(startTime, endTime, msg)
    
    ilwp daMsg

End Sub

Sub setFormulaArray(theCell As Range, theFormula As String)
    If Len(theFormula) > 255 Then
        theCell.value = "cannot compute, because formula is too long"
    Else
        theCell.FormulaArray = theFormula
    End If
End Sub

Function getDataFromRnge(rnge As Range) As Collection
    
    Dim data As Collection
    Set data = New Collection
    
    Dim botRight As Range
    Set botRight = brcor(rnge)
    
    Dim startRow As Long
    Dim startCol As Long
    Dim endRow As Long
    Dim endCol As Long
    startRow = rnge.row
    startCol = rnge.column
    endRow = botRight.row
    endCol = botRight.column
    
    Dim r As Long
    For r = startRow To endRow
        Dim c As Long
        For c = startCol To endCol
            data.add gvl(rnge.Worksheet.cells(r, c))
        Next
    Next
    
    Set getDataFromRnge = data
End Function

Sub setFilter(headerRowsForFilter As Range, anyCellInFilterCol As Range, criteria As Variant)

    Dim listOf__anyCellInFilterCol_allowedValuesArr As Collection
    Set listOf__anyCellInFilterCol_allowedValuesArr = New Collection
    With listOf__anyCellInFilterCol_allowedValuesArr
        .add Array(anyCellInFilterCol, Array(criteria))
    End With

    setFilters headerRowsForFilter, listOf__anyCellInFilterCol_allowedValuesArr

End Sub
Sub setFilters(headerRowsForFilter As Range, listOf__anyCellInFilterCol_allowedValuesArr As Collection)

On Error GoTo ehs

    clearFiltersFromPageIfNecessary headerRowsForFilter.Worksheet, True, False
    
    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    Dim lstOf__anyCellInFilterCol_allowedValuesArr As Collection
    Set lstOf__anyCellInFilterCol_allowedValuesArr = New Collection
    Dim d As Long
    For d = 1 To listOf__anyCellInFilterCol_allowedValuesArr.count
        Dim anyCellInFilterCol_allowedValuesArr As Variant
        anyCellInFilterCol_allowedValuesArr = listOf__anyCellInFilterCol_allowedValuesArr.item(d)
        
        Dim anyCellInFilterCl As Range
        Dim allwdValsArr As Variant
        Set anyCellInFilterCl = rlai(anyCellInFilterCol_allowedValuesArr, 1)
        atr allwdValsArr, rlai(anyCellInFilterCol_allowedValuesArr, 2)
        
        Dim columnName As String
        columnName = gvl(gcicsr(anyCellInFilterCl, tlcor(headerRowsForFilter).row))
        If Trim(columnName) = "" Then
            columnName = "Column #" & anyCellInFilterCl.column
        End If
        
        Dim suffix As String
        suffix = " for column [" & columnName & "]."
        
        Dim emsg As String
        emsg = "ERROR: NOT SET!!!"
        If Not IsArray(allwdValsArr) Then
            emsg = "Invalid filter criteria data format" & suffix
        Else
            Dim sz As Long
            sz = dimSize(allwdValsArr, 1)
            
            If sz <= 0 Then
                emsg = "No filter criteria specified" & suffix
            Else
                If anyInCollectionAreBlank(arrayToCollection(allwdValsArr)) Then
                    emsg = "Cannot filter by blank values, but you specified that you wanted to filter column [" & columnName & "] by a blank value."
                Else
                    emsg = ""
                End If
            End If
        End If
        
        If emsg <> "" Then
            emsgs.add emsg
        Else
            lstOf__anyCellInFilterCol_allowedValuesArr.add anyCellInFilterCol_allowedValuesArr
        End If
    Next
    
    If emsgs.count <> 0 Then
        elwp emsgs.toString(CHAR_CRLF, "")
    End If
    
    Dim c As Long
    For c = 1 To lstOf__anyCellInFilterCol_allowedValuesArr.count
    
        Dim anyCellInFilterCol_allowedValsArray As Variant
        anyCellInFilterCol_allowedValsArray = listOf__anyCellInFilterCol_allowedValuesArr.item(c)
        
        Dim anyCellInFilterCol As Range
        Dim allowedvalsArray As Variant
        Set anyCellInFilterCol = rlai(anyCellInFilterCol_allowedValsArray, 1)
        allowedvalsArray = rlai(anyCellInFilterCol_allowedValsArray, 2)
    
        Dim colNum As Long
        colNum = anyCellInFilterCol.column - tlcor(headerRowsForFilter).column + 1
        
        setAutoFilter headerRowsForFilter, colNum, allowedvalsArray
        
        
        
    Next
    
    Dim sel As Range
    Set sel = Selection
    If isNothing(sel) Then
        'DO NOTHING
    Else
        srgAndTryToCenterAroundIt sel
    End If
    
GoTo ehe
ehs:
    elwp "Cannot set filters.  Reason: " & Err.description
ehe:
On Error GoTo 0
End Sub

Sub setAutoFilter(headerRowsForFilter As Range, colNum As Long, allowedvalsArray As Variant)
On Error GoTo ehs
    headerRowsForFilter.AutoFilter field:=colNum, Criteria1:=allowedvalsArray, Operator:=xlFilterValues
GoTo ehe
ehs:
    elwp "Could not set filter.  Reason: " & Err.description
ehe:
On Error GoTo 0

End Sub

Sub clearFiltersFromPageIfNecessaryAndInformUserIfDone(ws As Worksheet, clearAutofilterVersusJustShowEverything As Boolean)
    clearFiltersFromPageIfNecessary ws, clearAutofilterVersusJustShowEverything, True
End Sub
Sub clearFiltersFromPageIfNecessary(ws As Worksheet, clearAutofilterVersusJustShowEverything As Boolean, showSuccessMsg As Boolean)
    
    If (ws.AutoFilterMode = True) Or (ws.FilterMode = True) Then
        
        Dim origSelection As Range
        Set origSelection = Selection
        
        Dim origWS As Worksheet
        Set origWS = ActiveSheet
        
        Dim filtersCleared As Boolean
        filtersCleared = False
        
        If clearAutofilterVersusJustShowEverything Then
            If ws.AutoFilterMode = True Then
                ws.Activate
                ws.Range("A1").AutoFilter
                filtersCleared = True
            End If
        End If
        
        If ws.FilterMode = True Then
            ws.Activate
            ws.ShowAllData
            filtersCleared = True
        End If
    
        If filtersCleared Then
        
            'If Not isNothing(optRngeToReapplyFilterTo) Then
            '    optRngeToReapplyFilterTo.AutoFilter
            'End If
            
            If showSuccessMsg Then
                ilwp "Please note that we have cleared the filters on this worksheet as a precaution, to make sure all of our macro code runs correctly."
            End If
            
            If isNothing(origSelection) Then
                If Not isNothing(origWS) Then
                    origWS.Activate
                End If
            Else
                srg origSelection
            End If
                
        End If
        
        
    
    End If
    
End Sub



Sub ssbm_everyX(theCurRow As Long, theLastRow As Long, Optional optMsg As String, Optional x As Long)

    Dim cnt As Long
    cnt = theLastRow - theCurRow + 1
    
    Dim shouldShow As Boolean
    If cnt = 1 Then
        shouldShow = True
    ElseIf x = 0 Then
        shouldShow = True
    ElseIf cnt Mod x = 0 Then
        shouldShow = True
    Else
        shouldShow = False
    End If
    
    If shouldShow Then
        
        Dim msg As String
        If isBlankValue(optMsg) Then
            msg = "Processing"
        Else
            msg = optMsg
        End If
    
        ssbm msg & " row #" & theCurRow & " (last row is " & theLastRow & ")..."
    Else
        'DO NOTHING
    End If
End Sub



Sub ssbm_done()
    ssbm "Done processing rows!"
End Sub

'"gvsdr" stands for "getValidSelectedDataRows"
Function gvsdr(userSel As Range, anyCellInColHeader As Range) As Range

    Dim userWS As Worksheet
    Dim headerWS As Worksheet
    Set userWS = userSel.Worksheet
    Set headerWS = anyCellInColHeader.Worksheet
    
    If Not (userWS Is headerWS) Then
        elwp "Worksheet mismatch!"
        Set gvsdr = Nothing
    ElseIf isNothing(userSel) Then
        elwp "Please pass in a user selection!"
        Set gvsdr = Nothing
    Else
        Dim firstRow As Long
        Dim lastRow As Long
        firstRow = userSel.row
        lastRow = brcor(userSel).row
        
        If firstRow <= anyCellInColHeader.row Then
            firstRow = anyCellInColHeader.row + 1
        End If
        
        If lastRow < firstRow Then
            Set gvsdr = Nothing
        Else
            Dim templateRnge As Range
            Set templateRnge = resizeRnge(userSel, 1, userSel.Columns.count)
            
            Set gvsdr = rngeToRnge(moveRnge(templateRnge, firstRow, templateRnge.column), moveRnge(templateRnge, lastRow, templateRnge.column))
        End If
        
        
    End If

End Function

'Stands for "getValidSelectedDataCols"
Function gvsdc(userSel As Range, anyCellInRowHeader As Range) As Range

    Dim userWS As Worksheet
    Dim headerWS As Worksheet
    Set userWS = userSel.Worksheet
    Set headerWS = anyCellInRowHeader.Worksheet
    
    If Not (userWS Is headerWS) Then
        elwp "Worksheet mismatch!"
        Set gvsdc = Nothing
    ElseIf isNothing(userSel) Then
        elwp "Please pass in a user selection!"
        Set gvsdc = Nothing
    Else
        Dim firstCol As Long
        Dim lastCol As Long
        firstCol = userSel.column
        lastCol = brcor(userSel).column
        
        If firstCol <= anyCellInRowHeader.column Then
            firstCol = anyCellInRowHeader.column + 1
        End If
        
        If lastCol < firstCol Then
            Set gvsdc = Nothing
        Else
            Dim templateRnge As Range
            Set templateRnge = resizeRnge(userSel, userSel.rows.count, 1)
            
            Set gvsdc = rngeToRnge(moveRnge(templateRnge, templateRnge.row, firstCol), moveRnge(templateRnge, templateRnge.row, lastCol))
        End If
        
        
    End If

End Function

Function textToBoolean(theValue As Variant) As Boolean
    
    If isBoolean(theValue) Then
        textToBoolean = CBool(theValue)
    Else
        Dim theText As String
        theText = Trim(LCase(CStr(theValue)))
        
        If theText = "true" Or theText = "yes" Or left(theText, 1) = "y" Then
            textToBoolean = True
        Else
            textToBoolean = False
        End If
    End If
    
End Function

Function convertBooleanToTextIfPossible(theValue As Variant) As Variant
    If isBoolean(theValue) Then
        convertBooleanToTextIfPossible = booleanToText(CBool(theValue))
    Else
        convertBooleanToTextIfPossible = theValue
    End If
End Function

Function booleanToText(theValue As Boolean) As String
    If theValue Then
        booleanToText = SIMPLE_VALUE_FOR_YES
    Else
        booleanToText = SIMPLE_VALUE_FOR_NO
    End If
End Function

'ignoreSpacesBetweenWords = false
'caseInsensitive = true
Function getAdvancedDictionaryFromConfigTable(keyRNOrArrayOfKeyRNs As Variant, valRNOrArrayOfValRNs As Variant, optWS As Worksheet, multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues As Boolean, showPopupMsgWhenDuplicateAssignmentIsDetected As Boolean, listsShouldBeCollectionsAsOpposedToArrays As Boolean, ignoreBlankKeys As Boolean, mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors As Variant, showStatusBarMsgUpdates As Boolean, shouldCastKeyToStringIfHelpsFindValue As Boolean, blankRangeNamesAreExpectedAndOk As Boolean, ByRef mod_emsgs As Variant, ignoreSpacesBetweenWords As Boolean, caseInsensitive As Boolean, shouldTrimKey As Boolean) As JYUT_AdvancedDictionary

    Dim valueByFieldName As Dictionary
    Set valueByFieldName = getDictionaryFromConfigTable(keyRNOrArrayOfKeyRNs, valRNOrArrayOfValRNs, optWS, multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues, showPopupMsgWhenDuplicateAssignmentIsDetected, listsShouldBeCollectionsAsOpposedToArrays, ignoreBlankKeys, mod_emsgs, showStatusBarMsgUpdates, shouldCastKeyToStringIfHelpsFindValue, blankRangeNamesAreExpectedAndOk)
    
    Dim adjValueByFieldName As JYUT_AdvancedDictionary
    Set adjValueByFieldName = createAdvancedDictionaryFromDictionary(valueByFieldName, mod_emsgs, ignoreSpacesBetweenWords, caseInsensitive, shouldTrimKey)
    
    Set getAdvancedDictionaryFromConfigTable = adjValueByFieldName
End Function

Function createAdvancedDictionaryFromDictionary(valueByFieldName As Dictionary, ByRef mod_emsgs As Variant, ignoreSpacesBetweenWords As Boolean, caseInsensitive As Boolean, shouldTrimKey As Boolean) As JYUT_AdvancedDictionary
    
    Dim dict As JYUT_AdvancedDictionary
    Set dict = createAdvancedDictionary(caseInsensitive, ignoreSpacesBetweenWords, shouldTrimKey)
     
    Dim overrideNVPs As Dictionary
    Set overrideNVPs = addDictionaryToDictionary(dict, valueByFieldName)
    
    If overrideNVPs.count <> 0 Then
        mod_emsgs.add "The following parameters were duplicated (and ignored): '" & arrayToString(overrideNVPs.keys, " ... ", "")
    End If
    
    Set createAdvancedDictionaryFromDictionary = dict
End Function

Function createAdvancedDictionary(caseInsensitive As Boolean, ignoreSpacesBetweenWords As Boolean, trimKey As Boolean) As JYUT_AdvancedDictionary

    Dim obj As JYUT_AdvancedDictionary
    Set obj = New JYUT_AdvancedDictionary
    With obj
        .shouldTrimKey = trimKey
        .caseInsensitive = caseInsensitive
        .ignoreSpacesBetweenWords = ignoreSpacesBetweenWords
    End With
    
    Set createAdvancedDictionary = obj

End Function

'listsShouldBeCollectionsAsOpposedToArrays = false
'whenMultValsAllowedForKey_representValsAsPrimitivesWheneverPossible = true
'ignoreBlankKeys = false
'mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors = nothing
'showStatusBarMsgUpdates = false
'shouldCastKeyToStringIfHelpsFindValue = false
'blankRangeNamesAreExpectedAndOk= false
Function getDictionaryFromConfigTable(keyRNOrArrayOfKeyRNs As Variant, valRNOrArrayOfValRNs As Variant, optWS As Worksheet, multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues As Boolean, showPopupMsgWhenDuplicateAssignmentIsDetected As Boolean, listsShouldBeCollectionsAsOpposedToArrays As Boolean, ignoreBlankKeys As Boolean, mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors As Variant, showStatusBarMsgUpdates As Boolean, shouldCastKeyToStringIfHelpsFindValue As Boolean, blankRangeNamesAreExpectedAndOk As Boolean) As Dictionary
    
    Dim arrOfRNs As Variant
    Dim numValRNs As Long
    convertRNOrArrayOfRNsToArrayOfRNs arrOfRNs, numValRNs, valRNOrArrayOfValRNs
    
    Dim keyRNs As Variant
    Dim numElementsInKey As Long
    convertRNOrArrayOfRNsToArrayOfRNs keyRNs, numElementsInKey, keyRNOrArrayOfKeyRNs
    
    Dim rnsToRetrieve As Collection
    Set rnsToRetrieve = New Collection
    acltcl rnsToRetrieve, arrayToCollection(keyRNs)
    acltcl rnsToRetrieve, arrayToCollection(arrOfRNs)
    
    Dim listOfKeysAndValues As Collection
    Set listOfKeysAndValues = getListOfValuesFromConfigTable(kta(rnsToRetrieve), optWS, blankRangeNamesAreExpectedAndOk)
    
    'Dim listOfKeysAndValues As Collection
    'If Not forceAllKeysToBeStrings Then
    '    Set listOfKeysAndValues = lstOfKeysAndValues
    'Else
    '    Set listOfKeysAndValues = New Collection
    '    Dim xx As Long
    '    For xx = 1 To lstOfKeysAndValues.count
    '        Dim row As Variant
    '        row = lstOfKeysAndValues.item(xx)
    '
    '        Dim newRow As Variant
    '        newRow = row
    '
    '        Dim lwr As Long
    '        Dim upr As Long
    '        glaubs newRow, lwr, upr
    '
    '        Dim yy As Long
    '        For yy = lwr To upr
    '            newRow(yy) = CStr(newRow(yy))
    '        Next
    '
    '        listOfKeysAndValues.add newRow
    '    Next
    'End If
    
    Dim interimDictionary As Dictionary
    Set interimDictionary = New Dictionary
    
    
    Dim c As Long
    For c = 1 To listOfKeysAndValues.count
        
        
        If showStatusBarMsgUpdates Then
            ssbm "Building Dictionary.  Processing item #" & c & " (of " & listOfKeysAndValues.count & ")..."
        End If
    
        Dim keysAndValues As Variant
        keysAndValues = listOfKeysAndValues.item(c)
        
        Dim arrOfKeys As Variant
        arrOfKeys = removeXElementsFromEndOfArray(keysAndValues, numValRNs)
        
        Dim arrOfValues As Variant
        arrOfValues = removeXElementsFromBeginningOfArray(keysAndValues, numElementsInKey)
        
        Dim valueOrArrOfValues As Variant
        If numValRNs = 1 Then
            If dimSize(arrOfValues, 1) <> 1 Then
                elwp_se
                valueOrArrOfValues = arrOfValues
            Else
                valueOrArrOfValues = rlai(arrOfValues, 1)
            End If
        Else
            valueOrArrOfValues = arrOfValues
        End If
        
        If allInArrayListAreBlank(arrOfKeys) And ignoreBlankKeys Then
            'DO NOTHING
        Else
            addEntryToInterimDictionaryBeingCreatedFromConfigTable interimDictionary, arrOfKeys, valueOrArrOfValues, multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues, showPopupMsgWhenDuplicateAssignmentIsDetected, mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors, shouldCastKeyToStringIfHelpsFindValue
        End If
    Next
    If showStatusBarMsgUpdates Then
        ssbm "Done Building Dictionary!"
    End If
    
    Dim adjDict As Dictionary
    Set adjDict = getFinalDictionaryFromInterimDictionaryBeingCreatedFromConfigTable(numElementsInKey, interimDictionary, multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues, listsShouldBeCollectionsAsOpposedToArrays, shouldCastKeyToStringIfHelpsFindValue)
    
    Set getDictionaryFromConfigTable = adjDict

End Function

Function getFinalDictionaryFromInterimDictionaryBeingCreatedFromConfigTable(numElementsInKey As Long, interimDictionary As Dictionary, multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues As Boolean, listsShouldBeCollectionsAsOpposedToArrays As Boolean, shouldCastKeyToStringIfHelpsFindValue As Boolean) As Dictionary
    
    Dim adjDict As Dictionary
    If multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues Then
        
        Set adjDict = New Dictionary
        
        Dim daKeys As Collection
        Set daKeys = getNestedDictionaryPaths_customMaxLevels(interimDictionary, False, numElementsInKey)
        
        Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
        assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = False '<-- false, because it the "customMaxLevels" version of the getNestedDictionaryPaths function is being used, which seems to imply that we might not be dealing with the full nested keys
        
        Dim rr As Long
        For rr = 1 To daKeys.count
            Dim daCurKey As Variant
            atr daCurKey, daKeys.item(rr)
            
            Dim daNestedDict As Dictionary
            Set daNestedDict = getValueForNestedDictionaryPath(interimDictionary, daCurKey, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
        
            Dim allPaths As Collection
            Set allPaths = getNestedDictionaryPaths(daNestedDict, False)
        
            Dim arrayOfValues As Variant
            ReDim arrayOfValues(1 To allPaths.count)
        
            Dim cc As Long
            For cc = 1 To allPaths.count
                Dim arrayOfValuesForOneLineItem As Variant
                arrayOfValuesForOneLineItem = allPaths.item(cc)
                
                Dim valueOrArrayOfValuesForOneLineItem As Variant
                If dimSize(arrayOfValuesForOneLineItem, 1) = 1 Then
                    atr valueOrArrayOfValuesForOneLineItem, rlai(arrayOfValuesForOneLineItem, 1)
                Else
                    valueOrArrayOfValuesForOneLineItem = arrayOfValuesForOneLineItem
                End If
                
                Dim theList As Variant
                If listsShouldBeCollectionsAsOpposedToArrays Then
                    If IsArray(valueOrArrayOfValuesForOneLineItem) Then
                        Set theList = arrayToCollection(valueOrArrayOfValuesForOneLineItem)
                    Else
                        theList = valueOrArrayOfValuesForOneLineItem
                    End If
                Else
                    theList = valueOrArrayOfValuesForOneLineItem
                End If
                
                atr arrayOfValues(cc), theList
            Next
            setValueForNestedDictionaryPath adjDict, daCurKey, arrayOfValues, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
        Next
    Else
        Set adjDict = interimDictionary
    End If
    
    Set getFinalDictionaryFromInterimDictionaryBeingCreatedFromConfigTable = adjDict
End Function

'mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors = nothing
'shouldCastKeyToStringIfHelpsFindValue = false
Sub addEntryToInterimDictionaryBeingCreatedFromConfigTable(ByRef mod_dict As Dictionary, keyOrArrOfKeysOrCollectionOfKeys As Variant, valueOrArrOfValues As Variant, multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues As Boolean, showPopupMsgWhenDuplicateAssignmentIsDetected As Boolean, ByRef mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors As Variant, shouldCastKeyToStringIfHelpsFindValue As Boolean)
    
    Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
    assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True '<-- true, by intention.  This is tricky.
    
    Dim arrOfKeys As Variant
    arrOfKeys = ensureValueIsAnArray(keyOrArrOfKeysOrCollectionOfKeys)
    
    If multipleValuesAllowedForEachKey_ifSoThenTheValueInResultingDictWillBeAnArrayOfValues Then
        
        Dim nestedDict As Dictionary
        If nestedPathExists(mod_dict, arrOfKeys, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree) Then
            Set nestedDict = getValueForNestedDictionaryPath(mod_dict, arrOfKeys, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
        Else
            Set nestedDict = New Dictionary
            setValueForNestedDictionaryPath mod_dict, arrOfKeys, nestedDict, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
        End If
        
        Dim nestedPath As Variant
        nestedPath = ensureValueIsAnArray(valueOrArrOfValues)
        
        Dim assumeThatNstedPathIsSupposedToBringUsToTheLeafNodeIntheTree2 As Boolean
        assumeThatNstedPathIsSupposedToBringUsToTheLeafNodeIntheTree2 = True '<-- true, by intention
        
        If nestedPathExists(nestedDict, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNstedPathIsSupposedToBringUsToTheLeafNodeIntheTree2) Then
            Dim emsg3 As String
            emsg3 = "Duplicate name-value pair detected!"
            If Not isNothing(mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors) Then
                mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors.add emsg3
            End If
            If showPopupMsgWhenDuplicateAssignmentIsDetected Then
                elwp emsg3
            End If
        Else
            setValueForNestedDictionaryPath nestedDict, nestedPath, "", shouldCastKeyToStringIfHelpsFindValue, assumeThatNstedPathIsSupposedToBringUsToTheLeafNodeIntheTree2 'the blank string is arbitrary
        End If
        
    Else
        If nestedPathExists(mod_dict, arrOfKeys, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree) Then
            
            Dim emsg1 As String
            emsg1 = "Duplicate key '" & arrayToString(arrOfKeys, "|", "\") & "' detected!"
            
            If Not isNothing(mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors) Then
                mod_emsgs__orNothingIfYouDoNotWantToTrackDuplicateAssignmentErrors.add emsg1
            End If
            
            If showPopupMsgWhenDuplicateAssignmentIsDetected Then
                elwp emsg1
            End If
        Else
            setValueForNestedDictionaryPath mod_dict, arrOfKeys, valueOrArrOfValues, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
        End If
    End If
End Sub

Function getListOf_dictionaryOfNameValuePairs_fromConfigTable(columnHeaders As Range) As Collection

    Dim listOf_dictionaryOfNameValuePairs As Collection
    Set listOf_dictionaryOfNameValuePairs = New Collection
    
    Dim ranges As JYUT_RngeIncrementer
    Dim rns As Variant
    Set ranges = getRngesObjectForRngeOfcolHeaders(columnHeaders, rns)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rns, lwr, upr
    
    While ranges.moreDataRemaining
    
        Dim thisDict As Dictionary
        Set thisDict = New Dictionary
        
        Dim c As Long
        For c = lwr To upr
            
            Dim curRN As String
            curRN = rns(c)
            
            Dim curAnchor As Range
            Set curAnchor = ranges.getAnchorCell(curRN)
            
            Dim curFieldName As String
            curFieldName = gvl(curAnchor)
            
            Dim curVal As Variant
            curVal = ranges.getValue(curRN)
            
            If thisDict.exists(curFieldName) Then
                elwp "'" & curFieldName & "' already exists!"
            ElseIf Trim(curVal) = "" Then
                'DO NOTHING
            Else
                atd thisDict, curFieldName, curVal
            End If
        Next
    
        listOf_dictionaryOfNameValuePairs.add thisDict
    
        ranges.increment
    
    Wend
    
    Set getListOf_dictionaryOfNameValuePairs_fromConfigTable = listOf_dictionaryOfNameValuePairs

End Function

Function getRngesObjectForRngeOfcolHeaders(columnHeaders As Range, ByRef out_rns As Variant) As JYUT_RngeIncrementer

    Dim ws As Worksheet
    Set ws = columnHeaders.Worksheet
    
    Dim theRngesObj As JYUT_RngeIncrementer
    Dim rns As Variant
    If columnHeaders.rows.count <> 1 Then
        elwp "Please pass in a range that has exactly one row!"
        Set theRngesObj = Nothing
        Set rns = Nothing
    Else
    
        Dim firstCol As Long
        Dim lastCol As Long
        firstCol = columnHeaders.column
        lastCol = brcor(columnHeaders).column
        
        ReDim rns(firstCol To lastCol)
        
        
        Dim headerRow As Long
        headerRow = columnHeaders.row
        
        Set theRngesObj = New JYUT_RngeIncrementer
        
        Dim c As Long
        For c = firstCol To lastCol
            Dim curAnchor As Range
            Set curAnchor = ws.cells(headerRow, c)
            
            Dim curRN As String
            curRN = "col" & c
            
            rns(c) = curRN
            theRngesObj.addRnge curRN, curAnchor, False
            
        Next
    
    End If
    
    atr out_rns, rns
    Set getRngesObjectForRngeOfcolHeaders = theRngesObj

End Function

'blankRangeNamesAreExpectedAndOk = false
Function getListOfValuesFromConfigTable(arrOfRNs As Variant, optWS As Worksheet, blankRangeNamesAreExpectedAndOk As Boolean) As Collection

    Dim listOfRowValueArrays As Collection
    Set listOfRowValueArrays = New Collection
    
    Dim ranges As JYUT_RngeIncrementer
    Set ranges = New JYUT_RngeIncrementer
    
    Dim arrSize As Long
    arrSize = dimSize(arrOfRNs, 1)
    
    Dim anchors As Variant
    ReDim anchors(1 To arrSize)
    
    Dim d As Long
    For d = 1 To arrSize
        Dim rn As String
        rn = rlai(arrOfRNs, d)
        
        If rn = "" Then
            If Not blankRangeNamesAreExpectedAndOk Then
                elwp "Encountered a blank range name!"
            End If
            Set anchors(d) = Nothing
        Else
            Set anchors(d) = rnge(rn, optWS)
        End If
    Next
    
    Dim arrSize2 As Long
    arrSize2 = casz(Array(anchors, arrOfRNs), True)
    
    Dim encounteredRNs As JYCORE_Set
    Set encounteredRNs = New JYCORE_Set
    
    Dim c As Long
    For c = 1 To arrSize2
        Dim rn2 As String
        rn2 = rlai(arrOfRNs, c)
        
    
        Dim anchor As Range
        Set anchor = rlai(anchors, c)
        
        If isNothing(anchor) Or rn2 = "" Then
            'DO NOTHING
        Else
            If encounteredRNs.exists(rn2) Then
                'DO NOTHING
                'rn was already added
            Else
                ranges.addRnge rn2, anchor, False
            End If
            encounteredRNs.add rn2
        End If
    Next
    
    While ranges.moreDataRemaining
    
        Dim rowVals As Variant
        ReDim rowVals(1 To arrSize)
        
        Dim j As Long
        For j = 1 To arrSize
            Dim daRN As String
            daRN = rlai(arrOfRNs, j)
            
            Dim daVal As Variant
            If daRN = "" Then
                daVal = "???"
            Else
                daVal = ranges.getValue(daRN)
            End If
            
            rowVals(j) = daVal
        Next
        
        listOfRowValueArrays.add rowVals
        ranges.increment
    Wend
    
    Set getListOfValuesFromConfigTable = listOfRowValueArrays
    
End Function

Function allAreEqual(values As Variant) As Boolean
    
    Dim sz As Long
    sz = dimSize(values, 1)
    
    Dim equalSoFar As Boolean
    equalSoFar = True
    
    Dim nextValue As Variant
    atr nextValue, rlai(values, 1)
    
    Dim c As Long
    For c = 2 To sz
        Dim prevValue As Variant
        atr prevValue, nextValue
        
        nextValue = rlai(values, c)
        
        If Not valuesAreEqual(prevValue, nextValue) Then
            equalSoFar = False
        End If
    Next
    
    allAreEqual = equalSoFar
    
End Function

Function allValuesAreEqual(arrOfValuesOrObjects As Variant) As Boolean

    Dim sz As Long
    sz = dimSize(arrOfValuesOrObjects, 1)

    Dim allAreEqualSoFar As Boolean
    If sz = 0 Then
        elwp "You passed in nothing to compare!"
        allAreEqualSoFar = False
    ElseIf sz = 1 Then
        elwp "You only passed in one item to compare!"
        allAreEqualSoFar = False
    Else

        Dim lwr As Long
        Dim upr As Long
        glaubs arrOfValuesOrObjects, lwr, upr
        
        Dim firstValueOrObject As Variant
        atr firstValueOrObject, rlai(arrOfValuesOrObjects, 1)
        
        
        allAreEqualSoFar = True
        Dim c As Long
        c = 2
        While (c <= sz) And (allAreEqualSoFar)
            Dim nextValueOrObject As Variant
            atr nextValueOrObject, rlai(arrOfValuesOrObjects, c)
            
            If valuesAreEqual(firstValueOrObject, nextValueOrObject) Then
                'DO NOTHING
            Else
                allAreEqualSoFar = False
            End If
            
            c = c + 1
        Wend
    End If
    
    allValuesAreEqual = allAreEqualSoFar
End Function



Function computePercentageOfArrayElementsThatAreEqual(firstOneDimArray As Variant, secondOneDimArray As Variant, ignoreBoundMismatches As Boolean, ByRef out_listOfArrayIndexesThatAreNotEqualWhereTheFirstIndexIsOne As Collection) As Double

    Dim listOfArrayIndexesThatAreNotEqualWhereTheFirstIndexIsOne As Collection
    Set listOfArrayIndexesThatAreNotEqualWhereTheFirstIndexIsOne = New Collection

    Dim arrsAreEq As Boolean
    Dim commonSize As Long
    arrsAreEq = doArraysAreEqual(firstOneDimArray, secondOneDimArray, ignoreBoundMismatches, listOfArrayIndexesThatAreNotEqualWhereTheFirstIndexIsOne, commonSize)

    Dim percentageThatAreEqual As Long
    If arrsAreEq Then
        percentageThatAreEqual = 1
    Else
    
        Dim numUnEqual As Double
        numUnEqual = listOfArrayIndexesThatAreNotEqualWhereTheFirstIndexIsOne.count
    
        If numUnEqual = 0 Then
            elwp "Unable to figure out what percentage of the array elements are equal, but we know that the arrays are not equal.  We will assume zero percent."
            percentageThatAreEqual = 0
        ElseIf commonSize = VALUE_REPRESENTING_INCONSISTENT_SIZES Then
            elwp "Unable to compute the percentage of array elements that are equal, because the arrays are not of the same size!  Something is wrong here, this should not have happened.  Probably a programming error."
            percentageThatAreEqual = 0
        ElseIf commonSize = 0 Then
            elwp "Unable to compute the percentage of array elements that are equal, because the arrays are empty!"
            percentageThatAreEqual = 0
        Else
        
            Dim numEqual As Double
            numEqual = (commonSize - numUnEqual)
            
            percentageThatAreEqual = numEqual / commonSize
            
        End If
    End If
        
    Set out_listOfArrayIndexesThatAreNotEqualWhereTheFirstIndexIsOne = listOfArrayIndexesThatAreNotEqualWhereTheFirstIndexIsOne
    
    computePercentageOfArrayElementsThatAreEqual = percentageThatAreEqual

End Function

Function arraysAreEqual(V1 As Variant, V2 As Variant) As Boolean

    Dim commonSize As Long
    arraysAreEqual = doArraysAreEqual(V1, V2, False, Nothing, commonSize)
    
End Function

Function arraysAreEqual_ignoreBoundMismatches(V1 As Variant, V2 As Variant) As Boolean
    
    Dim commonSize As Long
    arraysAreEqual_ignoreBoundMismatches = doArraysAreEqual(V1, V2, True, Nothing, commonSize)
    
End Function

'mod_collectionToAddUnequalIndexesToIfWhereFirstIndexIsOne_orNothingIfWeAreNotRequiredToFigureOutAllInequalities = nothing
Private Function doArraysAreEqual(V1 As Variant, V2 As Variant, ignoreBoundMismatches As Boolean, ByRef mod_collectionToAddUnequalIndexesToIfWhereFirstIndexIsOne_orNothingIfWeAreNotRequiredToFigureOutAllInequalities As Collection, ByRef out_commonSize As Long) As Boolean

    Dim dims1 As Long
    Dim dims2 As Long
    dims1 = numDims(V1)
    dims2 = numDims(V2)
    
    Dim commonSize As Long
    If dims1 <> dims2 Then
        commonSize = VALUE_REPRESENTING_INCONSISTENT_SIZES
        doArraysAreEqual = False
    ElseIf dims1 <> 1 Then
        elwp "Array dimensions of " & dims1 & " are not yet supported by arraysAreEqual(...)!"
        commonSize = VALUE_REPRESENTING_INCONSISTENT_SIZES
        doArraysAreEqual = False
    Else
        Dim lwr1 As Long
        Dim upr1 As Long
        Dim lwr2 As Long
        Dim upr2 As Long
        glaubs V1, lwr1, upr1
        glaubs V2, lwr2, upr2
        
        Dim equalSoFar As Boolean
        equalSoFar = True
        
        Dim sizeOfArrayOne As Long
        Dim sizeOfArrayTwo As Long
        sizeOfArrayOne = upr1 - lwr1 + 1
        sizeOfArrayTwo = upr2 - lwr2 + 1
        
        If ignoreBoundMismatches Then
            If sizeOfArrayOne <> sizeOfArrayTwo Then
                equalSoFar = False
            End If
        Else
            If lwr1 <> lwr2 Or upr1 <> upr2 Then
                equalSoFar = False
            End If
        End If
        
        If sizeOfArrayOne = sizeOfArrayTwo Then
            commonSize = sizeOfArrayOne
        Else
            commonSize = VALUE_REPRESENTING_INCONSISTENT_SIZES
        End If
        
        If equalSoFar Then
            Dim c As Long
            c = lwr1
            
            While (c <= upr1) And (equalSoFar Or Not isNothing(mod_collectionToAddUnequalIndexesToIfWhereFirstIndexIsOne_orNothingIfWeAreNotRequiredToFigureOutAllInequalities))
                Dim sv1 As Variant
                Dim sv2 As Variant
                atr sv1, V1(c)
                atr sv2, V2(c - lwr1 + lwr2)
                
                If valuesAreEqual(sv1, sv2) Then
                    'DO NOTHING
                Else
                    If isNothing(mod_collectionToAddUnequalIndexesToIfWhereFirstIndexIsOne_orNothingIfWeAreNotRequiredToFigureOutAllInequalities) Then
                        'DO NOTHING
                    Else
                        mod_collectionToAddUnequalIndexesToIfWhereFirstIndexIsOne_orNothingIfWeAreNotRequiredToFigureOutAllInequalities.add c - lwr1 + 1
                    End If
                    equalSoFar = False
                End If
                c = c + 1
            Wend
            
        End If
        doArraysAreEqual = equalSoFar
    End If
    
    out_commonSize = commonSize

End Function




'JY20140303a - start - This is a duplicate function.  The other version is in the JUT_Ranges module.
''JY20120519a - start - not sure if this stuff was supposed to be moved somewhere else... keep an eye out for duplicate versions of these methods and delete the ones here if you find them
'Function getRngeEncompassingDataInTable(tableHeaderRnge As Range) As Range
'
'    Dim firstRow As Long
'    Dim lastRow As Long
'    getRowRngeWhereDataExistsInColumnHeaders tableHeaderRnge, firstRow, lastRow
'
'    If lastRow < firstRow Then
'        lastRow = firstRow
'    End If
'
'
'    Set getRngeEncompassingDataInTable = rngeToRnge(gcicsr(tlcor(tableHeaderRnge), firstRow), gcicsr(brcor(tableHeaderRnge), lastRow))
'
'End Function
'JY20140303a - end


'JY20120625a - start - moved to a different module
'Sub getRowOrColRngeWhereDataExistsInAnchors(anchors As Collection, ByRef out_firstRowOrCol As Long, ByRef out_lastRowOrCol As Long, findMinAndMaxRowsVsCols As Boolean)
'
'    Dim lastPossibleRowOrCol As Long
'    If findMinAndMaxRowsVsCols Then
'        lastPossibleRowOrCol = LAST_POSSIBLE_ROW
'    Else
'        lastPossibleRowOrCol = LAST_POSSIBLE_COL
'    End If
'
'    getRowOrColRngeWhereDataExistsInAnchors_specifyLastPossibleRowAssumption anchors, out_firstRowOrCol, out_lastRowOrCol, lastPossibleRowOrCol, findMinAndMaxRowsVsCols
'End Sub
'JY20120625a - end - moved to a different module

'JY20120519a - end
Function castToStringIfError(theVal As Variant) As Variant
    If IsError(theVal) Then
        castToStringIfError = CStr(theVal)
    Else
        atr castToStringIfError, theVal
    End If
End Function

Sub clearDtaUnderneathHeaders(headerRange As Range)
    
    Dim firstDataRow As Long
    Dim lastDataRow As Long
    getRowRngeWhereDataExistsInColumnHeaders headerRange, firstDataRow, lastDataRow
    
    If lastDataRow < firstDataRow Then
        'DO NOTHIGN
        
        'There is no data to clear
    Else
    
        Dim firstCellInHeader As Range
        Set firstCellInHeader = tlcor(headerRange)
        
        Dim lastColInHeader As Long
        Dim firstColInHeader As Long
        firstColInHeader = firstCellInHeader.column
        lastColInHeader = brcor(headerRange).column
        
        
        Dim dataRange As Range
        Set dataRange = resizeRnge(firstCellInHeader.offset(1, 0), lastDataRow - firstDataRow + 1, lastColInHeader - firstColInHeader + 1)
        
        dataRange.ClearContents
    End If
End Sub

Function getSourceData(headers As Range, includeHeaders As Boolean) As Range
    Set getSourceData = getSourceData_specifyLastPossibleRowAssumption(headers, LAST_POSSIBLE_ROW, includeHeaders)
End Function

Function getSourceData_specifyLastPossibleRowAssumption(headers As Range, lastPossibleRow As Long, includeHeaders As Boolean) As Range
    
    If headers.rows.count <> 1 Then
        elwp "Expected 1 row in the header!"
        Set getSourceData_specifyLastPossibleRowAssumption = Nothing
    Else
    
        Dim firstRow As Long
        Dim lastRow As Long
        getRowRngeWhereDataExistsInAnchors_specifyLastPossibleRowAssumption getCellsInRnge(headers), firstRow, lastRow, lastPossibleRow
        
        If firstRow <> headers.row + 1 Then
            Set getSourceData_specifyLastPossibleRowAssumption = Nothing
        Else
        
            Dim bottomRight As Range
            Set bottomRight = gcicsr(brcor(headers), Application.Max(firstRow, lastRow))
            
            Dim topLeft As Range
            If includeHeaders Then
                Set topLeft = headers
            Else
                Set topLeft = headers.offset(1, 0)
            End If
            Set getSourceData_specifyLastPossibleRowAssumption = rngeToRnge(topLeft, bottomRight)
        End If
    End If
End Function

'theDataOption = xlSortNormal
Sub sortData(dataIncludingHeaders As Range, anyCellInColumnToSort_orArrayIfMultipleSortLevelsDesired As Variant, ascVsDesc_orArrayIfMultipleSortLevelsDesired As Variant, matchCase As Boolean, theDataOption_orArrayIfMultipleSortLevelsDesired As Variant)
    doSortData dataIncludingHeaders, True, anyCellInColumnToSort_orArrayIfMultipleSortLevelsDesired, ascVsDesc_orArrayIfMultipleSortLevelsDesired, matchCase, theDataOption_orArrayIfMultipleSortLevelsDesired
End Sub

Sub doSortData(dataToSort As Range, dataIncludesHeader As Boolean, anyCellInColumnToSort_orArrayIfMultipleSortLevelsDesired As Variant, ascVsDesc_orArrayIfMultipleSortLevelsDesired As Variant, matchCase As Boolean, theDataOption_orArrayIfMultipleSortLevelsDesired As Variant)
    
    Dim ws As Worksheet
    Set ws = dataToSort.Worksheet
    
    Dim sortFields As sortFields
    Set sortFields = ws.Sort.sortFields
    
    Dim firstRow As Long
    Dim lastRow As Long
    firstRow = dataToSort.row + 1
    lastRow = brcor(dataToSort).row
    
    If lastRow < firstRow Then
        elwp_se
    Else
    
        
        sortFields.Clear
        
        Dim arr As Variant
        If isRnge(anyCellInColumnToSort_orArrayIfMultipleSortLevelsDesired) Then
            arr = Array(anyCellInColumnToSort_orArrayIfMultipleSortLevelsDesired)
        Else
            arr = anyCellInColumnToSort_orArrayIfMultipleSortLevelsDesired
        End If
        
        Dim ascVsDescArr As Variant
        If Not IsArray(ascVsDesc_orArrayIfMultipleSortLevelsDesired) Then
            ascVsDescArr = Array(CBool(ascVsDesc_orArrayIfMultipleSortLevelsDesired))
        Else
            ascVsDescArr = ascVsDesc_orArrayIfMultipleSortLevelsDesired
        End If
        
        Dim dataOptionArr As Variant
        If Not IsArray(theDataOption_orArrayIfMultipleSortLevelsDesired) Then
            dataOptionArr = Array(theDataOption_orArrayIfMultipleSortLevelsDesired)
        Else
            dataOptionArr = theDataOption_orArrayIfMultipleSortLevelsDesired
        End If
        
        Dim arrSize As Long
        arrSize = casz(Array(arr, ascVsDescArr, dataOptionArr), True)
        
        Dim cnt As Long
        For cnt = 1 To arrSize
        
            Dim anyCellInColumn As Range
            Set anyCellInColumn = rlai(arr, cnt)
            
            Dim ascVsDesc As Boolean
            ascVsDesc = rlai(ascVsDescArr, cnt)
            
            Dim theDataOption As Variant
            theDataOption = rlai(dataOptionArr, cnt)
            
            Dim theOrder As Variant
            If ascVsDesc Then
                theOrder = xlAscending
            Else
                theOrder = xlDescending
            End If
            
            Dim keyColumns As Range
            Set keyColumns = getColumnCellsFromRowToRow(anyCellInColumn, firstRow, lastRow)
            
            sortFields.add key:=keyColumns, SortOn:=xlSortOnValues, Order:=theOrder, DataOption:=theDataOption
        
        Next
    
        With ws.Sort
            .SetRange dataToSort
            .header = IIf(dataIncludesHeader, xlYes, xlNo)
            .matchCase = matchCase
            .Orientation = xlTopToBottom
            .SortMethod = xlPinYin
            .Apply
        End With
        
    End If
End Sub

Function blankValueToNothing(theVal As Variant) As Variant
    If isBlankValue(theVal) Then
        Set blankValueToNothing = Nothing
    Else
        atr blankValueToNothing, theVal
    End If
End Function

Function isBlankValueOrZero(theVal As Variant) As Boolean
    
    Dim isBlnkOZero As Boolean
    If isBlankValue(theVal) Then
        isBlnkOZero = True
    ElseIf IsObject(theVal) Then
        isBlnkOZero = False
    ElseIf Not isNumber(theVal) Then
        isBlnkOZero = False
    Else
        Dim theNum As Double
        theNum = CDbl(theVal)
        
        isBlnkOZero = (theNum = 0)
    End If
        
    isBlankValueOrZero = isBlnkOZero
End Function

Function isBlankValue(theVal As Variant) As Boolean
    
    If IsObject(theVal) Then
        isBlankValue = isNothing(theVal)
    ElseIf IsArray(theVal) Then
        isBlankValue = False
    ElseIf IsEmpty(theVal) Then
        isBlankValue = True
    ElseIf IsNull(theVal) Then
        isBlankValue = True
    ElseIf Trim(CStr(theVal)) = "" Then
        isBlankValue = True
    ElseIf IsMissing(theVal) Then
        isBlankValue = True
    Else
        isBlankValue = False
    End If
    
End Function

Function nonNumericToZero(theVal As Variant) As Variant
    atr nonNumericToZero, blankToDefaultValue(theVal, 0)
End Function

Function nonNumericToDefaultValue(theVal As Variant, defaultValue As Variant) As Variant
    If Not isNumber(theVal) Then
        atr nonNumericToDefaultValue, defaultValue
    Else
        atr nonNumericToDefaultValue, theVal
    End If
End Function

Function blankToDefaultValue(theVal As Variant, defaultValue As Variant) As Variant
    If isBlankValue(theVal) Then
        atr blankToDefaultValue, defaultValue
    Else
        atr blankToDefaultValue, theVal
    End If
End Function

Function blankToZero(theVal As Variant) As Variant
    
    If isBlankValue(theVal) Then
        blankToZero = 0
    Else
        blankToZero = theVal
    End If
        
End Function

Function createChainableDataCBObj(thecbobj As Variant) As JYUT_ChainableDataCBObj

    Dim cbObj As JYUT_ChainableDataCBObj
    Set cbObj = New JYUT_ChainableDataCBObj
    Set cbObj.cbObj = thecbobj
    
    Set createChainableDataCBObj = cbObj
End Function

Function createSuccessFailureMsgCBObj(successMsg As String) As JYUT_SuccessFailureMsgCBObj

    Dim cbObj As JYUT_SuccessFailureMsgCBObj
    Set cbObj = New JYUT_SuccessFailureMsgCBObj
    With cbObj
        .successMsg = successMsg
    End With
    
    Set createSuccessFailureMsgCBObj = cbObj

End Function

Sub showAppropriateFinishMessageAndLogActivity(startAndEndTime_orNothingToNotShowTimeCompleted As Variant, msg As String, ByRef mod_emsgs As Variant, ssName As String, emailAddressOrNothingToNotSendEmail As Variant, environment As String, shortActionName As String, actionTaken As String, worksheetOrWorkbookOrAnyRNInTheWorkbookOrNothingIfNotKnown As Variant)

    Dim worksheetOrWorkbookOrNothingIfNotKnown As Variant
    If isWorksheet(worksheetOrWorkbookOrAnyRNInTheWorkbookOrNothingIfNotKnown) Then
        'We already have a reference to the worksheet, so use it.
        Set worksheetOrWorkbookOrNothingIfNotKnown = worksheetOrWorkbookOrAnyRNInTheWorkbookOrNothingIfNotKnown
    Else
        
        'The worksheet was not explicitly specified.
        'So we'll try to get the workbook instead.
        'Can we get the workbook instead?
        If isWorkbook(worksheetOrWorkbookOrAnyRNInTheWorkbookOrNothingIfNotKnown) Then
            'The workbook was explicitly specified.
            Set worksheetOrWorkbookOrNothingIfNotKnown = worksheetOrWorkbookOrAnyRNInTheWorkbookOrNothingIfNotKnown
        ElseIf isString(worksheetOrWorkbookOrAnyRNInTheWorkbookOrNothingIfNotKnown) Then
            'We might be able to use the range name to figure out the workbook.
                
            Dim anyRNInWorkbook As String
            anyRNInWorkbook = worksheetOrWorkbookOrAnyRNInTheWorkbookOrNothingIfNotKnown
                
            Dim foundRnge As Range
            Set foundRnge = rnge(anyRNInWorkbook, Nothing)
            
            If isNothing(foundRnge) Then
                'The range name is invalid, so we can't figure out the workbook.
                mod_emsgs.add "Unknown range name '" & anyRNInWorkbook & "' encountered while logging an activity."
                Set worksheetOrWorkbookOrNothingIfNotKnown = Nothing
            Else
            
                'The range name is valid...
                Dim ws As Worksheet
                Set ws = foundRnge.Worksheet
                
                If isNothing(ws) Then
                    '... however, we can't get a reference to the workbook.
                    mod_emsgs.add "Could not obtain a reference to the worksheet for range name '" & anyRNInWorkbook & "' for some reason."
                    Set worksheetOrWorkbookOrNothingIfNotKnown = Nothing
                Else
                    '... and therefore, we can get a reference to the workbook.
                    Dim wb As Workbook
                    Set wb = ws.Parent
            
                    Set worksheetOrWorkbookOrNothingIfNotKnown = wb
                End If
            End If
        Else
            'We don't know the worksheet, and we don't have any reliable way to figure out the workbook.
            Set worksheetOrWorkbookOrNothingIfNotKnown = Nothing
        End If
    End If

    Dim optWSForPage As Worksheet
    Dim wb_orNothingIfNotKnown As Workbook
    If isNothing(worksheetOrWorkbookOrNothingIfNotKnown) Then
        Set optWSForPage = Nothing
        Set wb_orNothingIfNotKnown = Nothing
    ElseIf isWorkbook(worksheetOrWorkbookOrNothingIfNotKnown) Then
        Set optWSForPage = Nothing
        Set wb_orNothingIfNotKnown = worksheetOrWorkbookOrNothingIfNotKnown
    ElseIf isWorksheet(worksheetOrWorkbookOrNothingIfNotKnown) Then
        Set optWSForPage = worksheetOrWorkbookOrNothingIfNotKnown
        Set wb_orNothingIfNotKnown = worksheetOrWorkbookOrNothingIfNotKnown.Parent
    Else
        mod_emsgs.add "Unknown data type passed in!"
        Set optWSForPage = Nothing
        Set wb_orNothingIfNotKnown = Nothing
    End If
    
    Dim listOfSuccessOrErrorMessagesShown As Collection
    Set listOfSuccessOrErrorMessagesShown = showAppropriateFinishMessage(startAndEndTime_orNothingToNotShowTimeCompleted, msg, mod_emsgs)
    
    logActivity ssName, emailAddressOrNothingToNotSendEmail, wb_orNothingIfNotKnown, environment, shortActionName, actionTaken, listOfSuccessOrErrorMessagesShown, optWSForPage, Nothing

End Sub


Function showAppropriateFinishMessage(startAndEndTime_orNothingToNotShowTimeCompleted As Variant, msg As String, emsgs As Variant) As Collection
    Dim listOfSuccessOrErrorMessagesShown As Collection
    doShowCompletedMessage msg, emsgs, startAndEndTime_orNothingToNotShowTimeCompleted, listOfSuccessOrErrorMessagesShown
    
    Set showAppropriateFinishMessage = listOfSuccessOrErrorMessagesShown
End Function

Function convertEmsgsToSomethingThatCanBeCountedAndAlsoRepresentedAsAString(theEmsgs As Variant) 'represented as a string via the "representAsString" method
    
    Dim emsgs As Variant
    If isNothing(theEmsgs) Then
        Set emsgs = New Collection
    ElseIf (Not IsObject(theEmsgs)) Then
        Set emsgs = New Collection
        If theEmsgs = "" Then
            'DO NOTHING
        Else
            emsgs.add theEmsgs
        End If
    Else
        Set emsgs = theEmsgs
    End If
    
    atr convertEmsgsToSomethingThatCanBeCountedAndAlsoRepresentedAsAString, emsgs
    
End Function

Sub showCompletedMessage(msg As String, theEmsgs As Variant, startAndEndTime_orNothingToNotShowTimeCompleted As Variant)
    Dim listOfSuccessOrErrorMessagesShown As Collection
    doShowCompletedMessage msg, theEmsgs, startAndEndTime_orNothingToNotShowTimeCompleted, listOfSuccessOrErrorMessagesShown
End Sub

Sub doShowCompletedMessage(msg As String, theEmsgs As Variant, startAndEndTime_orNothingToNotShowTimeCompleted As Variant, ByRef out_listOfSuccessOrErrorMessagesShown As Collection)
    
    Dim emsgs As Variant
    atr emsgs, convertEmsgsToSomethingThatCanBeCountedAndAlsoRepresentedAsAString(theEmsgs)

    Dim listOf__successVsError_msg As Collection
    Set listOf__successVsError_msg = New Collection
    If emsgs.count = 0 Then
        If isNothing(startAndEndTime_orNothingToNotShowTimeCompleted) Then
            listOf__successVsError_msg.add Array(True, msg)
        Else
            Dim startTime As Variant
            Dim endTime As Variant
            startTime = rlai(startAndEndTime_orNothingToNotShowTimeCompleted, 1)
            endTime = rlai(startAndEndTime_orNothingToNotShowTimeCompleted, 2)
            
            listOf__successVsError_msg.add Array(True, getTimeCompletedMessage(startTime, endTime, msg))
        End If
    ElseIf isSet(emsgs) Then
        listOf__successVsError_msg.add Array(False, castToSet(emsgs).toString(CHAR_CRLF, ""))
    ElseIf isCollection(emsgs) Then
        listOf__successVsError_msg.add Array(False, cltstr(castToCollection(emsgs), CHAR_CRLF, ""))
    Else
        listOf__successVsError_msg.add Array(False, representAsString_customDelimiter(emsgs, CHAR_CRLF))
    End If
    
    Dim listOfSuccessOrErrorMessagesShown As Collection
    Set listOfSuccessOrErrorMessagesShown = New Collection
    Dim x As Long
    For x = 1 To listOf__successVsError_msg.count
        Dim successVsError_msg As Variant
        successVsError_msg = listOf__successVsError_msg.item(x)
        
        Dim successVsError As Boolean
        Dim daMsg As String
        successVsError = rlai(successVsError_msg, 1)
        daMsg = rlai(successVsError_msg, 2)
        
        listOfSuccessOrErrorMessagesShown.add daMsg
        
        If successVsError Then
            ilwp daMsg
        Else
            elwp daMsg
        End If
    Next
    
    Set out_listOfSuccessOrErrorMessagesShown = listOfSuccessOrErrorMessagesShown
End Sub

Sub unhideAllColumns(ws As Worksheet)
On Error GoTo ehs
    ws.cells.EntireColumn.Hidden = False
GoTo ehe
ehs:
    elwp "Unable to unhide all columns.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Sub unhideColumn(col As Range)
On Error GoTo ehs
    col.EntireColumn.Hidden = False
GoTo ehe
ehs:
    elwp "Unable to unhide a column.  Msg=" & Err.description
ehe:
On Error GoTo 0
    
End Sub


Sub hideColumn(col As Range)
On Error GoTo ehs
    col.EntireColumn.Hidden = True
GoTo ehe
ehs:
    elwp "Unable to hide a column.  Msg=" & Err.description
ehe:
On Error GoTo 0
    
End Sub

Sub unhideAllSheets()
    
    Dim ws As Worksheet
    For Each ws In ActiveWorkbook.worksheets
        unhideWS ws
    Next
    
    ilwp "All sheets are now unhidden!"
End Sub

Sub hideWS(ws As Worksheet)

On Error GoTo ehs
    
    ws.Visible = xlSheetHidden
    
GoTo ehe
ehs:
    elwp "Could not hide worksheet.  Reason: " & Err.description
ehe:
On Error GoTo 0

End Sub

Sub unhideWS(ws As Worksheet)
On Error GoTo ehs
    
    ws.Visible = xlSheetVisible
    
GoTo ehe
ehs:
    elwp "Could not unhide worksheet.  Reason: " & Err.description
ehe:
On Error GoTo 0
End Sub

Function copyWSBeforeOrAfterSheet(ws As Worksheet, referenceWS As Worksheet, copyBeforeVsCopyAfter As Boolean) As Variant
    
    Dim emsg As String
    Dim newWS As Worksheet
    If isNothing(ws) Then
        emsg = "Please pass in a sheet to export!"
        Set newWS = Nothing
    Else
    
        If copyBeforeVsCopyAfter Then
            ws.Copy before:=referenceWS
        Else
            ws.Copy after:=referenceWS
        End If
    
        Set newWS = ActiveSheet
    End If
    
    If emsg = "" Then
        atr copyWSBeforeOrAfterSheet, newWS
    Else
        atr copyWSBeforeOrAfterSheet, emsg
    End If
    
End Function

Function copyWSIntoNewWB(ws As Worksheet) As Variant
    Dim emsg As String
    Dim newWS As Worksheet
    If isNothing(ws) Then
        emsg = "Please pass in a sheet to export!"
        Set newWS = Nothing
    Else
        ws.Copy
        Set newWS = ActiveSheet
        emsg = ""
    End If
    
    If emsg = "" Then
        atr copyWSIntoNewWB, newWS
    Else
        atr copyWSIntoNewWB, emsg
    End If
End Function

Function exportWorksheetsToNewExcelWorkbook(listOfWorksheets As Collection, ByRef mod_emsgs As Variant, deleteAllOLEObjectsInExport As Boolean) As Workbook

    Dim origCalc As Variant
    origCalc = Application.Calculation
    
    Application.Calculation = xlCalculationManual
    
    Dim wsAfterWhichToInsertNewPage_orNothingToInsertIntoNewWB As Worksheet
    Set wsAfterWhichToInsertNewPage_orNothingToInsertIntoNewWB = Nothing

    Dim firstWS As Worksheet
    Set firstWS = Nothing
        
    If listOfWorksheets.count = 0 Then
        mod_emsgs.add "Please pass in at least one worksheet!"
    Else

        Dim emsgs As JYCORE_Set
        Set emsgs = New JYCORE_Set
        
        Dim c As Long
        For c = 1 To listOfWorksheets.count
            Dim ws As Worksheet
            Set ws = listOfWorksheets.item(c)
            
            Dim emsg As String
            Set wsAfterWhichToInsertNewPage_orNothingToInsertIntoNewWB = doExportSheetAsExcel(ws, emsg, wsAfterWhichToInsertNewPage_orNothingToInsertIntoNewWB, True, True, deleteAllOLEObjectsInExport)
            
            If isNothing(firstWS) Then
                Set firstWS = wsAfterWhichToInsertNewPage_orNothingToInsertIntoNewWB
            End If
            
            If emsg <> "" Then
                mod_emsgs.add emsg
            End If
            
        Next
        
        
    End If
    
    If Not isNothing(firstWS) Then
        firstWS.Activate
    End If
    
    
    If origCalc <> Application.Calculation Then
        Application.Calculation = origCalc
    End If
    
    Set exportWorksheetsToNewExcelWorkbook = firstWS.Parent
End Function


Function exportSheetAsExcel(ws As Worksheet, convertToValuesOnly As Boolean, copyVsMove As Boolean, deleteAllOLEObjectsInExport As Boolean, deleteNamesInExportedWB As Boolean) As Worksheet
    
    Dim emsg As String
    Dim exported As Worksheet
    Set exported = doExportSheetAsExcel(ws, emsg, Nothing, convertToValuesOnly, copyVsMove, deleteAllOLEObjectsInExport)
    
    'JY20130313a - start
    If deleteNamesInExportedWB Then
        If Not isNothing(exported) Then
            If ws.Parent Is exported.Parent Then
                elwp "We unexpectedly did not export into a new workbook, so we will NOT delete the names in the workbook as requested."
            Else
                deleteNamesInWB exported.Parent
            End If
        End If
    End If
    'JY20130313a - end
    
    scm "Exported!", emsg, Nothing
    
    Set exportSheetAsExcel = exported
    
End Function
'convertToValuesOnly = true
'copyVsMove = true
Function doExportSheetAsExcel(ws As Worksheet, ByRef out_emsg As String, afterWS_orNothingToCopyIntoNewWB As Worksheet, convertToValuesOnly As Boolean, copyVsMove As Boolean, deleteAllOLEObjectsInExport As Boolean) As Worksheet
    
    Dim wsOrEMsg As Variant
    If copyVsMove Then
        If isNothing(afterWS_orNothingToCopyIntoNewWB) Then
            atr wsOrEMsg, copyWSIntoNewWB(ws)
        Else
            atr wsOrEMsg, copyWSBeforeOrAfterSheet(ws, afterWS_orNothingToCopyIntoNewWB, False)
        End If
    Else
        If isNothing(afterWS_orNothingToCopyIntoNewWB) Then
            ws.Move
        Else
            ws.Move after:=afterWS_orNothingToCopyIntoNewWB
        End If
        Set wsOrEMsg = ActiveSheet
    End If
    
    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    Dim newWS As Worksheet
    If Not IsObject(wsOrEMsg) Then
        emsgs.add CStr(wsOrEMsg)
        Set newWS = Nothing
    Else
        Set newWS = wsOrEMsg
        
        If convertToValuesOnly Then
            convertWorksheetToValuesOnly newWS
        End If
    
        srg rnge("A1", newWS)
    End If
    
    If deleteAllOLEObjectsInExport Then
    
        Dim obj As OLEObject
        For Each obj In newWS.OLEObjects
            deleteOLEObject obj, emsgs
        Next
    
    End If

    
    out_emsg = emsgs.toString(" ... ", "")
    Set doExportSheetAsExcel = newWS

End Function

Sub deleteOLEObject(obj As OLEObject, ByRef mod_emsgs As Variant)
On Error GoTo ehs
    obj.Delete
GoTo ehe
ehs:
    mod_emsgs.add "Could not delete OLE Object.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

'optPathToRecognize = ""
Sub exportWorkbookAsPDF(wb As Workbook, destFilePath As String, ByRef out_wasExported As Boolean, optPathToRecognize As String)
    exportWBOrWSOrRngeAsPDF wb, destFilePath, out_wasExported, optPathToRecognize
End Sub

'optPathToRecognize = ""
Sub exportSheetAsPDF(ws As Worksheet, destFilePath As String, ByRef out_wasExported As Boolean, optPathToRecognize As String)
    exportWBOrWSOrRngeAsPDF ws, destFilePath, out_wasExported, optPathToRecognize
End Sub

Sub exportWBOrWSOrRngeAsPDF(wbOrWSOrRnge As Variant, destFilePath As String, ByRef out_wasExported As Boolean, optPathToRecognize As String)
    
    Dim wbOrWS As Variant
    Dim shouldCloseWBOrWS As Boolean
    If isRnge(wbOrWSOrRnge) Then
    
        shouldCloseWBOrWS = True
        Set wbOrWS = createNewWB(1)
        
        Dim newWS As Worksheet
        Set newWS = castToWorkbook(wbOrWS).worksheets(1)
        
        With newWS.PageSetup
            .printArea = "$E$1:$AA$4"
            .FitToPagesWide = 1
            .FitToPagesTall = 1
        End With
    

        Dim srcRnge As Range
        Set srcRnge = wbOrWSOrRnge
        
        Dim destRnge As Range
        Set destRnge = rnge("A1", newWS)
        
        srg srcRnge
        srcRnge.Copy
        
        srg destRnge
        
        pasteValuesAndFormatsAndColWidths destRnge
        
        
        
    Else
        shouldCloseWBOrWS = False
        Set wbOrWS = wbOrWSOrRnge
        
    End If
    
    exportWBOrWSAsPDF wbOrWS, destFilePath, out_wasExported, optPathToRecognize
    
    If shouldCloseWBOrWS Then
        If Not isWorkbook(wbOrWS) Then
            elwp "Not a workbook!  This should not have happened."
        Else
            closeWB castToWorkbook(wbOrWS), False
        End If
    End If
End Sub

Sub pasteValuesAndFormatsAndColWidths(destRnge As Range)

        destRnge.PasteSpecial xlPasteColumnWidths
        pasteValuesAndFormats destRnge

End Sub

Sub pasteFormulas(destRnge As Range)
    destRnge.PasteSpecial xlPasteFormulas
    clearClipboardSelection
End Sub

Sub pasteValues(destRnge As Range)
    destRnge.PasteSpecial xlPasteValues
    clearClipboardSelection
End Sub

Sub pasteFormulasAndFormats(destRnge As Range)
    destRnge.PasteSpecial xlPasteFormulas
    pasteFormats destRnge
    clearClipboardSelection

End Sub

Sub pasteValuesAndFormats(destRnge As Range)
    destRnge.PasteSpecial xlPasteValues
    
    pasteFormats destRnge
    
    clearClipboardSelection
End Sub

Sub pasteFormats(destRnge As Range)
    destRnge.PasteSpecial xlPasteFormats
End Sub

Sub clearClipboardSelection()
    Application.CutCopyMode = False
End Sub

'optPathToRecognize = ""
Sub exportWBOrWSAsPDF(wbOrWS As Variant, destFilePath As String, ByRef out_wasExported As Boolean, optPathToRecognize As String)
    
    Dim wasExported As Boolean
    wasExported = False
    
    Dim sdCnt As Boolean
    sdCnt = ifFileExistsThenCheckWithUserToConfirmOverwrite(destFilePath)
    
    If sdCnt Then
        Dim folderPath As String
        folderPath = getFolderPathFromFilePath(destFilePath)
        
        ensureFolderPathExists_recognizeSpecificPathAndTreatAsFirstPathElement folderPath, optPathToRecognize
        
        'ChDir folderPath
    
        wbOrWS.ExportAsFixedFormat Type:=xlTypePDF, fileName:= _
            destFilePath, _
            Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas _
            :=False, OpenAfterPublish:=True
        
        wasExported = True
    
    End If
    
    out_wasExported = wasExported
    
    
End Sub



Sub runMacro(wb As Workbook, macroName As String)
    applicationRun wb.name & "!" & macroName
End Sub

Function appRunAndLogEmsgIfErrorOccurs(ByRef out_emsg As String, Optional macro As String, Optional arg1 As Variant, Optional arg2 As Variant, Optional arg3 As Variant, Optional arg4 As Variant, Optional arg5 As Variant, Optional arg6 As Variant, Optional arg7 As Variant, Optional arg8 As Variant, Optional arg9 As Variant, Optional arg10 As Variant, Optional arg11 As Variant, Optional arg12 As Variant, Optional arg13 As Variant, Optional arg14 As Variant, Optional arg15 As Variant, Optional arg16 As Variant, Optional arg17 As Variant, Optional arg18 As Variant, Optional arg19 As Variant, Optional arg20 As Variant, Optional arg21 As Variant, Optional arg22 As Variant, Optional arg23 As Variant, Optional arg24 As Variant, Optional arg25 As Variant, Optional arg26 As Variant, Optional arg27 As Variant, Optional arg28 As Variant, Optional arg29 As Variant, Optional arg30 As Variant) As Variant

    Dim returnValue As Variant
    Set returnValue = Nothing

    Dim emsg As String
    emsg = "ERROR: NOT SET!!!"
    
On Error GoTo ehs

    atr returnValue, applicationRun(macro, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30)
    emsg = ""

GoTo ehe
ehs:

    emsg = Err.description

ehe:
On Error GoTo 0

    out_emsg = emsg
    atr appRunAndLogEmsgIfErrorOccurs, returnValue

End Function

Function applicationRun(Optional macro As String, Optional arg1 As Variant, Optional arg2 As Variant, Optional arg3 As Variant, Optional arg4 As Variant, Optional arg5 As Variant, Optional arg6 As Variant, Optional arg7 As Variant, Optional arg8 As Variant, Optional arg9 As Variant, Optional arg10 As Variant, Optional arg11 As Variant, Optional arg12 As Variant, Optional arg13 As Variant, Optional arg14 As Variant, Optional arg15 As Variant, Optional arg16 As Variant, Optional arg17 As Variant, Optional arg18 As Variant, Optional arg19 As Variant, Optional arg20 As Variant, Optional arg21 As Variant, Optional arg22 As Variant, Optional arg23 As Variant, Optional arg24 As Variant, Optional arg25 As Variant, Optional arg26 As Variant, Optional arg27 As Variant, Optional arg28 As Variant, Optional arg29 As Variant, Optional arg30 As Variant) As Variant
 
    Dim result As Variant
    atr result, Application.Run(macro, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30)
    
    Dim shouldLog As Boolean
    shouldLog = True
    
    If shouldLog Then
        
        Dim args As Collection
        Set args = arrayToCollection(Array(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30))
        
        Dim cnt As Long
        cnt = args.count
        
        Dim shouldRunLoop As Boolean
        If cnt <= 0 Then
            shouldRunLoop = False
        Else
            shouldRunLoop = isBlankValue(args.item(cnt))
        End If
        While shouldRunLoop
            args.remove cnt
            cnt = cnt - 1
            
            If cnt <= 0 Then
                shouldRunLoop = False
            Else
                shouldRunLoop = isBlankValue(args.item(cnt))
            End If
            
        Wend
        
        ilg "---------------------------------------"
        ilg "Command: " & macro & "(" & cltstr(representAllInCollectionAsStrings(args, ",", ",", "\", False), ", ", "") & ")"
        ilg "result: " & representAsString(result)
        ilg "---------------------------------------"
        
    End If
    
    atr applicationRun, result
End Function

Function getCellByPivotTableAssumedName(headers As Range) As Dictionary
    
    Dim cellByName As Dictionary
    Set cellByName = New Dictionary
    
    Dim theCells As Collection
    Set theCells = getCellsInRnge(headers)
    
    Dim c As Long
    For c = 1 To theCells.count
        Dim thisCell As Range
        Set thisCell = theCells.item(c)
    
        Dim curName As String
        curName = gvl(thisCell)
        
        Dim suffix As Variant
        suffix = ""
        
        While cellByName.exists(curName & suffix)
            If suffix = "" Then
                suffix = 2
            Else
                suffix = suffix + 1
            End If
        Wend
        
        Dim newName As String
        newName = curName & suffix
        
        atd cellByName, newName, thisCell
    Next
    
    Set getCellByPivotTableAssumedName = cellByName
    
End Function

Function generateOneByOnePivotTableLikeReport(topLeftOfDestRnge As Range, sourceData As Range, rowCategoryFieldName As String, colCategoryFieldName As String, fieldsToSum As Collection, ByRef out_emsgs As JYCORE_Set) As Range

    Dim writtenRnge As Range
    Set writtenRnge = Nothing
    
    Dim headers As Range
    Set headers = resizeRnge(sourceData, 1, sourceData.Columns.count)
    
    Dim firstDataRow As Long
    Dim lastDataRow As Long
    firstDataRow = headers.row + 1
    lastDataRow = brcor(sourceData).row
    
    Dim cellByPresumedName As Dictionary
    Set cellByPresumedName = getCellByPivotTableAssumedName(headers)
    
    Dim rowCategoryAnchor As Range '
    Dim colCategoryAnchor As Range
    Set rowCategoryAnchor = vfd(cellByPresumedName, rowCategoryFieldName, False)
    Set colCategoryAnchor = vfd(cellByPresumedName, colCategoryFieldName, False)
    
    Dim dataFieldAnchors As Collection
    Set dataFieldAnchors = valuesFromDictionary(cellByPresumedName, fieldsToSum, False)
    
    Dim dataFieldNames As Collection
    Set dataFieldNames = fieldsToSum
    
    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    If isNothing(rowCategoryAnchor) Then
        emsgs.add "Could not find the field named '" & rowCategoryFieldName & "', in our source data!"
    ElseIf isNothing(colCategoryAnchor) Then
        emsgs.add "Could not find the field named '" & colCategoryFieldName & "', in our source data!"
    ElseIf dataFieldAnchors.count <> fieldsToSum.count Then
        emsgs.add "Could not find one or more of the specified data fields in our source data!"
    ElseIf dataFieldAnchors.count = 0 Then
        emsgs.add "Could not find any data fields to aggregate!"
    Else
    
        clearPivotTableSection topLeftOfDestRnge
        
        Dim colCategoriesShouldIncludeDataFieldName As Boolean
        colCategoriesShouldIncludeDataFieldName = (dataFieldAnchors.count <> 1)
        
        Dim delimiter As String
        Dim escapeChar As String
        delimiter = " - "
        escapeChar = "\"
        
        Dim distinctRowCategories As JYCORE_Set
        Dim distinctColCategories As JYCORE_Set
        Dim valueSoFarByColCategoryByRowCategory As Dictionary
        aggregateInformationForOurPivotTableLikeReport distinctRowCategories, distinctColCategories, valueSoFarByColCategoryByRowCategory, firstDataRow, lastDataRow, rowCategoryAnchor, colCategoryAnchor, dataFieldAnchors, dataFieldNames, emsgs, delimiter, escapeChar, colCategoriesShouldIncludeDataFieldName
    
        Dim table As JYUT_VectorBasedTable
        Set table = getTableObjectForPivotTableReport(distinctRowCategories, distinctColCategories, valueSoFarByColCategoryByRowCategory, True, delimiter, escapeChar, colCategoriesShouldIncludeDataFieldName)
        
        Dim tableArray As Variant
        tableArray = table.toArray()
        
        Set writtenRnge = writeArrayToRngeStartingAt(tableArray, topLeftOfDestRnge)
        
        sris writtenRnge
        
        sortData writtenRnge, tlcor(writtenRnge), True, False, xlSortNormal
        
        If emsgs.count <> 0 Then
            emsgs.add emsgs.toString(CHAR_CRLF, "")
        End If
        
    End If
    
    Set generateOneByOnePivotTableLikeReport = writtenRnge
    Set out_emsgs = emsgs
End Function

Function getTableObjectForPivotTableReport(distinctRowCategories As JYCORE_Set, distinctColCategories As JYCORE_Set, valueSoFarByColCategoryByRowCategory As Dictionary, includeTotalForRows As Boolean, delimiter As String, escChar As String, colCategoriesShouldIncludeDataFieldName As Boolean) As JYUT_VectorBasedTable
    
    Dim rowCategories As Collection
    Dim colCategories As Collection
    Set rowCategories = sortCollection(distinctRowCategories.toCollection())
    Set colCategories = sortCollection(distinctColCategories.toCollection())
    
    Dim table As JYUT_VectorBasedTable
    Set table = New JYUT_VectorBasedTable
    
    Dim headerRow As Collection
    Set headerRow = acltcl(addToCollection(createCollection(), ""), colCategories)
    
    Dim grandTotalColHeaders As Collection
    Set grandTotalColHeaders = New Collection
    
    Dim appropriateGrandTotalColHeaders As Collection
    Set appropriateGrandTotalColHeaders = New Collection
    
    If includeTotalForRows Then
            
        Dim encounteredGrandTotalCols As JYCORE_Set
        Set encounteredGrandTotalCols = New JYCORE_Set
        
        Dim xx As Long
        For xx = 1 To colCategories.count
            Dim curCat As String
            curCat = colCategories.item(xx)
            
            
            Dim grandTotalFieldName As String
            grandTotalFieldName = getGrandTotalHeaderNameForCategory(colCategoriesShouldIncludeDataFieldName, curCat, delimiter, escChar)
        
            appropriateGrandTotalColHeaders.add grandTotalFieldName
            
            If encounteredGrandTotalCols.exists(grandTotalFieldName) Then
                'DO NOTHING
            Else
                encounteredGrandTotalCols.add grandTotalFieldName
                grandTotalColHeaders.add grandTotalFieldName
            End If
        Next
    
    End If
    
    If includeTotalForRows Then
        acltcl headerRow, grandTotalColHeaders
    End If
    
    
    'Add the headers
    table.addRow headerRow
    
    Dim r As Long
    For r = 1 To rowCategories.count
    
        Dim rowCategory As String
        rowCategory = rowCategories.item(r)
        
        Dim thisRow As Collection
        Set thisRow = New Collection
        
        thisRow.add rowCategory
        
        Dim totalForRowByGrandTotalColHeader As Dictionary
        Set totalForRowByGrandTotalColHeader = New Dictionary
        
        Dim c As Long
        For c = 1 To colCategories.count
            Dim colCategory As String
            colCategory = colCategories.item(c)
            
            Dim nestedPath As Variant
            nestedPath = Array(rowCategory, colCategory)
            
            Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
            assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True '<-- because this is our intention
            
            Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
            shouldCastKeyToStringIfHelpsFindValue = False
            
            Dim theVal As Variant
            If nestedPathExists(valueSoFarByColCategoryByRowCategory, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree) Then
                theVal = getValueForNestedDictionaryPath(valueSoFarByColCategoryByRowCategory, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
                
                If includeTotalForRows Then
                
                    Dim thisGrandTotalColHeader As String
                    thisGrandTotalColHeader = appropriateGrandTotalColHeaders.item(c)
                    
                    Dim totalSoFarForThisGrandTotalHeader As Double
                    If totalForRowByGrandTotalColHeader.exists(thisGrandTotalColHeader) Then
                        totalSoFarForThisGrandTotalHeader = vfd(totalForRowByGrandTotalColHeader, thisGrandTotalColHeader, True)
                    Else
                        totalSoFarForThisGrandTotalHeader = 0
                    End If
                    totalSoFarForThisGrandTotalHeader = totalSoFarForThisGrandTotalHeader + theVal
                    
                    atd totalForRowByGrandTotalColHeader, thisGrandTotalColHeader, totalSoFarForThisGrandTotalHeader
                End If
            Else
                theVal = ""
            End If
            
            thisRow.add theVal
            
        Next
        
        If includeTotalForRows Then
        
            Dim abc As Long
            For abc = 1 To grandTotalColHeaders.count
                Dim curGrandTotalHeader As String
                curGrandTotalHeader = grandTotalColHeaders.item(abc)
                
                Dim curTotal As Double
                If totalForRowByGrandTotalColHeader.exists(curGrandTotalHeader) Then
                    curTotal = vfd(totalForRowByGrandTotalColHeader, curGrandTotalHeader, True)
                Else
                    curTotal = 0
                End If
                
                thisRow.add curTotal
            Next
        End If
        
        table.addRow thisRow
    
    Next
    
    Set getTableObjectForPivotTableReport = table
    
End Function

Sub aggregateInformationForOurPivotTableLikeReport(ByRef out_distinctRowCategories As JYCORE_Set, ByRef out_distinctColCategories As JYCORE_Set, ByRef out_valueSoFarByColCategoryByRowCategory As Dictionary, firstDataRow As Long, lastDataRow As Long, rowCategoryAnchor As Range, colCategoryAnchor As Range, dataFieldAnchors As Collection, dataFieldNames As Collection, ByRef mod_emsgs As Variant, delimiter As String, escChar As String, colCategoriesShouldIncludeDataFieldName As Boolean)
    
    Dim numDataFields As Long
    numDataFields = ccsz(Array(dataFieldNames, dataFieldAnchors), True)
    
    Dim distinctRowCategories As JYCORE_Set
    Dim distinctColCategories As JYCORE_Set
    Set distinctRowCategories = New JYCORE_Set
    Set distinctColCategories = New JYCORE_Set
    
    Dim valueSoFarByColCategoryByRowCategory As Dictionary
    Set valueSoFarByColCategoryByRowCategory = New Dictionary
    
    Dim r As Long
    For r = firstDataRow To lastDataRow
    
        ssbm "Processing row #" & r & " (last row is #" & lastDataRow & "')...        "
    
        Dim origRowCategory As String
        Dim origColCategory As String
        origRowCategory = CStr(gvl(gcicsr(rowCategoryAnchor, r)))
        origColCategory = CStr(gvl(gcicsr(colCategoryAnchor, r)))
        If Trim(origRowCategory) = "" Then
            origRowCategory = "(blank)"
        End If
        
        If Trim(origColCategory) = "" Then
            origColCategory = "(blank)"
        End If
        
        Dim x As Long
        For x = 1 To numDataFields
            Dim dataFieldAnchor As Range
            Set dataFieldAnchor = dataFieldAnchors.item(x)
            
            If isNothing(dataFieldAnchor) Then
                'DO NOTHING
            Else
            
                Dim dataColName As String
                dataColName = dataFieldNames.item(x)
                
                Dim valueToAggregate As Variant
                valueToAggregate = gvl(gcicsr(dataFieldAnchor, r))
                
                Dim colCategory As String
                Dim rowCategory As String
                colCategory = origColCategory
                rowCategory = origRowCategory
                
                If colCategoriesShouldIncludeDataFieldName Then
                    'We have multiple anchors, and so we must adjust
                    'our column category to reflect the type of data
                    'we are aggregating in the current column.
                    
                    colCategory = replaceInString(colCategory, delimiter, escChar & delimiter, False) & delimiter & replaceInString(dataColName, delimiter, escChar & delimiter, False)
                End If
                
                distinctRowCategories.add rowCategory
                distinctColCategories.add colCategory
                
                If isBlankValue(valueToAggregate) Then
                    'DO NOTHING
                ElseIf Not isNumber(valueToAggregate) Then
                    mod_emsgs.add "Encountered a non-numeric value in the '" & dataColName & "' column: " & valueToAggregate
                Else
                
                    Dim nestedPath As Variant
                    nestedPath = Array(rowCategory, colCategory)
                    
                    Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
                    assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True '<-- true, because this is our intention
                    
                    Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
                    shouldCastKeyToStringIfHelpsFindValue = False
                    
                    Dim aggregationSoFar As Double
                    If nestedPathExists(valueSoFarByColCategoryByRowCategory, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree) Then
                        aggregationSoFar = getValueForNestedDictionaryPath(valueSoFarByColCategoryByRowCategory, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
                    Else
                        aggregationSoFar = 0
                    End If
                    
                    aggregationSoFar = aggregationSoFar + CDbl(valueToAggregate)
                    
                    setValueForNestedDictionaryPath valueSoFarByColCategoryByRowCategory, nestedPath, aggregationSoFar, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree
                    
                End If
            End If
        Next
    Next
    
    ssbm "Done processing rows!"
    
    Set out_distinctRowCategories = distinctRowCategories
    Set out_distinctColCategories = distinctColCategories
    Set out_valueSoFarByColCategoryByRowCategory = valueSoFarByColCategoryByRowCategory
End Sub

Sub clearPivotTableSection(topLeftOfPivotTableArea As Range)

    Dim rngeToClear As Range
    Set rngeToClear = rngeToRnge(topLeftOfPivotTableArea, topLeftOfPivotTableArea.SpecialCells(xlCellTypeLastCell))
    
    srg rngeToClear
    rngeToClear.ClearContents
End Sub

Function getTopLeftOfPivotTableArea(optWS As Worksheet) As Range
    Set getTopLeftOfPivotTableArea = rnge("aggregationsAnchor", optWS).offset(1, 0)
End Function

Sub copyInFormulas(formulaRanges As Collection, firstRowToCopyTo As Long, lastRowToCopyTo As Long, showSuccessMsg As Boolean, returnToOrigSelWhenDone As Boolean)

    Dim origSel As Range
    Set origSel = getCurSel()
    
    Dim c As Long
    For c = 1 To formulaRanges.count
    
        Dim formulaRnge As Range
        Set formulaRnge = formulaRanges.item(c)
    
        Dim destRnge As Range
        Set destRnge = stretchOrCompressSoThatSpecificRowsAreCovered(formulaRnge, firstRowToCopyTo, lastRowToCopyTo)
        srg destRnge
        destRnge.ClearContents
    Next
    
    copyFormulasIntoSectionBetweenSpecificRows formulaRanges, firstRowToCopyTo, lastRowToCopyTo, IIf(showSuccessMsg, "in", "")

    If returnToOrigSelWhenDone Then
        sris origSel
    End If

End Sub


Function copyDownFormulas(optWS As Worksheet, rnOrRNsForAnchors As Variant, rnForFormulasOrArrayOrColletionOfRNsForThem As Variant, showSuccessMsg As Boolean) As Long
    copyDownFormulas = copyDownRowOrColFormulas(optWS, rnOrRNsForAnchors, rnForFormulasOrArrayOrColletionOfRNsForThem, showSuccessMsg, True, False)
End Function
Function copyDownRowFormulas(optWS As Worksheet, rnOrRNsForAnchors As Variant, rnForFormulasOrArrayOrColletionOfRNsForThem As Variant, showSuccessMsg As Boolean) As Long
    copyDownRowFormulas = copyDownRowOrColFormulas(optWS, rnOrRNsForAnchors, rnForFormulasOrArrayOrColletionOfRNsForThem, showSuccessMsg, False, False)
End Function

Function copyDownRowFormulas_baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections(optWS As Worksheet, rnOrRNsForAnchors As Variant, rnForFormulasOrArrayOrColletionOfRNsForThem As Variant, showSuccessMsg As Boolean) As Long
    copyDownRowFormulas_baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections = copyDownRowOrColFormulas(optWS, rnOrRNsForAnchors, rnForFormulasOrArrayOrColletionOfRNsForThem, showSuccessMsg, False, True)
End Function

Function copyDownRowOrColFormulas(optWS As Worksheet, rnOrRNsForAnchors As Variant, rnForFormulasOrArrayOrColletionOfRNsForThem As Variant, showSuccessMsg As Boolean, colDataVsRowData As Boolean, baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections__or__rowOrColThatWeShouldUse As Variant) As Long

    Dim rnsArray As Variant
    rnsArray = ensureValueIsAnArray(rnForFormulasOrArrayOrColletionOfRNsForThem)
    
    Dim formulaRanges As Collection
    Set formulaRanges = arrayToCollection(getCellsForListOfRNs(rnsArray, optWS))

    Dim listOfRNs As Variant
    Dim firstRN As Variant
    If isString(rnOrRNsForAnchors) Then
        listOfRNs = Array(rnOrRNsForAnchors)
        firstRN = rnOrRNsForAnchors
    ElseIf isCollection(rnOrRNsForAnchors) Then
        Set listOfRNs = rnOrRNsForAnchors
        If rnOrRNsForAnchors.count = 0 Then
            Set firstRN = Nothing
        Else
            firstRN = rnOrRNsForAnchors.item(1)
        End If
    Else 'must be an array
        listOfRNs = rnOrRNsForAnchors 'array or string, I think either one works
        If dimSize(listOfRNs, 1) = 0 Then
            Set firstRN = Nothing
        Else
            firstRN = rlai(rnOrRNsForAnchors, 1)
        End If
    
    End If
    
    If isNothing(firstRN) Then
        elwp "Could not figure out the anchor row!"
        copyDownRowOrColFormulas = -1
    Else
        
        Dim dataAnchorRowOrCol As Long
        If isBoolean(baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections__or__rowOrColThatWeShouldUse) Then
            Dim baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections As Boolean
            baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections = baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections__or__rowOrColThatWeShouldUse
            
            If baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections Then
            
                Dim anyFormulaAnchor As Range
                If formulaRanges.count = 0 Then
                    elwp "You did not pass in any formula ranges!"
                    Set anyFormulaAnchor = Nothing
                Else
                    Set anyFormulaAnchor = formulaRanges.item(1)
                End If
                If colDataVsRowData Then
                    dataAnchorRowOrCol = anyFormulaAnchor.row
                Else
                    dataAnchorRowOrCol = anyFormulaAnchor.column
                End If
            Else
                If colDataVsRowData Then
                    dataAnchorRowOrCol = rnge(CStr(firstRN), optWS).row
                Else
                    dataAnchorRowOrCol = rnge(CStr(firstRN), optWS).column
                End If
            End If
        Else
            Dim rowOrColThatWeShouldUse As Long
            rowOrColThatWeShouldUse = baseDataAnchorOffOfFormulaSectionsRatherThanAnchorSections__or__rowOrColThatWeShouldUse
            
            dataAnchorRowOrCol = rowOrColThatWeShouldUse
        End If
    
        Dim anchorCells As Variant
        anchorCells = getCellsForListOfRNs(listOfRNs, optWS)
        
        copyDownRowOrColFormulas = copyDownRowOrColFormulas_withAdditionalParams(anchorCells, formulaRanges, dataAnchorRowOrCol, showSuccessMsg, True, Nothing, colDataVsRowData, dataAnchorRowOrCol, True)
    End If

End Function


'showSuccessMsg = true
Function copyDownFormulas_withAdditionalParams(anchorsArrayListOrCollection As Variant, formulaRanges As Collection, dataAnchorRow As Long, showSuccessMsg As Boolean, returnToOrigSelWhenDone As Boolean, optMinRow_orNothingForNoMinimum As Variant) As Long
    copyDownFormulas_withAdditionalParams = copyDownRowOrColFormulas_withAdditionalParams(anchorsArrayListOrCollection, formulaRanges, dataAnchorRow, showSuccessMsg, returnToOrigSelWhenDone, optMinRow_orNothingForNoMinimum, True, dataAnchorRow, True)
End Function

'formulaAnchorRowOrCol = dataAnchorRowOrCol
'weExpectAllAnchorsToBeOnSingleWorksheet = true
Function copyDownRowOrColFormulas_withAdditionalParams(anchorsArrayListOrCollection As Variant, formulaRanges As Collection, dataAnchorRowOrCol As Long, showSuccessMsg As Boolean, returnToOrigSelWhenDone As Boolean, optMinRowOrCol_orNothingForNoMinimum As Variant, copyDownRatherThanAcross As Boolean, formulaAnchorRowOrCol As Long, weExpectAllAnchorsToBeOnSingleWorksheet As Boolean) As Long


    Dim anchorRanges As Collection
    If isCollection(anchorsArrayListOrCollection) Then
        Set anchorRanges = anchorsArrayListOrCollection
    Else
        Set anchorRanges = arrayToCollection(anchorsArrayListOrCollection)
    End If
    
    Dim anchors As Collection
    Set anchors = New Collection
    
    Dim x As Long
    For x = 1 To anchorRanges.count
        Dim ankRange As Range
        Set ankRange = anchorRanges.item(x)
        
        Dim cells As Collection
        Set cells = getCellsInRnge(ankRange)
        
        addCollectionToCollection anchors, cells
        
    Next
    
    Dim origSel As Range
    Set origSel = getCurSel()
    
    'JY20120709a - clear formulas afterwards, just in case some of our anchor cells are formula cells too (we want to use the anchor cells to count how far down to copy the formulas)
    'clearRowOrColFormulas formulaRanges, formulaAnchorRowOrCol, copyDownRatherThanAcross
    
    Dim firstRowOrCol As Long
    Dim lastRowOrCol As Long
    getRowOrColRngeWhereDataExistsInAnchors_withOptionalMinimumRowOrCol anchors, firstRowOrCol, lastRowOrCol, optMinRowOrCol_orNothingForNoMinimum, dataAnchorRowOrCol, copyDownRatherThanAcross
    
    'JY20120824a - start - I think I commented this one out by accident so I am re-instating it
    ''JY20120709a - clear formulas afterwards, just in case some of our anchor cells are formula cells too (we want to use the anchor cells to count how far down to copy the formulas)
    ''clearRowOrColFormulas formulaRanges, formulaAnchorRowOrCol, copyDownRatherThanAcross
    clearRowOrColFormulas formulaRanges, formulaAnchorRowOrCol, copyDownRatherThanAcross
    'JY20120824a - end
        
    Dim commonDataAnchorWorksheet As Worksheet
    Dim commonFormulaAnchorWorksheet As Worksheet
    Set commonDataAnchorWorksheet = commonWorksheetInRnges(anchorRanges)
    Set commonFormulaAnchorWorksheet = commonWorksheetInRnges(formulaRanges)
    
    Dim formulaStartAndEndRowShouldMatchThatOfDataAnchors As Boolean
    If isNothing(commonFormulaAnchorWorksheet) Then
        'No choice!  We don't have any formula anchors thruogh which we could determine an alternate start and end row.
        formulaStartAndEndRowShouldMatchThatOfDataAnchors = True
    ElseIf Not isNothing(commonDataAnchorWorksheet) And Not isNothing(commonFormulaAnchorWorksheet) And (commonDataAnchorWorksheet Is commonFormulaAnchorWorksheet) Then
        formulaStartAndEndRowShouldMatchThatOfDataAnchors = True
    Else
        formulaStartAndEndRowShouldMatchThatOfDataAnchors = False
    End If
    
    
    Dim firstRowOrColForFormulas As Long
    Dim lastRowOrColForFormulas As Long
    Dim sdCnt As Boolean
    If formulaStartAndEndRowShouldMatchThatOfDataAnchors Then
        'All of our anchors, data and formula, are in the same worksheet!  Therefore, formulas should be copied down to the same rows that data is populated under for the anchors.
        firstRowOrColForFormulas = firstRowOrCol
        lastRowOrColForFormulas = lastRowOrCol
        
        If Not weExpectAllAnchorsToBeOnSingleWorksheet Then
            elwp "We did not expect all of our anchors to be on a single worksheet, but they are!"
        End If
        sdCnt = True
    Else
        'We have things in different places.  Therefore,
    
        If weExpectAllAnchorsToBeOnSingleWorksheet Then
            elwp "We expected all our anchors to be on a single worksheet, but they are not!"
        End If
        
        If isNothing(commonFormulaAnchorWorksheet) Then
            elwp "Our formula anchors span multiple sheets... hence, we cannot figure out a common starting and ending row for them!"
            firstRowOrColForFormulas = -1 'arbitrary
            lastRowOrColForFormulas = -1 'arbitrary
            sdCnt = False
        Else
            sdCnt = True
            
            firstRowOrColForFormulas = formulaAnchorRowOrCol + 1
            lastRowOrColForFormulas = firstRowOrColForFormulas + (lastRowOrCol - firstRowOrCol)
        End If
    End If
    
    If Not sdCnt Then
        elwp "Could not copy down formulas!"
    Else
        copyFormulasIntoSectionBetweenSpecificRowsOrCols formulaRanges, firstRowOrColForFormulas, lastRowOrColForFormulas, IIf(showSuccessMsg, IIf(copyDownRatherThanAcross, "down", "across"), ""), copyDownRatherThanAcross
    End If
    If returnToOrigSelWhenDone Then
        sris origSel
    End If
    
    copyDownRowOrColFormulas_withAdditionalParams = lastRowOrColForFormulas

End Function
Sub getRowRngeWhereDataExistsInAnchors_withOptionalMinimumRow(anchors As Collection, ByRef out_firstRow As Long, ByRef out_lastRow As Long, optMinRowForLastRow_orNothingForNoMinimum As Variant, dataAnchorRow As Long)
    getRowOrColRngeWhereDataExistsInAnchors_withOptionalMinimumRowOrCol anchors, out_firstRow, out_lastRow, optMinRowForLastRow_orNothingForNoMinimum, dataAnchorRow, True
End Sub

Sub getRowOrColRngeWhereDataExistsInAnchors_withOptionalMinimumRowOrCol(anchors As Collection, ByRef out_firstRowOrCol As Long, ByRef out_lastRowOrCol As Long, optMinRowForLastRowOrCol_orNothingForNoMinimum As Variant, dataAnchorRowOrCol As Long, findMinAndMaxRowsVsCols As Boolean)
    
    Dim firstRowOrCol As Long
    Dim lastRowOrCol As Long
    getRowOrColRngeWhereDataExistsInAnchors anchors, firstRowOrCol, lastRowOrCol, findMinAndMaxRowsVsCols
    
    firstRowOrCol = wsFunctionMax(dataAnchorRowOrCol + 1, firstRowOrCol)
    lastRowOrCol = wsFunctionMax(firstRowOrCol, lastRowOrCol)
    
    If isNothing(optMinRowForLastRowOrCol_orNothingForNoMinimum) Then
        'DO NOTHING
    ElseIf Not isInteger(optMinRowForLastRowOrCol_orNothingForNoMinimum) Then
        elwp "Please pass in an integer value for the optional minimum row!"
    Else
        lastRowOrCol = wsFunctionMax(CLng(optMinRowForLastRowOrCol_orNothingForNoMinimum), lastRowOrCol)
    End If
    
    out_firstRowOrCol = firstRowOrCol
    out_lastRowOrCol = lastRowOrCol
End Sub
Sub copyFormulasIntoSectionBetweenSpecificRows(formulaRanges As Collection, firstRow As Long, lastRow As Long, descIfShouldShowSuccessMsg_orBlankToNotShow As String)
    copyFormulasIntoSectionBetweenSpecificRowsOrCols formulaRanges, firstRow, lastRow, descIfShouldShowSuccessMsg_orBlankToNotShow, True
End Sub
Sub copyFormulasIntoSectionBetweenSpecificCols(formulaRanges As Collection, firstCol As Long, lastCol As Long, descIfShouldShowSuccessMsg_orBlankToNotShow As String)
    copyFormulasIntoSectionBetweenSpecificRowsOrCols formulaRanges, firstCol, lastCol, descIfShouldShowSuccessMsg_orBlankToNotShow, False
End Sub

Sub copyFormulasIntoSectionBetweenSpecificRowsOrCols(formulaRanges As Collection, firstRowOrCol As Long, lastRowOrCol As Long, descIfShouldShowSuccessMsg_orBlankToNotShow As String, rowsVsCols As Boolean)
    
    Dim origCalc As Variant
    origCalc = tsctm()
    
    Dim wsByWSName As Dictionary
    Set wsByWSName = New Dictionary
    
    Dim c As Long
    For c = 1 To formulaRanges.count
        Dim curRnge As Range
        Set curRnge = formulaRanges.item(c)
        
        Dim destRnge As Range
        Set destRnge = stretchOrCompressSoThatSpecificRowsOrColsAreCovered(curRnge, firstRowOrCol, lastRowOrCol, rowsVsCols)
        
        'Dim theFormulas As Variant
        'theFormulas = curRnge.FormulaR1C1
        
        copyFormulasFromOneRngeIntoAnother curRnge, destRnge, False 'We do not re-calculate because we will recalculate the worksheet later
        
        Dim destWS As Worksheet
        Set destWS = destRnge.Worksheet
        
        Dim wsName As String
        wsName = destWS.name
        
        If wsByWSName.exists(wsName) Then
            If Not vfd(wsByWSName, wsName, True) Is destWS Then
                elwp "Found multiple worksheets with the same name!  This should be impossible."
            End If
        Else
            atd wsByWSName, wsName, destWS
        End If
    Next
    
    Dim wsNames As Variant
    wsNames = wsByWSName.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs wsNames, lwr, upr
    
    Dim dd As Long
    For dd = lwr To upr
        vfd(wsByWSName, wsNames(dd), True).Calculate
    Next
    
    rok origCalc
    
    If descIfShouldShowSuccessMsg_orBlankToNotShow <> "" Then
        ilwp "Formulas have been copied " & descIfShouldShowSuccessMsg_orBlankToNotShow & "!"
    End If

End Sub

Sub clearFormulas(formulaRanges As Collection, dataAnchorRow As Long)
    clearRowOrColFormulas formulaRanges, dataAnchorRow, True
End Sub

Sub clearRowOrColFormulas(formulaRanges As Collection, dataAnchorRowOrCol As Long, colDataVsRowData As Boolean)

    Dim origCalc As Variant
    origCalc = Application.Calculation
    
    If Application.Calculation <> xlCalculationManual Then
        Application.Calculation = xlCalculationManual
    End If

    Dim c As Long
    For c = 1 To formulaRanges.count
    
        Dim thisRnge As Range
        Set thisRnge = formulaRanges.item(c)
    
        Dim rngeToClear As Range
        If colDataVsRowData Then
            Set rngeToClear = moveRnge(resizeRnge(thisRnge, 1, thisRnge.Columns.count), dataAnchorRowOrCol, thisRnge.column)
        Else
            Set rngeToClear = moveRnge(resizeRnge(thisRnge, thisRnge.rows.count, 1), thisRnge.row, dataAnchorRowOrCol)
        End If
        
    
        clearColumnOrRowData rngeToClear, False, colDataVsRowData
    Next

    If origCalc <> Application.Calculation Then
        Application.Calculation = origCalc
    End If


End Sub
Function getGrandTotalHeaderNameForCategory(colCategoriesShouldIncludeDataFieldName As Boolean, curCat As String, delimiter As String, escChar As String) As String
    Dim grandTotalFieldName As String
    If Not colCategoriesShouldIncludeDataFieldName Then
        grandTotalFieldName = "Grand Total"
    Else
    
        Dim tkns As Collection
        Set tkns = stringToCollection(curCat, delimiter, escChar)
        
        If tkns.count <> 2 Then
            elwp_se
        End If
        
        Dim colCat As String
        Dim dataField As String
        colCat = tkns.item(1)
        dataField = tkns.item(2)
        
        grandTotalFieldName = "Grand Total for " & dataField
    End If
    getGrandTotalHeaderNameForCategory = grandTotalFieldName
End Function

Function allExistInSet(itemsToCheck As Collection, theSet As JYCORE_Set) As Boolean
    Dim allExistSoFar As Boolean
    allExistSoFar = True
    
    Dim c As Long
    c = 1
    
    While allExistSoFar And (c <= itemsToCheck.count)
        If Not theSet.exists(itemsToCheck.item(c)) Then
            allExistSoFar = False
        End If
        c = c + 1
    Wend
    
    allExistInSet = allExistSoFar

End Function

Sub findDifferencesBetweenSets(moreRecentSet As JYCORE_Set, origSet As JYCORE_Set, ByRef out_addedItems As JYCORE_Set, ByRef out_removedItems As JYCORE_Set)
    
    Dim addedItemsSoFar As JYCORE_Set
    Set addedItemsSoFar = moreRecentSet.clone()
    
    Dim origList As Collection
    Set origList = origSet.toCollection()
    
    Dim removedItems As JYCORE_Set
    Set removedItems = New JYCORE_Set
    
    Dim c As Long
    For c = 1 To origList.count
        Dim curItem As Variant
        atr curItem, origList.item(c)
        
        If addedItemsSoFar.remove(curItem) Then
            'DO NOTHING
        Else
            removedItems.add curItem
        End If
    Next
    
    Set out_addedItems = addedItemsSoFar
    Set out_removedItems = removedItems

End Sub

Sub copyColDataFromOnePlaceToAnother_usingRNsForDestAndFieldNamesForSrc_andOptFirstDataRow(matchCase As Boolean, listOf_srcFieldNameAndDestRN As Collection, headerRowInSource As Long, srcWS As Worksheet, optDestWS As Worksheet, optFirstDataRow As Variant, ByRef out_firstRowWrittenTo As Long, ByRef out_lastRowWrittenTo As Long, convertHeaderCellsToGeneralFormatBeforeSearch_thisIsWeirdButFoundACaseWhereACustomNumberFormatPreventedMeFromFindingACellWhenLookingForExactMatchInCell As Boolean)

    Dim listOf_srcRNAndDestRN As Collection
    Set listOf_srcRNAndDestRN = replaceSrcFieldNamesWithSrcRNs_in_listOfSrcFieldNameAndDestRN(listOf_srcFieldNameAndDestRN, matchCase, srcWS, headerRowInSource, convertHeaderCellsToGeneralFormatBeforeSearch_thisIsWeirdButFoundACaseWhereACustomNumberFormatPreventedMeFromFindingACellWhenLookingForExactMatchInCell, Nothing, True)
    
    Dim firstRowWrittenTo As Long
    Dim lastRowWrittenTo As Long
    copyColDataFromOnePlaceToAnother_usingRNsAndOptFirstDataRow listOf_srcRNAndDestRN, srcWS, optDestWS, optFirstDataRow, firstRowWrittenTo, lastRowWrittenTo
    
    out_firstRowWrittenTo = firstRowWrittenTo
    out_lastRowWrittenTo = lastRowWrittenTo

End Sub

Sub copyColDataFromOnePlaceToAnother_usingRNsAndOptFirstDataRow(listOf__srcRNOrBlankStringToShowBlank_and_DestRN As Collection, optSrcWS As Worksheet, optDestWS As Worksheet, optFirstDataRow As Variant, ByRef out_firstRowWrittenTo As Long, ByRef out_lastRowWrittenTo As Long)

    Dim listOf_destRNAndDataOrRngeToCopyIn As Collection
    Set listOf_destRNAndDataOrRngeToCopyIn = figureOutWhatDataShouldBeWritten(listOf__srcRNOrBlankStringToShowBlank_and_DestRN, optSrcWS, True, False)
    
    Dim minRowWrittenTo As Long
    Dim maxRowWrittenTo As Long
    writeColDataIntoListOfRNs listOf_destRNAndDataOrRngeToCopyIn, optDestWS, minRowWrittenTo, maxRowWrittenTo, optFirstDataRow
    
    out_firstRowWrittenTo = minRowWrittenTo
    out_lastRowWrittenTo = maxRowWrittenTo

End Sub

'useRngesWhenPossible = true
'removeBlankRows = false
Function figureOutWhatDataShouldBeWritten(listOf__srcRNOrBlankStringToShowBlank_and_DestRN As Collection, optSrcWS As Worksheet, useRngesWhenPossible_noteThatRangesWillNotBeUsedIfYouAreRemovingBlankRows As Boolean, removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows As Variant) As Collection

    Dim destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows As JYCORE_Set
    If isNothing(removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows) Then
        Set destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows = Nothing
    ElseIf IsObject(removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows) Then
        Set destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows = removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows
    Else
        If CBool(removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows) Then
            Set destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows = collectionToSet(castToCollection(sciloar(True, listOf__srcRNOrBlankStringToShowBlank_and_DestRN).item(2)))
        Else
            Set destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows = Nothing
        End If
    End If
    
    
    

    Dim listOf_destRNAndDataOrRngeToCopyIn As Collection
    If isNothing(listOf__srcRNOrBlankStringToShowBlank_and_DestRN) Then
    
        Set listOf_destRNAndDataOrRngeToCopyIn = Nothing
    Else
    
        
        Dim listOf_destRNAndRngeToCopyIn As Collection
        Dim maxRowsOfData As Long
        Dim listOf_destRNToHardcodeBlankValuesFor As Collection
        figureOutWhichSourceRngesToCopyWhereAsWellAsWhereWeWantToWriteAllBlankValues listOf_destRNAndRngeToCopyIn, listOf_destRNToHardcodeBlankValuesFor, maxRowsOfData, listOf__srcRNOrBlankStringToShowBlank_and_DestRN, optSrcWS
        
        
        Dim numRows As Long
        If useRngesWhenPossible_noteThatRangesWillNotBeUsedIfYouAreRemovingBlankRows And isNothing(destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows) Then
            Set listOf_destRNAndDataOrRngeToCopyIn = listOf_destRNAndRngeToCopyIn
            numRows = maxRowsOfData
        Else
            
            Dim listOf_destRNAndDataCollectionsToCopyIn As Collection
            Set listOf_destRNAndDataCollectionsToCopyIn = convertTheRngesToDataRows(listOf_destRNAndRngeToCopyIn)
            
            Dim destRN_dataCollection As Collection
            Set destRN_dataCollection = sciloar(True, listOf_destRNAndDataCollectionsToCopyIn)
            
            Dim theDestRNs As Collection
            Dim theCollectionsList As Collection
            With destRN_dataCollection
                Set theDestRNs = .item(1)
                Set theCollectionsList = .item(2)
            End With
            
            Dim collList_whereEachIsSameSize As Collection
            padCollectionsToMakeThemAllSameSize kta(theCollectionsList), ""
            Set collList_whereEachIsSameSize = theCollectionsList
            
            Dim numRowsRemoved As Long
            If isNothing(destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows) Then
                numRowsRemoved = 0
            Else
                
                Dim theCollectionsToCheck As Collection
                Set theCollectionsToCheck = New Collection
                
                Dim sz As Long
                sz = ccsz(Array(collList_whereEachIsSameSize, theDestRNs), True)
                

                Dim jy As Long
                For jy = 1 To sz
                
                    Dim theRN As String
                    Dim theData As Collection
                    theRN = theDestRNs.item(jy)
                    Set theData = collList_whereEachIsSameSize.item(jy)
                
                    Dim shouldInclude As Boolean
                    shouldInclude = destRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows_orNothingToNotRemoveBlankRows.exists(theRN)
                    
                    If shouldInclude Then
                        theCollectionsToCheck.add theData
                    End If
                Next
                    
                Dim indexesToRemove As Collection
                Set indexesToRemove = figureOutIndexesAtWhichValueIsBlankInAllCollections(theCollectionsToCheck)
                
                removeEntriesFromCollectionsAtSpecificIndexes collList_whereEachIsSameSize, indexesToRemove
                    
                numRowsRemoved = indexesToRemove.count
            End If
            
            Dim newSize As Long
            newSize = ccsz(kta(collList_whereEachIsSameSize), True)
            
            If newSize <> maxRowsOfData - numRowsRemoved Then
                elwp_se
            End If
            
            Set listOf_destRNAndDataOrRngeToCopyIn = listOf_destRNAndDataCollectionsToCopyIn
            numRows = newSize
        End If
        
        Dim blankValuesCollection As Collection
        Set blankValuesCollection = repeatedlyAddValueToCollection(createCollection(), "", numRows)
        
        Dim t As Long
        For t = 1 To listOf_destRNToHardcodeBlankValuesFor.count
            Dim destRNToHardcodeBlankValuesFor As String
            destRNToHardcodeBlankValuesFor = listOf_destRNToHardcodeBlankValuesFor.item(t)
            
            listOf_destRNAndDataOrRngeToCopyIn.add Array(destRNToHardcodeBlankValuesFor, blankValuesCollection)
        Next
        
'        Dim jj As Long
'        For jj = 1 To listOf_destRNAndDataOrRngeToCopyIn.count
'            Dim destRNAndDataOrRngeToCopyIn As Variant
'            destRNAndDataOrRngeToCopyIn = listOf_destRNAndDataOrRngeToCopyIn.item(jj)
'
'            Dim dataOrRngeToCopyIn As Variant
'            atr dataOrRngeToCopyIn, rlai(destRNAndDataOrRngeToCopyIn, 2)
'
'            Dim dataToCopyIn As Collection
'            If isRnge(dataOrRngeToCopyIn) Then
'                Set dataToCopyIn = getColDataFromColRnge(castToRnge(dataOrRngeToCopyIn))
'            Else
'                Set dataToCopyIn = dataOrRngeToCopyIn
'            End If
'
'
'
'            srai destRNAndDataOrRngeToCopyIn, 2, dataToCopyIn
'        Next
'
        
    End If
    Set figureOutWhatDataShouldBeWritten = listOf_destRNAndDataOrRngeToCopyIn
End Function

Sub writeColDataIntoListOfRNs(listOf_destRNAndDataOrRngeToCopyIn As Collection, optDestWS As Worksheet, ByRef out_minRowWrittenTo As Long, ByRef out_maxRowWrittenTo As Long, optFirstDataRow As Variant)
    
    Dim minRowWrittenTo As Long
    Dim maxRowWrittenTo As Long
    minRowWrittenTo = -1
    maxRowWrittenTo = -1
    
    If isNothing(listOf_destRNAndDataOrRngeToCopyIn) Then
        'DO NOTHING
    Else
    
        Dim d As Long
        For d = 1 To listOf_destRNAndDataOrRngeToCopyIn.count
        
            Dim destRNAndDataOrRngeToCopyIn As Variant
            destRNAndDataOrRngeToCopyIn = listOf_destRNAndDataOrRngeToCopyIn.item(d)
        
            Dim destRNToUse As String
            Dim dataOrRngeToCopyIn As Variant
            destRNToUse = rlai(destRNAndDataOrRngeToCopyIn, 1)
            Set dataOrRngeToCopyIn = rlai(destRNAndDataOrRngeToCopyIn, 2)
           
            Dim destAnchor As Range
            Set destAnchor = rnge(destRNToUse, optDestWS)
           
            Dim destAnchorToUse As Range
            If isNothing(optFirstDataRow) Then
                Set destAnchorToUse = destAnchor
            Else
                Set destAnchorToUse = gcicsr(destAnchor, CLng(optFirstDataRow) - 1)
            End If
            
            srg destAnchorToUse
            
            Dim setData As Range
            Set setData = scd(destAnchorToUse, dataOrRngeToCopyIn)
            
            If Not isNothing(setData) Then
                
                Dim firstRowThisRound As Long
                Dim lastRowThisRound As Long
                firstRowThisRound = setData.row
                lastRowThisRound = brcor(setData).row
            
                If minRowWrittenTo = -1 Then
                    minRowWrittenTo = firstRowThisRound
                Else
                    minRowWrittenTo = wsFunctionMin(minRowWrittenTo, firstRowThisRound)
                End If
                
                If maxRowWrittenTo = -1 Then
                    maxRowWrittenTo = lastRowThisRound
                Else
                    maxRowWrittenTo = wsFunctionMax(maxRowWrittenTo, lastRowThisRound)
                End If
            End If
                    
            
            srg setData
            
            
        Next
    End If

    out_minRowWrittenTo = minRowWrittenTo
    out_maxRowWrittenTo = maxRowWrittenTo

End Sub

Sub copyColDataFromOnePlaceToAnother_usingRNs(listOf_srcRNAndDestRN As Collection, optSrcWS As Worksheet, optDestWS As Worksheet)

    Dim firstRowWrittenTo As Long
    Dim lastRowWrittenTo As Long
    copyColDataFromOnePlaceToAnother_usingRNsAndOptFirstDataRow listOf_srcRNAndDestRN, optSrcWS, optDestWS, Nothing, firstRowWrittenTo, lastRowWrittenTo
End Sub

Function addCollectionContentsToObject(ByRef mod_objToAddTo As Variant, collectionToAdd As Collection) As Variant

    Dim c As Long
    For c = 1 To collectionToAdd.count
        mod_objToAddTo.add collectionToAdd.item(c)
    Next
    
    Set addCollectionContentsToObject = mod_objToAddTo

End Function
Sub sortSouceDataAndDeleteRowsThatWeDoNotWant_chooseBasedUponValueInOneColumn(dataHeader As Range, anchorForProdType As Range, arrofDesiredTypes As Variant)
    
    Dim allData As Range
    Set allData = getSourceData(dataHeader, True)
    
    srg allData
    
    Dim matchCase As Boolean
    matchCase = False
    
    sortData allData, anchorForProdType, True, matchCase, xlSortNormal
    
        
    Dim searchRnge As Range
    Set searchRnge = rngeToRnge(gcicsr(anchorForProdType, allData.row + 1), gcicsr(anchorForProdType, brcor(allData).row))
    
    Dim listOf_firstRowAndLastRowDenotingRangeToKeep As Collection
    Set listOf_firstRowAndLastRowDenotingRangeToKeep = figureOutWhichRowRngesInSortedTableToKeep(searchRnge, arrofDesiredTypes, matchCase)
    
    Dim sorted_listOf_firstRowAndLastRowDenotingRangeToKeep As Collection
    Set sorted_listOf_firstRowAndLastRowDenotingRangeToKeep = sortListOfArraysByArrayIndx(listOf_firstRowAndLastRowDenotingRangeToKeep, 1)
    
    Dim sorted_listOf_firstRowAndLastRowDenotingRangeToDelete As Collection
    Set sorted_listOf_firstRowAndLastRowDenotingRangeToDelete = figureOutWhichRowRangesToDelete(searchRnge, sorted_listOf_firstRowAndLastRowDenotingRangeToKeep)
    
    Dim t As Long
    For t = sorted_listOf_firstRowAndLastRowDenotingRangeToDelete.count To 1 Step -1
        Dim firstRowAndLastRowDenotingRangeToDelete As Variant
        firstRowAndLastRowDenotingRangeToDelete = sorted_listOf_firstRowAndLastRowDenotingRangeToDelete.item(t)
        
        Dim firstRowToDelete As Long
        Dim lastRowToDelete As Long
        firstRowToDelete = rlai(firstRowAndLastRowDenotingRangeToDelete, 1)
        lastRowToDelete = rlai(firstRowAndLastRowDenotingRangeToDelete, 2)
        
        Dim rngeToDelete As Range
        Set rngeToDelete = rngeToRnge(gcicsr(tlcor(dataHeader), firstRowToDelete), gcicsr(brcor(dataHeader), lastRowToDelete))
        
        srg rngeToDelete
        
        rngeToDelete.Delete xlShiftUp
    Next
End Sub
Sub writeVectorBasedTableToCellRnge(table As JYUT_VectorBasedTable, destRnge As Range)
    
    Dim numResultRows As Long
    Dim numResultCols As Long
    numResultRows = table.numRows()
    numResultCols = table.numCols()
    
    If numResultRows = 0 And numResultCols = 0 Then
        'DO NOTHING
    ElseIf numResultRows = 0 Or numResultCols = 0 Then
        elwp "# of rows or # of cols is zero, which is impossible!  (If one is zero, the other should also be zero)"
    ElseIf destRnge.rows.count < numResultRows Then
        elwp "Not enough rows available to display our results!"
    ElseIf destRnge.Columns.count < numResultCols Then
        elwp "Not enough columns available to display our results!"
    Else
    
        Dim arr As Variant
        arr = table.toArray()
        
        Dim fittedRnge As Range
        Set fittedRnge = resizeRnge(destRnge, numResultRows, numResultCols)
        
        srg fittedRnge
        writeArrayToRngeOfExactlySameSize fittedRnge, arr, True, False
    End If

End Sub

Sub writeColDataIntoRanges(colDataByRN As Dictionary, optWS As Worksheet, headerRow As Long)

    Dim fieldNameOrArrayOfFieldNamesByDestRN As Dictionary
    Set fieldNameOrArrayOfFieldNamesByDestRN = New Dictionary
    
    Dim rns As Variant
    rns = colDataByRN.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rns, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim rn As String
        rn = rns(c)
        
        atd fieldNameOrArrayOfFieldNamesByDestRN, rn, rn
    Next
    
    writeColDataByFieldNameIntoColumns_specifyOptionalHeaderRow colDataByRN, fieldNameOrArrayOfFieldNamesByDestRN, optWS, headerRow, True

End Sub

'selectAsWeSet = true
Sub writeColDataByFieldNameIntoColumns(colDataByFieldName As Dictionary, fieldNameOrArrayOfFieldNamesByDestRN_spaceWillBeUsedAsDelimiter As Dictionary, optWS As Worksheet, selectAsWeSet As Boolean)
    writeColDataByFieldNameIntoColumns_specifyOptionalHeaderRow colDataByFieldName, fieldNameOrArrayOfFieldNamesByDestRN_spaceWillBeUsedAsDelimiter, optWS, Nothing, selectAsWeSet
End Sub

'selectAsWeSet = True
Sub writeColDataByFieldNameIntoColumns_specifyOptionalHeaderRow(colDataByFieldName As Dictionary, fieldNameOrArrayOfFieldNamesByDestRN_spaceWillBeUsedAsDelimiter As Dictionary, optWS As Worksheet, headerRowOrNothingToNotSpecify As Variant, selectAsWeSet As Boolean)
    
    Dim destRNs As Variant
    destRNs = fieldNameOrArrayOfFieldNamesByDestRN_spaceWillBeUsedAsDelimiter.keys()
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(destRNs, 1)
    upper = UBound(destRNs, 1)
    
    Dim c  As Long
    For c = lower To upper
        Dim destRN As String
        destRN = destRNs(c)
        
        Dim fieldNameOrArrayOfFieldNames As Variant
        fieldNameOrArrayOfFieldNames = fieldNameOrArrayOfFieldNamesByDestRN_spaceWillBeUsedAsDelimiter.item(destRN)
        
        Dim arrayOfFieldNames As Variant
        If Not IsArray(fieldNameOrArrayOfFieldNames) Then
            arrayOfFieldNames = Array(fieldNameOrArrayOfFieldNames)
        Else
            arrayOfFieldNames = fieldNameOrArrayOfFieldNames
        End If
        
        Dim numCols As Long
        numCols = dimSize(arrayOfFieldNames, 1)
        
        Dim colsToConcatenate As Variant
        ReDim colsToConcatenate(1 To numCols)
        
        Dim dd As Long
        For dd = 1 To numCols
        
            Dim fieldName As String
            fieldName = rlai(arrayOfFieldNames, dd)
            
            atr colsToConcatenate(dd), vfd(colDataByFieldName, fieldName, True)
            
        Next
        
        Dim concatenated As Variant
        atr concatenated, concatenateCollectionElements(colsToConcatenate, " ", False)
        
        Dim data As Collection
        If isNothing(concatenated) Then
            Set data = New Collection
        Else
            Set data = arrayToCollection(concatenated)
        End If
        
        Dim anchor As Range
        If isNothing(headerRowOrNothingToNotSpecify) Then
            Set anchor = rnge(destRN, optWS)
        Else
            Set anchor = gcicsr(rnge(destRN, optWS), CLng(headerRowOrNothingToNotSpecify))
        End If
        
        
        If selectAsWeSet Then
            srg anchor
        End If
        scd anchor, data
        
    Next
    
End Sub

Function constructArrRowsFromColRNs(optWS As Worksheet, arrOfRNs As Variant) As Collection
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrOfRNs, lwr, upr
    
    Dim table As JYUT_VectorBasedTable
    Set table = New JYUT_VectorBasedTable
    
    Dim c As Long
    For c = lwr To upr
        Dim rn As String
        rn = arrOfRNs(c)
        
        table.addCol getColumnData(rnge(rn, optWS))
    Next
    
   
    If table.numRows > 0 Then
        Set constructArrRowsFromColRNs = arrayToCollection(separateRowsInArray(table.toArray(), False))
    Else
        Set constructArrRowsFromColRNs = New Collection
    End If
End Function

Sub selectAndSetValue(rn As String, optWSForYBConfiguration As Worksheet, theValue As Variant)

    Dim theCell As Range
    Set theCell = rnge(rn, optWSForYBConfiguration).offset(0, 1)
    
    srg theCell
    svl theCell, theValue
    
End Sub

Function temporarilySetCalcsToManual() As Variant
    Dim origCalc As Variant
    origCalc = "ERROR: NOT SET!!!"
    
    Dim shouldSetTheCalc As Boolean
    shouldSetTheCalc = True 'arbitrary
    
On Error GoTo ehs
    origCalc = Application.Calculation
    shouldSetTheCalc = (origCalc <> xlCalculationManual)
GoTo ehe
ehs:
    elg "Could not obtain current calculation state. Msg=" & Err.description 'I have seen an "overflow" error occur here.
    origCalc = xlCalculationManual
    shouldSetTheCalc = True
ehe:
On Error GoTo 0
    
    If shouldSetTheCalc Then
        Application.Calculation = xlCalculationManual
    End If
    
    temporarilySetCalcsToManual = origCalc
    
End Function

Sub restoreOrigCalcs(origCalc As Variant)

On Error GoTo ehs

    If origCalc <> Application.Calculation Then
        Application.Calculation = origCalc
    End If
    
GoTo ehe
ehs:
    elwp "Could not restore orig calcs!  Msg=" & Err.description
ehe:
On Error GoTo 0

End Sub

Sub calcRnge(theRnge As Range)
    theRnge.Calculate
End Sub
Sub tempsrg(rng As Range)
    Dim origSel As Range
    Set origSel = getCurSel()
    
    sris rng
    ilwp "Selected!"
    
    sris origSel
    
    
End Sub

Function warnUserIfMultipleWBsOpenAndPromptIfShouldContinue(reason As String) As Boolean
    
    Dim numWBs As Long
    numWBs = Workbooks.count
    
    Dim numOtherWBs As Long
    numOtherWBs = (numWBs - 1)
    
    Dim sdCnt As Boolean
    If numWBs > 1 Then
        Dim result As Variant
        result = MsgBox("You have " & numOtherWBs & " other " & IIf(numOtherWBs = 1, "workbook", "workbooks") & " open.  If they are large, they may " & reason & ".  Continue anyway?", vbYesNo)
        
        If result = vbYes Then
            result = MsgBox("Are you SURE??!?!?!?", vbYesNo)
        End If
        
        If result = vbYes Then
            sdCnt = True
        Else
            sdCnt = False
        End If
    Else
        sdCnt = True
    End If
    warnUserIfMultipleWBsOpenAndPromptIfShouldContinue = sdCnt
End Function

Sub calcWS(ws As Worksheet)
    ws.Calculate
End Sub

Sub calcAllSheetsIndividually(wb As Workbook)

    Dim ws As Worksheet
    For Each ws In wb.worksheets
        calcWS ws
    Next

End Sub

Sub strongRecalc(Optional suppressSuccessMsg As Variant, Optional suppressWarningMsg As Variant)
    
    Dim suppSucc As Boolean
    Dim suppWarning As Boolean
    If IsMissing(suppressSuccessMsg) Then
        suppSucc = False
    Else
        suppSucc = suppressSuccessMsg
    End If
    If IsMissing(suppressWarningMsg) Then
        suppWarning = False
    Else
        suppWarning = suppressWarningMsg
    End If
    
    Dim sdCnt As Boolean
    If suppWarning Then
        sdCnt = True
    Else
        sdCnt = warnUserIfMultipleWBsOpenAndPromptIfShouldContinue("cause us to freeze")
    End If
    
    If sdCnt Then
        Application.CalculateFullRebuild
        If suppSucc Then
            'DO NOTHING
        Else
            ilwp "Calculated!"
        End If
    End If
End Sub

Sub convertRNOrArrayOfRNsToArrayOfRNs(ByRef out_arrOfRNs As Variant, ByRef out_numRNs As Variant, valRNOrArrayOfValRNs As Variant)
    
    Dim arrOfRNs As Variant
    arrOfRNs = wrapInArrayIfNotAlreadyAnArray(valRNOrArrayOfValRNs)
    
    Dim numRNs As Long
    numRNs = dimSize(arrOfRNs, 1)
    
    out_arrOfRNs = arrOfRNs
    out_numRNs = numRNs
End Sub

'showPopupWhenNonNumericKeyIsPassedIn = true
Function lookupInDictionarySimilarToButMaybeNotExactlyLikeLikeVLOOKUPWhenYouLookForTheLargestValueThatIsLessThanOrEqualToOurSearchValue(valueByName As Dictionary, valueWeAreSearchingFor As Variant, valueToUseWhenCannotBeFound As Variant, ByRef mod_emgsIfShouldLogErrorsOrNothingIfShouldShowPopupInstead As Variant) As Variant

    Dim chosenValue As Variant
    If Not isNumber(valueWeAreSearchingFor) Then
        Dim emsg As String
        emsg = "You did not pass in a numeric key."
        If isNothing(mod_emgsIfShouldLogErrorsOrNothingIfShouldShowPopupInstead) Then
            elwp emsg
        Else
            mod_emgsIfShouldLogErrorsOrNothingIfShouldShowPopupInstead.add emsg
        End If
        atr chosenValue, valueToUseWhenCannotBeFound
    Else
    
        Dim searchValueAsNumber As Double
        searchValueAsNumber = CDbl(valueWeAreSearchingFor)
    
        Dim keys As Variant
        keys = valueByName.keys()
        
        Dim lwr As Long
        Dim upr As Long
        glaubs keys, lwr, upr
        
        Dim numericalKeys As Collection
        Set numericalKeys = New Collection
        
        Dim foundNonNumericKey As Boolean
        foundNonNumericKey = False
        
        Dim origKeyByNumKey As Dictionary
        Set origKeyByNumKey = New Dictionary
        
        Dim c As Long
        For c = lwr To upr
            Dim curKey As Variant
            atr curKey, keys(c)
            
            If isNumber(curKey) Then
                numericalKeys.add CDbl(curKey)
            Else
                foundNonNumericKey = True
            End If
            
            atd origKeyByNumKey, CDbl(curKey), curKey
        Next
        
        If foundNonNumericKey Then
            elwp "Found one or more non-numeric keys."
            atr chosenValue, valueToUseWhenCannotBeFound
        Else
            Dim sortedKeys As Collection
            Set sortedKeys = sortCollection(numericalKeys)
            
            If sortedKeys.count <= 0 Then
                chosenValue = valueToUseWhenCannotBeFound
            Else
                
                Dim theChosenValue As Variant
                Set theChosenValue = Nothing
                
                Dim cnt As Long
                cnt = sortedKeys.count
                
                While isNothing(theChosenValue) And (cnt >= 1)
                
                    Dim candidateKey As Double
                    candidateKey = sortedKeys.item(cnt)
                    
                    If candidateKey <= searchValueAsNumber Then
                    
                        Dim origKey As Variant
                        atr origKey, vfd(origKeyByNumKey, candidateKey, True)
                    
                        theChosenValue = vfd(valueByName, origKey, True)
                    End If
                
                    cnt = cnt - 1
                Wend
                
                If isNothing(theChosenValue) Then
                    chosenValue = valueToUseWhenCannotBeFound
                Else
                    chosenValue = theChosenValue
                End If
            End If
        End If
        
    End If
    
    atr lookupInDictionarySimilarToButMaybeNotExactlyLikeLikeVLOOKUPWhenYouLookForTheLargestValueThatIsLessThanOrEqualToOurSearchValue, chosenValue

End Function

'assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeIntheTree = false
Function lookupFromDictionaryAndReturnNAIfNotFound(dict As Dictionary, keyOrNestedPath As Variant) As Variant
    
    Dim assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree As Boolean
    assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree = True '<-- true, because this is our intention
    
    Dim nestedPath As Variant
    nestedPath = ensureValueIsAnArray(keyOrNestedPath)
    
    Dim shouldCastKeyToStringIfHelpsFindValue As Boolean
    shouldCastKeyToStringIfHelpsFindValue = False
    
    If nestedPathExists(dict, nestedPath, shouldCastKeyToStringIfHelpsFindValue, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree) Then
        lookupFromDictionaryAndReturnNAIfNotFound = getValueForNestedDictionaryPath(dict, nestedPath, True, assumeThatNestedPathIsSupposedToBringUsToTheLeafNodeInTheTree)
    Else
        lookupFromDictionaryAndReturnNAIfNotFound = getExcelNAError()
    End If
End Function

Function getExcelNAError() As Variant
    getExcelNAError = CVErr(xlErrNA)
End Function

'showMsgPopUpWhenDuplicateValuesAreFound = true
'shouldSuppressDuplicateIDsErrorIfLookedUpValuesWouldBeTheSame = false
Function getValueByNameSimilarToHowVLookupWouldDoIt(rnForLookup As String, optWS As Worksheet, showMsgPopUpWhenDuplicateValuesAreFound As Boolean, ByRef mod_optEMsgsIfShouldLogDupeErrors As Variant, shouldSuppressDuplicateIDsErrorIfLookedUpValuesWouldBeTheSame As Boolean) As Dictionary
    
    Dim origSel As Range
    Set origSel = getCurSel()
    
    Dim valueByName As Dictionary
    Set valueByName = New Dictionary
    
    Dim theRnge As Range
    Set theRnge = rnge(rnForLookup, optWS)
    
    Dim nameCol As Long
    Dim valueCol As Long
    nameCol = theRnge.column
    valueCol = brcor(theRnge).column
    
    Dim firstCellInNameCol As Range
    Set firstCellInNameCol = gcirsc(tlcor(rnge(rnForLookup, optWS)), nameCol)
    
    Dim lastCellInNameCol As Range
    Set lastCellInNameCol = lastCellInColumn(firstCellInNameCol, False)
    
    Dim startRow As Long
    startRow = firstCellInNameCol.row
    
    Dim lastRow As Long
    lastRow = lastCellInNameCol.row
    
    Dim row As Long
    For row = startRow To lastRow
    
        Dim curNameCell As Range
        Set curNameCell = gcicsr(firstCellInNameCol, row)
    
        Dim curName As String
        curName = CStr(gvl(curNameCell))
        
        Dim curValue As Variant
        curValue = gvl(gcirsc(curNameCell, valueCol))
        
        
        
        
        If Trim(curName) = "" Then
            'DO NOTHING
        ElseIf valueByName.exists(curName) Then
        
            Dim oldValue As Variant
            oldValue = vfd(valueByName, curName, True)
            
            If valuesAreEqual(oldValue, curValue) And shouldSuppressDuplicateIDsErrorIfLookedUpValuesWouldBeTheSame Then
                'DO NOTHING
            Else
            
                Dim daEmsg As String
                daEmsg = "The name '" & curName & "' appears more than once.  We will just use the first instance of it."
                
                If showMsgPopUpWhenDuplicateValuesAreFound Then
                    
                    srg curNameCell
                    elwp daEmsg
                    sris origSel
                Else
                    'DO NOTHING
                End If
                If isNothing(mod_optEMsgsIfShouldLogDupeErrors) Then
                    'DO NOTHING
                Else
                    mod_optEMsgsIfShouldLogDupeErrors.add daEmsg
                End If
            End If
        
        Else
            atd valueByName, curName, curValue
        End If
    Next
    
    Set getValueByNameSimilarToHowVLookupWouldDoIt = valueByName
End Function

Sub writeValuesToRowInColumns(listOf_anyCellInColumn As Collection, listOf_theValsForOneRow As Collection, startingRow As Long)
    
    Dim origCalc As Variant
    origCalc = tsctm()
    
    Dim curRow As Long
    curRow = startingRow
    
    Dim x As Long
    For x = 1 To listOf_theValsForOneRow.count
        Dim theValsForOneRow As Collection
        Set theValsForOneRow = listOf_theValsForOneRow.item(x)
        
        Dim sz As Long
        sz = ccsz(Array(listOf_anyCellInColumn, theValsForOneRow), True)
        
        Dim d As Long
        For d = 1 To sz
        
            Dim anyCellInTheCol As Range
            Dim theVal As Variant
            Set anyCellInTheCol = listOf_anyCellInColumn.item(d)
            atr theVal, theValsForOneRow.item(d)
            
            Dim dataCell As Range
            Set dataCell = gcicsr(anyCellInTheCol, curRow)
            
            If d = 1 Then
                srg dataCell
            End If
        
            svl dataCell, theVal
            
        Next
        
        curRow = curRow + 1
        
    Next
    
    rok origCalc
End Sub

Function replaceSrcFieldNamesWithSrcRNs_in_listOfSrcFieldNameAndDestRN(listOf_srcFieldNameAndDestRN As Collection, matchCase As Boolean, srcWS As Worksheet, headerRowInSource As Long, convertHeaderCellsToGeneralFormatBeforeSearch_thisIsWeirdButFoundACaseWhereACustomNumberFormatPreventedMeFromFindingACellWhenLookingForExactMatchInCell As Boolean, ByRef mod_emsgs__orNothingToShowPopupInstead As Variant, weExpectEverythingToBeFound As Boolean) As Collection

    Dim origSel As Range
    Set origSel = getCurSel()

    Dim listOf_srcRNAndDestRN As Collection
    If isNothing(srcWS) Then
        elwp "Please pass in a src worksheet!"
        Set listOf_srcRNAndDestRN = Nothing
    Else
        
        Dim searchArea As Range
        Set searchArea = rnge(headerRowInSource & ":" & headerRowInSource, srcWS)
        
        srg searchArea
        

        If convertHeaderCellsToGeneralFormatBeforeSearch_thisIsWeirdButFoundACaseWhereACustomNumberFormatPreventedMeFromFindingACellWhenLookingForExactMatchInCell Then
            setNumberFormat searchArea, NUMBER_FORMAT_GENERAL
        End If
        
        Set listOf_srcRNAndDestRN = New Collection

        Dim c As Long
        For c = 1 To listOf_srcFieldNameAndDestRN.count
        
            Dim srcFieldNameAndDestRN As Variant
            srcFieldNameAndDestRN = listOf_srcFieldNameAndDestRN.item(c)
        
            Dim srcFieldName As String
            Dim destRN As String
            srcFieldName = rlai(srcFieldNameAndDestRN, 1)
            destRN = rlai(srcFieldNameAndDestRN, 2)
            
            Dim srcRN_destRN As Variant
            If Trim(srcFieldName) = "" Then
                srcRN_destRN = Array("", destRN)
            Else
            
                Dim foundCell As Range
                Set foundCell = findCell(searchArea, srcFieldName, matchCase, True)
                
                If isNothing(foundCell) Then
                    
                    Dim daMsg As String
                    daMsg = "Could not copy the '" & srcFieldName & "' column, beacuse we could not find it in our source data!"
                    
                    If weExpectEverythingToBeFound Then
                        If isNothing(mod_emsgs__orNothingToShowPopupInstead) Then
                            elwp daMsg
                        Else
                            mod_emsgs__orNothingToShowPopupInstead.add daMsg
                        End If
                    End If
                    Set srcRN_destRN = Nothing
                Else
                
                    Dim srcRN As String
                    srcRN = getFullRngeDefinition(foundCell, False, True, True, False)
                
                    srcRN_destRN = Array(srcRN, destRN)
                End If
            End If
            
            If isNothing(srcRN_destRN) Then
                'DO NOTHING
            Else
                listOf_srcRNAndDestRN.add srcRN_destRN
            End If
        Next
        
        
        
    End If
    
    sris origSel
    
    Set replaceSrcFieldNamesWithSrcRNs_in_listOfSrcFieldNameAndDestRN = listOf_srcRNAndDestRN
    
End Function

Function copyDataFromMultipleWorksheetsIntoSingleWorksheetAndMarkEachPieceOfDataWithTheNameOfTheWorksheetItCameFrom(wsToCopyInto As Worksheet, listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Collection, rnInDestForDataSource As String, firstDataRow As Long, sourceWB As Workbook, ByRef mod_emsgs As Variant, weExpectEverythingToBeFound As Boolean) As Long
    copyDataFromMultipleWorksheetsIntoSingleWorksheetAndMarkEachPieceOfDataWithTheNameOfTheWorksheetItCameFrom = copyDataFromMultipleWorksheetsIntoSingleWorksheetAndMarkEachPieceOfDataWithIndicationOfWhereItCameFrom(wsToCopyInto, listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, rnInDestForDataSource, firstDataRow, sourceWB, mod_emsgs, Nothing, False, weExpectEverythingToBeFound)
End Function

'removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows = false
Function copyDataFromMultipleWorksheetsIntoSingleWorksheetAndMarkEachPieceOfDataWithIndicationOfWhereItCameFrom(wsToCopyInto As Worksheet, listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Collection, rnInDestForDataSource As String, firstDataRowToWriteTo As Long, sourceWB As Workbook, ByRef mod_emsgs As Variant, dataSourceNames_orNothingToUseSrcWSNamesAsDataSourceNames As Collection, removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows As Variant, weExpectEverythingToBeFound As Boolean) As Long
 
    Dim listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab As Collection
    Dim listOfDataSources As Collection
    Set listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab = figureOutWhatDataWeNeedToCopyInFromTheVariousTabs(listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, sourceWB, mod_emsgs, True, listOfDataSources, dataSourceNames_orNothingToUseSrcWSNamesAsDataSourceNames, removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows, weExpectEverythingToBeFound)
    
    Dim nextRowToWriteInto As Long
    nextRowToWriteInto = performTheActualCopyOfData(listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab, wsToCopyInto, firstDataRowToWriteTo, rnInDestForDataSource, listOfDataSources)
    
    copyDataFromMultipleWorksheetsIntoSingleWorksheetAndMarkEachPieceOfDataWithIndicationOfWhereItCameFrom = nextRowToWriteInto
End Function

Sub copyTheDataFromMultipleWorksheetsIntoSingleWorksheetAndMarkEachPieceOfDataWithTheNameOfTheWorksheetItCameFrom(wsToCopyInto As Worksheet, listOf__tabName_listOfSrcNameAndDestRN_optionalFilterColumnAnchorAndDesiredValuesSet_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Collection, rnInDestForDataSource As String, firstDataRowToWriteTo As Long, sourceWB As Workbook, ByRef mod_emsgs As Variant, avoidWhitespaceAtEdgesWhenFiltering As Boolean, shouldTakeAbsoluteValueForAllNumbers As Boolean)
    
    Dim tabNames_listsOfSrcNameAndDestRN_listOfOptionalFilterColumnAnchorAndDesiredValuesSet_listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Collection
    Set tabNames_listsOfSrcNameAndDestRN_listOfOptionalFilterColumnAnchorAndDesiredValuesSet_listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName = sciloar(True, listOf__tabName_listOfSrcNameAndDestRN_optionalFilterColumnAnchorAndDesiredValuesSet_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName)
    
    Dim tabNames As Collection
    Dim listsOfSrcNameAndDestRN As Collection
    Dim listOfOptionalFilterColumnAnchorAndDesiredValuesSet As Collection
    Dim listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Collection
    Set tabNames = tabNames_listsOfSrcNameAndDestRN_listOfOptionalFilterColumnAnchorAndDesiredValuesSet_listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName.item(1)
    Set listsOfSrcNameAndDestRN = tabNames_listsOfSrcNameAndDestRN_listOfOptionalFilterColumnAnchorAndDesiredValuesSet_listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName.item(2)
    Set listOfOptionalFilterColumnAnchorAndDesiredValuesSet = tabNames_listsOfSrcNameAndDestRN_listOfOptionalFilterColumnAnchorAndDesiredValuesSet_listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName.item(3)
    Set listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName = tabNames_listsOfSrcNameAndDestRN_listOfOptionalFilterColumnAnchorAndDesiredValuesSet_listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName.item(4)

    Dim optionalFilterColumnAnchorAndDesiredValuesSet_byTabName As Dictionary
    Set optionalFilterColumnAnchorAndDesiredValuesSet_byTabName = New Dictionary
    Dim sze As Long
    sze = ccsz(Array(tabNames, listOfOptionalFilterColumnAnchorAndDesiredValuesSet), True)
    Dim eky As Long
    For eky = 1 To sze
        Dim tName As String
        Dim optFilterColumnAnchorAndDesiredValuesSet As Variant
        tName = tabNames.item(eky)
        atr optFilterColumnAnchorAndDesiredValuesSet, listOfOptionalFilterColumnAnchorAndDesiredValuesSet.item(eky)
        
        If isNothing(optFilterColumnAnchorAndDesiredValuesSet) Then
            'DO NOTHING
        Else
            atd optionalFilterColumnAnchorAndDesiredValuesSet_byTabName, tName, optFilterColumnAnchorAndDesiredValuesSet
        End If
    Next
    
    Dim listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Collection
    Set listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName = convertListOfColumnDataIntoListOfArrayRows(arrayToCollection(Array(tabNames, listsOfSrcNameAndDestRN, listOfAnyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName)), 1, COL_DATA_TYPE_COLLECTION)
    
    Dim listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab As Collection
    Dim listOfDataSources As Collection
    Set listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab = figureOutWhatDataWeNeedToCopyInFromTheVariousTabs(listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, sourceWB, mod_emsgs, False, listOfDataSources, Nothing, False)
    
    Dim adjustedListOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab As Collection
    Set adjustedListOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab = New Collection
    
    Dim sz As Long
    sz = ccsz(Array(listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab, listOfDataSources), True)
    
    Dim c As Long
    For c = 1 To sz
        Dim listOf____destRN_DataToCopyIn As Collection
        Set listOf____destRN_DataToCopyIn = listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab.item(c)
        
        Dim dataSource As String
        dataSource = listOfDataSources.item(c)
        
        Dim optionalFilterColumnAnchorAndDesiredValuesSet As Variant
        atr optionalFilterColumnAnchorAndDesiredValuesSet, vfd(optionalFilterColumnAnchorAndDesiredValuesSet_byTabName, dataSource, False)
        
        Dim optFilterFlags As Collection
        If isNothing(optionalFilterColumnAnchorAndDesiredValuesSet) Then
            Set optFilterFlags = Nothing
        Else
            Dim filterColAnchor As Range
            Dim desiredValuesSet As JYCORE_Set
            Set filterColAnchor = rlai(optionalFilterColumnAnchorAndDesiredValuesSet, 1)
            Set desiredValuesSet = rlai(optionalFilterColumnAnchorAndDesiredValuesSet, 2)
            
            Dim filterColValues As Collection
            Set filterColValues = getColumnData(filterColAnchor)
            
            Set optFilterFlags = New Collection
            Dim cd As Long
            For cd = 1 To filterColValues.count
                Dim testValue As Variant
                testValue = filterColValues.item(cd)
                
                If avoidWhitespaceAtEdgesWhenFiltering Then
                    testValue = Trim(testValue)
                End If
            
                If desiredValuesSet.exists(testValue) Then
                    optFilterFlags.add True
                Else
                    optFilterFlags.add False
                End If
            Next
        End If
        
        
        Dim listOf_destRNAndAdjustedDataToCopyIn As Collection
        Set listOf_destRNAndAdjustedDataToCopyIn = New Collection
        
        
        
        Dim cnt As Long
        For cnt = 1 To listOf____destRN_DataToCopyIn.count
        
            Dim destRN_DataToCopyIn As Variant
            destRN_DataToCopyIn = listOf____destRN_DataToCopyIn.item(cnt)
            
            Dim destRN As String
            Dim dataToCopyIn As Collection
            Dim optionalFilterFieldRNAndDesiredValue As Variant
            destRN = rlai(destRN_DataToCopyIn, 1)
            Set dataToCopyIn = rlai(destRN_DataToCopyIn, 2)
            
            Dim adjustedDataToCopyIn As Collection
            If isNothing(optFilterFlags) Then
                Set adjustedDataToCopyIn = dataToCopyIn
            Else
                Set adjustedDataToCopyIn = New Collection
                Dim maxCnt As Long
                maxCnt = wsFunctionMin(optFilterFlags.count, dataToCopyIn.count)
                
                Dim y As Long
                For y = 1 To maxCnt
                    Dim shouldInc As Boolean
                    Dim dataCandidate As Variant
                    shouldInc = optFilterFlags.item(y)
                    dataCandidate = dataToCopyIn.item(y)
                    
                    If shouldInc Then
                    
                        If shouldTakeAbsoluteValueForAllNumbers Then
                            If isNumber(dataCandidate) Then
                                adjustedDataToCopyIn.add Abs(dataCandidate)
                            Else
                                adjustedDataToCopyIn.add dataCandidate
                            End If
                        Else
                            adjustedDataToCopyIn.add dataCandidate
                        End If
                    Else
                        'DO NOTHING
                    End If
                Next
            End If
            
            
            
            Dim destRN_adjustedDataToCopyIn As Variant
            destRN_adjustedDataToCopyIn = Array(destRN, adjustedDataToCopyIn)
            
            listOf_destRNAndAdjustedDataToCopyIn.add destRN_adjustedDataToCopyIn
        Next
        
        
        adjustedListOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab.add listOf_destRNAndAdjustedDataToCopyIn
    Next
    
    Dim nextRowToWriteInto As Long
    nextRowToWriteInto = performTheActualCopyOfData(adjustedListOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab, wsToCopyInto, firstDataRowToWriteTo, rnInDestForDataSource, listOfDataSources)
    
    copyTheDataFromMultipleWorksheetsIntoSingleWorksheetAndMarkEachPieceOfDataWithTheNameOfTheWorksheetItCameFrom = nextRowToWriteInto
End Sub
'removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows = false
Function figureOutWhatDataWeNeedToCopyInFromTheVariousTabs(listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Collection, sourceWB As Workbook, ByRef mod_emsgs As Variant, useRngesWhenPossible As Boolean, ByRef out_dataSources As Collection, dataSourceNames_orNothingToUseSrcWSNamesAsDataSourceNames As Collection, removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows As Variant, weExpectEverythingToBeFound As Boolean)
    
    Dim listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab As Collection
    Dim dataSources As Collection
    Set listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab = New Collection
    Set dataSources = New Collection
    
    Dim sz As Long
    If isNothing(dataSourceNames_orNothingToUseSrcWSNamesAsDataSourceNames) Then
        sz = listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName.count
    Else
        sz = ccsz(Array(listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, dataSourceNames_orNothingToUseSrcWSNamesAsDataSourceNames), True)
    End If
    
    Dim c As Long
    For c = 1 To sz
        
        Dim tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Variant
        tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName = listOf__tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName.item(c)
    
        Dim curTabName As String
        Dim listOf__srcName_destRN As Collection
        Dim anyfieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Variant
        curTabName = rlai(tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, 1)
        Set listOf__srcName_destRN = rlai(tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, 2)
        anyfieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName = rlai(tabname_listOfSrcNameAndDestRN_anyFieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, 3)
        
        Dim curWS As Worksheet
        Set curWS = getWorksheet(sourceWB, curTabName)
        
        Dim dataSource As String
        If isNothing(dataSourceNames_orNothingToUseSrcWSNamesAsDataSourceNames) Then
            dataSource = curWS.name
        Else
            dataSource = dataSourceNames_orNothingToUseSrcWSNamesAsDataSourceNames.item(c)
        End If
        
        If isNothing(curWS) Then
            mod_emsgs.add "Could not find the worksheet named '" & curTabName
        Else
        
            Dim listOf_destRNAndDataOrRngeToCopyIn As Collection
            Set listOf_destRNAndDataOrRngeToCopyIn = figureOutWhatDataWeNeedToCopyInFromParticularTab(curWS, anyfieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, listOf__srcName_destRN, mod_emsgs, useRngesWhenPossible, removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows, weExpectEverythingToBeFound)
            
            If isNothing(listOf_destRNAndDataOrRngeToCopyIn) Then
                'DO NOTHING
            Else
                
                listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab.add listOf_destRNAndDataOrRngeToCopyIn
                dataSources.add dataSource
            End If
        End If
        
    Next
    
    Set out_dataSources = dataSources
    Set figureOutWhatDataWeNeedToCopyInFromTheVariousTabs = listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab
    
End Function

Function performTheActualCopyOfData(listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab As Collection, wsToCopyInto As Worksheet, firstDataRowToWriteTo As Long, rnInDestForDataSource As String, listOfDataSources As Collection) As Long

    Dim origCalc As Variant
    origCalc = tsctm()

    Dim nextRowToWriteInto As Long
    nextRowToWriteInto = firstDataRowToWriteTo
    
    Dim size As Long
    size = ccsz(Array(listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab, listOfDataSources), True)
    
    Dim cnt As Long
    For cnt = 1 To size
    
        Dim dataSource As String
        dataSource = listOfDataSources.item(cnt)
        
        Dim listOf_rnAndSingleValueToFillIn As Collection
        Set listOf_rnAndSingleValueToFillIn = New Collection
        With listOf_rnAndSingleValueToFillIn
            .add Array(rnInDestForDataSource, dataSource)
        End With

        Dim listOf_destRNAndDataOrRngeToCopyIn As Collection
        Set listOf_destRNAndDataOrRngeToCopyIn = listOf_informationWeNeedToCopyDataFromOneParticularTabIntoOurDestinationTab.item(cnt)

        nextRowToWriteInto = writeColDataIntoListOfRNsAndCompletelyFillCertainColumnsWithSingleValues(listOf_destRNAndDataOrRngeToCopyIn, wsToCopyInto, nextRowToWriteInto, listOf_rnAndSingleValueToFillIn, False)
        
    Next
    
    rok origCalc
    
    performTheActualCopyOfData = nextRowToWriteInto

End Function

Function writeColDataIntoListOfRNsAndCompletelyFillCertainColumnsWithSingleValues(listOf_destRNAndDataOrRngeToCopyIn As Collection, wsToCopyInto As Worksheet, nextRowToWriteInto As Long, listOf_rnAndSingleValueToFillIn As Collection, writeAtLeastOneRowOfSingleValuesNoMatterWhat As Boolean) As Long
    
    Dim firstRowWrittenTo As Long
    Dim lastRowWrittenTo As Long
    writeColDataIntoListOfRNs listOf_destRNAndDataOrRngeToCopyIn, wsToCopyInto, firstRowWrittenTo, lastRowWrittenTo, nextRowToWriteInto
    
    If firstRowWrittenTo <> -1 And lastRowWrittenTo <> -1 Then
        Dim cnt As Long
        For cnt = 1 To listOf_rnAndSingleValueToFillIn.count
        
            Dim rnAndSingleValueToFillIn As Variant
            rnAndSingleValueToFillIn = listOf_rnAndSingleValueToFillIn.item(cnt)
        
            Dim curRN As String
            Dim curSingleValue As Variant
            curRN = rlai(rnAndSingleValueToFillIn, 1)
            curSingleValue = rlai(rnAndSingleValueToFillIn, 2)
            
            Dim lngth As Long
            lngth = lastRowWrittenTo - firstRowWrittenTo + 1
            
            Dim singleValues As Variant
            ReDim singleValues(1 To lngth)
            Dim c As Long
            For c = 1 To lngth
                singleValues(c) = curSingleValue
            Next
            
            
            
            setColDataOrFormulasStartingInCell gcicsr(rnge(curRN, wsToCopyInto), firstRowWrittenTo), singleValues, True, False
        Next
    End If
    
    If firstRowWrittenTo <> nextRowToWriteInto Then
        elwp_se
    End If
    
    writeColDataIntoListOfRNsAndCompletelyFillCertainColumnsWithSingleValues = lastRowWrittenTo + 1
    
End Function

Function addBBGHyperlinkTextToNavigateToYTScreen(securityID As String) As String
    addBBGHyperlinkTextToNavigateToYTScreen = "{nxtw " & securityID & " mtge YT<go>}"
End Function

Function booleansToStringFlags(arr As Variant) As String
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim stringSoFar As String
    stringSoFar = ""
    
    Dim c As Long
    For c = lwr To upr
        Dim bool As Boolean
        bool = arr(c)
        
        stringSoFar = stringSoFar & IIf(bool, FLAG_STRING_TRUE, FLAG_STRING_FALSE)
    Next
    
    booleansToStringFlags = stringSoFar
    
End Function

Function getAllCombinationsOfBooleanFlagStrings(numLevels As Long) As Variant
    
    Dim possibleValuesAtEachLevel As Variant
    ReDim possibleValuesAtEachLevel(1 To numLevels)
    
    Dim eee As Long
    For eee = 1 To numLevels
        possibleValuesAtEachLevel(eee) = Array(FLAG_STRING_TRUE, FLAG_STRING_FALSE)
    Next
    
    getAllCombinationsOfBooleanFlagStrings = getAllPossibleDifferentCombinations_returnString(possibleValuesAtEachLevel, "")
    
End Function

Function getAllPossibleDifferentCombinations_returnString(possibleValuesAtEachLevel As Variant, optDelim As String) As Variant
    
    Dim combos As Variant
    combos = getAllPossibleDifferentCombinations(possibleValuesAtEachLevel)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs combos, lwr, upr
    
    Dim newCombos As Variant
    ReDim newCombos(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim combo As Variant
        combo = combos(c)
        
        newCombos(c) = arrayToString(combo, optDelim, "")
    Next
    
    getAllPossibleDifferentCombinations_returnString = newCombos

End Function

Function getAllPossibleDifferentCombinations(possibleValuesAtEachLevel As Variant) As Variant

    Dim numLevels As Long
    numLevels = dimSize(possibleValuesAtEachLevel, 1)

    If numLevels <= 0 Then
        Set getAllPossibleDifferentCombinations = Nothing
    Else
    
        Dim possibleValues As Variant
        atr possibleValues, ensureValueIsAnArray(rlai(possibleValuesAtEachLevel, 1))
    
        Dim combosSoFar As Variant
        combosSoFar = wrapEachArrayElementInItsOwnArray(possibleValues)
        
        Dim c As Long
        For c = 2 To numLevels
        
            Dim possibleValuesAtLevelC As Variant
            possibleValuesAtLevelC = ensureValueIsAnArray(rlai(possibleValuesAtEachLevel, c))
            
            combosSoFar = pairUpEachArrayRowWithEachElementInASeparateSingleDimensionArray(combosSoFar, possibleValuesAtLevelC)
        
        Next
        getAllPossibleDifferentCombinations = combosSoFar
    End If
        
    
End Function

Function pairUpEachArrayRowWithEachElementInASeparateSingleDimensionArray(combosSoFar As Variant, possibleValuesAtLevelC As Variant) As Variant

    Dim size As Long
    size = dimSize(combosSoFar, 1)
    
    Dim numPossibleValuesAtLevelC As Long
    numPossibleValuesAtLevelC = dimSize(possibleValuesAtLevelC, 1)
    
    Dim newCombos As Variant
    ReDim newCombos(1 To size * numPossibleValuesAtLevelC)
    
    
    Dim nextIndex As Long
    nextIndex = 1
    
    Dim d As Long
    For d = 1 To size
    
        Dim xyz As Long
        For xyz = 1 To numPossibleValuesAtLevelC
        
            Dim arrSoFar As Variant
            arrSoFar = rlai(combosSoFar, d)
            
            Dim lw As Long
            Dim hg As Long
            glaubs arrSoFar, lw, hg
            
            Dim NewArr As Variant
            ReDim NewArr(lw To hg + 1)
            copyArrIntoAnotherArrAtSameIndexes arrSoFar, NewArr, lw, hg
            NewArr(hg + 1) = rlai(possibleValuesAtLevelC, xyz)
            newCombos(nextIndex) = NewArr
            nextIndex = nextIndex + 1
        Next
    Next
    
    pairUpEachArrayRowWithEachElementInASeparateSingleDimensionArray = newCombos
End Function



Sub swap(ByRef mod_a As Variant, ByRef mod_b As Variant)
    Dim Temp As Variant
    atr Temp, mod_a
    atr mod_a, mod_b
    atr mod_b, Temp
End Sub
Function GetUserName(viaWindowsFunctionVsEnvironVariable As Boolean) As String
    If viaWindowsFunctionVsEnvironVariable Then
        GetUserName = GetUserNameViaWindowsFunction()
    Else
        GetUserName = Environ$("username")
    End If
End Function

Function getHostName() As String
    getHostName = Environ$("computername")
End Function

Function userIsInProcessOfCutOrCopy()
    Dim ccMode As Variant
    ccMode = Application.CutCopyMode
    userIsInProcessOfCutOrCopy = ((ccMode = xlCut) Or (ccMode = xlCopy))
End Function

'JY20120823a - start - renamed this to "getAllWorksheetsInAllWorkbooksOfApplication"
'Function getAllWorksheetsInApplication() As Collection'
'
'    Dim worksheets As Collection
'    Set worksheets = New Collection
'
'    Dim wb As Workbook
'    For Each wb In Application.Workbooks
'        addAllWorksheetsInWorkbookToPassedInCollection worksheets, wb
'    Next
'
'
'    Set getAllWorksheetsInApplication = worksheets
'
'End Function
'JY20120823a - end

Function searchWorkbooksForTabWithSpecificName(wbs As Collection, tabName As String) As Collection
    
    Dim candidateTabs As Collection
    Set candidateTabs = New Collection
    
    Dim c As Long
    For c = 1 To wbs.count
        Dim wb As Workbook
        Set wb = wbs.item(c)
        
        Dim dailySummaryTabToAdjust As Worksheet
        Set dailySummaryTabToAdjust = getWorksheet(wb, tabName)
        
        If isNothing(dailySummaryTabToAdjust) Then
            'DO NOTHING
        Else
            candidateTabs.add dailySummaryTabToAdjust
        End If
    Next
    
    Set searchWorkbooksForTabWithSpecificName = candidateTabs
    
End Function

Function getAllOtherWorkbooksInApplication(wbToExclude As Workbook) As Collection

    Dim wbs As Collection
    Set wbs = getAllWorkbooksInApplication()
    
    Dim candidateWBs As Collection
    Set candidateWBs = New Collection
    
    Dim c As Long
    For c = 1 To wbs.count
        Dim wb As Workbook
        Set wb = wbs.item(c)
        
        If wb Is wbToExclude Then
            'DO NOTHING
        Else
            candidateWBs.add wb
        End If
    Next
    
    Set getAllOtherWorkbooksInApplication = candidateWBs
End Function


Function getAllWorkbooksInApplication() As Collection

    Dim theWorkbooks As Collection
    Set theWorkbooks = New Collection
    
    Dim wb As Workbook
    For Each wb In Application.Workbooks
        theWorkbooks.add wb
    Next
    
    
    Set getAllWorkbooksInApplication = theWorkbooks
    
End Function

Function getAllWorksheetsInWorkbook(wb As Workbook) As Collection

    Dim worksheets As Collection
    Set worksheets = New Collection
    
    addAllWorksheetsInWorkbookToPassedInCollection worksheets, wb

    Set getAllWorksheetsInWorkbook = worksheets
    
End Function

Function getAllWorksheetsInAllWorkbooksOfApplication() As Collection

    Dim list As Collection
    Set list = New Collection
    
    Dim wbs As Collection
    Set wbs = getAllWorkbooksInApplication()
    
    Dim c As Long
    For c = 1 To wbs.count
        Dim wb As Workbook
        Set wb = wbs.item(c)
        
        addCollectionToCollection list, getAllWorksheetsInWorkbook(wb)
    Next
    
    Set getAllWorksheetsInAllWorkbooksOfApplication = list

End Function

Sub addAllWorksheetsInWorkbookToPassedInCollection(ByRef mod_coll As Collection, wb As Workbook)

    Dim ws As Worksheet
    For Each ws In wb.worksheets
        mod_coll.add ws
    Next

End Sub

'removeBlankRows = false
Function figureOutWhatDataWeNeedToCopyInFromParticularTab(curWS As Worksheet, anyfieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName As Variant, listOf__srcName_destRN As Collection, ByRef mod_emsgs As Variant, useRngesWhenPossible As Boolean, removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows As Variant, weExpectEverythingToBeFound As Boolean)

    Dim zEmsg As String
    zEmsg = "ERROR: NOT SET!"
    
    Dim headerRowInSource_orNothingIfSrcNameIsRNVsFieldName As Variant
    If anyfieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName = "" Then
        Set headerRowInSource_orNothingIfSrcNameIsRNVsFieldName = Nothing
        zEmsg = ""
    Else
        Dim foundHeaderCell As Range
        Set foundHeaderCell = findCell_specifySearchOrder(curWS.UsedRange, anyfieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName, False, xlByRows, True, True)
    
        If isNothing(foundHeaderCell) Then
        
            zEmsg = "Could not figure out what row is the header row in the worksheet '" & curWS.name & "' (and hence we can't copy any data from it)." & CHAR_CRLF & CHAR_CRLF & "We were looking for a cell with the value '" & anyfieldNameWeExpectToSeeOrBlankStringIfSrcNameIsRNVersusFieldName & "'."
            headerRowInSource_orNothingIfSrcNameIsRNVsFieldName = -1
        Else
            headerRowInSource_orNothingIfSrcNameIsRNVsFieldName = foundHeaderCell.row
            zEmsg = ""
        End If
        
    End If
    
    Dim listOf_destRNAndDataOrRngeToCopyIn As Collection
    If zEmsg <> "" Then
        mod_emsgs.add zEmsg
        Set listOf_destRNAndDataOrRngeToCopyIn = Nothing
    Else
        
        Dim srcWS As Worksheet
        Dim listOf_srcNameAndDestRN As Collection
        Set srcWS = curWS
        Set listOf_srcNameAndDestRN = listOf__srcName_destRN
        
    
        Dim listOf_srcRNAndDestRN As Collection
        If Not isNothing(headerRowInSource_orNothingIfSrcNameIsRNVsFieldName) Then
            Set listOf_srcRNAndDestRN = replaceSrcFieldNamesWithSrcRNs_in_listOfSrcFieldNameAndDestRN(listOf_srcNameAndDestRN, False, srcWS, CLng(headerRowInSource_orNothingIfSrcNameIsRNVsFieldName), True, mod_emsgs, weExpectEverythingToBeFound)
        Else
            Set listOf_srcRNAndDestRN = listOf_srcNameAndDestRN
        End If
        
        Set listOf_destRNAndDataOrRngeToCopyIn = figureOutWhatDataShouldBeWritten(listOf_srcRNAndDestRN, srcWS, useRngesWhenPossible, removeBlankRows_orDestRNsWhoseDataShouldBeLookedAtWhenFilteringOutBlankRows)
        
    End If
    Set figureOutWhatDataWeNeedToCopyInFromParticularTab = listOf_destRNAndDataOrRngeToCopyIn
End Function

Sub figureOutWhichSourceRngesToCopyWhereAsWellAsWhereWeWantToWriteAllBlankValues(ByRef out_listOf_destRNAndRngeToCopyIn As Collection, ByRef out_listOf_destRNToHardcodeBlankValuesFor As Collection, ByRef out_maxRowsOfData As Long, listOf__srcRNOrBlankStringToShowBlank_and_DestRN As Collection, optSrcWS As Worksheet)
    
    Dim listOf_destRNToHardcodeBlankValuesFor As Collection
    Set listOf_destRNToHardcodeBlankValuesFor = New Collection
    
    Dim listOf_destRNAndRngeToCopyIn As Collection
    Set listOf_destRNAndRngeToCopyIn = New Collection
    
    Dim maxRowsOfData As Long
    maxRowsOfData = 0
    
    Dim c As Long
    For c = 1 To listOf__srcRNOrBlankStringToShowBlank_and_DestRN.count
    
        Dim srcRNAndDestRN As Variant
        srcRNAndDestRN = listOf__srcRNOrBlankStringToShowBlank_and_DestRN.item(c)
        
        Dim srcRNOrBlankStringToShowBlank As String
        Dim destRN As String
        srcRNOrBlankStringToShowBlank = rlai(srcRNAndDestRN, 1)
        destRN = rlai(srcRNAndDestRN, 2)
        
        
        If srcRNOrBlankStringToShowBlank = "" Then
            listOf_destRNToHardcodeBlankValuesFor.add destRN
        Else
        
            Dim srcAnchor As Range
            Set srcAnchor = rnge(srcRNOrBlankStringToShowBlank, optSrcWS)
            
            Dim srcDataRnge As Range
            Set srcDataRnge = getColumnDataRnge(srcAnchor)
            
            listOf_destRNAndRngeToCopyIn.add Array(destRN, srcDataRnge)
            
            
            maxRowsOfData = wsFunctionMax(maxRowsOfData, srcDataRnge.rows.count)
        End If
    Next
    
    Set out_listOf_destRNToHardcodeBlankValuesFor = listOf_destRNToHardcodeBlankValuesFor
    Set out_listOf_destRNAndRngeToCopyIn = listOf_destRNAndRngeToCopyIn
    out_maxRowsOfData = maxRowsOfData
End Sub

Function convertTheRngesToDataRows(listOf_destRNAndRngeToCopyIn As Collection) As Collection
    Dim returnColl As Collection
    Set returnColl = New Collection
    
    Dim dd As Long
    For dd = 1 To listOf_destRNAndRngeToCopyIn.count
        Dim destRNAndRngeToCopyIn As Variant
        destRNAndRngeToCopyIn = listOf_destRNAndRngeToCopyIn.item(dd)
        
        Dim destRN As String
        Dim rngeToCopyIn As Range
        destRN = rlai(destRNAndRngeToCopyIn, 1)
        Set rngeToCopyIn = rlai(destRNAndRngeToCopyIn, 2)
        
        returnColl.add Array(destRN, getColDataFromColRnge(rngeToCopyIn))
    Next
    
    Set convertTheRngesToDataRows = returnColl
End Function

Function copyFromOneRngeToAnother(srcRnge As Range, destRnge As Range, pasteModeOrListOfPasteModesInOrderOrCollectionOfPasteModesInOrder As Variant) As Range

    If Not destRnge.Worksheet.Parent Is ActiveWorkbook Then
        srg destRnge
    End If
    srcRnge.Copy
    
    Dim pms As Variant
    pms = ensureValueIsAnArray(pasteModeOrListOfPasteModesInOrderOrCollectionOfPasteModesInOrder)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs pms, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim pasteMode As Variant
        pasteMode = pms(c)
        destRnge.PasteSpecial pasteMode
    
    Next
    
    clearClipboardSelection
    
    Set copyFromOneRngeToAnother = Selection

End Function


Sub copyFormulasFromOneRngeIntoAnother(srcRnge As Range, destRnge As Range, calculateAfterCopying As Boolean)
    copyFromOneRngeToAnother srcRnge, destRnge, xlPasteFormulas
    
    If calculateAfterCopying Then
        destRnge.Calculate
    End If
End Sub

Sub setDataValidationFieldList(rnge As Range, allowedValues As Variant)

On Error GoTo ehs

    Dim formulaList As String
    formulaList = arrayToString(allowedValues, ",", "") 'Not sure what the escape character should be, so will just leave it blank for now

    With rnge.Validation
        .Delete
        .add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=formulaList
        .IgnoreBlank = True
        .InCellDropdown = True
        .InputTitle = ""
        .ErrorTitle = ""
        .InputMessage = ""
        .ErrorMessage = ""
        .ShowInput = True
        .ShowError = True
    End With
    
GoTo ehe
ehs:
    Dim origSel As Range
    Set origSel = getCurSel()
    
    sris rnge
    elwp "Unable to set data validation values list in this cell!  Msg=" & Err.description
    
    sris origSel

ehe:
On Error GoTo 0
End Sub

Function blankValueToDefaultValue(thing As Variant, defaultValue As Variant) As Variant
    If isBlankValue(thing) Then
        blankValueToDefaultValue = defaultValue
    Else
        atr blankValueToDefaultValue, thing
    End If
End Function

Function nothingToDefaultValue(thing As Variant, defaultValue As Variant) As Variant
    If isNothing(thing) Then
        atr nothingToDefaultValue, defaultValue
    Else
        atr nothingToDefaultValue, thing
    End If
End Function

Function nothingToBlankString(thing As Variant) As Variant
    nothingToBlankString = nothingToDefaultValue(thing, "")
End Function



Sub lookAtCurrentAnchorForRowAndColAndAdjustWhatWeKnowAboutTheMaxAndMinRowOrColSeenSoFar(rnge As Range, ByRef mod_minRowOrCol As Long, ByRef mod_maxRowOrCol As Long, findMinAndMaxRowsVsCols As Boolean, lastPossibleRowOrCol As Long)
    
    Dim firstDataCell As Range
    Set firstDataCell = firstDataCellInColumnOrRow(rnge, findMinAndMaxRowsVsCols)
    
    Dim firstDataRowOrCol As Long
    If findMinAndMaxRowsVsCols Then
        firstDataRowOrCol = firstDataCell.row
    Else
        firstDataRowOrCol = firstDataCell.column
    End If
    
    Dim theLastCell As Range
    Set theLastCell = lastCellInRowOrColumn_specifyAbsoluteLastRowOrColAssumption(rnge, True, lastPossibleRowOrCol, findMinAndMaxRowsVsCols)
    
    If mod_minRowOrCol = 0 Then
        mod_minRowOrCol = firstDataRowOrCol
    Else
        mod_minRowOrCol = wsFunctionMax(mod_minRowOrCol, firstDataRowOrCol)
    End If
    
    If isNothing(theLastCell) Then
        'DO NOTHING
    Else
        Dim lastDataRowOrCol As Long
        If findMinAndMaxRowsVsCols Then
            lastDataRowOrCol = theLastCell.row
        Else
            lastDataRowOrCol = theLastCell.column
        End If
        
        If mod_maxRowOrCol = 0 Then
            mod_maxRowOrCol = lastDataRowOrCol
        Else
            mod_maxRowOrCol = wsFunctionMax(mod_maxRowOrCol, lastDataRowOrCol)
        End If
    End If
End Sub

Function createWSAndInitialize(wb As Workbook, optAfter As Worksheet, desiredName As String, ByRef out_emsg As String) As Worksheet

    
    Dim ws As Worksheet
    Dim emsg As String
    Set ws = createWS(wb, desiredName, emsg, optAfter)
    
    If isNothing(ws) Then
        'DO NOTHING
    Else
        initWSForNewProject ws, True
    End If
    
    out_emsg = emsg
    Set createWSAndInitialize = ws
End Function

Function createWS(wb As Workbook, desiredName As String, ByRef out_emsg As String, optAfter As Worksheet) As Worksheet
    
    Dim existingWS As Worksheet
    Set existingWS = getWorksheet(wb, desiredName)
    
    Dim emsg As String
    emsg = "ERROR: NOT SET!"
    
    Dim ws As Worksheet
    If Not isNothing(existingWS) Then
        emsg = "A worksheet named '" & desiredName & "' already exists, so we can't create a new one.  Please delete the one that is there."
        Set ws = Nothing
    Else
        emsg = ""

        If isNothing(optAfter) Then
            Set ws = wb.worksheets.add()
        Else
            Set ws = wb.worksheets.add(after:=optAfter)
        End If
        
        setTabName ws, desiredName
    End If
    
    out_emsg = emsg
    Set createWS = ws
End Function

'setBackgroundColorToWhite = true
Sub initWSForNewProject(ws As Worksheet, setBackgroundColorToWhite As Boolean)
    If setBackgroundColorToWhite Then
        setBackground ws.cells, COLOR_WHITE_BACKGROUND_1
    End If
End Sub

'setBackgroundColorToWhite = true
Sub initWBForNewProject(wb As Workbook, ByRef out_emsg As String, setBackgroundColorToWhite As Boolean)
    
    Dim worksheets As Collection
    Set worksheets = New Collection
    
    Dim ws As Worksheet
    For Each ws In wb.worksheets
        worksheets.add ws
    Next
    Dim emsg As String
    If worksheets.count = 0 Then
        emsg = "There are no worksheets in this workbook!"
    Else
    
        Dim wsToKeep As Worksheet
        Set wsToKeep = worksheets.item(1)
    
        Dim c As Long
        For c = 2 To worksheets.count
            Dim curWS As Worksheet
            Set curWS = worksheets.item(c)
            
            deleteWS curWS
        Next
        
        initWSForNewProject wsToKeep, setBackgroundColorToWhite
        emsg = ""
        
    End If
    
    out_emsg = emsg
End Sub

Function exportColumnDataToNewWB(colDataList As Collection, ByRef out_emsg As String, desiredTabName As String, destRow As Long, destCol As Long, Optional collOfNumFormats As Variant) As Range

    Dim listOfNumFrmats As Collection
    If IsMissing(collOfNumFormats) Then
        Set listOfNumFrmats = Nothing
    Else
        Set listOfNumFrmats = collOfNumFormats
    End If
    
    Dim exportWS As Worksheet
    Dim emsg As String
    createNewWBAndInitForNewProjectAndSetTabToDesiredName exportWS, emsg, desiredTabName, True
   
    Dim pastedRngeSoFar As Range
    Set pastedRngeSoFar = Nothing
    If emsg <> "" Then
        'DO NOTHING
    ElseIf isNothing(exportWS) Then
        emsg = "Could not create a new workbook for some reason."
    Else
    
        Dim startingAnchor As Range
        Set startingAnchor = exportWS.cells(destRow - 1, destCol)
        
        Dim curAnk As Range
        Set curAnk = startingAnchor
        
        Dim sz As Long
        If isNothing(listOfNumFrmats) Then
            sz = colDataList.count
        Else
            sz = ccsz(Array(colDataList, listOfNumFrmats), True)
        End If
        
        Dim c As Long
        For c = 1 To sz
            
            Dim pastedRnge As Range
            Set pastedRnge = scd(curAnk, colDataList.item(c))
            
            If isNothing(pastedRngeSoFar) Then
                Set pastedRngeSoFar = pastedRnge
            Else
                Set pastedRngeSoFar = rngeToRnge(pastedRngeSoFar, pastedRnge)
            End If
            
            If isNothing(listOfNumFrmats) Then
                'DO NOTHING
            Else
                Dim numFormat As String
                numFormat = listOfNumFrmats.item(c)
                
                setNumberFormat pastedRngeSoFar, numFormat
            End If
            
            Set curAnk = curAnk.offset(0, 1)
            
        Next
    End If
    
    Set exportColumnDataToNewWB = pastedRngeSoFar

End Function

'setBackgroundColorToWhite = true
Function exportRngeToNewWB(includeFormats As Boolean, dataToCopy As Range, ByRef out_emsg As String, desiredTabName As String, destRow As Long, destCol As Long, setBackgroundColorToWhite As Boolean) As Range
    
    Dim exportWS As Worksheet
    Dim emsg As String
    createNewWBAndInitForNewProjectAndSetTabToDesiredName exportWS, emsg, desiredTabName, setBackgroundColorToWhite
   
    Dim pastedRnge As Range
    If isNothing(exportWS) Then
        Set pastedRnge = Nothing
    ElseIf emsg <> "" Then
        Set pastedRnge = Nothing
    Else
    
        Dim destRnge As Range
        Set destRnge = exportWS.cells(destRow, destCol)
    
        Dim pasteModesInOrder As Variant
        If includeFormats Then
            pasteModesInOrder = Array(xlValues, xlFormats)
        Else
            pasteModesInOrder = Array(xlValues)
        End If
    
        Set pastedRnge = copyFromOneRngeToAnother(dataToCopy, destRnge, pasteModesInOrder)
        
        srg pastedRnge
            
    End If
    Set exportRngeToNewWB = pastedRnge
    out_emsg = emsg
End Function

Function adjustToMakeTabNameCompatible(tabName As String) As String
    
    Dim adjNameSoFar As String
    adjNameSoFar = tabName
    
    Dim listOf__text_replacement_recursive As Collection
    Set listOf__text_replacement_recursive = New Collection
    With listOf__text_replacement_recursive
        .add Array(":", "_", False)
        .add Array("\", "_", False)
        .add Array("/", "_", False)
        .add Array("?", "_", False)
        .add Array("*", "_", False)
        .add Array("[", "_", False)
        .add Array("]", "_", False)
    End With
    
    adjNameSoFar = replaceInString_multipleReplacements(adjNameSoFar, listOf__text_replacement_recursive)
    
    If Len(tabName) >= 31 Then
        adjNameSoFar = left(tabName, 31)
    End If
    
    adjustToMakeTabNameCompatible = adjNameSoFar
End Function

Sub setTabNameAndAdjustIfNecessaryToMakeItWork(ws As Worksheet, tabName As String)
    setTabName ws, adjustToMakeTabNameCompatible(tabName)
End Sub

Sub setTabName(ws As Worksheet, tabName As String)
On Error GoTo ehs
    ws.name = tabName
GoTo ehe
ehs:
    elwp Err.description
ehe:
On Error GoTo 0
End Sub

Function getCurSel() As Range
    Dim sel As Variant
    atr sel, Selection
    
    If isRnge(sel) Then
        Set getCurSel = sel
    Else
        Set getCurSel = Nothing
    End If
End Function
Function getListOfOrderNumAndFieldToDisplayForCustomReportGeneration(rnForHeaderCellRnge As String, rowNumForFlagsAndOrderNums As Long, optWS As Worksheet) As Collection
    
    Dim cellHeaders As Collection
    Set cellHeaders = getCellsInRnge(rnge(rnForHeaderCellRnge, optWS))
    
    Dim listOf__orderNum_colAnchor As Collection
    Set listOf__orderNum_colAnchor = getListOfOrderNumAndAnchorForColToDisplayForCustomReportGeneration(cellHeaders, rowNumForFlagsAndOrderNums)
    

    Dim listOf__orderNum_fieldToDisplay As Collection
    Set listOf__orderNum_fieldToDisplay = New Collection
    
    Dim j As Long
    For j = 1 To listOf__orderNum_colAnchor.count
        Dim orderNum_colAnchor As Variant
        orderNum_colAnchor = listOf__orderNum_colAnchor.item(j)
        
        Dim orderNum As Double
        Dim colAnchor As Range
        orderNum = rlai(orderNum_colAnchor, 1)
        Set colAnchor = rlai(orderNum_colAnchor, 2)
        
        listOf__orderNum_fieldToDisplay.add Array(orderNum, gvl(colAnchor))
    Next
    Set getListOfOrderNumAndFieldToDisplayForCustomReportGeneration = listOf__orderNum_fieldToDisplay
End Function


Function getListOfOrderNumAndAnchorForColToDisplayForCustomReportGeneration(cellHeaders As Collection, rowNumForFlagsAndOrderNums As Long) As Collection
    
    Dim listOf__orderNum_colAnchor As Collection
    Set listOf__orderNum_colAnchor = New Collection
    
    Dim dd As Long
    For dd = 1 To cellHeaders.count
        Dim curHdr As Range
        Set curHdr = cellHeaders.item(dd)
        
        Dim shouldIncludeOrOrderNumber As Variant
        shouldIncludeOrOrderNumber = gvl(gcicsr(curHdr, rowNumForFlagsAndOrderNums))
        
        Dim orderNum2 As Double
        Dim shouldInclude As Boolean
        If isNumber(shouldIncludeOrOrderNumber) Then
            orderNum2 = CDbl(shouldIncludeOrOrderNumber)
            shouldInclude = True
        Else
            orderNum2 = 0
            shouldInclude = textToBoolean(shouldIncludeOrOrderNumber)
        End If
        
        If shouldInclude Then
            listOf__orderNum_colAnchor.add Array(orderNum2, curHdr)
        End If
    Next
    
    Set getListOfOrderNumAndAnchorForColToDisplayForCustomReportGeneration = listOf__orderNum_colAnchor
    
End Function



Sub addToEmsgsObject(ByRef mod_emsgs As Variant, emsgs As JYCORE_Set)
    
    If isNothing(mod_emsgs) Then
        elwp "Please pass in an error messages object!"
    ElseIf emsgs.count > 0 Then
        Dim emsgList As Collection
        Set emsgList = emsgs.toCollection()
        
        Dim d As Long
        For d = 1 To emsgList.count
            mod_emsgs.add emsgList.item(d)
        Next
    Else
        'DO NOTHING
    End If
End Sub

Function itm(vector As Variant, indx As Long) As Variant
    If IsArray(vector) Then
        atr itm, rlai(vector, indx)
    Else
        atr itm, vector.item(indx)
    End If

End Function

Function szof(vector As Variant) As Long

    If isBlankValue(vector) Then
        szof = 0
    ElseIf IsArray(vector) Then
        szof = dimSize(vector, 1)
    Else
        szof = vector.count
    End If

End Function

Function decideBooleanValueBasedOnTextOrCellValue(desc As String, theTextOrCellValue As Variant, trueText As String, falseText As String, caseSensitive As Boolean, trimBeforeComparing As Boolean) As Boolean

    Dim optCell As Range
    Dim theText As String
    If isRnge(theTextOrCellValue) Then
        Set optCell = theTextOrCellValue
        theText = gvl(optCell)
    Else
        Set optCell = Nothing
        theText = CStr(theTextOrCellValue)
    End If

    Dim boolToReturn As Boolean
    If sae2(theText, trueText, caseSensitive, trimBeforeComparing) Then
        boolToReturn = True
    Else
        If sae2(theText, falseText, caseSensitive, trimBeforeComparing) Then
            'DO NOTHING
        Else
        
            Dim origSel As Range
            Set origSel = getCurSel()
        
            If isNothing(optCell) Then
                'DO NOTHING
            Else
                sris optCell
            End If
            elwp "Unknown " & desc & ": " & theText & CHAR_CRLF & "(we will assume '" & falseText & "'.)"
            
            sris origSel
        End If
        boolToReturn = False
    End If
    
    decideBooleanValueBasedOnTextOrCellValue = boolToReturn

End Function

Sub convertWorksheetToValuesOnly(ws As Worksheet)
    
    Dim viaClipBoard As Boolean
    viaClipBoard = False
    
    Dim rng As Range
    If viaClipBoard Then
        Set rng = ws.cells
    Else
        Set rng = ws.UsedRange
    End If
    
    convertRngToValues rng, viaClipBoard
End Sub

Sub convertRngToValues(rng As Range, viaClipBoard As Boolean)
    
    If viaClipBoard Then
        rng.Copy
        rng.PasteSpecial xlPasteValues
        clearClipboardSelection
    Else
        rng.value = rng.value
    End If

End Sub

Function cellContainsFormula(rng As Range)

    If rng.count <> 1 Then
        elwp "Please pass in exactly one cell!"
        cellContainsFormula = False
    Else
        cellContainsFormula = startsWith(rng.formula, "=", True)
    End If
End Function

Function ensureValueIsCollection(valueOrArrayOfValuesOrCollectionOfValues) As Collection
    Set ensureValueIsCollection = arrayToCollection(ensureValueIsAnArray(valueOrArrayOfValuesOrCollectionOfValues))
End Function

Function ensureValueIsAnArrayOrNothing(valueOrArrayOfValuesOrCollectionOfValues As Variant) As Variant
    If isNothing(valueOrArrayOfValuesOrCollectionOfValues) Then
        Set ensureValueIsAnArrayOrNothing = Nothing
    Else
        ensureValueIsAnArrayOrNothing = ensureValueIsAnArray(valueOrArrayOfValuesOrCollectionOfValues)
    End If
End Function

Function ensureValueIsAnArray(valueOrArrayOfValuesOrCollectionOfValues As Variant) As Variant
    Dim rnsArray As Variant
    If IsArray(valueOrArrayOfValuesOrCollectionOfValues) Then
        rnsArray = valueOrArrayOfValuesOrCollectionOfValues
    ElseIf isCollection(valueOrArrayOfValuesOrCollectionOfValues) Then
        rnsArray = collectionToArray(castToCollection(valueOrArrayOfValuesOrCollectionOfValues))
    Else
        rnsArray = Array(valueOrArrayOfValuesOrCollectionOfValues)
    End If
    ensureValueIsAnArray = rnsArray
End Function

Sub runShellCommand(cmd As String, ByRef mod_emsgs As Variant)

On Error GoTo ehs

    Dim retValue As Double
    retValue = Shell(cmd)

GoTo ehe
ehs:
    Dim theErr As String
    theErr = Err.description
    elg theErr
    mod_emsgs.add theErr
ehe:
On Error GoTo 0

End Sub

Sub setAddInInstalled(addInName As String, installed As Boolean)
On Error GoTo ehs
    AddIns(addInName).installed = installed
GoTo ehe
ehs:
    elwp "Could not set the '" & addInName & "' add-in's 'installed' property to '" & installed & "'!  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Function getRowAnkParam(rn As String, optWS As Worksheet) As Variant
    getRowAnkParam = gvl(rnge(rn, optWS).offset(0, 1))
End Function

Function setRowAnkParam(rn As String, optWS As Worksheet, theVal As Variant)
    svl rnge(rn, optWS).offset(0, 1), theVal
End Function

Sub setScreenUpdating(desiredValue As Boolean)
On Error GoTo ehs
    If Application.ScreenUpdating <> desiredValue Then
        Application.ScreenUpdating = desiredValue
    End If
    
GoTo ehe
ehs:
    elwp "Could not set screen updating!  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Function temporarilyDisableScreenUpdatingAndAlerts() As Variant
    Dim origScreenUpdating As Variant
    Dim origAlerts As Variant
    origScreenUpdating = temporarilyDisableScreenUpdating()
    origAlerts = temporarilyDisableAlerts()
    
    temporarilyDisableScreenUpdatingAndAlerts = Array(origScreenUpdating, origAlerts)
End Function

Sub restoreOrigScreenUpdatingAndAlerts(origScreenUpdating_origAlerts As Variant)
    Dim origScreenUpdating As Boolean
    Dim origAlerts As Boolean
    origScreenUpdating = rlai(origScreenUpdating_origAlerts, 1)
    origAlerts = rlai(origScreenUpdating_origAlerts, 2)

    setScreenUpdating origScreenUpdating
    setDisplayAlerts origAlerts
End Sub

Function temporarilyDisableAlerts() As Boolean
    Dim origAlerts As Variant
    origAlerts = Application.DisplayAlerts
    
    setDisplayAlerts False
    
    temporarilyDisableAlerts = origAlerts
End Function

Function temporarilyDisableScreenUpdating() As Boolean
    Dim origScreenUpdating As Variant
    origScreenUpdating = Application.ScreenUpdating
    
    setScreenUpdating False
    
    temporarilyDisableScreenUpdating = origScreenUpdating
End Function

Function figureOutIfTargetIsExactlyOneCellAndUserIsNotInCutCopyMode(target As Range) As Boolean
    
    Dim targetIsExactlyOneCellAndUserIsNotInCutCopyMode As Boolean
    If isNothing(target) Then
        targetIsExactlyOneCellAndUserIsNotInCutCopyMode = False
    ElseIf target.cells.count <> 1 Then
        targetIsExactlyOneCellAndUserIsNotInCutCopyMode = False
    ElseIf Application.CutCopyMode = xlCopy Or Application.CutCopyMode = xlCut Then
        targetIsExactlyOneCellAndUserIsNotInCutCopyMode = False
    Else
        targetIsExactlyOneCellAndUserIsNotInCutCopyMode = True
    End If
    
    figureOutIfTargetIsExactlyOneCellAndUserIsNotInCutCopyMode = targetIsExactlyOneCellAndUserIsNotInCutCopyMode
End Function

Function formatIfPossible(something As Variant, fmt As Variant) As Variant
    Dim retVal As Variant
    retVal = "ERROR: NOT SET!"

On Error GoTo ehs
    retVal = Format(something, fmt)
GoTo ehe
ehs:
    retVal = something
ehe:
On Error GoTo 0

    formatIfPossible = retVal
End Function

Function performWorksheetMatch(desiredValue As Variant, dataArr As Variant, thirdParameter As Variant, convertDatesToYYYYMMDDsToMakeMatchFunctionPlayNiceBecauseItDoesNotByDefault As Boolean, shouldSplitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit As Variant) As Long '1 for "less than' as long
    
    Dim delm As String
    Dim strictVsFlex As Boolean
    delm = ""
    strictVsFlex = False
    
    Dim splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit As Variant
    If isNothing(shouldSplitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit) Then
        atr splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit, shouldSplitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit
    ElseIf thirdParameter <> 0 And thirdParameter <> 1 Then
        elwp "I'm only familiar with how these two parameters work, so I wo'nt perform our splitting algorithm for other settings"
        Set splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit = Nothing
    Else
        atr splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit, shouldSplitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit
    End If
    
    Dim yyyymmddArrayTwoDims As Variant
    Dim potentialValue As Variant
    If convertDatesToYYYYMMDDsToMakeMatchFunctionPlayNiceBecauseItDoesNotByDefault Then
        potentialValue = dateToYYYYMMDD_ifPossible_customDelimiter(desiredValue, delm, strictVsFlex)
        yyyymmddArrayTwoDims = convertAllDatesIn2DArrayToYYYYMMDD(dataArr, delm, strictVsFlex)
    Else
        potentialValue = desiredValue
        yyyymmddArrayTwoDims = dataArr
    End If
    
    Dim valueRepresentingNotFound As Long
    valueRepresentingNotFound = 0
    
    Dim assumedMaxArraySizeThatCanBeAcceptedIntoTheMatchFunctionWithoutThrowingTypeMismatchError As Long
    assumedMaxArraySizeThatCanBeAcceptedIntoTheMatchFunctionWithoutThrowingTypeMismatchError = 60000 '60000 is a conservative number, I think it's really 65000 and change
    
    Dim listOfArrays As Collection
    If isNothing(splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit) Then
        Set listOfArrays = arrayToCollection(Array(yyyymmddArrayTwoDims))
    Else
        Set listOfArrays = splitArraysVerticallyOrHorizontally(yyyymmddArrayTwoDims, CBool(splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit), assumedMaxArraySizeThatCanBeAcceptedIntoTheMatchFunctionWithoutThrowingTypeMismatchError)
    End If
    
    Dim curOffset As Long
    curOffset = 0
    
    Dim resultSoFar As Long
    resultSoFar = valueRepresentingNotFound
    
    Dim d As Long
    For d = 1 To listOfArrays.count
        Dim curArr As Variant
        curArr = listOfArrays.item(d)
        
        Dim result As Long
        result = doPerformWorksheetMatch(potentialValue, curArr, thirdParameter, valueRepresentingNotFound)
        
        If result = valueRepresentingNotFound Then
            'DO NOTHING
        Else
            resultSoFar = (result + curOffset)
        End If
        
        Dim adjustmentForOffset As Long
        If isNothing(splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit) Then
            If d <> 1 Then
                elwp "We are surprised that we did not perform an array split, but nonetheless are dealing with multiple arrays!"
            End If
            adjustmentForOffset = 0 'arbitrary
        Else
            adjustmentForOffset = getNumRowsOrNumColumnsOfTwoDimArray(curArr, CBool(splitArraysHorizontallyVsVerticallyWhenTooBig_orNothingIfShouldNotSplit))
        End If
        
        curOffset = curOffset + adjustmentForOffset
        
    Next
    
    performWorksheetMatch = resultSoFar
End Function

Function doPerformWorksheetMatch(potentialValue As Variant, curArr As Variant, thirdParameter As Variant, valueRepresentingNotFound As Long) As Long
    
    Dim retVal As Long
    retVal = valueRepresentingNotFound
    
On Error GoTo ehs

    Dim result As Double
    result = Application.WorksheetFunction.Match(potentialValue, curArr, thirdParameter)
    
    If Not isInteger(result) Then
        elwp "Unexpectedly received a non-integer result!"
        retVal = valueRepresentingNotFound
    Else
        retVal = result
    End If
    

GoTo ehe
ehs:
    elg Err.description
    retVal = valueRepresentingNotFound
ehe:
On Error GoTo 0
    
    doPerformWorksheetMatch = retVal
End Function


Sub temporarilyHighlightRangeAndDisplayErrorMessageAndAlsoLogIt(ByRef mod_emsgs, daEmsg As String, rngeToHighlight As Range)

    Dim origSel As Range
    Set origSel = Selection
    
    sris rngeToHighlight
    elwp daEmsg
    sris origSel

    mod_emsgs.add daEmsg
End Sub



Function getUSStateAbbrevsIncludingTerritories() As Variant

    Dim allowedStates As Collection
    Set allowedStates = New Collection
    With allowedStates
        'States
        .add "AL" 'Alabama
        .add "AK" 'Alaska
        .add "AZ" 'Arizona
        .add "AR" 'Arkansas
        .add "CA" 'California
        .add "CO" 'Colorado
        .add "CT" 'Connecticut
        .add "DE" 'Delaware
        .add "FL" 'Florida
        .add "GA" 'Georgia
        .add "HI" 'Hawaii
        .add "ID" 'Idaho
        .add "IL" 'Illinois
        .add "IN" 'Indiana
        .add "IA" 'Iowa
        .add "KS" 'Kansas
        .add "KY" 'Kentucky
        .add "LA" 'Louisiana
        .add "ME" 'Maine
        .add "MD" 'Maryland
        .add "MA" 'Massachusetts
        .add "MI" 'Michigan
        .add "MN" 'Minnesota
        .add "MS" 'Mississippi
        .add "MO" 'Missouri
        .add "MT" 'Montana
        .add "NE" 'Nebraska
        .add "NV" 'Nevada
        .add "NH" 'New Hampshire
        .add "NJ" 'New Jersey
        .add "NM" 'New Mexico
        .add "NY" 'New York
        .add "NC" 'North Carolina
        .add "ND" 'North Dakota
        .add "OH" 'Ohio
        .add "OK" 'Oklahoma
        .add "OR" 'Oregon
        .add "PA" 'Pennsylvania
        .add "RI" 'Rhode Island
        .add "SC" 'South Carolina
        .add "SD" 'South Dakota
        .add "TN" 'Tennessee
        .add "TX" 'Texas
        .add "UT" 'Utah
        .add "VT" 'Vermont
        .add "VA" 'Virginia
        .add "WA" 'Washington
        .add "WV" 'West Virginia
        .add "WI" 'Wisconsin
        .add "WY" 'Wyoming
        ' Commonwealth / Territories
        
        addCollectionToCollection allowedStates, getCommonWealthOrTerritories()
        
    End With
    
    getUSStateAbbrevsIncludingTerritories = collectionToArray(allowedStates)
    
End Function

Function getCommonWealthOrTerritories() As Collection
    
    Dim list As Collection
    Set list = New Collection
    With list
        .add "AS" 'American Samoa
        .add "DC" 'District of Columbia
        .add "FM" 'Federated States of Micronesia
        .add "GU" 'Guam
        .add "MH" 'Marshall Islands
        .add "MP" 'Northern Mariana Islands
        .add "PW" 'Palau
        .add "PR" 'Puerto Rico
        .add "VI" 'Virgin Islands
    End With
    
    Set getCommonWealthOrTerritories = list
End Function

Function convertToNumberIfPossible(theVal As Variant) As Variant
    If isNumber(theVal) Then
        convertToNumberIfPossible = CDbl(theVal)
    Else
        convertToNumberIfPossible = theVal
    End If
End Function

Sub addComment(theCell As Range, comment As String, ByRef mod_optEMsgs As Variant)

On Error GoTo ehs

    theCell.addComment comment

GoTo ehe
ehs:
    Dim desc As String
    desc = "Cannot add comment.  Msg=" & Err.description
    If isNothing(mod_optEMsgs) Then
        elwp desc
    Else
        elg desc
        mod_optEMsgs.add desc
    End If
    
ehe:
On Error GoTo 0
End Sub
Sub deleteComment(theCell As Range, ByRef mod_optEMsgs As Variant)
On Error GoTo ehs
    theCell.comment.Delete
GoTo ehe
ehs:
    
    Dim desc As String
    desc = "Cannot delete comment.  Msg=" & Err.description
    If isNothing(mod_optEMsgs) Then
        elwp desc
    Else
        elg desc
        mod_optEMsgs.add desc
    End If
    
ehe:
On Error GoTo 0
End Sub

Sub convertFormulasToValuesOnWorksheet(ws As Worksheet, ByRef mod_emsgs___orNothingIfShouldShowPopupErrorsInsteadOfLogging As Variant)

    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set

On Error GoTo ehs

    'JY20140205b - start - simply setting the value to itself generates an "Out of Memory" error in the CLO NAV Report, so we will go with the cut-and-paste method instead.  In the future, maybe make it a togglable option which method we should use, or do a failure over thing... i.e., try one first and if you hit an error than go the other way
    'ws.cells.value = ws.cells.value
    ws.cells.Copy
    pasteValues tlcor(ws.cells)
    'JY20140205b - end
GoTo ehe
ehs:
    emsgs.add Err.description
ehe:
On Error GoTo 0

    Dim emsg As String
    If emsgs.count = 0 Then
        emsg = ""
    Else
        emsg = "The following error(s) occurred while trying to convert formulas to values on a worksheet: " & emsgs.toString(" ... ", "")
    End If
    
    If emsg = "" Then
        'DO NOTHING
    Else
        If isNothing(mod_emsgs___orNothingIfShouldShowPopupErrorsInsteadOfLogging) Then
            elwp emsg
        Else
            mod_emsgs___orNothingIfShouldShowPopupErrorsInsteadOfLogging.add emsg
        End If
    End If

End Sub
Attribute VB_Name = "JYUT_MortgageRelated"
Option Explicit

Public Const DM_UCASE_CURVE_ABBREV As String = "DM"

Sub parseTextThatMightContainSpeedPricingInputsAndYieldCurveType(ByRef out_adjSpeedText2 As String, ByRef out_pxInput, ByRef out_thePricingType As String, ByRef out_yieldCurveTypeText As String, chosenSpreadAndSpeedAndYieldCurveTypeText As String, yieldCurveTypes As JYCORE_Set, ByRef mod_emsgs As Variant, pxTypeStrings As JYUT_MTGRelatedPxTypeStrings)
    
    Dim adjustedSpreadAndSpeedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist As String
    adjustedSpreadAndSpeedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist = Trim(replaceInString(replaceInString(chosenSpreadAndSpeedAndYieldCurveTypeText, "  ", " ", True), " + ", "+", False))
    
    Dim withPricesRemovedAdjustedSpreadAndSpeedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist As String
    Dim pricesText As String
    parseOutAnythingThatLooksLikeAPrice withPricesRemovedAdjustedSpreadAndSpeedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist, pricesText, adjustedSpreadAndSpeedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist, yieldCurveTypes, mod_emsgs
    
    Dim adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist As String
    Dim yieldCurveTypeText As String
    parseOutYieldCurveTypeFromOurString adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist, yieldCurveTypeText, withPricesRemovedAdjustedSpreadAndSpeedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist, yieldCurveTypes, mod_emsgs
    
    Dim spreadText As String
    Dim speedText As String
    parseOutSpreadTextAndSpeedText spreadText, speedText, adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist, mod_emsgs
    
    Dim thePricingType As String
    Dim pxInput As Variant
    parseSpreadText thePricingType, pxInput, spreadText, pxTypeStrings
    
    Dim adjSpeedText2 As String
    adjSpeedText2 = parseAndAdjustIfNecessaryTheSpeedText(speedText, mod_emsgs)
    
    out_adjSpeedText2 = adjSpeedText2
    out_thePricingType = thePricingType
    out_pxInput = pxInput
    out_yieldCurveTypeText = yieldCurveTypeText
End Sub

Function candidateIsDefinitelySpeed(speedText As String) As Boolean
    
    If Trim(speedText) = "" Then
        candidateIsDefinitelySpeed = False
    Else
    
        Dim emsgs As JYCORE_Set
        Set emsgs = New JYCORE_Set
        
        Dim adj As String
        adj = parseAndAdjustIfNecessaryTheSpeedText(speedText, emsgs)
        
        candidateIsDefinitelySpeed = emsgs.count = 0
    End If
End Function

Sub parseOutSpreadTextAndSpeedText(ByRef out_spreadText As String, ByRef out_speedText As String, adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist As String, ByRef mod_emsgs As Variant)
    
    Dim tkns As Collection
    Set tkns = gtkns(adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist, " ")
    Dim firstDelimiterVsLast_orNothingIfNotClear  As Variant
    If tkns.count >= 1 Then
        If candidateIsDefinitelySpread(tkns.item(1)) Then
            firstDelimiterVsLast_orNothingIfNotClear = True
        ElseIf candidateIsDefinitelySpread(tkns.item(tkns.count)) Then
            firstDelimiterVsLast_orNothingIfNotClear = False
        Else
           Set firstDelimiterVsLast_orNothingIfNotClear = Nothing
        End If
        
    Else
        firstDelimiterVsLast_orNothingIfNotClear = True 'arbitrary
    End If
    
    Dim firstDelimiterVsLast_orIndxToSplitAtAndTknName As Variant
    If isNothing(firstDelimiterVsLast_orNothingIfNotClear) Then
        Dim correspondingSearchValue As String
        Dim indx As Long
        indx = nextIndxOfChoiceOfStrings(UCase(adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist), Array("CPR", "PPC", "PSA", "ABS"), correspondingSearchValue)
        
        If indx = 0 Then
            firstDelimiterVsLast_orIndxToSplitAtAndTknName = True 'arbitrary
        Else
            firstDelimiterVsLast_orIndxToSplitAtAndTknName = Array(indx, correspondingSearchValue)
        End If
    
    Else
        firstDelimiterVsLast_orIndxToSplitAtAndTknName = firstDelimiterVsLast_orNothingIfNotClear
    End If
    
    Dim origCandidateSpreadorSpeedText1 As String
    Dim origCandidateSpreadorSpeedText2 As String
    If isBoolean(firstDelimiterVsLast_orIndxToSplitAtAndTknName) Then
        splitStringInTwo_aroundDelimiter origCandidateSpreadorSpeedText1, origCandidateSpreadorSpeedText2, adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist, " ", CBool(firstDelimiterVsLast_orIndxToSplitAtAndTknName), True
    Else
        Dim indxToSplitAtAndTknName As Variant
        indxToSplitAtAndTknName = firstDelimiterVsLast_orIndxToSplitAtAndTknName
        
        Dim indxToSplitAt As Long
        Dim tknName As String
        indxToSplitAt = rlai(indxToSplitAtAndTknName, 1)
        tknName = rlai(indxToSplitAtAndTknName, 2)
        
        Dim lengthOfSplit As Long
        lengthOfSplit = Len(tknName)
        
        Dim indxeToSplitAt As Long
        indxeToSplitAt = (indxToSplitAt + lengthOfSplit - 1)
        
        Dim temp1 As String
        Dim temp2 As String
        temp1 = left(adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist, indxeToSplitAt)
        temp2 = Right(adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist, Len(adjustedSpreadAndSpeedText_noteThatNoDoubleSpacesWillExist) - indxeToSplitAt)
        
        If Trim(temp2) = "" Then
            
            Dim adjusted As String
            adjusted = replaceInString(temp1, " " & tknName, tknName, True)
            
            Dim lst As Long
            lst = doLstIndxOf(" ", adjusted, Nothing)
            
            origCandidateSpreadorSpeedText1 = left(adjusted, lst - 1)
            origCandidateSpreadorSpeedText2 = Right(adjusted, Len(adjusted) - lst)
            
        
        Else
            origCandidateSpreadorSpeedText1 = temp1
            origCandidateSpreadorSpeedText2 = temp2
        End If
        
        
        
    End If
    
    Dim candidateSpreadorSpeedText1 As String
    Dim candidateSpreadorSpeedText2 As String
    candidateSpreadorSpeedText1 = adjustIfNecessaryAndIsDefinitelySpraed(origCandidateSpreadorSpeedText1)
    candidateSpreadorSpeedText2 = adjustIfNecessaryAndIsDefinitelySpraed(origCandidateSpreadorSpeedText2)
    
    Dim candidateOneIsDefinitelySpread As Boolean
    Dim candidateTwoIsDefinitelySpread As Boolean
    candidateOneIsDefinitelySpread = candidateIsDefinitelySpread(candidateSpreadorSpeedText1)
    candidateTwoIsDefinitelySpread = candidateIsDefinitelySpread(candidateSpreadorSpeedText2)
    
    Dim candidateOneIsDefinitelySpeed As Boolean
    Dim candidateTwoIsDefinitelySpeed As Boolean
    candidateOneIsDefinitelySpeed = candidateIsDefinitelySpeed(candidateSpreadorSpeedText1)
    candidateTwoIsDefinitelySpeed = candidateIsDefinitelySpeed(candidateSpreadorSpeedText2)
    
    Dim flags As String
    flags = booleansToStringFlags(Array(candidateOneIsDefinitelySpread, candidateOneIsDefinitelySpeed, candidateTwoIsDefinitelySpread, candidateTwoIsDefinitelySpeed))
    
    Dim spreadText As String
    Dim speedText As String
    If candidateSpreadorSpeedText1 = candidateSpreadorSpeedText2 Then
        'Doesn't matter which is which
        spreadText = candidateSpreadorSpeedText1
        speedText = candidateSpreadorSpeedText2
    ElseIf flags = "1111" Then
        mod_emsgs.add "Could not figure out what text represents speed and what text represents spread (both candidates look like speads and spreads)."
        spreadText = ""
        speedText = ""
    ElseIf flags = "1010" Then
        mod_emsgs.add "Could not figure out what text represents speed and what text represents spread (both candidates look like spreads)."
        spreadText = ""
        speedText = ""
    ElseIf flags = "0101" Then
        mod_emsgs.add "Could not figure out what text represents speed and what text represents spread (both candidates look like speeds)."
        spreadText = ""
        speedText = ""
    ElseIf flags = "0000" Or flags = "0011" Or flags = "1100" Then
        
        If flags <> "0000" Then
            mod_emsgs.add "Could not figure out what text represents speed and what text represents spread (we could not definitively figure out what is what)."
            spreadText = ""
            speedText = ""
        Else
            If isNumber(candidateSpreadorSpeedText1) And Not isNumber(candidateSpreadorSpeedText2) Then
                spreadText = candidateSpreadorSpeedText1
                speedText = candidateSpreadorSpeedText2
            ElseIf isNumber(candidateSpreadorSpeedText2) And Not isNumber(candidateSpreadorSpeedText1) Then
                spreadText = candidateSpreadorSpeedText2
                speedText = candidateSpreadorSpeedText1
            Else
                mod_emsgs.add "Could not figure out what text represents speed and what text represents spread (could not definitively figure out what is what)."
                spreadText = ""
                speedText = ""
            End If
        End If
        
    ElseIf flags = "0001" Or flags = "1101" Or flags = "1000" Or flags = "1011" Or flags = "1001" Then
        spreadText = candidateSpreadorSpeedText1
        speedText = candidateSpreadorSpeedText2
    ElseIf flags = "0100" Or flags = "0111" Or flags = "0010" Or flags = "1110" Or flags = "0110" Then
        spreadText = candidateSpreadorSpeedText2
        speedText = candidateSpreadorSpeedText1
    Else
        mod_emsgs.add "Our assumptions on the values of certain constants have changed.  Our code may break."
        spreadText = ""
        speedText = ""
    End If
    
    out_spreadText = spreadText
    out_speedText = speedText
End Sub


Sub parseOutAnythingThatLooksLikeAPrice(ByRef out_remainingText As String, ByRef out_priceText, startingText As String, yieldCurveTypes As JYCORE_Set, ByRef mod_emsgs As Variant)
    parseOutYieldCurveTypeOrPriceFromOurString out_remainingText, out_priceText, startingText, Nothing, mod_emsgs, "prices"
    
End Sub

Sub parseOutYieldCurveTypeFromOurString(ByRef out_speedText As String, ByRef out_yieldCurveTypeText, speedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist As String, yieldCurveTypes As JYCORE_Set, ByRef mod_emsgs As Variant)
    
    Dim typeDescAsPlural As String
    typeDescAsPlural = "yield curve types"

    Dim yieldCurveTyps As JYCORE_Set
    If isNothing(yieldCurveTypes) Then
        Set yieldCurveTyps = New JYCORE_Set
    Else
        Set yieldCurveTyps = yieldCurveTypes
    End If
    parseOutYieldCurveTypeOrPriceFromOurString out_speedText, out_yieldCurveTypeText, speedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist, yieldCurveTyps, mod_emsgs, typeDescAsPlural

End Sub

Sub parseOutYieldCurveTypeOrPriceFromOurString(ByRef out_remainingText As String, ByRef out_yieldCurveTypeTextOrPriceText, speedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist As String, yieldCurveTypes_orNothingToParseOutPricesInstead As JYCORE_Set, ByRef mod_emsgs As Variant, typeDescAsPlural As String)

    
    Dim tkns As Collection
    Set tkns = gtkns(speedAndYieldCurveTypeText_noteThatNoDoubleSpacesWillExist, " ")
    
    Dim yieldCurveTypesorPrices As JYCORE_Set
    Set yieldCurveTypesorPrices = New JYCORE_Set
    
    Dim tknsForRemainingText As Collection
    Set tknsForRemainingText = New Collection
    
    Dim c As Long
    For c = 1 To tkns.count
        Dim tkn As String
        tkn = tkns.item(c)
        
        Dim isWhatWeAreLookingFor As Boolean
        If isNothing(yieldCurveTypes_orNothingToParseOutPricesInstead) Then
            'Check to see if it's a price
            
            isWhatWeAreLookingFor = (0 <> InStr(1, tkn, "-"))
        
        Else
            'Check to see if it's a yield curve specification.
            
            isWhatWeAreLookingFor = yieldCurveTypes_orNothingToParseOutPricesInstead.exists(tkn)
        End If
    
        If isWhatWeAreLookingFor Then
            yieldCurveTypesorPrices.add tkn
        Else
            tknsForRemainingText.add tkn
        End If
    Next
    
    Dim yieldCurveTypeTextOrPriceText As String
    If yieldCurveTypesorPrices.count > 1 Then
        mod_emsgs.add "Multiple " & typeDescAsPlural & " seem to have been specified: " & yieldCurveTypesorPrices.toString(", ", "")
        yieldCurveTypeTextOrPriceText = ""
    ElseIf yieldCurveTypesorPrices.count = 0 Then
        yieldCurveTypeTextOrPriceText = ""
    Else 'yieldCurveTypesorPrices.count = 1
        yieldCurveTypeTextOrPriceText = yieldCurveTypesorPrices.toCollection().item(1)
    End If
    
    Dim remainingText As String
    remainingText = collectionToString(tknsForRemainingText, " ", "")
    
    out_remainingText = remainingText
    out_yieldCurveTypeTextOrPriceText = yieldCurveTypeTextOrPriceText
End Sub


Sub parseSpreadText(ByRef out_thePricingType As String, ByRef out_pxInput As Variant, theSpreadText As String, pxTypeStrings As JYUT_MTGRelatedPxTypeStrings)
    
    Dim nomuraPricingType As String
    Dim eSpreadPricingType As String
    Dim nSpreadPricingType As String
    Dim yieldPricingType As String
    Dim dmPricingType As String
    breakOutPxTypeStrings pxTypeStrings, nomuraPricingType, eSpreadPricingType, nSpreadPricingType, yieldPricingType, dmPricingType
    
    Dim indxOfPlus As Long
    indxOfPlus = InStr(1, theSpreadText, "+")
    
    Dim spreadText As String
    spreadText = adjustIfNecessaryAndIsDefinitelySpraed(theSpreadText)
    
    
    Dim thePricingType As String
    Dim pxInput As Variant
    If indxOfPlus = 0 Then
        thePricingType = dmPricingType
        pxInput = spreadText
    Else
        Dim ucaseCurveAbbrev As String
        ucaseCurveAbbrev = Trim(UCase(left(spreadText, indxOfPlus - 1)))
        
        If ucaseCurveAbbrev = "N" Then
            thePricingType = nomuraPricingType
        ElseIf ucaseCurveAbbrev = "E" Then
            thePricingType = eSpreadPricingType
        ElseIf ucaseCurveAbbrev = DM_UCASE_CURVE_ABBREV Then
        
            thePricingType = dmPricingType
        ElseIf ucaseCurveAbbrev = "L" Then
            thePricingType = dmPricingType
        ElseIf ucaseCurveAbbrev = "" Then
            thePricingType = dmPricingType 'Default to discount margin if a specific curve is not specified
        Else
            thePricingType = "????"
        End If
        
        pxInput = Right(spreadText, Len(spreadText) - indxOfPlus)
    End If
    
    out_thePricingType = thePricingType
    out_pxInput = convertToNumberIfPossible(pxInput)
End Sub

Function candidateIsDefinitelySpread(candidate As String) As Boolean


    If (InStr(1, candidate, "+") <> 0) Then
        candidateIsDefinitelySpread = True
    Else
        Dim adjusted As String
        adjusted = adjustIfNecessaryAndIsDefinitelySpraed(candidate)
        
        candidateIsDefinitelySpread = (adjusted <> candidate)
    
    End If
    
End Function

Function adjustIfNecessaryAndIsDefinitelySpraed(theSpreadText As String) As String

    
    If endsWith(theSpreadText, DM_UCASE_CURVE_ABBREV, False) Then
        Dim first As String
        Dim last As String
        first = left(theSpreadText, Len(theSpreadText) - Len(DM_UCASE_CURVE_ABBREV))
        last = Right(theSpreadText, Len(DM_UCASE_CURVE_ABBREV))
        
        If isNumber(first) Then
            adjustIfNecessaryAndIsDefinitelySpraed = DM_UCASE_CURVE_ABBREV & "+" & first
        Else
            adjustIfNecessaryAndIsDefinitelySpraed = theSpreadText
        End If
        
    Else
        adjustIfNecessaryAndIsDefinitelySpraed = theSpreadText
    End If

End Function
Attribute VB_Name = "JYUT_Names"
Option Explicit

Function getNamesForCellRnge(cellRnge As Range)

    Dim cellAddresses As Collection
    Set cellAddresses = New Collection
    
    Dim daCell As Range
    For Each daCell In cellRnge
        Dim cellAddress As String
        cellAddress = getFullRngeDefinition(daCell, True, True, True, False)
        
        cellAddresses.add cellAddress
    Next
    
    Dim nameObjectCollectionByRngeDefinition As Dictionary
    Set nameObjectCollectionByRngeDefinition = getNameObjectCollectionByRngeDefinition()
    
    Dim namesToReturn As Collection
    Set namesToReturn = New Collection
    
    Dim c As Long
    For c = 1 To cellAddresses.count
        Dim cellAddr As String
        cellAddr = cellAddresses.item(c)
        
        Dim modifiedAddress As String
        modifiedAddress = "=" & cellAddr
        
        If nameObjectCollectionByRngeDefinition.exists(modifiedAddress) Then
            Dim nameObjectCollection As Collection
            Set nameObjectCollection = nameObjectCollectionByRngeDefinition.item(modifiedAddress)
            
            Dim r As Long
            For r = 1 To nameObjectCollection.count
                Dim nameObj As name
                Set nameObj = nameObjectCollection.item(r)
                
                Dim thisName As String
                thisName = nameObj.name
                
                namesToReturn.add thisName
            Next
        End If
    Next
    
    Set getNamesForCellRnge = namesToReturn
    
End Function

Function getNameObjectCollectionByRngeDefinition() As Dictionary
    
    Dim nameObjCollectionByRefersTo As Dictionary
    Set nameObjCollectionByRefersTo = New Dictionary
    
    Dim names As Variant
    Set names = Application.names
    
    Dim c As Long
    For c = 1 To names.count
        Dim nameObj As name
        Set nameObj = names.item(c)
        
        Dim refersTo As String
        refersTo = nameObj.refersTo
        
        Dim nameObjCollection As Collection
        If nameObjCollectionByRefersTo.exists(refersTo) Then
            Set nameObjCollection = nameObjCollectionByRefersTo.item(refersTo)
        Else
            Set nameObjCollection = New Collection
            nameObjCollectionByRefersTo.add refersTo, nameObjCollection
        End If
        
        nameObjCollection.add nameObj
        
    Next
    
    Set getNameObjectCollectionByRngeDefinition = nameObjCollectionByRefersTo
    
End Function

Sub deleteNamesInWB(wb As Workbook)
    Dim namesList As Collection
    Set namesList = New Collection
    
    Dim curName As name
    For Each curName In wb.names
        namesList.add curName
    Next
    
    Dim c As Long
    For c = 1 To namesList.count
    
        Dim disName As name
        Set disName = namesList.item(c)
            
        deleteName disName, True
        
    Next
End Sub

'suppressPopups = false
Sub deleteName(nme As name, suppressPopups As Boolean)

    'JY20121218a - start - added to avoid pop-up messages when names can't be deleted for some reason
    Dim origDisplayAlerts As Variant
    Dim origEnableEvents As Variant
    origDisplayAlerts = Application.DisplayAlerts
    origEnableEvents = Application.enableEvents
    'JY20121218a - end

On Error GoTo ehs
    'JY20121218a - start - added to avoid pop-up messages when names can't be deleted for some reason
    If suppressPopups Then
        setDisplayAlerts False
        setEnableEvents False
    End If
    'JY20121218a - end
    
    nme.Delete
    
GoTo ehe
ehs:
    elg "Could not delete the name '" & nme & "'.  Msg=" & Err.description
ehe:
On Error GoTo 0

    'JY20121218a - start - added to avoid pop-up messages when names can't be deleted for some reason
    setDisplayAlerts origDisplayAlerts
    setEnableEvents origEnableEvents
    'JY20121218a - end - added to avoid pop-up messages when names can't be deleted for some reason
End Sub

Sub addNameToWorkbook(wb As Workbook, rn As String, referenceRngeOrDef As Variant)
On Error GoTo ehs
    wb.names.add name:=rn, refersTo:=referenceRngeOrDef
GoTo ehe
ehs:
    elwp "Could not add a name to the workbook.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Sub printNamesToLocation(topLeft As Range)

    Dim rns As Collection
    Set rns = New Collection
    
    Dim dadefs As Collection
    Set dadefs = New Collection

    Dim origCalc As Variant
    origCalc = tsctm()

    Dim dict As Dictionary
    Set dict = getNameObjectCollectionByRngeDefinition()
    
    Dim defs As Variant
    defs = dict.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs defs, lwr, upr
    
    Dim c As Long
    For c = lwr To upr
        Dim def As String
        def = defs(c)
        
        Dim coll As Collection
        Set coll = vfd(dict, def, True)
        
        Dim x As Long
        For x = 1 To coll.count
        
            Dim nameObj As name
            Set nameObj = coll.item(x)
            
            Dim rn As String
            rn = nameObj.name
            
            rns.add rn
            dadefs.add def
        Next
    Next
    
    scd topLeft, rns
    scd topLeft.offset(0, 1), dadefs
    
    rok origCalc
    
End Sub

Sub setRNsAcrossRow(rngForRNs As Range, rngForCellsToSet As Range, optWS As Worksheet)

    If Not rngForRNs.Worksheet Is rngForCellsToSet.Worksheet Then
        elwp "Ranges are on different worksheets!"
    Else
    
        Dim tlRowRNs As Long
        Dim tlColRNs As Long
        Dim brRowRNs As Long
        Dim brColRNs As Long
        getRngeBounds rngForRNs, tlRowRNs, tlColRNs, brRowRNs, brColRNs
        
        Dim tlRowAnks As Long
        Dim tlColAnks As Long
        Dim brRowAnks As Long
        Dim brColAnks As Long
        getRngeBounds rngForCellsToSet, tlRowAnks, tlColAnks, brRowAnks, brColAnks
    
        If tlRowRNs <> brRowRNs Then
            elwp "Please specify just a single-row range!"
        ElseIf tlRowAnks <> brRowAnks Then
            elwp "Please specify just a single-row range!"
        ElseIf tlColRNs <> tlColAnks Then
            elwp "Ranges don't line up!"
        ElseIf brColRNs <> brColAnks Then
            elwp "Ranges don't line up!"
        Else
        
            Dim ws As Worksheet
            Set ws = rngForRNs.Worksheet
        
            Dim startCol As Long
            Dim endCol As Long
            Dim rnsRow As Long
            Dim anksRow As Long
            startCol = tlColRNs
            endCol = brColRNs
            rnsRow = tlRowRNs
            anksRow = tlRowAnks
            
            Dim c As Long
            For c = startCol To endCol
                Dim rn As String
                rn = Trim(gvl(ws.cells(rnsRow, c)))
                
                Dim ankCell As Range
                Set ankCell = ws.cells(anksRow, c)
                
                sris ankCell
                
                addNameToWorkbook ws.Parent, rn, "=" & getFullRngeDefinition(ankCell, True, True, True, False)
                
            Next
            
            ilwp "Done!"
        End If
    End If
    
    

End Sub
Attribute VB_Name = "JYUT_PivTables"
Option Explicit

Public Const AGG_SUM As String = "sum"
Public Const AGG_AVG As String = "avg"

Sub applyOrderToPivotTable(pvtTable As PivotTable, fieldsToOrder As Variant, orderSpecificationByGroupingField As Dictionary)

    Dim lwr As Long
    Dim upr As Long
    lwr = LBound(fieldsToOrder, 1)
    upr = UBound(fieldsToOrder, 1)
    
    Dim rr As Long
    For rr = lwr To upr

        Dim fldToOrder As String
        fldToOrder = fieldsToOrder(rr)
        
        Dim valueOrderArr As Variant
        valueOrderArr = orderSpecificationByGroupingField.item(fldToOrder)
        
        Dim pivotField As pivotField
        Set pivotField = pvtTable.PivotFields(fldToOrder)
        
        Dim lw As Long
        Dim up As Long
        lw = LBound(valueOrderArr, 1)
        up = UBound(valueOrderArr, 1)
        
        Dim nextOrderIndx As Long
        nextOrderIndx = 1
        
        Dim ff As Long
        For ff = lw To up
            Dim curVal As String
            curVal = valueOrderArr(ff)
            
            Dim pivItem As PivotItem
            Set pivItem = getPivotItem(pivotField, curVal)
            
            If isNothing(pivItem) Then
                'DO NOTHING
            Else
                pivItem.Position = nextOrderIndx
                nextOrderIndx = nextOrderIndx + 1
            End If
        Next
    Next

End Sub

Sub createPivotTable(pTableDest As Range, ByRef out_ptable As PivotTable, sourceData As Range, tableName As String, dataOrientedInColumnsVsRow As Boolean, groupingFieldOrArrOfGroupingFieldsOrCollectionOfGroupingFields As Variant, groupingFieldOrientedInColumnVsRow As Boolean, listof_fieldNameAndDisplayNameAndAggregationMechanismAndOptEquationIfCalcField As Collection, optOrderSpecificationByGroupingField As Dictionary)

    srg pTableDest
    
    'This line seems to createa  pivot table on a new worksheet
    ActiveWorkbook.PivotCaches.create(SourceType:=xlDatabase, sourceData:= _
        sourceData, Version:=xlPivotTableVersion12).createPivotTable _
        tabledestination:="", tableName:=tableName, DefaultVersion:= _
        xlPivotTableVersion12

    Dim aWS As Worksheet
    Set aWS = ActiveSheet
    
    Dim destWS As Worksheet
    Set destWS = pTableDest.Worksheet
    
    Dim pTable As PivotTable
    'Set ptable = ActiveSheet.PivotTableWizard(TableDestination:=pTableDest)
    Set pTable = aWS.PivotTableWizard(tabledestination:=pTableDest)
    'Set ptable.sourceData = sourceData
    'ptable.name = tableName
    Set pTable = destWS.PivotTables(tableName) 'Do this so that we can delete the original worskheet that the pivot table wa son
    
    deleteWorksheet aWS.name
    
    srg pTableDest
    
    Dim arr As Variant
    arr = ensureValueIsAnArray(groupingFieldOrArrOfGroupingFieldsOrCollectionOfGroupingFields)
        
    Dim lower As Long
    Dim upper As Long
    lower = LBound(arr, 1)
    upper = UBound(arr, 1)
    
    Dim d As Long
    For d = lower To upper
        Dim nameOfGroupingField As String
        nameOfGroupingField = arr(d)
        
        With pTable.PivotFields(nameOfGroupingField)
            .Orientation = getOrientationValue(groupingFieldOrientedInColumnVsRow)
            .Position = (d - lower + 1)
        End With
    Next
    
    If isNothing(optOrderSpecificationByGroupingField) Then
        'DO NOTHING
    Else
    
        Dim fieldsToOrder As Variant
        fieldsToOrder = optOrderSpecificationByGroupingField.keys()
        
        Dim lwr As Long
        Dim upr As Long
        lwr = LBound(fieldsToOrder, 1)
        upr = UBound(fieldsToOrder, 1)
        
        Dim rr As Long
        For rr = lwr To upr
    
            Dim fldToOrder As String
            fldToOrder = fieldsToOrder(rr)
            
            Dim valueOrderArr As Variant
            valueOrderArr = optOrderSpecificationByGroupingField.item(fldToOrder)
            
            Dim pivotField As pivotField
            Set pivotField = pTable.PivotFields(fldToOrder)
            
            Dim lw As Long
            Dim up As Long
            lw = LBound(valueOrderArr, 1)
            up = UBound(valueOrderArr, 1)
            
            Dim nextOrderIndx As Long
            nextOrderIndx = 1
            
            Dim ff As Long
            For ff = lw To up
                Dim curVal As String
                curVal = valueOrderArr(ff)
                
                Dim pivItem As PivotItem
                Set pivItem = getPivotItem(pivotField, curVal)
                
                If isNothing(pivItem) Then
                    'DO NOTHING
                Else
                    pivItem.Position = nextOrderIndx
                    nextOrderIndx = nextOrderIndx + 1
                End If
            Next
        Next
    End If
    
    Dim c As Long
    For c = 1 To listof_fieldNameAndDisplayNameAndAggregationMechanismAndOptEquationIfCalcField.count
        Dim fieldNameAndDisplayNameAndAggregationMechanism As Variant
        fieldNameAndDisplayNameAndAggregationMechanism = listof_fieldNameAndDisplayNameAndAggregationMechanismAndOptEquationIfCalcField.item(c)
        
        Dim fieldName As String
        Dim dispName As String
        Dim aggMechanism As String
        Dim optEquationIfCalculatedField As String
        fieldName = rlai(fieldNameAndDisplayNameAndAggregationMechanism, 1)
        dispName = rlai(fieldNameAndDisplayNameAndAggregationMechanism, 2)
        aggMechanism = rlai(fieldNameAndDisplayNameAndAggregationMechanism, 3)
        optEquationIfCalculatedField = rlai(fieldNameAndDisplayNameAndAggregationMechanism, 4)
        
        Dim agg As Variant
        If aggMechanism = AGG_SUM Then
            agg = xlSum
        ElseIf aggMechanism = AGG_AVG Then
            agg = xlAverage
        Else
            elwp "Unknown agg type: " & agg
            agg = xlSum 'default value
        End If
        
        If optEquationIfCalculatedField = "" Then
            pTable.AddDataField ActiveSheet.PivotTables(tableName).PivotFields(fieldName), dispName, xlSum
        Else
            pTable.CalculatedFields.add fieldName, optEquationIfCalculatedField, True
            pTable.PivotFields(fieldName).Orientation = xlDataField
        End If
        
        
        
        
    Next
    
    'pTable.PivotSelect "'Sum of Equivalents 2Yr TSY'", xlDataAndLabel, True
    

    If listof_fieldNameAndDisplayNameAndAggregationMechanismAndOptEquationIfCalcField.count > 1 Then
        With pTable.DataPivotField
            .Orientation = getOrientationValue(dataOrientedInColumnsVsRow)
            .Position = 1
        End With
    End If
    Set out_ptable = pTable

End Sub

Function getOrientationValue(desiredOrientationInColumnsVsRow As Boolean)
    If desiredOrientationInColumnsVsRow Then
        getOrientationValue = xlColumnField
    Else
        getOrientationValue = xlRowField
    End If
End Function

Function getPivotItem(pivotField As pivotField, pivotName As String) As PivotItem
    Dim pivItem As PivotItem
    Set pivItem = Nothing
    
On Error GoTo ehs
    Set pivItem = pivotField.PivotItems(pivotName)
GoTo ehe
ehs:
    elg "Could not retrieve the pivot item named '" & pivotName & "'.  Msg=" & Err.description
ehe:
On Error GoTo 0

    Set getPivotItem = pivItem
End Function

'showSuccessMessage = false
Sub refreshPivotTable(optWS As Worksheet, tableName As String, disableNotifications As Boolean, showSuccessMessage As Boolean)

    Dim origSel As Range
    Set origSel = getCurSel()

    Dim emsg As String
    Dim pTable As PivotTable
    doRefreshPivotTable optWS, tableName, disableNotifications, emsg, pTable

    scmForPivotTable pTable, emsg, origSel, showSuccessMessage
End Sub

'scm = "showCompletedMessage"
Sub scmForPivotTable(pTable As PivotTable, emsg As Variant, origSel As Range, showSuccessMessage As Boolean)
    
    Dim emsgs As Variant
    atr emsgs, convertEmsgsToSomethingThatCanBeCountedAndAlsoRepresentedAsAString(emsg)
    
    Dim tableName As String
    tableName = pTable.name
    
    Dim successMsg As String
    successMsg = "Refreshed the pivot table '" & tableName & "'!"

    If emsgs.count = 0 Then
        If showSuccessMessage Then
            scm successMsg, emsgs, Nothing
        End If
    Else

        sris pTable.TableRange1
        
        If showSuccessMessage Then
            scm successMsg, emsgs, Nothing
        End If
        
        sris origSel
    End If

End Sub


Sub refreshPassedInPivTable(pTable As PivotTable, disableNotifications As Boolean, ByRef out_emsg As String)

    Dim emsg As String
    emsg = ""
    
    Dim dispAlerts As Boolean
    dispAlerts = Application.DisplayAlerts

On Error GoTo ehe

    If disableNotifications Then
        Application.DisplayAlerts = False
    End If

    pTable.PivotCache.Refresh
    
GoTo ehe
ehs:
    emsg = "Could not refresh the pivot table '" & pTable.name & "'.  Msg=" & Err.description
ehe:
On Error GoTo 0

    If Application.DisplayAlerts <> dispAlerts Then
        Application.DisplayAlerts = dispAlerts
    End If

    out_emsg = emsg


End Sub

Sub doRefreshPivotTable(optWS As Worksheet, tableName As String, disableNotifications As Boolean, ByRef out_emsg As String, ByRef out_ptable As PivotTable)
    
    Dim pTable As PivotTable
    Dim emsg As String
    Set pTable = getPivotTable(tableName, optWS, emsg)
    
On Error GoTo ehe
    
    If emsg <> "" Then
        elwp emsg
    ElseIf isNothing(pTable) Then
        elwp "Could not find our pivot table for some reason."
    Else
        refreshPassedInPivTable pTable, disableNotifications, out_emsg
        emsg = ""
    End If
    
    Set out_ptable = pTable
    
    
GoTo ehe
ehs:
    emsg = "Could not refresh the pivot table '" & tableName & "'.  Msg=" & Err.description
ehe:
On Error GoTo 0

    out_emsg = emsg
    
End Sub

Function getCategoriesFromPivotTableContainingJustOneBucket(pTableName As String, optWSForPivotTables As Worksheet, ByRef mod_emsgs As Variant)

    Dim rowLabelsAnk As Range
    Dim firstRowOfData As Long
    Dim lastRowOfData As Long
    Set rowLabelsAnk = getRowLabelsAnkFromPivotTableContainingJustOneBucket(pTableName, optWSForPivotTables, mod_emsgs, firstRowOfData, lastRowOfData, 0)
     
    Dim buckets As Collection
    Set buckets = New Collection
    
    Dim row As Long
    For row = firstRowOfData To lastRowOfData
        buckets.add gcicsr(rowLabelsAnk, row)
    Next

    Set getCategoriesFromPivotTableContainingJustOneBucket = buckets

End Function

Function getValueByNameFromPivotTableContainingJustOneBucketAndOneValue(pTableName As String, optWSForPivotTables As Worksheet, expectedDataHeaderName As String, ByRef mod_emsgs As Variant) As Dictionary

    Dim valueByName As Dictionary
    Set valueByName = New Dictionary
    
    Dim rowLabelsAnk As Range
    Dim firstRowOfData As Long
    Dim lastRowOfData As Long
    Set rowLabelsAnk = getRowLabelsAnkFromPivotTableContainingJustOneBucket(pTableName, optWSForPivotTables, mod_emsgs, firstRowOfData, lastRowOfData, -1)

    If isNothing(rowLabelsAnk) Then
        mod_emsgs.add "Could not obtain our row labels ank."
    Else
    
        Dim dataAnk As Range
        Set dataAnk = shiftRnge(rowLabelsAnk, 0, 1)
    
        If Not sae2(gvl(dataAnk), expectedDataHeaderName, True, False) Then
            mod_emsgs.add "Our pivot table named '" & pTableName & "' is not in the format we expected!  Cannot query data from it."
        Else
            
            Dim row As Long
            For row = firstRowOfData To lastRowOfData
                Dim theName As String
                Dim theValue As Variant
                theName = gvl(gcicsr(rowLabelsAnk, row))
                theValue = gvl(gcicsr(dataAnk, row))
                
                If valueByName.exists(theName) Then
                    mod_emsgs.add "Found multiple values of '" & theName & "' in the pivot table '" & pTableName & "'!  We will only keep the first value."
                Else
                    atd valueByName, theName, theValue
                End If
            Next
            
        End If
    End If
    
    Set getValueByNameFromPivotTableContainingJustOneBucketAndOneValue = valueByName
End Function

Function getPivotTablesWithCertainNameThatExistInParticularWorkbook(tableName As String, wb As Workbook) As Collection

    'Cycle through all the worksheets, looking for our pivot table.
    
    Dim results As Collection
    Set results = New Collection
    
    Dim allWorksheets As Collection
    Set allWorksheets = getAllWorksheetsInWorkbook(wb)
    
    Dim c As Long
    For c = 1 To allWorksheets.count
        Dim curWS As Worksheet
        Set curWS = allWorksheets.item(c)
        
        Dim pTable As PivotTable
        Set pTable = getPivTable(tableName, curWS)
        
        If isNothing(pTable) Then
            'DO NOTHING
        Else
            results.add pTable
        End If
    
    Next
    
    Set getPivotTablesWithCertainNameThatExistInParticularWorkbook = results

End Function

Function getPivotTable(tableName As String, optWS As Worksheet, ByRef out_reasonForNotFindingPivotTable As String) As PivotTable
    
    Dim reasonForNotFindingPivotTable As String
    reasonForNotFindingPivotTable = "ERROR: NOT SET!"
    
    Dim wb As Workbook
    Set wb = ActiveWorkbook
    
    Dim pTable As PivotTable
    If Not isNothing(optWS) Then
        Set pTable = getPivTable(tableName, optWS)
        If isNothing(pTable) Then
            reasonForNotFindingPivotTable = "Could not find our pivot table for some reason."
        Else
            reasonForNotFindingPivotTable = ""
        End If
    Else
    
        Dim candidatePTables As Collection
        Set candidatePTables = getPivotTablesWithCertainNameThatExistInParticularWorkbook(tableName, wb)
        
        If candidatePTables.count <> 1 Then
            reasonForNotFindingPivotTable = "Cannot figure out which pivot table to query, because there are " & candidatePTables.count & " pivot tables named '" & tableName & "' in our workbook!"
            Set pTable = Nothing
        Else
            Set pTable = candidatePTables.item(1)
            reasonForNotFindingPivotTable = ""
        End If
        
    End If
    out_reasonForNotFindingPivotTable = reasonForNotFindingPivotTable
    Set getPivotTable = pTable
End Function

Function getPivTable(tableName As String, ws As Worksheet) As PivotTable
    
    Dim pivTable As PivotTable
    Set pivTable = Nothing
    
On Error GoTo ehe
    
    Set getPivTable = ws.PivotTables(tableName)
    
GoTo ehe
ehs:
    'DO NOTHING
    
    ilg Err.description 'ilg instead of elg because this is not really an error, we expect to get an error thrown if the pivot table does not exist.
    
    'Pivot table was not found.
    
ehe:
On Error GoTo 0

End Function

Sub refreshAllPivotTables(wb As Workbook, showSuccessMessage As Boolean)
    
    wb.RefreshAll
     
    If showSuccessMessage Then
        ilwp "All pivot tables in this workbook have been refreshed!"
    End If
    
End Sub

Sub setPivotTablePage(pTable As PivotTable, pivotFieldName As String, whichPage As String)
On Error GoTo ehs
    pTable.PivotFields(pivotFieldName).CurrentPage = whichPage
GoTo ehe
ehs:
    elwp "Could not set pivot table page to '" & whichPage & "'.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

Sub sortPTableField(pTable As PivotTable, fieldName As String)
    pTable.PivotFields(fieldName).AutoSort xlAscending, fieldName
End Sub

Function getDataFieldNamesFromPivotTable(pTable As PivotTable) As Variant
    
    Dim sz As Long
    sz = pTable.DataFields.count
    
    
    Dim fldNames As Variant
    ReDim fldNames(1 To sz)
    
    Dim c As Long
    For c = 1 To sz
        fldNames(c) = pTable.DataFields.item(c)
    Next
    
    getDataFieldNamesFromPivotTable = fldNames
    
End Function


'TO DO: unify this function with the "getFormulaForQueryingPivotTable" one
'gptf stands for "getPivotTableFormula"
Function gptf(wsWhereFormulaIsToBeAddedTo As Worksheet, extractWS As Worksheet, pTableName As String, dataFieldOrCellContainingIt As Variant, fieldName_and_valueOrCellContainingTheValue__or__arrayOfThem As Variant) As String
    
    Dim optionalFieldFilteringString As String
    optionalFieldFilteringString = ""
    
    If isNothing(fieldName_and_valueOrCellContainingTheValue__or__arrayOfThem) Then
        'DO NOTHING
    Else
    
        Dim weHaveListOfArrays As Boolean
        weHaveListOfArrays = allArrayElementsAreArrays(fieldName_and_valueOrCellContainingTheValue__or__arrayOfThem)
    
        Dim ourList As Variant
        If Not weHaveListOfArrays Then
            ourList = Array(fieldName_and_valueOrCellContainingTheValue__or__arrayOfThem)
        Else
            ourList = fieldName_and_valueOrCellContainingTheValue__or__arrayOfThem
        End If
    
        Dim lwr As Long
        Dim upr As Long
        glaubs ourList, lwr, upr
        
        Dim c As Long
        For c = lwr To upr
        
            Dim fieldName_and_valueOrCellContainingTheValue As Variant
            fieldName_and_valueOrCellContainingTheValue = ourList(c)
            
            If dimSize(fieldName_and_valueOrCellContainingTheValue, 1) <> 2 Then
                elwp "received an unexpected size!"
            Else
        
                Dim fieldName As String
                Dim valueStringOrCellContainingTheValue As Variant
                fieldName = rlai(fieldName_and_valueOrCellContainingTheValue, 1)
                atr valueStringOrCellContainingTheValue, rlai(fieldName_and_valueOrCellContainingTheValue, 2)
            
                Dim fieldValue As Variant
                fieldValue = getFieldValue(valueStringOrCellContainingTheValue, wsWhereFormulaIsToBeAddedTo)
            
                'The double-quotes in the beginning are there on purpose
                optionalFieldFilteringString = optionalFieldFilteringString & ", """ & fieldName & """, """"&" & fieldValue
                
                
            End If
        Next
    
    End If
    
    Dim dataFieldValue As Variant
    dataFieldValue = getFieldValue(dataFieldOrCellContainingIt, wsWhereFormulaIsToBeAddedTo)
    
    
    Dim ptableAddress As String
    If wsWhereFormulaIsToBeAddedTo Is extractWS Then
        ptableAddress = pTableName
    Else
        ptableAddress = extractWS.name & "!" & pTableName
    End If
    
    Dim wbOfExtract As Workbook
    Set wbOfExtract = extractWS.Parent
    
    If wbOfExtract Is wsWhereFormulaIsToBeAddedTo.Parent Then
        'DO NOTHING
    Else
        ptableAddress = appendWBName(wbOfExtract.name, ptableAddress)
    End If
    
    'The double-quotes in the beginning are there on purpose
    gptf = "GETPIVOTDATA(""""&" & dataFieldValue & "," & ptableAddress & optionalFieldFilteringString & ")"
End Function
'TO DO: unify this function with the "gptf" one
Function getFormulaForQueryingPivotTable(pTable As PivotTable, dataToShowFieldName As String, fieldNamesToQueryBy As Variant, valuesToQueryBy As Variant, valueToShowForZeroesAndNotFounds_orNothingToNotPerformAnySubstitution As Variant) As String
    
    Dim anyCellInPivotTableArea As Range
    Set anyCellInPivotTableArea = tlcor(pTable.TableRange1)

    Dim rnForPivotTable As String
    rnForPivotTable = getFullRngeDefinition(anyCellInPivotTableArea, True, True, True, False)
            
    Dim formulaSoFar As String
    formulaSoFar = "GETPIVOTDATA(""" & dataToShowFieldName & """," & rnForPivotTable
    
    Dim sz As Long
    sz = casz(Array(fieldNamesToQueryBy, valuesToQueryBy), True)
    
    Dim c As Long
    For c = 1 To sz
        Dim fName As String
        Dim theVal As String
        fName = rlai(fieldNamesToQueryBy, c)
        theVal = rlai(valuesToQueryBy, c)
        
        formulaSoFar = formulaSoFar & ",""" & fName & """," & theVal
    Next
    
    formulaSoFar = formulaSoFar & ")"
    
    If isNothing(valueToShowForZeroesAndNotFounds_orNothingToNotPerformAnySubstitution) Then
        'DO NOTHING
    Else
        Dim chosenValue As String
        If isNumber(valueToShowForZeroesAndNotFounds_orNothingToNotPerformAnySubstitution) Then
            chosenValue = valueToShowForZeroesAndNotFounds_orNothingToNotPerformAnySubstitution
        Else
            chosenValue = """" & valueToShowForZeroesAndNotFounds_orNothingToNotPerformAnySubstitution & """"
        End If
        
        formulaSoFar = "IF(0=" & formulaSoFar & "," & chosenValue & "," & formulaSoFar & ")"
        formulaSoFar = "IFERROR(" & formulaSoFar & "," & chosenValue & ")"
    End If
    getFormulaForQueryingPivotTable = formulaSoFar
End Function
   
Function retrieveValueFromPivotTable(ByRef mod_emsgs As Variant, pivotTableName As String, optWSForPivotTable As Worksheet, nameOfFieldToRetrieve As String, fieldOneName As Variant, fieldOneValue As Variant, Optional fieldTwoName As Variant, Optional fieldTwoValue As Variant, Optional fieldThreeName As Variant, Optional fieldThreeValue As Variant, Optional fieldFourName As Variant, Optional fieldFourValue As Variant) As Variant

On Error GoTo ehs

    Dim listOPassedInFieldNameAndFieldValue As Collection
    Set listOPassedInFieldNameAndFieldValue = New Collection
    With listOPassedInFieldNameAndFieldValue
        .add Array(fieldOneName, fieldOneValue)
        .add Array(fieldTwoName, fieldTwoValue)
        .add Array(fieldThreeName, fieldThreeValue)
        .add Array(fieldFourName, fieldFourValue)
    End With
    
    Dim listOfFieldNameAndValue As Collection
    Set listOfFieldNameAndValue = New Collection
    
    Dim c As Long
    For c = 1 To listOPassedInFieldNameAndFieldValue.count
        Dim fieldName_fieldValue As Variant
        fieldName_fieldValue = listOPassedInFieldNameAndFieldValue.item(c)
        
        Dim fldName As Variant
        Dim fldValue As Variant
        fldName = rlai(fieldName_fieldValue, 1)
        fldValue = rlai(fieldName_fieldValue, 2)
        
        If IsMissing(fldName) And IsMissing(fldValue) Then
            'DO NOTHING
        ElseIf IsMissing(fldName) Or IsMissing(fldValue) Then
            mod_emsgs.add "Whenever you specify a field name, you must specify a field value... and vice versa!"
        Else
            listOfFieldNameAndValue.add Array(fldName, fldValue)
        End If
    Next
    
    Dim fieldNames_fieldValues As Collection
    Set fieldNames_fieldValues = sciloar(True, listOfFieldNameAndValue)
        
    Dim fieldNames As Collection
    Dim fieldValues As Collection
    Set fieldNames = fieldNames_fieldValues.item(1)
    Set fieldValues = fieldNames_fieldValues.item(2)
    
    Dim pTable As PivotTable
    Dim reasonForNotFindingIt As String
    Set pTable = getPivotTable(pivotTableName, optWSForPivotTable, reasonForNotFindingIt)
    
    
    Dim retValue As Variant
    If reasonForNotFindingIt <> "" Then
        mod_emsgs.add reasonForNotFindingIt
        retValue = reasonForNotFindingIt
    ElseIf isNothing(pTable) Then
        mod_emsgs.add "Could not find our pivot table for some reason!"
        retValue = "Could not find our pivot table for some reason!"
    Else
        retValue = getDaPivotTableData(pTable, nameOfFieldToRetrieve, fieldNames, fieldValues, mod_emsgs)
    End If

GoTo ehe
ehs:
    Dim daEmsg As String
    daEmsg = Err.description
    elwp daEmsg
    retValue = daEmsg
    
ehe:
On Error GoTo 0

    atr retrieveValueFromPivotTable, retValue
End Function

Function getDaPivotTableData(pTable As PivotTable, nameOfFieldToRetrieve As String, fieldNames As Collection, fieldValues As Collection, ByRef mod_emsgs As Variant) As Variant
    
On Error GoTo ehs
    
    Dim numParams As Long
    numParams = ccsz(Array(fieldNames, fieldValues), True)

    Dim retValue As Variant
    If numParams = 1 Then
        retValue = pTable.GetPivotData(nameOfFieldToRetrieve, fieldNames.item(1), fieldValues.item(1))
    ElseIf numParams = 2 Then
        retValue = pTable.GetPivotData(nameOfFieldToRetrieve, fieldNames.item(1), fieldValues.item(1), fieldNames.item(2), fieldValues.item(2))
    ElseIf numParams = 3 Then
        retValue = pTable.GetPivotData(nameOfFieldToRetrieve, fieldNames.item(1), fieldValues.item(1), fieldNames.item(2), fieldValues.item(2), fieldNames.item(3), fieldValues.item(3))
    ElseIf numParams = 4 Then
        retValue = pTable.GetPivotData(nameOfFieldToRetrieve, fieldNames.item(1), fieldValues.item(1), fieldNames.item(2), fieldValues.item(2), fieldNames.item(3), fieldValues.item(3), fieldNames.item(4), fieldValues.item(4))
    ElseIf numParams = 5 Then
        retValue = pTable.GetPivotData(nameOfFieldToRetrieve, fieldNames.item(1), fieldValues.item(1), fieldNames.item(2), fieldValues.item(2), fieldNames.item(3), fieldValues.item(3), fieldNames.item(4), fieldValues.item(4), fieldNames.item(5), fieldValues.item(5))
    Else
        Dim myEmsg As String
        myEmsg = "Unsupported number of parameters: " & numParams
        
        mod_emsgs.add myEmsg
        
        Set retValue = Nothing
    End If
    
GoTo ehe
ehs:
    'The data was not available in the pivot table.
    retValue = 0
ehe:
On Error GoTo 0
    
    atr getDaPivotTableData, retValue
    
End Function

Function getRowLabelsAnkFromPivotTableContainingJustOneBucket(pTableName As String, optWSForPivotTables As Worksheet, ByRef mod_emsgs As Variant, ByRef out_firstRowOfData As Long, ByRef out_lastRowOfData As Long, colOffsetForRowLabels As Long) As Range
    
    Dim pTable As PivotTable
    Dim reasonForNotFindingPivotTable As String
    Set pTable = getPivotTable(pTableName, optWSForPivotTables, reasonForNotFindingPivotTable)
    
    Dim dataBodyRnge As Range
    Set dataBodyRnge = pTable.DataBodyRange
    
    Dim lastRowOfData As Long
    lastRowOfData = brcor(dataBodyRnge).row
    
    Dim firstRowOfData As Long
    firstRowOfData = tlcor(dataBodyRnge).row
    
    Dim rowLabelsAnk As Range
    Set rowLabelsAnk = shiftRnge(tlcor(dataBodyRnge), -1, colOffsetForRowLabels)
    
    Dim retValue As Range
    If Not sae2(gvl(rowLabelsAnk), "Row Labels", True, False) Then
        mod_emsgs.add "Our pivot table '" & pTableName & "' is not in the format we expected!  Cannot query data from it."
        Set retValue = Nothing
    Else
        Set retValue = rowLabelsAnk
    End If
    out_firstRowOfData = firstRowOfData
    out_lastRowOfData = lastRowOfData
    Set getRowLabelsAnkFromPivotTableContainingJustOneBucket = retValue
End Function
Attribute VB_Name = "JYUT_Print"
Option Explicit

Sub setPrintRngeAndEnsureOnePageWideAndOnePageTall(rng As Range, landscapeVsPortrait As Boolean, centerHorizontally As Boolean, centerVertically As Boolean)
    Dim ws As Worksheet
    Set ws = rng.Worksheet

    ws.PageSetup.printArea = getFullRngeDefinition(rng.EntireColumn, False, True, True, False)
    With ws.PageSetup
        .centerHorizontally = centerHorizontally
        .centerVertically = centerVertically
        .Orientation = IIf(landscapeVsPortrait, xlLandscape, xlPortrait)
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = 1
    End With
End Sub

Sub setPrintRngeAndEnsureOnePageWide(rng As Range, landscapeVsPortrait As Boolean, centerHorizontally As Boolean, centerVertically As Boolean)

    Dim ws As Worksheet
    Set ws = rng.Worksheet

    ws.PageSetup.printArea = getFullRngeDefinition(rng.EntireColumn, False, True, True, False)
    With ws.PageSetup
        '.LeftHeader = ""
        '.CenterHeader = ""
        '.RightHeader = ""
        '.LeftFooter = ""
        '.CenterFooter = ""
        '.RightFooter = ""
        '.LeftMargin = Application.InchesToPoints(0.7)
        '.RightMargin = Application.InchesToPoints(0.7)
        '.TopMargin = Application.InchesToPoints(0.75)
        '.BottomMargin = Application.InchesToPoints(0.75)
        '.HeaderMargin = Application.InchesToPoints(0.3)
        '.FooterMargin = Application.InchesToPoints(0.3)
        
        '.PrintHeadings = False
        '.PrintGridlines = False
        '.PrintComments = xlPrintNoComments
        '.PrintQuality = 600
        .centerHorizontally = centerHorizontally
        .centerVertically = centerVertically
        .Orientation = IIf(landscapeVsPortrait, xlLandscape, xlPortrait)
        
        '.Draft = False
        '.PaperSize = xlPaperLetter
        '.FirstPageNumber = xlAutomatic
        '.Order = xlDownThenOver
        '.BlackAndWhite = False
        .Zoom = False
        .FitToPagesWide = 1
        .FitToPagesTall = False
    End With
    
End Sub

Sub adjustMarginsToNarrow(ws As Worksheet)
    With ws.PageSetup
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.75)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)
    End With
End Sub

Attribute VB_Name = "JYUT_Ranges"
Option Explicit

Public Const OVERFLOW_ERROR_DESC As String = "Overflow"

Public Const LAST_POSSIBLE_ROW As Long = 1048576
Public Const LAST_POSSIBLE_ROW_65536 As Long = 65536
Public Const LAST_POSSIBLE_COL As Long = 16384

Sub setRngeValue(rng As Range, value As Variant)
On Error GoTo ehs
    rng.value = value
GoTo ehe
ehs:
    elwp "Could not set the value of range " & getFullRngeDefinition(rng, True, False, False, False) & ".  Reason: " & Err.description
ehe:
On Error GoTo 0

End Sub


Sub setCellValue(cell As Range, value As Variant)
    setRngeValue cell, value
End Sub

Function bottomLeftCellOfRnge(theRnge As Range) As Range
    Set bottomLeftCellOfRnge = theRnge.cells(theRnge.rows.count, 1)
End Function

Function convertCellsToRngeDefs(cellsToConvert As Collection, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, useR1C1 As Boolean) As Collection
    
    Dim defs As Collection
    Set defs = New Collection
    Dim qq As Long
    For qq = 1 To cellsToConvert.count
        Dim cfCell As Range
        Set cfCell = cellsToConvert.item(qq)
        
        Dim def As String
        def = getFullRngeDefinition(cfCell, includeWSName, absoluteforcolumn, absoluteForRow, useR1C1)
        
        defs.add def
    Next
    
    Set convertCellsToRngeDefs = defs
End Function

Function constructSumFormula(expressions As Collection) As String
    
    Dim parenWrapped As Collection
    Set parenWrapped = ensureThatEachItemInCollectionIsWrappedByExactlyOneSetOfEnclosingParentheses(expressions)
    
    constructSumFormula = ensureThatExactlyOneSetOfEnclosingParenthesisExistsAroundExpression(cltstr(parenWrapped, "+", ""))
    
End Function


Function constructSumProductFormula(listOfFirstExpressions As Collection, listOfSecondExpressions As Collection, ByRef mod_emsgs As Variant) As String
    
    
    Dim sz As Long
    sz = ccsz(Array(listOfFirstExpressions, listOfSecondExpressions), False)
    
    Dim sumProdExpressionForLeverageFormula As String
    If sz = VALUE_REPRESENTING_INCONSISTENT_SIZES Then
        mod_emsgs.add "Encountered an unexpected error while trying to figure out our sumproduct formula."
        sumProdExpressionForLeverageFormula = "0"
    Else
        
        Dim expressions As Collection
        Set expressions = New Collection
        Dim jj As Long
        For jj = 1 To sz
            Dim firstExp As String
            Dim secondExp As String
            firstExp = ensureThatExactlyOneSetOfEnclosingParenthesisExistsAroundExpression(listOfFirstExpressions.item(jj))
            secondExp = ensureThatExactlyOneSetOfEnclosingParenthesisExistsAroundExpression(listOfSecondExpressions.item(jj))
            
            expressions.add firstExp & "*" & secondExp
        Next
        
        sumProdExpressionForLeverageFormula = constructSumFormula(expressions)
        
    End If
    constructSumProductFormula = sumProdExpressionForLeverageFormula
End Function

Function getFullRngeDefinition_colonDelimiter(theRnge As Range, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, Optional refCellIfDoingR1C1NotionForRelativeReference As Range) As String
    getFullRngeDefinition_colonDelimiter = getFullRngeDefinition_customDelimiter(":", theRnge, includeWSName, absoluteforcolumn, absoluteForRow, False, refCellIfDoingR1C1NotionForRelativeReference)
End Function

Function rngesAreEqual(rng1 As Range, rng2 As Range) As Boolean
    rngesAreEqual = getFullRngeDefinition(rng1, True, True, True, False) = getFullRngeDefinition(rng2, True, True, True, False)
End Function

Function getFullRngeDefinitions(rngeOrArrayOfRngesOrCollectionOfRnges As Variant, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, useR1C1 As Boolean) As Variant
    
    Dim arrOfRnges As Variant
    arrOfRnges = ensureValueIsAnArray(rngeOrArrayOfRngesOrCollectionOfRnges)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arrOfRnges, lwr, upr
    
    Dim arr As Variant
    ReDim arr(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim curRnge As Range
        Set curRnge = arrOfRnges(c)
    
        arr(c) = getFullRngeDefinition(curRnge, includeWSName, absoluteforcolumn, absoluteForRow, useR1C1)
    Next
    getFullRngeDefinitions = arr
End Function

'blankCellsAreExpectedAndOk = false
Function getRNsForListOfCells(arrayOrCollectionOfRnges As Variant, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, useR1C1 As Boolean, blankCellsAreExpectedAndOk As Boolean) As Variant

    Dim theRnges As Variant
    If isCollection(arrayOrCollectionOfRnges) Then
        theRnges = collectionToArray(castToCollection(arrayOrCollectionOfRnges))
    Else
        theRnges = arrayOrCollectionOfRnges
    End If
    
    Dim lwr As Long
    Dim upr As Long
    glaubs theRnges, lwr, upr
    
    Dim rns As Variant
    ReDim rns(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim rng As Range
        Set rng = theRnges(c)
        
        If isNothing(rng) Then
            If Not blankCellsAreExpectedAndOk Then
                elwp "You passed in a blank cell!"
            End If
            rns(c) = ""
        Else
            rns(c) = getFullRngeDefinition(rng, includeWSName, absoluteforcolumn, absoluteForRow, useR1C1)
        End If
    Next
    
    getRNsForListOfCells = rns

End Function

Function getFullRngeDefinition(theRnge As Range, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, useR1C1 As Boolean, Optional refCellIfDoingR1C1NotionForRelativeReference As Range) As String
    Dim delimiter As String
    If useR1C1 Then
        delimiter = ".."
    Else
        delimiter = ":"
    End If
    getFullRngeDefinition = getFullRngeDefinition_customDelimiter(delimiter, theRnge, includeWSName, absoluteforcolumn, absoluteForRow, useR1C1, refCellIfDoingR1C1NotionForRelativeReference)
End Function

Function getFullRngeDefinition_r1c1(theRnge As Range, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, Optional refCellIfDoingR1C1NotionForRelativeReference As Range) As String
    getFullRngeDefinition_r1c1 = getFullRngeDefinition_customDelimiter(":", theRnge, includeWSName, absoluteforcolumn, absoluteForRow, True, refCellIfDoingR1C1NotionForRelativeReference)
End Function

Function getFullRngeDefinition_customDelimiter(delimiter As String, theRnge As Range, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, useR1C1 As Boolean, Optional refCellIfDoingR1C1NotionForRelativeReference As Range) As String

    Dim rngeDef As String
    If theRnge.cells.count = 1 Then
        rngeDef = getFullRngeDefinition_forSingleCell_withoutWorksheet(theRnge, absoluteforcolumn, absoluteForRow, useR1C1, refCellIfDoingR1C1NotionForRelativeReference)
    Else
    
        Dim topLeft As Range
        Set topLeft = tlcor(theRnge)
        
        Dim bottomRight As Range
        Set bottomRight = brcor(theRnge)
        
        Dim topLeftDef As String
        topLeftDef = getFullRngeDefinition_forSingleCell_withoutWorksheet(topLeft, absoluteforcolumn, absoluteForRow, useR1C1, refCellIfDoingR1C1NotionForRelativeReference)
        
        Dim bottomRightDef As String
        bottomRightDef = getFullRngeDefinition_forSingleCell_withoutWorksheet(bottomRight, absoluteforcolumn, absoluteForRow, useR1C1, refCellIfDoingR1C1NotionForRelativeReference)
    
        rngeDef = topLeftDef & delimiter & bottomRightDef
        
    End If
        
    If includeWSName Then
        rngeDef = appendWSName(theRnge.Worksheet.name, rngeDef)
    End If
    
    getFullRngeDefinition_customDelimiter = rngeDef
        

End Function

Function appendWBName(wbName As String, rngeDef As String) As String
    
    If stringContains(rngeDef, "!") Then
        appendWBName = "[" & wbName & "]" & rngeDef
    Else
        appendWBName = wbName & "!" & rngeDef
    End If
End Function
Function getFullRngeDefinition_forSingleCell_withoutWorksheet(theRnge As Range, absoluteforcolumn As Boolean, absoluteForRow As Boolean, useR1C1 As Boolean, Optional refCellIfDoingR1C1NotionForRelativeReference As Range) As String
    If theRnge.cells.count <> 1 Then
        Dim emsg As String
        emsg = "Multiple cell selections are not supported by this function!"
        elwp emsg
        getFullRngeDefinition_forSingleCell_withoutWorksheet = emsg
    Else
        
        Dim row As Long
        Dim col As Long
        row = theRnge.row
        col = theRnge.column
        
        Dim def As String
        If useR1C1 Then
            def = "R" & getRowOrColR1C1Notation(absoluteForRow, row, True, refCellIfDoingR1C1NotionForRelativeReference) & "C" & getRowOrColR1C1Notation(absoluteforcolumn, col, False, refCellIfDoingR1C1NotionForRelativeReference)
        Else
        
            Dim columnLetter As String
            columnLetter = columnNumberToLetter(col)
        
            def = IIf(absoluteforcolumn, "$", "") & columnLetter & IIf(absoluteForRow, "$", "") & row
        
        End If
        getFullRngeDefinition_forSingleCell_withoutWorksheet = def
    End If

End Function

Function getRowOrColR1C1Notation(absVsRel As Boolean, rowOrCol As Long, dealingWithRowVsCol As Boolean, refCellIfDoingR1C1NotionForRelativeReference As Range) As String
    
    If absVsRel Then
        getRowOrColR1C1Notation = rowOrCol
    Else
        
        Dim relOffSet As String
        If isNothing(refCellIfDoingR1C1NotionForRelativeReference) Then
            relOffSet = ""
        Else
        
            Dim baseIndx As Long
            If dealingWithRowVsCol Then
                baseIndx = refCellIfDoingR1C1NotionForRelativeReference.row
            Else
                baseIndx = refCellIfDoingR1C1NotionForRelativeReference.column
            End If
            
            relOffSet = rowOrCol - baseIndx
        
            getRowOrColR1C1Notation = "[" & relOffSet & "]"
        End If
   End If
    

End Function

Function getFullRngeDefinition_forSingleCell(theRnge As Range, absoluteforcolumn As Boolean, absoluteForRow As Boolean, Optional refCellIfDoingR1C1NotionForRelativeReference As Range) As String

    If theRnge.cells.count <> 1 Then
        Dim emsg As String
        emsg = "Multiple cell selections are not supported by this function!"
        elwp emsg
        getFullRngeDefinition_forSingleCell = emsg
    Else
        Dim wsName As String
        wsName = theRnge.Worksheet.name
        
        getFullRngeDefinition_forSingleCell = appendWSName(wsName, getFullRngeDefinition_forSingleCell_withoutWorksheet(theRnge, absoluteforcolumn, absoluteForRow, False, refCellIfDoingR1C1NotionForRelativeReference))
    End If
End Function

Function appendWSName(wsName As String, rngeDef As String) As String
    appendWSName = "'" & wsName & "'!" & rngeDef
End Function
    
Function rngeToRnge_nothingIfAnyInputRngeIsBlank(rnge1 As Range, rnge2 As Range) As Range
    
    Dim writtenArea As Range
    If isNothing(rnge2) Or isNothing(rnge1) Then
        Set writtenArea = Nothing
    Else
        Set writtenArea = rngeToRnge(rnge1, rnge2)
    End If
    
    Set rngeToRnge_nothingIfAnyInputRngeIsBlank = writtenArea
End Function

Function lastCellInRow(rowHeader As Range) As Range
    Set lastCellInRow = lastCellInRow_specifyLastPossibleCol(rowHeader, False, LAST_POSSIBLE_COL)
End Function

'returnNothingIfNoData = false
Function lastCellInRow_specifyLastPossibleCol(rowHeader As Range, returnNothingIfNoData As Boolean, lastPossibleCol As Long) As Range
    Set lastCellInRow_specifyLastPossibleCol = lastCellInRowOrColumn_specifyAbsoluteLastRowOrColAssumption(rowHeader, returnNothingIfNoData, lastPossibleCol, False)
End Function

Function lastCellInColumn_specifyAbsoluteLastRowAssumption(columnHeader As Range, returnNothingIfNoData As Boolean, lastPossibleRow As Long) As Range
    Set lastCellInColumn_specifyAbsoluteLastRowAssumption = lastCellInRowOrColumn_specifyAbsoluteLastRowOrColAssumption(columnHeader, returnNothingIfNoData, lastPossibleRow, True)
End Function

Function lastCellInRowOrColumn_specifyAbsoluteLastRowOrColAssumption(colOrRowHeader As Range, returnNothingIfNoData As Boolean, lastPossibleRowOrCol As Long, colVsRow As Boolean) As Range

    Dim lastCell As Range
    If colVsRow Then
        Set lastCell = lastCellInColumn_ignoreColumnHeaderLocation_specifyAbsoluteLastRowAssumption(colOrRowHeader, returnNothingIfNoData, lastPossibleRowOrCol, True)
    Else
        Dim lastAbsoluteCell As Range
        Set lastAbsoluteCell = lastAbsoluteCellInRow_specifyLastPossibleCol(colOrRowHeader, lastPossibleRowOrCol)
        
        Set lastCell = lastAbsoluteCell.End(xlToLeft)
    End If
    
    Dim lastCellRowOrCol As Long
    Dim colOrRowHeaderRowOrCol As Long
    If colVsRow Then
        lastCellRowOrCol = lastCell.row
        colOrRowHeaderRowOrCol = colOrRowHeader.row
    Else
        lastCellRowOrCol = lastCell.column
        colOrRowHeaderRowOrCol = colOrRowHeader.column
    End If
    
    
    If lastCellRowOrCol <= colOrRowHeaderRowOrCol Then
        If returnNothingIfNoData Then
            Set lastCell = Nothing
        Else
            Set lastCell = firstDataCellInColumnOrRow(colOrRowHeader, colVsRow)
        End If
    End If

    
    Set lastCellInRowOrColumn_specifyAbsoluteLastRowOrColAssumption = lastCell

End Function

Function lastCellInColumn(columnHeader As Range, returnNothingIfNoData As Boolean) As Range
    Set lastCellInColumn = lastCellInColumn_specifyAbsoluteLastRowAssumption(columnHeader, returnNothingIfNoData, LAST_POSSIBLE_ROW)
End Function

Function lastCellInColumn_ignoreColumnHeaderLocation(anyCellInColumn As Range, returnNothingIfNoData As Boolean) As Range
    Set lastCellInColumn_ignoreColumnHeaderLocation = lastCellInColumn_ignoreColumnHeaderLocation_specifyAbsoluteLastRowAssumption(anyCellInColumn, returnNothingIfNoData, LAST_POSSIBLE_ROW, True)
End Function


'ifLastRowIsInvalidThenFigureItOutDynamically = false
Function lastCellInColumn_ignoreColumnHeaderLocation_specifyAbsoluteLastRowAssumption(anyCellInColumn As Range, returnNothingIfNoData As Boolean, lastPossibleRow As Long, ifLastRowIsInvalidThenFigureItOutDynamically As Boolean) As Range
    
    Dim ws As Worksheet
    Set ws = anyCellInColumn.Worksheet
    
    clearFiltersFromPageIfNecessaryAndInformUserIfDone ws, False
    
    Dim lastAbsoluteCell As Range
On Error GoTo ehs
    Set lastAbsoluteCell = lastAbsoluteCellInColumn_specifyLastPossibleRow(anyCellInColumn, lastPossibleRow)
GoTo ehe
ehs:
    ilg "Invalid last possible row: " & lastPossibleRow
    If ifLastRowIsInvalidThenFigureItOutDynamically Then
        ilg "We will try to figure it out dynamically..."
        Set lastAbsoluteCell = lastAbsoluteCellInColumn_specifyLastPossibleRow(anyCellInColumn, anyCellInColumn.EntireColumn.rows.count)
    Else
        Set lastAbsoluteCell = Nothing
    End If
ehe:
On Error GoTo 0

    
    Dim lastCell As Range
    If CStr(gvl(lastAbsoluteCell)) = "" Then
        Set lastCell = lastAbsoluteCell.End(xlUp)
    Else
        Set lastCell = lastAbsoluteCell
    End If
    
    Set lastCellInColumn_ignoreColumnHeaderLocation_specifyAbsoluteLastRowAssumption = lastCell
    
    
End Function

Function lastAbsoluteCellInRow_specifyLastPossibleCol(anyCellInRow As Range, lastPossibleCol As Long) As Range
    Set lastAbsoluteCellInRow_specifyLastPossibleCol = anyCellInRow.Worksheet.cells(anyCellInRow.row, lastPossibleCol)
End Function

Function lastAbsoluteCellInRow(anyCellInRow As Range) As Range
    Set lastAbsoluteCellInRow = lastAbsoluteCellInRow_specifyLastPossibleCol(anyCellInRow, LAST_POSSIBLE_COL)
End Function

Function lastAbsoluteCellInColumn(anyCellInColumn As Range) As Range
    Set lastAbsoluteCellInColumn = lastAbsoluteCellInColumn_specifyLastPossibleRow(anyCellInColumn, LAST_POSSIBLE_ROW)
End Function
Function lastAbsoluteCellInColumn_specifyLastPossibleRow(anyCellInColumn As Range, lastPossibleRow As Long) As Range
    Set lastAbsoluteCellInColumn_specifyLastPossibleRow = anyCellInColumn.Worksheet.cells(lastPossibleRow, anyCellInColumn.column)
End Function

Function stretchOrCompressSoThatSpecificRowsAreCovered(curRnge As Range, firstRow As Long, lastRow As Long) As Range
    stretchOrCompressSoThatSpecificRowsAreCovered = stretchOrCompressSoThatSpecificRowsOrColsAreCovered(curRnge, firstRow, lastRow, True)
End Function

Function stretchOrCompressSoThatSpecificRowsOrColsAreCovered(curRnge As Range, firstRowOrCol As Long, lastRowOrCol As Long, rowsVsCols As Boolean) As Range
   
    Dim topDataRowOrCol As Range
    If rowsVsCols Then
        Set topDataRowOrCol = moveRnge(resizeRnge(curRnge, 1, curRnge.Columns.count), firstRowOrCol, curRnge.column)
    Else
        Set topDataRowOrCol = moveRnge(resizeRnge(curRnge, curRnge.rows.count, 1), curRnge.row, firstRowOrCol)
    End If
    
    Dim bottomDataRowOrCol As Range
    If rowsVsCols Then
        Set bottomDataRowOrCol = moveRnge(topDataRowOrCol, lastRowOrCol, topDataRowOrCol.column)
    Else
        Set bottomDataRowOrCol = moveRnge(topDataRowOrCol, topDataRowOrCol.row, lastRowOrCol)
    End If
    
    
    Set stretchOrCompressSoThatSpecificRowsOrColsAreCovered = rngeToRnge(topDataRowOrCol, bottomDataRowOrCol)
    
End Function

Function moveRngeToRow(rnge As Range, row As Long) As Range
    Set moveRngeToRow = moveRnge(rnge, row, rnge.column)
End Function

Function moveRngeToColumn(rnge As Range, col As Long) As Range
    Set moveRngeToColumn = moveRnge(rnge, rnge.row, col)
End Function

Function getCellFormula(rnge As Range) As Variant

    Dim theVal As Variant
    theVal = rnge.formula
    
    If IsError(theVal) Then
        getCellFormula = CStr(theVal)
    Else
        getCellFormula = theVal
    End If

End Function

Sub writeValuesIntoCells(listOfCellsToSet As Collection, listOfValuesToWriteIntoCells As Collection, selectAsWeSet As Boolean)
    
    Dim numCellsToSet As Long
    numCellsToSet = ccsz(Array(listOfCellsToSet, listOfValuesToWriteIntoCells), True)
    
    Dim cnt As Long
    For cnt = 1 To numCellsToSet
    
        Dim cellToSet As Range
        Dim valueToWrite As Variant
        Set cellToSet = listOfCellsToSet.item(cnt)
        valueToWrite = listOfValuesToWriteIntoCells.item(cnt)
    
        If selectAsWeSet Then
            srg cellToSet
        End If
        
        svl cellToSet, valueToWrite
    Next
End Sub

Function tryToGetValue(rnge As Range, ByRef out_emsg As String) As Variant

    Dim emsg As String
    emsg = "ERROR: NOT SET!"

    Dim theVal As Variant
    theVal = "ERROR: NOT SET!"
    
On Error GoTo ehs
    theVal = rnge.value
    emsg = ""
GoTo ehe
ehs:
    emsg = Err.description
    theVal = emsg

ehe:
On Error GoTo 0

    out_emsg = emsg
    atr tryToGetValue, theVal

End Function

Function getValue(rnge As Range) As Variant
    Dim theVal As Variant
    Dim emsg As String
    theVal = tryToGetValue(rnge, emsg)
    
    If emsg = OVERFLOW_ERROR_DESC Then
        elg emsg
        setNumberFormat rnge, NUMBER_FORMAT_GENERAL
        theVal = rnge.value
    ElseIf emsg <> "" Then
        elwp emsg
        theVal = CStr(rnge.value)
    End If
        
    
    If IsError(theVal) Then
        getValue = CStr(theVal)
    Else
        getValue = theVal
    End If
End Function

Sub selectAndSvl(rnge As Range, theVal As Variant)
    svl_optionallySelect rnge, theVal, True
End Sub

Sub svl_disableWrapText(rnge As Range, theVal As Variant)
    svl rnge, theVal
    setWrapText rnge, False
End Sub

Sub svl_optionallySelect(rnge As Range, theVal As Variant, selectAsWeSet As Boolean)
    If selectAsWeSet Then
        sris rnge
    End If
    
    svl rnge, theVal
    
    
End Sub

Sub svl_noPopupOnError(rnge As Range, theVal As Variant)
On Error GoTo ehs
    rnge.value = theVal
GoTo ehe
ehs:
    elg "Unable to set the value for a cell.  Msg=" & Err.description
ehe:
On Error GoTo 0
End Sub

'JY20130419a - start - make the order that cells are included more well-defined
Function getCellsInRnge_cycleThroughRowsLeftToRightOnEachRow(rnge As Range) As Collection
    Dim numRows As Long
    Dim numCols As Long
    numRows = rnge.rows.count
    numCols = rnge.Columns.count
    
    Dim coll As Collection
    Set coll = New Collection
    
    Dim r As Long
    For r = 1 To numRows
    
        Dim c As Long
        For c = 1 To numCols
            
            coll.add rnge.cells(r, c)
        
        Next
    Next
    
    Set getCellsInRnge_cycleThroughRowsLeftToRightOnEachRow = coll
    
End Function
'JY20130419a - end

Function getIndividualCellsEncompassedByListOfRnges(rngeOrArrayOfRngesOrCollectionOfRnges As Variant) As Collection

    Dim list As Variant
    list = ensureValueIsAnArray(rngeOrArrayOfRngesOrCollectionOfRnges)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs rngeOrArrayOfRngesOrCollectionOfRnges, lwr, upr
    
    Dim list2 As Collection
    Set list2 = New Collection
    
    Dim c As Long
    For c = lwr To upr
        Dim rng As Range
        Set rng = rngeOrArrayOfRngesOrCollectionOfRnges(c)
        
        addCollectionToCollection list2, getCellsInRnge(rng)
    Next
    
    Set getIndividualCellsEncompassedByListOfRnges = list2

End Function


'Separate the passed-in Range object into multiple Range objects,
'where each of the multiple Range objects refers to exactly one cell.
Function getCellsInRnge(rnge As Range) As Collection
    
    Dim coll As Collection
    
    'JY20131024a - unnecessary line
    'Set coll = New Collection
    
    'JY20130419a - start - make the order that cells are included more well-defined
    'Dim cl As Range
    'For Each cl In rnge
    '    coll.add cl
    'Next
    '
    Set coll = getCellsInRnge_cycleThroughRowsLeftToRightOnEachRow(rnge)
    'JY20130419a - end
    Set getCellsInRnge = coll
End Function

Function getCellsInRnge_asArray(rnge As Range) As Variant
    
    Dim cnt As Long
    cnt = 0
    
    Dim cl As Range
    For Each cl In rnge
        cnt = cnt + 1
    Next
    
    Dim arr As Variant
    ReDim arr(1 To cnt)
    
    Dim cnt2 As Long
    cnt2 = 0
    Dim cl2 As Range
    For Each cl2 In rnge
        cnt2 = cnt2 + 1
        Set arr(cnt2) = cl2
    Next
    
    If cnt2 <> cnt Then
        elwp_se
    End If
    
    getCellsInRnge_asArray = arr
    
End Function

Function getValuesCollectionFromRngeInOrder(rng As Range) As Collection
    Set getValuesCollectionFromRngeInOrder = arrayToCollection(twoDimArrayToOneDimArray(ensureValueIsAnArray(rng.value)))
End Function


Function getValuesFromCells(cellOrArrayOfCellsOrCollectionOfCells As Variant) As Collection

    Dim arr As Variant
    arr = ensureValueIsAnArray(cellOrArrayOfCellsOrCollectionOfCells)

    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr
    
    Dim vals As Collection
    Set vals = New Collection
    
    Dim c As Long
    For c = lwr To upr
        vals.add gvl(castToRnge(arr(c)))
    Next
    
    Set getValuesFromCells = vals
End Function

Function getValuesFromCells_asArray(theCells As Variant) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs theCells, lwr, upr
    
    Dim arr As Variant
    ReDim arr(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        arr(c) = gvl(castToRnge(theCells(c)))
    Next
    
    getValuesFromCells_asArray = arr

End Function

Sub useSrtToFilterOutValuesExcept(valueToKeep As Variant, srcDataIncludingHeaders As Range, anyCellInColumnToFilterOn As Range)

    Dim matchCase As Boolean
    matchCase = False
    
    Dim headers As Range
    Set headers = resizeRnge(srcDataIncludingHeaders, 1, srcDataIncludingHeaders.Columns.count)
    
    sortData srcDataIncludingHeaders, anyCellInColumnToFilterOn, True, matchCase, xlSortNormal
     
    Dim ankOfFilterCol As Range
    Set ankOfFilterCol = gcicsr(anyCellInColumnToFilterOn, headers.row)
    
    Dim searchRnge As Range
    Set searchRnge = getColumnDataRnge(ankOfFilterCol)
    
    Dim firstInstance As Range
    Set firstInstance = findCell_optionallyDoSlowWayAsLastResort(searchRnge, valueToKeep, matchCase, True, False, False)
    
    If isNothing(firstInstance) Then
        clearColumnData getCellsInRnge(headers)
    Else
        Dim firstRowToKeep As Long
        firstRowToKeep = firstInstance.row
        
        Dim lastPossibleRow As Long
        lastPossibleRow = wsFunctionMax(brcor(srcDataIncludingHeaders).row, brcor(searchRnge).row)
            
        If CStr(gvl(firstInstance)) <> CStr(valueToKeep) Then
            elwp_se
        End If
        
        Dim curCandidateForLastRowToKeep As Long
        curCandidateForLastRowToKeep = firstRowToKeep
        
        While (curCandidateForLastRowToKeep + 1 <= lastPossibleRow) And (gvl(gcicsr(firstInstance, curCandidateForLastRowToKeep + 1)) = valueToKeep)
            curCandidateForLastRowToKeep = curCandidateForLastRowToKeep + 1
        Wend
        
        Dim lastRowToKeep As Long
        lastRowToKeep = curCandidateForLastRowToKeep
        
        Dim firstDataRow As Long
        firstDataRow = headers.row + 1
        
        'JY20130426 - a change was made to delete rows at the end first!  This is necessary.

        If lastRowToKeep > lastPossibleRow Then
            elwp_se
        ElseIf lastRowToKeep = lastPossibleRow Then
            'DO NOTHING
        Else
            'We have rows to delete at the end.
            
            Dim fstRowToDelete As Long
            Dim lstRowToDelete As Long
            fstRowToDelete = lastRowToKeep + 1
            lstRowToDelete = lastPossibleRow
            
            Dim deleteRnge2 As Range
            Set deleteRnge2 = resizeRnge(moveRnge(headers, fstRowToDelete, headers.column), lstRowToDelete - fstRowToDelete + 1, headers.Columns.count)
            deleteRows deleteRnge2, xlShiftUp
            
        End If
            
        If firstRowToKeep < firstDataRow Then
            elwp_se
        ElseIf firstRowToKeep = firstDataRow Then
            'DO NOTHING
        Else
            'We have rows to delete at the beginning.
            
            Dim lastRowToDelete As Long
            Dim firstRowToDelete As Long
            firstRowToDelete = firstDataRow
            lastRowToDelete = firstRowToKeep - 1
            
            Dim deleteRnge1 As Range
            Set deleteRnge1 = resizeRnge(moveRnge(headers, firstRowToDelete, headers.column), lastRowToDelete - firstRowToDelete + 1, headers.Columns.count)
            
            lastRowToKeep = lastRowToKeep - deleteRnge1.rows.count
            lastPossibleRow = lastPossibleRow - deleteRnge1.rows.count
            deleteRows deleteRnge1, xlShiftUp
            
            
        End If
                    
        
    End If
    
End Sub

Sub useSortToFilterOutValuesExcept(valueToKeep As Variant, headers As Range, anyCellInColumnToFilterOn As Range)

    Dim srcData As Range
    Set srcData = getSourceData(headers, True)

    useSrtToFilterOutValuesExcept valueToKeep, srcData, anyCellInColumnToFilterOn

End Sub

Function findCells_optionallyDoSlowWayAsLastResort(searchRnge As Range, searchValues As Variant, matchCase As Boolean, doSlowWayIfNecessary As Boolean) As Variant
    Dim lwr As Long
    Dim upr As Long
    glaubs searchValues, lwr, upr
    
    Dim results As Variant
    ReDim results(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Dim curSearchValue As Variant
        curSearchValue = searchValues(c)
        
        Dim result As Variant
        atr result, findCell_optionallyDoSlowWayAsLastResort(searchRnge, curSearchValue, matchCase, True, doSlowWayIfNecessary, True)
        
        If IsObject(result) Then
            Set results(c) = result
        Else
            results(c) = results
        End If
    Next
    
    findCells_optionallyDoSlowWayAsLastResort = results
End Function

'JY20120824a - start - renamed this function to avoid naming conflict with Jessie's function
'Function findCells(searchRnge As Range, searchValues As Variant, matchCase As Boolean) As Variant
'    atr findCells, findCells_optionallyDoSlowWayAsLastResort(searchRnge, searchValues, matchCase, False)
'End Function
Function fndCells(searchRnge As Range, searchValues As Variant, matchCase As Boolean) As Variant
    atr fndCells, findCells_optionallyDoSlowWayAsLastResort(searchRnge, searchValues, matchCase, False)
End Function
'JY20120824a - end

Function findCell_specifySearchOrder_optionallyDoSlowWayAsLastResort(searchRnge As Range, searchValue As Variant, matchCase As Boolean, searchOrder As Variant, wholeVsPart As Boolean, doSlowWayIfNecessary As Boolean, lookInValuesVsFormulas As Boolean) As Range
    Dim foundCell As Range
    Set foundCell = findCell_specifySearchOrder(searchRnge, searchValue, matchCase, searchOrder, wholeVsPart, lookInValuesVsFormulas)
    
    If isNothing(foundCell) Then
        If doSlowWayIfNecessary Then
            If Not wholeVsPart Then
                'DO NOTHING
                
                'Not supported
                Set foundCell = Nothing
            Else
                Set foundCell = findCellSlowWay(searchRnge, searchValue, matchCase, False)
            End If
        End If
    End If
    
    Set findCell_specifySearchOrder_optionallyDoSlowWayAsLastResort = foundCell
End Function

'trimBeforeComparing = false
Function findCellSlowWay(searchRnge As Range, searchValue As Variant, matchCase As Boolean, trimBeforeComparing As Boolean) As Range
    
    Dim searchCells As Collection
    Set searchCells = getCellsInRnge(searchRnge)
    
    Dim c As Long
    c = 1
    
    Dim foundCell As Range
    Set foundCell = Nothing
    
    While isNothing(foundCell) And c <= searchCells.count
        Dim curCell As Range
        Set curCell = searchCells.item(c)
        
        Dim testVal As Variant
        testVal = curCell.value
        If valuesAreEqual(testVal, searchValue) Then
            Set foundCell = curCell
        ElseIf sae2(CStr(testVal), CStr(searchValue), matchCase, trimBeforeComparing) Then
            Set foundCell = curCell
        Else
            'DO NOTHING
        End If
        c = c + 1
    Wend
    
    Set findCellSlowWay = foundCell
End Function

Function findCell_specifySearchOrder(searchRnge As Range, searchValue As Variant, matchCase As Boolean, searchOrder As Variant, wholeVsPart As Boolean, lookInValuesVsFormulas As Boolean) As Range
    Dim firstCell As Range
    Set firstCell = tlcor(searchRnge)
    
    Dim firstVal As Variant
    firstVal = gvl(firstCell)
    If valuesAreEqual(firstVal, searchValue) Then
        Set findCell_specifySearchOrder = firstCell
    Else
        
        Dim useFirstCell As Boolean
        If matchCase Then
            If sae2(CStr(firstVal), CStr(searchValue), True, False) Then
                useFirstCell = True
            Else
                useFirstCell = False
            End If
        Else
            useFirstCell = False
        End If
        
        If useFirstCell Then
            Set findCell_specifySearchOrder = firstCell
        Else
    
            Dim wholeOrPart As Variant
            If wholeVsPart Then
                wholeOrPart = xlWhole
            Else
                wholeOrPart = xlPart
            End If
            
            Dim lookInWhat As Variant
            If lookInValuesVsFormulas Then
                lookInWhat = xlValues
            Else
                lookInWhat = xlFormulas
            End If
    
            Set findCell_specifySearchOrder = searchRnge.Find(What:=searchValue, LookIn:=lookInWhat, _
                Lookat:=wholeOrPart, searchOrder:=searchOrder, SearchDirection:=xlNext, _
                matchCase:=matchCase, SearchFormat:=False)
        End If
    End If
End Function


Function findCell_optionallyDoSlowWayAsLastResort(searchRnge As Range, searchValue As Variant, matchCase As Boolean, wholeVsPart As Boolean, doSlowWayIfNecessary As Boolean, lookInValuesVsFormulas As Boolean) As Range
    Set findCell_optionallyDoSlowWayAsLastResort = findCell_specifySearchOrder_optionallyDoSlowWayAsLastResort(searchRnge, searchValue, matchCase, favoredSearchOrder(), wholeVsPart, doSlowWayIfNecessary, lookInValuesVsFormulas)
End Function

Function favoredSearchOrder() As Variant
    favoredSearchOrder = xlByRows
End Function

Function findCell_optionallyDoSlowWayAsLastResort_customSearchOrder(searchRnge As Range, searchValue As Variant, matchCase As Boolean, wholeVsPart As Boolean, doSlowWayIfNecessary As Boolean, lookInValuesVsFormulas As Boolean, searchOrder As Variant) As Range
    Set findCell_optionallyDoSlowWayAsLastResort_customSearchOrder = findCell_specifySearchOrder_optionallyDoSlowWayAsLastResort(searchRnge, searchValue, matchCase, searchOrder, wholeVsPart, doSlowWayIfNecessary, lookInValuesVsFormulas)
End Function

Function findCell_withTrimming(searchRnge As Range, searchValue As Variant, matchCase As Boolean) As Range
    
    Dim firstCol As Long
    Dim lastCol As Long
    firstCol = tlcor(searchRnge).column
    lastCol = brcor(searchRnge).column
    
    Dim realFound As Range
    Set realFound = Nothing
    
    Dim col As Long
    col = firstCol
    While (col <= lastCol) And isNothing(realFound)
    
        Dim searchCol As Range
        Set searchCol = rngeToRnge(gcirsc(tlcor(searchRnge), col), gcirsc(brcor(searchRnge), col))
        
        Dim curSearchArea As Range
        Set curSearchArea = searchCol
        
        While isNothing(realFound) And (Not isNothing(curSearchArea))
        
            Dim foundCell As Range
            Set foundCell = findCell(curSearchArea, searchValue, matchCase, False)
        
            If isNothing(foundCell) Then
                Set curSearchArea = Nothing
            Else
                If Trim(foundCell) = Trim(searchValue) Then
                    Set realFound = foundCell
                End If
                
                Dim nextRowToSearch As Long
                nextRowToSearch = foundCell.row + 1
                
                If nextRowToSearch > brcor(curSearchArea).row Then
                    Set curSearchArea = Nothing
                Else
                    Set curSearchArea = rngeToRnge(gcicsr(tlcor(curSearchArea), nextRowToSearch), brcor(curSearchArea))
                End If
            End If
        Wend
        
        col = col + 1
    Wend
        
    Set findCell_withTrimming = realFound
End Function

Function findCell_excludeFoundCellsInParticularRow(searchRnge As Range, searchValue As Variant, curRow As Long, matchCase As Boolean, wholeVsPart As Boolean) As Range
    
    Dim searchRangePart1 As Range
    If tlcor(searchRnge).row >= curRow Then
        Set searchRangePart1 = Nothing
    Else
        Set searchRangePart1 = rngeToRnge(tlcor(searchRnge), gcicsr(brcor(searchRnge), curRow - 1))
    End If
    
    Dim searchRangePart2 As Range
    If brcor(searchRnge).row <= curRow Then
        Set searchRangePart2 = Nothing
    Else
        Set searchRangePart2 = rngeToRnge(gcicsr(tlcor(searchRnge), curRow + 1), brcor(searchRnge))
    End If

    Dim foundCell As Range
    Set foundCell = findCell(searchRangePart1, searchValue, matchCase, wholeVsPart)
    If isNothing(foundCell) Then
        Set foundCell = findCell(searchRangePart2, searchValue, matchCase, wholeVsPart)
    End If
    
    Set findCell_excludeFoundCellsInParticularRow = foundCell
    
End Function


Function findCell(searchRnge As Range, searchValue As Variant, matchCase As Boolean, wholeVsPart As Boolean) As Range
    atr findCell, findCell_customSearchOrder(searchRnge, searchValue, matchCase, wholeVsPart, favoredSearchOrder())
End Function

Function findCell_customSearchOrder(searchRnge As Range, searchValue As Variant, matchCase As Boolean, wholeVsPart As Boolean, searchOrder As Variant) As Range

    Dim lookInValuesVsFormulas As Boolean
    lookInValuesVsFormulas = True

    atr findCell_customSearchOrder, findCell_optionallyDoSlowWayAsLastResort_customSearchOrder(searchRnge, searchValue, matchCase, wholeVsPart, False, lookInValuesVsFormulas, searchOrder)
End Function

Sub setCellFormula_logErrors(rnge As Range, fmola As Variant, useR1C1 As Boolean, ByRef mod_emsgs____orNothingTOPopUpErrorsInstead As Variant)
On Error GoTo ehs
    If useR1C1 Then
        rnge.FormulaR1C1 = fmola
    Else
        rnge.formula = fmola
    End If

GoTo ehe
ehs:
    
    Dim emsg As String
    emsg = "Could not set the formula for a cell."
    
    If isNothing(mod_emsgs____orNothingTOPopUpErrorsInstead) Then
        elwp emsg
    Else
        mod_emsgs____orNothingTOPopUpErrorsInstead.add emsg
    End If
ehe:
On Error GoTo 0
End Sub

Sub setCellFormula(rnge As Range, fmla As Variant, useR1C1 As Boolean)
    setCellFormula_logErrors rnge, fmla, useR1C1, Nothing
End Sub
    
Sub pasteFormulaIntoTopLeftCellOfRngeThenCopyItToRemainderOfRngeWithoutUsingTheClipboard(formulaForTopLeftCell As String, tableRnge As Range)
    
    Dim topLeft As Range
    Set topLeft = tlcor(tableRnge)
    
    setCellFormula topLeft, "=" & formulaForTopLeftCell, False
    
    Dim r1c1Formula As String
    r1c1Formula = topLeft.FormulaR1C1
    
    setCellFormula tableRnge, r1c1Formula, True
End Sub


'Pass in a list of range names, and optionally the worksheet that you want to search that contains them.
'Then, this function returns the actual Range objects that correspond to your list.
'If you leave 'optWS' blank, then this method will not make any assumptions as to the exact worksheet that you expect will contain
'the range names.
Function getCellsForListOfRNs(arrayOrCollectionOfRNs As Variant, optWS As Worksheet) As Variant
    
    Dim list As Variant
    list = ensureValueIsAnArray(arrayOrCollectionOfRNs)
    
    Dim lower As Long
    Dim upper As Long
    lower = LBound(list, 1)
    upper = UBound(list, 1)
    
    Dim anchors As Variant
    ReDim anchors(lower To upper)
    
    Dim c As Long
    For c = lower To upper
        Dim rn As String
        rn = list(c)
        
        Dim anchor As Range
        Set anchor = rnge(rn, optWS)
        
        Set anchors(c) = anchor
    Next
    
    getCellsForListOfRNs = anchors
End Function

Function getAnchorsForListOfRNs(list As Variant, optWS As Worksheet) As Variant
    atr getAnchorsForListOfRNs, getCellsForListOfRNs(list, optWS)
End Function

Function getRngeThatEncompassesListOfRnges(rangeOrArrayOfRangesOrCollectionOfRanges As Variant) As Range

    Dim arrOfRnges As Variant
    arrOfRnges = ensureValueIsAnArray(rangeOrArrayOfRangesOrCollectionOfRanges)
    

    Dim numRnges As Long
    numRnges = dimSize(arrOfRnges, 1)
    
    If numRnges < 1 Then
        elwp "No ranges passed in!"
        Set getRngeThatEncompassesListOfRnges = Nothing
    Else
        Dim rngeSoFar As Range
        Set rngeSoFar = rlai(arrOfRnges, 1)
        
        Dim c As Long
        For c = 2 To numRnges
            Set rngeSoFar = rngeToRnge(rngeSoFar, rlai(arrOfRnges, c))
        Next
        
        Set getRngeThatEncompassesListOfRnges = rngeSoFar
    End If

End Function

Function rnsToRnges(arrayOfRNs As Variant, optWS As Worksheet) As Variant

    Dim lwr As Long
    Dim upr As Long
    glaubs arrayOfRNs, lwr, upr
    
    Dim arr As Variant
    ReDim arr(lwr To upr)
    
    Dim c As Long
    For c = lwr To upr
        Set arr(c) = rnge(CStr(arrayOfRNs(c)), optWS)
    Next
    
    rnsToRnges = arr
End Function

Function shrinkRows(theRnge As Range) As Range
    
    Dim firstCol As Long
    Dim lastCol As Long
    firstCol = theRnge.column
    lastCol = brcor(theRnge).column
    
    Dim ws As Worksheet
    Set ws = theRnge.Worksheet
    
    Dim lastRow As Long
    lastRow = 0
    
    Dim c As Long
    For c = firstCol To lastCol
        lastRow = wsFunctionMax(lastRow, lastCellInColumn(ws.cells(theRnge.row, c), False).row)
    Next
    
    Set shrinkRows = resizeRnge(theRnge, lastRow - theRnge.row + 1, theRnge.Columns.count)
    
End Function

Function getBottomRowFromRnge(theRnge As Range) As Range
    Set getBottomRowFromRnge = moveRnge(resizeRnge(theRnge, 1, theRnge.Columns.count), brcor(theRnge).row, theRnge.column)
End Function

Function separateRngIntoColRnges(rng As Range) As Collection

    Dim startCol As Long
    Dim endCol As Long
    startCol = rng.column
    endCol = rng.column + rng.Columns.count - 1
    
    Dim listOfColRnges As Collection
    Set listOfColRnges = New Collection
    Dim c As Long
    For c = startCol To endCol
    
        Dim colRnge As Range
        Set colRnge = moveRnge(resizeRnge(rng, rng.rows.count, 1), rng.row, c)
    
        listOfColRnges.add colRnge
    Next
    
    Set separateRngIntoColRnges = listOfColRnges

End Function

Function getColDataListFromRnge(rng As Range) As Collection
    
    Dim listOfColRnges As Collection
    Set listOfColRnges = separateRngIntoColRnges(rng)
    
    Dim colDataList As Collection
    Set colDataList = New Collection
    
    Dim d As Long
    For d = 1 To listOfColRnges.count
        colDataList.add twoDimArrayToOneDimArray(listOfColRnges.item(d).value)
    Next
    
    Set getColDataListFromRnge = colDataList
End Function

Function getRngeEncompassingDataInTable(tableHeaderRnge As Range) As Range
    
    Dim firstRow As Long
    Dim lastRow As Long
    getRowRngeWhereDataExistsInColumnHeaders tableHeaderRnge, firstRow, lastRow
    
    If lastRow < firstRow Then
        lastRow = firstRow
    End If
    
    
    Set getRngeEncompassingDataInTable = rngeToRnge(gcicsr(tlcor(tableHeaderRnge), firstRow), gcicsr(brcor(tableHeaderRnge), lastRow))
    
End Function


Sub getRowRngeWhereDataExistsInColumnHeaders(headers As Range, ByRef out_firstRow As Long, ByRef out_lastRow As Long)
    getRowRngeWhereDataExistsInAnchors getCellsInRnge(headers), out_firstRow, out_lastRow
End Sub

Sub getRowRngeWhereDataExistsInAnchors_specifyLastPossibleRowAssumption(anchorOrArrayOfAnchorsOrCollectionOfAnchors As Variant, ByRef out_firstRow As Long, ByRef out_lastRow As Long, lastPossibleRow As Long)
    getRowOrColRngeWhereDataExistsInAnchors_specifyLastPossibleRowAssumption anchorOrArrayOfAnchorsOrCollectionOfAnchors, out_firstRow, out_lastRow, lastPossibleRow, True
End Sub

Sub getRowOrColRngeWhereDataExistsInAnchors_specifyLastPossibleRowAssumption(anchorOrArrayOfAnchorsOrCollectionOfAnchors As Variant, ByRef out_firstRowOrCol As Long, ByRef out_lastRowOrCol As Long, lastPossibleRowOrCol As Long, findMinAndMaxRowsVsCols As Boolean)
    
    Dim anksArr As Variant
    anksArr = ensureValueIsAnArray(anchorOrArrayOfAnchorsOrCollectionOfAnchors)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs anksArr, lwr, upr
    
    Dim minRowOrCol As Long
    Dim maxRowOrCol As Long
    minRowOrCol = 0
    maxRowOrCol = 0
    
    Dim y As Long
    For y = lwr To upr
        
        Dim curAnk As Range
        Set curAnk = anksArr(y)
    
        lookAtCurrentAnchorForRowAndColAndAdjustWhatWeKnowAboutTheMaxAndMinRowOrColSeenSoFar curAnk, minRowOrCol, maxRowOrCol, findMinAndMaxRowsVsCols, lastPossibleRowOrCol
    Next
    out_firstRowOrCol = minRowOrCol
    out_lastRowOrCol = maxRowOrCol


End Sub

Sub getRowRngeWhereDataExistsInAnchors(anchorOrArrayOfAnchorsOrCollectionOfAnchors As Variant, ByRef out_firstRow As Long, ByRef out_lastRow As Long)
    getRowOrColRngeWhereDataExistsInAnchors anchorOrArrayOfAnchorsOrCollectionOfAnchors, out_firstRow, out_lastRow, True
End Sub

Sub getRowOrColRngeWhereDataExistsInAnchors(anchorOrArrayOfAnchorsOrCollectionOfAnchors As Variant, ByRef out_firstRowOrCol As Long, ByRef out_lastRowOrCol As Long, findMinAndMaxRowsVsCols As Boolean)
    
    Dim lastPossibleRowOrCol As Long
    If findMinAndMaxRowsVsCols Then
        lastPossibleRowOrCol = LAST_POSSIBLE_ROW
    Else
        lastPossibleRowOrCol = LAST_POSSIBLE_COL
    End If
    
    getRowOrColRngeWhereDataExistsInAnchors_specifyLastPossibleRowAssumption anchorOrArrayOfAnchorsOrCollectionOfAnchors, out_firstRowOrCol, out_lastRowOrCol, lastPossibleRowOrCol, findMinAndMaxRowsVsCols
End Sub
Sub getRngeBounds(theRnge As Range, ByRef out_topLeftRow As Long, ByRef out_topLeftCol As Long, ByRef out_botRightRow As Long, ByRef out_botRightCol As Long)

    Dim topLeft As Range
    Dim botRight As Range
    Set topLeft = tlcor(theRnge)
    Set botRight = brcor(theRnge)
    
    out_topLeftRow = topLeft.row
    out_topLeftCol = topLeft.column
    out_botRightRow = botRight.row
    out_botRightCol = botRight.column

End Sub

Function commonWorksheetInRnges(rnges As Collection) As Worksheet

    Dim commonWS As Worksheet
    If rnges.count = 0 Then
        Set commonWS = Nothing
    Else
        Set commonWS = rnges.item(1).Worksheet

        Dim c As Long
        c = 2
        
        While c <= rnges.count And Not isNothing(commonWS)
        
            Dim rng As Range
            Set rng = rnges.item(c)
            
            Dim curWS As Worksheet
            Set curWS = rng.Worksheet
            
            If Not curWS Is commonWS Then
                Set commonWS = Nothing
            End If
        
            c = c + 1
        Wend
    End If
    
    Set commonWorksheetInRnges = commonWS
End Function

Sub showAsMuchOfRngeAsPossible(matrixOutputArea As Range)
    sris brcor(matrixOutputArea)
    sris tlcor(matrixOutputArea)
End Sub

Function rngeContainsCell(rng As Range, cell As Range) As Boolean
        
    If cell.cells.count <> 1 Then
        elwp "Please pass in a single cell."
    End If
    
    Dim tlRow As Long
    Dim tlCol As Long
    Dim brRow As Long
    Dim brCol As Long
    getRngeBounds rng, tlRow, tlCol, brRow, brCol
    
    If cell.column >= tlCol And cell.column <= brCol And cell.row >= tlRow And cell.row <= brRow Then
        rngeContainsCell = True
    Else
        rngeContainsCell = False
    End If


End Function

Function rngesAreSameSize(rnge1 As Range, rnge2 As Range) As Boolean
   rngesAreSameSize = (rnge1.Columns.count = rnge2.Columns.count) And (rnge1.rows.count = rnge2.rows.count)
End Function



Function offsetEachCell(theCells As Collection, rowOffset As Long, colOffset As Long) As Collection
    
    Dim newCells As Collection
    Set newCells = New Collection
    
    Dim c As Long
    For c = 1 To theCells.count
        Dim rng As Range
        Set rng = theCells.item(c)
        
        Dim newCell As Range
        Set newCell = rng.offset(-1, 0)
        
        newCells.add newCell
    Next

    Set offsetEachCell = newCells
End Function

Function worksheetsAreTheSame(ws1 As Worksheet, ws2 As Worksheet) As Boolean
    worksheetsAreTheSame = (ws1 Is ws2)
End Function

Function getPartOfRngeEncompassedByAnotherRnge(rng1 As Range, rng2 As Range) As Range

    If Not worksheetsAreTheSame(rng1.Worksheet, rng2.Worksheet) Then
        Set getPartOfRngeEncompassedByAnotherRnge = Nothing
    Else
    
        Dim ws As Worksheet
        Set ws = rng1.Worksheet
    
        Dim tlRow1 As Long
        Dim tlCol1 As Long
        Dim brRow1 As Long
        Dim brCol1 As Long
        getRngeBounds rng1, tlRow1, tlCol1, brRow1, brCol1
        
        Dim tlRow2 As Long
        Dim tlCol2 As Long
        Dim brRow2 As Long
        Dim brCol2 As Long
        getRngeBounds rng2, tlRow2, tlCol2, brRow2, brCol2
        
        Dim tlRow3 As Long
        Dim tlCol3 As Long
        Dim brRow3 As Long
        Dim brCol3 As Long
        tlRow3 = wsFunctionMax(tlRow1, tlRow2)
        tlCol3 = wsFunctionMax(tlCol1, tlCol2)
        brRow3 = wsFunctionMin(brRow1, brRow2)
        brCol3 = wsFunctionMin(brCol1, brCol2)
        
        Dim theOverlap As Range
        If tlRow3 > brRow3 Or tlCol3 > brCol3 Then
            Set theOverlap = Nothing
        Else
            Set theOverlap = rngeToRnge(ws.cells(tlRow3, tlCol3), ws.cells(brRow3, brCol3))
        End If
        
        Set getPartOfRngeEncompassedByAnotherRnge = theOverlap
    End If
End Function

Sub figureOutFirstAndLastRowsOfSectionInTableWhereSectionConsistsOfMultipleRowsAndIsDefinedByATitleInASectionNameColumnAndWhereThatTitleMightOrMIghtNotBeInAMergedCell(ByRef out_firstrowofsection As Long, ByRef out_lastrowofsection As Long, emeacell As Range)
    
    Dim rowAbove As Long
    rowAbove = emeacell.offset(-1, 0).row
    
    Dim rowBelow As Long
    Dim testCell As Range
    Set testCell = emeacell.offset(1, 0)
    While isBlankValue(gvl(testCell)) And testCell.row < brcor(testCell.Worksheet.UsedRange).row
        Set testCell = testCell.offset(1, 0)
    Wend
    rowBelow = testCell.row
    
    Dim firstRowOfSection As Long
    Dim lastRowOfSection As Long
    firstRowOfSection = rowAbove + 1
    lastRowOfSection = rowBelow - 1
    If lastRowOfSection < firstRowOfSection Then
        elwp_se
    End If
    
    out_firstrowofsection = firstRowOfSection
    out_lastrowofsection = lastRowOfSection
End Sub


Sub getFirstAndLastRowOfData(cellOrArrayOfCellsOrCollectionOfCells As Variant, ByRef out_firstRow As Long, ByRef out_lastRow As Long)
    
    Dim ranges As JYUT_RngeIncrementer
    Set ranges = New JYUT_RngeIncrementer
    ranges.addRnges "rng", cellOrArrayOfCellsOrCollectionOfCells, False
    
    out_firstRow = ranges.firstRow
    out_lastRow = ranges.lastRow
End Sub

Sub clearComment(theCell As Range, ByRef mod_emsgs As Variant)

On Error GoTo ehs
    theCell.ClearComments
GoTo ehe
ehs:
    Dim emsg As String
    emsg = "Could not clear comment.  Msg=" & Err.description
    
    elg emsg
    mod_emsgs.add emsg
ehe:
On Error GoTo 0

End Sub

Sub setComment(theCell As Range, theComment As String, ByRef mod_emsgs As Variant)
    
On Error GoTo ehs
    If isNothing(theCell.comment) Then
        theCell.addComment
    End If
        
    theCell.comment.text text:=theComment
GoTo ehe
ehs:
    Dim emsg As String
    emsg = "Could not insert comment.  Msg=" & Err.description
    
    elg emsg
    mod_emsgs.add emsg
ehe:
On Error GoTo 0
End Sub

Sub clearContentsInRnges(listOfDataRnges As Collection)
    Dim d As Long
    For d = 1 To listOfDataRnges.count
        Dim dataRnge As Range
        Set dataRnge = listOfDataRnges.item(d)
        
        sris dataRnge
        dataRnge.ClearContents
    Next
End Sub




Function getColumnAnksFromColumnSpanRNAndRowIndicatorRN(optWS As Worksheet, rnForRngeThatIndicatesColumnRnge As String, rnThatDeterminesRowForColAnks As String) As Collection
    
    Dim columnSpanRnge As Range
    Set columnSpanRnge = rnge(rnForRngeThatIndicatesColumnRnge, optWS)
    
    Dim startCol As Long
    Dim endCol As Long
    startCol = tlcor(columnSpanRnge).column
    endCol = brcor(columnSpanRnge).column
    
    Dim colAnks As Collection
    Set colAnks = New Collection
    Dim c As Long
    For c = startCol To endCol
        Dim colAnk As Range
        Set colAnk = gcirsc(rnge(rnThatDeterminesRowForColAnks, optWS), c)
        
        colAnks.add colAnk
    Next
    
    Set getColumnAnksFromColumnSpanRNAndRowIndicatorRN = colAnks
    
End Function
Attribute VB_Name = "JYUT_ReportTools"
Option Explicit

Public Const NUMBER_OF_SPACER_COLUMNS_IN_REPORT_THAT_WILL_BE_EXPORTED_TO_PDF As Long = 1

Function splitSectionsIntoSeparatePages(listOf__sectionUniqueIDWhichCanBeOfAnyDataType_numRowsInSection As Collection, maxRowsPerPage As Long, firstRowThatWillBeWrittenToOnEachPage As Long) As Collection

    Dim listOfSectionIdentifiers_listOfNumRows As Collection
    Set listOfSectionIdentifiers_listOfNumRows = sciloar(True, listOf__sectionUniqueIDWhichCanBeOfAnyDataType_numRowsInSection)

    Dim listOfSectionIdentifiers As Collection
    Dim listOf__numRowsForEachSection As Collection
    Set listOfSectionIdentifiers = listOfSectionIdentifiers_listOfNumRows.item(1)
    Set listOf__numRowsForEachSection = listOfSectionIdentifiers_listOfNumRows.item(2)

    Set splitSectionsIntoSeparatePages = doSplitSectnsIntoSeparatePages(listOfSectionIdentifiers, listOf__numRowsForEachSection, maxRowsPerPage, firstRowThatWillBeWrittenToOnEachPage)

End Function

Function doSplitSectnsIntoSeparatePages(listOfSectionIdentifiers As Collection, listOf__numRowsForEachSection As Collection, maxRowsPerPage As Long, firstRowThatWillBeWrittenToOnEachPage As Long) As Collection
    
    Dim sz As Long
    sz = ccsz(Array(listOfSectionIdentifiers, listOf__numRowsForEachSection), True)
    
    Dim listOfSubLists As Collection
    Set listOfSubLists = New Collection
    
    Dim curList As Collection
    Set curList = New Collection
    
    listOfSubLists.add curList
    
    Dim rowOffsetOnTop As Long
    rowOffsetOnTop = firstRowThatWillBeWrittenToOnEachPage - 1
    
    Dim numRowsSoFar As Long
    numRowsSoFar = rowOffsetOnTop
    
    Dim j As Long
    For j = 1 To sz
    
        Dim numRowsInSection As Long
        numRowsInSection = listOf__numRowsForEachSection.item(j)
        
        Dim shouldAdd As Boolean
        If numRowsSoFar = rowOffsetOnTop Then
            shouldAdd = True
        Else
            shouldAdd = (numRowsSoFar + numRowsInSection) <= maxRowsPerPage
        End If
        
        If shouldAdd Then
            'DO NOTHING
        Else
            'Create a new page
            Set curList = New Collection
            listOfSubLists.add curList
            numRowsSoFar = rowOffsetOnTop
        End If
        
        curList.add listOfSectionIdentifiers.item(j)
        numRowsSoFar = numRowsSoFar + numRowsInSection
    Next
    
    Set doSplitSectnsIntoSeparatePages = listOfSubLists
End Function

Sub setPrintSettingsAndResizeSpacerColumnsInPreparationForExportToPDF(totalWrittenArea_weAssumeThatASpacerColumnExistsOnBothTheLeftAndRightSidesOfThisRnge As Range)
    
    Dim totalWrittenAreaPlusSpacerColumnOnLeft As Range
    Dim spacerColumnOnLeftExists As Boolean
    If totalWrittenArea_weAssumeThatASpacerColumnExistsOnBothTheLeftAndRightSidesOfThisRnge.column <= NUMBER_OF_SPACER_COLUMNS_IN_REPORT_THAT_WILL_BE_EXPORTED_TO_PDF Then
        elwp "You did not leave any room for a spacer column.  You are supposed to leave a spacer column."
        Set totalWrittenAreaPlusSpacerColumnOnLeft = totalWrittenArea_weAssumeThatASpacerColumnExistsOnBothTheLeftAndRightSidesOfThisRnge
        spacerColumnOnLeftExists = False
    Else
        Set totalWrittenAreaPlusSpacerColumnOnLeft = expandRnge(shiftRnge(totalWrittenArea_weAssumeThatASpacerColumnExistsOnBothTheLeftAndRightSidesOfThisRnge, 0, -NUMBER_OF_SPACER_COLUMNS_IN_REPORT_THAT_WILL_BE_EXPORTED_TO_PDF), 0, NUMBER_OF_SPACER_COLUMNS_IN_REPORT_THAT_WILL_BE_EXPORTED_TO_PDF)
        spacerColumnOnLeftExists = True
    End If
        
    Dim printArea As Range
    Set printArea = expandRnge(totalWrittenAreaPlusSpacerColumnOnLeft, 0, NUMBER_OF_SPACER_COLUMNS_IN_REPORT_THAT_WILL_BE_EXPORTED_TO_PDF)
    
    Dim anyCellInRightMostColumnOfRptArea As Range
    Set anyCellInRightMostColumnOfRptArea = brcor(printArea)
    
    'Resize the left-most spacer column
    If spacerColumnOnLeftExists Then
        tlcor(printArea).Columns(1).ColumnWidth = 1
    End If
    
    'Resize the right-most spacer column
    anyCellInRightMostColumnOfRptArea.Columns(1).ColumnWidth = 1
    
    With printArea.Worksheet.PageSetup
        .LeftHeader = ""
        .CenterHeader = ""
        .RightHeader = ""
        .LeftFooter = ""
        .CenterFooter = ""
        .RightFooter = ""
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.25)
        .BottomMargin = Application.InchesToPoints(0.25)
        .HeaderMargin = Application.InchesToPoints(0.1)
        .FooterMargin = Application.InchesToPoints(0.1)
    End With

    setPrintRngeAndEnsureOnePageWideAndOnePageTall printArea, True, True, True
End Sub


Function createNewWSForReportToBeExported(wsThatIsRightBeforeTheSpotWeWantToPutOurNewWS As Worksheet, desiredWSName As String, ByRef mod_emsgs As Variant) As Worksheet

    Dim wb As Workbook
    Set wb = wsThatIsRightBeforeTheSpotWeWantToPutOurNewWS.Parent
    
    Dim emsg As String
    Dim candidateWSForReport As Worksheet
    Set candidateWSForReport = createWSAndInitialize(wb, wsThatIsRightBeforeTheSpotWeWantToPutOurNewWS, desiredWSName, emsg)
    
    Dim wsForReport As Worksheet
    If emsg <> "" Then
        mod_emsgs.add emsg
        Set wsForReport = Nothing
    Else
        Set wsForReport = candidateWSForReport
    End If
    
    Set createNewWSForReportToBeExported = wsForReport
End Function

Sub generateReportAsPDFFriendlyExcelSheet(rptGenerator As JYUT_RptToolsGenerator, listOfSectionIdentifiers_byBaseTabTitle As Dictionary, maxRowsPerPage As Long, ByRef mod_emsgs As Variant, optListOfPagesToGenerate As Collection, wsThatIsRightBeforeTheSpotWeWantToPutOurNewWS As Worksheet)
    
    
    Dim emsgs As JYCORE_Set
    Set emsgs = New JYCORE_Set
    
    Dim afterWS_orNothingToCopyIntoNewWB As Worksheet
    Set afterWS_orNothingToCopyIntoNewWB = Nothing
    
    Dim hypotheticalWSForReport As Worksheet
    Set hypotheticalWSForReport = createNewWSForReportToBeExported(wsThatIsRightBeforeTheSpotWeWantToPutOurNewWS, "TestWS", emsgs)
    
    Dim listOf__identifierOfSectionsToShow_title As Collection
    Set listOf__identifierOfSectionsToShow_title = divideListsUp(rptGenerator, listOfSectionIdentifiers_byBaseTabTitle, maxRowsPerPage, emsgs, hypotheticalWSForReport)
    
    deleteWS hypotheticalWSForReport
    
    Dim pagesToInclude As JYCORE_Set
    If isNothing(optListOfPagesToGenerate) Then
        Set pagesToInclude = Nothing
    Else
        Set pagesToInclude = collectionToSet(optListOfPagesToGenerate)
    End If
    
    Dim jj As Long
    For jj = 1 To listOf__identifierOfSectionsToShow_title.count
    
        ssbm "#" & jj & " of " & listOf__identifierOfSectionsToShow_title.count
    
        Dim identifierOfSectionToShow_title As Variant
        identifierOfSectionToShow_title = listOf__identifierOfSectionsToShow_title.item(jj)
        
        Dim sectionIdentifiersToShow As Collection
        Dim title As String
        Set sectionIdentifiersToShow = rlai(identifierOfSectionToShow_title, 1)
        title = rlai(identifierOfSectionToShow_title, 2)

        Dim shouldGeneratePage As Boolean
        If isNothing(pagesToInclude) Then
            shouldGeneratePage = True
        Else
            shouldGeneratePage = pagesToInclude.exists(jj)
        End If
        
        If shouldGeneratePage Then
            
            Dim listOfSectionIdentifiers As Collection
            Set listOfSectionIdentifiers = sectionIdentifiersToShow
            
            
            Dim desiredWSName As String
            desiredWSName = title
            
            Dim origSel As Range
            Set origSel = getCurSel()
            
            Dim wsForReport As Worksheet
            Set wsForReport = createNewWSForReportToBeExported(wsThatIsRightBeforeTheSpotWeWantToPutOurNewWS, desiredWSName, emsgs)
            
            '--------------------------
        
            Dim totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn As Range
            Set totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn = rptGenerator.generateReportPage(wsForReport, listOfSectionIdentifiers, emsgs)
    
            If isNothing(totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn) Then
                'DO NOTHING
            Else
                setPrintSettingsAndResizeSpacerColumnsInPreparationForExportToPDF totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn
            End If
            
            Dim exportedWSOrNothingIfNothingWasExported As Worksheet
            If isNothing(totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn) Then
                Set exportedWSOrNothingIfNothingWasExported = Nothing
            Else
                Set exportedWSOrNothingIfNothingWasExported = exportPageInGraphsReport(totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn, afterWS_orNothingToCopyIntoNewWB, emsgs, origSel)
            End If
            
            wsThatIsRightBeforeTheSpotWeWantToPutOurNewWS.Parent.Activate
            
            '--------------------------
            
            
            
            Set afterWS_orNothingToCopyIntoNewWB = exportedWSOrNothingIfNothingWasExported
        End If
    Next
    ssbm "Done"
    
    addToEmsgsObject mod_emsgs, emsgs
End Sub

Function divideListsUp(rptGenerator As JYUT_RptToolsGenerator, listOfSectionIdentifiers_byBaseTabTitle As Dictionary, maxRowsPerPage As Long, ByRef mod_emsgs As Variant, wsForReport As Worksheet) As Collection
    
    Dim listOf__subList_title As Collection
    Set listOf__subList_title = New Collection
    
    Dim baseTabTitles As Variant
    baseTabTitles = listOfSectionIdentifiers_byBaseTabTitle.keys()
    
    Dim lwr As Long
    Dim upr As Long
    glaubs baseTabTitles, lwr, upr

    Dim d As Long
    For d = lwr To upr
        ssbm "Dividing lists: #" & (d - lwr + 1) & " of " & (upr - lwr + 1) & "..."
        Dim baseTabTitle As Variant
        baseTabTitle = baseTabTitles(d)

        Dim listOfSectionIdentifiers As Collection
        Set listOfSectionIdentifiers = vfd(listOfSectionIdentifiers_byBaseTabTitle, baseTabTitle, True)

        Dim listOf_rowsInSection As Collection
        Dim startingRow As Long
        rptGenerator.figureOutLayoutOfReportThatWeAreConsideringGenerating listOfSectionIdentifiers, listOf_rowsInSection, startingRow, mod_emsgs, wsForReport

        Dim firstRowToBeWrittenToOnEachPage As Long
        firstRowToBeWrittenToOnEachPage = startingRow
        
        Dim listOfSubLists As Collection
        Set listOfSubLists = doSplitSectnsIntoSeparatePages(listOfSectionIdentifiers, listOf_rowsInSection, maxRowsPerPage, startingRow)
        
        Dim k As Long
        For k = 1 To listOfSubLists.count
            
            Dim subList As Collection
            Set subList = listOfSubLists.item(k)
            
            Dim title As String
            If listOfSubLists.count = 1 Then
                title = baseTabTitle
            Else
                title = baseTabTitle & " (" & k & " of " & listOfSubLists.count & ")"
            End If
            
            listOf__subList_title.add Array(subList, title)
        Next
        ssbm "Done dividing lists!"
    Next
    
    Set divideListsUp = listOf__subList_title
End Function

Function exportPageInGraphsReport(totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn As Range, afterWS_orNothingToCopyIntoNewWB As Worksheet, ByRef mod_emsgs As Variant, origSel As Range) As Worksheet
    
    Dim emsg2 As String
    Dim exportedWSOrNothingIfNothingWasExported As Worksheet
    Set exportedWSOrNothingIfNothingWasExported = doExportSheetAsExcel(totalWrittenArea_noteThatThisAreaIsBorderedOnLeftAndRightSidesByBlankSpacerColumn.Worksheet, emsg2, afterWS_orNothingToCopyIntoNewWB, False, False, False)
    
    deleteNamesInWB castToWorkbook(exportedWSOrNothingIfNothingWasExported.Parent)
    
    If emsg2 <> "" Then
        mod_emsgs.add emsg2
    End If
    
    sris origSel
    
    exportedWSOrNothingIfNothingWasExported.Activate
    exportedWSOrNothingIfNothingWasExported.Calculate
    
    Set exportPageInGraphsReport = exportedWSOrNothingIfNothingWasExported
End Function

Attribute VB_Name = "JYUT_RngeIncrementer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private rngesByName As Dictionary
Private inputRnges As Collection
Private outputRnges As Collection
Private minRow As Long
Private maxRow As Long
Private curIncrement As Long

Property Get allRNs() As Collection
    Dim allTheRNs As Collection
    Set allTheRNs = copyCollection(Me.inputRNs)
    acltcl allTheRNs, Me.outputRNs
    
    Set allRNs = allTheRNs
End Property

Property Get inputRNs() As Collection
    Set inputRNs = copyCollection(inputRnges)
End Property

Property Get outputRNs() As Collection
    Set outputRNs = copyCollection(outputRnges)
End Property

Function clone() As JYUT_RngeIncrementer
    
    Dim ri As JYUT_RngeIncrementer
    Set ri = New JYUT_RngeIncrementer
    
    ri.private_setInternals rngesByName, inputRnges, outputRnges, minRow, maxRow, curIncrement

    Set clone = ri
    
End Function

Sub private_setInternals(p_rngesByName As Dictionary, p_inputRnges As Collection, p_outputRnges As Collection, p_minRow As Long, p_maxRow As Long, p_curIncrement As Long)

    Set rngesByName = copyDictionary(p_rngesByName)
    Set inputRnges = copyCollection(p_inputRnges)
    Set outputRnges = copyCollection(p_outputRnges)
    minRow = p_minRow
    maxRow = p_maxRow
    curIncrement = p_curIncrement

End Sub

Function curRow() As Long
    curRow = curIncrement
End Function

Private Sub Class_Initialize()
    Set rngesByName = New Dictionary
    Set inputRnges = New Collection
    Set outputRnges = New Collection
    minRow = 0
    maxRow = 0
    curIncrement = 0
End Sub

Sub addNamedRnge_specifyAbsoluteLastRowAssumption(rn As String, optWS As Worksheet, outputVersusInputRnge As Boolean, lastPossibleRow As Long)
    
    Dim anchor As Range
    Set anchor = rnge(rn, optWS)
    
    If isNothing(anchor) Then
        elwp "Could not find our anchor!"
    Else
        Me.addRnge_specifyAbsoluteLastRowAssumption rn, anchor, outputVersusInputRnge, lastPossibleRow
    End If
    
End Sub

Sub addNamedRnge(rn As String, optWS As Worksheet, outputVersusInputRnge As Boolean)
    Me.addNamedRnge_specifyAbsoluteLastRowAssumption rn, optWS, outputVersusInputRnge, LAST_POSSIBLE_ROW

End Sub

Sub addNamedRnges(rns As Collection, optWS As Worksheet, outputVersusInputRnge As Boolean)
    Dim c As Long
    For c = 1 To rns.count
        Dim rn As String
        rn = rns.item(c)
        
        Me.addNamedRnge rn, optWS, outputVersusInputRnge
    Next
End Sub

Function addRnges(rnPrefix As String, rngeOrArrayOfRngesOrCollectionOfRnges As Variant, outputVersusInputRnges As Boolean) As Collection

    Dim arr As Variant
    arr = ensureValueIsAnArray(rngeOrArrayOfRngesOrCollectionOfRnges)
    
    Dim lwr As Long
    Dim upr As Long
    glaubs arr, lwr, upr

    Dim generatedRNsInOrder As Collection
    Set generatedRNsInOrder = New Collection

    Dim c As Long
    For c = lwr To upr
    
        Dim theRnge As Range
        Set theRnge = arr(c)
    
        Dim rn As String
        rn = rnPrefix & c
        
        generatedRNsInOrder.add rn
        
        Me.addRnge rn, theRnge, outputVersusInputRnges
    Next
    
    Set addRnges = generatedRNsInOrder

End Function

Sub addRnge_specifyAbsoluteLastRowAssumption(rn As String, rnge As Range, outputVersusInputRnge As Boolean, lastPossibleRow As Long)
    
    lookAtCurrentAnchorForRowAndColAndAdjustWhatWeKnowAboutTheMaxAndMinRowOrColSeenSoFar rnge, minRow, maxRow, True, lastPossibleRow
    
    If curIncrement < minRow Then
        curIncrement = minRow
    End If
    If (maxRow <> 0) And (curIncrement > maxRow) Then
        curIncrement = maxRow
    End If
    
    If rngesByName.exists(rn) Then
        elwp "'" & rn & "' already exists in our range incrementer!"
    Else
        atd rngesByName, rn, rnge
    End If
    
    If outputVersusInputRnge Then
        outputRnges.add rn
    Else
        inputRnges.add rn
    End If

End Sub
Sub addRnge(rn As String, rnge As Range, outputVersusInputRnge As Boolean)
    Me.addRnge_specifyAbsoluteLastRowAssumption rn, rnge, outputVersusInputRnge, LAST_POSSIBLE_ROW
End Sub

Sub increment()
    curIncrement = curIncrement + 1
End Sub

Function getAnchorCell(rn As String) As Range
    If Not rngesByName.exists(rn) Then
        elwp "Unknown range name: " & rn
        Set getAnchorCell = Nothing
    Else
        Set getAnchorCell = rngesByName.item(rn)
    End If
End Function
Function getCurDataCell(rn As String) As Range
    Dim anchorCell As Range
    Set anchorCell = Me.getAnchorCell(rn)
    
    If isNothing(anchorCell) Then
        Set getCurDataCell = Nothing
    Else
        Set getCurDataCell = gcicsr(anchorCell, curIncrement)
    End If
End Function

Function getValue(rn As String) As Variant
    
    Dim dataCell As Range
    Set dataCell = Me.getCurDataCell(rn)
    
    If isNothing(dataCell) Then
        Set getValue = Nothing
    Else
        getValue = gvl(dataCell)
    End If
End Function

Sub setCellColor(rn As String, colorIndication As String)
    setColor Me.getCurDataCell(rn), colorIndication
End Sub

Sub setValue_noWrap(rn As String, theVal As Variant)
    setValue rn, theVal
    setCellWrapText rn, False
End Sub


Sub setCellWrapText(rn As String, wrapText As Boolean)
    setWrapText Me.getCurDataCell(rn), wrapText
End Sub

Sub setFormula(rn As String, theFormula As String)
    Dim dataCell As Range
    Set dataCell = Me.getCurDataCell(rn)
    
    If isNothing(dataCell) Then
        elwp "Unknown cell: " & rn
    Else
        setCellFormula dataCell, theFormula, False
    End If
End Sub

Sub setValue(rn As String, theVal As Variant)
    
    Dim dataCell As Range
    Set dataCell = Me.getCurDataCell(rn)
    
    If isNothing(dataCell) Then
        elwp "Unknown cell: " & rn
    Else
        svl dataCell, theVal
    End If
End Sub

Function moreDataRemaining() As Boolean
    moreDataRemaining = (curIncrement <= maxRow)
End Function

Function numRowsOfDataRemaining() As Long
    numRowsOfDataRemaining = maxRow - curIncrement + 1
End Function

Function lastRow() As Long
    lastRow = maxRow
End Function

Function firstRow() As Long
    firstRow = minRow
End Function

Sub clearOutputFields()

    Dim firstRow As Long
    Dim lastRow As Long
    firstRow = Me.firstRow()
    lastRow = Me.lastRow()

    clearOutputFieldsBetweenRows firstRow, lastRow

End Sub

Sub clearInputFields()

    Dim firstRow As Long
    Dim lastRow As Long
    firstRow = Me.firstRow()
    lastRow = Me.lastRow()

    clearInputFieldsBetweenRows firstRow, lastRow

End Sub

Sub clearInputFieldsBetweenRows(firstRow As Long, lastRow As Long)
    clearFieldsBetweenRws True
End Sub


Sub clearOutputFieldsBetweenRows(firstRow As Long, lastRow As Long)
    clearFieldsBetweenRws False
End Sub

Private Sub clearFieldsBetweenRws(inputFieldsVsOutputFields As Boolean)

    Dim whichRanges As Collection
    If inputFieldsVsOutputFields Then
        Set whichRanges = inputRnges
    Else
        Set whichRanges = outputRnges
    End If

    Dim origCalc As Variant
    origCalc = tsctm()

    Dim c As Long
    For c = 1 To whichRanges.count
        Dim rn As String
        rn = whichRanges.item(c)
        
        Dim anchor As Range
        Set anchor = getAnchorCell(rn)
        
        If lastRow < firstRow Then
            'DO NOTHING
        Else
            clearCellsFromRowToRow anchor, firstRow, lastRow
        End If
    Next
    
    rok origCalc

End Sub

Sub setRowToSubsetAccordingToRnge(rnge As Range)

    Dim rngeFirstRow As Long
    Dim rngeLastRow As Long
    rngeFirstRow = rnge.row
    rngeLastRow = rnge.row + rnge.rows.count - 1
    
    minRow = wsFunctionMax(minRow, rngeFirstRow)
    maxRow = wsFunctionMin(maxRow, rngeLastRow)
    curIncrement = minRow
    
End Sub

Sub setRowTo(row As Long)
    curIncrement = row
End Sub

Sub setRowToEnd()
    curIncrement = wsFunctionMax(minRow, maxRow + 1)
End Sub

Sub selectCell(rn As String)
    srg Me.getCurDataCell(rn)
End Sub

Function getAnchorCellsCorrespondingToRNs(rns As Variant) As Collection

    Dim rngeIncrementer As JYUT_RngeIncrementer
    Set rngeIncrementer = Me

    Dim lwr As Long
    Dim upr As Long
    glaubs rns, lwr, upr
    
    Dim anchorCells As Collection
    Set anchorCells = New Collection
    
    Dim c As Long
    For c = lwr To upr
        Dim disRN As String
        disRN = rns(c)
    
        Dim daAnchorCell As Range
        Set daAnchorCell = rngeIncrementer.getAnchorCell(disRN)
    
        If isNothing(daAnchorCell) Then
            elwp "Unknown cell: " & rn
        End If
        anchorCells.add daAnchorCell
    Next

    Set getAnchorCellsCorrespondingToRNs = anchorCells
End Function

Sub writeResultsToCurrentRow(valByRN As Dictionary)

    Dim rngeIncrementer As JYUT_RngeIncrementer
    Set rngeIncrementer = Me
    
    Dim curRow As Long
    curRow = rngeIncrementer.curRow()
    
    Dim rns As Variant
    rns = valByRN.keys()
    
    Dim anchorCells As Collection
    Dim theVals As Collection
    Set anchorCells = getAnchorCellsCorrespondingToRNs(rns)
    Set theVals = getValsFromDictionaryForListOfKeys(rns, valByRN, True)
    
    Dim sz As Long
    sz = ccsz(Array(anchorCells, theVals), True)
    
    Dim anchorCellsForColsToWriteInto As Collection
    Dim theValsToWrite As Collection
    Set anchorCellsForColsToWriteInto = New Collection
    Set theValsToWrite = New Collection
    
    Dim c As Long
    For c = 1 To sz
        Dim anchorCell As Range
        Dim theVal As Variant
        Set anchorCell = anchorCells.item(c)
        atr theVal, theVals.item(c)
        
        If isNothing(anchorCell) Then
            'DO NOTHING
        Else
            anchorCellsForColsToWriteInto.add anchorCell
            theValsToWrite.add theVal
        End If
    Next
    
    Dim listOf_theValsToWrite As Collection
    Set listOf_theValsToWrite = New Collection
    With listOf_theValsToWrite
        .add theValsToWrite
    End With
    
    writeValuesToRowInColumns anchorCellsForColsToWriteInto, listOf_theValsToWrite, curRow

End Sub

Function getValuesForRNs_asArray(rns As Collection, lowerBound As Long) As Variant

    Dim upperBound As Long
    upperBound = lowerBound + rns.count - 1

    Dim arr As Variant
    ReDim arr(lowerBound To upperBound)
    
    Dim c As Long
    For c = lowerBound To upperBound
        
        Dim rn As String
        rn = rns.item(c - lowerBound + 1)
        
        Dim theVal As Variant
        atr theVal, Me.getValue(rn)
        
        atr arr(c), theVal
    Next

    getValuesForRNs_asArray = arr
End Function

Function getValuesForRNs(rns As Collection) As Dictionary
    
    Dim vals As Collection
    Set vals = Me.getValuesForRNs_asCollection(rns)
    
    Dim valByRN As Dictionary
    Set valByRN = New Dictionary
    
    Dim sz As Long
    sz = ccsz(Array(rns, vals), True)
    
    Dim c As Long
    For c = 1 To sz
    
        Dim rn As String
        rn = rns.item(c)
        
        Dim theVal As Variant
        atr theVal, vals.item(c)
        
        If valByRN.exists(rn) Then
            elwp "A value already exists for this RN!"
        Else
            atd valByRN, rn, theVal
        End If
    Next
    
    Set getValuesForRNs = valByRN
    
End Function

Function getValuesForRNs_asCollection(rns As Collection) As Collection
    Set getValuesForRNs_asCollection = arrayToCollection(getValuesForRNs_asArray(rns, 1))
End Function

Sub setValues(listOf__rn_data As Collection)
    
    Dim ranges As JYUT_RngeIncrementer
    Set ranges = Me
    
    Dim p As Long
    For p = 1 To listOf__rn_data.count
        Dim rn_data As Variant
        rn_data = listOf__rn_data.item(p)
        
        Dim rn As String
        Dim data As Variant
        rn = rlai(rn_data, 1)
        data = rlai(rn_data, 2)
        
        ranges.setValue rn, data
    Next
    
End Sub

Attribute VB_Name = "JYUT_RngeIncrementers"
Option Explicit

Sub ssbm_ranges(rngesObj As JYUT_RngeIncrementer, Optional optMsg As String)

    Dim theCurRow As Long
    theCurRow = rngesObj.curRow

    Dim theLastRow As Long
    theLastRow = rngesObj.lastRow
    
    ssbm_everyX theCurRow, theLastRow, optMsg
    
End Sub
Attribute VB_Name = "JYUT_RptToolsGenerator"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
'THIS IS AN INTERFACE!

Function generateReportPage(wsForReport As Worksheet, listOfSectionIdentifiers As Collection, ByRef mod_emsgs As Variant) As Range
    'THIS IS A STUB METHOD, SINCE THE CURRENT CLASS IS AN INTERFACE!
    'DO NOTHING
End Function


Sub figureOutLayoutOfReportThatWeAreConsideringGenerating(listOfSectionIdentifiers As Collection, ByRef out_listOf_rowsInSection As Collection, ByRef out_startingRow As Long, ByRef mod_emsgs As Variant, wsForReport As Worksheet)
    'THIS IS A STUB METHOD, SINCE THE CURRENT CLASS IS AN INTERFACE!
    'DO NOTHING
End Sub

Attribute VB_Name = "JYUT_Serialization"
Option Explicit

Public Const BOOLEAN_POSSIBLY_REPRESENTED_BY_NOTHING_TEXT As String = "convert to boolean, and handle nothing text"
Public Const POSSIBLE_NUMBER_AND_POSSIBLY_REPRESENTED_BY_NOTHING_TEXT As String = "convert to number if exists, and handle nothing text"

Public Const STRING_FOR_NOTHING As String = "[NOTHING]"

Function rmvKeyForProcessing(ByRef mod_textRepresentationOfParamsByStructureName As Dictionary, keyName As String, ByRef mod_emsgs As Variant) As String
    
    Dim theVal As Variant
    atr theVal, rfd(mod_textRepresentationOfParamsByStructureName, keyName)
    
    If isNothing(theVal) Then
        mod_emsgs.add "Unexpectedly did not find the key '" & keyName & "' in our object's serialized text representation!"
    End If
    
    rmvKeyForProcessing = nothingToBlankString(theVal)
End Function

Function extractTextRepresentationsFromKeyedSerialization(serializedStringRepresentingDictionaryObject As String, nvpDelim As String, entryDelim As String, escChar As String, ByRef mod_emsgs As Variant, listOf__paramName_options As Collection) As Variant
    
    Dim results As Variant
    ReDim results(1 To listOf__paramName_options.count)
    
    Dim textRepresentationByKeyName As Dictionary
    Set textRepresentationByKeyName = stringToDict_allValuesRemainStrings(serializedStringRepresentingDictionaryObject, nvpDelim, entryDelim, escChar, mod_emsgs)
    
    Dim c As Long
    For c = 1 To listOf__paramName_options.count
        Dim paramName_options As Variant
        paramName_options = listOf__paramName_options.item(c)
        
        Dim paramName As String
        Dim options As Variant
        paramName = rlai(paramName_options, 1)
        atr options, rlai(paramName_options, 2)
        
        Dim textRepresentation As String
        textRepresentation = rmvKeyForProcessing(textRepresentationByKeyName, paramName, mod_emsgs)
        
        Dim textRepOrBooleanOrNothing As Variant
        If isNothing(options) Then
            textRepOrBooleanOrNothing = textRepresentation
        Else
            If options = POSSIBLE_NUMBER_AND_POSSIBLY_REPRESENTED_BY_NOTHING_TEXT Or options = BOOLEAN_POSSIBLY_REPRESENTED_BY_NOTHING_TEXT Then
                
                
                
                Dim interim As Variant
                atr interim, handleNothingTextRepIfNecessary(textRepresentation)
                
                If options = POSSIBLE_NUMBER_AND_POSSIBLY_REPRESENTED_BY_NOTHING_TEXT Then
                    atr textRepOrBooleanOrNothing, interim
                ElseIf options = BOOLEAN_POSSIBLY_REPRESENTED_BY_NOTHING_TEXT Then
                    If isNothing(interim) Then
                        Set textRepOrBooleanOrNothing = Nothing
                    Else
                        textRepOrBooleanOrNothing = textToBoolean(interim)
                    End If
                Else
                    mod_emsgs.add "Encountered unknown options: " & options
                    atr textRepOrBooleanOrNothing, interim
                End If
                
            Else
                mod_emsgs.add "Unknown options: " & options
                textRepOrBooleanOrNothing = textRepresentation
            End If
        End If
        
        If IsObject(textRepOrBooleanOrNothing) Then
            Set results(c) = Nothing
        Else
            results(c) = textRepOrBooleanOrNothing
        End If
        
    Next
    
    validateThatNoExtraInformationWasPresent textRepresentationByKeyName, mod_emsgs
    
    extractTextRepresentationsFromKeyedSerialization = results
End Function

Sub validateThatNoExtraInformationWasPresent(textRepresentationByKeyName As Dictionary, ByRef mod_emsgs As Variant)

    If textRepresentationByKeyName.count <> 0 Then
        mod_emsgs.add "Some of the information in our text representation was not used!"
    End If
End Sub

'----------------------------------------------------------------------------------------------------

Function representAsNothingTextIfApplicable(something As Variant) As String
    
    Dim textRepresentation As String
    If isNothing(something) Then
        textRepresentation = STRING_FOR_NOTHING
    Else
        textRepresentation = something
    End If
    
    representAsNothingTextIfApplicable = textRepresentation
End Function

Function handleNothingTextRepIfNecessary(textRep As String) As Variant
    If textRepIndicatesNothing(textRep) Then
        Set handleNothingTextRepIfNecessary = Nothing
    Else
        handleNothingTextRepIfNecessary = convertToNumberIfPossible(textRep)
    End If
End Function

Function textRepIndicatesNothing(textRep As String) As Boolean
    textRepIndicatesNothing = (textRep = STRING_FOR_NOTHING)
End Function

Attribute VB_Name = "JYUT_Set"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'This module has been moved to the JYCORE library.
Attribute VB_Name = "JYUT_ShortHand"
Option Explicit

'This module lets me use abbreviations for commonly-used functions.
'This saves me typing-time!


'atr stands for "assignToReference"
Sub atr(ByRef mod_ref As Variant, itemToAssign As Variant)
    assignToReference mod_ref, itemToAssign
End Sub

'"gvl" stands for "getValue"
Function gvl(rnge As Range) As Variant
    atr gvl, getValue(rnge)
End Function

'cltstr stands for "collectionToString"
Function cltstr(coll As Collection, delim As String, escCharacter As String) As String
    cltstr = collectionToString(coll, delim, escCharacter)
End Function

'atd stands for "addToDict"
'mod_dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Function atd(ByRef mod_dict As Variant, key As Variant, value As Variant) As Variant
    atr atd, addToDictionary(mod_dict, key, value)
End Function

'glaubs stands for "getLowerAndUpperBbounds"
Sub glaubs(arr As Variant, ByRef out_lower As Long, ByRef out_upper As Long)
    getLowerAndUpperBounds arr, out_lower, out_upper
End Sub

'vfd stands for "valueFromDictionary"
'dict is a variant in case we decide to pass in a JYUT_AdvancedDictionary
Function vfd(dict As Variant, key As Variant, popupMsgIfNotThere As Boolean)
    atr vfd, valueFromDictionary(dict, key, popupMsgIfNotThere)
End Function

'clocdiloar stands for "convertListOfColumnDataIntoListOfArrayRows"
Function clocdiloar(colDataCollectionOrArrayOfColDataCollectionsOrListOfColDataCollections As Variant, lowerBound As Long) As Collection
    atr clocdiloar, convertListOfColumnDataIntoListOfArrayRows(colDataCollectionOrArrayOfColDataCollectionsOrListOfColDataCollections, lowerBound, COL_DATA_TYPE_COLLECTION_OR_ONE_DIM_ARRAY)
End Function

'sciloar stands for "separateColumnsInListOfArrayRows"
Function sciloar(allBoundsAreExpectedToBeAlike As Boolean, listOf_1dArray As Collection) As Collection
    atr sciloar, separateColumnsInListOfArrayRows(allBoundsAreExpectedToBeAlike, listOf_1dArray)
End Function

'scm stands for "showCompletedMessage"
Sub scm(msg As String, emsgs As Variant, startAndEndTime_orNothingToNotShowTimeCompleted As Variant)
    showCompletedMessage msg, emsgs, startAndEndTime_orNothingToNotShowTimeCompleted
End Sub

'atk stands for "arrayToCollection"
Function atk(arr As Variant) As Collection
    Set atk = arrayToCollection(arr)
End Function

'kta stands for "collectionToArray"
Function kta(data As Collection) As Variant
    kta = collectionToArray(data)
End Function

'cdf_withAdditionalParams stands for "copyDownFormulas_withAdditionalParams"
Function cdf_withAdditionalParams(anchorsArrayListOrCollection As Variant, formulaRanges As Collection, dataAnchorRow As Long, showSuccessMsg As Boolean, returnToOrigSelWhenDone As Boolean, optMinRow_orNothingForNoMinimum As Variant) As Long
    cdf_withAdditionalParams = copyDownRowOrColFormulas_withAdditionalParams(anchorsArrayListOrCollection, formulaRanges, dataAnchorRow, showSuccessMsg, returnToOrigSelWhenDone, optMinRow_orNothingForNoMinimum, True, dataAnchorRow, True)
End Function

Function copyDownRowFormulas_withAdditionalParams(anchorsArrayListOrCollection As Variant, formulaRanges As Collection, dataAnchorCol As Long, showSuccessMsg As Boolean, returnToOrigSelWhenDone As Boolean, optMinCol_orNothingForNoMinimum As Variant) As Long
    copyDownRowFormulas_withAdditionalParams = copyDownRowOrColFormulas_withAdditionalParams(anchorsArrayListOrCollection, formulaRanges, dataAnchorCol, showSuccessMsg, returnToOrigSelWhenDone, optMinCol_orNothingForNoMinimum, False, dataAnchorCol, True)
End Function

'cdf stadns for "copyDownFormulas"
Function cdf(optWS As Worksheet, rnOrRNsForAnchors As Variant, rnForFormulasOrArrayorCollectionOfRNsForThem As Variant, showSuccessMsg As Boolean) As Long
    cdf = copyDownFormulas(optWS, rnOrRNsForAnchors, rnForFormulasOrArrayorCollectionOfRNsForThem, showSuccessMsg)
End Function

'tsctm stands for "temporarilySetCalcsToManual"
Function tsctm() As Variant
    tsctm = temporarilySetCalcsToManual
End Function

'rok stands for "restoreOrigCalcs"
Sub rok(origCalc As Variant)
    restoreOrigCalcs origCalc
End Sub

'sae stands for "stringsAreEqual"
'Please note that "caseSensitive" parameter is opposite now
Function sae2(S1 As String, S2 As String, caseSensitive As Boolean, trimBeforeComparing As Boolean) As Boolean
    sae2 = stringsAreEqual2(S1, S2, caseSensitive, trimBeforeComparing)
End Function

'ewio stands for "ensureWorkbookIsOpen"
Sub ewio(filePath As String, updateLinksIfOpened As Boolean, readOnlyIfOpened As Boolean, ByRef out_wbOrEmsg As Variant, ByRef out_wasOpened As Boolean, delimiterOfShouldOpenAsTextOrBlankStringOtherwise As String)
    ensureWorkbookIsOpen filePath, updateLinksIfOpened, readOnlyIfOpened, out_wbOrEmsg, out_wasOpened, delimiterOfShouldOpenAsTextOrBlankStringOtherwise
End Sub

'gfrd stands for "getFullRngeDefinition"
Function gfrd(theRnge As Range, includeWSName As Boolean, absoluteforcolumn As Boolean, absoluteForRow As Boolean, useR1C1 As Boolean) As String
    gfrd = getFullRngeDefinition(theRnge, includeWSName, absoluteforcolumn, absoluteForRow, useR1C1)
End Function

Function scd(header As Range, dataCollectionOrArrayOrRnge As Variant) As Range
    Set scd = setColumnData(header, dataCollectionOrArrayOrRnge)
End Function

Function scd_optionallySelectAsWeSet(header As Range, dataCollectionOrArrayOrRnge As Variant, selectAsWeSet As Boolean) As Range
    Set scd_optionallySelectAsWeSet = setColumnData_optionallySelectAsWeSet(header, dataCollectionOrArrayOrRnge, selectAsWeSet)
End Function

'acltcl stands for 'addCollectionToCollection'
Function acltcl(ByRef mod_collToAddTo As Variant, collectionToAdd As Collection) As Collection
    Set acltcl = addCollectionToCollection(mod_collToAddTo, collectionToAdd)
End Function

'stands for "application.screenUpdating=true"
Sub ast()
    Application.ScreenUpdating = True
End Sub
Attribute VB_Name = "JYUT_SimpleFactoryInterface"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Function create() As Variant
    'STUB METHOD, SINCE THIS CLASS IS AN INTERFACE
    'DO NOTHING
End Function

Attribute VB_Name = "JYUT_SortingCPearson"
Option Explicit
Option Compare Text

'http://www.cpearson.com/excel/SortingArrays.aspx

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modQSortInPlace
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This module contains the QSortInPlace procedure and private supporting procedures.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function QSortInPlace( _
    ByRef InputArray As Variant, _
    Optional ByVal LB As Long = -1&, _
    Optional ByVal UB As Long = -1&, _
    Optional ByVal Descending As Boolean = False, _
    Optional ByVal CompareMode As VbCompareMethod = vbTextCompare, _
    Optional ByVal NoAlerts As Boolean = False) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' QSortInPlace
'
' This function sorts the array InputArray in place -- this is, the original array in the
' calling procedure is sorted. It will work with either string data or numeric data.
' It need not sort the entire array. You can sort only part of the array by setting the LB and
' UB parameters to the first (LB) and last (UB) element indexes that you want to sort.
' LB and UB are optional parameters. If omitted LB is set to the LBound of InputArray, and if
' omitted UB is set to the UBound of the InputArray. If you want to sort the entire array,
' omit the LB and UB parameters, or set both to -1, or set LB = LBound(InputArray) and set
' UB to UBound(InputArray).
'
' By default, the sort method is case INSENSTIVE (case doens't matter: "A", "b", "C", "d").
' To make it case SENSITIVE (case matters: "A" "C" "b" "d"), set the CompareMode argument
' to vbBinaryCompare (=0). If Compare mode is omitted or is any value other than vbBinaryCompare,
' it is assumed to be vbTextCompare and the sorting is done case INSENSITIVE.
'
' The function returns TRUE if the array was successfully sorted or FALSE if an error
' occurred. If an error occurs (e.g., LB > UB), a message box indicating the error is
' displayed. To suppress message boxes, set the NoAlerts parameter to TRUE.
'
''''''''''''''''''''''''''''''''''''''
' MODIFYING THIS CODE:
''''''''''''''''''''''''''''''''''''''
' If you modify this code and you call "Exit Procedure", you MUST decrment the RecursionLevel
' variable. E.g.,
'       If SomethingThatCausesAnExit Then
'           RecursionLevel = RecursionLevel - 1
'           Exit Function
'       End If
'''''''''''''''''''''''''''''''''''''''
'
' Note: If you coerce InputArray to a ByVal argument, QSortInPlace will not be
' able to reference the InputArray in the calling procedure and the array will
' not be sorted.
'
' This function uses the following procedures. These are declared as Private procedures
' at the end of this module:
'       IsArrayAllocated
'       IsSimpleDataType
'       IsSimpleNumericType
'       QSortCompare
'       NumberOfArrayDimensions
'       ReverseArrayInPlace
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Temp As Variant
Dim Buffer As Variant
Dim CurLow As Long
Dim CurHigh As Long
Dim CurMidpoint As Long
Dim Ndx As Long
Dim pCompareMode As VbCompareMethod

'''''''''''''''''''''''''
' Set the default result.
'''''''''''''''''''''''''
QSortInPlace = False

''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This variable is used to determine the level
' of recursion  (the function calling itself).
' RecursionLevel is incremented when this procedure
' is called, either initially by a calling procedure
' or recursively by itself. The variable is decremented
' when the procedure exits. We do the input parameter
' validation only when RecursionLevel is 1 (when
' the function is called by another function, not
' when it is called recursively).
''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Static RecursionLevel As Long


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Keep track of the recursion level -- that is, how many
' times the procedure has called itself.
' Carry out the validation routines only when this
' procedure is first called. Don't run the
' validations on a recursive call to the
' procedure.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
RecursionLevel = RecursionLevel + 1

If RecursionLevel = 1 Then
    ''''''''''''''''''''''''''''''''''
    ' Ensure InputArray is an array.
    ''''''''''''''''''''''''''''''''''
    If IsArray(InputArray) = False Then
        If NoAlerts = False Then
            MsgBox "The InputArray parameter is not an array."
        End If
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' InputArray is not an array. Exit with a False result.
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''
        RecursionLevel = RecursionLevel - 1
        Exit Function
    End If
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Test LB and UB. If < 0 then set to LBound and UBound
    ' of the InputArray.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If LB < 0 Then
        LB = LBound(InputArray)
    End If
    If UB < 0 Then
        UB = UBound(InputArray)
    End If
    
    Select Case NumberOfArrayDimensions(InputArray)
        Case 0
            ''''''''''''''''''''''''''''''''''''''''''
            ' Zero dimensions indicates an unallocated
            ' dynamic array.
            ''''''''''''''''''''''''''''''''''''''''''
            If NoAlerts = False Then
                MsgBox "The InputArray is an empty, unallocated array."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case 1
            ''''''''''''''''''''''''''''''''''''''''''
            ' We sort ONLY single dimensional arrays.
            ''''''''''''''''''''''''''''''''''''''''''
        Case Else
            ''''''''''''''''''''''''''''''''''''''''''
            ' We sort ONLY single dimensional arrays.
            ''''''''''''''''''''''''''''''''''''''''''
            If NoAlerts = False Then
                MsgBox "The InputArray is multi-dimensional." & _
                      "QSortInPlace works only on single-dimensional arrays."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
    End Select
    '''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Ensure that InputArray is an array of simple data
    ' types, not other arrays or objects. This tests
    ' the data type of only the first element of
    ' InputArray. If InputArray is an array of Variants,
    ' subsequent data types may not be simple data types
    ' (e.g., they may be objects or other arrays), and
    ' this may cause QSortInPlace to fail on the StrComp
    ' operation.
    '''''''''''''''''''''''''''''''''''''''''''''''''''
    If IsSimpleDataType(InputArray(LBound(InputArray))) = False Then
        If NoAlerts = False Then
            MsgBox "InputArray is not an array of simple data types."
            RecursionLevel = RecursionLevel - 1
            Exit Function
        End If
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ensure that the LB parameter is valid.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case LB
        Case Is < LBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The LB lower bound parameter is less than the LBound of the InputArray"
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is > UBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The LB lower bound parameter is greater than the UBound of the InputArray"
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is > UB
            If NoAlerts = False Then
                MsgBox "The LB lower bound parameter is greater than the UB upper bound parameter."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
    End Select

    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ensure the UB parameter is valid.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case UB
        Case Is > UBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The UB upper bound parameter is greater than the upper bound of the InputArray."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is < LBound(InputArray)
            If NoAlerts = False Then
                MsgBox "The UB upper bound parameter is less than the lower bound of the InputArray."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
        Case Is < LB
            If NoAlerts = False Then
                MsgBox "the UB upper bound parameter is less than the LB lower bound parameter."
            End If
            RecursionLevel = RecursionLevel - 1
            Exit Function
    End Select

    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' if UB = LB, we have nothing to sort, so get out.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If UB = LB Then
        QSortInPlace = True
        RecursionLevel = RecursionLevel - 1
        Exit Function
    End If

End If ' RecursionLevel = 1

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Ensure that CompareMode is either vbBinaryCompare  or
' vbTextCompare. If it is neither, default to vbTextCompare.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If (CompareMode = vbBinaryCompare) Or (CompareMode = vbTextCompare) Then
    pCompareMode = CompareMode
Else
    pCompareMode = vbTextCompare
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Begin the actual sorting process.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
CurLow = LB
CurHigh = UB

If LB = 0 Then
    CurMidpoint = ((LB + UB) \ 2) + 1
Else
    CurMidpoint = (LB + UB) \ 2 ' note integer division (\) here
End If
Temp = InputArray(CurMidpoint)

Do While (CurLow <= CurHigh)
    
    Do While QSortCompare(V1:=InputArray(CurLow), V2:=Temp, CompareMode:=pCompareMode) < 0
        CurLow = CurLow + 1
        If CurLow = UB Then
            Exit Do
        End If
    Loop
    
    Do While QSortCompare(V1:=Temp, V2:=InputArray(CurHigh), CompareMode:=pCompareMode) < 0
        CurHigh = CurHigh - 1
        If CurHigh = LB Then
           Exit Do
        End If
    Loop

    If (CurLow <= CurHigh) Then
        Buffer = InputArray(CurLow)
        InputArray(CurLow) = InputArray(CurHigh)
        InputArray(CurHigh) = Buffer
        CurLow = CurLow + 1
        CurHigh = CurHigh - 1
    End If
Loop

If LB < CurHigh Then
    QSortInPlace InputArray:=InputArray, LB:=LB, UB:=CurHigh, _
        Descending:=Descending, CompareMode:=pCompareMode, NoAlerts:=True
End If

If CurLow < UB Then
    QSortInPlace InputArray:=InputArray, LB:=CurLow, UB:=UB, _
        Descending:=Descending, CompareMode:=pCompareMode, NoAlerts:=True
End If

'''''''''''''''''''''''''''''''''''''
' If Descending is True, reverse the
' order of the array, but only if the
' recursion level is 1.
'''''''''''''''''''''''''''''''''''''
If Descending = True Then
    If RecursionLevel = 1 Then
        ReverseArrayInPlace2 InputArray, LB, UB
    End If
End If

RecursionLevel = RecursionLevel - 1
QSortInPlace = True
End Function

Public Function QSortCompare(V1 As Variant, V2 As Variant, _
    Optional CompareMode As VbCompareMethod = vbTextCompare) As Long
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' QSortCompare
' This function is used in QSortInPlace to compare two elements. If
' V1 AND V2 are both numeric data types (integer, long, single, double)
' they are converted to Doubles and compared. If V1 and V2 are BOTH strings
' that contain numeric data, they are converted to Doubles and compared.
' If either V1 or V2 is a string and does NOT contain numeric data, both
' V1 and V2 are converted to Strings and compared with StrComp.
'
' The result is -1 if V1 < V2,
'                0 if V1 = V2
'                1 if V1 > V2
' For text comparisons, case sensitivity is controlled by CompareMode.
' If this is vbBinaryCompare, the result is case SENSITIVE. If this
' is omitted or any other value, the result is case INSENSITIVE.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim D1 As Double
Dim D2 As Double
Dim S1 As String
Dim S2 As String

Dim Compare As VbCompareMethod
''''''''''''''''''''''''''''''''''''''''''''''''
' Test CompareMode. Any value other than
' vbBinaryCompare will default to vbTextCompare.
''''''''''''''''''''''''''''''''''''''''''''''''
If CompareMode = vbBinaryCompare Or CompareMode = vbTextCompare Then
    Compare = CompareMode
Else
    Compare = vbTextCompare
End If
'''''''''''''''''''''''''''''''''''''''''''''''
' If either V1 or V2 is either an array or
' an Object, raise a error 13 - Type Mismatch.
'''''''''''''''''''''''''''''''''''''''''''''''
If IsArray(V1) = True Or IsArray(V2) = True Then
    Err.Raise 13
    Exit Function
End If
If IsObject(V1) = True Or IsObject(V2) = True Then
    Err.Raise 13
    Exit Function
End If

If IsSimpleNumericType(V1) = True Then
    If IsSimpleNumericType(V2) = True Then
        '''''''''''''''''''''''''''''''''''''
        ' If BOTH V1 and V2 are numeric data
        ' types, then convert to Doubles and
        ' do an arithmetic compare and
        ' return the result.
        '''''''''''''''''''''''''''''''''''''
        D1 = CDbl(V1)
        D2 = CDbl(V2)
        If D1 = D2 Then
            QSortCompare = 0
            Exit Function
        End If
        If D1 < D2 Then
            QSortCompare = -1
            Exit Function
        End If
        If D1 > D2 Then
            QSortCompare = 1
            Exit Function
        End If
    End If
End If
''''''''''''''''''''''''''''''''''''''''''''
' Either V1 or V2 was not numeric data type.
' Test whether BOTH V1 AND V2 are numeric
' strings. If BOTH are numeric, convert to
' Doubles and do a arithmetic comparison.
''''''''''''''''''''''''''''''''''''''''''''
If IsNumeric(V1) = True And IsNumeric(V2) = True Then
    D1 = CDbl(V1)
    D2 = CDbl(V2)
    If D1 = D2 Then
        QSortCompare = 0
        Exit Function
    End If
    If D1 < D2 Then
        QSortCompare = -1
        Exit Function
    End If
    If D1 > D2 Then
        QSortCompare = 1
        Exit Function
    End If
End If
''''''''''''''''''''''''''''''''''''''''''''''
' Either or both V1 and V2 was not numeric
' string. In this case, convert to Strings
' and use StrComp to compare.
''''''''''''''''''''''''''''''''''''''''''''''
S1 = CStr(V1)
S2 = CStr(V2)
QSortCompare = StrComp(S1, S2, Compare)

End Function



Public Function NumberOfArrayDimensions(arr As Variant) As Integer
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' NumberOfArrayDimensions
' This function returns the number of dimensions of an array. An unallocated dynamic array
' has 0 dimensions. This condition can also be tested with IsArrayEmpty.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Ndx As Integer
Dim Res As Integer
On Error Resume Next
' Loop, increasing the dimension index Ndx, until an error occurs.
' An error will occur when Ndx exceeds the number of dimension
' in the array. Return Ndx - 1.
Do
    Ndx = Ndx + 1
    Res = UBound(arr, Ndx)
Loop Until Err.Number <> 0

NumberOfArrayDimensions = Ndx - 1

End Function
 
Public Function ReverseArrayInPlace(InputArray As Variant, _
    Optional NoAlerts As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ReverseArrayInPlace
' This procedure reverses the order of an array in place -- this is, the array variable
' in the calling procedure is sorted. An error will occur if InputArray is not an array,
 'if it is an empty, unallocated array, or if the number of dimensions is not 1.
'
' NOTE: Before calling the ReverseArrayInPlace procedure, consider if your needs can
' be met by simply reading the existing array in reverse order (Step -1). If so, you can save
' the overhead added to your application by calling this function.
'
' The function returns TRUE if the array was successfully reversed, or FALSE if
' an error occurred.
'
' If an error occurred, a message box is displayed indicating the error. To suppress
' the message box and simply return FALSE, set the NoAlerts parameter to TRUE.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Temp As Variant
Dim Ndx As Long
Dim Ndx2 As Long
Dim OrigN As Long
Dim NewN As Long
Dim NewArr() As Variant

''''''''''''''''''''''''''''''''
' Set the default return value.
''''''''''''''''''''''''''''''''
ReverseArrayInPlace = False

'''''''''''''''''''''''''''''''''
' Ensure we have an array
'''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
   If NoAlerts = False Then
        MsgBox "The InputArray parameter is not an array."
    End If
    Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Test the number of dimensions of the
' InputArray. If 0, we have an empty,
' unallocated array. Get out with
' an error message. If greater than
' one, we have a multi-dimensional
' array, which is not allowed. Only
' an allocated 1-dimensional array is
' allowed.
''''''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(InputArray)
    Case 0
        '''''''''''''''''''''''''''''''''''''''''''
        ' Zero dimensions indicates an unallocated
        ' dynamic array.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array is an empty, unallocated array."
        End If
        Exit Function
    Case 1
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
    Case Else
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array multi-dimensional. ReverseArrayInPlace works only " & _
                   "on single-dimensional arrays."
        End If
        Exit Function

End Select

'''''''''''''''''''''''''''''''''''''''''''''
' Ensure that we have only simple data types,
' not an array of objects or arrays.
'''''''''''''''''''''''''''''''''''''''''''''
If IsSimpleDataType(InputArray(LBound(InputArray))) = False Then
    If NoAlerts = False Then
        MsgBox "The input array contains arrays, objects, or other complex data types." & vbCrLf & _
            "ReverseArrayInPlace can reverse only arrays of simple data types."
        Exit Function
    End If
End If

ReDim NewArr(LBound(InputArray) To UBound(InputArray))
NewN = UBound(NewArr)
For OrigN = LBound(InputArray) To UBound(InputArray)
    NewArr(NewN) = InputArray(OrigN)
    NewN = NewN - 1
Next OrigN

For NewN = LBound(NewArr) To UBound(NewArr)
    InputArray(NewN) = NewArr(NewN)
Next NewN

ReverseArrayInPlace = True
End Function


Public Function ReverseArrayInPlace2(InputArray As Variant, _
    Optional LB As Long = -1, Optional UB As Long = -1, _
    Optional NoAlerts As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ReverseArrayInPlace2
' This reverses the order of elements in InputArray. To reverse the entire array, omit or
' set to less than 0 the LB and UB parameters. To reverse only part of tbe array, set LB and/or
' UB to the LBound and UBound of the sub array to be reversed.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim N As Long
Dim Temp As Variant
Dim Ndx As Long
Dim Ndx2 As Long
Dim OrigN As Long
Dim NewN As Long
Dim NewArr() As Variant

''''''''''''''''''''''''''''''''
' Set the default return value.
''''''''''''''''''''''''''''''''
ReverseArrayInPlace2 = False

'''''''''''''''''''''''''''''''''
' Ensure we have an array
'''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
    If NoAlerts = False Then
        MsgBox "The InputArray parameter is not an array."
    End If
    Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Test the number of dimensions of the
' InputArray. If 0, we have an empty,
' unallocated array. Get out with
' an error message. If greater than
' one, we have a multi-dimensional
' array, which is not allowed. Only
' an allocated 1-dimensional array is
' allowed.
''''''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(InputArray)
    Case 0
        '''''''''''''''''''''''''''''''''''''''''''
        ' Zero dimensions indicates an unallocated
        ' dynamic array.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array is an empty, unallocated array."
        End If
        Exit Function
    Case 1
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
    Case Else
        '''''''''''''''''''''''''''''''''''''''''''
        ' We can reverse ONLY a single dimensional
        ' arrray.
        '''''''''''''''''''''''''''''''''''''''''''
        If NoAlerts = False Then
            MsgBox "The input array multi-dimensional. ReverseArrayInPlace works only " & _
                   "on single-dimensional arrays."
        End If
        Exit Function

End Select

'''''''''''''''''''''''''''''''''''''''''''''
' Ensure that we have only simple data types,
' not an array of objects or arrays.
'''''''''''''''''''''''''''''''''''''''''''''
If IsSimpleDataType(InputArray(LBound(InputArray))) = False Then
    If NoAlerts = False Then
        MsgBox "The input array contains arrays, objects, or other complex data types." & vbCrLf & _
            "ReverseArrayInPlace can reverse only arrays of simple data types."
        Exit Function
    End If
End If

ReDim NewArr(LBound(InputArray) To UBound(InputArray))
NewN = UBound(NewArr)
If LB < 0 Then
    LB = LBound(InputArray)
End If
If UB < 0 Then
    UB = UBound(InputArray)
End If

For OrigN = LBound(InputArray) To UBound(InputArray)
    If OrigN < LB Then
        NewArr(OrigN) = InputArray(OrigN)
    ElseIf OrigN > UB Then
        NewArr(OrigN) = InputArray(OrigN)
    Else
        NewArr(NewN) = InputArray(OrigN)
    End If
    NewN = NewN - 1
Next OrigN

For NewN = LBound(NewArr) To UBound(NewArr)
    InputArray(NewN) = NewArr(NewN)
Next NewN

ReverseArrayInPlace2 = True
End Function



Public Function IsSimpleNumericType(V As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsSimpleNumericType
' This returns TRUE if V is one of the following data types:
'        vbBoolean
'        vbByte
'        vbCurrency
'        vbDate
'        vbDecimal
'        vbDouble
'        vbInteger
'        vbLong
'        vbSingle
'        vbVariant if it contains a numeric value
' It returns FALSE for any other data type, including any array
' or vbEmpty.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If IsSimpleDataType(V) = True Then
    Select Case VarType(V)
        Case vbBoolean, _
                vbByte, _
                vbCurrency, _
                vbDate, _
                vbDecimal, _
                vbDouble, _
                vbInteger, _
                vbLong, _
                vbSingle
            IsSimpleNumericType = True
        Case vbVariant
            If IsNumeric(V) = True Then
                IsSimpleNumericType = True
            Else
                IsSimpleNumericType = False
            End If
        Case Else
            IsSimpleNumericType = False
    End Select
Else
    IsSimpleNumericType = False
End If
End Function

Public Function IsSimpleDataType(V As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsSimpleDataType
' This function returns TRUE if V is one of the following
' variable types (as returned by the VarType function:
'    vbBoolean
'    vbByte
'    vbCurrency
'    vbDate
'    vbDecimal
'    vbDouble
'    vbEmpty
'    vbError
'    vbInteger
'    vbLong
'    vbNull
'    vbSingle
'    vbString
'    vbVariant
'
' It returns FALSE if V is any one of the following variable
' types:
'    vbArray
'    vbDataObject
'    vbObject
'    vbUserDefinedType
'    or if it is an array of any type.

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
On Error Resume Next
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Test if V is an array. We can't just use VarType(V) = vbArray
' because the VarType of an array is vbArray + VarType(type
' of array element). E.g, the VarType of an Array of Longs is
' 8195 = vbArray + vbLong.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If IsArray(V) = True Then
    IsSimpleDataType = False
    Exit Function
End If
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' We must also explicitly check whether V is an object, rather
' relying on VarType(V) to equal vbObject. The reason is that
' if V is an object and that object has a default proprety, VarType
' returns the data type of the default property. For example, if
' V is an Excel.Range object pointing to cell A1, and A1 contains
' 12345, VarType(V) would return vbDouble, the since Value is
' the default property of an Excel.Range object and the default
' numeric type of Value in Excel is Double. Thus, in order to
' prevent this type of behavior with default properties, we test
' IsObject(V) to see if V is an object.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If IsObject(V) = True Then
    IsSimpleDataType = False
    Exit Function
End If
'''''''''''''''''''''''''''''''''''''
' Test the value returned by VarType.
'''''''''''''''''''''''''''''''''''''
Select Case VarType(V)
    Case vbArray, vbDataObject, vbObject, vbUserDefinedType
        '''''''''''''''''''''''
        ' not simple data types
        '''''''''''''''''''''''
        IsSimpleDataType = False
    Case Else
        ''''''''''''''''''''''''''''''''''''
        ' otherwise it is a simple data type
        ''''''''''''''''''''''''''''''''''''
        IsSimpleDataType = True
End Select

End Function

Public Function IsArrayAllocated(arr As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayAllocated
' Returns TRUE if the array is allocated (either a static array or a dynamic array that has been
' sized with Redim) or FALSE if the array has not been allocated (a dynamic that has not yet
' been sized with Redim, or a dynamic array that has been Erased).
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim N As Long

'''''''''''''''''''''''''''''''''''''''''''''''''''
' If Arr is not an array, return FALSE and get out.
'''''''''''''''''''''''''''''''''''''''''''''''''''
If IsArray(arr) = False Then
    IsArrayAllocated = False
    Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Try to get the UBound of the array. If the array has not been allocated,
' an error will occur. Test Err.Number to see if an error occured.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
On Error Resume Next
N = UBound(arr, 1)
If Err.Number = 0 Then
    '''''''''''''''''''''''''''''''''''''
    ' No error. Array has been allocated.
    '''''''''''''''''''''''''''''''''''''
    IsArrayAllocated = True
Else
    '''''''''''''''''''''''''''''''''''''
    ' Error. Unallocated array.
    '''''''''''''''''''''''''''''''''''''
    IsArrayAllocated = False
End If

End Function


Attribute VB_Name = "JYUT_Strings"
'This module has been moved to the JYCORE library.
Attribute VB_Name = "JYUT_SuccessFailureMsgCBObj"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Implements JYUT_ExecutableInterface

Public successMsg As String
Public optCBObj As JYUT_ExecutableInterface

Sub JYUT_ExecutableInterface_execute(data As Variant)
    Dim emsg As String
    emsg = CStr(data)
    
    Dim msgShown As String
    If emsg <> "" Then
        elwp emsg
        msgShown = emsg
    Else
        ilwp successMsg
        msgShown = successMsg
    End If
    
    If Not isNothing(optCBObj) Then
        optCBObj.execute msgShown
    End If
End Sub

Attribute VB_Name = "JYUT_VectBasedTables"

Function getDelimitedFileDataAsTable(strFile As String, delimiter As String, ByRef out_emsg As String) As JYUT_VectorBasedTable

    Dim emsg As String
    emsg = ""

    Dim data As JYUT_VectorBasedTable
    Set data = New JYUT_VectorBasedTable

On Error GoTo ehs

    Open strFile For Input As #1

    While Not EOF(1)
        Dim curLine As String
        Line Input #1, curLine

        Dim tkns As Collection
        Set tkns = gtkns(curLine, delimiter)

        data.addRow tkns

    Wend

GoTo ehe
ehs:
    emsg = "Error while loading '" & strFile & "': " & Err.description
ehe:
On Error GoTo 0

    Close #1

    out_emsg = emsg
    Set getDelimitedFileDataAsTable = data

End Function

Attribute VB_Name = "JYUT_VectorBasedTable"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim rows As Collection

Public valForUndefined As Variant
Private cachedNumCols As Variant

Sub addRow(row As Variant)
    Set cachedNumCols = Nothing
    rows.add getInternalDataStructureToAdd(row)
End Sub

Sub addCol(col As Variant)

    If rows.count > 0 Then
        padCollectionsToMakeThemAllSameSize kta(rows), valForUndefined
    End If
    
    Dim column As Collection
    Set column = convertArrayToCollectionUnlessAlreadyCollection(col)
    
    Dim newNumRows As Long
    newNumRows = wsFunctionMax(column.count, rows.count)
    
    Dim numRowsToAdd As Long
    numRowsToAdd = wsFunctionMax(0, column.count - rows.count)
    
    Dim d As Long
    For d = 1 To numRowsToAdd
        Me.addRow New Collection
    Next
        
    Dim c As Long
    For c = 1 To newNumRows
        Dim curRow As Collection
        Set curRow = rows.item(c)
        
        If c > column.count Then
            curRow.add valForUndefined
        Else
            curRow.add column.item(c)
        End If
    Next
End Sub

Private Function getInternalDataStructureToAdd(row As Variant) As Collection
    Set getInternalDataStructureToAdd = convertArrayToCollectionUnlessAlreadyCollection(row)
End Function

Sub setRow(row As Variant, indx As Long)
    setItemInCollection rows, indx, getInternalDataStructureToAdd(row)
End Sub

Sub addRows(rows As Collection)
    Dim c As Long
    For c = 1 To rows.count
        Dim row As Variant
        atr row, rows.item(c)
        
        Me.addRow row
    Next
End Sub

Function getRow(rowNum As Long) As Collection
    Dim row As Collection
    Set row = copyCollection(rows.item(rowNum))
    
    Dim cols As Long
    cols = Me.numCols()
    
    Dim c As Long
    For c = row.count + 1 To cols
        row.add Me.getValueForUndefined()
    Next
    
    Set getRow = row
End Function

Function getCols() As Variant
    
    Dim numCols As Long
    numCols = Me.numCols
    
    Dim cols As Variant
    ReDim cols(1 To numCols)
    
    Dim c As Long
    For c = 1 To numCols
        Set cols(c) = Me.getCol(c)
    Next

    getCols = cols
End Function

Function getCol(colNum As Long) As Collection
    Dim col As Collection
    Set col = New Collection
    
    Dim r As Long
    For r = 1 To Me.numRows()
        Dim curRow As Collection
        Set curRow = rows.item(r)
        
        Dim curVal As Variant
        If colNum > curRow.count Then
            curVal = Me.getValueForUndefined()
        Else
            atr curVal, curRow.item(colNum)
        End If
        
        col.add curVal
    Next
    
    Set getCol = col
End Function

Sub setValueAt(row As Long, col As Long, val As Variant)
    
    Dim lastRow As Long
    lastRow = Me.numRows()
    
    Dim r As Long
    For r = lastRow + 1 To row
        Dim newRow As Collection
        Set newRow = New Collection
        
        rows.add newRow
    Next
    
    'At this point, we know we have enough collection objects to reach our row
    
    Dim rowWeWant As Collection
    Set rowWeWant = rows.item(row)
    
    Dim valForUndefined As Variant
    atr valForUndefined, Me.getValueForUndefined()
    
    Dim c As Long
    For c = rowWeWant.count + 1 To col
        rowWeWant.add valForUndefined
    Next
    
    'At this point, we know that the cell we want exists
    
    setItemInCollection rowWeWant, col, val
    
End Sub

Function numRows() As Long
    numRows = rows.count
End Function

Function numCols() As Long
    
    If isNothing(cachedNumCols) Then
    
        Dim maxCols As Long
        maxCols = 0
        
        Dim c As Long
        For c = 1 To rows.count
            
            Dim numColsHere As Long
            numColsHere = rows.item(c).count
            
            maxCols = wsFunctionMax(numColsHere, maxCols)
            
        Next
        cachedNumCols = maxCols
        numCols = maxCols
    Else
        numCols = cachedNumCols
    End If
End Function

Function getValueAt(rowNum As Long, colNum As Long) As Variant

    Dim numberOfCols As Long
    numberOfCols = Me.numCols()

    atr getValueAt, getValueAt_alreadyKnowNumColsInTable(rowNum, colNum, numberOfCols)
    
End Function

Function getValueAt_alreadyKnowNumColsInTable(rowNum As Long, colNum As Long, numberOfCols As Long) As Variant
    
    If rowNum < 1 Or colNum < 1 Then
        elwp "Please pass in valid row and column numbers!"
        Set getValueAt_alreadyKnowNumColsInTable = Nothing
    ElseIf rowNum > numRows() Then
        elwp "We don't have that many rows!"
        Set getValueAt_alreadyKnowNumColsInTable = Nothing
    ElseIf colNum > numberOfCols Then
        elwp "We don't have that many columns!"
        Set getValueAt_alreadyKnowNumColsInTable = Nothing
    Else
        Dim row As Collection
        Set row = rows.item(rowNum)
        
        If colNum > row.count Then
            Set getValueAt_alreadyKnowNumColsInTable = Me.getValueForUndefined()
        Else
            atr getValueAt_alreadyKnowNumColsInTable, row.item(colNum)
        End If
    End If
    
End Function

Function getValueForUndefined() As Variant
    atr getValueForUndefined, valForUndefined
End Function

Function maxLengthInCol(colNum As Long) As Long
    
    Dim maxSoFar As Long
    maxSoFar = 0
    
    Dim daNumRows As Long
    daNumRows = numRows()
    
    Dim r As Long
    For r = 1 To daNumRows
    
        ssbm "Calculating max length in column.  Looking at row #" & r & " of " & daNumRows & "..."
    
        Dim colValue As Variant
        atr colValue, getValueAt(r, colNum)
        
        If isNothing(colValue) Then
            colValue = ""
        Else
            colValue = CStr(colValue)
        End If
        
        maxSoFar = wsFunctionMax(maxSoFar, Len(colValue))
    Next
    
    ssbm "Done calculating the maximum length!"
    
    maxLengthInCol = maxSoFar
        
End Function

Function toArray() As Variant
    
    Dim numRows As Long
    Dim numCols As Long
    numRows = Me.numRows()
    numCols = Me.numCols()
    
    If numRows = 0 Or numCols = 0 Then
        'This implies that the user added blank rows or blank columns.
        Set toArray = Nothing
    Else
        
        Dim arr As Variant
        ReDim arr(1 To numRows, 1 To numCols)
        
        Dim r As Long
        For r = 1 To numRows
            
            Dim row As Collection
            Set row = rows.item(r)
            
            Dim c As Long
            For c = 1 To numCols
                
                
                Dim theVal As Variant
                If c > row.count Then
                    theVal = Empty
                Else
                    theVal = row.item(c)
                End If
            
                arr(r, c) = theVal
            
            Next
            
        Next
                
        toArray = arr
    End If
End Function

Function toFixedWidthTextLines(columnDelimiter As String) As Variant
    Dim nmRows As Long
    nmRows = Me.numRows()

    Dim lines As Variant
    ReDim lines(1 To nmRows)
    
    
    Dim d As Long
    For d = 1 To nmRows
        lines(d) = ""
    Next
    
    Dim firstIndex As Long
    firstIndex = 1
    
    Dim numCols As Long
    numCols = Me.numCols()
    
    Dim c As Long
    For c = firstIndex To numCols
        
        Dim maxLength As Long
        maxLength = maxLengthInCol(c)
        
        Dim r As Long
        For r = 1 To nmRows
        
            ssbm "Converting (" & c & " of " & numCols & ", " & r & " of " & nmRows & ") to fixed width..."
        
            Dim curValue As Variant
            curValue = nothingToBlankString(getValueAt(r, c))
            
            curValue = padRight(CStr(curValue), maxLength, " ")
            
            If c > firstIndex Then
                lines(r) = lines(r) + columnDelimiter
            End If
            lines(r) = lines(r) & curValue
            
        Next
        
    Next
    
    ssbm "Done converting to fixed width!"
    toFixedWidthTextLines = lines
End Function
Function toFixedWidthText(columnDelimiter As String) As String
    toFixedWidthText = arrToString(toFixedWidthTextLines(columnDelimiter), CHAR_CRLF)
End Function

Private Sub Class_Initialize()
    Set valForUndefined = Nothing
    Set rows = New Collection
    Set cachedNumCols = Nothing
End Sub
Attribute VB_Name = "JYUT_WebPages"
Option Explicit

Public Const MAX_LENGTH_THAT_EXCEL_SEEMS_TO_ACCEPT_FOR_PATH_WHEN_OPENING_A_WEBSITE As Long = 255

Function constructHTTPAddress(serverName As String, portNum As String) As String
    constructHTTPAddress = appendToPath_customSeparator("http://" & serverName & ":" & portNum, "", WEB_PATH_SEPARATOR)
End Function

Function addEscapeCharactersToWebQuery(webString As String) As String

    Dim listOf__regularCharacter_escCode As Collection
    Set listOf__regularCharacter_escCode = New Collection
    With listOf__regularCharacter_escCode
        .add Array(" ", "%20")
        .add Array("!", "%21")
        .add Array("#", "%23")
        .add Array("$", "%24")
        .add Array("&", "%26")
        .add Array("'", "%27")
        .add Array("(", "%28")
        .add Array(")", "%29")
        .add Array("*", "%2A")
        .add Array("+", "%2B")
        .add Array(",", "%2C")
        .add Array("/", "%2F")
        .add Array(":", "%3A")
        .add Array(";", "%3B")
        .add Array("=", "%3D")
        .add Array("?", "%3F")
        .add Array("@", "%40")
        .add Array("[", "%5B")
        .add Array("]", "%5D")
    End With
    
    Dim stringSoFar As String
    stringSoFar = webString

    Dim c As Long
    For c = 1 To listOf__regularCharacter_escCode.count
        Dim regularChar_escCode As Variant
        regularChar_escCode = listOf__regularCharacter_escCode.item(c)
        
        Dim regChar As String
        Dim escCode As String
        regChar = rlai(regularChar_escCode, 1)
        escCode = rlai(regularChar_escCode, 2)
        
        stringSoFar = replaceInString(stringSoFar, regChar, escCode, False)
    Next
    addEscapeCharactersToWebQuery = stringSoFar
    
End Function

Function lengthOfWebsitePathIsAcceptableForExcelToOpen(filePath As String) As Boolean
    lengthOfWebsitePathIsAcceptableForExcelToOpen = (Len(filePath) <= MAX_LENGTH_THAT_EXCEL_SEEMS_TO_ACCEPT_FOR_PATH_WHEN_OPENING_A_WEBSITE)
End Function

Attribute VB_Name = "JYUT_WindowsFunctions"
Option Explicit

Declare Function GetCommandLine Lib "kernel32" Alias "GetCommandLineW" () As Long
Declare Function lstrlenW Lib "kernel32" (ByVal lpString As Long) As Long
Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (MyDest As Any, MySource As Any, ByVal MySize As Long)


Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Declare Function WNetGetUser Lib "mpr.dll" Alias "WNetGetUserA" (ByVal lpName As String, ByVal lpUserName As String, lpnLength As Long) As Long
Declare Function GetTempPath _
Lib "kernel32" Alias "GetTempPathA" _
(ByVal nBufferLength As Long, _
ByVal lpBuffer As String) As Long
 
Const NoError = 0       'The Function call was successful

Declare Function URLDownloadToFile Lib "urlmon" Alias _
    "URLDownloadToFileA" (ByVal pCaller As Long, _
    ByVal szURL As String, _
    ByVal szFileName As String, _
    ByVal dwReserved As Long, _
    ByVal lpfnCB As Long) As Long

'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
'This code is based on code taken from the NAV report
'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Function getCommandLineString() As String


    Dim CmdRaw As Long
    CmdRaw = GetCommandLine

    Dim Buffer() As Byte
    Dim StrLen As Long
   
   If CmdRaw Then
      StrLen = lstrlenW(CmdRaw) * 2
      If StrLen Then
         ReDim Buffer(0 To (StrLen - 1)) As Byte
         CopyMemory Buffer(0), ByVal CmdRaw, StrLen
         getCommandLineString = Buffer
      End If
   End If

End Function


Function CmdToSTr(cmd As Long) As String
End Function


'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
'This code is based off of: http://social.msdn.microsoft.com/Forums/eu/isvvba/thread/beb6fa0e-fbc8-49df-9f2e-30f85d941fad
'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Function DownloadFile(URL As String, LocalFileName As String) As Boolean
    
    '"http://nyfikdbprd10:9024/q.csv?getTbaLast[30;`01F022626`01F042624`01F062622`01N040629`01N060627`02R040623`02R060621`21H040624`21H060622`01N040421`01N060429`01F032427`01F052425`02R032422`02R052420]"
    Dim lngRetVal      As Long
    lngRetVal = URLDownloadToFile(0, URL, LocalFileName, 0, 0)
    If lngRetVal = 0 Then DownloadFile = True
    
End Function




'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
'This code is based off of: http://www.vbaexpress.com/kb/getarticle.php?kb_id=1121
'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Public Function getWindowsTemporaryPath() As String
    Dim PathLen As Long
    Dim WinTempDir As String
    Dim BufferLength As Long
    BufferLength = 260
    WinTempDir = Space(BufferLength)
    PathLen = GetTempPath(BufferLength, WinTempDir)
    If Not PathLen = 0 Then
        getWindowsTemporaryPath = left(WinTempDir, PathLen)
    Else
        getWindowsTemporaryPath = CurDir()
    End If
End Function

 
'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
'This code is based off of: http://support.microsoft.com/kb/161394
'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Function GetUserNameViaWindowsFunction() As String

On Error GoTo ehs

   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      ' An error occurred.
      lpUserName = "UNKNOWN"
   End If

GoTo ehe
ehs:
    Dim emsg As String
    emsg = "Unable to obtain the username of the person who is currently using this spreadsheet.  Msg=" & Err.description
    elwp emsg
    lpUserName = emsg
ehe:
On Error GoTo 0
   
   GetUserNameViaWindowsFunction = lpUserName


End Function

'========================================================================================



Attribute VB_Name = "Module1"
Option Explicit

Function decsToTicks(theNum As Variant) As Variant
    decsToTicks = convertDecimalsToTicks(theNum, True, False)
End Function

Sub CreateOfferingSheet()

    Dim wk As Workbook
    Dim wkDir As String
    
    wkDir = ThisWorkbook.path
    
    Application.DisplayAlerts = False
    Set wk = Workbooks.add
    
    Dim dateStr As String
    Dim Td As Date
    Td = Date
    dateStr = Format(Td, "mmddyyyy")
    
    Dim FlName As String
    FlName = wkDir & "\" & "Nomura_Floaters_Offering" & dateStr & ".xls" 'remove _test
    
    wk.SaveAs fileName:=FlName, fileFormat:=56

    Do While (ActiveWorkbook.Sheets.count > 1)
        ActiveWorkbook.ActiveSheet.Delete
    Loop
        
    ActiveWorkbook.ActiveSheet.name = "CMO-FLTs"
    
    ActiveWindow.ActivateNext
    
    Dim r As Integer
    r = 8
    Do While StrComp(left(cells(r, 3), 4), "DISC") <> 0
        r = r + 1
    Loop

    Range("B1:U" & Application.WorksheetFunction.text(r, "#0")).SpecialCells(xlCellTypeVisible).Select
    Selection.Copy
    ActiveWindow.ActivatePrevious
    Range("A1").Select
    ActiveSheet.Paste
    Selection.PasteSpecial Paste:=xlPasteValues, operation:=xlNone, _
        skipblanks:=False, Transpose:=False

    ActiveWindow.Zoom = 70
    Range("A9").Select
    
    ActiveWindow.ActivateNext
    Columns("B:U").Select
    Selection.Copy
    ActiveWindow.ActivatePrevious
    Columns("A:T").Select
    Selection.PasteSpecial Paste:=xlPasteColumnWidths, operation:=xlNone, _
        skipblanks:=False, Transpose:=False
    Range("A9").Select
    
    ActiveWindow.ActivateNext
    Range("A9").Select
    
    wk.Save
    wk.Close

    Application.DisplayAlerts = True
    
    Generate_Email (FlName)
    
End Sub


Function Generate_Email(FlName As String)

    Dim CMO As Worksheet
    Dim t As Worksheet
        
    Dim r As Integer
    Dim r_new As Integer
    Dim Orig_Face As Double
    Dim Spread As Double
    Dim Cap As Double
    Dim CapStr As String
    Dim Collateral As Variant
    Dim TrancheType As String
    
    Dim i As Integer
    Dim j As Integer
    
    Dim Emailb As String
    Dim Pad As String
    Dim Spaces As String
    Spaces = "                                                                                             "

    worksheets.add().name = "Temp"
    
    Set CMO = Sheets("CMO")
    Set t = Sheets("Temp")

    r = 8
    r_new = 1
    
    Dim ct As Variant
    ct = CMO.cells(r, 3)
    
    Do While StrComp(ct, "2/10 Swap") <> 0
        
        If StrComp(ct, "Bond") = 0 Then
            'skip new issue
'            If StrComp(CMO.Cells(r, 2), "NEW ISSUE") = 0 Then
'                r = r + 1
'                Do While StrComp(CMO.Cells(r, 3), "Bond") <> 0
'                    r = r + 1
'                Loop
'            End If
            
            r_new = r_new + 1
            t.cells(r_new, 2) = CMO.cells(r, 2)
            
            Emailb = Emailb & vbCr & t.cells(r_new, 2) & ":" & vbCr
            
        Else
            t.cells(r_new, 2) = CMO.cells(r, 2)
            Orig_Face = CMO.cells(r, 4) / 1000000
            If Round(Orig_Face, 0) = Orig_Face Then
                t.cells(r_new, 3) = Application.WorksheetFunction.text(Application.WorksheetFunction.Floor(Orig_Face, 1), "#0") & " mm"
            Else
                t.cells(r_new, 3) = Application.WorksheetFunction.text(Application.WorksheetFunction.Floor(Orig_Face, 1), "#0") & "+mm"
            End If
            t.cells(r_new, 4) = ct
            
            Spread = CMO.cells(r, 8) * 100
            Cap = CMO.cells(r, 7)
            CapStr = "#0"
            i = 0
            Do While Round(Cap, 0) <> Cap
                
                If i = 0 Then CapStr = CapStr & "."
                CapStr = CapStr & "0"
                Cap = Cap * 10
                i = i + 1
                
            Loop
            
            t.cells(r_new, 5) = "L+" & Application.WorksheetFunction.text(Spread, "#0") & "/" & _
                    Application.WorksheetFunction.text(Cap / 10 ^ i, CapStr) & " CAP"
            
            
            t.cells(r_new, 6) = CMO.cells(r, 26)
            t.cells(r_new, 7) = CMO.cells(r, 19)
            
            'r 2 max 9
            If Len(t.cells(r_new, 2)) > 6 Then MsgBox "Warning Increase Max Length Col 2"
            Emailb = Emailb & left(Spaces, 1) & t.cells(r_new, 2) & left(Spaces, 6 - Len(t.cells(r_new, 2)))
            'r 3 max 10
            If Len(t.cells(r_new, 3)) >= 7 Then MsgBox "Warning Increase Max Length Col 3"
            Emailb = Emailb & left(Spaces, 7 - Len(t.cells(r_new, 3))) & t.cells(r_new, 3) & left(Spaces, 2)
            'r 4 max 20
            If Len(t.cells(r_new, 4)) >= 16 Then MsgBox "Warning Increase Max Length Col 4"
            Emailb = Emailb & t.cells(r_new, 4) & left(Spaces, 16 - Len(t.cells(r_new, 4)))
            'r 5 max 20
            If Len(t.cells(r_new, 5)) >= 16 Then MsgBox "Warning Increase Max Length Col 5"
            Emailb = Emailb & t.cells(r_new, 5) & left(Spaces, 16 - Len(t.cells(r_new, 5)))
            'r 6 max 20
            If Len(t.cells(r_new, 6)) >= 16 Then MsgBox "Warning Increase Max Length Col 6"
            Emailb = Emailb & t.cells(r_new, 6) & left(Spaces, 16 - Len(t.cells(r_new, 6)))
            'r 7 max 10
            If Len(t.cells(r_new, 7)) >= 9 Then MsgBox "Warning Increase Max Length Col 7"
            Emailb = Emailb & left(Spaces, 9 - Len(t.cells(r_new, 7))) & t.cells(r_new, 7)
            Emailb = Emailb & vbCr
    
        End If
        
        r = r + 1
        r_new = r_new + 1
        ct = Sheets("CMO").cells(r, 3)
        
    Loop
    
    t.Columns("C:G").Select
    t.Columns("C:G").EntireColumn.AutoFit
    
    r_new = r_new + 1
    t.cells(r_new, 2) = CMO.cells(r, 5) & " " & CMO.cells(r, 3) & " " & CMO.cells(r, 4) & vbCr
    Emailb = Emailb & vbCr & t.cells(r_new, 2) & vbCr
    
    Mail_Range Emailb, FlName
    
    Application.DisplayAlerts = False
    Sheets("Temp").Delete
    Application.DisplayAlerts = True
    
End Function


Function Mail_Range(Emailb As String, AttachFile As String)

    Dim oLookApp As Outlook.Application
    Dim tMail As Outlook.MailItem
    
    'Set oLookApp = Nothing
    'Set tMail = Nothing
    
    Set oLookApp = New Outlook.Application
    Set tMail = oLookApp.CreateItem(olMailItem)
    
    Dim dateStr As String
    Dim Td As Date
    Td = Date
    dateStr = Format(Td, "mm/dd")
    
    Dim Source As Range
    Set Source = Sheets("Temp").Range("B2:G19") '.SpecialCells(xlCellTypeVisible)
    
    With tMail
        '.To = "siddharth.joshi1@nomura.com; joseph.sikoscow@nomura.com"
        .To = "jsikoscow3@bloomberg.net; sjoshi57@bloomberg.net"
        .subject = "Nomura Agency Floater Offers " & dateStr
        .BodyFormat = olFormatPlain
        .Body = Emailb
        .Attachments.add AttachFile
        '.Display
        .Send
    End With

    Set oLookApp = Nothing
    Set tMail = Nothing

End Function









Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub btn_Generator_Click()
    Call CreateOfferingSheet
End Sub
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


' InQuest injected base64 decoded content
' ,"{h
' w+zg
' Vz(!
' ^"wq
' ~)e"s
'  ejy
' [Uj[
' ,xZ+
' jZai
' .+-9
' pejy
' N|*%
' jYUj[
' ^t*%
' WQzf
' &.+-9
' &.+-9
' &.+-9
' .+-9
' N|*%
' +bjX
' ~)eFx
' ~)eFx
' N|	e
' y:)F
' *'Ry^
' z+az
' { +x
' (^rAh
' y*^r'
' zk >
' )^"{hJ
' l"p%
' 1jjeyPN(&
' "{hI
' &z{l6
' -"w^
' -"wq9
' *^uJXz
' WVk%^
' *'jT.
' !/zsn
' %y+k
' 'rZ,
' Z)e6
' -"wq9
' 'rZ,
' k ,J
' mJ'^9
' mJ'^
' pejy
' 'u(b~
' ZZ+a
' N|)^j
' 0.+-
' Vz(!
' xZ+Y
' *'.)
' bzWH|
' n1bzWMjg
' n1bzWMjg
' wN}j
' Z+aX
' ,x	mz
' 0"{hJ
' aj~t=
' BzYE
' BzY@
' /x(Z
' N+ey
' *'jP+
' *'jP+
' *'jP+
' YRjg
' x%x8
' j'J,
' jYNn7
' p+y8^I
' z{l"p
' z{l"p
' -zb'
' z{az
' q%zg
' [Uj[
' *ex*%
' *'jP
' BzYH
' *^r'
' BzYH
' BzY@
' pejy
' '.+-9
' Ck 'u
' Ck"'2
' Ck"'2
' Ck"'2
' ']zuZ
' zpky
' { 'uV
' xZ+5
' "wqU
' bzWA
' v'-9
' :-jR
' jYUj[
' v'-Z
' '.+-N
' Z+.+-9
' z{J{ r:
' WAx8
' Czz&
' *'v+b
' *'jQh
' zYl"{h
' k ^~
' "p,q
' O*^J
' z{Cy
' z{Aj
' 'N'$
' &J,my
' N'$>
' ,xZ+
' *':t
' *'~(
' YAx	
' Vj{S
' *'~(
' x	e)
' Z+:w
' z{lN
' *ey*+
' [Uj[
' Bjp^
' z{^t
' rY ^~
' L\zU
' -xZ+
' BzYA
' bzWMjg
' u:-jP
' "{hI
' .+-:
' "{hI
' "{hI
' bzWMjg
' bzWMjg
' Z+aJ
' WAyj
' Z"{hE
' bzWMjg
' !bzWMjg
' bzWMjg
' VHZ+`
' {",=
' ny8Z
' zh,!
' "{-y
' "uhb
' *'jQb
' bzWQ4	
' p'u(
' Z"{h.+-9
' Z+aJ)
' M'+y
' [Uj[
' ek!h
' zYUj[
' P'uK
' k#bq
' Bjp^
' "{hN
' *'Z+a
' "{-y
' "zWB
' 'u*^y
' ^u*ky
' "zWB
' O*^M
' 'u*^y
' 'u*^y
' y*ky
' y*ky
' y<("
' z{^t
' ny+k
' bzWMjg
' BzYlN
' zYH|:"
' +xLiy
' s'%y8k
' JZ0Y
' jwbu
' $"uZ
' -xZ+
' Z"{hN
' BzYN}
' ^2(!
' mJ'^
' mJ'^
' bzWl

INQUEST-PP=macro
