Attribute VB_Name = "DialogWindows"
Option Explicit

'************************************************************************************************************************************************************
'BROWSE FOR FOLDER DIALOG WINDOW
'************************************************************************************************************************************************************
Const BIF_RETURNONLYFSDIRS = 1
Const MAX_PATH = 260
Private Declare Sub CoTaskMemFree Lib "ole32.dll" (ByVal hMem As Long)
Private Declare Function lstrcat Lib "kernel32" Alias "lstrcatA" (ByVal lpString1 As String, ByVal lpString2 As String) As Long
Private Declare Function SHBrowseForFolder Lib "shell32" (lpbi As BrowseInfo) As Long
Private Type BrowseInfo
    hWndOwner As Long
    pIDLRoot As Long
    pszDisplayName As Long
    lpszTitle As Long
    ulFlags As Long
    lpfnCallback As Long
    lParam As Long
    iImage As Long
End Type
Private Declare Function SHGetPathFromIDList Lib "shell32" (ByVal pidList As Long, ByVal lpBuffer As String) As Long

'************************************************************************************************************************************************************
'OPEN FILE DIALOG WINDOW
'************************************************************************************************************************************************************
Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Type OPENFILENAME
    lStructSize As Long
    hWndOwner As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    FLAGS As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type
    
    
    
    
    
    
    
'************************************************************************************************************************************************************
'OPEN FILE DIALOG WINDOW CALLING FUNCTIONS
'************************************************************************************************************************************************************
Public Function ShowOpen(filter As String, initialDir As String, dialogTitle As String) As String
    Dim OFName As OPENFILENAME
    OFName.lStructSize = Len(OFName)        'Set the structure size
    OFName.hWndOwner = 0                    'Set the owner window
    OFName.lpstrFilter = filter             'Set the filter
    OFName.nMaxFile = 255                   'Set the maximum number of chars
    OFName.lpstrFile = Space(254)           'Create a buffer
    OFName.lpstrFileTitle = Space$(254)     'Create a buffer
    OFName.nMaxFileTitle = 255              'Set the maximum number of chars
    OFName.lpstrInitialDir = initialDir     'Set the initial directory
    OFName.lpstrTitle = dialogTitle         'Set the dialog title
    OFName.FLAGS = 0                        'no extra flags
    If GetOpenFileName(OFName) Then         'Show the 'Open File' dialog
        ShowOpen = Trim(OFName.lpstrFile)
    Else
        ShowOpen = ""
    End If
End Function

Public Function AutoCADFilePickerIES(ByRef oFileName)
    Dim filter As String
    Dim initialDir As String
    Dim dialogTitle As String
    'Dim outputStr As String
    'filter = "Drawing Files (*.dwg)" + Chr$(0) + "*.dwg" + Chr$(0) + "All Files (*.*)" + Chr$(0) + "*.*" + Chr$(0)
    filter = "IES Files (*.ies)" + Chr$(0) + "*.ies" + Chr$(0) + "All Files (*.*)" + Chr$(0) + "*.*" + Chr$(0)
    'initialDir = "C:\a"
    initialDir = CurDir()
    dialogTitle = "Open an IES file"
    'outputStr = ShowOpen(filter, initialDir, dialogTitle)
    oFileName = ShowOpen(filter, initialDir, dialogTitle)
    'MsgBox outputStr
End Function





'************************************************************************************************************************************************************
'BROWSE FOR FOLDER DIALOG WINDOW CALLING FUNCTION
'************************************************************************************************************************************************************
Public Function BrowseForFolder() As String
'Private Sub Form_Load()
    'KPD-Team 1998
    'URL: http://www.allapi.net/
    'KPDTeam@Allapi.net
    Dim iNull As Integer, lpIDList As Long, lResult As Long
    Dim sPath As String, udtBI As BrowseInfo
'    With udtBI
'        'Set the owner window
'        .hWndOwner = Me.hWnd
'        'lstrcat appends the two strings and returns the memory address
'        .lpszTitle = lstrcat("C:\", "")
'        'Return only if the user selected a directory
'        .ulFlags = BIF_RETURNONLYFSDIRS
'    End With
    'Show the 'Browse for folder' dialog
    lpIDList = SHBrowseForFolder(udtBI)
    If lpIDList Then
        sPath = String$(MAX_PATH, 0)
        'Get the path from the IDList
        SHGetPathFromIDList lpIDList, sPath
        'free the block of memory
        CoTaskMemFree lpIDList
        iNull = InStr(sPath, vbNullChar)
        If iNull Then
            sPath = Left$(sPath, iNull - 1)
        End If
    End If

    'MsgBox sPath
    BrowseForFolder = sPath
'End Sub
End Function




























'************************************************************************************************************************************************************
'OTHER PROGRAMMED BY ADAM
'************************************************************************************************************************************************************

Public Function FolderPicker(ByRef directory)
    'DECLARE A VARIABLE AS A FILEDIALOG OBJECT
    'Debug.Print CurDir
    Dim fd As FileDialog
    
    'CREATE A FILEDIALOG OBJECT AS A FOLDER PICKER DIALOG BOX
    Set fd = Application.FileDialog(msoFileDialogFolderPicker)
    
    'Declare a variable to contain the path of selected item
    'even though the path is a string the variable must be a variant
    'because for each...next routines only work with variants and objects.
    Dim selectedItem As Variant
    Debug.Print "FolderPicker: " & CurDir
    Debug.Print "---------------"
    fd.InitialFileName = CurDir
    fd.Show
    fd.AllowMultiSelect = False
    If fd.SelectedItems.count > 0 Then
        selectedItem = fd.SelectedItems(1)
        directory = selectedItem
    Else
        directory = ""
    End If
    Set fd = Nothing
    
End Function


Public Function FilePickerIES(ByRef oFileName)
    'This function uses the file selection dialogue to select an IES file, and returns
    'the filename
    'INPUT:     [nothing]
    'OUTPUT:    openFileName    filename with the directory attached
    
    Dim gotName As Boolean                      'true when the file exists
    Dim fso As Scripting.FileSystemObject       'file system variable
    Set fso = New Scripting.FileSystemObject    'create the file system object
    
    gotName = False
    Do
        oFileName = Application.GetOpenFileName("Photometric Files (*.ies), *.ies", 1, "IES File Selection Dialog")     'show the open file dialog and pass the selected file name to the string variable "oFileName"
        If oFileName = "False" Then
            Exit Function
        ElseIf fso.FileExists(oFileName) Then
            gotName = True
        Else
            MsgBox "This file doesn't exist and cannot be opened.", vbOKOnly
        End If
    Loop While (gotName = False)
    
End Function

Public Function FilePickerIES2(ByRef fileName As Variant) As Boolean
    'This function uses the file selection dialogue to select an IES file, and returns
    'the filename
    '
    'INPUT:     [nothing]
    'OUTPUT:    fileName(n) as Variant          'Array of filenames with the directory attached.
    '           FilePickerIES2 as Boolean       'True if files were selected, False if no files were selected.
    '
    Dim fso As Scripting.FileSystemObject       'file system variable
    Set fso = New Scripting.FileSystemObject    'create the file system object
    
    'OPEN FILE DIALOG
    fileName = Application.GetOpenFileName("Photometric Files (*.ies), *.ies", 1, "IES File Selection Dialog", "Button", True)
    
    'CHECK IF SUCCEEDED AND GOT FILENAMES
    If VarType(fileName) = vbBoolean Then
        'NO FILES SELECTED
        If fileName = False Then
            FilePickerIES2 = False
        End If
    Else
        'SUCCESSFUL
        FilePickerIES2 = True
    End If
End Function

Public Function FilePickerOWL2(ByRef fileName As Variant) As Boolean
    'This function uses the file selection dialogue to select an OWL file, and returns
    'the filename
    '
    'INPUT:     [nothing]
    'OUTPUT:    fileName(n) as Variant          'Array of filenames with the directory attached.
    '           FilePickerOWL2 as Boolean       'True if files were selected, False if no files were selected.
    '
    Dim fso As Scripting.FileSystemObject       'file system variable
    Set fso = New Scripting.FileSystemObject    'create the file system object
    
    'OPEN FILE DIALOG
    fileName = Application.GetOpenFileName("Photometric Files (*.owl), *.OWL", 1, "OWL File Selection Dialog", "Button", True)
    
    'CHECK IF SUCCEEDED AND GOT FILENAMES
    If VarType(fileName) = vbBoolean Then
        'NO FILES SELECTED
        If fileName = False Then
            FilePickerOWL2 = False
        End If
    Else
        'SUCCESSFUL
        FilePickerOWL2 = True
    End If
End Function

Public Function FilePickerIES2Single(ByRef fileName As Variant) As Boolean
    'This function uses the file selection dialogue to select an IES file, and returns
    'the filename
    '
    'INPUT:     [nothing]
    'OUTPUT:    fileName(n) as Variant          'Array of filenames with the directory attached.
    '           FilePickerIES2 as Boolean       'True if files were selected, False if no files were selected.
    '
    Dim fso As Scripting.FileSystemObject       'file system variable
    Set fso = New Scripting.FileSystemObject    'create the file system object
    
    'OPEN FILE DIALOG
    fileName = Application.GetOpenFileName("Photometric Files (*.ies), *.ies", 1, "IES File Selection Dialog", "Button", False)
    
    'CHECK IF SUCCEEDED AND GOT FILENAMES
    If VarType(fileName) = vbBoolean Then
        'NO FILES SELECTED
        If fileName = False Then
            FilePickerIES2Single = False
        End If
    Else
        'SUCCESSFUL
        FilePickerIES2Single = True
    End If
End Function

Public Function FilePickerTXT(ByRef oFileName)
    'This function uses the file selection dialogue to select an TXT file, and returns
    'the filename
    'INPUT:     [nothing]
    'OUTPUT:    openFileName    filename with the directory attached
    
    Dim gotName As Boolean                      'true when the file exists
    Dim fso As Scripting.FileSystemObject       'file system variable
    Set fso = New Scripting.FileSystemObject    'create the file system object
    
    gotName = False
    Do
        oFileName = Application.GetOpenFileName("Text Files (*.txt), *.txt", 1, "Text File Selection Dialog")     'show the open file dialog and pass the selected file name to the string variable "oFileName"
        If oFileName = "False" Then
            Exit Function
        ElseIf fso.FileExists(oFileName) Then
            gotName = True
        Else
            MsgBox "This file doesn't exist and cannot be opened.", vbOKOnly
        End If
    Loop While (gotName = False)
    
End Function

Public Function FilePickerALL(ByRef oFileName)
    'This function uses the file selection dialogue to select a file, and returns
    'the filename
    'INPUT:     [nothing]
    'OUTPUT:    openFileName    filename with the directory attached
    
    Dim gotName As Boolean                      'true when the file exists
    Dim fso As Scripting.FileSystemObject       'file system variable
    Set fso = New Scripting.FileSystemObject    'create the file system object
    
    gotName = False
    Do
        oFileName = Application.GetOpenFileName("All Files (*.*), *.*", 1, "File Selection Dialog")     'show the open file dialog and pass the selected file name to the string variable "openFileName"
        If oFileName = "False" Then
            Exit Function
        ElseIf fso.FileExists(oFileName) Then
            gotName = True
        Else
            MsgBox "This file doesn't exist and cannot be opened.", vbOKOnly
        End If
    Loop While (gotName = False)
    
End Function

Public Function FilePickerBmpJpg(ByRef oFileName)
    'This function uses the file selection dialogue to select a file, and returns
    'the filename - only used for BMP AND JPB FILES
    'INPUT:     [nothing]
    'OUTPUT:    openFileName    filename with the directory attached
    
    Dim gotName As Boolean                      'true when the file exists
    Dim fso As Scripting.FileSystemObject       'file system variable
    Set fso = New Scripting.FileSystemObject    'create the file system object
    
    gotName = False
    Do
        oFileName = Application.GetOpenFileName("Bitmaps (*.bmp),*.bmp,JPGs (*.jpg),*.jpg", 2, "File Selection Dialog")     'show the open file dialog and pass the selected file name to the string variable "openFileName"
        If oFileName = "False" Then
            Exit Function
        ElseIf fso.FileExists(oFileName) Then
            gotName = True
        Else
            MsgBox "This file doesn't exist and cannot be opened.", vbOKOnly
        End If
    Loop While (gotName = False)
    
End Function

Public Function FilePickerSaveAsIES(ByRef saveAsFileName, ByRef boolSucceed)
    'This function uses the file selection dialogue to select an IES file, and returns
    'the filename
    'INPUT:     [nothing]
    'OUTPUT:    saveAsFileName    filename with the directory attached
    
    Dim overwrite As Integer                    'Answer to the message box about overwriteing the existing file.
    Dim gotName As Boolean                      'true when the file exists.
    Dim fso As Scripting.FileSystemObject       'file system variable.
    Set fso = New Scripting.FileSystemObject    'create the file system object.
    
    boolSucceed = True
    
    'SHOW THE SAVE AS FILE DIALOG AND PASS THE SELECTED FILE NAME TO THE STRING VARIABLE: "saveAsFileName"
    saveAsFileName = Application.GetSaveAsFilename("Filename.ies", "Photometric Files (*.ies), *.ies", 1, "IES File Selection Dialog")
    If saveAsFileName = "False" Then
        Exit Function
    ElseIf fso.FileExists(saveAsFileName) Then
        overwrite = MsgBox("Overwrite Existing File ?" & Chr(13) & Chr(13) & "Filename: " & fso.GetBaseName(saveAsFileName), vbYesNoCancel, "Overwrite Existing File?")
        Select Case overwrite
            Case vbYes
                boolSucceed = True
            Case vbNo
                boolSucceed = False
            Case vbCancel
                boolSucceed = False
        End Select
    Else
        'THIS IS A NEW FILENAME
    End If
    
End Function

Public Function FilePickerSaveAsTXT(ByRef saveAsFileName, ByRef boolSucceed)
    'This function uses the file selection dialogue to select an IES file, and returns
    'the filename
    'INPUT:     [nothing]
    'OUTPUT:    saveAsFileName    filename with the directory attached
    
    Dim overwrite As Integer                    'Answer to the message box about overwriteing the existing file.
    Dim gotName As Boolean                      'true when the file exists.
    Dim fso As Scripting.FileSystemObject       'file system variable.
    Set fso = New Scripting.FileSystemObject    'create the file system object.
    
    boolSucceed = True
    
    'SHOW THE SAVE AS FILE DIALOG AND PASS THE SELECTED FILE NAME TO THE STRING VARIABLE: "saveAsFileName"
    saveAsFileName = Application.GetSaveAsFilename("Filename.txt", "Text Files (*.txt), *.txt", 1, "Text File Selection Dialog")
    If saveAsFileName = "False" Then
        Exit Function
    ElseIf fso.FileExists(saveAsFileName) Then
        overwrite = MsgBox("Overwrite Existing File ?" & Chr(13) & Chr(13) & "Filename: " & fso.GetBaseName(saveAsFileName), vbYesNoCancel, "Overwrite Existing File?")
        Select Case overwrite
            Case vbYes
                boolSucceed = True
            Case vbNo
                boolSucceed = False
            Case vbCancel
                boolSucceed = False
        End Select
    Else
        'THIS IS A NEW FILENAME
    End If
    
End Function
Attribute VB_Name = "IES"
'boom goes the dynamite

Const PI = 3.141592654
Const dtr = PI / 180
Const rtd = 180 / PI

'Chr(8) = backspace
'Chr(9) = tab
'Chr(10) = linefeed
'Chr(13) = carriage return

Option Explicit
Public Function TenPercentMaxCD(lum, intensity, TenPercentmaxV, ImaxTen)

'This function takes the loaded ies file and calculates the set of vertical angles (in 1 degree increments) for both 0 and 90degree lateral planes that
'contain intensity values greater than 10% of maximum.

    Dim v, h, i, j As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim IntensityZero() As Double 'Array of interpolated intensities in 1 degree increments for 0 degree vert plane
    Dim IntensityNinety() As Double 'Array of interpolated intensities in 1 degree increments for 90 degree vert plane
    ReDim IntensityZero(0 To 90) As Double
    ReDim IntensityNinety(0 To 90) As Double
    Dim HAmax As Integer
    Dim VAmax As Integer
    
    'Find max luminaire intensity
    Imax = 0
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            
            If intensity(h, v, 3) > Imax Then
                Imax = intensity(h, v, 3)
                HAmax = intensity(h, v, 1)
                VAmax = intensity(h, v, 2)
                indexH = h
                indexV = v
            End If

        Next v
    Next h
    
    ImaxTen(1, 1) = 0.1 * Imax 'Calculated 90% max CD value for 0 deg lateral plane
    ImaxTen(1, 2) = 0.1 * Imax 'Calculated 90% max CD value for 90 deg lateral plane (same as for 0 deg)

    For i = 1 To UBound(intensity, 1) 'loop through H angles, find 0 and 90
        For j = 1 To UBound(intensity, 2) - 1 'loop through V angles
            If intensity(i, j, 1) = 0 Then
                For v = 0 To 90
                
                    If v >= intensity(i, j, 2) And v <= intensity(i, j + 1, 2) Then 'find bounding angles for interpolation
                        IntensityZero(v) = intensity(i, j, 3) + (intensity(i, j + 1, 3) - intensity(i, j, 3)) * ((v - intensity(i, j, 2)) / (intensity(i, j + 1, 2) - intensity(i, j, 2)))
                        If UBound(intensity, 1) = 1 Then
                            IntensityNinety(v) = IntensityZero(v)
                        End If
                    End If
                    
                Next v
            ElseIf intensity(i, j, 1) = 90 Then
                For v = 0 To 90
                
                    If v >= intensity(i, j, 2) And v <= intensity(i, j + 1, 2) Then 'find bounding angles for interpolation
                        IntensityNinety(v) = intensity(i, j, 3) + (intensity(i, j + 1, 3) - intensity(i, j, 3)) * ((v - intensity(i, j, 2)) / (intensity(i, j + 1, 2) - intensity(i, j, 2)))
                    End If
                    
                Next v
            Else
            End If
        Next j
    Next i



    
For v = 0 To 90
 If IntensityZero(v) > ImaxTen(1, 1) Then
 TenPercentmaxV(1) = v
 ImaxTen(2, 1) = IntensityZero(v)
Else
End If
If IntensityNinety(v) > ImaxTen(1, 2) Then
 TenPercentmaxV(2) = v
 ImaxTen(2, 2) = IntensityNinety(v)
Else
End If
Next v


End Function

Public Function TruncateIntensity90VA_C(intensity, lum)

    Dim iTemp() As Double
    Dim v As Integer
    Dim h As Integer
    Dim v90 As Integer  'save index of 90VA from intensity array
    
    v = 0
    Do
        v = v + 1
    Loop While intensity(1, v, 2) < 90
    v90 = v
    
    ReDim iTemp(1 To lum.NumHAngles, 1 To v90, 1 To 3)
    
    For h = 1 To lum.NumHAngles
        For v = 1 To v90
            iTemp(h, v, 1) = intensity(h, v, 1)
            iTemp(h, v, 2) = intensity(h, v, 2)
            iTemp(h, v, 3) = intensity(h, v, 3)
        Next v
    Next h
    lum.NumVAngles = v90
    intensity = iTemp

End Function



Public Function AverageBilateral(ByVal lumIN, ByVal intensityIN, ByRef lumOUT, ByRef intensityOUT, HAres)
    'THIS FUNCTION AVERAGES AN IES FILE DOWN TO A BILATERALLY SYMMETRIC FILE
    'IT WORKS FOR ALL TYPES OF INPUTTED SYMMETRY (bilateral, quadrilateral, and assymetric)
    'HAres = the horizontal angular resolution (shortcut to get this running instead of automatically finding it)
    
    Dim v As Integer
    Dim h As Integer
    Dim diffH As Double                 'Difference between horizontal angles.
    Dim intensityThisAvg As Double      'Average intensity for the horizontal angles above.
    Dim intensitySum As Double          'Sum of intensities (weighted by solid angle).
    Dim intensityAVG As Double          'Average of intensities (weighted by solid angle).
    Dim VA As Double
    Dim HA As Double
    Dim i As Double
    
    '----------Temp vars to preserve the IN data if the IN and OUT are the same variables passed into this function----
    Dim lumOrig As IESFile
    Set lumOrig = New IESFile
    Dim intensityOrig() As Double
    ReDim intensityOrig(1 To UBound(intensityIN, 1), 1 To UBound(intensityIN, 2), 1 To 3) As Double
    
    lumOrig.BallastFactor = lumIN.BallastFactor
    lumOrig.fileName = lumIN.fileName
    lumOrig.GeneralMultiplier = lumIN.GeneralMultiplier
    lumOrig.InputWatts = lumIN.InputWatts
    lumOrig.LampLumens = lumIN.LampLumens
    lumOrig.LuminousHeight = lumIN.LuminousHeight
    lumOrig.LuminousLength = lumIN.LuminousLength
    lumOrig.LuminousWidth = lumIN.LuminousWidth
    lumOrig.NumberLamps = lumIN.NumberLamps
    lumOrig.NumHAngles = lumIN.NumHAngles
    lumOrig.NumVAngles = lumIN.NumVAngles
    lumOrig.PhotometryType = lumIN.PhotometryType
    lumOrig.units = lumIN.units
    For v = 1 To lumOrig.NumVAngles
        For h = 1 To lumOrig.NumHAngles
            intensityOrig(h, v, 1) = intensityIN(h, v, 1)   'Horiz angle
            intensityOrig(h, v, 2) = intensityIN(h, v, 2)   'Vert angle
            intensityOrig(h, v, 3) = intensityIN(h, v, 3)   'Intensity
        Next h
    Next v
    '-------------------------------------------------------------------------------------------------------------------
       
    lumOUT.BallastFactor = lumOrig.BallastFactor
    lumOUT.fileName = lumOrig.fileName
    lumOUT.GeneralMultiplier = lumOrig.GeneralMultiplier
    lumOUT.InputWatts = lumOrig.InputWatts
    lumOUT.LampLumens = lumOrig.LampLumens
    lumOUT.LuminousHeight = lumOrig.LuminousHeight
    lumOUT.LuminousLength = lumOrig.LuminousLength
    lumOUT.LuminousWidth = lumOrig.LuminousWidth
    lumOUT.NumberLamps = lumOrig.NumberLamps
    lumOUT.NumHAngles = (180 / HAres) + 1        'changed this based on new symmetry and resolution
    lumOUT.NumVAngles = lumOrig.NumVAngles
    lumOUT.PhotometryType = lumOrig.PhotometryType
    lumOUT.units = lumOrig.units
    
    ReDim intensityOUT(1 To lumOUT.NumHAngles, 1 To lumOrig.NumVAngles, 1 To 3) As Double
    
    For h = 1 To lumOUT.NumHAngles
        For v = 1 To lumOUT.NumVAngles
            intensityOUT(h, v, 1) = (h - 1) * HAres         'horizontal angle to new array
            intensityOUT(h, v, 2) = intensityOrig(1, v, 2)  'vertical angle to new array
        Next v
    Next h


    '***************************************THIS WROKS PERFECT (MORE ACCURATE)***************
    Dim ha1, ha2 As Double ', HA3, HA4 As Double
    Dim i1, i2 As Double ', i3, i4 As Double
    For v = 1 To lumOUT.NumVAngles
        intensitySum = 0
        intensityAVG = 0
        VA = intensityOrig(1, v, 2)
        
        'GET FOUR ANGLES TO AVERAGE
        For h = 1 To lumOUT.NumHAngles
            ha1 = intensityOUT(h, v, 1)
            ha2 = 360 - ha1
'            HA3 = 180 + HA1
'            HA4 = 360 - HA1
            
            Call IES.GetIESIntensity(intensityOrig, VA, ha1, i1)
            Call IES.GetIESIntensity(intensityOrig, VA, ha2, i2)
            'Call IES.GetIESIntensity(intensityORIG, VA, HA3, i3)
            'Call IES.GetIESIntensity(intensityORIG, VA, HA4, i4)
            
            intensitySum = i1 + i2 '+ i3 + i4
            intensityAVG = intensitySum / 2
            
            intensityOUT(h, v, 3) = intensityAVG
            
        Next h
        
        

    Next v

End Function

Public Function AppendProrationLog(lumOrig, _
                                    headerOrig() As String, _
                                    intensityOrig() As Double, _
                                    lumNew, _
                              ByRef headerNew() As String, _
                                    intensityNew() As Double, _
                              ByRef testNumberNew As String)

    
    Dim r3, c3, h, i As Integer
    Dim contentsTest As String                                          'Variable to step through table to find end/test numbers
    Dim maxRevNum As Long                                               'Max test number currently in table
    '---------------------------
    Dim testNumberOrig As String                                        'Original test number from header array
    '---------------------------
    Dim found As Boolean                                                'True if found the test searching for
    '---------------------------
    Dim lumCatOrig As String
    Dim lumIssueDateOrig As String
    Dim lumLumensOrig As Double
    '---------------------------
    Dim lumCatNew As String
    Dim lumIssueDateNew As String
    Dim lumLumensNew As Double
    
    Dim contentsRevNum As Long
    
    'CHECK TO SEE IF "PRORATED IES FILE LOG.xlsm" IS OPEN
    'Debug.Print Windows.count
    On Error Resume Next
    Windows("PRORATED IES FILE LOG.xlsm").Activate
    If Err <> 0 Then
        MsgBox "'PRORATED IES FILE LOG.xlsm' is not open. Please open that file for tracking the test numbers and try again", vbOKOnly
        Debug.Print Err
        End
    Else
        'found file open
        Dim wbBook As Workbook
        Dim wsSheet As Worksheet
        Set wbBook = Workbooks("PRORATED IES FILE LOG.xlsm")
        Set wsSheet = wbBook.Worksheets(1)
    End If
    'Debug.Print Err
    'Windows("IES FILE PRORATION 2_2010-12-20.xlsm").Activate

    '-----------------------------------------------------------------
    'GET THE MAX P8000 TEST NUMBER
    r3 = 2
    c3 = 1
    contentsTest = wsSheet.Cells(r3, c3)
    maxRevNum = 80000
    
    maxRevNum = wsSheet.[maxtestnumber] 'try referencing this instead of using the loop... speed?
    
    Dim char As String
    Dim number As String
'    Do While contentsTest <> ""
'        'contentsRevNum = Right(Left(contentsTest, 6), 5) 'Len(contentsTest) - 1)
'
'        '-----ADDED 7/1/2013----------
'        'ALTERNATE WAY OF ISOLATING THE TEST NUMBER FROM VARIOUS TEST NUMBER STRINGS
'        'SEARCH FOR CONSECUTIVE NUMBERS UNTIL END OF THE STRING OR END OF THE NUMBER
'        number = ""
'        char = ""
'        'FIND FIRST NUMBER
'        For i = 1 To Len(contentsTest)
'            char = Mid(contentsTest, i, 1)
'            If Misc.IsNumberOnly(char) = True Then
'                Exit For
'            End If
'        Next i
'        'CONTINUE UNTIL FIND NON-NUMBER OR REACH END
'        For i = i To Len(contentsTest)
'            char = Mid(contentsTest, i, 1)
'            If Misc.IsNumberOnly(char) Then
'                number = number + char
'            Else
'                Exit For
'            End If
'        Next i
'        contentsRevNum = Val(number)
'        Debug.Print Val(number)
'        '-----END ADDITIONS 7/1/2013----------
'
''        If Val(number) > 200000 Then
''            Debug.Print "shit"
''        End If
'
'        If (contentsRevNum > maxRevNum) And (wsSheet.Cells(r3, c3 + 10) <> "") Then
'            maxRevNum = contentsRevNum
'        End If
'        r3 = r3 + 1
'        contentsTest = wsSheet.Cells(r3, c3)
'    Loop
    testNumberNew = "P" & CStr(maxRevNum + 1)

    '-----------------------------------------------------------------
    'GET ORIGINAL TEST NUMBER FROM THE headerOrig - added 11/2014 for TT gen II
    '  IF THE HEADER HAS A "TEST IS SCALED" NOTE, THEN USE THE TEST NUMBER FROM THAT FILE
    Dim scaledNote As Boolean
    Dim hLoc As Integer 'h location for the test number line (scaled)
    Dim strLoc As Integer
    Dim strLoc2 As Integer
    Dim testStrLen As Integer
    For h = 1 To UBound(headerOrig)
        strLoc = InStr(1, headerOrig(h), "TEST IS SCALED", vbTextCompare)
        If strLoc <> 0 Then
            scaledNote = True
            hLoc = h
            Exit For
        End If
    Next h
    If scaledNote Then
        strLoc = InStr(1, headerOrig(hLoc), "(P", vbTextCompare)
        strLoc2 = InStr(1, headerOrig(hLoc), ")", vbTextCompare)
        testStrLen = strLoc2 - (strLoc + 1)
        testNumberOrig = Mid(headerOrig(hLoc), strLoc + 1, testStrLen)
    Else
        For h = 1 To UBound(headerOrig)
            If UCase(Left(headerOrig(h), 6)) = "[TEST]" Then
                testNumberOrig = Right(headerOrig(h), Len(headerOrig(h)) - 6)
            End If
        Next h
    End If
    '-----------------------------------------------------------------
    
    'LOOK FOR EXISTING SOURCE (ORIGINAL) FILE IN LIST
    'UPDATED THIS SECTION 7/1/2013
    r3 = 2
    c3 = 1
    found = False
    contentsTest = wsSheet.Cells(r3, c3)
    Do While contentsTest <> "" And found = False
        If contentsTest = testNumberOrig Then
            found = True
            'INSERT THIS PRORATION DIRECTLY BELOW THE ORIGINAL TEST'S LOCATION
            r3 = r3 + 1
            wsSheet.Activate
            wsSheet.Cells(r3, c3).Select
            Selection.EntireRow.Insert
            Selection.EntireRow.Font.Bold = False
            With Selection.EntireRow.Interior
                .Pattern = xlNone
                .TintAndShade = 0
                .PatternTintAndShade = 0
            End With
        Else
            r3 = r3 + 1
            contentsTest = wsSheet.Cells(r3, c3)
        End If
    Loop
    
    '-----------------------------------------------------------------
    
    'GET CAT LOGIC AND TEST NUMBER FOR ORIGINAL FILE
    For h = 1 To UBound(headerOrig)
        'If UCase(Left(headerOrig(h), 6)) = "[TEST]" Then
            'testNumberOrig = Right(headerOrig(h), Len(headerOrig(h) - 6))      'Already did this above...
        If UCase(Left(headerOrig(h), 8)) = "[LUMCAT]" Then
            lumCatOrig = headerOrig(h)
        ElseIf UCase(Left(headerOrig(h), 11)) = "[ISSUEDATE]" Then
            lumIssueDateOrig = headerOrig(h)
        End If
    Next h
    lumLumensOrig = IES.GetLuminaireLumens(intensityOrig, lumOrig)
    
    '-----------------------------------------------------------------
    
    If found = False Then
        'TEST NOT IN REV SHEET YET, ADD ORIGINAL FILE INFO TO END
        wsSheet.Cells(r3, c3) = testNumberOrig
        'wsSheet.Cells(r3, c3) = "SOURCE"
        wsSheet.Cells(r3, c3 + 1) = testNumberOrig
        wsSheet.Cells(r3, c3 + 2) = lumCatOrig
        wsSheet.Cells(r3, c3 + 3) = Round(lumLumensOrig, 0)
        wsSheet.Cells(r3, c3 + 4) = lumOrig.InputWatts
        wsSheet.Cells(r3, c3 + 5) = lumIssueDateOrig
        wsSheet.Range(CStr(r3) + ":" + CStr(r3)).Font.Bold = True
        wsSheet.Range(CStr(r3) + ":" + CStr(r3)).Interior.ColorIndex = 15 'lt gray
        r3 = r3 + 1
    End If
    
    '-----------------------------------------------------------------
    
    'GET CAT LOGIC AND TEST NUMBER FOR NEW FILE
    For h = 1 To UBound(headerNew)
        If UCase(Left(headerNew(h), 6)) = "[TEST]" Then
            headerNew(h) = "[TEST]" & testNumberNew
        ElseIf UCase(Left(headerNew(h), 8)) = "[LUMCAT]" Then
            lumCatNew = headerNew(h)
        ElseIf UCase(Left(headerNew(h), 11)) = "[ISSUEDATE]" Then
            lumIssueDateNew = headerNew(h)
        End If
    Next h
    lumLumensNew = IES.GetLuminaireLumens(intensityNew, lumNew)
    
    'ADD NEW PRORATION AFTER THE ORIGINAL
    'maxRevNum = 0
    wsSheet.Cells(r3, c3) = testNumberNew
    wsSheet.Cells(r3, c3 + 1) = testNumberOrig
    wsSheet.Cells(r3, c3 + 2) = lumCatNew              '[LUMCAT]
    wsSheet.Cells(r3, c3 + 3) = Round(lumLumensNew, 0)   'LUM LUMENS
    wsSheet.Cells(r3, c3 + 4) = Round(lumNew.InputWatts, 1)
    wsSheet.Cells(r3, c3 + 5) = Date
'                    If scaled Then
'                        wsSheet.Cells(r3, c3 + 6) = "X"
'                    End If
    wsSheet.Range(CStr(r3) + ":" + CStr(r3)).Font.Bold = False
    wsSheet.Range(CStr(r3) + ":" + CStr(r3)).Interior.ColorIndex = 0  'No color
    wsSheet.Cells(r3, c3 + 10) = maxRevNum + 1
    
    'RETURN THE NEXT TEST NUMBER (for cbRun to add to new file header)
    'testNumberNew = "P" & CStr(maxRevNum)  'already changed in header above in the block-if statement
    
End Function


Public Function AverageAxially(ByVal lumIN, ByVal intensityIN, ByRef lumOUT, ByRef intensityOUT)
    'THIS FUNCTION AVERAGES AN IES FILE DOWN TO AN AXIALLY SYMMETRIC FILE
    'IT WORKS FOR ALL TYPES OF INPUTTED SYMMETRY (bilateral, quadrilateral, and assymetric)
    
    Dim v As Integer
    Dim h As Integer
    Dim diffH As Double                 'Difference between horizontal angles.
    Dim intensityThisAvg As Double      'Average intensity for the horizontal angles above.
    Dim intensitySum As Double          'Sum of intensities (weighted by solid angle).
    Dim intensityAVG As Double          'Average of intensities (weighted by solid angle).
    
    '----------Temp vars to preserve the IN data if the IN and OUT are the same variables passed into this function----
    Dim lumOrig As IESFile
    Set lumOrig = New IESFile
    Dim intensityOrig() As Double
    ReDim intensityOrig(1 To UBound(intensityIN, 1), 1 To UBound(intensityIN, 2), 1 To 3) As Double
    
    lumOrig.BallastFactor = lumIN.BallastFactor
    lumOrig.fileName = lumIN.fileName
    lumOrig.GeneralMultiplier = lumIN.GeneralMultiplier
    lumOrig.InputWatts = lumIN.InputWatts
    lumOrig.LampLumens = lumIN.LampLumens
    lumOrig.LuminousHeight = lumIN.LuminousHeight
    lumOrig.LuminousLength = lumIN.LuminousLength
    lumOrig.LuminousWidth = lumIN.LuminousWidth
    lumOrig.NumberLamps = lumIN.NumberLamps
    lumOrig.NumHAngles = lumIN.NumHAngles
    lumOrig.NumVAngles = lumIN.NumVAngles
    lumOrig.PhotometryType = lumIN.PhotometryType
    lumOrig.units = lumIN.units
    For v = 1 To lumOrig.NumVAngles
        For h = 1 To lumOrig.NumHAngles
            intensityOrig(h, v, 1) = intensityIN(h, v, 1)   'Horiz angle
            intensityOrig(h, v, 2) = intensityIN(h, v, 2)   'Vert angle
            intensityOrig(h, v, 3) = intensityIN(h, v, 3)   'Intensity
        Next h
    Next v
    '-------------------------------------------------------------------------------------------------------------------
       
    lumOUT.BallastFactor = lumOrig.BallastFactor
    lumOUT.fileName = lumOrig.fileName
    lumOUT.GeneralMultiplier = lumOrig.GeneralMultiplier
    lumOUT.InputWatts = lumOrig.InputWatts
    lumOUT.LampLumens = lumOrig.LampLumens
    lumOUT.LuminousHeight = lumOrig.LuminousHeight
    lumOUT.LuminousLength = lumOrig.LuminousLength
    lumOUT.LuminousWidth = lumOrig.LuminousWidth
    lumOUT.NumberLamps = lumOrig.NumberLamps
    lumOUT.NumHAngles = 1                               '<----- Change this to "1"
    lumOUT.NumVAngles = lumOrig.NumVAngles
    lumOUT.PhotometryType = lumOrig.PhotometryType
    lumOUT.units = lumOrig.units
    
    ReDim intensityOUT(1 To 1, 1 To lumOrig.NumVAngles, 1 To 3) As Double
    



    '***************************************THIS WROKS PERFECT (MORE ACCURATE)***************
    For v = 1 To lumOrig.NumVAngles
        intensitySum = 0
        intensityAVG = 0
        'vAngle = intensityORIG(1, v, 2)
        If lumOrig.NumHAngles > 1 Then
            For h = 1 To lumOrig.NumHAngles - 1
                diffH = intensityOrig(h + 1, v, 1) - intensityOrig(h, v, 1)                   'Horizontal angle span
                intensityThisAvg = (intensityOrig(h, v, 3) + intensityOrig(h + 1, v, 3)) / 2  'Average intensity between this and the next value in the file
                intensitySum = intensitySum + (intensityThisAvg * diffH)
            Next h
            intensityAVG = intensitySum / intensityOrig(UBound(intensityOrig, 1), 1, 1)
            intensityOUT(1, v, 1) = intensityOrig(1, v, 1)  'Horiz angle
            intensityOUT(1, v, 2) = intensityOrig(1, v, 2)  'Vert angle
            intensityOUT(1, v, 3) = intensityAVG            'Intensity
        Else
            intensityOUT(1, v, 1) = intensityOrig(1, v, 1)  'Horiz angle
            intensityOUT(1, v, 2) = intensityOrig(1, v, 2)  'Vert angle
            intensityOUT(1, v, 3) = intensityOrig(1, v, 3)  'Intensity
        End If
    Next v

End Function


Public Function AverageQuad(ByVal lumIN, ByVal intensityIN, ByRef lumOUT, ByRef intensityOUT, HAres)
    'THIS FUNCTION AVERAGES AN IES FILE DOWN TO AN AXIALLY SYMMETRIC FILE
    'IT WORKS FOR ALL TYPES OF INPUTTED SYMMETRY (bilateral, quadrilateral, and assymetric)
    'HAres = the horizontal angular resolution (shortcut to get this running instead of automatically finding it)
    
    Dim v As Integer
    Dim h As Integer
    Dim diffH As Double                 'Difference between horizontal angles.
    Dim intensityThisAvg As Double      'Average intensity for the horizontal angles above.
    Dim intensitySum As Double          'Sum of intensities (weighted by solid angle).
    Dim intensityAVG As Double          'Average of intensities (weighted by solid angle).
    Dim VA As Double
    Dim HA As Double
    Dim i As Double
    
    '----------Temp vars to preserve the IN data if the IN and OUT are the same variables passed into this function----
    Dim lumOrig As IESFile
    Set lumOrig = New IESFile
    Dim intensityOrig() As Double
    ReDim intensityOrig(1 To UBound(intensityIN, 1), 1 To UBound(intensityIN, 2), 1 To 3) As Double
    
    lumOrig.BallastFactor = lumIN.BallastFactor
    lumOrig.fileName = lumIN.fileName
    lumOrig.GeneralMultiplier = lumIN.GeneralMultiplier
    lumOrig.InputWatts = lumIN.InputWatts
    lumOrig.LampLumens = lumIN.LampLumens
    lumOrig.LuminousHeight = lumIN.LuminousHeight
    lumOrig.LuminousLength = lumIN.LuminousLength
    lumOrig.LuminousWidth = lumIN.LuminousWidth
    lumOrig.NumberLamps = lumIN.NumberLamps
    lumOrig.NumHAngles = lumIN.NumHAngles
    lumOrig.NumVAngles = lumIN.NumVAngles
    lumOrig.PhotometryType = lumIN.PhotometryType
    lumOrig.units = lumIN.units
    For v = 1 To lumOrig.NumVAngles
        For h = 1 To lumOrig.NumHAngles
            intensityOrig(h, v, 1) = intensityIN(h, v, 1)   'Horiz angle
            intensityOrig(h, v, 2) = intensityIN(h, v, 2)   'Vert angle
            intensityOrig(h, v, 3) = intensityIN(h, v, 3)   'Intensity
        Next h
    Next v
    '-------------------------------------------------------------------------------------------------------------------
       
    lumOUT.BallastFactor = lumOrig.BallastFactor
    lumOUT.fileName = lumOrig.fileName
    lumOUT.GeneralMultiplier = lumOrig.GeneralMultiplier
    lumOUT.InputWatts = lumOrig.InputWatts
    lumOUT.LampLumens = lumOrig.LampLumens
    lumOUT.LuminousHeight = lumOrig.LuminousHeight
    lumOUT.LuminousLength = lumOrig.LuminousLength
    lumOUT.LuminousWidth = lumOrig.LuminousWidth
    lumOUT.NumberLamps = lumOrig.NumberLamps
    lumOUT.NumHAngles = (90 / HAres) + 1        'changed this based on new symmetry and resolution
    lumOUT.NumVAngles = lumOrig.NumVAngles
    lumOUT.PhotometryType = lumOrig.PhotometryType
    lumOUT.units = lumOrig.units
    
    ReDim intensityOUT(1 To lumOUT.NumHAngles, 1 To lumOrig.NumVAngles, 1 To 3) As Double
    
    For h = 1 To lumOUT.NumHAngles
        For v = 1 To lumOUT.NumVAngles
            intensityOUT(h, v, 1) = (h - 1) * HAres         'horizontal angle to new array
            intensityOUT(h, v, 2) = intensityOrig(1, v, 2)  'vertical angle to new array
        Next v
    Next h


    '***************************************THIS WROKS PERFECT (MORE ACCURATE)***************
    Dim ha1, ha2, HA3, HA4 As Double
    Dim i1, i2, i3, i4 As Double
    For v = 1 To lumOUT.NumVAngles
        intensitySum = 0
        intensityAVG = 0
        VA = intensityOrig(1, v, 2)
        
        'GET FOUR ANGLES TO AVERAGE
        For h = 1 To lumOUT.NumHAngles
            ha1 = intensityOUT(h, v, 1)
            ha2 = 180 - ha1
            HA3 = 180 + ha1
            HA4 = 360 - ha1
            
            Call IES.GetIESIntensity(intensityOrig, VA, ha1, i1)
            Call IES.GetIESIntensity(intensityOrig, VA, ha2, i2)
            Call IES.GetIESIntensity(intensityOrig, VA, HA3, i3)
            Call IES.GetIESIntensity(intensityOrig, VA, HA4, i4)
            
            intensitySum = i1 + i2 + i3 + i4
            intensityAVG = intensitySum / 4
            
            intensityOUT(h, v, 3) = intensityAVG
            
        Next h
        
        

    Next v

End Function
Public Function AverageQuadHAString(ByVal lumIN, ByVal intensityIN, ByRef lumOUT, ByRef intensityOUT, HAarray)
    'THIS FUNCTION AVERAGES AN IES FILE DOWN TO AN AXIALLY SYMMETRIC FILE
    'IT WORKS FOR ALL TYPES OF INPUTTED SYMMETRY (bilateral, quadrilateral, and assymetric)
    'HAarray = string of HA's to include in the new file)
    
    Dim v As Integer
    Dim h As Integer
    Dim diffH As Double                 'Difference between horizontal angles.
    Dim intensityThisAvg As Double      'Average intensity for the horizontal angles above.
    Dim intensitySum As Double          'Sum of intensities (weighted by solid angle).
    Dim intensityAVG As Double          'Average of intensities (weighted by solid angle).
    Dim VA As Double
    Dim HA As Double
    Dim i As Double
    
    '----------Temp vars to preserve the IN data if the IN and OUT are the same variables passed into this function----
    Dim lumOrig As IESFile
    Set lumOrig = New IESFile
    Dim intensityOrig() As Double
    ReDim intensityOrig(1 To UBound(intensityIN, 1), 1 To UBound(intensityIN, 2), 1 To 3) As Double
    
    lumOrig.BallastFactor = lumIN.BallastFactor
    lumOrig.fileName = lumIN.fileName
    lumOrig.GeneralMultiplier = lumIN.GeneralMultiplier
    lumOrig.InputWatts = lumIN.InputWatts
    lumOrig.LampLumens = lumIN.LampLumens
    lumOrig.LuminousHeight = lumIN.LuminousHeight
    lumOrig.LuminousLength = lumIN.LuminousLength
    lumOrig.LuminousWidth = lumIN.LuminousWidth
    lumOrig.NumberLamps = lumIN.NumberLamps
    lumOrig.NumHAngles = lumIN.NumHAngles
    lumOrig.NumVAngles = lumIN.NumVAngles
    lumOrig.PhotometryType = lumIN.PhotometryType
    lumOrig.units = lumIN.units
    For v = 1 To lumOrig.NumVAngles
        For h = 1 To lumOrig.NumHAngles
            intensityOrig(h, v, 1) = intensityIN(h, v, 1)   'Horiz angle
            intensityOrig(h, v, 2) = intensityIN(h, v, 2)   'Vert angle
            intensityOrig(h, v, 3) = intensityIN(h, v, 3)   'Intensity
        Next h
    Next v
    '-------------------------------------------------------------------------------------------------------------------
       
    'GET AN ARRAY OF HORIZONTAL ANGLES
    
    
    
    
    
    lumOUT.BallastFactor = lumOrig.BallastFactor
    lumOUT.fileName = lumOrig.fileName
    lumOUT.GeneralMultiplier = lumOrig.GeneralMultiplier
    lumOUT.InputWatts = lumOrig.InputWatts
    lumOUT.LampLumens = lumOrig.LampLumens
    lumOUT.LuminousHeight = lumOrig.LuminousHeight
    lumOUT.LuminousLength = lumOrig.LuminousLength
    lumOUT.LuminousWidth = lumOrig.LuminousWidth
    lumOUT.NumberLamps = lumOrig.NumberLamps
    lumOUT.NumHAngles = UBound(HAarray)         'changed based on string input array
    lumOUT.NumVAngles = lumOrig.NumVAngles
    lumOUT.PhotometryType = lumOrig.PhotometryType
    lumOUT.units = lumOrig.units
    
    ReDim intensityOUT(1 To lumOUT.NumHAngles, 1 To lumOrig.NumVAngles, 1 To 3) As Double
    
    For h = 1 To lumOUT.NumHAngles
        For v = 1 To lumOUT.NumVAngles
            intensityOUT(h, v, 1) = HAarray(h)         'horizontal angle to new array
            intensityOUT(h, v, 2) = intensityOrig(1, v, 2)  'vertical angle to new array
        Next v
    Next h


    '***************************************THIS WROKS PERFECT (MORE ACCURATE)***************
    Dim ha1, ha2, HA3, HA4 As Double
    Dim i1, i2, i3, i4 As Double
    For v = 1 To lumOUT.NumVAngles
        intensitySum = 0
        intensityAVG = 0
        VA = intensityOrig(1, v, 2)
        
        'GET FOUR ANGLES TO AVERAGE
        For h = 1 To lumOUT.NumHAngles
            ha1 = intensityOUT(h, v, 1)
            ha2 = 180 - ha1
            HA3 = 180 + ha1
            HA4 = 360 - ha1
            
            Call IES.GetIESIntensity(intensityOrig, VA, ha1, i1)
            Call IES.GetIESIntensity(intensityOrig, VA, ha2, i2)
            Call IES.GetIESIntensity(intensityOrig, VA, HA3, i3)
            Call IES.GetIESIntensity(intensityOrig, VA, HA4, i4)
            
            intensitySum = i1 + i2 + i3 + i4
            intensityAVG = intensitySum / 4
            
            intensityOUT(h, v, 3) = intensityAVG
            
        Next h
        
        

    Next v

End Function


Public Function BeamAngleB(header, lum, intensity, BAh, BAv)
    'FIND THE BEAM ANGLE FOR A TYPE B PHOTOMETRIC FILE.
    'BEAM ANGLE IS FULL ANGLE BETWEEN HALF MAXES, THROUGH THE MAX INTENSITY
    
    Dim v, h As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim Ihalf As Double     '1/2 maximum candela value
    Dim VAmax As Double     'Vertical angle of max candela
    Dim HAmax As Double     'Horizontal angle of max candela
    
    Dim HA, ha1, ha2 As Double
    Dim HAleft, HAright As Double
    Dim i1, i2 As Double
    Dim VA, va1, va2 As Double  'Bounding VA's for half max
    Dim VAtop, VAbottom As Double
    
    'FIND MAX INTENSITY
    Imax = 0
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            If intensity(h, v, 3) > Imax Then
                Imax = intensity(h, v, 3)
                HAmax = intensity(h, v, 1)
                VAmax = intensity(h, v, 2)
                indexH = h
                indexV = v
            End If
        Next v
    Next h
    Ihalf = Imax / 2
    
    
    '**************************************************************************************
    'HORIZONTAL BEAM ANGLE (ON VERTICAL PLANE OF MAX I)
    If intensity(1, 1, 1) = 0 Then
    
        'ONLY DATA FROM 0->90
        'RIGHT SIDE OF MAX I
        For h = indexH To UBound(intensity, 1)
            If intensity(h, indexV, 3) <= Ihalf Then    'STOP WHEN LESS THAN 1/2 MAX
                ha1 = intensity(h - 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h - 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        HAright = ha1 + ((Ihalf - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        BAh = HAright - HAmax
        
        'CHECK THE LEFT SIDE TO MAKE SURE DOESN'T DROP BELOW 1/2 MAX
        ha1 = 0
        ha2 = 0
        For h = indexH To 1 Step -1
            If intensity(h, indexV, 3) <= Ihalf Then 'STOP WHEN LESS THAN THAN 1/2 MAX BEFORE 0-DEG HA
                ha1 = intensity(h + 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h + 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        If ha1 <> 0 And ha2 <> 0 Then
            HAleft = ha1 + ((Ihalf - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        Else
            HAleft = -HAright
        End If
        BAh = BAh + (HAmax - HAleft)
        'BAh = HAleft * 2    'Full angle
        
    Else
        'DATA FROM -90->90
        'LEFT SIDE
        For h = indexH To 1 Step -1
            If intensity(h, indexV, 3) <= Ihalf Then 'STOP WHEN LESS THAN THAN 1/2 MAX
                ha1 = intensity(h + 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h + 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        HAleft = ha1 + ((Ihalf - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        BAh = HAmax - HAleft
        
        
        'RIGHT SIDE
        For h = indexH To UBound(intensity, 1)
            If intensity(h, indexV, 3) <= Ihalf Then    'STOP WHEN LESS THAN 1/2 MAX
                ha1 = intensity(h - 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h - 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        HAright = ha1 + ((Ihalf - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        'BAh = HAright + HAleft     'Full angle
        BAh = BAh + (HAright - HAmax)
    End If
    
    
    
    
    
    '**************************************************************************************
    'VERTICAL BEAM ANGLE (THROUGH HORIZONTAL ANGLE OF MAX I)
    If intensity(1, 1, 2) = 0 Then
        'ONLY DATA FROM 0->90
        'TOP SIDE
        For v = indexV To UBound(intensity, 2)
            If intensity(indexH, v, 3) <= Ihalf Then    'STOP WHEN LESS THAN 1/2 MAX
                va1 = intensity(indexH, v - 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v - 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        VAtop = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        BAv = VAtop - VAmax
        
        'CHECK THE BOTTOM SIDE TO MAKE SURE DOESN'T DROP BELOW 1/2 MAX BEFORE 0-DEG VA
        va1 = 0
        va2 = 0
        For v = indexV To 1 Step -1
            If intensity(indexH, v, 3) <= Ihalf Then    'STOP WHEN LESS THAN 1/2 MAX
                va1 = intensity(indexH, v + 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v + 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        If va1 <> 0 And va2 <> 0 Then
            VAbottom = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        Else
            VAbottom = -VAtop
        End If
        BAv = BAv + (VAmax - VAbottom)
        
    Else
        
        'DATA FROM -90->90
        'TOP SIDE
        For v = indexV To UBound(intensity, 2)
            If intensity(indexH, v, 3) <= Ihalf Then    'STOP WHEN LESS THAN 1/2 MAX
                va1 = intensity(indexH, v - 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v - 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        VAtop = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        BAv = VAtop - VAmax
        
        'BOTTOM SIDE
        For v = indexV To 1 Step -1
            If intensity(indexH, v, 3) <= Ihalf Then    'STOP WHEN LESS THAN 1/2 MAX
                va1 = intensity(indexH, v + 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v + 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        VAbottom = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        BAv = BAv + (VAmax - VAbottom)
    End If
    
    

    
End Function
Public Function BeamAngleC(header, lum, intensity, BA)
    Dim v, h As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim Ihalf As Double     '1/2 maximum candela value
    Dim VAmax As Double     'Vertical angle of max candela
    Dim HAmax As Double     'Horizontal angle of max candela
    
    'FIND MAX INTENSITY
    Imax = 0
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            If intensity(h, v, 3) > Imax Then
                Imax = intensity(h, v, 3)
                HAmax = intensity(h, v, 1)
                VAmax = intensity(h, v, 2)
                indexH = h
                indexV = v
            End If
        Next v
    Next h
    Ihalf = Imax / 2
    
    'ASSIGN THE TWO HORIZONTAL PLANES TO CONSIDER
    Dim indexVcount As Integer
    indexVcount = UBound(intensity, 2) * 2 - 2
    Dim intensityPlane() As Double
    ReDim intensityPlane(1 To 1, 1 To indexVcount, 1 To 3) As Double
    Dim HAneg, HApos As Double
    HApos = HAmax
    HAneg = HApos + 180
    If HAneg > 360 Then
        HAneg = HAneg - 360
    End If
    
    'LOAD intensityPlane with the max plane, and the 180 degree plane from the max plane
    Dim countV As Integer
    countV = 1
    'LOAD NEGATIVE PLANE - plane opposite the HA of the peak candela value
    For v = UBound(intensity, 2) - 1 To 2 Step -1
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HAneg, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2) * -1
        countV = countV + 1
    Next v
    'LOAD POSITIVE PLANE
    For v = 1 To UBound(intensity, 2)
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HApos, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2)
        countV = countV + 1
'        If countV = 142 Then
'            'Debug.Print "countV = 142"
'        End If
    Next v
    'Debug.Print "IntensityPlane Loaded!!"

    'FIND THE MAX INTENSITY INDEX IN THE NEW INTENSITYPLANE ARRAY
    Imax = 0
    'For h = 1 To UBound(intensityPlane, 1)
        For v = 1 To UBound(intensityPlane, 2)
            If intensityPlane(1, v, 3) > Imax Then
                Imax = intensityPlane(1, v, 3)
                HAmax = intensityPlane(1, v, 1)
                VAmax = intensityPlane(1, v, 2)
                indexH = 1
                indexV = v
            End If
        Next v
    'Next h
    'Ihalf = Imax / 2

'----------------------------------------------------------------------------------------
'trying new code for finding two angles 4/14/15
    
    'CLOCKWISE
    Dim va1, va2 As Double  'Bounding VA's for half max
    Dim i1, i2 As Double    'Bounding intensity values at bounding angles
    Dim VAhigh As Double        'VA for half max
    Dim foundH As Boolean
    foundH = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v + 1
        If v > UBound(intensityPlane, 2) Then
            v = 1
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Ihalf Then
            va1 = intensityPlane(indexH, v - 1, 2)
            va2 = intensityPlane(indexH, v, 2)
            i1 = intensityPlane(indexH, v - 1, 3)
            i2 = intensityPlane(indexH, v, 3)
            foundH = True
            Exit Do
        End If
    Loop
    If foundH Then
        VAhigh = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1)
    End If
    
    'CCW
    Dim VAlow
    Dim foundL As Boolean
    foundL = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v - 1
        If v < 1 Then
            v = UBound(intensityPlane, 2)
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Ihalf Then
            va1 = intensityPlane(indexH, v, 2)
            va2 = intensityPlane(indexH, v + 1, 2)
            i1 = intensityPlane(indexH, v, 3)
            i2 = intensityPlane(indexH, v + 1, 3)
            foundL = True
            Exit Do
        End If
    Loop
    If foundL Then
        VAlow = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1)
    End If
    
    'Debug.Print "VAlow : " & VAlow
    'Debug.Print "VAmax : " & VAmax
    'Debug.Print "VAhigh: " & VAhigh
    
'----------------------------------------------------------------------------------------

    'FIND UPPER BOUND V-ANGLE OF HALF MAX IN INTENSITYPLANE ARRAY
'    Dim VA1, VA2 As Double  'Bounding VA's for half max
'    Dim i1, i2 As Double    'Bounding intensity values at bounding angles
'    Dim VAhigh As Double        'VA for half max
'    Dim foundH As Boolean
'    foundH = False
'    For v = indexV To UBound(intensityPlane, 2)
'        If intensityPlane(indexH, v, 3) <= Ihalf Then
'            VA1 = intensityPlane(indexH, v - 1, 2)
'            VA2 = intensityPlane(indexH, v, 2)
'            i1 = intensityPlane(indexH, v - 1, 3)
'            i2 = intensityPlane(indexH, v, 3)
'            foundH = True
'            Exit For
'        End If
'
'    Next v
'    If foundH Then
'        VAhigh = VA1 + ((Ihalf - i1) / (i2 - i1)) * (VA2 - VA1)
'    End If
'
'    'FIND LOWER BOUND V-ANGLE OF HALF MAX IN INTENSITY PLANE ARRAY
''    Dim VAlow
''    Dim foundL As Boolean
'    foundL = False
'    For v = indexV To LBound(intensityPlane, 2) Step -1
'        If intensityPlane(indexH, v, 3) <= Ihalf Then
'            VA1 = intensityPlane(indexH, v, 2)
'            VA2 = intensityPlane(indexH, v + 1, 2)
'            i1 = intensityPlane(indexH, v, 3)
'            i2 = intensityPlane(indexH, v + 1, 3)
'            foundL = True
'            Exit For
'        End If
'    Next v
'    If foundL Then
'        VAlow = VA1 + ((Ihalf - i1) / (i2 - i1)) * (VA2 - VA1)
'    End If
    
    Dim BAccw, BAcw As Double
    If foundL And foundH Then
        '---------CCW---------------
        If VAhigh > VAmax Then
            BAccw = VAhigh - VAmax
        Else
            BAccw = (180 - VAmax) + (VAhigh - (-180))
        End If
        '---------CW----------------
        If VAlow < VAmax Then
            BAcw = VAmax - VAlow
        Else
            BAcw = (180 - VAlow) + (VAmax - (-180))
        End If
        '------------------------
        BA = BAccw + BAcw
    Else
        BA = 0
    End If
    
    
End Function


Public Function BeamAngleCInputHA(intensity, HA, BA)
    Dim v, h As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim Ihalf As Double     '1/2 maximum candela value
    Dim VAmax As Double     'Vertical angle of max candela
    Dim HAmax As Double     'Horizontal angle of max candela
    
    'FIND MAX INTENSITY
Imax = 0
For h = 1 To UBound(intensity, 1)
    For v = 1 To UBound(intensity, 2)
        If intensity(h, v, 3) > Imax Then
            Imax = intensity(h, v, 3)
            'HAmax = intensity(h, v, 1)
            'VAmax = intensity(h, v, 2)
            'indexH = h
            'indexV = v
        End If
    Next v
Next h
Ihalf = Imax / 2
    
    'ASSIGN THE TWO HORIZONTAL PLANES TO CONSIDER
    Dim indexVcount As Integer
    indexVcount = UBound(intensity, 2) * 2 - 2
    Dim intensityPlane() As Double
    ReDim intensityPlane(1 To 1, 1 To indexVcount, 1 To 3) As Double
    Dim HAneg, HApos As Double
'    HApos = HAmax
'    HAneg = HApos + 180

    If HA < 180 Then
        HApos = HA
        HAneg = HA + 180
    Else
        HApos = HA - 180
        HAneg = HA
    End If

    If HAneg > 360 Then
        HAneg = HAneg - 360
    End If
    
    'LOAD intensityPlane with the max plane, and the 180 degree plane from the max plane
    Dim countV As Integer
    countV = 1
    'LOAD NEGATIVE PLANE - plane opposite the HA of the peak candela value
    For v = UBound(intensity, 2) - 1 To 2 Step -1
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HAneg, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2) * -1
        countV = countV + 1
    Next v
    'LOAD POSITIVE PLANE
    For v = 1 To UBound(intensity, 2)
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HApos, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2)
        countV = countV + 1
'        If countV = 142 Then
'            'Debug.Print "countV = 142"
'        End If
    Next v
    'Debug.Print "IntensityPlane Loaded!!"

    'FIND THE MAX INTENSITY INDEX IN THE NEW INTENSITYPLANE ARRAY
    Imax = 0
    'For h = 1 To UBound(intensityPlane, 1)
        For v = 1 To UBound(intensityPlane, 2)
            If intensityPlane(1, v, 3) > Imax Then
                Imax = intensityPlane(1, v, 3)
                HAmax = intensityPlane(1, v, 1)
                VAmax = intensityPlane(1, v, 2)
                indexH = 1
                indexV = v
            End If
        Next v
    'Next h
'Ihalf = Imax / 2   turn this on to only look at the max in the single plane of concern (not what photopia uses)

'----------------------------------------------------------------------------------------
'trying new code for finding two angles 4/14/15
    
    'CLOCKWISE
    Dim va1, va2 As Double  'Bounding VA's for half max
    Dim i1, i2 As Double    'Bounding intensity values at bounding angles
    Dim VAhigh As Double        'VA for half max
    Dim foundH As Boolean
    foundH = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v + 1
        If v > UBound(intensityPlane, 2) Then
            v = 1
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Ihalf Then
            va1 = intensityPlane(indexH, v - 1, 2)
            va2 = intensityPlane(indexH, v, 2)
            i1 = intensityPlane(indexH, v - 1, 3)
            i2 = intensityPlane(indexH, v, 3)
            foundH = True
            Exit Do
        End If
    Loop
    If foundH Then
        VAhigh = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1)
    End If
    
    'CCW
    Dim VAlow
    Dim foundL As Boolean
    foundL = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v - 1
        If v < 1 Then
            v = UBound(intensityPlane, 2)
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Ihalf Then
            va1 = intensityPlane(indexH, v, 2)
            va2 = intensityPlane(indexH, v + 1, 2)
            i1 = intensityPlane(indexH, v, 3)
            i2 = intensityPlane(indexH, v + 1, 3)
            foundL = True
            Exit Do
        End If
    Loop
    If foundL Then
        VAlow = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1)
    End If
    
    'Debug.Print "VAlow : " & VAlow
    'Debug.Print "VAmax : " & VAmax
    'Debug.Print "VAhigh: " & VAhigh
    
    Dim BAccw, BAcw As Double
    If foundL And foundH Then
        '---------CCW---------------
        If VAhigh > VAmax Then
            BAccw = VAhigh - VAmax
        Else
            BAccw = (180 - VAmax) + (VAhigh - (-180))
        End If
        '---------CW----------------
        If VAlow < VAmax Then
            BAcw = VAmax - VAlow
        Else
            BAcw = (180 - VAlow) + (VAmax - (-180))
        End If
        '------------------------
        BA = BAccw + BAcw
    Else
        BA = 0
    End If
    
    
End Function


Public Function FieldAngleB(header, lum, intensity, FAh, FAv)
    'FIND THE FIELD ANGLE FOR A TYPE B PHOTOMETRIC FILE.
    'FIELD ANGLE IS FULL ANGLE BETWEEN HALF MAXES, THROUGH THE MAX INTENSITY
    
    Dim v, h As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim Ifield As Double     '1/10 maximum candela value
    Dim VAmax As Double     'Vertical angle of max candela
    Dim HAmax As Double     'Horizontal angle of max candela
    
    Dim HA, ha1, ha2 As Double
    Dim HAleft, HAright As Double
    Dim i1, i2 As Double
    Dim VA, va1, va2 As Double  'Bounding VA's for half max
    Dim VAtop, VAbottom As Double
    
    'FIND MAX INTENSITY
    Imax = 0
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            If intensity(h, v, 3) > Imax Then
                Imax = intensity(h, v, 3)
                HAmax = intensity(h, v, 1)
                VAmax = intensity(h, v, 2)
                indexH = h
                indexV = v
            End If
        Next v
    Next h
    Ifield = Imax / 10
    
    
    '**************************************************************************************
    'HORIZONTAL FIELD ANGLE (ON VERTICAL PLANE OF MAX I)
    If intensity(1, 1, 1) = 0 Then
    
        'ONLY DATA FROM 0->90
        'RIGHT SIDE OF MAX I
        For h = indexH To UBound(intensity, 1)
            If intensity(h, indexV, 3) <= Ifield Then    'STOP WHEN LESS THAN 1/10 MAX
                ha1 = intensity(h - 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h - 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        HAright = ha1 + ((Ifield - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        FAh = HAright - HAmax
        
        'CHECK THE LEFT SIDE TO MAKE SURE DOESN'T DROP BELOW 1/10 MAX
        ha1 = 0
        ha2 = 0
        For h = indexH To 1 Step -1
            If intensity(h, indexV, 3) <= Ifield Then 'STOP WHEN LESS THAN THAN 1/10 MAX BEFORE 0-DEG HA
                ha1 = intensity(h + 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h + 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        If ha1 <> 0 And ha2 <> 0 Then
            HAleft = ha1 + ((Ifield - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        Else
            HAleft = -HAright
        End If
        FAh = FAh + (HAmax - HAleft)
        'FAh = HAleft * 2    'Full angle
        
    Else
        'DATA FROM -90->90
        'LEFT SIDE
        For h = indexH To 1 Step -1
            If intensity(h, indexV, 3) <= Ifield Then 'STOP WHEN LESS THAN THAN 1/10 MAX
                ha1 = intensity(h + 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h + 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        HAleft = ha1 + ((Ifield - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        FAh = HAmax - HAleft
        
        
        'RIGHT SIDE
        For h = indexH To UBound(intensity, 1)
            If intensity(h, indexV, 3) <= Ifield Then    'STOP WHEN LESS THAN 1/10 MAX
                ha1 = intensity(h - 1, indexV, 1)
                ha2 = intensity(h, indexV, 1)
                i1 = intensity(h - 1, indexV, 3)
                i2 = intensity(h, indexV, 3)
                Exit For
            End If
        Next h
        HAright = ha1 + ((Ifield - i1) / (i2 - i1)) * (ha2 - ha1) 'Half angle
        'FAh = HAright + HAleft     'Full angle
        FAh = FAh + (HAright - HAmax)
    End If
    
    
    
    
    
    '**************************************************************************************
    'VERTICAL FIELD ANGLE (THROUGH HORIZONTAL ANGLE OF MAX I)
    If intensity(1, 1, 2) = 0 Then
        'ONLY DATA FROM 0->90
        'TOP SIDE
        For v = indexV To UBound(intensity, 2)
            If intensity(indexH, v, 3) <= Ifield Then    'STOP WHEN LESS THAN 1/10 MAX
                va1 = intensity(indexH, v - 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v - 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        VAtop = va1 + ((Ifield - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        FAv = VAtop - VAmax
        
        'CHECK THE BOTTOM SIDE TO MAKE SURE DOESN'T DROP BELOW 1/10 MAX BEFORE 0-DEG VA
        va1 = 0
        va2 = 0
        For v = indexV To 1 Step -1
            If intensity(indexH, v, 3) <= Ifield Then    'STOP WHEN LESS THAN 1/10 MAX
                va1 = intensity(indexH, v + 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v + 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        If va1 <> 0 And va2 <> 0 Then
            VAbottom = va1 + ((Ifield - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        Else
            VAbottom = -VAtop
        End If
        FAv = FAv + (VAmax - VAbottom)
        
    Else
        
        'DATA FROM -90->90
        'TOP SIDE
        For v = indexV To UBound(intensity, 2)
            If intensity(indexH, v, 3) <= Ifield Then    'STOP WHEN LESS THAN 1/10 MAX
                va1 = intensity(indexH, v - 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v - 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        VAtop = va1 + ((Ifield - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        FAv = VAtop - VAmax
        
        'BOTTOM SIDE
        For v = indexV To 1 Step -1
            If intensity(indexH, v, 3) <= Ifield Then    'STOP WHEN LESS THAN 1/10 MAX
                va1 = intensity(indexH, v + 1, 2)
                va2 = intensity(indexH, v, 2)
                i1 = intensity(indexH, v + 1, 3)
                i2 = intensity(indexH, v, 3)
                Exit For
            End If
        Next v
        VAbottom = va1 + ((Ifield - i1) / (i2 - i1)) * (va2 - va1) 'Half angle
        FAv = FAv + (VAmax - VAbottom)
    End If
End Function

Public Function FieldAngleC(header, lum, intensity, FA)
    'FIND THE FIELD ANGLE FOR A TYPE C PHOTOMETRIC FILE.
    'FIELD ANGLE IS FULL ANGLE BETWEEN TWO 1/10th MAX CANDELA ON EITHER SIDE OF THE PEAK CD.
    Dim v, h As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim Itenth As Double    '1/10 maximum candela value
    Dim VAmax As Double     'Vertical angle of max candela
    Dim HAmax As Double     'Horizontal angle of max candela
    
    'FIND MAX INTENSITY
    Imax = 0
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            If intensity(h, v, 3) > Imax Then
                Imax = intensity(h, v, 3)
                HAmax = intensity(h, v, 1)
                VAmax = intensity(h, v, 2)
                indexH = h
                indexV = v
            End If
        Next v
    Next h
    Itenth = Imax / 10
    
    'ASSIGN THE TWO HORIZONTAL PLANES TO CONSIDER
    Dim indexVcount As Integer
    indexVcount = UBound(intensity, 2) * 2 - 2
    Dim intensityPlane() As Double
    ReDim intensityPlane(1 To 1, 1 To indexVcount, 1 To 3) As Double
    Dim HAneg, HApos As Double
    HApos = HAmax
    HAneg = HApos + 180
    If HAneg > 360 Then
        HAneg = HAneg - 360
    End If
    
    'LOAD intensityPlane with the max plane, and the 180 degree plane from the max plane
    Dim countV As Integer
    countV = 1
    'LOAD NEGATIVE PLANE
    For v = UBound(intensity, 2) - 1 To 2 Step -1
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HAneg, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2) * -1
        countV = countV + 1
    Next v
    'LOAD POSITIVE PLANE
    For v = 1 To UBound(intensity, 2)
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HApos, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2)
        countV = countV + 1
'        If countV = 142 Then
'            Debug.Print "countV = 142"
'        End If
    Next v
    'Debug.Print "IntensityPlane Loaded!!"

    'FIND THE MAX INTENSITY INDEX IN THE NEW INTENSITYPLANE ARRAY
    Imax = 0
    'For h = 1 To UBound(intensityPlane, 1)
        For v = 1 To UBound(intensityPlane, 2)
            If intensityPlane(1, v, 3) > Imax Then
                Imax = intensityPlane(1, v, 3)
                HAmax = intensityPlane(1, v, 1)
                VAmax = intensityPlane(1, v, 2)
                indexH = 1
                indexV = v
            End If
        Next v
    'Next h

'----------------------------------------------------------------------------------------
'trying new code for finding two angles 4/14/15

    'CLOCKWISE
    Dim va1, va2 As Double  'Bounding VA's for half max
    Dim i1, i2 As Double    'Bounding intensity values at bounding angles
    Dim VAhigh As Double        'VA for half max
    Dim foundH As Boolean
    foundH = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v + 1
        If v > UBound(intensityPlane, 2) Then
            v = 1
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Itenth Then
            va1 = intensityPlane(indexH, v - 1, 2)
            va2 = intensityPlane(indexH, v, 2)
            i1 = intensityPlane(indexH, v - 1, 3)
            i2 = intensityPlane(indexH, v, 3)
            foundH = True
            Exit Do
        End If
    Loop
    If foundH Then
        VAhigh = va1 + ((Itenth - i1) / (i2 - i1)) * (va2 - va1)
    End If

    'CCW
    Dim VAlow
    Dim foundL As Boolean
    foundL = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v - 1
        If v < 1 Then
            v = UBound(intensityPlane, 2)
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Itenth Then
            va1 = intensityPlane(indexH, v, 2)
            va2 = intensityPlane(indexH, v + 1, 2)
            i1 = intensityPlane(indexH, v, 3)
            i2 = intensityPlane(indexH, v + 1, 3)
            foundL = True
            Exit Do
        End If
    Loop
    If foundL Then
        VAlow = va1 + ((Itenth - i1) / (i2 - i1)) * (va2 - va1)
    End If
    
    'Debug.Print "VAlow : " & VAlow
    'Debug.Print "VAmax : " & VAmax
    'Debug.Print "VAhigh: " & VAhigh

    Dim FAccw, FAcw As Double
    If foundL And foundH Then
        '---------CCW---------------
        If VAhigh > VAmax Then
            FAccw = VAhigh - VAmax
        Else
            FAccw = (180 - VAmax) + (VAhigh - (-180))
        End If
        '---------CW----------------
        If VAlow < VAmax Then
            FAcw = VAmax - VAlow
        Else
            FAcw = (180 - VAlow) + (VAmax - (-180))
        End If
        '------------------------
        FA = FAccw + FAcw
    Else
        FA = 0
    End If


'    'FIND UPPER BOUND V-ANGLE OF 1/10th MAX IN INTENSITYPLANE ARRAY
'    Dim VA1, VA2 As Double  'Bounding VA's for half max
'    Dim i1, i2 As Double    'Bounding intensity values at bounding angles
'    Dim VAhigh As Double        'VA for half max
'    Dim foundH As Boolean
'    foundH = False
'    For v = indexV To UBound(intensityPlane, 2)
'        If intensityPlane(indexH, v, 3) <= Itenth Then
'            VA1 = intensityPlane(indexH, v - 1, 2)
'            VA2 = intensityPlane(indexH, v, 2)
'            i1 = intensityPlane(indexH, v - 1, 3)
'            i2 = intensityPlane(indexH, v, 3)
'            foundH = True
'            Exit For
'        End If
'    Next v
'    If foundH Then
'        VAhigh = VA1 + ((Itenth - i1) / (i2 - i1)) * (VA2 - VA1)
'    End If
'
'    'FIND LOWER BOUND V-ANGLE OF 1/10th MAX IN INTENSITY PLANE ARRAY
'    Dim VAlow
'    Dim foundL As Boolean
'    foundL = False
'    For v = indexV To LBound(intensityPlane, 2) Step -1
'        If intensityPlane(indexH, v, 3) <= Itenth Then
'            VA1 = intensityPlane(indexH, v, 2)
'            VA2 = intensityPlane(indexH, v + 1, 2)
'            i1 = intensityPlane(indexH, v, 3)
'            i2 = intensityPlane(indexH, v + 1, 3)
'            foundL = True
'            Exit For
'        End If
'    Next v
'    If foundL Then
'        VAlow = VA1 + ((Itenth - i1) / (i2 - i1)) * (VA2 - VA1)
'    End If
'
'    If foundL And foundH Then
'        FA = VAhigh - VAlow  'High is a positive, low if on the opposite side of nadir is negative
'    Else
'        FA = 0
'    End If
    
End Function

Public Function FieldAngleCInputHA(intensity, HA, FA)
    'FIND THE FIELD ANGLE FOR A TYPE C PHOTOMETRIC FILE.
    'FIELD ANGLE IS FULL ANGLE BETWEEN TWO 1/10th MAX CANDELA ON EITHER SIDE OF THE PEAK CD.
    Dim v, h As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim Itenth As Double    '1/10 maximum candela value
    Dim VAmax As Double     'Vertical angle of max candela
    Dim HAmax As Double     'Horizontal angle of max candela
    
'FIND MAX INTENSITY
Imax = 0
For h = 1 To UBound(intensity, 1)
    For v = 1 To UBound(intensity, 2)
        If intensity(h, v, 3) > Imax Then
            Imax = intensity(h, v, 3)
            HAmax = intensity(h, v, 1)
            VAmax = intensity(h, v, 2)
            indexH = h
            indexV = v
        End If
    Next v
Next h
Itenth = Imax / 10
    
    'ASSIGN THE TWO HORIZONTAL PLANES TO CONSIDER
    Dim indexVcount As Integer
    indexVcount = UBound(intensity, 2) * 2 - 2
    Dim intensityPlane() As Double
    ReDim intensityPlane(1 To 1, 1 To indexVcount, 1 To 3) As Double
    Dim HAneg, HApos As Double
'    HApos = HAmax
'    HAneg = HApos + 180
    
    If HA < 180 Then
        HApos = HA
        HAneg = HA + 180
    Else
        HApos = HA - 180
        HAneg = HA
    End If
    
    If HAneg > 360 Then
        HAneg = HAneg - 360
    End If
    
    'LOAD intensityPlane with the max plane, and the 180 degree plane from the max plane
    Dim countV As Integer
    countV = 1
    'LOAD NEGATIVE PLANE
    For v = UBound(intensity, 2) - 1 To 2 Step -1
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HAneg, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2) * -1
        countV = countV + 1
    Next v
    'LOAD POSITIVE PLANE
    For v = 1 To UBound(intensity, 2)
        Call IES.GetIESIntensity(intensity, intensity(1, v, 2), HApos, intensityPlane(1, countV, 3))
        intensityPlane(1, countV, 1) = HApos
        intensityPlane(1, countV, 2) = intensity(1, v, 2)
        countV = countV + 1
'        If countV = 142 Then
'            Debug.Print "countV = 142"
'        End If
    Next v
    'Debug.Print "IntensityPlane Loaded!!"

    'FIND THE MAX INTENSITY INDEX IN THE NEW INTENSITYPLANE ARRAY
    Imax = 0
    'For h = 1 To UBound(intensityPlane, 1)
        For v = 1 To UBound(intensityPlane, 2)
            If intensityPlane(1, v, 3) > Imax Then
                Imax = intensityPlane(1, v, 3)
                HAmax = intensityPlane(1, v, 1)
                VAmax = intensityPlane(1, v, 2)
                indexH = 1
                indexV = v
            End If
        Next v
    'Next h
'Itenth = Imax / 2   turn this on to only look at the max in the single plane of concern (not what photopia uses for BA calc...)

'----------------------------------------------------------------------------------------
'trying new code for finding two angles 4/14/15

    'CLOCKWISE
    Dim va1, va2 As Double  'Bounding VA's for half max
    Dim i1, i2 As Double    'Bounding intensity values at bounding angles
    Dim VAhigh As Double        'VA for half max
    Dim foundH As Boolean
    foundH = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v + 1
        If v > UBound(intensityPlane, 2) Then
            v = 1
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Itenth Then
            va1 = intensityPlane(indexH, v - 1, 2)
            va2 = intensityPlane(indexH, v, 2)
            i1 = intensityPlane(indexH, v - 1, 3)
            i2 = intensityPlane(indexH, v, 3)
            foundH = True
            Exit Do
        End If
    Loop
    If foundH Then
        VAhigh = va1 + ((Itenth - i1) / (i2 - i1)) * (va2 - va1)
    End If

    'CCW
    Dim VAlow
    Dim foundL As Boolean
    foundL = False
    v = indexV
    countV = 0
    Do While countV < UBound(intensityPlane, 2)
        v = v - 1
        If v < 1 Then
            v = UBound(intensityPlane, 2)
        End If
        countV = countV + 1
        If intensityPlane(indexH, v, 3) <= Itenth Then
            va1 = intensityPlane(indexH, v, 2)
            va2 = intensityPlane(indexH, v + 1, 2)
            i1 = intensityPlane(indexH, v, 3)
            i2 = intensityPlane(indexH, v + 1, 3)
            foundL = True
            Exit Do
        End If
    Loop
    If foundL Then
        VAlow = va1 + ((Itenth - i1) / (i2 - i1)) * (va2 - va1)
    End If
    
    'Debug.Print "VAlow : " & VAlow
    'Debug.Print "VAmax : " & VAmax
    'Debug.Print "VAhigh: " & VAhigh

    Dim FAccw, FAcw As Double
    If foundL And foundH Then
        '---------CCW---------------
        If VAhigh > VAmax Then
            FAccw = VAhigh - VAmax
        Else
            FAccw = (180 - VAmax) + (VAhigh - (-180))
        End If
        '---------CW----------------
        If VAlow < VAmax Then
            FAcw = VAmax - VAlow
        Else
            FAcw = (180 - VAlow) + (VAmax - (-180))
        End If
        '------------------------
        FA = FAccw + FAcw
    Else
        FA = 0
    End If

    
End Function

Public Function FieldLumensB(intensity, lumens, intensityMax, Flumens)
    'CALCULATE Field LUMENS
'    Dim lumensField As Double
'    Dim insideField As Integer
'    Dim binI() As Double
'    Dim binL() As Double
'    Dim dVAbin, dHAbin As Double
'    Dim numVAbin, numHAbin As Integer
'    Dim binSize As Double
    Dim v, v2, h, h2 As Integer
    Dim Iave As Double
'    Dim VA1, VA2, HA1, HA2 As Double
    'Dim VA1, VA2, HA1, HA2 As Double
    Dim mult As Integer
    Dim Vmin, Vmax, Hmin, Hmax As Double
    Dim Vdiff, Hdiff As Double

    'TYPE B - FLOOD
    Vmin = intensity(1, 1, 2)
    Vmax = intensity(1, UBound(intensity, 2), 2)
    Vdiff = Vmax - Vmin
    Hmin = intensity(1, 1, 1)
    Hmax = intensity(UBound(intensity, 1), 1, 1)
    Hdiff = Hmax - Hmin
    mult = 1
    If Vdiff = 90 Then
        mult = mult + 1
    End If
    If Hdiff = 90 Then
        mult = mult + 1
    End If

    For v = 1 To UBound(lumens, 2)
        For h = 1 To UBound(lumens, 1)
        
'            Debug.Print "V/H: " & v & "/" & h
''                If v = 7 And h = 1 Then
''                    Debug.Print "stop"
''                End If
'
'            insideField = 0
'            If intensity(h, v, 3) >= intensityMax / 10 Then
'                insideField = insideField + 1
'            End If
'            If intensity(h, v + 1, 3) >= intensityMax / 10 Then
'                insideField = insideField + 1
'            End If
'            If intensity(h + 1, v, 3) >= intensityMax / 10 Then
'                insideField = insideField + 1
'            End If
'            If intensity(h + 1, v + 1, 3) >= intensityMax / 10 Then
'                insideField = insideField + 1
'            End If
'

            Iave = intensity(h, v, 3) + _
                   intensity(h + 1, v, 3) + _
                   intensity(h, v + 1, 3) + _
                   intensity(h + 1, v + 1, 3)
            Iave = Iave / 4
            If Iave >= intensityMax / 10 Then
                Flumens = Flumens + lumens(h, v)
            End If



'
'            If insideField = 4 Then
'                'COUNT WHOLE BIN
'                Flumens = Flumens + lumens(h, v)
'            ElseIf insideField > 0 Then
'                binSize = 0.25
'                'DESCRETIZE BIN FURTHER FOR LUMEN SUM
'                dVAbin = intensity(h, v + 1, 2) - intensity(h, v, 2)
'                dHAbin = intensity(h + 1, v, 1) - intensity(h, v, 1)
'
'                'BREAK INTO 0.25deg BINS
'                If Application.RoundDown(dVAbin / binSize, 0) <> dVAbin / binSize Then
'                    'NOT EVENLY DIVISIBLE
'                    numVAbin = Application.RoundDown(dVAbin / binSize, 0) + 2
'                Else
'                    numVAbin = dVAbin / binSize + 1
'                End If
'                If Application.RoundDown(dHAbin / binSize, 0) <> dHAbin / binSize Then
'                    'NOT EVENLY DIVISIBLE
'                    numHAbin = Application.RoundDown(dHAbin / binSize, 0) + 2
'                Else
'                    numHAbin = dHAbin / binSize + 1
'                End If
'
'                'GET INTENSITIES FOR SUB BIN CORNERS
'                ReDim binI(1 To numHAbin, 1 To numVAbin, 1 To 3)
'                ReDim binL(1 To UBound(binI, 1) - 1, 1 To UBound(binI, 2) - 1)
'                For v2 = 1 To numVAbin - 1
'                    For h2 = 1 To numHAbin - 1
'                        binI(h2, v2, 1) = intensity(h, v, 1) + (h2 - 1) * binSize
'                        binI(h2, v2, 2) = intensity(h, v, 2) + (v2 - 1) * binSize
'                        Call IES.GetIESIntensityB(intensity, binI(h2, v2, 2), binI(h2, v2, 1), binI(h2, v2, 3))
'                    Next h2
'                Next v2
'                'LAST ROW/COLUMN (in case not evenly divisible by 0.25 deg
'                For h2 = 1 To numHAbin - 1
'                    binI(h2, numVAbin, 1) = intensity(h, v, 1) + (h2 - 1) * binSize
'                    binI(h2, numVAbin, 2) = intensity(h, v + 1, 2)
'                    Call IES.GetIESIntensityB(intensity, intensity(h, v + 1, 2), binI(h2, v2, 1), binI(h2, v2, 3))
'                Next h2
'                For v2 = 1 To numVAbin - 1
'                    binI(numHAbin, v2, 1) = intensity(h + 1, v, 1)
'                    binI(numHAbin, v2, 2) = intensity(h, v, 2) + (v2 - 1) * binSize
'                    Call IES.GetIESIntensityB(intensity, binI(h2, v2, 2), intensity(h + 1, v, 1), binI(numHAbin, v2, 3))
'                Next v2
'                binI(numHAbin, numVAbin, 1) = intensity(h + 1, v + 1, 1)
'                binI(numHAbin, numVAbin, 2) = intensity(h + 1, v + 1, 2)
'                Call IES.GetIESIntensityB(intensity, binI(numHAbin, numVAbin, 2), binI(numHAbin, numVAbin, 1), binI(numHAbin, numVAbin, 3))
'
''                'OUTPUT TO CHECK
''                Sheet2.Cells.ClearContents
''                For v2 = 1 To numVAbin
''                    Sheet2.Cells(v2 + 1, 1) = binI(1, v2, 2)
''                Next v2
''                For h2 = 1 To numHAbin
''                    Sheet2.Cells(1, h2 + 1) = binI(h2, 1, 1)
''                Next h2
''                For h2 = 1 To numHAbin
''                    For v2 = 1 To numVAbin
''                        Sheet2.Cells(v2 + 1, h2 + 1) = binI(h2, v2, 3)
''                    Next v2
''                Next h2
'
'                'CALCULATE SUB BIN LUMENS
'                For v2 = 1 To UBound(binL, 2)
'                    For h2 = 1 To UBound(binL, 1)
'                        Iave = binI(h2, v2, 3) + _
'                               binI(h2, v2 + 1, 3) + _
'                               binI(h2 + 1, v2, 3) + _
'                               binI(h2 + 1, v2 + 1, 3)
'                        Iave = Iave / 4
'                        VA1 = binI(h2, v2, 2)
'                        VA2 = binI(h2, v2 + 1, 2)
'                        HA1 = binI(h2, v2, 1) + 90   '+ 90 to convert to the poles as 0 and 180 deg
'                        HA2 = binI(h2 + 1, v2, 1) + 90
'                        binL(h2, v2) = (VA2 - VA1) * dtr * Iave * (Cos(HA1 * dtr) - Cos(HA2 * dtr))
'                    Next h2
'                Next v2
'
'                'RE CHECK WHICH BINS ARE ALL-IN THE Field
'                For v2 = 1 To UBound(binL, 2)
'                    For h2 = 1 To UBound(binL, 1)
'                        insideField = 0
'                        If binI(h2, v2, 3) >= intensityMax / 10 Then
'                            insideField = insideField + 1
'                        End If
'                        If binI(h2, v2 + 1, 3) >= intensityMax / 10 Then
'                            insideField = insideField + 1
'                        End If
'                        If binI(h2 + 1, v2, 3) >= intensityMax / 10 Then
'                            insideField = insideField + 1
'                        End If
'                        If binI(h2 + 1, v2 + 1, 3) >= intensityMax / 10 Then
'                            insideField = insideField + 1
'                        End If
'                        If insideField = 4 Then
'                            'ALL CORNERS IN THE Field
'                            Flumens = Flumens + binL(h2, v2)
'                        End If
'                    Next h2
'                Next v2
'
'            End If
            
        Next h
    Next v
    
    Flumens = Flumens * mult
    
End Function


Public Function BeamAnglePlane(PlaneIntensity, BA)
  'FIND THE BEAM ANGLE FOR A TYPE C PHOTOMETRIC FILE AND SPECIFIC HORIZONTAL ANGLE
    'BEAM ANGLE IS FULL ANGLE BETWEEN HALF MAXES ON EITHER SIDE OF NADIR.
    Dim v, h As Integer
    Dim indexV, indexH As Integer
    Dim Imax As Double      'Maximum candela value
    Dim Ihalf As Double     '1/2 maximum candela value
    Dim VAmax As Double     'Vertical angle of max candela
    Dim HAmax As Double     'Horizontal angle of max candela
    
    
    'FIND MAX INTENSITY
    Imax = 0
    For h = 1 To UBound(PlaneIntensity, 1)
        For v = 1 To UBound(PlaneIntensity, 2)
            If PlaneIntensity(h, v, 3) > Imax Then
                Imax = PlaneIntensity(h, v, 3)
                HAmax = PlaneIntensity(h, v, 1)
                VAmax = PlaneIntensity(h, v, 2)
                indexH = h
                indexV = v
            End If
        Next v
    Next h
    Ihalf = Imax / 2
    
    'FIND V-ANGLE ANGLE OF HALF MAX
    Dim va1, va2 As Double  'Bounding VA's for half max
    Dim i1, i2 As Double    'Bounding Intensity values at bounding angles
    Dim VA As Double        'VA for half max
    For v = indexV To UBound(PlaneIntensity, 2)
        If PlaneIntensity(indexH, v, 3) <= Ihalf Then
            va1 = PlaneIntensity(indexH, v - 1, 2)
            va2 = PlaneIntensity(indexH, v, 2)
            i1 = PlaneIntensity(indexH, v - 1, 3)
            i2 = PlaneIntensity(indexH, v, 3)
            Exit For
        End If
    Next v
    
    VA = va1 + ((Ihalf - i1) / (i2 - i1)) * (va2 - va1)
    
    BA = VA * 2

End Function



Public Function BeamLumensB(intensity, lumens, intensityMax, Blumens)
    'CALCULATE BEAM LUMENS
'    Dim lumensBeam As Double
'    Dim insideBeam As Integer
'    Dim binI() As Double
'    Dim binL() As Double
'    Dim dVAbin, dHAbin As Double
'    Dim numVAbin, numHAbin As Integer
'    Dim binSize As Double
    Dim v, v2, h, h2 As Integer
    Dim Iave As Double
'    Dim VA1, VA2, HA1, HA2 As Double
    Dim mult As Integer
    Dim Vmin, Vmax, Hmin, Hmax As Double
    Dim Vdiff, Hdiff As Double

    'TYPE B - FLOOD
    Vmin = intensity(1, 1, 2)
    Vmax = intensity(1, UBound(intensity, 2), 2)
    Vdiff = Vmax - Vmin
    Hmin = intensity(1, 1, 1)
    Hmax = intensity(UBound(intensity, 1), 1, 1)
    Hdiff = Hmax - Hmin
    mult = 1
    If Vdiff = 90 Then
        mult = mult + 1
    End If
    If Hdiff = 90 Then
        mult = mult + 1
    End If

    For v = 1 To UBound(lumens, 2)
        For h = 1 To UBound(lumens, 1)
        
'            Debug.Print "V/H: " & v & "/" & h
'                If v = 7 And h = 1 Then
'                    Debug.Print "stop"
'                End If
            
'            insideBeam = 0
'            If intensity(h, v, 3) >= intensityMax / 2 Then
'                insideBeam = insideBeam + 1
'            End If
'            If intensity(h, v + 1, 3) >= intensityMax / 2 Then
'                insideBeam = insideBeam + 1
'            End If
'            If intensity(h + 1, v, 3) >= intensityMax / 2 Then
'                insideBeam = insideBeam + 1
'            End If
'            If intensity(h + 1, v + 1, 3) >= intensityMax / 2 Then
'                insideBeam = insideBeam + 1
'            End If

            Iave = intensity(h, v, 3) + _
                   intensity(h + 1, v, 3) + _
                   intensity(h, v + 1, 3) + _
                   intensity(h + 1, v + 1, 3)
            Iave = Iave / 4
            If Iave >= intensityMax / 2 Then
                Blumens = Blumens + lumens(h, v)
            End If
            
'            If insideBeam = 4 Then
'                'COUNT WHOLE BIN
'                Blumens = Blumens + lumens(h, v)
''            ElseIf insideBeam >= 2 Then
''                Blumens = Blumens + lumens(h, v)
'            ElseIf insideBeam > 0 Then
'                binSize = 0.25
'                'DESCRETIZE BIN FURTHER FOR LUMEN SUM
'                dVAbin = intensity(h, v + 1, 2) - intensity(h, v, 2)
'                dHAbin = intensity(h + 1, v, 1) - intensity(h, v, 1)
'
'                'BREAK INTO 0.25deg BINS
'                If Application.RoundDown(dVAbin / binSize, 0) <> dVAbin / binSize Then
'                    'NOT EVENLY DIVISIBLE
'                    numVAbin = Application.RoundDown(dVAbin / binSize, 0) + 2
'                Else
'                    numVAbin = dVAbin / binSize + 1
'                End If
'                If Application.RoundDown(dHAbin / binSize, 0) <> dHAbin / binSize Then
'                    'NOT EVENLY DIVISIBLE
'                    numHAbin = Application.RoundDown(dHAbin / binSize, 0) + 2
'                Else
'                    numHAbin = dHAbin / binSize + 1
'                End If
'
'                'GET INTENSITIES FOR SUB BIN CORNERS
'                ReDim binI(1 To numHAbin, 1 To numVAbin, 1 To 3)
'                ReDim binL(1 To UBound(binI, 1) - 1, 1 To UBound(binI, 2) - 1)
'                For v2 = 1 To numVAbin - 1
'                    For h2 = 1 To numHAbin - 1
'                        binI(h2, v2, 1) = intensity(h, v, 1) + (h2 - 1) * binSize
'                        binI(h2, v2, 2) = intensity(h, v, 2) + (v2 - 1) * binSize
'                        Call IES.GetIESIntensityB(intensity, binI(h2, v2, 2), binI(h2, v2, 1), binI(h2, v2, 3))
'                    Next h2
'                Next v2
'                'LAST ROW/COLUMN (in case not evenly divisible by 0.25 deg
'                For h2 = 1 To numHAbin - 1
'                    binI(h2, numVAbin, 1) = intensity(h, v, 1) + (h2 - 1) * binSize
'                    binI(h2, numVAbin, 2) = intensity(h, v + 1, 2)
'                    Call IES.GetIESIntensityB(intensity, intensity(h, v + 1, 2), binI(h2, v2, 1), binI(h2, v2, 3))
'                Next h2
'                For v2 = 1 To numVAbin - 1
'                    binI(numHAbin, v2, 1) = intensity(h + 1, v, 1)
'                    binI(numHAbin, v2, 2) = intensity(h, v, 2) + (v2 - 1) * binSize
'                    Call IES.GetIESIntensityB(intensity, binI(h2, v2, 2), intensity(h + 1, v, 1), binI(numHAbin, v2, 3))
'                Next v2
'                binI(numHAbin, numVAbin, 1) = intensity(h + 1, v + 1, 1)
'                binI(numHAbin, numVAbin, 2) = intensity(h + 1, v + 1, 2)
'                Call IES.GetIESIntensityB(intensity, binI(numHAbin, numVAbin, 2), binI(numHAbin, numVAbin, 1), binI(numHAbin, numVAbin, 3))
'
''                'OUTPUT TO CHECK
''                Sheet2.Cells.ClearContents
''                For v2 = 1 To numVAbin
''                    Sheet2.Cells(v2 + 1, 1) = binI(1, v2, 2)
''                Next v2
''                For h2 = 1 To numHAbin
''                    Sheet2.Cells(1, h2 + 1) = binI(h2, 1, 1)
''                Next h2
''                For h2 = 1 To numHAbin
''                    For v2 = 1 To numVAbin
''                        Sheet2.Cells(v2 + 1, h2 + 1) = binI(h2, v2, 3)
''                    Next v2
''                Next h2
'
'                'CALCULATE SUB BIN LUMENS
'                For v2 = 1 To UBound(binL, 2)
'                    For h2 = 1 To UBound(binL, 1)
'                        Iave = binI(h2, v2, 3) + _
'                               binI(h2, v2 + 1, 3) + _
'                               binI(h2 + 1, v2, 3) + _
'                               binI(h2 + 1, v2 + 1, 3)
'                        Iave = Iave / 4
'                        VA1 = binI(h2, v2, 2)
'                        VA2 = binI(h2, v2 + 1, 2)
'                        HA1 = binI(h2, v2, 1) + 90   '+ 90 to convert to the poles as 0 and 180 deg
'                        HA2 = binI(h2 + 1, v2, 1) + 90
'                        binL(h2, v2) = (VA2 - VA1) * dtr * Iave * (Cos(HA1 * dtr) - Cos(HA2 * dtr))
'                    Next h2
'                Next v2
'
'                'RE CHECK WHICH BINS ARE ALL-IN THE BEAM
'                For v2 = 1 To UBound(binL, 2)
'                    For h2 = 1 To UBound(binL, 1)
'                        insideBeam = 0
'                        If binI(h2, v2, 3) >= intensityMax / 2 Then
'                            insideBeam = insideBeam + 1
'                        End If
'                        If binI(h2, v2 + 1, 3) >= intensityMax / 2 Then
'                            insideBeam = insideBeam + 1
'                        End If
'                        If binI(h2 + 1, v2, 3) >= intensityMax / 2 Then
'                            insideBeam = insideBeam + 1
'                        End If
'                        If binI(h2 + 1, v2 + 1, 3) >= intensityMax / 2 Then
'                            insideBeam = insideBeam + 1
'                        End If
'                        If insideBeam = 4 Then
'                            'ALL CORNERS IN THE BEAM
'                            Blumens = Blumens + binL(h2, v2)
'                        End If
'                    Next h2
'                Next v2

'            End If
            
        Next h
    Next v
    
    Blumens = Blumens * mult
    
End Function




Public Function BUG(typeIESNA, FL, FM, FH, FVH, BL, BM, BH, BVH, UL, UH, ByRef Brating, ByRef Urating, ByRef Grating) ', ByRef UGrating)
    'B.U.G. RATINGS (IESNA TM-15-07)______________________________________________________________________________________________________________
    'THESE ARE  MODIFICATIONS TO THE TABLES PROVIDED BY BECKY RAINER
    ' FEBRUARY 2011
    'THESE VALUES FINALIZED IN TM-15-11
    
    'Dim Brating As String
    'Dim Urating As String
    'Dim Grating As String
    
    If BH <= 110 And BM <= 220 And BL <= 110 Then
        Brating = "B0"
    ElseIf BH <= 500 And BM <= 1000 And BL <= 500 Then
        Brating = "B1"
    ElseIf BH <= 1000 And BM <= 2500 And BL <= 1000 Then
        Brating = "B2"
    ElseIf BH <= 2500 And BM <= 5000 And BL <= 2500 Then
        Brating = "B3"
    ElseIf BH <= 5000 And BM <= 8500 And BL <= 5000 Then
        Brating = "B4"
    Else 'If BH > 5000 Or BM > 8500 Or BL > 5000 Then
        Brating = "B5"
    End If
    
    If UH <= 0 And UL <= 0 Then 'And FVH <= 10 And BVH <= 10 Then
        Urating = "U0"
    ElseIf UH <= 10 And UL <= 10 Then 'And FVH <= 75 And BVH <= 75 Then
        Urating = "U1"
    ElseIf UH <= 50 And UL <= 50 Then 'And FVH <= 150 And BVH <= 150 Then
        Urating = "U2"
    ElseIf UH <= 500 And UL <= 500 Then 'And FVH > 150 10 And BVH > 150 Then
        Urating = "U3"
    ElseIf UH <= 1000 And UL <= 1000 Then
        Urating = "U4"
    Else
        Urating = "U5"
    End If
    
    If typeIESNA <> "V" And typeIESNA <> "VS" Then
        If FVH <= 10 And BVH <= 10 And FH <= 660 And BH <= 110 Then
            Grating = "G0"
        ElseIf FVH <= 100 And BVH <= 100 And FH <= 1800 And BH <= 500 Then
            Grating = "G1"
        ElseIf FVH <= 225 And BVH <= 225 And FH <= 5000 And BH <= 1000 Then
            Grating = "G2"
        ElseIf FVH <= 500 And BVH <= 500 And FH <= 7500 And BH <= 2500 Then
            Grating = "G3"
        ElseIf FVH <= 750 And BVH <= 750 And FH <= 12000 And BH <= 5000 Then
            Grating = "G4"
        Else 'If FVH > 750 Or BVH > 750 Or FH > 12000 Or BH > 5000 Then
            Grating = "G5"
        End If
    Else
        If FVH <= 10 And BVH <= 10 And FH <= 660 And BH <= 660 Then
            Grating = "G0"
        ElseIf FVH <= 100 And BVH <= 100 And FH <= 1800 And BH <= 1800 Then
            Grating = "G1"
        ElseIf FVH <= 225 And BVH <= 225 And FH <= 5000 And BH <= 5000 Then
            Grating = "G2"
        ElseIf FVH <= 500 And BVH <= 500 And FH <= 7500 And BH <= 7500 Then
            Grating = "G3"
        ElseIf FVH <= 750 And BVH <= 750 And FH <= 12000 And BH <= 12000 Then
            Grating = "G4"
        Else 'If FVH > 750 Or BVH > 750 Or FH > 12000 Or BH > 5000 Then
            Grating = "G5"
        End If
    End If
    
'    If Right(Grating, 1) > Right(Urating, 1) Then
'        UGrating = "UG" & Right(Grating, 1)
'    Else
'        UGrating = "UG" & Right(Urating, 1)
'    End If
    
End Function

Public Function BUG2007(FL, FM, FH, FVH, BL, BM, BH, BVH, UL, UH, ByRef Brating, ByRef Urating, ByRef Grating)
    'B.U.G. RATINGS (IESNA TM-15-07)______________________________________________________________________________________________________________
    'Dim Brating As String
    'Dim Urating As String
    'Dim Grating As String
    
    If BH <= 110 And BM <= 220 And BL <= 110 Then
        Brating = "B0"
    ElseIf BH <= 500 And BM <= 1000 And BL <= 500 Then
        Brating = "B1"
    ElseIf BH <= 1000 And BM <= 2500 And BL <= 1000 Then
        Brating = "B2"
    ElseIf BH <= 2500 And BM <= 5000 And BL <= 2500 Then
        Brating = "B3"
    ElseIf BH <= 5000 And BM <= 8500 And BL <= 5000 Then
        Brating = "B4"
    Else 'If BH > 5000 Or BM > 8500 Or BL > 5000 Then
        Brating = "B5"
    End If
    
    If UH <= 0 And UL <= 0 And FVH <= 10 And BVH <= 10 Then
        Urating = "U0"
    ElseIf UH <= 10 And UL <= 10 And FVH <= 75 And BVH <= 75 Then
        Urating = "U1"
    ElseIf UH <= 100 And UL <= 100 And FVH <= 150 And BVH <= 150 Then
        Urating = "U2"
    ElseIf UH <= 500 And UL <= 500 Then 'And FVH > 150 10 And BVH > 150 Then
        Urating = "U3"
    ElseIf UH <= 1000 And UL <= 1000 Then
        Urating = "U4"
    Else
        Urating = "U5"
    End If
    
    If FVH <= 10 And BVH <= 10 And FH <= 660 And BH <= 110 Then
        Grating = "G0"
    ElseIf FVH <= 250 And BVH <= 250 And FH <= 1800 And BH <= 500 Then
        Grating = "G1"
    ElseIf FVH <= 375 And BVH <= 375 And FH <= 5000 And BH <= 1000 Then
        Grating = "G2"
    ElseIf FVH <= 500 And BVH <= 500 And FH <= 7500 And BH <= 2500 Then
        Grating = "G3"
    ElseIf FVH <= 750 And BVH <= 750 And FH <= 12000 And BH <= 5000 Then
        Grating = "G4"
    Else 'If FVH > 750 Or BVH > 750 Or FH > 12000 Or BH > 5000 Then
        Grating = "G5"
    End If

End Function

Function ConvertIES_TypeCtoB(ByRef intensityC() As Double, ByVal lumC, ByRef intensityB() As Double, ByRef lumB)
    
    Dim MH As Double
    
    Dim vB As Integer           'Vertical index of the type B intensity array.
    Dim hB As Integer           'Horizontal index of the type B intensity array.
    
    Dim vAngleC As Double       'Equivelant vertical angle for the current point in the type-B coordinate system.
    Dim hAngleC As Double       'Equivelant horizontal angle for the current point in the type-B coordinate system.
    
    Dim dMH As Double           'Distance across the road.
    Dim dForward As Double      'Distance from the luminaire head down to the road at dMH in the 0-degree plane (perp to the curbline).
    Dim dxy As Double           'Diatance on the ground to the point.
    Dim dRoad As Double         'Distance down the curbline away from the luminaire.
    
    MH = 1
    
    For vB = 1 To UBound(intensityB, 2)
        'Debug.Print "-------------------------"
        'Debug.Print "VA(B) = " & intensityB(1, vB, 2)
        dMH = MH * Tan(dtr * intensityB(1, vB, 2))
        dForward = Sqr(dMH ^ 2 + MH ^ 2)
        
        For hB = 1 To UBound(intensityB, 1)
            dRoad = dForward * Tan(dtr * intensityB(hB, vB, 1))
            dxy = Sqr(dRoad ^ 2 + dMH ^ 2)
            vAngleC = rtd * Atn(dxy / MH)
            If dxy <> 0 Then
                Call Math.ACOS(dMH / dxy, hAngleC)
            Else
                hAngleC = 0
            End If
            hAngleC = hAngleC * rtd
            If intensityB(hB, vB, 1) > 0 Then
                hAngleC = 360 - hAngleC
            End If
            Call IES.GetIESIntensity(intensityC, vAngleC, hAngleC, intensityB(hB, vB, 3))
            'Debug.Print "  HA(B) = " & intensityB(hB, vB, 1)
            'Debug.Print "    HA(C) = " & hAngleC
            'Debug.Print "    VA(C) = " & vAngleC
        Next hB
    Next vB
End Function



Function ConvertIES_TypeBtoC(ByRef intensityC() As Double, ByRef lumC, ByRef intensityB() As Double, ByVal lumB)
    'YOU MUST PASS A PRE-DEFINED INTENSITYC ARRAY AND LUMC VARIABLE.  IT STEPS THROUGH THE
    'ANGLES DEFINED IN THAT ARRAY AND ASSIGNS THE RIGHT INTENSITY BASED ON THE INTENSITYB ARRAY
    'PASSED.
    
    Dim h, v As Integer                 'index for intensityC
    Dim haC, vaC As Double              'type c angles in degrees
    Dim haCRad, vaCRad As Double        'type c angles in radians
    Dim vecC(1 To 1, 1 To 3) As Double
    
    Dim haB, vaB As Double              'type b angles in degrees
    Dim i As Double                     'intensity for current angle
    
    For h = 1 To UBound(intensityC, 1)
    
        haC = intensityC(h, 1, 1)
        haCRad = haC * dtr
        
        For v = 1 To UBound(intensityC, 2)
        
            vaC = intensityC(h, v, 2)
            vaCRad = vaC * dtr
            Call Math.RayFromAngles(vaCRad, haCRad, vecC)           'get vector from the type C angles
            Call Math.AnglesFromRayB(vecC, vaB, haB)                'get type B angles from the vector
            Call IES.GetIESIntensityB(intensityB, vaB, haB, i)      'get the intensity from the type B angles
            intensityC(h, v, 3) = i                                 'assign the intensity to the type C array
            
        Next v
        
    Next h
    
End Function



Function CopyIESAll(ByVal lum, ByRef lum2, ByRef intensity() As Double, ByRef intensity2() As Double, ByRef header() As String, ByRef header2() As String)
    lum2.BallastFactor = lum.BallastFactor
    lum2.fileName = lum.fileName
    lum2.GeneralMultiplier = lum.GeneralMultiplier
    lum2.InputWatts = lum.InputWatts
    lum2.LampLumens = lum.LampLumens
    lum2.LampToLuminaire = lum.LampToLuminaire
    lum2.LuminousHeight = lum.LuminousHeight
    lum2.LuminousLength = lum.LuminousLength
    lum2.LuminousWidth = lum.LuminousWidth
    lum2.NumberLamps = lum.NumberLamps
    lum2.NumHAngles = lum.NumHAngles
    lum2.NumTiltAngles = lum.NumTiltAngles
    lum2.NumVAngles = lum.NumVAngles
    lum2.PhotometryType = lum.PhotometryType
    lum2.units = lum.units
    Dim v, h As Integer
    ReDim intensity2(1 To UBound(intensity, 1), 1 To UBound(intensity, 2), 1 To 3) As Double
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            intensity2(h, v, 1) = intensity(h, v, 1)
            intensity2(h, v, 2) = intensity(h, v, 2)
            intensity2(h, v, 3) = intensity(h, v, 3)
        Next v
    Next h
    ReDim header2(1 To UBound(header)) As String
    For h = 1 To UBound(header)
        header2(h) = header(h)
    Next h
End Function

Function CopyIESClass(ByVal lum, ByRef lum2)
    lum2.BallastFactor = lum.BallastFactor
    lum2.fileName = lum.fileName
    lum2.GeneralMultiplier = lum.GeneralMultiplier
    lum2.InputWatts = lum.InputWatts
    lum2.LampLumens = lum.LampLumens
    lum2.LampToLuminaire = lum.LampToLuminaire
    lum2.LuminousHeight = lum.LuminousHeight
    lum2.LuminousLength = lum.LuminousLength
    lum2.LuminousWidth = lum.LuminousWidth
    lum2.NumberLamps = lum.NumberLamps
    lum2.NumHAngles = lum.NumHAngles
    lum2.NumTiltAngles = lum.NumTiltAngles
    lum2.NumVAngles = lum.NumVAngles
    lum2.PhotometryType = lum.PhotometryType
    lum2.units = lum.units
End Function

Function CoefficientOfUtilization(lum, intensity, LampLumens, lumLumens, zonalLumens, rf, rc, rw, RCR, ByRef CU)
    'This function calculates the coefficient of utilization for a given floor (rw), wall(rw), and ceiling (rc) reflectance, and room
    'cavity ration (RCR).
    
    'PROCEDURE OUTLINES IN: ILLUMINATING ENGINEERING SOCIETY'S LIGHTING HANDBOOK 10th EDITION,
        'PAGE 10.40, SECTION 10.11.3 Calculating Lumen Method Coefficient of Utilization
    
    
    Dim v As Integer
    Dim n As Integer
    Const e = 2.71828182846
    
    Dim lumensUP, lumensDOWN As Double  'Up and downlight lumens
    Dim effUP, effDOWN As Double        'Up and down efficiency
    Dim Krcr(0 To 8) As Double          'Zonal multiplier for calculating CU
    Dim A(0 To 8) As Double                 'constants for calculating Krcr
    Dim b(0 To 8) As Double                 'constanta for calculating Krcr
    
   'Dim Fww(0 To 10) As Double                   'Form factors between all room surfaces
   ' Dim Fwc(0 To 10), Fwf(0 To 10) As Double       'Only need the Fcf for CU calculation
   ' Dim Fcw(0 To 10), Ffw(0 To 10) As Double
    Dim Fcf(0 To 10) As Double
    'dim Ffc(0 To 10) As Double
    
    Dim c1, c2, c3, C0 As Double
    
    'CONSTANTS
    A(0) = 0
    A(1) = 0.041
    A(2) = 0.07
    A(3) = 0.1
    A(4) = 0.136
    A(5) = 0.19
    A(6) = 0.315
    A(7) = 0.64
    A(8) = 2.1
    
    b(0) = 0
    b(1) = 0.98
    b(2) = 1.05
    b(3) = 1.12
    b(4) = 1.16
    b(5) = 1.25
    b(6) = 1.25
    b(7) = 1.25
    b(8) = 0.8
    
    'FORM FACTORS - FOR EACH RCR
    'Fww(0) = 0:::::: Fwc(0) = 0.5:::: Fwf(0) = 0.5:::: Fcw(0) = 0:::::: Ffw(0) = 0:::::: Fcf(0) = 1:::::: Ffc(0) = 1        'RCR=0
    'Fww(1) = 0.133:: Fwc(1) = 0.434:: Fwf(1) = 0.434:: Fcw(1) = 0.173:: Ffw(1) = 0.173:: Fcf(1) = 0.827:: Ffc(1) = 0.827    'RCR=1
    'Fww(2) = 0.224:: Fwc(2) = 0.388:: Fwf(2) = 0.388:: Fcw(2) = 0.311:: Ffw(2) = 0.311:: Fcf(2) = 0.689:: Ffc(2) = 0.689    'RCR=2
    'Fww(3) = 0.289:: Fwc(3) = 0.351:: Fwf(3) = 0.351:: Fcw(3) = 0.421:: Ffw(3) = 0.421:: Fcf(3) = 0.579:: Ffc(3) = 0.579    'RCR=3
    'Fww(4) = 0.361:: Fwc(4) = 0.32::: Fwf(4) = 0.32::: Fcw(4) = 0.511:: Ffw(4) = 0.511:: Fcf(4) = 0.489:: Ffc(4) = 0.489    'RCR=4
    'Fww(5) = 0.415:: Fwc(5) = 0.292:: Fwf(5) = 0.292:: Fcw(5) = 0.585:: Ffw(5) = 0.585:: Fcf(5) = 0.415:: Ffc(5) = 0.415    'RCR=5
    'Fww(6) = 0.463:: Fwc(6) = 0.269:: Fwf(6) = 0.269:: Fcw(6) = 0.645:: Ffw(6) = 0.645:: Fcf(6) = 0.355:: Ffc(6) = 0.355    'RCR=6
    'Fww(7) = 0.504:: Fwc(7) = 0.248:: Fwf(7) = 0.248:: Fcw(7) = 0.649:: Ffw(7) = 0.649:: Fcf(7) = 0.306:: Ffc(7) = 0.306    'RCR=7
    'Fww(8) = 0.54::: Fwc(8) = 0.23::: Fwf(8) = 0.23::: Fcw(8) = 0.735:: Ffw(8) = 0.735:: Fcf(8) = 0.265:: Ffc(8) = 0.265    'RCR=8
    'Fww(9) = 0.573:: Fwc(9) = 0.214:: Fwf(9) = 0.214:: Fcw(9) = 0.769:: Ffw(9) = 0.769:: Fcf(9) = 0.231:: Ffc(9) = 0.231    'RCR=9
    'Fww(10) = 0.601: Fwc(10) = 0.199: Fwf(10) = 0.199: Fcw(10) = 0.798: Ffw(10) = 0.798: Fcf(10) = 0.202: Ffc(10) = 0.202   'RCR=10
    
    Fcf(0) = 1      'RCR=0
    Fcf(1) = 0.827  'RCR=1
    Fcf(2) = 0.689  'RCR=2
    Fcf(3) = 0.579  'RCR=3
    Fcf(4) = 0.489  'RCR=4
    Fcf(5) = 0.415  'RCR=5
    Fcf(6) = 0.355  'RCR=6
    Fcf(7) = 0.306  'RCR=7
    Fcf(8) = 0.265  'RCR=8
    Fcf(9) = 0.231  'RCR=9
    Fcf(10) = 0.202 'RCR=10
    
    
    
    'EFFICIENCY
    lumensDOWN = 0
    For n = 0 To 8
        lumensDOWN = lumensDOWN + zonalLumens(n)
    Next n
    lumensUP = 0
    For n = 9 To 17
        lumensUP = lumensUP + zonalLumens(n)
    Next n
    
    If lum.LampLumens <> -1 Then
        effDOWN = lumensDOWN / LampLumens
        effUP = lumensUP / LampLumens
    Else
        effDOWN = lumensDOWN / lumLumens
        effUP = lumensUP / lumLumens
    End If
    
    'DIRECT RATIO (Drcr) - fraction of flux below the horizontal directly incident on the workplane:
    Dim Drcr As Double
    Dim sum As Double   'temporary summation
    sum = 0
    For n = 0 To 8
        Krcr(n) = e ^ ((-A(n)) * (RCR ^ b(n)))
        sum = sum + (Krcr(n) * zonalLumens(n))
    Next n
    
    If lum.LampLumens <> -1 Then
        If effDOWN <> 0 Then                                'added this if 3/17/15 for indirect luminaires
            Drcr = (1 / (effDOWN * LampLumens)) * sum
        Else
            Drcr = 0
        End If
    Else
        If effDOWN <> 0 Then
            Drcr = (1 / (effDOWN * lumLumens)) * sum
        Else
            Drcr = 0
        End If
    End If
    
    If RCR <> 0 Then
        
        'Intermediate Parameters:
        c1 = ((1 - rw) * (1 - Fcf(RCR) ^ 2) * RCR)
        c1 = c1 / (2.5 * rw * (1 - Fcf(RCR) ^ 2) + RCR * Fcf(RCR) * (1 - rw))
        c2 = (1 - rc) * (1 + Fcf(RCR)) / (1 + rc * Fcf(RCR))
        c3 = (1 - rf) * (1 + Fcf(RCR)) / (1 + rf * Fcf(RCR))
        C0 = c1 + c2 + c3
        
        'CU
        CU = (2.5 * rw * c1 * c3 * (1 - Drcr) * effDOWN) / (RCR * (1 - rw) * (1 - rf) * C0)
        CU = CU + (rc * c2 * c3 * effUP) / ((1 - rc) * (1 - rf) * C0) + (1 - ((rf * c3 * (c1 + c2)) / ((1 - rf) * C0))) * (Drcr * effDOWN / (1 - rf))
        '    -- + --------------------------------------------------- + ----------------------------------------------- * ---------------------------
        
    Else
    
        'CU for an RCR =0
        CU = (effDOWN + rc * effUP) / (1 - rc * rf)
        
    End If
        
        
    'Thanks be to Kevin Broughton for finding that this plus sign ^ needed to be a plus and not a multiply - my copy of the handbook didn't have any
    'operator printed.  The online erratta corrected the equation to what you see here.
    
    
    
End Function

















Function Cutoff(lum, intensity() As Double, ByRef cutoffClass)
    'CUTOFF CLASSIFICATION_______________________
    Dim ImaxUP As Double
    Dim Imax80to90 As Double
    Dim Imax90 As Double
    
    Dim IRatioUp As Double
    Dim IRatio80to90 As Double
    Dim IRatio90 As Double
    'Dim Cutoff As String
    Dim Ivh As Double
    
    Dim vAngle As Double
    Dim indexV As Integer
    Dim indexV80 As Integer
    Dim indexV90 As Integer
    Dim indexH As Integer
    Dim indexH2 As Integer
    
    Dim lumLumens As Double
    
    If lum.LampLumens = -1 Then
        lumLumens = IES.GetLuminaireLumens(intensity, lum)   'If absolute photometry use the lumianrie lumens for the classification.
    Else
        lumLumens = lum.LampLumens * lum.NumberLamps
    End If
    
    ImaxUP = 0
    Imax80to90 = 0
    Imax90 = 0
    Ivh = 0
    'GET MAX CANDELA FOR UPLIGHT (90-180 degrees)
    'If intensity(1, UBound(intensity, 2), 2) = 180 Then
        For indexH = 1 To UBound(intensity, 1)
            For indexV = 1 To UBound(intensity, 2)
                If intensity(1, indexV, 2) >= 90 Then
                    If intensity(indexH, indexV, 3) > ImaxUP Then
                        ImaxUP = intensity(indexH, indexV, 3)
                    End If
                End If
            Next indexV
        Next indexH
        IRatioUp = ImaxUP / lumLumens
        IRatio90 = IRatioUp
    'End If
    
    
    'GET MAX CANDELA FROM 80 TO 89 DEGREES
    For vAngle = 80 To 89.5 Step 0.5
        For indexH = 1 To UBound(intensity, 1)
            Call IES.GetIESIntensity(intensity, vAngle, intensity(indexH, 1, 1), Ivh)
            If Ivh > Imax80to90 Then
                Imax80to90 = Ivh
            End If
        Next indexH
    Next vAngle
    IRatio80to90 = Imax80to90 / lumLumens

            
    If IRatio80to90 <= 0.1 Then
        If IRatio90 = 0 Then
            cutoffClass = "Full Cutoff"
        ElseIf IRatio90 <= 0.025 Then
            cutoffClass = "Cutoff"
        ElseIf IRatio90 <= 0.05 Then
            cutoffClass = "Semi-Cutoff"
        Else
            cutoffClass = "Non-Cutoff"
        End If
    ElseIf IRatio80to90 <= 0.2 Then
        If IRatio90 <= 0.05 Then
            cutoffClass = "Semi-Cutoff"
        Else
            cutoffClass = "Non-Cutoff"
        End If
    Else
        cutoffClass = "Non-Cutoff"
    End If
    
'    If lum.LampLumens = -1 Then
'        cutoffClass = "*" + cutoffClass     'Add an "*" to the cutoff if it is absolute photometry.
'    End If
    
End Function

Public Function GetDirectEIES(lumNum, _
                                ByRef center, _
                                IESintensity, _
                                ByRef distance, _
                                ByRef horizAngle, _
                                ByRef vertAngle, _
                                ByRef intensity, _
                                ByRef e, aperCenter)
    Dim i As Integer
    Dim j As Integer
    Dim k As Integer
    Dim m As Integer
    Dim hAngle As Double
    Dim vAngle As Double
    Dim decimalPrecision As Integer
    
    decimalPrecision = 8
    
'    ReDim distance(1 To UBound(center, 1), 1 To UBound(center, 2))
'    ReDim horizAngle(1 To UBound(center, 1), 1 To UBound(center, 2))
'    ReDim vertAngle(1 To UBound(center, 1), 1 To UBound(center, 2))
'    ReDim intensity(1 To UBound(center, 1), 1 To UBound(center, 2))
'    ReDim E(1 To UBound(center, 1), 1 To UBound(center, 2))
    
    Dim ray(1 To 1, 1 To 3) As Double   'ray form luminaire to point
    Dim rayLength As Double             'length of ray
    Dim rayXY(1 To 1, 1 To 3) As Double  'ray projected on the xy plane
    
    Dim nadir(1 To 1, 1 To 3) As Double  'vector facing zenith for the luminaire
    nadir(1, 1) = 0
    nadir(1, 2) = 0
    nadir(1, 3) = -1
    
    Dim Yaxis(1 To 1, 1 To 3) As Double 'vector facing forward (for finding the horizontal angle)
    Yaxis(1, 1) = 0
    Yaxis(1, 2) = 1
    Yaxis(1, 3) = 0
    
    For i = 1 To UBound(center, 2)  'for each column along the curb
    
        For j = 1 To UBound(center, 3)  'for each row away from the curb (across the street/behind the pole)
            'ray from luminaire to point
            ray(1, 1) = center(lumNum, i, j, 1) - aperCenter(1, 1)
            ray(1, 2) = center(lumNum, i, j, 2) - aperCenter(1, 2)
            ray(1, 3) = 0 - aperCenter(1, 3)
            
            'ray1 - ray projected on the xy plane (to get the horiz angle)
            rayXY(1, 1) = ray(1, 1)
            rayXY(1, 2) = ray(1, 2)
            rayXY(1, 3) = 0
            
            'DISTANCE (to point)
            Call Math.VectorLength(ray, distance(lumNum, i, j))
            
            'VERTIACL ANGLE (insident ray to point normal)
            Call Math.AngleBetweenVectors(ray, nadir, vAngle)       'returns angle in radians
            vAngle = Round(vAngle * rtd, decimalPrecision)          'convert to degrees
            vertAngle(lumNum, i, j) = vAngle * dtr                  'save vertical angle as radians
            
            If vAngle = 0 Then  'if the point is directly under luminaire
                hAngle = 0
                horizAngle(lumNum, i, j) = 0
                intensity(lumNum, i, j) = IESintensity(1, 1, 3)
            Else
                'HORIZONTAL ANGLE (outgoing ray from luminaire)
                Call Math.AngleBetweenVectors(rayXY, Yaxis, hAngle)
                hAngle = Round(hAngle * rtd, decimalPrecision)      'convert to degrees
                If ray(1, 1) > 0 Then                               'If the angle is in the positive x half of the coordinate system
                    hAngle = 360 - hAngle                           'Because the photometry is counter-clockwise off the y-axis
                End If
                horizAngle(lumNum, i, j) = hAngle * dtr             'save horizontal angle as radians
                'INTENSITY (to point - from iesIntensity)
                Call IES.GetIESIntensity(IESintensity, vAngle, hAngle, intensity(lumNum, i, j))
            End If
            
            'ILLUMINANCE, E
            e(lumNum, i, j) = e(lumNum, i, j) + (intensity(lumNum, i, j) * Cos(vertAngle(lumNum, i, j)) / (distance(lumNum, i, j) * distance(lumNum, i, j)))
            center(lumNum, i, j, 3) = center(lumNum, i, j, 3) + e(lumNum, i, j)
        Next j
    
    Next i
End Function

Public Function GetEfficiency(ByVal lum, ByVal intensity)
    Dim sumLumens As Double

    sumLumens = IES.GetLuminaireLumens(intensity, lum)

    If lum.NumberLamps = 0 Then
        GetEfficiency = sumLumens / (lum.LampLumens)
    Else
        GetEfficiency = sumLumens / (lum.LampLumens * lum.NumberLamps)
    End If
    
End Function

Public Function GetIESIntensityB(IESintensity, vAngleIn, hAngleIn, ByRef value)
    'THIS FUNCTION GETS AN INTENSITY FROM THE DISTRIBUTION INPUTTED BASED ON TWO INPUT
    'ANGLES TO INDEX IN THE INTENSITY DISTRIBUTION.  IT USES LINEAR, OR BI-LINEAR INTERPOLATION
    'DEPENDING ON THE INPUT ANGLES, AND HOW THEY LINE UP WITH THE DISTRIBUTION DATA.
    '
    'INPUT:
    '       iesIntensity(h, v, 1-3)     h - HAngle index.
    '                                   v - VAngle index.
    '                                   1 - HAngle / 2 - VAngle / 3 - Intensity.
    '       vAngleIn                    Vertical angle to get intensity from.
    '       hAngleIn                    Horizontal angle to get intensity from.
    'OUTPUT:
    '       value                       Intensity of the luminaire from the input angles.

    Dim vAngle As Double
    Dim hAngle As Double
    Dim maxVAngle As Double                 'For checking how high vertical angle readings go (basically 90 or 180)
    'HORIZONTAL ANGLE MATCHING VARIABLES
    Dim k As Integer
    Dim k1 As Integer
    Dim k2 As Integer
    Dim h1 As Double
    Dim h2 As Double
    'VERTICAL ANGLE MATCHING VARIABLES
    Dim m As Integer
    Dim m1 As Integer
    Dim m2 As Integer
    Dim v1 As Double
    Dim v2 As Double
    'BILINEAR INTERPOLATION VARIABLES
    Dim Q11 As Double
    Dim Q12 As Double
    Dim Q21 As Double
    Dim Q22 As Double
    Dim r1 As Double
    Dim r2 As Double
    Dim P As Double
    Dim value1 As Double
    Dim value2 As Double
    Dim value3 As Double
    Dim value4 As Double
    'LINEAR INTERPOLATION VARIABLES
    Dim L1 As Double
    Dim L2 As Double
    Dim hPass As Double
    Dim Hdiff As Double
    Dim hFrac As Double
    Dim vPass As Double
    Dim Vdiff As Double
    Dim vFrac As Double
    Dim iDiff As Double
    Dim iPass As Double
    
    Dim outside As Boolean  'indicates if the input angles are outside the angle set of the file
    
    hAngle = hAngleIn
    If hAngle > 180 Then
        hAngle = hAngle - 360
    ElseIf hAngle < -180 Then
        hAngle = hAngle + 360
    End If
    vAngle = vAngleIn
    If vAngle > 180 Then
        vAngle = vAngle - 360
    ElseIf vAngle < -180 Then
        vAngle = vAngle + 360
    End If
    
    'HORIZONTAL SYMMETRY ADJUSTING--------------------------------------
    If UBound(IESintensity, 1) = 1 Then
        'SINGLE ANGLE
        hAngle = IESintensity(1, 1, 1)
    
    ElseIf IESintensity(1, 1, 1) = 0 Then
        'HORIZONTAL SYMMETRY (RIGHT DATA ONLY)
        If hAngle < 0 Then
            hAngle = -hAngle
        End If
    ElseIf IESintensity(UBound(IESintensity, 1), 1, 1) = 0 Then
        'HORIZONTAL SYMMETRY (LEFT DATA ONLY)
        If hAngle > 0 Then
            hAngle = -hAngle
        End If
    End If
    
    'VERTICAL SYMMETRY ADJUSTING----------------------------------------
    If UBound(IESintensity, 2) = 1 Then
        'SINGLE PLANE
        vAngle = IESintensity(1, 1, 2)
    
    ElseIf IESintensity(1, 1, 2) = 0 Then
        'VERTICAL SYMMETRY (TOP DATA ONLY)
        If vAngle < 0 Then
            vAngle = -vAngle
        End If
    ElseIf IESintensity(1, UBound(IESintensity, 2), 2) = 0 Then
        'VERTICAL SYMMETRY (BOTTOM DATA ONLY)
        If vAngle > 0 Then
            vAngle = -vAngle
        End If
    End If
    
    'CHECK IF OUTSIDE THE RANGE OF THE IES FILE'S ANGLE SET
    outside = False
    If Abs(vAngle) > 90 Then
        value = 0
        outside = True
    End If
    If Abs(hAngle) > 90 Then
        value = 0
        outside = True
    End If

    
    If outside = False Then
        'HORIZONTAL ANGLE MATCHING------------------------------------------
        For k = 1 To UBound(IESintensity, 1)
            If IESintensity(k, 1, 1) > hAngle Then
                'PASSED HORIZONTAL ANGLE
                h1 = IESintensity(k - 1, 1, 1)
                h2 = IESintensity(k, 1, 1)
                k1 = k - 1
                k2 = k
                Exit For
            ElseIf IESintensity(k, 1, 1) = hAngle Then
                'EXACT HORIZONTAL ANGLE MATCH
                h1 = IESintensity(k, 1, 1)
                h2 = h1
                k1 = k
                k2 = k
                Exit For
            End If
        Next k
        'VERTICAL ANGLE MATCHING---------------------------------------------
        If vAngle > IESintensity(1, UBound(IESintensity, 2), 2) Then
            value = 0
        Else
            For m = 1 To UBound(IESintensity, 2)
                If IESintensity(k, m, 2) > vAngle Then
                    'PASSED VERTICAL ANGLE
                    v1 = IESintensity(k, m - 1, 2)
                    v2 = IESintensity(k, m, 2)
                    m1 = m - 1
                    m2 = m
                    Exit For
                ElseIf IESintensity(k, m, 2) = vAngle Then
                    'EXACT VERTICAL ANGLE MATCH
                    v1 = IESintensity(k, m, 2)
                    v2 = v1
                    m1 = m
                    m2 = m
                    Exit For
                End If
            Next m
            'INTERPOLATION OF THE INTENSITY--------------------------------------
            If k1 <> k2 And m1 <> m2 Then
                'BILINEAR INTERPOLATION - neither vert or horiz angle matched angle
                Q11 = IESintensity(k1, m1, 3)
                Q12 = IESintensity(k1, m2, 3)
                Q21 = IESintensity(k2, m1, 3)
                Q22 = IESintensity(k2, m2, 3)
                r1 = ((hAngle - h2) / (h1 - h2) * Q11) + ((hAngle - h1) / (h2 - h1) * Q21)
                r2 = ((hAngle - h2) / (h1 - h2) * Q21) + ((hAngle - h1) / (h2 - h1) * Q22)
                P = ((vAngle - v2) / (v1 - v2) * r1) + ((vAngle - v1) / (v2 - v1) * r2)
                value1 = (Q11 / ((h1 - h2) * (v1 - v2))) * (hAngle - h2) * (vAngle - v2)
                value2 = (Q21 / ((h1 - h2) * (v1 - v2))) * (hAngle - h1) * (vAngle - v2)
                value3 = (Q12 / ((h1 - h2) * (v1 - v2))) * (hAngle - h2) * (vAngle - v1)
                value4 = (Q22 / ((h1 - h2) * (v1 - v2))) * (hAngle - h1) * (vAngle - v1)
                value = value1 - value2 - value3 + value4
            ElseIf k1 = k2 And m1 <> m2 Then
                'LINEAR INTERPOLATION - exact horizontal angle match
                Vdiff = v2 - v1
                vPass = vAngle - v1
                vFrac = vPass / Vdiff 'vAngle
                iDiff = IESintensity(k1, m2, 3) - IESintensity(k1, m1, 3)
                iPass = vFrac * iDiff
                value = IESintensity(k1, m1, 3) + iPass
            ElseIf k1 <> k2 And m1 = m2 Then
                'LINEAR INTERPOLATION - exact vertical angle match
                Hdiff = h2 - h1
                hPass = hAngle - h1
                hFrac = hPass / Hdiff
                iDiff = IESintensity(k2, m1, 3) - IESintensity(k1, m1, 3)
                iPass = hFrac * iDiff
                value = IESintensity(k1, m1, 3) + iPass
            ElseIf k1 = k2 And m1 = m2 Then
                'EXACT MATCH OF ANGLE
                value = IESintensity(k1, m1, 3)
            End If
        End If  'vAngle > iesIntensity(maxvAngle)
    End If  'outside = false
End Function


Public Function GetLuminaireLumens(ByVal intensity, lum) As Double
    Dim h As Double
    Dim v As Double
    Dim i As Double
    
    Dim i1 As Double
    Dim i2 As Double
    Dim i3 As Double
    Dim i4 As Double
    
    Dim dh As Double    'Change in azimuthal angle.
    Dim dv As Double    'Change in vertical angle.
    Dim dI As Double    'Zone lumens.
    
    Dim sumLumens As Double
    Dim mult As Double  'Multiplier for lumens based on the symmetry of the file
                        '   Axial = 1
                        '   Quadrilateral = 4
                        '   Bilateral = 2
                        '   Asymmetric = 1
     
    Dim Vmin As Double
    Dim Vmax As Double
    Dim Vdiff As Double
    Dim Hmin As Double
    Dim Hmax As Double
    Dim Hdiff As Double
  
    Dim h1, h2, h3, h4 As Double
    Dim v1, v2, v3, v4 As Double
    Dim iAVG As Double
  
    Vmin = intensity(1, 1, 2)
    Vmax = intensity(1, UBound(intensity, 2), 2)
    Vdiff = Vmax - Vmin
    
    Hmin = intensity(1, 1, 1)
    Hmax = intensity(UBound(intensity, 1), 1, 1)
    Hdiff = Hmax - Hmin
    
    'Debug.Print "   Vmin = " & Vmin & "  Vmax = " & Vmax & "   Vdiff = " & Vdiff
    'Debug.Print "   Hmin = " & Hmin & "  Hmax = " & Hmax & "   Hdiff = " & Hdiff
        
    'If UCase(PhotoType_ABC) = "B" Then
    If lum.PhotometryType = 2 Then 'IF TYPE B PHOTOMETRY
        'TYPE B - FLOOD
        mult = 1
        If Vdiff = 90 Then
            mult = mult + 1
        End If
        If Hdiff = 90 Then
            mult = mult + 1
        End If
        sumLumens = 0
        For h = 1 To UBound(intensity, 1) - 1
            For v = UBound(intensity, 2) To 2 Step -1
                h1 = intensity(h, v, 1)
                v1 = intensity(h, v, 2)
                i1 = intensity(h, v, 3)
                h2 = intensity(h + 1, v, 1)
                v2 = intensity(h + 1, v, 2)
                i2 = intensity(h + 1, v, 3)
                h3 = intensity(h, v - 1, 1)
                v3 = intensity(h, v - 1, 2)
                i3 = intensity(h, v - 1, 3)
                h4 = intensity(h + 1, v - 1, 1)
                v4 = intensity(h + 1, v - 1, 2)
                i4 = intensity(h + 1, v - 1, 3)
                
                iAVG = (i1 + i2 + i3 + i4) / 4
                
                h1 = h1 + 90
                h2 = h2 + 90
                dI = ((v1 - v3) * dtr) * iAVG * (Cos(h1 * dtr) - Cos(h2 * dtr))
                sumLumens = sumLumens + Abs(dI)
            Next v
        Next h
        sumLumens = sumLumens * mult
        
    Else
        'TYPE A or C - ROADWAY/INDOOR
        If Hmax = 90 Then
            mult = 4
        ElseIf Hmax = 180 Then
            mult = 2
        ElseIf Hmax = 0 Then
            mult = 0
        ElseIf Hmax = 360 Then
            mult = 1
        End If
        sumLumens = 0
        If mult <> 0 Then
            'NOT AXIALLY SYMMETRIC
            For v = 1 To UBound(intensity, 2) - 1
                For h = 1 To UBound(intensity, 1) - 1
                    h1 = intensity(h, v, 1)
                    v1 = intensity(h, v, 2)
                    i1 = intensity(h, v, 3)
                    h2 = intensity(h, v + 1, 1)
                    v2 = intensity(h, v + 1, 2)
                    i2 = intensity(h, v + 1, 3)
                    h3 = intensity(h + 1, v, 1)
                    v3 = intensity(h + 1, v, 2)
                    i3 = intensity(h + 1, v, 3)
                    h4 = intensity(h + 1, v + 1, 1)
                    v4 = intensity(h + 1, v + 1, 2)
                    i4 = intensity(h + 1, v + 1, 3)
                    iAVG = (i1 + i2 + i3 + i4) / 4
                    dI = ((h3 - h1) * dtr) * iAVG * (Cos(v1 * dtr) - Cos(v2 * dtr))
                    sumLumens = sumLumens + dI
                Next h
            Next v
            sumLumens = sumLumens * mult
        Else
            'AXIALLY SYMMETRIC
            For v = 1 To UBound(intensity, 2) - 1
                v1 = intensity(1, v, 2)
                i1 = intensity(1, v, 3)
                v2 = intensity(1, v + 1, 2)
                i2 = intensity(1, v + 1, 3)
                iAVG = (i1 + i2) / 2
                dI = 2 * PI * iAVG * (Cos(v1 * dtr) - Cos(v2 * dtr))
                sumLumens = sumLumens + dI
            Next v
        End If
    End If
  
    GetLuminaireLumens = sumLumens  'RETURN VALUE TO THE PROGRAM
End Function

Public Function GetLuminaireLumens2(ByVal intensity, PhotoType_ABC As String) As Double
    Dim h As Double
    Dim v As Double
    Dim i As Double
    
    Dim i1 As Double
    Dim i2 As Double
    Dim i3 As Double
    Dim i4 As Double
    
    Dim dh As Double    'Change in azimuthal angle.
    Dim dv As Double    'Change in vertical angle.
    Dim dI As Double    'Zone lumens.
    
    Dim sumLumens As Double
    Dim mult As Double  'Multiplier for lumens based on the symmetry of the file
                        '   Axial = 1
                        '   Quadrilateral = 4
                        '   Bilateral = 2
                        '   Asymmetric = 1
     
    Dim Vmin As Double
    Dim Vmax As Double
    Dim Vdiff As Double
    Dim Hmin As Double
    Dim Hmax As Double
    Dim Hdiff As Double
  
    Dim h1, h2, h3, h4 As Double
    Dim v1, v2, v3, v4 As Double
    Dim iAVG As Double
  
    Vmin = intensity(1, 1, 2)
    Vmax = intensity(1, UBound(intensity, 2), 2)
    Vdiff = Vmax - Vmin
    
    Hmin = intensity(1, 1, 1)
    Hmax = intensity(UBound(intensity, 1), 1, 1)
    Hdiff = Hmax - Hmin
    
    'Debug.Print "   Vmin = " & Vmin & "  Vmax = " & Vmax & "   Vdiff = " & Vdiff
    'Debug.Print "   Hmin = " & Hmin & "  Hmax = " & Hmax & "   Hdiff = " & Hdiff
        
    If UCase(PhotoType_ABC) = "B" Then
        'TYPE B - FLOOD
        mult = 1
        If Vdiff = 90 Then
            mult = mult + 1
        End If
        If Hdiff = 90 Then
            mult = mult + 1
        End If
        sumLumens = 0
        For h = 1 To UBound(intensity, 1) - 1
            For v = UBound(intensity, 2) To 2 Step -1
                h1 = intensity(h, v, 1)
                v1 = intensity(h, v, 2)
                i1 = intensity(h, v, 3)
                h2 = intensity(h + 1, v, 1)
                v2 = intensity(h + 1, v, 2)
                i2 = intensity(h + 1, v, 3)
                h3 = intensity(h, v - 1, 1)
                v3 = intensity(h, v - 1, 2)
                i3 = intensity(h, v - 1, 3)
                h4 = intensity(h + 1, v - 1, 1)
                v4 = intensity(h + 1, v - 1, 2)
                i4 = intensity(h + 1, v - 1, 3)
                
                iAVG = (i1 + i2 + i3 + i4) / 4
                
                h1 = h1 + 90
                h2 = h2 + 90
                dI = ((v1 - v3) * dtr) * iAVG * (Cos(h1 * dtr) - Cos(h2 * dtr))
                sumLumens = sumLumens + Abs(dI)
            Next v
        Next h
        sumLumens = sumLumens * mult
        
    Else
        'TYPE A or C - ROADWAY/INDOOR
        If Hmax = 90 Then
            mult = 4
        ElseIf Hmax = 180 Then
            mult = 2
        ElseIf Hmax = 0 Then
            mult = 0
        ElseIf Hmax = 360 Then
            mult = 1
        End If
        sumLumens = 0
        If mult <> 0 Then
            'NOT AXIALLY SYMMETRIC
            For v = 1 To UBound(intensity, 2) - 1
                For h = 1 To UBound(intensity, 1) - 1
                    h1 = intensity(h, v, 1)
                    v1 = intensity(h, v, 2)
                    i1 = intensity(h, v, 3)
                    h2 = intensity(h, v + 1, 1)
                    v2 = intensity(h, v + 1, 2)
                    i2 = intensity(h, v + 1, 3)
                    h3 = intensity(h + 1, v, 1)
                    v3 = intensity(h + 1, v, 2)
                    i3 = intensity(h + 1, v, 3)
                    h4 = intensity(h + 1, v + 1, 1)
                    v4 = intensity(h + 1, v + 1, 2)
                    i4 = intensity(h + 1, v + 1, 3)
                    iAVG = (i1 + i2 + i3 + i4) / 4
                    dI = ((h3 - h1) * dtr) * iAVG * (Cos(v1 * dtr) - Cos(v2 * dtr))
                    sumLumens = sumLumens + dI
                Next h
            Next v
            sumLumens = sumLumens * mult
        Else
            'AXIALLY SYMMETRIC
            For v = 1 To UBound(intensity, 2) - 1
                v1 = intensity(1, v, 2)
                i1 = intensity(1, v, 3)
                v2 = intensity(1, v + 1, 2)
                i2 = intensity(1, v + 1, 3)
                iAVG = (i1 + i2) / 2
                dI = 2 * PI * iAVG * (Cos(v1 * dtr) - Cos(v2 * dtr))
                sumLumens = sumLumens + dI
            Next v
        End If
    End If
  
    GetLuminaireLumens2 = sumLumens  'RETURN VALUE TO THE PROGRAM
End Function

Public Function GetIESFile(oFileName, ByRef header() As String, ByRef lum, ByRef intensity)
    'This function takes in a IESFile class object and assigns the information from an IES file to the variable.
    'It also takes an array of intensity values as doubles.  The array is dimensioned in the function.
    
    'This "3" version improves on previous by reading files with the information lines formatted
    '  so that each bit of information can be on separate lines or dilimited with anything not numeric.
    
    'INPUT/OUTPUT:
    '       oFileName       String for the filename with directory and extension.
    '       lum             IESFile calss object
    '                           See IESFile class Module for specific fields saved to the variable.
    '       intensity   3D array of intensity values and angles (HAngle Index, VAngle Indedx, 1 to 3)
    '                           Where (_, _, 1) = HAngle
    '                           Where (_, _, 2) = VAngle
    '                           Where (_, _, 3) = Intensity
    '                                     ^v-index
    '                                  ^h-index
    
    'WARNING:
    'Tools -> References -> Make sure the "Microsoft Scripting Runtime" reference is selected for the
    'file system object to work correctly.
    
    Dim i As Integer
    Dim j As Integer
    Dim char As String
    Dim number As String
    Dim count, countH, countV As Integer
    Dim fso As Scripting.FileSystemObject           'File System Object
    Set fso = New Scripting.FileSystemObject        'File System Object creted
    'Dim oFileName As String                         'Filename returned from the dialog
    
    Dim ies_VAngles() As Double
    Dim ies_HAngles() As Double

    'LOOP UNTIL THE FILENAME EXISTS
    'Call DialogWindows.FilePickerIES(oFileName)
    If fso.FileExists(oFileName) = False Then
        MsgBox "IES File Doesn't Exist", vbOKOnly
        Exit Function
    End If
    
    'OPEN THE FILE TO THE FSO VARIABLE
    Dim tsv As Scripting.TextStream
    Set tsv = fso.OpenTextFile(oFileName, ForReading)
    lum.fileName = fso.GetFileName(oFileName)
    
    'READ HEADER LINES
    char = tsv.ReadLine
    count = 0
    Do While UCase(Left(char, 1)) <> "T"
        count = count + 1
        If count = 1 Then
            ReDim header(1 To 1) As String
        Else
            ReDim Preserve header(1 To UBound(header, 1) + 1) As String
        End If
        'tsv.ReadLine
        header(UBound(header, 1)) = char
        char = tsv.ReadLine
        'header(UBound(header, 1)) = char
    Loop
    'char = tsv.ReadLine  'read the "TILT=NONE" line
    ReDim Preserve header(1 To UBound(header, 1) + 1) As String
    header(UBound(header, 1)) = char
    
    '--------------------------------------------------------
    
    Dim numCheck As Boolean
    'READ OPENING SPACES (UNTIL FIND A NUMBER)
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    
    'NUMBER OF LAMPS---------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.NumberLamps = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'LAMP LUMENS-------------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LampLumens = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'GENERAL MULTIPLIER------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.GeneralMultiplier = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'NUMBER OF VERTICAL TEST ANGLES------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.NumVAngles = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'NUMBER OF HORIZONTAL TEST ANGLES------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.NumHAngles = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    
    ReDim ies_VAngles(1 To lum.NumVAngles)
    ReDim ies_HAngles(1 To lum.NumHAngles)
    'ReDim ies_Angles(1 To lum.NumHAngles, 1 To lum.NumVAngles, 1 To 2)
    ReDim intensity(1 To lum.NumHAngles, 1 To lum.NumVAngles, 1 To 3)
    
    'PHOTOMETRY TYPE-----------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.PhotometryType = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'LUMINOUS MEASUREMENT UNITS------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.units = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'LUMINOUS MEASUREMENTS-----------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LuminousWidth = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LuminousLength = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LuminousHeight = Val(number)
    'If lum.LuminousHeight = 0 Then lum.LuminousHeight = 0.1
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'BALLAST FACTOR------------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.BallastFactor = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'RESERVED FOR FUTURE USE---------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    'lum. (FUTURE USE NOT STORED) = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'INPUT WATTS---------------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.InputWatts = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    
    '-----------------------------------------------------
    'VERTICAL TEST ANGLES
    countV = 0
    Do
        number = ""
        Do
            number = number + char
            char = tsv.Read(1)
            numCheck = IsNumber(char)
        Loop While (numCheck)
        countV = countV + 1
        ies_VAngles(countV) = Val(number)
        'SPACE AFTER
        Do
            char = tsv.Read(1)
            numCheck = IsNumber(char)
        Loop While Not (numCheck)
    Loop While countV < lum.NumVAngles
    '-----------------------------------------------------
    'HORIZONTAL TEST ANGLES
    countH = 0
    Do                                      'Loop through all angle numbers
        number = ""
        Do                                  'Loop through characters
            number = number + char
            char = tsv.Read(1)
            numCheck = IsNumber(char)
        Loop While (numCheck)
        countH = countH + 1
        ies_HAngles(countH) = Val(number)
        'SPACE AFTER
        Do                                  'Loop through spaces after number
            char = tsv.Read(1)
            numCheck = IsNumber(char)
        Loop While Not (numCheck)
    Loop While countH < lum.NumHAngles
    
    
    '-----------------------------------------------------
    'INTENSITIES
    countV = 0
    countH = 0
    Do
        countH = countH + 1
        countV = 0
        Do
            number = ""
            Do
                number = number + char
                On Error Resume Next
                char = tsv.Read(1)
                If Err = 62 Then    'end of file
                    'Debug.Print Err
                    Exit Do
                End If
                numCheck = IsNumber(char)
            Loop While (numCheck)
            countV = countV + 1
            intensity(countH, countV, 1) = ies_HAngles(countH)                   'Horizontal angle
            intensity(countH, countV, 2) = ies_VAngles(countV)                   'Vertical angle
            intensity(countH, countV, 3) = Val(number) * lum.GeneralMultiplier  'Intensity

            'SPACE AFTER
            Do
                On Error Resume Next
                char = tsv.Read(1)
                If Err = 62 Then    'end of file
                    'Debug.Print Err
                    Exit Do
                End If
                numCheck = IsNumber(char)
            Loop While Not (numCheck)
        Loop While countV < lum.NumVAngles
    Loop While countH < lum.NumHAngles
    
    lum.GeneralMultiplier = 1   'reset this because it was already applied to the intensities when read
    tsv.Close
    
End Function

Public Function GetOWLFile(oFileName, ByRef header() As String, ByRef lum, ByRef intensity)
    'This function takes in a IESFile class object and assigns the information from an IES file to the variable.
    'It also takes an array of intensity values as doubles.  The array is dimensioned in the function.
    
    'This "3" version improves on previous by reading files with the information lines formatted
    '  so that each bit of information can be on separate lines or dilimited with anything not numeric.
    
    'INPUT/OUTPUT:
    '       oFileName       String for the filename with directory and extension.
    '       lum             IESFile calss object
    '                           See IESFile class Module for specific fields saved to the variable.
    '       intensity   3D array of intensity values and angles (HAngle Index, VAngle Indedx, 1 to 3)
    '                           Where (_, _, 1) = HAngle
    '                           Where (_, _, 2) = VAngle
    '                           Where (_, _, 3) = Intensity
    '                                     ^v-index
    '                                  ^h-index
    
    'WARNING:
    'Tools -> References -> Make sure the "Microsoft Scripting Runtime" reference is selected for the
    'file system object to work correctly.
    
    Dim i As Integer
    Dim j As Integer
    Dim h As Integer
    Dim v As Integer
    Dim char As String
    Dim number As String
    Dim count, countH, countV As Integer
    Dim fso As Scripting.FileSystemObject           'File System Object
    Set fso = New Scripting.FileSystemObject        'File System Object creted
    'Dim oFileName As String                         'Filename returned from the dialog
    
    Dim ies_VAngles() As Double
    Dim ies_HAngles() As Double

    'LOOP UNTIL THE FILENAME EXISTS
    'Call DialogWindows.FilePickerIES(oFileName)
    If fso.FileExists(oFileName) = False Then
        MsgBox "IES File Doesn't Exist", vbOKOnly
        Exit Function
    End If
    
    'OPEN THE FILE TO THE FSO VARIABLE
    Dim tsv As Scripting.TextStream
    Set tsv = fso.OpenTextFile(oFileName, ForReading)
    lum.fileName = fso.GetFileName(oFileName)
    
    'READ HEADER LINES
    char = tsv.ReadLine
    count = 0
    Do While UCase(Left(char, 4)) <> "TILT"
        count = count + 1
        If count = 1 Then
            ReDim header(1 To 1) As String
        Else
            ReDim Preserve header(1 To UBound(header, 1) + 1) As String
        End If
        'tsv.ReadLine
        header(UBound(header, 1)) = char
        char = tsv.ReadLine
        'header(UBound(header, 1)) = char
    Loop
    'char = tsv.ReadLine  'read the "TILT=NONE" line
    ReDim Preserve header(1 To UBound(header, 1) + 1) As String
    header(UBound(header, 1)) = char
    
    '-----------------------------------------------------------
    'Look for the "Absolute photometry constant:", and assign that to the
    'lum.FutureUse field of the lum variable
    Dim strLoc As Integer
    Dim numCheck As Boolean
    For h = 1 To UBound(header)
        strLoc = InStr(1, header(h), "ABSOLUTE PHOTOMETRY CONSTANT:", vbTextCompare)
        If strLoc <> 0 Then
            'Debug.Print "stop"
            i = Len(header(h))
            i = i - 29 - 2
            char = Right(header(h), i)
            numCheck = IsNumber(char)
            If numCheck = False Then
                lum.FutureUse = 1
            Else
                lum.FutureUse = Val(char)
            End If
            
        End If
    Next h
      
    '--------------------------------------------------------
    
    
    'READ OPENING SPACES (UNTIL FIND A NUMBER)
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    
    'NUMBER OF LAMPS---------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.NumberLamps = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'LAMP LUMENS-------------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LampLumens = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'GENERAL MULTIPLIER------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.GeneralMultiplier = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'NUMBER OF VERTICAL TEST ANGLES------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.NumVAngles = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'NUMBER OF HORIZONTAL TEST ANGLES------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.NumHAngles = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    
    ReDim ies_VAngles(1 To lum.NumVAngles)
    ReDim ies_HAngles(1 To lum.NumHAngles)
    'ReDim ies_Angles(1 To lum.NumHAngles, 1 To lum.NumVAngles, 1 To 2)
    ReDim intensity(1 To lum.NumHAngles + 1, 1 To lum.NumVAngles, 1 To 3)
                                        '+1 because owl files don't include 360 - i add it at the end
    
    'PHOTOMETRY TYPE-----------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.PhotometryType = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'LUMINOUS MEASUREMENT UNITS------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.units = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'LUMINOUS MEASUREMENTS-----------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LuminousWidth = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LuminousLength = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.LuminousHeight = Val(number)
    'If lum.LuminousHeight = 0 Then lum.LuminousHeight = 0.1
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'BALLAST FACTOR------------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.BallastFactor = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'RESERVED FOR FUTURE USE---------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    'lum.FutureUse = Val(number)
    'lum. (FUTURE USE NOT STORED) = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    'INPUT WATTS---------------------------
    number = ""
    Do
        number = number + char
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While (numCheck)
    lum.InputWatts = Val(number)
    'SPACE AFTER
    Do
        char = tsv.Read(1)
        numCheck = IsNumber(char)
    Loop While Not (numCheck)
    
    '-----------------------------------------------------
    'VERTICAL TEST ANGLES
    countV = 0
    Do
        number = ""
        Do
            number = number + char
            char = tsv.Read(1)
            numCheck = IsNumber(char)
        Loop While (numCheck)
        countV = countV + 1
        ies_VAngles(countV) = Val(number)
        'SPACE AFTER
        Do
            char = tsv.Read(1)
            numCheck = IsNumber(char)
        Loop While Not (numCheck)
    Loop While countV < lum.NumVAngles
    '-----------------------------------------------------
    'DARK CURRENT READINGS - DISREGARD (CARLOS B. 11-20-2013)
    char = tsv.ReadLine
    Do
        char = tsv.ReadLine 'read all the dark current lines
        strLoc = InStr(1, char, "lateral angle", vbTextCompare) 'check if reach the first bank of data
    Loop While strLoc = 0
    '-----------------------------------------------------
    

    
    
    '-----------------------------------------------------
    'INTENSITIES
    countV = 0
    countH = 0
    Do 'HA LOOP
        countH = countH + 1
        countV = 0
        char = Left(char, strLoc - 1)
        ies_HAngles(countH) = Val(char)
        char = tsv.Read(1)
        Do 'VA LOOP
            number = ""
            Do
                number = number + char
                char = tsv.Read(1)
                numCheck = IsNumber(char)
            Loop While (numCheck)
            countV = countV + 1
            intensity(countH, countV, 1) = ies_HAngles(countH)                   'Horizontal angle
            intensity(countH, countV, 2) = ies_VAngles(countV)                   'Vertical angle
            intensity(countH, countV, 3) = Val(number) * lum.GeneralMultiplier  'Intensity

            'SPACE AFTER
            Do
                On Error Resume Next
                char = tsv.Read(1)
                If Err = 62 Then    'end of file
                    Debug.Print Err
                    Exit Do
                End If
                numCheck = IsNumber(char)
            Loop While Not (numCheck)
        Loop While countV < lum.NumVAngles
        number = char
        char = tsv.ReadLine
        char = number + char
        strLoc = InStr(1, char, "lateral angle", vbTextCompare)
    Loop While countH < lum.NumHAngles
    
    lum.GeneralMultiplier = 1   'reset this because it was already applied to the intensities when read
    tsv.Close
    
    'OWL FILES END AT THE ANGLE BEFORE 360 - ADD 360 PLANE AS A COPY OF THE 0-DEGREE PLANE
    lum.NumHAngles = lum.NumHAngles + 1
    For v = 1 To UBound(intensity, 2)
        intensity(UBound(intensity, 1), v, 1) = 360                 'HA
        intensity(UBound(intensity, 1), v, 2) = intensity(1, v, 2)  'VA
        intensity(UBound(intensity, 1), v, 3) = intensity(1, v, 3)  'Intensity
    Next v
    
End Function


Public Function GetIESIntensity(IESintensity, vAngleIn, hAngleIn, ByRef value)
    'THIS FUNCTION GETS AN INTENSITY FROM THE DISTRIBUTION INPUTTED BASED ON TWO INPUT
    'ANGLES TO INDEX IN THE INTENSITY DISTRIBUTION.  IT USES LINEAR, OR BI-LINEAR INTERPOLATION
    'DEPENDING ON THE INPUT ANGLES, AND HOW THEY LINE UP WITH THE DISTRIBUTION DATA.
    '
    'INPUT:
    '       iesIntensity(h, v, 1-3)     h - HAngle index.
    '                                   v - VAngle index.
    '                                   1 - HAngle / 2 - VAngle / 3 - Intensity.
    '       vAngleIn                    Vertical angle to get intensity from.
    '       hAngleIn                    Horizontal angle to get intensity from.
    'OUTPUT:
    '       value                       Intensity of the luminaire from the input angles.

    Dim vAngle As Double
    Dim hAngle As Double
    'Dim maxVAngle As Double                 'For checking how high vertical angle redings go (basically 90 or 180)
    'HORIZONTAL ANGLE MATCHING VARIABLES
    Dim k As Integer
    Dim k1 As Integer
    Dim k2 As Integer
    Dim h1 As Double
    Dim h2 As Double
    'VERTICAL ANGLE MATCHING VARIABLES
    Dim m As Integer
    Dim m1 As Integer
    Dim m2 As Integer
    Dim v1 As Double
    Dim v2 As Double
    'BILINEAR INTERPOLATION VARIABLES
    Dim Q11 As Double
    Dim Q12 As Double
    Dim Q21 As Double
    Dim Q22 As Double
    Dim r1 As Double
    Dim r2 As Double
    Dim P As Double
    Dim value1 As Double
    Dim value2 As Double
    Dim value3 As Double
    Dim value4 As Double
    'LINEAR INTERPOLATION VARIABLES
    Dim L1 As Double
    Dim L2 As Double
    Dim hPass As Double
    Dim Hdiff As Double
    Dim hFrac As Double
    Dim vPass As Double
    Dim Vdiff As Double
    Dim vFrac As Double
    Dim iDiff As Double
    Dim iPass As Double
    
    hAngle = hAngleIn
    If hAngle > 360 Then
        hAngle = hAngle - 360
    End If
    vAngle = vAngleIn
    'HORIZONTAL SYMMETRY ADJUSTING--------------------------------------
    If UBound(IESintensity, 1) = 1 Then
        'AXIALLY SYMMETRIC
        hAngle = IESintensity(1, 1, 1)
    ElseIf IESintensity(UBound(IESintensity, 1), 1, 1) = 90 Then
        'QUADRILATERAL SYMMETRY
        If hAngle <= 90 Then
            'FIRST QUADRANT
            'hAngle = hAngle
        ElseIf hAngle <= 180 Then
            'SECOND QUADRANT
            hAngle = 180 - hAngle
        ElseIf hAngle <= 270 Then
            'THIRD QUADRANT
            hAngle = hAngle - 180
        Else
            'FOURTH QUADRANT
            hAngle = 360 - hAngle
        End If
    ElseIf IESintensity(UBound(IESintensity, 1), 1, 1) = 180 Then
        'BILATERAL SYMMETRY
        If hAngle <= 180 Then
            'FIRST HALF
            'hAngle = hAngle
        Else
            'SECOND HALF
            hAngle = 180 - (hAngle - 180)
        End If
    End If
    'VERTICAL SYMMETRY ADJUSTING----------------------------------------
    If UBound(IESintensity, 2) = 1 Then
        'VERTICALLY SYMMETRIC (UNIFORM SPHERE)
        vAngle = IESintensity(1, 1, 2)
    Else
        'GET VERTICAL ANGLE THROUGH MATCHING SEARCH
        'vAngle = vAngle
    End If
    'HORIZONTAL ANGLE MATCHING------------------------------------------
    For k = 1 To UBound(IESintensity, 1)
        If IESintensity(k, 1, 1) > hAngle Then
            'PASSED HORIZONTAL ANGLE
            h1 = IESintensity(k - 1, 1, 1)
            h2 = IESintensity(k, 1, 1)
            k1 = k - 1
            k2 = k
            Exit For
        ElseIf IESintensity(k, 1, 1) = hAngle Then
            'EXACT HORIZONTAL ANGLE MATCH
            h1 = IESintensity(k, 1, 1)
            h2 = h1
            k1 = k
            k2 = k
            Exit For
        End If
    Next k
    'VERTICAL ANGLE MATCHING---------------------------------------------
    If vAngle > IESintensity(1, UBound(IESintensity, 2), 2) Then
        'ANGLE IS ABOVE THE MAX VA IN THE ARRAY
        value = 0
    ElseIf vAngle < IESintensity(1, 1, 2) Then
        'ANGLE IS BELOW THE STARTING ANGLE - FILE MUST START AT 90 VA
        value = 0
    Else
        For m = 1 To UBound(IESintensity, 2)
            If IESintensity(k, m, 2) > vAngle Then
                'PASSED VERTICAL ANGLE
                v1 = IESintensity(k, m - 1, 2)
                v2 = IESintensity(k, m, 2)
                m1 = m - 1
                m2 = m
                Exit For
            ElseIf IESintensity(k, m, 2) = vAngle Then
                'EXACT VERTICAL ANGLE MATCH
                v1 = IESintensity(k, m, 2)
                v2 = v1
                m1 = m
                m2 = m
                Exit For
            End If
        Next m
        'INTERPOLATION OF THE INTENSITY--------------------------------------
        If k1 <> k2 And m1 <> m2 Then
            'BILINEAR INTERPOLATION - neither vert or horiz angle matched angle
            Q11 = IESintensity(k1, m1, 3)
            Q12 = IESintensity(k1, m2, 3)
            Q21 = IESintensity(k2, m1, 3)
            Q22 = IESintensity(k2, m2, 3)
            r1 = ((hAngle - h2) / (h1 - h2) * Q11) + ((hAngle - h1) / (h2 - h1) * Q21)
            r2 = ((hAngle - h2) / (h1 - h2) * Q21) + ((hAngle - h1) / (h2 - h1) * Q22)
            P = ((vAngle - v2) / (v1 - v2) * r1) + ((vAngle - v1) / (v2 - v1) * r2)
            value1 = (Q11 / ((h1 - h2) * (v1 - v2))) * (hAngle - h2) * (vAngle - v2)
            value2 = (Q21 / ((h1 - h2) * (v1 - v2))) * (hAngle - h1) * (vAngle - v2)
            value3 = (Q12 / ((h1 - h2) * (v1 - v2))) * (hAngle - h2) * (vAngle - v1)
            value4 = (Q22 / ((h1 - h2) * (v1 - v2))) * (hAngle - h1) * (vAngle - v1)
            value = value1 - value2 - value3 + value4
        ElseIf k1 = k2 And m1 <> m2 Then
            'LINEAR INTERPOLATION - exact horizontal angle match
            Vdiff = v2 - v1
            vPass = vAngle - v1
            vFrac = vPass / Vdiff 'vAngle
            iDiff = IESintensity(k1, m2, 3) - IESintensity(k1, m1, 3)
            iPass = vFrac * iDiff
            value = IESintensity(k1, m1, 3) + iPass
        ElseIf k1 <> k2 And m1 = m2 Then
            'LINEAR INTERPOLATION - exact vertical angle match
            Hdiff = h2 - h1
            hPass = hAngle - h1
            hFrac = hPass / Hdiff
            iDiff = IESintensity(k2, m1, 3) - IESintensity(k1, m1, 3)
            iPass = hFrac * iDiff
            value = IESintensity(k1, m1, 3) + iPass
        ElseIf k1 = k2 And m1 = m2 Then
            'EXACT MATCH OF ANGLE
            value = IESintensity(k1, m1, 3)
        End If
    End If  'vAngle > iesIntensity(maxvAngle)
End Function

Public Function IESThrow(ByRef intensity() As Double) As String
    'THROW DISTRIBUTION (SHORT/MEDIUM/LONG)
    
    Dim v, h As Integer
    Dim hAngleMax As Double
    Dim vAngleMax As Double
    Dim Imax As Double
    
    Dim xThrow As Double
    Dim dxy As Double
    Dim dx As Double
    
    'FIND MAXIMUM CANDELA VALUE AND ANGLES
    Imax = 0
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            If intensity(h, v, 3) > Imax Then
                Imax = intensity(h, v, 3)
                hAngleMax = intensity(h, v, 1)
                vAngleMax = intensity(h, v, 2)
            End If
        Next v
    Next h
    
    'CALCULATE THE THROW CLASSIFICATION
    If hAngleMax > 180 Then
        hAngleMax = hAngleMax - 180
    End If
    dxy = Tan(vAngleMax * dtr)
    If hAngleMax < 90 Then
        dx = dxy * Cos((90 - hAngleMax) * dtr)
    Else
        dx = dxy * Cos((180 - hAngleMax) * dtr)
    End If
    
    If dx <= 1 Then
        'IESThrow = "V Short"
        IESThrow = "Short"
    ElseIf dx <= 2.25 Then
        IESThrow = "Short"
    ElseIf dx <= 3.75 Then
        IESThrow = "Medium"
    ElseIf dx <= 6 Then
        IESThrow = "Long"
    Else
        IESThrow = "V Long"
    End If
End Function

Public Function IESType(ByRef intensity() As Double, ByVal lum) As String
    'TYPE DISTRIBUTION (I, II, III, IV, V)
    'PROGRAM CONVERTS THE TYPE C PHOTOMETRY TO TYPE B SO THAT THE INTENSITY VALUES CAN BE EASILY MAPPED TO A RECTANGULAR GRID ON THE ROADWAY.
    
    Dim v, h As Integer
    Dim hAngleMax As Double
    Dim vAngleMax As Double
    Dim Imax As Double
    Dim MH As Integer
    
    Dim xThrow As Double
    Dim dxy As Double
    Dim dx As Double
    Dim throw As String
    
    'TYPE B PHOTOMETRY VARIABLES
    Dim intensityB() As Double
    Dim lumB As IESFile
    Dim deltaAngle As Double
    Dim numAnglesB As Integer
    Dim vB, hB, hB1, hB2 As Integer
    
    'ROADWAY MEASUREMENT VARIABLES
    Dim dRoad1 As Double
    Dim dRoad2 As Double
    Dim dRoad As Double
    Dim dMH As Double
    Dim dForward As Double
    
    Dim iCheck As Double
    Dim VA As Double                        'Starting vertical angle for the current area being scanned.
    Dim HA As Double
    Dim found As Boolean
    
    'TYPE V vs. TYPE VS VARIABLES
    
    MH = 1
    
    'CHECK FOR TYPE V AND TYPE V SQUARE
    If intensity(UBound(intensity, 1), 1, 1) = 0 Then
        'AXIALLY SYMMETRIC
        IESType = "V"
        Exit Function
    ElseIf intensity(UBound(intensity, 1), 1, 1) = 90 Then
        'QUAD SYMMETRIC
        IESType = "V"
        Exit Function
    Else
        'CHECK FOR OCTANT SYMETRY FOR TYPE VS (IF ALL OCTANTS' LUMENS ARE W/IN +/-10% OF AVERAGE OF ALL 8 THEN TYPE VS
        Dim lumensOctAvg As Double
        Dim lumensOct(1 To 8) As Double
        Dim lumensOctDelta(1 To 8) As Double
        Dim intensityASY() As Double
        Dim lumASY As IESFile
        Dim maxDelta As Double
        'Set lumASY = New IESFile
        Call IES.SymmetryUndo(intensity, lum, intensityASY, lumASY)
'        Call IES.zoneLumens2(intensityASY, 0, 180, 0, 45, lumensOct(1))
'        Call IES.zoneLumens2(intensityASY, 0, 180, 45, 90, lumensOct(2))
'        Call IES.zoneLumens2(intensityASY, 0, 180, 90, 135, lumensOct(3))
'        Call IES.zoneLumens2(intensityASY, 0, 180, 135, 180, lumensOct(4))
'        Call IES.zoneLumens2(intensityASY, 0, 180, 180, 225, lumensOct(5))
'        Call IES.zoneLumens2(intensityASY, 0, 180, 225, 270, lumensOct(6))
'        Call IES.zoneLumens2(intensityASY, 0, 180, 270, 315, lumensOct(7))
'        Call IES.zoneLumens2(intensityASY, 0, 180, 315, 360, lumensOct(8))
        
        If intensityASY(1, 1, 2) = 0 Then
            'changing this to only look at the downlight lumens for symmetry driven type V
            Call IES.zoneLumens2(intensityASY, 0, 90, 0, 45, lumensOct(1))
            Call IES.zoneLumens2(intensityASY, 0, 90, 45, 90, lumensOct(2))
            Call IES.zoneLumens2(intensityASY, 0, 90, 90, 135, lumensOct(3))
            Call IES.zoneLumens2(intensityASY, 0, 90, 135, 180, lumensOct(4))
            Call IES.zoneLumens2(intensityASY, 0, 90, 180, 225, lumensOct(5))
            Call IES.zoneLumens2(intensityASY, 0, 90, 225, 270, lumensOct(6))
            Call IES.zoneLumens2(intensityASY, 0, 90, 270, 315, lumensOct(7))
            Call IES.zoneLumens2(intensityASY, 0, 90, 315, 360, lumensOct(8))
        ElseIf intensityASY(1, 1, 2) = 90 Then
            Call IES.zoneLumens2(intensityASY, 90, 180, 0, 45, lumensOct(1))
            Call IES.zoneLumens2(intensityASY, 90, 180, 45, 90, lumensOct(2))
            Call IES.zoneLumens2(intensityASY, 90, 180, 90, 135, lumensOct(3))
            Call IES.zoneLumens2(intensityASY, 90, 180, 135, 180, lumensOct(4))
            Call IES.zoneLumens2(intensityASY, 90, 180, 180, 225, lumensOct(5))
            Call IES.zoneLumens2(intensityASY, 90, 180, 225, 270, lumensOct(6))
            Call IES.zoneLumens2(intensityASY, 90, 180, 270, 315, lumensOct(7))
            Call IES.zoneLumens2(intensityASY, 90, 180, 315, 360, lumensOct(8))
        End If
        
        lumensOctAvg = 0
        For h = 1 To 8
            lumensOctAvg = lumensOctAvg + lumensOct(h)
        Next h
        lumensOctAvg = lumensOctAvg / 8
        maxDelta = 0
        For h = 1 To 8
            lumensOctDelta(h) = (lumensOct(h) - lumensOctAvg) / lumensOctAvg
            If lumensOctDelta(h) > maxDelta Then maxDelta = lumensOctDelta(h)
        Next h
        If maxDelta < 0.1 Then
            'TYPE VS
            IESType = "V"
            Exit Function
        End If
        
    End If
    
    'FIND MAXIMUM CANDELA VALUE AND ANGLES
    Imax = 0
    For h = 1 To UBound(intensity, 1)
        For v = 1 To UBound(intensity, 2)
            
            If intensity(1, 1, 2) = 0 Then
                'only consider downlight when finding max cd... - added 1/8/2014)
                If intensity(h, v, 2) <= 90 Then
                    If intensity(h, v, 3) > Imax Then
                        Imax = intensity(h, v, 3)
                        hAngleMax = intensity(h, v, 1)
                        vAngleMax = intensity(h, v, 2)
                    End If
                End If
            ElseIf intensity(1, 1, 2) = 90 Then
                'consider uplight as well, this file only has angles from 90-180 vertical
                If intensity(h, v, 3) > Imax Then
                    Imax = intensity(h, v, 3)
                    hAngleMax = intensity(h, v, 1)
                    vAngleMax = intensity(h, v, 2)
                End If
            End If
            
            
            
        Next v
    Next h
    
    
    'CALCULATE THE THROW CLASSIFICATION - SKIP IF THE MAX CD IS ABOVE 90 DEGREES
    If vAngleMax < 90 Then
        If hAngleMax > 180 Then
            hAngleMax = hAngleMax - 180
        End If
        dxy = Tan(vAngleMax * dtr)
        If hAngleMax < 90 Then
            dx = dxy * Cos((90 - hAngleMax) * dtr)
        Else
            'dx = dxy * Cos((180 - hAngleMax) * dtr)
            dx = dxy * Cos((hAngleMax - 90) * dtr)
        End If
        
        If dx <= 1 Then
            throw = "V Short"
            dRoad1 = 0
            dRoad2 = 1
        ElseIf dx <= 2.25 Then
            throw = "Short"
            dRoad1 = 1
            dRoad2 = 2.25
        ElseIf dx <= 3.75 Then
            throw = "Medium"
            dRoad1 = 2.25
            dRoad2 = 3.75
        ElseIf dx <= 6 Then
            throw = "Long"
            dRoad1 = 3.75
            dRoad2 = 999999
        Else
            throw = "V Long"
            dRoad1 = 3.75
            dRoad2 = 999999
        End If
    End If
    
    
    'CALCULATE THE TYPE CLASSIFICATION (based on where dx falls) - if max VA is below 90
    If vAngleMax < 90 Then
        If lum.PhotometryType = 1 Then  'type C
            'CONVERT TYPE C PHOTOMETRY TO TYPE B
            Set lumB = New IESFile
            deltaAngle = 2.5
            numAnglesB = 180 / deltaAngle + 1
            ReDim intensityB(1 To numAnglesB, 1 To numAnglesB, 1 To 3)
            lumB.BallastFactor = lum.BallastFactor
            lumB.fileName = lum.fileName
            lumB.GeneralMultiplier = lum.GeneralMultiplier
            lumB.InputWatts = lum.InputWatts
            lumB.LampLumens = lum.LampLumens
            lumB.LuminousHeight = lum.LuminousHeight
            lumB.LuminousLength = lum.LuminousLength
            lumB.LuminousWidth = lum.LuminousWidth
            lumB.NumberLamps = lum.NumberLamps
            lumB.NumHAngles = numAnglesB
            lumB.NumVAngles = numAnglesB
            lumB.PhotometryType = 2
            lumB.units = lum.units
    
            For vB = 1 To numAnglesB
                For hB = 1 To numAnglesB
                    intensityB(hB, vB, 1) = -90 + deltaAngle * (hB - 1) 'horizontal angle
                    intensityB(hB, vB, 2) = -90 + deltaAngle * (vB - 1) 'vertical angle
                    '
                Next hB
            Next vB
            Call IES.ConvertIES_TypeCtoB(intensity, lum, intensityB, lumB)
    
            found = False
            'For vB = UBound(intensityB, 2) To (numAnglesB - 1) / 2 Step -1
            For VA = 90 To 0 Step -0.5
                'VA = intensityB(1, vB, 2)
                dMH = Tan(VA * dtr) * MH                '<-- distance across the road on the ground
                For hB = 1 To UBound(intensityB, 1)
                    'HA = intensityB(hB, vB, 1)
                    HA = intensityB(hB, 1, 1)
                    dRoad = Sqr(dMH ^ 2 + MH ^ 2) * Tan(HA * dtr)
                    'Debug.Print "HA: " & Format(HA, "#00.0") & " / VA: " & Format(VA, "#00.0") & " / dRoad: " & Round(dRoad, 2)
                    'If dRoad >= dRoad1 And dRoad <= dRoad2 Then
                    If Abs(dRoad) >= dRoad1 And Abs(dRoad) <= dRoad2 Then 'this accounts for the left side of the roadway
                        'BETWEEN TRL's LOOKING AT
                        
                        Call IES.GetIESIntensity(intensityB, VA, HA, iCheck)
                        
                        'Call IES.GetIESIntensityB(intensityB, VA, HA, iCheck)
                        
                        'If intensityB(hB, vB, 3) >= (0.5 * iMax) Then
                        
                        'Debug.Print "HA: " & Format(HA, "#00.0") & " / VA: " & Format(VA, "#00.0") & " / I: " & Round(iCheck, 2)
                        'Debug.Print "                                    I: " & Round(iCheck, 2)
                        If iCheck >= (0.5 * Imax) Then
                            'FOUND 1/2 MAX CANDELA
                            found = True
                            Exit For
                        End If
                    End If
                    
                Next hB
                If found = True Then
                    Exit For
                End If
                'Debug.Print "----------------------------------"
            Next VA
            'Next vB
            
            
            If found = True Then
                If dMH >= 2.75 Then
                    IESType = "IV"
                ElseIf dMH >= 1.75 Then
                    IESType = "III"
                ElseIf dMH >= 1 Then
                    IESType = "II"
                Else
                    IESType = "I"
                End If
            End If
            
        Else
            'ALREADY TYPE B PHOTOMETRY
        End If  'type C?
    End If  'max va < 90
End Function













Public Function LCS(lum, ies_Intensity() As Double, normalizeFactor, ByRef FL, ByRef FM, ByRef FH, ByRef FVH, ByRef BL, ByRef BM, ByRef BH, ByRef BVH, ByRef UL, ByRef UH)
    'lumensFL = 0
    'PLampFL = 0
    
    Dim h As Double
    Dim v As Double
    Dim dh As Double
    Dim dv As Double
    
    Dim i1 As Double
    Dim i2 As Double
    Dim i3 As Double
    Dim i4 As Double
    
    FL = 0
    FM = 0
    FH = 0
    FVH = 0
    'LumensBL = 0
    'PLampBL = 0
    BL = 0
    BM = 0
    BH = 0
    BVH = 0
    'LumensUL = 0
    'PLampUL = 0
    UL = 0
    UH = 0
    'LumensTL = 0
    'PLampTL = 0
    
    
    'ASSIGN THE ANGLE INCREMENTS FOR THE SPECIFIC FILE
    If lum.NumHAngles = 1 Then
        dh = 1
    Else
        dh = ies_Intensity(2, 1, 1) - ies_Intensity(1, 1, 1)
    End If
    If lum.NumVAngles = 1 Then
        dv = 1
    Else
        dv = ies_Intensity(1, 2, 2) - ies_Intensity(1, 1, 2)
    End If
    'dh = 0.25
    'dv = 0.25
    
    'FORWARD LIGHT________________________________________________________________________________________________________________________________
    For v = 0 To 30 - dv Step dv    '---------------------------------------------------------------------- 0-30
        For h = 0 To 90 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
            'FL = FL +   h2 - h1     *         Iaverage                            *  cos(v1) - cos (v2)
             FL = FL + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h

        For h = 270 To 360 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
            'FL = FL +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
             FL = FL + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
    For v = 30 To 60 - dv Step dv    '---------------------------------------------------------------------- 30-60
        For h = 0 To 90 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
            'FM = FM +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
             FM = FM + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
        For h = 270 To 360 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'FM = FM +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            FM = FM + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
    For v = 60 To 80 - dv Step dv    '---------------------------------------------------------------------- 60-80
        For h = 0 To 90 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'FH = FH +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            FH = FH + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
        For h = 270 To 360 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'FH = FH +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            FH = FH + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
    For v = 80 To 90 - dv Step dv    '---------------------------------------------------------------------- 80-90
        For h = 0 To 90 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'FVH = FVH +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            FVH = FVH + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
        For h = 270 To 360 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'FVH = FVH +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            FVH = FVH + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
'    lumensFL = FL + FM + FH + FVH
'    PLampFL = lumensFL / (lum.lampLumens * lum.NumberLamps)
    
    'BACK LIGHT___________________________________________________________________________________________________________________________________
    For v = 0 To 30 - dv Step dv    '---------------------------------------------------------------------- 0-30
        For h = 90 To 270 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'BL = BL +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            BL = BL + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
            'thisBLux = (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
    For v = 30 To 60 - dv Step dv    '---------------------------------------------------------------------- 30-60
        For h = 90 To 270 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'Bm = Bm +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            BM = BM + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
    For v = 60 To 80 - dv Step dv    '---------------------------------------------------------------------- 60-80
        For h = 90 To 270 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'bh = bh +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            BH = BH + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
    For v = 80 To 90 - dv Step dv    '---------------------------------------------------------------------- 80-90
        For h = 90 To 270 - dh Step dh
            Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
            Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
            Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
           'bvh = bvh +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
            BVH = BVH + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
        Next h
    Next v
'    LumensBL = BL + BM + BH + BVH
'    PLampBL = LumensBL / (lum.lampLumens * lum.NumberLamps)

    
    'UPLIGHT______________________________________________________________________________________________________________________________________
    For v = 90 To 100 - dv Step dv    '---------------------------------------------------------------------- 90-100
        If v <= ies_Intensity(1, UBound(ies_Intensity, 2) - 1, 2) Then
            For h = 0 To 360 - dh Step dh
                Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
                Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
                Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
                Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
                'UL = UL +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
                UL = UL + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
            Next h
        End If
    Next v
    For v = 100 To 180 - dv Step dv    '---------------------------------------------------------------------- 100-180
        If v <= ies_Intensity(1, UBound(ies_Intensity, 2) - 1, 2) Then
            For h = 0 To 360 - dh Step dh
                Call IES.GetIESIntensity(ies_Intensity, v, h, i1)
                Call IES.GetIESIntensity(ies_Intensity, v + dv, h, i2)
                Call IES.GetIESIntensity(ies_Intensity, v, h + dh, i3)
                Call IES.GetIESIntensity(ies_Intensity, v + dv, h + dh, i4)
               'UH = UH +   h2 - h1     *         Iaverage          *  cos(v1) - cos (v2)
                UH = UH + (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * normalizeFactor * (Cos(v * dtr) - Cos((v + dv) * dtr)))
                'thisBLux = (((dh) * dtr) * ((i1 + i2 + i3 + i4) / 4) * (Cos(v * dtr) - Cos((v + dv) * dtr)))
            Next h
        End If
    Next v
'    LumensUL = UL + UH
'    PLampUL = LumensUL / (lum.lampLumens * lum.NumberLamps)
    
    'TRAPPED LIGHT________________________________________________________________________________________________________________________________
'    LumensTL = lum.lampLumens * lum.NumberLamps - (lumensFL + LumensBL + LumensUL)
'    PLampTL = LumensTL / (lum.lampLumens * lum.NumberLamps)
    
    'TOTAL LUMINAIRE LUMENS_______________________________________________________________________________________________________________________
'    LumensTot = lumensFL + LumensBL + LumensUL
End Function

Public Function LCS2(lum, ies_Intensity() As Double, normalizeFactor, ByRef FL, ByRef FM, ByRef FH, ByRef FVH, ByRef BL, ByRef BM, ByRef BH, ByRef BVH, ByRef UL, ByRef UH)
    'THIS VERSION USES THE ZONELUMENS2 FUNCTION WHICH TAKES A HORIZONAL AND VERTICAL INPUT AND RETURNS LUMENS.
    'THE DIFFERENCE IS DOING THAT ENSURES THAT THE CALCS USE THE ANGLE STEPS FROM THE ORIGINAL INTENSITY ARRAY
    
    'lumensFL = 0
    'PLampFL = 0
    
    Dim h As Double
    Dim v As Double
    Dim dh As Double
    Dim dv As Double
    
    Dim i1 As Double
    Dim i2 As Double
    Dim i3 As Double
    Dim i4 As Double
    
    Dim LMtemp As Double
    
    Dim lumASY As IESFile
    Set lumASY = New IESFile
    Dim ies_intensityASY() As Double
    
    FL = 0
    FM = 0
    FH = 0
    FVH = 0

    BL = 0
    BM = 0
    BH = 0
    BVH = 0

    UL = 0
    UH = 0
    
    'UNDO ANY SYMMETRY IN THE INTENSITY ARRAY BEFORE CALLING ZONELUMENS2
    Call IES.SymmetryUndo(ies_Intensity, lum, ies_intensityASY, lumASY)
    
    'FORWARD LIGHT________________________________________________________________________________________________________________________________
    Call IES.zoneLumens2(ies_intensityASY, 0, 30, 0, 90, FL)
    Call IES.zoneLumens2(ies_intensityASY, 0, 30, 270, 360, LMtemp)
    FL = FL + LMtemp
    
    Call IES.zoneLumens2(ies_intensityASY, 30, 60, 0, 90, FM)
    Call IES.zoneLumens2(ies_intensityASY, 30, 60, 270, 360, LMtemp)
    FM = FM + LMtemp
    
    Call IES.zoneLumens2(ies_intensityASY, 60, 80, 0, 90, FH)
    Call IES.zoneLumens2(ies_intensityASY, 60, 80, 270, 360, LMtemp)
    FH = FH + LMtemp
    
    Call IES.zoneLumens2(ies_intensityASY, 80, 90, 0, 90, FVH)
    Call IES.zoneLumens2(ies_intensityASY, 80, 90, 270, 360, LMtemp)
    FVH = FVH + LMtemp
    
    'BACK LIGHT___________________________________________________________________________________________________________________________________
    Call IES.zoneLumens2(ies_intensityASY, 0, 30, 90, 270, BL)
    Call IES.zoneLumens2(ies_intensityASY, 30, 60, 90, 270, BM)
    Call IES.zoneLumens2(ies_intensityASY, 60, 80, 90, 270, BH)
    Call IES.zoneLumens2(ies_intensityASY, 80, 90, 90, 270, BVH)

    'UPLIGHT______________________________________________________________________________________________________________________________________
    If ies_intensityASY(1, UBound(ies_intensityASY, 2), 2) = 90 Then
        UL = 0
        UH = 0
    Else
        Call IES.zoneLumens2(ies_intensityASY, 90, 100, 0, 360, UL)
        Call IES.zoneLumens2(ies_intensityASY, 100, 180, 0, 360, UH)
    End If
    

End Function
Public Function MirrorVertical(ByVal intensityIN, ByVal lumIN, ByRef intensityOUT, ByRef lumOUT)
    'THIS FUNCTION MIRRORS THE INTENSITY DISTRIBUTION VERTICALLY ABOUT HORIZONTAL (UPLIGHT->DOWNLIGHT / DOWNLIGHT->UPLIGHT)
    
    Dim v As Integer
    Dim h As Integer
    
    Dim maxV As Integer
    Dim maxVA, minVA As Double
    maxV = UBound(intensityIN, 2)
    maxVA = intensityIN(1, maxV, 2)
    minVA = intensityIN(1, 1, 2)
    
    '----------Temp vars to preserve the IN data if the IN and OUT are the same variables passed into this function----
    Dim lumOrig As IESFile
    Set lumOrig = New IESFile
    Dim intensityOrig() As Double
'    If maxVA <> 180 Then
'        'ADD A PLACE TO ADD 180 VA TO THE FILE
'        ReDim intensityOrig(1 To UBound(intensityIN, 1), 1 To UBound(intensityIN, 2) + 1, 1 To 3) As Double
'    ElseIf minVA <> 0 Then
'        'ADD A PLACE TO ADD 0 VA TO THE FILE
'        ReDim intensityOrig(1 To UBound(intensityIN, 1), 1 To UBound(intensityIN, 2) + 1, 1 To 3) As Double
'    Else
'        'ALREADY HAS ANGLES FROM 0 TO 180 INCLUDED
        ReDim intensityOrig(1 To UBound(intensityIN, 1), 1 To UBound(intensityIN, 2), 1 To 3) As Double
'    End If
    
    lumOrig.BallastFactor = lumIN.BallastFactor
    lumOrig.fileName = lumIN.fileName
    lumOrig.GeneralMultiplier = lumIN.GeneralMultiplier
    lumOrig.InputWatts = lumIN.InputWatts
    lumOrig.LampLumens = lumIN.LampLumens
    lumOrig.LuminousHeight = lumIN.LuminousHeight
    lumOrig.LuminousLength = lumIN.LuminousLength
    lumOrig.LuminousWidth = lumIN.LuminousWidth
    lumOrig.NumberLamps = lumIN.NumberLamps
    lumOrig.NumHAngles = lumIN.NumHAngles
    lumOrig.NumVAngles = lumIN.NumVAngles
    lumOrig.PhotometryType = lumIN.PhotometryType
    lumOrig.units = lumIN.units
    
    For v = 1 To UBound(intensityIN, 2)
        For h = 1 To UBound(intensityIN, 1)
            intensityOrig(h, v, 1) = intensityIN(h, v, 1)   'Horiz angle
            intensityOrig(h, v, 2) = intensityIN(h, v, 2)   'Vert angle
            intensityOrig(h, v, 3) = intensityIN(h, v, 3)   'Intensity
        Next h
    Next v
    
    'ADDITIONAL VERTICAL ANGLE AT 180 IF NEEDED
'    If maxVA <> 180 Then
'        For h = 1 To UBound(intensityIN, 1)
'            intensityOrig(h, v, 1) = intensityIN(h, 1, 1)
'            intensityOrig(h, v, 2) = 180
'            intensityOrig(h, v, 3) = 0
'        Next h
'        lumOUT.NumVAngles = lumOrig.NumVAngles + 1
'    ElseIf minVA <> 0 Then
'        'MOVE EVERYTHING UP ONE INDEX IN THE VA PLACE, THEN ADD THE ZERO TO THE FIRST V INDEX
'        For h = 1 To UBound(intensityIN, 1)
'            For v = UBound(intensityOrig, 2) To 2 Step -1
'                intensityOrig(h, v, 2) = intensityIN(h, v - 1, 2)   'VA
'                intensityOrig(h, v, 3) = intensityIN(h, v - 1, 3)   'intensity
'            Next v
'            intensityOrig(h, 1, 2) = 0  'VA=0
'            intensityOrig(h, 1, 3) = 0  'intensity=0
'            lumOUT.NumVAngles = lumOrig.NumVAngles + 1
'        Next h
'    Else
        lumOUT.NumVAngles = lumOrig.NumVAngles
'    End If
    
    '-------------------------------------------------------------------------------------------------------------------
    
    lumOUT.BallastFactor = lumOrig.BallastFactor
    lumOUT.fileName = lumOrig.fileName
    lumOUT.GeneralMultiplier = lumOrig.GeneralMultiplier
    lumOUT.InputWatts = lumOrig.InputWatts
    lumOUT.LampLumens = lumOrig.LampLumens
    lumOUT.LuminousHeight = lumOrig.LuminousHeight
    lumOUT.LuminousLength = lumOrig.LuminousLength
    lumOUT.LuminousWidth = lumOrig.LuminousWidth
    lumOUT.NumberLamps = lumOrig.NumberLamps
    lumOUT.NumHAngles = lumOrig.NumHAngles
    'lumOUT.NumVAngles = lumOrig.NumVAngles
    lumOUT.PhotometryType = lumOrig.PhotometryType
    lumOUT.units = lumOrig.units

    intensityOUT = intensityOrig
    maxV = UBound(intensityOrig, 2)
    maxVA = 180
    For h = 1 To UBound(intensityOrig, 1)
        For v = 1 To maxV
            intensityOUT(h, v, 1) = intensityOrig(h, v, 1)                        'horizontal angle unchanged
            intensityOUT(h, v, 2) = maxVA - intensityOrig(h, maxV - v + 1, 2)     'vertical angle mirrored
            intensityOUT(h, v, 3) = intensityOrig(h, maxV - v + 1, 3)             'intensity mirrored
        Next v
    Next h

End Function

Public Function MirrorAndSumVertical(ByVal intensityIN, ByVal lumIN, ByRef intensityOUT, ByRef lumOUT)
    'THIS FUNCTION MIRRORS THE INTENSITY DISTRIBUTION VERTICALLY ABOUT HORIZONTAL (UPLIGHT->DOWNLIGHT / DOWNLIGHT->UPLIGHT)
    'UPDATES    LUM.NUMHANGLES
    '           LUM.NUMVANGLES
    '           LUM.INPUTWATTS
    
    
    Dim v1, v2 As Integer
    Dim h1, h2 As Integer
    Dim i1, i2 As Double
    Dim index As Integer
    
    
    Dim HAarray() As Double
    Dim VAarray() As Double
    
    Dim intensityMirror() As Double
    Dim intensitySum() As Double
    Dim lumMirror As IESFile
    Set lumMirror = New IESFile
    
    Dim intensitySum() As Double        'temp in case intensityIN and intensityOUT are the same array
    
    Call IES.MirrorVertical(intensityIN, lumIN, intensityMirror, lumMirror)
    
    'Generate arrays of horizontal and vertical angles
    '   will need different indicies for each on, assign the lesser of the two angles, each time
    '   this will includ ALL angles present in each array
    '
    '   will have to pay attention to the ubound/lbound for starting and ending points
    
    'GET ALL VERTICAL ANGLES-------------------------------------------------
    v1 = 1
    v2 = 1
    index = 0
    
    Do While v1 <= UBound(intensityIN, 2) Or v2 <= UBound(intensityMirror, 2)
        index = index + 1
        ReDim Preserve VAarray(1 To index) As Double
        
        If v1 <= UBound(intensityIN, 2) And v2 <= UBound(intensityMirror, 2) Then
            If intensityIN(1, v1, 2) = intensityMirror(1, v2, 2) Then
                'EQUAL VA - SAVE AND INCREMENT V1 AND V2
                VAarray(index) = intensityIN(1, v1, 2)
                v1 = v1 + 1
                v2 = v2 + 1
            ElseIf intensityIN(1, v1, 2) < intensityMirror(1, v2, 2) Then
                'V1 MIN - SAVE AND INCREMENT V1
                VAarray(index) = intensityIN(1, v1, 2)
                v1 = v1 + 1
            Else 'If intensityIN(1, v1, 2) > intensityMirror(1, v2, 2) Then
                'V2 MIN - SAVE AND INCREMENT V2
                VAarray(index) = intensityMirror(1, v2, 2)
                v2 = v2 + 1
            End If
            
        ElseIf v1 > UBound(intensityIN, 2) Then
            'USED ALL VA IN intensityIN, use intensityMirror only
            VAarray(index) = intensityMirror(1, v2, 2)
            v2 = v2 + 1
            
        ElseIf v2 > UBound(intensityMirror, 2) Then
            'USED ALL VA IN intensityMirror, use intensityIN only
            VAarray(index) = intensityIN(1, v1, 2)
            v1 = v1 + 1
            
        End If
    Loop

    'GET ALL HORIZONTAL ANGLES-----------------------------------------------
    h1 = 1
    h2 = 1
    index = 0
    
    Do While h1 <= UBound(intensityIN, 1) Or h2 <= UBound(intensityMirror, 1)
        index = index + 1
        ReDim Preserve HAarray(1 To index) As Double
        
        If h1 <= UBound(intensityIN, 1) And h2 <= UBound(intensityMirror, 1) Then
            If intensityIN(h1, 1, 1) = intensityMirror(h2, 1, 1) Then
                'EQUAL ha - SAVE AND INCREMENT h1 AND h2
                HAarray(index) = intensityIN(h1, 1, 1)
                h1 = h1 + 1
                h2 = h2 + 1
                
            ElseIf intensityIN(h1, 1, 1) < intensityMirror(h2, 1, 1) Then
                'h1 MIN - SAVE AND INCREMENT h1
                HAarray(index) = intensityIN(h1, 1, 1)
                h1 = h1 + 1
                
            Else 'If intensityIN(h1, 1, 1) > intensityMirror(h2, 1, 1) Then
                'h2 MIN - SAVE AND INCREMENT h2
                HAarray(index) = intensityMirror(h2, 1, 1)
                h2 = h2 + 1
            End If
            
        ElseIf h1 > UBound(intensityIN, 1) Then
            'USED ALL ha IN intensityIN, use intensityMirror only
            HAarray(index) = intensityMirror(h2, 1, 1)
            h2 = h2 + 1
            
        ElseIf h2 > UBound(intensityMirror, 1) Then
            'USED ALL ha IN intensityMirror, use intensityIN only
            HAarray(index) = intensityIN(h1, 1, 1)
            h1 = h1 + 1
            
        End If
    Loop

    'DIMENSION AND ASSIGN INTENSITY VALUES FROM BOTH ARRAYS--------------------
    ReDim intensitySum(1 To UBound(HAarray), 1 To UBound(VAarray), 1 To 3) As Double
    
    For h1 = 1 To UBound(HAarray)
    
        For v1 = 1 To UBound(VAarray)
            
            Call IES.GetIESIntensity(intensityIN, VAarray(v1), HAarray(h1), i1)
            Call IES.GetIESIntensity(intensityMirror, VAarray(v1), HAarray(h1), i2)
            intensitySum(h1, v1, 1) = HAarray(h1)
            intensitySum(h1, v1, 2) = VAarray(v1)
            intensitySum(h1, v1, 3) = i1 + i2
            
        Next v1
    
    Next h1

    intensityOUT = intensitySum
    lumOUT.NumHAngles = UBound(HAarray)
    lumOUT.NumVAngles = UBound(VAarray)
    lumOUT.InputWatts = lumIN.InputWatts * 2

End Function

Public Sub ShortenHeader(header, charLen)
    'SHORTENS ALL HEADER LINES TO charLen - WRAPS LONG LINES TO INCLUDE MORE LINES BELOW WRAPPING THE TEXT
    
    Dim h As Integer
    Dim h2 As Integer
    Dim strLoc As Integer
    
    h = 1
    Do While h <= UBound(header)
        
        If Len(header(h)) > charLen Then
        
            'MAKE A [MORE] LINE TO SHORTEN THE STRING TO <=charLen CHARACTERS
            ReDim Preserve header(1 To UBound(header) + 1) As String
            For h2 = UBound(header) To h + 1 Step -1
                header(h2) = header(h2 - 1)
            Next h2
            header(h + 1) = ""
            'FIND LAST space/COMMA THAT OCCURS BEFORE CHARACTER charLen
            strLoc = InStrRev(Left(header(h), charLen), " ")
            If strLoc = 0 Then
                strLoc = InStrRev(Left(header(h), charLen), ",")
            End If
            header(h + 1) = "[MORE]" & Mid(header(h), strLoc + 1, Len(header(h)))
            header(h) = Left(header(h), strLoc - 1)
            h = h - 1
        End If
        h = h + 1
    Loop
    
End Sub



Public Function SpacingCriteria(header() As String, lum, intensity() As Double, ByRef SC0 As Double, ByRef SC90 As Double, ByRef SCDiag As Double)
'----------------------------------------------------------------------------------------------------------------
'SPACING CRITERIA CALCULATION METHOD (FROM AGI32 KNOWLEDGBASE)
'----------------------------------------------------------------------------------------------------------------
'Spacing Criteria in AGI32 and Photometric ToolboxPro is calculated per IES recommendations.
'More Information:
'The IES Handbook defines Luminaire Spacing Criterion (SC) as a classification technique for
'interior luminaires relating to the spread or distribution of the direct illuminance in a horizontal
'plane.  It further states that the luminaire spacing criterion is a design tool. It is not
'especially appropriate as a specification quantity.
'SC is based on the direct illuminance on the workplane from nearby luminaires. Since additional
'illuminance from reflections and more distant luminaires will likely add to and increase the
'uniformity of horizontal illuminance when the final measurements are taken, the SC is only a first
'approximation.
'
'How it Is calculated:
'Spacing Criteria (Horizontal) For any two luminaires whether measured in the horizontal (0-180) or
'   vertical (90-270) plane - &ldquo;Maximum spacing at a given mounting height above the work-plane
'   is chosen such that the illuminance one-half the way between the two luminaires due to both
'   luminaires equals the illuminance under one luminaire due to that one luminaire only&rdquo;.
'
'Spacing Criteria (Diagonal) considers four luminaires in a square array of adjacent luminaires -
'   Maximum spacing at a given mounting height above the work-plane is chosen such that the
'   illuminance at the center of the luminaires due to all four luminaires equals the illuminance under
'   one luminaire due to that one luminaire only.
'
'One of the problems with spacing criteria is that it assumes that the photometric distribution is
'relatively smooth. Photometric distributions that are not smooth (e.g. have large
'spikes in the intensity) may yield useless spacing criteria values.
'----------------------------------------------------------------------------------------------------------------
'----------------------------------------------------------------------------------------------------------------
    
    Dim doneSC As Boolean
    Dim x As Double
    Dim increment As Double
    Dim MH As Double
    
    'MIDDLE
    Dim VAm_rad As Double       'vertical angle to MIDDLE from lum1/lum2 (radians)
    Dim VAm_deg As Double       'vertical angle to MIDDLE from lum1/lum2 (degrees)
    Dim HAm_deg As Double       'horizontal angle to MIDDLE POINT
    Dim Dm As Double            'distance to MIDDLE from lum1/lum2
    Dim Dmxy As Double          'xy distance from lum to MIDDLE point of 4-poles
    Dim Im1 As Double           'intensity to MIDDLE from lum1
    Dim Im2 As Double           'intensity to MIDDLE from lum2
    Dim Im3 As Double           'intensity from lum3 to the MIDDLE point (4-poles)
    Dim Im4 As Double           'intensity from lum4 to the MIDDLE point (4-poles)
    Dim Em As Double
    
    'NADIR
    Dim VAn_deg As Double       'lum1 to nadir point below itself
    Dim HAn_deg As Double
    Dim Dn As Double
    Dim I0 As Double
    Dim En As Double
    
    '-----------------------------------------------------------------------------
    'CALCULATE THE SPACING CRITERIA (0-180)---------------------------------------
    doneSC = False
    x = 10
    increment = 1
    MH = 0
    Do
        MH = MH + increment
        'MIDDLE (both lum)
        Em = 0
        Dm = ((x / 2) ^ 2 + MH ^ 2) ^ (1 / 2)
        VAm_rad = Atn((x / 2) / MH)
        VAm_deg = VAm_rad * rtd
        HAm_deg = 180
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im1)
        Em = Em + (Im1 * Cos(VAm_rad) / (Dm ^ 2))
        HAm_deg = 0
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im2)
        Em = Em + (Im2 * Cos(VAm_rad) / (Dm ^ 2))
        'NADIR (one lum)
        Dn = MH
        HAn_deg = 0
        VAn_deg = 0
        Call IES.GetIESIntensity(intensity, VAn_deg, HAn_deg, I0)
        En = I0 / (Dn ^ 2)
        If Em >= En Then
            If increment = 1 Then
                MH = MH - increment
                increment = 0.1
            ElseIf increment = 0.1 Then
                MH = MH - increment
                increment = 0.001
            Else
                doneSC = True
                increment = 1
            End If
        End If
    Loop While (doneSC = False)
    SC0 = x / MH
    '------------------------------------------------------------------------------
    'CALCULATE THE SPACING CRITERIA (90-270)---------------------------------------
    doneSC = False
    x = 10
    increment = 1
    MH = 0
    Do
        MH = MH + increment
        'MIDDLE (both lum)
        Dm = ((x / 2) ^ 2 + MH ^ 2) ^ (1 / 2)
        VAm_rad = Atn((x / 2) / MH)
        VAm_deg = VAm_rad * rtd
        Em = 0
        HAm_deg = 270
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im1)
        Em = Em + (Im1 * Cos(VAm_rad) / (Dm ^ 2))
        HAm_deg = 90
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im2)
        Em = Em + (Im2 * Cos(VAm_rad) / (Dm ^ 2))
        'NADIR (one lum)
        Dn = MH
        HAn_deg = 0
        VAn_deg = 0
        Call IES.GetIESIntensity(intensity, VAn_deg, HAn_deg, I0)
        En = I0 / (Dn ^ 2)
        If Em >= En Then
            If increment = 1 Then
                MH = MH - increment
                increment = 0.1
            ElseIf increment = 0.1 Then
                MH = MH - increment
                increment = 0.001
            Else
                doneSC = True
                increment = 1
            End If
        End If
    Loop While (doneSC = False)
    SC90 = x / MH
    
    '------------------------------------------------------------------------------
    'CALCULATE THE SPACING CRITERIA (DIAG-DIRECTION)-------------------------------
    'MIDDLE POINT ILLUMINANCE
    doneSC = False
    x = 10
    increment = 1
    MH = 0
    
    Do
        MH = MH + increment
        'MIDDLE POINT
        Em = 0
        Dmxy = ((x ^ 2) / 2) ^ (1 / 2)
        Dm = (Dmxy ^ 2 + MH ^ 2) ^ (1 / 2)
        VAm_rad = Atn(Dmxy / MH)
        VAm_deg = VAm_rad * rtd
        HAm_deg = 315   'lum 1
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im1)
        Em = Em + (Im1 * Cos(VAm_rad) / (Dm ^ 2))
        HAm_deg = 45    'lum 2
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im2)
        Em = Em + (Im2 * Cos(VAm_rad) / (Dm ^ 2))
        HAm_deg = 135   'lum 3
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im3)
        Em = Em + (Im3 * Cos(VAm_rad) / (Dm ^ 2))
        HAm_deg = 235   'lum 4
        Call IES.GetIESIntensity(intensity, VAm_deg, HAm_deg, Im4)
        Em = Em + (Im4 * Cos(VAm_rad) / (Dm ^ 2))

        'NADIR POINT (lum 0 - directly over)
        Dn = MH
        VAn_deg = 0
        HAn_deg = 0
        Call IES.GetIESIntensity(intensity, VAn_deg, HAn_deg, I0)
        En = I0 / (Dn ^ 2)
        If Em >= En Then
            If increment = 1 Then
                MH = MH - increment
                increment = 0.1
            ElseIf increment = 0.1 Then
                MH = MH - increment
                increment = 0.001
            Else
                doneSC = True
                increment = 1
            End If
        End If
    Loop While (doneSC = False)
    SCDiag = x / MH
    
End Function

Public Function SymmetryUndo(ByVal intensity, ByVal lum, ByRef intensity2, ByRef lum2)
    'THIS FUNCTION TAKES IN AN INTENSITY DISTRIBUTION, AND OUTPUTS ANOTHER VARIALBLE WITH 360 DEGREES OF DATA
    'TYPE C PHOTOMETRY ONLY
    
    Dim h, v As Integer
    'Dim numHA As Integer
    Dim count As Integer
    'CREATE A NEW ASYMMETRIC LUM AND INTENSITY ARRAY FOR NEW FILE
'    Dim lum3 As IESFile
'    Set lum3 = New IESFile
    'Dim intensity2() As Double
    Dim numHA As Integer
'    Call IES.CopyIESClass(lum, lum3)
    If lum2 Is Nothing Then
        Set lum2 = New IESFile
    End If
    Call IES.CopyIESClass(lum, lum2)
    'lum2 = lum3
    
    If intensity(UBound(intensity, 1), 1, 1) = 360 Then
        'ALREADY ASYMMETRIC FILE
        'intensity2 = intensity
        ReDim intensity2(1 To UBound(intensity, 1), 1 To UBound(intensity, 2), 1 To 3) As Double
        For h = 1 To UBound(intensity, 1)
            For v = 1 To UBound(intensity, 2)
                intensity2(h, v, 1) = intensity(h, v, 1)
                intensity2(h, v, 2) = intensity(h, v, 2)
                intensity2(h, v, 3) = intensity(h, v, 3)
            Next v
        Next h
    ElseIf intensity(UBound(intensity, 1), 1, 1) = 180 Then
        'BILATERALLY SYMMETRIC - CREATE OTHER HALF
        numHA = (lum.NumHAngles - 1) * 2 + 1
        ReDim intensity2(1 To numHA, 1 To UBound(intensity, 2), 1 To 3) As Double
        lum2.NumHAngles = numHA
        '0-180 HALF
        For h = 1 To UBound(intensity, 1)
            For v = 1 To UBound(intensity, 2)
                intensity2(h, v, 1) = intensity(h, v, 1)
                intensity2(h, v, 2) = intensity(h, v, 2)
                intensity2(h, v, 3) = intensity(h, v, 3)
            Next v
        Next h
        '180 TO 360 HALF
        count = 0
        For h = UBound(intensity, 1) + 1 To UBound(intensity2, 1)
            count = count + 1
            For v = 1 To UBound(intensity, 2)
                intensity2(h, v, 1) = 360 - intensity(UBound(intensity, 1) - count, v, 1)
                intensity2(h, v, 2) = intensity(UBound(intensity, 1) - count, v, 2)
                intensity2(h, v, 3) = intensity(UBound(intensity, 1) - count, v, 3)
            Next v
        Next h
    ElseIf intensity(UBound(intensity, 1), 1, 1) = 90 Then
        'QUADRILATERALLY SYMMETRIC - CREATE OTHER THREE QUARTERS
        numHA = (lum.NumHAngles - 1) * 4 + 1
        ReDim intensity2(1 To numHA, 1 To UBound(intensity, 2), 1 To 3) As Double
        lum2.NumHAngles = numHA
        '0-90
        For h = 1 To UBound(intensity, 1)
            For v = 1 To UBound(intensity, 2)
                intensity2(h, v, 1) = intensity(h, v, 1)
                intensity2(h, v, 2) = intensity(h, v, 2)
                intensity2(h, v, 3) = intensity(h, v, 3)
            Next v
        Next h
        '90 TO 180
        count = 0
        For h = UBound(intensity, 1) + 1 To (UBound(intensity2, 1) + 1) / 2
            count = count + 1
            For v = 1 To UBound(intensity, 2)
                intensity2(h, v, 1) = 180 - intensity(UBound(intensity, 1) - count, v, 1)
                intensity2(h, v, 2) = intensity(UBound(intensity, 1) - count, v, 2)
                intensity2(h, v, 3) = intensity(UBound(intensity, 1) - count, v, 3)
            Next v
        Next h
        '180 to 360
        count = 0
        For h = (UBound(intensity2, 1) + 1) / 2 + 1 To UBound(intensity2, 1)
            count = count + 1
            For v = 1 To UBound(intensity, 2)
                intensity2(h, v, 1) = 360 - intensity2((UBound(intensity2, 1) + 1) / 2 - count, v, 1)
                intensity2(h, v, 2) = intensity2((UBound(intensity2, 1) + 1) / 2 - count, v, 2)
                intensity2(h, v, 3) = intensity2((UBound(intensity2, 1) + 1) / 2 - count, v, 3)
            Next v
        Next h
    ElseIf intensity(UBound(intensity, 1), 1, 1) = 0 Then
        'AXIALLY SYMMETRIC - CREATE ASYMMETRIC FILE WITH HA's EVERY 22.5 DEG
        numHA = 17 '22.5 degree horizontal increments
        ReDim intensity2(1 To numHA, 1 To UBound(intensity, 2), 1 To 3) As Double
        lum2.NumHAngles = numHA
        For h = 1 To UBound(intensity2, 1)
            For v = 1 To UBound(intensity, 2)
                intensity2(h, v, 1) = 22.5 * (h - 1)
                intensity2(h, v, 2) = intensity(1, v, 2)
                intensity2(h, v, 3) = intensity(1, v, 3)
            Next v
        Next h
    End If
    'On Error Resume Next
End Function

Public Function WriteIESFile(header() As String, lum, intensity() As Double, fileName As String)
    'THIS FUNCTION WRITES THE VERTICAL ANGLES, HORIZONTAL ANGLES, AND INTENSITIES
    'TO AN IES FILE WITH THE GIVEN FILENAME.
    'INPUT:
    '   header()                    As Double       Array of the header information
    '   lum                         As IESFile      Luminaire information
    '   intensityArray(h,v,1-2-3)   As Double       Array of intensities
    '                                                   1 = horizontal angle
    '                                                   2 = vertical angle
    '                                                   3 = intensity
    '   fileName                    As String
    '
    'OUTPUT
    '   file with angles and intensities written to it.
    
    Dim text As String
    Dim count10 As Integer
    Dim h As Integer
    Dim v As Integer
    Dim i As Integer
    
    Dim fso As Scripting.FileSystemObject           '
    Set fso = New Scripting.FileSystemObject        ''
    'DELETE THE FILE IF IT EXISTS ALREADY           '''
    If fso.FileExists(fileName) Then                ''''
        fso.DeleteFile (fileName)                   ''''' Open the file for writing -> delete it if it already exists
    End If                                          ''''
    'CREATE THE FILE                                '''
    Dim tsv As Scripting.TextStream                 ''
    Set tsv = fso.CreateTextFile(fileName)          '
    
    'HEADER LINES-------------------------------------------------------------------
    For i = 1 To UBound(header, 1)
        tsv.WriteLine (header(i))
        'Debug.Print header(i)
    Next i
    
    'NUMERICAL INFORMATION LINE-----------------------------------------------------
    '#LAMPS/LUMENS/MULT/#VANGLES/#HANGLES/PHOTO TYPE/UNITS/W/L/H
    text = CStr(lum.NumberLamps) & " " & _
            CStr(lum.LampLumens) & " " & _
            CStr(lum.GeneralMultiplier) & " " & _
            CStr(lum.NumVAngles) & " " & _
            CStr(lum.NumHAngles) & " " & _
            CStr(lum.PhotometryType) & " " & _
            CStr(lum.units) & " " & _
            CStr(lum.LuminousWidth) & " " & _
            CStr(lum.LuminousLength) & " " & _
            CStr(lum.LuminousHeight)
    tsv.WriteLine text
    'Debug.Print text
    'Debug.Print "-------------"
    
    'NUMERICAL INFORMATION LINE-----------------------------------------------------
    'BF/FUTURE USE/WATTS
    text = CStr(lum.BallastFactor) & " " & _
            "1 " & _
            CStr(lum.InputWatts)
    tsv.WriteLine (text)
    'Debug.Print text
    'Debug.Print "-------------"
    
    'VERTICAL TEST ANGLES-----------------------------------------------------------
    count10 = 0
    text = ""
    For v = 1 To UBound(intensity, 2)
        count10 = count10 + 1
        If count10 = 1 Then
            text = CStr(intensity(1, v, 2))
        Else
            text = text + " " + CStr(intensity(1, v, 2))
        End If
        If count10 = 10 Then
            tsv.WriteLine (text)
            'Debug.Print text
            text = ""
            count10 = 0
        End If
    Next v
    If text <> "" Then
        tsv.WriteLine (text)
        'Debug.Print text
    End If
    'Debug.Print "-------------"
    
    'HORIZONTAL TEST ANGLES--------------------------------------------------------
    count10 = 0
    text = ""
    For h = 1 To UBound(intensity, 1)
        count10 = count10 + 1
        If count10 = 1 Then
            text = CStr(intensity(h, 1, 1))
        Else
            text = text + " " + CStr(intensity(h, 1, 1))
        End If
        If count10 = 10 Then
            tsv.WriteLine (text)
            'Debug.Print text
            text = ""
            count10 = 0
        End If
    Next h
    If text <> "" Then
        tsv.WriteLine (text)
        'Debug.Print text
    End If
    'Debug.Print "-------------"
    
    
    'INTENSITIES--------------------------------------------------------------------
    count10 = 0
    text = ""
    For h = 1 To UBound(intensity, 1)
        count10 = 0
        text = ""
        For v = 1 To UBound(intensity, 2)
            count10 = count10 + 1
            If count10 = 1 Then
                text = CStr(Round(intensity(h, v, 3), 1))
                'text = intensity(h, v, 3)
            Else
                text = text + " " + CStr(Round(intensity(h, v, 3), 1))
                'text = text + " " + CStr(intensity(h, v, 3))
            End If
            If count10 = 10 Then
                tsv.WriteLine (text)
                'Debug.Print text
                text = ""
                count10 = 0
            End If
        Next v
        If text <> "" Then
            tsv.WriteLine (text)
            'Debug.Print text
        End If
    Next h
    
    'CLOSE THE FILE
    tsv.Close
End Function


Public Function WriteIESFileAvoidOverwrite(header() As String, lum, intensity() As Double, fileName As String)
    'THIS FUNCTION WRITES THE VERTICAL ANGLES, HORIZONTAL ANGLES, AND INTENSITIES
    'TO AN IES FILE WITH THE GIVEN FILENAME.
    'INPUT:
    '   header()                    As Double       Array of the header information
    '   lum                         As IESFile      Luminaire information
    '   intensityArray(h,v,1-2-3)   As Double       Array of intensities
    '                                                   1 = horizontal angle
    '                                                   2 = vertical angle
    '                                                   3 = intensity
    '   fileName                    As String
    '
    'OUTPUT
    '   file with angles and intensities written to it.
    
    '7/17/2013 - added this version of the function to avoid overwriting files with the same name.
    'This caused problems if you had two files w/ the same lumcat and weren't including the test number
    'in the rename - good safe thing to do is to alway use this one!!!
    
    Dim text As String
    Dim count10 As Integer
    Dim h As Integer
    Dim v As Integer
    Dim i As Integer
    
    Dim fso As Scripting.FileSystemObject           '
    Set fso = New Scripting.FileSystemObject        ''
    'DELETE THE FILE IF IT EXISTS ALREADY           '''
    
    'loop to find a filename that doesn't exist--> add "(#).ies" to the filename if needed
    Dim newName As String
    If fso.FileExists(fileName) Then                ''''
        i = 0
        Do
            i = i + 1
            newName = Left(fileName, Len(fileName) - 4) + "(" + CStr(i) + ").ies"
        Loop While fso.FileExists(newName)
        fileName = newName
    End If                                          ''''
    
    
    'CREATE THE FILE                                '''
    Dim tsv As Scripting.TextStream                 ''
    Set tsv = fso.CreateTextFile(fileName)          '
    
    'HEADER LINES-------------------------------------------------------------------
    For i = 1 To UBound(header, 1)
        tsv.WriteLine (header(i))
        'Debug.Print header(i)
    Next i
    
    'NUMERICAL INFORMATION LINE-----------------------------------------------------
    '#LAMPS/LUMENS/MULT/#VANGLES/#HANGLES/PHOTO TYPE/UNITS/W/L/H
    text = CStr(lum.NumberLamps) & " " & _
            CStr(lum.LampLumens) & " " & _
            CStr(lum.GeneralMultiplier) & " " & _
            CStr(lum.NumVAngles) & " " & _
            CStr(lum.NumHAngles) & " " & _
            CStr(lum.PhotometryType) & " " & _
            CStr(lum.units) & " " & _
            CStr(lum.LuminousWidth) & " " & _
            CStr(lum.LuminousLength) & " " & _
            CStr(lum.LuminousHeight)
    tsv.WriteLine text
    'Debug.Print text
    'Debug.Print "-------------"
    
    'NUMERICAL INFORMATION LINE-----------------------------------------------------
    'BF/FUTURE USE/WATTS
    text = CStr(lum.BallastFactor) & " " & _
            "1 " & _
            CStr(lum.InputWatts)
    tsv.WriteLine (text)
    'Debug.Print text
    'Debug.Print "-------------"
    
    'VERTICAL TEST ANGLES-----------------------------------------------------------
    count10 = 0
    text = ""
    For v = 1 To UBound(intensity, 2)
        count10 = count10 + 1
        If count10 = 1 Then
            text = CStr(intensity(1, v, 2))
        Else
            text = text + " " + CStr(intensity(1, v, 2))
        End If
        If count10 = 10 Then
            tsv.WriteLine (text)
            'Debug.Print text
            text = ""
            count10 = 0
        End If
    Next v
    If text <> "" Then
        tsv.WriteLine (text)
        'Debug.Print text
    End If
    'Debug.Print "-------------"
    
    'HORIZONTAL TEST ANGLES--------------------------------------------------------
    count10 = 0
    text = ""
    For h = 1 To UBound(intensity, 1)
        count10 = count10 + 1
        If count10 = 1 Then
            text = CStr(intensity(h, 1, 1))
        Else
            text = text + " " + CStr(intensity(h, 1, 1))
        End If
        If count10 = 10 Then
            tsv.WriteLine (text)
            'Debug.Print text
            text = ""
            count10 = 0
        End If
    Next h
    If text <> "" Then
        tsv.WriteLine (text)
        'Debug.Print text
    End If
    'Debug.Print "-------------"
    
    
    'INTENSITIES--------------------------------------------------------------------
    count10 = 0
    text = ""
    For h = 1 To UBound(intensity, 1)
        count10 = 0
        text = ""
        For v = 1 To UBound(intensity, 2)
            count10 = count10 + 1
            If count10 = 1 Then
                text = CStr(Round(intensity(h, v, 3), 1))
            Else
                text = text + " " + CStr(Round(intensity(h, v, 3), 1))
            End If
            If count10 = 10 Then
                tsv.WriteLine (text)
                'Debug.Print text
                text = ""
                count10 = 0
            End If
        Next v
        If text <> "" Then
            tsv.WriteLine (text)
            'Debug.Print text
        End If
    Next h
    
    'CLOSE THE FILE
    tsv.Close
End Function
    


Public Function WriteIESFileToSheet(lum, header, intensity, row, col)
    'THIS FUNCTION WRITES AN IES FILE TO AN EXCEL SHEET STARTING IN CELL
    'GIVEN BY THE INPUTTED row AND col VARIABLES
    
    Dim h As Integer
    Dim textColor1 As Integer
    Dim textColor2 As Integer
    textColor1 = 0  'black
    textColor2 = 48 'gray 40%
    
    'HEADER
    For h = 1 To UBound(header)
        ActiveSheet.Cells(row, col) = header(h)
        ActiveSheet.Cells(row, col).Font.ColorIndex = textColor1
        row = row + 1
    Next h
    
    'NUMERICAL INFORMATION LINES
    '#LAMPS/LUMENS/MULT/#VANGLES/#HANGLES/PHOTO TYPE/UNITS/W/L/H
    ActiveSheet.Cells(row, col) = CStr(lum.NumberLamps) & " " & _
                                        CStr(lum.LampLumens) & " " & _
                                        CStr(lum.GeneralMultiplier) & " " & _
                                        CStr(lum.NumVAngles) & " " & _
                                        CStr(lum.NumHAngles) & " " & _
                                        CStr(lum.PhotometryType) & " " & _
                                        CStr(lum.units) & " " & _
                                        CStr(lum.LuminousWidth) & " " & _
                                        CStr(lum.LuminousLength) & " " & _
                                        CStr(lum.LuminousHeight)
    ActiveSheet.Cells(row, col).Font.ColorIndex = textColor2
    row = row + 1
    'NUMERICAL INFORMATION LINE
    'BF/FUTURE USE/WATTS
    ActiveSheet.Cells(row, col) = CStr(lum.BallastFactor) & " " & _
                                        "1 " & _
                                        CStr(lum.InputWatts)
    ActiveSheet.Cells(row, col).Font.ColorIndex = textColor2
    row = row + 1
    
    'VERTICAL TEST ANGLES
    Dim count10 As Integer
    Dim text As String
    Dim v As Integer
    count10 = 0
    text = ""
    For v = 1 To UBound(intensity, 2)
        count10 = count10 + 1
        If count10 = 1 Then
            text = CStr(intensity(1, v, 2))
        Else
            text = text + " " + CStr(intensity(1, v, 2))
        End If
        If count10 = 10 Then
            ActiveSheet.Cells(row, col) = text
            ActiveSheet.Cells(row, col).Font.ColorIndex = textColor1
            row = row + 1
            'Debug.Print text
            text = ""
            count10 = 0
        End If
    Next v
    If text <> "" Then
        ActiveSheet.Cells(row, col) = text
        ActiveSheet.Cells(row, col).Font.ColorIndex = textColor1
        row = row + 1
    End If
    
    'HORIZONTAL TEST ANGLES
    count10 = 0
    text = ""
    For h = 1 To UBound(intensity, 1)
        count10 = count10 + 1
        If count10 = 1 Then
            text = CStr(intensity(h, 1, 1))
        Else
            text = text + " " + CStr(intensity(h, 1, 1))
        End If
        If count10 = 10 Then
            ActiveSheet.Cells(row, col) = text
            ActiveSheet.Cells(row, col).Font.ColorIndex = textColor2
            row = row + 1
            text = ""
            count10 = 0
        End If
    Next h
    If text <> "" Then
        ActiveSheet.Cells(row, col) = text
        ActiveSheet.Cells(row, col).Font.ColorIndex = textColor2
        row = row + 1
    End If
    
    'INTENSITIES
    count10 = 0
    text = ""
    For h = 1 To UBound(intensity, 1)
        count10 = 0
        text = ""
        For v = 1 To UBound(intensity, 2)
            count10 = count10 + 1
            If count10 = 1 Then
                text = CStr(Round(intensity(h, v, 3), 1))
            Else
                text = text + " " + CStr(Round(intensity(h, v, 3), 1))
            End If
            If count10 = 10 Then
                ActiveSheet.Cells(row, col) = text
                ActiveSheet.Cells(row, col).Font.ColorIndex = textColor1
                row = row + 1
                'tsv.WriteLine (text)
                'Debug.Print text
                text = ""
                count10 = 0
            End If
        Next v
        If text <> "" Then
            ActiveSheet.Cells(row, col) = text
            ActiveSheet.Cells(row, col).Font.ColorIndex = textColor1
            row = row + 1
            'tsv.WriteLine (text)
            'Debug.Print text
        End If
    Next h
    
    
    
    
    
    
    
    
    
    
    
    
End Function
    
    
Public Function zonalLumens(ByVal lum, ByRef intensity() As Double, ByRef zLumens() As Double)
    'Calculate the zonal lumens for the intensity distribution passed to the function.
    'Results are handed back in an array from 0-17 where the 0 index is the lumens from
    '0 to 10 degrees, index of 5 is the lumens from 50 to 60 degrees, and the index of
    '17 is the lumens from 170 to 180 degrees vertically.
    
    Dim v As Integer
    Dim dLumen As Double            'Lumen value for the angular zone
    Dim iZone As Double             'Intensity value for the zone for calculating the lumen
    Dim done As Boolean
    
    Dim lumA As IESFile         'Axially symmetric luminaire information (for zonal lumens)
    Dim intensityA() As Double  'Axially symmetric intensity distribution (for zonal lumens)
    Set lumA = New IESFile
    
    Call IES.AverageAxially(lum, intensity, lumA, intensityA)
    
    Call IES.zoneLumens(intensityA, 0, 10, zLumens(0))
    Call IES.zoneLumens(intensityA, 10, 20, zLumens(1))
    Call IES.zoneLumens(intensityA, 20, 30, zLumens(2))
    Call IES.zoneLumens(intensityA, 30, 40, zLumens(3))
    Call IES.zoneLumens(intensityA, 40, 50, zLumens(4))
    Call IES.zoneLumens(intensityA, 50, 60, zLumens(5))
    Call IES.zoneLumens(intensityA, 60, 70, zLumens(6))
    Call IES.zoneLumens(intensityA, 70, 80, zLumens(7))
    Call IES.zoneLumens(intensityA, 80, 90, zLumens(8))
    Call IES.zoneLumens(intensityA, 90, 100, zLumens(9))
    Call IES.zoneLumens(intensityA, 100, 110, zLumens(10))
    Call IES.zoneLumens(intensityA, 110, 120, zLumens(11))
    Call IES.zoneLumens(intensityA, 120, 130, zLumens(12))
    Call IES.zoneLumens(intensityA, 130, 140, zLumens(13))
    Call IES.zoneLumens(intensityA, 140, 150, zLumens(14))
    Call IES.zoneLumens(intensityA, 150, 160, zLumens(15))
    Call IES.zoneLumens(intensityA, 160, 170, zLumens(16))
    Call IES.zoneLumens(intensityA, 170, 180, zLumens(17))
End Function


Public Function zoneLumens(ByRef intensity() As Double, ByVal zoneStart As Double, ByVal zoneEnd As Double, ByRef lumens As Double)
    'Calculates the lumens in the vertical zone specified by the input parameters.
    '  Considers the zone all 360 degrees around the luminaire.
    
    Dim v As Integer
    Dim vStart As Integer
    Dim vEnd As Integer
    Dim iZone As Double
    Dim i1 As Double
    Dim a1 As Double
    Dim i2 As Double
    Dim a2 As Double
    
    vStart = 0
    Do
        vStart = vStart + 1
    Loop While intensity(1, vStart, 2) < zoneStart And vStart < UBound(intensity, 2)
    a1 = intensity(1, vStart, 2)
    
    vEnd = 0
    Do
        vEnd = vEnd + 1
    Loop While intensity(1, vEnd, 2) < zoneEnd And vEnd < UBound(intensity, 2)
    
    
    lumens = 0
    For v = vStart To vEnd - 1
        
        If lumens = 0 And a1 > zoneStart Then
            Call IES.GetIESIntensity(intensity, zoneStart, 0, i1)
            a1 = zoneStart
        Else
            i1 = intensity(1, v, 3)
            a1 = intensity(1, v, 2)
        End If
        
        If intensity(1, v + 1, 2) > zoneEnd Then 'intensity(1, vEnd, 2) Then
            Call IES.GetIESIntensity(intensity, zoneEnd, 0, i2)
            a2 = zoneEnd
        Else
            i2 = intensity(1, v + 1, 3)
            a2 = intensity(1, v + 1, 2)
        End If
        
        iZone = (i1 + i2) / 2
        lumens = lumens + (2 * PI * iZone * (Cos(a1 * dtr) - Cos(a2 * dtr)))
        
    Next v
    
End Function


Public Function zoneLumens2(ByRef intensityASY() As Double, ByVal VAstart As Double, ByVal VAend As Double, ByVal HAstart, ByVal HAend, ByRef lumens)
    'Calculates the lumens in the vertical/horizontal zone specified by the input parameters.
    '   Considers descrete horizontal and vertical inputs.
    
    'Must pass an unaveraged intensity array to this for it to work accurately
    
    Dim countV, countH As Integer
    Dim VAarray() As Double
    Dim HAarray() As Double
    Dim v As Integer
    Dim h As Integer
    Dim HA As Double
    
    'GET ARRAY OF VERTICAL ANGLES IN THE ZONE NEEDED------------------------
    ReDim VAarray(1 To 1) As Double
    countV = 1
    VAarray(countV) = VAstart
    'FIND FIRST VA FROM THE INTENSITY ARRAY
    v = 1
    Do While intensityASY(1, v, 2) <= VAstart
        v = v + 1
    Loop
    countV = countV + 1
    ReDim Preserve VAarray(1 To 2) As Double
    VAarray(2) = intensityASY(1, v, 2)
    'ASSIGN ALL VERTICAL ANGLES FROM THE INTENSITY ARRAY UP TO THE VAEND
    If VAarray(2) < VAend Then
        v = v + 1
        Do While intensityASY(1, v, 2) < VAend
            countV = countV + 1
            ReDim Preserve VAarray(1 To countV) As Double
            VAarray(countV) = intensityASY(1, v, 2)
            v = v + 1
            If v > UBound(intensityASY, 2) Then Exit Do
        Loop
        'ADD LAST ANGLE
        countV = countV + 1
        ReDim Preserve VAarray(1 To countV) As Double
        VAarray(countV) = VAend
        'Debug.Print "stop here - got array of VA"
    End If
    
    
    'UNAVERAGE THE INTENSITY DISTRIBUTION SO THERE WILL BE NO ERRORS------------
    Dim intensity2() As Double
'    Dim lum2 As IESFile
'    Set lum2 = New IESFile
'    Call IES.SymmetryUndo(intensity, lum, intensity2, lum2)
'    DO THIS BEFORE CALLING ZoneLumens2
    
    
    'GET ARRAY OF HORIZONTAL ANGLES IN THE ZONE NEEDED--------------------------
    ReDim HAarray(1 To 1) As Double
    countH = 1
    HAarray(countH) = HAstart
    'FIND FIRST VA FROM THE INTENSITY ARRAY
    h = 1
    Do While intensityASY(h, 1, 1) <= HAstart
        h = h + 1
    Loop
    countH = countH + 1
    ReDim Preserve HAarray(1 To 2) As Double
    HAarray(2) = intensityASY(h, 1, 1)
    'ASSIGN ALL HORIZONTAL ANGLES FROM THE INTENSITY ARRAY UP TO THE HA END
    HA = intensityASY(h, 1, 1)
    h = h + 1
    Do While HA <= HAend
        If h > UBound(intensityASY, 1) Then
            countH = countH + 1
            ReDim Preserve HAarray(1 To countH) As Double
            HA = 360 + intensityASY(h - UBound(intensityASY, 1), 1, 1)
            HAarray(countH) = HA 'intensity(h - UBound(intensity, 1), 1, 1)
            h = h + 1
        Else
            countH = countH + 1
            ReDim Preserve HAarray(1 To countH) As Double
            HA = intensityASY(h, 1, 1)
            HAarray(countH) = intensityASY(h, 1, 1)
            h = h + 1
        End If
        'GET THE NEXT HA TO CHECK IN THE BEGINNING OF THE LOOP
        If h > UBound(intensityASY, 1) Then
            HA = 360 + intensityASY(h - UBound(intensityASY, 1), 1, 1)
        Else
            HA = intensityASY(h, 1, 1)
        End If
    Loop
    
    'ADD LAST ANGLE
    If HAarray(countH) < HAend Then
        countH = countH + 1
        ReDim Preserve HAarray(1 To countH) As Double
        HAarray(countH) = HAend
    '    If HA < HAend Then
    '        countH = countH + 1
    '        ReDim Preserve HAarray(1 To countH) As Double
    '        HAarray(countH) = HAend
    '    End If
    End If
    'Debug.Print "stop here - got array HA"
    
    'CYCLE THROUGH THE ZONE, AND GET THE LUMENS
    Dim lumensArray() As Double
    ReDim lumensArray(1 To countH - 1, 1 To countV - 1) As Double
    Dim i1, i2, i3, i4 As Double
    Dim va1, va2, ha1, ha2 As Double
    Dim iAVG As Double
    lumens = 0
    For h = 1 To UBound(lumensArray, 1)
        For v = 1 To UBound(lumensArray, 2)
            Call IES.GetIESIntensity(intensityASY, VAarray(v), HAarray(h), i1) ': Debug.Print i1
            Call IES.GetIESIntensity(intensityASY, VAarray(v), HAarray(h + 1), i2) ': Debug.Print i2
            Call IES.GetIESIntensity(intensityASY, VAarray(v + 1), HAarray(h + 1), i3) ': Debug.Print i3
            Call IES.GetIESIntensity(intensityASY, VAarray(v + 1), HAarray(h), i4) ': Debug.Print i4
            iAVG = (i1 + i2 + i3 + i4) / 4
            lumensArray(h, v) = ((HAarray(h + 1) * dtr) - (HAarray(h) * dtr)) * iAVG * (Cos(VAarray(v) * dtr) - Cos(VAarray(v + 1) * dtr))
            lumens = lumens + lumensArray(h, v)
        Next v
    Next h
    
End Function

Public Function zoneLumens2B(ByRef intensity() As Double, ByVal VAstart As Double, ByVal VAend As Double, ByVal HAstart, ByVal HAend, ByRef lumens)
    'Calculates the lumens in the vertical/horizontal zone specified by the input parameters.
    '   Considers descrete horizontal and vertical inputs.
    
    'TYPE B (FLOOD) INTENSITY DISTRIBUTIONS ONLY
    
    Dim countV, countH As Integer
    Dim VAarray() As Double
    Dim HAarray() As Double
    Dim v As Integer
    Dim h As Integer
    Dim HA As Double
    
    'GET ARRAY OF VERTICAL ANGLES IN THE ZONE NEEDED------------------------
    ReDim VAarray(1 To 1) As Double
    countV = 1
    VAarray(countV) = VAstart
    'FIND FIRST VA FROM THE INTENSITY ARRAY
    v = 1
    Do While intensity(1, v, 2) <= VAstart
        v = v + 1
    Loop
    countV = countV + 1
    ReDim Preserve VAarray(1 To 2) As Double
    VAarray(2) = intensity(1, v, 2)
    'ASSIGN ALL VERTICAL ANGLES FROM THE INTENSITY ARRAY UP TO THE VAEND
    v = v + 1
    Do While intensity(1, v, 2) < VAend
        countV = countV + 1
        ReDim Preserve VAarray(1 To countV) As Double
        VAarray(countV) = intensity(1, v, 2)
        v = v + 1
        If v > UBound(intensity, 2) Then Exit Do
    Loop
    'ADD LAST VERTICAL ANGLE
    countV = countV + 1
    ReDim Preserve VAarray(1 To countV) As Double
    VAarray(countV) = VAend
    
    
    
    'GET ARRAY OF HORIZONTAL ANGLES IN THE ZONE NEEDED------------------------
    ReDim HAarray(1 To 1) As Double
    countH = 1
    HAarray(countH) = HAstart
    'FIND FIRST VA FROM THE INTENSITY ARRAY
    h = 1
    Do While intensity(h, 1, 1) <= HAstart
        h = h + 1
    Loop
    countH = countH + 1
    ReDim Preserve HAarray(1 To 2) As Double
    HAarray(2) = intensity(h, 1, 1)
    'ASSIGN ALL HORIZONTAL ANGLES FROM THE INTENSITY ARRAY UP TO THE HAEND
    h = h + 1
    Do While intensity(h, 1, 1) < HAend
        countH = countH + 1
        ReDim Preserve HAarray(1 To countH) As Double
        HAarray(countH) = intensity(h, 1, 1)
        h = h + 1
        If h > UBound(intensity, 1) Then Exit Do
    Loop
    'ADD LAST VERTICAL ANGLE
    countH = countH + 1
    ReDim Preserve HAarray(1 To countH) As Double
    HAarray(countH) = HAend
    
    
    '-------------------------------------------------------------------------
    
    
    'CYCLE THROUGH THE ZONE, AND GET THE LUMENS
    Dim lumensArray() As Double
    ReDim lumensArray(1 To countH - 1, 1 To countV - 1) As Double
    Dim i1, i2, i3, i4 As Double
    Dim va1, va2, ha1, ha2 As Double
    Dim iAVG As Double
    lumens = 0
    
    If VAstart = 80 And VAend = 90 Then
        If HAstart = 80 And HAend = 90 Then
            Debug.Print "stop"
        End If
    End If
    
    
    For h = 1 To UBound(lumensArray, 1)
        ha1 = HAarray(h)
        ha2 = HAarray(h + 1)
        For v = 1 To UBound(lumensArray, 2)
            va1 = VAarray(v)
            va2 = VAarray(v + 1)
        
            Call IES.GetIESIntensityB(intensity, VAarray(v), HAarray(h), i1) ': Debug.Print i1
            Call IES.GetIESIntensityB(intensity, VAarray(v), HAarray(h + 1), i2) ': Debug.Print i2
            Call IES.GetIESIntensityB(intensity, VAarray(v + 1), HAarray(h + 1), i3) ': Debug.Print i3
            Call IES.GetIESIntensityB(intensity, VAarray(v + 1), HAarray(h), i4) ': Debug.Print i4
            iAVG = (i1 + i2 + i3 + i4) / 4
            'lumensArray(h, v) = ((HAarray(h + 1) * dtr) - (HAarray(h) * dtr)) * iAVG * (Cos(VAarray(v) * dtr) - Cos(VAarray(v + 1) * dtr))
            
            'lumensArray(h, v) = Abs(((VAarray(v + 1) * dtr) - (VAarray(v) * dtr)) * iAVG * (Cos((HAarray(h) + 90) * dtr) - Cos((HAarray(h + 1) + 90) * dtr)))
            
            lumensArray(h, v) = Abs((va2 - va1) * dtr) * iAVG * (Cos((ha1 + 90) * dtr) - Cos((ha2 + 90) * dtr))
            
            lumens = lumens + lumensArray(h, v)
        Next v
    Next h
    
End Function


Public Function zoneLumensVertTypeB(ByRef intensityB() As Double, ByVal zoneStart As Double, ByVal zoneEnd As Double, ByRef lumens As Double)
    'Calculates the lumens in the vertical zone specified by the input parameters.
    
    Dim v As Integer
    Dim vStart As Integer
    Dim vEnd As Integer
    
    Dim h As Integer    'horizontal angle index
    
    Dim va1, va2 As Double
    Dim ha1, ha2 As Double
    Dim i1, i2, i3, i4 As Double
    Dim iZone As Double
    
    'GET STARTING AND ENDING INDEX ON THE INTERIOR OF THE ZONE YOU WANT------------------------
    'If they don't exactly match the starting and ending values for the
    'inputted angles, calculate them, then add the starting and ending
    'wedges onto the lumen sum seperately.
    vStart = 0
    Do
        vStart = vStart + 1
        'Debug.Print "vAngle1 = " & intensityB(1, vStart, 2)
    Loop While intensityB(1, vStart, 2) < zoneStart And vStart < UBound(intensityB, 2)
    'Debug.Print "V Angle Start = " & intensityB(1, vStart, 2)
    
    vEnd = 0
    Do
        vEnd = vEnd + 1
        'Debug.Print "vAngle2 = " & intensityB(1, vEnd, 2)
    Loop While intensityB(1, vEnd, 2) < zoneEnd And vEnd < UBound(intensityB, 2)
    'Debug.Print "V Angle End =" & intensityB(1, vEnd, 2)
    If intensityB(1, vEnd, 2) > zoneEnd Then
        vEnd = vEnd - 1
    End If
    'Debug.Print "Whole Angles:"
    'Debug.Print "  Start = " & intensityB(1, vStart, 2)
    'Debug.Print "  End   = " & intensityB(1, vEnd, 2)
    
    '--------------------------------------------------------------------------------------------
    'CALCULATE LUMENS FOR THE INTERIOR OF THE ZONE (if start and end angles are not exact
    'that will be added at the end)
    lumens = 0
    For v = vStart To (vEnd - 1)
        For h = 1 To (UBound(intensityB, 1) - 1)
            i1 = intensityB(h, v, 3)
            i2 = intensityB(h + 1, v, 3)
            i3 = intensityB(h + 1, v + 1, 3)
            i4 = intensityB(h, v + 1, 3)
            va1 = intensityB(h, v, 2)
            va2 = intensityB(h, v + 1, 2)
            ha1 = intensityB(h, v, 1) + 90          '+90 to convert to a type c equivelant vertical angle
            ha2 = intensityB(h + 1, v, 1) + 90      'ditto
            iZone = (i1 + i2 + i3 + i4) / 4
            'lumens = lumens + Abs(((HA2 * dtr) - (HA1 * dtr)) * iZone * (Cos(VA1 * dtr) - Cos(VA2 * dtr)))
            lumens = lumens + Abs(((va2 * dtr) - (va1 * dtr)) * iZone * (Cos(ha1 * dtr) - Cos(ha2 * dtr)))
                'switched the ha and va for the type b because the central axis of the polar coordinate systems
                ' are perpendicular to eachother
        Next h
    Next v
    'Debug.Print "  Lumens = " & Round(lumens, 0)
    
    'LUMENS FOR THE BEGINNING ZONE
    Dim lumensStart As Double
    lumensStart = 0
    If zoneStart < intensityB(1, vStart, 2) Then
        'ADD SLIVER OF ZONE FROM THE STARTING SIDE OF THE ANGULAR ZONE.
        va1 = zoneStart
        va2 = intensityB(1, vStart, 2)
        For h = 1 To (UBound(intensityB, 1) - 1)
            ha1 = intensityB(h, 1, 1) + 90
            ha2 = intensityB(h + 1, 1, 1) + 90
            Call IES.GetIESIntensityB(intensityB, va1, intensityB(h, 1, 1), i1)
            Call IES.GetIESIntensityB(intensityB, va1, intensityB(h + 1, 1, 1), i2)
            i3 = intensityB(h + 1, vStart, 3)
            i4 = intensityB(h, vStart, 3)
            iZone = (i1 + i2 + i3 + i4) / 4
            lumensStart = lumensStart + Abs(((va2 * dtr) - (va1 * dtr)) * iZone * (Cos(ha1 * dtr) - Cos(ha2 * dtr)))
        Next h
    End If
    
    'LUMENS FOR THE ENDING ZONE
    Dim lumensEnd As Double
    lumensEnd = 0
    If zoneEnd > intensityB(1, vEnd, 2) Then
        'ADD SLIVER OF ZONE FROM THE ENDING SIDE OF THE ANGULAR ZONE.
        va1 = intensityB(1, vEnd, 2)
        va2 = zoneEnd
        For h = 1 To (UBound(intensityB, 1) - 1)
            ha1 = intensityB(h, 1, 1) + 90
            ha2 = intensityB(h + 1, 1, 1) + 90
            Call IES.GetIESIntensityB(intensityB, va2, intensityB(h, 1, 1), i1)
            Call IES.GetIESIntensityB(intensityB, va2, intensityB(h + 1, 1, 1), i2)
            i3 = intensityB(h + 1, vStart, 3)
            i4 = intensityB(h, vStart, 3)
            iZone = (i1 + i2 + i3 + i4) / 4
            lumensEnd = lumensEnd + Abs(((va2 * dtr) - (va1 * dtr)) * iZone * (Cos(ha1 * dtr) - Cos(ha2 * dtr)))
        Next h
    End If
    
    
    lumens = lumens + lumensStart + lumensEnd
End Function


'
Public Function zoneLumensVertTypeB2(ByRef intensityB() As Double, ByVal VAngleStart As Double, ByVal VAngleEnd As Double, ByVal hTRLStart As Double, ByVal hTRLend As Double, ByRef lumens As Double)
    'CALCULATES THE LUMENS IN THE VERITCAL AND HORIZONTAL ZONE DESCRIBED BY THE INPUT PARAMETERS.
    'THIS TAKES IN ROADWAY TRL INPUTS AS THE EXTENT FOR ha'S FOR CU CALCULATIONS - USED IN IES FILE PDF ROADWAY GENERATOR
    
    Dim v As Integer        'vertical angle index
    Dim vStart As Integer   'index of starting vangle
    Dim vEnd As Integer     'index of ending vangle
    
    
    Dim h As Integer        'horizontal angle index
    Dim Hstart As Integer   'index of starting horizontal angle
    Dim Hend As Integer     'index of ending horizontal angle
    
    Dim MH As Double
    Dim dMH As Double
    Dim dForward As Double
    Dim dRoad As Double
    
    Dim va1, va2 As Double
    Dim ha1, ha2 As Double
    Dim i1, i2, i3, i4 As Double
    Dim iZone As Double
    
    'GET STARTING AND ENDING INDEX ON THE INTERIOR OF THE ZONE YOU WANT------------------------
    'If they don't exactly match the starting and ending values for the
    'inputted angles, calculate them, then add the starting and ending
    'wedges onto the lumen sum seperately.
    
    'VERTICAL ANGLES
    vStart = 0
    Do
        vStart = vStart + 1
    Loop While intensityB(1, vStart, 2) < VAngleStart And vStart < UBound(intensityB, 2)
    vEnd = 0
    Do
        vEnd = vEnd + 1
    Loop While intensityB(1, vEnd, 2) < VAngleEnd And vEnd < UBound(intensityB, 2)
    If intensityB(1, vEnd, 2) > VAngleEnd Then
        vEnd = vEnd - 1
    End If
    
'    'HORIZONTAL ANGLES
'    Hstart = 0
'    Do
'        Hstart = Hstart + 1
'    Loop While intensityB(Hstart, 1, 1) < HzoneStart And Hstart < UBound(intensityB, 1)
'    Hend = 0
'    Do
'        Hend = Hend + 1
'    Loop While intensityB(Hend, 1, 1) < HzoneEnd And Hend < UBound(intensityB, 1)
'    If intensityB(Hend, 1, 1) > HzoneEnd Then
'        Hend = Hend - 1
'    End If
    
'    Debug.Print "Whole Angles:"
'    Debug.Print "  V Start = " & intensityB(1, Vstart, 2)
'    Debug.Print "  V End   = " & intensityB(1, Vend, 2)
    
    
    '--------------------------------------------------------------------------------------------
    'CALCULATE LUMENS FOR THE INTERIOR OF THE ZONE (if start and end angles are not exact
    'that will be added at the end)
    'The way it is looped through now, the small horizontal zones on the outside of the target
    'are not accounted for.  I added code to do this for the middle section (see commented section below) and it
    'did not change the result very much, but added a lot of calculation time (getiesintensity2).
    
    lumens = 0
    MH = 1
    For v = vStart To (vEnd - 1)
        va1 = intensityB(1, v, 2)
        va2 = intensityB(1, v + 1, 2)
        'FIND STARTING HANGLE
        dMH = MH * Tan(va1 * dtr)
        dForward = Sqr(dMH ^ 2 + MH ^ 2)
        For h = 1 To (UBound(intensityB, 1) - 1)
'        For HA1 = -90 To 89 Step 1
'            HA2 = HA1 + 1
            ha1 = intensityB(h, v, 1)
            dRoad = dForward * Tan(ha1 * dtr)
            If dRoad >= hTRLStart And dRoad <= hTRLend Then
                'POINT FALLS INBETWEEN THE HORIZONTAL TARGET ZONE
                ha2 = intensityB(h + 1, v, 1)
                i1 = intensityB(h, v, 3)
                i2 = intensityB(h + 1, v, 3)
                i3 = intensityB(h + 1, v + 1, 3)
                i4 = intensityB(h, v + 1, 3)
'                Call IES.GetIESIntensity2(intensityB, VA1, HA1, i1)
'                Call IES.GetIESIntensity2(intensityB, VA1, HA2, i2)
'                Call IES.GetIESIntensity2(intensityB, VA2, HA2, i3)
'                Call IES.GetIESIntensity2(intensityB, VA2, HA1, i4)
                'Debug.Print "VA1 = " & Round(VA1, 1) & "  HA1 = " & Round(HA1, 1)
                iZone = (i1 + i2 + i3 + i4) / 4
                lumens = lumens + Abs(((va2 * dtr) - (va1 * dtr)) * iZone * (Cos((ha1 + 90) * dtr) - Cos((ha2 + 90) * dtr)))
            End If
'        Next HA1
        Next h
    Next v
    'Debug.Print "  Lumens = " & Round(lumens, 0)
    
    'LUMENS FOR THE BEGINNING ZONE
    Dim lumensStart As Double
    lumensStart = 0
    If VAngleStart < intensityB(1, vStart, 2) Then
        'ADD SLIVER OF ZONE FROM THE STARTING SIDE OF THE ANGULAR ZONE.
        va1 = VAngleStart
        va2 = intensityB(1, vStart, 2)
        dMH = MH * Tan(va1 * dtr)
        dForward = Sqr(dMH ^ 2 + MH ^ 2)
        For h = 1 To (UBound(intensityB, 1) - 1)
            ha1 = intensityB(h, 1, 1) + 90
            ha2 = intensityB(h + 1, 1, 1) + 90
            
            dRoad = dForward * Tan((ha1 - 90) * dtr)
            If dRoad >= hTRLStart And dRoad <= hTRLend Then
                'POINT FALLS INBETWEEN THE HORIZONTAL TARGET ZONE
                Call IES.GetIESIntensityB(intensityB, va1, intensityB(h, 1, 1), i1)
                Call IES.GetIESIntensityB(intensityB, va1, intensityB(h + 1, 1, 1), i2)
                i3 = intensityB(h + 1, vStart, 3)
                i4 = intensityB(h, vStart, 3)
                iZone = (i1 + i2 + i3 + i4) / 4
                lumensStart = lumensStart + Abs(((va2 * dtr) - (va1 * dtr)) * iZone * (Cos(ha1 * dtr) - Cos(ha2 * dtr)))
            End If
        Next h
    End If
    
    'LUMENS FOR THE ENDING ZONE
    Dim lumensEnd As Double
    lumensEnd = 0
    If VAngleEnd > intensityB(1, vEnd, 2) Then
        'ADD SLIVER OF ZONE FROM THE STARTING SIDE OF THE ANGULAR ZONE.
        va1 = intensityB(1, vStart, 2)
        va2 = VAngleStart
        dMH = MH * Tan(va1 * dtr)
        dForward = Sqr(dMH ^ 2 + MH ^ 2)
        For h = 1 To (UBound(intensityB, 1) - 1)
            ha1 = intensityB(h, 1, 1) + 90
            ha2 = intensityB(h + 1, 1, 1) + 90
            
            dRoad = dForward * Tan((ha1 - 90) * dtr)
            If dRoad >= hTRLStart And dRoad <= hTRLend Then
                'POINT FALLS INBETWEEN THE HORIZONTAL TARGET ZONE
                Call IES.GetIESIntensityB(intensityB, va2, intensityB(h, 1, 1), i1)
                Call IES.GetIESIntensityB(intensityB, va2, intensityB(h + 1, 1, 1), i2)
                i3 = intensityB(h + 1, vStart, 3)
                i4 = intensityB(h, vStart, 3)
                iZone = (i1 + i2 + i3 + i4) / 4
                lumensEnd = lumensEnd + Abs(((va2 * dtr) - (va1 * dtr)) * iZone * (Cos(ha1 * dtr) - Cos(ha2 * dtr)))
            End If
        Next h
    End If
    
    
    lumens = lumens + lumensStart + lumensEnd
End Function


Public Function GetLumDimsString(ByVal lum, ByRef dimStr As String)
    'This function takes in the IESFile variable for the luminaire and outputs a string describing the
    'luminous dimensions according to the shape called out by the signs of the values in the ies file.
    '
    'So instead of showing "-1.2 x -1.2 x 0", it will output "1.2' Diameter"
    Dim w, L, h As Double
    w = lum.LuminousWidth       'order of ies file values <width> <length> <height>
    L = lum.LuminousLength
    h = lum.LuminousHeight
    
    Dim foundArea As Boolean
    foundArea = False
    
    Dim units As String
    If lum.units = 1 Then
        units = "'"
    ElseIf lum.units = 2 Then
        units = "m"
    Else
        units = ""
    End If
    '-----------------------------------------------------------
    'The '+/+/0 dictation is the W/L/H dimentions from the ies
    'file.
    
    '*****ADD ABS TO ALL VALUE OUTPUTS*******
    
    dimStr = ""
    'POINT SOURCE------------------------------------------
    '0/0/0
    If w = 0 And L = 0 And h = 0 Then
        dimStr = "Point Source " _
                & "(0" & units _
                & " x 0" & units _
                & " x 0" & units & ")"
                
    'RECTANGULAR-------------------------------------------
    '+/+/0
    ElseIf w > 0 And L > 0 And h = 0 Then
        dimStr = "Rectangular " _
                & "(W " & Round(w, 2) & units & " x " _
                & "L: " & Round(L, 2) & units & " x " _
                & "H: " & Round(h, 2) & units & ")"

    'RECTANGULAR WITH LUMINOUS SIDES-----------------------
    '+/+/+
    ElseIf w > 0 And L > 0 And h > 0 Then
        dimStr = "Rectangular w/ Sides " _
                & "(W: " & Round(w, 2) & units & " x " _
                & "L: " & Round(L, 2) & units & " x " _
                & "H: " & Round(h, 2) & units & ")"
    
    
    'CIRCULAR AND ELLIPSE----------------------------------
    '-/-/0
    ElseIf w < 0 And L < 0 And h = 0 Then
        If w = L Then
            'circular
            dimStr = "Circular " _
                    & "(Dia: " & Round(Abs(w), 2) & units & " x " _
                    & "H: " & Round(h, 2) & units & ")"
        Else
            'elliptical
            dimStr = "Elliptical " _
                    & "(W: " & Round(Abs(w), 2) & units & " x " _
                    & "L: " & Round(Abs(L), 2) & units & " x " _
                    & "H: " & Round(h, 2) & units & ")"
        End If
        
    'VERTICAL CYLINDER AND VERTICAL ELLIPSOIDAL CYLINDER----------
    '-/-/+
    ElseIf w < 0 And L < 0 And h > 0 Then
        If w = L Then
            'Vertical Cylinder
            dimStr = "Vertical Cylinder " _
                    & "(Dia: " & Round(Abs(w), 2) & units & " x " _
                    & "H: " & Round(h, 2) & units & ")"
        Else
            'Vertical Ellipsoidal Cylinder
            dimStr = "Vertical Ellipsoidal Cylinder " _
                    & "(W: " & Round(Abs(w), 2) & units & " x " _
                    & "L: " & Round(Abs(L), 2) & units & " x " _
                    & "H: " & Round(h, 2) & units & ")"
        End If
        
    'SPHERE/ELLIPSOIDAL SPHEROID-----------------------------------
    '-/-/-
    ElseIf w < 0 And L < 0 And h < 0 Then
        If w = L And w = h Then
            'Sphere
            dimStr = "Sphere " _
                    & "(Dia: " & Round(Abs(w), 2) & units & ")"
        Else
            'Ellipsoidal Spheroid
            dimStr = "Ellipsoidal Spheroid " _
                    & "(W: " & Round(Abs(w), 2) & units & " x " _
                    & "L: " & Round(Abs(L), 2) & units & " x " _
                    & "H: " & Round(Abs(h), 2) & units & ")"
        End If
        
    'HORIZ CYLINDER AND HORIZ ELLIPSOIDAL CYLINDER (ALONG PHOTO HORIZ)-----
    '-/+/-
    ElseIf w < 0 And L > 0 And h < 0 Then
        If w = h Then
            'Horizontal Cylinder along photometric horizontal
            dimStr = "Horizontal Cylinder Along Photometric Horizontal " _
                    & "(Dia: " & Round(Abs(w), 2) & units & " x " _
                    & "L: " & Round(L, 2) & units & ")"
        Else
            'Horizontal Ellipsoidal Cylinder along photometric horizontal
            dimStr = "Horizontal Ellipsoidal Cylinder Along Photometric Horizontal " _
                    & "(W: " & Round(Abs(w), 2) & units & " x " _
                    & "H: " & Round(Abs(h), 2) & units & " x " _
                    & "L: " & Round(L, 2) & units & ")"
        End If
    
    'HORIZ CYLINDER AND HORIZ ELLIPSOIDAL CYLINDER (PERP TO PHOTO HORIZ)------
    '+/-/-
    ElseIf w > 0 And L < 0 And h < 0 Then
        If L = h Then
            'Horizontal Cylinder perp to photometric horizontal
            dimStr = "Horizontal Cylinder Perpendicular to Photometric Horizontal " _
                    & "(Dia: " & Round(Abs(L), 2) & units & " x " _
                    & "W: " & Round(w, 2) & units & ")"
        Else
            'Horizontal Ellipsoidal Cylinder perp to photometric horizontal
            dimStr = "Horizontal Ellipsoidal Cylinder Perpendicular to Photometric Horizontal " _
                    & "(L: " & Round(Abs(L), 2) & units & " x " _
                    & "H: " & Round(Abs(h), 2) & units & " x " _
                    & "W: " & Round(w, 2) & units & ")"
        End If

    'VERTICAL CIRCLE AND ELLIPSE FACING PHOTO HORIZ------------------------
    '-/0/-
    ElseIf w < 0 And L = 0 And h < 0 Then
        If w = h Then
            'Vertical Circle Facing Photo Horizontal
            dimStr = "Vertical Circle Facing Photometric Horizontal " _
                    & "(Dia: " & Round(Abs(w), 2) & units & ")"
        Else
            'Vertical Ellipse Facing Photo Horizontal
            dimStr = "Vertical Ellipse Facing Photometric Horizontal " _
                    & "(W: " & Round(Abs(w), 2) & units & " x " _
                    & "H: " & Round(Abs(h), 2) & units & ")"
        End If
    End If
    
    'ASSIGN DEFAULT IF NOT FOUND FROM ABOVE IF-STATEMENT
    If dimStr = "" Then
        'Default to (L: #, W: #, H:#)
        dimStr = "(L: " & Round(lum.LuminousLength, 2) & " " & units & " x " _
               & "W: " & Round(lum.LuminousWidth, 2) & " " & units & " x " _
               & "H: " & Round(lum.LuminousHeight, 2) & " " & units

    End If
    

End Function

Attribute VB_Name = "IESFile"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'STANDARD PROPERTIES
Public fileName As String
Public NumberLamps As Integer
Public LampLumens As Double
Public GeneralMultiplier As Double
Public NumVAngles As Integer
Public NumHAngles As Integer
Public PhotometryType As Integer
Public units As Integer
Public LuminousLength As Double
Public LuminousWidth As Double
Public LuminousHeight As Double
Public BallastFactor As Double
Public FutureUse As Double
Public InputWatts As Double

'TILT=INCLUDE PROPERTIES
Public LampToLuminaire As Double
Public NumTiltAngles As Integer

'INTEGER VALUES FOR LampToLuminaire AND THEIR MEANING
'    1   Lamp base is either vertical base up or vertical base down when
'        the luminaire is aimed straight down.
'    2   Lamp is horizontal and remains horizontal when the luminaire is
'        aimed straight down or rotated about the zero-degree horizontal
'        plane.
'    3   Lamp is horizontal when the luminaire is pointed straight down,
'        but does not remains horizontal when the luminaire is rotated
'        about the zero-degree horizontal plane.


'You cannot initiate a new instance of this class from another workbook.  There is a work-around for this
' by having a function in this project (FOY) in Misc that returns an instance of IESFile.
' See FOY.Misc.ReturnClassIESFile() for details.  I have gone away from this since IESFile class is not changin
' anytime soon.  It is not a big deal to have individual class modules of IESFile in each project.
Attribute VB_Name = "Program"
Option Explicit

'COLOR NUMBERS
'0 = No Fill Color
'1 = Black
'2 = White
'----------------------RED COLUMN
'1  = Black
'9  = Dark Red
'3  = Red
'7  = Pink
'38 = Rose
'----------------------ORANGE COLUMN
'53 = Brown
'46 = Orange
'45 = Light Orange
'44 = Gold
'40 = Tan
'----------------------YELLOW COLUMN
'52 = Olive Green
'12 = Dark Yellow
'43 = Lime
'6  = Yellow
'36 = Light Yellow
'----------------------GREEN COLUMN
'51 = Dark Green
'10 = Green
'50 = Sea Green
'4  = Bright Green
'35 = Light Green
'43 = Lime
'----------------------CYAN COLUMN
'49 = Dark Teel
'14 = Teel
'42 = Aqua
'8  = Turquoise
'34 = Light Turquoise
'----------------------BLUE COLUMN
'11 = Dark Blue
'5  = Blue
'41 = Light Blue
'33 = Sky Blue
'37 = Pale Blue
'----------------------PURPLE COLUMN
'55 = Indigo
'47 = Blue-Gray
'13 = Violet
'54 = Plum
'39 = Lavender
'----------------------GRAY COLUMN
'56 = Gray 80%
'16 = Gray 50%
'48 = Gray 40%
'15 = Gray 25%
'2  = White
'----------------------

Public Sub Run()
    
    Dim h As Integer
    Dim v As Integer
    Dim r As Integer
    Dim c As Integer
    Dim i As Integer
    
    Dim numVA As Integer
    Dim numHA As Integer
    Dim sheetName As String
    
    Dim intensity() As Double
    Dim header() As String
    'Dim iesBase As IESFile
    'Set iesBase = New IESFile
    
    Dim lumensBase As Double
    Dim lumensNew As Double
    
    Dim lum As IESFile
    Set lum = New IESFile
    
    
    
    'GET THE INTENSITY ARRRAY FOR BASE FILE--------------------------------------------------------------
    sheetName = Sheet1.[sheetNum] 'TAB NAME WITH INTENSITY DATA
    numVA = 0
    numHA = 0
    Do  'Count horizontal angles
        numHA = numHA + 1
    Loop While Sheets(CStr(sheetName)).Cells(1, numHA + 1) <> ""
    numHA = numHA - 1
    Do  'Count vertical angles
        numVA = numVA + 1
    Loop While Sheets(CStr(sheetName)).Cells(numVA + 1, 1) <> ""
    numVA = numVA - 1
    
    ReDim intensity(1 To numHA, 1 To numVA, 1 To 3) As Double
    For h = 1 To numHA  'Assign intensities to array
        For v = 1 To numVA
            intensity(h, v, 1) = Sheets(CStr(sheetName)).Cells(1, h + 1).value    'Horizontal Angle
            intensity(h, v, 2) = Sheets(CStr(sheetName)).Cells(v + 1, 1).value    'Vertical Angle
            intensity(h, v, 3) = Sheets(CStr(sheetName)).Cells(v + 1, h + 1)      'Intensity
        Next v
    Next h
    
    
    'GET THE HEADER INFORMATION FOR BASE IES FILE-------------------------------------------------
    c = numHA + 8
    r = 4
    i = 1
    Do While Sheets(CStr(sheetName)).Cells(r, c) <> ""
        ReDim Preserve header(1 To i) As String
        header(i) = Sheets(CStr(sheetName)).Cells(r, c)
        r = r + 1
        i = i + 1
    Loop
    
    'CORRECT HEADER INFORMATION TO REFLECT NEW IES FILE-------------------------------------------
    'TEST NO.
    header(2) = "[TEST]DEFINE LENGTH TOOL"
    header(5) = "[ISSUEDATE]" & Sheet1.[Date]
    header(7) = "[LUMCAT]" & Sheet1.[lumCatNew]
    header(10) = Sheet1.[lamp]
    header(14) = Sheet1.[cri]
    header(15) = Sheet1.[cct]
    header(19) = "[_ABSOLUTELUMENS]" & Round(Sheet1.[lumensNew])
    
    'GET IES CLASS DATA AND MODIFY TO NEW FIXTURE------------------------------------------------
    r = 1
    c = 1
    Do While Sheets(CStr(sheetName)).Cells(r, c) <> "Photometric Filename:"
        c = c + 1
    Loop
    Do While Sheets(CStr(sheetName)).Cells(r, c) <> "Characteristics"
        r = r + 1
    Loop
    'from base sheet
    lum.BallastFactor = Sheets(CStr(sheetName)).Cells(r + 7, c + 1)
    lum.FutureUse = 1
    lum.GeneralMultiplier = 1
    lum.InputWatts = Sheets(CStr(sheetName)).Cells(r + 6, c + 1)
    lum.LampLumens = Sheets(CStr(sheetName)).Cells(r + 2, c + 1)
    'lum.LampToLuminaire
    lum.LuminousHeight = Sheets(CStr(sheetName)).Cells(r + 13, c + 1)
    lum.LuminousLength = Sheets(CStr(sheetName)).Cells(r + 11, c + 1)
    lum.LuminousWidth = Sheets(CStr(sheetName)).Cells(r + 12, c + 1)
    lum.NumberLamps = Sheets(CStr(sheetName)).Cells(r + 1, c + 1)
    lum.NumHAngles = numHA
    lum.NumVAngles = numVA
    'lum.NumTiltAngles
    lum.PhotometryType = 1  'type C
    lum.units = 1           'feet
    
    'SCALE INTENSITY ARRAY BY THE LUMEN MULT
    lumensBase = IES.GetLuminaireLumens(intensity, lum)
    For h = 1 To numHA  'Assign intensities to array
        For v = 1 To numVA
            intensity(h, v, 3) = intensity(h, v, 3) * Sheet1.[lumenMult]      'Intensity
        Next v
    Next h
    lumensNew = IES.GetLuminaireLumens(intensity, lum)
    lum.InputWatts = lum.InputWatts * Sheet1.[wattMult]
    
    'NEW LUM DIMS
    lum.LuminousHeight = Sheet1.[lumHeight]
    lum.LuminousLength = Sheet1.[lumLength]
    lum.LuminousWidth = Sheet1.[lumWidth]
    
    'SETUP NEW FILE NAME
    Dim fileName As String
    If Sheet1.[ProjectName] <> "" Then
        fileName = Left(Sheet1.[ProjectName], 8) & "_" 'limited project name to 8 characters
    End If
    If Sheet1.[SchType] <> "" Then
        fileName = fileName & Left(Sheet1.[SchType], 6) & "_" 'limited fixture schedule type to 6 characters
    End If
    fileName = Sheet1.[directory] & "\" & fileName & Sheet1.[lumCatNew] & ".ies"
    Call IES.WriteIESFileAvoidOverwrite(header, lum, intensity, fileName)
    
    
End Sub



Public Sub Directory1()

    'Debug.Print "INPUT:        " & CurDir
    If Sheets(1).[directory] <> "" Then
        On Error Resume Next
        ChDir Sheets(1).[directory]
        If Err = 13 Then
            ChDir "C:/"
        End If
    End If
    
    'GET THE DIRECTORY FOLDER FOR THE PRORATION, AND COUNT THE IES FILES IN THE FOLDER (OR FOLDER W/ SUBFOLDERS)
    Dim directory As String
    Dim fileFilter As String
    Dim numFiles As Integer
    
    fileFilter = "*.ies"
    Call DialogWindows.FolderPicker(directory)
    If directory = "" Then
        directory = Sheets(1).[directory]
    Else
        Sheets(1).[directory] = directory
    End If
    
    'FORMAT THE DIRECTORY IN THE CELL
    Dim i As Integer
    Dim length As Integer
    Dim countSlash As Integer
    Dim strLoc As Integer
    Dim strLocLast As Integer
    Dim slash As String
    slash = "\"
    length = Len(directory)
    
    i = 0
    strLoc = 0
    strLocLast = 0
    countSlash = 0
    
    'RESET FONT
    With Sheets(1).[directory].Font
        .ColorIndex = 16
        .Bold = False
    End With
    
    'BOLD AND BLUE THE SLASHES
    Do
        strLocLast = strLoc
        strLoc = InStr(strLoc + 1, directory, slash, vbTextCompare)
        countSlash = countSlash + 1
        If strLoc <> 0 Then
            With Sheets(1).[directory].Characters(Start:=strLoc, length:=1).Font
                .Bold = True
                .ColorIndex = 1 '5 'blue
                .Size = 12
            End With
        End If
    Loop While strLoc <> 0
    countSlash = countSlash - 1
    
    'BOLD AND BLUE THE LAST FOLDER
    With Sheets(1).[directory].Characters(Start:=strLocLast + 1, length:=(length - strLocLast)).Font
        .ColorIndex = 1 '5 '11 '5
        .Bold = True
    End With


End Sub


Public Function LinearInterpolateXLArray(x As Variant, y As Variant, xthis) As Variant
    'LINEAR INTERPOLATION as an excel function to use in cells
    
    Dim xDiff As Double
    Dim xPass As Double
    Dim xFrac As Double
    Dim iDiff As Double
    Dim iPass As Double
    
    Dim xAr As Variant  'array of x variables from selection
    Dim yAR As Variant  'array of y variables from selection
    Dim r As Integer    'row index
    Dim c As Integer    'col index
    Dim r2 As Integer   'row index for sorting
    Dim c2 As Integer   'col index for sorting
    Dim dr As Integer   'row index increment (if vertical array then dr = 1 and dc = 0)
    Dim dc As Integer   'col index increment (if horizontal array then dr = 0 and dc = 1)

    Dim maxIndex As Integer 'maximum index value to check if done looping during the sort/looping
    Dim temp As Variant

    Dim x1 As Double
    Dim x2 As Double
    Dim y1 As Double
    Dim y2 As Double
       
    xAr = x
    yAR = y
    
    'CHECK THAT xAR AND yAR ARE THE SAME SIZE
    If (UBound(xAr, 1) = UBound(yAR, 1)) And (UBound(xAr, 2) = UBound(yAR, 2)) Then
        'good
    Else
        'bad
        'MsgBox "X and Y arrays must be the same size, try again.", vbOKOnly
        LinearInterpolateXLArray = "#ARDIMS1"
        Exit Function
    End If
    
    'CHECK THE xAR DIMENSIONS FOR A SINGLE DIMENSION ARRAY - horiz or vert, assign dr and cr appropriately
    If UBound(xAr, 1) > 1 Then
        'VERTICAL ARRAY
        If UBound(xAr, 2) = 1 Then
            'single column - good to go
            dr = 1
            dc = 0
            maxIndex = UBound(xAr, 1)
        Else
            'MsgBox "Array must be 1 dimensional, try again", vbOKOnly
            LinearInterpolateXLArray = "#ARDIMS2"
            Exit Function
        End If
    ElseIf UBound(xAr, 2) > 1 Then
        'HORIZONTAL ARRAY
        If UBound(xAr, 1) = 1 Then
            'single row - good to go
            dr = 0
            dc = 1
        Else
            'MsgBox "Array must be 1 dimensional, try again", vbOKOnly
            LinearInterpolateXLArray = "#ARDIMS3"
            Exit Function
        End If
    Else
        'MsgBox "Array must be more than one cell, try again", vbOKOnly
        LinearInterpolateXLArray = "#ARDIMS4"
        Exit Function
    End If
    
    'SORT THE ARRAYS ASCENDING BY xAR
        'you can rearrange the xAR arrays and it doesn't do anything to the spreadsheet cells - good
    r = 1
    c = 1
    Do
        r2 = r
        c2 = c
        Do
            If xAr(r2, c2) < xAr(r, c) Then
                'swap xAR
                temp = xAr(r, c)
                xAr(r, c) = xAr(r2, c2)
                xAr(r2, c2) = temp
                'swap yAR
                temp = yAR(r, c)
                yAR(r, c) = yAR(r2, c2)
                yAR(r2, c2) = temp
            End If
            r2 = r2 + dr
            c2 = c2 + dc
        Loop While (r2 < maxIndex And c2 < maxIndex)
        r = r + dr
        c = c + dc
    Loop While (r < maxIndex And c < maxIndex)
    
    'STEP THROUGH AND GET THE SURROUNDING VALUES FOR THE INTERPOLATION
    'SPECIAL CASES
    If xthis < xAr(1, 1) Then
        'xThis smaller than anything in list - use first two values as a linear trend
        x1 = xAr(1, 1)
        x2 = xAr(1 + dr, 1 + dc)
        y1 = yAR(1, 1)
        y2 = yAR(1 + dr, 1 + dc)
    ElseIf xthis > xAr(UBound(xAr, 1), UBound(xAr, 2)) Then
        'xThis larger than anything in list - use last two values as a linear trend
        x1 = xAr(UBound(xAr, 1) - dr, UBound(xAr, 2) - dc)
        x2 = xAr(UBound(xAr, 1), UBound(xAr, 2))
        y1 = yAR(UBound(yAR, 1) - dr, UBound(yAR, 2) - dc)
        y2 = yAR(UBound(yAR, 1), UBound(yAR, 2))
    Else
        'find higher and lower bounding x and y
        r = 1 + dr
        c = 1 + dc
        Do
            Debug.Print xAr(r, c)
            If xAr(r, c) = xthis Then
                LinearInterpolateXLArray = yAR(r, c)
                Exit Function
            ElseIf xAr(r, c) > xthis Then
                x1 = xAr(r - dr, c - dc)
                x2 = xAr(r, c)
                y1 = yAR(r - dr, c - dc)
                y2 = yAR(r, c)
                Exit Do
            End If
            r = r + dr
            c = c + dc
        Loop While (r <= maxIndex And c <= maxIndex)
        
    End If
    
    'INTERPOLATE
    xDiff = x2 - x1
    xPass = xthis - x1
    xFrac = xPass / xDiff
    iDiff = y2 - y1         'IESintensity(k2, m1, 3) - IESintensity(k1, m1, 3)
    iPass = xFrac * iDiff
    LinearInterpolateXLArray = y1 + iPass
    
End Function










Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

'COLOR NUMBERS
'0 = No Fill Color
'1 = Black
'2 = White
'----------------------RED COLUMN
'1  = Black
'9  = Dark Red
'3  = Red
'7  = Pink
'38 = Rose
'----------------------ORANGE COLUMN
'53 = Brown
'46 = Orange
'45 = Light Orange
'44 = Gold
'40 = Tan
'----------------------YELLOW COLUMN
'52 = Olive Green
'12 = Dark Yellow
'43 = Lime
'6  = Yellow
'36 = Light Yellow
'----------------------GREEN COLUMN
'51 = Dark Green
'10 = Green
'50 = Sea Green
'4  = Bright Green
'35 = Light Green
'43 = Lime
'----------------------CYAN COLUMN
'49 = Dark Teel
'14 = Teel
'42 = Aqua
'8  = Turquoise
'34 = Light Turquoise
'----------------------BLUE COLUMN
'11 = Dark Blue
'5  = Blue
'41 = Light Blue
'33 = Sky Blue
'37 = Pale Blue
'----------------------PURPLE COLUMN
'55 = Indigo
'47 = Blue-Gray
'13 = Violet
'54 = Plum
'39 = Lavender
'----------------------GRAY COLUMN
'56 = Gray 80%
'16 = Gray 50%
'48 = Gray 40%
'15 = Gray 25%
'2  = White
'----------------------

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    Dim r As Integer
    Dim c As Integer

    If Not Application.Intersect(Target, Range(Sheet1.[pickBox].Address)) Is Nothing Then
        Debug.Print "clicky"
        Debug.Print Target.Column
        Debug.Print Sheet1.[pickBox].Column
        
        Debug.Print "index " & Target.Column - Sheet1.[pickBox].Column + 1
        
        c = Target.Column - Sheet1.[pickBox].Column + 1
        r = Target.row - Sheet1.[pickBox].row + 1
        
        
        If Target.text <> "" And Target.text <> "-" And c <> 5 Then
            If c <> 4 Then 'ignore if lumen callout - formula based
                Sheet1.[lumcatstart].Cells(1, c) = Target
            Else
                Sheet1.[custLumens] = ""
                Sheet1.[lumenrow] = r + 1
            End If
        
            'CHECK IF S121 AND "CORE" - CHANGE TO "STANDARD"
            If r = 1 And c = 1 Then
                If Sheet1.[lumcatstart].Cells(1, 3) = "C" Then
                    Sheet1.[lumcatstart].Cells(1, 3) = "S"
                End If
            End If
            
            
        End If
        
    End If
    
End Sub












Attribute VB_Name = "Sheet10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet13"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet15"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet16"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet17"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet18"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet19"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet20"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet21"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet22"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet23"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet24"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet25"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet26"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet27"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet28"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet29"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet30"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet31"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet32"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet33"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet34"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet35"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet36"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet37"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet38"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet39"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet40"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet41"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet42"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet43"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet44"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet45"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet46"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet47"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet48"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet49"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet5"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet50"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet51"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet52"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet53"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet54"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet55"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet56"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet57"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet58"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_Open()
    'Protect, even if already protected
    'MsgBox "before lock"
    
    'specific sheets
    Sheet1.Protect Password:="trC!2{:", UserInterfaceOnly:=True
    Sheet2.Protect Password:="trC!2{:", UserInterfaceOnly:=True
    Sheet3.Protect Password:="trC!2{:", UserInterfaceOnly:=True
    Sheet4.Protect Password:="trC!2{:", UserInterfaceOnly:=True
    
    'whole workbook
    ActiveWorkbook.Protect Password:="trC!2{:", Structure:=True, Windows:=True
    
    
    
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    'MsgBox "after lock"
       
End Sub

' InQuest injected base64 decoded content
' ~'"z{N}Kb

INQUEST-PP=macro
