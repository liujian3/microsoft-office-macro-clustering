Attribute VB_Name = "CO_Archiv"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_Archiv
'Oliver Seidel 14.07.2000
'  Collection der Archive, Key:=C_Archiv::ID
'  - (get) DPArchiv ermittelt das komplette DPE inkl. Verdichtungsstufe und DPE der Funktion
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoArchiv As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get DPArchiv(sDP As String, sDPE As String, sDPT As String, sDPFkt As String) As String

Dim oArchiv As C_Archiv
Dim oDPFkt  As C_DPFunktion

  DPArchiv = ""
  For Each oArchiv In mcoArchiv
    If (oArchiv.dpe = sDPE) And _
       (oArchiv.dpt = sDPT) Then
      For Each oDPFkt In oArchiv.coDPFkt.Items
        If oDPFkt.Bezeichnung = sDPFkt Then
          
          If Len(sDPE) > 0 Then
            DPArchiv = sDP & "." & sDPE & "." & oArchiv.VStufe & "." & oDPFkt.dpe
          Else
            DPArchiv = sDP & "." & oArchiv.VStufe & "." & oDPFkt.dpe
          End If
          Exit Property
          
        End If
      Next oDPFkt
    End If
  Next oArchiv

End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoArchiv.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oArchiv As C_Archiv)
  mcoArchiv.Add oArchiv, CStr(oArchiv.ID)  'Key(oArchiv.DPT, oArchiv.DPE, oArchiv.VStufe)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoArchiv.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lID As Long) As C_Archiv
  Set Item = mcoArchiv(lID)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoArchiv
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_Archiv
  On Error Resume Next
  Set FindItem = mcoArchiv(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Public Function xKey(sDPT As String, sDPE As String, sVStufe As String) As String
  'Key = sDPT & "|" & sDPE & "|" & sVStufe
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoArchiv = New Collection
  Call M_Debug.addRef("CO_Archiv", glCOArchivInstanz, glCOArchivInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_Archiv", glCOArchivInstanz, glCOArchivInstanzMax)
End Sub


Attribute VB_Name = "CO_Basiswert"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_Basiswert
'Oliver Seidel 14.07.2000
'  Collection der Basiswerte, Key:=C_Basiswert::Bezeichnung
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoBasiswert As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoBasiswert.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oBasiswert As C_Basiswert)
  mcoBasiswert.Add oBasiswert, oBasiswert.Bezeichnung
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoBasiswert.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(sKey As String) As C_Basiswert
  Set Item = mcoBasiswert(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoBasiswert
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_Basiswert
  On Error Resume Next
  Set FindItem = mcoBasiswert(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoBasiswert = New Collection
  Call M_Debug.addRef("CO_Basiswert", glCOBasiswertInstanz, glCOBasiswertInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_Basiswert", glCOBasiswertInstanz, glCOBasiswertInstanzMax)
End Sub


Attribute VB_Name = "CO_BlattOffset"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'CO_CostCenter
'Wolfram Klebel 26.6.09
'  Collection der Blatt Offsets
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoBlattOffset As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoBlattOffset.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oBO As C_BlattOffset)
  mcoBlattOffset.Add oBO, CStr(oBO.lIndex)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As Long)
  mcoBlattOffset.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_BlattOffset
  Set Item = mcoBlattOffset(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoBlattOffset
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As Long) As C_BlattOffset
  On Error Resume Next
  Set FindItem = mcoBlattOffset(CStr(sKey))
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoBlattOffset = New Collection
  Call M_Debug.addRef("CO_BlattOffset", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_BlattOffset", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub




Attribute VB_Name = "CO_CostCenter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'CO_CostCenter
'Wolfram Klebel 26.6.09
'  Collection der Kostenstellen
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoCostCenter As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoCostCenter.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oCCName As C_CostCenter)
  mcoCostCenter.Add oCCName, oCCName.Bezeichnung
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoCostCenter.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_CostCenter
  Set Item = mcoCostCenter(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoCostCenter
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_CostCenter
  On Error Resume Next
  Set FindItem = mcoCostCenter(sKey)
End Function

'---------------------------------------------------------------------------------------------------
'Public Function Tariffset(sKey As String) As C_Tariffset
'Dim cCostCenter As C_CostCenter
'Dim coTariffset As CO_Tariffset
'
'  On Error Resume Next
'  Set cCostCenter = FindItem(sKey)
'  Set coTariffset = M_Tariffset.coLesen
'  Set Tariffset = coTariffset.FindItem(cCostCenter.Tariffset)
'  On Error GoTo 0
'
'End Function
'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoCostCenter = New Collection
  Call M_Debug.addRef("CO_CostCenter", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_CostCenter", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub



Attribute VB_Name = "CO_DP"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_DP
'Oliver Seidel 14.07.2000
'  Collection der Datenpunkte, Key:=C_DP::Archiv|C_DP::Offset
'  Es werden zwei Collections gefuehrt: Jeder DP kann mehrfach referenziert werden! (optional)
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoDP       As Collection
Private mcoDPRef    As Collection
Private mcoDPGroup  As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoDP.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oDP As C_DP, Optional oDPRef As C_DPReferenz)
  
Dim lIndex As Long
Dim sKey   As String
Dim oDpGroup  As C_DPGruppe
Dim boInGroup As Boolean
Dim sArchivTyp  As String

  'Der Dp wird in eine Gruppe eingereiht, falls er nicht
  'eh schon beruecksichtigt worden ist.
  boInGroup = True
  If oDPRef Is Nothing Then
    mcoDP.Add oDP
    Exit Sub
  End If
  
  sKey = Key(oDP.ArchivFkt, oDP.ArchivTyp, oDP.Archiv, oDP.Offset)
  On Error Resume Next
  mcoDP.Add oDP, sKey
  If Err Then
    For lIndex = 1 To mcoDP.Count
      If Key(mcoDP(lIndex).ArchivFkt, mcoDP(lIndex).ArchivTyp, _
             mcoDP(lIndex).Archiv, mcoDP(lIndex).Offset) = sKey Then
        Exit For
      End If
    Next lIndex
    boInGroup = False
  Else
    lIndex = mcoDP.Count
  End If
  
  oDPRef.index = lIndex
  mcoDPRef.Add oDPRef
    
  If boInGroup Then
    For Each oDpGroup In mcoDPGroup
      If oDpGroup.Von = oDP.Von And _
         oDpGroup.Bis = oDP.Bis And _
         oDpGroup.PVSSSystem = oDP.PVSSSystem And _
         oDpGroup.ArchivTyp = oDP.ArchivTyp Then
        oDpGroup.coDP.Add oDP
        Exit Sub
      End If
    Next oDpGroup
    
    Set oDpGroup = New C_DPGruppe
    oDpGroup.Von = oDP.Von
    oDpGroup.Bis = oDP.Bis
    oDpGroup.PVSSSystem = oDP.PVSSSystem
    oDpGroup.ArchivTyp = oDP.ArchivTyp
    oDpGroup.coDP.Add oDP
    mcoDPGroup.Add oDpGroup, oDpGroup.Key
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
'Public Sub Remove(sArchiv As String, Optional lOffset As Long = 0)
'  mcoDP.Remove Key(sArchiv, lOffset)
'End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(ByVal lIndex As Long) As C_DP
  Set Item = mcoDP(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoDP
End Function

'---------------------------------------------------------------------------------------------------
Public Property Get RefItems() As Collection
  Set RefItems = mcoDPRef
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get GroupItems() As Collection
  Set GroupItems = mcoDPGroup
End Property

'---------------------------------------------------------------------------------------------------
'Public Property Get FindItem(sArchiv As String, Optional lOffset As Long = 0) As C_DP
'  On Error Resume Next
'  Set FindItem = mcoDP(Key(sArchiv, lOffset))
'End Property

'---------------------------------------------------------------------------------------------------
Public Function Key(sDPE As String, iArchivTyp As Integer, sArchiv As String, Optional lOffset As Long = 0) As String
  Key = sDPE & "|" & iArchivTyp & "|" & sArchiv & "|" & CStr(lOffset)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoDP = New Collection
  Set mcoDPRef = New Collection
  Set mcoDPGroup = New Collection
  Call M_Debug.addRef("CO_DP", glCODPInstanz, glCODPInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_DP", glCODPInstanz, glCODPInstanzMax)
End Sub


Attribute VB_Name = "CO_DPFunktion"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_DPFunktion
'Oliver Seidel 14.07.2000
'  Collection der Funktionen, Key:=C_DPFunktion::Bezeichnung
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoDPFunktion As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoDPFunktion.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oDPFunktion As C_DPFunktion)
  mcoDPFunktion.Add oDPFunktion, oDPFunktion.Bezeichnung
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoDPFunktion.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(sKey As String) As C_DPFunktion
  Set Item = mcoDPFunktion(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoDPFunktion
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_DPFunktion
  On Error Resume Next
  Set FindItem = mcoDPFunktion(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoDPFunktion = New Collection
  Call M_Debug.addRef("CO_DPFunktion", glCODPFunktionInstanz, glCODPFunktionInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_DPFunktion", glCODPFunktionInstanz, glCODPFunktionInstanzMax)
End Sub


Attribute VB_Name = "CO_MailVerteiler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'CO_MailVerteiler
'Oliver Seidel 14.07.2000
'  Collection der MailVerteiler, Key:=C_MailVerteiler::Bezeichnung
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoMailVerteiler As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoMailVerteiler.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oMailVerteiler As C_MailVerteiler)
  mcoMailVerteiler.Add oMailVerteiler, oMailVerteiler.Bezeichnung
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoMailVerteiler.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Property Get Item(ByVal lIndex As Long) As C_MailVerteiler
  Set Item = mcoMailVerteiler(lIndex)
End Property

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoMailVerteiler
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_MailVerteiler
  On Error Resume Next
  Set FindItem = mcoMailVerteiler(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoMailVerteiler = New Collection
  Call M_Debug.addRef("CO_MailVerteiler", glCOMailVerteilerInstanz, glCOMailVerteilerInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_MailVerteiler", glCOMailVerteilerInstanz, glCOMailVerteilerInstanzMax)
End Sub


Attribute VB_Name = "CO_Media"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'CO_Media
'Wolfram Klebel 9.11.10
'  Collection of Media
'Changes: -none-
'===================================================================================================
Option Explicit

Private mcoMedia As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoMedia.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oMedia As C_Medium)
  mcoMedia.Add oMedia, oMedia.Name
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoMedia.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_Medium
  Set Item = mcoMedia(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoMedia
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_Medium
  On Error Resume Next
  Set FindItem = mcoMedia(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoMedia = New Collection
  Call M_Debug.addRef("CO_Media", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_Media", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub





Attribute VB_Name = "CO_Optionen"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'CO_Optionen
'Oliver Seidel 14.07.2000
'  Collection der Optionen, Key:=C_Optionen::Host
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoOptionen As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoOptionen.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oOptionen As C_Optionen)
  mcoOptionen.Add oOptionen, oOptionen.host
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoOptionen.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_Optionen
  Set Item = mcoOptionen(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoOptionen
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_Optionen
  On Error Resume Next
  Set FindItem = mcoOptionen(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoOptionen = New Collection
  Call M_Debug.addRef("CO_Optionen", glCOOptionenInstanz, glCOOptionenInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_Optionen", glCOOptionenInstanz, glCOOptionenInstanzMax)
End Sub


Attribute VB_Name = "CO_Protokoll"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_Protokoll
'Oliver Seidel 14.07.2000
'  Collection der Protolle, Key:=C_Protkoll::Bezeichnung
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoProtokoll As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoProtokoll.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oProtokoll As C_Protokoll)
  mcoProtokoll.Add oProtokoll, oProtokoll.Bezeichnung
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoProtokoll.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_Protokoll
  Set Item = mcoProtokoll(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoProtokoll
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_Protokoll
  On Error Resume Next
  Set FindItem = mcoProtokoll(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoProtokoll = New Collection
  Call M_Debug.addRef("CO_Protokoll", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_Protokoll", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub


Attribute VB_Name = "CO_ProtokollTyp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_ProtokollTyp
'Oliver Seidel 14.07.2000
'  Collection der Protokolltypen, Key:=C_ProtokollTyp::Bezeichnung
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoProtTyp As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoProtTyp.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oProtTyp As C_ProtokollTyp)
  mcoProtTyp.Add oProtTyp, oProtTyp.Bezeichnung
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoProtTyp.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Property Get Item(ByVal lIndex As Long) As C_ProtokollTyp
  Set Item = mcoProtTyp(lIndex)
End Property

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoProtTyp
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_ProtokollTyp
  On Error Resume Next
  Set FindItem = mcoProtTyp(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoProtTyp = New Collection
  Call M_Debug.addRef("CO_ProtokollTyp", glCOProtokollTypInstanz, glCOProtokollTypInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_ProtokollTyp", glCOProtokollTypInstanz, glCOProtokollTypInstanzMax)
End Sub


Attribute VB_Name = "CO_StatusBit"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_StatusBit
'Oliver Seidel 14.07.2000
'  Collection der StatusBits, Key:=C_StatusBit::Bezeichnung
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoStatusBit As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoStatusBit.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oStatusBit As C_StatusBit)
  mcoStatusBit.Add oStatusBit, oStatusBit.Bezeichnung
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoStatusBit.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_StatusBit
  Set Item = mcoStatusBit.Item(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoStatusBit
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_StatusBit
  On Error Resume Next
  Set FindItem = mcoStatusBit(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoStatusBit = New Collection
  Call M_Debug.addRef("C_StatusBit", glCStatusBitInstanz, glCStatusBitInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Set mcoStatusBit = Nothing
  Call M_Debug.Releas("C_StatusBit", glCStatusBitInstanz, glCStatusBitInstanzMax)
End Sub

Attribute VB_Name = "CO_TabBereich"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'CO_TabBereich
'Oliver Seidel 14.07.2000
'  Collection der Tabellenbereiche, Key:=C_TabBereich::Blatt|C_TabBereich::Bereich
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoTabBereich As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoTabBereich.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oTabBereich As C_TabBereich)
  mcoTabBereich.Add oTabBereich, GetKey(oTabBereich.Blatt, oTabBereich.Bereich)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(lBlatt As Long, sBereich As String)
  mcoTabBereich.Remove GetKey(lBlatt, sBereich)
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lBlatt As Long, sBereich As String) As C_TabBereich
  Set Item = mcoTabBereich(GetKey(lBlatt, sBereich))
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoTabBereich
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(lBlatt As Long, sBereich As String) As C_TabBereich
  On Error Resume Next
  Set FindItem = mcoTabBereich(GetKey(lBlatt, sBereich))
End Function

'---------------------------------------------------------------------------------------------------
Private Function GetKey(lBlatt As Long, sBereich As String) As String
  GetKey = CStr(lBlatt) & sBereich
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoTabBereich = New Collection
  Call M_Debug.addRef("CO_TabBereich", glCOTabBereichInstanz, glCOTabBereichInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_TabBereich", glCOTabBereichInstanz, glCOTabBereichInstanzMax)
End Sub

Attribute VB_Name = "CO_Tariffset"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'CO_Tariffset
'Wolfram Klebel 2.7.09
'  Collection der Tarifs|fffd|tze
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoTariffset As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoTariffset.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oCCName As C_Tariffset)
  mcoTariffset.Add oCCName, oCCName.Name
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoTariffset.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_Tariffset
  Set Item = mcoTariffset(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoTariffset
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_Tariffset
  On Error Resume Next
  Set FindItem = mcoTariffset(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoTariffset = New Collection
  Call M_Debug.addRef("CO_Tariffset", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_Tariffset", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub




Attribute VB_Name = "CO_TariffsetEntry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'CO_TariffsetEntry
'Wolfram Klebel 15.11.2010
'  Collection of tariffset entries
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoTsEntry As Collection

'---------------------------------------------------------------------------------------------------
Public Property Get Count() As Long
  Count = mcoTsEntry.Count
End Property

'---------------------------------------------------------------------------------------------------
Public Sub Add(oCCName As C_TariffsetEntry)
  mcoTsEntry.Add oCCName, oCCName.Name
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Remove(sKey As String)
  mcoTsEntry.Remove sKey
End Sub

'---------------------------------------------------------------------------------------------------
Public Function Item(lIndex As Long) As C_TariffsetEntry
  Set Item = mcoTsEntry(lIndex)
End Function

'---------------------------------------------------------------------------------------------------
Public Function Items() As Collection
  Set Items = mcoTsEntry
End Function

'---------------------------------------------------------------------------------------------------
Public Function FindItem(sKey As String) As C_TariffsetEntry
  On Error Resume Next
  Set FindItem = mcoTsEntry(sKey)
End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoTsEntry = New Collection
  Call M_Debug.addRef("CO_TariffsetEntry", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("CO_TariffsetEntry", glCOProtokollInstanz, glCOProtokollInstanzMax)
End Sub





Attribute VB_Name = "C_Archiv"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'C_Archiv
'Oliver Seidel 28.09.2000
'  Das Archiv ist die Beschreibung eines Elements, das in PVSS in der HDB gespeichert wird.
'  Im Gegensatz zur Parametrierung unter PVSS werden nicht nur elementare DPT aufgefuehrt, sondern
'  auch DPE die diese elementaren DPT referenzieren.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoDPFkt  As CO_DPFunktion  'Alle Funktionen, die unter der Verdichtungsstufe
                                    'gespeichert sind

Public ID         As Long     'Primaerschluessel
Public SYS        As String   'Das System
Public dpt        As String   'Der DPT
Public dpe        As String   'optional - falls angegeben, wird auf elementaren DPT referenziert
Public VStufe     As String   'Die Verdichtungsstufe
Public Intervall  As Long     'Intervall, in dem die Werte gespeichert werden
Public IntEinheit As Integer  'Einheit des Intervalls (Stunde, Tag,...)

'---------------------------------------------------------------------------------------------------
' WOKL: woher kommt das System? wer ist der Aufrufer? Was soll ich zur|fffd|ckgeben?
' Workbook_bevoreSave->M_Vorlage.Analysieren->M_Vorlage.DPlistSpeichern
' System ist im sDp enthalten; "dist_3:a1.C3.AVG_WT0"
Public Property Get DPArchiv(sDP As String, sDPFkt As String) As String

Dim oDPFkt  As C_DPFunktion

  DPArchiv = ""
  For Each oDPFkt In mcoDPFkt.Items
    If oDPFkt.Bezeichnung = sDPFkt Then
      
      If Len(dpe) > 0 Then
        DPArchiv = sDP & "." & dpe & "." & VStufe & "." & oDPFkt.dpe
      Else
        DPArchiv = sDP & "." & VStufe & "." & oDPFkt.dpe
      End If
      Exit Property
      
    End If
  Next oDPFkt
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let IntervallInSek(lIntervall As Long)
  Call SecToIntervallWithUnit(lIntervall, Me.Intervall, Me.IntEinheit)
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get IntervallInSek() As Long
  Intervall = IntervallWithUnitToSec(Me.Intervall, Me.IntEinheit)
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get IntervallStr() As String
  IntervallStr = IntervallWithUnitToStr(Me.Intervall, Me.IntEinheit)
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set coDPFkt(coNewDPFkt As CO_DPFunktion)
  Set mcoDPFkt = coNewDPFkt
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get coDPFkt() As CO_DPFunktion
  Set coDPFkt = mcoDPFkt
End Property

'---------------------------------------------------------------------------------------------------
Public Function Clone() As C_Archiv
  
  Set Clone = New C_Archiv
  With Clone
    .SYS = Me.SYS
    .dpt = Me.dpt
    .dpe = Me.dpe
    .VStufe = Me.VStufe
    .Intervall = Me.Intervall
    .IntEinheit = Me.IntEinheit
    'ToDo: werden Funktionen nicht geclont?
  End With

End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoDPFkt = New CO_DPFunktion
  Call M_Debug.addRef("C_Archiv", glCArchivInstanz, glCArchivInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_Archiv", glCArchivInstanz, glCArchivInstanzMax)
End Sub
Attribute VB_Name = "C_ArchivMsg"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_ArchivMsg
'Wolfram Klebel, 30.11.11
'  struct to manage the queries during import of archive data (see M_Archiv)
'Aenderungen: -keine-
'===================================================================================================

Option Explicit

Public mboACPara          As Boolean
Public mboRDBPara         As Boolean
Public miLastKeyPressed   As Integer      ' from right to left (1 - cancel, 2 - no, 3 - yes, ...)
Public msMsg              As String
Public mbAcRdbSelect      As Boolean
Public miSysCount         As Integer
Public miSysNo            As Integer


'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()

  mboACPara = True
  mboRDBPara = True
  mbAcRdbSelect = True
  miSysCount = 0
  miSysNo = 0
  
End Sub
Attribute VB_Name = "C_Basiswert"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'C_Basiswert
'Oliver Seidel 28.09.2000
'  Der Basiswert ist der Container fuer unterschiedliche Archive.
'  Das Intervall wird als Defaultwert fuer die Auswahl der Archive und fuer die Protokolltypen
'  benoetigt. Das Intervall hat keinen Einfuss auf die Protokollerstellung!
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoArchiv   As CO_Archiv  'Die enthaltenen Archive

Public ID           As Long       'Prmaerschluessel
Public Bezeichnung  As String     'Eindeutige Bezeichung des Basiswertes (Name)
Public Intervall    As Long       'Intervall
Public IntEinheit   As Integer    'Einheit des Intervalls (Stunde, Tag,...)

'---------------------------------------------------------------------------------------------------
Public Property Set coArchive(coNewArchiv As CO_Archiv)
  Set mcoArchiv = coNewArchiv
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get coArchive() As CO_Archiv
  Set coArchive = mcoArchiv
End Property

'---------------------------------------------------------------------------------------------------
Public Function Clone() As C_Basiswert

  Set Clone = New C_Basiswert
  With Clone
    .Bezeichnung = Me.Bezeichnung
    .Intervall = Me.Intervall
    .IntEinheit = Me.IntEinheit
    'ToDo: werden Archive nicht geclont?
  End With

End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoArchiv = New CO_Archiv
  Call M_Debug.addRef("C_Basiswert", glCBasiswertInstanz, glCBasiswertInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_Basiswert", glCBasiswertInstanz, glCBasiswertInstanzMax)
End Sub


Attribute VB_Name = "C_BlattOffset"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_DPWert
'Wolfram Klebel, 8.4.2011
'  Class for common textual attributes to a worksheet, first used with sheet offset (Blatt Offset)
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public lIndex       As Long     ' sheet index
Public sAttribute   As String
Public sValue       As String

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Call M_Debug.addRef("C_BlattOffset", glCDPWertInstanz, glCDPWertInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_BlattOffset", glCDPWertInstanz, glCDPWertInstanzMax)
End Sub



Attribute VB_Name = "C_ComCB"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private WithEvents moComMan As WCCOACOMLib.ComManager   ' COMMANLib.PVSS
Attribute moComMan.VB_VarHelpID = -1


Public Sub init(oComMan As ComManager)
  Set moComMan = oComMan
End Sub

Public Sub Connect(vIdent As Variant, sDpName As String)
          
Dim asDpCB(1) As String
  asDpCB(0) = sDpName & ":_online.._value"
  asDpCB(1) = sDpName & ":_online.._user"
  Call moComMan.dpConnect(vIdent, asDpCB, False)
  
End Sub

Public Sub Disconnect(sDpName As String)
  Call moComMan.dpDisconnect(sDpName)
End Sub

Private Sub Class_Terminate()
  Set moComMan = Nothing
End Sub

Private Sub moComMan_dpConnectCB(ByVal ident As Variant, ByVal value As Variant)
  Call M_PVSS.ReportCB(ident, value)
End Sub
Attribute VB_Name = "C_CostCenter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_CostCenter
'Wolfram Klebel 30.6.09
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

' Private mbcTariffset As C_Tariffset  ' der verwiesene Tarifsatz

Public ID               As Long       'Primaerschluessel
Public Bezeichnung      As String     'Eindeutige Bezeichung des Basiswertes (Name)
Private mcoTariffsets   As CO_Tariffset ' up to 10 tariffsets

'Public Tariffset    As String     'Tarifsatzname
'Public Tariffset_ID As Long       ' Tarifsatznummer

'---------------------------------------------------------------------------------------------------
Public Property Get coTariffsets() As CO_Tariffset
  Set coTariffsets = mcoTariffsets
End Property
Public Property Set coTariffsets(coTs As CO_Tariffset)
  Set mcoTariffsets = coTs
End Property

'---------------------------------------------------------------------------------------------------
'Public Function Clone() As C_CostCenter
'
'  Set Clone = New C_CostCenter
'  With Clone
'    .ID = Me.ID
'    .Bezeichnung = Me.Bezeichnung
'    .mcoTariffsets = Me.coTariffsets
'  End With
'
'End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  ID = 0
  Bezeichnung = ""
  'Tariffset = ""
  Set mcoTariffsets = New CO_Tariffset
  
  Call M_Debug.addRef("C_CostCenter", glCBasiswertInstanz, glCBasiswertInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_CostCenter", glCBasiswertInstanz, glCBasiswertInstanzMax)
End Sub



Attribute VB_Name = "C_DP"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_DP
'Oliver Seidel 28.09.2000
'  Stellt einen konkreten Datenpunkt mit allen erforderlichen Daten dar, der aus PVSS abgefragt
'  wird. Die Werte, inkl. Status und Zeit werden in einer internen Collection gespeichert.
'  Kann verschiedene Ergebnisse aus den enthaltenen Werten berechnen.
'  Fuer Vergleiche (Offset!) werden mehrere Objekte benoetigt!
'  - AddValue fuegt einen neuen Wert ein.
'  - setRange stellt einen speziellen Wert oder ein Ergebnis inkl. Formatierung in eine Zelle
'  - (get) coDPWert liefert alle Werte
'ACHTUNG: Die Zeiten werden bei der Auswertung nicht beruegsichtigt. Die Eintragungen in die
'         Protokolltabelle erfolgt wg. Performance der Reihe nach direkt ueber die Collection.
'         -> Daher muessen die Werte ueber AddValue chronologisch richtig und in per Definition
'            fuer jedes Intervall eingefuegt werden!
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private Const FLOAT_MIN = 1E+38
Private Const FLOAT_MAX = -1E+38

Private mcoDPWert       As Collection     'Die Werte im Intervall
Private mcoStatusBit    As CO_StatusBit   'Fuer den Zugriff auf die Formatvorlagen

Private mboStatFktBerechnet As Boolean    'Ergebnisse schon berechnet?
Private mlWertAnz           As Long       'Anzahl der gueltigen Werte

'Private mfMittel    As Double 'Ergebnisse, falls gefordert
Private mlInterSec  As Long     'Intervall in Sekunden
Private mfMin       As Double
Private mfMax       As Double
Private mfSumme     As Double
Private mfIntegral0 As Double
Private mfIntegral1 As Double
Private mfTimeSum   As Double
Private mfFirst     As Double
Private mfLast      As Double
'Private mdtMinZeit  As Date
'Private mdtMaxZeit  As Date
Private mlMinID     As Long
Private mlMaxID     As Long

Public ID           As Long     'Primaerschluessel
Public dp           As String   'Der DP
Public dpe          As String
Public dpt          As String
Public Alias        As String
Public Kommentar    As String
Public Einheit      As String
Public Format       As String
Public AutoFormat   As Integer
Public Archiv       As String   'DPE, kommplett zum Abfragen
Public ArchivFkt    As String   'Funktion, die abgefragt wird
Public ArchivTyp    As Integer
Public Marker       As Boolean  'Min/ Max Markierung
Public Offset       As Long
Public Intervall    As Long
Public IntEinheit   As Integer
Public Von          As Date
Public Bis          As Date

Public ResultQuery  As String
Public ResultFkt    As String
Public TabBereich   As C_TabBereich
Public CostCenter   As String   ' CostCenter members for transfer to DPReferenz only
Public CCWeighting  As Double
Public CCMedium     As String   ' IM 101311 WOKL: textueller Medium-Eintrag
Public CCUnitFactor As Double   ' IM 101311 WOKL: Einheiten-Umrechnungsfaktor

'---------------------------------------------------------------------------------------------------
Public Property Get PVSSSystem() As String

Dim n As Long

  n = InStr(1, dp, ":")
  If n > 0 Then
    PVSSSystem = Left(dp, n - 1)
  Else
    PVSSSystem = ""
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set StatusBit(coStatusBit As CO_StatusBit)
  Set mcoStatusBit = coStatusBit
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get StatusBit() As CO_StatusBit
  Set StatusBit = mcoStatusBit
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get coDPWert() As Collection
  Set coDPWert = mcoDPWert
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get DPWert(dtZeit As Date, _
                           Optional sFunktion As String = "") As C_DPWert

Dim oDPWert     As C_DPWert
  
  'ToDo: Implementierung aendern!
  'Zugriff ueber die Zeit ist nicht schnell genug!
  Stop
  
'  Set DPWert = Nothing
'
'  'Datenbereich!
'  If (Len(sFunktion) = 0) Or ((sFunktion = Me.ArchivFkt) And (mcoDPWert.Count = 1)) Then
'    On Error Resume Next
'    Set DPWert = mcoDPWert(CStr(dtZeit))
'
'  'Ergebnisbereich!
'  Else
'
'    Set DPWert = New C_DPWert
'    DPWert.Zeit = dtZeit
'
'    If Not mboStatFktBerechnet Then
'      Call StatFktBerechnen
'    End If
'
'    If mlWertAnz > 0 Then
'      Select Case sFunktion
'        Case VAR_MITTEL
'          DPWert.Wert = mfMittel
'        Case VAR_SUMME
'          DPWert.Wert = mfSumme
'        Case VAR_MIN
'          DPWert.Wert = mfMin
'        Case VAR_MAX
'          DPWert.Wert = mfMax
'      End Select
'    End If
'
'  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Sub setRange(rgZiel As Range, ByVal lIndex As Long, ByVal lMinColor As Long, _
                    ByVal lMaxColor As Long, Optional sFunktion As String = "")

Dim dtTmp As Date
Dim fTmp  As Double
Static sFormat As String
Static boHaveFormat As Boolean

  On Error Resume Next

  If Not boHaveFormat Then
    If AutoFormat = AUTOFORMAT_ONLYFORMAT Then
      sFormat = M_Protokoll.getFormatStr(Me.Format)
    ElseIf AutoFormat = AUTOFORMAT_FORMATUNIT Then
      sFormat = M_Protokoll.getFormatStr(Me.Format, Me.Einheit)
    End If
'    If InStr(1, rgZiel.EntireRow.Cells(1, 1).Value, "Time") Or _
'       InStr(1, Me.Archiv, "Time") Then
'      sFormat = ""
'    End If
    boHaveFormat = True
  End If
  If sFormat <> "" Then
    'Trick vom gro|fffd|em Mumpitz!
    'hab keine Ahnung, ob ich eine Zeit als Wert habe
    'Eigendlich m|fffd|sste ich wissen, in welchem format ich bin
    'Std: EntireRow, ATV: EntireColum, sonst vergis es.
    If InStr(1, rgZiel.EntireRow.Cells(1, 1).value, "Time") < 1 And _
       InStr(1, rgZiel.EntireColumn.Cells(1, 1).value, "Time") < 1 And _
       InStr(1, Me.Archiv, "Time") < 1 Then
      rgZiel.NumberFormat = sFormat
    End If
  End If

  'Datenbereich!
  If lIndex > 0 Then
    'Formatvorlage eintragen
    If mcoDPWert.Item(lIndex).StatusBitID Then
      'Fehler, wenn Formatvorlage noch nicht in der Vorlage vorhanden ist
      '(Vorlage muss noch Analysiert und gespeichert werden)
      rgZiel.Style = CStr(mcoStatusBit.Item(mcoDPWert.Item(lIndex).StatusBitID).Bezeichnung)
    End If
    'ToDo: MinMax Farbe aus Optionen lesen
    If Marker Then
      If Not mboStatFktBerechnet Then
        Call StatFktBerechnen
      End If
      If lIndex = mlMinID Then
        rgZiel.Interior.Color = lMinColor
      ElseIf lIndex = mlMaxID Then
        rgZiel.Interior.Color = lMaxColor
      Else
        rgZiel.Interior.Color = rgZiel.Worksheet.Cells(rgZiel.Row, 1).Interior.Color
      End If
    End If
'    If sFormat <> "" Then rgZiel.NumberFormat = sFormat
    'Value2 wg. DATE mit Millisekunden! (Currency wird eh nicht verwendet!)
    rgZiel.Value2 = mcoDPWert.Item(lIndex).Wert
    
  'Ergebnisbereich!
  Else
    'Ergebnis wurde aus PVSS gelesen
    If mcoDPWert.Count = 1 And sFunktion = ArchivFkt Then
      If mcoDPWert.Item(1).StatusBitID Then
        'Fehler, wenn Formatvorlage noch nicht in der Vorlage vorhanden ist
        '(Vorlage muss noch Analysiert und gespeichert werden)
        rgZiel.Style = CStr(mcoStatusBit.Item(mcoDPWert.Item(1).StatusBitID).Bezeichnung)
      End If
'      If sFormat <> "" Then rgZiel.NumberFormat = sFormat
      'Value2 wg. DATE mit Millisekunden! (Currency wird eh nicht verwendet!)
      rgZiel.Value2 = mcoDPWert.Item(1).Wert
    'Ergebnis wird aus den Daten selbst berechnet
    Else
    
      If Not mboStatFktBerechnet Then
        Call StatFktBerechnen
      End If
      If mlWertAnz > 0 Then
'        If sFormat <> "" And _
'           sFunktion <> VAR_MIN_ZEIT And _
'           sFunktion <> VAR_MAX_ZEIT Then
'           rgZiel.NumberFormat = sFormat
'        End If
        Select Case sFunktion
          Case VAR_MIN
            If mfMin <> FLOAT_MIN Then rgZiel.value = mfMin
          Case VAR_MAX
            If mfMax <> FLOAT_MAX Then rgZiel.value = mfMax
          Case VAR_MIN_ZEIT
            If mlMinID > 0 Then
              dtTmp = DateAdd(getIntFormatStr(Me.IntEinheit), Me.Intervall * (mlMinID - 1), Me.Von)
              rgZiel.value = dtTmp
            End If
          Case VAR_MAX_ZEIT
            If mlMaxID > 0 Then
              dtTmp = DateAdd(getIntFormatStr(Me.IntEinheit), Me.Intervall * (mlMaxID - 1), Me.Von)
              rgZiel.value = dtTmp
            End If
          Case VAR_ANZAHL
            rgZiel.value = mlWertAnz
          Case VAR_SUMME
            rgZiel.value = mfSumme
          Case VAR_INTG0
            rgZiel.value = mfIntegral0
          Case VAR_INTG1
            rgZiel.value = mfIntegral1
          Case VAR_SUM_ANZ
            rgZiel.value = mfSumme / mlWertAnz
          Case VAR_MITTEL
            rgZiel.value = mfIntegral0 / mfTimeSum
          Case VAR_MITTEL1
            rgZiel.value = mfIntegral1 / mfTimeSum
          Case VAR_BEGIN
            rgZiel.value = mfFirst
          Case VAR_END
            rgZiel.value = mfLast
          Case VAR_DIFF
            rgZiel.value = mfFirst - mfLast
          Case VAR_DIFF_ABS
            rgZiel.value = Abs(mfFirst - mfLast)
          Case Else
            Stop
        End Select
      End If
    
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub AddValue(vWert As Variant, vZeit As Date, ByVal vStatus As String)

Dim oDPWert     As C_DPWert
Dim n As Long
Static dtLastValueTime As Date

  Set oDPWert = New C_DPWert

'  If ArchivFkt = VAR_MIN_ZEIT Or _
'     ArchivFkt = VAR_MAX_ZEIT Then
'    oDPWert.Wert = CPVSSTime(vWert)
'  Else
'    oDPWert.Wert = CPVSSValue(vWert)
'  End If
  oDPWert.Wert = vWert
  
  'oDPWert.Zeit = CPVSSTime(vZeit)
  oDPWert.Zeit = vZeit
'  If dtLastValueTime = 0 Then
    'dtLastValueTime = oDPWert.Zeit
'  Else
    'dtLastValueTime = DateAdd(M_Archiv.getIntFormatStr(Me.IntEinheit), Me.Intervall, dtLastValueTime)
'  End If
  
  'Bisher wird zwingend vorrausgesetzt, dass die Werte passend geliefert werden
'  Call BugAssert(DateDiff("s", dtLastValueTime, oDPWert.Zeit) = 0, "Intervall der Daten fehlerhaft", "C_DP::AddValue")
'  If dtLastValueTime <> oDPWert.Zeit Then
    'DoTo: Werte verdichten, expandieren oder so...
'  End If
  
  oDPWert.Status = vStatus 'CPVSSStatus(vStatus)
  For n = 1 To mcoStatusBit.Count
    If oDPWert.Status Like mcoStatusBit.Item(n).BitMuster Then
      oDPWert.StatusBitID = n
      Exit For
    End If
  Next n
  
  'On Error Resume Next
  mcoDPWert.Add oDPWert ', CStr(oDPWert.Zeit)
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set mcoDPWert = New Collection
  Set mcoStatusBit = New CO_StatusBit
  Call M_Debug.addRef("C_DP", glCDPInstanz, glCDPInstanzMax)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_DP", glCDPInstanz, glCDPInstanzMax)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub StatFktBerechnen()

Dim oDPWert   As C_DPWert
Dim fWert     As Double
Dim fWertLast As Double
Dim iWertAnz  As Integer
Dim n         As Long
Dim nLast     As Long
Dim boIgnore  As Boolean

  mfMin = FLOAT_MIN
  mfMax = FLOAT_MAX
  mfSumme = 0
  mlWertAnz = 0
  mfIntegral0 = 0
  mfIntegral1 = 0
  mfTimeSum = 0
  nLast = 0
  
  mlInterSec = IntervallWithUnitToSec(Me.Intervall, Me.IntEinheit)
  
  For Each oDPWert In mcoDPWert
    n = n + 1
    
    If oDPWert.StatusBitID Then
      boIgnore = mcoStatusBit.Item(oDPWert.StatusBitID).WerteIgnorieren
    Else
      boIgnore = False
    End If
    
    If IsNumeric(oDPWert.Wert) And _
       Not IsEmpty(oDPWert.Wert) And _
       Not boIgnore Then
    
      fWert = CDbl(oDPWert.Wert)
      
      If nLast = 0 Then
        fWertLast = fWert
        mfFirst = fWert
      End If
      mfLast = fWert
      mlWertAnz = mlWertAnz + 1
      mfTimeSum = mfTimeSum + mlInterSec * (n - nLast)
      
      If mfMin > fWert Then
        mfMin = fWert
        mlMinID = n
      End If
      If mfMax <= fWert Then
        mfMax = fWert
        mlMaxID = n
      End If
      mfSumme = mfSumme + fWert
      
      mfIntegral0 = mfIntegral0 + fWert * mlInterSec * (n - nLast)
      mfIntegral1 = mfIntegral1 + ((fWert + fWertLast) / 2) * mlInterSec * (n - nLast)
      nLast = n
    Else
    
    End If
  Next oDPWert
  
  mboStatFktBerechnet = True
  
End Sub

Attribute VB_Name = "C_DPFunktion"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'C_DPFunktion
'Oliver Seidel 28.09.2000
'  Eindeutige Zuordnung und Beschreibung zwischen einem DPE in PVSS und der zugehoerigen
'  statistischen Funktion.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public ID                 As Long     'Primaerschluessel
Public Bezeichnung        As String   'Bezeichnung der Funktion (engl.)
Public dpe                As String   'DPE unterhalb der Verdichtungsstufe, das die Funktion traegt.
Public BerechnungMoeglich As Boolean  'Diese Funktion kann im Excel intern berechnet werden

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Call M_Debug.addRef("C_DPFunktion", glCDPFunktionInstanz, glCDPFunktionInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_DPFunktion", glCDPFunktionInstanz, glCDPFunktionInstanzMax)
End Sub

Attribute VB_Name = "C_DPGruppe"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




'===================================================================================================
'C_DPGroup
'Oliver Seidel 30.11.2000
'  Die DP werden nach ihrem jeweiligen Zeitbereich (Von, Bis) zu Gruppen zusammengefasst.
'  Fuer Jede Gruppe wird eine eigene Abfrage ueber dpGetAsynch oder dpGetPeriode gestartet.
'  -> Damit werden nur sehr wenige Messages vom ComManager versendet.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public Von        As Date
Public Bis        As Date
Public PVSSSystem As String
Public coDP       As Collection
Public ArchivTyp  As Integer

'---------------------------------------------------------------------------------------------------
Public Property Get Key() As String
  Key = Von & "|" & Bis & "|" & PVSSSystem & "|" & ArchivTyp
End Property

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set coDP = New Collection
  Call M_Debug.addRef("C_DPGruppe", glCDPGruppeInstanz, glCDPGruppeInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_DPGruppe", glCDPGruppeInstanz, glCDPGruppeInstanzMax)
End Sub

Attribute VB_Name = "C_DPReferenz"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'===================================================================================================
'C_DPReferenz
'Oliver Seidel 28.09.2000
'  Die Referenz bezeichnet den Ort (die Zeile bzw. die Spalte), in der ein DP definiert ist.
'  -> Ein DP kann an mehreren Stellen, auch ueber Tabellengrenzen hinweg, referenziert werden, wird
'     aber nur ein eiziges mal abgefragt.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moTabBereich As C_TabBereich

Public Blatt      As Long
Public Spalte     As Long
Public Zeile      As Long
Public index      As Long
Public ArchivFkt  As String
Public CostCenter As String
Public CCWeighting As Double
Public CCMedium   As String
Public CCUnitFactor As Double

'---------------------------------------------------------------------------------------------------
Public Property Set TabBereich(oTabBereich As C_TabBereich)
  Set moTabBereich = oTabBereich
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get TabBereich() As C_TabBereich
  Set TabBereich = moTabBereich
End Property

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set moTabBereich = New C_TabBereich

  Call M_Debug.addRef("C_DPReferenz", glCDPReferenzInstanz, glCDPReferenzInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_DPReferenz", glCDPReferenzInstanz, glCDPReferenzInstanzMax)
End Sub


Attribute VB_Name = "C_DPWert"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




'===================================================================================================
'C_DPWert
'Oliver Seidel 28.09.2000
'  Der Wert, wie immer ein Tripel aus Wert, Zeit und Status.
'  Die Statusbits werden auf Formatvorlagen abgebildet, welche das konkret ist, steht in StatusBitID
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public Wert         As Variant
Public Zeit         As Date
Public Status       As String
Public StatusBitID  As Long

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Call M_Debug.addRef("C_DPWert", glCDPWertInstanz, glCDPWertInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Wert = vbNull
  Call M_Debug.Releas("C_DPWert", glCDPWertInstanz, glCDPWertInstanzMax)
End Sub


Attribute VB_Name = "C_MailVerteiler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_MailVerteiler
'eigentlich Oliver Seidel 28.09.2000
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public ID As Long
Public Bezeichnung As String
Public An As String
Public Betreff As String
Public isMailGruppe As Boolean

Attribute VB_Name = "C_Medium"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_Medium
'Wolfram Klebel 9.11.10
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public ID       As Long       'Primaerschluessel
Public Name     As String     'Eindeutige Bezeichung des Basiswertes (Name)
Public unit     As String     'Einheit

'---------------------------------------------------------------------------------------------------
'Public Function Clone() As C_Medium
'
'  Set Clone = New C_Medium
'  With Clone
'    .ID = Me.ID
'    .Name = Me.Name
'    .Unit = Me.Unit
'  End With
'
'End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  ID = 0
  Name = ""
  unit = ""
  Call M_Debug.addRef("C_Medium", glCBasiswertInstanz, glCBasiswertInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_Medium", glCBasiswertInstanz, glCBasiswertInstanzMax)
End Sub




Attribute VB_Name = "C_Optionen"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'==================================================================================================
'C_Optionen
'Oliver Seidel 27.09.2000
' Wolfram Klebel 16.4.2010 Rittmeyer - User Berechtigungen
'  Verwaltet alle Optionen/Einstellungen fuer das Projekt
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Private masProtFormat()   As String

Public ID             As Long
Public Passwort       As String 'Das Passwort
Public UserPwd        As String 'Passwort fuer Protokolle
Public host           As String 'Der Host, fuer den diese Optionen sind...
Public HostZeitplan   As String 'Der Client, der die Auftraege aus dem Zeitplan bearbeiter

Public ComManConfig   As String 'Configdatei fuer den ComManager
Public ComManPara     As String 'optionale Parameter

Public HTMLPfad       As String

Public FilterDP       As String  'Filter fuer die DP Auswahl
Public Auswahl        As String  'Was wird ausgewaehlt? DPName, Alias oder Kommentar?
Public SpracheID      As Long    'Was sprechen wir heute?

Public SynchZeit      As Date     'Default SynchZeit fuer die ProtokollTypen
Public LoginActive    As Boolean  ' wenn gesetzt, nur mit PVSS Erlaubnis einloggen
Public AutoLogout     As Long     ' 0 - kein Autologout, sonst: Sekunden
Public DpInsExtend    As Boolean  ' show statistical functions; default: true


'--------------------------------------------------------------------------------------------------
Public Property Get ProtFormatAnz() As Integer
  ProtFormatAnz = UBound(masProtFormat)
End Property
'--------------------------------------------------------------------------------------------------
Public Property Let ProtFormat(iIndex As Integer, sProtFormat As String)
  If iIndex > UBound(masProtFormat) Then ReDim Preserve masProtFormat(iIndex)
  masProtFormat(iIndex) = sProtFormat
End Property
'--------------------------------------------------------------------------------------------------
Public Property Get ProtFormat(iIndex As Integer) As String
  ProtFormat = masProtFormat(iIndex)
End Property

Private Sub Class_Initialize()
  ReDim masProtFormat(4)
  FilterDP = "*"
  Auswahl = "DP"
  DpInsExtend = True  ' default is to show all details
  Call M_Debug.addRef("C_Optionen", glCOptionenInstanz, glCOptionenInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_Optionen", glCOptionenInstanz, glCOptionenInstanzMax)
End Sub


Attribute VB_Name = "C_PVSSLogin"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'C_PVSSLogin
' Wolfram Klebel 16.4.2010 Rittmeyer - User Berechtigungen
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Public mboLoginValid       As Boolean
Public msUsername         As String
Public msGlobalPermission As String
Public miGlobalPermission As Integer
Public mcoAreas            As Collection
Public mcoAreaPermission   As Collection


Private Sub Class_Initialize()
  
  mboLoginValid = False
  msUsername = ""
  
  Call ClearAreas
  Call ClearAreaPermissions
  Call M_Debug.addRef("C_PVSSLogin", 1, 1)

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_PVSSLogin", 1, 1)
End Sub

Public Sub AddAreaPermission(newPermission As Variant, num As Integer)
  mcoAreaPermission.Add newPermission, CStr(num)
End Sub

Public Sub AddArea(newArea As Variant, num As Integer)
  mcoAreas.Add newArea, CStr(num)
End Sub

Public Sub ClearAreaPermissions()
  Set mcoAreaPermission = New Collection
End Sub

Public Sub ClearAreas()
  Set mcoAreas = New Collection
End Sub

Attribute VB_Name = "C_Protokoll"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_Protkoll
'Oliver Seidel 28.09.2000
'  Vollstaendige Beschreibung eines Protkolls
'  Periode und Einheit werden automatisch vom Protokolltyp uebernommen, koennen aber auch
'  ueberschrieben werden.
'  - Zeitpunkt liefert fuer jedes Intervall den konkreten Zeitpunkt
'  - ZeitpunktAnz liefert die Anzahl der Intervalle in der Periode
'  - Von und Bis liefern den Beginn (das Ende) der Periode mit optionalem Offset
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moProtTyp     As C_ProtokollTyp
Private mdtVon        As Date
Private mdtBis        As Date
Private mlPeriode     As Long
Private miPerEinheit  As Integer
Private mlIntervall   As Long
Private miIntEinheit  As Integer

Public ID             As Long
Public Bezeichnung    As String
Public wbProtokoll    As Workbook
Public DateiTyp       As String
Public ProtTypName    As String
Public Username       As String
Public UserFullName   As String
Public RequestType    As Integer
'Public ProtFormat     As String ---- Obsolet
Public Vorlage        As String
Public Drucken        As Boolean
Public Speichern      As Boolean
Public Schliessen     As Boolean
Public Version        As String
Public Seitenansicht  As Boolean
Public Zeitbereich    As Integer '0:=Aktuell
Public avTime         As Variant
'Public FileName       As String
Public Tag            As Variant
Public Bereich        As String   ' IM 98626 WOKL

'Eigenschaften fuer den Zeitplan...
Public zpIntervall      As Long
Public zpIntEinheit     As Integer
Public zpAktiv          As Boolean
Public zpStatus         As Integer
Public zpNaechterAufruf As Date
Public zpMailVerteiler  As Long
Public zpHTML           As Boolean
Public IntercalaryExcp  As Long
Public zpFilePath       As String 'ICSGEAD

'Eigenschaften fuer die Schnellanwahl...
Public Prio             As Long     'Prioritaet in der CO_Schnellanwahl

'---------------------------------------------------------------------------------------------------
Public Property Set ProtTyp(oProtTyp As C_ProtokollTyp)
  Set moProtTyp = oProtTyp
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get ProtTyp() As C_ProtokollTyp
  Set ProtTyp = moProtTyp
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Periode(lPeriode As Long)
  mlPeriode = lPeriode
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get Periode() As Long
  If miIntEinheit > 0 And mlPeriode > 0 Then
    Periode = mlPeriode
  Else
    Periode = moProtTyp.Periode
  End If
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let PerEinheit(iPerEinheit As Integer)
  miPerEinheit = iPerEinheit
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get PerEinheit() As Integer
  If miPerEinheit > 0 And mlIntervall > 0 Then
    PerEinheit = miPerEinheit
  Else
    PerEinheit = moProtTyp.PerEinheit
  End If
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Intervall(lIntervall As Long)
  mlIntervall = lIntervall
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get Intervall() As Long
  If miIntEinheit > 0 And mlIntervall > 0 Then
    Intervall = mlIntervall
  Else
    Intervall = moProtTyp.Intervall
  End If
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let IntEinheit(iIntEinheit As Integer)
  miIntEinheit = iIntEinheit
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get IntEinheit() As Integer
  If miIntEinheit > 0 And mlIntervall > 0 Then
    IntEinheit = miIntEinheit
  Else
    IntEinheit = moProtTyp.IntEinheit
  End If
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Von(Optional iOffset As Integer = 0, dtVon As Date)
  mdtVon = dtVon
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get Von(Optional iOffset As Integer = 0) As Date
  
Dim dtBis As Date

  If mdtVon = 0 Then
    moProtTyp.Zeitbereich mdtVon, dtBis, iZeitbereich:=Me.Zeitbereich
  End If
  
  If iOffset = 0 Then
    Von = mdtVon
  Else
    'Zwei Varianten: Offset bezieht sich auf die gesamte Periode
    '(z.B. Periode = 3 Tage, Offset = 2 => 6 Tage) oder auf die Zeiteinheit der Periode
    '(=> 2 Tage)
    'Idee: In die Projekteinstellungen aufnehmen
    'Von = DateAdd(getIntFormatStr(PerEinheit), Periode * iOffset, mdtVon)
    Von = DateAdd(getIntFormatStr(PerEinheit), iOffset, mdtVon)
  End If

End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Bis(Optional iOffset As Integer = 0, dtBis As Date)
  mdtBis = dtBis
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get Bis(Optional iOffset As Integer = 0) As Date

  If mdtBis = 0 Or (mdtVon > mdtBis) Then
    moProtTyp.Zeitbereich mdtVon, mdtBis
  End If
  
  If iOffset = 0 Then
    Bis = mdtBis
  Else
    'Siehe Me.Von
    'Bis = DateAdd(getIntFormatStr(PerEinheit), Periode * iOffset, mdtBis)
    Bis = DateAdd(getIntFormatStr(PerEinheit), iOffset, mdtBis)
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ZeitpunktAnz() As Long

  'Achtung: DateDiff rundet immer ab! Daher wird wg. Bis = h:59:59 eine Sekunde addiert.
  '(Wenn der Zeitpunkt Bis auf eine volle Stunde zeigt, ist die Berechnung immer noch gueltig)
  If IsEmpty(avTime) Then
    If IntEinheit > 0 Then
      ZeitpunktAnz = DateDiff(getIntFormatStr(IntEinheit), mdtVon, (mdtBis + CDate("00:00:01")))
      ZeitpunktAnz = ZeitpunktAnz / Me.Intervall
    Else
      ZeitpunktAnz = 0
    End If
  Else
    ZeitpunktAnz = UBound(avTime)
  End If
End Property
      
'---------------------------------------------------------------------------------------------------
' changed IM 102541 WOKL on 8.4.2011, added iOffsetParameter (was already planned by Oliver)

Public Property Get Zeitpunkt(ByVal lIndex As Long, Optional iOffset As Integer = 0) As Date
'Public Property Get Zeitpunkt(ByVal lIndex As Long) As Date
      
  If IsEmpty(avTime) Then
    Zeitpunkt = DateAdd(getIntFormatStr(IntEinheit), lIndex * Me.Intervall, Me.Von)
  Else
    Zeitpunkt = avTime(lIndex + 1)
  End If
  
  If iOffset <> 0 Then  ' IM 102541
      'Von = DateAdd(getIntFormatStr(PerEinheit), Periode * iOffset, mdtVon)
    Zeitpunkt = DateAdd(getIntFormatStr(PerEinheit), iOffset, Zeitpunkt)
  End If
'  If IsEmpty(avTime) Or iOffset <> 0 Then
'    Zeitpunkt = DateAdd(getIntFormatStr(IntEinheit), lIndex * Me.Intervall, Me.Von(iOffset))
'  Else
'    Zeitpunkt = avTime(lIndex + 1)
'  End If
End Property

'---------------------------------------------------------------------------------------------------
Public Function pathProtInfo(ByVal sText As String) As String

  sText = TextErsetzen(sText, VAR_REPORTTYP, Me.ProtTyp.Bezeichnung)
  If Me.Intervall >= 86400 Then
    sText = TextErsetzen(sText, VAR_VON, Format(Me.Von, "Short Date"))
    sText = TextErsetzen(sText, VAR_BIS, Format(Me.Bis, "Short Date"))
  Else
    sText = TextErsetzen(sText, VAR_VON, Format(Me.Von, "Short Date") & " " & _
                                         Format(Me.Von, "Long Time"))
    sText = TextErsetzen(sText, VAR_BIS, Format(Me.Bis, "Short Date") & " " & _
                                         Format(Me.Bis, "Long Time"))
  End If
  sText = TextErsetzen(sText, VAR_INTERVALL, Me.Intervall)
  sText = TextErsetzen(sText, VAR_VONDATUM, Format(Me.Von, "Short Date"))
  sText = TextErsetzen(sText, VAR_VONZEIT, Format(Me.Von, "Long Time"))
  sText = TextErsetzen(sText, VAR_BISDATUM, Format(Me.Bis, "Short Date"))
  sText = TextErsetzen(sText, VAR_BISZEIT, Format(Me.Bis, "Long Time"))
  
  pathProtInfo = sText
  
End Function

'---------------------------------------------------------------------------------------------------
Public Function getValueIndex(ByVal dtZeit As Date, ByVal lLastIndex As Long) As Long

Dim n As Long
Dim lIndex As Long

  On Error GoTo Fehler
  lIndex = 0

  If IsArray(avTime) Then
    Select Case IntEinheit
      Case erSekunde
        For n = lLastIndex + 1 To UBound(avTime)
          If Second(dtZeit) = Second(avTime(n)) Then
            lIndex = n
            Exit For
          End If
        Next n
        If lIndex = 0 Then
          For n = 1 To lLastIndex
            If Second(dtZeit) = Second(avTime(n)) Then
              lIndex = n
              Exit For
            End If
          Next n
        End If
      Case erMinute
        For n = lLastIndex + 1 To UBound(avTime)
          If Minute(dtZeit) = Minute(avTime(n)) Then
            lIndex = n
            Exit For
          End If
        Next n
        If lIndex = 0 Then
          For n = 1 To lLastIndex
            If Minute(dtZeit) = Minute(avTime(n)) Then
              lIndex = n
              Exit For
            End If
          Next n
        End If
      Case erStunde
        For n = lLastIndex + 1 To UBound(avTime)
          If Hour(dtZeit) = Hour(avTime(n)) Then
            lIndex = n
            Exit For
          End If
        Next n
        If lIndex = 0 Then
          For n = 1 To lLastIndex
            If Hour(dtZeit) = Hour(avTime(n)) Then
              lIndex = n
              Exit For
            End If
          Next n
        End If
      Case erTag
        For n = lLastIndex + 1 To UBound(avTime)
          If Day(dtZeit) = Day(avTime(n)) Then
            lIndex = n
            Exit For
          End If
        Next n
        If lIndex = 0 Then
          For n = 1 To lLastIndex
            If Day(dtZeit) = Day(avTime(n)) Then
              lIndex = n
              Exit For
            End If
          Next n
        End If
      Case erWoche
        For n = lLastIndex + 1 To UBound(avTime)
          If weekday(dtZeit) = weekday(avTime(n)) Then
            lIndex = n
            Exit For
          End If
        Next n
        If lIndex = 0 Then
          For n = 1 To lLastIndex
            If weekday(dtZeit) = weekday(avTime(n)) Then
              lIndex = n
              Exit For
            End If
          Next n
        End If
      Case erMonat
        For n = lLastIndex + 1 To UBound(avTime)
          If Month(dtZeit) = Month(avTime(n)) Then
            lIndex = n
            Exit For
          End If
        Next n
        If lIndex = 0 Then
          For n = 1 To lLastIndex
            If Month(dtZeit) = Month(avTime(n)) Then
              lIndex = n
              Exit For
            End If
          Next n
        End If
      Case erJahr
        For n = lLastIndex + 1 To UBound(avTime)
          If Year(dtZeit) = Year(avTime(n)) Then
            lIndex = n
            Exit For
          End If
        Next n
        If lIndex = 0 Then
          For n = 1 To lLastIndex
            If Year(dtZeit) = Year(avTime(n)) Then
              lIndex = n
              Exit For
            End If
          Next n
        End If
      Case Else
        lIndex = 0
    End Select
  End If
  getValueIndex = lIndex
Exit Function
Fehler:
  Stop
  Resume
  getValueIndex = 0

End Function

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set moProtTyp = New C_ProtokollTyp
  Me.Zeitbereich = 0
  Me.IntercalaryExcp = 0
  Call M_Debug.addRef("C_Protokoll", glCProtokollInstanz, glCProtokollInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_Protokoll", glCProtokollInstanz, glCProtokollInstanzMax)
End Sub


Attribute VB_Name = "C_ProtokollTyp"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False







'===================================================================================================
'C_ProtokollTyp
'Oliver Seidel 14.07.2000
'  Ein ProtokollTyp beschreibt die Daten, die in einem Protokoll unabhaengig vom Protokollformat
'  dargestellt werden. Die Basiswerte sind die Quelle der Werte fuer den Daten- und Ergebnisbereich.
'  Aus Periode, Intervall und Synch___ wird der Zeitbereich von-bis fuer das zuletzt vollstaendig
'  abgeschlossene Protkoll berechnet (oder nur bis aus gegebenem von und periode)
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moBasisDaten    As C_Basiswert
Private moBasisErgebnis As C_Basiswert
Private mboAktuell      As Boolean

Public ID               As Long
Public Bezeichnung      As String
Public Periode          As Long
Public PerEinheit       As Integer
Public Intervall        As Long
Public BonusIntervall   As Boolean    ' IM 115373
Public IntEinheit       As Integer
Public SynchZeit        As Date
Public SynchWochenTag   As Integer
Public SynchTag         As Integer
Public SynchMonat       As Integer
' Public vlTyp            As Integer    ' IM 115373
' Public DeleteMe         As Boolean    ' IM 115373

'---------------------------------------------------------------------------------------------------
Public Property Set BasiswertDaten(oBasiswert As C_Basiswert)
  Set moBasisDaten = oBasiswert
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get BasiswertDaten() As C_Basiswert
  Set BasiswertDaten = moBasisDaten
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set BasiswertErgebnis(oBasiswert As C_Basiswert)
  Set moBasisErgebnis = oBasiswert
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get BasiswertErgebnis() As C_Basiswert
  Set BasiswertErgebnis = moBasisErgebnis
End Property

'--------------------------------------------------------------------------------------------------
'Berechnet Synchronisationszeitpunkt
'
'Wenn dtVon ungleich 0 ist und boMitStart nicht expliziet gesetzt wurde, wird
'nur der Endzeitpunkt der Periode dtBis gerechnet.
'
'Sonst wird ausgehend von dtSynchFrom (falls NULL wird now angenommen) fuer die aktuelle
'Periode (iZeitbereich = 0) oder fuer die zuletzt abgeschlossene Periode (iZeitbereich = 1)
'der Zeitpunkte dtVon auf den Synchronisationszeitpunkt gesetzt.
Public Sub Zeitbereich(ByRef dtVon As Date, ByRef dtBis As Date, _
                       Optional boMitStart As Boolean = False, _
                       Optional iZeitbereich As Integer = 0, _
                       Optional dtSynchFrom As Date = 0)

Dim dtSynch   As Date
Dim dStart    As Date
Dim tStart    As Date
'Dim iJahr     As Integer
'Dim iMonat    As Integer
'Dim iTag      As Integer
Dim i         As Long
Dim n         As Long
'Dim dKW1      As Long
'Dim lDINKw As Long

  If dtSynchFrom = 0 Then dtSynchFrom = Now

  If boMitStart Then
    dStart = DateSerial(Year(dtVon), Month(dtVon), Day(dtVon))
    tStart = TimeSerial(Hour(dtVon), Minute(dtVon), Second(dtVon))
    dtVon = 0
  Else
    dStart = DateSerial(Year(dtSynchFrom), Month(dtSynchFrom), Day(dtSynchFrom))
    tStart = TimeSerial(Hour(dtSynchFrom), Minute(dtSynchFrom), Second(dtSynchFrom))
  End If

  If (dtVon = 0) Then
  
    'Spezialfall: Synchronisation auf die KW 1 - Jahresprotokoll mit Wochenwerten!
    If PerEinheit = erJahr And Periode = 1 And _
       IntEinheit = erWoche And Intervall = 1 Then
    
      'Aktuelle (1) oder Abgeschlossene Periode?
      If iZeitbereich = 1 Then
        dtSynch = dStart
      Else
        dtSynch = DateAdd("yyyy", -1, dStart)
      End If
      
      If SynchWochenTag Then
        n = SynchWochenTag - weekday(dtSynch)
      Else
        n = vbMonday - weekday(dtSynch)
      End If
      'If n > 0 Then n = n - 7
      dtSynch = DateAdd("d", n, dtSynch)
      
      'Synchronisation auf die erste KW
      n = DIN_KW(dtSynch)
      If n > 1 And n < 52 Then
        dtSynch = DateAdd("ww", -1 * (n - 1), dtSynch)
      ElseIf n >= 52 Then
        dtSynch = DateAdd("ww", 1, dtSynch)
      End If
      
      dtVon = dtSynch + SynchZeit
      dtBis = DateAdd(getIntFormatStr(PerEinheit), Periode, dtVon) - CDate("00:00:01")
      'MiD:ab Version 3.9.7 mit Bonusintervall IM 115373
      If BonusIntervall Then
        dtBis = DateAdd(getIntFormatStr(IntEinheit), Intervall, dtBis) - CDate("00:00:01")
      End If
      Exit Sub
    
    End If
  
    'Der zuletzt abgeschlossene Zeitbereich wird gesucht
    If True Then
      dtSynch = DateAdd(getIntFormatStr(PerEinheit), (-1) * Periode, dStart)
    End If
    
    'Der letzte SynchZeitPunkt wird gesucht...
    'Tageswechsel wird zunaechst ignoriert, spaeter wieder hinzugefuegt
    If tStart < SynchZeit Then dtSynch = dtSynch - 1
    
    If SynchTag Then
      If Day(dtSynch) < SynchTag Then
        dtSynch = DateAdd("m", -1, dtSynch)
      End If
      n = SynchTag - Day(dtSynch)
      dtSynch = DateAdd("d", n, dtSynch)
    End If
    
    If SynchMonat Then
      If Month(dtSynch) > SynchMonat Then
        dtSynch = DateAdd("yyyy", -1, dtSynch)
      End If
      n = SynchMonat - Month(dtSynch)
      dtSynch = DateAdd("m", n, dtSynch)
    End If
    dtSynch = dtSynch + SynchZeit
    
    'Debug.Print Format(dtSynch, "dddd"), dtSynch
    
    'Anzahl der Perioden zwischen SynchZeitPunkt und Heute
    If boMitStart Then
      n = 1
    Else
      n = DateDiff(getIntFormatStr(PerEinheit), dtSynch, dtSynchFrom)
      n = Abrunden(n / Periode)
    End If
    
    'Wegen Synch. auf Wochentag und SynchZeit kann es zu einer Fehlberechnung
    'kommen, wenn SynchZeit Heute noch nicht vorhei ist.
    'Daher Pruefung und eventuell Korrektur an diesr Stelle
    If (DateAdd(getIntFormatStr(PerEinheit), n * Periode, dtSynch) > dtSynchFrom) Then
      n = n - 1
    End If
    
    'Aktuelle (1) oder Abgeschlossene Periode?
    n = n + iZeitbereich
    
    'Der Wochentag hat hoechste Prioritaet - so bloed das auch klingt.
    If SynchWochenTag Then
      i = SynchWochenTag - weekday(dtSynch)
      If i > 0 Then i = i - 7
      dtSynch = DateAdd("d", i, dtSynch)
    End If
    
    'Wann hat die letzte Periode begonnen?
    dtVon = DateAdd(getIntFormatStr(PerEinheit), (n - 1) * Periode, dtSynch)
    'dtVon = dtSynch
    'Und wann war sie zu ende?
    dtBis = DateAdd(getIntFormatStr(PerEinheit), Periode, dtVon) - CDate("00:00:01")
    
  Else
    
    dtBis = DateAdd(getIntFormatStr(PerEinheit), Periode, dtVon) - CDate("00:00:01")
    
  End If
  'MiD:ab Version 3.9.7 mit Bonusintervall IM 115373
  If BonusIntervall Then
        dtBis = DateAdd(getIntFormatStr(IntEinheit), Intervall, dtBis) - CDate("00:00:01")
  End If
    
  'Debug.Print "Von: " & Format(dtVon, "dddd"), dtVon
  'Debug.Print "Bis: " & Format(dtBis, "dddd"), dtBis

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  'Idee: mboAktuell in Optionen einstellbar
  mboAktuell = False
  Set moBasisDaten = New C_Basiswert
  Set moBasisErgebnis = New C_Basiswert
  Call M_Debug.addRef("C_ProtokollTyp", glCProtokollTypInstanz, glCProtokollTypInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_ProtokollTyp", glCProtokollTypInstanz, glCProtokollTypInstanzMax)
End Sub



Attribute VB_Name = "C_SQL"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






Option Explicit

Private mbAlert As Boolean
Private masSelect() As String
Private masFrom() As String
Private msRemote As String
Private masWhere() As String
Private mbTimerangeActive As Boolean
Private miTimerangeBonus As Integer
Private miTimerangeModus As Integer
Private masSort() As String

'---------------------------------------------------------------------------------------------------
Public Property Let Alert(bAlert As Boolean)
  mbAlert = bAlert
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Alert() As Boolean
  Alert = mbAlert
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let SelectAsString(sSelect As String)

Dim asSelectSplit() As String
Dim iStart As Integer
Dim iSelect As Integer
Dim n As Integer


  If Len(sSelect) > 0 Then
  
    Call M_SQLVorlage.strSplit(sSelect, " ", asSelectSplit)
  
    If UBound(asSelectSplit) > 0 Then
      'Schluesselwort ALERT finden
      If asSelectSplit(1) = "ALERT" Then
        iStart = 2
        mbAlert = True
      Else
        iStart = 1
        mbAlert = False
      End If
    End If
  
  
    'Argumente isolieren
    ReDim masSelect(0)
    iSelect = 0
    For n = iStart To UBound(asSelectSplit)
      iSelect = iSelect + 1
      ReDim Preserve masSelect(iSelect)
      'Wegschneiden des ","
      If Right(asSelectSplit(n), 1) = "," Then
        asSelectSplit(n) = Left(asSelectSplit(n), Len(asSelectSplit(n)) - 1)
      End If
      'Wegschneiden der "'"
      masSelect(iSelect) = Mid(asSelectSplit(n), 2, Len(asSelectSplit(n)) - 2)
    Next n
    
  End If

End Property

'---------------------------------------------------------------------------------------------------
Public Property Get SelectAsString() As String

Dim sSelect As String
Dim n As Integer
  
  sSelect = ""
  
  If mbAlert = True Then
    sSelect = sSelect & "ALERT "
  End If
  
  For n = 1 To UBound(masSelect) - 1
    sSelect = sSelect & "'" & masSelect(n) & "', "
  Next n
  sSelect = sSelect & "'" & masSelect(UBound(masSelect)) & "'"

  sSelect = "'" & sSelect 'Fuer die Darstellung in Excel ein "'" hinzufuegen
  SelectAsString = sSelect

End Property

'---------------------------------------------------------------------------------------------------
Public Sub SetSelect(ByRef asSelect() As String)

Dim n As Integer
  
  If UBound(asSelect) <= 0 Then
    ReDim masSelect(0)
  End If
  
  For n = 1 To UBound(asSelect)
    ReDim Preserve masSelect(n)
    masSelect(n) = asSelect(n)
  Next n
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub GetSelect(ByRef asSelect() As String)

Dim n As Integer

  ReDim asSelect(0)
  
  For n = 1 To UBound(masSelect)
    ReDim Preserve asSelect(n)
    asSelect(n) = masSelect(n)
  Next n

End Sub

'---------------------------------------------------------------------------------------------------
Public Property Let FromAsString(sFrom As String)

Dim asFromSplit() As String
Dim sArgument As String
Dim n As Integer


  If Len(sFrom) > 0 Then

    'Wegschneiden der "'"
    sFrom = Mid(sFrom, 2, Len(sFrom) - 2)

    'Wegschneiden der "{}"
    If Right(sFrom, 1) = "}" Then
      sFrom = Mid(sFrom, 2, Len(sFrom) - 2)
    End If

    Call M_SQLVorlage.strSplit(sFrom, ",", asFromSplit)
    For n = 1 To UBound(asFromSplit)
      ReDim Preserve masFrom(n)
      masFrom(n) = asFromSplit(n)
    Next n
  
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get FromAsString() As String

Dim sFrom As String
Dim n As Integer


  If UBound(masFrom) = 1 Then
    sFrom = "'" & masFrom(1) & "'"
  ElseIf UBound(masFrom) > 1 Then
    sFrom = "'{"
    For n = 1 To UBound(masFrom) - 1
      sFrom = sFrom & masFrom(n) & ","
    Next n
    sFrom = sFrom & masFrom(UBound(masFrom)) & "}'"
  End If
  
  sFrom = "'" & sFrom 'Fuer die Darstellung in Excel ein "'" hinzufuegen
  FromAsString = sFrom

End Property

'---------------------------------------------------------------------------------------------------
Public Sub SetFrom(ByRef asFrom() As String)
Dim n As Integer
  
  If UBound(asFrom) <= 0 Then
    ReDim masFrom(0)
  End If
  
  For n = 1 To UBound(asFrom)
    ReDim Preserve masFrom(n)
    masFrom(n) = asFrom(n)
  Next n
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub GetFrom(ByRef asFrom() As String)
Dim n As Integer

  ReDim asFrom(0)

  For n = 1 To UBound(masFrom)
    ReDim Preserve asFrom(n)
    asFrom(n) = masFrom(n)
  Next n

End Sub

'---------------------------------------------------------------------------------------------------
Public Property Let RemoteAsString(sRemote As String)

  If Len(sRemote) > 0 Then
  
    'Wegschneiden der "'"
    msRemote = Mid(sRemote, 2, Len(sRemote) - 2)
    
  End If
    
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get RemoteAsString() As String

Dim sRemote

  If Len(msRemote) > 0 Then
    If Right(msRemote, 1) = ":" Then
      sRemote = "'" & msRemote & "'"
    Else
      sRemote = "'" & msRemote & ":'"
    End If
  Else
    sRemote = ""
  End If
  
  sRemote = "'" & sRemote 'Fuer die Darstellung in Excel ein "'" hinzufuegen
  RemoteAsString = sRemote

End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Remote(sRemote As String)
  msRemote = sRemote
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Remote() As String
  Remote = msRemote
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let WhereAsString(sWhere As String)

Dim asWhereSplit() As String
Dim sArgument As String
Dim iWhere As Integer
Dim sWhereTempo As String
Dim n As Integer


  Call M_SQLVorlage.strSplit(sWhere, " ", asWhereSplit)

  If UBound(asWhereSplit) > 0 And Len(sWhere) > 0 Then

    For n = 1 To UBound(asWhereSplit)
      If asWhereSplit(n) = "AND" Or asWhereSplit(n) = "OR" Then
        '"Gesammelten" String und Operator hinzufuegen
        ReDim Preserve masWhere(iWhere + 2)
        iWhere = iWhere + 1
        masWhere(iWhere) = Trim(sWhereTempo)
        sWhereTempo = ""
        
        iWhere = iWhere + 1
        masWhere(iWhere) = Trim(asWhereSplit(n))
        
      Else
        'String "sammeln"
        sWhereTempo = sWhereTempo & " " & asWhereSplit(n)
      End If
    Next n
    
    'Letztes Statement anhaengen
    iWhere = iWhere + 1
    ReDim Preserve masWhere(iWhere)
    masWhere(iWhere) = Trim(sWhereTempo)

  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get WhereAsString() As String

Dim sWhere As String
Dim n As Integer

  If UBound(masWhere) > 0 Then
    For n = 1 To UBound(masWhere) - 1
      sWhere = sWhere & masWhere(n) & " "
    Next n
    sWhere = sWhere & masWhere(UBound(masWhere))
  End If
  
  sWhere = "'" & sWhere 'Fuer die Darstellung in Excel ein "'" hinzufuegen
  WhereAsString = sWhere

End Property

'---------------------------------------------------------------------------------------------------
Public Sub SetWhere(ByRef asWhere() As String)
Dim n As Integer
  
  If UBound(asWhere) <= 0 Then
    ReDim masWhere(0)
  End If
  
  For n = 1 To UBound(asWhere)
    ReDim Preserve masWhere(n)
    masWhere(n) = asWhere(n)
  Next n
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub GetWhere(ByRef asWhere() As String)
Dim n As Integer

  ReDim asWhere(0)

  For n = 1 To UBound(masWhere)
    ReDim Preserve asWhere(n)
    asWhere(n) = masWhere(n)
  Next n

End Sub

'---------------------------------------------------------------------------------------------------
Public Property Let TimerangeAsString(sTimerange As String)

Dim asTimerangeSplit() As String

  Call M_SQLVorlage.strSplit(sTimerange, "|", asTimerangeSplit)
  
  If UBound(asTimerangeSplit) > 1 Then
    If asTimerangeSplit(1) = True Then
      mbTimerangeActive = True
      miTimerangeModus = asTimerangeSplit(2)
      miTimerangeBonus = asTimerangeSplit(3)
    Else
      mbTimerangeActive = False
    End If
  End If

End Property

'---------------------------------------------------------------------------------------------------
Public Property Get TimerangeAsString() As String

  If mbTimerangeActive = True Then
    TimerangeAsString = mbTimerangeActive & "|" & _
                        miTimerangeModus & "|" & _
                        miTimerangeBonus
  Else
    TimerangeAsString = "FALSE||"
  End If

End Property

'---------------------------------------------------------------------------------------------------
Public Property Let TimerangeActive(bTimerangeActive As Boolean)
  mbTimerangeActive = bTimerangeActive
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get TimerangeActive() As Boolean
  TimerangeActive = mbTimerangeActive
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let TimerangeModus(iTimerangeModus As Integer)
  miTimerangeModus = iTimerangeModus
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get TimerangeModus() As Integer
  TimerangeModus = miTimerangeModus
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let TimerangeBonus(iTimerangeBonus As Integer)
  miTimerangeBonus = iTimerangeBonus
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get TimerangeBonus() As Integer
  TimerangeBonus = miTimerangeBonus
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let SortAsString(sSort As String)

Dim asSortSplit() As String
Dim iSort As Integer
Dim n As Integer

  ReDim masSort(0)
  If Len(sSort) > 0 Then
  
    'Aufloesen der einzelnen Statements
    Call M_SQLVorlage.strSplit(sSort, " ", asSortSplit)
    If UBound(asSortSplit) > 0 Then
    
      iSort = 0
      For n = 1 To UBound(asSortSplit)
        If asSortSplit(n) <> "GROUP" And asSortSplit(n) <> "BY" Then
          iSort = iSort + 1
          ReDim Preserve masSort(iSort)
          masSort(iSort) = asSortSplit(n)
        End If
      Next n
    End If
    
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get SortAsString() As String

Dim sSort

  If UBound(masSort) > 0 Then
    If UBound(masSort) = 1 Then
      sSort = masSort(1)
    Else
      sSort = masSort(1) & " GROUP BY " & masSort(2)
    End If
    
    sSort = "'" & sSort 'Fuer die Darstellung in Excel ein "'" hinzufuegen
    SortAsString = sSort
    
  End If

End Property

'---------------------------------------------------------------------------------------------------
Public Sub SetSort(ByRef asSort() As String)
  
Dim n As Integer
  
  If UBound(asSort) <= 0 Then
    ReDim masSort(0)
  End If
  
  For n = 1 To UBound(asSort)
    ReDim Preserve masSort(n)
    masSort(n) = asSort(n)
  Next n
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub GetSort(ByRef asSort() As String)

Dim n As Integer

  ReDim asSort(0)
  
  For n = 1 To UBound(masSort)
    ReDim Preserve asSort(n)
    asSort(n) = masSort(n)
  Next n

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()

  mbAlert = False
  ReDim masSelect(0)
  ReDim masFrom(0)
  msRemote = ""
  ReDim masWhere(0)
  mbTimerangeActive = False
  miTimerangeBonus = 1
  miTimerangeModus = 0
  ReDim masSort(0)

End Sub
Attribute VB_Name = "C_StatusBit"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'==================================================================================================
'C_StatusBit
'Oliver Seidel 28.09.2000
'  Verbindet ein Bitmuster mit einer Formatvorlage. Wahlweise koennen Werte, die diesem Muster
'  entsprechen bei der internen Berechnung von Ergebnissen ignoriert werden.
'ACHTUNG: Format<C_Style> wird wg. Problemen beim Erzeugen neuer Formatforlagen in Vorlagen
'         nicht verwendet! FormatKopieren faellt ebenfalls weg (ist nun in M_Vorlage::VersionPruefen
'         durch ::Styles.Merge implementiert)
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public ID               As Long     'Primaerschluessel
Public Prio             As Long     'Prioritaet in der CO_StatusBit
Private msBezeichnung   As String   'Eindeutige Bezeichnung eines Eintrags
Private msBitMuster     As String   'Bitmuster der StatusBit's
Public WerteIgnorieren  As Boolean  'Werte mit diesem Bitmuster gehen in die Berechnung der
                                    'Statistischen Funktionen ein
Public Format           As C_Style  'Formatvorlage fuer die Zellen einer Tabelle

'--------------------------------------------------------------------------------------------------
Public Property Get Bezeichnung() As String
  Bezeichnung = msBezeichnung
End Property
'--------------------------------------------------------------------------------------------------
Public Property Let Bezeichnung(sBezeichnung As String)
  msBezeichnung = sBezeichnung
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get BitMuster() As String
  BitMuster = msBitMuster
End Property

'--------------------------------------------------------------------------------------------------
Public Property Let BitMuster(sBitMuster As String)
  msBitMuster = sBitMuster
End Property

'--------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Set Format = New C_Style
  Call M_Debug.addRef("C_StatusBit", glCStatusBitInstanz, glCStatusBitInstanzMax)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Set Format = Nothing
  Call M_Debug.Releas("C_StatusBit", glCStatusBitInstanz, glCStatusBitInstanzMax)
End Sub

'--------------------------------------------------------------------------------------------------
'Public Sub FormatKopieren(rgZiel As Range)
'
'  On Error Resume Next
'  ActiveWorkbook.Styles(Format.Name).Delete
'
'  On Error GoTo 0
'  tabKonfig.Range(msRefFormat).Copy
'  'ActiveCell.PasteSpecial xlPasteFormats
'  rgZiel.PasteSpecial xlPasteFormats
'  'rgZiel.Select
'
'  On Error Resume Next
'  Call ActiveWorkbook.Styles.Add(Format.Name, rgZiel)
'
'End Sub

'--------------------------------------------------------------------------------------------------
'Public Sub FormatKopieren(wbZiel As Workbook)
'
'Dim i As Integer
'Dim boGefunden  As Boolean
'Dim oZielFormat As Style
'
'  For i = 1 To wbZiel.Styles.Count
'    If wbZiel.Styles(i).Name = moFormat.Name Then
'      boGefunden = True
'      Exit For
'    End If
'  Next i
'
'  If boGefunden Then
'    Set oZielFormat = wbZiel.Styles(moFormat.Name)
'  Else
'    Set oZielFormat = wbZiel.Styles.add(moFormat.Name)
'  End If
'
'  If moFormat.IncludeAlignment Then
'    oZielFormat.HorizontalAlignment = moFormat.HorizontalAlignment
'    oZielFormat.Orientation = moFormat.Orientation
'    oZielFormat.ReadingOrder = moFormat.ReadingOrder
'    oZielFormat.VerticalAlignment = moFormat.VerticalAlignment
'    oZielFormat.WrapText = moFormat.WrapText
'  Else
'    oZielFormat.IncludeAlignment = False
'  End If
'
'  If moFormat.IncludeBorder Then
'    'Set oZielFormat.Borders = moFormat.Borders
'  Else
'    oZielFormat.IncludeBorder = False
'  End If
'
'  If moFormat.IncludeFont Then
'    oZielFormat.Font.Size = moFormat.Font.Size
'    oZielFormat.Font.Bold = moFormat.Font.Bold
'    oZielFormat.Font.Background = moFormat.Font.Background
'    oZielFormat.Font.Color = moFormat.Font.Color
'    oZielFormat.Font.ColorIndex = moFormat.Font.ColorIndex
'    oZielFormat.Font.Italic = moFormat.Font.Italic
'    oZielFormat.Font.Name = moFormat.Font.Name
'    oZielFormat.Font.OutlineFont = moFormat.Font.OutlineFont
'    oZielFormat.Font.Shadow = moFormat.Font.Shadow
'    oZielFormat.Font.Strikethrough = moFormat.Font.Strikethrough
'    oZielFormat.Font.Subscript = moFormat.Font.Subscript
'    oZielFormat.Font.Superscript = moFormat.Font.Superscript
'    oZielFormat.Font.Underline = moFormat.Font.Underline
'  Else
'    oZielFormat.IncludeFont = False
'  End If
'
'  If moFormat.IncludeNumber Then
'    'Zahlenformate duerfen nicht uebernommen werden!
'    'oZielFormat.NumberFormat  = moFormat.NumberFormat
'  Else
'    oZielFormat.IncludeNumber = False
'  End If
'
'  If moFormat.IncludePatterns Then
'    'oZielFormat. = moFormat
'  Else
'    oZielFormat.IncludePatterns = False
'
'  End If
'
'  If moFormat.IncludeProtection Then
'    oZielFormat.Locked = moFormat.Locked
'  Else
'    oZielFormat.IncludeProtection = False
'  End If
'
'  Set oZielFormat = Workbooks(ProjektDatei).Styles(moFormat.Name)
'
'End Sub
Attribute VB_Name = "C_Style"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'C_Template
'Oliver Seidel 28.09.2000
'  Da Objekte von VBA::Style nicht direkt erzeugt und gespeichert werden koennen, ist hier eine
'  Klasse als Wrapper implementiert. Deren Objekte sollen in der Projektdatenbank gespeichert werden
'  um unabhaengig von der Report.xls Datei zu sein. Nur leider gibt es damit noch Probleme...
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mlBorderWeight(6)      As Long
Private mlBorderLineStyle(6)   As Long
Private mfBorderColor(6)       As Double
Private mlBorderColorIndex(6)  As Long

Public Name As String

Public IncludeNumber  As Boolean
Public Number_Format  As String

Public IncludeFont        As Boolean
Public Font_Name          As String
Public Font_Size          As Double
Public Font_Bold          As Boolean
Public Font_Italic        As Boolean
Public Font_Underline     As Long
Public Font_OutlineFont   As Boolean
Public Font_Shadow        As Boolean
Public Font_Strikethrough As Boolean
Public Font_Subscript     As Boolean
Public Font_Superscript   As Boolean
Public Font_Background    As Long
Public Font_Color         As Double
Public Font_ColorIndex    As Long

Public IncludeAlignment     As Boolean
Public HorizontalAlignment  As Long
Public Orientation          As Long
Public ReadingOrder         As Long
Public VerticalAlignment    As Long
Public WrapText             As Boolean

Public IncludeBorder

Public IncludePatterns            As Boolean
Public Interior_Pattern           As Long
Public Interior_PatternColor      As Double
Public Interior_PatternColorIndex As Long
Public Interior_Color             As Double
Public Interior_ColorIndex        As Long

Public IncludeProtection  As Boolean
Public Locked             As Boolean

Public Property Let BorderWeight(lIndex As Long, lWeight As Long)
  mlBorderWeight(lIndex) = lWeight
End Property
Public Property Get BorderWeight(lIndex As Long) As Long
  BorderWeight = mlBorderWeight(lIndex)
End Property

Public Property Let BorderLineStyle(lIndex As Long, lLineStyle As Long)
  mlBorderLineStyle(lIndex) = lLineStyle
End Property
Public Property Get BorderLineStyle(lIndex As Long) As Long
  BorderLineStyle = mlBorderLineStyle(lIndex)
End Property

Public Property Let BorderColor(lIndex As Long, fColor As Double)
  mfBorderColor(lIndex) = fColor
End Property
Public Property Get BorderColor(lIndex As Long) As Double
  BorderColor = mfBorderColor(lIndex)
End Property

Public Property Let BorderColorIndex(lIndex As Long, lColorIndex As Long)
  mlBorderColorIndex(lIndex) = lColorIndex
End Property
Public Property Get BorderColorIndex(lIndex As Long) As Long
  BorderColorIndex = mlBorderColorIndex(lIndex)
End Property

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Call M_Debug.addRef("C_Style", glCStyleInstanz, glCStyleInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_Style", glCStyleInstanz, glCStyleInstanzMax)
End Sub


Attribute VB_Name = "C_TabBereich"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False






'===================================================================================================
'C_TabBereich
'Oliver Seidel 28.09.2000
'  Die Protokollformate bestehen aus verschiedenen Bereichen (Kopf- Fusszeilen, Datenbereich,
'  Seitenende,... Die Bereiche werden beim Analysieren der Vorlage bestimmt und in der Konfiguration
'  gespeichert. Aenderungen, die sich aus dem Erstellen von Protkollen ergeben, werden nachgefuehrt.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Public Blatt    As Long
Public Bereich  As String
Public Zeile    As Long
Public Spalte   As Long

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Call M_Debug.addRef("C_TabBereich", glCTabBereichInstanz, glCTabBereichInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_TabBereich", glCTabBereichInstanz, glCTabBereichInstanzMax)
End Sub


Attribute VB_Name = "C_Tariffset"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' _________________________________________________________________
'
'   Projekt:    PCS 7 Powerrate
'   Copyright (c) Siemens AG 2008. All rights reserved. Confidential.
' _________________________________________________________________
'
'   Modul:              clsTariffset.cls
'
'   Autor:              Ralf Leistner /A&D SE DE21
'   Datum:              12.11.2008
'   Version:            V 1.00
' _________________________________________________________________
'
'   Funktion:           Class for tariffset
' ________________________________________________________________________
'
'   Aenderungshistorie:
'
'   Autor: Wolfram Klebel
'   Datum: 15.11.2010
'   Version: PowerReport 3.0 / ExcelReport DB 3.7
'   Funktion: alles
'
'--------------------------------------------------------------------
Option Explicit

Option Compare Text

'**********************************************************
'                Definition von Konstanten
'**********************************************************
Private Const c_ModulName = "C_Tariffset"


'**********************************************************
'                Definition von Variablen
'**********************************************************
Public ID As Long
Public Name As String
Public CurrName As String

Public Medium As C_Medium
Public tsEntry As CO_TariffsetEntry

Public Holidays As Collection

'********************************************************************
'Beginn: Initialisierung der Klasse
'********************************************************************
Private Sub Class_Initialize()
  Dim sHelp As String
  ID = 0
  Name = "NewName"
  sHelp = Format(0, "Currency")
  CurrName = Mid(sHelp, 1, 1)
  CurrName = "|fffd|"
  
  Set Medium = New C_Medium
  Set tsEntry = New CO_TariffsetEntry

  Set Holidays = New Collection
End Sub
'********************************************************************
'Ende: Initialisierung der Klasse
'********************************************************************


'********************************************************************
'Beginn: Kopieren der Klasse
'********************************************************************
Public Function Copy() As C_Tariffset
Dim newTariffset As C_Tariffset ' WOKL 20.4.2010 Funktion ev. nicht benoetigt
Dim oItem As Object
Dim bExitDo As Boolean
Dim i As Long
Dim myLen As Long
Dim tempName As String

    On Error GoTo errorHandler
    
    Set newTariffset = New C_Tariffset
    '**************************************************************************************
    'Copy name in Microsoft Windows style
    '**************************************************************************************
    'If Not Config.TariffsetGroup.CheckElementByName(myLoadResString(DCT_COPY_OF) & Name) Then
    '    newTariffset.Name = myLoadResString(DCT_COPY_OF) & Name
    'Else
    '    i = 1
    '    Do
    '        bExitDo = False
    '        i = i + 1
    '        If Not Config.TariffsetGroup.CheckElementByName(myLoadResString(DCT_COPY) & i & myLoadResString(DCT_OF) & Name) Then
    '            newTariffset.Name = myLoadResString(DCT_COPY) & i & myLoadResString(DCT_OF) & Name
    '            bExitDo = True
    '        End If
    '    Loop Until bExitDo
    'End If
    '**************************************************************************************
    
    '**************************************************************************************
    'Copy name in SIMATIC Manager style (limited to 20 characters)
    '**************************************************************************************
    i = 1
    Do
        bExitDo = False
        myLen = Len(CStr(i))
        tempName = Left(Name, (20 - (myLen + 2)))
'        If Not Config.TariffsetGroup.CheckElementByName(tempName & "(" & i & ")") Then
'            newTariffset.Name = tempName & "(" & i & ")"
'            bExitDo = True
'        End If
        i = i + 1
    Loop Until bExitDo
    '**************************************************************************************
 
    
errorHandler:
    Set Copy = Nothing
End Function
'********************************************************************
'Ende: Kopieren der Klasse
'********************************************************************
Attribute VB_Name = "C_TariffsetEntry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' _________________________________________________________________
'
'   Projekt:    PowerReport 3.0
'   Copyright (c) ETM GesmbH 2010. All rights reserved. Confidential.
' _________________________________________________________________
'
'   Modul:              C_TariffsetEntry
'
'   Autor:              Wolfram Klebel
'   Datum:              15.11.2010
'   Version:            V 1.00
' _________________________________________________________________
'
'   Funktion:           SubClass for tariffset
' ________________________________________________________________________
'
'   Aenderungshistorie:
'
'   Autor:
'   Datum:
'   Version:
'   Funktion:
'
'--------------------------------------------------------------------
Option Explicit

Option Compare Text

'**********************************************************
'                Definition von Variablen
'**********************************************************
Public ID As Long
Public Name As String
Public ValidFrom As Date
Public ValidUntil As Date

Private mboTariffIsUsed(1 To TARIFFCOUNT) As Boolean
Private mdoTariffCost(1 To TARIFFCOUNT) As Double
Private mdtTariffStart(1 To TARIFFCOUNT) As Date
Private mdtTariffEnd(1 To TARIFFCOUNT) As Date
Private mboTariffOn(1 To TARIFFCOUNT, 8) As Boolean ' weekday-flags

Public Property Get TariffIsUsed(index As Integer) As Boolean
  Let TariffIsUsed = mboTariffIsUsed(index)
End Property
Public Property Let TariffIsUsed(index As Integer, par As Boolean)
  mboTariffIsUsed(index) = par
End Property
'-----
Public Property Get TariffCost(index As Integer) As Double
  Let TariffCost = mdoTariffCost(index)
End Property
Public Property Let TariffCost(index As Integer, par As Double)
  mdoTariffCost(index) = par
End Property
'-----
Public Property Get TariffStart(index As Integer) As Date
  Let TariffStart = mdtTariffStart(index)
End Property
Public Property Get aTariffStart() As Date()
  Let aTariffStart = mdtTariffStart()
End Property
Public Property Let TariffStart(index As Integer, par As Date)
  mdtTariffStart(index) = par
End Property
'-----
Public Property Get TariffEnd(index As Integer) As Date
  Let TariffEnd = mdtTariffEnd(index)
End Property
Public Property Get aTariffEnd() As Date()
  Let aTariffEnd = mdtTariffEnd()
End Property
Public Property Let TariffEnd(index As Integer, par As Date)
  mdtTariffEnd(index) = par
End Property
'-----
Public Property Get TariffOn(index As Integer, weekday As Integer) As Boolean
  Let TariffOn = mboTariffOn(index, weekday)
End Property
Public Property Let TariffOn(index As Integer, weekday As Integer, par As Boolean)
  mboTariffOn(index, weekday) = par
End Property

'********************************************************************
'Beginn: Initialisierung der Klasse
'********************************************************************
Private Sub Class_Initialize()
  Dim i As Integer
  Dim j As Integer

  ID = 0
  Name = "Default"
  ValidFrom = #1/1/1970#
  ValidUntil = #12/31/2099#
  
  For i = 1 To TARIFFCOUNT
    mboTariffIsUsed(i) = False
    mdoTariffCost(i) = CDbl("0")       ' IM 100492: comma error with "0,00"
    mdtTariffStart(i) = CDate("00:00:00")
    mdtTariffEnd(i) = CDate("00:00:00")
    For j = 1 To 8
      mboTariffOn(i, j) = False
    Next j
  Next i

End Sub
'********************************************************************
'Ende: Initialisierung der Klasse
'********************************************************************


'********************************************************************
'Beginn: Kopieren der Klasse
'********************************************************************
Public Function Copy() As C_TariffsetEntry
  Dim i As Integer
  Dim j As Integer
  Dim newTsE As C_TariffsetEntry

  'On Error GoTo ErrorHandler
  On Error GoTo 0
    
  Set newTsE = New C_TariffsetEntry
  With newTsE
    .ID = 0
    .Name = Me.Name
    .ValidFrom = Me.ValidFrom
    .ValidUntil = Me.ValidUntil
    
    For i = 1 To TARIFFCOUNT
      .TariffIsUsed(i) = Me.TariffIsUsed(i)
      .TariffCost(i) = Me.TariffCost(i)
      .TariffStart(i) = Me.TariffStart(i)
      .TariffEnd(i) = Me.TariffEnd(i)
      For j = 1 To 8
        .TariffOn(i, j) = Me.TariffOn(i, j)
      Next j
    Next i
  End With
  
  Set Copy = newTsE
    
Exit Function
errorHandler:
    Set Copy = Nothing
End Function
'********************************************************************
'Ende: Kopieren der Klasse
'********************************************************************

Attribute VB_Name = "C_Timer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_DPWert
'Oliver Seidel 28.09.2000
'Wolfram Klebel 26.4.2010
' Fehlerbehandlung eingebaut
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private msFunktion As String
Private WithEvents MyTimer As CTimer
Attribute MyTimer.VB_VarHelpID = -1

'---------------------------------------------------------------------------------------------------
Public Sub init(lIntervall As Long)

  If (Not MyTimer Is Nothing) Then
    'Call BugMessage("Intervall " & lIntervall, "C_Timer::Init")
    MyTimer.interval = lIntervall
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Reset()

  If (Not MyTimer Is Nothing) Then
    'Call BugMessage(msFunktion, "C_Timer::Reset")
    MyTimer.interval = 0
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Public Property Let Funktion(sFunktion As String)
  Call BugAssert((sFunktion = Me.FktPVSS) Or (sFunktion = Me.FktZeitPlan) Or (sFunktion = Me.FktAutoLogout), _
                 "CBFunktion nicht definiert!", "C_Timer::Funktion")
  msFunktion = sFunktion
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get FktPVSS()
  FktPVSS = "M_PVSS"
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get FktZeitPlan()
  FktZeitPlan = "Zeitplan"
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get FktAutoLogout()
  FktAutoLogout = "AutoLogout"
End Property

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()

  On Error GoTo Initialize_error
  Set MyTimer = New CTimer
  Call M_Debug.addRef("C_Timer", glCTimerInstanz, glCTimerInstanzMax)
  On Error GoTo 0
  
  Exit Sub
  
Initialize_error:
  Call BugMessage("SubTimer.dll Init-fehler: " & Err.Description, "C_Timer::Class_Initialize")
  Call MsgBox(Err.Source & " / SubTimer.dll " & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
              
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call M_Debug.Releas("C_Timer", glCTimerInstanz, glCTimerInstanzMax)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub MyTimer_ThatTime()
  
  Call BugMessage("CB Funktion aufgerufen von SubTimer (" & msFunktion & ")", "C_Timer::MyTimer_ThatTime()")
  
  Select Case msFunktion
    Case Me.FktPVSS
      'ToDo: Loeschen
      'Call M_PVSS.OnTime
    Case Me.FktZeitPlan
      Call M_ZeitPlan.ProtErstellenCB
    Case Me.FktAutoLogout
      Call M_Optionen.AutoLogoutCB
  End Select
  
End Sub

Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True






'===================================================================================================
'ThisWorkbook
'Oliver Seidel 28.09.2000
'  Regiert auf Ereignisse, die diese Arbeitsmappe betreffen.
'  - Initialisierung des Projekts beim oeffnen der Arbeitsmappe.
'  - Verhindert das Schliessen des Projekts, falls noch Vorlagen oder Protkolle geoeffnet sind.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private WithEvents appExcel As Application
Attribute appExcel.VB_VarHelpID = -1







'---------------------------------------------------------------------------------------------------
Private Sub appExcel_WorkbookBeforeSave(ByVal wb As Excel.Workbook, ByVal SaveAsUI As Boolean, cancel As Boolean)
  
  If DateiTyp(wb) = DATEI_VORLAGE Then
    Call M_Vorlage.Analysieren
    wb.Activate
  End If

End Sub


'---------------------------------------------------------------------------------------------------
Private Sub Workbook_BeforeClose(cancel As Boolean)

Dim wb As Workbook
Dim sh As Worksheet

  Call BugMessage("Das Projekt soll geschlossen werden!", _
                  "ThisWorkbook::BeforeClose")

  'Sind noch Projektdateiein geoeffnet?
  For Each wb In Workbooks
    'wb.Activate
    If DateiTyp(wb) = DATEI_VORLAGE Or _
       DateiTyp(wb) = DATEI_PROTOKOLL And _
       wb.Name <> "Report.xls" _
       Then

      'Beenden des Projektes abbrechen!
      Call MsgBox(GetResText(21133), vbOKOnly + vbExclamation, GetResText(20101))

      'Die Projektdatei soll angezeigt werden,
      'damit der Benutzer auch sieht, warum nicht beendet wird!
      ' wb.Sheets(2).Visible = xlSheetVisible
      wb.Activate
'      wb.Worksheets(TAB_KONFIG).Visible = xlSheetVisible
'      Set sh = wb.Worksheets(TAB_KONFIG)
'      sh.Activate
      
      
      cancel = True
      Exit Sub
    End If
  Next wb

  'Alles OK, Projekt kann beendet werden
  Call M_Report.ReportEnde
'Call MsgBox("ToDo: Aenderungen automatisch verwerfen" & Chr(13) & _
            "In ThisWorkbook::BeforeClose", vbOKOnly + vbExclamation, "Don't forget!!")
  ThisWorkbook.Saved = True

End Sub 'Workbook_BeforeClose()

'---------------------------------------------------------------------------------------------------
Private Sub Workbook_Open()
  
  Application.StatusBar = "init...."
  Call BugMessage("Projekt wird gestartet", "ThisWorkbook::Workbook_Open")
  Call InitAppEvents
  Call ReportStart
  Application.StatusBar = ""
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Workbook_WindowActivate(ByVal Wn As Excel.Window)
  Call InitAppEvents
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Workbook_WindowDeactivate(ByVal Wn As Excel.Window)
  Call InitAppEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub InitAppEvents()
Attribute InitAppEvents.VB_ProcData.VB_Invoke_Func = " \n14"
  If appExcel Is Nothing Then
    Set appExcel = Application
  End If
End Sub

Attribute VB_Name = "M_ATVProt"
'==================================================================================================
'M_ATVProt
'
'Oliver Seidel 22.03.2000
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

Private Const REF_KOPF_FUSS_ZEILEN = "A11"
Private Const REF_ATV_PROT_TYPEN = "E1"
Private Const REF_ATV_DPT = "F1"
Private Const REF_ATV_DPL = "M1"

'--------------------------------------------------------------------------------------------------
Public Sub WerteEintragen(wsProt As Worksheet, oDP As C_DP, oDPRef As C_DPReferenz, lDatenAnz As Long)

Dim iWertId As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long
Dim lMinColor As Long
Dim lMaxColor As Long

  On Error Resume Next
  lMinColor = getMinColor(wsProt.Parent)
  lMaxColor = getMaxColor(wsProt.Parent)

  If oDPRef.TabBereich.Bereich = VAR_DATENBEREICH Then
    
    'Zeitpunkt Offset eintragen
    wsProt.Cells(oDPRef.Zeile, 15) = oDP.Von
    
    For iWertId = 1 To oDP.coDPWert.Count
      'Bei Vergleichen (Offset) koennen zu viele Daten vorhanden sein
      If iWertId > lDatenAnz Then Exit For
      Call oDP.setRange( _
                   wsProt.Cells(oDPRef.Zeile, oDPRef.TabBereich.Spalte + iWertId), _
                   iWertId, lMinColor, lMaxColor)
    Next iWertId
    
    ' IM 109939 WOKL 5.3.13 index fault fixed
    wsProt.Cells(oDPRef.Zeile, 5) = oDP.Kommentar
    wsProt.Cells(oDPRef.Zeile, 6) = oDP.Alias
    wsProt.Cells(oDPRef.Zeile, 7) = oDP.Format
    wsProt.Cells(oDPRef.Zeile, 8) = oDP.Einheit
    
  Else
    Call oDP.setRange( _
                 wsProt.Cells(oDPRef.Zeile, oDPRef.TabBereich.Spalte), _
                 0, lMinColor, lMaxColor, _
                 oDPRef.TabBereich.Bereich)
  End If
  
End Sub


'--------------------------------------------------------------------------------------------------
Public Sub SeiteEinrichten(oProtokoll As C_Protokoll, wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim oTabBereich   As C_TabBereich
Dim oBereichKopf  As C_TabBereich
Dim oBereichDaten As C_TabBereich
Dim oBereichFuss   As C_TabBereich
Dim oBereichEnde  As C_TabBereich

Dim rgStart As Range
Dim rgEnde  As Range
Dim rgSuche As Range

Dim boSpalteAEingeblendet As Boolean

Dim rgDatenStart  As Range
Dim rgDatenEnde   As Range
Dim iDatenAnz     As Integer
Dim iDatenSpalte  As Integer
Dim dtZeit        As Date

'Dim wsProt      As Worksheet
Dim lwsProtID   As Long

Dim fStatus   As Single
Dim lStatusId As Long
Dim boErsterFehler As Boolean

  On Error GoTo M_ATVProt_SeiteEinrichten_Fehler

  ReDim audZeile(0)
  lStatusId = StatusTextAusgeben("")
  
  Call StatusTextAusgeben(wsProt.Name & " einrichten ", lStatusId)
  
'Call ZeitMessung(True)
    
  lwsProtID = wsProt.index
  wsProt.EnableCalculation = False
  
  Set oBereichKopf = coTabBereich.FindItem(lwsProtID, VAR_KOPFZEILE)
  Set oBereichDaten = coTabBereich.FindItem(lwsProtID, VAR_DATENBEREICH)
  Set oBereichFuss = coTabBereich.FindItem(lwsProtID, VAR_FUSSZEILE)
  Set oBereichEnde = coTabBereich.FindItem(lwsProtID, VAR_SEITENENDE)
  
  Set rgDatenStart = wsProt.Cells(1, oBereichDaten.Spalte + 1)
  Set rgStart = rgDatenStart
  Set rgDatenEnde = wsProt.Cells(1, oBereichFuss.Spalte - 1)
  
  iDatenSpalte = rgDatenEnde.Column - rgDatenStart.Column + 1
  iDatenAnz = oProtokoll.ZeitpunktAnz
  
  For Each oTabBereich In coTabBereich.Items
    With oTabBereich
      If .Blatt = lwsProtID And _
         .Spalte > oBereichDaten.Spalte Then
       .Spalte = .Spalte + iDatenAnz - iDatenSpalte
      End If
    End With
  Next oTabBereich
  
  Do Until iDatenSpalte >= iDatenAnz

    fStatus = Aufrunden(iDatenSpalte / iDatenAnz * 100)
    Call StatusTextAusgeben(wsProt.Name & " einrichten " & fStatus & "%", lStatusId)

    If (iDatenSpalte <= (iDatenAnz / 2)) Then
      Range(rgDatenStart, rgDatenEnde).EntireColumn.Copy
      rgDatenEnde.Offset(0, 1).Insert
      iDatenSpalte = iDatenSpalte * 2
      Set rgDatenEnde = rgDatenStart.Offset(0, iDatenSpalte - 1)
    Else
      Set rgDatenEnde = rgDatenStart.Offset(0, iDatenAnz - iDatenSpalte - 1)
      Range(rgDatenStart, rgDatenEnde).EntireColumn.Copy
      rgDatenStart.Offset(0, iDatenSpalte).Insert
      Set rgDatenEnde = rgDatenStart.Offset(0, iDatenAnz - 1)
      iDatenSpalte = iDatenAnz
    End If
  Loop
  
  If iDatenSpalte > iDatenAnz Then
    Range(rgDatenStart.Offset(0, iDatenSpalte - 1), rgDatenStart.Offset(0, iDatenAnz)).EntireRow.Delete
  End If
  
  For iDatenSpalte = 1 To iDatenAnz

    fStatus = Aufrunden(iDatenSpalte / iDatenAnz * 100)
    Call StatusTextAusgeben(wsProt.Name & " " & GetResText(21304) & "" & fStatus & "%", lStatusId)

    dtZeit = oProtokoll.Zeitpunkt(iDatenSpalte - 1)
    rgDatenStart.Offset(0, iDatenSpalte - 1).value = dtZeit
  Next iDatenSpalte
  
  wsProt.Range(wsProt.Cells(1, 1), wsProt.Cells(1, oBereichKopf.Spalte)).EntireColumn.hidden = True
  wsProt.Cells(1, oBereichDaten.Spalte).EntireColumn.hidden = True
  wsProt.Cells(1, oBereichFuss.Spalte).EntireColumn.hidden = True
  
  On Error Resume Next
  wsProt.Range(wsProt.Cells(1, oBereichEnde.Spalte), wsProt.Cells(1, 255)).EntireColumn.hidden = True
  On Error GoTo M_ATVProt_SeiteEinrichten_Fehler
  
  wsProt.Range("A1:A1").EntireRow.hidden = True
  
'Call ZeitMessung(False, "M_ATVProt::SeiteEinrichten " + wsProt.Name)
  Call StatusTextLoeschen(lStatusId)
  
Exit Sub
M_ATVProt_SeiteEinrichten_Fehler:
  boErsterFehler = (Err.Number < ERR_BASIS)
  'Call StatusTextLoeschen(lStatusID)
  Call FehlerAusloesen(ERR_PROT_SEITE_EINRICHTEN, , boErsterFehler)
End Sub

Attribute VB_Name = "M_ATVVorlage"
'==================================================================================================
'M_ATVVorlage
'Oliver Seidel 20.03.2000
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

'--------------------------------------------------------------------------------------------------
Public Sub DPEinfuegen()

Dim rgDp        As Range
Dim tabVorlage  As Worksheet

Dim coDP    As CO_DP
Dim oDP     As C_DP
Dim iDPL    As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long

Dim vwDPEinfuegen As V_DPEinfuegen
Dim iSelectionSpalte    As Integer

  On Error GoTo M_ATVVorlage_DPEinfuegen_Fehler

  Set vwDPEinfuegen = New V_DPEinfuegen
  
  vwDPEinfuegen.Modus = 5
  vwDPEinfuegen.Show

  If vwDPEinfuegen.ok Then
    iSelectionSpalte = ActiveWindow.ScrollColumn
    ActiveWindow.ActiveCell.EntireRow.Select
  
    Set coDP = vwDPEinfuegen.getDPL
    For iDPL = coDP.Count To 1 Step -1
      Selection.Insert
      Call setDp(Selection.Cells(1, 1), coDP.Item(iDPL))
    Next iDPL
  
    ActiveWindow.ScrollColumn = iSelectionSpalte
    Selection.Cells(2, iSelectionSpalte + 1).Select

  End If

  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing

Exit Sub
M_ATVVorlage_DPEinfuegen_Fehler:

  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_EINFUEGEN)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DPAendern()

Dim rgDp  As Range
Dim tabVorlage As Worksheet

Dim coDP    As CO_DP
Dim oDP     As C_DP

Dim vwDPEinfuegen As V_DPEinfuegen
Dim iSelectionSpalte    As Integer

  On Error GoTo M_ATVVorlage_DPAendern_Fehler

  Set vwDPEinfuegen = New V_DPEinfuegen
  Set rgDp = ActiveWindow.ActiveCell.EntireRow.Cells(1, 1)

  vwDPEinfuegen.Modus = 6
  Set oDP = getDp(rgDp)
  Call vwDPEinfuegen.setDp(oDP)
  vwDPEinfuegen.Show

  If vwDPEinfuegen.ok Then
    Set coDP = vwDPEinfuegen.getDPL
    For Each oDP In coDP.Items
      Call setDp(rgDp, oDP)
    Next oDP
    
  End If

  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing

Exit Sub
M_ATVVorlage_DPAendern_Fehler:

  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_AeNDERN)
End Sub

'--------------------------------------------------------------------------------------------------
'Ermittelt das Layout der Tabelle
Public Sub GetTabLayout(wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim rgSpalte      As Range
Dim coDPFkt       As CO_DPFunktion
Dim oDPFkt        As C_DPFunktion
Dim oTabBereich   As C_TabBereich
Dim boFktBereich  As Boolean

  Set coDPFkt = M_DPFunktion.coLesen
  Set rgSpalte = wsProt.Range("A1")
  
  Do While Not rgSpalte Is Nothing
    If rgSpalte.value = VAR_KOPFZEILE Or _
       rgSpalte.value = VAR_FUSSZEILE Or _
       rgSpalte.value = VAR_SEITENENDE Then
       
      Set oTabBereich = New C_TabBereich
      oTabBereich.Blatt = wsProt.index
      oTabBereich.Bereich = rgSpalte.value
      oTabBereich.Spalte = rgSpalte.Column
      coTabBereich.Add oTabBereich
    End If
    
    If rgSpalte.value = VAR_DATENBEREICH Then
      Set oTabBereich = New C_TabBereich
      oTabBereich.Blatt = wsProt.index
      oTabBereich.Bereich = rgSpalte.value
      oTabBereich.Spalte = rgSpalte.Column
      coTabBereich.Add oTabBereich
    End If
    
    If rgSpalte.Text = VAR_KOPFZEILE Or _
       rgSpalte.Text = VAR_FUSSZEILE Then
      boFktBereich = True
    ElseIf rgSpalte.Text = VAR_DATENBEREICH Or _
           rgSpalte.Text = VAR_SEITENENDE Then
      boFktBereich = False
    End If
    If boFktBereich Then
      For Each oDPFkt In coDPFkt.Items
        If oDPFkt.Bezeichnung = rgSpalte.value Then
          Set oTabBereich = New C_TabBereich
          oTabBereich.Blatt = wsProt.index
          oTabBereich.Bereich = oDPFkt.Bezeichnung
          oTabBereich.Spalte = rgSpalte.Column
          coTabBereich.Add oTabBereich
          Exit For
        End If
      Next oDPFkt
    End If
    
    Set rgSpalte = MoveRange(rgSpalte, xlToRight)
  Loop

End Sub

'--------------------------------------------------------------------------------------------------
Public Function getDp(rgDp As Range) As C_DP

Dim oDP         As C_DP
Dim coDPFkt     As CO_DPFunktion

Dim sDP         As String
Dim sDPE        As String
Dim sDPTyp      As String
Dim sDPFkt      As String
Dim iArchivTyp  As Integer
Dim lOffset     As Long
Dim lIntervall  As Long
Dim iIntEinheit As Integer
  
  sDP = rgDp.value
  sDPTyp = rgDp.Offset(0, 2).value
  sDPFkt = rgDp.Offset(0, 3).value
  iArchivTyp = RangeToLng(rgDp.Offset(0, 9), ARCHIVTYP_ACPERIODE)
    
  'DPTyp und DPFunktion OK?
  If sDPTyp = "" Or sDPFkt = "" Then
    sDP = ""
  End If
    
  'OK?
  If Len(sDP) Then
    
    Set oDP = New C_DP
    With oDP
      .dp = sDP
      .dpt = sDPTyp
      .dpe = rgDp.Offset(0, 1).value
      .ArchivFkt = sDPFkt
      .Kommentar = rgDp.Offset(0, 4).value
      .Alias = rgDp.Offset(0, 5).value
      .Format = rgDp.Offset(0, 6).value
      .Einheit = rgDp.Offset(0, 7).value
      .AutoFormat = RangeToLng(rgDp.Offset(0, 8))
      .ArchivTyp = iArchivTyp
      .Marker = RangeToLng(rgDp.Offset(0, 10))
      .ResultQuery = rgDp.Offset(0, 11).value
      .ResultFkt = rgDp.Offset(0, 12).Text
      .Offset = RangeToLng(rgDp.Offset(0, 13))
    End With
  End If
  Set getDp = oDP

End Function

'--------------------------------------------------------------------------------------------------
Public Sub setDp(rgDp As Range, oDP As C_DP)

  rgDp.value = oDP.dp
  rgDp.Offset(0, 1).value = oDP.dpe
  rgDp.Offset(0, 2).value = oDP.dpt
  rgDp.Offset(0, 3).value = oDP.ArchivFkt
  rgDp.Offset(0, 4).value = oDP.Kommentar
  rgDp.Offset(0, 5).value = oDP.Alias
  rgDp.Offset(0, 6).value = oDP.Format
  rgDp.Offset(0, 7).value = oDP.Einheit
  rgDp.Offset(0, 8).value = oDP.AutoFormat
  rgDp.Offset(0, 9).value = oDP.ArchivTyp
  rgDp.Offset(0, 10).value = oDP.Marker
  rgDp.Offset(0, 11).value = oDP.ResultQuery
  rgDp.Offset(0, 12).value = oDP.ResultFkt
  rgDp.Offset(0, 13).value = oDP.Offset

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub GetDPList(wsProt As Worksheet, coDP As CO_DP)

Dim rgDp        As Range
Dim oDP         As C_DP
Dim coDPFkt     As CO_DPFunktion

Dim sDPStat As String

Dim i As Integer

  Set coDPFkt = M_DPFunktion.coLesen

  'Spaltenweise die DP definition einlesen
  Set rgDp = wsProt.Cells(2, 1)
  While (Not rgDp Is Nothing)
  
    Set oDP = getDp(rgDp)
    
    If Not oDP Is Nothing Then
      'ACTyp?
      If oDP.ArchivTyp = ARCHIVTYP_ACPERIODE Or _
         oDP.ArchivTyp = ARCHIVTYP_RACPERIODE Then
        If coDPFkt.FindItem(oDP.ArchivFkt) Is Nothing Then
          Set oDP = Nothing
        End If
      End If
    End If
    If Not oDP Is Nothing Then
      Set oDP.TabBereich = New C_TabBereich
      oDP.TabBereich.Bereich = VAR_DATENBEREICH
      oDP.TabBereich.Blatt = wsProt.index
      oDP.TabBereich.Spalte = 0
      oDP.TabBereich.Zeile = rgDp.Row
      coDP.Add oDP
    End If
  
    Set rgDp = MoveRange(rgDp, xlDown)
  Wend

End Sub 'GetDPList

'--------------------------------------------------------------------------------------------------
Public Sub updateDpInfos(wsProt As Worksheet)

Dim oComMan As ComManager
Dim rgDp    As Range
Dim sDP     As String

Dim v As Variant

  On Error GoTo updateDpInfosFehler
  
  Set oComMan = M_PVSS.getComMan
  Set rgDp = MoveRange(wsProt.Cells(1, 1), xlDown)
  While (Not rgDp Is Nothing)
    
    sDP = rgDp.value
    'DPTyp und DPFunktion OK?
    If rgDp.Offset(0, 2).value = "" Or _
       rgDp.Offset(0, 3).value = "" Then
      sDP = ""
    End If
    
    'OK?
    If Len(sDP) Then
      'Bei AC Typen schauen wir auf das .value
      If rgDp.Offset(0, 9).value = ARCHIVTYP_ACPERIODE Then
        'DPE vorhanden?
        If rgDp.Offset(0, 1).value <> "" Then
          sDP = sDP & "." & rgDp.Offset(0, 1).value & ".value"
        Else
          sDP = sDP & ".value"
        End If
      Else
        sDP = sDP & "." & rgDp.Offset(0, 1).value
      End If
      v = oComMan.dpGetDescription(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 4).value = CStr(v)
      v = oComMan.dpGetAlias(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 5).value = CStr(v)
      v = oComMan.dpGetFormat(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 6).value = CStr(v)
      v = oComMan.dpGetUnit(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 7).value = CStr(v)
    End If
  
    Set rgDp = MoveRange(rgDp, xlDown)
  Wend

Exit Sub
updateDpInfosFehler:
  Stop
End Sub

'--------------------------------------------------------------------------------------------------
'Public Sub CleanWS(wsProt As Worksheet, coTabBereich As CO_TabBereich)
'
'Dim oTabBereich As C_TabBereich
'Dim rgDelete    As Range
'
'  Set oTabBereich = coTabBereich.FindItem(wsProt.Index, VAR_SEITENENDE)
'  If oTabBereich Is Nothing Then Exit Sub
'
'  Set rgDelete = wsProt.Range(wsProt.Cells(1, oTabBereich.Spalte + 1), wsProt.Cells(1, 255)).EntireColumn
'  rgDelete.Delete
'
'End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Update_3_0()

Dim wbProtVorlage As Worksheet

  'Schleife ueber alle Blaetter
  For Each wbProtVorlage In ActiveWorkbook.Worksheets
    If wbProtVorlage.Range("A1") = "ATV Protokoll" Then
      
      'Neue Spalten einfuegen
      wbProtVorlage.Columns(2).Insert
      wbProtVorlage.Columns(7).Insert
      wbProtVorlage.Columns(8).Insert
      wbProtVorlage.Columns(9).Insert
      
      'Spalten Beschriften
      wbProtVorlage.Range("B1").value = "DPE"
      wbProtVorlage.Range("C1").value = "DPT"
      wbProtVorlage.Range("D1").value = "Function"
      wbProtVorlage.Range("E1").value = "Comment"
      wbProtVorlage.Range("F1").value = "Alias"
      wbProtVorlage.Range("G1").value = "Result Query"
      wbProtVorlage.Range("H1").value = "Result Function"
      wbProtVorlage.Range("I1").value = "Offset"
      wbProtVorlage.Range("J1").value = "Offset Time"
      
    End If
  Next wbProtVorlage
End Sub
Attribute VB_Name = "M_Archiv"
'===================================================================================================
'M_Archiv
'Oliver Seidel 28.09.2000
'  Verwaltung der Archive (auch Import) und Dienstfunktionen fuer Intervallberechnung.
'Anmerkung: Editieren und Speichern der Archive wird (noch) nicht unterstuetzt. Die Archive muessen
'           komplett aus PVSS importiert werden.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Private bRefArchivDeleted As Boolean    ' flag for the loop of systems to delete just once


'--------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_Archiv

Dim recArchiv As ADODB.Recordset
Dim sSql      As String
Dim oArchiv   As C_Archiv

  On Error GoTo M_Archiv_coLesen_Fehler

  Set coLesen = New CO_Archiv
  
  sSql = "SELECT * FROM tabArchiv"
  Set recArchiv = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recArchiv.EOF
    Set oArchiv = New C_Archiv
    oArchiv.ID = recArchiv.Fields("ID")
    oArchiv.SYS = recArchiv.Fields("SYS")
    oArchiv.dpt = recArchiv.Fields("DPT")
    oArchiv.dpe = recArchiv.Fields("DPE")
    oArchiv.VStufe = recArchiv.Fields("VStufe")
    oArchiv.Intervall = recArchiv.Fields("Intervall")
    oArchiv.IntEinheit = recArchiv.Fields("IntEinheit")
    Set oArchiv.coDPFkt = M_DPFunktion.coSuchen(lArchivID:=oArchiv.ID)
    
    recArchiv.MoveNext
    coLesen.Add oArchiv
  Wend
  
  Call M_DB.CloseRecordset(recArchiv)
  
Exit Function
M_Archiv_coLesen_Fehler:
  
  Call M_DB.CloseRecordset(recArchiv)
  If Not oArchiv Is Nothing Then
    Call FehlerAusloesen(30700, "Archiv #" & oArchiv.ID, False, "M_Archiv::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Archiv::coLesen")
  End If

End Function 'coLesen()

'Public Sub coSpeichern(coArchiv As CO_Archiv)
'
'Dim dbReport     As Database
'Dim recArchiv  As ADODB.Recordset
'Dim oArchiv    As C_Archiv
'
'  On Error GoTo M_Archiv_coSpeichern_Fehler
'
'  Set dbReport = OpenDatabase(getDBReportDatei)
'
'  Set recArchiv = M_DB.ReportDB.OpenRecordset("tabArchiv", dbOpenDynaset)
'  For Each oArchiv In coArchiv.Items
'    Select Case oArchiv.ObjektStatus
'      Case OBJEKT_STATUS_NEU
'        recArchiv.FindFirst "ID = " & oArchiv.ID
'
'        If recArchiv.NoMatch Then
'          recArchiv.AddNew
'          recArchiv.Fields("DPT") = oArchiv.DPT
'          recArchiv.Fields("DPE") = oArchiv.DPE
'          recArchiv.Fields("VStufe") = oArchiv.VStufe
'          recArchiv.Fields("Intervall") = oArchiv.Intervall
'          recArchiv.Fields("IntEinheit") = oArchiv.IntEinheit
'          recArchiv.Update
'          recArchiv.Bookmark = recArchiv.LastModified
'          oArchiv.ID = recArchiv.Fields("ID")
'          oArchiv.ObjektStatus = OBJEKT_STATUS_GESPEICHERT
'        Else
'          Stop
'        End If
'      Case OBJEKT_STATUS_GEAENDERT
'        recArchiv.FindFirst "ID = " & oArchiv.ID
'        If Not recArchiv.NoMatch Then
'          recArchiv.Edit
'          recArchiv.Fields("DPT") = oArchiv.DPT
'          recArchiv.Fields("DPE") = oArchiv.DPE
'          recArchiv.Fields("VStufe") = oArchiv.VStufe
'          recArchiv.Fields("Intervall") = oArchiv.Intervall
'          recArchiv.Fields("IntEinheit") = oArchiv.IntEinheit
'          recArchiv.Update
'          oArchiv.ObjektStatus = OBJEKT_STATUS_GESPEICHERT
'        End If
'
'      Case OBJEKT_STATUS_GELOESCHT
'        recArchiv.FindFirst "ID = " & oArchiv.ID
'        If Not recArchiv.NoMatch Then
'          recArchiv.Delete
'          coArchiv.Remove (oArchiv.ID)
'        End If
'
'    End Select
'
'  Next oArchiv
'
'Exit Sub
'M_Archiv_coSpeichern_Fehler:
'  Call MsgBox(Err.Description, vbCritical + vbOKOnly, Err.Number & " " & Err.Source)
'End Sub

'--------------------------------------------------------------------------------------------------
Public Function coSuchen(Optional lID As Long = 0, _
                         Optional sDPT As String = "", _
                         Optional sDPE As String = "%", _
                         Optional sVStufe As String = "", _
                         Optional lIntervall As Long = 0, _
                         Optional iIntEinheit As Integer = 0, _
                         Optional lBasiswertID As Long = 0) As CO_Archiv

Dim recArchiv As ADODB.Recordset
Dim sSql      As String
Dim sWhere    As String

Dim oArchiv   As C_Archiv
Dim coArchiv  As CO_Archiv

  On Error GoTo M_Archiv_coSuchen_Fehler
  
  If lID > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "ID = " & lID
  End If
    
  If Len(sDPT) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "DPT like '" & sDPT & "'"
  End If
    
  If sDPE = "*" Then sDPE = "%"
  'If Len(sDPE) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "DPE like '" & sDPE & "'"
  'End If
    
  If Len(sVStufe) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "VStufe like '" & sVStufe & "'"
  End If
    
  If lIntervall > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "Intervall = " & lIntervall
  End If
    
  If iIntEinheit > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "IntEinheit = " & iIntEinheit
  End If
    
  If lBasiswertID > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "Basiswert = " & lBasiswertID
  End If
    
  If lBasiswertID > 0 Then
    sSql = "SELECT ID, SYS, DPT, DPE, VStufe, Intervall, IntEinheit, Basiswert " & _
           "FROM refArchiv INNER JOIN tabArchiv ON refArchiv.Archiv = tabArchiv.ID "
    If Len(sWhere) > 0 Then
      sSql = sSql & "WHERE " & sWhere & " "
    End If
    sSql = sSql & "GROUP BY ID, SYS, DPT, DPE, VStufe, Intervall, IntEinheit, Basiswert;"
  Else
    sSql = "SELECT ID, SYS, DPT, DPE, VStufe, Intervall, IntEinheit " & _
           "FROM tabArchiv "
    If Len(sWhere) > 0 Then
      sSql = sSql & "WHERE " & sWhere & " "
    End If
    sSql = sSql & "GROUP BY ID, SYS, DPT, DPE, VStufe, Intervall, IntEinheit;"
  End If

  Set coArchiv = New CO_Archiv
  Set recArchiv = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)

  While Not recArchiv.EOF
    Set oArchiv = New C_Archiv
    oArchiv.ID = recArchiv.Fields("ID")
    oArchiv.SYS = recArchiv.Fields("SYS")
    oArchiv.dpt = recArchiv.Fields("DPT")
    oArchiv.dpe = recArchiv.Fields("DPE")
    oArchiv.VStufe = recArchiv.Fields("VStufe")
    oArchiv.Intervall = recArchiv.Fields("Intervall")
    oArchiv.IntEinheit = recArchiv.Fields("IntEinheit")
    Set oArchiv.coDPFkt = M_DPFunktion.coSuchen(lArchivID:=oArchiv.ID)
    
    coArchiv.Add oArchiv
    recArchiv.MoveNext
  Wend

  Call M_DB.CloseRecordset(recArchiv)

  Set coSuchen = coArchiv

Exit Function
M_Archiv_coSuchen_Fehler:
  
  Call ErrMessage("SQL: " & sSql)
  Call M_DB.CloseRecordset(recArchiv)
  If Not oArchiv Is Nothing Then
    Call FehlerAusloesen(30701, "Archiv #" & oArchiv.ID, False, "M_Archiv::coSuchen")
  Else
    Call FehlerAusloesen(30701, Err.Description, False, "M_Archiv::coSuchen")
  End If

End Function 'coSuchen()

'--------------------------------------------------------------------------------------------------
Public Sub Import()

  Dim i         As Integer
  Dim sysName   As Variant
  Dim oComMan   As Object
  Dim sSql      As String
  Dim archMsg   As C_ArchivMsg
  
  Dim asSysNames() As String
  Dim iHelp      As Integer
  
  Set archMsg = New C_ArchivMsg
  Set oComMan = M_PVSS.getReportExt
  Call M_PVSS.PVSSInit
  If (M_PVSS.CheckForRdbStatus = False) Then Exit Sub
  
  bRefArchivDeleted = False   ' init for loop
  ReDim asSysNames(0)
  For i = 0 To MAX_SYSNO
  
    Call oComMan.getSystemName(i, sysName)
    
    If (sysName <> "") Then
      iHelp = UBound(asSysNames) + 1
      ReDim Preserve asSysNames(iHelp)
      asSysNames(iHelp) = sysName
    End If
  Next i
  
  archMsg.miSysCount = UBound(asSysNames)
  For i = 1 To UBound(asSysNames)
    archMsg.miSysNo = i
    Call ImportSys(asSysNames(i), archMsg)
    If (archMsg.miLastKeyPressed = ARCHMSG_CANCEL) Then  ' cancel
      Exit For
    End If
  Next i
  
  ' message "imported successfully"
  If bRefArchivDeleted = True And Not archMsg.miLastKeyPressed = ARCHMSG_CANCEL Then
    Call MsgBox(GetResText(21134), _
              vbOKOnly + vbInformation, _
              GetResText(20105))
      
    ' delete all entries that are not any more referenced
    sSql = "DELETE FROM refArchiv WHERE Archiv NOT IN (SELECT ID FROM tabArchiv)"
    M_DB.getConnection.Execute sSql
      
  End If
  
End Sub


'--------------------------------------------------------------------------------------------------
' Import functionality by system
Public Sub ImportSys(ByVal sysName As String, ByRef archMsg As C_ArchivMsg)

Dim boVorlagenAktualisieren As Boolean 'VStufe geaendert -> Vorlagen muessen aktualisiert werden!
Dim sSql      As String
Dim vAcSt     As Variant
Dim vAM       As V_ArchivMsg
Dim sHelp     As String

  boVorlagenAktualisieren = False
    
  If (archMsg.miLastKeyPressed < ARCHMSG_ALL_SYSTEMS And _
      archMsg.miLastKeyPressed <> ARCHMSG_CANCEL) Then      ' if not 'all systems' were clicked
    Set vAM = New V_ArchivMsg
    
    ' Sollen die Parametrierdaten vom [SYSTEM] eingelesen werden?
    sHelp = Chr(34) & sysName & Chr(34)
    If (archMsg.miSysCount > 1) Then
      sHelp = sHelp & " (" & archMsg.miSysNo & "/" & archMsg.miSysCount & ")"
    End If
    archMsg.msMsg = TextErsetzen(GetResText(22014), "[SYSTEM]", sHelp)
    archMsg.mbAcRdbSelect = True
    Set vAM.archivMsg = archMsg
    vAM.Show
    archMsg.mbAcRdbSelect = False
  End If
  
  If (archMsg.miLastKeyPressed >= ARCHMSG_YES) Then   ' not no or cancel
  
    If (bRefArchivDeleted = False) Then
      'Referenzen auf die Funktionen loeschen
      '(ist einfacher als eine einzelne Verwaltung der Datensaetze)
      sSql = "DELETE FROM refFunktion"
      M_DB.getConnection.Execute sSql
      
      bRefArchivDeleted = True
    End If
  
    'Alle Datensaetze zum Loeschen markieren
    sSql = "UPDATE tabArchiv SET Loeschen = 1 WHERE SYS = '" & sysName & "'"
    M_DB.getConnection.Execute sSql
  
    If (archMsg.mboACPara = True) Then      ' AC Parametrierung
      Call M_PVSS.getReportExt.getAcStructureSys(sysName, vAcSt)
      Call ImportSysRaw(sysName, vAcSt, boVorlagenAktualisieren)
    End If
    
    If (IS_RDBACTIVE And archMsg.mboRDBPara = True) Then      ' RDB Compression
      Call ImportSysRDB(sysName)
    End If
    
    sSql = "DELETE FROM tabArchiv WHERE Loeschen <> 0"
    M_DB.getConnection.Execute sSql
    
    Call NewArchiveToBasicValues(sysName, archMsg)
  
    If boVorlagenAktualisieren Then
      Call M_Vorlage.Nachziehen
    End If
  End If

End Sub



'--------------------------------------------------------------------------------------------------
Public Sub ImportSysRaw(ByVal sysName As String, ByRef vAcSt As Variant, ByRef boVorlagenAktualisieren As Boolean)

Dim oReportExt  As reportExt
Dim lRow        As Long

Dim spDPT         As Integer
Dim spDPE         As Integer
Dim spVSTUFE      As Integer
Dim spINTERVALL   As Integer
Dim spFUNKTION    As Integer

Dim sDPT          As String
Dim sDPE          As String
Dim sVStufe       As String
Dim lIntervall    As Long
Dim lIntervallAnz As Long
Dim iEinheit      As Integer

Dim refArchiv     As ADODB.Recordset
Dim tabArchiv     As ADODB.Recordset
Dim refFunktion   As ADODB.Recordset
Dim tabFunktion   As ADODB.Recordset
Dim sSql          As String
Dim lFktID        As Long
Dim lArchivID     As Long

Dim lStatusId   As Long
Dim sStatusText As String
Dim nDatensatz  As Long
Dim n As Long
Dim m As Long

  On Error GoTo Import_Archivstruktur_Fehler

  sStatusText = GetResText(21326) & " "
  nDatensatz = 0
  lStatusId = StatusTextAusgeben(sStatusText & nDatensatz)
  
  spDPT = 0
  spDPE = 1
  spVSTUFE = 2
  spFUNKTION = 3
  spINTERVALL = 4
  
  'Datenbank oeffnen
  sSql = "SELECT * FROM tabFunktion"
  Set tabFunktion = M_DB.OpenRecordset(sSql, adOpenStatic, adLockReadOnly)
  
  'Alle Spalten gefunden? (Das sollte nun wirklich nicht passieren)
  If UBound(vAcSt, 2) < 4 Then
    Call FehlerAusloesen(30602, "AcStructure", True, "M_Archiv::Import")
    Exit Sub
  End If
  
  For lRow = 1 To UBound(vAcSt)
  
    nDatensatz = nDatensatz + 1
    Call StatusTextAusgeben(sStatusText & nDatensatz & " - " & vAcSt(lRow, spDPT), lStatusId)

    'Funktion suchen
    tabFunktion.MoveFirst
    tabFunktion.Find "DPE = '" & vAcSt(lRow, spFUNKTION) & "'", , adSearchForward
    If Not tabFunktion.EOF Then
      lFktID = tabFunktion.Fields("ID")
      
      'Gleiches Archiv wie beim letzten Durchlauf?
      '(aber andere Funktion!)
      If sDPT = vAcSt(lRow, spDPT) And _
         sDPE = vAcSt(lRow, spDPE) And _
         sVStufe = vAcSt(lRow, spVSTUFE) And _
         lIntervall = vAcSt(lRow, spINTERVALL) Then
      
      Else      'Nicht nur die Funktion hat sich geaendert
      
        sDPT = vAcSt(lRow, spDPT)
        sDPE = vAcSt(lRow, spDPE)
        sVStufe = vAcSt(lRow, spVSTUFE)
        lIntervall = vAcSt(lRow, spINTERVALL)
        'convert intervall from seconds to count/unit (e.g. '5 erMinutes')
        Call SecToIntervallWithUnit(lIntervall, _
                                    lIntervallAnz, _
                                    iEinheit)
      
        'Suche nach DPT, DPE und Intervall
        ' (Verdichtungsstufe geaendert?)
        sSql = "SELECT * FROM tabArchiv WHERE " & _
               "((SYS = '" & sysName & "') AND " & _
               "(DPT = '" & sDPT & "') AND " & _
               "(DPE = '" & sDPE & "') AND " & _
               "(Intervall = " & lIntervallAnz & ") AND " & _
               "(IntEinheit = " & iEinheit & "))"
        Set tabArchiv = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockOptimistic)
        If Not tabArchiv.EOF Then
          lArchivID = tabArchiv.Fields("ID")
          'Verdichtungsstufe geaendert?
          If (tabArchiv.Fields("VStufe") <> sVStufe) And Not (sVStufe = "RDB") Then
            tabArchiv.Fields("VStufe") = sVStufe            'Datensatz aktualisieren
            'Achtung: RefArchiv bleibt erhalten aber neue VStufe
            '-> Vorlagen muessen aktualisiert werden
            boVorlagenAktualisieren = True
          End If
          tabArchiv.Fields("Loeschen") = 0
          tabArchiv.Update
        Else 'Nicht gefunden
          Call M_DB.CloseRecordset(tabArchiv)
          'Suche nach DPT, DPE und VStufe
          sSql = "SELECT * FROM tabArchiv WHERE " & _
                 "(SYS = '" & sysName & "' AND " & _
                 "DPT = '" & sDPT & "' AND " & _
                 "DPE = '" & sDPE & "' AND " & _
                 "VStufe = '" & sVStufe & "')"
          Set tabArchiv = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
          'Gefunden?
          If Not tabArchiv.EOF And Not sVStufe = "RDB" Then
            lArchivID = tabArchiv.Fields("ID")
            'Intervall muss sich geaendert haben -> Datensatz aktualisieren
            tabArchiv.Fields("Intervall") = lIntervallAnz
            tabArchiv.Fields("IntEinheit") = iEinheit
            tabArchiv.Fields("Loeschen") = 0
            'Achtung: RefArchiv loeschen, da neues Intervall vorliegt
            sSql = "SELECT * FROM refArchiv WHERE " & _
                   "(Archiv = " & tabArchiv.Fields("ID") & ")"
            Set refArchiv = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
            If Not refArchiv.EOF Then
              refArchiv.Delete
            End If
            Call M_DB.CloseRecordset(refArchiv)
            tabArchiv.Update
            
          Else 'Nicht gefunden? => Neuen Datensatz anlegen
           
            tabArchiv.AddNew
            tabArchiv.Fields("SYS").value = sysName
            tabArchiv.Fields("DPT").value = sDPT
            tabArchiv.Fields("DPE").value = sDPE
            tabArchiv.Fields("VStufe").value = sVStufe
            tabArchiv.Fields("Intervall").value = lIntervallAnz
            tabArchiv.Fields("IntEinheit").value = iEinheit
            
            tabArchiv.Update
            'tabArchiv.Bookmark = tabArchiv.LastModified
            lArchivID = tabArchiv("ID")
            
          End If 'Neuer Datensatz
          Call M_DB.CloseRecordset(tabArchiv)
        End If 'Suche nach Verdichtungsstufe
  
      End If
      
      sSql = "SELECT * FROM refFunktion WHERE " & _
             "((Archiv = " & lArchivID & ") AND " & _
             "(Funktion = " & lFktID & "))"
      Set refFunktion = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
      If refFunktion.EOF Then
        refFunktion.AddNew
        refFunktion.Fields("Archiv") = lArchivID
        refFunktion.Fields("Funktion") = lFktID
        refFunktion.Update
      End If
      Call M_DB.CloseRecordset(refFunktion)
    
    Else
      'ToDo Fehlerprotokoll
      ' 25001: "function not implemented"
      MsgBox GetResText(25001) & Chr(13) & vAcSt(lRow, spFUNKTION), vbCritical + vbOKOnly, GetResText(20104)
    End If
  Next lRow

  Call M_DB.CloseRecordset(tabFunktion)

  Call StatusTextLoeschen(lStatusId)

Exit Sub
Import_Archivstruktur_Fehler:
  Call ErrMessage("sSQL:" & sSql & Chr(13) & Err.Description, "M_Archiv::ImportSys")
  MsgBox (Err.Description)
  Call M_DB.CloseRecordset(refArchiv)
  Call M_DB.CloseRecordset(tabArchiv)
  Call M_DB.CloseRecordset(refFunktion)
  Call M_DB.CloseRecordset(tabFunktion)
  Call FehlerAusloesen(30520, Err.Description, False, "M_Archiv::Import")
End Sub
'--------------------------------------------------------------------------------------------------
Public Sub ImportSysRDB(ByVal sysName As String)

Dim reportExt As Object
Dim dpTypes     As Variant
Dim dpNames     As Variant
Dim dpElems     As Variant
Dim i           As Long
Dim j           As Long
Dim vAcSt       As Variant
Dim asDpElems()      As String
Dim asTypes()    As String
Dim elName      As String
Dim fctName     As String
Dim iNum        As Long
Dim iUnit       As Long
Dim boVorlagenAktualisieren As Boolean

  ' read DPT list
  Set reportExt = M_PVSS.getReportExt
  Call reportExt.dpRdbTypes(sysName & ":", dpTypes)
    
  ' look for all master dp and feed all compression elems to array
  ReDim asDpElems(0)
  ReDim asTypes(0)
  If Not IsEmpty(dpTypes) Then
    For i = 1 To UBound(dpTypes)
      Call reportExt.dpRdbNames(sysName & ":_mp*", dpTypes(i), dpNames) ' select for all "_mp" mass para DPs
      
      If (Not IsEmpty(dpNames) And UBound(dpNames) > 0) Then
        Call reportExt.dpRdbElems(sysName & ":", dpNames(1), dpElems)   ' assume just _one_ master allowed
        For j = 1 To UBound(dpElems)
          ReDim Preserve asDpElems(UBound(asDpElems) + 1)
          asDpElems(UBound(asDpElems)) = dpElems(j)
          ReDim Preserve asTypes(UBound(asTypes) + 1)
          asTypes(UBound(asTypes)) = dpTypes(i)
        Next j
      End If
    Next i
  End If
  
  ' no other way found to create variant as string array
  ReDim vAcSt(UBound(asDpElems), 4) As String
  vAcSt(0, 0) = "Type"
  vAcSt(0, 1) = "DPE"
  vAcSt(0, 2) = "Compression"
  vAcSt(0, 3) = "Function"
  vAcSt(0, 4) = "Interval"
  
  For i = 1 To UBound(asDpElems)
    Call convertDpToDetails(asDpElems(i), elName, fctName, iNum, iUnit)
    vAcSt(i, 0) = asTypes(i)
    vAcSt(i, 1) = elName
    vAcSt(i, 2) = "RDB"
    vAcSt(i, 3) = fctName
    vAcSt(i, 4) = IntervallWithUnitToSec(iNum, iUnit)
  Next i
        
  ' enter them into tabArchiv
  Call ImportSysRaw(sysName, vAcSt, boVorlagenAktualisieren)

End Sub
'--------------------------------------------------------------------------------------------------
' find out all information from compression dpe
' @param input: name - element name, eg. "System1:Example_DPint.:_5min_avg"
' @param output: elname, eg. ""
' @param output: fctName, eg. "avg"
' @param output: iNum, eg. '5'
' @param output: iUnit as constant, eg. 'erMinutes'
Private Sub convertDpToDetails(ByVal Name As String, ByRef elName As String, _
                               ByRef fctName As String, ByRef iNum As Long, ByRef iUnit As Long)
  Dim detail  As String
  Dim secs    As Long
  Dim i       As Integer
  Dim timName As String
  
  Name = Mid$(Name, InStr(Name, ":") + 1)    ' omit system
  Name = Mid$(Name, InStr(Name, ".") + 1)
  If (InStr(Name, ":") > 1) Then
    elName = Mid$(Name, 1, InStr(Name, ":") - 1)
  Else
    elName = ""
  End If
  detail = Mid$(Name, InStr(Name, ":") + 1)   ' take detail from config
  
  detail = Mid$(detail, InStr(detail, "_") + 1)
  For i = 1 To 5
    If (Asc(Mid$(detail, i, 1)) > 57) Then    ' bigger than '9'
      timName = Mid$(detail, i, InStr(detail, "_") - i)
      Exit For
    End If
  Next i
  iNum = val(detail)
  fctName = Mid$(detail, InStr(detail, "_") + 1)
  
  ' convert detail part to time constants
  Select Case timName
  Case "min"
    iUnit = erMinute
  Case "hour"
    iUnit = erStunde
  Case "day"
    iUnit = erTag
  Case "week"
    iUnit = erWoche
  Case "month"
    iUnit = erMonat
  Case "year"
    iUnit = erJahr
  End Select
  
  ' convert detail part to elem names (from AC Para), is then indexed in table tabFunction.DPE
  Select Case fctName
  Case "sum", "min", "max", "avg", "diff", "min_time", "max_time"
    fctName = UCase(fctName)
  Case "avg_integral"
    fctName = "AVG_WT0"
  Case "diffabs"
    fctName = "DIFF_ABS"
  Case Else
    MsgBox ("M_Archiv::convertDpToDetails - Internal error: function not found " & fctName)
  End Select
  
End Sub
'--------------------------------------------------------------------------------------------------
' Adds new params from tabArchiv into tables tabBasiswert and tabProtTyp
' @Param sysName: used for user message when asking wether default protocol type should be imported

Private Sub NewArchiveToBasicValues(ByVal sysName As String, ByRef arch As C_ArchivMsg)

Dim tabArchiv     As ADODB.Recordset
Dim tabIntervall  As ADODB.Recordset
Dim sSql          As String
Dim lIntervall    As Long
Dim lIntEinheit   As Long
Dim alArchivId()  As Long

Dim lBasisStunde    As Long
Dim lBasisTag       As Long
Dim lBasisMonat     As Long

Dim n As Long

  'Sucht alle Archive, die noch nicht einem Basiswert zugeordnet sind
  'Pro Datensatz ein Intervall/IntEinheit
  sSql = "SELECT IntEinheit, Intervall " & _
         "FROM tabArchiv " & _
         "WHERE ID Not In (SELECT Archiv FROM refArchiv) " & _
         "GROUP BY tabArchiv.IntEinheit, tabArchiv.Intervall;"
  Set tabIntervall = M_DB.OpenRecordset(sSql, adOpenStatic, adLockReadOnly)
  While Not tabIntervall.EOF
    lIntEinheit = tabIntervall.Fields(0)
    lIntervall = tabIntervall.Fields(1)
    ReDim alArchivId(0)
    n = 1
    sSql = "SELECT ID " & _
           "FROM tabArchiv " & _
           "WHERE (ID Not In (SELECT Archiv FROM refArchiv)) AND " & _
                 "(IntEinheit = " & lIntEinheit & ") AND " & _
                 "(Intervall = " & lIntervall & ")"
    Set tabArchiv = M_DB.OpenRecordset(sSql, adOpenStatic, adLockReadOnly)
    While Not tabArchiv.EOF
      ReDim Preserve alArchivId(n)
      alArchivId(n) = tabArchiv.Fields(0)
      n = n + 1
      tabArchiv.MoveNext
    Wend
    n = M_Basiswert.addDefaultBasiswert(lIntEinheit, lIntervall, alArchivId, sysName, arch)
    If lIntervall = 1 Then
      Select Case lIntEinheit
        Case erStunde: lBasisStunde = n
        Case erTag:    lBasisTag = n
        Case erMonat:  lBasisMonat = n
      End Select
    End If
    tabIntervall.MoveNext
  Wend

  If (lBasisStunde > 0) And (lBasisTag > 0) Then
    Call addDefaultProtokollTyp(erTag, lBasisStunde, lBasisTag, sysName, arch)
  End If
  If (lBasisTag > 0) And (lBasisMonat > 0) Then
    Call addDefaultProtokollTyp(erMonat, lBasisTag, lBasisMonat, sysName, arch)
  End If

  ' IM 82756 WOKL 7.2.08 Eingefuegt
  Call M_Basiswert.coBasiswertCacheReset
  
End Sub

'Sucht aus den Archiven alle Intervalle, die noch nicht
'einem Basiswert zugeordnet sind.
'SELECT IntEinheit, Intervall
'FROM tabArchiv
'WHERE ID Not In (SELECT Archiv FROM refArchiv)
'GROUP BY tabArchiv.IntEinheit, tabArchiv.Intervall;

'Sucht alle Archive, die noch nicht einem Basiswert zugeordnet sind
'SELECT *
'FROM tabArchiv
'WHERE ID Not In (SELECT Archiv FROM refArchiv)
'ORDER BY tabArchiv.IntEinheit, tabArchiv.Intervall;


'--------------------------------------------------------------------------------------------------
'Diese Funktion entspricht der PVSS Ctrl Funktion acGetIntervalString
Public Sub SecToIntervallWithUnit(ByVal lSekunden As Long, _
                                   ByRef lIntervall As Long, _
                                   ByRef iUnit As Integer)

  If (lSekunden >= (365 * 86400)) Then
    lIntervall = lSekunden / (365 * 86400)
    iUnit = erJahr
  ElseIf (lSekunden >= (31 * 86400)) Then
    lIntervall = lSekunden / (31 * 86400)
    iUnit = erMonat
  ElseIf (lSekunden >= (7 * 86400)) Then
    lIntervall = lSekunden / (7 * 86400)
    iUnit = erWoche
  ElseIf (lSekunden >= 86400) Then
    lIntervall = lSekunden / 86400
    iUnit = erTag
  ElseIf (lSekunden >= 3600) Then
    lIntervall = lSekunden / 3600
    iUnit = erStunde
  ElseIf (lSekunden >= 60) Then
    lIntervall = lSekunden / 60
    iUnit = erMinute
  Else
    lIntervall = lSekunden
    iUnit = erSekunde
  End If
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Function IntervallWithUnitToSec(ByVal lIntervallAnz As Long, _
                                       ByVal iUnit As Integer) As Long
                                       
Dim lSekunden As Long

  Select Case iUnit
    Case erSekunde: lSekunden = lIntervallAnz
    Case erMinute:  lSekunden = lIntervallAnz * 60
    Case erStunde:  lSekunden = lIntervallAnz * 3600
    Case erTag:     lSekunden = lIntervallAnz * 86400
    Case erWoche:   lSekunden = lIntervallAnz * 86400 * 7
    Case erMonat:   lSekunden = lIntervallAnz * 86400 * 31
    Case erJahr:    lSekunden = lIntervallAnz * 86400 * 365
  End Select
  
  IntervallWithUnitToSec = lSekunden
  
End Function

'--------------------------------------------------------------------------------------------------
Public Function IntervallWithUnitToStr(ByVal lInterval As Long, ByVal iUnit As Integer) As String
  IntervallWithUnitToStr = CStr(lInterval) & " " & _
                           GetResText(TXT_ZEIT_EINHEIT_BEGINN + iUnit)
End Function

'--------------------------------------------------------------------------------------------------
Public Sub StrToIntervallWithUnit(ByRef sSource As String, ByRef lInterval As Long, ByRef iUnit As Integer)

Dim s As String
  
  On Error Resume Next
  iUnit = 0
  lInterval = CLng(ElementN(sSource, 1, " "))
  s = ElementN(sSource, 2, " ")
  For iUnit = 1 To TXT_ZEIT_EINHEIT_ANZ
    If GetResText(TXT_ZEIT_EINHEIT_BEGINN + iUnit) = s Then Exit For
  Next iUnit

End Sub

'--------------------------------------------------------------------------------------------------
Public Function getIntFormatStr(ByVal iUnit As Integer) As String

Dim sFormatStr As String

  Select Case iUnit
    Case erSekunde: sFormatStr = "s"
    Case erMinute:  sFormatStr = "n"
    Case erStunde:  sFormatStr = "h"
    Case erTag:     sFormatStr = "d"
    Case erWoche:   sFormatStr = "ww"
    Case erMonat:   sFormatStr = "m"
    Case erJahr:    sFormatStr = "yyyy"
  End Select
  
  getIntFormatStr = sFormatStr

End Function

Attribute VB_Name = "M_Basiswert"
'===================================================================================================
'M_Basiswert
'Oliver Seidel 31.07.2000
'  Verwaltung der Basiswerte
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Private mcoBasiswertCache As CO_Basiswert

'---------------------------------------------------------------------------------------------------
' die hier brauchen wir, damit nach einem neuen Einlesen der Konfiguration auch der Basiswert wieder stimmt
' WOKL 7.2.08 IM 82756
Public Sub coBasiswertCacheReset()
    
    Set mcoBasiswertCache = Nothing
    
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwBasiswert As V_Basiswert
Dim coBasiswert As CO_Basiswert

  On Error GoTo M_Basiswert_Edit_Fehler
  
  Set vwBasiswert = New V_Basiswert
  Set coBasiswert = M_Basiswert.coLesen
  Set vwBasiswert.Basiswert = coBasiswert
  vwBasiswert.Show
  If vwBasiswert.ok Then
    'Sieht lustig aus, aber auf Collection wird direkt referenziert
    'Aenderungen schlagen also automatisch durch!
    Call M_Basiswert.coSpeichern(coBasiswert)
    
    'Vorsicht Falle!
    'Auch wenn man es hier nicht sieht, es wird indirekt mcoBasiswertCache geaendert! UND
    'Die Editierten Basiswerte kennen zwar ihre Archive (DPE aus AC Parametrierung, inkl VStufe)
    'aber nicht die dort enthaltenen Stat. Funktionen (AVG_WT0).
    'Nun koennte man diese Infos an dieser Stelle erneut aus der DB lesen, einfacher ist es
    'jedoch, den Cache wegzuschmeissen. Der Performance- Verlust ist selbst bei Dongshen irrelevant.
    Set mcoBasiswertCache = Nothing
    
  End If
  'ToDo: Falls coBasiswert gepuffert wird, muss nach einem Abbruch der
  'Bearbeitung der Puffer geloescht werden!
  'Stimmt, ich sollte mal das Datum zu meinen Kommentaren aufnehmen
  Set mcoBasiswertCache = Nothing
    
  Unload vwBasiswert
  Set vwBasiswert = Nothing

Exit Sub
M_Basiswert_Edit_Fehler:
  
  If Not vwBasiswert Is Nothing Then
    Unload vwBasiswert
    Set vwBasiswert = Nothing
  End If
  Call FehlerAusloesen(30702, , False, "M_Basiswert::coEdit")
  
End Sub 'coEdit()

'---------------------------------------------------------------------------------------------------
Public Function addDefaultBasiswert(lIntEinheit As Long, lIntervall As Long, alArchivId() As Long, _
                                    ByVal sysName As String, ByRef archMsg As C_ArchivMsg) As Long

Dim recBasiswert  As ADODB.Recordset
Dim recArchiv     As ADODB.Recordset
Dim sBasiswert    As String
Dim lID           As Long
Dim sSql          As String

Dim lStatusId   As Long
Dim sStatusText As String

Dim i As Integer
Dim n As Long
Dim s As String
Dim vAM As V_ArchivMsg

  On Error GoTo addDefaultBasiswert_Fehler

  If lIntEinheit < erSekunde Or lIntEinheit > erJahr Then
    Exit Function
  End If
  sBasiswert = GetResText(TXT_ZEIT_EINHEIT_BEGINN + lIntEinheit)
  If lIntervall = 1 Then
    Select Case lIntEinheit
      Case erStunde:   sBasiswert = GetResText(21580)
      Case erTag:      sBasiswert = GetResText(21581)
      Case erMonat:    sBasiswert = GetResText(21582)
      Case Else
        i = InStr(1, sBasiswert, "(")
        If i > 1 Then
          sBasiswert = Left(sBasiswert, i - 1)
        End If
    End Select
  Else
    sBasiswert = TextErsetzen(sBasiswert, "(", "")
    sBasiswert = lIntervall & " " & TextErsetzen(sBasiswert, ")", "")
  End If

  lStatusId = StatusTextAusgeben(GetResText(21317))

  sSql = "SELECT ID, Bezeichnung, Intervall, IntEinheit FROM tabBasiswert WHERE Bezeichnung = '" & sBasiswert & "';"
  Set recBasiswert = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  If recBasiswert.EOF Then
    ' Basiswert erstellen? (20107)
    If (archMsg.miLastKeyPressed = ARCHMSG_YES Or _
        archMsg.miLastKeyPressed = ARCHMSG_NO) Then      ' if not 'all systems' were clicked
      Set vAM = New V_ArchivMsg
      s = GetResText(21135) ' Basiswert nicht def! - soll er erstellt werden?
      archMsg.msMsg = TextErsetzen(s, "[BASICVALUE]", sBasiswert & " [" & sysName & "] ")
      Set vAM.archivMsg = archMsg
      vAM.Show
    End If
    
    If archMsg.miLastKeyPressed >= ARCHMSG_YES Then   ' yes / system / all systems
      recBasiswert.AddNew
      recBasiswert.Fields("Bezeichnung") = sBasiswert
      recBasiswert.Fields("Intervall") = lIntervall
      recBasiswert.Fields("IntEinheit") = lIntEinheit
      recBasiswert.Update
      'recBasiswert.Bookmark = recBasiswert.LastModified
      lID = recBasiswert.Fields("ID")
      
    End If
  Else
    If (archMsg.miLastKeyPressed = ARCHMSG_YES Or _
        archMsg.miLastKeyPressed = ARCHMSG_NO) Then      ' if not 'all systems' were clicked
      Set vAM = New V_ArchivMsg
      s = GetResText(21136) ' Basiswert nicht def! - soll er erweitert werden?
      archMsg.msMsg = TextErsetzen(s, "[BASICVALUE]", sBasiswert & " [" & sysName & "] ")
      Set vAM.archivMsg = archMsg
      vAM.Show
    End If
    
    If archMsg.miLastKeyPressed >= ARCHMSG_YES Then
      lID = recBasiswert.Fields("ID")
    End If
  
  End If
  
  Call M_DB.CloseRecordset(recBasiswert)
  
  If lID > 0 Then
    sSql = "SELECT * FROM refArchiv"
    Set recArchiv = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
    For n = 1 To UBound(alArchivId)
      recArchiv.AddNew
      recArchiv.Fields("Basiswert") = lID
      recArchiv.Fields("Archiv") = alArchivId(n)
      recArchiv.Update
    Next n
    Call M_DB.CloseRecordset(recArchiv)
  End If
  
  addDefaultBasiswert = lID
  
  Call StatusTextLoeschen(lStatusId)
  
Exit Function
addDefaultBasiswert_Fehler:
  
  Call M_DB.CloseRecordset(recBasiswert)
  Call M_DB.CloseRecordset(recArchiv)
  Call FehlerAusloesen(30705, Err.Description, False, "M_Basiswert::addDefaultBasiswert")

End Function 'addDefaultBasiswert()

'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_Basiswert

Dim recBasiswert  As ADODB.Recordset
Dim sSql          As String
Dim oBasiswert    As C_Basiswert
Dim lStatusId     As Long

  On Error GoTo Basiswert_Lesen_Fehler
  If mcoBasiswertCache Is Nothing Then
    lStatusId = StatusTextAusgeben("Reading Basisvalues")
    
    Set mcoBasiswertCache = New CO_Basiswert
    sSql = "SELECT * FROM tabBasiswert"
    Set recBasiswert = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    
    While Not recBasiswert.EOF
      Set oBasiswert = New C_Basiswert
      oBasiswert.ID = recBasiswert.Fields("ID")
      oBasiswert.Bezeichnung = recBasiswert.Fields("Bezeichnung")
      Call StatusTextAusgeben("Reading Basisvalues " & oBasiswert.Bezeichnung, lStatusId)
      oBasiswert.Intervall = recBasiswert.Fields("Intervall")
      oBasiswert.IntEinheit = recBasiswert.Fields("IntEinheit")
      'Call RefArchiv_Lesen(oBasiswert)
      Set oBasiswert.coArchive = M_Archiv.coSuchen(lBasiswertID:=oBasiswert.ID)
      recBasiswert.MoveNext
      mcoBasiswertCache.Add oBasiswert
    Wend
    Call M_DB.CloseRecordset(recBasiswert)
  
  End If
    
  Set coLesen = mcoBasiswertCache
  StatusTextLoeschen (lStatusId)
  
Exit Function
Basiswert_Lesen_Fehler:
  
  Call M_DB.CloseRecordset(recBasiswert)
  If Not oBasiswert Is Nothing Then
    Call FehlerAusloesen(30700, "Basiswert #" & oBasiswert.ID, False, "M_Basiswert::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Basiswert::coLesen")
  End If

End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Public Function Lesen(ID As Integer) As C_Basiswert

Dim coBasiswert As CO_Basiswert
Dim oBasiswert  As C_Basiswert

  On Error GoTo Basiswert_Lesen_Fehler
  
  Set coBasiswert = coLesen
  For Each oBasiswert In coBasiswert.Items
    If oBasiswert.ID = ID Then
      Set Lesen = oBasiswert
      Exit For
    End If
  Next oBasiswert

'Dim recBasiswert  As ADODB.Recordset
'Dim sSQL          As String
'Dim oBasiswert    As C_Basiswert
'
'  On Error GoTo Basiswert_Lesen_Fehler
'
'  Set oBasiswert = New C_Basiswert
'
'  sSQL = "SELECT ID, Bezeichnung, Intervall, IntEinheit FROM tabBasiswert WHERE ID = " & ID & ";"
'  Set recBasiswert = M_DB.OpenRecordset(sSQL, adOpenForwardOnly, adLockReadOnly)
'
'  If Not recBasiswert.EOF Then
'    oBasiswert.ID = recBasiswert.Fields("ID")
'    oBasiswert.Bezeichnung = recBasiswert.Fields("Bezeichnung")
'    oBasiswert.Intervall = recBasiswert.Fields("Intervall")
'    oBasiswert.IntEinheit = recBasiswert.Fields("IntEinheit")
'
'    Set oBasiswert.coArchive = M_Archiv.coSuchen(lBasiswertID:=oBasiswert.ID)
'  End If
'
'  Call M_DB.CloseRecordset(recBasiswert)
'  Set Lesen = oBasiswert
  
Exit Function
Basiswert_Lesen_Fehler:
  
'  Call M_DB.CloseRecordset(recBasiswert)
  
  If Not oBasiswert Is Nothing Then
    Call FehlerAusloesen(30705, "Basiswert #" & oBasiswert.ID, False, "M_Basiswert::Lesen")
  Else
    Call FehlerAusloesen(30705, Err.Description, False, "M_Basiswert::Lesen")
  End If

End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coBasiswert As CO_Basiswert)

Dim recBasiswert  As ADODB.Recordset
Dim oBasiswert    As C_Basiswert
Dim sSql          As String
Dim lLoeschen     As Long

  On Error GoTo Basiswert_Speichern_Fehler

  sSql = "UPDATE tabBasiswert SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen
  
  sSql = "SELECT * FROM tabBasiswert"
  Set recBasiswert = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)

  For Each oBasiswert In coBasiswert.Items
    
    If recBasiswert.BOF And recBasiswert.EOF Then
      recBasiswert.AddNew
    Else
      recBasiswert.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recBasiswert.Find "ID = " & oBasiswert.ID, , adSearchForward
      If recBasiswert.EOF Then
        recBasiswert.AddNew
      Else
        'recBasiswert.Edit
        recBasiswert.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recBasiswert.Fields("Bezeichnung") = oBasiswert.Bezeichnung
    recBasiswert.Fields("Intervall") = oBasiswert.Intervall
    recBasiswert.Fields("IntEinheit") = oBasiswert.IntEinheit
    recBasiswert.Update
    'recBasiswert.Bookmark = recBasiswert.LastModified
    oBasiswert.ID = recBasiswert.Fields("ID")
    Call RefArchiv_Speichern(oBasiswert)

  Next oBasiswert
  
  recBasiswert.MoveFirst
  recBasiswert.Find "Loeschen <> 0", , adSearchForward
  While Not recBasiswert.EOF
    sSql = "DELETE FROM refArchiv WHERE Basiswert = " & recBasiswert.Fields("ID")
    M_DB.getConnection.Execute sSql
    recBasiswert.MoveNext
    recBasiswert.Find "Loeschen <> 0", , adSearchForward
    lLoeschen = lLoeschen - 1
  Wend
  Call BugAssert(lLoeschen = 0)
  sSql = "DELETE FROM tabBasiswert WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql

  Call M_DB.CloseRecordset(recBasiswert)
  
Exit Sub
Basiswert_Speichern_Fehler:
  
  Call M_DB.CloseRecordset(recBasiswert)
  
  Call ErrMessage("sSQL: " & sSql, "M_Basiswert::coSpeichern")
  If Not oBasiswert Is Nothing Then
    Call FehlerAusloesen(30703, "Basiswert " & oBasiswert.Bezeichnung, _
                        False, "M_Basiswert::coSpeichern")
  Else
    Call FehlerAusloesen(30703, Err.Description, _
                        False, "M_Basiswert::coSpeichern")
  End If

End Sub 'coSpeichern()

'---------------------------------------------------------------------------------------------------
Public Sub RefArchiv_Speichern(oBasiswert As C_Basiswert)

Dim recArchiv As ADODB.Recordset
Dim oArchiv   As C_Archiv
Dim sSql      As String

  On Error GoTo RefArchiv_Speichern_Fehler

  sSql = "DELETE FROM refArchiv WHERE Basiswert = " & oBasiswert.ID
  M_DB.getConnection.Execute sSql
  
  sSql = "SELECT * FROM refArchiv"
  Set recArchiv = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  For Each oArchiv In oBasiswert.coArchive.Items
    recArchiv.AddNew
    recArchiv.Fields("Basiswert") = oBasiswert.ID
    recArchiv.Fields("Archiv") = oArchiv.ID
    recArchiv.Update
  Next oArchiv
  
  Call M_DB.CloseRecordset(recArchiv)
  
Exit Sub
RefArchiv_Speichern_Fehler:

  Call M_DB.CloseRecordset(recArchiv)
  
  Call ErrMessage("sSQL: " & sSql, "M_Basiswert::RefArchiv_Speichern")
  If Not oArchiv Is Nothing Then
    Call FehlerAusloesen(30707, "Archiv " & oArchiv.ID, _
                        False, "M_Basiswert::RefArchiv_Speichern")
  Else
    Call FehlerAusloesen(30707, Err.Description, _
                        False, "M_Basiswert::RefArchiv_Speichern")
  End If

End Sub 'RefArchiv_Speichern()

'---------------------------------------------------------------------------------------------------
Public Sub RefArchiv_Lesen(oBasiswert As C_Basiswert)

Dim recArchiv  As ADODB.Recordset
Dim oArchiv    As C_Archiv
Dim sSql         As String

  On Error GoTo RefArchiv_Lesen_Fehler

  sSql = "SELECT Basiswert, Archiv, SYS, DPT, DPE, VStufe, Intervall, IntEinheit " & _
         "FROM refArchiv INNER JOIN tabArchiv ON refArchiv.Archiv = tabArchiv.ID " & _
         "WHERE Basiswert = " & oBasiswert.ID & " " & _
         "GROUP BY Basiswert, Archiv, SYS, DPT, DPE, VStufe, Intervall, IntEinheit;"
  Set recArchiv = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recArchiv.EOF
    Set oArchiv = New C_Archiv
    oArchiv.ID = recArchiv.Fields("Archiv")
    oArchiv.SYS = recArchiv.Fields("SYS")
    oArchiv.dpt = recArchiv.Fields("DPT")
    oArchiv.dpe = recArchiv.Fields("DPE")
    oArchiv.VStufe = recArchiv.Fields("VStufe")
    oArchiv.Intervall = recArchiv.Fields("Intervall")
    oArchiv.IntEinheit = recArchiv.Fields("IntEinheit")
    'oArchiv.coDPFkt = ...
    oBasiswert.coArchive.Add oArchiv
    recArchiv.MoveNext
  Wend
  
  Call M_DB.CloseRecordset(recArchiv)
  
Exit Sub
RefArchiv_Lesen_Fehler:

  Call M_DB.CloseRecordset(recArchiv)
  
  Call ErrMessage("sSQL: " & sSql, "M_Basiswert::RefArchiv_Speichern")
  If Not oArchiv Is Nothing Then
    Call FehlerAusloesen(30708, "Archiv " & oArchiv.ID, _
                        False, "M_Basiswert::RefArchiv_Speichern")
  Else
    Call FehlerAusloesen(30708, Err.Description, _
                        False, "M_Basiswert::RefArchiv_Speichern")
  End If

End Sub 'RefArchiv_Lesen()

Attribute VB_Name = "M_BtrProt"
'==================================================================================================
'M_BtrProt
'
'Oliver Seidel
'09.07.1999
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

Private Const REF_KOPF_FUSS_ZEILEN = "A11"
Private Const REF_BTR_PROT_TYPEN = "E1"
Private Const REF_BTR_DPT = "F1"
Private Const REF_BTR_DPL = "M1"

'--------------------------------------------------------------------------------------------------
Public Sub WerteEintragen(wsProt As Worksheet, oDP As C_DP, oDPRef As C_DPReferenz, lDatenAnz As Long)

Dim rgRef As Range
Dim rgDp  As Range

  On Error Resume Next
  
  wsProt.Cells(oDPRef.Zeile, 13).value = oDP.Von
  
  'Der gesamte Bereich ist Datenbereich
  On Error Resume Next
  
  Set rgDp = wsProt.Cells(oDPRef.Zeile, REF_BTR_WERTSPALTE)
  Call oDP.setRange(rgDp, 1, 0, 0)
  
  wsProt.Cells(oDPRef.Zeile, 5) = oDP.Kommentar
  wsProt.Cells(oDPRef.Zeile, 6) = oDP.Alias
  wsProt.Cells(oDPRef.Zeile, 7) = oDP.Format
  wsProt.Cells(oDPRef.Zeile, 8) = oDP.Einheit
        
  For Each rgRef In rgDp.DirectDependents
    rgRef.Style = rgDp.Style
    If oDP.AutoFormat > 0 Then
      rgRef.NumberFormat = rgDp.NumberFormat
    End If
  Next rgRef

End Sub


'--------------------------------------------------------------------------------------------------
Public Sub SeiteEinrichten(oProtokoll As C_Protokoll, wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim oTabBereich   As C_TabBereich
Dim oBereichKopf  As C_TabBereich
Dim oBereichDaten As C_TabBereich
Dim oBereichFuss   As C_TabBereich
Dim oBereichEnde  As C_TabBereich

Dim rgStart As Range
Dim rgEnde  As Range
Dim rgSuche As Range

Dim boSpalteAEingeblendet As Boolean

Dim rgDatenStart  As Range
Dim rgDatenEnde   As Range
Dim iDatenAnz     As Integer
Dim iDatenSpalte  As Integer
Dim dtZeit        As Date

Dim lwsProtID   As Long

Dim fStatus   As Single
Dim lStatusId As Long
Dim boErsterFehler As Boolean

  On Error GoTo M_BtrProt_SeiteEinrichten_Fehler

  ReDim audZeile(0)
  lStatusId = StatusTextAusgeben("")
  
'Call ZeitMessung(True)
'  Call M_Protokoll.KopfFusszeileEinrichten(oProtokoll)
'Call ZeitMessung(False, "M_BtrProt::KopfFusszeileEinrichten")
  
    lwsProtID = wsProt.index
    
    Call StatusTextAusgeben(wsProt.Name & " einrichten ", lStatusId)
    
'Call ZeitMessung(True)
      
    wsProt.EnableCalculation = False
    'boSpalteAEingeblendet = wsProt.Range("A1").EntireColumn.Hidden
    'wsProt.Range("A1").EntireRow.Hidden = false
    
    wsProt.Range("A1").EntireRow.hidden = True
    wsProt.Range("A1:N1").EntireColumn.hidden = True
      
'Call ZeitMessung(False, "M_BtrProt::SeiteEinrichten " + wsProt.Name)
  Call StatusTextLoeschen(lStatusId)
  
Exit Sub
M_BtrProt_SeiteEinrichten_Fehler:
  boErsterFehler = (Err.Number < ERR_BASIS)
  'Call StatusTextLoeschen(lStatusID)
  Call FehlerAusloesen(ERR_PROT_SEITE_EINRICHTEN, , boErsterFehler)
End Sub
Attribute VB_Name = "M_BtrVorlage"
'==================================================================================================
'M_BtrVorlage
'
'Oliver Seidel
'08.07.1999
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

'--------------------------------------------------------------------------------------------------
Public Sub DPEinfuegen()

Dim rgDp        As Range
Dim tabVorlage  As Worksheet
Dim iRefSpalte  As Integer

Dim coDP    As CO_DP
Dim oDP     As C_DP
Dim iDPL    As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long

Dim vwDPEinfuegen As V_DPEinfuegen

  On Error GoTo M_BtrVorlage_DPEinfuegen_Fehler
  
  Set vwDPEinfuegen = New V_DPEinfuegen
  vwDPEinfuegen.Modus = 3
  vwDPEinfuegen.Show

  If vwDPEinfuegen.ok Then
    
    iRefSpalte = ActiveWindow.ActiveCell.Column
    ActiveWindow.ActiveCell.EntireRow.Select
    
    Set coDP = vwDPEinfuegen.getDPL
    For iDPL = coDP.Count To 1 Step -1
      Selection.Insert
      Call setDp(Selection.Cells(1, 1), coDP.Item(iDPL))
      If iRefSpalte > 14 Then
        Selection.Cells(1, iRefSpalte).Formula = "=" & Selection.Cells(1, REF_BTR_WERTSPALTE).Address
      End If
    Next iDPL
    
    Selection.Cells(1, iRefSpalte).Select
    
  End If
  
  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing

Exit Sub
M_BtrVorlage_DPEinfuegen_Fehler:
  
  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_EINFUEGEN)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DPAendern()

Dim rgDp  As Range
Dim tabVorlage As Worksheet

Dim coDP  As CO_DP
Dim oDP   As C_DP

Dim vwDPEinfuegen As V_DPEinfuegen

  On Error GoTo M_BtrVorlage_DPAendern_Fehler
  
  Set vwDPEinfuegen = New V_DPEinfuegen
  Set rgDp = ActiveWindow.ActiveCell.EntireRow.Cells(1, 1)
  
  vwDPEinfuegen.Modus = 4
  Set oDP = getDp(rgDp)
  Call vwDPEinfuegen.setDp(oDP)
  vwDPEinfuegen.Show
  If vwDPEinfuegen.ok Then
    Set coDP = vwDPEinfuegen.getDPL
    For Each oDP In coDP.Items
      Call setDp(rgDp, oDP)
    Next oDP
    
    'Fehler, wenn noch keine Referenz auf den Wert vorhanden ist
    'Dafuer ist der Benutzer verantwortlich
    On Error Resume Next
    Set rgDp = Selection.Cells(1, REF_BTR_WERTSPALTE).DirectDependents
    If Err = 0 Then rgDp.Cells(1, 1).Select
  End If
  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing
  
Exit Sub
M_BtrVorlage_DPAendern_Fehler:
  
  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_AeNDERN)
End Sub

'--------------------------------------------------------------------------------------------------
'Ermittelt das Layout der Tabelle
Public Sub GetTabLayout(wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim oTabBereich As C_TabBereich
  
  Set oTabBereich = New C_TabBereich
  oTabBereich.Blatt = wsProt.index
  oTabBereich.Bereich = VAR_DATENBEREICH
  oTabBereich.Spalte = REF_BTR_WERTSPALTE
  coTabBereich.Add oTabBereich
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Function getDp(rgDp As Range) As C_DP

Dim oDP         As C_DP
Dim coDPFkt     As CO_DPFunktion

Dim sDP         As String
Dim sDPE        As String
Dim sDPTyp      As String
Dim sDPFkt      As String
Dim iArchivTyp  As Integer
Dim lOffset     As Long
Dim lIntervall  As Long
Dim iIntEinheit As Integer
  
Dim sDPStat As String

Dim i As Integer

  Set coDPFkt = M_DPFunktion.coLesen

  sDP = rgDp.value
  sDPTyp = rgDp.Offset(0, 2).value
  sDPFkt = rgDp.Offset(0, 3).value
  iArchivTyp = RangeToLng(rgDp.Offset(0, 9), ARCHIVTYP_ACSINGLE)
  
  'DPTyp und DPFunktion OK?
  If sDPTyp = "" Or sDPFkt = "" Then
    sDP = ""
  End If
  
  'OK?
  If Len(sDP) Then
    
    Set oDP = New C_DP
    With oDP
      .dp = sDP
      .dpt = sDPTyp
      .dpe = rgDp.Offset(0, 1).value
      .ArchivFkt = sDPFkt
      .Kommentar = rgDp.Offset(0, 4).value
      .Alias = rgDp.Offset(0, 5).value
      .Format = rgDp.Offset(0, 6).value
      .Einheit = rgDp.Offset(0, 7).value
      .AutoFormat = RangeToLng(rgDp.Offset(0, 8))
      .ArchivTyp = iArchivTyp
      '.ResultQuery = rgDP.Offset(0, 7).Value gibts hier nicht
      '.ResultFkt = rgDP.Offset(0, 8).Text gibts hier nicht
      .Offset = RangeToLng(rgDp.Offset(0, 11))
      
    End With
  End If
  Set getDp = oDP
  
End Function

'--------------------------------------------------------------------------------------------------
Public Sub setDp(rgDp As Range, oDP As C_DP)

  rgDp.value = oDP.dp
  rgDp.Offset(0, 1).value = oDP.dpe
  rgDp.Offset(0, 2).value = oDP.dpt
  rgDp.Offset(0, 3).value = oDP.ArchivFkt
  rgDp.Offset(0, 4).value = oDP.Kommentar
  rgDp.Offset(0, 5).value = oDP.Alias
  rgDp.Offset(0, 6).value = oDP.Format
  rgDp.Offset(0, 7).value = oDP.Einheit
  rgDp.Offset(0, 8).value = oDP.AutoFormat
  rgDp.Offset(0, 9).value = oDP.ArchivTyp
  'rgDp.Offset(0, 0).Value = oDp.Marker
  'rgDp.Offset(0, 0).Value = oDp.ResultQuery
  'rgDp.Offset(0, 0).Value = oDp.ResultFkt
  rgDp.Offset(0, 11).value = oDP.Offset

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub GetDPList(wsProt As Worksheet, coDP As CO_DP)

Dim rgDp        As Range
Dim oDP         As C_DP
Dim coDPFkt     As CO_DPFunktion

  Set coDPFkt = M_DPFunktion.coLesen

  'Zeilenweise die DP definition einlesen
  Set rgDp = wsProt.Cells(2, 1)
  While (Not rgDp Is Nothing)
  
    Set oDP = getDp(rgDp)
    If Not oDP Is Nothing Then
      'Wird in getDp nicht gepr|fffd|ft!
      If oDP.ArchivTyp = ARCHIVTYP_ACSINGLE Then
        If coDPFkt.FindItem(oDP.ArchivFkt) Is Nothing Then
          Set oDP = Nothing
        End If
      End If
    End If
    If Not oDP Is Nothing Then
      Set oDP.TabBereich = New C_TabBereich
      oDP.TabBereich.Bereich = VAR_DATENBEREICH
      oDP.TabBereich.Blatt = wsProt.index
      oDP.TabBereich.Spalte = 0
      oDP.TabBereich.Zeile = rgDp.Row
      
      coDP.Add oDP
    End If
  
    Set rgDp = MoveRange(rgDp, xlDown)
  Wend

End Sub 'GetDPList

'--------------------------------------------------------------------------------------------------
Public Sub updateDpInfos(wsProt As Worksheet)

Dim oComMan As ComManager
Dim rgDp    As Range
Dim sDP     As String

Dim v As Variant

  On Error GoTo updateDpInfosFehler
  
  Set oComMan = M_PVSS.getComMan
  Set rgDp = MoveRange(wsProt.Cells(1, 1), xlDown)
  While (Not rgDp Is Nothing)
    
    sDP = rgDp.value
    'DPTyp und DPFunktion OK?
    If rgDp.Offset(0, 2).value = "" Or _
       rgDp.Offset(0, 3).value = "" Then
      sDP = ""
    End If
    
    'OK?
    If Len(sDP) Then
      'Bei AC Typen schauen wir auf das .value
      If rgDp.Offset(0, 9).value = ARCHIVTYP_ACSINGLE Then
        'DPE vorhanden?
        If rgDp.Offset(0, 1).value <> "" Then
          sDP = sDP & "." & rgDp.Offset(0, 1).value & ".value"
        Else
          sDP = sDP & ".value"
        End If
      Else
        sDP = sDP & "." & rgDp.Offset(0, 1).value
      End If
      v = oComMan.dpGetDescription(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 4).value = CStr(v)
      v = oComMan.dpGetAlias(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 5).value = CStr(v)
      v = oComMan.dpGetFormat(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 6).value = CStr(v)
      v = oComMan.dpGetUnit(sDP)
      If Not IsError(v) Then rgDp.Offset(0, 7).value = CStr(v)
    End If
  
    Set rgDp = MoveRange(rgDp, xlDown)
  Wend

Exit Sub
updateDpInfosFehler:
  Stop
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Update_3_0()

Dim wbProtVorlage As Worksheet

  'Schleife ueber alle Blaetter
  For Each wbProtVorlage In ActiveWorkbook.Worksheets
    If wbProtVorlage.Range("A1") = BEZ_BTR_PROTOKOLL Then
      
      'Neue Spalte B einfuegen und "DPE" beschriften
      wbProtVorlage.Columns(2).Insert
      wbProtVorlage.Columns(9).Insert
      
      'Spalten Beschriften
      wbProtVorlage.Range("B1").value = "DPE"
      wbProtVorlage.Range("C1").value = "DPT"
      wbProtVorlage.Range("D1").value = "Function"
      wbProtVorlage.Range("E1").value = "Comment"
      wbProtVorlage.Range("F1").value = "Alias"
      wbProtVorlage.Range("G1").value = "Offset"
      wbProtVorlage.Range("H1").value = "Offset Time"
      
    End If
  Next wbProtVorlage
End Sub
Attribute VB_Name = "M_CostCenter"
'===================================================================================================
'M_CostCenter
'Wolfram Klebel 2.7.09
'  Verwaltung der CostCenter Eintraege
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Private mcoCostCenter As CO_CostCenter


Public Sub Invalidate()
  If Not mcoCostCenter Is Nothing Then
    Set mcoCostCenter = Nothing
  End If
  
End Sub
'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwCostCenter As V_CostCenter
Dim oCostCenter As CO_CostCenter
Dim oTariffsets As CO_Tariffset

  On Error GoTo M_CostCenter_Edit_Fehler
  
  Set vwCostCenter = New V_CostCenter
  Set oCostCenter = M_CostCenter.coLesen
  Set oTariffsets = M_Tariffset.coLesen
  Set vwCostCenter.CostCenter = oCostCenter
  Set vwCostCenter.Tariffset = oTariffsets
  vwCostCenter.Show
  
  If vwCostCenter.ok Then
    'Sieht lustig aus, aber auf Collection wird direkt referenziert
    'Aenderungen schlagen also automatisch durch!
    Call M_CostCenter.coSpeichern(oCostCenter)
    
    'Vorsicht Falle!
    'Auch wenn man es hier nicht sieht, es wird indirekt mcoCostCenter geaendert! UND
    'Die Editierten CostCentere kennen zwar ihre Archive (DPE aus AC Parametrierung, inkl VStufe)
    'aber nicht die dort enthaltenen Stat. Funktionen (AVG_WT0).
    'Nun koennte man diese Infos an dieser Stelle erneut aus der DB lesen, einfacher ist es
    'jedoch, den Cache wegzuschmeissen. Der Performance- Verlust ist selbst bei Dongshen irrelevant.
    Set mcoCostCenter = Nothing
    
  End If
  'ToDo: Falls coBasiswert gepuffert wird, muss nach einem Abbruch der
  'Bearbeitung der Puffer geloescht werden!
  'Stimmt, ich sollte mal das Datum zu meinen Kommentaren aufnehmen
  Set mcoCostCenter = Nothing
    
  Unload vwCostCenter
  Set vwCostCenter = Nothing

Exit Sub
M_CostCenter_Edit_Fehler:
  
  If Not vwCostCenter Is Nothing Then
    Unload vwCostCenter
    Set vwCostCenter = Nothing
  End If
  Call FehlerAusloesen(30702, , False, "M_CostCenter::coEdit")
  
End Sub 'coEdit()


'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_CostCenter

  If mcoCostCenter Is Nothing Then
    Set mcoCostCenter = coFilter("")
  End If
  
  Set coLesen = mcoCostCenter

End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
' wie coLesen, aber mit Filter auf Tariffset.Medium
' vorerst ohne Filterfunktion, da JOIN |fffd|ber 4 Tabellen erforderlich w|fffd|re WOKL 25.11.10
Public Function coFilter(pMedium As String) As CO_CostCenter

Dim recCostCenter  As ADODB.Recordset
Dim sSql          As String
Dim oCostCenter    As C_CostCenter
Dim coCostCenter   As CO_CostCenter
Dim coTariffset    As CO_Tariffset
Dim lStatusId     As Long


  On Error GoTo CostCenter_Lesen_Fehler
   
  If mcoCostCenter Is Nothing Or Not pMedium = "" Then
    lStatusId = StatusTextAusgeben("Reading Basisvalues")
    
    Set coCostCenter = New CO_CostCenter
    
    sSql = "SELECT * FROM tabCostCenter"
           
'    If (Not pUnit = "") Then
'      sSql = sSql + " AND tabTariffset.Unit = '" & pMedium & "'"
'    End If
           
    Set recCostCenter = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    
    While Not recCostCenter.EOF
      Set oCostCenter = New C_CostCenter
      
      oCostCenter.ID = recCostCenter.Fields("ID")
      oCostCenter.Bezeichnung = recCostCenter.Fields("Bezeichnung")
      Set oCostCenter.coTariffsets = M_Tariffset.coFilterCcId(oCostCenter.ID)
'      oCostCenter.Tariffset = recCostCenter.Fields("Name")
'      oCostCenter.Tariffset_ID = recCostCenter.Fields("tabTariffset.ID")
      
      Call StatusTextAusgeben("Reading Basisvalues " & oCostCenter.Bezeichnung, lStatusId)
      recCostCenter.MoveNext
      
      coCostCenter.Add oCostCenter
    Wend
    Call M_DB.CloseRecordset(recCostCenter)

  Else
    coCostCenter = mcoCostCenter
  End If
    
  Set coFilter = coCostCenter
  StatusTextLoeschen (lStatusId)
  
Exit Function
CostCenter_Lesen_Fehler:
  MsgBox ("Err " & Err.Description)
  Call M_DB.CloseRecordset(recCostCenter)
  If Not oCostCenter Is Nothing Then
    Call FehlerAusloesen(30700, "CostCenter #" & oCostCenter.Bezeichnung, False, "M_CostCenter::coFilter")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_CostCenter::coFilter")
  End If

End Function 'coFilter()

'---------------------------------------------------------------------------------------------------
' wie coLesen, aber mit Filter auf Tariffset.Unit
Public Function readUnit(CostCenter As String) As String

Dim recCostCenter  As ADODB.Recordset
Dim sSql          As String

  readUnit = ""
  On Error GoTo ReadUnit_Lesen_Fehler
      
  sSql = "SELECT * FROM tabCostCenter, tabTariffset WHERE " & _
         "tabCostCenter.Tariffset = tabTariffset.ID AND " & _
         "tabCostCenter.Bezeichnung = '" & CostCenter & "'"
         
  Set recCostCenter = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  If Not recCostCenter.EOF Then
    Let readUnit = recCostCenter.Fields("Unit")
  End If
  Call M_DB.CloseRecordset(recCostCenter)
  
Exit Function

ReadUnit_Lesen_Fehler:
  ' MsgBox ("Err " & Err.Description)
  Call M_DB.CloseRecordset(recCostCenter)
  Call FehlerAusloesen(30700, "CostCenter #" & CostCenter, False, "M_CostCenter::readUnit")

End Function
'---------------------------------------------------------------------------------------------------
' wie coLesen, aber mit Filter auf Tariffset Name
Public Function readTariffset(Tariffset As String) As String

Dim recCostCenter  As ADODB.Recordset
Dim sSql           As String

  readTariffset = ""
  On Error GoTo ReadUnit_Lesen_Fehler
      
  sSql = "SELECT * FROM tabCostCenter,tabTariffset,refTariffset WHERE " & _
         "refTariffset.Tariffset = tabTariffset.ID AND refTariffset.CostCenter = tabCostCenter.ID AND " & _
         "tabTariffset.Name = '" & Tariffset & "'"
         
  Set recCostCenter = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  If Not recCostCenter.EOF Then
    Let readTariffset = recCostCenter.Fields("Bezeichnung")
  End If
  Call M_DB.CloseRecordset(recCostCenter)
  
Exit Function

ReadUnit_Lesen_Fehler:
  ' MsgBox ("Err " & Err.Description)
  Call M_DB.CloseRecordset(recCostCenter)
  Call FehlerAusloesen(30700, "CostCenter #" & Tariffset, False, "M_CostCenter::readTariffset")

End Function

'---------------------------------------------------------------------------------------------------
' wird die noch verwendet? WOKL 2.7.09
Public Function Lesen(ID As Integer) As C_CostCenter

Dim coCostCenter As CO_CostCenter
Dim oCostCenter  As C_CostCenter

  ' On Error GoTo CostCenter_Lesen_Fehler
  GoTo CostCenter_Lesen_Fehler
  
  Set coCostCenter = coLesen
  For Each oCostCenter In coCostCenter.Items
    If oCostCenter.ID = ID Then
      Set Lesen = oCostCenter
      Exit For
    End If
  Next oCostCenter
  
Exit Function
CostCenter_Lesen_Fehler:
  
  If Not oCostCenter Is Nothing Then
    Call FehlerAusloesen(30705, "CostCenter #" & oCostCenter.ID, False, "M_CostCenter::Lesen")
  Else
    Call FehlerAusloesen(30705, Err.Description, False, "M_CostCenter::Lesen")
  End If

End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coCostCenter As CO_CostCenter)

Dim recCostCenter  As ADODB.Recordset
Dim oCostCenter    As C_CostCenter
Dim sSql          As String
Dim lLoeschen     As Long
Dim lLoeschen2    As Long

  On Error GoTo CostCenter_Speichern_Fehler
  
  sSql = "UPDATE tabCostCenter SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen
  
  sSql = "SELECT * FROM tabCostCenter"
  Set recCostCenter = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)

  For Each oCostCenter In coCostCenter.Items
    
    If recCostCenter.BOF And recCostCenter.EOF Then
      recCostCenter.AddNew
    Else
      recCostCenter.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recCostCenter.Find "ID = " & oCostCenter.ID, , adSearchForward
      If recCostCenter.EOF Then
        recCostCenter.AddNew
      Else
        recCostCenter.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recCostCenter.Fields("Bezeichnung") = oCostCenter.Bezeichnung
    ' recCostCenter.Fields("Tariffset") = oCostCenter.coTariffsets.
    recCostCenter.Update
    
    oCostCenter.ID = recCostCenter.Fields("ID")
    
    Call RefCostCenter_Speichern(oCostCenter)

  Next oCostCenter
  
  sSql = "DELETE FROM tabCostCenter WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql, lLoeschen2
  Call BugAssert(lLoeschen = lLoeschen2)

  Call M_DB.CloseRecordset(recCostCenter)
  
Exit Sub
CostCenter_Speichern_Fehler:
  
  Call M_DB.CloseRecordset(recCostCenter)
  
  Call ErrMessage("sSQL: " & sSql, "M_CostCenter::coSpeichern")
  If Not oCostCenter Is Nothing Then
    Call FehlerAusloesen(30703, "CostCenter " & oCostCenter.Bezeichnung, _
                        False, "M_CostCenter::coSpeichern")
  Else
    Call FehlerAusloesen(30703, Err.Description, _
                        False, "M_CostCenter::coSpeichern")
  End If

End Sub 'coSpeichern()


Public Sub RefCostCenter_Speichern(oCostCenter As C_CostCenter)

Dim recRefEntry  As ADODB.Recordset
Dim sSql        As String
Dim oTs     As C_Tariffset
Dim hasDefault  As Boolean
Dim moDBConn  As ADODB.Connection

  On Error GoTo RefCostCenter_Error

  ' alles neu macht der Mai ...
  sSql = "DELETE FROM refTariffset WHERE CostCenter = " & oCostCenter.ID
  Set moDBConn = M_DB.getConnection
  moDBConn.Execute sSql
  
  sSql = "SELECT * FROM refTariffset"
  Set recRefEntry = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  hasDefault = False
  For Each oTs In oCostCenter.coTariffsets.Items
    recRefEntry.AddNew
    
    recRefEntry.Fields("CostCenter") = oCostCenter.ID
    recRefEntry.Fields("Tariffset") = oTs.ID
  Next oTs
  
  recRefEntry.Update   ' Commit
  Call M_DB.CloseRecordset(recRefEntry)
  
Exit Sub
RefCostCenter_Error:

  Call M_DB.CloseRecordset(recRefEntry)
  Call ErrMessage("sSQL: " & sSql, "M_Tariffset::RefTariffsetEntry_Speichern")
  If Not oTs Is Nothing Then
    Call FehlerAusloesen(30707, "Tariffset " & oTs.ID, _
                        False, "M_Tariffset::RefCostCenter_Speichern")
  Else
    Call FehlerAusloesen(30707, Err.Description, _
                        False, "M_Tariffset::RefCostCenter_Speichern")
  End If

End Sub

Attribute VB_Name = "M_DB"
'===================================================================================================
'M_DB
'Oliver Seidel 31.07.2000
'  Schnittstelle zur Datenbank ueber ReportDB.
'  Implementation einiger allgemeiner Abfragen, die nicht den peristenten Objekten zugeordnet sind.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module
 
Const DB_DATEI = "Report.mdb"

Private Const MY_MODULE  As String = "M_DB"
Private moDBConn  As ADODB.Connection

'---------------------------------------------------------------------------------------------------
Public Function OpenRecordset(sSql As String, iCoursorTyp As Integer, iLockType As Integer)
  Set OpenRecordset = New ADODB.Recordset
  Set OpenRecordset.ActiveConnection = getConnection
  OpenRecordset.CursorType = iCoursorTyp
  OpenRecordset.LockType = iLockType
  OpenRecordset.Open sSql
  Call BugAssert(OpenRecordset.State = adStateOpen, "Nicht geoeffnet: " & sSql, "getRecordset")
End Function

'---------------------------------------------------------------------------------------------------
Public Sub CloseRecordset(recToClose As Recordset)
  If Not recToClose Is Nothing Then
    If Not recToClose.State = adStateClosed Then
      recToClose.Close
    End If
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Function getConnection() As ADODB.Connection

Dim oDBRec  As ADODB.Recordset
Dim sSql    As String

  If moDBConn Is Nothing Then
    Set moDBConn = New ADODB.Connection
  End If

  If moDBConn.State = adStateClosed Then
    'moDBConn.OpenSchema adSchemaTables
    On Error Resume Next
    moDBConn.Provider = M_Optionen.getDBProvider
    moDBConn.Open M_Tools.ProjektPfad & "\" & DB_DATEI, "Admin"
    If Err Then
      Err.Clear
      moDBConn.Provider = "Microsoft.Jet.OLEDB.4.0"
      moDBConn.Open M_Tools.ProjektPfad & "\" & DB_DATEI, "Admin"
      If Err Then
        On Error GoTo 0
        Call FehlerAusloesen(ERR_INTERN_DB, M_Tools.ProjektPfad & "\" & DB_DATEI, True, "ReportDB")
      End If
      Call M_Optionen.setDBProvider(moDBConn.Provider)
    End If
    Call VersionPruefen(moDBConn)
  End If
  
  If moDBConn.State <> adStateOpen Then
    Call FehlerAusloesen(ERR_INTERN_DB, M_Tools.ProjektPfad & "\" & DB_DATEI, True, "ReportDB")
  End If
  Set getConnection = moDBConn
  
End Function
'---------------------------------------------------------------------------------------------------
' IM 102174 WOKL 16.3.11: System information is available just after ComMan.Init
' is done at every start for to be sure (+esperrer)
Public Sub ReworkDbUpdate()
  Dim sSql      As String
  Dim mySystem  As Variant
  Dim oComMan   As reportExt
  Dim recMail   As ADODB.Recordset
  
  On Error Resume Next
  If (Not moDBConn Is Nothing) Then
    Set oComMan = M_PVSS.getReportExt
    Call oComMan.getSystemName(-1, mySystem)   ' default system
    
    sSql = "update tabArchiv set SYS = '" & mySystem & "' WHERE SYS='@UpdSys'"
    Set recMail = moDBConn.Execute(sSql)
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
' Aufgerufen von M_DB.getConnection
Private Sub VersionPruefen(oDBConn As ADODB.Connection)

Dim recProjekt  As ADODB.Recordset
Dim recMail     As ADODB.Recordset
Dim oComMan     As reportExt
Dim sSql        As String
Dim sVersion    As String
Dim iVerHaupt   As Integer
Dim iVerNeben   As Integer
Dim iVerSub     As Integer
Dim s           As String
Dim mySystem    As Variant

  On Error GoTo M_DB_VersionPruefen_Fehler

  sSql = "select * from tabProjekt"
  Set recProjekt = New ADODB.Recordset
  Set recProjekt.ActiveConnection = oDBConn
  recProjekt.CursorType = adOpenDynamic
  recProjekt.LockType = adLockOptimistic
  recProjekt.Open sSql
  
  If Not recProjekt.EOF Then
    sVersion = recProjekt.Fields("Version")
  Else
    Call M_DB.CloseRecordset(recProjekt)
    Call FehlerAusloesen(ERR_INTERN_DB, "Version '???'", True, "VersionPruefen")
  End If
  
  'Bei gleicher Version ist nichts zu tun...
  If sVersion = ProjektVersion Then
    Call M_DB.CloseRecordset(recProjekt)
    Exit Sub
  End If
  
  'Erweiterung fuer kommende Versionen
  s = ElementN(sVersion, 1, ".")
  iVerHaupt = CInt(Right(s, Len(s) - 1))
  iVerNeben = CInt(ElementN(sVersion, 2, "."))
  iVerSub = CInt(ElementN(sVersion, 3, "."))

  'Weitere Verzweigung nach den Versionen und Bearbeitung in den Update-Funktionen
  If iVerHaupt <> 3 Then
    'Sollange wir keine Version 4.x.x haben: Fehler ausloesen
    Call M_DB.CloseRecordset(recProjekt)
    Call FehlerAusloesen(ERR_INTERN_DB, "Version '" & sVersion & "'", True, "VersionPruefen")
  End If

  'Update auf Version 3.1.x
  If iVerNeben = 0 Then
    'Tabelle fuer EMail Verteiler einrichten
    On Error Resume Next
    Set recMail = oDBConn.Execute("CREATE TABLE tabMailVerteiler(" & _
                                  "ID AUTOINCREMENT CONSTRAINT maID PRIMARY KEY, " & _
                                  "Bezeichnung TEXT(255)," & _
                                  "An TEXT(255), " & _
                                  "Betreff TEXT(255), " & _
                                  "Loeschen BIT" & _
                                  ")")
    If Err Then
      'Tabelle existiert (warum auch immer) bereits
      If Err <> -2147217900 Then
        Call MsgBox("Kann die Tabelle tabMailVerteiler nicht anlegen", vbCritical + vbOKOnly, GetResText(20104))
        Stop
      End If
    End If
    Err.Clear
    On Error GoTo M_DB_VersionPruefen_Fehler
    Call addFieldInDB(oDBConn, "tabZeitplan", "MailVerteiler", "INTEGER")
    Call addFieldInDB(oDBConn, "tabZeitplan", "HTML", "INTEGER")
    Call addFieldInDB(oDBConn, "tabZeitplan", "Zeitbereich", "INTEGER")
    Call addFieldInDB(oDBConn, "tabSchnellAnwahl", "Zeitbereich", "INTEGER")
    Call addFieldInDB(oDBConn, "tabOptionen", "HTMLPath", "TEXT")
    
    iVerNeben = 1
    recProjekt.Fields("Version") = "v3.1.0"
    recProjekt.Update
  End If
  
  If iVerNeben = 1 Then
    'Update fuer 3.2
    recProjekt.Close
    Call M_DB.addFieldInDB(oDBConn, "tabProjekt", "Passwort", "TEXT")
    recProjekt.CursorType = adOpenDynamic
    recProjekt.LockType = adLockOptimistic
    recProjekt.Open sSql
    
    iVerNeben = 2
    recProjekt.Fields("Version") = "v3.2.0"
    recProjekt.Fields("Passwort") = "erAdmin"
    recProjekt.Update
  End If

  If iVerNeben = 2 Then
    'Update fuer 3.3
    Call M_DB.addFieldInDB(oDBConn, "tabOptionen", "wbPasswort", "TEXT")
    
    iVerNeben = 3
    recProjekt.Fields("Version") = "v3.3.0"
    recProjekt.Update
  End If
  
  ' IM 79802 WOKL 13.9.07
  If iVerNeben = 3 Then
    'Update fuer 3.4
    Call M_DB.addFieldInDB(oDBConn, "tabArchiv", "SYS", "TEXT(200) NOT NULL")
    
    iVerNeben = 4
    iVerSub = 0
    recProjekt.Fields("Version") = "v3.4.0"
    recProjekt.Update
    
    ' Spalte NOT NULL muss wohl auch gleich befuellt werden fuer existierende Projekte
    'Set oComMan = M_PVSS.getReportExt
    'Call oComMan.getSystemName(-1, mySystem)   ' default system
    mySystem = "@UpdSys"  ' IM 102174 WOKL 16.3.11: ComMan not yet initialized!!
    sSql = "update tabArchiv set SYS = '" & mySystem & "'"
    Set recMail = oDBConn.Execute(sSql)
    If Err Then
      'Spalte existiert (warum auch immer) bereits
      If Err <> -2147217900 Then
        Call MsgBox("Kann die Spalte tabArchiv.SYS nicht anlegen", vbCritical + vbOKOnly, GetResText(20104))
        Stop
      End If
    End If
    Err.Clear

  End If
  
  'Revisionsnummer (3.4.2) auch in Version eintragen
  If iVerNeben = 4 Then
  
    If iVerSub <= 1 Then  ' 3.4.1 || tabStatusBit.BitMuster
      sSql = "ALTER TABLE tabStatusBit ALTER COLUMN BitMuster Text(64)"
      Set recMail = oDBConn.Execute(sSql)
      sSql = "UPDATE tabStatusBit SET BitMuster = '????????????????????????????????'&BitMuster"
      Set recMail = oDBConn.Execute(sSql)
      If Err Then
        Call MsgBox("Kann die Spalte tabStatusBit.BitMuster nicht modifizieren", _
                    vbCritical + vbOKOnly, GetResText(20104))
      End If
      Err.Clear
    End If
    
    iVerNeben = 5
    iVerSub = 0
    
  End If
  
  If iVerNeben = 5 Then
    Call UpdateDBToVersion35(oDBConn, recMail)
    
    recProjekt.Update
    iVerNeben = 6
  End If
  
  If iVerNeben = 8 And iVerSub = 0 Then ' DB von PVSS 3.8.2 IM 102541
    iVerNeben = 6
  End If
  
  If iVerNeben = 6 Then
    'Update fuer 3.6
    Call UpdateDBToVersion36(oDBConn, recMail)
     
    recProjekt.Update
    iVerSub = 999
    iVerNeben = 7
  End If
  
  If iVerNeben = 7 Then
    'Update fuer letzte Version
    Call UpdateDBToVersion37(oDBConn, recMail, iVerSub)
    iVerNeben = 8
    iVerSub = 1
  End If
  
  If iVerNeben = 8 And iVerSub > 0 And iVerSub < 3 Then   ' IM 102541 WOKL sheet offset: nothing to do, just increment
       
    Call CheckDBForRDBFunctions           ' ER 3.8.2: RDB Compression: DIFF_ABS
    iVerSub = 3
  End If
    
  If iVerNeben = 8 And iVerSub = 3 Then   ' IM 115373 WOKL changes from ETM D / India
       
    Call UpdateDBToICS(oDBConn, recMail, iVerSub)              ' ICS India and power manager changes (just in DB to not fork too far)
    iVerSub = 4
  End If
  
  If iVerNeben = 8 And iVerSub = 4 Then   ' IM 117977 WOKL international styles / russian language
       
    Set recMail = oDBConn.Execute("UPDATE tabStatusBit SET Bezeichnung = 'Valid' WHERE ID = 1")
    Set recMail = oDBConn.Execute("UPDATE tabStatusBit SET Bezeichnung = 'DefaultValue' WHERE ID = 9")
    Set recMail = oDBConn.Execute("UPDATE tabStatusBit SET Bezeichnung = 'Invalid' WHERE ID = 10")
    Set recMail = oDBConn.Execute("UPDATE tabStatusBit SET Bezeichnung = 'Changed' WHERE ID = 11")
    iVerSub = 5
  End If
  
  If iVerNeben = 8 And iVerSub = 5 Then   ' IM 118941 WOKL: sequel from ICS update
       
    Set recMail = oDBConn.Execute("UPDATE tabZeitplan SET FilePath = '' where FilePath is NULL")
    iVerSub = 6
    
    '-------------- ...to be continued
    recProjekt.Fields("Version") = ProjektVersion
    recProjekt.Update
    
    Call M_DB.CloseRecordset(recProjekt)
    
    Exit Sub
  End If

  Call M_DB.CloseRecordset(recProjekt)
  Call FehlerAusloesen(ERR_INTERN_DB, "Version '" & sVersion & "'", True, "VersionPruefen")

Exit Sub
M_DB_VersionPruefen_Fehler:
  Call FehlerAusloesen(ERR_INTERN_DB, "Version '" & sVersion & "'", False, "VersionPruefen")
End Sub

'---------------------------------------------------------------------------------------------------
' Erweitert die Datenbank um
' 0 - Media-Management (Name / Unit)
' 1 - tariffset - entry
' 2 - refTariffset / CostCenter
' Aufgerufen von M_DB.VersionPruefen
' IM 101311 WOKL, Nov 2010
Public Sub UpdateDBToICS(oDBConn As ADODB.Connection, recMail As ADODB.Recordset, iVerSub As Integer)
  
  On Error GoTo UpdateDBToICS_Fehler

  '--- IM 115373
  If iVerSub = 3 Then 'Placeholder f|fffd|r WK - not used
  
     'Anpassung f|fffd|r Bonusintervall
     Call M_DB.addFieldInDB(oDBConn, "tabProtTyp", "BonusIntervall", "BIT")
     Set recMail = oDBConn.Execute("UPDATE tabProtTyp SET BonusIntervall = 0")
     
     Call M_DB.addFieldInDB(oDBConn, "tabZeitplan", "FilePath", "TEXT") 'ICSGEAD
     Set recMail = oDBConn.Execute("UPDATE tabZeitplan SET FilePath = ''")
     iVerSub = 4
   End If

Exit Sub
UpdateDBToICS_Fehler:
  
  If (oDBConn.Errors.Count > 0) Then
    Call FehlerAusloesen(30701, oDBConn.Errors.Item(0).Description, False, "M_DB::UpdateDBToICS")
  Else
    Call FehlerAusloesen(30701, Err.Description, False, "M_DB::UpdateDBToICS")
  End If
End Sub
'---------------------------------------------------------------------------------------------------
' This function adds conditional a new function needed for rdb compression: diffAbs

Private Sub CheckDBForRDBFunctions()

Dim sSql          As String
Dim rsTabFunction As ADODB.Recordset

  sSql = "SELECT * FROM tabFunktion WHERE DPE = 'DIFF_ABS'"
  Set rsTabFunction = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  If rsTabFunction.EOF Then
    rsTabFunction.AddNew
    rsTabFunction.Fields("Bezeichnung") = VAR_DIFF_ABS
    rsTabFunction.Fields("DPE") = "DIFF_ABS"
    rsTabFunction.Update
  End If
  Call M_DB.CloseRecordset(rsTabFunction)
      
End Sub


'---------------------------------------------------------------------------------------------------
' Erweitert die Datenbank um
' 0 - Media-Management (Name / Unit)
' 1 - tariffset - entry
' 2 - refTariffset / CostCenter
' Aufgerufen von M_DB.VersionPruefen
' IM 101311 WOKL, Nov 2010
Public Sub UpdateDBToVersion37(oDBConn As ADODB.Connection, recMail As ADODB.Recordset, iVerSub As Integer)
  Dim sSql As String
  Dim txtUnit As String
  Dim StrArray() As String
  Dim i As Integer
  Dim rs  As ADODB.Recordset
  Dim txtUnit1(), txtUnit2() As String
  Dim idUnit() As Integer
  Dim mediaId As Integer
  Dim mediaName As String
  Dim ccID() As String
  Dim tsID() As String
  Dim nullDate As Date
  Dim endDate As Date
  
  On Error GoTo UpdateDBToVersion37_Fehler

  If iVerSub = 999 Then
    Set recMail = oDBConn.Execute("CREATE TABLE tabMedia(" & _
                                  "ID AUTOINCREMENT CONSTRAINT mediaID PRIMARY KEY, " & _
                                  "Name TEXT(255) CONSTRAINT nameID UNIQUE," & _
                                  "Unit TEXT(255), " & _
                                  "Loeschen BIT" & _
                                  ")")
    If Err Then
      'Tabelle existiert (warum auch immer) bereits
      If Err <> -2147217900 Then
        Call MsgBox("Cannot create table tabMedia", vbCritical + vbOKOnly, GetResText(20104))
        Stop
      End If
    End If
    Err.Clear
    iVerSub = 0
  End If
  
  If iVerSub = 0 Then  ' expand Tariffsets
    ' create column 'currency'
    Call M_DB.addFieldInDB(oDBConn, "tabTariffset", "CurrName", "TEXT")
    
    Set recMail = oDBConn.Execute("ALTER TABLE tabTariffset ADD  " & _
      "Medium INTEGER, CONSTRAINT mdIDl FOREIGN KEY (Medium) REFERENCES tabMedia(ID));")
    
    ' fetch all 'unit' from tariffsets
    sSql = "SELECT Unit FROM tabTariffset;"
    Set rs = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    i = 0
    While Not rs.EOF
      i = i + 1
      ReDim Preserve txtUnit1(i)
      ReDim Preserve txtUnit2(i)
      ReDim Preserve idUnit(i)
      txtUnit = rs.Fields("Unit")
      StrArray = Split(txtUnit, "/") ' EUR / kWH
      txtUnit1(i) = StrArray(0)
      txtUnit2(i) = StrArray(1)
      rs.MoveNext
    Wend
    Call M_DB.CloseRecordset(rs)

    If (i > 0) Then
      ' enter all 'unit(2)' into (new) table media (if not exist)
      On Error Resume Next
      For i = 1 To UBound(txtUnit2)
        Set recMail = oDBConn.Execute("INSERT INTO tabMedia (Name, Unit) " & _
                                      "VALUES ('" & txtUnit2(i) & "','" & txtUnit2(i) & "');")
      Next i
      On Error GoTo UpdateDBToVersion37_Fehler

      ' fetch media IDs
      sSql = "SELECT ID, Name FROM tabMedia;"
      Set rs = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
      While Not rs.EOF
        mediaId = rs.Fields("ID")
        mediaName = rs.Fields("Name")
        For i = 1 To UBound(txtUnit2)
          If (txtUnit2(i) = mediaName) Then
            idUnit(i) = mediaId
          End If
        Next i
        rs.MoveNext
      Wend
      Call M_DB.CloseRecordset(rs)
  
      ' enter all 'unit(1)' into currency
      ' link according media entries to tariffset.media
      sSql = "SELECT * FROM tabTariffset;"
      Set rs = M_DB.OpenRecordset(sSql, adOpenKeyset, adLockOptimistic)
      i = 0
      While Not rs.EOF
        i = i + 1
        rs.Fields("CurrName") = txtUnit1(i) ' currency
        rs.Fields("Medium") = idUnit(i)    '  ref to Media tab
        rs.MoveNext
      Wend
      Call M_DB.CloseRecordset(rs)
    End If  ' no tariffset found

    ' delete column unit
    Set recMail = oDBConn.Execute("ALTER TABLE tabTariffset DROP COLUMN Unit")
      
    iVerSub = 1
  End If
  
  If (iVerSub = 1) Then
    ' Set recMail = oDBConn.Execute("ALTER TABLE tabTariffsetLine DROP CONSTRAINT ccIDl") ' kann mal drin bleiben
    
    Set recMail = oDBConn.Execute("CREATE TABLE tabTariffsetEntry(" & _
                                  "ID AUTOINCREMENT CONSTRAINT tseID PRIMARY KEY, " & _
                                  "Tariffset INTEGER, CONSTRAINT tsID FOREIGN KEY (Tariffset) REFERENCES tabTariffset(ID) ON DELETE CASCADE, " & _
                                  "Name TEXT(255)," & _
                                  "ValidFrom DATE, " & _
                                  "ValidUntil DATE, " & _
                                  "IsDefault BIT, " & _
                                  "Loeschen BIT" & _
                                  ")")
    If Err Then
      'Tabelle existiert (warum auch immer) bereits
      If Err <> -2147217900 Then
        Call MsgBox("cannot create table tabTariffsetEntry", vbCritical + vbOKOnly, GetResText(20104))
        Stop
      End If
    End If
    Err.Clear

    Set recMail = oDBConn.Execute("ALTER TABLE tabTariffsetLine ADD " & _
      "TariffsetEntry INTEGER")
    
    nullDate = DateSerial(1970, 1, 1)  ' #1/1/1970#
    endDate = DateSerial(2099, 12, 31) '#12/31/2099#
    Set recMail = oDBConn.Execute("INSERT INTO tabTariffsetEntry " & _
      "(Name, ValidFrom, ValidUntil, IsDefault, Tariffset) " & _
      "select 'Default', '" & Str$(nullDate) & "', '" & Str$(endDate) & "', '-1', ID from tabTariffset")
    
    sSql = "SELECT ID, Tariffset FROM tabTariffsetEntry;"
    Set rs = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    While Not rs.EOF
      txtUnit = rs.Fields("ID")
      mediaName = rs.Fields("Tariffset")
      Set recMail = oDBConn.Execute("UPDATE tabTariffsetLine" & _
        " SET TariffsetEntry = " & rs.Fields("ID") & _
        " WHERE Tariffset = " & rs.Fields("Tariffset") & ";")
      rs.MoveNext
    Wend
    Call M_DB.CloseRecordset(rs)
    
    Set recMail = oDBConn.Execute("ALTER TABLE tabTariffsetLine ADD " & _
      "CONSTRAINT tseID FOREIGN KEY (TariffsetEntry) REFERENCES tabTariffsetEntry(ID) ON DELETE CASCADE)")
    Set recMail = oDBConn.Execute("ALTER TABLE tabTariffsetLine DROP CONSTRAINT ccIDl")
    Set recMail = oDBConn.Execute("ALTER TABLE tabTariffsetLine DROP COLUMN Tariffset")
    
    iVerSub = 2
  
  End If
  
  If (iVerSub = 2) Then
    ' insert refTariffset with constraints
      ' "ID AUTOINCREMENT CONSTRAINT tseID PRIMARY KEY, " &
    Set recMail = oDBConn.Execute( _
      "CREATE TABLE refTariffset(" & _
      "CostCenter INTEGER, CONSTRAINT RTS_ccID FOREIGN KEY (CostCenter) REFERENCES tabCostCenter(ID) ON DELETE CASCADE, " & _
      "Tariffset INTEGER, CONSTRAINT RTS_tsID FOREIGN KEY (Tariffset) REFERENCES tabTariffset(ID) ON DELETE CASCADE " & _
      ", CONSTRAINT RTS_pk_ccTs PRIMARY KEY (CostCenter, Tariffset)" & _
      ")")
    If Err Then
      'Tabelle existiert (warum auch immer) bereits
      If Err <> -2147217900 Then
        Call MsgBox("Kann die Tabelle refTariffset nicht anlegen", vbCritical + vbOKOnly, GetResText(20104))
        Stop
      End If
    End If
    Err.Clear

    ' fill table refTariffset from cost center table
    sSql = "SELECT ID,Tariffset FROM tabCostCenter;"
    Set rs = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    i = 0
    While Not rs.EOF
      i = i + 1
      ReDim Preserve ccID(i): ReDim Preserve tsID(i)
      ccID(i) = rs.Fields("ID")
      tsID(i) = rs.Fields("Tariffset")
      rs.MoveNext
    Wend
    Call M_DB.CloseRecordset(rs)
    If (i > 0) Then   ' cost center entries found
      On Error Resume Next
      For i = 1 To UBound(ccID)
        Set recMail = oDBConn.Execute("INSERT INTO refTariffset (CostCenter, Tariffset) " & _
                                      "VALUES (" + ccID(1) + "," + tsID(i) + ");")
      Next i
      On Error GoTo UpdateDBToVersion37_Fehler
    End If

    ' CostCenter - drop constraint
    Set recMail = oDBConn.Execute("ALTER TABLE tabCostCenter DROP CONSTRAINT FK_ccTs")
    
    ' drop column tariffset
    Set recMail = oDBConn.Execute("ALTER TABLE tabCostCenter DROP COLUMN Tariffset")
    
    iVerSub = 3
  End If
  
  If iVerSub = 3 Then
    Call M_DB.addFieldInDB(oDBConn, "tabOptionen", "DpInsExtend", "BIT")
    Set recMail = oDBConn.Execute("UPDATE tabOptionen SET DpInsExtend = 1")

    iVerSub = 4
  End If
  
  If iVerSub = 4 Then
    Call M_DB.addFieldInDB(oDBConn, "tabArchiv", "Hidden", "BIT")
    Set recMail = oDBConn.Execute("UPDATE tabArchiv SET Hidden = 0")

    iVerSub = 5
  End If
  
Exit Sub
UpdateDBToVersion37_Fehler:
  
  Call M_DB.CloseRecordset(rs)
  If (oDBConn.Errors.Count > 0) Then
    Call FehlerAusloesen(30701, oDBConn.Errors.Item(0).Description, False, "M_DB::UpdateDBToVersion37")
  Else
    Call FehlerAusloesen(30701, Err.Description, False, "M_DB::UpdateDBToVersion37")
  End If
End Sub

'---------------------------------------------------------------------------------------------------
'BK 20120723
'Hilfsfunktion die das einstpielen von Protokolltypen vereinfacht.
'Sub vlTypInsert(oDBConn As Connection, vlTyp As Integer, langID As Integer, Name As String, ProtID As Integer)
'  Dim recMail As Recordset
'
'  If Not CheckIfValueExists(oDBConn, "vlTyp_Name", "ClearName", Name, True) Then Set recMail = oDBConn.Execute("UPDATE vlTyp_Name  Set vlTyp=" & vlTyp & ", langId=" & langID & ", protID=" & ProtID & " WHERE ClearName='" & Name & "'")
'
'End Sub
' auskommentiert WOKL 24.3.15 IM 112000


'---------------------------------------------------------------------------------------------------
' Erweitert die Datenbank um 2 Optionsfelder sowie Schnellanwahl und Mailverteiler
' fuer die Verwendung mit Benutzerbereichen
' Aufgerufen von M_DB.VersionPruefen
' IM WOKL, Mai 2010
Public Sub UpdateDBToVersion36(oDBConn As ADODB.Connection, recMail As ADODB.Recordset)
  On Error Resume Next

  'Update fuer 3.6
  Call M_DB.addFieldInDB(oDBConn, "tabOptionen", "LoginActive", "INTEGER")
  Call M_DB.addFieldInDB(oDBConn, "tabOptionen", "AutoLogout", "INTEGER")
  Call M_DB.addFieldInDB(oDBConn, "tabSchnellanwahl", "Bereich", "TEXT")
  Call M_DB.addFieldInDB(oDBConn, "tabMailVerteiler", "isGruppe", "BIT")

  Set recMail = oDBConn.Execute("update tabOptionen set LoginActive = 0")   ' PVSS Login ungueltig
  Set recMail = oDBConn.Execute("update tabOptionen set AutoLogout = 0")    ' Autologout inaktiv
  Set recMail = oDBConn.Execute("update tabSchnellanwahl set Bereich = ''") ' Kein Bereich

End Sub

'---------------------------------------------------------------------------------------------------
' Aufgerufen von M_DB.VersionPruefen
' WOKL, Juli 09
Public Sub UpdateDBToVersion35(oDBConn As ADODB.Connection, recMail As ADODB.Recordset)

  On Error Resume Next
  Set recMail = oDBConn.Execute("CREATE TABLE tabTariffset(" & _
                                "ID AUTOINCREMENT CONSTRAINT ccID PRIMARY KEY, " & _
                                "Name TEXT(255)," & _
                                "Unit TEXT(255), " & _
                                "Loeschen BIT" & _
                                ")")
  If Err Then
    'Tabelle existiert (warum auch immer) bereits
    If Err <> -2147217900 Then
      Call MsgBox("Kann die Tabelle tabTariffset nicht anlegen", vbCritical + vbOKOnly, GetResText(20104))
      Stop
    End If
  End If
  Err.Clear

  Set recMail = oDBConn.Execute("CREATE TABLE tabTariffsetLine(" & _
                                "Tariffset INTEGER, CONSTRAINT ccIDl FOREIGN KEY (Tariffset) REFERENCES tabTariffset(ID) ON DELETE CASCADE, " & _
                                "Cost DOUBLE," & _
                                "FromDate DATE, " & _
                                "UntilDate DATE, " & _
                                "OnMo BIT, " & _
                                "OnTu BIT, " & _
                                "OnWe BIT, " & _
                                "OnTh BIT, " & _
                                "OnFr BIT, " & _
                                "OnSa BIT, " & _
                                "OnSu BIT, " & _
                                "OnHo BIT " & _
                                ")")
  If Err Then
    If Err <> -2147217900 Then
      Call MsgBox("Kann die Tabelle tabTariffsetLine nicht anlegen", vbCritical + vbOKOnly, GetResText(20104))
      Stop
    End If
  End If
  Err.Clear

  Set recMail = oDBConn.Execute("CREATE TABLE tabTariffsetHoli(" & _
                                "Tariffset INTEGER, CONSTRAINT ccIDh FOREIGN KEY (Tariffset) REFERENCES tabTariffset(ID) ON DELETE CASCADE, " & _
                                "Datum DATE" & _
                                ")")
  If Err Then
    If Err <> -2147217900 Then
      Call MsgBox("Kann die Tabelle tabTariffsetHoli nicht anlegen", vbCritical + vbOKOnly, GetResText(20104))
      Stop
    End If
  End If
  Err.Clear

  Set recMail = oDBConn.Execute("CREATE TABLE tabCostCenter(" & _
                                "ID AUTOINCREMENT CONSTRAINT ccID PRIMARY KEY, " & _
                                "Bezeichnung TEXT(255)," & _
                                "Loeschen BIT," & _
                                "Tariffset INTEGER, CONSTRAINT FK_ccTs FOREIGN KEY (Tariffset) REFERENCES tabTariffset(ID) ON DELETE CASCADE" & _
                                ")")
  If Err Then
    'Tabelle existiert (warum auch immer) bereits
    If Err <> -2147217900 Then
      Call MsgBox("Kann die Tabelle tabCostCenter nicht anlegen", vbCritical + vbOKOnly, GetResText(20104))
      Stop
    End If
  End If
  Err.Clear

End Sub 'UpdateDBToVersion35()

'---------------------------------------------------------------------------------------------------
Public Function addFieldInDB(oDBConn As ADODB.Connection, sTab As String, sFeld As String, sTyp As String) As Integer
  'IM 115737 BK 20120329 R|fffd|ckgabe der Funktion gibt an ob neues Feld angelegt wurde.
  
Dim recCheck  As ADODB.Recordset
Dim fldTest   As ADODB.Field
Dim sSql      As String
Dim boCheck   As Boolean

  addFieldInDB = 0 ' BK 20120329
  Set recCheck = New ADODB.Recordset
  Set recCheck.ActiveConnection = oDBConn
  recCheck.CursorType = adOpenDynamic
  recCheck.LockType = adLockPessimistic
  recCheck.Open "SELECT * FROM " & sTab
  
  For Each fldTest In recCheck.Fields
    If fldTest.Name = sFeld Then
      recCheck.Close
      addFieldInDB = -1
      Exit Function
    End If
  Next fldTest
  recCheck.Close
  
  sSql = "ALTER TABLE " & sTab & " ADD COLUMN " & sFeld & " " & sTyp & ";"
  oDBConn.Execute sSql

End Function

' IM 115737
Public Function CheckIfValueExists(oDBConn As ADODB.Connection, sTab As String, sFeld As String, sValue As String, Optional bInsert As Boolean = False) As Boolean
    'DESCRITPTION R|fffd|ckgabe der Funktion gibt an ob ein Wert bereits existiert (
    'BK 20120329 ARTS 13250202 DB Update schl|fffd|gt fehl
Const MY_FUNCT As String = "CheckIfValueExists"
Dim em As String
On Error GoTo Fehler

Dim recCheck  As ADODB.Recordset
Dim fldTest   As ADODB.Field
Dim sSql      As String
Dim boCheck   As Boolean
  CheckIfValueExists = False ' BK 20120329 IF VALUE IS INSERTED
  Set recCheck = New ADODB.Recordset
  Set recCheck.ActiveConnection = oDBConn
  recCheck.CursorType = adOpenForwardOnly
  
  recCheck.LockType = adLockOptimistic
  
  recCheck.Open "SELECT " & sFeld & " FROM " & sTab
  While Not recCheck.EOF
    For Each fldTest In recCheck.Fields
      If fldTest.value = sFeld Then
        CheckIfValueExists = True ' IF VALUE ALREADY EXISTED
        recCheck.Close
        Exit Function               'EXIT
      End If
    Next fldTest
    Call recCheck.MoveNext
  Wend
  'Loop Until recCheck.EOF

  recCheck.Close
    If bInsert Then
        sSql = "INSERT INTO " & sTab & " ( " & sFeld & " ) VALUES (""" & sValue & """)"
        oDBConn.Execute sSql
    End If
Exit Function
Fehler:
    Debug.Print (MY_MODULE & "::" & MY_FUNCT & ">> " & Err.Description & vbNewLine)
    If (em <> "") Then: Debug.Print "Fehlerbeschreibung: " & em & vbNewLine
End Function

' IM 115737
Function checkIfTableExists(oDBConn As ADODB.Connection, ByVal sTablename As String) As Boolean
'DESCRITPTION Returns True if Table exists
'BK 20120329 ARTS 13250202 DB Update schl|fffd|gt fehl. Es muss gepr|fffd|ft werden ob Tabellen bereits existieren.
Const MY_FUNCT As String = "checkIfTableExists"
Dim em As String
On Error GoTo Fehler
checkIfTableExists = False
Dim rs As ADODB.Recordset
 
Set rs = oDBConn.OpenSchema(adSchemaTables, Array(Empty, Empty, sTablename))
checkIfTableExists = Not rs.EOF
rs.Close
 

Exit Function
Fehler:
    Debug.Print (MY_MODULE & "::" & MY_FUNCT & ">> " & Err.Description & vbNewLine)
    If (em <> "") Then: Debug.Print "Fehlerbeschreibung: " & em & vbNewLine
        
End Function

'---------------------------------------------------------------------------------------------------
' hidden: 0 - don't care
'         1 - get hidden = false
'         2 - get hidden = true
' @param useRdb: 0 - don't care
'                1 - use RDB = false
'                2 - use RDB = true
Public Sub getDPTyps(ByVal sysName As String, asDpTyp() As String, _
                     Optional hidden As Integer = 0, Optional useRdb As Integer = 0)

Dim recDPTyp  As ADODB.Recordset
Dim sSql      As String
Dim i         As Integer

  On Error GoTo getDPTyps_Fehler

  If sysName = "*" Then sysName = "%"
  
  ReDim asDpTyp(0)
  sSql = "SELECT DPT FROM tabArchiv WHERE SYS LIKE '" & sysName & "' "
  If useRdb > 0 Then
    If useRdb = 1 Then sSql = sSql & "AND VStufe <> 'RDB' "
    If useRdb = 2 Then sSql = sSql & "AND VStufe = 'RDB' "
  End If
  If hidden > 0 Then
    If hidden = 1 Then sSql = sSql & "AND Hidden = false "
    If hidden = 2 Then sSql = sSql & "AND Hidden = true "
  End If
  sSql = sSql & "GROUP BY DPT;"
  
  Set recDPTyp = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recDPTyp.EOF
    i = i + 1
    ReDim Preserve asDpTyp(i)
    asDpTyp(i) = recDPTyp.Fields(0).value
    recDPTyp.MoveNext
  Wend

  Call M_DB.CloseRecordset(recDPTyp)

Exit Sub
getDPTyps_Fehler:
  
  Call M_DB.CloseRecordset(recDPTyp)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getDPTyps")

End Sub 'getDPTyps()

'---------------------------------------------------------------------------------------------------
' sysName: not yet used
' asDpTyp: list of hidden dp typs
'          for all other dp typs the hidden flag is reset
Public Sub setDPTypHidden(ByVal sysName As String, asDpTyp() As String)

Dim recRc     As ADODB.Recordset
Dim i         As Integer
Dim oDBConn   As ADODB.Connection

  On Error GoTo setDPTypHidden_Error
  
  Set oDBConn = getConnection
  Set recRc = oDBConn.Execute("UPDATE tabArchiv SET Hidden = FALSE")
  For i = 1 To UBound(asDpTyp)
    Set recRc = oDBConn.Execute("UPDATE tabArchiv SET Hidden = TRUE WHERE DPT = '" & asDpTyp(i) & "'")
  Next i

Exit Sub
setDPTypHidden_Error:
  MsgBox (Err.Description)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::setDPTypHidden")

End Sub 'getDPTyps()

'---------------------------------------------------------------------------------------------------
Public Sub getDPSyss(asDPSyss() As String)

Dim recDPSys  As ADODB.Recordset
Dim sSql      As String

Dim i As Integer

  On Error GoTo getDPSyss_Fehler

  ReDim asDPSyss(0)
  sSql = "SELECT SYS FROM tabArchiv GROUP BY SYS;"
  Set recDPSys = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recDPSys.EOF
    i = i + 1
    ReDim Preserve asDPSyss(i)
    asDPSyss(i) = recDPSys.Fields(0).value
    recDPSys.MoveNext
  Wend

  Call M_DB.CloseRecordset(recDPSys)

Exit Sub
getDPSyss_Fehler:
  
  Call M_DB.CloseRecordset(recDPSys)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getDPSyss")

End Sub 'getDPSyss()

'---------------------------------------------------------------------------------------------------
Public Sub getArchivDPE(asDPE() As String, ByVal sSystem As String, ByVal sDPT As String)

Dim recDPE    As ADODB.Recordset
Dim sSql      As String

Dim i As Integer

  On Error GoTo getArchivDPE_Fehler

  ReDim asDPE(0)
  If sDPT = "*" Then sDPT = "%"
  If sSystem = "*" Then sSystem = "%"
  
  sSql = "SELECT DISTINCT DPE FROM tabArchiv WHERE DPT like '" & sDPT & _
         "' AND SYS like '" & sSystem & "' GROUP BY DPT, DPE;"
  Set recDPE = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recDPE.EOF
    i = i + 1
    ReDim Preserve asDPE(i)
    asDPE(i) = recDPE.Fields("DPE").value
    recDPE.MoveNext
  Wend

  Call M_DB.CloseRecordset(recDPE)

Exit Sub
getArchivDPE_Fehler:
  
  Call M_DB.CloseRecordset(recDPE)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getArchivDPE")

End Sub 'getArchivDPE()

'---------------------------------------------------------------------------------------------------
' WOKL 12.9.07 die Funktion scheint nicht verwendet zu werden
' Aufruf nur in V_ArchivDetail, das seinerseits nicht verwendet wird
Public Sub getVStufe(asVStufe() As String, sDPT As String, sDPE As String)

Dim recVStufe As ADODB.Recordset
Dim sSql      As String

Dim i As Integer

  On Error GoTo getVStufe_Fehler

  ReDim asVStufe(0)
  If sDPT = "*" Then sDPT = "%"
  If sDPE = "*" Then sDPE = "%"
  ' TODO: wenn verwendet, dann SYS einfuegen WOKL 12.9.07
  sSql = "SELECT VStufe FROM tabArchiv " & _
         "WHERE ((DPT Like '" & sDPT & "') AND (DPE Like '" & sDPE & "')) " & _
         "GROUP BY VStufe ORDER BY VStufe;"
  Set recVStufe = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)

  While Not recVStufe.EOF
    i = i + 1
    ReDim Preserve asVStufe(i)
    asVStufe(i) = recVStufe.Fields(0).value
    recVStufe.MoveNext
  Wend

  Call M_DB.CloseRecordset(recVStufe)

Exit Sub
getVStufe_Fehler:

  Call M_DB.CloseRecordset(recVStufe)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getVStufe")

End Sub 'getVStufe()

'---------------------------------------------------------------------------------------------------
' WOKL 12.9.07 nur verwendet in V_ArchivSucher
'---------------------------------------------------------------------------------------------------
Public Sub getIntervallStr(asIntervallStr() As String, ByVal sSystem As String, ByVal sDPT As String, ByVal sDPE As String)

Dim recIntervall  As ADODB.Recordset
Dim sSql          As String

Dim i As Integer
  
  On Error GoTo getIntervallStr_Fehler

  ReDim asIntervallStr(0)
  
  If sSystem = "*" Then sSystem = "%"
  If sDPT = "*" Then sDPT = "%"
  If sDPE = "*" Then sDPE = "%"
  sSql = "SELECT Intervall, IntEinheit FROM tabArchiv " & _
         "WHERE SYS LIKE '" & sSystem & "' AND DPT Like '" & sDPT & "' AND DPE Like '" & sDPE & "' " & _
         "GROUP BY IntEinheit, Intervall ORDER BY IntEinheit, Intervall"

  Set recIntervall = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recIntervall.EOF
    i = i + 1
    ReDim Preserve asIntervallStr(i)
    asIntervallStr(i) = IntervallWithUnitToStr( _
                              recIntervall.Fields(0).value, _
                              recIntervall.Fields(1).value)
    
    recIntervall.MoveNext
  Wend

  Call M_DB.CloseRecordset(recIntervall)

Exit Sub
getIntervallStr_Fehler:
  Call ErrMessage(sSql, "M_DB::getIntervallStr")
  Call M_DB.CloseRecordset(recIntervall)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getIntervallStr")

End Sub 'getIntervallStr()

'---------------------------------------------------------------------------------------------------
' nur in V_ArchivDetail aufgerufen; nachdem dieses nirgends verwendet wird ....
' WOKL 12.9.07
Public Function getArchiv(sDPT As String, sDPE As String, sVStufe As String) As C_Archiv

Dim recArchiv As ADODB.Recordset
Dim sSql      As String

Dim i As Integer

  On Error GoTo getArchiv_Fehler

  Set getArchiv = New C_Archiv
  
  ' bei Verwendung TODO: SYS einfuegen (Parameter und Aufrufe)
  sSql = "SELECT ID, DPT, DPE, VStufe, Intervall " & _
         "FROM tabArchiv " & _
         "WHERE DPT = '" & sDPT & "' AND DPE = '" & sDPE & "' AND VStufe = '" & sVStufe & "';"
  
  Set recArchiv = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  If Not recArchiv.EOF Then
    getArchiv.ID = recArchiv.Fields("ID")
    getArchiv.dpt = recArchiv.Fields("DPT")
    getArchiv.dpe = recArchiv.Fields("DPE")
    getArchiv.VStufe = recArchiv.Fields("VStufe")
    'getArchiv = recArchiv.Fields("")
  End If

  Call M_DB.CloseRecordset(recArchiv)

Exit Function
getArchiv_Fehler:

  Call M_DB.CloseRecordset(recArchiv)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getArchiv")

End Function 'getArchiv()

'---------------------------------------------------------------------------------------------------
Public Sub getProtTypBezeichner(alId() As Long, asBezeichnung() As String)

Dim recProtTyp  As ADODB.Recordset
Dim sSql        As String
Dim n As Long

  On Error GoTo getProtTypBezeichner_Fehler

  ReDim alId(0)
  ReDim asBezeichnung(0)
 
  sSql = "SELECT ID, Bezeichnung " & _
         "FROM tabProtTyp;"
         
  Set recProtTyp = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recProtTyp.EOF
    n = n + 1
    ReDim Preserve alId(n)
    alId(n) = recProtTyp.Fields("ID")
    ReDim Preserve asBezeichnung(n)
    asBezeichnung(n) = recProtTyp.Fields("Bezeichnung")
    
    recProtTyp.MoveNext
  Wend
  
  Call M_DB.CloseRecordset(recProtTyp)

Exit Sub
getProtTypBezeichner_Fehler:
  
  Call M_DB.CloseRecordset(recProtTyp)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getProtTypBezeichner")
  
End Sub 'getProtTypBezeichner()

'---------------------------------------------------------------------------------------------------
Public Function getMailVerteiler(sBezeichnung As String) As Long

Dim recMail As ADODB.Recordset
Dim sSql    As String

  getMailVerteiler = -1
  On Error Resume Next
  
  sSql = "SELECT ID, Bezeichnung " & _
         "FROM tabMailVerteiler " & _
         "WHERE Bezeichnung = '" & sBezeichnung & "';"
         
  Set recMail = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  If Not recMail.EOF Then
    getMailVerteiler = recMail.Fields("ID")
  End If
  
  Call M_DB.CloseRecordset(recMail)
  
End Function


'---------------------------------------------------------------------------------------------------
Public Sub getMailVerteilerBezeichner(alId() As Long, asBezeichnung() As String)

Dim recMail  As ADODB.Recordset
Dim sSql     As String
Dim n As Long

  On Error GoTo getMailVerteilerBezeichner_Fehler

  ReDim alId(0)
  ReDim asBezeichnung(0)
 
  sSql = "SELECT ID, Bezeichnung " & _
         "FROM tabMailVerteiler;"
         
  Set recMail = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recMail.EOF
    n = n + 1
    ReDim Preserve alId(n)
    alId(n) = recMail.Fields("ID")
    ReDim Preserve asBezeichnung(n)
    asBezeichnung(n) = recMail.Fields("Bezeichnung")
    
    recMail.MoveNext
  Wend
  
  Call M_DB.CloseRecordset(recMail)

Exit Sub
getMailVerteilerBezeichner_Fehler:
  
  Call M_DB.CloseRecordset(recMail)
  Call FehlerAusloesen(30701, Err.Description, False, "M_DB::getMailVerteilerBezeichner")
  
End Sub 'getMailVerteilerBezeichner()

'---------------------------------------------------------------------------------------------------
Public Function CDBStr(v As Variant) As String
  If Not IsNull(v) Then
    CDBStr = CStr(v)
  Else
    CDBStr = ""
  End If
End Function

'---------------------------------------------------------------------------------------------------
Public Sub tst()

Dim astst() As String
Dim n       As Integer

'  Call M_DB.getDPTyps(astst)
'  For n = 1 To UBound(astst)
'    Debug.Print astst(n)
'  Next n
  
  If Not moDBConn Is Nothing Then
    moDBConn.Close
    Set moDBConn = Nothing
  End If
  
  If moDBConn Is Nothing Then
    Set moDBConn = New ADODB.Connection
  End If

  If moDBConn.State = adStateClosed Then
    'moDBConn.OpenSchema adSchemaTables
    On Error Resume Next
    moDBConn.Provider = M_Optionen.getDBProvider
    moDBConn.Open M_Tools.ProjektPfad & "\" & DB_DATEI, "Admin"
    If Err Then
      Err.Clear
      moDBConn.Provider = "Microsoft.Jet.OLEDB.4.0"
      moDBConn.Open M_Tools.ProjektPfad & "\" & DB_DATEI, "Admin"
      If Err Then
        On Error GoTo 0
        Call FehlerAusloesen(ERR_INTERN_DB, M_Tools.ProjektPfad & "\" & DB_DATEI, True, "ReportDB")
      End If
      Call M_Optionen.setDBProvider(moDBConn.Provider)
    End If
    Call VersionPruefen(moDBConn)
  End If
  
End Sub


Attribute VB_Name = "M_DP"
'===================================================================================================
'M_DP
'Oliver Seidel 31.07.2000
'  Verwaltung der Datenpunkte
'Aenderungen: WOKL 12.9.07 Import geloescht, Funktionen werden nicht verwendet
' Modul ist obsolet
'===================================================================================================
Option Explicit
Option Private Module

Private msSQLLetzteSuche  As String
Private mcoDP             As CO_DP

'---------------------------------------------------------------------------------------------------
Public Function coSuchen(Optional lID As Long, _
                         Optional sDP As String, _
                         Optional sDPE As String = "%", _
                         Optional sDPT As String) As CO_DP

Dim recDPL    As ADODB.Recordset
Dim sSql      As String
Dim sWhere    As String

Dim oDP   As C_DP
Dim coDP  As CO_DP

  On Error GoTo M_DP_coSuchen_Fehler
  
  If lID > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "ID = " & lID
  End If
    
  If Len(sDP) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "DP like '" & sDP & "'"
  End If
    
  If sDPE = "*" Then sDPE = "%"
  'Auch nach leeren DPE kann gesucht werden!
  'If Len(sDPE) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "DPE like '" & sDPE & "'"
  'End If
    
  If Len(sDPT) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "DPT like '" & sDPT & "'"
  End If
    
  sSql = "SELECT ID, DP, DPE, DPT, Alias, Kommentar " & _
         "FROM tabDPL "
  If Len(sWhere) > 0 Then
    sSql = sSql & "WHERE " & sWhere & " "
  End If
  sSql = sSql & "GROUP BY ID, DP, DPE, DPT, Alias, Kommentar " & _
                "ORDER BY DP, DPE;"
  If (sSql = msSQLLetzteSuche) And _
     (Not mcoDP Is Nothing) Then
  
    Set coDP = mcoDP
  Else
    Set coDP = New CO_DP
    Set recDPL = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    
    While Not recDPL.EOF
      Set oDP = New C_DP
      oDP.ID = recDPL.Fields("ID")
      oDP.dp = recDPL.Fields("DP")
      oDP.dpe = recDPL.Fields("DPE")
      oDP.dpt = recDPL.Fields("DPT")
      'Alias und Kommentar werden nicht mehr in der DB gespeichert
      'oDp.Alias = CDBStr(recDPL.Fields("Alias"))
      'oDp.Kommentar = CDBStr(recDPL.Fields("Kommentar"))
      coDP.Add oDP
      recDPL.MoveNext
    Wend
    Set mcoDP = coDP
    msSQLLetzteSuche = sSql
    Call M_DB.CloseRecordset(recDPL)
  
  End If
  
  Set coSuchen = coDP

Exit Function
M_DP_coSuchen_Fehler:
  
  Call ErrMessage("SQL: " & sSql)
  Call M_DB.CloseRecordset(recDPL)
  If Not oDP Is Nothing Then
    Call FehlerAusloesen(30701, "DP #" & oDP.ID, False, "M_DP::coSuchen")
  Else
    Call FehlerAusloesen(30701, Err.Description, False, "M_DP::coSuchen")
  End If
End Function 'coSuchen()

'---------------------------------------------------------------------------------------------------
Public Function Suchen(Optional lID As Long, _
                       Optional sDP As String, _
                       Optional sDPE As String = "%") As C_DP

Dim recDPL    As ADODB.Recordset
Dim sSql      As String
Dim sWhere    As String

Dim oDP   As C_DP

  On Error GoTo M_DP_Suchen_Fehler
  
  If lID > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "ID = " & lID
  End If
    
  If Len(sDP) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "DP = '" & sDP & "'"
  End If
  
  If sDPE = "*" Then sDPE = "%"
  'Auch nach leeren DPE kann gesucht werden!
  'If Len(sDPE) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "DPE = '" & sDPE & "'"
  'End If
    
  sSql = "SELECT ID, DP, DPE, DPT, Alias, Kommentar " & _
         "FROM tabDPL "
  If Len(sWhere) > 0 Then
    sSql = sSql & "WHERE " & sWhere & " "
  Else
    Exit Function
  End If
  sSql = sSql & "GROUP BY ID, DP, DPE, DPT, Alias, Kommentar;"
    
  Set oDP = New C_DP
  Set recDPL = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  'ToDo: ist RecordCount sicher?
  If recDPL.EOF Then 'Or recDPL.RecordCount <> 1 Then
    Exit Function
  End If
    
  oDP.ID = recDPL.Fields("ID")
  oDP.dp = recDPL.Fields("DP")
  oDP.dpe = recDPL.Fields("DPE")
  oDP.dpt = recDPL.Fields("DPT")
  'Alias und Kommentar werden nicht mehr in der DB gespeichert
  'oDp.Alias = CDBStr(recDPL.Fields("Alias"))
  'oDp.Kommentar = CDBStr(recDPL.Fields("Kommentar"))
  
  Set Suchen = oDP

  Call M_DB.CloseRecordset(recDPL)

Exit Function
M_DP_Suchen_Fehler:
  Call ErrMessage("SQL: " & sSql)
  Call M_DB.CloseRecordset(recDPL)
  If Not oDP Is Nothing Then
    Call FehlerAusloesen(30701, "DP #" & oDP.ID, False, "M_DP::coSuchen")
  Else
    Call FehlerAusloesen(30701, Err.Description, False, "M_DP::coSuchen")
  End If
End Function 'Suchen()

Attribute VB_Name = "M_DPFunktion"
'===================================================================================================
'M_DPFunktion
'Oliver Seidel 28.09.2000
'  Verwaltung der Datenpunktfunktionen
'Anmerkung: Editieren und Speichern der DPFunktionen wird (noch) nicht unterstuetzt.
'           Die Datensaetze muessen per Hand in die Datenbank eingetragen werden.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Dim m_coDPFunktion As CO_DPFunktion

'--------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_DPFunktion

Dim recDPFunktion As ADODB.Recordset
Dim sSql          As String
Dim oDPFunktion   As C_DPFunktion

  On Error GoTo DPFunktion_Lesen_Fehler
  Set coLesen = Nothing

  If Not m_coDPFunktion Is Nothing Then
    Set coLesen = m_coDPFunktion
    Exit Function
  End If

  Set m_coDPFunktion = New CO_DPFunktion
  sSql = "SELECT * FROM tabFunktion"
  Set recDPFunktion = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recDPFunktion.EOF
    Set oDPFunktion = New C_DPFunktion
    oDPFunktion.ID = recDPFunktion.Fields("ID")
    oDPFunktion.Bezeichnung = recDPFunktion.Fields("Bezeichnung")
    oDPFunktion.dpe = recDPFunktion.Fields("DPE")
    oDPFunktion.BerechnungMoeglich = IstBerechnungMoeglich(oDPFunktion.Bezeichnung)
    recDPFunktion.MoveNext
    m_coDPFunktion.Add oDPFunktion
  Wend
  
  Call M_DB.CloseRecordset(recDPFunktion)
  
  Set coLesen = m_coDPFunktion
  
Exit Function
DPFunktion_Lesen_Fehler:
  
  Call M_DB.CloseRecordset(recDPFunktion)
  If Not oDPFunktion Is Nothing Then
    Call FehlerAusloesen(30700, "DPFunktion #" & oDPFunktion.ID, False, "M_DPFunktion::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_DPFunktion::coLesen")
  End If
  
End Function 'coLesen()

'--------------------------------------------------------------------------------------------------
'Public Sub coSpeichern(coDPFunktion As CO_DPFunktion)
'
'Dim dbReport      As Database
'Dim recDPFunktion  As ADODB.Recordset
'Dim oDPFunktion    As C_DPFunktion
'
'  On Error GoTo DPFunktion_Speichern_Fehler
'
'  Set dbReport = OpenDatabase(getDBReportDatei)
'
'  Set recDPFunktion = M_DB.ReportDB.OpenRecordset("tabDPFunktion", dbOpenDynaset)
'  For Each oDPFunktion In coDPFunktion.Items
'    Select Case oDPFunktion.ObjektStatus
'      Case OBJEKT_STATUS_NEU
'        recDPFunktion.FindFirst "ID = " & oDPFunktion.ID
'
'        If recDPFunktion.NoMatch Then
'          recDPFunktion.AddNew
'          recDPFunktion.Fields("Bezeichnung") = oDPFunktion.Bezeichnung
'          recDPFunktion.Fields("DPE") = oDPFunktion.DPE
'          recDPFunktion.Update
'          recDPFunktion.Bookmark = recDPFunktion.LastModified
'          oDPFunktion.ID = recDPFunktion.Fields("ID")
'          oDPFunktion.ObjektStatus = OBJEKT_STATUS_GESPEICHERT
'        Else
'          Stop
'        End If
'      Case OBJEKT_STATUS_GEAENDERT
'        recDPFunktion.FindFirst "ID = " & oDPFunktion.ID
'        If Not recDPFunktion.NoMatch Then
'          recDPFunktion.Edit
'          recDPFunktion.Fields("Bezeichnung") = oDPFunktion.Bezeichnung
'          recDPFunktion.Update
'          oDPFunktion.ObjektStatus = OBJEKT_STATUS_GESPEICHERT
'        End If
'
'      Case OBJEKT_STATUS_GELOESCHT
'        recDPFunktion.FindFirst "ID = " & oDPFunktion.ID
'        If Not recDPFunktion.NoMatch Then
'          recDPFunktion.Delete
'          coDPFunktion.Remove (oDPFunktion.Bezeichnung)
'        End If
'
'    End Select
'
'  Next oDPFunktion
'
'Exit Sub
'DPFunktion_Speichern_Fehler:
'  Call MsgBox(Err.Description, vbCritical + vbOKOnly, Err.Number & " " & Err.Source)
'End Sub

'--------------------------------------------------------------------------------------------------
Public Function coSuchen(Optional lID As Long = 0, _
                         Optional sBezeichnung As String = "", _
                         Optional lArchivID As Long = 0) As CO_DPFunktion

Dim recDPFunktion   As ADODB.Recordset
Dim sSql            As String
Dim sWhere          As String

Dim oDPFunktion     As C_DPFunktion
Dim coDPFkt         As CO_DPFunktion

  On Error GoTo DPFunktion_coSuchen_Fehler
  
  If lID > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "ID = " & lID
  End If
    
  If Len(sBezeichnung) > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "Bezeichnung like '" & sBezeichnung & "'"
  End If
    
  If lArchivID > 0 Then
    If Len(sWhere) > 0 Then sWhere = sWhere & " AND "
    sWhere = sWhere & "Archiv = " & lArchivID
  End If
    
  If lArchivID > 0 Then
    sSql = "SELECT ID, Bezeichnung, DPE, Archiv " & _
           "FROM refFunktion INNER JOIN tabFunktion ON refFunktion.Funktion = tabFunktion.ID "
    If Len(sWhere) > 0 Then
      sSql = sSql & "WHERE " & sWhere & " "
    End If
    sSql = sSql & "GROUP BY ID, Bezeichnung, DPE, Archiv;"
  Else
    sSql = "SELECT ID, Bezeichnung, DPE " & _
           "FROM tabFunktion "
    If Len(sWhere) > 0 Then
      sSql = sSql & "WHERE " & sWhere & " "
    End If
    sSql = sSql & "GROUP BY ID, Bezeichnung, DPE;"
  End If

  Set coDPFkt = New CO_DPFunktion
  Set recDPFunktion = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recDPFunktion.EOF
    Set oDPFunktion = New C_DPFunktion
    oDPFunktion.ID = recDPFunktion.Fields("ID")
    oDPFunktion.Bezeichnung = recDPFunktion.Fields("Bezeichnung")
    oDPFunktion.dpe = recDPFunktion.Fields("DPE")
    oDPFunktion.BerechnungMoeglich = IstBerechnungMoeglich(oDPFunktion.Bezeichnung)
    recDPFunktion.MoveNext
    coDPFkt.Add oDPFunktion
  Wend

  Call M_DB.CloseRecordset(recDPFunktion)
  
  Set coSuchen = coDPFkt

Exit Function
DPFunktion_coSuchen_Fehler:
  Call ErrMessage("SQL: " & sSql)
  Call M_DB.CloseRecordset(recDPFunktion)
  If Not oDPFunktion Is Nothing Then
    Call FehlerAusloesen(30701, "DPFunktion #" & oDPFunktion.ID, False, "M_DPFunktion::coSuchen")
  Else
    Call FehlerAusloesen(30701, Err.Description, False, "M_DPFunktion::coSuchen")
  End If
End Function 'coSuchen()

'--------------------------------------------------------------------------------------------------
'Funktionen, die auch intern berechnet werden koennen, liefern 'true' zurueck.
'--------------------------------------------------------------------------------------------------
Private Function IstBerechnungMoeglich(sDPFkt As String) As Boolean
  Select Case sDPFkt
    Case VAR_MIN:       IstBerechnungMoeglich = True
    Case VAR_MAX:       IstBerechnungMoeglich = True
    Case VAR_MIN_ZEIT:  IstBerechnungMoeglich = True
    Case VAR_MAX_ZEIT:  IstBerechnungMoeglich = True
    Case VAR_ANZAHL:    IstBerechnungMoeglich = True
    Case VAR_SUMME:     IstBerechnungMoeglich = True
    Case VAR_INTG0:     IstBerechnungMoeglich = True
    Case VAR_INTG1:     IstBerechnungMoeglich = True
    Case VAR_SUM_ANZ:   IstBerechnungMoeglich = True
    Case VAR_MITTEL:    IstBerechnungMoeglich = True
    Case VAR_MITTEL1:   IstBerechnungMoeglich = True
    Case VAR_TIME0:     IstBerechnungMoeglich = False
    Case VAR_TIME1:     IstBerechnungMoeglich = False
    Case VAR_WECHSEL:   IstBerechnungMoeglich = False
    Case VAR_WECHSEL01: IstBerechnungMoeglich = False
    Case VAR_WECHSEL10: IstBerechnungMoeglich = False
    Case VAR_BEGIN:     IstBerechnungMoeglich = True
    Case VAR_END:       IstBerechnungMoeglich = True
    Case VAR_DIFF:      IstBerechnungMoeglich = True
    Case VAR_RESERVE:   IstBerechnungMoeglich = False
    Case VAR_MAN:       IstBerechnungMoeglich = False
    Case VAR_DIFF_ABS:  IstBerechnungMoeglich = True
    Case Else: Stop
  End Select
  
End Function

Public Function CDPFktToName(sDPFkt As String) As String
  Select Case sDPFkt
    Case VAR_MIN:       CDPFktToName = GetResText(21520)
    Case VAR_MAX:       CDPFktToName = GetResText(21521)
    Case VAR_MIN_ZEIT:  CDPFktToName = GetResText(21522)
    Case VAR_MAX_ZEIT:  CDPFktToName = GetResText(21523)
    Case VAR_ANZAHL:    CDPFktToName = GetResText(21524)
    Case VAR_SUMME:     CDPFktToName = GetResText(21525)
    Case VAR_INTG0:     CDPFktToName = GetResText(21526)
    Case VAR_INTG1:     CDPFktToName = GetResText(21527)
    Case VAR_SUM_ANZ:   CDPFktToName = GetResText(21528)
    Case VAR_MITTEL:    CDPFktToName = GetResText(21529)
    Case VAR_MITTEL1:   CDPFktToName = GetResText(21530)
    Case VAR_TIME0:     CDPFktToName = GetResText(21531)
    Case VAR_TIME1:     CDPFktToName = GetResText(21532)
    Case VAR_WECHSEL:   CDPFktToName = GetResText(21533)
    Case VAR_WECHSEL01: CDPFktToName = GetResText(21534)
    Case VAR_WECHSEL10: CDPFktToName = GetResText(21535)
    Case VAR_BEGIN:     CDPFktToName = GetResText(21536)
    Case VAR_END:       CDPFktToName = GetResText(21537)
    Case VAR_DIFF:      CDPFktToName = GetResText(21538)
    Case VAR_RESERVE:   CDPFktToName = GetResText(21539)
    Case VAR_MAN:       CDPFktToName = GetResText(21540)
    Case VAR_DIFF_ABS:  CDPFktToName = GetResText(21541)
  End Select
End Function

Public Function CNameToDPFkt(sName As String) As String
  Select Case sName
    Case GetResText(21520): CNameToDPFkt = VAR_MIN
    Case GetResText(21521): CNameToDPFkt = VAR_MAX
    Case GetResText(21522): CNameToDPFkt = VAR_MIN_ZEIT
    Case GetResText(21523): CNameToDPFkt = VAR_MAX_ZEIT
    Case GetResText(21524): CNameToDPFkt = VAR_ANZAHL
    Case GetResText(21525): CNameToDPFkt = VAR_SUMME
    Case GetResText(21526): CNameToDPFkt = VAR_INTG0
    Case GetResText(21527): CNameToDPFkt = VAR_INTG1
    Case GetResText(21528): CNameToDPFkt = VAR_SUM_ANZ
    Case GetResText(21529): CNameToDPFkt = VAR_MITTEL
    Case GetResText(21530): CNameToDPFkt = VAR_MITTEL1
    Case GetResText(21531): CNameToDPFkt = VAR_TIME0
    Case GetResText(21532): CNameToDPFkt = VAR_TIME1
    Case GetResText(21533): CNameToDPFkt = VAR_WECHSEL
    Case GetResText(21534): CNameToDPFkt = VAR_WECHSEL01
    Case GetResText(21535): CNameToDPFkt = VAR_WECHSEL10
    Case GetResText(21536): CNameToDPFkt = VAR_BEGIN
    Case GetResText(21537): CNameToDPFkt = VAR_END
    Case GetResText(21538): CNameToDPFkt = VAR_DIFF
    Case GetResText(21539): CNameToDPFkt = VAR_RESERVE
    Case GetResText(21540): CNameToDPFkt = VAR_MAN
    Case GetResText(21541): CNameToDPFkt = VAR_DIFF_ABS
    Case Else:              CNameToDPFkt = sName
  End Select
End Function
Attribute VB_Name = "M_Debug"
Option Explicit
Option Private Module

#Const aboLogFile = 1
#Const aboMsgBox = 2
#Const aboDebugWin = 4

Private mcoProcessInfo As Collection

Public glCDPInstanz                 As Long
Public glCDPInstanzMax              As Long
Public glCArchivInstanz             As Long
Public glCArchivInstanzMax          As Long
Public glCBasiswertInstanz          As Long
Public glCBasiswertInstanzMax       As Long
Public glCDPFunktionInstanz         As Long
Public glCDPFunktionInstanzMax      As Long
Public glCDPGruppeInstanz           As Long
Public glCDPGruppeInstanzMax        As Long
Public glCDPReferenzInstanz         As Long
Public glCDPReferenzInstanzMax      As Long
Public glCDPWertInstanz             As Long
Public glCDPWertInstanzMax          As Long
Public glCOptionenInstanz           As Long
Public glCOptionenInstanzMax        As Long
Public glCProtokollInstanz          As Long
Public glCProtokollInstanzMax       As Long
Public glCProtokollTypInstanz       As Long
Public glCProtokollTypInstanzMax    As Long
Public glCStatusBitInstanz          As Long
Public glCStatusBitInstanzMax       As Long
Public glCStyleInstanz              As Long
Public glCStyleInstanzMax           As Long
Public glCTabBereichInstanz         As Long
Public glCTabBereichInstanzMax      As Long
Public glCTimerInstanz              As Long
Public glCTimerInstanzMax           As Long
Public glCOArchivInstanz            As Long
Public glCOArchivInstanzMax         As Long
Public glCOBasiswertInstanz         As Long
Public glCOBasiswertInstanzMax      As Long
Public glCODPInstanz                As Long
Public glCODPInstanzMax             As Long
Public glCODPFunktionInstanz        As Long
Public glCODPFunktionInstanzMax     As Long
Public glCOOptionenInstanz          As Long
Public glCOOptionenInstanzMax       As Long
Public glCOProtokollInstanz         As Long
Public glCOProtokollInstanzMax      As Long
Public glCOProtokollTypInstanz      As Long
Public glCOProtokollTypInstanzMax   As Long
Public glCOStatusBitInstanz         As Long
Public glCOStatusBitInstanzMax      As Long
Public glCOTabBereichInstanz        As Long
Public glCOTabBereichInstanzMax     As Long
Public glCOMailVerteilerInstanz     As Long
Public glCOMailVerteilerInstanzMax  As Long

'--------------------------------------------------------------------------------------------------
Public Sub addRef(sClassName As String, lInstanz As Long, lInstanzMax As Long)
'  lInstanz = lInstanz + 1
'  If lInstanz = 1 Then
'    Call BugMessage("Erste Instanz erzeugt", sClassName)
'  End If
'  If lInstanzMax < lInstanz Then
'    lInstanzMax = lInstanz
'  End If
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Releas(sClassName As String, lInstanz As Long, lInstanzMax As Long)
'  lInstanz = lInstanz - 1
'  If lInstanz = 0 Then
'    Call BugMessage("Letzte Instanz von max. " & lInstanzMax & " zerstoert", sClassName)
'  End If
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub ProcessInfoInit()

'Dim osProcessState As CState
'
'  Set osProcessState = New CState
'  Call osProcessState.Create("Handles", "\Prozess(excel)\Anzahl von Handles")
'  mcoProcessInfo.Add osProcessState
'
'  Set osProcessState = New CState
'  Call osProcessState.Create("Thread", "\Prozess(excel)\Thread-Anzahl")
'  mcoProcessInfo.Add osProcessState
'
'  Set osProcessState = New CState
'  Call osProcessState.Create("Virtuelle Groesse", "\Prozess(excel)\Virtuelle Groesse")
'  mcoProcessInfo.Add osProcessState

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub ProcessInfoStart(sMsg As String)

'Dim iLogFile As Integer
'Dim osProcessState As CState
'Dim s As String
'
'#If aboDebug And aboLogFile Then
'
'  If mcoProcessInfo Is Nothing Then
'    Set mcoProcessInfo = New Collection
'    Call ProcessInfoInit
'  End If
'
'  iLogFile = FreeFile
'  Open ProjektPfad & "\" & _
'       ProjektBezeichnung & ".DBG" _
'       For Append Shared As iLogFile
'
'  For Each osProcessState In mcoProcessInfo
'    With osProcessState
'      .Start
'      Print #iLogFile, Date & " " & Time & " " & _
'                       "Start: " & Format(.StartValue, "#,##0") & Chr(9) & _
'                       .Name & Chr(9) & _
'                       sMsg & Chr(9)
'    End With
'
'  Next osProcessState
'  Close iLogFile
'#End If
  
End Sub
'--------------------------------------------------------------------------------------------------
Public Sub ProcessInfo(sMsg As String)

'Dim iLogFile As Integer
'Dim osProcessState As CState
'Dim s As String
'
'#If aboDebug And aboLogFile Then
'
'  If mcoProcessInfo Is Nothing Then
'    Set mcoProcessInfo = New Collection
'    Call ProcessInfoInit
'  End If
'
'  iLogFile = FreeFile
'  Open ProjektPfad & "\" & _
'       ProjektBezeichnung & ".DBG" _
'       For Append Shared As iLogFile
'
'  For Each osProcessState In mcoProcessInfo
'    With osProcessState
'      .Update
'      Print #iLogFile, Date & " " & Time & " " & _
'                       "End:   " & Format(.EndValue, "#,##0") & Chr(9) & _
'                       "Div:   " & Format((.EndValue - .StartValue), "#,##0") & Chr(9) & _
'                       .Name & Chr(9) & _
'                       sMsg & Chr(9)
'
'    End With
'  Next osProcessState
'  Close iLogFile
'#End If

End Sub



Attribute VB_Name = "M_Funktionen"
'==================================================================================================
'M_Funktionen
'
'Oliver Seidel
'05.02.1999
'
'Sammlung von benutzerdefinierten Funktionen fuer die Protokollen. Koennen vom Benutzer direkt in
'den Vorlagen und Protokollen eingesetzt werden.
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Dim mcoStatusBit As CO_StatusBit

'---------------------------------------------------------------------------------------------------
Public Function erSum(rgWerte As Range) As Variant
Attribute erSum.VB_ProcData.VB_Invoke_Func = " \n14"

'Dim coStatusBit As CO_StatusBit
Dim rgWert      As Range
Dim fSumme      As Double
Dim lAnz        As Long

  If mcoStatusBit Is Nothing Then
    Set mcoStatusBit = M_StatusBit.coLesen
  End If
  
  For Each rgWert In rgWerte
    If Not mcoStatusBit.FindItem(rgWert.Style) Is Nothing Then
      If Not mcoStatusBit.FindItem(rgWert.Style).WerteIgnorieren And _
         IsNumeric(rgWert.value) Then
        fSumme = fSumme + rgWert.value
        lAnz = lAnz + 1
      End If
    End If
  Next rgWert
  If lAnz > 0 Then
    erSum = fSumme
  Else
    erSum = ""
  End If
  
End Function

'---------------------------------------------------------------------------------------------------
Public Function erAvg(rgWerte As Range) As Variant
Attribute erAvg.VB_ProcData.VB_Invoke_Func = " \n14"

'Dim coStatusBit As CO_StatusBit
Dim rgWert      As Range
Dim fSumme      As Double
Dim lAnz        As Long

  If mcoStatusBit Is Nothing Then
    Set mcoStatusBit = M_StatusBit.coLesen
  End If
  
  For Each rgWert In rgWerte
    If Not mcoStatusBit.FindItem(rgWert.Style) Is Nothing Then
      If Not mcoStatusBit.FindItem(rgWert.Style).WerteIgnorieren And _
         IsNumeric(rgWert.value) Then
        fSumme = fSumme + rgWert.value
        lAnz = lAnz + 1
      End If
    End If
  Next rgWert
  If lAnz > 0 Then
    erAvg = fSumme / lAnz
  Else
    erAvg = ""
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Function erMin(rgWerte As Range) As Variant
Attribute erMin.VB_ProcData.VB_Invoke_Func = " \n14"

'Dim coStatusBit As CO_StatusBit
Dim rgWert  As Range
Dim fMin    As Double
Dim lAnz    As Long

  If mcoStatusBit Is Nothing Then
    Set mcoStatusBit = M_StatusBit.coLesen
  End If
  
  For Each rgWert In rgWerte
    If Not mcoStatusBit.FindItem(rgWert.Style) Is Nothing Then
      If Not mcoStatusBit.FindItem(rgWert.Style).WerteIgnorieren And _
         IsNumeric(rgWert.value) Then
        If lAnz = 0 Then
          fMin = rgWert
        ElseIf fMin > rgWert Then
          fMin = rgWert
        End If
        lAnz = lAnz + 1
      End If
    End If
  Next rgWert
  If lAnz > 0 Then
    erMin = fMin
  Else
    erMin = ""
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Function erMax(rgWerte As Range) As Variant
Attribute erMax.VB_ProcData.VB_Invoke_Func = " \n14"

'Dim coStatusBit As CO_StatusBit
Dim rgWert  As Range
Dim fMax    As Double
Dim lAnz    As Long

  If mcoStatusBit Is Nothing Then
    Set mcoStatusBit = M_StatusBit.coLesen
  End If
  
  For Each rgWert In rgWerte
    If Not mcoStatusBit.FindItem(rgWert.Style) Is Nothing Then
      If Not mcoStatusBit.FindItem(rgWert.Style).WerteIgnorieren And _
         IsNumeric(rgWert.value) Then
        If lAnz = 0 Then
          fMax = rgWert
        ElseIf fMax < rgWert Then
          fMax = rgWert
        End If
        lAnz = lAnz + 1
      End If
    End If
  Next rgWert
  If lAnz > 0 Then
    erMax = fMax
  Else
    erMax = ""
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Function erIntervallWithUnitToSec(ByVal lIntervall As Long, _
                                       ByVal iUnit As Integer) As Long
Attribute erIntervallWithUnitToSec.VB_ProcData.VB_Invoke_Func = " \n14"
  erIntervallWithUnitToSec = IntervallWithUnitToSec(lIntervall, iUnit)
End Function

'---------------------------------------------------------------------------------------------------
Public Function erHostName() As String
Attribute erHostName.VB_ProcData.VB_Invoke_Func = " \n14"
  erHostName = HostName
End Function

'---------------------------------------------------------------------------------------------------
Public Function erUserName() As String
Attribute erUserName.VB_ProcData.VB_Invoke_Func = " \n14"
  erUserName = Username
End Function

'---------------------------------------------------------------------------------------------------
Public Function erFormatPVSSTime(ByVal tSource As Date) As String
Attribute erFormatPVSSTime.VB_ProcData.VB_Invoke_Func = " \n14"
      
Dim d As Double
Dim lMilli  As Long
      
  d = tSource - CLng(tSource)
  lMilli = d * 86400000
  lMilli = lMilli Mod 1000
  erFormatPVSSTime = Format(tSource, "DD.MM.YYYY hh:mm:ss") & "." & Format(lMilli, "000")

End Function
Attribute VB_Name = "M_Konstanten"
'==================================================================================================
'M_Konstanten
'
'Oliver Seidel
'05.02.1999
'
'Zentrale Definition globaler Konstanten.
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

'Nuetzliche Konstanten, die MS vergessen hat
'Zeiteinheiten
Public Const erSekunde = 1
Public Const erMinute = 2
Public Const erStunde = 3
Public Const erTag = 4
Public Const erWoche = 5
Public Const erMonat = 6
Public Const erJahr = 7

'ArchivTyp
'  Beschreibt die Quelle der Daten und auch ob nur ein Wert oder
'  viele Werte in einem Zeitbereich abgefragt werden sollen
Public Const ARCHIVTYP_CALCULATE = 1    'Werte wird im Report berechnet
Public Const ARCHIVTYP_ONLINE = 2       'Online Werte vom Event
Public Const ARCHIVTYP_ACSINGLE = 3     'Ergebnis AC Typ (das Klassische)
Public Const ARCHIVTYP_ACPERIODE = 4    'Daten AC Typ (das Klassische)
Public Const ARCHIVTYP_HDBSINGLE = 5    'Ergebnis direkt aus der HDB
Public Const ARCHIVTYP_HDBPERIODE = 6   'Daten direkt aus der HDB
Public Const ARCHIVTYP_ODBCSINGLE = 7   'Event. Erweiterung
Public Const ARCHIVTYP_ODBCPERIODE = 8  'Event. Erweiterung
Public Const ARCHIVTYP_RDBSINGLE = 9    'Ergebnis direkt aus der RDB
Public Const ARCHIVTYP_RDBPERIODE = 10  'Daten direkt aus der RDB
Public Const ARCHIVTYP_RACSINGLE = 11   'Ergebnis RDB AC (mass para)
Public Const ARCHIVTYP_RACPERIODE = 12  'Daten RDB AC

' AchivMsg
' selection criteria for configuration import dialog
' the order of constants is important!
Public Const ARCHMSG_ALL_SYSTEMS = 5
Public Const ARCHMSG_THIS_SYSTEM = 4
Public Const ARCHMSG_YES = 3
Public Const ARCHMSG_NO = 2
Public Const ARCHMSG_CANCEL = 1
Public Const ARCHMSG_INIT = 0

' defines for combobox in DPEinfuegen
Public Const ARCHIVTYP_AC = 0           ' AC Para
Public Const ARCHIVTYP_HDB = 1          ' HDB direct
' Public Const ARCHIVTYP_ONLINE = 2       ' ONLINE (defined above!)
Public Const ARCHIVTYP_RDB = 3          ' RDB
Public Const ARCHIVTYP_RAC = 4          ' RDB AC

' Zaehler f|fffd|r die Eintraege im Tarifsatz
Public Const TARIFFCOUNT = 12

'AutoFormat
'  Automatisches Formatieren der Daten
Public Const AUTOFORMAT_NOFORMAT = 0
Public Const AUTOFORMAT_ONLYFORMAT = 1
Public Const AUTOFORMAT_FORMATUNIT = 2

'RequestType (Wie wurde das Protokoll ausgel|fffd|st?)
Public Const REQUESTTYPE_MAN = 0
Public Const REQUESTTYPE_TIME = 1
Public Const REQUESTTYPE_PVSS = 2
Public Const REQUESTTYPE_EVENT = 3

'Allgemeine Stati persistenter Objekte
'Public Const OBJEKT_STATUS_GESPEICHERT = 0
'Public Const OBJEKT_STATUS_NEU = 1
'Public Const OBJEKT_STATUS_GEAENDERT = 2
'Public Const OBJEKT_STATUS_GELOESCHT = 3

'Referenzen Tabelle TabKonfig aus Report.xls
'Public Const REF_PROJEKT = "A2"
Public Const TAB_KONFIG = "Konfiguration"
Public Const REF_DATEI_TYP = "B2"
Public Const REF_DATEI_BEZ = "B3"
Public Const REF_DATEI_VERSION = "B4"
Public Const REF_SEITENANSICHT = "B5"
Public Const REF_PROTOKOLL_TYP = "B6"
Public Const REF_STARTZEIT = "B7"
Public Const REF_STOPPZEIT = "B8"
Public Const REF_INTERVALL = "B9"
Public Const REF_INT_EINHEIT = "B10"
Public Const REF_PERIODE = "B11"
Public Const REF_PER_EINHEIT = "B12"
Public Const REF_PASSWORD = "B13"
Public Const REF_MIN_COLOR = "B14"
Public Const REF_MAX_COLOR = "B15"
Public Const REF_USER = "B16"
Public Const REF_USER_FULLNAME = "C16"
Public Const REF_REQUESTTYPE = "B17"
Public Const REF_LOGCHANGES = "B18"
Public Const REF_CREATION_DATE = "B19"
Public Const REF_LASTUPDATE = "C19"
Public Const REF_AREA_PERMISSIONS = "B20" ' IM 98626 Bereiche
Public Const REF_COSTCENTER_UNIT = "B21"  ' IM 98626 verschoben von B20
Public Const REF_COSTCENTER_TABLE = "B22"
Public Const REF_COSTCENTER_DIAGRAM = "B23"

'Public Const REF_REDU = "B5"
'Public Const REF_EMPFANG = "B6"
'Public Const REF_HOST_AKTIV = "B7"
'Public Const REF_HOSTNAME_1 = "B8"
'Public Const REF_PROJ_PFAD_1 = "B9"
'Public Const REF_DDE_1 = "B10"
'Public Const REF_HOSTNAME_2 = "B11"
'Public Const REF_PROJ_PFAD_2 = "B12"
'Public Const REF_DDE_2 = "B13"
'Public Const REF_PVSS_BEFEHL_TIME_OUT = "B14"
'Public Const REF_PVSS_RM_TIME_OUT = "B15"
'Public Const REF_FILTER_DP = "B16"
'Public Const REF_AUSWAHL = "B17"
'Public Const REF_SPRACHE = "B18"
'Public Const REF_CONFIG_1 = "B19"
'Public Const REF_DDE_BEFEHL = "B25"

'Public Const REF_PROT_FORMAT = "D2"
'Public Const REF_BASISWERT = "F2"
'Public Const REF_PROT_TYP = "T2"
'Public Const REF_STATUS_BIT = "AA2"
'Public Const REF_PROT_ANWAHL = "BM2"

'Konstanten fuer die Vorlagen und Protkolle
'in der Tabelle Konfig
Public Const REF_BTR_WERTSPALTE = 11
Public Const REF_PROT_PROTTYPEN = "E1"
Public Const REF_PROT_DPT = "F1"
Public Const REF_PROT_DPL = "M1"
Public Const REF_PROT_KOPF_FUSS_ZEILEN = "A31"
Public Const REF_PROT_TAB_BEREICH = "H1"

'Public Const DPT_HVT_PROT = "EMW"

'Dateitypen
Public Const DATEI_VORLAGE = "Vorlage"
Public Const DATEI_PROTOKOLL = "Protokoll"
Public Const DATEI_PROJEKT = "Projektdatei"
'ICSGEAD
Public Const DATEI_STD_VORLAGE = "StdTemplate.xltm"
Public Const DATEI_BTR_VORLAGE = "OprTemplate.xltm"
Public Const DATEI_ATV_VORLAGE = "ATVTemplate.xltm"
Public Const DATEI_SQL_VORLAGE = "SQLTemplate.xltm"
Public Const DATEI_KST_VORLAGE = "CstTemplate.xltm"

'Verzeichnisse
Public Const VERZ_VORLAGE = "Template"
Public Const VERZ_PROTOKOLL = "Report"

'Allgemeine Texte
Public Const TXT_STAT_FKT_BERECHNEN = 21206
Public Const TXT_STAT_FKT_ABFRAGEN = 21207
Public Const TXT_AUTOFORMAT_NOFORMAT = 21210
Public Const TXT_AUTOFORMAT_ONLYFORMAT = 21211
Public Const TXT_AUTOFORMAT_FORMATUNIT = 21212

'Benannte Konstanten
'Protokollformate
Public Const BEZ_STD_PROTOKOLL = "Standardprotokoll"
Public Const BEZ_BTR_PROTOKOLL = "Betriebsprotokoll"
Public Const BEZ_ATV_PROTOKOLL = "ATV Protokoll"
Public Const BEZ_SQL_PROTOKOLL = "SQL_Abfrage"
Public Const BEZ_KST_PROTOKOLL = "Kostenstellenprotokoll"
'Public Const BEZ_HVT_PROTOKOLL = "Haeufigkeitsverteilung"
'Public Const BEZ_ERG_PROTOKOLL = "Ereignisprotokoll"
'Public Const BEZ_FREI_PROTOKOLL = "Freies Protokoll"

'RequestType (Wie wurde das Protokoll ausgel|fffd|st?)
Public Const TXT_REQUESTTYPE_MAN = "Manual"
Public Const TXT_REQUESTTYPE_TIME = "Schedule"
Public Const TXT_REQUESTTYPE_PVSS = "PVSS"
Public Const TXT_REQUESTTYPE_EVENT = "Event"

'Diverse Texte
Public Const PWD_FILE = "Report"
Public Const DEFAULT_CONFIG = "(Default)"

Public Const VAR_REPORTTYP = "[Reporttype]"
Public Const VAR_VON = "[From]"
Public Const VAR_VONDATUM = "[From Date]"
Public Const VAR_VONZEIT = "[From Time]"
Public Const VAR_BIS = "[To]"
Public Const VAR_BISDATUM = "[To Date]"
Public Const VAR_BISZEIT = "[To Time]"
Public Const VAR_INTERVALL = "[Interval]"
Public Const VAR_ZEITRAUM = "[Period]"
Public Const VAR_ZEILEN = "[Rows]"
Public Const VAR_EINSTELLUNGEN = "Adjustment"
Public Const VAR_KOPFZEILE = "Header"
Public Const VAR_DATENBEREICH = "Data"
Public Const VAR_FUSSZEILE = "Footer"
Public Const VAR_SEITENENDE = "Page End"

' functions, see table tabFunktion
Public Const VAR_MIN = "Min"
Public Const VAR_MAX = "Max"
Public Const VAR_MIN_ZEIT = "MinTime"
Public Const VAR_MAX_ZEIT = "MaxTime"
Public Const VAR_ANZAHL = "Number"
Public Const VAR_SUMME = "Sum"
Public Const VAR_INTG0 = "Integral0"
Public Const VAR_INTG1 = "Integral1"
Public Const VAR_SUM_ANZ = "SumNumber"
Public Const VAR_MITTEL = "Average"
Public Const VAR_MITTEL1 = "Average1"
Public Const VAR_TIME0 = "Time0"
Public Const VAR_TIME1 = "Time1"
Public Const VAR_WECHSEL = "Changes"
Public Const VAR_WECHSEL01 = "Changes01"
Public Const VAR_WECHSEL10 = "Changes10"
Public Const VAR_BEGIN = "StartValue"
Public Const VAR_END = "EndValue"
Public Const VAR_DIFF = "Difference"
Public Const VAR_RESERVE = "Reserve"
Public Const VAR_MAN = "ManualInput"
Public Const VAR_DIFF_ABS = "DiffAbsolut"
'Public Const VAR_LETZTWERT = "LastValue"
'Public Const VAR_TEXT = "Text"

Public Const TXT_ZEIT_EINHEIT_BEGINN = 21560 - 1
Public Const TXT_ZEIT_EINHEIT_ANZ = 7
Public Const TXT_WOCHENTAG_BEGINN = 21570 - 1

'Fehlerdefinition
Public Const ERR_BASIS = 30000

'Fehler - Abbruch der Bearbeitung (durch Benutzer oder interner Logig)
Public Const ERR_BENUTZER_ABBRUCH = ERR_BASIS + 9

'Fehler - Intern, FrameWork - weitere Bearbeitung nicht moeglich
Public Const ERR_INTERN_DB = ERR_BASIS + 10
Public Const ERR_INTERN = ERR_BASIS + 11

'Fehler - Vorlagen
Public Const ERR_VORLAGE_ERSTELLEN = ERR_BASIS + 100
Public Const ERR_VORLAGE_KONFIGURIEREN = ERR_BASIS + 101
Public Const ERR_VORLAGE_VERSION_PRUEFEN = ERR_BASIS + 102
Public Const ERR_VORLAGE_SPEICHERN = ERR_BASIS + 103
Public Const ERR_VORLAGE_ANALYSIEREN = ERR_BASIS + 104
Public Const ERR_VORLAGE_DP_EINFUEGEN = ERR_BASIS + 105
Public Const ERR_VORLAGE_DP_AeNDERN = ERR_BASIS + 106
Public Const ERR_VORLAGE_BLATT_EINFUEGEN = ERR_BASIS + 107
Public Const ERR_VORLAGE_BLATT_LOeSCHEN = ERR_BASIS + 108
Public Const ERR_VORLAGE_BLATT_NAMEN = ERR_BASIS + 109
Public Const ERR_VORLAGE_DP_FKT_ERMITTELN = ERR_BASIS + 110

'Fehler - Protokolle
Public Const ERR_PROT_NEU = ERR_BASIS + 200
Public Const ERR_PROT_ERSTELLEN = ERR_BASIS + 201
Public Const ERR_PROT_SEITE_EINRICHTEN = ERR_BASIS + 202
Public Const ERR_PROT_VERSION_PRUEFEN = ERR_BASIS + 203
Public Const ERR_PROT_KOPF_FUSS = ERR_BASIS + 204
Public Const ERR_PROT_KONFIG = ERR_BASIS + 205
Public Const ERR_PROT_UNLOCK = ERR_BASIS + 206

'M_PVSS
Public Const ERR_PVSS_DP_SET = ERR_BASIS + 500
Public Const ERR_PVSS_DP_GET = ERR_BASIS + 501
Public Const ERR_PVSS_POLLING = ERR_BASIS + 502
Public Const ERR_PVSS_PVSS_SPERREN = ERR_BASIS + 503
Public Const ERR_PVSS_PVSS_FREIGEBEN = ERR_BASIS + 504
Public Const ERR_PVSS_BEFEHL_SENDEN = ERR_BASIS + 505
Public Const ERR_PVSS_RM_SENDEN = ERR_BASIS + 506
Public Const ERR_PVSS_DP_LISTE = ERR_BASIS + 507
Public Const ERR_PVSS_DP_LISTE_ABFRAGEN = ERR_BASIS + 508
Public Const ERR_PVSS_DP_LISTE_EINLESEN = ERR_BASIS + 509
Public Const ERR_PVSS_DP_WERT = ERR_BASIS + 510
Public Const ERR_PVSS_DP_WERT_ABFRAGEN = ERR_BASIS + 511
Public Const ERR_PVSS_DP_WERT_EINLESEN = ERR_BASIS + 512
Public Const ERR_PVSS_PROTOKOLL_ERSTELLEN = ERR_BASIS + 513
Public Const ERR_PVSS_PROTOKOLL_EINLESEN = ERR_BASIS + 514
Public Const ERR_PVSS_TELEGRAMM_AUSWERTEN = ERR_BASIS + 515
Public Const ERR_PVSS_FEHLER_CODE_SENDEN = ERR_BASIS + 516
Public Const ERR_PVSS_INIT = ERR_BASIS + 517
Public Const ERR_PVSS_FEHLER = ERR_BASIS + 518
Public Const ERR_PVSS_NOLICENSE = ERR_BASIS + 519
' 520 scheint belegt zu sein IM 79800 WOKL 24.5.07 ("Datensatz kann nicht importiert werden")
Public Const ERR_PVSS_QUERY_ABORTED = ERR_BASIS + 521
Public Const ERR_PVSS_AREA_PERMISSION = ERR_BASIS + 522

' Globale Einstellungen, die in M_PVSS.PVSSinit gesetzt werden und ab da fix sind
' Erweiterungen fuer PVSSLogin IM 98626 WOKL: 20.4.2010
Public MAX_SYSNO As Long        ' H|fffd|chste zul|fffd|ssige Systemnummer (3.8.1: 256!)
Public MY_MAN_NUM As Long       ' aktuelle Managernummer
Public MY_REPORT_DP As String   ' aktueller interner DP in PVSS (Typ: _Report)
Public Const MY_REPORT_DPTYPE = "_Report"  ' interner DPTyp
Public IS_RDBACTIVE As Boolean    ' configuration from data internal dp

' Parametrierung der Berechtigungspr|fffd|fung
' Menue Vorlage:
Public Const PL_TMPL_CHANGE = 1
' Menue Report:
Public Const PL_RPT_TMPL_UPDATE = 2
Public Const PL_RPT_QUICK_SEL = 3
Public Const PL_RPT_SCHEDULE = 4
Public Const PL_RPT_MAILINGLIST = 5
Public Const PL_RPT_CONFIGURATION = 0  '
Public Const PL_RPTCFG_PASSWORD = 0
Public Const PL_RPTCFG_CHGPWD = 0
Public Const PL_RPTCFG_OPTIONS = 6
Public Const PL_RPTCFG_ARCH_STRUCT = 7
Public Const PL_RPTCFG_BASIC_VAL = 8
Public Const PL_RPTCFG_REPORT_TYPES = 8
Public Const PL_RPTCFG_STATUSBIT = 8
Public Const PL_RPTCFG_TARIFFSET = 9
Public Const PL_RPTCFG_COST_CENTER = 9
Public Const PL_RPTCFG_MEDIA = 9

' Bereichsberechtigungen - funktionsId
Public Const PL_AREA_PROT_NEW = 1
Public Const PL_AREA_PROT_CHANGE = 2

        
'ICSGEAD IM 115373 1 - 6 not used
Public Const DPINSERT_MODUS_STD_INSERT As Integer = 1
Public Const DPINSERT_MODUS_STD_CHANGE As Integer = 2
Public Const DPINSERT_MODUS_ATV_INSERT As Integer = 3
Public Const DPINSERT_MODUS_ATV_CHANGE As Integer = 4
Public Const DPINSERT_MODUS_BTR_INSERT As Integer = 5
Public Const DPINSERT_MODUS_BTR_CHANGE As Integer = 6
Public Const DPINSERT_MODUS_KST_INSERT As Integer = 7
Public Const DPINSERT_MODUS_KST_CHANGE As Integer = 8

Public Const DPINSERT_MODUS_DL_INSERT As Integer = 101
Public Const DPINSERT_MODUS_DL_CHANGE As Integer = 102
Public Const DPINSERT_MODUS_CV_INSERT As Integer = 103
Public Const DPINSERT_MODUS_CV_CHANGE As Integer = 104
Public Const DPINSERT_MODUS_CR_INSERT As Integer = 105
Public Const DPINSERT_MODUS_CR_CHANGE As Integer = 106

Public Const ID_PROTTYP_CLASS_GEN = 0
Public Const ID_PROTTYP_CLASS_CL = 1
Public Const ID_PROTTYP_CLASS_CR = 2
Public Const ID_PROTTYP_CLASS_CV = 2
Public Const TEXT_ERROR_INSERTDP_EMPTY_DIVISOR = 35106
Public Const TEXT_WARNING_TITLE = 20103
        

Attribute VB_Name = "M_KstProt"
'==================================================================================================
'M_KstProt
'
'Wolfram Klebel
'15.7.09
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

Private Const REF_KOPF_FUSS_ZEILEN = "A11"
Private Const REF_STD_PROT_TYPEN = "E1"
Private Const REF_STD_DPT = "F1"
Private Const REF_STD_DPL = "M1"

'--------------------------------------------------------------------------------------------------
Public Sub WerteEintragen(wsProt As Worksheet, oDP As C_DP, oDPRef As C_DPReferenz, lDatenAnz As Long)

Dim iWertId As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long
Dim lMinColor As Long
Dim lMaxColor As Long

  On Error Resume Next
  lMinColor = getMinColor(wsProt.Parent)
  lMaxColor = getMaxColor(wsProt.Parent)
  If oDPRef.TabBereich.Bereich = VAR_DATENBEREICH Then
  
    'Zeitpunkt Offset eintragen
    wsProt.Cells(16, oDPRef.Spalte) = oDP.Von
    
    For iWertId = 1 To oDP.coDPWert.Count
      'Bei Vergleichen (Offset) koennen zu viele Daten vorhanden sein
      If iWertId > lDatenAnz Then Exit For
      Call oDP.setRange( _
                   wsProt.Cells(oDPRef.TabBereich.Zeile + iWertId, oDPRef.Spalte), _
                   iWertId, lMinColor, lMaxColor)
    Next iWertId
    
    wsProt.Cells(6, oDPRef.Spalte) = oDP.Kommentar
    wsProt.Cells(7, oDPRef.Spalte) = oDP.Alias
    wsProt.Cells(8, oDPRef.Spalte) = oDP.Format
    wsProt.Cells(9, oDPRef.Spalte) = oDP.Einheit
  
  Else
    Call oDP.setRange( _
                 wsProt.Cells(oDPRef.TabBereich.Zeile, oDPRef.Spalte), _
                 0, lMinColor, lMaxColor, _
                 oDPRef.TabBereich.Bereich)
  End If

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub SeiteEinrichten(oProtokoll As C_Protokoll, wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim oTabBereich   As C_TabBereich
Dim oBereichKopf  As C_TabBereich
Dim oBereichDaten As C_TabBereich
Dim oBereichFuss   As C_TabBereich
Dim oBereichEnde  As C_TabBereich

Dim rgStart As Range
Dim rgEnde  As Range
Dim rgSuche As Range

Dim boSpalteAEingeblendet As Boolean

Dim rgDatenStart  As Range
Dim rgDatenEnde   As Range
Dim iDatenAnz     As Integer
Dim iDatenZeile   As Integer
Dim dtZeit        As Date
Dim lwsProtID     As Long

Dim fStatus   As Single
Dim lStatusId As Long
Dim boErsterFehler As Boolean

  On Error GoTo M_STDProt_SeiteEinrichten_Fehler

  ReDim audZeile(0)
  lStatusId = StatusTextAusgeben("")
     
  Call StatusTextAusgeben(wsProt.Name & " einrichten ", lStatusId)
  
'Call ZeitMessung(True)
    
  lwsProtID = wsProt.index
  wsProt.EnableCalculation = False
  
  Set oBereichKopf = coTabBereich.FindItem(lwsProtID, VAR_KOPFZEILE)
  Set oBereichDaten = coTabBereich.FindItem(lwsProtID, VAR_DATENBEREICH)
  Set oBereichFuss = coTabBereich.FindItem(lwsProtID, VAR_FUSSZEILE)
  Set oBereichEnde = coTabBereich.FindItem(lwsProtID, VAR_SEITENENDE)
  If (oBereichFuss Is Nothing) Then     ' IM 72165 bei alten Templates? WOKL 2.11.06
    Set oBereichFuss = oBereichEnde
  End If

  wsProt.Range(wsProt.Cells(1, 1), wsProt.Cells(oBereichKopf.Zeile, 1)).EntireRow.hidden = True
  wsProt.Cells(oBereichDaten.Zeile, 1).EntireRow.hidden = True
  wsProt.Cells(oBereichFuss.Zeile, 1).EntireRow.hidden = True
  
  On Error Resume Next
  wsProt.Range(wsProt.Cells(oBereichEnde.Zeile, 1), wsProt.Cells(65536, 1)).EntireRow.hidden = True
  On Error GoTo M_STDProt_SeiteEinrichten_Fehler
  
  Set rgDatenStart = wsProt.Cells(oBereichDaten.Zeile + 1, 1)
  Set rgStart = rgDatenStart
  Set rgDatenEnde = wsProt.Cells(oBereichFuss.Zeile - 1, 1)
  
  iDatenZeile = rgDatenEnde.Row - rgDatenStart.Row + 1
  iDatenAnz = oProtokoll.ZeitpunktAnz
  
  For Each oTabBereich In coTabBereich.Items
    With oTabBereich
      If .Blatt = lwsProtID And _
         .Zeile > oBereichDaten.Zeile Then
       .Zeile = .Zeile + iDatenAnz - iDatenZeile
      End If
    End With
  Next oTabBereich
  
  Do Until iDatenZeile >= iDatenAnz

    fStatus = Aufrunden(iDatenZeile / iDatenAnz * 100)
    Call StatusTextAusgeben(wsProt.Name & " einrichten " & fStatus & "%", lStatusId)

    If (iDatenZeile <= (iDatenAnz / 2)) Then
      Range(rgDatenStart, rgDatenEnde).EntireRow.Copy 'rgDatenEnde.Offset(1, 0)
      rgDatenEnde.Offset(1, 0).Insert
      iDatenZeile = iDatenZeile * 2
      Set rgDatenEnde = rgDatenStart.Offset(iDatenZeile - 1, 0)
    Else
      Set rgDatenEnde = rgDatenStart.Offset(iDatenAnz - iDatenZeile - 1, 0)
      Range(rgDatenStart, rgDatenEnde).EntireRow.Copy 'rgDatenStart.Offset(iDatenZeile, 0)
      rgDatenStart.Offset(iDatenZeile, 0).Insert
      Set rgDatenEnde = rgDatenStart.Offset(iDatenAnz - 1, 0)
      iDatenZeile = iDatenAnz
    End If
  Loop
  
  If iDatenZeile > iDatenAnz Then
    Range(rgDatenStart.Offset(iDatenZeile - 1, 0), rgDatenStart.Offset(iDatenAnz, 0)).EntireRow.Delete
  End If
  
  For iDatenZeile = 1 To iDatenAnz

    fStatus = Aufrunden(iDatenZeile / iDatenAnz * 100)
    Call StatusTextAusgeben(wsProt.Name & " " & GetResText(21304) & "" & fStatus & "%", lStatusId)

    dtZeit = oProtokoll.Zeitpunkt(iDatenZeile - 1)
    rgDatenStart.Offset(iDatenZeile - 1, 0) = dtZeit
  Next iDatenZeile
  
  'wsProt.Range("A1").Select
  
'Call ZeitMessung(False, "M_ATVProt::SeiteEinrichten " + wsProt.Name)
  
  Call StatusTextLoeschen(lStatusId)
  
Exit Sub
M_STDProt_SeiteEinrichten_Fehler:
  boErsterFehler = (Err.Number < ERR_BASIS)
  'Call StatusTextLoeschen(lStatusID)
  Call FehlerAusloesen(ERR_PROT_SEITE_EINRICHTEN, , boErsterFehler)
End Sub


Attribute VB_Name = "M_KstProtCalculation"
'Attribute VB_Name = "mEnergyCCReport"
' _________________________________________________________________
'
'   Projekt:    PCS 7 Powerrate
'   Copyright (c) Siemens AG 2008. All rights reserved. Confidential.
' _________________________________________________________________
'
'   Modul:              mEnergyCCReport.bas
'
'   Autor:              Ralf Leistner /A&D SE DE21
'                       adaptiert Wolfram Klebel / ETM pc gesmbH
'   Datum:              28.10.2008
'                       22.7.2009
'   Version:            V 1.00
' _________________________________________________________________
'
'   Funktion:           Make cost center report from raw data
' ________________________________________________________________________
'
'   Aenderungshistorie:
'
'   Autor:
'   Datum:
'   Version:
'   Funktion:
'
'--------------------------------------------------------------------
Option Explicit

Option Compare Text

'**********************************************************
'                Definition von Konstanten
'**********************************************************
Private Const c_ModulName = "mEnergyCCReport"
Public Sub PrepareCCReport(ByRef oProtokoll As C_Protokoll, ByRef coTabBereich As CO_TabBereich, RawDataSheet As Worksheet, coDP As CO_DP)

Dim XLSRawDataWorksheet As Worksheet
Dim XLSDerivedDataWorksheet As Worksheet
Dim XLSConsumptionWorksheet As Worksheet
Dim XLSChartWorksheet As Worksheet
Dim lStatusId As Long
Dim wsPosition As String
Dim sArray() As String

  'Set XLSRawDataWorksheet = XLSWorkbook.Sheets(RAW_DATA_SHEET_INDEX)
  'XLSRawDataWorksheet.Name = myLoadResString(DCT_SHEETNAME_RAWDATA)
  'Set XLSDerivedDataWorksheet = XLSWorkbook.Sheets(DERIVED_DATA_SHEET_INDEX)
  'XLSDerivedDataWorksheet.Name = myLoadResString(DCT_SHEETNAME_DERIVEDDATA)
  
  'Set XLSConsumptionWorksheet = ActiveWorkbook.Sheets(CONSUMPTION_SHEET_INDEX)
  ' IM 100116
  wsPosition = oProtokoll.wbProtokoll.Worksheets("Konfiguration").Range(REF_COSTCENTER_TABLE).Value2
  sArray = Split(wsPosition, "/")
  Set XLSConsumptionWorksheet = ActiveWorkbook.Sheets(CInt(sArray(0)))
  XLSConsumptionWorksheet.Name = myLoadResString(DCT_SHEETNAME_COCE_TABLE)
  
  'Set XLSChartWorksheet = ActiveWorkbook.Sheets(CHART_SHEET_INDEX)
  wsPosition = oProtokoll.wbProtokoll.Worksheets("Konfiguration").Range(REF_COSTCENTER_DIAGRAM).Value2
  sArray = Split(wsPosition, "/")
  Set XLSChartWorksheet = ActiveWorkbook.Sheets(CInt(sArray(0)))
  XLSChartWorksheet.Name = myLoadResString(DCT_SHEETNAME_COCE_DIAGRAM)

  lStatusId = StatusTextAusgeben("Calculate cost center data")
  Call Make_CCReport(RawDataSheet, XLSConsumptionWorksheet, XLSChartWorksheet, oProtokoll, coTabBereich, coDP, True)
  Call StatusTextLoeschen(lStatusId)

End Sub

'**********************************************************
'                Make cost center report
'**********************************************************
Public Sub Make_CCReport(ByRef RawDataSheet As Worksheet, _
                         ByRef ConsumtionSheet As Worksheet, ByRef ChartSheet As Worksheet, _
                         ByRef oProtokoll As C_Protokoll, ByRef coTabBereich As CO_TabBereich, _
                         ByRef coDP As CO_DP, _
                         ByVal Auto_Report As Boolean, Optional ByRef ProgresForm As Object)
                         'ByRef Tariffset As C_Tariffset, ByRef selReport As clsReport,
'OS: added new block: calculate/write consumption/cost
Dim blnCalculated As Boolean
Dim dblConsumption As Double, dblCosts As Double
Dim i As Long
Dim rowIndex As Integer
Dim mediaCol As Integer

Dim oTs As C_Tariffset
Dim oDPRef As C_DPReferenz
Dim coCostCenter As CO_CostCenter
Dim oCostCenter As C_CostCenter
Dim coMedia As CO_Media
Dim oMedium As C_Medium
Dim rawData As Range
Dim oBereichDaten As C_TabBereich
Dim oBereichFuss As C_TabBereich
Dim dblHelp As Double
Dim mediaSum As Range
Dim sumCell As Range

  On Error GoTo errorHandler
  
  Set coCostCenter = New CO_CostCenter
  Set coMedia = New CO_Media
  On Error Resume Next      ' no duplicate entries in cost center and media lists
  For Each oDPRef In coDP.RefItems
    If oDPRef.CostCenter <> "" Then
      Set oCostCenter = M_CostCenter.coLesen.FindItem(oDPRef.CostCenter)
      If (Not oCostCenter Is Nothing) Then
        Call coCostCenter.Add(oCostCenter)
      Else        ' Kostenstelle nicht gefunden
        Call MsgBox(GetResText(22001) & Chr$(10) & oDPRef.CostCenter, vbCritical + vbOKOnly, GetResText(20104))
        GoTo errorHandler
      End If
      
      Set oMedium = M_Media.coLesen.FindItem(oDPRef.CCMedium)
      If (Not oMedium Is Nothing) Then
        Call coMedia.Add(oMedium)   ' unique list
      Else        ' no medium found
        Call MsgBox(GetResText(22002) & Chr$(10) & oDPRef.CCMedium, vbCritical + vbOKOnly, GetResText(20104))
        GoTo errorHandler
      End If
      
      For Each oTs In oCostCenter.coTariffsets.Items
        If (oMedium.Name = oTs.Medium.Name) Then
          Exit For
        End If
      Next oTs
      If (oTs Is Nothing) Then    ' no tariffset found
        Call MsgBox(GetResText(22005) & Chr$(10) & coDP.Items(oDPRef.index).dp & " (" & oCostCenter.Bezeichnung & " / " & oMedium.Name & ")", _
          vbCritical + vbOKOnly, GetResText(20104))
        GoTo errorHandler
      End If
    End If
  Next oDPRef
  On Error GoTo errorHandler
  
  If (coCostCenter.Count < 1) Then
    Call MsgBox(GetResText(22003), vbCritical + vbOKOnly, GetResText(20104))    ' Keine Kostenstelle gefunden
    GoTo errorHandler
  End If
  If (coMedia.Count < 1) Then
    Call MsgBox(GetResText(22004), vbCritical + vbOKOnly, GetResText(20104))        ' kein Medium gefunden
    GoTo errorHandler
  End If
  
  Set oBereichDaten = coTabBereich.FindItem(2, VAR_DATENBEREICH)
  Set oBereichFuss = coTabBereich.FindItem(RawDataSheet.index, VAR_FUSSZEILE)
  
  rowIndex = 10
  
  For Each oCostCenter In coCostCenter.Items
    rowIndex = rowIndex + 1
    mediaCol = 3
    
    For Each oMedium In coMedia.Items
      mediaCol = mediaCol + 3
      
      ' find out tariffset, then leave loop
      For Each oTs In oCostCenter.coTariffsets.Items
        If (oMedium.Name = oTs.Medium.Name) Then
          Exit For
        End If
      Next oTs
      
      If (Not oTs Is Nothing) Then
        ConsumtionSheet.Cells(10, 2).Value2 = GetResText(1637)    ' "Kostenstelle"
        ConsumtionSheet.Cells(10, 4).Value2 = GetResText(1642) & " [" & oTs.CurrName & "]" ' Gesamtkosten
      
        ConsumtionSheet.Cells(9, mediaCol).Value2 = oMedium.Name
        ConsumtionSheet.Cells(10, mediaCol).Value2 = GetResText(1643) & "[" & oMedium.unit & "]"  ' Verbrauch
        ConsumtionSheet.Cells(10, mediaCol + 1).Value2 = GetResText(1636) & " [" & oTs.CurrName & "]"  ' Kosten
        ConsumtionSheet.Rows(9).Font.Bold = True
        ConsumtionSheet.Rows(10).Font.Bold = True
        
        For Each oDPRef In coDP.RefItems
          If (oDPRef.CostCenter = oCostCenter.Bezeichnung And _
              oDPRef.CCMedium = oMedium.Name) Then
              
            'calculate consumption
            Set rawData = Range(RawDataSheet.Cells(oBereichDaten.Zeile, oDPRef.Spalte), _
                                RawDataSheet.Cells(oBereichFuss.Zeile, oDPRef.Spalte))
            ' rawData.Address
            dblHelp = oDPRef.CCWeighting * WorksheetFunction.Sum(rawData) ' IM 99845
            dblConsumption = dblConsumption + (dblHelp / oDPRef.CCUnitFactor)
            RawDataSheet.Cells(oBereichFuss.Zeile + 1, oDPRef.Spalte).Value2 = dblHelp
            
            'calculate costs
            dblHelp = oDPRef.CCWeighting * CalcCosts(rawData, oTs) / oDPRef.CCUnitFactor
            dblCosts = dblCosts + dblHelp
            RawDataSheet.Cells(oBereichFuss.Zeile + 2, oDPRef.Spalte).Value2 = dblHelp
            
            blnCalculated = True 'tag of cost center was calculated
          End If
          
        Next oDPRef
        If blnCalculated Then 'write consumption/costs
            ConsumtionSheet.Cells(rowIndex, mediaCol).Value2 = dblConsumption
            ConsumtionSheet.Cells(rowIndex, mediaCol + 1).Value2 = dblCosts
            ConsumtionSheet.Rows(rowIndex).NumberFormat = myLoadResString(DCT_FORMAT_NUMBER)
            blnCalculated = False
        End If
      End If  ' no Tariffset found
      
      'reset calculations
      dblConsumption = 0
      dblCosts = 0
    
    Next oMedium
    
    ' cost center summary
    Set mediaSum = ConsumtionSheet.Cells(rowIndex, 7)
    For i = 7 To mediaCol + 1 Step 3   'calculation
      Set mediaSum = Union(mediaSum, ConsumtionSheet.Cells(rowIndex, i))
    Next i
    
    ConsumtionSheet.Cells(rowIndex, 4).FormulaLocal = WorksheetFunction.Sum(mediaSum)
    ConsumtionSheet.Cells(rowIndex, 2).Value2 = oCostCenter.Bezeichnung

  Next oCostCenter
  
  ' total summary line
  For i = 4 To mediaCol + 1
    Set sumCell = ConsumtionSheet.Cells(11, i)
    If (IsEmpty(ConsumtionSheet.Cells(10, i))) Then
      ConsumtionSheet.Columns(i).ColumnWidth = 1
    Else
      Set sumCell = Range(ConsumtionSheet.Cells(11, i), _
                          ConsumtionSheet.Cells(rowIndex, i))
      ConsumtionSheet.Cells(rowIndex + 3, i).FormulaLocal = WorksheetFunction.Sum(sumCell)
      ConsumtionSheet.Rows(rowIndex + 3).NumberFormat = myLoadResString(DCT_FORMAT_NUMBER)
      ConsumtionSheet.Columns(i).EntireColumn.AutoFit
    End If
  Next i
  ConsumtionSheet.Cells(rowIndex + 3, 2).Value2 = GetResText(1616)  ' "Gesamt"
  ConsumtionSheet.Rows(rowIndex + 3).Font.Bold = True

  'write consumption time settings
  ConsumtionSheet.Range(POS_COCE_REPORTNAME).value = myLoadResString(DCT_REPORTTYPE_CCREPORT)
  ConsumtionSheet.Range(POS_TIME_START_VAL).value = oProtokoll.Von
  ConsumtionSheet.Range(POS_TIME_START_VAL).NumberFormat = myLoadResString(DCT_FORMAT_DATETIME)
  ConsumtionSheet.Range(POS_TIME_END_VAL).value = oProtokoll.Bis
  ConsumtionSheet.Range(POS_TIME_END_VAL).NumberFormat = myLoadResString(DCT_FORMAT_DATETIME)
  ConsumtionSheet.Range(POS_TIME_COCE).value = myLoadResString(DCT_COSTCENTER)
  ConsumtionSheet.Range(POS_TIME_SETTING).value = myLoadResString(DCT_TIMESETTINGS)
  ConsumtionSheet.Range(POS_TIME_START_STR).value = myLoadResString(DCT_STARTTIME)
  ConsumtionSheet.Range(POS_TIME_END_STR).value = myLoadResString(DCT_ENDTIME)
  
  'write chart time settings
  ChartSheet.Range(POS_COCE_REPORTNAME).value = myLoadResString(DCT_REPORTTYPE_CCREPORT)
  ChartSheet.Range(POS_TIME_START_VAL).value = oProtokoll.Von
  ChartSheet.Range(POS_TIME_START_VAL).NumberFormat = myLoadResString(DCT_FORMAT_DATETIME)
  ChartSheet.Range(POS_TIME_END_VAL).value = oProtokoll.Bis
  ChartSheet.Range(POS_TIME_END_VAL).NumberFormat = myLoadResString(DCT_FORMAT_DATETIME)
  ChartSheet.Range(POS_TIME_SETTING).value = myLoadResString(DCT_TIMESETTINGS)
  ChartSheet.Range(POS_TIME_START_STR).value = myLoadResString(DCT_STARTTIME)
  ChartSheet.Range(POS_TIME_END_STR).value = myLoadResString(DCT_ENDTIME)
    
  If Auto_Report = False Then
      Call UpdateAllCharts(ConsumtionSheet, ChartSheet, Auto_Report, ProgresForm)
  Else
      Call UpdateAllCharts(ConsumtionSheet, ChartSheet, Auto_Report)
  End If
  ChartSheet.Cells(1, 1).Select 'IM 115373 BK 20110504 AP1163961 Default selection on Chartsheept due to Printing issue

Exit Sub
errorHandler:
  'MsgBox (Err.Description)
  ' Stop
  Dim boErsterFehler As Boolean
  boErsterFehler = (Err.Number < ERR_BASIS)
  Call FehlerAusloesen(ERR_PROT_SEITE_EINRICHTEN, , boErsterFehler)
End Sub

Function FindEntry(ByRef oTs As C_Tariffset, tempTimeStamp As Date) As C_TariffsetEntry

  Dim oTsEntry As C_TariffsetEntry
  
  For Each oTsEntry In oTs.tsEntry.Items  ' try to find one with fitting time
    If ((oTsEntry.ValidFrom <= tempTimeStamp And _
         oTsEntry.ValidUntil >= tempTimeStamp) And _
         oTsEntry.Name <> "Default") Then
      Exit For
    End If
  Next oTsEntry
  If (oTsEntry Is Nothing) Then
    Set oTsEntry = oTs.tsEntry.FindItem("Default")  ' that must exist
  End If
  
  Set FindEntry = oTsEntry
      
End Function

'Autor: Siemens A&D SE SH 6 / ETM
'CreateDate: 6.09.2007
'Purpose: calculates the costs of one normal tag with tariffs from tariffset
'Requirements:
'Version: PowerReport 3.0
'Status: in progress
'ChangeLog: WOKL 7.12.10
Private Function CalcCosts(ByRef rawData As Range, _
                           ByRef oTs As C_Tariffset) As Double
Dim dtmHoliday As Date
Dim tempTimeStamp As Date
Dim dblCosts As Double
Dim blnHolFound As Boolean
Dim i As Integer
Dim myCell As Range
Dim oTsEntry As C_TariffsetEntry
Dim dayIndex As Integer
    
  On Error GoTo errorHandler
  
  'init  costs
  dblCosts = 0
  For Each myCell In rawData
    If myCell.value <> Empty Then
      tempTimeStamp = CDate(myCell.Offset(0, 1 - myCell.Column).value) 'get time stamp
      ' WOKL 19.8.09: hier wird (wurde) eine Sekunde abgezogen ....
      ' tempTimeStamp = DateAdd("s", -1, tempTimeStamp)

      
      Set oTsEntry = FindEntry(oTs, tempTimeStamp)  ' at least the default entry must exist
      With oTsEntry

        '*************************************************************************************************
        'check if day is a holiday
        blnHolFound = False
        If oTs.Holidays.Count <> 0 Then
          For i = 1 To oTs.Holidays.Count
            dtmHoliday = CDate(oTs.Holidays.Item(i))
            If (Year(tempTimeStamp) = Year(dtmHoliday)) And _
               (Month(tempTimeStamp) = Month(dtmHoliday)) And _
               (Day(tempTimeStamp) = Day(dtmHoliday)) Then
              blnHolFound = True              'tempTimeStamp is a holiday
              Exit For
            End If
          Next
        End If
        
        If blnHolFound Then
          dayIndex = 8
        Else
          dayIndex = weekday(tempTimeStamp) - 1
          If (dayIndex = 0) Then dayIndex = 7 'sunday
        End If
        
        For i = 1 To TARIFFCOUNT
          If .TariffOn(i, dayIndex) = True Then
            If CheckIfTarifIsApplicable(myCell, dblCosts, _
              .TariffStart(i), .TariffEnd(i), tempTimeStamp, .TariffCost(i)) = True Then GoTo NextForLoop
          End If
        Next i
      End With
    End If
                
NextForLoop:
  Next myCell
  CalcCosts = dblCosts

Exit Function
errorHandler:
  MsgBox (Err.Description)
  Stop

End Function
'-------------------------------------------------------------------------------------
' timestamp is restricted to differentiate the hour (no minute, no second, ...)
Private Function CheckIfTarifIsApplicable(ByRef myCell As Range, ByRef dblCosts As Double, _
                                          ByVal TariffStart As Date, ByVal TariffEnd As Date, _
                                          ByVal TimeStamp As Date, ByVal TariffCost As Double) As Boolean
Dim HTime As Integer
Dim MTime As Integer
Dim HStart As Integer
Dim HEnd As Integer

  On Error GoTo errorHandler
  
  CheckIfTarifIsApplicable = False
  HTime = Hour(TimeStamp)
  ' MTime = Minute(TimeStamp)
  HStart = Hour(TariffStart)
  HEnd = Hour(TariffEnd)
  
  If HStart = HEnd Then
    'tariff is for the entire day
    dblCosts = dblCosts + TariffCost * CDbl(myCell.value)
    CheckIfTarifIsApplicable = True
  ElseIf HStart < HEnd Then
    'normal time intervall
    If (HTime >= HStart) And (HTime < HEnd) Then
      dblCosts = dblCosts + TariffCost * CDbl(myCell.value)
      CheckIfTarifIsApplicable = True
    End If
  ElseIf HEnd = 0 Then
    'normal time intervall with 00:00:00 as end time
    If HTime >= HStart Then
      dblCosts = dblCosts + TariffCost * CDbl(myCell.value)
      CheckIfTarifIsApplicable = True
    End If
  Else
    'over night tariff
    If (HTime >= HStart) Or (HTime < HEnd) Then
      dblCosts = dblCosts + TariffCost * CDbl(myCell.value)
      CheckIfTarifIsApplicable = True
    End If
  End If

Exit Function
errorHandler:
  MsgBox (Err.Description)
  Stop
End Function



Attribute VB_Name = "M_KstProtCalculation2"
'Attribute VB_Name = "mInteligentChart"
' _________________________________________________________________
'
'   Projekt:    PCS 7 Powerrate
'   Copyright (c) Siemens AG 2008. All rights reserved. Confidential.
' _________________________________________________________________
'
'   Modul:              mInteligentChart.bas
'
'   Autor:              Ralf Leistner /A&D SE DE21
'   Datum:              10.11.2008
'   Version:            V 1.00
' _________________________________________________________________
'
'   Funktion:           Module to generate charts
' ________________________________________________________________________
'
'   Aenderungshistorie:
'
'   Autor: Wolfram Klebel
'   Datum: 7.12.10
'   Version: PowerReport 3.0
'   Funktion: data tree / IM 101311
'
'--------------------------------------------------------------------
Option Explicit

Option Compare Text

'**********************************************************
'                Definition von Konstanten
'**********************************************************
' Private Const c_ModulName = "mInteligentChart"


Public Sub SetAxisAttributes(xs As Axis, isY As Boolean)

  With xs
    .MajorTickMark = xlOutside
    .MinorTickMark = xlNone
    .TickLabelPosition = xlNextToAxis
    .HasMajorGridlines = True
    .HasMinorGridlines = False
    
    .AxisTitle.Font.Name = "Arial"
    .AxisTitle.Font.Bold = False
    .AxisTitle.Font.Size = 8
    .AxisTitle.HorizontalAlignment = xlCenter
    
    'Border
    .Border.Weight = xlHairline
    .Border.LineStyle = xlNone
    
    'MajorGridlines.Border
    .MajorGridlines.Border.ColorIndex = 57
    .MajorGridlines.Border.Weight = xlHairline
    .MajorGridlines.Border.LineStyle = xlDot
    
    '.TickLabels.Font
    .TickLabels.Font.Name = "Arial"
    .TickLabels.Font.FontStyle = "Standard"
    .TickLabels.Font.Size = 8.25
    .TickLabels.Font.Strikethrough = False
    .TickLabels.Font.Superscript = False
    .TickLabels.Font.Subscript = False
    .TickLabels.Font.OutlineFont = False
    .TickLabels.Font.Shadow = False
    .TickLabels.Font.Underline = xlUnderlineStyleNone
    .TickLabels.Font.ColorIndex = xlAutomatic
    .TickLabels.Font.Background = xlAutomatic
  
    If (isY = True) Then
      .MinimumScaleIsAuto = False
      .MaximumScaleIsAuto = True
      .MinorUnitIsAuto = True
      .MajorUnitIsAuto = True
      .Crosses = xlAutomatic
      .ReversePlotOrder = False
      .ScaleType = xlLinear
      .DisplayUnit = xlNone
      .AxisTitle.Orientation = xlHorizontal
       
      .MajorTickMark = xlOutside
      .MinorTickMark = xlOutside
      .TickLabels.NumberFormat = myLoadResString(DCT_FORMAT_NUMBER)
      
      'Border
      .Border.LineStyle = xlAutomatic
      
      'TickLabels
      .TickLabels.AutoScaleFont = True
      'TickLabels.Font
      .TickLabels.Font.Size = 8
    End If
  End With
  
End Sub

Public Sub SetPlotArea(plArea As PlotArea)
  With plArea
    'Border
    .Border.ColorIndex = 16
    .Border.Weight = xlThin
    .Border.LineStyle = xlContinuous
    
    'Interior
    .Interior.ColorIndex = 2
    .Interior.PatternColorIndex = 1
    .Interior.Pattern = xlSolid
  End With
End Sub

Public Sub SetSeriesAttributes(srs As Series)
  With srs
    ' ? doch nicht alle gleich? .Interior.Color = RGB(204, 255, 255)
    .HasDataLabels = True
    .DataLabels.Font.Size = 8
    .DataLabels.Font.Background = xlBackgroundOpaque
    .DataLabels.NumberFormat = myLoadResString(DCT_FORMAT_NUMBER)
  End With
End Sub

Public Sub SetChartAttributes(cht As Chart)
  With cht
    .ChartType = xlColumnClustered      ' Liniendiagrammtyp w|fffd|hlen
    
    .ChartTitle.Font.Size = 10
    .ChartTitle.Font.Name = "Arial"
    .ChartTitle.Font.Bold = True
    
    .HasLegend = True
    .Legend.Position = xlLegendPositionRight
    .Legend.Font.Size = 10
  End With

End Sub


Public Sub UpdateAllCharts(ByRef ConsumptionSheet As Worksheet, ByRef ChartSheet As Worksheet, _
                            ByVal Auto_Report As Boolean, Optional ByRef ProgresForm As Object)
Dim shtSheet As Worksheet
Dim objChartObj As ChartObject
Dim objChart As Chart
Dim objConsumption As Series, objCosts As Series
Dim lngRowCount As Long
Dim objTemp As Object
Dim rgCons As Range, rgHelp As Range
Dim rgX As Range, rgY As Range
Dim i As Integer
Dim chtCons As Chart, choCons As ChartObject
Dim srsCons As Series
Dim ccCount As Integer
Dim sCurr As String
Dim sArray() As String
Dim rgCC As Range
Dim sCons As String

    ' On Error Resume Next
  On Error GoTo errorHandler
 
  Set rgCC = ConsumptionSheet.Cells(10, 2)
  ccCount = rgCC.End(xlDown).Row - rgCC.Row - 1
  Set rgCC = Range(rgCC.Offset(1), rgCC.Offset(ccCount + 1))  ' range over cost center names
  
  sArray = Split(ConsumptionSheet.Cells(10, 4), "[")  ' taken from 'total costs
  sCurr = "[" & sArray(1)
  
  While ChartSheet.ChartObjects.Count > 0  ' delete chart existing
    ChartSheet.ChartObjects(1).Delete
  Wend

  ' === chart for consumption
  Set choCons = ChartSheet.ChartObjects.Add(0, 133, 462, 250)
  Set chtCons = choCons.Chart
  Set rgCons = ConsumptionSheet.Cells(9, 6)    ' first value
  For i = 0 To 500
    If IsEmpty(rgCons.Offset(0, i * 3)) Then Exit For
    Set rgHelp = rgCons.Offset(2, i * 3)  ' upper value
    sArray = Split(rgCons.Offset(1, i * 3), "[")
    sCons = "[" & sArray(1)
    
    choCons.Activate
    chtCons.ChartArea.Select
    Set srsCons = ActiveChart.SeriesCollection.NewSeries
    With srsCons
      .Values = Range(rgHelp, rgHelp.Offset(ccCount)) ' values
      .Name = rgCons.Offset(0, i * 3) & "  " & sCons  ' Medium [unit]
      .XValues = rgCC                                 ' legend for cost center
      Call SetSeriesAttributes(srsCons)
    End With
  Next i
  
  With chtCons
    .HasTitle = True
    Call SetChartAttributes(chtCons)  '"Diagramm Kostenstellenbericht Verbrauch"
    .ChartTitle.Text = GetResText(1644) & " " & GetResText(1643) & Chr(10) & _
      Format(ConsumptionSheet.Cells(5, 4), myLoadResString(DCT_FORMAT_DATETIME)) _
      & " - " & _
      Format(ConsumptionSheet.Cells(6, 4), myLoadResString(DCT_FORMAT_DATETIME))
     
    .Axes(xlCategory, xlPrimary).HasTitle = True
    .Axes(xlCategory, xlPrimary).AxisTitle.Characters.Text = GetResText(1637)  ' "Kostenstelle"
    
    .Axes(xlValue, xlPrimary).HasTitle = True
    .Axes(xlValue, xlPrimary).AxisTitle.Characters.Text = GetResText(1645) ' "[Einheit]"
  End With
  
  ' set axis attributes
  Call SetAxisAttributes(chtCons.Axes(xlCategory), isY:=False)
  Call SetAxisAttributes(chtCons.Axes(xlValue), isY:=True)
  Call SetPlotArea(chtCons.PlotArea)

  ' === chart for costs
  Set choCons = ChartSheet.ChartObjects.Add(467, 133, 462, 250)
  Set chtCons = choCons.Chart
  Set rgCons = ConsumptionSheet.Cells(9, 6)    ' first value
  For i = 0 To 500
    If IsEmpty(rgCons.Offset(0, i * 3)) Then Exit For
    Set rgHelp = rgCons.Offset(2, (i * 3) + 1)  ' upper value
    
    choCons.Activate
    chtCons.ChartArea.Select
    Set srsCons = ActiveChart.SeriesCollection.NewSeries
    With srsCons
      .Values = Range(rgHelp, rgHelp.Offset(ccCount)) ' values
      .Name = rgCons.Offset(0, i * 3)          ' Medium
      .XValues = rgCC                                 ' legend for cost center
      Call SetSeriesAttributes(srsCons)
    End With
  Next i
  
  With chtCons
    .HasTitle = True
    Call SetChartAttributes(chtCons) ' "Diagramm Kostenstellenbericht Kosten"
    .ChartTitle.Text = GetResText(1644) & " " & GetResText(1636) & Chr(10) & _
      Format(ConsumptionSheet.Cells(5, 4), myLoadResString(DCT_FORMAT_DATETIME)) _
      & " - " & _
      Format(ConsumptionSheet.Cells(6, 4), myLoadResString(DCT_FORMAT_DATETIME))
    .Axes(xlCategory, xlPrimary).HasTitle = True
    .Axes(xlCategory, xlPrimary).AxisTitle.Characters.Text = GetResText(1637) ' "Kostenstelle"
    .Axes(xlValue, xlPrimary).HasTitle = True
    .Axes(xlValue, xlPrimary).AxisTitle.Characters.Text = sCurr  ' currency
  End With
  
  ' set axis attributes
  Call SetAxisAttributes(chtCons.Axes(xlCategory), isY:=False)
  Call SetAxisAttributes(chtCons.Axes(xlValue), isY:=True)
  Call SetPlotArea(chtCons.PlotArea)

Exit Sub
errorHandler:
  MsgBox (Err.Description)
  Stop
End Sub

Attribute VB_Name = "M_KstVorlage"
'==================================================================================================
'M_KstVorlage
'
'Wolfram Klebel
'10.7.09
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module


'--------------------------------------------------------------------------------------------------
Public Sub DPEinfuegen()

Dim rgDp        As Range
Dim tabVorlage  As Worksheet
Dim tabConfig   As Worksheet

Dim coDP    As CO_DP
Dim oDP     As C_DP
Dim iDPL    As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long
Dim aHelp() As String
Dim unit    As String
Dim lUnit   As String
Dim sHelp   As String
Dim ret     As Long

Dim vwDPEinfuegen As V_DPEinfuegen

  On Error GoTo M_KstVorlage_DPEinfuegen_Fehler
  Set tabConfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
  Set vwDPEinfuegen = New V_DPEinfuegen
  
  vwDPEinfuegen.Modus = DPINSERT_MODUS_KST_INSERT 'IM 115373 BK 07022011 Konstanten verwenden
  vwDPEinfuegen.Show

  If vwDPEinfuegen.ok Then
    'ToDo: Das hier scheitert bei verbundenen Zellen,
    'gibt es was besseres?
    Set rgDp = ActiveCell
    rgDp.EntireColumn.Select
    
    Set coDP = vwDPEinfuegen.getDPL
    
    For iDPL = coDP.Count To 1 Step -1
          
      Selection.Insert Shift:=xlToRight
      Call setDp(Selection.Cells(2, 1), coDP.Item(iDPL))
    Next iDPL
    
    rgDp.Select
  End If
M_KstVorlage_Einfuegen_Exit:

  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing

Exit Sub
M_KstVorlage_DPEinfuegen_Fehler:
  
  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_EINFUEGEN)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DPAendern()

Dim rgDp  As Range
Dim tabVorlage As Worksheet
Dim tabConfig   As Worksheet

Dim coDP  As CO_DP
Dim oDP   As C_DP

Dim vwDPEinfuegen As V_DPEinfuegen

  On Error GoTo M_StdVorlage_DPAendern_Fehler
  
  Set tabConfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
  Set vwDPEinfuegen = New V_DPEinfuegen
  
  Set rgDp = ActiveWindow.ActiveCell.EntireColumn.Cells(2, 1)
  Set oDP = getDp(rgDp)
  
  vwDPEinfuegen.Modus = DPINSERT_MODUS_KST_CHANGE 'IM 115373 BK 07022011 Konstanten verwenden
  Call vwDPEinfuegen.setDp(oDP)
  
  vwDPEinfuegen.Show
  
  If vwDPEinfuegen.ok Then
    
    Set coDP = vwDPEinfuegen.getDPL
    For Each oDP In coDP.Items
      Call setDp(rgDp, oDP)
    Next oDP

  End If
  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing
  
Exit Sub
M_StdVorlage_DPAendern_Fehler:
  
  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_AeNDERN)
End Sub

'--------------------------------------------------------------------------------------------------
'Ermittelt das Layout der Tabelle
Public Sub GetTabLayout(wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim rgZeile       As Range
Dim coDPFkt       As CO_DPFunktion
Dim oDPFkt        As C_DPFunktion
Dim oTabBereich   As C_TabBereich
Dim boFktBereich  As Boolean

  Set coDPFkt = M_DPFunktion.coLesen
  Set rgZeile = wsProt.Range("A1")
  
  Do While Not rgZeile Is Nothing
    If rgZeile.value = VAR_KOPFZEILE Or _
       rgZeile.value = VAR_FUSSZEILE Or _
       rgZeile.value = VAR_SEITENENDE Then
       
      Set oTabBereich = New C_TabBereich
      oTabBereich.Blatt = wsProt.index
      oTabBereich.Bereich = rgZeile.value
      oTabBereich.Zeile = rgZeile.Row
      coTabBereich.Add oTabBereich
    End If
    
    If rgZeile.value = VAR_DATENBEREICH Then
      Set oTabBereich = New C_TabBereich
      oTabBereich.Blatt = wsProt.index
      oTabBereich.Bereich = rgZeile.value
      oTabBereich.Zeile = rgZeile.Row
      coTabBereich.Add oTabBereich
    End If
    
    If rgZeile.Text = VAR_KOPFZEILE Or _
       rgZeile.Text = VAR_FUSSZEILE Then
      boFktBereich = True
    ElseIf rgZeile.Text = VAR_DATENBEREICH Or _
           rgZeile.Text = VAR_SEITENENDE Then
      boFktBereich = False
    End If
    If boFktBereich Then
      For Each oDPFkt In coDPFkt.Items
        If oDPFkt.Bezeichnung = rgZeile.value Then
          Set oTabBereich = New C_TabBereich
          oTabBereich.Blatt = wsProt.index
          oTabBereich.Bereich = oDPFkt.Bezeichnung
          oTabBereich.Zeile = rgZeile.Row
          coTabBereich.Add oTabBereich
          Exit For
        End If
      Next oDPFkt
    End If
    
    Set rgZeile = MoveRange(rgZeile, xlDown)
  Loop

End Sub

'--------------------------------------------------------------------------------------------------
Public Function getDp(rgDp As Range) As C_DP

Dim oDP         As C_DP
Dim sDP         As String
Dim sDPE        As String
Dim sDPTyp      As String
Dim sDPFkt      As String
Dim iArchivTyp  As Integer
Dim lOffset     As Long
Dim lIntervall  As Long
Dim iIntEinheit As Integer
Dim sDPStat As String
Dim i As Integer

  sDP = rgDp.value
  sDPTyp = rgDp.Offset(2, 0).value
  sDPFkt = rgDp.Offset(3, 0).value
  iArchivTyp = RangeToLng(rgDp.Offset(9, 0), lDefault:=ARCHIVTYP_ACPERIODE)
  
  'DPTyp und DPFunktion OK?
  If sDPTyp = "" Or sDPFkt = "" Then
    sDP = ""
  End If
    
  'OK?
  If Len(sDP) Then
    Set oDP = New C_DP
    With oDP
      .dp = sDP
      .dpe = rgDp.Offset(1, 0).value
      .dpt = sDPTyp
      .ArchivFkt = sDPFkt
      .Kommentar = rgDp.Offset(4, 0).value
      .Alias = rgDp.Offset(5, 0).value
      .Format = rgDp.Offset(6, 0).value
      .Einheit = rgDp.Offset(7, 0).value
      .AutoFormat = RangeToLng(rgDp.Offset(8, 0))
      .ArchivTyp = iArchivTyp
      .Marker = RangeToLng(rgDp.Offset(10, 0))
      .ResultQuery = rgDp.Offset(11, 0).value
      .ResultFkt = rgDp.Offset(12, 0).Text
      .Offset = RangeToLng(rgDp.Offset(13, 0))
      ' Offset time
      .CostCenter = rgDp.Offset(15, 0).Text
      .CCWeighting = RangeToDbl(rgDp.Offset(16, 0))
      .CCMedium = rgDp.Offset(17, 0).value
      .CCUnitFactor = RangeToDbl(rgDp.Offset(18, 0))
    End With
  End If
  Set getDp = oDP

End Function

'--------------------------------------------------------------------------------------------------
Public Sub setDp(rgDp As Range, oDP As C_DP)

  rgDp.value = oDP.dp
  rgDp.Offset(1, 0).value = oDP.dpe
  rgDp.Offset(2, 0).value = oDP.dpt
  rgDp.Offset(3, 0).value = oDP.ArchivFkt
  rgDp.Offset(4, 0).value = oDP.Kommentar
  rgDp.Offset(5, 0).value = oDP.Alias
  rgDp.Offset(6, 0).value = oDP.Format
  rgDp.Offset(7, 0).value = oDP.Einheit
  rgDp.Offset(8, 0).value = oDP.AutoFormat
  rgDp.Offset(9, 0).value = oDP.ArchivTyp
  rgDp.Offset(10, 0).value = oDP.Marker
  rgDp.Offset(11, 0).value = oDP.ResultQuery
  rgDp.Offset(12, 0).value = oDP.ResultFkt
  rgDp.Offset(13, 0).value = oDP.Offset
  ' Offset time
  rgDp.Offset(15, 0).value = oDP.CostCenter
  rgDp.Offset(16, 0).value = oDP.CCWeighting
  rgDp.Offset(17, 0).value = oDP.CCMedium
  rgDp.Offset(18, 0).value = oDP.CCUnitFactor
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub GetDPList(wsProt As Worksheet, coDP As CO_DP)

Dim rgDp        As Range
Dim oDP         As C_DP
Dim coDPFkt     As CO_DPFunktion

  Set coDPFkt = M_DPFunktion.coLesen

  'Spaltenweise die DP definition einlesen
  'Set rgDp = wsProt.Cells(2, 2)
  'While (Not rgDp Is Nothing)
  For Each rgDp In wsProt.Range("B2", wsProt.Cells(2, Columns.Count).End(xlToLeft)) 'IM 49919 'IM 117635
    Set oDP = getDp(rgDp)
    If Not oDP Is Nothing Then
      'Wird in getDp nicht gepr|fffd|ft!
      If oDP.ArchivTyp = ARCHIVTYP_ACPERIODE Or _
         oDP.ArchivTyp = ARCHIVTYP_RACPERIODE Then
        If coDPFkt.FindItem(oDP.ArchivFkt) Is Nothing Then
          Set oDP = Nothing
        End If
      End If
    End If
    If Not oDP Is Nothing Then
      Set oDP.TabBereich = New C_TabBereich
      oDP.TabBereich.Bereich = VAR_DATENBEREICH
      oDP.TabBereich.Blatt = wsProt.index
      oDP.TabBereich.Spalte = rgDp.Column
      oDP.TabBereich.Zeile = 0
      coDP.Add oDP
    End If
    'Set rgDp = MoveRange(rgDp, xlToRight)
  'Wend
  Next rgDp

End Sub 'GetDPList

'--------------------------------------------------------------------------------------------------
Public Sub updateDpInfos(wsProt As Worksheet)

Dim oComMan As ComManager
Dim rgDp    As Range
Dim sDP     As String

Dim v As Variant

  On Error GoTo updateDpInfosFehler
  
  Set oComMan = M_PVSS.getComMan
  For Each rgDp In wsProt.Range("B2", wsProt.Cells(2, Columns.Count).End(xlToLeft)) 'IM 49919 'IM 117635
  
    sDP = rgDp.value
    'DPTyp und DPFunktion OK?
    If rgDp.Offset(2, 0).value = "" Or _
       rgDp.Offset(3, 0).value = "" Then
      sDP = ""
    End If
    
    'OK?
    If Len(sDP) Then
      'Bei AC Typen schauen wir auf das .value
      If rgDp.Offset(9, 0).value = ARCHIVTYP_ACPERIODE Then
        'DPE vorhanden?
        If rgDp.Offset(1, 0).value <> "" Then
          sDP = sDP & "." & rgDp.Offset(1, 0).value & ".value"
        Else
          sDP = sDP & ".value"
        End If
      Else
        sDP = sDP & "." & rgDp.Offset(1, 0).value
      End If
      v = oComMan.dpGetDescription(sDP)
      If Not IsError(v) Then rgDp.Offset(4, 0).value = CStr(v)
      v = oComMan.dpGetAlias(sDP)
      If Not IsError(v) Then rgDp.Offset(5, 0).value = CStr(v)
      v = oComMan.dpGetFormat(sDP)
      If Not IsError(v) Then rgDp.Offset(6, 0).value = CStr(v)
      v = oComMan.dpGetUnit(sDP)
      If Not IsError(v) Then rgDp.Offset(7, 0).value = CStr(v)
    End If
  
  Next rgDp

Exit Sub
updateDpInfosFehler:
  Stop
End Sub

Attribute VB_Name = "M_MailVerteiler"
'===================================================================================================
'M_MailVerteiler
'Oliver Seidel 03.05.2001
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Private mcoMailVerteiler As CO_MailVerteiler

'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwMailVerteiler As V_MAilVerteiler
Dim coMailVerteiler As CO_MailVerteiler

  Set vwMailVerteiler = New V_MAilVerteiler
  Set coMailVerteiler = coLesen
  Set vwMailVerteiler.MailVerteiler = coMailVerteiler
  vwMailVerteiler.Show
  If vwMailVerteiler.ok Then
    Call coSpeichern(coMailVerteiler)
  Else
    Set mcoMailVerteiler = Nothing
  End If

  Unload vwMailVerteiler
  Set vwMailVerteiler = Nothing
  DoEvents
  
End Sub 'coEdit()

'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_MailVerteiler

Dim recMailVerteiler  As ADODB.Recordset
Dim sSql          As String
Dim oMailVerteiler    As C_MailVerteiler

Dim alId()          As Long
Dim asBezeichnung() As String
Dim lID             As Long
Dim n               As Long
  
  On Error GoTo MailVerteiler_Lesen_Fehler

  If Not mcoMailVerteiler Is Nothing Then
    Set coLesen = mcoMailVerteiler
    Exit Function
  End If

  Set coLesen = New CO_MailVerteiler
  sSql = "SELECT * FROM tabMailVerteiler"
  Set recMailVerteiler = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recMailVerteiler.EOF
    Set oMailVerteiler = New C_MailVerteiler
    oMailVerteiler.ID = recMailVerteiler.Fields("ID")
    oMailVerteiler.Bezeichnung = recMailVerteiler.Fields("Bezeichnung")
    oMailVerteiler.An = recMailVerteiler.Fields("An")
    oMailVerteiler.Betreff = recMailVerteiler.Fields("Betreff")
    oMailVerteiler.isMailGruppe = recMailVerteiler.Fields("isGruppe")
    
    recMailVerteiler.MoveNext
    coLesen.Add oMailVerteiler
  Wend
  Call M_DB.CloseRecordset(recMailVerteiler)

Exit Function
MailVerteiler_Lesen_Fehler:
  Call M_DB.CloseRecordset(recMailVerteiler)
  Call FehlerAusloesen(30700, Err.Description, False, "M_MailVerteiler::coLesen")
End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Public Function Lesen(ID As Long) As C_MailVerteiler

Dim recMailVerteiler  As ADODB.Recordset
Dim oMailVerteiler    As C_MailVerteiler
Dim sSql          As String

Dim alId()          As Long
Dim asBezeichnung() As String
Dim lID             As Long
Dim n               As Long

  On Error GoTo MailVerteiler_Suchen_Fehler

  If Not mcoMailVerteiler Is Nothing Then
    For Each oMailVerteiler In mcoMailVerteiler.Items
      If oMailVerteiler.ID = ID Then
        Set Lesen = oMailVerteiler
        Exit Function
      End If
    Next oMailVerteiler
  End If

  Set oMailVerteiler = New C_MailVerteiler

  sSql = "SELECT * FROM tabMailVerteiler WHERE ID = " & ID & ";"
  Set recMailVerteiler = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)

  If Not recMailVerteiler.EOF Then
    
    oMailVerteiler.ID = recMailVerteiler.Fields("ID")
    oMailVerteiler.Bezeichnung = recMailVerteiler.Fields("Bezeichnung")
    oMailVerteiler.An = recMailVerteiler.Fields("An")
    oMailVerteiler.Betreff = recMailVerteiler.Fields("Betreff")
    oMailVerteiler.isMailGruppe = recMailVerteiler.Fields("isGruppe")
  
  End If
  Call M_DB.CloseRecordset(recMailVerteiler)
  Set Lesen = oMailVerteiler

Exit Function
MailVerteiler_Suchen_Fehler:
  Call M_DB.CloseRecordset(recMailVerteiler)
  Call FehlerAusloesen(30705, Err.Description, False, "M_MailVerteiler::Lesen")
End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coMailVerteiler As CO_MailVerteiler)

Dim recMailVerteiler  As ADODB.Recordset
Dim oMailVerteiler    As C_MailVerteiler
Dim sSql          As String
Dim lLoeschen     As Long

  On Error GoTo MailVerteiler_Speichern_Fehler

  'Set mcoMailVerteiler = Nothing

  'DB oeffnen und alle Datensaetz zum Loeschen makieren
  sSql = "UPDATE tabMailVerteiler SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen

  sSql = "SELECT * FROM tabMailVerteiler"
  Set recMailVerteiler = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  For Each oMailVerteiler In coMailVerteiler.Items

    If recMailVerteiler.BOF And recMailVerteiler.EOF Then
      recMailVerteiler.AddNew
    Else
      recMailVerteiler.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recMailVerteiler.Find "ID = " & oMailVerteiler.ID, , adSearchForward
      If recMailVerteiler.EOF Then
        recMailVerteiler.AddNew
      Else
        'recMailVerteiler.Edit
        recMailVerteiler.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recMailVerteiler.Fields("Bezeichnung") = oMailVerteiler.Bezeichnung
    recMailVerteiler.Fields("An") = oMailVerteiler.An
    recMailVerteiler.Fields("Betreff") = oMailVerteiler.Betreff
    recMailVerteiler.Fields("isGruppe") = oMailVerteiler.isMailGruppe

    recMailVerteiler.Update
    'recMailVerteiler.Bookmark = recMailVerteiler.LastModified
    oMailVerteiler.ID = recMailVerteiler.Fields("ID")

  Next oMailVerteiler

  Call M_DB.CloseRecordset(recMailVerteiler)

  sSql = "DELETE FROM tabMailVerteiler WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql

  Set mcoMailVerteiler = coMailVerteiler

Exit Sub
MailVerteiler_Speichern_Fehler:
  Set mcoMailVerteiler = Nothing
  Call M_DB.CloseRecordset(recMailVerteiler)
  Call FehlerAusloesen(30703, Err.Description, False, "M_MailVerteiler::coSpeichern")
End Sub 'coSpeichern()

'---------------------------------------------------------------------------------------------------
Public Sub Senden(oProtokoll As C_Protokoll, Optional oMailVerteiler As C_MailVerteiler = Nothing)

Dim vwMailSenden    As V_MailSenden
Dim coMailVerteiler As CO_MailVerteiler
Dim oMVHelp         As C_MailVerteiler

Dim asAn()          As String
Dim index           As Integer
Dim OutApp          As Object
   
  If oProtokoll Is Nothing Then
    Exit Sub
  End If

  'Kein Verteiler angegeben?
  If oMailVerteiler Is Nothing Then
  
    'Dann soll der Benutzer einen auswaehlen...
    Set vwMailSenden = New V_MailSenden
    Set coMailVerteiler = coLesen
    Set vwMailSenden.MailVerteiler = coMailVerteiler
    vwMailSenden.Show
    If vwMailSenden.ok Then
      Set oMailVerteiler = vwMailSenden.MailTo
    End If
  
    Unload vwMailSenden
    Set vwMailSenden = Nothing
    DoEvents
  
  End If

  If oMailVerteiler Is Nothing Then Exit Sub
  If oMailVerteiler.ID <= 0 Then Exit Sub
  
  If (oMailVerteiler.isMailGruppe) Then
    Set coMailVerteiler = coLesen
    Call StrToArray(asAn, oMailVerteiler.An, ";")
    For index = 1 To UBound(asAn)
      Set oMVHelp = coMailVerteiler.FindItem(asAn(index))
      asAn(index) = oMVHelp.An
    Next
  Else
    Call StrToArray(asAn, oMailVerteiler.An, ";")
  End If
  
  ' check whether outlook is installed IM 111991
  On Error GoTo MailVerteiler_Outlook_Fehler
  Set OutApp = CreateObject("Outlook.Application")
  Set OutApp = Nothing
  GoTo MailVerteiler_Outlook
     
'---------------------------
MailVerteiler_Outlook_Fehler:
  On Error GoTo MailVerteiler_Senden_Fehler
  oProtokoll.wbProtokoll.SendMail _
      asAn, _
      oProtokoll.pathProtInfo(oMailVerteiler.Betreff)
  Exit Sub
      
'---------------------------
MailVerteiler_Outlook:
  On Error GoTo MailVerteiler_Senden_Fehler
    
  Call SendWithOutlook(asAn, oProtokoll.pathProtInfo(oMailVerteiler.Betreff))
  Call BugMessage("Mail <" & oMailVerteiler.Betreff & "> sent to " & oMailVerteiler.An, "M_MailVerteiler::Senden")
  
  Exit Sub
  
'---------------------------
MailVerteiler_Senden_Fehler:
  Call MsgBox("M_MailVerteiler::Senden:" & Chr(10) & Err.Description & Chr(10) & oMailVerteiler.An, _
              vbCritical + vbOKOnly, Err.Number & " " & Err.Source)
End Sub

'------------------------------------------------------
' added WOKL 24.3.15 IM 111991

Public Sub SendWithOutlook(asTo() As String, sSubject As String)
   Dim sTo As String
   Call ArrayToStr(sTo, asTo, ";")
   
  'Working in Excel 2000-2013
  'Mail a copy of the ActiveWorkbook with another file name
  'For Tips see: http://www.rondebruin.nl/win/winmail/Outlook/tips.htm
   Dim wb1 As Workbook
   Dim TempFilePath As String
   Dim TempFileName As String
   Dim FileExtStr As String
   Dim OutApp As Object
   Dim OutMail As Object

   With Application
       .ScreenUpdating = False
       .EnableEvents = False
   End With

   Set wb1 = ActiveWorkbook

   'Make a copy of the file/Open it/Mail it/Delete it
   'If you want to change the file name then change only TempFileName
   FileExtStr = ".xlsm"
   TempFilePath = Environ$("temp") & "\"
   TempFileName = wb1.Name
   If LCase(Right(TempFileName, Len(FileExtStr))) <> LCase(FileExtStr) Then
       TempFileName = TempFileName & FileExtStr
   End If

   wb1.SaveCopyAs TempFilePath & TempFileName

   Set OutApp = CreateObject("Outlook.Application")
   Set OutMail = OutApp.CreateItem(0)

   ' error treatment has caller
   With OutMail
       .To = sTo
       .cc = ""
       .BCC = ""
       .Subject = sSubject
       .Body = ""
       .Attachments.Add TempFilePath & TempFileName
       .Send
   End With

   'Delete the file
   Kill TempFilePath & TempFileName

   Set OutMail = Nothing
   Set OutApp = Nothing

   With Application
       .ScreenUpdating = True
       .EnableEvents = True
   End With
End Sub

Attribute VB_Name = "M_Media"
'===================================================================================================
'M_Media
'Wolfram Klebel 2.7.09
'  Verwaltung der Media Eintraege
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Private mcoMedia As CO_Media


'Public Sub Invalidate()
'  If Not mcoMedia Is Nothing Then
'    mcoMedia = Nothing
'  End If
'
'End Sub
'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwMedia As V_Media
Dim oMedia As CO_Media

  On Error GoTo M_Media_Edit_Fehler
  
  Set vwMedia = New V_Media
  Set oMedia = M_Media.coLesen
  Set vwMedia.Media = oMedia
  vwMedia.Show
  
  If vwMedia.ok Then
    'Sieht lustig aus, aber auf Collection wird direkt referenziert
    'Aenderungen schlagen also automatisch durch!
    Call M_Media.coSpeichern(oMedia)
    
    'Vorsicht Falle!
    'Auch wenn man es hier nicht sieht, es wird indirekt mcoMedia geaendert!
    'Nun koennte man diese Infos an dieser Stelle erneut aus der DB lesen, einfacher ist es
    'jedoch, den Cache wegzuschmeissen.
    Set mcoMedia = Nothing
    
  End If
  'ToDo: Falls coBasiswert gepuffert wird, muss nach einem Abbruch der
  'Bearbeitung der Puffer geloescht werden!
  'Stimmt, ich sollte mal das Datum zu meinen Kommentaren aufnehmen
  Set mcoMedia = Nothing
    
  Unload vwMedia
  Set vwMedia = Nothing

Exit Sub
M_Media_Edit_Fehler:
  
  If Not vwMedia Is Nothing Then
    Unload vwMedia
    Set vwMedia = Nothing
  End If
  Call FehlerAusloesen(30702, , False, "M_Media::coEdit")
  
End Sub 'coEdit()


'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_Media

Dim recMedia  As ADODB.Recordset
Dim sSql          As String
Dim oMedium    As C_Medium
Dim coMedia   As CO_Media
Dim lStatusId     As Long

  On Error GoTo Media_Lesen_Fehler
   
  If mcoMedia Is Nothing Then
    lStatusId = StatusTextAusgeben("Reading Media values")
    
    Set coMedia = New CO_Media
    
    sSql = "SELECT * FROM tabMedia"
           
    Set recMedia = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    
    While Not recMedia.EOF
      Set oMedium = New C_Medium
      
      oMedium.ID = recMedia.Fields("ID")
      oMedium.Name = recMedia.Fields("Name")
      oMedium.unit = recMedia.Fields("Unit")
      
      Call StatusTextAusgeben("Reading Media " & oMedium.Name, lStatusId)
      recMedia.MoveNext
      
      coMedia.Add oMedium
    Wend
    Call M_DB.CloseRecordset(recMedia)

  Else
    coMedia = mcoMedia
  End If
    
  Set coLesen = coMedia
  StatusTextLoeschen (lStatusId)
  
Exit Function
Media_Lesen_Fehler:
  MsgBox ("Err " & Err.Description)
  Call M_DB.CloseRecordset(recMedia)
  If Not oMedium Is Nothing Then
    Call FehlerAusloesen(30700, "Media #" & oMedium.Name, False, "M_Media::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Media::coLesen")
  End If

End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Public Function Lesen(ID As Integer) As C_Medium

Dim coMedia As CO_Media
Dim oMedium  As C_Medium

  On Error GoTo Media_Lesen_Fehler

  Set coMedia = coLesen
  For Each oMedium In coMedia.Items
    If oMedium.ID = ID Then
      Set Lesen = oMedium
      Exit For
    End If
  Next oMedium

Exit Function
Media_Lesen_Fehler:

  If Not oMedium Is Nothing Then
    Call FehlerAusloesen(30705, "Media #" & oMedium.ID, False, "M_Media::Lesen")
  Else
    Call FehlerAusloesen(30705, Err.Description, False, "M_Media::Lesen")
  End If

End Function 'Lesen()


'---------------------------------------------------------------------------------------------------
Public Function FilterName(mediaName As String) As C_Medium

Dim coMedia As CO_Media
Dim oMedium  As C_Medium

  On Error GoTo Media_Lesen_Fehler

  Set coMedia = coLesen
  For Each oMedium In coMedia.Items
    If oMedium.Name = mediaName Then
      Set FilterName = oMedium
      Exit For
    End If
  Next oMedium

Exit Function
Media_Lesen_Fehler:

  If Not oMedium Is Nothing Then
    Call FehlerAusloesen(30705, "Media #" & oMedium.Name, False, "M_Media::FilterName")
  Else
    Call FehlerAusloesen(30705, Err.Description, False, "M_Media::FilterName")
  End If

End Function 'Lesen()'---------------------------------------------------------------------------------------------------
Public Function coFilterCc(ccID As Integer) As CO_Media
  Dim recMedia    As ADODB.Recordset
  Dim sSql        As String
  Dim oMedium     As C_Medium
  Dim coMedia     As CO_Media
  
  On Error GoTo coFilterCc_Error
   
  Set coMedia = New CO_Media
  
  sSql = "SELECT DISTINCT tm.ID, tm.Name, tm.Unit FROM " & _
    "tabMedia tm, tabTariffset ts, refTariffset rts WHERE " & _
    "tm.ID = ts.Medium AND ts.ID = rts.Tariffset AND rts.CostCenter = " & ccID
  Set recMedia = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recMedia.EOF
    Set oMedium = New C_Medium
    oMedium.ID = recMedia.Fields("ID")
    oMedium.Name = recMedia.Fields("Name")
    oMedium.unit = recMedia.Fields("Unit")
    
    coMedia.Add oMedium
    recMedia.MoveNext
  Wend
  Call M_DB.CloseRecordset(recMedia)

  Set coFilterCc = coMedia
  
Exit Function
coFilterCc_Error:
  Call M_DB.CloseRecordset(recMedia)
  If Not oMedium Is Nothing Then
    Call FehlerAusloesen(30700, "Media #" & oMedium.Name, False, "M_Media::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Media::coLesen")
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coMedia As CO_Media)

Dim recMedia  As ADODB.Recordset
Dim oMedium    As C_Medium
Dim sSql          As String
Dim lLoeschen     As Long
Dim lLoeschen2    As Long

  On Error GoTo Media_Speichern_Fehler
  
  sSql = "UPDATE tabMedia SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen
  
  sSql = "SELECT * FROM tabMedia"
  Set recMedia = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)

  For Each oMedium In coMedia.Items
    
    If recMedia.BOF And recMedia.EOF Then
      recMedia.AddNew
    Else
      recMedia.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recMedia.Find "ID = " & oMedium.ID, , adSearchForward
      If recMedia.EOF Then
        recMedia.AddNew
      Else
        recMedia.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recMedia.Fields("Name") = oMedium.Name
    recMedia.Fields("Unit") = oMedium.unit
    recMedia.Update
    
    oMedium.ID = recMedia.Fields("ID")

  Next oMedium
  
  sSql = "DELETE FROM tabMedia WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql, lLoeschen2
  Call BugAssert(lLoeschen = lLoeschen2)

  Call M_DB.CloseRecordset(recMedia)
  
Exit Sub
Media_Speichern_Fehler:
  
  Call M_DB.CloseRecordset(recMedia)
  
  Call ErrMessage("sSQL: " & sSql, "M_Media::coSpeichern")
  If Not oMedium Is Nothing Then
    Call FehlerAusloesen(30703, "Media " & oMedium.Name, _
                        False, "M_Media::coSpeichern")
  Else
    Call FehlerAusloesen(30703, Err.Description, _
                        False, "M_Media::coSpeichern")
  End If

End Sub 'coSpeichern()




Attribute VB_Name = "M_Menue"
'==================================================================================================
'M_Menue
'
'Oliver Seidel
'20.01.1999
'
'Erstellt die Menueeintraege und Symbolschaltfaechen bei Projektstart und macht alle Aenderungen bei
'Projektende rueckgaengig. Alle Befehle werden abgefangen und an die angesprochenen Module weiter
'geleitet.
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

Private msImportPath As String

Private Declare Function ShellExecute _
  Lib "shell32.dll" Alias "ShellExecuteA" ( _
  ByVal hWnd As Long, _
  ByVal Operation As String, _
  ByVal Filename As String, _
  Optional ByVal Parameters As String, _
  Optional ByVal Directory As String, _
  Optional ByVal WindowStyle As Long = vbMinimizedFocus _
  ) As Long

'Private Const MENUE_EINBLENDEN = "Einblenden!"
Private Const MENUE_LOESCHEN = "Loeschen!"
Private Const MENUE_RESET = "Wiederherstellen!"

Private Const MENUE_REPORT = "mnuReport"
Private Const MENUE_VORLAGE = "mnuVorlage"
Private Const MENUE_VORLAGE_NEU = "mnuVorlageNeu"
Private Const MENUE_VORLAGE_OEFFNEN = "mnuVorlageOeffnen"
Private Const MENUE_PROTOKOLL = "mnuProtokoll"
Private Const MENUE_PROTOKOLL_SENDEN = "mnuProtokoll_Senden"
Private Const MENUE_PROTOKOLL_HTML = "mnuProtokoll_Html"

Private Const MENUE_REPORT_UPDTTEMPL = "mnuReportUpdateTemplate"
Private Const MENUE_REPORT_QUICKSEL = "mnuReportQuickSel"
Private Const MENUE_REPORT_SCHEDULE = "mnuReportSchedule"
Private Const MENUE_REPORT_MAILINGLIST = "mnuReportMailinglist"
Private Const MENUE_REPORT_KENNWORT = "mnuReport_Kennwort"

Private Const MENUE_REPORT_KENNWORT_CHG = "mnuReport_KennwortChg"
Private Const MENUE_REPORT_OPTIONEN = "mnuReportOptionen"
Private Const MENUE_REPORT_ARCHIVSTR = "mnuReportArchivStr"
Private Const MENUE_REPORT_BASISWERTE = "mnuReportBasisValue"
Private Const MENUE_REPORT_PROTTYP = "mnuReportProtTyp"
Private Const MENUE_REPORT_STATUSBIT = "mnuReportStatusbit"
Private Const MENUE_REPORT_TARIFFSET = "mnuReportTariffset"
Private Const MENUE_REPORT_COSTCENTER = "mnuReportCostCenter"
Private Const MENUE_REPORT_MEDIA = "mnuReportMedia"
      

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport()

Dim cmdbar As CommandBar
Dim cmdCtl As CommandBarControl

Dim cmdctlReport    As CommandBarControl
Dim cmdctlOptionen  As CommandBarControl
Dim boAktiv         As Boolean

'Die Menuepunkte koennen eigentlich immer aktiv sein
'  If M_Report.DateiTyp(ActiveWorkbook) = DATEI_PROJEKT Then boAktiv = True
  
  Set cmdbar = Application.CommandBars("Worksheet Menu Bar")
'  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT)
'  If cmdctlReport Is Nothing Then Exit Sub
'  For Each cmdCtl In cmdctlReport.Controls
'    cmdCtl.Enabled = boAktiv
'  Next cmdCtl

  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_UPDTTEMPL, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPT_TMPL_UPDATE)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_QUICKSEL, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPT_QUICK_SEL)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_SCHEDULE, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPT_SCHEDULE)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_MAILINGLIST, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPT_MAILINGLIST)
  
  
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_OPTIONEN, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_OPTIONS)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_ARCHIVSTR, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_ARCH_STRUCT)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_BASISWERTE, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_BASIC_VAL)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_PROTTYP, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_REPORT_TYPES)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_STATUSBIT, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_STATUSBIT)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_MEDIA, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_MEDIA)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_TARIFFSET, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_TARIFFSET)
  Set cmdctlReport = cmdbar.FindControl(Tag:=MENUE_REPORT_COSTCENTER, Recursive:=True)
  cmdctlReport.Enabled = CheckPLPassword(False, PL_RPTCFG_COST_CENTER)
  
  
  ' Kennwort valid/invalid markieren
  Set cmdctlOptionen = cmdbar.FindControl(Tag:=MENUE_REPORT_KENNWORT, Recursive:=True)
  If cmdctlOptionen Is Nothing Then Exit Sub
  If CheckPassword(False, PL_RPTCFG_PASSWORD) Then
    cmdctlOptionen.FaceId = 1087
  Else
    cmdctlOptionen.FaceId = 1088
  End If

  
'  For Each cmdCtl In cmdbar.Controls(GetResText(19100)).Controls
'    cmdCtl.Enabled = boAktiv
'    If cmdCtl.Caption = GetResText(19110) Then
'      'Eintrag "Konfiguration" gefunden
'      If CheckPassword(False) Then
'        cmdCtl.Controls(1).FaceId = 1087
'      Else
'        cmdCtl.Controls(1).FaceId = 1088
'      End If
'    End If
'  Next cmdCtl

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_VorlagenNachziehen()
  If M_PVSSLogin.CheckPLPassword(True, PL_RPT_TMPL_UPDATE) Then  ' nur bei PVSS Login
    Call M_Vorlage.Nachziehen(True)
    DoEvents
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Optionen()
  
Dim cmdCtl As CommandBarControl
  
  On Error GoTo mnuReport_Optionen_Fehler
  
  If CheckPassword(True, PL_RPTCFG_OPTIONS) Then
    Call M_Optionen.coEdit
    
    ' IM 98626: keine Passworteingabe bei PVSS Login
    Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_REPORT_KENNWORT_CHG)
    If Not cmdCtl Is Nothing Then
      cmdCtl.Enabled = (Not M_Optionen.getOpt.LoginActive)
    End If
  End If
  
Exit Sub
mnuReport_Optionen_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::Optionen")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_MailVerteiler()
  
  On Error GoTo mnuReport_MailVerteiler_Fehler
  
  'If CheckPassword(True) Then
  If M_PVSSLogin.CheckPLPassword(True, PL_RPT_MAILINGLIST) Then  ' nur bei PVSS Login
    Call M_MailVerteiler.coEdit
  End If
  
Exit Sub
mnuReport_MailVerteiler_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_MailVerteiler::coEdit")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Kennwort()
  
  If M_Report.CheckPassword(False, PL_RPTCFG_PASSWORD) Then
    M_Report.ResetPasswordSession
  Else
    Call M_Report.CheckPassword(True, PL_RPTCFG_PASSWORD)
  End If
  DoEvents
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_KennwortAendern()
  
  M_Report.changePassword
  DoEvents
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Archivstruktur()
  
'Dim vDatei      As Variant
'Dim sDateiTypen As String

  On Error GoTo mnuReport_Archivstruktur_Fehler
  Call StatusTextAusgeben(GetResText(21326))
  
  If CheckPassword(True, PL_RPTCFG_ARCH_STRUCT) Then
    
'    sDateiTypen = "structures (*.csv), *.csv"
'    If msImportPath = "" Then msImportPath = ProjektPfad
'    Call SetCurrentDirectory(msImportPath)
'    vDatei = Application.GetOpenFilename(sDateiTypen, , GetResText(21325), , False)
'    If Not IsNumeric(vDatei) Then
'      If Len(vDatei) > 0 Then
'
'        msImportPath = getPath(CStr(vDatei))
'        Call M_Archiv.Import(vDatei)
        Call M_Archiv.Import
        
'      End If
'    End If
  End If
  Call StatusTextLoeschen(0)
  DoEvents
  
Exit Sub
mnuReport_Archivstruktur_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::Archivstruktur")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents

End Sub


'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Basiswerte()
  
  On Error GoTo mnuReport_Basiswerte_Fehler
  
  If CheckPassword(True, PL_RPTCFG_BASIC_VAL) Then
    Call M_Basiswert.coEdit
  End If
  DoEvents

Exit Sub
mnuReport_Basiswerte_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::Basiswerte")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub
'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_CostCenter()
  
  On Error GoTo mnuReport_CostCenter_Fehler
  
  If CheckPassword(True, PL_RPTCFG_COST_CENTER) Then
    Call M_CostCenter.coEdit
  End If
  DoEvents

Exit Sub
mnuReport_CostCenter_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::CostCenter")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub
'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Media()
  
  On Error GoTo mnuReport_Media_Fehler
  
  If CheckPassword(True, PL_RPTCFG_MEDIA) Then
    Call M_Media.coEdit
  End If
  DoEvents

Exit Sub
mnuReport_Media_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::Media")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub
'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Tariffset()
  
  On Error GoTo mnuReport_Tariffset_Fehler
  
  If CheckPassword(True, PL_RPTCFG_TARIFFSET) Then
    Call M_Tariffset.coEdit
  End If
  DoEvents

Exit Sub
mnuReport_Tariffset_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::Tariffset")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_ProtokollTypen()
  
  On Error GoTo mnuReport_ProtokollTypen_Fehler
  If CheckPassword(True, PL_RPTCFG_REPORT_TYPES) Then
    Call M_ProtokollTyp.Edit
  End If
  DoEvents

Exit Sub
mnuReport_ProtokollTypen_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::mnuReport_ProtokollTypen")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_StatusBit()
  
  On Error GoTo mnuReport_StatusBit_Fehler
  If CheckPassword(True, PL_RPTCFG_STATUSBIT) Then
    Call M_StatusBit.coEdit
  End If
  DoEvents

Exit Sub
mnuReport_StatusBit_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::mnuReport_StatusBit")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Schnellanwahl()

  On Error GoTo mnuReport_Schnellanwahl_Fehler
  
  If M_PVSSLogin.CheckPLPassword(True, PL_RPT_QUICK_SEL) Then  ' nur bei PVSS Login
    Call M_Schnellanwahl.coEdit
    DoEvents
  End If

Exit Sub
mnuReport_Schnellanwahl_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::mnuReport_Schnellanwahl")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_Zeitplan()

  On Error GoTo mnuReport_Zeitplan_Fehler
  
  If M_PVSSLogin.CheckPLPassword(True, PL_RPT_SCHEDULE) Then  ' nur bei PVSS Login
    Call M_ZeitPlan.coEdit
    DoEvents
  End If
  
Exit Sub
mnuReport_Zeitplan_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::mnuReport_Zeitplan")
  Call MsgBox(Err.Source & Chr(13) & Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
              
  Call StatusTextLoeschen(0)
  DoEvents

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub mnuInfo()

Dim vwInfo As V_Info

  Set vwInfo = New V_Info
  vwInfo.Show
  DoEvents
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuReport_DDETesten()
    
  On Error GoTo mnuReport_DDETesten_Fehler
  
  M_PVSS.PVSSStop
  M_PVSS.PVSSInit

  Call MsgBox(GetResText(21114), _
              vbOKOnly + vbInformation, _
              GetResText(20106))

Exit Sub
mnuReport_DDETesten_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Report::ReportStart")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
              
End Sub

'---------------------------------------------------------------------------------------------------
'Public Sub mnuReport_Konfiguration()
'  Call M_Report.Konfiguration
'  Call StatusTextLoeschen(0)
'End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage()

Dim cmdbar As CommandBar
Dim cmdCtl As CommandBarControl

Dim boAktiv As Boolean

  If M_Report.DateiTyp(ActiveWorkbook) = DATEI_VORLAGE Then boAktiv = True
  
  Set cmdbar = Application.CommandBars("Worksheet Menu Bar")
  Set cmdCtl = cmdbar.FindControl(Tag:=MENUE_VORLAGE)
  If cmdCtl Is Nothing Then Exit Sub
  On Error Resume Next
  cmdCtl.Controls(1).Enabled = CheckPLPassword(False, PL_TMPL_CHANGE) ' vlg neu
  cmdCtl.Controls(2).Enabled = CheckPLPassword(False, PL_TMPL_CHANGE) ' vlg oeffnen
  cmdCtl.Controls(3).Enabled = boAktiv
  cmdCtl.Controls(4).Enabled = boAktiv
  cmdCtl.Controls(5).Enabled = boAktiv
  If GetTabFormat(ActiveSheet) = BEZ_STD_PROTOKOLL Then
    cmdCtl.Controls(6).Enabled = boAktiv  ' IM 102541 WOKL: SheetOffset implemented
  Else
    cmdCtl.Controls(6).Enabled = False
  End If

  If GetTabFormat(ActiveSheet) = BEZ_SQL_PROTOKOLL Then
    cmdCtl.Controls(7).Enabled = False
    cmdCtl.Controls(8).Enabled = False
    cmdCtl.Controls(9).Enabled = True
  Else
    cmdCtl.Controls(7).Enabled = boAktiv
    cmdCtl.Controls(8).Enabled = boAktiv
    cmdCtl.Controls(9).Enabled = False
  End If
  cmdCtl.Controls(10).Enabled = boAktiv And M_PVSSLogin.PVSSLoginIsValid   ' vlg Bereich aendern
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_Neu()

  If M_PVSSLogin.CheckPLPassword(True, PL_TMPL_CHANGE) Then  ' nur bei PVSS Login
    Call M_Report.DateiNeu(DATEI_VORLAGE)
    Call StatusTextLoeschen(0)
    DoEvents
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_Oeffnen()

  If M_PVSSLogin.CheckPLPassword(True, PL_TMPL_CHANGE) Then  ' nur bei PVSS Login
    Call M_Report.DateiOeffnen(DATEI_VORLAGE)
    Call StatusTextLoeschen(0)
    DoEvents
  End If
    
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_Konfig()
  Call M_Vorlage.Konfigurieren
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_BlattEinfuegen()
  Call M_Vorlage.BlattEinfuegen
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_BlattLoeschen()
  Call M_Vorlage.BlattLoeschen
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_BlattOffset()
  Call M_Vorlage.BlattOffset
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_DPEinfuegen()
  Call M_Vorlage.DPEinfuegen
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_DPAendern()
  Call M_Vorlage.DPAendern
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_SQL()
  Call M_SQLVorlage.Edit
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuVorlage_BereichAendern()
  Call M_Vorlage.BereichAendern
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuProtokoll()
  
Dim cmdbar As CommandBar
Dim cmdCtl As CommandBarControl

Dim boAktiv As Boolean

  'If M_Report.DateiTyp = DATEI_PROJEKT Then boAktiv = True
  boAktiv = True 'Menue ist immer aktiv
  
  Set cmdbar = Application.CommandBars("Worksheet Menu Bar")
  Set cmdCtl = cmdbar.FindControl(Tag:=MENUE_PROTOKOLL)
  If Not cmdCtl Is Nothing Then
    For Each cmdCtl In cmdCtl.Controls
      cmdCtl.Enabled = boAktiv
    Next cmdCtl
  End If
  
  Set cmdCtl = cmdbar.FindControl(Tag:=MENUE_PROTOKOLL_SENDEN, Recursive:=True)
  If (Not cmdCtl Is Nothing) Then
    If (M_Report.DateiTyp(ActiveWorkbook) = DATEI_PROTOKOLL) Then
      cmdCtl.Enabled = True
    Else
      cmdCtl.Enabled = False
    End If
  End If

  Set cmdCtl = cmdbar.FindControl(Tag:=MENUE_PROTOKOLL_HTML, Recursive:=True)
  If (Not cmdCtl Is Nothing) Then
    If (M_Report.DateiTyp(ActiveWorkbook) = DATEI_PROTOKOLL) And _
       (Left(Application.Version, 1) <> "8") Then
      cmdCtl.Enabled = True
    Else
      cmdCtl.Enabled = False
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuProt_Neu()
  Call M_Report.DateiNeu(DATEI_PROTOKOLL)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuProt_Oeffnen()
  Call M_Report.DateiOeffnen(DATEI_PROTOKOLL)
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuProt_Senden()
  
Dim oProtokoll As C_Protokoll

  On Error GoTo mnuProt_Senden_Fehler

  If M_Report.DateiTyp(ActiveWorkbook) = DATEI_PROTOKOLL Then
    Set oProtokoll = M_Protokoll.DefLesen
    If oProtokoll Is Nothing Then Exit Sub
    
    Call M_MailVerteiler.Senden(oProtokoll)
  End If
  
Exit Sub
mnuProt_Senden_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::mnuProtSenden")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuProt_HTML()
  
Dim oProtokoll As C_Protokoll

  On Error GoTo mnuProt_Html_Fehler

  If M_Report.DateiTyp(ActiveWorkbook) = DATEI_PROTOKOLL Then
    Set oProtokoll = M_Protokoll.DefLesen
    If oProtokoll Is Nothing Then Exit Sub
    
    Call M_Protokoll.SpeichernHTML(oProtokoll)
  End If
  
Exit Sub
mnuProt_Html_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Menue::mnuProtHtml")
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  Call StatusTextLoeschen(0)
  DoEvents

End Sub


'---------------------------------------------------------------------------------------------------
Public Sub mnuDatei_Speichern()
  Call M_Report.DateiSpeichern
  Call StatusTextLoeschen(0)
  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuDatei_Neu()
'  Call M_Report.DateiNeu
'  Call StatusTextLoeschen(0)
'  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuDatei_Oeffnen()
'  Call M_Report.DateiOeffnen
'  Call StatusTextLoeschen(0)
'  DoEvents
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuDatei_Schliessen()
'  Call M_Report.DateiSchliessen
'  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuDatei_SpeichernUnter()

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuDatei_Beenden()
  Call M_Report.ProjektBeenden
  Call StatusTextLoeschen(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub mnuHelp_Report()

Dim s As String
Dim home As String
Dim rc As Integer
Dim pos As Integer
Dim oProjAdmin  As ProjAdmin

  ' IM 112462 WOKL 4.9.13
  ' IM 115629 WOKL 17.10.14
  Set oProjAdmin = New ProjAdmin
  Call oProjAdmin.ProjName2ConfigFile("3.16", home)
  pos = InStr(home, "\config\config")
  If (pos > 0) Then
    home = Left(home, pos - 1)
  Else
    home = Environ("PVSS_II_HOME")
  End If
  
  ' TFS 37563 change to QT help tool 'assistant' WOKL 16.4.18
  If (M_Optionen.getSpracheID() = 1) Then
    s = home + "\help\de_AT.utf8\WinCC_OA.qhc"
    If (Len(Dir(s)) <= 0) Then
      s = home + "\help\en_US.utf8\WinCC_OA.qhc"
    End If
  Else
    s = home + "\help\en_US.utf8\WinCC_OA.qhc"
  End If
  
  If (Len(Dir(s)) > 0) Then
    rc = ShellExecute(0, "Open", home & "\bin\assistant", _
                      " -showUrl qthelp://wincc_oa/doc/Excelreport/EXCELREPORT.htm -collectionFile " & s, _
                      vbNullString, vbNormalFocus)
  Else
    Call MsgBox(GetResText(21168), _
                    vbOKOnly + vbInformation, _
                    GetResText(20105))
  End If

End Sub

'--------------------------------------------------------------------------------------------------
Private Sub addCmdBarCtl(coCmdBarCtrl As CommandBarControls, iType As Integer, _
                         sCaption As String, sOnAction As String, _
                         iFaceId As Integer, boBeginGroup As Boolean)

  With coCmdBarCtrl.Add(Type:=iType)
    .Caption = sCaption
    .OnAction = sOnAction
    .FaceId = iFaceId
    .BeginGroup = boBeginGroup
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Sub SymbolleisteEinrichten()
  
Dim Menue               As CommandBarControl
Dim cmdctlDatei         As CommandBarControl
Dim cmdbarSymbolleiste  As CommandBar

Dim cmdbar    As CommandBar
Dim cocmdBar  As CommandBars

Dim cmdCtl    As CommandBarControl
Dim cocmdCtl  As CommandBarControls
Dim tst As CommandBarButton

  'Titelzeile von Excel bearbeiten
  Application.Caption = "WinCC OA Report"
  SymbolleisteWiederherstellen
  
  'Menueeintraege ausblenden
    '[TODO]
  '  For Each Menue In CommandBars("Worksheet Menu Bar").Controls
  '    If Menue.Caption <> "&Bearbeiten" And _
  '       Menue.Caption <> "Forma&t" Then
  '
  '      Menue.Visible = False
  '      Menue.Tag = MENUE_EINBLENDEN
  '    End If
  '  Next Menue
  
  'Symbolleisten ausblenden
    '[TODO]
  '  For Each Symbolleiste In Application.CommandBars
  '    'Debug.Print Symbolleiste.Name
  '    If Symbolleiste.Name <> "Worksheet Menu Bar" And _
  '       Symbolleiste.Name <> "Formatting" Then
  '
  '      If Symbolleiste.Visible Then
  '        Symbolleiste.Visible = False
  '        If Symbolleiste.Controls.Count > 0 Then
  '          Symbolleiste.Controls(1).Tag = MENUE_EINBLENDEN
  '        End If
  '      End If
  '    Else
  '      Symbolleiste.Visible = True
  '    End If
  '  Next Symbolleiste
  
  'Ueberschreiben der Standartbefehle im Menue und in den Symbolleisten
  
    'Befehle im Menue Datei bearbeiten
    Set cmdctlDatei = Application.CommandBars("Worksheet Menu Bar").FindControl(ID:=30002)
    If Not cmdctlDatei Is Nothing Then
      For Each cmdCtl In cmdctlDatei.Controls
        Call MenueBefehl(cmdCtl)
      Next cmdCtl
    End If
    
    'Befehle in der Standard Symbolleitse bearbeiten
    Set cmdbarSymbolleiste = Application.CommandBars("Standard")
    If Not cmdbarSymbolleiste Is Nothing Then
      For Each cmdCtl In cmdbarSymbolleiste.Controls
        Call MenueBefehl(cmdCtl)
      Next cmdCtl
    End If
    
  'Neue Menuebehle generieren

    'Menue Report
    Set Menue = CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup, before:=3)
    Menue.Tag = MENUE_REPORT
    Menue.Caption = GetResText(19100)
    Menue.OnAction = "mnuReport"

    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19102)
      .OnAction = "mnuReport_VorlagenNachziehen"
      .Tag = MENUE_REPORT_UPDTTEMPL
      .FaceId = 531
    End With
    
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19103)
      .OnAction = "mnuReport_Schnellanwahl"
      .Tag = MENUE_REPORT_QUICKSEL
      .FaceId = 531
    End With
      
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19104)
      .OnAction = "mnuReport_Zeitplan"
      .Tag = MENUE_REPORT_SCHEDULE
      .FaceId = 33
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19118)
      .OnAction = "mnuReport_MailVerteiler"
      .Tag = MENUE_REPORT_MAILINGLIST
      .FaceId = 262
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19111)
      .OnAction = "mnuReport_Kennwort"
      .Tag = MENUE_REPORT_KENNWORT
    End With

    
    '----- submenue Konfiguration
    '----- separator
    Set cmdCtl = Menue.Controls.Add(Type:=msoControlPopup)
    With cmdCtl
      .BeginGroup = True
      .Caption = GetResText(19110)  ' Konfiguration
    End With
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19119)
      .OnAction = "mnuReport_KennwortAendern"
      .FaceId = 225
      .Tag = MENUE_REPORT_KENNWORT_CHG
      .Enabled = (Not M_Optionen.getOpt.LoginActive)
    End With
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19112)
      .OnAction = "mnuReport_Optionen"
      .FaceId = 212
      .Tag = MENUE_REPORT_OPTIONEN
    End With
    
    '---- separator
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = True
      .Caption = GetResText(19113)
      .OnAction = "mnuReport_Archivstruktur"
      .Tag = MENUE_REPORT_ARCHIVSTR
      .FaceId = 523
    End With
    '---- separator
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = True
      .Caption = GetResText(19115)
      .OnAction = "mnuReport_Basiswerte"
      .Tag = MENUE_REPORT_BASISWERTE
      .FaceId = 300
    End With
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19116)
      .OnAction = "mnuReport_ProtokollTypen"
      .Tag = MENUE_REPORT_PROTTYP
      .FaceId = 800
    End With
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19117)
      .OnAction = "mnuReport_StatusBit"
      .Tag = MENUE_REPORT_STATUSBIT
      .FaceId = 896
    End With
    '---- separator
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = True
      .Caption = GetResText(19108)
      .OnAction = "mnuReport_Media"
      .Tag = MENUE_REPORT_MEDIA
      .FaceId = 300
    End With
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19106)
      .OnAction = "mnuReport_Tariffset"
      .Tag = MENUE_REPORT_TARIFFSET
      .FaceId = 300
    End With
    With cmdCtl.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19107)
      .OnAction = "mnuReport_CostCenter"
      .Tag = MENUE_REPORT_COSTCENTER
      .FaceId = 300
    End With
    
    

    '---- Fortsetzung Report-Menue
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = False
      .Caption = GetResText(19105)
      .OnAction = "mnuInfo"
      .FaceId = 49
    End With
    
    'Menue Vorlage
    Set Menue = CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup, before:=4)
    Menue.Tag = MENUE_VORLAGE
    Menue.Caption = GetResText(19200)
    Menue.OnAction = "mnuVorlage"
      
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19201)
      .OnAction = "mnuVorlage_Neu"
      .Tag = MENUE_VORLAGE_NEU
      'tabKonfig.imgVorlage_Neu.CopyPicture
      '.PasteFace
      .FaceId = 533
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19202)
      .OnAction = "mnuVorlage_Oeffnen"
      .Tag = MENUE_VORLAGE_OEFFNEN
      'tabKonfig.imgVorlage_Oeffnen.CopyPicture
      '.PasteFace
      .FaceId = 532
    End With
    
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = True
      .Caption = GetResText(19203)
      .OnAction = "mnuVorlage_Konfig"
      'tabKonfig.imgVorlage_Konfig.CopyPicture
      '.PasteFace
      .FaceId = 611
    End With
    
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = True
      .Caption = GetResText(19204)
      .OnAction = "mnuVorlage_BlattEinfuegen"
      'tabKonfig.imgVorlage_BlattEinfuegen.CopyPicture
      '.PasteFace
      .FaceId = 535
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19205)
      .OnAction = "mnuVorlage_BlattLoeschen"
      'tabKonfig.imgVorlage_BlattLoeschen.CopyPicture
      '.PasteFace
      .FaceId = 536
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19210)
      .OnAction = "mnuVorlage_BlattOffset"
      ' kein Icon
    End With
  
    With Menue.Controls.Add(Type:=msoControlButton)
      .BeginGroup = True
      .Caption = GetResText(19206)
      .OnAction = "mnuVorlage_DPEinfuegen"
      'tabKonfig.imgVorlage_DPEinfuegen.CopyPicture
      '.PasteFace
      .FaceId = 1589
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19207)
      .OnAction = "mnuVorlage_DPAendern"
      'tabKonfig.imgVorlage_DPAendern.CopyPicture
      '.PasteFace
      .FaceId = 1667
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19208)
      .OnAction = "mnuVorlage_SQL"
      .FaceId = 473
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19209)
      .OnAction = "mnuVorlage_BereichAendern"
      .FaceId = 531
    End With

  
    'Menue Protokoll
    Set Menue = CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup, before:=5)
    Menue.Tag = MENUE_PROTOKOLL
    Menue.Caption = GetResText(19300)
    Menue.OnAction = "mnuProtokoll"
      
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19301)
      .OnAction = "mnuProt_Neu"
      'tabKonfig.imgProtokoll_Neu.CopyPicture
      '.PasteFace
      .FaceId = 533
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19302)
      .OnAction = "mnuProt_Oeffnen"
      'tabKonfig.imgProtokoll_Oeffnen.CopyPicture
      '.PasteFace
      .FaceId = 532
    End With
    
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19303)
      .OnAction = "mnuProt_Senden"
      .FaceId = 262
      .Tag = MENUE_PROTOKOLL_SENDEN
    End With
    With Menue.Controls.Add(Type:=msoControlButton)
      .Caption = GetResText(19304)
      .OnAction = "mnuProt_HTML"
      .FaceId = 610
      .Tag = MENUE_PROTOKOLL_HTML
    End With
    
    'Befehle im Menue Help bearbeiten
    Set cmdCtl = Application.CommandBars("Worksheet Menu Bar").FindControl(ID:=30010)
    If Not cmdCtl Is Nothing Then
      With cmdCtl.Controls.Add(Type:=msoControlButton, before:=1)
        .Caption = "Report"
        .OnAction = "mnuHelp_Report"
        .FaceId = 49
        .Tag = MENUE_LOESCHEN
      End With
      cmdCtl.Controls(2).BeginGroup = True
    End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub MenueBefehl(cmdCtl As CommandBarControl)

  Select Case cmdCtl.ID
    
    'Neu
    Case 18, 2520
'      cmdCtl.OnAction = "mnuDatei_Neu"
'      cmdCtl.Tag = MENUE_RESET
 
    'Oeffnen
    Case 23
'      cmdCtl.OnAction = "mnuDatei_Oeffnen"
'      cmdCtl.Tag = MENUE_RESET
    
    'Speichern
    Case 3
      cmdCtl.OnAction = "mnuDatei_Speichern"
      cmdCtl.Tag = MENUE_RESET
 
    'Schliessen
    Case 106
'      cmdCtl.OnAction = "mnuDatei_Schliessen"
'      cmdCtl.Tag = MENUE_RESET
 
    'Beenden
    Case 752
'      cmdCtl.OnAction = "mnuDatei_Beenden"
'      cmdCtl.Tag = MENUE_RESET
 
  End Select

End Sub 'MenueBefehl()

'---------------------------------------------------------------------------------------------------
Sub SymbolleisteWiederherstellen()

Dim Menue As CommandBarControl
Dim Symbolleiste As CommandBar
Dim Symbolleisten As CommandBars
 
Dim cmdbar    As CommandBar
Dim cocmdBar  As CommandBars

Dim cmdCtl    As CommandBarControl
Dim cocmdCtl  As CommandBarControls
  
Dim i As Integer
  
  On Error GoTo SymbolleisteWiederherstellen_Fehler
  
  'Eigene Menueeintraege loeschen
  Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_REPORT)
  If Not cmdCtl Is Nothing Then
    cmdCtl.Delete
  End If
  Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_VORLAGE)
  If Not cmdCtl Is Nothing Then
    cmdCtl.Delete
  End If
  Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_PROTOKOLL)
  If Not cmdCtl Is Nothing Then
    cmdCtl.Delete
  End If
  
  'Titelzeile von Excel bearbeiten
  Application.Caption = ""
  i = 0
  Do While i < 100 '(mehr als 100 Befehle werden selten ueberschrieben...)
    Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_RESET)
    If cmdCtl Is Nothing Then Exit Do
    cmdCtl.Reset
    i = i + 1
  Loop

  i = 0
  Do While i < 100 '(mehr als 100 Befehle werden selten ueberschrieben...)
    Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_LOESCHEN)
    If cmdCtl Is Nothing Then Exit Do
    cmdCtl.Delete
    i = i + 1
  Loop



'  i = 0
'  Do While i < 100
'    i = i + 1
'    Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_EINBLENDEN)
'    If cmdCtl Is Nothing Then Exit Do
'
'    cmdCtl.Visible = True
'  Loop

'  i = 0
'  Do While i < 100
'    i = i + 1
'    Set cmdCtl = Application.CommandBars.FindControl(Tag:=MENUE_LOESCHEN)
'    If cmdCtl Is Nothing Then Exit Do
'
'    cmdCtl.Delete
'  Loop

'  Call SymbolleisteAktivieren
  
'  For Each Menue In CommandBars("Worksheet Menu Bar").Controls
'    If Menue.Tag = MENUE_EINBLENDEN Then
'      Menue.Visible = True
'      Menue.Tag = ""
'    ElseIf Menue.Tag = MENUE_LOESCHEN Then
'      Menue.Delete
'    End If
'    If Menue.Caption = "&Report" Or Menue.Caption = "&DP" Then
'      Menue.Delete
'    End If
'  Next Menue
  
'  Set Symbolleisten = Application.CommandBars
'  For Each Symbolleiste In Symbolleisten
'    If Symbolleiste.Controls.Count > 0 Then
'      If Symbolleiste.Controls(1).Tag = MENUE_EINBLENDEN Then
'        Symbolleiste.Visible = True
'        Symbolleiste.Controls(1).Tag = ""
'      ElseIf Symbolleiste.Controls(1).Tag = MENUE_EINBLENDEN Then
'        Symbolleiste.Delete
'      End If
'    End If
'  Next Symbolleiste
'
Exit Sub
SymbolleisteWiederherstellen_Fehler:
'  Call ErrMessage("Fehler " & Err.Number & " " & Err.Description & " IN " & _
'                  Err.Source, "M_Menue::SymbolleisteWiederherstellen")
  Resume Next
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub SymbolleisteDeaktivieren()
dummy
'Dim Menue As CommandBarControl
'Dim Symbolleiste As CommandBar
'Dim Symbol As CommandBarControl
'
'  Set Menue = CommandBars("Worksheet Menu Bar").Controls("&Bearbeiten")
'  Menue.Enabled = False
'  Set Menue = CommandBars("Worksheet Menu Bar").Controls("Forma&t")
'  Menue.Enabled = False
'
'  Set Symbolleiste = Application.CommandBars("Formatting")
'  For Each Symbol In Symbolleiste.Controls
'    'Debug.Print Symbol.Caption
'    Symbol.Enabled = False
'  Next Symbol

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub SymbolleisteAktivieren()
dummy
'Dim Menue As CommandBarControl
'Dim Symbolleiste As CommandBar
'Dim Symbol As Object
'
'  Set Menue = CommandBars("Worksheet Menu Bar").Controls("&Bearbeiten")
'  Menue.Enabled = True
'  Set Menue = CommandBars("Worksheet Menu Bar").Controls("Forma&t")
'  Menue.Enabled = True
'
'  Set Symbolleiste = Application.CommandBars("Formatting")
'  For Each Symbol In Symbolleiste.Controls
'    'Debug.Print Symbol.Caption
'    Symbol.Enabled = True
'  Next Symbol
'
End Sub

Attribute VB_Name = "M_Optionen"
'==================================================================================================
'M_Optionen
'Oliver Seidel 27.09.2000
'  Verwaltung der Optionen / Einstellungen fuer das Projekt. Da sehr oft auf C_Optionen fuer den
'  eigenen Host zugegriffen werden muss, wird das Objekt gepuffert.
'  Ueber den virtuellen Host '(Default)' wird eine Default Einstellung fuer alle Hosts definier.
'  Spezielle Einstellungen werden unter dem jeweiligen Hostnamen gespeichert.
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

Private moOptionen As C_Optionen
Private miSpracheID As Integer
Private TimerAutoLogout As C_Timer

'---------------------------------------------------------------------------------------------------
Public Function isPvssLogin() As Boolean
  Let isPvssLogin = getOpt.LoginActive
End Function

'---------------------------------------------------------------------------------------------------
Public Function getOpt() As C_Optionen

  If moOptionen Is Nothing Then
    Set moOptionen = Lesen(M_Tools.HostName)
    miSpracheID = moOptionen.SpracheID
  End If
  Set getOpt = moOptionen

End Function

'---------------------------------------------------------------------------------------------------
Public Function getSpracheID() As Integer
  
  If miSpracheID = 0 Then
    Select Case Application.International(xlCountryCode)
      Case 43, 49
        miSpracheID = 1
      Case Else
        miSpracheID = 2
    End Select
  End If
  getSpracheID = miSpracheID

End Function

'---------------------------------------------------------------------------------------------------
Public Function getDBProvider() As String
  
Dim sDBProvider As String
  sDBProvider = OptionLaden(HostName, "DBProvider")
  If sDBProvider = "" Then
    sDBProvider = "Microsoft.Jet.OLEDB.3.51"
  End If
  getDBProvider = sDBProvider
  
End Function

'---------------------------------------------------------------------------------------------------
Public Sub setDBProvider(sDBProvider As String)
  Call OptionSpeichern(HostName, "DBProvider", sDBProvider)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwOptionen As V_Optionen
Dim coOptionen As CO_Optionen
Dim oOptionen As C_Optionen

  On Error GoTo M_Optionen_Edit_Fehler
  
  Set vwOptionen = New V_Optionen
  Set coOptionen = M_Optionen.coLesen
  Set vwOptionen.Optionen = coOptionen
  vwOptionen.Show
  If vwOptionen.ok Then
    'Sieht lustig aus, aber auf Collection wird direkt referenziert
    'Aenderungen schlagen also automatisch durch!

    Set moOptionen = Nothing
    Call M_Optionen.coSpeichern(coOptionen)
    
    ' IM 102529 no pvss login if not allowed
    ' Login-Check (nur fuer eigenen Host) und ev. Ruecksetzen des Flags
    Set oOptionen = M_Optionen.getOpt
    If (oOptionen.LoginActive = True) Then
      If CheckPassword(True, PL_RPTCFG_OPTIONS) <> True Then
        oOptionen.LoginActive = False   ' reset
        Call coOptionen.Remove(oOptionen.host)
        Call coOptionen.Add(oOptionen)
        Call M_Optionen.coSpeichern(coOptionen)
      End If
    End If
    
  End If
  'ToDo: Falls coOptionen gepuffert wird, muss nach einem Abbruch der
  'Bearbeitung der Puffer geloescht werden!
  
  Unload vwOptionen
  Set vwOptionen = Nothing

Exit Sub
M_Optionen_Edit_Fehler:
  
  If Not vwOptionen Is Nothing Then
    Unload vwOptionen
    Set vwOptionen = Nothing
  End If
  Call FehlerAusloesen(30702, , False, "M_Optionen::coEdit")
  
End Sub 'coEdit()

'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_Optionen

Dim recOptionen As ADODB.Recordset
Dim sSql        As String
Dim oOptionen   As C_Optionen

  On Error GoTo Optionen_Lesen_Fehler

  Set coLesen = New CO_Optionen
  sSql = "SELECT * FROM tabOptionen"
  Set recOptionen = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recOptionen.EOF
    Set oOptionen = New C_Optionen
    With oOptionen
      .ID = recOptionen.Fields("ID")
      .host = CDBStr(recOptionen.Fields("Host"))
      .HostZeitplan = CDBStr(recOptionen.Fields("HostZeitplan"))
      .UserPwd = CDBStr(recOptionen.Fields("wbPasswort"))
      
      .ComManConfig = CDBStr(recOptionen.Fields("ComManConfig"))
      If .ComManConfig = "" Then
        .ComManConfig = getConfigFile()
      End If
      .ComManPara = CDBStr(recOptionen.Fields("ComManPara"))
      
      .FilterDP = CDBStr(recOptionen.Fields("FilterDP"))
      If Len(.FilterDP) = 0 Then .FilterDP = "DP"
      .Auswahl = CDBStr(recOptionen.Fields("Auswahl"))
      If Len(.Auswahl) = 0 Then .Auswahl = "*"
      
      .SpracheID = recOptionen.Fields("SpracheID")
      'If .SpracheID = 0 Then .SpracheID = getSpracheID
      
      .SynchZeit = recOptionen.Fields("SynchZeit")
      
      .HTMLPfad = CDBStr(recOptionen.Fields("HTMLPath"))
      .LoginActive = recOptionen.Fields("LoginActive")
      .AutoLogout = recOptionen.Fields("AutoLogout")
      .DpInsExtend = recOptionen.Fields("DpInsExtend")
      
    End With
    
    recOptionen.MoveNext
    coLesen.Add oOptionen
  Wend
  
  Call M_DB.CloseRecordset(recOptionen)
  
  'Defaulteinstellungen sollte es immer geben!
  If coLesen.FindItem(DEFAULT_CONFIG) Is Nothing Then
    Set oOptionen = Lesen(M_Tools.HostName)
    oOptionen.host = DEFAULT_CONFIG
    coLesen.Add oOptionen
  End If

Exit Function
Optionen_Lesen_Fehler:
  
  Call M_DB.CloseRecordset(recOptionen)
  If Not oOptionen Is Nothing Then
    Call FehlerAusloesen(30700, "Optionen: " & oOptionen.host, False, "M_Optionen::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Optionen::coLesen")
  End If

End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Public Function Lesen(sHost As String) As C_Optionen

Dim recOptionen  As ADODB.Recordset
Dim oOptionen    As C_Optionen
Dim sSql          As String
Dim s As String
Dim i As Integer

  On Error GoTo Optionen_Lesen_Fehler

  Set oOptionen = New C_Optionen
  
  sSql = "SELECT * FROM tabOptionen WHERE Host = '" & sHost & "';"
  Set recOptionen = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  If recOptionen.EOF Then
    recOptionen.Close
    sSql = "SELECT * FROM tabOptionen WHERE Host = '" & DEFAULT_CONFIG & "';"
    Set recOptionen = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  End If
  
  If Not recOptionen.EOF Then
    With oOptionen
      .ID = recOptionen.Fields("ID")
      .host = CDBStr(recOptionen.Fields("Host"))
      .HostZeitplan = CDBStr(recOptionen.Fields("HostZeitplan"))
      .UserPwd = CDBStr(recOptionen.Fields("wbPasswort"))
      .LoginActive = recOptionen.Fields("LoginActive")
      .AutoLogout = recOptionen.Fields("AutoLogout")
      
      .ComManConfig = CDBStr(recOptionen.Fields("ComManConfig"))
      If .ComManConfig = "" Then
        .ComManConfig = getConfigFile()
      End If
      .ComManPara = CDBStr(recOptionen.Fields("ComManPara"))
      
      .FilterDP = CDBStr(recOptionen.Fields("FilterDP"))
      If Len(.FilterDP) = 0 Then .FilterDP = "*"
      .Auswahl = CDBStr(recOptionen.Fields("Auswahl"))
      If Len(.Auswahl) = 0 Then .Auswahl = "DP"
      .SpracheID = recOptionen.Fields("SpracheID")
      'If .SpracheID = 0 Then .SpracheID = getSpracheID
    
      .SynchZeit = recOptionen.Fields("SynchZeit")
      
      .HTMLPfad = CDBStr(recOptionen.Fields("HTMLPath"))
      .DpInsExtend = CDBStr(recOptionen.Fields("DpInsExtend"))
      
    End With
  Else
    With oOptionen
      .host = DEFAULT_CONFIG
      .HostZeitplan = M_Tools.HostName
      .UserPwd = "erAdmin"
      .LoginActive = False
      'In PVSS II 3.0 wird diese Veriable nicht mehr von der Console gelesen...
      's = Environ("PVSS_II")
      .ComManConfig = getConfigFile
      
      .SynchZeit = 0
    
      s = M_Tools.ProjektPfad
      i = InStr(1, UCase(s), "\DATA\XLS_REPORT")
      If i > 0 Then
        .HTMLPfad = s & "\html"
      Else
        s = ""
      End If
    
    End With
  
  End If
'  If (Not oOptionen.LoginActive) Then
'    M_PVSSLogin.PVSSLoginName = ""
'  End If
  
  Call M_DB.CloseRecordset(recOptionen)
  
  'Allgemeine Optionen fuer das Projekt
  With oOptionen
    .ProtFormat(1) = BEZ_STD_PROTOKOLL
    .ProtFormat(2) = BEZ_ATV_PROTOKOLL
    .ProtFormat(3) = BEZ_BTR_PROTOKOLL
    .ProtFormat(4) = BEZ_SQL_PROTOKOLL
    .ProtFormat(5) = BEZ_KST_PROTOKOLL
  End With
  
  Set Lesen = oOptionen
  
Exit Function
Optionen_Lesen_Fehler:
  
  'Keine Fehlermeldung?
  Stop
  
  Call M_DB.CloseRecordset(recOptionen)
  
  If Not oOptionen Is Nothing Then
    Call FehlerAusloesen(30705, "Optionen: " & oOptionen.host, False, "M_Optionen::Lesen")
  Else
    Call FehlerAusloesen(30705, Err.Description, False, "M_Optionen::Lesen")
  End If

End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coOptionen As CO_Optionen)

Dim recOptionen  As ADODB.Recordset
Dim oOptionen    As C_Optionen
Dim recArchiv     As ADODB.Recordset
Dim sSql          As String
Dim lLoeschen     As Long
Dim iNeueSprache  As Integer

  On Error GoTo Optionen_Speichern_Fehler

  sSql = "UPDATE tabOptionen SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen
  
  sSql = "SELECT * FROM tabOptionen"
  Set recOptionen = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  For Each oOptionen In coOptionen.Items
    
    If recOptionen.BOF And recOptionen.EOF Then
      recOptionen.AddNew
    Else
      recOptionen.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recOptionen.Find "ID = " & oOptionen.ID, , adSearchForward
      If recOptionen.EOF Then
        recOptionen.AddNew
      Else
        'recOptionen.Edit
        recOptionen.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    With oOptionen
      'recOptionen.Fields("ID") = .ID
      recOptionen.Fields("Host") = .host
      recOptionen.Fields("HostZeitplan") = .HostZeitplan
      recOptionen.Fields("wbPasswort") = .UserPwd
      recOptionen.Fields("LoginActive") = .LoginActive
      recOptionen.Fields("AutoLogout") = .AutoLogout
      
      If .host = DEFAULT_CONFIG Then
        recOptionen.Fields("ComManConfig") = ""
      Else
        recOptionen.Fields("ComManConfig") = .ComManConfig
      End If
      recOptionen.Fields("ComManPara") = .ComManPara
      
      recOptionen.Fields("FilterDP") = .FilterDP
      recOptionen.Fields("Auswahl") = .Auswahl
      recOptionen.Fields("SpracheID") = .SpracheID
      If .host = DEFAULT_CONFIG And iNeueSprache = 0 Then
        iNeueSprache = .SpracheID
      ElseIf .host = HostName Then
        iNeueSprache = .SpracheID
      End If
    
      recOptionen.Fields("SynchZeit") = .SynchZeit
      recOptionen.Fields("HTMLPath") = .HTMLPfad
      recOptionen.Fields("DpInsExtend") = .DpInsExtend
      
    End With
    
    recOptionen.Update
    'recOptionen.Bookmark = recOptionen.LastModified
    oOptionen.ID = recOptionen.Fields("ID")

  Next oOptionen
  
  sSql = "DELETE FROM tabOptionen WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql

  Call M_DB.CloseRecordset(recOptionen)
  
  'Online Sprachumschaltung
  If miSpracheID <> iNeueSprache Then
    miSpracheID = iNeueSprache
    M_Menue.SymbolleisteWiederherstellen
    M_Menue.SymbolleisteEinrichten
    TabMenue.Anzeigen
  End If
  
Exit Sub
Optionen_Speichern_Fehler:
  
  Call M_DB.CloseRecordset(recOptionen)
  Call ErrMessage("sSQL: " & sSql, "M_Optionen::coSpeichern")
  If Not oOptionen Is Nothing Then
    Call FehlerAusloesen(30703, "Optionen: " & oOptionen.host, _
                        False, "M_Optionen::coSpeichern")
  Else
    Call FehlerAusloesen(30703, Err.Description, _
                        False, "M_Optionen::coSpeichern")
  End If

End Sub 'coSpeichern()

'---------------------------------------------------------------------------------------------------
Public Sub getSprachen(asSprache() As String)

Dim rgSprache As Range
Dim n As Long

  ReDim asSprache(0)
  For Each rgSprache In SelectRange(ThisWorkbook.Worksheets("Texte").Range("C1"), , False, 1)
    If (Left(rgSprache.Text, 1) = "#") Then Exit For
    n = n + 1
    ReDim Preserve asSprache(n)
    asSprache(n) = rgSprache.Text
  Next rgSprache

End Sub 'getSprachen()

'---------------------------------------------------------------------------------------------------
' holt den config dateinamen aus dem aktuellen Projekt
Public Function getConfigFile() As String

Dim oProjAdmin  As ProjAdmin
Dim sProjName   As String
Dim sConfigFile As String
Dim iErr        As Long

  Set oProjAdmin = New ProjAdmin
  iErr = oProjAdmin.GetActProj(sProjName)
  If iErr = 0 Then
    iErr = oProjAdmin.ProjName2ConfigFile(sProjName, sConfigFile)
  End If
  If iErr = 0 Then
    getConfigFile = sConfigFile
  Else
    getConfigFile = ""
  End If
  
End Function

'---------------------------------------------------------------------------------------------------
Public Function checkConfigFile(sConfigFile As String) As Boolean

Dim oProjAdmin  As ProjAdmin
Dim iErr        As Long

  Set oProjAdmin = New ProjAdmin
  iErr = oProjAdmin.checkConfigFile(sConfigFile, 1)
  checkConfigFile = (iErr = 0)
  
End Function
'---------------------------------------------------------------------------------------------------
Public Sub AutoLogoutReset()
  
  If (moOptionen.AutoLogout > 0) Then
    Call TimerAutoLogout.Reset
  End If

End Sub
'---------------------------------------------------------------------------------------------------
Public Sub AutoLogoutInit()

  If (moOptionen.AutoLogout > 0) Then
    If TimerAutoLogout Is Nothing Then
      Set TimerAutoLogout = New C_Timer
      TimerAutoLogout.Funktion = TimerAutoLogout.FktAutoLogout
    End If
    Call TimerAutoLogout.Reset
    Call TimerAutoLogout.init(moOptionen.AutoLogout * 60000)
    'Call BugMessage("AutoLogout activate: " + CStr(moOptionen.AutoLogout), _
    '                "M_Optionen::AutoLogoutInit")
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub AutoLogoutCB()

  Call M_Report.ResetPasswordSession
  Call TimerAutoLogout.Reset
  Call BugMessage("AutoLogout activate: " + CStr(moOptionen.AutoLogout), _
                  "M_Optionen::AutoLogoutCB")
  
End Sub
Attribute VB_Name = "M_PVSS"
'==================================================================================================
'M_PVSS
'Oliver Seidel 13.10.2000
'
'Bietet Zugriff auf PVSS ueber den ComManager
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

Private moComMan    As ComManager
Private moReportExt As reportExt
Private moComCB     As C_ComCB

'---------------------------------------------------------------------------------------------------
Public Function useDDE() As Boolean
  useDDE = False
End Function

'---------------------------------------------------------------------------------------------------
Public Sub dpGet(sDpName As String, vValue As Variant)

Dim asDpName(0) As String
Dim v           As Variant
  
  On Error GoTo M_PVSS_dpGet_Fehler
  If moComMan Is Nothing Then
    PVSSInit
  End If
  asDpName(0) = sDpName
  Call BugMessage("sDpName = " & sDpName, "M_PVSS::dpGet")
  Call moComMan.dpGet(asDpName, v)
  vValue = v(0)
  Call BugMessage("vValue = " & vValue, "M_PVSS::dpGet")

Exit Sub
M_PVSS_dpGet_Fehler:
  Call FehlerAusloesen(ERR_PVSS_DP_GET, , False)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub SQLQuery(sSql As String, vDaten As Variant)

  On Error GoTo SQLQuery_Fehler

  If moComMan Is Nothing Then
    PVSSInit
  End If
  Call BugMessage("sSQL = " & sSql, "M_PVSS::dpQuery")
  Call moComMan.dpQuery(sSql, vDaten)
Exit Sub
SQLQuery_Fehler:
  'Stop
  'Resume
  Resume Next
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Werte(ByRef oProtokoll As C_Protokoll, ByRef coDP As CO_DP)

Dim fStatus   As Single
Dim lStatusId As Long
Dim oDpGroup  As C_DPGruppe
Dim n         As Long
Dim nMax      As Long
Dim adTime()  As Date
Dim v         As Variant
Dim hasOffset As Boolean
Dim insertCount As Long
  On Error GoTo Werte_Fehler
  lStatusId = StatusTextAusgeben(GetResText(21315))
  
  PVSSInit
  
  With oProtokoll
    Call moReportExt.getTimeList(.Von, .Bis, .Intervall, .IntEinheit, adTime)
        
    ' IM 93881 WOKL 18.8.09: Schalttag auch in Jahren, wo keiner ist ...
    ' wenn Jahresprotokoll und kein Schaltjahr und DPs mit Offset da sind
    If (.Intervall = 1 And .IntEinheit = erTag) Then
      hasOffset = False
      For n = 1 To coDP.Count
        If Not coDP.Item(n).Offset = 0 Then
          hasOffset = True
          Exit For
        End If
      Next n
      If (hasOffset) Then
        insertCount = 0       ' suche den 28. Februar, merke Index fuer day-after
        For n = 1 To UBound(adTime)
          If (Month(adTime(n)) = 2 And Day(adTime(n)) = 28) Then
             insertCount = n + 1
             Exit For
          End If
        Next n
      
        ' wenn es keinen 29. Februar (nona) gibt, dann einfuegen
        ' IM 98736: WOKL 12.4.10 Bedinung zerlegt, da sonst out-of-bounds Fehler
        If (insertCount > 0 And insertCount < UBound(adTime)) Then
          If (Not Day(adTime(insertCount)) = 29) Then
            ReDim Preserve adTime(UBound(adTime) + 1)
            .IntercalaryExcp = insertCount
            For n = UBound(adTime) - 1 To insertCount Step -1
              adTime(n + 1) = adTime(n)
            Next n
            adTime(insertCount) = #2/29/2000#    ' CDate("29 feb 2000")
          End If
        End If
      End If
    End If

    .avTime = adTime
  End With
  
  nMax = coDP.GroupItems.Count
  For Each oDpGroup In coDP.GroupItems
    n = n + 1
    fStatus = Aufrunden(n / nMax * 100)
    Call StatusTextAusgeben(GetResText(21315) & " " & fStatus & "%", lStatusId)
    Select Case oDpGroup.ArchivTyp
      
      Case ARCHIVTYP_ACPERIODE, _
           ARCHIVTYP_RACPERIODE, _
           ARCHIVTYP_HDBPERIODE, _
           ARCHIVTYP_RDBPERIODE
        Call dpWertePeriode(oProtokoll, oDpGroup)
      
      Case ARCHIVTYP_ACSINGLE, _
           ARCHIVTYP_HDBSINGLE, _
           ARCHIVTYP_RACSINGLE, _
           ARCHIVTYP_RDBSINGLE
        Call dpWerteSingle(oProtokoll, oDpGroup)
      
      Case ARCHIVTYP_ONLINE
        Call dpWerteOnline(oProtokoll, oDpGroup)
    
    End Select
  Next oDpGroup
  
  Call updateDpInfo(coDP)
  StatusTextLoeschen (lStatusId)
  
Exit Sub
Werte_Fehler:
  'Stop
  'Resume
  If Err.Number = ERR_PVSS_NOLICENSE Then
    Call FehlerAusloesen(ERR_PVSS_NOLICENSE, , False)
  End If
  'Resume Next
  Call FehlerAusloesen(ERR_PVSS_DP_WERT)
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub updateDpInfo(coDP As CO_DP)

Dim oDP   As C_DP
Dim sDP   As String
Dim v     As Variant

  'On Error Resume Next
  For Each oDP In coDP.Items
    If oDP.ArchivTyp = ARCHIVTYP_ACPERIODE Or _
       oDP.ArchivTyp = ARCHIVTYP_ACSINGLE Then
      If oDP.dpe = "" Then
        sDP = oDP.dp & ".value"
      Else
        sDP = oDP.dp & "." & oDP.dpe & ".value"
      End If
    Else
      sDP = oDP.Archiv
    End If
    v = moComMan.dpGetDescription(sDP)
    If Not IsError(v) Then oDP.Kommentar = CStr(v)
    v = moComMan.dpGetAlias(sDP)
    If Not IsError(v) Then oDP.Alias = CStr(v)
    v = moComMan.dpGetFormat(sDP)
    If Not IsError(v) Then oDP.Format = CStr(v)
    v = moComMan.dpGetUnit(sDP)
    If Not IsError(v) Then oDP.Einheit = CStr(v)
  Next oDP

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub dpWertePeriode(oProt As C_Protokoll, oDpGroup As C_DPGruppe)

Dim oDP         As C_DP
Dim lDpId       As Long
Dim asArchiv()  As String
Dim asStatFct() As String

Dim adTime()    As Date
Dim avWert      As Variant

'Dim lVerdichten As Long
Dim vWert   As Variant
Dim vEmpty  As Variant
Dim lOffset As Long
'Dim vStat   As Variant
'Dim nAnz    As Long
  
'Dim dtAkt   As Date
'Dim dtNext  As Date
Dim n As Long
Dim m As Long

  On Error GoTo dpWertePeriode
  ReDim asArchiv(2 * oDpGroup.coDP.Count)
  ReDim asStatFct(2 * oDpGroup.coDP.Count)
  If oDpGroup.coDP.Count < 1 Then
    Exit Sub
  End If

  If oDpGroup.ArchivTyp = ARCHIVTYP_ACPERIODE Then
  
    lDpId = 1
    For Each oDP In oDpGroup.coDP
      asArchiv(lDpId) = oDP.Archiv & ":_offline.._value"
      asStatFct(lDpId) = oDP.ArchivFkt
      asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"
      asStatFct(lDpId + 1) = "ValueState"
      lDpId = lDpId + 2
    Next oDP
    
    Call moReportExt.dpGetPeriodIntervall(oDpGroup.Von, oDpGroup.Bis, _
                                       oProt.Intervall, oProt.IntEinheit, _
                                       asArchiv, asStatFct, _
                                       avWert, adTime)
    
    DoEvents
  
  ElseIf oDpGroup.ArchivTyp = ARCHIVTYP_RACPERIODE Then
  
    lDpId = 1
    For Each oDP In oDpGroup.coDP
      asArchiv(lDpId) = oDP.Archiv & ":_offline." & rdbCompressionDetail(oDP.IntEinheit, oDP.Intervall, oDP.ArchivFkt) & "._value"
      asStatFct(lDpId) = oDP.ArchivFkt
      asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"   ' there is no explicit status for rdb compression
      asStatFct(lDpId + 1) = "ValueState"
      lDpId = lDpId + 2
    Next oDP
    
    Call moReportExt.dpGetPeriodIntervall(oDpGroup.Von, oDpGroup.Bis, _
                                       oProt.Intervall, oProt.IntEinheit, _
                                       asArchiv, asStatFct, _
                                       avWert, adTime)
    
    DoEvents
  
  ElseIf oDpGroup.ArchivTyp = ARCHIVTYP_HDBPERIODE Then
    lDpId = 1
    For Each oDP In oDpGroup.coDP
      asArchiv(lDpId) = oDP.Archiv & ":" & oDP.ArchivFkt
      asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"
      lDpId = lDpId + 2
    Next oDP
    Call moReportExt.dpGetAsynchIntervall(oDpGroup.Von, oDpGroup.Bis, _
                                       oProt.Intervall, oProt.IntEinheit, _
                                       asArchiv, avWert, adTime)
  
    DoEvents
  ElseIf oDpGroup.ArchivTyp = ARCHIVTYP_RDBPERIODE Then
    lDpId = 1
    For Each oDP In oDpGroup.coDP
      asArchiv(lDpId) = oDP.Archiv & ":_offline." & oDP.ArchivFkt & "._value"
      asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"
      lDpId = lDpId + 2
    Next oDP
    Call moReportExt.dpGetAsynchIntervall(oDpGroup.Von, oDpGroup.Bis, _
                                       oProt.Intervall, oProt.IntEinheit, _
                                       asArchiv, avWert, adTime)
  
    DoEvents
  Else
    Exit Sub
  End If
  
  'ToDo: Fehlermeldung im Fehlerprotkoll
  ' 24.5.07 IM 79800 WOKL: Fehlerbehandlung eingebaut
  If UBound(adTime) = -1 Then
    On Error GoTo dpWerteError
    Call FehlerAusloesen(ERR_PVSS_QUERY_ABORTED)
  End If
  If IsEmpty(avWert) Or IsEmpty(adTime) Then Exit Sub
  If (Not IsArray(avWert)) Or (Not IsArray(adTime)) Then Exit Sub
  lDpId = 1
  'nAnz = UBound(adTime)
  For Each oDP In oDpGroup.coDP
    'If IsArray(vWerte(lDpId)) And IsArray(vWerte(lDpId + 1)) Then
      lOffset = 0
      For n = 1 To UBound(adTime) 'nAnz
        'Debug.Print lDpId, n, m, vZeit(n)
        'dtNext = adTime(n)
        m = oProt.getValueIndex(adTime(n), m)
        'Debug.Print "ok", m
        While ((m - n) > lOffset)
          Call oDP.AddValue(vEmpty, adTime(n), vEmpty)
          lOffset = lOffset + 1
        Wend
        If ((m - n) = lOffset) Then
          Call oDP.AddValue(avWert(lDpId, n), adTime(n), avWert(lDpId + 1, n))
        Else
          lOffset = lOffset - 1
        End If
      Next n
   'End If

   lDpId = lDpId + 2
 Next oDP

Exit Sub
dpWertePeriode:
  'Stop
  'Resume
  Resume Next
  
dpWerteError:
  ' 24.5.07 IM 79800 WOKL: Fehlerbehandlung eingebaut
 Call Err.Raise(ERR_PVSS_QUERY_ABORTED, "Query aborted")
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub dpWerteSingle(oProt As C_Protokoll, oDpGroup As C_DPGruppe)

Dim oDP         As C_DP
Dim lDpId       As Long
Dim asArchiv()  As String
Dim vWerte      As Variant
Dim boInterm    As Boolean
Dim vWert       As Variant
Dim rc          As Integer

  On Error GoTo dpWerteSingle_Fehler
  
  boInterm = False
  lDpId = 0
  ReDim asArchiv(2 * oDpGroup.coDP.Count - 1)
  
  If oDpGroup.ArchivTyp = ARCHIVTYP_ACSINGLE Then
    If oDpGroup.Bis < Now Then
      For Each oDP In oDpGroup.coDP
        asArchiv(lDpId) = oDP.Archiv & ":_offline.._value"
        asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"
        lDpId = lDpId + 2
      Next oDP
      Call moComMan.dpGetAsynch(oDpGroup.Von, asArchiv, vWerte)
      'DoEvents
    Else
      For Each oDP In oDpGroup.coDP
        asArchiv(lDpId) = oDP.Archiv & ":_dp_fct.._interm"
        asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"
        lDpId = lDpId + 2
      Next oDP
      boInterm = True
      Call moComMan.dpGet(asArchiv, vWerte)
      'DoEvents
    End If
  ElseIf oDpGroup.ArchivTyp = ARCHIVTYP_HDBSINGLE Then
    For Each oDP In oDpGroup.coDP
      asArchiv(lDpId) = oDP.Archiv & ":" & oDP.ArchivFkt
      asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"
      lDpId = lDpId + 2
    Next oDP
    Call moComMan.dpGetAsynch(oDpGroup.Von, asArchiv, vWerte)
    'DoEvents
  ElseIf oDpGroup.ArchivTyp = ARCHIVTYP_RDBSINGLE Then
    For Each oDP In oDpGroup.coDP
      asArchiv(lDpId) = oDP.Archiv & ":" & oDP.ArchivFkt
      asArchiv(lDpId + 1) = oDP.Archiv & ":_offline.._status64"
      lDpId = lDpId + 2
    Next oDP
    Call moComMan.dpGetAsynch(oDpGroup.Von, asArchiv, vWerte)
  ElseIf oDpGroup.ArchivTyp = ARCHIVTYP_RACSINGLE Then
    ReDim vWerte(2 * oDpGroup.coDP.Count - 1) As Variant
    ReDim asArchiv(1)
    For Each oDP In oDpGroup.coDP
      asArchiv(0) = oDP.Archiv & ":_offline." & rdbCompressionDetail(oDP.IntEinheit, oDP.Intervall, oDP.ArchivFkt) & "._value"
      asArchiv(1) = oDP.Archiv & ":_offline.._status64"   ' no real state in RDB
      Call moComMan.dpGetAsynch(oDpGroup.Von, asArchiv, vWert)
      vWerte(lDpId) = vWert(0)
      vWerte(lDpId + 1) = vWert(1)
      lDpId = lDpId + 2
    Next oDP
  Else
    Exit Sub
  End If
  
  'ToDo: Fehlermeldung im Fehlerprotkoll
  If IsEmpty(vWerte) Then Exit Sub
  If Not IsArray(vWerte) Then Exit Sub
    
  lDpId = 0
  For Each oDP In oDpGroup.coDP
    If Not IsError(vWerte(lDpId)) And Not IsError(vWerte(lDpId + 1)) Then
      If boInterm Then
        'Notloesung bis COM es richtig liefert
        Call oDP.AddValue(CPVSSValue(vWerte(lDpId)), oDP.Von, vWerte(lDpId + 1))
      Else
        Call oDP.AddValue(vWerte(lDpId), oDP.Von, vWerte(lDpId + 1))
      End If
    End If
    lDpId = lDpId + 2
  Next oDP
    
Exit Sub
dpWerteSingle_Fehler:
  'Stop
  'Resume
  Resume Next
End Sub

''---------------------------------------------------------------------------------------------------
'Private Sub dpWerteHDBSingle(oProt As C_Protokoll, oDpGroup As C_DPGruppe)
'
'Dim oDp         As C_DP
'Dim lDpId       As Long
'Dim asArchiv()  As String
'
'Dim dtAkt       As Date
'Dim dtBis       As Date
'Dim iOffset     As Integer
'Dim lZeitpunkt  As Long
'
'Dim vWerte      As Variant
'
'  ReDim asArchiv(2 * oDpGroup.coDP.Count - 1)
'
'  If oDpGroup.coDP.Count < 1 Then
'    Exit Sub
'  End If
'  With oDpGroup.coDP.Item(1)
'    iOffset = .Offset
'    dtBis = .Bis
'  End With
'
'  lDpId = 0
'  For Each oDp In oDpGroup.coDP
'    asArchiv(lDpId) = oDp.Archiv & ":" & oDp.ArchivFkt
'    asArchiv(lDpId + 1) = oDp.Archiv & ":_offline.._status"
'    lDpId = lDpId + 2
'  Next oDp
'
'  lZeitpunkt = 0
'  dtAkt = oProt.Zeitpunkt(lZeitpunkt, iOffset)
'  Do
'    Call moComMan.dpGetAsynch(dtAkt, asArchiv, vWerte)
'    If IsEmpty(vWerte) Then Exit Sub
'    If Not IsArray(vWerte) Then Exit Sub
'
'    lDpId = 0
'    For Each oDp In oDpGroup.coDP
'      If Not IsError(vWerte(lDpId)) And Not IsError(vWerte(lDpId + 1)) Then
'        Call oDp.AddValue(vWerte(lDpId), dtAkt, vWerte(lDpId + 1))
'        lDpId = lDpId + 2
'      End If
'    Next oDp
'
'    lZeitpunkt = lZeitpunkt + 1
'    dtAkt = oProt.Zeitpunkt(lZeitpunkt, iOffset)
'  Loop While (dtAkt <= dtBis) And (dtAkt <= Now)
'
'End Sub
'
'---------------------------------------------------------------------------------------------------
Private Sub dpWerteOnline(oProt As C_Protokoll, oDpGroup As C_DPGruppe)
  
Dim oDP         As C_DP
Dim lDpId       As Long
Dim asArchiv()  As String

Dim dtAkt       As Date
Dim vWerte      As Variant

  On Error GoTo dpWerteOnline_Fehler

  If oDpGroup.coDP.Count < 1 Then
    Exit Sub
  End If
  
  lDpId = 0
  ReDim asArchiv(2 * oDpGroup.coDP.Count - 1)
  For Each oDP In oDpGroup.coDP
    asArchiv(lDpId) = oDP.Archiv & ":" & oDP.ArchivFkt
    'Der Status vom DPE kann mehrfach auftauchen, wenn unterschiedliche Configs
    'abgefragt werden. Optimierung evtl. ueber Querverweisliste vornehmen
    asArchiv(lDpId + 1) = oDP.Archiv & ":_online.._status64"
    lDpId = lDpId + 2
  Next oDP

  Call moComMan.dpGet(asArchiv, vWerte)
  'DoEvents
  If IsEmpty(vWerte) Then Exit Sub
  If Not IsArray(vWerte) Then Exit Sub
  
  lDpId = 0
  dtAkt = oProt.Zeitpunkt(0)
  For Each oDP In oDpGroup.coDP
    If Not IsError(vWerte(lDpId)) And Not IsError(vWerte(lDpId + 1)) Then
      Call oDP.AddValue(CPVSSValue(vWerte(lDpId)), dtAkt, vWerte(lDpId + 1))
    End If
    lDpId = lDpId + 2
  Next oDP

Exit Sub
dpWerteOnline_Fehler:
  'Stop
  'Resume
  Resume Next
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub PVSSInit()
  
Dim sConfigFile As String
Dim sPara       As String
Dim lMaxLicens  As Long
Dim sDpCB       As String
Dim sDP         As String
Dim asDpCB()    As String
Dim sHelp       As String
Dim boxRc       As Integer
Dim isRdbActive As Variant

  On Error GoTo PVSSInit_Fehler
  
  If moComMan Is Nothing Then
    sConfigFile = getOpt.ComManConfig
    If Len(sConfigFile) Then
      'If Len(Dir(sConfigFile)) Then
      If Not M_Optionen.checkConfigFile(sConfigFile) Then
        sHelp = M_Optionen.getConfigFile
        If Len(sHelp) Then
          boxRc = MsgBox(GetResText(21167) & Chr(10) & sHelp, vbOKCancel + vbInformation, GetResText(20101))
          If boxRc = 1 Then
            sConfigFile = sHelp
          End If
        End If
      End If
      
      If M_Optionen.checkConfigFile(sConfigFile) Then
      
        sConfigFile = TextErsetzen(sConfigFile, "\", "\\")
        sPara = getOpt.ComManPara
        Call BugMessage("sConfigFile = " & sConfigFile & ", sPara = " & sPara, "M_PVSS::PVSSInit")
        
        Set moComMan = New ComManager
        Call moComMan.init(sPara & " -config " & sConfigFile)
        
        Set moReportExt = getReportExt
        Call moReportExt.getMaxSystemNumber(MAX_SYSNO)
        Call moReportExt.getMyManNum(MY_MAN_NUM)

        Let MY_REPORT_DP = MY_REPORT_DPTYPE & "_" & CStr(MY_MAN_NUM)  ' zb. "_Report_1"
        Call moComMan.dpCreate(MY_REPORT_DP, MY_REPORT_DPTYPE)
        Call moComMan.dpNames(MY_REPORT_DP, MY_REPORT_DPTYPE, asDpCB)
        If UBound(asDpCB) < 1 Then
          Call FehlerAusloesen(ERR_PVSS_INIT, "no internal DPTYPE '_Report?'")
        End If
        
        sDP = MY_REPORT_DP & ".Authenticate.Workstation"
        Call moComMan.dpSet(sDP, LCase(HostName))
        
        ' IM 110248 WOKL 20.2.13 - callbacks crash excel in redu switch!
'        sDpCB = MY_REPORT_DP & ".Exec.cmd"
'        ' sDpCB = "_ExcelReport_" & LCase(HostName) & ".cmd"
'        Call moComMan.dpNames(sDpCB, MY_REPORT_DPTYPE, asDpCB)
'        If UBound(asDpCB) = 1 Then
'          Set moComCB = New C_ComCB
'          Call moComCB.init(moComMan)
'          Call moComCB.Connect("cmd", sDpCB)
'          Call BugMessage(sDpCB & " connected", "M_PVSS::PVSSinit")
'        Else
'          Call BugMessage(sDpCB & " not found", "M_PVSS::PVSSinit")
'        End If
'
'        sDpCB = MY_REPORT_DP & ".Authenticate.Logout"
'        Call moComMan.dpNames(sDpCB, MY_REPORT_DPTYPE, asDpCB)
'        If UBound(asDpCB) = 1 Then
'          Call moComCB.Connect("logout", sDpCB)
'          Call BugMessage(sDpCB & " connected", "M_PVSS::PVSSinit")
'        Else
'          Call BugMessage(sDpCB & " not found", "M_PVSS::PVSSinit")
'        End If
        
'        sDpCB = MY_REPORT_DP & ".Authenticate.GlobalPermission"
'        Call moComMan.dpNames(sDpCB, MY_REPORT_DPTYPE, asDpCB)
'        If UBound(asDpCB) = 1 Then
'          Call moComCB.Connect("permission", sDpCB)
'          Call BugMessage(sDpCB & " connected", "M_PVSS::PVSSinit")
'        Else
'          Call BugMessage(sDpCB & " not found", "M_PVSS::PVSSinit")
'        End If

        Call moComMan.dpGet("_DataManager.UseRDBArchive:_original.._value", isRdbActive)
        M_Konstanten.IS_RDBACTIVE = isRdbActive
        
        Call M_PVSSLogin.PVSSLoginInit
        Call M_Optionen.AutoLogoutInit
        Call M_DB.ReworkDbUpdate
      Else
        Call FehlerAusloesen(ERR_PVSS_INIT, "Config file not found" & Chr(13) & sConfigFile)
      End If
    Else
      Call FehlerAusloesen(ERR_PVSS_INIT, "no ConfigFile" & Chr(13) & sConfigFile)
    End If
  End If

  Call moComMan.getLicense("excelreport", lMaxLicens)
  If (lMaxLicens < 1) Then
    'Call MsgBox("Achtung: keine Lizenz vorhanden!", vbOKOnly + vbInformation, "ACHTUNG 3.3 Beta!")
    Call BugMessage("lMaxLicens = " & lMaxLicens, "M_PVSS::PVSSInit")
    On Error GoTo 0
    Call FehlerAusloesen(ERR_PVSS_NOLICENSE, "", True)
  End If
Exit Sub

PVSSInit_Fehler:
  'Stop
  Call FehlerAusloesen(ERR_PVSS_INIT, , False)
End Sub
Public Sub ReportCB(vIdent As Variant, vValue As Variant)

  Call BugMessage(vIdent, "M_PVSS::ReportCB")
     
  Select Case vIdent
  Case "cmd"
    Call ReportCmdCB(vIdent, vValue)
  Case "logout"
    Call M_PVSSLogin.ResetPasswordSession
  Case "permission"
    Call M_PVSSLogin.ReadPermissionData
  End Select

End Sub
'---------------------------------------------------------------------------------------------------
Public Sub ReportCmdCB(vIdent As Variant, vValue As Variant)
  
Dim asCmd() As String
Dim oProt   As C_Protokoll
Dim oMailVerteiler As C_MailVerteiler
Dim sDP     As String
Dim sValue  As String
Dim boClose As Boolean
Dim iErr    As Integer

'Static boInit As Boolean

  On Error GoTo ReportCmdCB_Error
  
  sDP = MY_REPORT_DP & ".Exec.state:_original.._value"
  If IsArray(vValue) Then
  
    Call BugMessage(vValue(0), "M_PVSS::ReportCmdCB")
    Call BugMessage(vValue(1), "M_PVSS::ReportCmdCB")
    Set oProt = New C_Protokoll
    iErr = ReportCmdRead(vValue(0), oProt)
    If iErr = 0 Then

      ' Wo bekomme ich den vollen UserNamen her? - WOKL: ReportExt
      oProt.Username = moReportExt.GetUserName(vValue(1))  ' IM 98626
      ' Call BugMessage("UserName:" & moReportExt.GetUserName(vValue(1)), "M_PVSS::ReportCmdCB")
      oProt.RequestType = REQUESTTYPE_PVSS
      
      'Protokoll darf nicht automatisch in ProtErstellen geschlossen werden, weil ich
      'PVSS den Pfad und den Dateinamen mitteilen moechte.
      boClose = oProt.Schliessen
      oProt.Schliessen = False
      Call M_Protokoll.ProtErstellen(oProt, True)
      'Protokoll per EMail verschicken
      Set oMailVerteiler = M_MailVerteiler.Lesen(oProt.zpMailVerteiler)
      If Not oMailVerteiler Is Nothing Then
        Call M_MailVerteiler.Senden(oProt, oMailVerteiler)
      End If
      'HTML Speichern
      If oProt.zpHTML Then
        Call M_Protokoll.SpeichernHTML(oProt)
      End If
      
      sValue = "Succeeded|" & oProt.Tag & "|" & oProt.wbProtokoll.Name & "|" & oProt.wbProtokoll.Path
      If boClose Then
        ThisWorkbook.Activate 'auch wg. der bloeden ListBox Schnellanwahl
        Application.ScreenUpdating = True
        oProt.wbProtokoll.Close SaveChanges:=False
      Else
        Application.ScreenUpdating = True
      End If
      Call BugMessage(sValue, "M_PVSS::ReportCmdCB")
      Call moComMan.dpSet(sDP, sValue)
    Else
      sValue = "Error|" & oProt.Tag & "|-1|Missing Parameter"
      Call BugMessage(sValue, "M_PVSS::ReportCmdCB")
      Call moComMan.dpSet(sDP, sValue)
    End If
  Else
    sValue = "Error|" & oProt.Tag & "|-2|Missing Value"
    Call BugMessage(sValue, "M_PVSS::ReportCmdCB")
    Call moComMan.dpSet(sDP, sValue)
  End If

Exit Sub
ReportCmdCB_Error:
  Call ErrMessage(Err.Number & ": " & Err.Description, "M_PVSS::ReportCmdCB")
  sValue = "Error|" & oProt.Tag & "|" & Err.Number & "|" & Err.Description
  On Error Resume Next
  Call moComMan.dpSet(sDP, sValue)
  TabMenue.SchnellanwahlAnzeigen
End Sub

'---------------------------------------------------------------------------------------------------
Private Function ReportCmdRead(ByVal sCmd As String, oProt As C_Protokoll) As Integer
    
Dim asCmd()   As String
Dim coMail    As CO_MailVerteiler
Dim oMail     As C_MailVerteiler
Dim s As String
Dim i As Integer

  On Error GoTo ReportCmdRead_Fehler

  Call StrToArray(asCmd, sCmd, "|")
  If (UBound(asCmd) >= 3) Then
      
      oProt.Vorlage = Trim(asCmd(1))
      oProt.ProtTypName = Trim(asCmd(2))
      Set oProt.ProtTyp = M_ProtokollTyp.Lesen(oProt.ProtTypName)
      
      'Zeitbereich
      If UBound(asCmd) >= 3 Then
        If Len(Trim(asCmd(3))) = 0 Then
          i = 0
        Else
          i = CLng(asCmd(3))
        End If
        'Abgeschlossen oder Aktuell
        If i = 0 Or i = 1 Then
          oProt.Zeitbereich = i
        Else
          If UBound(asCmd) >= 5 Then
            oProt.Von = CDate(asCmd(4))
            oProt.Bis = CDate(asCmd(5))
          Else
            ReportCmdRead = -2
            Exit Function
          End If
        End If
      End If
       
      'Drucken
      If UBound(asCmd) >= 6 Then
        If Len(Trim(asCmd(6))) > 0 Then
          oProt.Drucken = CBool(asCmd(6))
        End If
      End If
      'speichern
      If UBound(asCmd) >= 7 Then
        If Len(Trim(asCmd(7))) > 0 Then
          oProt.Speichern = CBool(asCmd(7))
        Else
          oProt.Speichern = True
        End If
      Else
        oProt.Speichern = True
      End If
      'Schliessen
      If UBound(asCmd) >= 8 Then
        If Len(Trim(asCmd(8))) > 0 Then
          oProt.Schliessen = CBool(asCmd(8))
        Else
          oProt.Schliessen = True
        End If
      Else
        oProt.Schliessen = True
      End If
      'HTML
      If UBound(asCmd) >= 9 Then
        If Len(Trim(asCmd(9))) > 0 Then
          oProt.zpHTML = CBool(asCmd(9))
        End If
      End If
      'EMail
      If UBound(asCmd) >= 10 Then
        If Len(Trim(asCmd(10))) > 0 Then
          s = Trim(asCmd(10))
          i = M_DB.getMailVerteiler(s)
          If i >= 0 Then
            oProt.zpMailVerteiler = i
          End If
        End If
      End If
      'Tag - beliebiger Bezeichner des Client
      If UBound(asCmd) >= 11 Then
        oProt.Tag = asCmd(11)
      End If

  Else
    ReportCmdRead = -1
  End If
Exit Function
ReportCmdRead_Fehler:
  Call ErrMessage(Err.Number & ": " & Err.Description, "M_PVSS::ReportCmdRead")
  ReportCmdRead = -2
End Function

'---------------------------------------------------------------------------------------------------
Public Function getComMan() As ComManager
  PVSSInit
  Set getComMan = moComMan
End Function

'---------------------------------------------------------------------------------------------------
Public Function getReportExt() As reportExt
  If (moReportExt Is Nothing) Then  ' IM 102174 WOKL 15.3.11
    Set moReportExt = New reportExt
  End If
  Set getReportExt = moReportExt
End Function

'---------------------------------------------------------------------------------------------------
Public Sub PVSSStop()
  Call moComMan.Terminate
  Set moComMan = Nothing
End Sub

'---------------------------------------------------------------------------------------------------
Public Function CPVSSStatus(vStatus As Variant) As String
  If VarType(vStatus) = vbString Then
    If Len(vStatus) = 32 Then
      CPVSSStatus = vStatus
    Else
      'ToDo: Was dann?
      CPVSSStatus = "00000000000000000000000000000000"
    End If
  Else
    'ToDo: Was dann?
    CPVSSStatus = "00000000000000000000000000000000"
  End If
End Function

'---------------------------------------------------------------------------------------------------
Public Function CPVSSValue(vWert As Variant) As Variant

Static cDezTrenn  As String
Static cDezErsatz As String
Dim vIstZahl      As Variant

  'Trennzeichen fuer Zahlen ermitteln
  If Len(cDezTrenn) = 0 Then
    If CStr(0.42) = "0,42" Then
      cDezTrenn = ","
      cDezErsatz = "."
    Else
      cDezTrenn = "."
      cDezErsatz = ","
    End If
  End If

  If vWert = "NULL" Then
    CPVSSValue = ""
  Else
    vIstZahl = vWert
    'Trennzeichen gemaess Laendereinstellung anpassen
    If InStr(1, vIstZahl, cDezErsatz) Then
      vIstZahl = Left(vIstZahl, InStr(1, vIstZahl, cDezErsatz) - 1) & _
                 cDezTrenn & _
                 Right(vIstZahl, Len(vIstZahl) - InStr(1, vIstZahl, cDezErsatz))
    End If
        
    If IsNumeric(vIstZahl) Then
      CPVSSValue = CDbl(vIstZahl)
    Else
      CPVSSValue = vWert
    End If
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Function CPVSSTime(vTime As Variant) As Date

Dim iTag      As Integer
Dim iMonat    As Integer
Dim iJahr     As Integer
Dim iStunde   As Integer
Dim iMinute   As Integer
Dim iSekunde  As Integer

Dim sPVSSDate As String
Dim sDatum    As String

Static sFormat  As String
  
  If IsDate(vTime) Then
    CPVSSTime = CDate(vTime)
    Exit Function
  End If
  
  If Len(sFormat) = 0 Then
    sFormat = Format(#12/31/1999#, "Short Date") & " " & _
              Format(#11:59:42 PM#, "Long Time")
    sFormat = TextErsetzen(sFormat, "31", "TT")
    sFormat = TextErsetzen(sFormat, "12", "MM")
    sFormat = TextErsetzen(sFormat, "1999", "JJJJ")
    sFormat = TextErsetzen(sFormat, "99", "JJJJ")
    sFormat = TextErsetzen(sFormat, "23", "hh")
    sFormat = TextErsetzen(sFormat, "11", "hh")
    sFormat = TextErsetzen(sFormat, "59", "mm")
    sFormat = TextErsetzen(sFormat, "42", "ss")
    If InStr(1, sFormat, " PM") > 0 Then
      sFormat = Left(sFormat, Len(sFormat) - 3)
    End If
  End If
  
  sDatum = TextErsetzen(sFormat, "TT", Mid(vTime, 9, 2))
  sDatum = TextErsetzen(sDatum, "MM", Mid(vTime, 6, 2))
  sDatum = TextErsetzen(sDatum, "JJJJ", Mid(vTime, 1, 4))
  sDatum = TextErsetzen(sDatum, "hh", Mid(vTime, 12, 2))
  sDatum = TextErsetzen(sDatum, "mm", Mid(vTime, 15, 2))
  sDatum = TextErsetzen(sDatum, "ss", Mid(vTime, 18, 2))
  
  If IsDate(sDatum) Then
    CPVSSTime = CDate(sDatum)
  Else
    CPVSSTime = 0
  End If
  
End Function
'---------------------------------------------------------------------------------------------------
' checks for the connection status of rdb manager datapoint; this dp signalizes both
' RDB Manager disruption as Database shutdown
' @param: sysName - for future use; it would be rather
' @return: true - continue (default if RDB not configured)
'          false - abort calling function
Public Function CheckForRdbStatus(Optional sysName As String = "") As Boolean

Dim isRdbConnected As Variant
Dim answer         As Integer
Dim dp As String

  CheckForRdbStatus = True
  
  If (IS_RDBACTIVE = True) Then
    If (Len(sysName) > 0) Then dp = sysName & ":"
    dp = dp + "_RDBArchive.dbConnection.connected"
    Call M_PVSS.getComMan.dpGet(dp, isRdbConnected)
    If (isRdbConnected = False) Then    ' Warnung: "RDB connection not available; abort function?"
      answer = MsgBox(GetResText(23000), vbYesNo + vbQuestion, GetResText(20103))
      If answer = vbYes Then CheckForRdbStatus = False
    End If
  End If
  
End Function
Attribute VB_Name = "M_PVSSLogin"
'==================================================================================================
'M_PVSSLogin
' Wolfram Klebel 16.4.2010 Rittmeyer - User Berechtigungen
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Private mCPvssLogin As C_PVSSLogin
Private msPvssLoginName As String


Public Property Get PVSSLoginName() As String
  PVSSLoginName = msPvssLoginName
End Property

Public Property Let PVSSLoginName(ln As String)
  msPvssLoginName = ln
  
  On Error Resume Next
  ThisWorkbook.Sheets(1).Unprotect
  ThisWorkbook.Sheets(1).Shapes("LoginName").Select
  Selection.Characters.Text = ln
  ThisWorkbook.Sheets(1).Protect
  
End Property

Public Property Get Areas() As Collection
  Set Areas = mCPvssLogin.mcoAreas
End Property

'---------------------------------------------------------------------------------------------------
Public Sub PVSSLoginInit()
  Dim user As String
  Dim pwd As String
    
  If (mCPvssLogin Is Nothing) Then
    Set mCPvssLogin = New C_PVSSLogin
  End If
  
  mCPvssLogin.mboLoginValid = False
  Let user = Environ("ER_LOGIN")
  Let pwd = Environ("ER_PWD")
  If (Len(pwd) > 2) Then
    pwd = Mid(pwd, 2, Len(pwd) - 2)     ' delete leading and trailing "
  End If
  
  If (Len(user) > 0) Then
    mCPvssLogin.mboLoginValid = PVSSLoginCheck(user, pwd)
    If (mCPvssLogin.mboLoginValid) Then
      mCPvssLogin.msUsername = user
    End If
  End If
  
End Sub

Public Function PVSSLoginCheck(Username As String, pwd As String) As Boolean

Dim vPwdPvss As Variant
Dim sPwdEntered As String
Dim sPwdPvss As String
Dim iLoop As Integer
Dim vUname As Variant
Dim vPwdHash As Variant

  ' IM 113008 refactoring crypt for security reasons WOKL 25.10.13
  PVSSLoginCheck = M_PVSS.getReportExt.CheckPassword(Username, pwd)
  If (PVSSLoginCheck = False) Then    ' IM 113182: check for real or encrypted pwd
    Call M_PVSS.getComMan.dpGet("_Users.UserName", vUname)
    Call M_PVSS.getComMan.dpGet("_Users.Password", vPwdHash)
    For iLoop = 0 To UBound(vUname)
      If (Username = vUname(iLoop) And (pwd = vPwdHash(iLoop))) Then
        PVSSLoginCheck = True
        Exit For
      End If
    Next iLoop
  End If
        
  If (PVSSLoginCheck = True) Then
    Call M_PVSS.getComMan.dpSet(MY_REPORT_DP & ".Authenticate.Password", "")
    Call M_PVSS.getComMan.dpSet(MY_REPORT_DP & ".Authenticate.Username", Username)
  
    iLoop = 1   ' IM 109206 waits max 11 sec in incremental intervals
    Do
      Call Delay(0.2 * iLoop)
      Call M_PVSS.getComMan.dpGet(MY_REPORT_DP & ".Authenticate.Password", vPwdPvss)
      sPwdPvss = CStr(vPwdPvss)
      iLoop = iLoop + 1
    Loop Until (sPwdPvss <> "" Or iLoop > 10)
  
    If (sPwdPvss <> "X" Or iLoop > 10) Then  ' control didn't work
      PVSSLoginName = ""    ' clear
      PVSSLoginCheck = False
      Call BugMessage("PVSSLoginCheck=" & PVSSLoginCheck & " user=" & Username, "M_PVSSLogin::PVSSLoginCheck - got no ctrl reaction")
    Else
      Call M_PVSS.getComMan.dpSet(MY_REPORT_DP & ".Authenticate.LoginValid", 1)
      Call ReadPermissionData
      PVSSLoginName = Username
    End If
  Else
    PVSSLoginName = ""    ' clear
  End If
  
  Call BugMessage("PVSSLoginCheck=" & PVSSLoginCheck & " user=" & Username, "M_PVSSLogin::PVSSLoginCheck")
    
End Function
    
Public Property Get PVSSLoginIsValid() As Boolean
  
  PVSSLoginIsValid = M_Optionen.getOpt.LoginActive
  
End Property
' created for display of QuickList depending on valid Login, but not yet used
Public Property Get PVSSLoginLoggedIn() As Boolean
  
  PVSSLoginLoggedIn = False
  On Error Resume Next
  PVSSLoginLoggedIn = (PVSSLoginIsValid And mCPvssLogin.mboLoginValid)
  
End Property

'--------------------------------------------------------------------------------------------------
Public Function CheckPLPassword(boAskForPassword As Boolean, functionId As Integer) As Boolean

Dim vwKennwort As V_KennwortPLogin

  CheckPLPassword = False   ' sollte nie gebraucht werden
  
  If (mCPvssLogin Is Nothing) Then
    Set mCPvssLogin = New C_PVSSLogin
  End If
  
  If M_Optionen.isPvssLogin Then
    If mCPvssLogin.mboLoginValid = False Then
      
      If boAskForPassword Then
        Set vwKennwort = New V_KennwortPLogin
        vwKennwort.Username = mCPvssLogin.msUsername
        vwKennwort.Show
  
        If vwKennwort.ok And Len(vwKennwort.Username) > 0 Then
          mCPvssLogin.mboLoginValid = True
          mCPvssLogin.msUsername = vwKennwort.Username
        End If
        
        Call TabMenue.SchnellanwahlAnzeigen   ' IM 100650-5 refresh
      End If
    End If
    
    If mCPvssLogin.mboLoginValid Then
      CheckPLPassword = CheckGlobalAuth(boAskForPassword, functionId)
    End If
    
  Else    ' Steuerung nicht ueber PVSS Login
    CheckPLPassword = True
  End If
  
  If (CheckPLPassword) Then
    M_Optionen.AutoLogoutInit
  End If
  
End Function

'--------------------------------------------------------------------------------------------------
Public Sub ResetPasswordSession()
  mCPvssLogin.mboLoginValid = False
  PVSSLoginName = ""
  Call M_PVSS.getComMan.dpSet(MY_REPORT_DP & ".Authenticate.LoginValid", 0)
  Call TabMenue.SchnellanwahlAnzeigen
End Sub

'--------------------------------------------------------------------------------------------------
Public Function CheckGlobalAuth(boAskForPassword As Boolean, functionId As Integer) As Boolean

Dim i As Integer
Dim iHelp As Integer

  If (functionId = 0) Then    ' Konstante, wenn ich keine Pr|fffd|fung will
    CheckGlobalAuth = True
  Else
    iHelp = 1
    For i = 1 To functionId - 1
      iHelp = iHelp * 2
    Next
    i = iHelp And mCPvssLogin.miGlobalPermission   ' bitweises UND
    
    CheckGlobalAuth = (i > 0)
    
    If (CheckGlobalAuth = False And boAskForPassword) Then
      Call ResetPasswordSession     ' IM 113008 force new login
      Call MsgBox(GetResText(21181), vbOKOnly, GetResText(20101))
    End If
  End If

End Function

'--------------------------------------------------------------------------------------------------
Public Function CheckAreaAuth(objectAreas As String, functionId As Integer) As Boolean

Dim i As Integer
Dim iHelp As Integer
Dim area() As String
Dim perm As String

  ' objectAreas mit "0" heisst: alle Bereiche
  If M_Optionen.isPvssLogin And objectAreas <> "0" Then
    area = Split(objectAreas, "|")
    
    On Error Resume Next
    CheckAreaAuth = False   ' IM 106053: in logout status give no permission
    If (mCPvssLogin.mboLoginValid = False) Then
      Exit Function
    End If
    perm = "00"
    For i = 0 To UBound(area)
      iHelp = CInt(area(i))
      perm = mCPvssLogin.mcoAreaPermission.Item(iHelp)
      Select Case functionId
      Case PL_AREA_PROT_NEW:
        If (Mid$(perm, 2, 1) = "1") Then    ' Mid$ beginnt mit 1
          CheckAreaAuth = True
          Exit For
        End If
      Case PL_AREA_PROT_CHANGE:
        If (Mid$(perm, 1, 1) = "1") Then
          CheckAreaAuth = True
          Exit For
        End If
      Case Else:
        Call BugMessage("FunctionID not found: " & CStr(functionId), "M_PVSSLogin::CheckAreaAuth")
      End Select
    Next
    On Error GoTo 0
     
  Else
    CheckAreaAuth = True
  End If
  
End Function

'--------------------------------------------------------------------------------------------------
Public Sub ReadPermissionData()

Dim vHelp As Variant
Dim i As Integer
Dim iHelp As Integer
Dim v As Variant
Dim Areas As Variant
Dim areaPerm As Variant


  Call M_PVSS.getComMan.dpGet(MY_REPORT_DP + ".Authenticate.GlobalPermission", vHelp)
  Let mCPvssLogin.msGlobalPermission = vHelp
  mCPvssLogin.miGlobalPermission = 0
  iHelp = 1
  For i = Len(vHelp) To 1 Step -1
    If (Mid$(vHelp, i, 1) = "1") Then
      mCPvssLogin.miGlobalPermission = mCPvssLogin.miGlobalPermission + iHelp
    End If
    iHelp = iHelp * 2
  Next
  
  On Error GoTo ReadPermissionData_Fehler
  
  Call M_PVSS.getComMan.dpGet(MY_REPORT_DP + ".Authenticate.Areas", Areas)
  Call M_PVSS.getComMan.dpGet(MY_REPORT_DP + ".Authenticate.AreaPermission", areaPerm)
  If (Not IsNull(Areas)) Then
    Call mCPvssLogin.ClearAreas
    Call mCPvssLogin.ClearAreaPermissions
    Let i = 0
    For Each v In Areas
      Call mCPvssLogin.AddArea(v, i)
      Call mCPvssLogin.AddAreaPermission(areaPerm(i), i)
      i = i + 1
    Next
  End If
  
  On Error GoTo 0
  
Exit Sub
ReadPermissionData_Fehler:
  'Stop
  On Error GoTo 0
  Call BugMessage("Area Permissions not consistent?", "M_PVSSLogin::ReadPermissionData")
  Call FehlerAusloesen(ERR_PVSS_AREA_PERMISSION, "Bereichsberechtigung", False, _
                       "M_PVSSLogin::ReadPermissionData")
 
End Sub


Attribute VB_Name = "M_Protokoll"
'==================================================================================================
'M_Protokoll
'
'Oliver Seidel
'10.11.98 / 5.1.99
'
'Schnittstelle fuer die Protokollarten.
'Erstellt eine neues Protokoll.
'Ist mehr als ein Protokollformat definiert, wird ein Auswahlfenster dargestellt, in dem der
'Benutzer ein Format auswaehlen kann. Ist im Projekt nur ein einzelnes Format definiert, wird
'die Auswahl uebersprungen - nona.
'==================================================================================================
Option Explicit
Option Private Module

Public Sub Neu(Optional sProtFormat As String)

Dim wbProtokoll   As Workbook
Dim sDatei        As String
Dim sDateiTypen   As String
Dim boDateiOffen  As Boolean
Dim oProtokoll    As C_Protokoll
Dim oPNeu         As C_Protokoll
Dim sError        As String
Dim i             As Integer

  On Error GoTo M_Protokoll_Neu_Fehler
  
  'TI 8074 - Vermutung: aktives Workbook darf nicht die Vorlage sein,
  '          von der ein Protokoll erstellt werden soll.
  '          -> Report aktivieren (wird spaeter eh benoetigt)
  ThisWorkbook.Activate
  
  If (M_PVSS.CheckForRdbStatus = False) Then Exit Sub
  
  Call SetCurrentDirectory(ProjektPfad & "\" & VERZ_VORLAGE)
  'ICSGEAD IM 115373
  sDateiTypen = GetResText(21204) & " (*.xltm), *.xltm" & "," & GetResText(21204) & " (*.xlt), *.xlt"
  sDatei = Application.GetOpenFilename(sDateiTypen, , GetResText(21124), , False)
  
  If (sDatei = CStr(False)) Then    ' seltsamer Vergleich
    Exit Sub
  End If
    
  Application.ScreenUpdating = False
  On Error Resume Next
  Set wbProtokoll = Application.Workbooks.Add(sDatei)
  If Err.Number <> 0 Then
    Application.ScreenUpdating = True
    GoTo M_Protokoll_Neu_Fehler
  Else
    boDateiOffen = True
    On Error GoTo M_Protokoll_Neu_Fehler
    
    'Set oProtokoll = New C_Protokoll
    'Set oProtokoll.wbProtokoll = wbProtokoll
    Call M_Vorlage.DefLesen(oProtokoll)
    oProtokoll.RequestType = REQUESTTYPE_MAN
    oProtokoll.Username = M_Tools.Username
    oProtokoll.UserFullName = M_Tools.UserFullName
    
    sError = ""
    If (CheckAreaAuth(oProtokoll.Bereich, PL_AREA_PROT_NEW)) Then
      Call M_Protokoll.VersionPruefen(oProtokoll)
      
      If oProtokoll.DateiTyp = DATEI_PROTOKOLL Then
        
        Call Neu2(oProtokoll, wbProtokoll)
  
        If Not wbProtokoll Is Nothing Then
          Call ReportFinished(wbProtokoll, False)
          Call lockWorkbook(wbProtokoll)
          
          If (Not CheckAreaAuth(oProtokoll.Bereich, PL_AREA_PROT_CHANGE)) Then
            wbProtokoll.Saved = True
            For i = 1 To wbProtokoll.Sheets.Count
              With wbProtokoll.Sheets(i)
                .Protect
              End With
            Next i

          End If
        End If
        
      Else
        sError = GetResText(21126) & " " & sProtFormat & "!"  ' Protokolltyp nicht bekannt
      End If
    Else
      sError = GetResText(21188)  ' keine Berechtigung
    End If
    
    If (Len(sError) > 0) Then
      Call MsgBox(sError, vbOKOnly + vbCritical, GetResText(21116))
      
      ActiveWorkbook.Close SaveChanges:=False
      Application.ScreenUpdating = True
      'Die /*censored*/ ListBox fuehrt ab und an kein automatisches repaint aus
      'und manuell kann man es auch nicht veranlassen.......
      TabMenue.lstProtAnwahl.BackColor = RGB(255, 255, 255)
      DoEvents
        
    End If
  End If

  Application.ScreenUpdating = True
  Call M_PVSS.CheckForRdbStatus   ' IM 106801 WOKL data could be manking

Exit Sub
M_Protokoll_Neu_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Protokoll::Neu")

  If Err.Source <> "UI" Then
    Call MsgBox(Err.Source & Chr(13) & _
                Err.Description, _
                vbOKOnly + vbCritical, _
                "Fehler " & Err.Number)
  End If
  
  If boDateiOffen Then
    'Call goReport.Schliessen(boAenderungenSpeichern:=False)
    ActiveWorkbook.Close SaveChanges:=False
  End If
  Application.ScreenUpdating = True
  'Die /*censored*/ ListBox fuehrt ab und an kein automatisches repaint aus
  'und manuell kann man es auch nicht veranlassen.......
  'TabMenue.lstProtAnwahl.BackColor = RGB(255, 255, 255)
  TabMenue.lstProtAnwahl.BackColor = RGB(255, 255, 255)
  DoEvents
      
End Sub 'Neu

'--------------------------------------------------------------------------------------------------
Private Sub Neu2(oProtokoll As C_Protokoll, _
               wbProtNeu As Workbook)
  
Dim sVorlage    As String
Dim tabKonfig   As Worksheet
Dim rgProttyp   As Range
Dim coProtTypen As CO_ProtokollTyp
Dim oProtTyp    As C_ProtokollTyp

Dim sProtTyp      As String
Dim dtVon         As Date
Dim dtBis         As Date
Dim lIntervall    As Long
Dim vwZeitbereich As V_ProtZeitbereich

Dim iRueckgabe      As Integer
Dim wbProtVergleich As Workbook
Dim wsProtVergleich As Worksheet
Dim oProtVergleich  As C_Protokoll

  On Error GoTo M_STDProt_Neu_Fehler
  Set coProtTypen = New CO_ProtokollTyp

  Set tabKonfig = oProtokoll.wbProtokoll.Worksheets(TAB_KONFIG)
  tabKonfig.Range(REF_DATEI_TYP) = DATEI_PROTOKOLL
  'IM 56907
  tabKonfig.Range(REF_CREATION_DATE) = Now

  For Each rgProttyp In SelectRange(tabKonfig.Range(REF_PROT_PROTTYPEN), 1, True)
    If Len(rgProttyp.Text) Then
      Set oProtTyp = M_ProtokollTyp.Lesen(rgProttyp.Text)
      If oProtTyp.ID > 0 Then
        coProtTypen.Add oProtTyp
      End If
    End If
  Next rgProttyp

  'Fehler, wenn keine Protokolltypen in der Vorlage sind
  If coProtTypen.Count = 0 Then
    Call FehlerAusloesen(ERR_PROT_KONFIG)
  End If
  
  Call ReportNew(oProtokoll)    ' Entry point ins Protokoll-Dokument
  
  If oProtokoll.ProtTypName <> "" Then
  
    Set oProtokoll.ProtTyp = coProtTypen.FindItem(oProtokoll.ProtTypName)
  
  ElseIf ZeitbereichErforderlich(oProtokoll.wbProtokoll) Or _
         coProtTypen.Count > 1 Then
    
    Set vwZeitbereich = New V_ProtZeitbereich
    vwZeitbereich.Modus = 1
    vwZeitbereich.Zeitbereich = oProtokoll.Zeitbereich
    vwZeitbereich.setProtTypen coProtTypen
  
    'Umschalten auf "Menue" des Reports, dtp anzeigen, anderes Workbook aktivieren
    ThisWorkbook.Activate
    Application.ScreenUpdating = True
    vwZeitbereich.Show
    Application.ScreenUpdating = False
    oProtokoll.wbProtokoll.Activate
  
    If Not vwZeitbereich.ok Then
      Call FehlerAusloesen(ERR_BENUTZER_ABBRUCH)
    End If
      
    Set oProtokoll.ProtTyp = coProtTypen.FindItem(vwZeitbereich.ProtTyp)
    oProtokoll.Von = vwZeitbereich.Von
    oProtokoll.Bis = vwZeitbereich.Bis
  
  Else
  
    Set oProtokoll.ProtTyp = coProtTypen.Item(1)
    oProtokoll.Von = 0
    oProtokoll.Bis = 0
  
  End If

  'Nach Moeglichkeit den Benutzer vor die Wahl stellen, ob Update oder Neuberechnung erfolgen soll
  Call M_Protokoll.AktualisierenPruefen(oProtokoll, iRueckgabe, oProtVergleich)
  
  Select Case iRueckgabe
    Case -1:
      'Keine Datei gefunden: Fortsetzen mit "Erstellen"
      Call M_Protokoll.Erstellen(oProtokoll)
      Set wbProtNeu = oProtokoll.wbProtokoll
      
    Case 0:
      'Abbruch
      'Beide offenen Protokolle schliessen
      Application.ScreenUpdating = True
      oProtokoll.wbProtokoll.Close SaveChanges:=False
      oProtVergleich.wbProtokoll.Close SaveChanges:=False
      Set wbProtNeu = Nothing
      
    Case 1:
      'Datei Oeffnen
      oProtokoll.wbProtokoll.Close SaveChanges:=False 'Vorlage schliessen
      Set wbProtNeu = oProtVergleich.wbProtokoll
   
    Case 2:
      'Datei neu erstellen
      oProtVergleich.wbProtokoll.Close SaveChanges:=False 'Vorlage schliessen
      Call M_Protokoll.Erstellen(oProtokoll)
      Set wbProtNeu = oProtokoll.wbProtokoll
      
    Case 3:
      'Datei Aktualisieren
      'Die nun nicht benoetigte Vorlage schliessen
      oProtokoll.wbProtokoll.Close SaveChanges:=False 'Vorlage schliessen

      'Schutz der Tabellen aufheben
      Call unlockWorkbook(oProtVergleich.wbProtokoll)
      oProtVergleich.Username = oProtokoll.Username
      oProtVergleich.UserFullName = oProtokoll.UserFullName
      oProtVergleich.RequestType = oProtokoll.RequestType
      'Protokolldaten aus PVSS abfragen
      Call M_Protokoll.Erstellen(oProtVergleich)
      'ggf. |fffd|nderungshistorie anzeigen
      Call showLogChanges(oProtVergleich.wbProtokoll)
      Set wbProtNeu = oProtVergleich.wbProtokoll
      
    Case Else
      'Abbruch
      oProtokoll.wbProtokoll.Close SaveChanges:=False
      oProtVergleich.wbProtokoll.Close SaveChanges:=False
      Set wbProtNeu = Nothing
    
  End Select

  If Not vwZeitbereich Is Nothing Then
    Unload vwZeitbereich
    Set vwZeitbereich = Nothing
  End If
    
Exit Sub
M_STDProt_Neu_Fehler:

Dim boErsterFehler As Boolean
  boErsterFehler = (Err.Number < ERR_BASIS)
  
  If Not vwZeitbereich Is Nothing Then
    Unload vwZeitbereich
    Set vwZeitbereich = Nothing
  End If

  Call FehlerAusloesen(ERR_PROT_NEU, , boErsterFehler)

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Erstellen(oProtokoll As C_Protokoll)

Dim tabDaten      As Worksheet
Dim coTabBereich  As CO_TabBereich
Dim oProtTyp      As C_ProtokollTyp

Dim oDP       As C_DP
Dim coDP      As CO_DP
Dim oDPRef    As C_DPReferenz
Dim oWert     As C_DPWert
Dim rgDp      As Range
Dim iDPID     As Integer

Dim dtAktZeit   As Date
Dim lDatenAnz   As Long

Dim lStatusId As Long
Dim fStatus   As Single

  On Error GoTo M_StdProt_Erstellen_Fehler

  Call M_Debug.ProcessInfoStart("M_Protokoll::Erstellen")
  'IM 56907
  oProtokoll.wbProtokoll.Worksheets("Konfiguration").Range(REF_LASTUPDATE) = Now
  Call ReportBegin(oProtokoll)

  lStatusId = StatusTextAusgeben(GetResText(21300))
  
  'Call ZeitMessung(True)
  Set coTabBereich = M_Vorlage.TabBereichLesen
  Set coDP = M_Vorlage.DPListLesen(oProtokoll, coTabBereich)

  'Call ZeitMessung(False, "M_Protokoll::Erstellen - coDP erstellen (" & _
  '            iDPID & " Datenpunkte, " & coDP.Count & " Archive)")

  'Call ZeitMessung(True)
  Call StatusTextAusgeben(GetResText(21301), lStatusId)
  Call M_Debug.ProcessInfo("M_Protokoll::Werte")
  Call M_PVSS.Werte(oProtokoll, coDP)
  'Call ZeitMessung(False, "M_PVSS::Werte - Werte abfragen")
  
  'Call ZeitMessung(True)
  Call StatusTextAusgeben(GetResText(21302), lStatusId)
  
  Call M_Debug.ProcessInfo("M_Protokoll::SeiteEinrichten")
  Call SeiteEinrichten(oProtokoll, coTabBereich)        ' je Protokolltyp
  
  'Call ZeitMessung(False, "M_Protokoll::SeiteEinrichten - Seite einrichten")

  'Call ZeitMessung(True)
  lDatenAnz = oProtokoll.ZeitpunktAnz
  
  For Each oDPRef In coDP.RefItems 'oATVProt.coDPRef
    Set tabDaten = oProtokoll.wbProtokoll.Sheets(oDPRef.TabBereich.Blatt)
    Call M_Debug.ProcessInfo("M_Protokoll::WerteEintragen " & tabDaten.Name)
    
    Select Case GetTabFormat(tabDaten)
      Case BEZ_STD_PROTOKOLL:
        Call M_StdProt.WerteEintragen(tabDaten, coDP.Items(oDPRef.index), _
                                      oDPRef, lDatenAnz)
      Case BEZ_ATV_PROTOKOLL:
        Call M_ATVProt.WerteEintragen(tabDaten, coDP.Items(oDPRef.index), _
                                      oDPRef, lDatenAnz)
      
      Case BEZ_BTR_PROTOKOLL:
        Call M_BtrProt.WerteEintragen(tabDaten, coDP.Items(oDPRef.index), _
                                      oDPRef, lDatenAnz)
      
      Case BEZ_KST_PROTOKOLL:
        Call M_KstProt.WerteEintragen(tabDaten, coDP.Items(oDPRef.index), _
                                      oDPRef, lDatenAnz)
    End Select
  Next oDPRef

  'Call ZeitMessung(False, "M_Protokoll::Erstellen - Werte eintragen")
  For Each tabDaten In ActiveWorkbook.Worksheets
    Select Case GetTabFormat(tabDaten)
      Case BEZ_SQL_PROTOKOLL:
        Call M_SQLProt.Erstellen(tabDaten, oProtokoll, coTabBereich)
        
      Case BEZ_KST_PROTOKOLL:
        Call M_Vorlage.TabBereichSpeichern(coTabBereich)  ' ich glaube ich brauche die Infos
        ' Set coDp = M_Vorlage.DPListLesen(oProtokoll, coTabBereich)
        Call M_KstProtCalculation.PrepareCCReport(oProtokoll, coTabBereich, tabDaten, coDP)
    End Select
  Next tabDaten
  
  ' IM 102174 Workaround: WS-crossing calculations are not executed (bug in Excel)
  For Each tabDaten In ActiveWorkbook.Worksheets
    tabDaten.Calculate
  Next tabDaten

  'Aktualisiertes Layout Speichern, wg. Aktualisierung
  Call M_Vorlage.TabBereichSpeichern(coTabBereich)

  'Protokoll berechnen
  For Each tabDaten In ActiveWorkbook.Worksheets
    If IsReportTab(tabDaten) Then
      tabDaten.EnableCalculation = True
      tabDaten.Calculate
    End If
  Next tabDaten
  'Call lockWorkbook(oProtokoll.wbProtokoll)
  
  Call M_Protokoll.DefSpeichern(oProtokoll)
  Call StatusTextLoeschen(lStatusId)
  Call M_Debug.ProcessInfo("M_Protokoll::Erstellen (Ende)")
Exit Sub

M_StdProt_Erstellen_Fehler:
  Dim boErsterFehler As Boolean
  
  boErsterFehler = (Err.Number < ERR_BASIS)
  'Call StatusTextLoeschen(lStatusID)
  Call FehlerAusloesen(ERR_PROT_ERSTELLEN, , boErsterFehler)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub SeiteEinrichten(oProtokoll As C_Protokoll, coTabBereich As CO_TabBereich)

Dim wsProt As Worksheet

'Call ZeitMessung(True)
  Call M_Protokoll.KopfFusszeileEinrichten(oProtokoll)
'Call ZeitMessung(False, "M_Protokoll::KopfFusszeileEinrichten")
  
  'Tabellen durchlaufen
  For Each wsProt In oProtokoll.wbProtokoll.Worksheets

    ' Call ZeitMessung(True)
    'Je nach Protokollformat
    Select Case GetTabFormat(wsProt)
      'Layout ermitteln und Definierte Dp's einlesen
      Case BEZ_STD_PROTOKOLL:
        Call M_StdProt.SeiteEinrichten(oProtokoll, wsProt, coTabBereich)
      Case BEZ_BTR_PROTOKOLL:
        Call M_BtrProt.SeiteEinrichten(oProtokoll, wsProt, coTabBereich)
      Case BEZ_ATV_PROTOKOLL:
        Call M_ATVProt.SeiteEinrichten(oProtokoll, wsProt, coTabBereich)
      Case BEZ_KST_PROTOKOLL:
        Call M_KstProt.SeiteEinrichten(oProtokoll, wsProt, coTabBereich)
    End Select

'    Call ZeitMessung(False, _
'      "M_Protokoll::SeiteEinrichten - " & GetTabFormat(wsProt) & Str(wsProt.index) & ": Seite einrichten")
  Next wsProt


End Sub

'--------------------------------------------------------------------------------------------------
Public Sub VersionPruefen(oProtokoll As C_Protokoll)
  
Dim sDateiVersion As String
Dim iDateiVerHaupt As Integer
Dim iDateiVerNeben As Integer

Dim sReportVersion As String
Dim iReportVerHaupt As Integer
Dim iReportVerNeben As Integer

Dim tabKonfig  As Worksheet  'Tabelle mit den Einstellungen (Konfig)

Dim s As String
Dim boVersionPruefen As Boolean
  
  On Error GoTo M_Protokoll_VersionPruefen_Fehler
  
  If DateiTyp(oProtokoll.wbProtokoll) = DATEI_VORLAGE Then
    oProtokoll.DateiTyp = DATEI_PROTOKOLL
  Else
    Call FehlerAusloesen(ERR_PROT_VERSION_PRUEFEN, "Keine Vorlage")
  End If
  
  'Obsolet
  'oProtokoll.ProtFormat = DateiBez
  
  sDateiVersion = DateiVersion
  s = ElementN(sDateiVersion, 1, ".")
  iDateiVerHaupt = CInt(Right(s, Len(s) - 1))
  iDateiVerNeben = CInt(ElementN(sDateiVersion, 2, "."))

  sReportVersion = M_Tools.ProjektVersion
  s = ElementN(sReportVersion, 1, ".")
  iReportVerHaupt = CInt(Right(s, Len(s) - 1))
  iReportVerNeben = CInt(ElementN(sReportVersion, 2, "."))
  
  If iDateiVerHaupt = iReportVerHaupt Then
    If iDateiVerNeben = iReportVerNeben Then
      oProtokoll.Version = sReportVersion
      boVersionPruefen = True
    Else
      boVersionPruefen = False
      Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN, _
                          GetResText(21108), True)
    End If
  Else
    boVersionPruefen = False
    Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN, _
                        GetResText(21107), True)
  End If

Exit Sub
M_Protokoll_VersionPruefen_Fehler:
  Call FehlerAusloesen(ERR_PROT_VERSION_PRUEFEN)

End Sub

'--------------------------------------------------------------------------------------------------
'ProtErstellen
'
'Oliver Seidel
'08.09.1999
'
'Erstellt eine neues Protokoll.
'
'Aenderungen: -keine-
'--------------------------------------------------------------------------------------------------
Public Sub ProtErstellen(oProtokoll As C_Protokoll, _
                         Optional boSeitenAnsichtUnterdruecken As Boolean = False)

'  Call NZD("Haltbarkeitsdatum der Funktion ist abgelaufen!", "M_Protokokll::ProtErstellen()")


'Dim oProtokoll  As C_Protokoll
Dim wbProtokoll As Workbook

Dim iProtWahlID   As Integer
Dim boDateiOffen  As Boolean
Dim boGefunden    As Boolean

  On Error GoTo PROT_ERSTELLEN_FEHLER

  'Set oProtokoll = M_Schnellanwahl.Lesen(lID)
  If Not oProtokoll Is Nothing Then

    'Vorlage vorhanden?    ICSGEAD IM 115373
    If UCase(Right(oProtokoll.Vorlage, 4)) <> ".XLT" Then
        If UCase(Right(oProtokoll.Vorlage, 5)) <> ".XLTM" Then
          oProtokoll.Vorlage = oProtokoll.Vorlage & ".XLTM"
        End If
    End If
    
    If Len(Dir(ProjektPfad & "\" & VERZ_VORLAGE & "\" & oProtokoll.Vorlage)) > 0 Then
      'Vorlage oeffnen
      Application.ScreenUpdating = False
      Set wbProtokoll = Application.Workbooks.Add(ProjektPfad & "\" & VERZ_VORLAGE & "\" & oProtokoll.Vorlage)
      boDateiOffen = True

      If DateiTyp(wbProtokoll) = DATEI_VORLAGE Then

        Call M_Vorlage.DefLesen(oProtokoll)
        Call M_Protokoll.VersionPruefen(oProtokoll)

        If oProtokoll.ProtTyp.ID = 0 Then
          Call Neu2(oProtokoll, oProtokoll.wbProtokoll)
        Else
          Call ProtokollAktualisieren(oProtokoll)
          Call Erstellen(oProtokoll)
        End If

        On Error Resume Next
        'Keine Seitenansicht wg. ZeitPlan
        Call ReportFinished(oProtokoll.wbProtokoll, boSeitenAnsichtUnterdruecken)
        Call lockWorkbook(oProtokoll.wbProtokoll)
        Err.Clear
        On Error GoTo PROT_ERSTELLEN_FEHLER

        'Protokoll speichern
        If oProtokoll.Speichern Then
          Call M_Protokoll.Speichern(False, oProtokoll.zpFilePath, boSeitenAnsichtUnterdruecken)  'IM 115373 ICSGEAD
        End If

        'ggf. |fffd|nderungshistorie anzeigen
        Call showLogChanges(oProtokoll.wbProtokoll)
        
        'Protokoll ausdrucken
        If oProtokoll.Drucken Then
          ActiveWorkbook.PrintOut
        End If

        If oProtokoll.Schliessen Then
          'Call goReport.Schliessen(boAenderungenSpeichern:=False)
          oProtokoll.wbProtokoll.Close SaveChanges:=False
        End If
      End If
    End If
  End If
  Application.ScreenUpdating = True
  
Exit Sub
PROT_ERSTELLEN_FEHLER:

  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Protokoll::ProtErstellen")

  'boSeitenAnsichtUnterdruecken ist ein Trick vom grossem Mumpitz:
  'ist nur bei automatischen Aufrufen (bisher nur Zeitplan) gesetzt!
  If Err.Source <> "UI" And Not boSeitenAnsichtUnterdruecken Then
    Call MsgBox(Err.Source & Chr(13) & _
                Err.Description, _
                vbOKOnly + vbCritical, _
                GetResText(20104) & " " & Err.Number)
  End If

  If boDateiOffen Then
    Application.ScreenUpdating = True
    'Call goReport.Schliessen(boAenderungenSpeichern:=False)
    ActiveWorkbook.Close SaveChanges:=False
  End If
  If boSeitenAnsichtUnterdruecken Then
    Call FehlerAusloesen(ERR_PROT_ERSTELLEN, Err.Description)
  End If
  
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub ProtokollAktualisieren(oProtokoll As C_Protokoll)

Dim sDatei              As String
Dim sPfad               As String
Dim wbVergleich         As Workbook
Dim wsProtVergleich     As Worksheet
Dim oProtVergleich      As C_Protokoll

  'Datei schon vorhanden?
  sDatei = DateinameErzeugen(oProtokoll.wbProtokoll.Name, oProtokoll.Von, (oProtokoll.PerEinheit < erTag))
  sPfad = ThisWorkbook.Path & "\" & VERZ_PROTOKOLL & "\" & oProtokoll.ProtTyp.Bezeichnung
  If Len(Dir(sPfad & "\" & sDatei)) > 0 Then
      
    'Pruefen, ob in einer gefundenen Datei die Daten auch uebereinstimmen
    'ToDo: pwd
    Set wbVergleich = Workbooks.Open(sPfad & "\" & sDatei, Password:=PWD_FILE)
    Set oProtVergleich = DefLesen()
    Set oProtVergleich.wbProtokoll = wbVergleich

       'oProtVergleich.ProtFormat = oProtokoll.ProtFormat And
    If oProtVergleich.DateiTyp = DATEI_PROTOKOLL And _
       oProtVergleich.ProtTyp.Bezeichnung = oProtokoll.ProtTyp.Bezeichnung And _
       DateDiff("s", oProtVergleich.Von, oProtokoll.Von) = 0 And _
       DateDiff("s", oProtVergleich.Bis, oProtokoll.Bis) = 0 And _
       oProtVergleich.Intervall = oProtokoll.Intervall And _
       oProtVergleich.Version = oProtokoll.Version Then
       
        'Datei Aktualisieren
        'Die nun nicht benoetigte Vorlage schliessen
        oProtokoll.wbProtokoll.Close SaveChanges:=False 'Vorlage schliessen
        Set oProtokoll.wbProtokoll = oProtVergleich.wbProtokoll
  
        'Schutz der Tabellen aufheben
        Call unlockWorkbook(oProtokoll.wbProtokoll)
    Else
      
      'Datei neu erstellen
      oProtVergleich.wbProtokoll.Close SaveChanges:=False 'Vorlage schliessen
    
    End If
    
    Set oProtVergleich = Nothing
      
  End If
      
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub KopfFusszeileEinrichten(oProtokoll As C_Protokoll)

Dim tabKonfig         As Worksheet
Dim lSheetID          As Long
Dim lSheetIDOld       As Long
Dim rgKopfFussZeilen  As Range

Dim asVarText() As String
Dim sVarText    As String
Dim asText()     As String
Dim sFormat      As String
Dim i As Integer
Dim header(3)    As String
Dim footer(3)    As String
Dim changed(6)   As Boolean

  On Error GoTo M_StdProt_KopfFusszeileEinrichten_Fehler
 
  ReDim asVarText(8)
  asVarText(1) = VAR_REPORTTYP
  asVarText(2) = VAR_VON
  asVarText(3) = VAR_BIS
  asVarText(4) = VAR_INTERVALL
  asVarText(5) = VAR_VONDATUM
  asVarText(6) = VAR_VONZEIT
  asVarText(7) = VAR_BISDATUM
  asVarText(8) = VAR_BISZEIT

  ReDim asText(8)
  asText(1) = oProtokoll.ProtTyp.Bezeichnung

  If oProtokoll.Intervall >= 86400 Then
    asText(2) = Format(oProtokoll.Von, "Short Date")
    asText(3) = Format(oProtokoll.Bis, "Short Date")
  Else
    asText(2) = Format(oProtokoll.Von, "Short Date") & " " & _
                Format(oProtokoll.Von, "Long Time")
    asText(3) = Format(oProtokoll.Bis, "Short Date") & " " & _
                Format(oProtokoll.Bis, "Long Time")
  End If

  asText(4) = oProtokoll.Intervall
  asText(5) = Format(oProtokoll.Von, "Short Date")
  asText(6) = Format(oProtokoll.Von, "Long Time")
  asText(7) = Format(oProtokoll.Bis, "Short Date")
  asText(8) = Format(oProtokoll.Bis, "Long Time")

  Set tabKonfig = oProtokoll.wbProtokoll.Worksheets(TAB_KONFIG)
  lSheetIDOld = -1
  For i = 1 To 6
    changed(i) = False
  Next i
  For Each rgKopfFussZeilen In SelectRange(tabKonfig.Range(REF_PROT_KOPF_FUSS_ZEILEN), 1, True)
    
    If Len(rgKopfFussZeilen.Text) = 0 Then Exit For
    lSheetID = CInt(rgKopfFussZeilen)
    
    With oProtokoll.wbProtokoll.Sheets(lSheetID).PageSetup
      
      If (lSheetID <> lSheetIDOld) Then    ' read only once, first time
        
        If (lSheetIDOld <> -1) Then
          If changed(1) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.LeftHeader = header(1)
          If changed(2) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.CenterHeader = header(2)
          If changed(3) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.RightHeader = header(3)
          If changed(4) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.LeftFooter = footer(1)
          If changed(5) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.CenterFooter = footer(2)
          If changed(6) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.RightFooter = footer(3)
          For i = 1 To 6
            changed(i) = False
          Next i
        End If
        
        lSheetIDOld = lSheetID
      End If
      
      sVarText = rgKopfFussZeilen.Offset(0, 2)
      Select Case rgKopfFussZeilen.Offset(0, 1)
      
        Case "LeftHeader"
          For i = 1 To UBound(asVarText)
            If sVarText = asVarText(i) Then
              If changed(1) = False Then
                header(1) = .LeftHeader
                changed(1) = True
              End If
              header(1) = TextErsetzen(header(1), asVarText(i), asText(i))
            End If
          Next i
      
        Case "CenterHeader"
          For i = 1 To UBound(asVarText)
            If sVarText = asVarText(i) Then
              If changed(2) = False Then
                header(2) = .CenterHeader
                changed(2) = True
              End If
              header(2) = TextErsetzen(header(2), asVarText(i), asText(i))
            End If
          Next i
        
        Case "RightHeader"
          For i = 1 To UBound(asVarText)
            If sVarText = asVarText(i) Then
              If changed(3) = False Then
                header(3) = .RightHeader
                changed(3) = True
              End If
              header(3) = TextErsetzen(header(3), asVarText(i), asText(i))
            End If
          Next i
        
        Case "LeftFooter"
          For i = 1 To UBound(asVarText)
            If sVarText = asVarText(i) Then
              If changed(4) = False Then
                footer(1) = .LeftFooter
                changed(4) = True
              End If
              footer(1) = TextErsetzen(footer(1), asVarText(i), asText(i))
            End If
          Next i
        
        Case "CenterFooter"
          For i = 1 To UBound(asVarText)
            If sVarText = asVarText(i) Then
              If changed(5) = False Then
                footer(2) = .CenterFooter
                changed(5) = True
              End If
              footer(2) = TextErsetzen(footer(2), asVarText(i), asText(i))
            End If
          Next i
        
        Case "RightFooter"
          For i = 1 To UBound(asVarText)
            If sVarText = asVarText(i) Then
              If changed(6) = False Then
                footer(3) = .RightFooter
                changed(6) = True
              End If
              footer(3) = TextErsetzen(footer(3), asVarText(i), asText(i))
            End If
          Next i
        
      End Select
    End With
    
  Next rgKopfFussZeilen
  
  If (lSheetIDOld <> -1) Then   ' entered loop at least once, this is last time
    If changed(1) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.LeftHeader = header(1)
    If changed(2) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.CenterHeader = header(2)
    If changed(3) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.RightHeader = header(3)
    If changed(4) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.LeftFooter = footer(1)
    If changed(5) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.CenterFooter = footer(2)
    If changed(6) = True Then oProtokoll.wbProtokoll.Sheets(lSheetIDOld).PageSetup.RightFooter = footer(3)
  End If

Exit Sub
M_StdProt_KopfFusszeileEinrichten_Fehler:
  Call FehlerAusloesen(ERR_PROT_KOPF_FUSS)
End Sub


'--------------------------------------------------------------------------------------------------
Public Sub ReportNew(oProt As C_Protokoll)
  
  On Error Resume Next
  Application.Run "'" & oProt.wbProtokoll.Name & "'!ReportNew", oProt
  Err.Clear

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub ReportBegin(oProt As C_Protokoll)

  On Error Resume Next
  Application.Run "'" & oProt.wbProtokoll.Name & "'!ReportBegin", oProt
  Err.Clear

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub ReportFinished(wbProtokoll As Workbook, _
                          Optional boSeitenAnsichtUnterdruecken = False)

Dim i As Integer

  On Error Resume Next
  Application.Run "'" & wbProtokoll.Name & "'!ReportFinished"
  Err.Clear
  
  If wbProtokoll.Worksheets(TAB_KONFIG).Range(REF_SEITENANSICHT) And _
     Not boSeitenAnsichtUnterdruecken Then
    For i = 1 To wbProtokoll.Sheets.Count
      With wbProtokoll.Sheets(i)
        If .Visible = xlSheetVisible Then
          .Select True
          Exit For
        End If
      End With
    Next i
    For i = 1 To wbProtokoll.Sheets.Count
      With wbProtokoll.Sheets(i)
        If .Visible = xlSheetVisible Then
          .Select False
        End If
      End With
    Next i
    
    ActiveWindow.SelectedSheets.PrintPreview
    
    ' IM 104679 WOKL 16.6.11 Rittmeyer: Bl|fffd|tter k|fffd|nnen nur gesch|fffd|tzt werden,
    ' wenn sie einzeln selektioniert sind
    For i = 1 To wbProtokoll.Sheets.Count
      With wbProtokoll.Sheets(i)
        If .Visible = xlSheetVisible Then
          .Select True
          Exit For
        End If
      End With
    Next i

  End If

End Sub

'--------------------------------------------------------------------------------------------------
Public Function DefLesen() As C_Protokoll

Dim oProt As C_Protokoll
Dim tabKonfig As Worksheet

  Set oProt = New C_Protokoll
  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)

  On Error Resume Next

  'Definierte Konstanten einsetzen
  Set oProt.wbProtokoll = ActiveWorkbook
  oProt.DateiTyp = tabKonfig.Range(REF_DATEI_TYP)
  'oProt.ProtFormat = TabKonfig.Range(REF_DATEI_BEZ)
  oProt.Version = tabKonfig.Range(REF_DATEI_VERSION)
  oProt.Seitenansicht = tabKonfig.Range(REF_SEITENANSICHT)
  Set oProt.ProtTyp = M_ProtokollTyp.Lesen(tabKonfig.Range(REF_PROTOKOLL_TYP))
  oProt.Von = tabKonfig.Range(REF_STARTZEIT)
  oProt.Bis = tabKonfig.Range(REF_STOPPZEIT)
  oProt.Intervall = tabKonfig.Range(REF_INTERVALL)
  oProt.IntEinheit = tabKonfig.Range(REF_INT_EINHEIT)
  oProt.Periode = tabKonfig.Range(REF_PERIODE)
  oProt.PerEinheit = tabKonfig.Range(REF_PER_EINHEIT)
  oProt.Username = tabKonfig.Range(REF_USER)
  oProt.UserFullName = tabKonfig.Range(REF_USER_FULLNAME)
  oProt.Bereich = tabKonfig.Range(REF_AREA_PERMISSIONS)
  'oProt.RequestType = RangeToLng(tabKonfig.Range(REF_REQUESTTYPE))
  
  Select Case tabKonfig.Range(REF_REQUESTTYPE)
    Case TXT_REQUESTTYPE_MAN
      oProt.RequestType = REQUESTTYPE_MAN
    Case TXT_REQUESTTYPE_TIME
      oProt.RequestType = REQUESTTYPE_TIME
    Case TXT_REQUESTTYPE_PVSS
      oProt.RequestType = REQUESTTYPE_PVSS
    Case TXT_REQUESTTYPE_EVENT
      oProt.RequestType = REQUESTTYPE_EVENT
  End Select

  Set DefLesen = oProt
  
End Function

'--------------------------------------------------------------------------------------------------
Public Sub DefSpeichern(oProt As C_Protokoll)

Dim tabKonfig As Worksheet

  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)

  'Definierte Konstanten einsetzen
  tabKonfig.Range(REF_DATEI_TYP) = oProt.DateiTyp
  'TabKonfig.Range(REF_DATEI_BEZ) = oProt.ProtFormat
  tabKonfig.Range(REF_DATEI_VERSION) = oProt.Version
  tabKonfig.Range(REF_SEITENANSICHT) = oProt.Seitenansicht
  tabKonfig.Range(REF_PROTOKOLL_TYP) = oProt.ProtTyp.Bezeichnung
  tabKonfig.Range(REF_STARTZEIT) = oProt.Von
  tabKonfig.Range(REF_STOPPZEIT) = oProt.Bis
  tabKonfig.Range(REF_INTERVALL) = oProt.Intervall
  tabKonfig.Range(REF_INT_EINHEIT) = oProt.IntEinheit
  tabKonfig.Range(REF_PERIODE) = oProt.Periode
  tabKonfig.Range(REF_PER_EINHEIT) = oProt.PerEinheit
  tabKonfig.Range(REF_USER) = oProt.Username
  tabKonfig.Range(REF_USER_FULLNAME) = oProt.UserFullName
  'tabKonfig.Range(REF_REQUESTTYPE) = oProt.RequestType
  Select Case oProt.RequestType
    Case REQUESTTYPE_MAN
      tabKonfig.Range(REF_REQUESTTYPE) = TXT_REQUESTTYPE_MAN
    Case REQUESTTYPE_TIME
      tabKonfig.Range(REF_REQUESTTYPE) = TXT_REQUESTTYPE_TIME
    Case REQUESTTYPE_PVSS
      tabKonfig.Range(REF_REQUESTTYPE) = TXT_REQUESTTYPE_PVSS
    Case REQUESTTYPE_EVENT
      tabKonfig.Range(REF_REQUESTTYPE) = TXT_REQUESTTYPE_EVENT
  End Select

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub lockWorkbook(wbProt As Workbook)

Dim wsProt  As Worksheet
Dim sDatei  As String
Dim sVorlage As String
Dim sProtTyp  As String
Dim dtVon     As Date
Dim iPerEinheit As Integer
Dim oOpt        As C_Optionen

  Set wsProt = wbProt.Worksheets(TAB_KONFIG)
  Set oOpt = M_Optionen.getOpt
  wsProt.Range(REF_PASSWORD) = oOpt.UserPwd
  If getLogChanges(wbProt) Then
    If wbProt.Path = "" Then
      'sDatei =
      dtVon = wsProt.Range(REF_STARTZEIT)
      sProtTyp = wsProt.Range(REF_PROTOKOLL_TYP)
      iPerEinheit = wsProt.Range(REF_PER_EINHEIT)
      sVorlage = wbProt.Name
      sDatei = DateinameErzeugen(sVorlage, dtVon, (iPerEinheit < erTag))
      If Not CBool(SetCurrentDirectory(ProjektPfad & "\" & VERZ_PROTOKOLL & "\" & sProtTyp)) Then
        MkDir (ProjektPfad & "\" & VERZ_PROTOKOLL & "\" & sProtTyp)
        SetCurrentDirectory (ProjektPfad & "\" & VERZ_PROTOKOLL & "\" & sProtTyp)
      End If
      'IM 58093: Aenderungen verfolgen
      wbProt.KeepChangeHistory = True
      wbProt.ChangeHistoryDuration = 9999
      
      'ToDo: pwd
      'wbProt.ProtectSharing Filename:=sDatei
      'wbProt.ProtectSharing Filename:=sDatei, Sharingpassword:=oOpt.UserPwd
      'wbProt.ProtectSharing Filename:=sDatei, Password:="", Sharingpassword:=oOpt.UserPwd
      wbProt.ProtectSharing Filename:=sDatei, Password:=PWD_FILE, Sharingpassword:=oOpt.UserPwd
      Call BugMessage("Workbook " & wbProt.Name & " ProtectedSharing", "M_Protokoll::lockWorkbook")
    Else
      'Nicht Speichern, sonst wird das |fffd|nderungsprotokoll gel|fffd|scht
      'wbProt.Save
    End If
  Else
    For Each wsProt In wbProt.Worksheets
      If IsReportTab(wsProt) Then
        If Not wsProt.Name = TAB_KONFIG Then
          Call BugMessage("Worksheet " & wsProt.Name & " protcted", "M_Protokoll::lockWorkbook")
          Call wsProt.Protect(oOpt.UserPwd, True, True, True)
        End If
      End If
    Next wsProt
  End If
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub unlockWorkbook(wbProt As Workbook)

Dim wsProt As Worksheet
Dim sPW As String
Dim n   As Long
Dim iVisible As Integer

  On Error GoTo unlockWorkbook_Error
  If Not getLogChanges(wbProt) Then
    n = wbProt.ActiveSheet.index
    Set wsProt = wbProt.Worksheets(TAB_KONFIG)
    sPW = wsProt.Range(REF_PASSWORD)
    
    For Each wsProt In wbProt.Worksheets
      If IsReportTab(wsProt) Then
        If Not wsProt.Name = TAB_KONFIG Then
          'Warum auch immer, aber falls mehrere Seiten geleichzeitig markiert sind,
          'kann bloedes Excel nicht den Blattschutz aufheben - grmpf
          iVisible = wsProt.Visible
          If iVisible <> xlSheetVisible Then wsProt.Visible = xlSheetVisible
          wsProt.Select
          Call BugMessage("Worksheet " & wsProt.Name & " unprotcted", "M_Protokoll::unlockWorkbook")
          Call wsProt.Unprotect(sPW)
          If iVisible <> xlSheetVisible Then wsProt.Visible = iVisible
        End If
      End If
    Next wsProt
    On Error Resume Next      ' IM 104043 WOKL 14.3.11 no other chance
    wbProt.Sheets(n).Select   ' error at cost center report renew
  End If
  
Exit Sub
unlockWorkbook_Error:
  Call FehlerAusloesen(ERR_PROT_UNLOCK, wsProt.Name, True)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub showLogChanges(wbProt As Workbook)

  'ToDo: Warum wird immer die erste Tabelle angezeigt?
  's = ActiveCell.Worksheet.Name
  'On Error Resume Next
  On Error GoTo showLogChanges_Fehler
  If wbProt.Worksheets(TAB_KONFIG).Range(REF_LOGCHANGES) Then
    Call BugMessage("Workbook " & wbProt.Name, "M_Protokoll::showLogChanges")
    'wbProt.Save
    wbProt.HighlightChangesOptions when:=xlAllChanges
    wbProt.ListChangesOnNewSheet = True
    'wbProt.Sheets(s).Select
  End If
  
Exit Sub
showLogChanges_Fehler:
  Call BugMessage(Err.Description & " " & Err.Number, "M_Protokoll::showLogChanges")
  Resume Next
End Sub

'--------------------------------------------------------------------------------------------------
Private Function ZeitbereichErforderlich(wbProt As Workbook) As Boolean

Dim wsProt As Worksheet
Dim rg As Range
Dim asTmp() As String

  On Error Resume Next
  ZeitbereichErforderlich = False
  
  Set wsProt = wbProt.Worksheets(TAB_KONFIG)
  If Len(wsProt.Range(REF_PROT_DPL).Offset(1, 0).value) > 0 Then

    For Each rg In SelectRange(wsProt.Range(REF_PROT_DPL).Offset(0, 3), 1, True)
      If RangeToLng(rg) <> ARCHIVTYP_ONLINE And _
         RangeToLng(rg) <> ARCHIVTYP_CALCULATE Then
        ZeitbereichErforderlich = True
        Exit Function
      End If
    Next rg
  
  End If
  
  For Each wsProt In wbProt.Worksheets
    If GetTabFormat(wsProt) = BEZ_SQL_PROTOKOLL Then
      Call StrToArray(asTmp, wsProt.Range("B6").value, "|")
      If UBound(asTmp) >= 1 Then
        If CBool(asTmp(1)) Then
      'If wsProt.Range("B6").Value = True Then
          ZeitbereichErforderlich = True
          Exit Function
        End If
      End If
    End If
  Next wsProt

End Function

'--------------------------------------------------------------------------------------------------
Public Function getMinColor(wbProt As Workbook) As Long
  getMinColor = RangeToLng(wbProt.Worksheets(TAB_KONFIG).Range(REF_MIN_COLOR))
End Function
'--------------------------------------------------------------------------------------------------
Public Function getMaxColor(wbProt As Workbook) As Long
  getMaxColor = RangeToLng(wbProt.Worksheets(TAB_KONFIG).Range(REF_MAX_COLOR))
End Function
'--------------------------------------------------------------------------------------------------
Public Function getLogChanges(wbProt As Workbook) As Boolean
  getLogChanges = RangeToLng(wbProt.Worksheets(TAB_KONFIG).Range(REF_LOGCHANGES))
End Function
'--------------------------------------------------------------------------------------------------
Public Function getFormatStr(sCFormat As String, Optional sUnit As String = "") As String

Dim s As String
Dim x As Integer
Dim y As Integer
Dim i As Integer

  getFormatStr = ""
  If Len(sCFormat) = 0 Then Exit Function
  If Left(sCFormat, 1) <> "%" Then Exit Function
  Select Case Right(sCFormat, 1)
    Case "f"
      i = InStr(1, sCFormat, ".")
      If i = 0 Then
        x = Mid(sCFormat, 2, Len(sCFormat) - 2)
        s = String(x - 1, "#") & "0"
      Else
        x = Mid(sCFormat, 2, i - 2)
        y = Mid(sCFormat, i + 1, Len(sCFormat) - i - 1)
        'IM 55602 "%f5.0"
        If y = 0 Then
          s = String(x - 1, "#") & "0"
        Else
          s = String(x - 1, "#") & "0." & String(y, "0")
        End If
      End If
    Case "d"
      x = Mid(sCFormat, 2, Len(sCFormat) - 2)
      s = String(x - 1, "#") & "0"
    Case "s"
      s = ""
    Case Else
      s = ""
  End Select
  If Len(sUnit) Then
    getFormatStr = s & " """ & sUnit & """"
  Else
    getFormatStr = s
  End If
  
End Function


'--------------------------------------------------------------------------------------------------
Public Function DateinameErzeugen(sVorlage As String, _
                                  dtDatum As Date, _
                                  boWithTime As Boolean) As String
Dim i As Integer

  'Pruefen, ob die Vorlage numerisch ist und Dateinamen erstellen
  If InStr(1, sVorlage, ".") = 0 Then
    i = 1
    Do Until Not IsNumeric(Right$(sVorlage, i))
      i = i + 1
    Loop
    sVorlage = Left(sVorlage, Len(sVorlage) - i + 1)
    If boWithTime Then
      DateinameErzeugen = sVorlage & "_" & Format(dtDatum, "YYYYMMDD_hhmmss") & ".xlsm"   ' IM 115373
    Else
      DateinameErzeugen = sVorlage & "_" & Format(dtDatum, "YYYYMMDD") & ".xlsm"    ' IM 115373
    End If
  Else
    DateinameErzeugen = sVorlage
  End If
  
End Function

'--------------------------------------------------------------------------------------------------
' IM 115373 function declaration changed
Public Sub Speichern(boDateiAuswahl As Boolean, Optional sPath As String = vbNullString, Optional seitenAnsichtUnterdr As Boolean = False)

Dim sDatei    As String
Dim vDatei    As Variant
Dim sVorlage  As String
Dim sProtTyp  As String
Dim dtVon     As Date
Dim iPerEinheit As Integer
Dim i As Integer
Dim tabKonfig  As Worksheet
Dim sAreaPerm  As String

  On Error GoTo M_Protokoll_Speichern_Fehler
  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
  
  dtVon = tabKonfig.Range(REF_STARTZEIT)
  sProtTyp = tabKonfig.Range(REF_PROTOKOLL_TYP)
  iPerEinheit = tabKonfig.Range(REF_PER_EINHEIT)
  
  sAreaPerm = tabKonfig.Range(REF_AREA_PERMISSIONS)
  ' SeitenAnsicht wird nur bei automatischer Ausfuehrung unterdrueckt, dort keine Pr|fffd|fung
  If (seitenAnsichtUnterdr = False And _
      Not CheckAreaAuth(sAreaPerm, PL_AREA_PROT_CHANGE)) Then

    Call MsgBox(GetResText(21189), vbOKOnly + vbCritical, GetResText(20101)) ' keine Berechtigung
      
  Else
    'Trick vom grossem Mumpitz!
    sVorlage = ActiveWorkbook.Name
    'If InStr(1, sVorlage, ".") = 0 Then
    If Len(ActiveWorkbook.Path) = 0 Then
      sDatei = DateinameErzeugen(sVorlage, dtVon, (iPerEinheit < erTag))
    Else
      sDatei = sVorlage
    End If
  
    'ICSGEAD start IM 115373
    If sPath = vbNullString Then
     sPath = ProjektPfad & "\" & VERZ_PROTOKOLL & "\" & sProtTyp
    Else
      If Dir(sPath & "\" & VERZ_PROTOKOLL, vbDirectory) = vbNullString Then
        MkDir (sPath & "\" & VERZ_PROTOKOLL)
      End If
      sPath = sPath & "\" & VERZ_PROTOKOLL & "\" & sProtTyp
    End If
    'ICSGEAD End
      
    If Not CBool(SetCurrentDirectory(sPath)) Then
      MkDir (sPath)
      SetCurrentDirectory sPath
    End If
    
    '25.06.2013 BUEC Kompatibilit|fffd|ts|fffd|berpr|fffd|fung unterdr|fffd|cken / IM 112000
    ActiveWorkbook.CheckCompatibility = False

    If boDateiAuswahl Then
      ' IM 108877 WOKL: filterindex helps to provide filename for excel 2007/2010
      ' IM 115373 ICS
      vDatei = Application.GetSaveAsFilename(sDatei, GetResText(21205) & " (*.xlsm), *.xlsm", 2, GetResText(21110))
      If Not IsNumeric(vDatei) Then
        sDatei = vDatei
        If Len(sDatei) > 0 Then
          'Application.ActiveWorkbook.SaveAs sDatei
          If sDatei <> (ActiveWorkbook.Path & "\" & ActiveWorkbook.Name) Then
            Call BugMessage("Workbook save as " & sDatei, "M_Protokoll::Speichern")
            'ToDo: pwd
            ' IM 115373 FileFormat changed (former: xlWorkbookNormal)
            Application.ActiveWorkbook.SaveAs sDatei, FileFormat:=xlOpenXMLWorkbookMacroEnabled 'Nur freigegebene Protokolle haben ein Passwort  , Password:=PWD_FILE
          Else
            Call BugMessage("Workbook save " & sDatei, "M_Protokoll::Speichern")
            Application.ActiveWorkbook.Save
          End If
        End If
      End If
    Else
      Application.DisplayAlerts = False
      'Application.ActiveWorkbook.SaveAs sDatei
      If sDatei = ActiveWorkbook.Name And _
         sPath = ActiveWorkbook.Path Then
        Call BugMessage("Workbook save " & sDatei, "M_Protokoll::Speichern")
        Application.ActiveWorkbook.Save
      Else
        Call BugMessage("Workbook save as " & sDatei, "M_Protokoll::Speichern")
        'ToDo: pwd
        ' IM 115373 FileFormat changed (former: xlWorkbookNormal)
        Application.ActiveWorkbook.SaveAs sDatei, FileFormat:=xlOpenXMLWorkbookMacroEnabled 'Nur freigegebene Protokolle haben ein Passwort  , Password:=PWD_FILE
      End If
      Application.DisplayAlerts = True
    End If
  End If

Exit Sub
M_Protokoll_Speichern_Fehler:
  Call MsgBox(Err.Description, vbCritical + vbOKOnly, Err.Number & " " & Err.Source)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub SpeichernHTML(oProtokoll As C_Protokoll)
  
Dim sHTMLPfad As String
Dim sFileName As String
Dim udDummy   As SECURITY_ATTRIBUTES
Dim n As Long
Dim bo As Boolean

  If Left(Application.Version, 1) = "8" Then
    Call BugMessage("Excel Version " & Application.Version & _
                    " HTML wird nicht unterstuetzt!", "M_Protokoll::SpeichernHTML")
    Exit Sub
  End If

  SetCurrentDirectory M_Tools.ProjektPfad
  sHTMLPfad = M_Optionen.getOpt.HTMLPfad
  If Len(sHTMLPfad) = 0 Then
    sHTMLPfad = VERZ_PROTOKOLL & "\HTML"
  End If
  
  If Not CBool(SetCurrentDirectory(sHTMLPfad & "\" & oProtokoll.ProtTyp.Bezeichnung)) Then
    Call CreateDirectory(sHTMLPfad, udDummy)
    Call CreateDirectory(sHTMLPfad & "\" & oProtokoll.ProtTyp.Bezeichnung, udDummy)
  End If
  'SetCurrentDirectory (sHTMLPfad & "\" & oProtokoll.ProtTyp.Bezeichnung)
  
  n = InStr(1, UCase(oProtokoll.wbProtokoll.Name), ".XLS")
  If (n > 0) Then
    sFileName = Left(oProtokoll.wbProtokoll.Name, n - 1) & ".html"
  Else
    sFileName = DateinameErzeugen(oProtokoll.wbProtokoll.Name, oProtokoll.Von, (oProtokoll.PerEinheit < erTag))
    n = InStr(1, UCase(sFileName), ".XLS")
    If (n > 0) Then
      sFileName = Left(sFileName, n - 1) & ".html"
    Else
      sFileName = oProtokoll.wbProtokoll.Name & ".html"
    End If
  End If
  
  'Keine Frage, Dateien werden ueberschrieben!
  bo = Application.DisplayAlerts
  Application.DisplayAlerts = False
  Call unlockWorkbook(oProtokoll.wbProtokoll)
  'FileFormat 44 := xlHtml
  sFileName = sHTMLPfad & "\" & oProtokoll.ProtTyp.Bezeichnung & "\" & sFileName
  oProtokoll.wbProtokoll.SaveAs sFileName, _
                                FileFormat:=44, _
                                ReadOnlyRecommended:=False, _
                                CreateBackup:=False
  Call lockWorkbook(oProtokoll.wbProtokoll)
  Application.DisplayAlerts = bo
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Function AktualisierenPruefen(oProtokoll As C_Protokoll, _
                                     iBefehl As Integer, _
                                     oProtVergleich As C_Protokoll)

Dim sDatei              As String
Dim sPfad               As String
Dim vwProtAktualisieren As V_ProtAktualisieren
Dim wbVergleich         As Workbook
Dim sFehlerText         As String
Dim ws                  As Worksheet
Dim bo                  As Boolean

  'Dateiname erzeugen
  sDatei = DateinameErzeugen(oProtokoll.wbProtokoll.Name, oProtokoll.Von, (oProtokoll.PerEinheit < erTag))
  
  sPfad = ThisWorkbook.Path & "\" & VERZ_PROTOKOLL & "\" & oProtokoll.ProtTyp.Bezeichnung
  
  'Pruefen, ob eine Datei mit dem erzeugten Dateinamen existiert
'Gefaehrlich: test_x wird auch bei FileName = "t_x" gefunden!
'  With Application.FileSearch
'    .FileName = sDatei
'    .LookIn = sPfad
'    .MatchTextExactly = True
'    .Execute
'    If .FoundFiles.Count > 0 Then
    If Len(Dir(sPfad & "\" & sDatei)) > 0 Then
      'Pruefen, ob in einer gefundenen Datei die Daten auch uebereinstimmen
      'sDatei = sPfad & "\" & sDatei
      'ToDo: pwd
      Set wbVergleich = Workbooks.Open(sPfad & "\" & sDatei, Password:=PWD_FILE)
      Set oProtVergleich = DefLesen()
      Set oProtVergleich.wbProtokoll = wbVergleich

      'Werte aus Objekt und Datei vergleichen
      sFehlerText = ""
      
      If oProtVergleich.DateiTyp <> DATEI_PROTOKOLL Then
        sFehlerText = sFehlerText & "'" & DATEI_PROTOKOLL & "' | '" & oProtVergleich.DateiTyp & "'" & Chr(13)
      End If
      
'      If oProtVergleich.ProtFormat <> oProtokoll.ProtFormat Then
'        sFehlerText = sFehlerText & "Fehler: ProtFormate ungleich: '" & oProtVergleich.ProtFormat & "' | '" & oProtokoll.ProtFormat & "'" & Chr(13)
'      End If
      'Achtung: hier klaue ich Texte aus den Views
      If oProtVergleich.ProtTyp.Bezeichnung <> oProtokoll.ProtTyp.Bezeichnung Then
        sFehlerText = sFehlerText & GetResText(17140) & " '" & oProtVergleich.ProtTyp.Bezeichnung & "' | '" & oProtokoll.ProtTyp.Bezeichnung & "'" & Chr(13)
      End If
            
      'Rundungsfehler! Nie Zeiten direkt vergleichen!
      'If oProtVergleich.Von <> oProtokoll.Von Then
      If DateDiff("s", oProtVergleich.Von, oProtokoll.Von) <> 0 Then
        sFehlerText = sFehlerText & GetResText(17161) & " '" & oProtVergleich.Von & "' | '" & oProtokoll.Von & "'" & Chr(13)
      End If
      
      'Rundungsfehler! Nie Zeiten direkt vergleichen!
      'If oProtVergleich.Bis <> oProtokoll.Bis Then
      If DateDiff("s", oProtVergleich.Bis, oProtokoll.Bis) <> 0 Then
        sFehlerText = sFehlerText & GetResText(17162) & " '" & oProtVergleich.Bis & "' | '" & oProtokoll.Bis & "'" & Chr(13)
      End If
      
      If oProtVergleich.Intervall <> oProtokoll.Intervall Then
        sFehlerText = sFehlerText & GetResText(17147) & " '" & oProtVergleich.Intervall & "' | '" & oProtokoll.Intervall & "'" & Chr(13)
      End If
      
      If oProtVergleich.Version <> oProtokoll.Version Then
        sFehlerText = sFehlerText & GetResText(21214) & " '" & oProtVergleich.Version & "' | '" & oProtokoll.Version & "'" & Chr(13)
      End If
      
      'Den letzten Zeilenumbruch wieder loeschen
      If Len(sFehlerText) > 0 Then
        sFehlerText = Mid(sFehlerText, 1, Len(sFehlerText) - 1)
        sFehlerText = GetResText(21213) & Chr(13) & sFehlerText
      End If
      
      'View einblenden, ob aktualisiert oder neu berechnet werden soll
      Set vwProtAktualisieren = New V_ProtAktualisieren
      vwProtAktualisieren.Caption = GetResText(20110)
      vwProtAktualisieren.lblTextInfo = GetResText(21164)
      vwProtAktualisieren.lblTextFehler = sFehlerText
      
      'Wenn mit Fehlern beendet, keine Aktualisierung zulassen
      If Len(sFehlerText) > 0 Then
        vwProtAktualisieren.btnAktualisieren.Enabled = False
      End If
      
'      Set ws = ActiveSheet
'      TabMenue.Select
      bo = Application.ScreenUpdating
      Application.ScreenUpdating = True
      vwProtAktualisieren.Show
'      ws.Select
      Application.ScreenUpdating = bo
'      Set ws = Nothing
      
      iBefehl = vwProtAktualisieren.Befehl
      Unload vwProtAktualisieren
      Set vwProtAktualisieren = Nothing
      
    Else 'Kein File gefunden
      iBefehl = -1
      sDatei = ""
    End If
'  End With
End Function



Attribute VB_Name = "M_ProtokollTyp"
'===================================================================================================
'M_ProtokollTyp
'Oliver Seidel 31.07.2000
'  Verwaltung der Protokolltypen
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

'---------------------------------------------------------------------------------------------------
Public Sub Edit()

Dim vwProtTyp As V_ProtTyp
Dim coProtTyp As CO_ProtokollTyp

  On Error GoTo M_ProtokollTyp_Edit_Fehler

  Set vwProtTyp = New V_ProtTyp
  Set coProtTyp = M_ProtokollTyp.coLesen
  Set vwProtTyp.ProtTyp = coProtTyp
  vwProtTyp.Show
  If vwProtTyp.ok Then
    Call M_ProtokollTyp.coSpeichern(coProtTyp)
    'Da die Protokolltypen geaendert wurden, muss der Puffer im Zeitplan geloescht werden!
    Call M_ZeitPlan.init
  End If
  
  Unload vwProtTyp
  Set vwProtTyp = Nothing
Exit Sub
M_ProtokollTyp_Edit_Fehler:
  
  If Not vwProtTyp Is Nothing Then
    Unload vwProtTyp
    Set vwProtTyp = Nothing
  End If
  Call FehlerAusloesen(30702, , False, "M_ProtokollTyp::Edit")

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub addDefaultProtokollTyp(iProtokoll As Integer, lBasisDatenID As Long, lBasisErgebnisID As Long, _
                                  ByVal sysName As String, ByRef archMsg As C_ArchivMsg)

Dim recProtTyp    As ADODB.Recordset
Dim sProtokollTyp As String
Dim lID           As Long
Dim sSql          As String

Dim lStatusId   As Long
Dim sStatusText As String

Dim i As Integer
Dim n As Long
Dim s As String
Dim vAM As V_ArchivMsg

  On Error GoTo addDefaultProtkollTyp_Fehler

  Select Case iProtokoll
    Case erTag:    sProtokollTyp = GetResText(21590) '"Tagesprotokoll"
    Case erMonat:  sProtokollTyp = GetResText(21591) '"Monatsprotokoll"
    Case Else
      Exit Sub
  End Select

  lStatusId = StatusTextAusgeben(GetResText(21318))

  sSql = "SELECT * FROM tabProtTyp WHERE Bezeichnung = '" & sProtokollTyp & "';"
  Set recProtTyp = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  If recProtTyp.EOF Then
    
    If (archMsg.miLastKeyPressed = ARCHMSG_YES Or _
        archMsg.miLastKeyPressed = ARCHMSG_NO) Then      ' if not 'all systems' were clicked
      Set vAM = New V_ArchivMsg
      s = GetResText(21137) ' Basiswert nicht def! - soll er erstellt werden?
      archMsg.msMsg = TextErsetzen(s, "[REPORTTYPE]", sProtokollTyp & " [" & sysName & "] ")
      Set vAM.archivMsg = archMsg
      vAM.Show
    End If
    
    If (archMsg.miLastKeyPressed >= ARCHMSG_YES) Then   ' yes / this system / all systems
      recProtTyp.AddNew
      recProtTyp.Fields("Bezeichnung") = sProtokollTyp
      recProtTyp.Fields("BasiswertDaten") = lBasisDatenID
      recProtTyp.Fields("BasiswertErgebnis") = lBasisErgebnisID
      recProtTyp.Fields("Periode") = 1
      recProtTyp.Fields("PerEinheit") = iProtokoll
      recProtTyp.Fields("Intervall") = 1
      recProtTyp.Fields("BonusIntervall") = 0 'IM 115373 MiD:ab Version 3.7.9
      ' recProtTyp.Fields("vlTyp") = 0 ' IM 112000 WOKL 24.3.15
      
      If iProtokoll = erMonat Then
        recProtTyp.Fields("IntEinheit") = erTag
      Else
        recProtTyp.Fields("IntEinheit") = iProtokoll - 1
      End If
      recProtTyp.Fields("SynchZeit") = getOpt.SynchZeit
      recProtTyp.Fields("SynchWochenTag") = 0
      If iProtokoll = erMonat Then
        recProtTyp.Fields("SynchTag") = 1
      Else
        recProtTyp.Fields("SynchTag") = 0
      End If
      recProtTyp.Fields("SynchMonat") = 0
      recProtTyp.Update
    End If
  End If
  
  Call M_DB.CloseRecordset(recProtTyp)

  Call StatusTextLoeschen(lStatusId)

Exit Sub
addDefaultProtkollTyp_Fehler:
  Call M_DB.CloseRecordset(recProtTyp)
  Call FehlerAusloesen(30705, Err.Description, False, "M_ProtkollTyp::addDefaultProtokollTyp")
End Sub 'addDefaultProtokollTyp()

'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_ProtokollTyp

Dim recProtTyp  As ADODB.Recordset
Dim sSql        As String
Dim oProtTyp    As C_ProtokollTyp

  On Error GoTo ProtokollTyp_coLesen_Fehler

  Set coLesen = New CO_ProtokollTyp
  
  sSql = "SELECT * FROM tabProtTyp"
  Set recProtTyp = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recProtTyp.EOF
    
    Set oProtTyp = New C_ProtokollTyp
    oProtTyp.ID = recProtTyp.Fields("ID")
    oProtTyp.Bezeichnung = recProtTyp.Fields("Bezeichnung")
    Set oProtTyp.BasiswertDaten = M_Basiswert.Lesen(recProtTyp.Fields("BasiswertDaten"))
    Set oProtTyp.BasiswertErgebnis = M_Basiswert.Lesen(recProtTyp.Fields("BasiswertErgebnis"))
    oProtTyp.Periode = recProtTyp.Fields("Periode")
    oProtTyp.PerEinheit = recProtTyp.Fields("PerEinheit")
    oProtTyp.Intervall = recProtTyp.Fields("Intervall")
    oProtTyp.BonusIntervall = recProtTyp.Fields("BonusIntervall")   ' IM 115373
    oProtTyp.IntEinheit = recProtTyp.Fields("IntEinheit")
    oProtTyp.SynchZeit = recProtTyp.Fields("SynchZeit")
    oProtTyp.SynchWochenTag = recProtTyp.Fields("SynchWochenTag")
    oProtTyp.SynchTag = recProtTyp.Fields("SynchTag")
    oProtTyp.SynchMonat = recProtTyp.Fields("SynchMonat")
    
    coLesen.Add oProtTyp
    recProtTyp.MoveNext
  
  Wend
  
  Call M_DB.CloseRecordset(recProtTyp)
  
Exit Function
ProtokollTyp_coLesen_Fehler:
  Call M_DB.CloseRecordset(recProtTyp)
  If Not oProtTyp Is Nothing Then
    Call FehlerAusloesen(30700, "Basiswert #" & oProtTyp.ID, False, "M_ProtokollTyp::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_ProtokollTyp::coLesen")
  End If
End Function

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coProtTyp As CO_ProtokollTyp)

Dim recProtTyp  As ADODB.Recordset
Dim oProtTyp    As C_ProtokollTyp
Dim sSql        As String
Dim lLoeschen   As Long

  On Error GoTo ProtokollTyp_coSpeichern_Fehler

  'DB oeffnen und alle Datensaetz zum Loeschen makieren
  sSql = "UPDATE tabProtTyp SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen
  
  sSql = "SELECT * FROM tabProtTyp"
  Set recProtTyp = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  For Each oProtTyp In coProtTyp.Items
    
    If recProtTyp.BOF And recProtTyp.EOF Then
      recProtTyp.AddNew
    Else
      recProtTyp.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recProtTyp.Find "ID = " & oProtTyp.ID, , adSearchForward
      If recProtTyp.EOF Then
        recProtTyp.AddNew
      Else
        'recProtTyp.Edit
        recProtTyp.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recProtTyp.Fields("Bezeichnung") = oProtTyp.Bezeichnung
    If Not oProtTyp.BasiswertDaten Is Nothing Then
      recProtTyp.Fields("BasiswertDaten") = oProtTyp.BasiswertDaten.ID
    Else
      recProtTyp.Fields("BasiswertDaten") = 0
    End If
    If Not oProtTyp.BasiswertErgebnis Is Nothing Then
      recProtTyp.Fields("BasiswertErgebnis") = oProtTyp.BasiswertErgebnis.ID
    Else
      recProtTyp.Fields("BasiswertErgebnis") = 0
    End If
    recProtTyp.Fields("Periode") = oProtTyp.Periode
    recProtTyp.Fields("PerEinheit") = oProtTyp.PerEinheit
    recProtTyp.Fields("Intervall") = oProtTyp.Intervall
    recProtTyp.Fields("BonusIntervall") = oProtTyp.BonusIntervall   ' IM 115373
    recProtTyp.Fields("IntEinheit") = oProtTyp.IntEinheit
    recProtTyp.Fields("SynchZeit") = oProtTyp.SynchZeit
    recProtTyp.Fields("SynchWochenTag") = oProtTyp.SynchWochenTag
    recProtTyp.Fields("SynchTag") = oProtTyp.SynchTag
    recProtTyp.Fields("SynchMonat") = oProtTyp.SynchMonat
        
    recProtTyp.Update
    'recProtTyp.Bookmark = recProtTyp.LastModified
    oProtTyp.ID = recProtTyp.Fields("ID")

  Next oProtTyp
  
'  recProtTyp.FindFirst "Loeschen <> 0"
'  While Not recProtTyp.NoMatch
'    recProtTyp.FindNext "Loeschen <> 0"
'    lLoeschen = lLoeschen - 1
'  Wend
'  Call BugAssert(lLoeschen = 0)
  
  Call M_DB.CloseRecordset(recProtTyp)
  
  sSql = "DELETE FROM tabProtTyp WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql
  
Exit Sub
ProtokollTyp_coSpeichern_Fehler:
  
  Call M_DB.CloseRecordset(recProtTyp)
  
  Call ErrMessage("sSQL: " & sSql, "M_ProtokollTyp::coSpeichern")
  If Not oProtTyp Is Nothing Then
    Call FehlerAusloesen(30703, "Basiswert " & oProtTyp.Bezeichnung, _
                        False, "M_ProtokollTyp::coSpeichern")
  Else
    Call FehlerAusloesen(30703, Err.Description, _
                        False, "M_ProtokollTyp::coSpeichern")
  End If
  
End Sub 'coSpeichern()

'---------------------------------------------------------------------------------------------------
Public Function Lesen(Optional Bezeichnung As String, Optional ID As Long) As C_ProtokollTyp

Dim recProtTyp  As ADODB.Recordset
Dim oProtTyp    As C_ProtokollTyp
Dim sSql        As String
  
  On Error GoTo ProtokollTyp_Lesen_Fehler

  Set oProtTyp = New C_ProtokollTyp
  
  Call BugAssert((ID > 0) Or (Len(Bezeichnung) > 0), "zu wenig Parameter", "M_ProtokollTyp::Lesen")
  If ID > 0 Then
    sSql = "SELECT * FROM tabProtTyp WHERE ID = " & ID & ";"
  Else
    sSql = "SELECT * FROM tabProtTyp WHERE Bezeichnung = '" & Bezeichnung & "';"
  End If
  Set recProtTyp = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  If Not recProtTyp.EOF Then
    oProtTyp.ID = recProtTyp.Fields("ID")
    oProtTyp.Bezeichnung = recProtTyp.Fields("Bezeichnung")
    oProtTyp.Intervall = recProtTyp.Fields("Intervall")
    Set oProtTyp.BasiswertDaten = M_Basiswert.Lesen(recProtTyp.Fields("BasiswertDaten"))
    Set oProtTyp.BasiswertErgebnis = M_Basiswert.Lesen(recProtTyp.Fields("BasiswertErgebnis"))
    oProtTyp.Periode = recProtTyp.Fields("Periode")
    oProtTyp.PerEinheit = recProtTyp.Fields("PerEinheit")
    oProtTyp.Intervall = recProtTyp.Fields("Intervall")
    oProtTyp.BonusIntervall = recProtTyp.Fields("BonusIntervall") ' IM 115373
    oProtTyp.IntEinheit = recProtTyp.Fields("IntEinheit")
    oProtTyp.SynchZeit = recProtTyp.Fields("SynchZeit")
    oProtTyp.SynchWochenTag = recProtTyp.Fields("SynchWochenTag")
    oProtTyp.SynchTag = recProtTyp.Fields("SynchTag")
    oProtTyp.SynchMonat = recProtTyp.Fields("SynchMonat")
  End If
  
  Call M_DB.CloseRecordset(recProtTyp)
  
  Set Lesen = oProtTyp
  
Exit Function
ProtokollTyp_Lesen_Fehler:
  
  Call M_DB.CloseRecordset(recProtTyp)
  If Not oProtTyp Is Nothing Then
    Call FehlerAusloesen(30705, "Basiswert #" & oProtTyp.ID, False, "M_ProtokollTyp::Lesen")
  Else
    Call FehlerAusloesen(30705, Err.Description, False, "M_ProtokollTyp::Lesen")
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Sub dpt(coProtTyp As CO_ProtokollTyp, ByRef asDpt() As String)

Dim oProtTyp    As C_ProtokollTyp
Dim oArchiv     As C_Archiv
Dim iProtTypID  As Integer
Dim iDPTID      As Integer
Dim boGefunden  As Boolean

Dim i As Integer

  ReDim asDpt(0)
  For Each oProtTyp In coProtTyp.Items
    For Each oArchiv In oProtTyp.BasiswertDaten.coArchive.Items
      boGefunden = False
      For i = 1 To UBound(asDpt)
        If oArchiv.dpt = asDpt(i) Then
          boGefunden = True
          Exit For
        End If
      Next i
      If Not boGefunden Then
        ReDim Preserve asDpt(UBound(asDpt) + 1)
        asDpt(UBound(asDpt)) = oArchiv.dpt
      End If
    Next oArchiv
  Next oProtTyp

End Sub

Attribute VB_Name = "M_PublicMacro"
Option Explicit

Public Sub ReportStoppen()
Attribute ReportStoppen.VB_ProcData.VB_Invoke_Func = " \n14"
  Call M_Report.ReportEnde
End Sub

Public Sub ReportStarten()
Attribute ReportStarten.VB_ProcData.VB_Invoke_Func = " \n14"
  Call M_Report.ReportStart
End Sub

'Public Function firstMin(rg As Range) As Boolean
'  firstMin = True
'End Function


Attribute VB_Name = "M_Report"
'==================================================================================================
'M_Report
'
'Oliver Seidel
'08.02.1999
'
'Versionsverwaltung:
' v1.0.1 - Projektstart
' v1.0.2 - Prototyp
' v1.0.3 - Standardvorlage erstellen
' v1.1.0 - Testversion Standardvorlage
' v1.1.1 - Standardprotokolle erstellen
' v1.2.0 - Testversion Standardprotokolle
' v1.2.1 - DDE Verbindung mit PVSS
' v1.2.2 - DPLErstellen mit PVSS
' v1.2.3 - DPAbfrage mit PVSS
' v1.3.0 - Testversion DDE
' v1.3.1 - Benutzerfuehrung und Menuesystem
' v1.4.0 - BetaTest
' v1.4.1 - Abschlusstest im ARA Paket 1.1
' v1.4.2 - Fehlerbehebung
' v1.4.3 - Testversion ARA Paket 1.1
' v1.4.4 - Fehlerbereinigung
'
' v2.0   - Ziel! Projekt zur Auslieferung mit ARA Paket
' v2.0.1 - Projekt SwB: Automatische Protokollerstellung auf Anfrage von PVSS implementiert
' v2.0.2 - Projekt SwB: Automatische Kopie von Protokollen auf \\T01-12\PVSS\WWA (hardcoded)
' v2.0.3 - Projekt SAG Schrack: Betriebsprotokoll
' v2.0.4 - Projekt SAG Schrack: SQL Abfrage
' V2.1   - Neue Dateiversion fuer Vorlagen!
' V2.1.1 - Kopf/Fusszeilen werden schon bei der Erstellung von Vorlagen analysiert und gespeichert
'          Optimierung der Routine zum Einfuegen von Zeilen.
' V2.1.2 - Schnellanwahl von Protokollen implementiert
' V2.1.3 - Spezialfall: Kein LArchiv, keine Unterscheidung nach DPT, nur DPE mit Aliasnamen
' V2.2   - Internationale Version
' V2.2.1 - Makro ReportFinished in Vorlagen automatisch ausfuehren
' V2.2.2 - ATV Protokoll eingebaut
' V2.3   - Erweiterungen fuer Rittmeyer: Freie Blattbezeichner, Seitenansicht, [From] [To] formatieren
'          Das Protokollformat wird nun an der Zelle A1 jeder Vorlage erkannt!
' V2.3.1 - [From Date], [From Time], [To Date] und [To Time] eingebaut.
'          Platzhalter werden gesammelt ueber alle Sheets bearbeitet.
' V2.4.0 - Version gesplittet fuer LZA und HistoryDB
'
' V3.0   - Neue Version: interne DB, ComMan, ...
' V3.0.1 - Kleinere BUGs behoben.
' V3.0.2 - TI 8601: Lizensierung
' V3.1   - EMail Verteiler, Verteilte Systeme
' V3.1.1 - Min/Max Markierung
' V3.1.2 - TI 14550 - Synchzeit bei Wochen
' V3.2.0 - SQL, gemeinsame Vorlage aller ProtFormate, Abfrage von HDBdirekt und Online Values,...
' V3.2.1 - TI 17736, 17751 - Dongshen, Chinesisch, Optimierung fuer exessive Typ in Typ Referenzen
'....
' V3.5   - IM 93829: Erweiterung Powermanagement/Kostenstellenreport fuer Siemens
' V3.6 - IM 98626: Erweiterung Bereichsberechtigungen & Login f|fffd|r Rittmeyer
'
'ACHTUNG: Aktuelle Versionsnummer in M_Tools::PROJEKT_VERSION eintragen!!!
'         Aenderungen an Dateiformaten werden nur an den ersten beiden Stellen erkannt!!!
'         (siehe ::VersionPruefen der einzelnen ProtokollFormate)
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

'Public goReport       As C_Report
'Public gboReportLaeuft As Boolean

Private mboPassword   As Boolean

Private Const DEFAULT_PASSWORT = "erAdmin"

'---------------------------------------------------------------------------------------------------
Public Sub ReportStart()

Dim oOpt As C_Optionen
Dim obj As Object

  On Error GoTo ReportStart_Fehler
  'gboReportLaeuft = True
  
  Call BugMessage("Projektstart, " & HostName & ", " & Username, "M_Report::ReportStart")
  
  ' IM 99291: die wichtigsten Fehlerquellen abpruefen
  On Error GoTo COM_Fehler
  Set obj = New ComManager
  
  On Error GoTo SubTimer_Fehler
  Set obj = New CTimer
  
  On Error GoTo AdoDB_Fehler
  Set obj = New ADODB.Connection
  
  On Error GoTo ReportStart_Fehler

  'Zugriff auf Optionen
  '(Damit ist die Sprache eingestellt)
  Set oOpt = getOpt
  
  'Sind die erforderlichen Verzeichnisse vorhanden?
  'ToDo: Ist MkDir auch bei UNC Pfaden zulaessig?
  If Not CBool(SetCurrentDirectory(ProjektPfad & "\" & VERZ_PROTOKOLL)) Then
    MkDir (ProjektPfad & "\" & VERZ_PROTOKOLL)
  End If
  If Not CBool(SetCurrentDirectory(ProjektPfad & "\" & VERZ_VORLAGE)) Then
    MkDir (ProjektPfad & "\" & VERZ_VORLAGE)
  End If

  tabKonfig.Visible = xlSheetVeryHidden
  'TabFehlerCode.Visible = xlSheetHidden
  TabResText.Visible = xlSheetHidden
  
  Call SymbolleisteEinrichten
  
  TabMenue.Activate
  TabMenue.Range("A1").Select
  With ActiveWindow
    .DisplayHorizontalScrollBar = False
    .DisplayVerticalScrollBar = False
    .DisplayWorkbookTabs = False
    .DisplayHeadings = False
  End With
  TabMenue.Anzeigen
  
  'Set goReport = New C_Report
  M_PVSS.PVSSInit
  M_ZeitPlan.init

  'IM 55853 (Wenns denn sein muss)
  Call TabMenue.SchnellanwahlAnzeigen
  
Exit Sub

COM_Fehler:
  Call BugMessage("COM Fehler", "M_Report::ReportStart")
  Call FehlerAusloesen(ERR_PVSS_INIT, "COM Manager WCCOAcom.dll not registered?")
Exit Sub

SubTimer_Fehler:
  Call BugMessage("SubTimer Fehler", "M_Report::ReportStart")
  Call FehlerAusloesen(ERR_INTERN, "SubTimer.dll not registered?")
Exit Sub

AdoDB_Fehler:
  Call BugMessage("ADODB Fehler", "M_Report::ReportStart")
  Call FehlerAusloesen(ERR_INTERN_DB, "MS ADODB mdac.dll not registered?")
Exit Sub

ReportStart_Fehler:
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Report::ReportStart")
  
  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub ReportEnde()
  
  On Error Resume Next
  'gboReportLaeuft = False
  
  Call M_PVSS.PVSSStop
  Call M_ZeitPlan.Reset
  
  SymbolleisteWiederherstellen
  
'Die Tabellen brauchen wir nicht mehr anzeigen
'  TabKonfig.Visible = xlSheetVisible
'  TabFehlerCode.Visible = xlSheetVisible
'  TabResText.Visible = xlSheetVisible
  
  Call BugMessage("Projektende", "M_Report::ReportEnde")

  'Fehler koennen bei geschuetzter Arbeitsmappe auftreten
  '- ist aber nicht weiter kritisch!
  On Error Resume Next
  TabMenue.Activate
  ActiveSheet.Range("A1").Select
  'ActiveSheet.Unprotect
  With ActiveWindow
    .DisplayHorizontalScrollBar = True
    .DisplayVerticalScrollBar = True
    .DisplayWorkbookTabs = True
    .DisplayHeadings = True
  End With

  'Set goReport = Nothing

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Konfiguration()

Dim vwKennwort  As V_Kennwort
Dim cmdCtl      As CommandBarControl

  Set vwKennwort = New V_Kennwort
  vwKennwort.Titel = GetResText(11120)
  vwKennwort.InfoText = GetResText(11121)
  vwKennwort.Kennwort = M_Report.getPassword
  vwKennwort.Show
  
  If vwKennwort.ok Then
    Call ReportEnde
  End If

  Unload vwKennwort
  Set vwKennwort = Nothing

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub DateiNeu(ByVal sDateiTyp As String, _
                    Optional ByVal sProtFormat As String)

Dim vwProtFormat   As V_ProtFormat  'Auswahlfenster
Dim asProtFormat() As String        'Liste der Formate
Dim iProtFormat    As Integer       'Index der Formate

Dim lStatus As Long

  On Error GoTo M_Report_DateiNeu_Fehler
  
  'Protokollformate einlesen
  For iProtFormat = 1 To M_Optionen.getOpt.ProtFormatAnz
    ReDim Preserve asProtFormat(iProtFormat)
    asProtFormat(iProtFormat) = M_Optionen.getOpt.ProtFormat(iProtFormat)
  Next iProtFormat
  
  'Wenn das Protokollformat vorgewaehlt wurde
  If Len(sProtFormat) > 0 Then
    
    'Wenn Protokollformat gueltig ist
    For iProtFormat = 1 To UBound(asProtFormat)
      If sProtFormat = asProtFormat(iProtFormat) Then
        'Auswahl auf dieses Protokollformat beschraenken
        ReDim asProtFormat(1)
        asProtFormat(1) = sProtFormat
        Exit For
      End If
    Next iProtFormat
  
  End If
  
  'Wenn die Auswahl nicht eindeutig ist
  If UBound(asProtFormat) > 1 Then
  
    'Statusmeldung ausgeben
    lStatus = StatusTextAusgeben(GetResText(21323))

    'Pruefen, ob vwProtFormat angezeigt werden muss
    If sDateiTyp <> DATEI_PROTOKOLL Then
      
      'Auswahlfenster anzeigen
      Set vwProtFormat = New V_ProtFormat
      Call vwProtFormat.ProtFormate(asProtFormat)
      Call vwProtFormat.Show
    
      'Wenn Format ausgewaehlt wurde
      If vwProtFormat.ok Then
        'Auswahl des Benutzers auslesen
        sProtFormat = vwProtFormat.ProtFormat
      Else
        'Vorgaben loeschen
        sProtFormat = ""
      End If
      
      'Fenster loeschen
      Unload vwProtFormat
      Set vwProtFormat = Nothing
      
      'Statustext loeschen
      Call StatusTextLoeschen(lStatus)
    End If
  
  Else
    sProtFormat = asProtFormat(1)
  End If
  
  
  'Formate bestimmen
  Select Case sDateiTyp
    
    Case DATEI_VORLAGE
      'Aktion wurde abgebrochen
      If sProtFormat = "" Then Exit Sub

      Call M_Vorlage.Neu(sProtFormat)

    Case DATEI_PROTOKOLL
      Call M_Protokoll.Neu(sProtFormat)
  
  End Select

Exit Sub
M_Report_DateiNeu_Fehler:
  
  If Not vwProtFormat Is Nothing Then
    Unload vwProtFormat
    Set vwProtFormat = Nothing
  End If
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Report::DateiNeu")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub DateiOeffnen(Optional ByVal sDateiTyp As String = "")

Dim sDatei As String
Dim sDateiTypen As String
Dim wbProtokoll As Workbook
Dim i As Integer
Dim sAreaPerm As String

  On Error GoTo M_Report_DateiOeffnen_Fehler
  
  Select Case sDateiTyp
  
  'ICSGEAD IM 115373
    Case DATEI_VORLAGE
      Call SetCurrentDirectory(ProjektPfad & "\" & VERZ_VORLAGE)
      sDateiTypen = GetResText(21204) & " (*.xltm), *.xltm" & "," & GetResText(21204) & " (*.xlt), *.xlt"
    Case DATEI_PROTOKOLL
      Call SetCurrentDirectory(ProjektPfad & "\" & VERZ_PROTOKOLL)
      sDateiTypen = GetResText(21205) & " (*.xlsm), *.xlsm" & "," & GetResText(21205) & " (*.xls), *.xls"
    Case Else
      Call SetCurrentDirectory(ProjektPfad)
      sDateiTypen = GetResText(21204) & " (*.xltm), *.xltm" & "," & GetResText(21204) & " (*.xlt), *.xlt" & ", " & _
                    GetResText(21205) & " (*.xlsm), *.xlsm" & "," & GetResText(21205) & " (*.xls), *.xls"
  End Select
  
  'ToDo: vDatei da Benutzer auch Abbrechen kann
  sDatei = Application.GetOpenFilename(sDateiTypen, , GetResText(21124), , False)
    
  Application.ScreenUpdating = False
  On Error Resume Next
  'ToDo: pwd
  Set wbProtokoll = Application.Workbooks.Open(sDatei, Password:=PWD_FILE)
  If Err.Number > 0 Then
    Application.ScreenUpdating = True
    On Error GoTo M_Report_DateiOeffnen_Fehler
  Else
    On Error GoTo M_Report_DateiOeffnen_Fehler
    
    Select Case DateiTyp(wbProtokoll)
      
    Case DATEI_VORLAGE
      Call M_Vorlage.VersionPruefen
      
    Case DATEI_PROTOKOLL
      sAreaPerm = wbProtokoll.Worksheets(TAB_KONFIG).Range(REF_AREA_PERMISSIONS)
      If (Not CheckAreaAuth(sAreaPerm, PL_AREA_PROT_NEW)) Then
    
        Call MsgBox(GetResText(21188), vbOKOnly + vbCritical, GetResText(20101)) ' keine Berechtigung
        ActiveWorkbook.Close SaveChanges:=False
  
      Else
        'Version Pruefung ist natuerlich bloed, da auch aeltere Versionen geoeffnet werden sollen
        'Call M_Protokoll.VersionPruefen
        i = wbProtokoll.ActiveSheet.index
        Call showLogChanges(wbProtokoll)
        If wbProtokoll.Worksheets(TAB_KONFIG).Range(REF_SEITENANSICHT) Then
          For i = 1 To wbProtokoll.Sheets.Count
            With wbProtokoll.Sheets(i)
              If .Visible = xlSheetVisible Then
                .Select False
              End If
              If (Not CheckAreaAuth(sAreaPerm, PL_AREA_PROT_CHANGE)) Then
                .Protect
              End If
            End With
          Next i
          ActiveWindow.SelectedSheets.PrintPreview
        Else
          On Error Resume Next    ' IM 109084 error 1004 doesn't occur on single step
          wbProtokoll.Sheets(i).Select
          On Error GoTo M_Report_DateiOeffnen_Fehler
        End If
        
        If (Not CheckAreaAuth(sAreaPerm, PL_AREA_PROT_CHANGE)) Then
          ActiveWorkbook.Saved = True
        End If
      End If
      
    'ACHTUNG: Momentan koennen nur Projektdateien geoeffnet werden!
    Case Else
      Call MsgBox(GetResText(21127), _
                  vbOKOnly + vbCritical, _
                  GetResText(21116))
      ActiveWorkbook.Close SaveChanges:=False
       
    End Select
  End If

  Application.ScreenUpdating = True

Exit Sub
M_Report_DateiOeffnen_Fehler:
  Application.ScreenUpdating = True
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Report::Datei|fffd|ffnen")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DateiSpeichern()
  
  'ToDo: immer ActiveWorkbook?
  Select Case DateiTyp(ActiveWorkbook)
  
    Case DATEI_VORLAGE
      Call M_Vorlage.Speichern
      
    Case DATEI_PROTOKOLL
      Call M_Protokoll.Speichern(True)
    
    Case Else
      ActiveWorkbook.Save
  
  End Select
End Sub

'--------------------------------------------------------------------------------------------------
Public Function DateiTyp(wb As Workbook) As String
  On Error Resume Next
  DateiTyp = wb.Worksheets(TAB_KONFIG).Range(REF_DATEI_TYP).Text
End Function

'--------------------------------------------------------------------------------------------------
Public Function xDateityp() As String

Dim sDateiTyp As String
Dim i As Integer
  
  For i = 1 To ActiveWorkbook.Worksheets.Count
    If ActiveWorkbook.Worksheets(i).Name = TAB_KONFIG Then
      sDateiTyp = ActiveWorkbook.Worksheets(i).Range(REF_DATEI_TYP)
      Exit For
    End If
  Next i

  xDateityp = sDateiTyp

End Function

'--------------------------------------------------------------------------------------------------
Public Function DateiBez() As String

Dim sDateiBez As String
Dim i As Integer
   
  ' IM 72165 WOKL 12.9.07
  'Call NZD("Haltbarkeitsdatum der Funktion ist abgelaufen!", "M_Report::DateiBez()")
  'Exit Function
  
  For i = 1 To ActiveWorkbook.Worksheets.Count
    If ActiveWorkbook.Worksheets(i).Name = TAB_KONFIG Then
      sDateiBez = ActiveWorkbook.Worksheets(i).Range(REF_DATEI_BEZ)
      Exit For
    End If
  Next i

  DateiBez = sDateiBez

End Function

'--------------------------------------------------------------------------------------------------
Public Function DateiVersion() As String

Dim sDateiVersion As String
Dim i As Integer
  
  For i = 1 To ActiveWorkbook.Worksheets.Count
    If ActiveWorkbook.Worksheets(i).Name = TAB_KONFIG Then
      sDateiVersion = ActiveWorkbook.Worksheets(i).Range(REF_DATEI_VERSION)
      Exit For
    End If
  Next i

  DateiVersion = sDateiVersion

End Function

'--------------------------------------------------------------------------------------------------
Public Function IsReportTab(wbProtVorlage As Worksheet) As Boolean

Dim sProtFormat As String

  If wbProtVorlage.Name = TAB_KONFIG Then
    IsReportTab = False
    Exit Function
  End If
  
  sProtFormat = wbProtVorlage.Range("A1")
  If sProtFormat = BEZ_STD_PROTOKOLL Or _
     sProtFormat = BEZ_BTR_PROTOKOLL Or _
     sProtFormat = BEZ_ATV_PROTOKOLL Or _
     sProtFormat = BEZ_SQL_PROTOKOLL Or _
     sProtFormat = BEZ_KST_PROTOKOLL Then
    IsReportTab = True
  Else
    IsReportTab = False
  End If

End Function

'--------------------------------------------------------------------------------------------------
'Liefert das Format der Tabelle
Public Function GetTabFormat(ws As Worksheet) As String

Dim sProtFormat As String

  If ws.Name = TAB_KONFIG Then
    GetTabFormat = TAB_KONFIG
  Else
    sProtFormat = ws.Range("A1").value
    If sProtFormat = BEZ_STD_PROTOKOLL Or _
       sProtFormat = BEZ_BTR_PROTOKOLL Or _
       sProtFormat = BEZ_ATV_PROTOKOLL Or _
       sProtFormat = BEZ_KST_PROTOKOLL Or _
       sProtFormat = BEZ_SQL_PROTOKOLL Then
      GetTabFormat = sProtFormat
    Else
      GetTabFormat = ""
    End If
  End If

End Function

'--------------------------------------------------------------------------------------------------
Public Function CDateiTypToText(sDateiTyp As String)

  Select Case sDateiTyp
    Case DATEI_VORLAGE
      CDateiTypToText = GetResText(21204)
    Case DATEI_PROTOKOLL
      CDateiTypToText = GetResText(21205)
    Case Else
      Call ErrMessage("Unbekannter Dateityp! " & sDateiTyp, "CDateiTypToText")
      CDateiTypToText = sDateiTyp
  End Select

End Function

'--------------------------------------------------------------------------------------------------
Public Function CDateiTypToConst(sDateiTyp As String)

  Select Case sDateiTyp
    Case GetResText(21204)
      CDateiTypToConst = DATEI_VORLAGE
    Case GetResText(21205)
      CDateiTypToConst = DATEI_PROTOKOLL
    Case Else
      Call ErrMessage("Unbekannter Dateityp! " & sDateiTyp, "CDateiTypToConst")
      CDateiTypToConst = sDateiTyp
  End Select

End Function

'--------------------------------------------------------------------------------------------------
Public Function CProtFormatToText(sProtFormat As String)

    Select Case sProtFormat
      Case BEZ_STD_PROTOKOLL
        CProtFormatToText = GetResText(21500)
      Case BEZ_BTR_PROTOKOLL
        CProtFormatToText = GetResText(21501)
      Case BEZ_ATV_PROTOKOLL
        CProtFormatToText = GetResText(21505)
      Case BEZ_SQL_PROTOKOLL
        CProtFormatToText = GetResText(21503)
      Case BEZ_KST_PROTOKOLL
        CProtFormatToText = GetResText(21508)
      Case Else
        Call ErrMessage("Unbekanntes ProtFormat! " & sProtFormat, "M_Report::CProtFormatToText")
    End Select

End Function

'--------------------------------------------------------------------------------------------------
Public Function CProtFormatToConst(sProtFormat As String)

    Select Case sProtFormat
      Case GetResText(21500)
        CProtFormatToConst = BEZ_STD_PROTOKOLL
      Case GetResText(21501)
        CProtFormatToConst = BEZ_BTR_PROTOKOLL
      Case GetResText(21505)
        CProtFormatToConst = BEZ_ATV_PROTOKOLL
      Case GetResText(21503)
        CProtFormatToConst = BEZ_SQL_PROTOKOLL
      Case GetResText(21508)
        CProtFormatToConst = BEZ_KST_PROTOKOLL
      Case Else
        Call ErrMessage("Unbekanntes ProtFormat! " & sProtFormat, "M_Report::CProtFormatToConst")
    End Select

End Function

'--------------------------------------------------------------------------------------------------
Public Sub ProjektBeenden()

'Dim wb As Workbook
'
'  Application.ScreenUpdating = False
'  For Each wb In Workbooks
'    wb.Activate
'    If DateiTyp = DATEI_VORLAGE Or _
'       DateiTyp = DATEI_PROTOKOLL Then
'
'      Call MsgBox("Projekt kann nicht beendet werden, da noch" & Chr(13) & _
'                  "Projektdateien geoeffnet sind!", _
'                  vbOKOnly + vbExclamation, _
'                  "ACHTUNG")
'
'      Application.ScreenUpdating = True
'      Exit Sub
'    End If
'  Next wb
'  ThisWorkbook.Activate
'  Application.ScreenUpdating = True
'  Call M_Report.ReportEnde
'  ThisWorkbook.Saved = True
'  goReport.Quit
'
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DateiSchliessen()

'Dim wb As Workbook
'
'  If DateiTyp = DATEI_PROJEKT Then
'    Application.ScreenUpdating = False
'    For Each wb In Workbooks
'      wb.Activate
'      If DateiTyp = DATEI_VORLAGE Or _
'         DateiTyp = DATEI_PROTOKOLL Then
'
'        Call MsgBox("Projekt kann nicht beendet werden, da noch" & Chr(13) & _
'                    "Projektdateien geoeffnet sind!", _
'                    vbOKOnly + vbExclamation, _
'                    "ACHTUNG")
'
'        Application.ScreenUpdating = True
'        Exit Sub
'      End If
'    Next wb
'    ThisWorkbook.Activate
'    Application.ScreenUpdating = True
'    Call M_Report.ReportEnde
'
'    Call goReport.Schliessen(boAenderungenSpeichern:=False)
'  Else
'    ActiveWorkbook.Close
'  End If
End Sub

'--------------------------------------------------------------------------------------------------
Public Function CheckPassword(boAskForPassword As Boolean, fktId As Integer) As Boolean

Dim vwKennwort As V_Kennwort

  If M_Optionen.isPvssLogin Then
    CheckPassword = M_PVSSLogin.CheckPLPassword(boAskForPassword, fktId)
  Else
    If mboPassword Then
      CheckPassword = True
    Else
      If boAskForPassword Then
        Set vwKennwort = New V_Kennwort
        vwKennwort.Kennwort = M_Report.getPassword
        vwKennwort.Show
  
        If vwKennwort.ok Then
          CheckPassword = True
  
          If vwKennwort.PasswortSpeichern Then
            mboPassword = True
          End If
  
        End If
      Else
        CheckPassword = False
      End If
    End If
    
    If (CheckPassword) Then
      M_Optionen.AutoLogoutInit
    End If
  End If
End Function

'--------------------------------------------------------------------------------------------------
Public Sub ResetPasswordSession()
  If M_Optionen.isPvssLogin Then
    Call M_PVSSLogin.ResetPasswordSession
  Else
    mboPassword = False
  End If
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub changePassword()

Dim vwPW As V_KennwortNew
  
  Set vwPW = New V_KennwortNew
  vwPW.KennwortOld = getPassword
  vwPW.Show
  If vwPW.ok Then
    Call setPassord(vwPW.KennwortNew)
  End If
  Unload vwPW
  Set vwPW = Nothing
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Function getPassword() As String

Dim recProjekt  As ADODB.Recordset
Dim sSql        As String
  
  On Error GoTo Fehler_getPassword
  sSql = "SELECT Passwort FROM tabProjekt"
  Set recProjekt = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  If Not recProjekt.EOF Then
    getPassword = recProjekt.Fields(0).value
  Else
    getPassword = "erAdmin"
  End If
  Call M_DB.CloseRecordset(recProjekt)

Exit Function
Fehler_getPassword:
  getPassword = "erAdmin"
End Function

'--------------------------------------------------------------------------------------------------
Public Sub setPassord(sPassword As String)

Dim recProjekt  As ADODB.Recordset
Dim sSql        As String

  On Error Resume Next

  sSql = "SELECT Passwort FROM tabProjekt"
  Set recProjekt = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  recProjekt.MoveFirst
  If Not recProjekt.EOF Then
    recProjekt.Fields(0).value = sPassword
    recProjekt.Update
  End If
  Call M_DB.CloseRecordset(recProjekt)

End Sub
Attribute VB_Name = "M_SQLProt"
Option Explicit

'--------------------------------------------------------------------------------------------------
Public Sub Erstellen(wsProt As Worksheet, _
                     oProtokoll As C_Protokoll, _
                     coTabBereich As CO_TabBereich)

Dim rgDef   As Range
Dim sSql    As String
Dim vDaten  As Variant
Dim iDatenAnz As Integer
Dim rgDaten   As Range
Dim oTabBereich  As C_TabBereich
Dim rgStart      As Range
Dim rg           As Range

  'SQL String zusammenstellen
  sSql = getSQLString(wsProt, oProtokoll)
  
  'Abfragen
  Call M_PVSS.SQLQuery(sSql, vDaten)
  If Not IsEmpty(vDaten) Then
    iDatenAnz = UBound(vDaten)
  End If
  'Seite einrichten
  Call SeiteEinrichten(oProtokoll, wsProt, coTabBereich, iDatenAnz, rgDaten)
  
  'Werte eintragen
  Call WerteEintragen(wsProt, vDaten, rgDaten)

  'Spaltenbreite anpassen?
  If RangeToLng(wsProt.Range("B8")) = 42 Then
    Set oTabBereich = coTabBereich.FindItem(wsProt.index, VAR_KOPFZEILE)
    If oTabBereich Is Nothing Then Exit Sub
    Set rgStart = wsProt.Cells(oTabBereich.Zeile, 1)
    Set rg = wsProt.Range(rgStart, rgDaten)
    rg.Columns.AutoFit
  End If

End Sub

'--------------------------------------------------------------------------------------------------
Private Function getSQLString(wsProt As Worksheet, oProtokoll As C_Protokoll)

Dim rgDef   As Range
Dim sSql    As String
Dim asTmp() As String
Dim s       As String
Dim i As Integer
Dim j As Integer

  'SQL String zusammenstellen
  'SELECT
  Set rgDef = wsProt.Range("B2")
  sSql = "SELECT " & rgDef.Text

  'FROM
  s = rgDef.Offset(1, 0).Text
  If Len(s) Then
    sSql = sSql & " FROM " & s
  End If

  'REMOTE
  s = rgDef.Offset(2, 0).Text
  If Len(s) Then
    sSql = sSql & " REMOTE " & s
  End If

  'WHERE
  s = rgDef.Offset(3, 0).Text
  If Len(s) Then
    sSql = sSql & " WHERE " & s
  End If
  
  'TIMERANGE
  s = rgDef.Offset(4, 0).Text
  If Len(s) Then
    On Error Resume Next
    Call StrToArray(asTmp, s, "|")
    If UBound(asTmp) >= 2 Then i = asTmp(2)
    If UBound(asTmp) >= 3 Then j = asTmp(3)
    If UBound(asTmp) >= 1 Then
      If CBool(asTmp(1)) Then
        sSql = sSql & " TIMERANGE(""" & _
               Format(oProtokoll.Von, "YYYY.MM.DD hh:mm:ss") & """,""" & _
               Format(oProtokoll.Bis, "YYYY.MM.DD hh:mm:ss") & """," & i & "," & j & ")"
      End If
    End If
  End If
  
  'SORT BY
  s = rgDef.Offset(5, 0).Text
  If Len(s) Then
    sSql = sSql & " SORT BY " & s
  End If

  getSQLString = sSql
  
End Function

'--------------------------------------------------------------------------------------------------
Public Sub SeiteEinrichten(oProtokoll As C_Protokoll, _
                           wsProt As Worksheet, _
                           coTabBereich As CO_TabBereich, _
                           iDatenAnz As Integer, _
                           rgDaten As Range)

Dim oTabBereich   As C_TabBereich
Dim oBereichKopf  As C_TabBereich
Dim oBereichDaten As C_TabBereich
Dim oBereichFuss   As C_TabBereich
Dim oBereichEnde  As C_TabBereich

Dim rgStart As Range
Dim rgEnde  As Range
Dim rgSuche As Range

Dim boSpalteAEingeblendet As Boolean

Dim rgDatenStart  As Range
Dim rgDatenEnde   As Range
Dim iDatenZeile   As Integer
Dim dtZeit        As Date
Dim lwsProtID     As Long

Dim fStatus   As Single
Dim lStatusId As Long
Dim boErsterFehler As Boolean

  On Error GoTo M_SQLProt_SeiteEinrichten_Fehler

  ReDim audZeile(0)
  lStatusId = StatusTextAusgeben("")
     
  Call StatusTextAusgeben(wsProt.Name & " einrichten ", lStatusId)
  
'Call ZeitMessung(True)
    
  lwsProtID = wsProt.index
  wsProt.EnableCalculation = False
  
  Set oBereichKopf = coTabBereich.FindItem(lwsProtID, VAR_KOPFZEILE)
  Set oBereichDaten = coTabBereich.FindItem(lwsProtID, VAR_DATENBEREICH)
  Set oBereichFuss = coTabBereich.FindItem(lwsProtID, VAR_FUSSZEILE)
  Set oBereichEnde = coTabBereich.FindItem(lwsProtID, VAR_SEITENENDE)
  
  wsProt.Range(wsProt.Cells(1, 1), wsProt.Cells(oBereichKopf.Zeile, 1)).EntireRow.hidden = True
  wsProt.Cells(oBereichDaten.Zeile, 1).EntireRow.hidden = True
  wsProt.Cells(oBereichFuss.Zeile, 1).EntireRow.hidden = True
  
  On Error Resume Next
  wsProt.Range(wsProt.Cells(oBereichEnde.Zeile, 1), wsProt.Cells(65536, 1)).EntireRow.hidden = True
  On Error GoTo M_SQLProt_SeiteEinrichten_Fehler
  
  Set rgDatenStart = wsProt.Cells(oBereichDaten.Zeile + 1, 1)
  Set rgDaten = rgDatenStart
  Set rgStart = rgDatenStart
  Set rgDatenEnde = wsProt.Cells(oBereichFuss.Zeile - 1, 1)
  
  iDatenZeile = rgDatenEnde.Row - rgDatenStart.Row + 1
  'iDatenAnz = oProtokoll.ZeitpunktAnz
  
  For Each oTabBereich In coTabBereich.Items
    With oTabBereich
      If .Blatt = lwsProtID And _
         .Zeile > oBereichDaten.Zeile Then
       .Zeile = .Zeile + iDatenAnz - iDatenZeile
      End If
    End With
  Next oTabBereich
  
  Do Until iDatenZeile >= iDatenAnz

    fStatus = Aufrunden(iDatenZeile / iDatenAnz * 100)
    Call StatusTextAusgeben(wsProt.Name & " einrichten " & fStatus & "%", lStatusId)

    If (iDatenZeile <= (iDatenAnz / 2)) Then
      Range(rgDatenStart, rgDatenEnde).EntireRow.Copy 'rgDatenEnde.Offset(1, 0)
      rgDatenEnde.Offset(1, 0).Insert
      iDatenZeile = iDatenZeile * 2
      Set rgDatenEnde = rgDatenStart.Offset(iDatenZeile - 1, 0)
    Else
      Set rgDatenEnde = rgDatenStart.Offset(iDatenAnz - iDatenZeile - 1, 0)
      Range(rgDatenStart, rgDatenEnde).EntireRow.Copy 'rgDatenStart.Offset(iDatenZeile, 0)
      rgDatenStart.Offset(iDatenZeile, 0).Insert
      Set rgDatenEnde = rgDatenStart.Offset(iDatenAnz - 1, 0)
      iDatenZeile = iDatenAnz
    End If
  Loop
  
  If iDatenZeile > iDatenAnz Then
    Range(rgDatenStart.Offset(iDatenZeile - 1, 0), rgDatenStart.Offset(iDatenAnz, 0)).EntireRow.Delete
  End If
  
'Call ZeitMessung(False, "M_ATVProt::SeiteEinrichten " + wsProt.Name)
  
  Call StatusTextLoeschen(lStatusId)
  
Exit Sub
M_SQLProt_SeiteEinrichten_Fehler:
  boErsterFehler = (Err.Number < ERR_BASIS)
  'Call StatusTextLoeschen(lStatusID)
  Call FehlerAusloesen(ERR_PROT_SEITE_EINRICHTEN, , boErsterFehler)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub WerteEintragen(wsProt As Worksheet, vDaten As Variant, rgDaten As Range)

Dim vTmp    As Variant
Dim nCol    As Long
Dim nCols   As Long
Dim nRow    As Long
Dim nRows   As Long
Dim aiTyp() As Integer '0 - undef
                       '1 - value
                       '2 - stime
                       '3 - status
Dim rg      As Range
Dim aiCol() As Integer
Dim iColMax As Integer

  If Not IsArray(vDaten) Then
    Exit Sub
  End If
  If Not IsArray(vDaten(0)) Then
    Exit Sub
  End If
  On Error Resume Next
  
  'Zielspalten ermitteln
  ReDim aiCol(UBound(vDaten(0)))
  For nCol = 0 To UBound(aiCol)
    aiCol(nCol) = -1 ':= nicht gefunden
  Next nCol
  For Each rg In rgDaten.Offset(-1, 0).EntireRow.Columns
    If rg.value <> "" Then
      'Sonderfall Spalte Datenpunkt
      If rg.value = "Datapoint" Then
        aiCol(0) = rg.Column - 1
      Else
        For nCol = 0 To UBound(vDaten(0))
          If rg.value = vDaten(0)(nCol) Then
            aiCol(nCol) = rg.Column - 1
            If iColMax < (rg.Column - 1) Then iColMax = (rg.Column - 1)
          End If
        Next nCol
      End If
    End If
  Next rg
  'Wenn Spaltendefinitionen vorhanden sind
  If iColMax > 0 Then
    For nCol = 0 To UBound(aiCol)
      'Fehlende Spalten am Ende einf|fffd|gen
      If aiCol(nCol) = -1 Then
        'Sonderfall Splate Datenpunkt steht am Anfang
        If nCol = 0 Then
          aiCol(0) = 0
        Else
          iColMax = iColMax + 1
          aiCol(nCol) = iColMax
        End If
      End If
    Next nCol
  End If
  
  'jede Zeile hat die gleiche Spaltenanzahl
  nRows = UBound(vDaten)
  nCols = UBound(vDaten(0))
  
  ReDim aiTyp(nCols)
  For nCol = 0 To nCols
    'Spaltenueberschrift als kommentar
    Call rgDaten.Offset(0, aiCol(nCol)).NoteText(vDaten(0)(nCol), 1, True)
    
    'Typ der dargestellten Daten wg. konvertierung ermitteln
    If InStr(1, vDaten(0)(nCol), "value") And nCol > 0 Then
      aiTyp(nCol) = 1
    ElseIf InStr(1, vDaten(0)(nCol), "stime") And nCol > 0 Then
      aiTyp(nCol) = 2
    ElseIf InStr(1, vDaten(0)(nCol), "status") And nCol > 0 Then
      aiTyp(nCol) = 3
    Else
      aiTyp(nCol) = 0
    End If
  Next nCol
  
  'Daten
  If iColMax = 0 Then
    ReDim vTmp(nRows - 1, nCols)
  Else
    ReDim vTmp(nRows - 1, 0)
  End If
  nCol = 0
  nRow = 0
  For nCol = 0 To nCols
    Select Case aiTyp(nCol)
    Case 0:
      If iColMax = 0 Then
        For nRow = 0 To nRows - 1
          vTmp(nRow, nCol) = vDaten(nRow + 1)(nCol)
        Next nRow
      Else
        For nRow = 0 To nRows - 1
          vTmp(nRow, 0) = vDaten(nRow + 1)(nCol)
        Next nRow
      End If
    Case 1:
      If iColMax = 0 Then
        For nRow = 0 To nRows - 1
          vTmp(nRow, nCol) = CPVSSValue(vDaten(nRow + 1)(nCol))
        Next nRow
      Else
        For nRow = 0 To nRows - 1
          vTmp(nRow, 0) = CPVSSValue(vDaten(nRow + 1)(nCol))
        Next nRow
      End If
    Case 2:
      If iColMax = 0 Then
        For nRow = 0 To nRows - 1
          vTmp(nRow, nCol) = CPVSSTime(vDaten(nRow + 1)(nCol))
        Next nRow
      Else
        For nRow = 0 To nRows - 1
          vTmp(nRow, 0) = CPVSSTime(vDaten(nRow + 1)(nCol))
        Next nRow
      End If
    Case 3:
      If iColMax = 0 Then
        For nRow = 0 To nRows - 1
          vTmp(nRow, nCol) = CPVSSStatus(vDaten(nRow + 1)(nCol))
        Next nRow
      Else
        For nRow = 0 To nRows - 1
          vTmp(nRow, 0) = CPVSSStatus(vDaten(nRow + 1)(nCol))
        Next nRow
      End If
    End Select
    If iColMax > 0 Then
      Set rg = Range(rgDaten.Offset(0, aiCol(nCol)), rgDaten.Offset(UBound(vTmp, 1), aiCol(nCol)))
      rg.Value2 = vTmp
    End If
    
  Next nCol
  
  'Werte in die Tabelle pumpen
  '(Value2 wg local!!)
  If iColMax = 0 Then
    Set rg = Range(rgDaten, rgDaten.Offset(UBound(vTmp, 1), UBound(vTmp, 2)))
    rg.Value2 = vTmp
  End If

End Sub


Attribute VB_Name = "M_SQLVorlage"
'==================================================================================================
'M_SQLVorlage
'Marc Haslop, 25.06.02
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module


Public Const DPE_CHAR = 19
Public Const DPE_UNSIGNED = 20
Public Const DPE_INT = 21
Public Const DPE_FLOAT = 22
Public Const DPE_BOOL = 23
Public Const DPE_BIT32 = 24
Public Const DPE_STRING = 25
Public Const DPE_TIME = 26

Public Const SQL_START = "B2"


'--------------------------------------------------------------------------------------------------
Public Sub Edit()

Dim oSQL As C_SQL
Dim vSQL As V_SQL

Dim wsSQL As Worksheet
Dim rgSQL As Range

  On Error GoTo M_SQLVorlage_Edit_Fehler

  If Not ActiveSheet.Type = xlWorksheet Then Exit Sub
  Set wsSQL = ActiveSheet 'ActiveWorkbook.Worksheets("SQL")
  If Not IsReportTab(wsSQL) Then Exit Sub
  Set rgSQL = wsSQL.Range(SQL_START)

  Set oSQL = New C_SQL

  oSQL.SelectAsString = rgSQL.Offset(0, 0).value
  oSQL.FromAsString = rgSQL.Offset(1, 0).value
  oSQL.RemoteAsString = rgSQL.Offset(2, 0).value
  oSQL.WhereAsString = rgSQL.Offset(3, 0).value
  oSQL.TimerangeAsString = rgSQL.Offset(4, 0).value
  oSQL.SortAsString = rgSQL.Offset(5, 0).value

  Set vSQL = New V_SQL
  Set vSQL.SQL = oSQL
  vSQL.Show
  
  If vSQL.Finish = True Then
    rgSQL.Offset(0, 0).value = oSQL.SelectAsString
    rgSQL.Offset(1, 0).value = oSQL.FromAsString
    rgSQL.Offset(2, 0).value = oSQL.RemoteAsString
    rgSQL.Offset(3, 0).value = oSQL.WhereAsString
    rgSQL.Offset(4, 0).value = oSQL.TimerangeAsString
    rgSQL.Offset(5, 0).value = oSQL.SortAsString
  End If

  Unload vSQL
  Set vSQL = Nothing

Exit Sub
M_SQLVorlage_Edit_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::DPAendern")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
  
End Sub

'---------------------------------------------------------------------------------------------------
' Thema: Hilfsfunktionen fuer das SQL-View "V_SQL"
' Autor: M. Haslop
' Stand: 30.05.02
'---------------------------------------------------------------------------------------------------

'---------------------------------------------------------------------------------------------------
Public Function positionAsc(sText As String, ByRef asList() As String) As Integer

Dim iListElement As Integer
Dim sList As String
Dim sTextTemp As String
Dim iTextAsci As Integer
Dim sListTemp As String
Dim iListAsci As Integer
Dim n As Integer


  'Schleife ueber alle Listenelemente
  iListElement = 0
  Do
    'Schleife ueber Buchstaben
    iListElement = iListElement + 1
    
    'Pruefen, ob die Liste lang genug ist
    If iListElement <= UBound(asList) Then
    
      sList = asList(iListElement)
      n = 1
      
      Do
        sTextTemp = Mid(sText, n)
        iTextAsci = Asc(sTextTemp)
        sListTemp = Mid(sList, n)
        iListAsci = Asc(sListTemp)
      
        If iTextAsci = iListAsci Then
          n = n + 1
        End If
      
      Loop Until iTextAsci <> iListAsci
    End If
  Loop Until iTextAsci < iListAsci Or UBound(asList) < iListElement
  
  positionAsc = iListElement
  
End Function

'---------------------------------------------------------------------------------------------------
Public Sub strSplit(ByRef sSource As String, cSep As String, ByRef asSplit() As String)

Dim iSplit As Integer
Dim iStart As Integer
Dim n As Integer


  cSep = Left(cSep, 1)
  iStart = 1
  
  For n = 1 To Len(sSource)
    If cSep = Mid(sSource, n, 1) Then
    
      'Trennzeichen gefunden
      iSplit = iSplit + 1
      ReDim Preserve asSplit(iSplit)
      asSplit(iSplit) = Mid(sSource, iStart, n - iStart)
      iStart = n + 1
      
    End If
  Next

  'Letzten Teil anhaengen
  iSplit = iSplit + 1
  ReDim Preserve asSplit(iSplit)
  asSplit(iSplit) = Mid(sSource, iStart, n - iStart)

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub getDpTypeNames(ByRef asDptNameComplete() As String, asDptName() As String)

Dim iDptName As Integer
Dim n As Integer


  For n = 1 To UBound(asDptNameComplete)
  
    'Abfangen, wenn das erste Zeiche "_" ist
    If Asc(asDptNameComplete(n)) <> 95 Then
    
      iDptName = iDptName + 1
      ReDim Preserve asDptName(iDptName)
      asDptName(iDptName) = asDptNameComplete(n)
      
    End If
    
  Next

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub getDpNames(ByRef asDpNameComplete() As String, asDpName() As String)

Dim asDpNameSplit() As String
Dim iDpName As Integer
Dim n As Integer

  For n = 1 To UBound(asDpNameComplete)
    'Abfangen, wenn das erste Zeiche "_" ist
    If Asc(asDpNameComplete(n)) <> 95 Then
    
      'Systemname filtern
      Call M_SQLVorlage.strSplit(asDpNameComplete(n), ":", asDpNameSplit)
      
      iDpName = iDpName + 1
      ReDim Preserve asDpName(iDpName)
      asDpName(iDpName) = (asDpNameSplit(2))
      
    End If
  Next

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub getDpElementName(ByRef asDpeNameComplete() As String, asDpeName() As String)

Dim asDpNameSplit() As String
Dim asDpeNameSplit() As String
Dim iSplit As Integer
Dim sDPE As String
Dim n As Integer


  For n = 1 To UBound(asDpeNameComplete)

    'Systemname filtern
    Call M_SQLVorlage.strSplit(asDpeNameComplete(n), ":", asDpNameSplit)
    If UBound(asDpNameSplit) > 1 Then
      Call M_SQLVorlage.strSplit(asDpNameSplit(2), ".", asDpeNameSplit)
    End If
    
    'Datenpunkt filtern (Elemente bleiben uebrig)
    If UBound(asDpNameSplit) > 1 Then
    
      sDPE = ""
      For iSplit = 2 To UBound(asDpeNameSplit) - 1
        sDPE = sDPE & asDpeNameSplit(iSplit) & "."
      Next iSplit
      sDPE = sDPE & asDpeNameSplit(UBound(asDpeNameSplit))
      
    End If
    
    ReDim Preserve asDpeName(n)
    asDpeName(n) = sDPE
  Next n

End Sub

Attribute VB_Name = "M_Schnellanwahl"
'===================================================================================================
'M_Schnellanwahl
'Oliver Seidel 31.07.2000
'  Zentraler Zugriff auf die Protokolle (Class und Collection).
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwProtokoll As V_Schnellanwahl
Dim coProtokoll As CO_Protokoll

  Set vwProtokoll = New V_Schnellanwahl
  Set coProtokoll = coLesen
  Set vwProtokoll.Protokoll = coProtokoll
  vwProtokoll.Show
  If vwProtokoll.ok Then
    Call coSpeichern(coProtokoll)
  End If

  Unload vwProtokoll
  Set vwProtokoll = Nothing

  Call TabMenue.SchnellanwahlAnzeigen

End Sub 'coEdit()

'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_Protokoll

Dim recProtokoll  As ADODB.Recordset
Dim oProtokoll    As C_Protokoll
Dim sSql          As String
Dim alId()          As Long
Dim asBezeichnung() As String
Dim lID             As Long
Dim lPrio           As Long
Dim n               As Long
  
  On Error GoTo Protokoll_Lesen_Fehler

  Set coLesen = New CO_Protokoll
  sSql = "SELECT * FROM tabSchnellAnwahl ORDER BY Prio, Bezeichnung"
  Set recProtokoll = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recProtokoll.EOF
    Set oProtokoll = New C_Protokoll
    oProtokoll.ID = recProtokoll.Fields("ID")
    oProtokoll.Bezeichnung = recProtokoll.Fields("Bezeichnung")
    oProtokoll.Vorlage = recProtokoll.Fields("Vorlage")
    
    lID = recProtokoll.Fields("ProtTyp")
    If lID > 0 Then
      Call getProtTypBezeichner(alId, asBezeichnung)
      For n = 1 To UBound(alId)
        If alId(n) = lID Then
          oProtokoll.ProtTyp.ID = lID
          oProtokoll.ProtTyp.Bezeichnung = asBezeichnung(n)
          Exit For
        End If
      Next n
    End If
      
    oProtokoll.Drucken = recProtokoll.Fields("Drucken")
    oProtokoll.Speichern = recProtokoll.Fields("Speichern")
    oProtokoll.Schliessen = recProtokoll.Fields("Schliessen")
    lPrio = lPrio + 1
    oProtokoll.Prio = lPrio
    oProtokoll.Zeitbereich = recProtokoll.Fields("Zeitbereich")
    oProtokoll.Bereich = recProtokoll.Fields("Bereich")
    
    recProtokoll.MoveNext
    coLesen.Add oProtokoll
  Wend
  Call M_DB.CloseRecordset(recProtokoll)

Exit Function
Protokoll_Lesen_Fehler:
  Call M_DB.CloseRecordset(recProtokoll)
  Call FehlerAusloesen(30700, Err.Description, False, "M_Schnellanwahl::coLesen")
End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Public Function Lesen(ID As Long) As C_Protokoll

Dim recProtokoll  As ADODB.Recordset
Dim oProtokoll    As C_Protokoll
Dim sSql          As String

Dim alId()          As Long
Dim asBezeichnung() As String
Dim lID             As Long
Dim n               As Long

  On Error GoTo Protokoll_Suchen_Fehler

  Set oProtokoll = New C_Protokoll

  sSql = "SELECT * FROM tabSchnellAnwahl WHERE ID = " & ID & ";"
  Set recProtokoll = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)

  If Not recProtokoll.EOF Then
    
    oProtokoll.ID = recProtokoll.Fields("ID")
    oProtokoll.Bezeichnung = recProtokoll.Fields("Bezeichnung")
    oProtokoll.Vorlage = recProtokoll.Fields("Vorlage")
    lID = recProtokoll.Fields("ProtTyp")
    If lID > 0 Then
      Call getProtTypBezeichner(alId, asBezeichnung)
      For n = 1 To UBound(alId)
        If alId(n) = lID Then
          oProtokoll.ProtTyp.ID = lID
          oProtokoll.ProtTyp.Bezeichnung = asBezeichnung(n)
          Exit For
        End If
      Next n
    End If
    oProtokoll.Drucken = recProtokoll.Fields("Drucken")
    oProtokoll.Speichern = recProtokoll.Fields("Speichern")
    oProtokoll.Schliessen = recProtokoll.Fields("Schliessen")
    oProtokoll.Zeitbereich = recProtokoll.Fields("Zeitbereich")
    oProtokoll.Bereich = recProtokoll.Fields("Bereich")
    
  End If
  Call M_DB.CloseRecordset(recProtokoll)
  Set Lesen = oProtokoll

Exit Function
Protokoll_Suchen_Fehler:
  Call M_DB.CloseRecordset(recProtokoll)
  Call FehlerAusloesen(30705, Err.Description, False, "M_Schnellanwahl::Lesen")
End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coProtokoll As CO_Protokoll)

Dim recProtokoll  As ADODB.Recordset
Dim oProtokoll    As C_Protokoll
Dim recArchiv     As ADODB.Recordset
Dim sSql          As String
Dim lLoeschen     As Long

  On Error GoTo Protokoll_Speichern_Fehler

  'DB oeffnen und alle Datensaetz zum Loeschen makieren
  sSql = "UPDATE tabSchnellAnwahl SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen
  
  sSql = "SELECT * FROM tabSchnellAnwahl"
  Set recProtokoll = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)

  For Each oProtokoll In coProtokoll.Items

    If recProtokoll.BOF And recProtokoll.EOF Then
      recProtokoll.AddNew
    Else
      recProtokoll.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recProtokoll.Find "ID = " & oProtokoll.ID, , adSearchForward
      If recProtokoll.EOF Then
        recProtokoll.AddNew
      Else
        'recProtokoll.Edit
        recProtokoll.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recProtokoll.Fields("Bezeichnung") = oProtokoll.Bezeichnung
    recProtokoll.Fields("Vorlage") = oProtokoll.Vorlage
    recProtokoll.Fields("ProtTyp") = oProtokoll.ProtTyp.ID
    recProtokoll.Fields("Drucken") = oProtokoll.Drucken
    recProtokoll.Fields("Speichern") = oProtokoll.Speichern
    recProtokoll.Fields("Schliessen") = oProtokoll.Schliessen
    recProtokoll.Fields("Prio") = oProtokoll.Prio
    recProtokoll.Fields("Zeitbereich") = oProtokoll.Zeitbereich
    recProtokoll.Fields("Bereich") = oProtokoll.Bereich
    
    recProtokoll.Update
    'recProtokoll.Bookmark = recProtokoll.LastModified
    oProtokoll.ID = recProtokoll.Fields("ID")

  Next oProtokoll

  Call M_DB.CloseRecordset(recProtokoll)

  sSql = "DELETE FROM tabSchnellAnwahl WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql

Exit Sub
Protokoll_Speichern_Fehler:
  Call M_DB.CloseRecordset(recProtokoll)
  Call FehlerAusloesen(30703, Err.Description, False, "M_Schnellanwahl::coSpeichern")
End Sub 'coSpeichern()
Attribute VB_Name = "M_StatusBit"
'===================================================================================================
'M_StatusBit
'Oliver Seidel 31.07.2000
'
'Zentraler Zugriff auf die StatusBite (Class und Collection).
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwStatusBit As V_StatusBit
Dim coStatusBit As CO_StatusBit

  Set vwStatusBit = New V_StatusBit
  Set coStatusBit = coLesen
  Set vwStatusBit.StatusBit = coStatusBit
  vwStatusBit.Show
  If vwStatusBit.ok Then
    Call coSpeichern(coStatusBit)
  End If

  Unload vwStatusBit
  Set vwStatusBit = Nothing

End Sub

'---------------------------------------------------------------------------------------------------
'coLesen()
'Oliver Seidel 01.08.2000
'
'Liest alle StatusBite aus der DB inkl aller referenzierten Archive
'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_StatusBit

Dim recStatusBit  As ADODB.Recordset
'Dim recStyle      As ADODB.Recordset
Dim oStatusBit    As C_StatusBit
Dim sSql          As String

  On Error GoTo StatusBit_Lesen_Fehler

  Set coLesen = New CO_StatusBit
  sSql = "SELECT * FROM tabStatusBit ORDER BY Prio;"
  Set recStatusBit = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recStatusBit.EOF
    Set oStatusBit = New C_StatusBit
    oStatusBit.ID = recStatusBit.Fields("ID")
    oStatusBit.Bezeichnung = recStatusBit.Fields("Bezeichnung")
    oStatusBit.Prio = recStatusBit.Fields("Prio")
    oStatusBit.BitMuster = recStatusBit.Fields("BitMuster")
    oStatusBit.WerteIgnorieren = recStatusBit.Fields("WerteIgnorieren")
    
'    sSQL = "SELECT * FROM tabStyle WHERE ID = " & oStatusBit.ID & ";"
'    Set recStyle = M_DB.ReportDB.OpenRecordset(sSQL, dbOpenForwardOnly)
'    If Not recStyle.EOF Then
'      Call getStyleFromDB(recStyle, oStatusBit.Format)
'      oStatusBit.Format.Name = oStatusBit.Bezeichnung
'    End If
'    recStyle.Close
    
    recStatusBit.MoveNext
    coLesen.Add oStatusBit
  
  Wend
  
  Call M_DB.CloseRecordset(recStatusBit)

Exit Function
StatusBit_Lesen_Fehler:
  
  Call M_DB.CloseRecordset(recStatusBit)
  If Not oStatusBit Is Nothing Then
    Call FehlerAusloesen(30700, "Basiswert #" & oStatusBit.ID, False, "M_StatusBit::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_StatusBit::coLesen")
  End If

End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coStatusBit As CO_StatusBit)

Dim recStatusBit  As ADODB.Recordset
'Dim recStyle      As ADODB.Recordset
Dim oStatusBit    As C_StatusBit
Dim recArchiv     As ADODB.Recordset
Dim sSql          As String
Dim lLoeschen     As Long

  On Error GoTo StatusBit_Speichern_Fehler

  'DB oeffnen und alle Datensaetz zum Loeschen makieren
  sSql = "UPDATE tabStatusBit SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen

  sSql = "SELECT * FROM tabStatusBit"
  Set recStatusBit = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
'  Set recStyle = M_DB.ReportDB.OpenRecordset("tabStyle", dbOpenDynaset)
  
  For Each oStatusBit In coStatusBit.Items
    
    If recStatusBit.BOF And recStatusBit.EOF Then
      recStatusBit.AddNew
    Else
      recStatusBit.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recStatusBit.Find "ID = " & oStatusBit.ID, , adSearchForward
      If recStatusBit.EOF Then
        recStatusBit.AddNew
      Else
        'recStatusBit.Edit
        recStatusBit.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recStatusBit.Fields("Prio") = oStatusBit.Prio
    recStatusBit.Fields("Bezeichnung") = oStatusBit.Bezeichnung
    recStatusBit.Fields("BitMuster") = oStatusBit.BitMuster
    recStatusBit.Fields("WerteIgnorieren") = oStatusBit.WerteIgnorieren
    
    recStatusBit.Update
    'recStatusBit.Bookmark = recStatusBit.LastModified
    oStatusBit.ID = recStatusBit.Fields("ID")

'    recStyle.FindFirst "ID = " & oStatusBit.ID
'    If recStyle.NoMatch Then
'      recStyle.AddNew
'      recStyle.Fields("ID") = oStatusBit.ID
'    Else
'      recStyle.Edit
'    End If
'    oStatusBit.Format.Name = oStatusBit.Bezeichnung
'    Call setStyleInDB(recStyle, oStatusBit.Format)
'    recStyle.Update
    
  Next oStatusBit

'  recStatusBit.FindFirst ("Loeschen <> 0")
'  While Not recStatusBit.NoMatch
'    recStyle.FindFirst "ID = " & recStatusBit.Fields("ID")
'    If Not recStyle.NoMatch Then
'      recStyle.Delete
'    End If
'    recStatusBit.FindNext ("Loeschen <> 0")
'  Wend
  
  Call M_DB.CloseRecordset(recStatusBit)

  sSql = "DELETE FROM tabStatusBit WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql

Exit Sub
StatusBit_Speichern_Fehler:
  
  Call M_DB.CloseRecordset(recStatusBit)
  Call ErrMessage("sSQL: " & sSql, "M_StatusBit::coSpeichern")
  Call FehlerAusloesen(30703, Err.Description, False, "M_StatusBit::coSpeichern")
  
End Sub 'coSpeichern

'---------------------------------------------------------------------------------------------------
Public Sub StyleEdit(oStyle As C_Style)

Dim wb    As Worksheet
'Dim Style As Style
Dim i As Integer
Dim boEdit  As Boolean
Dim boValid As Boolean
Dim boAnswer As Boolean

  Set wb = ThisWorkbook.Worksheets("Menue")
  wb.Activate
  ActiveSheet.Range("a1").Select
  ActiveSheet.Unprotect
  
  wb.Range("N3").Select
  wb.Range("N3").value = 42.123
  'IM 57014
  boEdit = False
  boValid = False
  For i = 1 To ThisWorkbook.Styles.Count
    If ThisWorkbook.Styles(i).Name = oStyle.Name Then
      boEdit = True
    End If
    If ThisWorkbook.Styles(i).Name = "G|fffd|ltig" Then
      boValid = True
    End If
  Next i
  If Not boEdit Then
    If boValid Then
      wb.Range("N3").Style = "G|fffd|ltig"
      Call ThisWorkbook.Styles.Add(oStyle.Name, wb.Range("N3"))
    Else
      Call ThisWorkbook.Styles.Add(oStyle.Name)
    End If
  Else
    wb.Range("N3").Style = oStyle.Name
  End If
  
  'Call setStyleInWb(ThisWorkbook, oStyle)
  boAnswer = Application.Dialogs(xlDialogDefineStyle).Show(oStyle.Name)
  'Call getStyleFromWb(ThisWorkbook, oStyle.Name, oStyle)
  
  ' IM 105140 WOKL 19.7.11: styles are not yet saved, no warning, therefore save report
  If (boAnswer = True) Then
    Call Application.ThisWorkbook.Save
  End If
  
  wb.Range("N3").value = ""
  If (val(Application.Version) >= 14) Then    ' IM 99187 for excel 2010 ff.
    wb.Range("N3").Style = "Normal"
  Else
    wb.Range("N3").Style = "Standard"
  End If
  wb.Range("N3").Interior.ColorIndex = wb.Range("N2").Interior.ColorIndex
  wb.Range("A1").Select
  Call ActiveSheet.Protect(DrawingObjects:=True, Contents:=True, Scenarios:=True)
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub getStyleFromWb(wb As Workbook, sName As String, oStyle As C_Style)

Dim Style As Style
Dim n     As Long
  
  'Style Objekte mach noch aerger, daher werden sie
  'nicht in der Datenbank sondern direkt in der Report.xls
  'Datei gespeichert! Uebernahme in die Vorlagen beim
  'Analysieren mit Call wbVorlage.Styles.Merge(ThisWorkbook)
  Stop
  
  On Error Resume Next
  Set Style = wb.Styles(sName)
  If Style Is Nothing Then
    'ToDo: Fehlerbehandlung
    Exit Sub
  End If
  'ToDo: Fehlerbehandlung
  On Error GoTo 0

  With Style
    oStyle.Name = .Name
    oStyle.IncludeNumber = .IncludeNumber
    If .IncludeNumber Then
      oStyle.Number_Format = .NumberFormat
    End If
    
    oStyle.IncludeFont = .IncludeFont
    If .IncludeFont Then
      oStyle.Font_Name = .Font.Name
      oStyle.Font_Size = .Font.Size
      oStyle.Font_Bold = .Font.Bold
      oStyle.Font_Italic = .Font.Italic
      oStyle.Font_Underline = .Font.Underline
      
      oStyle.Font_OutlineFont = .Font.OutlineFont
      oStyle.Font_Shadow = .Font.Shadow
      oStyle.Font_Strikethrough = .Font.Strikethrough
      'Warum auch immer die Goetter hierfuer variants nehmen....
      If Not IsNull(Style.Font.Subscript) Then oStyle.Font_Subscript = .Font.Subscript
      If Not IsNull(Style.Font.Superscript) Then oStyle.Font_Superscript = .Font.Superscript
      If Not IsNull(.Font.Background) Then oStyle.Font_Background = .Font.Background
      oStyle.Font_Color = .Font.Color
      oStyle.Font_ColorIndex = .Font.ColorIndex
    End If
    
    oStyle.IncludeAlignment = .IncludeAlignment
    If .IncludeAlignment Then
      oStyle.HorizontalAlignment = .HorizontalAlignment
      oStyle.Orientation = .Orientation
      'Was auch immer das ist, es wird in einer deutschen Excel Version nicht verwendet
      '(siehe Online-Hilfe) ...schade
      'oStyle.ReadingOrder = .ReadingOrder
      oStyle.VerticalAlignment = .VerticalAlignment
      oStyle.WrapText = .WrapText
    End If
    
    oStyle.IncludeBorder = .IncludeBorder
    If .IncludeBorder Then
    
      For n = 1 To .Borders.Count
        'ToDo: Fehlermeldung wenn es tatsaechlich vorkommen kann
        'Da aber die hoechstgrenze fix bei 6 liegt...
        'If n > 6 Then Exit For
        
        With .Borders(n)
          If (.ColorIndex = xlColorIndexNone) Or (.ColorIndex = xlColorIndexAutomatic) Then
            oStyle.BorderColor(n) = .Color
            oStyle.BorderColorIndex(n) = .ColorIndex
          Else
            oStyle.BorderColor(n) = .Color
            oStyle.BorderColorIndex(n) = .ColorIndex  'xlColorIndexNone
          End If
          If IsNull(.Weight) Then
            oStyle.BorderWeight(n) = -1 'XlBorderWeight.xlHairline
          Else
            oStyle.BorderWeight(n) = .Weight
          End If
          If IsNull(.LineStyle) Then
            oStyle.BorderLineStyle(n) = -1 'XlLineStyle.xlContinuous  'xlLineStyleNone
          Else
            oStyle.BorderLineStyle(n) = .LineStyle
          End If
        End With
      Next n
    End If
    
    oStyle.IncludePatterns = .IncludePatterns
    If .IncludePatterns Then
      oStyle.Interior_Pattern = .Interior.Pattern
      oStyle.Interior_PatternColor = .Interior.PatternColor
      oStyle.Interior_PatternColorIndex = .Interior.PatternColorIndex
      oStyle.Interior_Color = .Interior.Color
      oStyle.Interior_ColorIndex = .Interior.ColorIndex
    End If
    
    oStyle.IncludeProtection = .IncludeProtection
    If .IncludeProtection Then
      oStyle.Locked = .Locked
    End If

  End With

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub setStyleInWb(wb As Workbook, oStyle As C_Style)

Dim Style As Style
Dim n     As Long

  'Style Objekte mach noch aerger, daher werden sie
  'nicht in der Datenbank sondern direkt in der Report.xls
  'Datei gespeichert! Uebernahme in die Vorlagen beim
  'Analysieren mit Call wbVorlage.Styles.Merge(ThisWorkbook)
  Stop
  
  For n = 1 To wb.Styles.Count
    If wb.Styles(n).Name = oStyle.Name Then
      Set Style = wb.Styles(n)
      Exit For
    End If
  Next n
  If Style Is Nothing Then
    Set Style = wb.Styles.Add(oStyle.Name)
  End If
  On Error Resume Next
  
  If Style Is Nothing Then
    'ToDo: Fehlerbehandlung
    Exit Sub
  End If
  'ToDo: Fehlerbehandlung
  On Error GoTo 0

  With Style
    .IncludeNumber = oStyle.IncludeNumber
    If .IncludeNumber Then
      .NumberFormat = oStyle.Number_Format
    End If
    
    .IncludeFont = oStyle.IncludeFont
    If .IncludeFont Then
      .Font.Name = oStyle.Font_Name
      .Font.Size = oStyle.Font_Size
      .Font.Bold = oStyle.Font_Bold
      .Font.Italic = oStyle.Font_Italic
      .Font.Underline = oStyle.Font_Underline
      
      .Font.OutlineFont = oStyle.Font_OutlineFont
      .Font.Shadow = oStyle.Font_Shadow
      .Font.Strikethrough = oStyle.Font_Strikethrough
      .Font.Subscript = oStyle.Font_Subscript
      .Font.Superscript = oStyle.Font_Superscript
      
      .Font.Background = oStyle.Font_Background
      .Font.Color = oStyle.Font_Color
      .Font.ColorIndex = oStyle.Font_ColorIndex
    End If
    
    .IncludeAlignment = oStyle.IncludeAlignment
    If .IncludeAlignment Then
      .HorizontalAlignment = oStyle.HorizontalAlignment
      .Orientation = oStyle.Orientation
      'Was auch immer das ist, es wird in einer deutschen Excel Version nicht verwendet
      '(siehe Online-Hilfe) ...schade
      '.ReadingOrder = oStyle.ReadingOrder
      .VerticalAlignment = oStyle.VerticalAlignment
      .WrapText = oStyle.WrapText
    End If
    
    .IncludeBorder = oStyle.IncludeBorder
    If oStyle.IncludeBorder Then
      For n = 1 To 6
        With .Borders(n)
          If oStyle.BorderColorIndex(n) = xlColorIndexNone Or oStyle.BorderColorIndex(n) = xlColorIndexAutomatic Then
            .ColorIndex = oStyle.BorderColorIndex(n)
            .Color = oStyle.BorderColor(n)
          Else
            .ColorIndex = oStyle.BorderColorIndex(n) 'xlColorIndexNone
            .Color = oStyle.BorderColor(n)
          End If
          If oStyle.BorderWeight(n) = -1 Then
            .Weight = vbNull
          Else
            .Weight = oStyle.BorderWeight(n)
          End If
          If oStyle.BorderLineStyle(n) = -1 Then
            .LineStyle = vbNull
          Else
            .LineStyle = oStyle.BorderLineStyle(n)
          End If
        End With
      Next n
      
    End If
    
    .IncludePatterns = oStyle.IncludePatterns
    If .IncludePatterns Then
      .Interior.Pattern = oStyle.Interior_Pattern
      .Interior.PatternColor = oStyle.Interior_PatternColor
      .Interior.PatternColorIndex = oStyle.Interior_PatternColorIndex
      .Interior.Color = oStyle.Interior_Color
      .Interior.ColorIndex = oStyle.Interior_ColorIndex
    End If
    
    .IncludeProtection = oStyle.IncludeProtection
    If .IncludeProtection Then
      .Locked = oStyle.Locked
    End If
  
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub getStyleFromDB(recSytle As ADODB.Recordset, oStyle As C_Style)

Dim n As Long
  
  
  'Style Objekte mach noch aerger, daher werden sie
  'nicht in der Datenbank sondern direkt in der Report.xls
  'Datei gespeichert! Uebernahme in die Vorlagen beim
  'Analysieren mit Call wbVorlage.Styles.Merge(ThisWorkbook)
  Stop
  
  'ToDo: Fehlerbehandlung
  
  With recSytle
    
    oStyle.Name = .Fields("Name").value
    
    oStyle.IncludeNumber = .Fields("IncludeNumber")
    If oStyle.IncludeNumber Then
      oStyle.Number_Format = .Fields("Number_Format")
    End If
    
    oStyle.IncludeFont = .Fields("IncludeFont")
    If oStyle.IncludeFont Then
      oStyle.Font_Name = .Fields("Font_Name")
      oStyle.Font_Size = .Fields("Font_Size")
      oStyle.Font_Bold = .Fields("Font_Bold")
      oStyle.Font_Italic = .Fields("Font_Italic")
      oStyle.Font_Underline = .Fields("Font_Underline")
      
      oStyle.Font_OutlineFont = .Fields("Font_OutlineFont")
      oStyle.Font_Shadow = .Fields("Font_Shadow")
      oStyle.Font_Strikethrough = .Fields("Font_Strikethrough")
      oStyle.Font_Subscript = .Fields("Font_Subscript")
      oStyle.Font_Superscript = .Fields("Font_Superscript")
      
      oStyle.Font_Background = .Fields("Font_Background")
      oStyle.Font_Color = .Fields("Font_Color")
      oStyle.Font_ColorIndex = .Fields("Font_ColorIndex")
    End If
    
    oStyle.IncludeAlignment = .Fields("IncludeAlignment")
    If oStyle.IncludeAlignment Then
      oStyle.HorizontalAlignment = .Fields("HorizontalAlignment")
      oStyle.Orientation = .Fields("Orientation")
      oStyle.ReadingOrder = .Fields("ReadingOrder")
      oStyle.VerticalAlignment = .Fields("VerticalAlignment")
      oStyle.WrapText = .Fields("WrapText")
    End If
    
    oStyle.IncludeBorder = .Fields("IncludeBorder")
    If oStyle.IncludeBorder Then
      For n = 1 To 6
        oStyle.BorderColor(n) = .Fields("Border_" & n & "_Color")
        oStyle.BorderColorIndex(n) = .Fields("Border_" & n & "_ColorIndex")
        oStyle.BorderLineStyle(n) = .Fields("Border_" & n & "_LineStyle")
        oStyle.BorderWeight(n) = .Fields("Border_" & n & "_Weight")
        
      Next n
    End If
    
    oStyle.IncludePatterns = .Fields("IncludePatterns")
    If oStyle.IncludePatterns Then
      oStyle.Interior_Pattern = .Fields("Interior_Pattern")
      oStyle.Interior_PatternColor = .Fields("Interior_PatternColor")
      oStyle.Interior_PatternColorIndex = .Fields("Interior_PatternColorIndex")
      oStyle.Interior_Color = .Fields("Interior_Color")
      oStyle.Interior_ColorIndex = .Fields("Interior_ColorIndex")
    End If
    
    oStyle.IncludeProtection = .Fields("IncludeProtection")
    If oStyle.IncludeProtection Then
      oStyle.Locked = .Fields("Locked")
    End If

  End With

End Sub


'---------------------------------------------------------------------------------------------------
Public Sub setStyleInDB(recSytle As ADODB.Recordset, oStyle As C_Style)

Dim n As Long

  'Style Objekte mach noch aerger, daher werden sie
  'nicht in der Datenbank sondern direkt in der Report.xls
  'Datei gespeichert! Uebernahme in die Vorlagen beim
  'Analysieren mit Call wbVorlage.Styles.Merge(ThisWorkbook)
  Stop
  
  'ToDo: Fehlerbehandlung
  
  With recSytle
    
    .Fields("Name").value = oStyle.Name
    
    .Fields("IncludeNumber") = oStyle.IncludeNumber
    If oStyle.IncludeNumber Then
      .Fields("Number_Format") = oStyle.Number_Format
    End If
    
    .Fields("IncludeFont") = oStyle.IncludeFont
    If oStyle.IncludeFont Then
      .Fields("Font_Name") = oStyle.Font_Name
      .Fields("Font_Size") = oStyle.Font_Size
      .Fields("Font_Bold") = oStyle.Font_Bold
      .Fields("Font_Italic") = oStyle.Font_Italic
      .Fields("Font_Underline") = oStyle.Font_Underline
      
      .Fields("Font_OutlineFont") = oStyle.Font_OutlineFont
      .Fields("Font_Shadow") = oStyle.Font_Shadow
      .Fields("Font_Strikethrough") = oStyle.Font_Strikethrough
      .Fields("Font_Subscript") = oStyle.Font_Subscript
      .Fields("Font_Superscript") = oStyle.Font_Superscript
      
      .Fields("Font_Background") = oStyle.Font_Background
      .Fields("Font_Color") = oStyle.Font_Color
      .Fields("Font_ColorIndex") = oStyle.Font_ColorIndex
    End If
    
    .Fields("IncludeAlignment") = oStyle.IncludeAlignment
    If oStyle.IncludeAlignment Then
      .Fields("HorizontalAlignment") = oStyle.HorizontalAlignment
      .Fields("Orientation") = oStyle.Orientation
      .Fields("ReadingOrder") = oStyle.ReadingOrder
      .Fields("VerticalAlignment") = oStyle.VerticalAlignment
      .Fields("WrapText") = oStyle.WrapText
    End If
    
    .Fields("IncludeBorder") = oStyle.IncludeBorder
    If oStyle.IncludeBorder Then
    
      For n = 1 To 6
        .Fields("Border_" & n & "_ColorIndex") = oStyle.BorderColorIndex(n)
        .Fields("Border_" & n & "_Color") = oStyle.BorderColor(n)
        .Fields("Border_" & n & "_LineStyle") = oStyle.BorderLineStyle(n)
        .Fields("Border_" & n & "_Weight") = oStyle.BorderWeight(n)
      Next n
    End If
    
    .Fields("IncludePatterns") = oStyle.IncludePatterns
    If oStyle.IncludePatterns Then
      .Fields("Interior_Pattern") = oStyle.Interior_Pattern
      .Fields("Interior_PatternColor") = oStyle.Interior_PatternColor
      .Fields("Interior_PatternColorIndex") = oStyle.Interior_PatternColorIndex
      .Fields("Interior_Color") = oStyle.Interior_Color
      .Fields("Interior_ColorIndex") = oStyle.Interior_ColorIndex
    End If
    
    .Fields("IncludeProtection") = oStyle.IncludeProtection
    If oStyle.IncludeProtection Then
      .Fields("Locked") = oStyle.Locked
    End If

  End With

End Sub

Private Sub TstStyle()

Dim Style As Style
Dim StyleCopy As Style
Dim oStyle As C_Style
Dim oStyleCopy As C_Style

Dim n As Long

  Set Style = ThisWorkbook.Styles("Ersatzwert")
  Set oStyle = New C_Style
  oStyle.Name = "Ersatzwert"
  Call getStyleFromWb(ThisWorkbook, "Ersatzwert", oStyle)
  oStyle.Name = oStyle.Name & "_copyWB"
  Call setStyleInWb(ThisWorkbook, oStyle)
  Set StyleCopy = ThisWorkbook.Styles(oStyle.Name)
  Set oStyleCopy = New C_Style
  Call getStyleFromWb(ThisWorkbook, oStyle.Name, oStyleCopy)
  
  For n = 1 To 6
    
    Debug.Print "Style;n;" & n & ";" & _
                "ColorIndex;" & Style.Borders(n).ColorIndex & ";" & _
                "Color;" & Style.Borders(n).Color & ";" & _
                "LineStyle;" & Style.Borders(n).LineStyle & ";" & _
                "Weight;" & Style.Borders(n).Weight
    
    Debug.Print "oStyle;n;" & n & ";" & _
                "ColorIndex;" & oStyle.BorderColorIndex(n) & ";" & _
                "Color;" & oStyle.BorderColor(n) & ";" & _
                "LineStyle;" & oStyle.BorderLineStyle(n) & ";" & _
                "Weight;" & oStyle.BorderWeight(n)
    
    Debug.Print "StyleCopy;n;" & n & ";" & _
                "ColorIndex;" & StyleCopy.Borders(n).ColorIndex & ";" & _
                "Color;" & StyleCopy.Borders(n).Color & ";" & _
                "LineStyle;" & StyleCopy.Borders(n).LineStyle & ";" & _
                "Weight;" & StyleCopy.Borders(n).Weight
    
    Debug.Print "oStyleCopy;n;" & n & ";" & _
                "ColorIndex;" & oStyleCopy.BorderColorIndex(n) & ";" & _
                "Color;" & oStyleCopy.BorderColor(n) & ";" & _
                "LineStyle;" & oStyleCopy.BorderLineStyle(n) & ";" & _
                "Weight;" & oStyleCopy.BorderWeight(n)
                
    Debug.Print
  Next n

End Sub

Attribute VB_Name = "M_StdProt"
'==================================================================================================
'M_StdProt
'
'Oliver Seidel
'10.11.98
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

Private Const REF_KOPF_FUSS_ZEILEN = "A11"
Private Const REF_STD_PROT_TYPEN = "E1"
Private Const REF_STD_DPT = "F1"
Private Const REF_STD_DPL = "M1"

'--------------------------------------------------------------------------------------------------
Public Sub WerteEintragen(wsProt As Worksheet, oDP As C_DP, oDPRef As C_DPReferenz, lDatenAnz As Long)

Dim iWertId As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long
Dim lMinColor As Long
Dim lMaxColor As Long

  On Error Resume Next
  lMinColor = getMinColor(wsProt.Parent)
  lMaxColor = getMaxColor(wsProt.Parent)
  If oDPRef.TabBereich.Bereich = VAR_DATENBEREICH Then
  
    'Zeitpunkt Offset eintragen
    wsProt.Cells(16, oDPRef.Spalte) = oDP.Von
    
    For iWertId = 1 To oDP.coDPWert.Count
      'Bei Vergleichen (Offset) koennen zu viele Daten vorhanden sein
      If iWertId > lDatenAnz Then Exit For
      Call oDP.setRange( _
                   wsProt.Cells(oDPRef.TabBereich.Zeile + iWertId, oDPRef.Spalte), _
                   iWertId, lMinColor, lMaxColor)
    Next iWertId
    
    wsProt.Cells(6, oDPRef.Spalte) = oDP.Kommentar
    wsProt.Cells(7, oDPRef.Spalte) = oDP.Alias
    wsProt.Cells(8, oDPRef.Spalte) = oDP.Format
    wsProt.Cells(9, oDPRef.Spalte) = oDP.Einheit
  
  Else
    Call oDP.setRange( _
                 wsProt.Cells(oDPRef.TabBereich.Zeile, oDPRef.Spalte), _
                 0, lMinColor, lMaxColor, _
                 oDPRef.TabBereich.Bereich)
  End If

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub SeiteEinrichten(oProtokoll As C_Protokoll, wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim oTabBereich   As C_TabBereich
Dim oBereichKopf  As C_TabBereich
Dim oBereichDaten As C_TabBereich
Dim oBereichFuss   As C_TabBereich
Dim oBereichEnde  As C_TabBereich

Dim rgStart As Range
Dim rgEnde  As Range
Dim rgSuche As Range

Dim boSpalteAEingeblendet As Boolean

Dim rgDatenStart  As Range
Dim rgDatenEnde   As Range
Dim iDatenAnz     As Long   ' IM 101828 overflow if more than 32000 results come
Dim iDatenZeile   As Long   ' IM 101828 'long' instead of 'integer'
Dim dtZeit        As Date
Dim lwsProtID     As Long

Dim fStatus   As Single
Dim lStatusId As Long
Dim boErsterFehler As Boolean
Dim iBlattOffset  As Integer

  On Error GoTo M_STDProt_SeiteEinrichten_Fehler

  ReDim audZeile(0)
  lStatusId = StatusTextAusgeben("")
     
  Call StatusTextAusgeben(wsProt.Name & " einrichten ", lStatusId)
  
'Call ZeitMessung(True)
    
  lwsProtID = wsProt.index
  iBlattOffset = M_Vorlage.BlattOffsetLesen(oProtokoll.wbProtokoll, lwsProtID)
  wsProt.EnableCalculation = False
  
  Set oBereichKopf = coTabBereich.FindItem(lwsProtID, VAR_KOPFZEILE)
  Set oBereichDaten = coTabBereich.FindItem(lwsProtID, VAR_DATENBEREICH)
  Set oBereichFuss = coTabBereich.FindItem(lwsProtID, VAR_FUSSZEILE)
  Set oBereichEnde = coTabBereich.FindItem(lwsProtID, VAR_SEITENENDE)
  If (oBereichFuss Is Nothing) Then     ' IM 72165 bei alten Templates? WOKL 2.11.06
    Set oBereichFuss = oBereichEnde
  End If

  ' IM 115373 corrected
  If Not oBereichKopf Is Nothing Then wsProt.Range(wsProt.Cells(1, 1), wsProt.Cells(oBereichKopf.Zeile, 1)).EntireRow.hidden = True
  If Not oBereichDaten Is Nothing Then wsProt.Cells(oBereichDaten.Zeile, 1).EntireRow.hidden = True
  If Not oBereichFuss Is Nothing Then wsProt.Cells(oBereichFuss.Zeile, 1).EntireRow.hidden = True
  
  On Error Resume Next
  If Not oBereichEnde Is Nothing Then wsProt.Range(wsProt.Cells(oBereichEnde.Zeile, 1), wsProt.Cells(65536, 1)).EntireRow.hidden = True
  On Error GoTo M_STDProt_SeiteEinrichten_Fehler
  
  Set rgDatenStart = wsProt.Cells(oBereichDaten.Zeile + 1, 1)
  Set rgStart = rgDatenStart
  Set rgDatenEnde = wsProt.Cells(oBereichFuss.Zeile - 1, 1)
  
  iDatenZeile = rgDatenEnde.Row - rgDatenStart.Row + 1
  iDatenAnz = oProtokoll.ZeitpunktAnz
  
  For Each oTabBereich In coTabBereich.Items
    With oTabBereich
      If .Blatt = lwsProtID And _
         .Zeile > oBereichDaten.Zeile Then
       .Zeile = .Zeile + iDatenAnz - iDatenZeile
      End If
    End With
  Next oTabBereich
  
  Do Until iDatenZeile >= iDatenAnz

    fStatus = Aufrunden(iDatenZeile / iDatenAnz * 100)
    Call StatusTextAusgeben(wsProt.Name & " einrichten " & fStatus & "%", lStatusId)

    If (iDatenZeile <= (iDatenAnz / 2)) Then
      Range(rgDatenStart, rgDatenEnde).EntireRow.Copy 'rgDatenEnde.Offset(1, 0)
      rgDatenEnde.Offset(1, 0).Insert
      iDatenZeile = iDatenZeile * 2
      Set rgDatenEnde = rgDatenStart.Offset(iDatenZeile - 1, 0)
    Else
      Set rgDatenEnde = rgDatenStart.Offset(iDatenAnz - iDatenZeile - 1, 0)
      Range(rgDatenStart, rgDatenEnde).EntireRow.Copy 'rgDatenStart.Offset(iDatenZeile, 0)
      rgDatenStart.Offset(iDatenZeile, 0).Insert
      Set rgDatenEnde = rgDatenStart.Offset(iDatenAnz - 1, 0)
      iDatenZeile = iDatenAnz
    End If
  Loop
  
  If iDatenZeile > iDatenAnz Then
    Range(rgDatenStart.Offset(iDatenZeile - 1, 0), rgDatenStart.Offset(iDatenAnz, 0)).EntireRow.Delete
  End If
  
  For iDatenZeile = 1 To iDatenAnz

    fStatus = Aufrunden(iDatenZeile / iDatenAnz * 100)
    Call StatusTextAusgeben(wsProt.Name & " " & GetResText(21304) & "" & fStatus & "%", lStatusId)

    dtZeit = oProtokoll.Zeitpunkt(iDatenZeile - 1, iBlattOffset)
    rgDatenStart.Offset(iDatenZeile - 1, 0) = dtZeit
  Next iDatenZeile
  If oProtokoll.IntercalaryExcp > 0 Then
    rgDatenStart.Offset(oProtokoll.IntercalaryExcp - 1, 0) = ""
  End If
  
  'wsProt.Range("A1").Select
  
'Call ZeitMessung(False, "M_ATVProt::SeiteEinrichten " + wsProt.Name)
  
  Call StatusTextLoeschen(lStatusId)
  
Exit Sub
M_STDProt_SeiteEinrichten_Fehler:
  boErsterFehler = (Err.Number < ERR_BASIS)
  'Call StatusTextLoeschen(lStatusID)
  Call FehlerAusloesen(ERR_PROT_SEITE_EINRICHTEN, , boErsterFehler)
End Sub

Attribute VB_Name = "M_StdVorlage"
'==================================================================================================
'M_StdVorlage
'
'Oliver Seidel
'10.11.98
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

'--------------------------------------------------------------------------------------------------
Public Sub DPEinfuegen()

Dim rgDp        As Range
Dim tabVorlage  As Worksheet

Dim coDP    As CO_DP
Dim oDP     As C_DP
Dim iDPL    As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long

Dim vwDPEinfuegen As V_DPEinfuegen

  On Error GoTo M_StdVorlage_DPEinfuegen_Fehler
  
  Set vwDPEinfuegen = New V_DPEinfuegen
  vwDPEinfuegen.Modus = 1
  vwDPEinfuegen.Show

  If vwDPEinfuegen.ok Then
'    vwDPEinfuegen.DPL asDPL, asKommentar, asAlias
    'ToDo: Das hier scheitert bei verbundenen Zellen,
    'gibt es was besseres?
    Set rgDp = ActiveCell
    rgDp.EntireColumn.Select
    'ActiveWindow.ActiveCell.EntireColumn.Select
    
    Set coDP = vwDPEinfuegen.getDPL
    For iDPL = coDP.Count To 1 Step -1
      Selection.Insert Shift:=xlToRight
      Call setDp(Selection.Cells(2, 1), coDP.Item(iDPL))
    Next iDPL
    
    rgDp.Select
  End If

  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing

Exit Sub
M_StdVorlage_DPEinfuegen_Fehler:
  
  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_EINFUEGEN)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DPAendern()

Dim rgDp  As Range
Dim tabVorlage As Worksheet

Dim coDP  As CO_DP
Dim oDP   As C_DP

Dim vwDPEinfuegen As V_DPEinfuegen

  On Error GoTo M_StdVorlage_DPAendern_Fehler
  
  Set vwDPEinfuegen = New V_DPEinfuegen
  
  Set rgDp = ActiveWindow.ActiveCell.EntireColumn.Cells(2, 1)
  Set oDP = getDp(rgDp)
  
  vwDPEinfuegen.Modus = 2
  Call vwDPEinfuegen.setDp(oDP)
  vwDPEinfuegen.Show
  
  If vwDPEinfuegen.ok Then
    Set coDP = vwDPEinfuegen.getDPL
    For Each oDP In coDP.Items
      Call setDp(rgDp, oDP)
    Next oDP
    
  End If
  Unload vwDPEinfuegen
  Set vwDPEinfuegen = Nothing
  
Exit Sub
M_StdVorlage_DPAendern_Fehler:
  
  If Not vwDPEinfuegen Is Nothing Then
    Unload vwDPEinfuegen
    Set vwDPEinfuegen = Nothing
  End If

  Call FehlerAusloesen(ERR_VORLAGE_DP_AeNDERN)
End Sub

'--------------------------------------------------------------------------------------------------
'Ermittelt das Layout der Tabelle
Public Sub GetTabLayout(wsProt As Worksheet, coTabBereich As CO_TabBereich)

Dim rgZeile       As Range
Dim coDPFkt       As CO_DPFunktion
Dim oDPFkt        As C_DPFunktion
Dim oTabBereich   As C_TabBereich
Dim boFktBereich  As Boolean

  Set coDPFkt = M_DPFunktion.coLesen
  Set rgZeile = wsProt.Range("A1")
  
  Do While Not rgZeile Is Nothing
    If rgZeile.value = VAR_KOPFZEILE Or _
       rgZeile.value = VAR_FUSSZEILE Or _
       rgZeile.value = VAR_SEITENENDE Then
       
      Set oTabBereich = New C_TabBereich
      oTabBereich.Blatt = wsProt.index
      oTabBereich.Bereich = rgZeile.value
      oTabBereich.Zeile = rgZeile.Row
      coTabBereich.Add oTabBereich
    End If
    
    If rgZeile.value = VAR_DATENBEREICH Then
      Set oTabBereich = New C_TabBereich
      oTabBereich.Blatt = wsProt.index
      oTabBereich.Bereich = rgZeile.value
      oTabBereich.Zeile = rgZeile.Row
      coTabBereich.Add oTabBereich
    End If
    
    If rgZeile.Text = VAR_KOPFZEILE Or _
       rgZeile.Text = VAR_FUSSZEILE Then
      boFktBereich = True
    ElseIf rgZeile.Text = VAR_DATENBEREICH Or _
           rgZeile.Text = VAR_SEITENENDE Then
      boFktBereich = False
    End If
    If boFktBereich Then
      For Each oDPFkt In coDPFkt.Items
        If oDPFkt.Bezeichnung = rgZeile.value Then
          Set oTabBereich = New C_TabBereich
          oTabBereich.Blatt = wsProt.index
          oTabBereich.Bereich = oDPFkt.Bezeichnung
          oTabBereich.Zeile = rgZeile.Row
          coTabBereich.Add oTabBereich
          Exit For
        End If
      Next oDPFkt
    End If
    
    Set rgZeile = MoveRange(rgZeile, xlDown)
  Loop

End Sub

'--------------------------------------------------------------------------------------------------
Public Function getDp(rgDp As Range) As C_DP

Dim oDP         As C_DP
Dim sDP         As String
Dim sDPE        As String
Dim sDPTyp      As String
Dim sDPFkt      As String
Dim iArchivTyp  As Integer
Dim lOffset     As Long
Dim lIntervall  As Long
Dim iIntEinheit As Integer
Dim sDPStat As String
Dim i As Integer

  sDP = rgDp.value
  sDPTyp = rgDp.Offset(2, 0).value
  sDPFkt = rgDp.Offset(3, 0).value
  iArchivTyp = RangeToLng(rgDp.Offset(9, 0), ARCHIVTYP_ACPERIODE)
  
  'DPTyp und DPFunktion OK?
  If sDPTyp = "" Or sDPFkt = "" Then
    sDP = ""
'ToDo: Brauche ich das hier (kommt von getDpList)
'  Else
'    'ACTyp?
'    If iArchivTyp = ARCHIVTYP_ACPERIODE Then
'      If coDPFkt.FindItem(sDPFkt) Is Nothing Then
'        sDp = ""
'      End If
'    End If
  End If
    
  'OK?
  If Len(sDP) Then
    Set oDP = New C_DP
    With oDP
      .dp = sDP
      .dpe = rgDp.Offset(1, 0).value
      .dpt = sDPTyp
      .ArchivFkt = sDPFkt
      .Kommentar = rgDp.Offset(4, 0).value
      .Alias = rgDp.Offset(5, 0).value
      .Format = rgDp.Offset(6, 0).value
      .Einheit = rgDp.Offset(7, 0).value
      .AutoFormat = RangeToLng(rgDp.Offset(8, 0))
      .ArchivTyp = iArchivTyp
      .Marker = RangeToLng(rgDp.Offset(10, 0))
      .ResultQuery = rgDp.Offset(11, 0).value
      .ResultFkt = rgDp.Offset(12, 0).Text
      .Offset = RangeToLng(rgDp.Offset(13, 0))
    End With
  End If
  Set getDp = oDP

End Function

'--------------------------------------------------------------------------------------------------
Public Sub setDp(rgDp As Range, oDP As C_DP)

  rgDp.value = oDP.dp
  rgDp.Offset(1, 0).value = oDP.dpe
  rgDp.Offset(2, 0).value = oDP.dpt
  rgDp.Offset(3, 0).value = oDP.ArchivFkt
  rgDp.Offset(4, 0).value = oDP.Kommentar
  rgDp.Offset(5, 0).value = oDP.Alias
  rgDp.Offset(6, 0).value = oDP.Format
  rgDp.Offset(7, 0).value = oDP.Einheit
  rgDp.Offset(8, 0).value = oDP.AutoFormat
  rgDp.Offset(9, 0).value = oDP.ArchivTyp
  rgDp.Offset(10, 0).value = oDP.Marker
  rgDp.Offset(11, 0).value = oDP.ResultQuery
  rgDp.Offset(12, 0).value = oDP.ResultFkt
  rgDp.Offset(13, 0).value = oDP.Offset
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub GetDPList(wsProt As Worksheet, coDP As CO_DP)

Dim rgDp        As Range
Dim oDP         As C_DP
Dim coDPFkt     As CO_DPFunktion

  Set coDPFkt = M_DPFunktion.coLesen

  'Spaltenweise die DP definition einlesen
  'Set rgDp = wsProt.Cells(2, 2)
  'While (Not rgDp Is Nothing)
  For Each rgDp In wsProt.Range("B2", wsProt.Cells(2, Columns.Count).End(xlToLeft)) 'IM 49919 'IM 117635
    Set oDP = getDp(rgDp)
    If Not oDP Is Nothing Then
      'Wird in getDp nicht gepr|fffd|ft!
      If oDP.ArchivTyp = ARCHIVTYP_ACPERIODE Or _
         oDP.ArchivTyp = ARCHIVTYP_RACPERIODE Then
        If coDPFkt.FindItem(oDP.ArchivFkt) Is Nothing Then
          Set oDP = Nothing
        End If
      End If
    End If
    If Not oDP Is Nothing Then
      Set oDP.TabBereich = New C_TabBereich
      oDP.TabBereich.Bereich = VAR_DATENBEREICH
      oDP.TabBereich.Blatt = wsProt.index
      oDP.TabBereich.Spalte = rgDp.Column
      oDP.TabBereich.Zeile = 0
      coDP.Add oDP
    End If
    'Set rgDp = MoveRange(rgDp, xlToRight)
  'Wend
  Next rgDp

End Sub 'GetDPList

'--------------------------------------------------------------------------------------------------
Public Sub updateDpInfos(wsProt As Worksheet)

Dim oComMan As ComManager
Dim rgDp    As Range
Dim sDP     As String

Dim v As Variant

  On Error GoTo updateDpInfosFehler
  
  Set oComMan = M_PVSS.getComMan
  For Each rgDp In wsProt.Range("B2", wsProt.Cells(2, Columns.Count).End(xlToLeft)) 'IM 49919 'IM 117635
  
    sDP = rgDp.value
    'DPTyp und DPFunktion OK?
    If rgDp.Offset(2, 0).value = "" Or _
       rgDp.Offset(3, 0).value = "" Then
      sDP = ""
    End If
    
    'OK?
    If Len(sDP) Then
      'Bei AC Typen schauen wir auf das .value
      If rgDp.Offset(9, 0).value = ARCHIVTYP_ACPERIODE Then
        'DPE vorhanden?
        If rgDp.Offset(1, 0).value <> "" Then
          sDP = sDP & "." & rgDp.Offset(1, 0).value & ".value"
        Else
          sDP = sDP & ".value"
        End If
      ElseIf rgDp.Offset(9, 0).value = ARCHIVTYP_RDBPERIODE Then
        If rgDp.Offset(1, 0).value <> "" Then
          sDP = sDP & "." & rgDp.Offset(1, 0).value
        Else
          sDP = sDP & "."
        End If
        sDP = sDP & ":" & rgDp.Offset(3, 0).value
      Else
        sDP = sDP & "." & rgDp.Offset(1, 0).value
      End If
      v = oComMan.dpGetDescription(sDP)
      If Not IsError(v) Then rgDp.Offset(4, 0).value = CStr(v)
      v = oComMan.dpGetAlias(sDP)
      If Not IsError(v) Then rgDp.Offset(5, 0).value = CStr(v)
      v = oComMan.dpGetFormat(sDP)
      If Not IsError(v) Then rgDp.Offset(6, 0).value = CStr(v)
      v = oComMan.dpGetUnit(sDP)
      If Not IsError(v) Then rgDp.Offset(7, 0).value = CStr(v)
    End If
  
  Next rgDp

Exit Sub
updateDpInfosFehler:
  Stop
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Update_3_0()

Dim wbProtVorlage As Worksheet
Dim rgDPs As Range
Dim rgDp As Range
Dim iBlatt As Integer
Dim iSpalte As Integer
Dim asFkt() As String
Dim sFkt As String
Dim n As Integer


  'Die Zellen Min, Max, Average und Summe zusammenfassen
  'Alle Datenpunkte sind im Tabellenblatt "Konfiguration" angegeben
  Set rgDPs = SelectRange(ActiveWorkbook.Worksheets(TAB_KONFIG).Range("H2"), 1, False)
  For Each rgDp In rgDPs.Rows
    
    ReDim asFkt(0)
    iBlatt = rgDp.Offset(0, 2).value    ' IM 72165 Indizes korr. WOKL 12.9.07
    iSpalte = rgDp.Offset(0, 3).value
    
    If ActiveWorkbook.Worksheets(iBlatt).Cells(7, iSpalte).value = True Then
      Call StrAppend(asFkt, "Min")
    End If
    
    If ActiveWorkbook.Worksheets(iBlatt).Cells(8, iSpalte).value = True Then
      Call StrAppend(asFkt, "Max")
    End If
    
    If ActiveWorkbook.Worksheets(iBlatt).Cells(9, iSpalte).value = True Then
      Call StrAppend(asFkt, "Average")
    End If
    
    If ActiveWorkbook.Worksheets(iBlatt).Cells(10, iSpalte).value = True Then
      Call StrAppend(asFkt, "Sum")
    End If
    
    'Das Feld mit den Fkt in einen String wandeln
    M_Tools.ArrayToStr sFkt, asFkt, "|"
    
    'Das Ergebnis in Zeile 10 schreiben und die anderen Zellenwerte loeschen
    ActiveWorkbook.Worksheets(iBlatt).Cells(7, iSpalte).value = ""
    ActiveWorkbook.Worksheets(iBlatt).Cells(8, iSpalte).value = ""
    ActiveWorkbook.Worksheets(iBlatt).Cells(9, iSpalte).value = ""
    ActiveWorkbook.Worksheets(iBlatt).Cells(10, iSpalte).value = sFkt
    
  Next
  
  'Schleife ueber alle Blaetter
  For Each wbProtVorlage In ActiveWorkbook.Worksheets
    If wbProtVorlage.Range("A1") = "Standardprotokoll" Then
    
      'Die Beschriftung der Spalte A fuer Min, Max, Average und Sum loeschen
      wbProtVorlage.Range("A2:A13").value = ""
      
      'Neue Zeile 3 einfuegen
      wbProtVorlage.Rows(3).Insert
      wbProtVorlage.Range("A2").value = "DP"
      wbProtVorlage.Range("A3").value = "DPE"
      wbProtVorlage.Range("A4").value = "DPT"
      wbProtVorlage.Range("A5").value = "Function"
      wbProtVorlage.Range("A10").value = "Result Query"
      wbProtVorlage.Range("A11").value = "Result Function"
      wbProtVorlage.Range("A12").value = "Offset"
      wbProtVorlage.Range("A13").value = "Offset Time"
    ElseIf (wbProtVorlage.Range("A1") = "Bilanzierung") Or _
           (wbProtVorlage.Range("A1") = "Normaltag") Then
      'Neue Zeile 3 einfuegen
      wbProtVorlage.Rows(3).Insert
    End If
  Next wbProtVorlage
End Sub
Attribute VB_Name = "M_Tariffset"
'===================================================================================================
'M_Tariffset
'Wolfram Klebel 2.7.09
'  Verwaltung der Tariffset Eintraege
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Private mcoTariffset As CO_Tariffset


'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwTariffset As V_Tariffset
Dim coTariffset As CO_Tariffset

  On Error GoTo M_Tariffset_Edit_Fehler
  
  Set vwTariffset = New V_Tariffset
  Set coTariffset = M_Tariffset.coLesen
  Set vwTariffset.Tariffset = coTariffset
  vwTariffset.Show
  
  If vwTariffset.ok Then
    'Sieht lustig aus, aber auf Collection wird direkt referenziert
    'Aenderungen schlagen also automatisch durch!
    Call M_Tariffset.coSpeichern(coTariffset)
    
    'Vorsicht Falle!
    'Auch wenn man es hier nicht sieht, es wird indirekt mcoTariffset geaendert! UND
    'Die editierten Tariffsaetze kennen zwar ihre Archive (DPE aus AC Parametrierung, inkl VStufe)
    'aber nicht die dort enthaltenen Stat. Funktionen (AVG_WT0).
    'Nun koennte man diese Infos an dieser Stelle erneut aus der DB lesen, einfacher ist es
    'jedoch, den Cache wegzuschmeissen. Der Performance- Verlust ist selbst bei Dongshen irrelevant.
    Set mcoTariffset = Nothing
    Call M_CostCenter.Invalidate    ' IM 104043
    
  End If
  'ToDo: Falls coBasiswert gepuffert wird, muss nach einem Abbruch der
  'Bearbeitung der Puffer geloescht werden!
  'Stimmt, ich sollte mal das Datum zu meinen Kommentaren aufnehmen
  Set mcoTariffset = Nothing
    
  Unload vwTariffset
  Set vwTariffset = Nothing

Exit Sub
M_Tariffset_Edit_Fehler:
  
  If Not vwTariffset Is Nothing Then
    Unload vwTariffset
    Set vwTariffset = Nothing
  End If
  Call FehlerAusloesen(30702, , False, "M_Tariffset::coEdit")
  
End Sub 'coEdit()



'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_Tariffset

Dim recTariffset  As ADODB.Recordset
Dim sSql          As String
Dim oTariffset    As C_Tariffset
Dim lStatusId     As Long

  On Error GoTo Tariffset_Lesen_Fehler
   
  Set mcoTariffset = Nothing
   
  If mcoTariffset Is Nothing Then
    lStatusId = StatusTextAusgeben("Reading Tariffsets")
    
    Set mcoTariffset = New CO_Tariffset
    
    sSql = "SELECT * FROM tabTariffset"
    Set recTariffset = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    While Not recTariffset.EOF
      Set oTariffset = New C_Tariffset
      
      oTariffset.ID = recTariffset.Fields("ID")
      oTariffset.Name = recTariffset.Fields("Name")
      oTariffset.CurrName = recTariffset.Fields("CurrName")
      Set oTariffset.Medium = M_Media.Lesen(recTariffset.Fields("Medium"))
      
      Call StatusTextAusgeben("Reading Basisvalues " & oTariffset.Name, lStatusId)
      recTariffset.MoveNext
      
      mcoTariffset.Add oTariffset
    Wend
    Call M_DB.CloseRecordset(recTariffset)

    For Each oTariffset In mcoTariffset.Items
      Call coReadEntry(oTariffset)
      Call coReadHolidays(oTariffset)
    Next oTariffset
      
  End If
    
  Set coLesen = mcoTariffset
  StatusTextLoeschen (lStatusId)
  
Exit Function
Tariffset_Lesen_Fehler:
  
  Call M_DB.CloseRecordset(recTariffset)
  If Not oTariffset Is Nothing Then
    Call FehlerAusloesen(30700, "Tariffset #" & oTariffset.Name, False, "M_Tariffset::coLesen")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Tariffset::coLesen")
  End If

End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Private Sub coReadEntry(ts As C_Tariffset)

Dim recTariffset  As ADODB.Recordset
Dim sSql          As String
Dim tsEntry       As C_TariffsetEntry

  sSql = "SELECT * FROM tabTariffsetEntry WHERE " & _
         "Tariffset = " & ts.ID
         
  Set recTariffset = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recTariffset.EOF
    Set tsEntry = New C_TariffsetEntry
  
    With tsEntry
      .ID = recTariffset.Fields("ID")
      .Name = recTariffset.Fields("Name")
      .ValidFrom = recTariffset.Fields("ValidFrom")
      .ValidUntil = recTariffset.Fields("ValidUntil")
    End With
    Call ts.tsEntry.Add(tsEntry)
    
    recTariffset.MoveNext
  Wend
  Call M_DB.CloseRecordset(recTariffset)
  
  For Each tsEntry In ts.tsEntry.Items
    Call coReadLines(tsEntry)
  Next tsEntry
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub coReadLines(tsEntry As C_TariffsetEntry)

Dim recTariffset  As ADODB.Recordset
Dim sSql          As String
Dim index         As Integer
Dim i As Integer

  index = 1
    
  sSql = "SELECT * FROM tabTariffsetLine WHERE " & _
         "TariffsetEntry = " & tsEntry.ID
         
  Set recTariffset = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recTariffset.EOF
  
    With tsEntry
      .TariffIsUsed(index) = True
      .TariffCost(index) = recTariffset.Fields("Cost")
      .TariffStart(index) = recTariffset.Fields("FromDate")
      .TariffEnd(index) = recTariffset.Fields("UntilDate")
      .TariffOn(index, 1) = recTariffset.Fields("OnMo")
      .TariffOn(index, 2) = recTariffset.Fields("OnTu")
      .TariffOn(index, 3) = recTariffset.Fields("OnWe")
      .TariffOn(index, 4) = recTariffset.Fields("OnTh")
      .TariffOn(index, 5) = recTariffset.Fields("OnFr")
      .TariffOn(index, 6) = recTariffset.Fields("OnSa")
      .TariffOn(index, 7) = recTariffset.Fields("OnSu")
      .TariffOn(index, 8) = recTariffset.Fields("OnHo")
    End With
    
    index = index + 1
    recTariffset.MoveNext
  Wend
  Call M_DB.CloseRecordset(recTariffset)
  
  For i = index To TARIFFCOUNT    ' rest is unused
    tsEntry.TariffIsUsed(i) = False
  Next i
  
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub coReadHolidays(ts As C_Tariffset)

Dim recTariffset  As ADODB.Recordset
Dim sSql          As String
Dim index         As Integer

  For index = 1 To ts.Holidays.Count
    ts.Holidays.Remove 1
  Next
 
  sSql = "SELECT * FROM tabTariffsetHoli WHERE " & _
         "Tariffset = " & ts.ID
         
  Set recTariffset = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  While Not recTariffset.EOF
  
    ts.Holidays.Add CDate(recTariffset.Fields("Datum"))
    recTariffset.MoveNext
  Wend
  
  Call M_DB.CloseRecordset(recTariffset)
  
End Sub
'---------------------------------------------------------------------------------------------------
' wird die noch verwendet? WOKL 2.7.09
'Public Function Lesenxxx(ID As Integer) As C_Tariffset
'
'Dim coTariffset As CO_Tariffset
'Dim oTariffset  As C_Tariffset
'
'  ' On Error GoTo Tariffset_Lesen_Fehler
'  GoTo Tariffset_Lesen_Fehler
'
'  Set coTariffset = coLesen
'  For Each oTariffset In coTariffset.Items
'    If oTariffset.ID = ID Then
'      Set Lesen = oTariffset
'      Exit For
'    End If
'  Next oTariffset
'
'Exit Function
'Tariffset_Lesen_Fehler:
'
'  If Not oTariffset Is Nothing Then
'    Call FehlerAusloesen(30705, "Tariffset #" & oTariffset.ID, False, "M_Tariffset::Lesen")
'  Else
'    Call FehlerAusloesen(30705, Err.Description, False, "M_Tariffset::Lesen")
'  End If
'
'End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Function coFilterCcId(ccID As Integer) As CO_Tariffset

Dim coTariffset   As CO_Tariffset
Dim oTariffset    As C_Tariffset
Dim sSql          As String
Dim rs  As ADODB.Recordset
  Dim dbConn As ADODB.Connection

  On Error GoTo coFilterCcId_Lesen_Fehler
   
    Set coTariffset = New CO_Tariffset
    
    sSql = "SELECT * FROM tabTariffset " & _
      "INNER JOIN refTariffset ON tabTariffset.ID = refTariffset.Tariffset " & _
      "WHERE refTariffset.CostCenter = " & ccID
      
    Set dbConn = M_DB.getConnection()
    Set rs = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    While Not rs.EOF
      Set oTariffset = New C_Tariffset
      
      oTariffset.ID = rs.Fields("ID")
      oTariffset.Name = rs.Fields("Name")
      oTariffset.CurrName = rs.Fields("CurrName")
      Set oTariffset.Medium = M_Media.Lesen(rs.Fields("Medium"))
      
      rs.MoveNext
      
      coTariffset.Add oTariffset
    Wend
    Call M_DB.CloseRecordset(rs)

    For Each oTariffset In coTariffset.Items
      Call coReadEntry(oTariffset)
      Call coReadHolidays(oTariffset)
    Next oTariffset
      
  Set coFilterCcId = coTariffset
  
Exit Function
coFilterCcId_Lesen_Fehler:
  
  Call M_DB.CloseRecordset(rs)
  If Not oTariffset Is Nothing Then
    Call FehlerAusloesen(30700, "Tariffset #" & oTariffset.Name, False, "M_Tariffset::coFilterCcId")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Tariffset::coFilterCcId")
  End If

End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Function coFilterMediaId(mdId As Integer) As CO_Tariffset

Dim coTariffset   As CO_Tariffset
Dim oTariffset    As C_Tariffset
Dim sSql          As String
Dim rs  As ADODB.Recordset
  Dim dbConn As ADODB.Connection

  On Error GoTo coFilterMediaId_Error
   
    Set coTariffset = New CO_Tariffset
    
    sSql = "SELECT * FROM tabTariffset " & _
      "WHERE Medium = " & mdId
      
    Set dbConn = M_DB.getConnection()
    Set rs = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
    While Not rs.EOF
      Set oTariffset = New C_Tariffset
      
      oTariffset.ID = rs.Fields("ID")
      oTariffset.Name = rs.Fields("Name")
      oTariffset.CurrName = rs.Fields("CurrName")
      Set oTariffset.Medium = M_Media.Lesen(rs.Fields("Medium"))
      
      rs.MoveNext
      
      coTariffset.Add oTariffset
    Wend
    Call M_DB.CloseRecordset(rs)

    For Each oTariffset In coTariffset.Items
      Call coReadEntry(oTariffset)
      Call coReadHolidays(oTariffset)
    Next oTariffset
      
  Set coFilterMediaId = coTariffset
  
Exit Function
coFilterMediaId_Error:
  
  Call M_DB.CloseRecordset(rs)
  If Not oTariffset Is Nothing Then
    Call FehlerAusloesen(30700, "Tariffset #" & oTariffset.Name, False, "M_Tariffset::coFilterMediaId")
  Else
    Call FehlerAusloesen(30700, Err.Description, False, "M_Tariffset::coFilterMediaId")
  End If

End Function 'Lesen()'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coTariffset As CO_Tariffset)

Dim recTariffset  As ADODB.Recordset
Dim oTariffset    As C_Tariffset
Dim sSql          As String
Dim lLoeschen     As Long

  On Error GoTo Tariffset_Speichern_Fehler
  
  sSql = "UPDATE tabTariffset SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen
  
  sSql = "SELECT * FROM tabTariffset"
  Set recTariffset = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)

  For Each oTariffset In coTariffset.Items
    
    If recTariffset.BOF And recTariffset.EOF Then
      recTariffset.AddNew
    Else
      recTariffset.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recTariffset.Find "ID = " & oTariffset.ID, , adSearchForward
      If recTariffset.EOF Then
        recTariffset.AddNew
      Else
        recTariffset.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recTariffset.Fields("Name") = oTariffset.Name
    recTariffset.Fields("CurrName") = oTariffset.CurrName
    recTariffset.Fields("Medium") = oTariffset.Medium.ID
    
    recTariffset.Update
    oTariffset.ID = recTariffset.Fields("ID")
    
    Call RefTariffsetEntry_Speichern(oTariffset)
    Call RefTariffsetHoli_Speichern(oTariffset)

  Next oTariffset
  If (lLoeschen > 0) Then
    Call M_CostCenter.Invalidate
  End If
  
  ' Alle zum Loeschen markierten Eintraege tatsaechlich loeschen
  ' die referenzierenden Kostenstelleneintraege werden mitgeloscht
  sSql = "DELETE FROM tabTariffset WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql

  Call M_DB.CloseRecordset(recTariffset)
  
Exit Sub
Tariffset_Speichern_Fehler:
  
  Call M_DB.CloseRecordset(recTariffset)
  
  Call ErrMessage("sSQL: " & sSql, "M_Tariffset::coSpeichern")
  If Not oTariffset Is Nothing Then
    Call FehlerAusloesen(30703, "Tariffset " & oTariffset.Name, _
                        False, "M_Tariffset::coSpeichern")
  Else
    Call FehlerAusloesen(30703, Err.Description, _
                        False, "M_Tariffset::coSpeichern")
  End If

End Sub 'coSpeichern()

'---------------------------------------------------------------------------------------------------
Public Sub RefTariffsetEntry_Speichern(oTariffset As C_Tariffset)

Dim recTsEntry  As ADODB.Recordset
Dim sSql        As String
Dim tsEntry     As C_TariffsetEntry
Dim hasDefault  As Boolean
Dim moDBConn  As ADODB.Connection

  On Error GoTo TsEntrySpeichern_Fehler

  ' alles neu macht der Mai ...
  sSql = "DELETE FROM tabTariffsetEntry WHERE Tariffset = " & oTariffset.ID
  Set moDBConn = M_DB.getConnection
  moDBConn.Execute sSql
  
  sSql = "SELECT * FROM tabTariffsetEntry"
  Set recTsEntry = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  hasDefault = False
  For Each tsEntry In oTariffset.tsEntry.Items
    recTsEntry.AddNew
    
    recTsEntry.Fields("Tariffset") = oTariffset.ID
    recTsEntry.Fields("Name") = tsEntry.Name
    recTsEntry.Fields("ValidFrom") = CDate(tsEntry.ValidFrom)
    recTsEntry.Fields("ValidUntil") = CDate(tsEntry.ValidUntil)
    If (tsEntry.Name = "Default" And hasDefault = False) Then
      recTsEntry.Fields("IsDefault") = True
      hasDefault = True
    End If

    recTsEntry.Update   ' Commit
    tsEntry.ID = recTsEntry.Fields("ID")
    
    Call RefTariffsetLine_Speichern(tsEntry)
  Next tsEntry
  
  Call M_DB.CloseRecordset(recTsEntry)
  
Exit Sub
TsEntrySpeichern_Fehler:

  Call M_DB.CloseRecordset(recTsEntry)
  Call ErrMessage("sSQL: " & sSql, "M_Tariffset::RefTariffsetEntry_Speichern")
  If Not oTariffset Is Nothing Then
    Call FehlerAusloesen(30707, "Tariffset " & oTariffset.ID, _
                        False, "M_Tariffset::RefTariffsetEntry_Speichern")
  Else
    Call FehlerAusloesen(30707, Err.Description, _
                        False, "M_Tariffset::RefTariffsetEntry_Speichern")
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub RefTariffsetLine_Speichern(oTsEntry As C_TariffsetEntry)

Dim recTsLine As ADODB.Recordset
Dim sSql      As String
Dim index     As Integer

  On Error GoTo RefTsLine_Speichern_Fehler

  sSql = "SELECT * FROM tabTariffsetLine"
  Set recTsLine = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  'If oTariffset.Tariff1IsUsed Then
  For index = 1 To TARIFFCOUNT
    If (oTsEntry.TariffIsUsed(index) = True) Then
      recTsLine.AddNew
      
      recTsLine.Fields("TariffsetEntry") = oTsEntry.ID
      recTsLine.Fields("Cost") = CDbl(oTsEntry.TariffCost(index))
      recTsLine.Fields("FromDate") = CDate(oTsEntry.TariffStart(index))
      recTsLine.Fields("UntilDate") = CDate(oTsEntry.TariffEnd(index))
      recTsLine.Fields("OnMo") = oTsEntry.TariffOn(index, 1)
      recTsLine.Fields("OnTu") = oTsEntry.TariffOn(index, 2)
      recTsLine.Fields("OnWe") = oTsEntry.TariffOn(index, 3)
      recTsLine.Fields("OnTh") = oTsEntry.TariffOn(index, 4)
      recTsLine.Fields("OnFr") = oTsEntry.TariffOn(index, 5)
      recTsLine.Fields("OnSa") = oTsEntry.TariffOn(index, 6)
      recTsLine.Fields("OnSu") = oTsEntry.TariffOn(index, 7)
      recTsLine.Fields("OnHo") = oTsEntry.TariffOn(index, 8)
    
      recTsLine.Update
    End If
  Next index
  
  Call M_DB.CloseRecordset(recTsLine)
  
Exit Sub
RefTsLine_Speichern_Fehler:

  Call M_DB.CloseRecordset(recTsLine)
  
  Call ErrMessage("sSQL: " & sSql, "M_Tariffset::RefTariffsetLine_Speichern")
  If Not oTsEntry Is Nothing Then
    Call FehlerAusloesen(30707, "Tariffset " & oTsEntry.ID, _
                        False, "M_Tariffset::RefTariffsetLine_Speichern")
  Else
    Call FehlerAusloesen(30707, Err.Description, _
                        False, "M_Tariffset::RefTariffsetLine_Speichern")
  End If

End Sub 'RefTariffsetLine_Speichern()

'---------------------------------------------------------------------------------------------------
Public Sub RefTariffsetHoli_Speichern(oTariffset As C_Tariffset)

Dim recTsLine As ADODB.Recordset
Dim sSql      As String
Dim index     As Integer

  On Error GoTo RefTariffsetHoli_Speichern_Fehler

  sSql = "DELETE FROM tabTariffsetHoli WHERE Tariffset = " & oTariffset.ID
  M_DB.getConnection.Execute sSql
  
  sSql = "SELECT * FROM tabTariffsetHoli"
  Set recTsLine = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  For index = 1 To oTariffset.Holidays.Count
    recTsLine.AddNew
    
    recTsLine.Fields("Tariffset") = oTariffset.ID
    recTsLine.Fields("Datum") = CDate(oTariffset.Holidays.Item(index))
    
    recTsLine.Update
  Next
  
  Call M_DB.CloseRecordset(recTsLine)
  
Exit Sub
RefTariffsetHoli_Speichern_Fehler:

  Call M_DB.CloseRecordset(recTsLine)
  
  Call ErrMessage("sSQL: " & sSql, "M_Tariffset::RefTariffsetHoli_Speichern")
  If Not oTariffset Is Nothing Then
    Call FehlerAusloesen(30707, "Tariffset " & oTariffset.ID, _
                        False, "M_Tariffset::RefTariffsetHoli_Speichern")
  Else
    Call FehlerAusloesen(30707, Err.Description, _
                        False, "M_Tariffset::RefTariffsetHoli_Speichern")
  End If

End Sub 'RefTariffsetHoli_Speichern()





Attribute VB_Name = "M_Tools"
'==================================================================================================
'Modul M_Tools
'
'Datei   osTools.xls
'Version 0.1
'Datum   27.11.98
'Autor   Oliver Seidel
'
'Allgemeine Tools, die das Programmieren erleichtern.
'ACHTUNG: Dieses Modul wird in verschiedenen Projekten eingesetzt - Schnittstelle nicht Aendern!
'
'Aenderungen: -keine- (zumindest noch nicht dokumentiert da noch in Entwicklung)
'==================================================================================================
Option Explicit
Option Private Module

'Projekt-Informationen
Private Const PROJEKT_BEZEICHNUNG = "Report"

' IM 102541 WOKL: in PVSS 3.8.2 it is 3.8.0 for distinction
' IM 115373 WOKL: ICS India enhancements file types xlsm...
' IM 117977 3.8.5 WOKL: international coding / russian
Private Const PROJEKT_VERSION = "v3.8.6"  ' IM 118941 WOKL: Folgeproblem von ICS
Private Const PROJEKT_AUTOR = "Wolfram Klebel"
'Private Const PROJEKT_KENNWORT = "erAdmin"

'Verhalten der Fehlerprotokollierung
#Const aboLogFile = 1
#Const aboMsgBox = 2
#Const aboDebugWin = 4

Public Type BROWSEINFO
  hOwner As Long
  pidlRoot As Long
  pszDisplayName As String
  lpszTitle As String
  ulFlags As Long
  lpfn As Long
  lParam As Long
  iImage As Long
End Type

Type SECURITY_ATTRIBUTES
  nLength As Long
  lpSecurityDescriptor As Long
  bInheritHandle As Long
End Type

Declare Function GetComputerName _
                 Lib "kernel32" _
                 Alias "GetComputerNameA" _
                 (ByVal lpBuffer As String, _
                 nSize As Long) As Long
Declare Function GetUserName _
                 Lib "advapi32.dll" _
                 Alias "GetUserNameA" _
                 (ByVal lpBuffer As String, _
                 nSize As Long) As Long

'Leider kein Enum unter Excel 97 m|fffd|glich
'private Enum EXTENDED_NAME_FORMAT
'    NameUnknown = 0
'    NameFullyQualifiedDN = 1
'    NameSamCompatible = 2
'    NameDisplay = 3
'    NameUniqueId = 6
'    NameCanonical = 7
'    NameUserPrincipal = 8
'    NameCanonicalEx = 9
'    NameServicePrincipal = 10
'End Enum
Private Declare Function GetUserNameEx _
                         Lib "secur32.dll" _
                         Alias "GetUserNameExA" _
                         (ByVal NameFormat As Integer, _
                         ByVal lpNameBuffer As String, _
                         ByRef nSize As Long) As Long
Declare Function GetPrivateProfileSection _
                 Lib "kernel32" _
                 Alias "GetPrivateProfileSectionA" _
                 (ByVal lpAppName As String, _
                 ByVal lpReturnedString As String, _
                 ByVal nSize As Long, _
                 ByVal lpFileName As String) As Long
Declare Function WritePrivateProfileSection _
                 Lib "kernel32" _
                 Alias "WritePrivateProfileSectionA" _
                 (ByVal lpAppName As String, _
                  ByVal lpString As String, _
                  ByVal lpFileName As String) As Long

Declare Function GetPrivateProfileInt _
                 Lib "kernel32" _
                 Alias "GetPrivateProfileIntA" _
                 (ByVal lpApplicationName As String, _
                 ByVal lpKeyName As String, _
                 ByVal nDefault As Long, _
                 ByVal lpFileName As String) As Long

Declare Function GetPrivateProfileString _
                 Lib "kernel32" _
                 Alias "GetPrivateProfileStringA" _
                 (ByVal lpApplicationName As String, _
                  ByVal lpKeyName As Any, _
                  ByVal lpDefault As String, _
                  ByVal lpReturnedString As String, _
                  ByVal nSize As Long, _
                  ByVal lpFileName As String) As Long
Declare Function WritePrivateProfileString _
                 Lib "kernel32" _
                 Alias "WritePrivateProfileStringA" _
                 (ByVal lpApplicationName As String, _
                  ByVal lpKeyName As Any, _
                  ByVal lpString As Any, _
                  ByVal lpFileName As String) As Long

Declare Function SHGetPathFromIDList _
                 Lib "shell32.dll" _
                 Alias "SHGetPathFromIDListA" _
                 (ByVal pidl As Long, _
                  ByVal pszPath As String) As Long
Declare Function SHBrowseForFolder _
                 Lib "shell32.dll" _
                 Alias "SHBrowseForFolderA" _
                 (lpBrowseInfo As BROWSEINFO) As Long

Declare Function SetCurrentDirectory _
                 Lib "kernel32" _
                 Alias "SetCurrentDirectoryA" _
                 (ByVal lpPathName As String) As Long
Declare Function GetCurrentDirectory _
                 Lib "kernel32" _
                 Alias "GetCurrentDirectoryA" _
                 (ByVal nBufferLength As Long, _
                 ByVal lpBuffer As String) As Long
Declare Function CreateDirectory _
                 Lib "kernel32" _
                 Alias "CreateDirectoryA" _
                 (ByVal lpPathName As String, _
                 lpSecurityAttributes As SECURITY_ATTRIBUTES) As Long

Declare Sub Sleep Lib "Kernel32.dll" (ByVal SleepTime As Long)
Declare Function GetTickCount Lib "kernel32" () As Long

Private masStatusText() As String
Private mboDebugMsg As Boolean
Private mboErrorMsg As Boolean

'--------------------------------------------------------------------------------------------------
Public Function getDebugMsgFlag() As Boolean

Static boInit As Boolean

  On Error Resume Next    ' IM 117977 ru

  If Not boInit Then
    mboDebugMsg = CBool(GetSetting("PVSSReport", "Debug", "DebugMsgFlag", CStr(False)))
    boInit = True
  End If
  getDebugMsgFlag = mboDebugMsg
  
End Function

'--------------------------------------------------------------------------------------------------
Public Sub setDebugMsgFlag(boDebugMsg As Boolean)
  mboDebugMsg = boDebugMsg
  Call SaveSetting("PVSSReport", "Debug", "DebugMsgFlag", CStr(mboDebugMsg))
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub BugAssert(ByVal fExpression As Boolean, _
                     Optional ByVal sExpression As String, _
                     Optional ByVal sQuelle As String)
              
#If aboError Then
  If fExpression Then Exit Sub
  Call ErrMessage(sExpression, sQuelle)
  Stop
#End If
              
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub BugMessage(ByVal sMsg As String, _
                      Optional ByVal sQuelle As String)
              
Dim iLogFile As Integer
              
#If aboDebug And aboLogFile Then
  If getDebugMsgFlag Then
    iLogFile = FreeFile
    Open ProjektPfad & "\" & _
         ProjektBezeichnung & ".DBG" _
         For Append Shared As iLogFile
         
    Print #iLogFile, Date & Chr(9) & Time & Chr(9) & _
                     "Msg" & Chr(9) & sQuelle & Chr(9) & "->" & Chr(9) & sMsg
    Close iLogFile
  End If
#End If

#If aboDebug And aboMsgBox Then
  MsgBox sMsg, vbOKOnly, sQuelle
#End If

#If aboDebug And aboDebugWin Then
  Debug.Print Date & " " & Time & " " & sQuelle & " -> " & sMsg
#End If

End Sub

'--------------------------------------------------------------------------------------------------
Public Function getErrorMsgFlag() As Boolean

Static boInit As Boolean

  On Error Resume Next    ' IM 117977 ru
  
  If Not boInit Then
    mboErrorMsg = CBool(GetSetting("PVSSReport", "Debug", "ErrorMsgFlag", CStr(False)))
    boInit = True
  End If
  getErrorMsgFlag = mboErrorMsg
  
End Function

'--------------------------------------------------------------------------------------------------
Public Sub setErrorMsgFlag(boErrorMsg As Boolean)
  mboErrorMsg = boErrorMsg
  Call SaveSetting("PVSSReport", "Debug", "ErrorMsgFlag", CStr(mboErrorMsg))
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub ErrMessage(ByVal sMsg As String, _
                      Optional ByVal sQuelle As String)
              
Dim iLogFile As Integer
Dim errCode   As Long
Dim errSource As String
Dim errDescr   As String
              
  'IM 119563 make error info transparent for this function
  errCode = Err.Number
  errSource = Err.Source
  errDescr = Err.Description
              
#If aboError And aboLogFile Then
  If getErrorMsgFlag Then
    iLogFile = FreeFile
    Open ProjektPfad & "\" & _
         ProjektBezeichnung & ".DBG" _
         For Append Shared As iLogFile
         
    Print #iLogFile, HostName & Chr(9) & Username & Chr(9) & Date & Chr(9) & Time & Chr(9) & _
                     "Err" & Chr(9) & sQuelle & Chr(9) & "->" & Chr(9) & sMsg
    Close iLogFile
    
    ' Err contents are deleted with file access
  End If
  
  Err.Number = errCode
  Err.Source = errSource
  Err.Description = errDescr
#End If

#If aboError And aboMsgBox Then
  MsgBox sMsg, vbOKOnly, "Fehler in " & sQuelle
#End If

#If aboError And aboDebugWin Then
  Debug.Print Date & " " & Time & " " & sQuelle & " -> " & sMsg
#End If

End Sub

'--------------------------------------------------------------------------------------------------
Public Function GetDirectory(Optional msg As String) As String

Dim bInfo As BROWSEINFO
Dim Path As String
Dim r As Long, x As Long, pos As Integer
  
  bInfo.pidlRoot = 0&
  If IsMissing(msg) Then
    bInfo.lpszTitle = "Waehlen Sie bitte einen Ordner aus."
  Else
    bInfo.lpszTitle = msg
  End If
  bInfo.ulFlags = &H1
  x = SHBrowseForFolder(bInfo)
  Path = Space$(512)
  r = SHGetPathFromIDList(ByVal x, ByVal Path)
  If r Then
    pos = InStr(Path, Chr$(0))
    GetDirectory = Left(Path, pos - 1)
  Else
    GetDirectory = ""
  End If
End Function

'--------------------------------------------------------------------------------------------------
Public Sub LaufwertWechsel(ByVal sPfad As String)
Dim ApiErgeb As Long
  ApiErgeb = SetCurrentDirectory(sPfad)
End Sub

Public Function getPath(ByVal sFile As String)

Dim n As Long
Dim m As Long
  
  'GetAttr schlaegt fehl, wenn Datei nicht vorhanden ist,
  'trotzdem soll der Path zurueckgegeben werden
  On Error Resume Next
  If GetAttr(sFile) <> vbDirectory Then
    For n = 1 To Len(sFile)
      If Mid(sFile, n, 1) = "\" Then m = n - 1
    Next n
    getPath = Left(sFile, m)
  Else
    If Right(sFile, 1) = "\" Then
      getPath = Left(sFile, Len(sFile) - 1)
    Else
      getPath = sFile
    End If
  End If
  
End Function

'--------------------------------------------------------------------------------------------------
'Loest einen Laufzeitfehler mit der Nummer lFehlerCode aus.
'Die Fehlernummern fuer eigene Fehler beginnt beim Basiswert ERR_BASIS ab 30000.
'(Meine eigene Vereinbarung!, kein anderer soll es wagen diesen Bereich zu benutzen!!).
'
'ACHTUNG: Damit die Fehler auch von den uebergeordneten Methoden im Debugger abgefangen werden
'         koennen, muss unter Extras/Optionen/Allgemein die Auswahl 'Fehlerbehandlung' auf
'         'Bei nicht verarbeiteten Fehlern unterbrechen' gestellt werden!
'Aenderungen: -keine-
'--------------------------------------------------------------------------------------------------
Public Sub FehlerAusloesen(ByVal lFehlerCode As Long, _
                          Optional ByVal sInfoText As String = "", _
                          Optional ByVal boErsterAufruf As Boolean = True, _
                          Optional ByVal sQuelle As String = "")

Dim rgFehlerDef         As Range
Dim lFehlerID           As Long
Static lFehlerCodeAlt   As Long
Static sFehlerQuelleAlt As String
Static sFehlerTextAlt   As String
Dim i             As Long

  'Noch kein Fehler aufgetreten oder aktueller Fehler bereits geloescht
  '(VBA loescht Err-Object, wenn Methoden in Fehlerbehandlungsroutinen aufgerufen werden!)
  If Err.Number = 0 Then
    
    'Erster Aufruf - bisher war noch kein Fehler aufgetreten
    If boErsterAufruf Then
      
      lFehlerCodeAlt = lFehlerCode
      If sQuelle <> "" Then
        sFehlerQuelleAlt = sQuelle
      Else
         sFehlerQuelleAlt = GetResText(lFehlerCode, True)
      End If
      sFehlerTextAlt = GetResText(lFehlerCode)
      If Len(sInfoText) > 0 Then
        sFehlerTextAlt = sFehlerTextAlt & Chr(13) & sInfoText
      End If
    End If 'Wenn nicht erster Aufruf wird auf gespeicherte Fehlerbeschreibung zugegriffen!
    
    'Fehler protokollieren und mit neuem Fehlercode weiterleiten
    Call ErrMessage("FEHLER " & lFehlerCodeAlt & " " & sFehlerTextAlt, _
                    sFehlerQuelleAlt)
    Call Err.Raise(lFehlerCode, _
                   sFehlerQuelleAlt, _
                   sFehlerTextAlt)
    
  'Letzter Fehler kam von VBA?
  ElseIf Err.Number < ERR_BASIS Then
    
    lFehlerCodeAlt = lFehlerCode
    If sQuelle <> "" Then
      sFehlerQuelleAlt = sQuelle
    Else
       sFehlerQuelleAlt = GetResText(lFehlerCode, True)
    End If
    If boErsterAufruf Or sFehlerTextAlt = "" Then
      sFehlerTextAlt = GetResText(lFehlerCode)
      If Len(sInfoText) > 0 Then
        sFehlerTextAlt = sFehlerTextAlt & Chr(13) & sInfoText
      End If
    End If
    'Fehler protokollieren und mit neuem Fehlercode und neuer Fehlerbeschreibung weiterleiten
    Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description, _
                    Err.Source)
    Call Err.Raise(lFehlerCode, _
                   sFehlerQuelleAlt, _
                   sFehlerTextAlt)
    
  'Eigener Fehler
  Else
    
    'Fehler speichern - kann bei naechstem Aufruf schon geloescht sein!
    lFehlerCodeAlt = Err.Number
    sFehlerQuelleAlt = Err.Source
    sFehlerTextAlt = Err.Description
    'FehlerCode aktualisieren und Fehler weiterleiten
    Call ErrMessage("FEHLER " & lFehlerCode & " " & Err.Description, _
                    Err.Source)
    Call Err.Raise(lFehlerCode, _
                   Err.Source, _
                   Err.Description)
  
  End If

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Delay(ByVal dtPause As Single)
  Call Sleep(CLng(dtPause * 1000))
  DoEvents
End Sub

'--------------------------------------------------------------------------------------------------
'Von der ersten Spalte der ersten Zeile (rgStart) wird ein zusammenhaengender Zellbereich gesucht
'und als Range-Objekt zurueckgegeben. Die Anzahl der Spalten kann angegeben werden, ebenso kann die
'erste Zeile unterdrueckt werden. Die erste Spalte muss vollstaendig gefuellt sein, damit die Anzahl
'der Zeilen berechnet werden kann!
'
'Aenderungen: -keine-
'--------------------------------------------------------------------------------------------------
Public Function SelectRange(ByVal rgStart As Range, _
                            Optional ByVal iSpaltenAnz As Integer, _
                            Optional ByVal boTitelZeile As Boolean, _
                            Optional ByVal iZeilenAnz As Integer) As Range

Dim rgZelle As Range      'Eine Zelle aus dem untersuchten Bereich
'Dim iZeilenAnz As Integer 'Anzahl der Zeilen im Bereich

  Call BugAssert(Not rgStart Is Nothing, "rgStart is nothing", "M_Tools::SelectRange")
  
  'Wenn die Anzahl der Spalten nicht angegeben ist
  If iSpaltenAnz = 0 And Len(rgStart) > 0 Then
    'Wird sie aus der ersten Zeile ermittelt
'    Set rgZelle = rgStart
'    Do Until Len(rgZelle.Text) = 0
'      iSpaltenAnz = iSpaltenAnz + 1
'      Set rgZelle = rgZelle.Offset(0, 1)
'    Loop
    Set rgZelle = rgStart.End(xlToRight)
    If (Len(rgZelle) > 0) And (Len(rgZelle.Offset(0, -1)) > 0) Then
      iSpaltenAnz = Range(rgStart, rgZelle).Columns.Count
    Else
      iSpaltenAnz = 1
    End If
  End If
    
  'Wenn die Anzahl der Zeilen nicht angegeben ist
  If iZeilenAnz = 0 And Len(rgStart) > 0 Then
    'Anzahl der Zeilen aus der ersten Spalte ermitteln
'    Set rgZelle = rgStart
'    Do Until Len(rgZelle.Text) = 0
'      iZeilenAnz = iZeilenAnz + 1
'      Set rgZelle = rgZelle.Offset(1, 0)
'    Loop
    Set rgZelle = rgStart.End(xlDown)
    If (Len(rgZelle) > 0) And (Len(rgZelle.Offset(-1, 0)) > 0) Then
      iZeilenAnz = Range(rgStart, rgZelle).Rows.Count
    Else
      iZeilenAnz = 1
    End If
  End If
  
  'Erste Zeile enthaelt Titel
  If boTitelZeile Then
    'Start um eine Zeile nach unten schieben
    Set rgStart = rgStart.Offset(1, 0)
    '...wodurch sich die effektiven Zeilen verringern!
    iZeilenAnz = iZeilenAnz - 1
  End If
  
  If (iZeilenAnz > 0) And (iSpaltenAnz > 0) Then
    'Gefundenen Bereich zurueckgeben
    Set SelectRange = Range(rgStart, rgStart.Offset(iZeilenAnz - 1, iSpaltenAnz - 1))
  Else
    Set SelectRange = rgStart
  End If
  
  Set rgZelle = Nothing
  
End Function 'SelectRange

'--------------------------------------------------------------------------------------------------
Public Function MoveRange(ByVal rgStart As Range, _
                          ByVal lDirection As Long) As Range

Dim rgZelle As Range

  'Die Ursache eines Fehlers werden ignoriert...
  '(Tritt auf, wenn Offset() die Tabelle verlaesst!)
  On Error Resume Next

  Call BugAssert(Not rgStart Is Nothing, "rgStart is nothing", "M_Tools::SelectRange")
  
  If Len(rgStart.Text) > 0 Then
    Select Case lDirection
      Case xlDown
        Set rgZelle = rgStart.Offset(1, 0)
      Case xlToLeft
        Set rgZelle = rgStart.Offset(0, -1)
      Case xlToRight
        Set rgZelle = rgStart.Offset(0, 1)
      Case xlUp
        Set rgZelle = rgStart.Offset(-1, 0)
    End Select
  
  Else
    
    Select Case lDirection
      Case xlDown
        Set rgZelle = rgStart.End(xlDown)
      Case xlToLeft
        Set rgZelle = rgStart.End(xlToLeft)
      Case xlToRight
        Set rgZelle = rgStart.End(xlToRight)
      Case xlUp
        Set rgZelle = rgStart.End(xlUp)
    End Select
    
  End If
    
  If rgZelle Is Nothing Then
    Set MoveRange = Nothing
  Else
    If rgZelle.Address = rgStart.Address Then
      Set MoveRange = Nothing
    Else
      If Len(rgZelle.Text) > 0 Then
        Set MoveRange = rgZelle
      Else
        Set MoveRange = MoveRange(rgZelle, lDirection)
      End If
    End If
    Set rgZelle = Nothing
  End If

End Function

'---------------------------------------------------------------------------------------------------
'  gibt den Inhalt einer Zelle als long zurueck.
'  wenn das nicht moeglich ist, wird der Default- Wert zurueckgegeben
Public Function RangeToLng(rg As Range, Optional lDefault = 0) As Long
    
    If IsEmpty(rg) Or Not IsNumeric(rg) Then
      RangeToLng = lDefault
    Else
      RangeToLng = CLng(rg)
    End If

End Function

'---------------------------------------------------------------------------------------------------
'  gibt den Inhalt einer Zelle als double zurueck.
'  wenn das nicht moeglich ist, wird der Default- Wert zurueckgegeben
'  TFS 13794 WOKL 23.11.16 neu
Public Function RangeToDbl(rg As Range, Optional lDefault = 0#) As Double
    
    If IsEmpty(rg) Or Not IsNumeric(rg) Then
      RangeToDbl = lDefault
    Else
      RangeToDbl = CDbl(rg)
    End If

End Function

'---------------------------------------------------------------------------------------------------
Public Function StatusText(Optional ByVal lID As Long = 0) As String

  Call InitArray(masStatusText)

  If lID = 0 Then
    lID = UBound(masStatusText)
  End If

  If lID <= UBound(masStatusText) Then
    StatusText = masStatusText(lID)
  Else
    StatusText = ""
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Function StatusTextAusgeben(ByVal sText As String, _
                                   Optional ByVal lID As Long = 0) As Long
  Call InitArray(masStatusText)

  If lID = 0 Then
    lID = UBound(masStatusText) + 1
    ReDim Preserve masStatusText(lID)
  ElseIf lID > UBound(masStatusText) Then
    ReDim Preserve masStatusText(lID)
  End If

  masStatusText(lID) = sText
  Application.StatusBar = sText
  StatusTextAusgeben = lID
  
End Function

'---------------------------------------------------------------------------------------------------
Public Sub InitArray(ByRef avArray As Variant)

Dim i As Integer
  On Error GoTo InitArray_Fehler
  i = UBound(avArray)
Exit Sub
InitArray_Fehler:
  ReDim avArray(0)
End Sub

'---------------------------------------------------------------------------------------------------
Public Function StatusTextLoeschen(ByVal lID As Long) As String

  Call InitArray(masStatusText)

  If lID <= 1 Then
    ReDim masStatusText(0)
    StatusTextLoeschen = ""
    Application.StatusBar = False
  ElseIf lID <= UBound(masStatusText) Then
    StatusTextLoeschen = masStatusText(lID)
    Application.StatusBar = masStatusText(lID - 1)
    ReDim Preserve masStatusText(lID - 1)
  Else
    StatusTextLoeschen = ""
    Application.StatusBar = False
  End If

End Function

'--------------------------------------------------------------------------------------------------
'Bezeichung sollte besser in den benutzerdefinierten Dateiinfo's untergebracht werden - geht
'nur leider nicht :o|
'--------------------------------------------------------------------------------------------------
Public Function ProjektBezeichnung() As String
  ProjektBezeichnung = PROJEKT_BEZEICHNUNG
End Function

'--------------------------------------------------------------------------------------------------
'Autor sollte besser in den benutzerdefinierten Dateiinfo's untergebracht werden - geht
'nur leider nicht :o|
'--------------------------------------------------------------------------------------------------
Public Function ProjektAutor() As String
  ProjektAutor = PROJEKT_AUTOR
End Function

'--------------------------------------------------------------------------------------------------
'Versionsinfo sollte besser in den benutzerdefinierten Dateiinfo's untergebracht werden - geht
'nur leider nicht :o|
'--------------------------------------------------------------------------------------------------
Public Function ProjektVersion() As String
  ProjektVersion = PROJEKT_VERSION
End Function

'--------------------------------------------------------------------------------------------------
'Public Function ProjektKennwort() As String
'  ProjektKennwort = PROJEKT_KENNWORT
'End Function

'--------------------------------------------------------------------------------------------------
Public Function ProjektDatei() As String
  'ProjektDatei = Application.VBE.ActiveVBProject.Name
  ProjektDatei = ThisWorkbook.Name
End Function

'--------------------------------------------------------------------------------------------------
Public Function ProjektPfad() As String
  ProjektPfad = ThisWorkbook.Path
End Function

'--------------------------------------------------------------------------------------------------
Public Function HostName() As String

Dim lpBuffer    As String
Dim nSize       As Long
Dim lErrorCode  As Long
Dim sHostName   As String

  nSize = 255
  lpBuffer = String(255, " ")
  lErrorCode = GetComputerName(lpBuffer, nSize)
  If lErrorCode = 1 Then
    sHostName = Left$(lpBuffer, nSize)
    If Asc(Right$(sHostName, 1)) < 32 Then
      sHostName = Left$(sHostName, Len(sHostName) - 1)
    End If
  Else
    'TODO: Fehlermeldung generieren
    sHostName = ""
  End If
  HostName = sHostName

End Function

'--------------------------------------------------------------------------------------------------
Public Function Username() As String

Dim lpBuffer    As String
Dim nSize       As Long
Dim lErrorCode  As Long
Dim sUserName   As String

  nSize = 255
  lpBuffer = String(255, " ")
  lErrorCode = GetUserName(lpBuffer, nSize)
  If lErrorCode = 1 Then
    sUserName = Left$(lpBuffer, nSize)
    If Asc(Right$(sUserName, 1)) < 32 Then
      sUserName = Left$(sUserName, Len(sUserName) - 1)
    End If
  Else
    sUserName = ""
  End If
  Username = sUserName

End Function

'--------------------------------------------------------------------------------------------------
Public Function UserFullName() As String

Dim lpBuffer    As String
Dim nSize       As Long
Dim lErrorCode  As Long
Dim sUserName   As String

  nSize = 255
  lpBuffer = String(255, " ")
  lErrorCode = GetUserNameEx(3, lpBuffer, nSize)
  If nSize > 1 Then
    sUserName = Left$(lpBuffer, nSize)
    If Asc(Right$(sUserName, 1)) < 32 Then
      sUserName = Left$(sUserName, Len(sUserName) - 1)
    End If
  Else
    sUserName = ""
  End If
  UserFullName = sUserName

End Function

'---------------------------------------------------------------------------------------------------
Sub NZD(Optional sMeldung As String, Optional sFunktion As String)

  If Len(sMeldung) = 0 Then
    sMeldung = GetResText(21129)
  End If
  Call MsgBox(sMeldung, vbOKOnly + vbInformation, "Achtung " & sFunktion)
  Call BugMessage(sMeldung, sFunktion)
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub OptionSpeichern(ByVal sSektion As String, _
                           ByVal sOption As String, _
                           ByVal sWert As String)
                           
Dim sDatei       As String
Dim lErrorCode   As Long
  
  sWert = Chr(34) & sWert & Chr(34)
  sDatei = ThisWorkbook.Path & "\Report.ini"
  lErrorCode = WritePrivateProfileString(sSektion, _
                                         sOption, _
                                         sWert, _
                                         sDatei)
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Function OptionLaden(ByVal sSektion As String, _
                            ByVal sOption As String) As String

Dim lErrorCode As Long
Dim sDefault   As String
Dim sBuffer    As String
Dim lTextLaenge As Long
Dim sDatei     As String
  
  sDefault = ""
  sBuffer = Space$(255)
  lTextLaenge = 255
  sDatei = ThisWorkbook.Path & "\Report.ini"
  
  lTextLaenge = GetPrivateProfileString(sSektion, _
                                       sOption, _
                                       sDefault, _
                                       sBuffer, _
                                       lTextLaenge, _
                                       sDatei)
  If lTextLaenge > 0 Then
    OptionLaden = Left$(sBuffer, lTextLaenge)
  Else
    OptionLaden = ""
  End If
  
End Function

'------------------------------------------------------------------------------
Public Function TextErsetzen(ByVal sQuelle As String, _
                             ByVal sSuchText As String, _
                             Optional ByVal sErsatzText As String = "") As String

Dim iPos      As Integer
Dim sErgebnis As String

  iPos = InStr(1, sQuelle, sSuchText)
  While (iPos > 0)
  
    sErgebnis = sErgebnis & Left$(sQuelle, iPos - 1) & sErsatzText
    sQuelle = Mid$(sQuelle, iPos + Len(sSuchText), Len(sQuelle) - iPos)
    iPos = InStr(1, sQuelle, sSuchText)
    
  Wend

  If Len(sErgebnis) = 0 Then
    TextErsetzen = sQuelle
  Else
    TextErsetzen = sErgebnis & sQuelle
  End If

End Function
                        
'------------------------------------------------------------------------------
Public Sub ArrayToStr(ByRef sErgebnis As String, _
                      ByRef asQuelle() As String, _
                      Optional ByVal sTrennZeichen As String = ";")
                      
Dim n As Long
  
  sErgebnis = ""
  For n = 1 To UBound(asQuelle) - 1
    sErgebnis = sErgebnis & asQuelle(n) & sTrennZeichen
  Next n
  sErgebnis = sErgebnis & asQuelle(UBound(asQuelle))

End Sub

'------------------------------------------------------------------------------
Public Sub StrToArray(ByRef asErgebnis() As String, _
                      ByVal sQuelle As String, _
                      Optional ByVal sTrennZeichen As String = ";")

Dim iErgId  As Integer
Dim iPos    As Integer

  iErgId = 0
  ReDim asErgebnis(iErgId)
  
  iPos = InStr(1, sQuelle, sTrennZeichen)
  While (iPos > 0)
    
    iErgId = iErgId + 1
    ReDim Preserve asErgebnis(iErgId)
    asErgebnis(iErgId) = Left$(sQuelle, iPos - 1)
    
    sQuelle = Mid$(sQuelle, iPos + Len(sTrennZeichen), Len(sQuelle) - iPos)
    iPos = InStr(1, sQuelle, sTrennZeichen)
  
  Wend
  
  If Len(sQuelle) > 0 Then
    iErgId = iErgId + 1
    ReDim Preserve asErgebnis(iErgId)
    asErgebnis(iErgId) = sQuelle
  End If
                      
End Sub

'------------------------------------------------------------------------------
Public Sub StrAppend(ByRef asErgebnis() As String, _
                     ByRef sQuelle As String)
  
Dim n As Long
  
  'Der einzige moegliche Fehler ist ein nicht initialisiertes Feld
  'Da aber sowieso ein Element angehaengt wird, kann der Fehler
  'ignoriert werden. Index darf daher aber nicht inkrementiert werden!
  On Error Resume Next
  
  n = UBound(asErgebnis)
  ReDim Preserve asErgebnis(n + 1)
  asErgebnis(n + 1) = sQuelle
  
End Sub
'------------------------------------------------------------------------------
Public Function Zufallszahl(lAnfang As Long, lEnde As Long) As Long

Static boZufallInit As Boolean

  If Not boZufallInit Then
    Randomize
    boZufallInit = True
  End If
  Zufallszahl = CLng((lEnde - lAnfang) * Rnd + lAnfang)
  
End Function

'------------------------------------------------------------------------------
Public Sub StrSwap(sFirst As String, sLast As String)
Dim sTmp
  sTmp = sFirst
  sFirst = sLast
  sLast = sTmp
End Sub

'------------------------------------------------------------------------------
Public Sub StrSort(ByRef asQuelle() As String, _
                   Optional vFirst As Variant, _
                   Optional vLast As Variant)

Dim sTmp As String
Dim lFirst As Long
Dim lLast As Long
Dim lLo  As Long
Dim lHi  As Long
Dim lTmp As Long

  If IsMissing(vFirst) Then lFirst = LBound(asQuelle) Else lFirst = vFirst
  If IsMissing(vLast) Then lLast = UBound(asQuelle) Else lLast = vLast
  
  If lFirst < lLast Then
  
    If lLast - lFirst = 1 Then
    
      If StrComp(asQuelle(lFirst), asQuelle(lLast)) > 0 Then
      
        Call StrSwap(asQuelle(lFirst), asQuelle(lLast))
      
      End If
    
    Else
    
      lTmp = Zufallszahl(lFirst, lLast)
      Call StrSwap(asQuelle(lLast), asQuelle(lTmp))
      
      lLo = lFirst
      lHi = lLast
      
      Do
      
        Do While (lLo < lHi) And (StrComp(asQuelle(lLo), asQuelle(lLast)) <= 0)
          lLo = lLo + 1
        Loop
        Do While (lHi > lLo) And (StrComp(asQuelle(lHi), asQuelle(lLast)) >= 0)
          lHi = lHi - 1
        Loop
        
        If lLo < lHi Then Call StrSwap(asQuelle(lHi), asQuelle(lLo))
      
      Loop While lLo < lHi
      
      Call StrSwap(asQuelle(lHi), asQuelle(lLast))
    
      If (lLo - lFirst) < (lLast - lLo) Then
        Call StrSort(asQuelle, lFirst, lLo - 1)
        Call StrSort(asQuelle, lLo + 1, lLast)
      Else
        Call StrSort(asQuelle, lLo + 1, lLast)
        Call StrSort(asQuelle, lFirst, lLo - 1)
      End If
    End If
  
  End If

End Sub

'------------------------------------------------------------------------------
Public Function Aufrunden(fWert As Single) As Long

Dim lErgebnis As Long

  lErgebnis = CLng(fWert)
  If lErgebnis - fWert < 0 Then
    Aufrunden = lErgebnis + 1
  Else
    Aufrunden = lErgebnis
  End If

End Function

'------------------------------------------------------------------------------
Public Function Abrunden(fWert As Single) As Long

Dim lErgebnis As Long

  lErgebnis = CLng(fWert)
  If lErgebnis - fWert <= 0 Then
    Abrunden = lErgebnis
  Else
    Abrunden = lErgebnis - 1
  End If

End Function

'------------------------------------------------------------------------------
Public Function ElementN(ByVal sQuelle As String, _
                         ByVal iElement As Integer, _
                         Optional ByVal sTrennZeichen As String = ";") As String


Dim iPos      As Integer
Dim sElement  As String

  iPos = InStr(1, sQuelle, sTrennZeichen)
  While ((iPos > 0) And (iElement > 0))

    iElement = iElement - 1
    sElement = Left$(sQuelle, iPos - 1)
    
    sQuelle = Mid$(sQuelle, iPos + Len(sTrennZeichen), Len(sQuelle) - iPos)
    iPos = InStr(1, sQuelle, sTrennZeichen)

  Wend

  If iElement = 0 Then
    ElementN = sElement
  ElseIf iElement = 1 Then
    ElementN = sQuelle
  Else
    ElementN = ""
  End If

End Function

'------------------------------------------------------------------------------
Public Function ListeErstellen(rgWerte As Range, _
                               Optional sTrennZeichen As String = ";", _
                               Optional boLeereZellen As Boolean = False _
                               ) As String

Dim sListe As String
Dim rgZelle As Range

  If Len(sTrennZeichen) > 1 Then
    'sTrennZeichen = Left(sTrennZeichen, 1)
  End If

  For Each rgZelle In rgWerte
    If rgZelle.value <> "" Or boLeereZellen Then
      sListe = sListe & rgZelle.value & sTrennZeichen
    End If
  Next rgZelle

  If Right(sListe, Len(sTrennZeichen)) = sTrennZeichen Then
    sListe = Left(sListe, Len(sListe) - Len(sTrennZeichen))
  End If
  ListeErstellen = sListe

End Function

'------------------------------------------------------------------------------
Public Sub CodeExport()

'Dim iKompTyp As Integer
'Dim iKompId  As Integer
'Dim iKompAnz As Integer
'Dim sDatei   As String
'
'  If Not CBool(SetCurrentDirectory(ProjektPfad() & "\Module")) Then
'    Call MkDir(ProjektPfad() & "\Module")
'  End If
'
'  With Application.VBE.ActiveVBProject.VBComponents
'    iKompAnz = .Count
'    For iKompId = 1 To iKompAnz
'      iKompTyp = .Item(iKompId).Type
'
'      sDatei = ""
'      Select Case iKompTyp
'        Case vbext_ComponentType.vbext_ct_ClassModule
'          sDatei = ProjektPfad() & "\Module\" & .Item(iKompId).Name & ".cls"
'        Case vbext_ComponentType.vbext_ct_MSForm
'          sDatei = ProjektPfad() & "\Module\" & .Item(iKompId).Name & ".frm"
'        Case vbext_ComponentType.vbext_ct_StdModule
'          sDatei = ProjektPfad() & "\Module\" & .Item(iKompId).Name & ".bas"
'      End Select
'
'      If Len(sDatei) > 0 Then
'        .Item(iKompId).Export (sDatei)
'        Call BugMessage("Komponente " & .Item(iKompId).Name & " exportiert", "CodeExport")
'      End If
'
'    Next iKompId
'  End With
  

End Sub

'---------------------------------------------------------------------------------------------------
Sub MakroListe()

'Const FUNKTIONEN = False
'
'Dim oModul        As VBComponent
'Dim asModulTyp()  As String
'Dim iModulTypID   As Integer
'
'Dim asModul()     As String
'Dim iModulID      As Integer
'
'Dim sProc         As String
'Dim asProc()      As String
'Dim iProcID       As Integer
'
'Dim i As Integer
'Dim r As Integer
'Dim c As Integer
'
'  ReDim asModulTyp(4)
'  asModulTyp(1) = vbext_ct_Document
'  asModulTyp(2) = vbext_ct_MSForm
'  asModulTyp(3) = vbext_ct_StdModule
'  asModulTyp(4) = vbext_ct_ClassModule
'
'  Workbooks.Add
'  Cells.Clear
'  c = 1
'
'  For iModulTypID = 1 To UBound(asModulTyp)
'
'    ReDim asModul(0)
'    r = 8
'    'Cells(1, c).EntireColumn.Width = 70
'
'    For Each oModul In ThisWorkbook.VBProject.VBComponents
'
'      If oModul.Type = asModulTyp(iModulTypID) Then
'
'          iModulID = UBound(asModul) + 1
'          ReDim Preserve asModul(iModulID)
'          asModul(iModulID) = oModul.Name
'
'      End If
'    Next oModul
'
'    Call StrSort(asModul, 1)
'
'    For iModulID = 1 To UBound(asModul)
'
'      Set oModul = ThisWorkbook.VBProject.VBComponents(asModul(iModulID))
'
'      If FUNKTIONEN Then
'        r = r + 2
'      Else
'        r = r + 1
'      End If
'      Cells(r, c) = asModul(iModulID)
'      Cells(r, c).Font.Bold = True
'
'      ReDim asProc(0)
'      iProcID = 0
'
'      If FUNKTIONEN Then
'        With oModul.CodeModule
'          For i = 1 To .CountOfLines
'            If .ProcOfLine(i, vbext_pk_Proc) > "" Then
'              sProc = .ProcOfLine(i, vbext_pk_Proc)
'              If sProc <> asProc(iProcID) Then
'                iProcID = iProcID + 1
'                ReDim Preserve asProc(iProcID)
'                asProc(iProcID) = sProc
'              End If
'            End If
'          Next i
'
'          Call StrSort(asProc, 1)
'          For i = 1 To UBound(asProc)
'            r = r + 1
'            Cells(r, c + 1) = asProc(i)
'          Next i
'
'        End With
'      End If
'
'    Next iModulID
'
'    If FUNKTIONEN Then
'      Cells(1, c + 1).EntireColumn.AutoFit
'      c = c + 3
'    Else
'      Cells(1, c).EntireColumn.AutoFit
'      c = c + 1
'    End If
'
'  Next iModulTypID

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub ZeitMessung(boStart As Boolean, Optional sText As String)

Static lStart As Long
Dim lLaufzeit As Long

  If boStart Then
    lStart = GetTickCount
  Else
    lLaufzeit = GetTickCount - lStart
    Call BugMessage("Zeitdauer " & Format(lLaufzeit, "#,##0") & " ms", sText)
    lStart = 0
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Hotlink_Erstellen(rgDDE As Range, _
                              sHost As String, _
                              bDDENr As Byte, _
                              sDP As String, _
                              sKonfig As String)

Dim sHotLink  As String
Dim boDDEOK   As Boolean

Dim dtTimeOut   As Single
Dim dtTimeStart As Single
Dim boTimeOut   As Boolean

Const DDE_TIME_OUT = 10

  'DDE als Hotlink in der Zelle rgDDE erstellen
  sHotLink = "='\\" & sHost & "\ndde$'|" & _
             "'pvss2_" & bDDENr & "$'!" & _
             "'" & sDP & ":" & sKonfig & "'"
  rgDDE = sHotLink

  dtTimeStart = Timer
  dtTimeOut = DDE_TIME_OUT
  Do
    DoEvents
    rgDDE.Calculate
    
    'Mitternachtskorrektur
    If Timer < dtTimeStart Then
      dtTimeOut = dtTimeOut - 86400
    End If
    
    'TimeOut ueberpruefung
    boTimeOut = (Timer - dtTimeOut) > dtTimeStart
    
    boDDEOK = Not IsError(rgDDE)
    
  Loop Until (boTimeOut Or boDDEOK)

  If Not boDDEOK Then
    Err.Raise 101, "M_Tools::Hotlink_Erstellen", _
              "DDE Hotlink konnte nicht erstellt werden"
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub DDE_Verbindung()

'Dim rgDDE As Range
'
'Dim iFehlerBehandlung As Integer
'
'  On Error GoTo DDE_Verbindung_Fehler
'
'  Set rgDDE = TabKonfig.Range(REF_REPORT_BEFEHL)
'  Call Hotlink_Erstellen(rgDDE, HOSTNAME_1, DDE_1, DP_REPORT_BEFEHL, "_online.._value")
'
'  Set rgDDE = TabKonfig.Range(REF_REPORT_RM)
'  Call Hotlink_Erstellen(rgDDE, HOSTNAME_1, DDE_1, DP_REPORT_RM, "_online.._value")
'
'  Set rgDDE = TabKonfig.Range(REF_PVSS_BEFEHL)
'  Call Hotlink_Erstellen(rgDDE, HOSTNAME_1, DDE_1, DP_PVSS_BEFEHL, "_online.._value")
'
'  Set rgDDE = TabKonfig.Range(REF_PVSS_RM)
'  Call Hotlink_Erstellen(rgDDE, HOSTNAME_1, DDE_1, DP_PVSS_RM, "_online.._value")
'
'Exit Sub
'DDE_Verbindung_Fehler:
'
'  Call BugMessage(Err.Description & " " & Err.Number - vbObjectError, _
'                  "M_PVSS::DDE_Verbindung")
'
'  iFehlerBehandlung = MsgBox(Err.Description, _
'                             vbAbortRetryIgnore + vbExclamation, _
'                             "Fehler Nr " & Err.Number)
'
'  Select Case iFehlerBehandlung
'
'    Case vbAbort
'      Exit Sub
'
'    Case vbRetry
'      Resume 0
'
'    Case vbIgnore
'      Resume Next
'
'  End Select
'
End Sub

'------------------------------------------------------------------------------
Public Sub FormularBeschriften(oForm As Object)

Dim oCtrl     As Control
Dim lResID    As Long
Dim txt As String

  On Error Resume Next
  
  If oForm.Tag <> "" Then
    lResID = CLng(oForm.Tag)
    txt = GetResText(lResID)
    If txt <> "*DEFAULT*" Then
      oForm.Caption = txt
    End If
  End If

  For Each oCtrl In oForm.Controls
    lResID = 0
    If oCtrl.Tag <> "" Then
      lResID = CLng(oCtrl.Tag)
    End If
    If lResID > 0 Then
    
      Select Case TypeName(oCtrl)
      
        Case "ListBox", "ComboBox", "Calendar"
          
        Case "TextBox"
          txt = GetResText(lResID)
          If txt <> "*DEFAULT*" Then
            oCtrl.Text = txt
          End If
          
        Case Else
          
          txt = GetResText(lResID)
          'MsgBox ("Tag = " + oCtrl.Tag + ", txt = " + txt)
          If txt <> "*DEFAULT*" Then
            oCtrl.Caption = txt
          End If
          
      End Select
    End If
  Next oCtrl
  
End Sub

'------------------------------------------------------------------------------
Public Function GetResText(lResID As Long, Optional boErrSource As Boolean = False) As String

Static avRes      As Variant
Dim rgRes         As Range
Dim rgText        As Range
'Dim i             As Long
Dim l As Long 'Linke Seite
Dim r As Long 'Rechte Seite
Dim x As Long 'Vergleich

  If IsEmpty(avRes) Then
    avRes = SelectRange(TabResText.Range("A1"), , True)
  End If
  
  l = 1
  r = UBound(avRes)
  While r >= l
    x = (l + r) / 2
    If lResID = avRes(x, 1) Then
      If Not boErrSource Then
        GetResText = Trim(avRes(x, M_Optionen.getSpracheID + 2))
      Else
        GetResText = Trim(avRes(x, 2))
      End If
      Exit Function
    End If
    If lResID < avRes(x, 1) Then
      r = x - 1
    Else
      l = x + 1
    End If
  Wend
  
'  For i = 1 To UBound(avRes)
'    If avRes(i, 1) = lResID Then
'      GetResText = Trim(avRes(i, M_Optionen.getSpracheID + 2))
'      Exit Function
'    End If
'  Next i
  
  GetResText = "Text #" & lResID & " not found!"
  
End Function

'------------------------------------------------------------------------------
Public Sub ProtDatenImport()

Dim lReturnCode As Long
Dim sDatei          As String  'Die Datei, die importiert werden soll
Dim sPfad           As String
Dim iDateiNr        As Integer 'Dateinr, die geoeffnet werden soll
Dim sDateiZeile     As String  'Eine Zeile aus der Datei
Dim asInhaltZeile() As String  'Der Inhalt einer Zeile aus der Datei
Dim asZeileNr()     As Integer '
Dim iInhaltZeileId  As Integer 'Index der Zeile
Dim rgImport        As Range
Dim iZeile          As Integer
Dim iFehlerBehandlung As Integer
Dim rgWerte As Range
Dim wsBlatt         As Worksheet
Dim sTrennZeichen As String

  On Error GoTo ProtDatenImport_Fehler

  'Trennzeichen ermitteln
  sTrennZeichen = Chr(9)
  
  'Pfad und Namen der Textdatei ermitteln
  sPfad = "Q:\PVSS\SwB\DATA\XLS_Report"
  sDatei = sPfad & "\" & "osProtDaten.csv"
  
  ChDrive sPfad
  ChDir sPfad
  
  If Len(Dir(sDatei)) > 0 Then
  
    ReDim asZeileNr(10)
    asZeileNr(1) = 0  'DP Nr - wird nicht benoetigt
    asZeileNr(2) = 2  'DPName
    asZeileNr(3) = 3  'DPType
    asZeileNr(4) = 4  'DPFkt
    asZeileNr(5) = 7  'Min Berechnen?
    asZeileNr(6) = 8  'Max Berechnen?
    asZeileNr(7) = 9  'Mittelwert berechnen?
    asZeileNr(8) = 10 'Summe berechnen?
    asZeileNr(9) = 21 'Kommentar
    asZeileNr(10) = 22 'Einheit
    
    Set rgImport = ActiveWindow.ActiveCell
    iZeile = rgImport.Row
    
    iDateiNr = FreeFile
    Open sDatei For Input As #iDateiNr
  
    While (Not EOF(iDateiNr))
  
      Line Input #iDateiNr, sDateiZeile
      Call StrToArray(asInhaltZeile, sDateiZeile, sTrennZeichen)
      If UBound(asInhaltZeile) = UBound(asZeileNr) Then
        For iInhaltZeileId = 1 To UBound(asInhaltZeile)
          If asZeileNr(iInhaltZeileId) > 0 Then
            rgImport.Offset(asZeileNr(iInhaltZeileId) - iZeile, 0) = asInhaltZeile(iInhaltZeileId)
          End If
        Next iInhaltZeileId
      End If
      Set rgImport = rgImport.Offset(0, 1)
      
    Wend
  
    Close #iDateiNr
  
  End If
  
Exit Sub
ProtDatenImport_Fehler:
  
  iFehlerBehandlung = MsgBox(Err.Description, _
                             vbAbortRetryIgnore + vbExclamation, _
                             "Fehler Nr " & Err.Number)
  
  Select Case iFehlerBehandlung
    
    Case vbAbort
      Exit Sub
    
    Case vbRetry
      Resume 0
    
    Case vbIgnore
      Resume Next
  
  End Select
  
End Sub

'------------------------------------------------------------------------------
'CGDate
'Oliver Seidel 11.01.2000
'
'Wandelt ein Datum/Uhrzeit in einem String in den Datentyp Date um, unabhaengig
'von der jeweiligen Laendereinstellung des Systems. Format des Strings:
'[TT.MM.JJ[JJ]] [hh:mm[:ss]]
'------------------------------------------------------------------------------
Public Function CGDate(ByVal sGermanDate As String) As Date

Dim iTag      As Integer
Dim iMonat    As Integer
Dim iJahr     As Integer
Dim iStunde   As Integer
Dim iMinute   As Integer
Dim iSekunde  As Integer

Dim sDatum    As String
Dim iPos      As Integer

Static sFormat  As String
  
  iPos = InStr(1, sGermanDate, ".")
  If iPos > 0 Then
    iTag = Left(sGermanDate, 2)
    iMonat = Mid(sGermanDate, 4, 2)
    iPos = InStr(1, sGermanDate, " ")
    If iPos = 0 Then iPos = Len(sGermanDate)
    iJahr = Mid(sGermanDate, 7, Len(sGermanDate) - iPos - 4)
    sGermanDate = Right(sGermanDate, Len(sGermanDate) - iPos)
  End If
  
  iPos = InStr(1, sGermanDate, ":")
  If iPos > 0 Then
    iStunde = Left(sGermanDate, 2)
    iMinute = Mid(sGermanDate, 4, 2)
    If Len(sGermanDate) > 6 Then
      iSekunde = Mid(sGermanDate, 7, 2)
    End If
  End If
  
  If Len(sFormat) = 0 Then
    sFormat = Format(#12/31/1999#, "Short Date") & " " & _
              Format(#11:59:42 PM#, "Long Time")
    sFormat = TextErsetzen(sFormat, "31", "TT")
    sFormat = TextErsetzen(sFormat, "12", "MM")
    sFormat = TextErsetzen(sFormat, "1999", "JJJJ")
    sFormat = TextErsetzen(sFormat, "99", "JJJJ")
    sFormat = TextErsetzen(sFormat, "23", "hh")
    sFormat = TextErsetzen(sFormat, "11", "hh")
    sFormat = TextErsetzen(sFormat, "59", "mm")
    sFormat = TextErsetzen(sFormat, "42", "ss")
    If InStr(1, sFormat, " PM") > 0 Then
      sFormat = Left(sFormat, Len(sFormat) - 3)
    End If
  End If
  
  sDatum = TextErsetzen(sFormat, "TT", iTag)
  sDatum = TextErsetzen(sDatum, "MM", iMonat)
  sDatum = TextErsetzen(sDatum, "JJJJ", iJahr)
  sDatum = TextErsetzen(sDatum, "hh", iStunde)
  sDatum = TextErsetzen(sDatum, "mm", iMinute)
  sDatum = TextErsetzen(sDatum, "ss", iSekunde)
  
  If IsDate(sDatum) Then
    CGDate = CDate(sDatum)
  Else
    CGDate = 0
  End If
  
End Function

'------------------------------------------------------------------------------
'DIN_KW
'Oliver Seidel 25.03.2002
'
'Gibt die Kalenderwoche des Datum nach DIN 1355 zurueck.
'1.KW = die, die den ersten Donnerstag des Jahres enthaelt!
'------------------------------------------------------------------------------
Function DIN_KW(d As Date) As Integer

Dim t As Long

  t = DateSerial(Year(d + (8 - weekday(d)) Mod 7 - 3), 1, 1)
  DIN_KW = (d - t - 3 + (weekday(t) + 1) Mod 7) \ 7 + 1

' Oder eine andere Variante, die im Internet kursiert
' .... aber komplizierter als notwendig
'Dim i As Integer
'
'  i = Int((d - DateSerial(Year(d), 1, 1) + _
'      ((WeekDay(DateSerial(Year(d), 1, 1)) + 1) Mod 7) - 3) / 7) + 1
'  If i = 0 Then
'    i = DIN_KW(DateSerial(Year(d) - 1, 12, 31))
'  ElseIf i = 53 And (WeekDay(DateSerial(Year(d), 12, 31)) - 1) Mod 7 <= 3 Then
'    i = 1
'  End If
'  DIN_KW = i
End Function

'------------------------------------------------------------------------------
'colorToRGB
'Oliver Seidel 22.05.2002
'
'Wandelt den long Wert lColor in die Bestandteile Rot, Gruen und Blau um.
'Reverse Funktion zu RGB(..)
'------------------------------------------------------------------------------
Public Sub colorToRGB(ByVal lColor As Long, iRed As Integer, iGreen As Integer, iBlue As Integer)

Dim n As Long
Dim s As String
  
  s = Hex(lColor)
  s = String(6 - Len(s), "0") & s
  iRed = val("&H" & Mid(s, 5, 2))
  iGreen = val("&H" & Mid(s, 3, 2))
  iBlue = val("&H" & Mid(s, 1, 2))
'und das alles nur weil es "richtig" nicht geht
'/* grumpfh */
'  n = lColor And &HFF
'  iRed = n
'  n = (lColor And &HFF00)
'  iGreen = n / 256
'  n = (lColor And &HFF0000)
'  iBlue = n / (256 ^ 2)

End Sub

Sub displayMenuItems()

Dim Menue     As CommandBarControl
Dim cmdCtrl   As CommandBarControl
Dim cmdCtrl2  As CommandBarControl

  'Menueeintraege ausgeben
  For Each Menue In CommandBars("Worksheet Menu Bar").Controls
    Debug.Print Menue.Caption, Menue.ID
  Next Menue
    
  Set Menue = Application.CommandBars("Worksheet Menu Bar").FindControl(ID:=30010)
  If Not Menue Is Nothing Then
    For Each cmdCtrl In Menue.Controls
      Debug.Print cmdCtrl.Caption, cmdCtrl.ID
    Next cmdCtrl
  End If

End Sub
    
Sub tstShape()

Dim ws As Worksheet
Dim shape As shape
Dim sNewName As String

  Set ws = ActiveSheet
  sNewName = "SelizioneRapida"
  
  For Each shape In ws.Shapes
    'shape
    Debug.Print shape.Name
    If InStr(1, shape.Name, "SelezioneRapida") > 0 Then
      Call shape.zOrder(msoSendToBack)
      Call shape.zOrder(msoBringToFront)
      shape.Name = sNewName
    End If
  Next shape

  'Set shape = ws.Shapes(sNewName)
  'Call shape.ZOrder(msoSendToBack)
  'Call shape.ZOrder(msoBringToFront)

End Sub

Public Sub getViewText()

Dim vwTEST As Object

'  Set vwTEST = New V_Option
'  Call getCtrlText(vwTEST, 8100)
'
'  Set vwTEST = New V_Passwd
'  Call getCtrlText(vwTEST, 8200)
'
'  Set vwTEST = New V_ColHide
'  Call getCtrlText(vwTEST, 8300)
'
'  Set vwTEST = New V_TextFile
'  Call getCtrlText(vwTEST, 8400)
  
  Set vwTEST = New V_DP
  Call getCtrlText(vwTEST, 17400, False)
  
  Set vwTEST = Nothing

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub getCtrlText(oForm As Object, lResIDOffset As Long, boAll As Boolean)

Dim oCtrl   As Control
Dim rgZiel  As Range
Dim lResID    As Long
Dim lResIDAlt As Long

  On Error Resume Next

  Set rgZiel = ActiveCell
  lResID = lResIDOffset
  lResIDAlt = lResIDOffset

  rgZiel = lResID
  rgZiel.Offset(0, 1) = oForm.Name
  rgZiel.Offset(0, 2) = oForm.Caption
  rgZiel.Offset(0, 3) = "Formular"
  
  For Each oCtrl In oForm.Controls
    lResID = 0
    If oCtrl.Tag <> "" Then
      lResID = CLng(oCtrl.Tag)
    End If
    If lResID <= 0 Then
      lResID = lResIDAlt + 1
    End If
    
    Select Case TypeName(oCtrl)
    
      Case "ListBox", "ComboBox"
        If boAll Then
          Set rgZiel = rgZiel.Offset(1, 0)
          rgZiel = lResID
          rgZiel.Offset(0, 1) = oCtrl.Name
          rgZiel.Offset(0, 3) = TypeName(oCtrl)
          lResIDAlt = lResID
        End If
      Case "TextBox"
        If boAll Then
          Set rgZiel = rgZiel.Offset(1, 0)
          rgZiel = lResID
          rgZiel.Offset(0, 1) = oCtrl.Name
          rgZiel.Offset(0, 2) = oCtrl.Text
          rgZiel.Offset(0, 3) = TypeName(oCtrl)
          lResIDAlt = lResID
        End If
      Case Else
        Set rgZiel = rgZiel.Offset(1, 0)
        rgZiel = lResID
        rgZiel.Offset(0, 1) = oCtrl.Name
        rgZiel.Offset(0, 2) = oCtrl.Caption
        rgZiel.Offset(0, 3) = TypeName(oCtrl)
        lResIDAlt = lResID
    End Select
    
  Next oCtrl
  
  rgZiel.Select

End Sub

Public Function cvtUnitToString(IntEinheit As Long) As String

  Select Case IntEinheit
  Case erSekunde
    cvtUnitToString = "sec"
  Case erMinute
    cvtUnitToString = "min"
  Case erStunde
    cvtUnitToString = "hour"
  Case erTag
    cvtUnitToString = "day"
  Case erWoche
    cvtUnitToString = "week"
  Case erMonat
    cvtUnitToString = "month"
  Case erJahr
    cvtUnitToString = "year"
  Case Else
    Call MsgBox("M_Tools.cvtUnitToString: illegal parameter: " & Str(IntEinheit))    ' Fehler
  End Select

End Function

Public Function rdbCompressionDetail(IntEinheit As Long, Intervall As Long, ArchivFkt As String) As String

Dim unit As String

  unit = cvtUnitToString(IntEinheit)
  rdbCompressionDetail = "_" & Trim(Str(Intervall)) & unit & "_" & LCase(ArchivFkt)
  
End Function



Attribute VB_Name = "M_Vorlage"
'==================================================================================================
'M_Vorlage
'Oliver Seidel 07.08.2000
'
'Fachklasse fuer die Bearbeitung von Vorlagen. Funktionen, die speziell fuer die einzelnen Protkoll-
'formate sind, werden an die entsprechenden Fachklassen delegiert. Gemeinsame Funktionen werden
'ausschliesslich hier zusammen gefasst.
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module

'--------------------------------------------------------------------------------------------------
'Erstellen
'Oliver Seidel 07.08.2000
'
'Erstellt eine neue Vorlage fuer das Protkollformat.
'
'Aenderungen: -keine-
'--------------------------------------------------------------------------------------------------
Public Sub Neu(sProtFormat As String)

Dim wbProtVorlage As Workbook   'Vorlage fuer die Vorlage :o)
Dim tabKonfig     As Worksheet  'Tabelle mit den Einstellungen (Konfig)
Dim sDateiVorlage As String     'Die Datei der Vorlage
Dim lStatus       As Long

  On Error GoTo M_Vorlage_Neu_Fehler
  lStatus = StatusTextAusgeben(GetResText(21305))
  
  'Jedes Protokollformat hat seine eigen Datei
  Select Case sProtFormat
    Case BEZ_STD_PROTOKOLL: sDateiVorlage = DATEI_STD_VORLAGE
    Case BEZ_BTR_PROTOKOLL: sDateiVorlage = DATEI_BTR_VORLAGE
    Case BEZ_ATV_PROTOKOLL: sDateiVorlage = DATEI_ATV_VORLAGE
    Case BEZ_SQL_PROTOKOLL: sDateiVorlage = DATEI_SQL_VORLAGE
    Case BEZ_KST_PROTOKOLL: sDateiVorlage = DATEI_KST_VORLAGE
    Case Else
      Call NZD(GetResText(21125), "M_Vorlage::Neu")
      Exit Sub
  End Select
  
  'Neue Datei aus der Vorlage erstellen
  On Error Resume Next
  Set wbProtVorlage = Workbooks.Add(ProjektPfad & "\" & sDateiVorlage)
  If wbProtVorlage Is Nothing Then
    Call StatusTextLoeschen(lStatus)
    On Error GoTo 0
    Call FehlerAusloesen(ERR_VORLAGE_ERSTELLEN, ProjektPfad & "\" & sDateiVorlage, True)
  End If
  On Error GoTo M_Vorlage_Neu_Fehler
  
  Set tabKonfig = wbProtVorlage.Worksheets(TAB_KONFIG)
  
  'Version der Vorlage pruefen
  If Left(tabKonfig.Range(REF_DATEI_VERSION), 4) <> Left(ProjektVersion, 4) Then
    Call StatusTextLoeschen(lStatus)
    Call FehlerAusloesen(ERR_VORLAGE_ERSTELLEN, ProjektPfad & "\" & sDateiVorlage, True)
  End If
  'Dateiinfos in der Vorlage speichern
  tabKonfig.Range(REF_DATEI_TYP) = DATEI_VORLAGE
  tabKonfig.Range(REF_DATEI_BEZ) = sProtFormat
  tabKonfig.Range(REF_DATEI_VERSION) = ProjektVersion
  tabKonfig.Visible = xlSheetHidden
      
  Call Konfigurieren
  Call StatusTextLoeschen(lStatus)

Exit Sub
M_Vorlage_Neu_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::Neu")

  If Err.Source <> "UI" Then
    Call MsgBox(Err.Source & Chr(13) & _
                Err.Description, _
                vbOKOnly + vbCritical, _
                GetResText(20104) & " " & Err.Number)
  End If
End Sub 'Neu

'--------------------------------------------------------------------------------------------------
'VersionPruefen
'Oliver Seidel 07.08.2000
'
'Prueft die Version der Vorlage und Konvertiert diese bei Bedarf.
'
'Aenderungen: -keine-
'--------------------------------------------------------------------------------------------------
Public Sub VersionPruefen()

Dim sVersion        As String
Dim iVerHaupt       As Integer
Dim iVerNeben       As Integer
Dim iVerSub         As Integer

Dim tabKonfig       As Worksheet  'Tabelle mit den Einstellungen (Konfig)

Dim s               As String
Dim sProtBez        As String
Dim boAlerts        As Boolean

  On Error GoTo M_Vorlage_VersionPruefen_Fehler

  sVersion = DateiVersion
  s = ElementN(sVersion, 1, ".")
  iVerHaupt = CInt(Right(s, Len(s) - 1))
  iVerNeben = CInt(ElementN(sVersion, 2, "."))
  s = ElementN(sVersion, 3, ".")
  If s <> "" Then
    iVerSub = CInt(s)
  Else
    iVerSub = 0
  End If
  
  'Weitere Verzweigung nach den Versionen und Bearbeitung in den Update-Funktionen
  If iVerHaupt = 1 Then
    Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN, _
                        GetResText(21108), True)
  End If
  
  If iVerHaupt = 2 Then
                        
    If iVerNeben = 0 Then
      Call Update_2_1
      iVerNeben = 1
    End If

    If iVerNeben = 1 Then
      Call Update_2_2(iVerSub)
      iVerNeben = 2
    End If

    If iVerNeben = 2 Then
      Call Update_2_3
      iVerNeben = 3
    End If

    If iVerNeben = 3 Then
      Call Update_2_4
      iVerNeben = 4
    End If
    
    If iVerNeben = 4 Then
      Call Update_3_0
      iVerNeben = 5
    End If

    If iVerNeben <> 5 Then
      Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN, _
                          GetResText(21109), True)
    End If
    iVerHaupt = 3
    iVerNeben = 0

  End If
  
  If iVerHaupt = 3 Then
    If iVerNeben = 0 Then
      'Update auf die Version 3.1.x
      Call Update_3_1
      iVerNeben = 1
    End If
    
    If iVerNeben = 1 Then
      'Update auf die Version 3.2.x
      Call update_3_2
      iVerNeben = 2
    End If
    
    If iVerNeben = 2 Then
      'Update auf die Version 3.3.x
      Call update_3_3
      iVerNeben = 3
    End If
    
    If iVerNeben = 3 Or iVerNeben = 4 Then
      'Update auf die Version 3.4.x
      'Call update_3_4       ' WOKL 7.9.07 derzeit nichts zu tun
      'Call update_3_5       ' WOKL 10.7.09 auch hier nur DB Aenderung, nichts zu tun
      iVerNeben = 5
    End If
    
    If iVerNeben = 5 Then
      'Update auf die Version 3.6.x
      Call update_3_6   ' WOKL 23.4.10 IM 98626 Bereichsberechtigungen
      iVerNeben = 6
    End If
    
    If (iVerNeben = 6) Then
      Call update_3_7   ' WOKL 6.12.10 IM 101313: PowerReport 3.0
      iVerNeben = 7
    End If
    
    If iVerNeben = 7 Then
      iVerNeben = 8   ' IM 102541 sheet offset - no change needed
      iVerSub = 1
    End If
    
    If iVerNeben = 8 And iVerSub = 0 Then ' coming from Patch 3.8.2, that was v3.5.0
      Call update_3_6
      Call update_3_7
      iVerSub = 1
    End If
    
    If iVerNeben = 8 And (iVerSub = 1 Or iVerSub = 3 Or iVerSub = 4 _
                           Or iVerSub = 5 Or iVerSub = 6) Then    ' RDB Compression, nothing changed in templates
      'OK Vorlage ist aktuell
    Else
      Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN, _
                          GetResText(21109), True)
    
    End If
  Else
    Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN, _
                        sProtBez & " " & GetResText(21107), True)
  End If

  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
  tabKonfig.Range(REF_DATEI_VERSION) = ProjektVersion
  
boAlerts = Application.DisplayAlerts
Application.DisplayAlerts = False
  ActiveWorkbook.Styles.Merge ThisWorkbook
Application.DisplayAlerts = boAlerts
  'Formatvorlagen aus der DB in die Vorlage kopieren
  'Call ActiveWorkbook.Styles.Merge(ThisWorkbook)
'  Set coStatusBit = M_StatusBit.coLesen
'  If Not coStatusBit Is Nothing Then
'    For Each oStatusBit In coStatusBit.Items
'      Call M_StatusBit.setStyleInWb(ActiveWorkbook, oStatusBit.Format)
'    Next oStatusBit
'  End If

Exit Sub
M_Vorlage_VersionPruefen_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::VersionPruefen")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Speichern()

Dim vVorlage      As Variant
Dim sVorlage      As String
Dim sVerzeichnis  As String
Dim boDateiNameOK As Boolean
Dim boAbbruch     As Boolean
Dim asTmp()       As String
Dim i As Integer

  On Error GoTo M_Vorlage_Speichern_Fehler

  Call SetCurrentDirectory(ProjektPfad & "\" & VERZ_VORLAGE)
  sVorlage = ActiveWorkbook.Name
  Do
    boAbbruch = False
    boDateiNameOK = False
    'ICSGEAD IM 115373
    vVorlage = Application.GetSaveAsFilename(sVorlage, GetResText(21204) & _
                                            " (*.xltm), *.xltm", , GetResText(21307))
                                            
    If Not IsNumeric(vVorlage) Then
      sVorlage = vVorlage
      If Len(sVorlage) = 0 Then
        boAbbruch = True
      End If
    Else
      boAbbruch = True
    End If

    If Not boAbbruch Then

'Falls im Verzeichnis oder im Dateinamen auf ein "." vorkommt,
'funktioniert es so nicht
'      i = InStr(1, sVorlage, ".")
'      If i = 0 Then i = Len(sVorlage)
'      If IsNumeric(Mid$(asTmp(UBound(asTmp)), i - 1, 1)) Then
'        boDateiNameOK = False
'        Call MsgBox(GetResText(21112), _
'                    vbOKOnly + vbCritical, _
'                    GetResText(20103))
'      Else
'        boDateiNameOK = True
'      End If
'aber so schon...
      i = Len(sVorlage)
      Do While i > 1
        If Mid(sVorlage, i, 1) = "\" Then
          boDateiNameOK = True
          Exit Do
        ElseIf Mid(sVorlage, i, 1) = "." Then
          If IsNumeric(Mid(sVorlage, i - 1, 1)) Then
            boDateiNameOK = False
            Call MsgBox(GetResText(21112), _
                        vbOKOnly + vbCritical, _
                        GetResText(20103))
          Else
            boDateiNameOK = True
          End If
          Exit Do
        End If
        i = i - 1
      Loop

    End If

  Loop Until boDateiNameOK Or boAbbruch

  If boDateiNameOK Then
    'Das Speichern der Vorlage wird in C_Report abgefangen. Die Analyse wird dort initiiert!
    'Call Analysieren
    Call DieseArbeitsmappe.InitAppEvents
    If sVorlage <> (ActiveWorkbook.Path & "\" & ActiveWorkbook.Name) Then
      ' IM 115373 chgd Application.ActiveWorkbook.SaveAs sVorlage, xlTemplate
      Application.ActiveWorkbook.SaveAs sVorlage, xlOpenXMLTemplateMacroEnabled
    Else
      Application.ActiveWorkbook.Save
    End If
  End If
  

Exit Sub
M_Vorlage_Speichern_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::Speichern")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub Nachziehen(Optional boNachfrage As Boolean = True)

Dim sDatei  As String
Dim wbTmp   As Workbook
Dim aDir()  As String
Dim i       As Integer

  If boNachfrage Then
    If MsgBox(GetResText(21152), vbQuestion + vbYesNo, _
              GetResText(20109)) = vbNo Then
      Exit Sub
    End If
  End If
  
  On Error Resume Next
  Application.DisplayAlerts = False
  
  'ICSGEAD IM 115373
  Call SetCurrentDirectory(ProjektPfad & "\" & VERZ_VORLAGE)
  sDatei = Dir(ProjektPfad & "\" & VERZ_VORLAGE & "\*.xlt")
  i = 0
  ReDim aDir(0)   ' to exit loop below
  While Len(sDatei) > 0
    If (InStr(Len(sDatei) - 5, sDatei, ".XLTM", vbBinaryCompare) > 0) Or _
       (InStr(Len(sDatei) - 5, sDatei, ".xltm", vbBinaryCompare) > 0) Or _
       (InStr(Len(sDatei) - 4, sDatei, ".XLT", vbBinaryCompare) > 0) Or _
       (InStr(Len(sDatei) - 4, sDatei, ".xlt", vbBinaryCompare) > 0) Then
      i = i + 1
      ReDim Preserve aDir(i)
      aDir(i) = sDatei
    End If
    sDatei = Dir
  Wend
  
  For i = 1 To UBound(aDir)
    sDatei = aDir(i)
    
    Application.StatusBar = GetResText(20109) & " " & sDatei
    Call FileCopy(sDatei, sDatei & "_bkp")    ' IM 103943
    Set wbTmp = Workbooks.Open(sDatei)
    wbTmp.Activate
    M_Vorlage.VersionPruefen
    
    ' Ueberschreiben
    'ICSGEAD IM 115373
    If UCase(Right(sDatei, 5)) = ".XLTM" Then
        Call wbTmp.SaveAs(Filename:=sDatei, FileFormat:=xlOpenXMLTemplateMacroEnabled)
    ElseIf UCase(Right(sDatei, 4)) = ".XLT" Then
        Call wbTmp.SaveAs(Filename:=sDatei, FileFormat:=xlTemplate)   ' IM 103943 wg. Office 2010
    End If
    wbTmp.Close False
  Next
  
  Application.DisplayAlerts = True
  Application.StatusBar = ""
  
End Sub


'--------------------------------------------------------------------------------------------------
Public Sub Analysieren()

Dim wbProtVorlage As Workbook
Dim wsProt        As Worksheet
Dim coDP          As CO_DP
Dim coTabBereich  As CO_TabBereich
  
  On Error GoTo M_Vorlage_Analysieren_Fehler

  Set wbProtVorlage = ActiveWorkbook
  Set coDP = New CO_DP
  Set coTabBereich = New CO_TabBereich

Call ZeitMessung(True)
    
  'Tabellen durchlaufen
  For Each wsProt In wbProtVorlage.Worksheets

    'Je nach Protokollformat
    Select Case GetTabFormat(wsProt)
      'Layout ermitteln und Definierte Dp's einlesen
      Case BEZ_STD_PROTOKOLL:
        Call M_StdVorlage.GetTabLayout(wsProt, coTabBereich)
        Call M_StdVorlage.GetDPList(wsProt, coDP)
        Call M_StdVorlage.updateDpInfos(wsProt)
      Case BEZ_BTR_PROTOKOLL:
        Call M_BtrVorlage.GetTabLayout(wsProt, coTabBereich)
        Call M_BtrVorlage.GetDPList(wsProt, coDP)
        Call M_BtrVorlage.updateDpInfos(wsProt)
      Case BEZ_ATV_PROTOKOLL:
        Call M_ATVVorlage.GetTabLayout(wsProt, coTabBereich)
        Call M_ATVVorlage.GetDPList(wsProt, coDP)
        Call M_ATVVorlage.updateDpInfos(wsProt)
      Case BEZ_SQL_PROTOKOLL:
        'Aufbau wie Standardprotokoll
        Call M_StdVorlage.GetTabLayout(wsProt, coTabBereich)
      Case BEZ_KST_PROTOKOLL:
        Call M_KstVorlage.GetTabLayout(wsProt, coTabBereich)
        Call M_KstVorlage.GetDPList(wsProt, coDP)
        Call M_KstVorlage.updateDpInfos(wsProt)
        
    End Select

  Next wsProt

  TabBereichSpeichern coTabBereich
  DPListSpeichern wbProtVorlage, coDP, coTabBereich
  
  KopfFusszeilenAnalysieren wbProtVorlage
  Application.StatusBar = ""
  
Call ZeitMessung(False, "M_Vorlage::Analysieren")
  
Exit Sub
M_Vorlage_Analysieren_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::Speichern")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DPListSpeichern(wbProtVorlage As Workbook, coDP As CO_DP, coTabBereich As CO_TabBereich)

Dim wsProt        As Worksheet
Dim oDP           As C_DP
'Dim coTabBereich  As CO_TabBereich
Dim oTabBereich   As C_TabBereich
Dim coProtTyp     As CO_ProtokollTyp
Dim oProtTyp      As C_ProtokollTyp
Dim coArchiv      As CO_Archiv
Dim oArchiv       As C_Archiv
Dim rgProttyp     As Range
Dim rgKonfig      As Range
Dim asTitel()     As String
Dim iTitelAnz     As Integer
Dim iTitelID      As Integer
Dim boArchiv      As Boolean

Dim lIntervall    As Long
Dim iIntEinheit   As Integer
Dim iProtTyp      As Integer

Dim sDPStat       As String
Dim iArchiv       As Integer
Dim asArchiv()    As String
Dim sArchiv       As String
'Dim sArchivQuery  As String
Dim asArchivCalc()  As String
Dim asTmp()       As String
Dim asResultFkt() As String
Dim aiResultTyp() As Integer

Dim i As Integer
Dim j As Integer

 
  'Vorgesehene Protokolltypen einlesen
  Set wsProt = wbProtVorlage.Worksheets(TAB_KONFIG)
  Set coProtTyp = New CO_ProtokollTyp
  iTitelAnz = 16
  ReDim asTitel(iTitelAnz)
  asTitel(1) = "DPName"
  asTitel(2) = "DPE"
  asTitel(3) = "DPFkt"
  asTitel(4) = "ArchivTyp"
  asTitel(5) = "DPTyp"
  asTitel(6) = "Offset"
  asTitel(7) = "Blatt"
  asTitel(8) = "Bereich"
  asTitel(9) = "Zeile"
  asTitel(10) = "Spalte"
  asTitel(11) = "Marker"
  asTitel(12) = "AutoFormat"
  asTitel(13) = "CostCenter"
  asTitel(14) = "CostCenterWeighting"
  asTitel(15) = "CCMedium"
  asTitel(16) = "CCUnitFactor"

  Set coProtTyp = New CO_ProtokollTyp

  'Fuer die Vorlage definierte Protokolltypen einlesen
  For Each rgProttyp In SelectRange(wsProt.Range(REF_PROT_PROTTYPEN), 1, True)
    If Len(rgProttyp.Text) Then
      Set oProtTyp = M_ProtokollTyp.Lesen(rgProttyp.Text)
      If oProtTyp.Bezeichnung = rgProttyp.Text Then
        Call StrAppend(asTitel, rgProttyp.Text)
        Call StrAppend(asTitel, rgProttyp.Text & "(Intervall)")
        Call StrAppend(asTitel, rgProttyp.Text & "(Einheit)")
        coProtTyp.Add oProtTyp
      End If
    End If
  Next rgProttyp

  'Definitionsbereich DPL loeschen
  Set rgKonfig = SelectRange(wsProt.Range(REF_PROT_DPL))
  rgKonfig = ""

  'Titelzeile ausgeben
  Set rgKonfig = wsProt.Range(REF_PROT_DPL)
  For iTitelID = 1 To UBound(asTitel)
    rgKonfig.Offset(0, iTitelID - 1) = asTitel(iTitelID)
  Next iTitelID
  Set rgKonfig = rgKonfig.Offset(1, 0)

  'Dp's durchlaufen
  For Each oDP In coDP.Items

    If Not coTabBereich.FindItem(oDP.TabBereich.Blatt, oDP.TabBereich.Bereich) Is Nothing Then
    
      ReDim asArchiv(1)
      ReDim aiResultTyp(1)
      ReDim asResultFkt(1)
      asArchiv(1) = oDP.ArchivFkt
      aiResultTyp(1) = oDP.ArchivTyp
      asResultFkt(1) = oDP.ArchivFkt
  
'ACHTUNG: Reihenfolge zwingend geachten: erst ResultFkt dann ResultQuery in DPL eintragen!!
      StrToArray asTmp, oDP.ResultFkt, "|"
      For j = 1 To UBound(asTmp)
        If Not coTabBereich.FindItem(oDP.TabBereich.Blatt, asTmp(j)) Is Nothing Then
          i = UBound(asArchiv) + 1
          ReDim Preserve asArchiv(i):    asArchiv(i) = oDP.ArchivFkt
          ReDim Preserve aiResultTyp(i): aiResultTyp(i) = ARCHIVTYP_CALCULATE
          ReDim Preserve asResultFkt(i): asResultFkt(i) = asTmp(j)
        End If
      Next j
      
      StrToArray asTmp, oDP.ResultQuery, "|"
      For j = 1 To UBound(asTmp)
        If Not coTabBereich.FindItem(oDP.TabBereich.Blatt, asTmp(j)) Is Nothing Then
          i = UBound(asArchiv) + 1
          ReDim Preserve asArchiv(i):    asArchiv(i) = asTmp(j)
          If (oDP.ArchivTyp = ARCHIVTYP_RACPERIODE) Then
            ReDim Preserve aiResultTyp(i): aiResultTyp(i) = ARCHIVTYP_RACSINGLE
          Else
            ReDim Preserve aiResultTyp(i): aiResultTyp(i) = ARCHIVTYP_ACSINGLE
          End If
          ReDim Preserve asResultFkt(i): asResultFkt(i) = asTmp(j)
        End If
      Next j
      
      'sArchivQuery = ""
      ReDim asArchivCalc(coProtTyp.Count)
      For iArchiv = 1 To UBound(asArchiv)
        boArchiv = False
        iProtTyp = 0
        
        'Protokolltypen durchlaufen
        For Each oProtTyp In coProtTyp.Items
          iProtTyp = iProtTyp + 1
          'Wenn Archiv (letztlich DPE) vorhaden ist, eintragen
          sArchiv = ""
          If aiResultTyp(iArchiv) = ARCHIVTYP_ONLINE Then
            sArchiv = oDP.dp & "." & oDP.dpe
            lIntervall = 0
            iIntEinheit = 0
          ElseIf aiResultTyp(iArchiv) = ARCHIVTYP_HDBSINGLE Or _
                 aiResultTyp(iArchiv) = ARCHIVTYP_HDBPERIODE Or _
                 aiResultTyp(iArchiv) = ARCHIVTYP_RDBPERIODE Then
            sArchiv = oDP.dp & "." & oDP.dpe
            lIntervall = oProtTyp.Intervall
            iIntEinheit = oProtTyp.IntEinheit
          ElseIf aiResultTyp(iArchiv) = ARCHIVTYP_ACSINGLE Or _
                 aiResultTyp(iArchiv) = ARCHIVTYP_ACPERIODE Then
            
            If (aiResultTyp(iArchiv) = ARCHIVTYP_ACSINGLE) Then
              Set coArchiv = oProtTyp.BasiswertErgebnis.coArchive
            Else
              Set coArchiv = oProtTyp.BasiswertDaten.coArchive
            End If
            For Each oArchiv In coArchiv.Items
            
              If oArchiv.dpt = oDP.dpt And _
                 oArchiv.dpe = oDP.dpe And _
                 oArchiv.SYS = oDP.PVSSSystem _
                 Then                           'IM 115373 BK 20110421 Report funktioniert jetzt auch in Verteilten Systemen (Sys vergleich)
                sArchiv = oArchiv.DPArchiv(oDP.dp, asArchiv(iArchiv))
                lIntervall = oArchiv.Intervall
                iIntEinheit = oArchiv.IntEinheit
                Exit For
              End If
            Next oArchiv
          ElseIf aiResultTyp(iArchiv) = ARCHIVTYP_RACSINGLE Or _
                 aiResultTyp(iArchiv) = ARCHIVTYP_RACPERIODE Then
            
            If (aiResultTyp(iArchiv) = ARCHIVTYP_RACSINGLE) Then
              Set coArchiv = oProtTyp.BasiswertErgebnis.coArchive
            Else
              Set coArchiv = oProtTyp.BasiswertDaten.coArchive
            End If
            For Each oArchiv In coArchiv.Items
            
              ' take interval info from archive
              If oArchiv.dpt = oDP.dpt And _
                 oArchiv.dpe = oDP.dpe Then
                sArchiv = oDP.dp & "." & oDP.dpe
                lIntervall = oArchiv.Intervall
                iIntEinheit = oArchiv.IntEinheit
                Exit For
              End If
            Next oArchiv
          ElseIf aiResultTyp(iArchiv) = ARCHIVTYP_CALCULATE Then
            'Das Archiv fuer die Berechnung ist das erste Archiv, was nach
            'geltener Reihenfolge den Abgefragten Daten entspricht
            sArchiv = asArchivCalc(iProtTyp)
            
          End If
          If Len(sArchiv) > 0 Then
            If iArchiv = 1 Then asArchivCalc(iProtTyp) = sArchiv
            boArchiv = True
            rgKonfig.Offset(0, (iTitelAnz - 3) + (iProtTyp * 3)) = sArchiv
            rgKonfig.Offset(0, (iTitelAnz - 2) + (iProtTyp * 3)) = lIntervall
            rgKonfig.Offset(0, (iTitelAnz - 1) + (iProtTyp * 3)) = iIntEinheit
          End If
        
        Next oProtTyp
        
        'wenn mindestens ein Archiv gefunden werden konnte
        If boArchiv Then
          'DP in den Definitionsbereich eintragen
          rgKonfig.Offset(0, 0) = oDP.dp
          rgKonfig.Offset(0, 1) = oDP.dpe
          rgKonfig.Offset(0, 2) = asResultFkt(iArchiv)
          rgKonfig.Offset(0, 3) = aiResultTyp(iArchiv)
          rgKonfig.Offset(0, 4) = oDP.dpt
          rgKonfig.Offset(0, 5) = oDP.Offset
          rgKonfig.Offset(0, 6) = oDP.TabBereich.Blatt
          If iArchiv = 1 Then
            rgKonfig.Offset(0, 7) = VAR_DATENBEREICH
          Else
            rgKonfig.Offset(0, 7) = asResultFkt(iArchiv)
          End If
          rgKonfig.Offset(0, 8) = oDP.TabBereich.Zeile
          rgKonfig.Offset(0, 9) = oDP.TabBereich.Spalte
          rgKonfig.Offset(0, 10) = oDP.Marker
          rgKonfig.Offset(0, 11) = oDP.AutoFormat
          rgKonfig.Offset(0, 12) = oDP.CostCenter
          rgKonfig.Offset(0, 13) = oDP.CCWeighting
          rgKonfig.Offset(0, 14) = oDP.CCMedium
          rgKonfig.Offset(0, 15) = oDP.CCUnitFactor
          Set rgKonfig = rgKonfig.Offset(1, 0)
        End If
      Next iArchiv
  
    End If
  Next oDP

  SelectRange(wsProt.Range(REF_PROT_DPL), iZeilenAnz:=1).Columns.AutoFit

End Sub

'--------------------------------------------------------------------------------------------------
Public Function DPListLesen(oProtokoll As C_Protokoll, coTabBereich As CO_TabBereich) As CO_DP

Dim coDP As CO_DP
Dim coStatusBit As CO_StatusBit
Dim tabKonfig     As Worksheet

Dim oDP       As C_DP
Dim oDPRef    As C_DPReferenz
Dim rgDp      As Range
Dim iDPID     As Integer
Dim rgProttyp As Range
Dim rgSuche   As Range
Dim coBO      As CO_BlattOffset
Dim cBO       As C_BlattOffset
Dim lBlatt    As Long
  
  Set tabKonfig = oProtokoll.wbProtokoll.Worksheets(TAB_KONFIG)
  For Each rgSuche In SelectRange(tabKonfig.Range(REF_PROT_DPL), _
                                  iZeilenAnz:=1)
    If rgSuche.Text = oProtokoll.ProtTyp.Bezeichnung Then
      Set rgProttyp = rgSuche
      Exit For
    End If
  Next rgSuche
  Call M_Vorlage.BlattOffsetsLesen(oProtokoll.wbProtokoll, coBO)

  'Fehler, wenn keine Protokolltypen in der Vorlage sind
  If rgProttyp Is Nothing Then
    Call FehlerAusloesen(ERR_PROT_KONFIG)
  End If
  
  Set coStatusBit = M_StatusBit.coLesen
  Set coDP = New CO_DP
  iDPID = 1
  For Each rgDp In SelectRange(ActiveWorkbook.Worksheets(TAB_KONFIG).Range(REF_PROT_DPL), _
                               1, True)
  
    If Len(rgProttyp.Offset(iDPID, 0).Text) > 0 Then
      
      If rgDp.Offset(0, 3) <> ARCHIVTYP_CALCULATE Then
        Set oDP = New C_DP
        Set oDP.StatusBit = coStatusBit
        oDP.dp = rgDp.Offset(0, 0).Text
        oDP.dpe = rgDp.Offset(0, 1).Text
        oDP.ArchivFkt = rgDp.Offset(0, 2).Text
        oDP.ArchivTyp = rgDp.Offset(0, 3).Text
        oDP.dpt = rgDp.Offset(0, 4).Text
        oDP.Offset = RangeToLng(rgDp.Offset(0, 5))
        lBlatt = rgDp.Offset(0, 6)
        Set cBO = coBO.FindItem(lBlatt)
        If (Not cBO Is Nothing) Then
          oDP.Offset = oDP.Offset + cBO.sValue    ' IM 102541 WOKL: calculate with sheet offset
        End If
        oDP.Marker = RangeToLng(rgDp.Offset(0, 10))
        oDP.AutoFormat = RangeToLng(rgDp.Offset(0, 11))
        oDP.CostCenter = rgDp.Offset(0, 12).Text
        oDP.CCWeighting = CDbl(rgDp.Offset(0, 13).Text)
        oDP.CCMedium = rgDp.Offset(0, 14).Text
        oDP.CCUnitFactor = CDbl(rgDp.Offset(0, 15).Text)
        
        oDP.Archiv = rgProttyp.Offset(iDPID, 0).Text
        oDP.Intervall = rgProttyp.Offset(iDPID, 1)
        oDP.IntEinheit = rgProttyp.Offset(iDPID, 2)
        oDP.Von = oProtokoll.Von(oDP.Offset)
        oDP.Bis = oProtokoll.Bis(oDP.Offset)
        
  '      'Was soll wie abgefragt werden?
  '      If rgDp.Offset(0, 6) = VAR_DATENBEREICH Then
  '        If Left(oDp.ArchivFkt, 7) = "_online" Then
  '          oDp.ArchivTyp = ARCHIVTYP_ONLINE
  '        ElseIf Left(oDp.ArchivFkt, 8) = "_offline" Then
  '          oDp.ArchivTyp = ARCHIVTYP_HDBPERIODE
  '        Else
  '          oDp.ArchivTyp = ARCHIVTYP_ACPERIODE
  '        End If
  '      Else
  '        If Left(oDp.ArchivFkt, 7) = "_online" Then
  '          oDp.ArchivTyp = ARCHIVTYP_ONLINE
  '        ElseIf Left(oDp.ArchivFkt, 8) = "_offline" Then
  '          oDp.ArchivTyp = ARCHIVTYP_HDBSINGLE
  '        Else
  '          oDp.ArchivTyp = ARCHIVTYP_ACSINGLE
  '        End If
  '      End If
      End If
      Set oDPRef = New C_DPReferenz
      Set oDPRef.TabBereich = coTabBereich.FindItem(rgDp.Offset(0, 6).value, rgDp.Offset(0, 7).value)
      oDPRef.Zeile = rgDp.Offset(0, 8).value
      oDPRef.Spalte = rgDp.Offset(0, 9).value
      oDPRef.ArchivFkt = oDP.ArchivFkt
      oDPRef.CostCenter = oDP.CostCenter
      oDPRef.CCWeighting = oDP.CCWeighting
      oDPRef.CCMedium = oDP.CCMedium
      oDPRef.CCUnitFactor = oDP.CCUnitFactor
      'On Error GoTo M_StdProt_Erstellen_Fehler
      
      coDP.Add oDP, oDPRef
      
      'Set oDp = Nothing
      'Set oDPRef = Nothing
    
    End If
    iDPID = iDPID + 1
  Next rgDp
  
  Set DPListLesen = coDP

End Function

'--------------------------------------------------------------------------------------------------
Public Function ReadSheetAttribute(wbProtVorlage As Workbook, lSheetID As Long, attrib As String) As String
Dim rgKopfFussZeilen As Range
Dim line As Range

  ReadSheetAttribute = ""
  
  Set rgKopfFussZeilen = SelectRange(wbProtVorlage.Worksheets(TAB_KONFIG).Range(REF_PROT_KOPF_FUSS_ZEILEN), 1, True)
  For Each line In rgKopfFussZeilen
    If line = lSheetID And line.Offset(0, 1) = attrib Then
      ReadSheetAttribute = line.Offset(0, 2)
      Exit For
    End If
  Next line
         
End Function

'--------------------------------------------------------------------------------------------------
Public Sub WriteSheetAttribute(wbProtVorlage As Workbook, lSheetID As Long, attrib As String, value As String)
Dim rgKopfFussZeilen As Range
Dim line As Range
Dim found As Boolean

  found = False
  Set rgKopfFussZeilen = SelectRange(wbProtVorlage.Worksheets(TAB_KONFIG).Range(REF_PROT_KOPF_FUSS_ZEILEN), 1, True)
  For Each line In rgKopfFussZeilen
    If line = lSheetID And line.Offset(0, 1) = attrib Then
      line.Offset(0, 2) = value
      found = True
    End If
  Next line
      
  If (Not found) Then
    Set rgKopfFussZeilen = wbProtVorlage.Worksheets(TAB_KONFIG).Range(REF_PROT_KOPF_FUSS_ZEILEN).End(xlDown)
    Set rgKopfFussZeilen = rgKopfFussZeilen.Offset(1, 0)
    
    rgKopfFussZeilen = lSheetID
    rgKopfFussZeilen.Offset(0, 1) = attrib
    rgKopfFussZeilen.Offset(0, 2) = value
  End If
          
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub KopfFusszeilenAnalysieren(wbProtVorlage As Workbook)

Dim rgKopfFussZeilen As Range
Dim line      As Range
Dim lSheetID  As Long
Dim coBO      As CO_BlattOffset
Dim cBO       As C_BlattOffset

Dim asVarText() As String
Dim i As Integer

Dim lStatusId As Long

  On Error GoTo KopfFusszeilenAnalysieren_Fehler
  lStatusId = StatusTextAusgeben(GetResText(21308))
  
  ReDim asVarText(10)
  asVarText(1) = VAR_REPORTTYP
  asVarText(2) = VAR_VON
  asVarText(3) = VAR_BIS
  asVarText(4) = VAR_INTERVALL
  asVarText(5) = VAR_VONDATUM
  asVarText(6) = VAR_VONZEIT
  asVarText(7) = VAR_BISDATUM
  asVarText(8) = VAR_BISZEIT
  asVarText(9) = VAR_ZEITRAUM
  asVarText(10) = VAR_ZEILEN

  Call BlattOffsetsLesen(wbProtVorlage, coBO)
  
  Set rgKopfFussZeilen = SelectRange(wbProtVorlage.Worksheets(TAB_KONFIG).Range(REF_PROT_KOPF_FUSS_ZEILEN), 3, True)
  rgKopfFussZeilen = ""
  Set rgKopfFussZeilen = wbProtVorlage.Worksheets(TAB_KONFIG).Range(REF_PROT_KOPF_FUSS_ZEILEN).Offset(1, 0)
  
  For lSheetID = 1 To wbProtVorlage.Sheets.Count
  
    With wbProtVorlage.Sheets(lSheetID).PageSetup
    
      For i = 1 To UBound(asVarText)
        If (InStr(1, .LeftHeader, asVarText(i)) > 0) Then
          rgKopfFussZeilen = lSheetID
          rgKopfFussZeilen.Offset(0, 1) = "LeftHeader"
          rgKopfFussZeilen.Offset(0, 2) = asVarText(i)
          Set rgKopfFussZeilen = rgKopfFussZeilen.Offset(1, 0)
        End If
      Next i
      For i = 1 To UBound(asVarText)
        If (InStr(1, .CenterHeader, asVarText(i)) > 0) Then
          rgKopfFussZeilen = lSheetID
          rgKopfFussZeilen.Offset(0, 1) = "CenterHeader"
          rgKopfFussZeilen.Offset(0, 2) = asVarText(i)
          Set rgKopfFussZeilen = rgKopfFussZeilen.Offset(1, 0)
        End If
      Next i
      For i = 1 To UBound(asVarText)
        If (InStr(1, .RightHeader, asVarText(i)) > 0) Then
          rgKopfFussZeilen = lSheetID
          rgKopfFussZeilen.Offset(0, 1) = "RightHeader"
          rgKopfFussZeilen.Offset(0, 2) = asVarText(i)
          Set rgKopfFussZeilen = rgKopfFussZeilen.Offset(1, 0)
        End If
      Next i
  
      For i = 1 To UBound(asVarText)
        If (InStr(1, .LeftFooter, asVarText(i)) > 0) Then
          rgKopfFussZeilen = lSheetID
          rgKopfFussZeilen.Offset(0, 1) = "LeftFooter"
          rgKopfFussZeilen.Offset(0, 2) = asVarText(i)
          Set rgKopfFussZeilen = rgKopfFussZeilen.Offset(1, 0)
        End If
      Next i
      For i = 1 To UBound(asVarText)
        If (InStr(1, .CenterFooter, asVarText(i)) > 0) Then
          rgKopfFussZeilen = lSheetID
          rgKopfFussZeilen.Offset(0, 1) = "CenterFooter"
          rgKopfFussZeilen.Offset(0, 2) = asVarText(i)
          Set rgKopfFussZeilen = rgKopfFussZeilen.Offset(1, 0)
        End If
      Next i
      For i = 1 To UBound(asVarText)
        If (InStr(1, .RightFooter, asVarText(i)) > 0) Then
          rgKopfFussZeilen = lSheetID
          rgKopfFussZeilen.Offset(0, 1) = "RightFooter"
          rgKopfFussZeilen.Offset(0, 2) = asVarText(i)
          Set rgKopfFussZeilen = rgKopfFussZeilen.Offset(1, 0)
        End If
      Next i
  
    End With

  Next lSheetID
  
  ' write back Offset-Atrributes again
  For Each cBO In coBO.Items
    Call WriteSheetAttribute(wbProtVorlage, cBO.lIndex, cBO.sAttribute, cBO.sValue)
  Next

Exit Sub
KopfFusszeilenAnalysieren_Fehler:
  Debug.Print Err.Number, Err.Description
End Sub

'--------------------------------------------------------------------------------------------------
'Konfigurieren
'
'Oliver Seidel 21.03.2000
'
'Konfiguriert eine neue Vorlage.
'
'Aenderungen: -keine-
'--------------------------------------------------------------------------------------------------
Public Sub Konfigurieren()
  
Dim tabKonfig  As Worksheet  'Tabelle mit den Einstellungen (Konfig)

Dim asProtTyp() As String   'Protokolltypen fuer diese Vorlage
Dim iProtTyp    As Integer  '
Dim rgProttyp   As Range    '
Dim asDpTyp()   As String   '
Dim iDPTyp      As Integer

Dim oProtTyp  As C_ProtokollTyp
Dim coProtTyp As CO_ProtokollTyp
Dim vwAuswahl As V_AuswahlProtTypen
Dim lStatus As Long

  On Error GoTo M_Vorlage_Konfigurieren_Fehler

  lStatus = StatusTextAusgeben(GetResText(21306))

  Set vwAuswahl = New V_AuswahlProtTypen
  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
  Set coProtTyp = M_ProtokollTyp.coLesen

  'Bereits definierte Protokolltypen lesen
  ReDim asProtTyp(0)
  For Each rgProttyp In SelectRange(tabKonfig.Range(REF_PROT_PROTTYPEN), 1, True)
    iProtTyp = iProtTyp + 1
    ReDim Preserve asProtTyp(iProtTyp)
    asProtTyp(iProtTyp) = rgProttyp.Text
  Next rgProttyp
  vwAuswahl.setProtokolltypen asProtTyp
  If IsNumeric(tabKonfig.Range(REF_SEITENANSICHT).value) Then
    vwAuswahl.Seitenansicht = tabKonfig.Range(REF_SEITENANSICHT).value
  End If
  vwAuswahl.MinColor = getMinColor(ActiveWorkbook)
  vwAuswahl.MaxColor = getMaxColor(ActiveWorkbook)
  vwAuswahl.chkLogChanges = getLogChanges(ActiveWorkbook)
  
  vwAuswahl.Show

  If vwAuswahl.ok Then

    Call vwAuswahl.getProtokolltypen(asProtTyp)

    SelectRange(tabKonfig.Range(REF_PROT_PROTTYPEN), 1, True) = ""
    For iProtTyp = 1 To UBound(asProtTyp)
      tabKonfig.Range(REF_PROT_PROTTYPEN).Offset(iProtTyp, 0).value = asProtTyp(iProtTyp)
    Next iProtTyp

    tabKonfig.Range(REF_SEITENANSICHT).value = vwAuswahl.Seitenansicht
    tabKonfig.Range(REF_MIN_COLOR).value = vwAuswahl.MinColor
    tabKonfig.Range(REF_MAX_COLOR).value = vwAuswahl.MaxColor
    tabKonfig.Range(REF_LOGCHANGES).value = vwAuswahl.LogChanges

    Call BereichNeu
  Else
    Call FehlerAusloesen(ERR_BENUTZER_ABBRUCH)
  End If

  Unload vwAuswahl
  Set vwAuswahl = Nothing

  Set rgProttyp = Nothing
  Call StatusTextLoeschen(lStatus)

Exit Sub
M_Vorlage_Konfigurieren_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::Konfigurieren")

  If Err.Source <> "UI" Then
    Call MsgBox(Err.Source & Chr(13) & _
                Err.Description, _
                vbOKOnly + vbCritical, _
                GetResText(20104) & " " & Err.Number)
  End If
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub BereichAendern()

Dim vwBereichsauswahl As V_Bereichsauswahl
Dim selAreas As String

  If (M_PVSSLogin.PVSSLoginIsValid) Then
    Set vwBereichsauswahl = New V_Bereichsauswahl
    Let vwBereichsauswahl.selAreas = ActiveWorkbook.Worksheets(TAB_KONFIG).Range(REF_AREA_PERMISSIONS)
    Set vwBereichsauswahl.Areas = M_PVSSLogin.Areas
    
    vwBereichsauswahl.Show

    If vwBereichsauswahl.ok Then
      ActiveWorkbook.Worksheets(TAB_KONFIG).Range(REF_AREA_PERMISSIONS) = vwBereichsauswahl.selAreas
    End If
  
  End If
End Sub
'--------------------------------------------------------------------------------------------------
Public Sub BereichNeu()

Dim vwBereichsauswahl As V_Bereichsauswahl

  If (M_PVSSLogin.PVSSLoginIsValid) Then
    Set vwBereichsauswahl = New V_Bereichsauswahl
    Set vwBereichsauswahl.Areas = M_PVSSLogin.Areas
    
    vwBereichsauswahl.Show

    If vwBereichsauswahl.ok Then
      ActiveWorkbook.Worksheets(TAB_KONFIG).Range(REF_AREA_PERMISSIONS) = vwBereichsauswahl.selAreas
    End If
  
  End If

End Sub
'--------------------------------------------------------------------------------------------------
Public Sub DPEinfuegen()

  On Error GoTo M_Vorlage_DPEinfuegen_Fehler

  If (M_PVSS.CheckForRdbStatus = False) Then Exit Sub
  
  'Weitere Bearbeitung an die zustaendigen Module deligieren
  Select Case GetTabFormat(ActiveSheet)
    Case BEZ_STD_PROTOKOLL:   Call M_StdVorlage.DPEinfuegen
    Case BEZ_BTR_PROTOKOLL:   Call M_BtrVorlage.DPEinfuegen
    Case BEZ_ATV_PROTOKOLL:   Call M_ATVVorlage.DPEinfuegen
    Case BEZ_KST_PROTOKOLL:   Call M_KstVorlage.DPEinfuegen
  End Select

Exit Sub
M_Vorlage_DPEinfuegen_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::DPEinfuegen")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DPAendern()

  On Error GoTo M_Vorlage_DPAendern_Fehler

  'Weitere Bearbeitung an die zustaendigen Module deligieren
  Select Case GetTabFormat(ActiveSheet)
    Case BEZ_STD_PROTOKOLL:  Call M_StdVorlage.DPAendern
    Case BEZ_BTR_PROTOKOLL:  Call M_BtrVorlage.DPAendern
    Case BEZ_ATV_PROTOKOLL:  Call M_ATVVorlage.DPAendern
    Case BEZ_KST_PROTOKOLL:  Call M_KstVorlage.DPAendern
  End Select

Exit Sub
M_Vorlage_DPAendern_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::DPAendern")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub BlattEinfuegen()

Dim sDateiVorlage As String
Dim wbProtVorlage As Workbook
Dim tabQuelle     As Worksheet
Dim tabZiel       As Worksheet
Dim tabKonfig     As Worksheet

Dim vwProtFormat  As V_ProtFormat
Dim iProtFormat   As Integer
Dim asProtFormat() As String
Dim lStatus       As Long
Dim ls            As Variant
Dim i             As Integer

  On Error GoTo M_Vorlage_BlattEinfuegen_Fehler

  'Protokollformate einlesen
  For iProtFormat = 1 To M_Optionen.getOpt.ProtFormatAnz
    ReDim Preserve asProtFormat(iProtFormat)
    asProtFormat(iProtFormat) = M_Optionen.getOpt.ProtFormat(iProtFormat)
  Next iProtFormat
  
  'Statusmeldung ausgeben
  lStatus = StatusTextAusgeben(GetResText(21323))

  'Auswahlfenster anzeigen
  Set vwProtFormat = New V_ProtFormat
  Call vwProtFormat.ProtFormate(asProtFormat)
  Call vwProtFormat.Show
    
  'Wenn Format ausgewaehlt wurde
  If Not vwProtFormat.ok Then
    Set vwProtFormat = Nothing
    Exit Sub
  End If
  
  Select Case vwProtFormat.ProtFormat
    Case BEZ_STD_PROTOKOLL: sDateiVorlage = DATEI_STD_VORLAGE
    Case BEZ_BTR_PROTOKOLL: sDateiVorlage = DATEI_BTR_VORLAGE
    Case BEZ_ATV_PROTOKOLL: sDateiVorlage = DATEI_ATV_VORLAGE
    Case BEZ_SQL_PROTOKOLL: sDateiVorlage = DATEI_SQL_VORLAGE
    Case BEZ_KST_PROTOKOLL: sDateiVorlage = DATEI_KST_VORLAGE
    Case Else
      Call NZD(GetResText(21125), "M_Vorlage::BlattEinfuegen")
      Exit Sub
  End Select

  Application.ScreenUpdating = False

  Set tabZiel = ActiveWorkbook.ActiveSheet

  On Error Resume Next
  Set wbProtVorlage = Workbooks.Open(ProjektPfad & "\" & sDateiVorlage)
  If Err Then
    Err.Clear
    Application.ScreenUpdating = True
    Exit Sub
  End If
  
  'Version der Vorlage pruefen
  On Error GoTo M_Vorlage_BlattEinfuegen_Fehler
  Set tabKonfig = wbProtVorlage.Worksheets(TAB_KONFIG)
  If Left(tabKonfig.Range(REF_DATEI_VERSION), 4) <> Left(ProjektVersion, 4) Then
    Call StatusTextLoeschen(lStatus)
    wbProtVorlage.Close SaveChanges:=False
    Application.ScreenUpdating = True
    Call FehlerAusloesen(ERR_VORLAGE_ERSTELLEN, ProjektPfad & "\" & sDateiVorlage, True)
  End If

  For Each tabQuelle In wbProtVorlage.Worksheets
    If IsReportTab(tabQuelle) Then
      Exit For
    End If
  Next tabQuelle

  If Err Then
    Err.Clear
    'Call goReport.Schliessen(boAenderungenSpeichern:=False)
    wbProtVorlage.Close SaveChanges:=False
    Application.ScreenUpdating = True
    Exit Sub
  End If

  tabQuelle.Copy after:=tabZiel
  'wbProtVorlage.Activate
  'Call goReport.Schliessen(boAenderungenSpeichern:=False)
  wbProtVorlage.Close SaveChanges:=False
  Application.ScreenUpdating = True
  
  '  ActiveWorkbook.ChangeLink name:=ProjektPfad & "\" & sDateiVorlage, _
  '                            newname:=ActiveWorkbook.name, _
  '                            Type:=xlExcelLinks
                            
  ' IM 109058 delete all links
  ls = ActiveWorkbook.LinkSources(xlExcelLinks)
  If Not IsEmpty(ls) Then
    For i = 1 To UBound(ls)
        ActiveWorkbook.ChangeLink Name:=ls(i), _
          newname:=ActiveWorkbook.Name, _
          Type:=xlExcelLinks
    Next i
  End If

Exit Sub
M_Vorlage_BlattEinfuegen_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::BlattEinfuegen")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub BlattLoeschen()

  On Error GoTo M_Vorlage_BlattLoeschen_Fehler
  ActiveSheet.Delete

Exit Sub
M_Vorlage_BlattLoeschen_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::BlattLoeschen")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub BlattOffsetsLesen(wbProtVorlage As Workbook, coBlattOffset As CO_BlattOffset)

  Dim lSheetID As Long
  Dim cBO As C_BlattOffset
  Dim value As String
  
  If coBlattOffset Is Nothing Then
    Set coBlattOffset = New CO_BlattOffset
  End If

  For lSheetID = 1 To wbProtVorlage.Sheets.Count
    value = M_Vorlage.ReadSheetAttribute(wbProtVorlage, lSheetID, "Offset")
    If (value <> "") Then
      Set cBO = New C_BlattOffset
      cBO.lIndex = lSheetID
      cBO.sAttribute = "Offset"
      cBO.sValue = value
      Call coBlattOffset.Add(cBO)
    End If
  Next lSheetID
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Function BlattOffsetLesen(wbProtVorlage As Workbook, lSheetID As Long) As Integer
  On Error Resume Next
  BlattOffsetLesen = 0    ' default
  BlattOffsetLesen = CInt(M_Vorlage.ReadSheetAttribute(wbProtVorlage, lSheetID, "Offset"))
End Function

'--------------------------------------------------------------------------------------------------
Public Sub BlattOffset()

Dim vwBlattOffset As V_BlattOffset

  On Error GoTo M_Vorlage_BlattOffset_Fehler
  
  Set vwBlattOffset = New V_BlattOffset
  On Error Resume Next
  vwBlattOffset.Offset = CInt(M_Vorlage.ReadSheetAttribute(ActiveWorkbook, ActiveSheet.index, "Offset"))
  On Error GoTo M_Vorlage_BlattOffset_Fehler
  
  vwBlattOffset.SheetName = ActiveSheet.Name
  Call vwBlattOffset.Show
  If (vwBlattOffset.ok) Then
  
    Call WriteSheetAttribute(ActiveWorkbook, ActiveSheet.index, "Offset", vwBlattOffset.Offset)
  
   Set vwBlattOffset = Nothing
  End If
  
Exit Sub
M_Vorlage_BlattOffset_Fehler:
  
  Call ErrMessage("FEHLER " & Err.Number & " " & Err.Description & _
                  " IN " & Err.Source, "M_Vorlage::BlattOffset")

  Call MsgBox(Err.Source & Chr(13) & _
              Err.Description, _
              vbOKOnly + vbCritical, _
              GetResText(20104) & " " & Err.Number)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub Update_2_1()

Dim sProtBez        As String
Dim tabKonfig       As Worksheet  'Tabelle mit den Einstellungen (Konfig)

  On Error GoTo M_Vorlage_Update_2_1_Fehler
  
  'Weitere Verzweigung der einzelnen Protokollformen
  Select Case DateiBez
    
    Case BEZ_STD_PROTOKOLL, "Standard"
      sProtBez = BEZ_STD_PROTOKOLL
 
    Case BEZ_BTR_PROTOKOLL
      sProtBez = BEZ_BTR_PROTOKOLL
      
    Case BEZ_ATV_PROTOKOLL
      Exit Sub
  End Select

  ' Das eigentliche Update auf Version 2.1
  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
  tabKonfig.Range(REF_DATEI_VERSION) = ProjektVersion
  tabKonfig.Range(REF_DATEI_BEZ) = sProtBez
  tabKonfig.Range("C1").EntireColumn.Insert
  tabKonfig.Range(REF_PROT_KOPF_FUSS_ZEILEN).Offset(-1, 0) = "Kopf / Fusszeilen"
  tabKonfig.Range(REF_PROT_KOPF_FUSS_ZEILEN).Offset(0, 0) = "Blatt"
  tabKonfig.Range(REF_PROT_KOPF_FUSS_ZEILEN).Offset(0, 1) = "Bereich"
  tabKonfig.Range(REF_PROT_KOPF_FUSS_ZEILEN).Offset(0, 2) = "Text"

  Call MsgBox(GetResText(21111), vbOKOnly, _
              GetResText(20105))

  Set tabKonfig = Nothing

Exit Sub

M_Vorlage_Update_2_1_Fehler:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)

End Sub

'--------------------------------------------------------------------------------------------------
Private Sub Update_2_2(iVerSub As Integer)

Dim wbProtVorlage As Worksheet
Dim asVarText()   As String
Dim asSuchText()  As String
Dim tabKonfig       As Worksheet  'Tabelle mit den Einstellungen (Konfig)

Dim rgSuche       As Range
Dim i As Integer


  On Error GoTo M_Vorlage_Update_2_2_Fehler

  If DateiBez = BEZ_ATV_PROTOKOLL Then
    'ATV-Protokoll: Es ist nichts zu tun
    Exit Sub
  Else
    'STD- oder BTR-Protokoll
    ReDim asSuchText(4)
    asSuchText(1) = "[Protokolltyp]"
    asSuchText(2) = "[Von]"
    asSuchText(3) = "[Bis]"
    asSuchText(4) = "[Intervall]"
  
    ReDim asVarText(4)
    asVarText(1) = VAR_REPORTTYP
    asVarText(2) = VAR_VON
    asVarText(3) = VAR_BIS
    asVarText(4) = VAR_INTERVALL
  
    For Each wbProtVorlage In ActiveWorkbook.Worksheets
      With wbProtVorlage.PageSetup
        For i = 1 To UBound(asSuchText)
          .LeftHeader = TextErsetzen(.LeftHeader, asSuchText(i), asVarText(i))
          .CenterHeader = TextErsetzen(.CenterHeader, asSuchText(i), asVarText(i))
          .RightHeader = TextErsetzen(.RightHeader, asSuchText(i), asVarText(i))
          .LeftFooter = TextErsetzen(.LeftFooter, asSuchText(i), asVarText(i))
          .CenterFooter = TextErsetzen(.CenterFooter, asSuchText(i), asVarText(i))
          .RightFooter = TextErsetzen(.RightFooter, asSuchText(i), asVarText(i))
        Next i
      End With

      'Dieser Teil nur fuer das STD-Protokoll
      If DateiBez = BEZ_STD_PROTOKOLL Then
        If wbProtVorlage.Name Like "Blatt*" Then
    
          Set rgSuche = wbProtVorlage.Range("A1")
          While (Not rgSuche Is Nothing)
    
            If rgSuche = "Einstellungen" Then rgSuche = BEZ_STD_PROTOKOLL
            If rgSuche = "Kopfzeilen" Then rgSuche = VAR_KOPFZEILE
            If rgSuche = "Datenbereich" Then rgSuche = VAR_DATENBEREICH
            If rgSuche = "Fusszeilen" Then rgSuche = VAR_FUSSZEILE
            If (iVerSub = 3) Then
              If rgSuche = "Fu|fffd|zeilen" Then rgSuche = VAR_FUSSZEILE
            End If
            If rgSuche = "Seitenende" Then rgSuche = VAR_SEITENENDE
            If rgSuche = "Minimum" Then rgSuche = VAR_MIN
            If rgSuche = "Maximum" Then rgSuche = VAR_MAX
            If rgSuche = "Arithm. Mittel" Then rgSuche = VAR_MITTEL
            If rgSuche = "Summe" Then rgSuche = VAR_SUMME
    
            Set rgSuche = MoveRange(rgSuche, xlDown)
    
          Wend
        End If
      End If
    Next wbProtVorlage
  
    ' IM 82829 WOKL 4.10.07 eine Spalte zu viel ('DPFkt')
    If (iVerSub = 3) Then
        Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
        tabKonfig.Range("I1").EntireColumn.Delete
    End If
  
  End If
Exit Sub

M_Vorlage_Update_2_2_Fehler:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)

End Sub

'--------------------------------------------------------------------------------------------------
Private Sub Update_2_3()
  
Dim tabDaten As Worksheet
Dim sProtBez As String

  On Error GoTo M_Vorlage_Update_2_3_Fehler
  
  'Weitere Verzweigung der einzelnen Protokollformen
  Select Case DateiBez
    
    Case BEZ_STD_PROTOKOLL, "Standard"
      sProtBez = BEZ_STD_PROTOKOLL
 
    Case BEZ_BTR_PROTOKOLL
      sProtBez = BEZ_BTR_PROTOKOLL
      
    Case BEZ_ATV_PROTOKOLL
      Exit Sub
      
  End Select

  Set tabDaten = ActiveWorkbook.Worksheets(TAB_KONFIG)
  tabDaten.Range("B5").Offset(0, -1) = "Seitenansicht"
  tabDaten.Range("B5") = False
  
  For Each tabDaten In ActiveWorkbook.Worksheets
    If tabDaten.Name Like "Blatt *" Then
      tabDaten.Range("A1") = BEZ_STD_PROTOKOLL
    End If
  Next tabDaten
Exit Sub


M_Vorlage_Update_2_3_Fehler:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)

End Sub

'--------------------------------------------------------------------------------------------------
Private Sub Update_2_4()
  'Hier sind keine Aenderungen noetig
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub Update_3_0()
  
Dim tabDaten As Worksheet
Dim rgZeiger As Range
Dim n As Integer

  On Error GoTo M_Vorlage_Update_3_0_Fehler
  
  'Zunaechst Verzweigung der einzelnen Protokollformen (Reihenfolge wichtig fuer das Std-Prot)
  Select Case DateiBez
    
    Case BEZ_STD_PROTOKOLL, "Standard"
     M_StdVorlage.Update_3_0
    
    Case BEZ_BTR_PROTOKOLL
      M_BtrVorlage.Update_3_0
      
    Case BEZ_ATV_PROTOKOLL
      M_ATVVorlage.Update_3_0
      
  End Select
  
  'Nun der allgemeine Teil
  'Das Blatt "Konfiguration" benennen
  Set tabDaten = ActiveWorkbook.Worksheets(TAB_KONFIG)
  
  'Alte Zellen loeschen
  'Alter Bereich der Kopf- und Fusszeilen
  Set rgZeiger = SelectRange(tabDaten.Range("A10"), 3)
  rgZeiger = ""
  
  'Bereich der Tabellenbereiche
  Set rgZeiger = SelectRange(tabDaten.Range("H1"))
  rgZeiger = ""
  
  'Ueberschrift wieder einsetzen fuer die Spalten H1:K1
  tabDaten.Range("H1").value = "Blatt"
  tabDaten.Range("I1").value = "Bereich"
  tabDaten.Range("J1").value = "Zeile"
  tabDaten.Range("K1").value = "Spalte"
  
  'Ueberschrift wieder einsetzen fuer die Kopf/Fusszeilen
  tabDaten.Range("A20").value = "Kopf / Fusszeilen"
  tabDaten.Range("A21").value = "Blatt"
  tabDaten.Range("B21").value = "Bereich"
  tabDaten.Range("C21").value = "Text"
  tabDaten.Range("A10").Font.Bold = False
  tabDaten.Range("A10").Font.Size = 10
  tabDaten.Range("A20").Font.Bold = True
  tabDaten.Range("A20").Font.Size = 12
   
  'Zellen mit Namen versehen zur Orientierung
  tabDaten.Range("A5").value = "Seitenansicht"
  tabDaten.Range("A6").value = "ProtokollTyp"
  ActiveWorkbook.Names.Add "erProtkollTyp", tabDaten.Range("B6")
  tabDaten.Range("A7").value = "Von"
  ActiveWorkbook.Names.Add "erVon", tabDaten.Range("B7")
  tabDaten.Range("A8").value = "Bis"
  ActiveWorkbook.Names.Add "erBis", tabDaten.Range("B8")
  tabDaten.Range("A9").value = "Intervall"
  ActiveWorkbook.Names.Add "erIntervall", tabDaten.Range("B9")
  tabDaten.Range("A10").value = "Intervall Einheit"
  ActiveWorkbook.Names.Add "erIntervallEinheit", tabDaten.Range("B10")
  tabDaten.Range("A11").value = "Periode"
  ActiveWorkbook.Names.Add "erPeriode", tabDaten.Range("B11")
  tabDaten.Range("A12").value = "Periode Einheit"
  ActiveWorkbook.Names.Add "erPeriodeEinheit", tabDaten.Range("B12")
  
  'Zellen in der Breite formatieren
  For n = 1 To 30
  
    If n = 4 Or n = 7 Or n = 12 Then
      tabDaten.Columns(n).ColumnWidth = 0.88
      
    Else
      If n >= 8 And n <= 21 Then
        tabDaten.Columns(n).ColumnWidth = 10
        
      Else
        tabDaten.Columns(n).ColumnWidth = 20
        
      End If
    End If
  Next n

  For Each tabDaten In ActiveWorkbook.Worksheets
  
    Select Case tabDaten.Range("A1")
    Case BEZ_ATV_PROTOKOLL
      Call FormelRefAendern(tabDaten.Range("A2"), "erProtokollTyp")
      Call FormelRefAendern(tabDaten.Range("B2"), "erVon")
      Call FormelRefAendern(tabDaten.Range("C2"), "erBis")
      Call FormelRefAendern(tabDaten.Range("D2"), _
         "Report.xls!erIntervallWithUnitToSec(erIntervall, erIntervallEinheit)")
    Case BEZ_BTR_PROTOKOLL
      Call FormelRefAendern(tabDaten.Range("J1"), "erProtokollTyp")
      Call FormelRefAendern(tabDaten.Range(""), "erVon")
      Call FormelRefAendern(tabDaten.Range(""), "erBis")
      Call FormelRefAendern(tabDaten.Range(""), _
         "Report.xls!erIntervallWithUnitToSec(erIntervall, erIntervallEinheit)")
    Case BEZ_STD_PROTOKOLL
      Call FormelRefAendern(tabDaten.Range("A2"), "erProtokollTyp")
      Call FormelRefAendern(tabDaten.Range("A3"), "erVon")
      Call FormelRefAendern(tabDaten.Range("A4"), "erBis")
      Call FormelRefAendern(tabDaten.Range("A6"), _
         "Report.xls!erIntervallWithUnitToSec(erIntervall, erIntervallEinheit)")
    End Select
  Next tabDaten

Exit Sub

M_Vorlage_Update_3_0_Fehler:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)

End Sub

Private Sub Update_3_1()
  
  On Error Resume Next
  With ActiveWorkbook
  .Names.Add "erProtokollTyp", Range("Konfiguration!$B$6")
  .Names.Add "erReportType", Range("Konfiguration!$B$6")
  .Names.Add "erFrom", Range("Konfiguration!$B$7")
  .Names.Add "erTo", Range("Konfiguration!$B$8")
  .Names.Add "erInterval", Range("Konfiguration!$B$9")
  .Names.Add "erIntervalUnit", Range("Konfiguration!$B$10")
  .Names.Add "erPeriod", Range("Konfiguration!$B$11")
  .Names.Add "erPeriodUnit", Range("Konfiguration!$B$12")
  End With
  
End Sub

Private Sub update_3_2()

Dim tabDaten As Worksheet
Dim rgDp     As Range
Dim oOpt     As C_Optionen
Dim n As Integer
Dim dpName As String
Dim sHelp As String
Dim asFkt() As String

  On Error GoTo M_Vorlage_Update_3_2_Fehler
  
  For Each tabDaten In ActiveWorkbook.Worksheets
  
    Select Case GetTabFormat(tabDaten)
      Case TAB_KONFIG
        tabDaten.Range(REF_PASSWORD).Offset(0, -1) = "Passwort"
        Set oOpt = M_Optionen.getOpt
        tabDaten.Range(REF_PASSWORD) = oOpt.UserPwd
        tabDaten.Range(REF_MIN_COLOR).Offset(0, -1) = "Min Color"
        tabDaten.Range(REF_MIN_COLOR).value = RGB(0, 255, 0)
        tabDaten.Range(REF_MAX_COLOR).Offset(0, -1) = "Max Color"
        tabDaten.Range(REF_MAX_COLOR).value = RGB(255, 0, 0)
        
        'Spalte mit Archvityp in DPList wird beim Analysieren
        'automatisch generiert
      Case BEZ_STD_PROTOKOLL
        'Neue Definition der Zeilen in die Spalte A eintragen
        tabDaten.Range("A8") = "ArchivTyp"
        tabDaten.Range("A9") = "Min/Max mark"
        'Spaltenweise die DP durchlaufen und Min/Max Markierung
        'Defaultm|fffd|ssig auf true setzten
        Set rgDp = tabDaten.Cells(2, 2)
        While (Not rgDp Is Nothing)
          If Len(rgDp.Text) > 0 And Len(rgDp.Offset(2, 0)) > 0 And Len(rgDp.Offset(3, 0)) > 0 Then
            rgDp.Offset(7, 0).value = True
            ' IM 82829 WOKL 3.10.07
            If rgDp.Offset(2, 0).value = "*" Then
               rgDp.Offset(6, 0).value = 6  ' HDB direkt
               
               M_Tools.StrToArray asFkt, rgDp.Offset(9, 0).value, "|"
               If rgDp.Offset(3, 0).value = "Differenz" Then Call StrAppend(asFkt, VAR_DIFF)
               If rgDp.Offset(3, 0).value = "Mittelwert" Then Call StrAppend(asFkt, VAR_MITTEL)
               If rgDp.Offset(3, 0).value = "Minimum" Then Call StrAppend(asFkt, VAR_MIN)
               If rgDp.Offset(3, 0).value = "Maximum" Then Call StrAppend(asFkt, VAR_MAX)
               If rgDp.Offset(3, 0).value = "Summe" Then Call StrAppend(asFkt, VAR_SUMME)
               M_Tools.ArrayToStr sHelp, asFkt, "|"
               rgDp.Offset(9, 0).value = sHelp
               
               rgDp.Offset(3, 0).value = "_offline.._value"
               sHelp = rgDp.value
               dpName = ElementN(sHelp, 1, ".")       ' Datenpunkt
               rgDp = dpName
               If dpName <> sHelp Then
                   rgDp.Offset(1, 0).value = Right(sHelp, Len(sHelp) - Len(dpName) - 1)
               End If
            Else
               rgDp.Offset(6, 0).value = 4
               If rgDp.Offset(3, 0).value = "Differenz" Then rgDp.Offset(3, 0).value = VAR_DIFF
               If rgDp.Offset(3, 0).value = "Mittelwert" Then rgDp.Offset(3, 0).value = VAR_MITTEL
               If rgDp.Offset(3, 0).value = "Minimum" Then rgDp.Offset(3, 0).value = VAR_MIN
               If rgDp.Offset(3, 0).value = "Maximum" Then rgDp.Offset(3, 0).value = VAR_MAX
               If rgDp.Offset(3, 0).value = "Summe" Then rgDp.Offset(3, 0).value = VAR_SUMME
            End If
          End If
          Set rgDp = MoveRange(rgDp, xlToRight)
        Wend

      Case BEZ_ATV_PROTOKOLL
        tabDaten.Range("G:G").Insert
        tabDaten.Range("G1") = "ArchivTyp"
        tabDaten.Range("H:H").Insert
        tabDaten.Range("H1") = "Min/Max mark"
        'Zeilenweise die DP durchlaufen und Min/Max Markierung
        'Defaultmaessig auf true setzten
        Set rgDp = tabDaten.Cells(1, 2)
        While (Not rgDp Is Nothing)
          If Len(rgDp.Text) > 0 And Len(rgDp.Offset(0, 2)) > 0 And Len(rgDp.Offset(0, 3)) > 0 Then
            rgDp.Offset(0, 6).value = 4
            rgDp.Offset(0, 7).value = True
          End If
          Set rgDp = MoveRange(rgDp, xlDown)
        Wend
      Case BEZ_BTR_PROTOKOLL
        tabDaten.Range("G:G").Insert
        tabDaten.Range("G1") = "ArchivTyp"
    End Select
  
  Next tabDaten
  
Exit Sub
M_Vorlage_Update_3_2_Fehler:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)
End Sub

Private Sub update_3_3()

Dim tabDaten As Worksheet
Dim rgDp     As Range
Dim n As Integer

  On Error GoTo M_Vorlage_Update_3_3_Fehler
  
  For Each tabDaten In ActiveWorkbook.Worksheets
  
    Select Case GetTabFormat(tabDaten)
      Case TAB_KONFIG
        tabDaten.Range("A20:C29").Insert xlDown
        tabDaten.Range(REF_USER).Offset(0, -1) = "User"
        tabDaten.Range(REF_REQUESTTYPE).Offset(0, -1) = "RequestType"
        tabDaten.Range(REF_LOGCHANGES).Offset(0, -1) = "LogChanges"
        tabDaten.Range(REF_LOGCHANGES).value = 0
        tabDaten.Range(REF_CREATION_DATE).Offset(0, -1) = "CreationDate"
        
        With ActiveWorkbook
          .Names.Add "erUserName", Range("Konfiguration!$B$16")
          .Names.Add "erUserFullName", Range("Konfiguration!$C$16")
          .Names.Add "erRequestType", Range("Konfiguration!$B$17")
          .Names.Add "erCreationDate", Range("Konfiguration!$B$19")
          .Names.Add "erLastUpDate", Range("Konfiguration!$C$19")
        End With
        
      Case BEZ_STD_PROTOKOLL
        tabDaten.Range("8:10").Insert
        tabDaten.Range("A8") = "Format"
        tabDaten.Range("A9") = "Unit"
        tabDaten.Range("A10") = "AutoFormat"
        
      Case BEZ_ATV_PROTOKOLL
        tabDaten.Range("G:I").Insert
        tabDaten.Range("G1") = "Format"
        tabDaten.Range("H1") = "Unit"
        tabDaten.Range("I1") = "AutoFormat"
        
      Case BEZ_BTR_PROTOKOLL
        tabDaten.Range("E1") = "Comment"
        tabDaten.Range("G:I").Insert
        tabDaten.Range("G1") = "Format"
        tabDaten.Range("H1") = "Unit"
        tabDaten.Range("I1") = "AutoFormat"
        tabDaten.Range("K1") = "Value"
    
    End Select
  
  Next tabDaten
  
Exit Sub
M_Vorlage_Update_3_3_Fehler:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)
End Sub


Private Sub update_3_6()

Dim tabDaten As Worksheet
Dim rgDp     As Range
Dim n As Integer

  On Error GoTo M_Vorlage_Update_3_6_Fehler
  
  For Each tabDaten In ActiveWorkbook.Worksheets
  
    Select Case GetTabFormat(tabDaten)
      Case TAB_KONFIG
        tabDaten.Range("A20:C20").Insert xlDown
        tabDaten.Range(REF_AREA_PERMISSIONS).Offset(0, -1) = "Areas"
        tabDaten.Range(REF_AREA_PERMISSIONS) = "0"    ' Default fuer: alle Bereiche
        
        With ActiveWorkbook
          .Names.Add "erAreaIndexes", Range("Konfiguration!$B$20")
        End With
    
    End Select
  
  Next tabDaten
  
Exit Sub
M_Vorlage_Update_3_6_Fehler:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)
End Sub

Private Sub update_3_7()

Dim tabDaten  As Worksheet
Dim rgDp      As Range
Dim n         As Long

  On Error GoTo M_Vorlage_Update_3_7_Error
  
  For Each tabDaten In ActiveWorkbook.Worksheets
  
    Select Case GetTabFormat(tabDaten)
      Case TAB_KONFIG
        n = tabDaten.Cells(1, 13).End(xlDown).Row - 2
        tabDaten.Columns(27).Insert (xlShiftToRight)
        tabDaten.Cells(1, 27).Value2 = "CCMedium"
        tabDaten.Columns(28).Insert (xlShiftToRight)
        tabDaten.Cells(1, 28).Value2 = "CCUnitFactor"
        If (n > 0) Then
          Set rgDp = tabDaten.Range(tabDaten.Cells(2, 28), tabDaten.Cells(2, 28).Offset(n, 0))
          rgDp.Value2 = 1   ' CCUnitFactor default
          rgDp.Offset(0, -1).Value2 = GetResText(16046)   ' <noMedium>
        End If
      Case BEZ_KST_PROTOKOLL
        n = tabDaten.Cells(2, 3).End(xlToRight).Column - 3
        tabDaten.Rows(19).Insert (xlShiftDown)
        tabDaten.Cells(19, 1).Value2 = "CostCenter Medium"
        Set rgDp = Range(tabDaten.Cells(19, 3), tabDaten.Cells(19, 3).Offset(0, n))
        rgDp.Value2 = GetResText(16046)   ' <noMedium>
        
        tabDaten.Rows(20).Insert (xlShiftDown)
        tabDaten.Cells(20, 1).Value2 = "CostCenter Unit Factor"
        rgDp.Offset(1, 0).Value2 = 1
      Case Else
        ' other tabs no change
    End Select
  
  Next tabDaten
  
Exit Sub
M_Vorlage_Update_3_7_Error:
  Call FehlerAusloesen(ERR_VORLAGE_VERSION_PRUEFEN)
End Sub


Private Sub FormelRefAendern(rgReferenz As Range, sBereichName As String)

Dim rgVerweis   As Range
Dim rgBereich   As Range
Dim sAdrAbs     As String
Dim sAdrRel     As String
Dim sFormel     As String
Dim sFormelAlt  As String

  sAdrAbs = rgReferenz.Address
  sAdrRel = TextErsetzen(rgReferenz.Address, "$", "")
  'Fehler wenn keine Abhaengigkeiten gefunden wurden
  On Error Resume Next
  Set rgBereich = rgReferenz.DirectDependents
  On Error GoTo 0
  
  If Not rgBereich Is Nothing Then
    For Each rgVerweis In rgBereich
      sFormelAlt = rgVerweis.Formula
      sFormel = TextErsetzen(sFormelAlt, sAdrAbs, sBereichName)
      sFormel = TextErsetzen(sFormelAlt, sAdrRel, sBereichName)
      On Error Resume Next
      rgVerweis.Formula = sFormel
      If Err Then
        Call BugMessage("Formel enthaelt einen Fehler: " & sFormel, "FormelRefAendern")
        rgVerweis.Formula = sFormelAlt
      End If
    Next rgVerweis
  End If
  
End Sub

'--------------------------------------------------------------------------------------------------
Public Function TabBereichLesen() As CO_TabBereich

Dim rgKonfig As Range
Dim oTabBereich As C_TabBereich
Dim coTabBereich As CO_TabBereich
Dim tabKonfig As Worksheet
  
  Set coTabBereich = New CO_TabBereich
  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)

  For Each rgKonfig In SelectRange(tabKonfig.Range(REF_PROT_TAB_BEREICH), 1, True)
    Set oTabBereich = New C_TabBereich
  
    oTabBereich.Blatt = rgKonfig.value
    oTabBereich.Bereich = rgKonfig.Offset(0, 1).value
    oTabBereich.Zeile = rgKonfig.Offset(0, 2).value
    oTabBereich.Spalte = rgKonfig.Offset(0, 3).value

    coTabBereich.Add oTabBereich
  Next rgKonfig
  
  Set TabBereichLesen = coTabBereich
End Function

'--------------------------------------------------------------------------------------------------
Public Sub TabBereichSpeichern(coTabBereich As CO_TabBereich)

Dim rgKonfig As Range
Dim oTabBereich As C_TabBereich
Dim tabKonfig As Worksheet

  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)
  
  'Definitionsbereich Tab-Bereich loeschen
  Set rgKonfig = SelectRange(tabKonfig.Range(REF_PROT_TAB_BEREICH), , True)
  rgKonfig = ""
  
  'Definitionsbereich neu erstellen
  Set rgKonfig = tabKonfig.Range(REF_PROT_TAB_BEREICH)
  For Each oTabBereich In coTabBereich.Items
  
    Set rgKonfig = rgKonfig.Offset(1, 0)
    rgKonfig.Offset(0, 0).value = oTabBereich.Blatt
    rgKonfig.Offset(0, 1).value = oTabBereich.Bereich
    rgKonfig.Offset(0, 2).value = oTabBereich.Zeile
    rgKonfig.Offset(0, 3).value = oTabBereich.Spalte
  
  Next oTabBereich
End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DefLesen(oProt As C_Protokoll)

Dim tabKonfig As Worksheet
Dim lID       As Long

  If oProt Is Nothing Then
    Set oProt = New C_Protokoll
  Else
    lID = oProt.ProtTyp.ID
  End If
  
  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)

  On Error Resume Next

  'Definierte Konstanten einsetzen
  Set oProt.wbProtokoll = ActiveWorkbook
  oProt.DateiTyp = tabKonfig.Range(REF_DATEI_TYP)
  'oProt.ProtFormat = TabKonfig.Range(REF_DATEI_BEZ)
  oProt.Version = tabKonfig.Range(REF_DATEI_VERSION)
  oProt.Seitenansicht = tabKonfig.Range(REF_SEITENANSICHT)
  If lID > 0 Then
    Set oProt.ProtTyp = M_ProtokollTyp.Lesen(ID:=lID)
  End If
  oProt.Bereich = tabKonfig.Range(REF_AREA_PERMISSIONS)

'Ist in der Vorlage noch nicht definiert
'  Set oProt.ProtTyp = M_ProtokollTyp.Lesen(tabKonfig.Range(REF_PROTOKOLL_TYP))
'  oProt.Von = tabKonfig.Range(REF_STARTZEIT)
'  oProt.Bis = tabKonfig.Range(REF_STOPPZEIT)
'  oProt.Intervall = tabKonfig.Range(REF_INTERVALL)
'  oProt.IntEinheit = tabKonfig.Range(REF_INT_EINHEIT)
'  oProt.Periode = tabKonfig.Range(REF_PERIODE)
'  oProt.PerEinheit = tabKonfig.Range(REF_PER_EINHEIT)

End Sub

'--------------------------------------------------------------------------------------------------
Public Sub DefSpeichern(oProt As C_Protokoll)

Dim tabKonfig As Worksheet

  Set tabKonfig = ActiveWorkbook.Worksheets(TAB_KONFIG)

  'Definierte Konstanten einsetzen
  tabKonfig.Range(REF_DATEI_TYP) = oProt.DateiTyp
  'TabKonfig.Range(REF_DATEI_BEZ) = oProt.ProtFormat
  tabKonfig.Range(REF_DATEI_VERSION) = oProt.Version
  tabKonfig.Range(REF_SEITENANSICHT) = oProt.Seitenansicht
  tabKonfig.Range(REF_PROTOKOLL_TYP) = oProt.ProtTyp.Bezeichnung

'Ist in der Vorlage noch nicht definiert
'  tabKonfig.Range(REF_STARTZEIT) = oProt.Von
'  tabKonfig.Range(REF_STOPPZEIT) = oProt.Bis
'  tabKonfig.Range(REF_INTERVALL) = oProt.Intervall
'  tabKonfig.Range(REF_INT_EINHEIT) = oProt.IntEinheit
'  tabKonfig.Range(REF_PERIODE) = oProt.Periode
'  tabKonfig.Range(REF_PER_EINHEIT) = oProt.PerEinheit

End Sub




Attribute VB_Name = "M_ZeitPlan"
'===================================================================================================
'M_Zeitplan
'Oliver Seidel 31.07.2000
'  Zentraler Zugriff auf die Protokolle (Class und Collection) fuer die zeitlich gesteuerte
'  Protokollerstellung.
'Aenderungen: -keine-
'===================================================================================================
Option Explicit
Option Private Module

Private TimerNaechsterAufruf As C_Timer
Private mcoZeitplan As CO_Protokoll
Private mvwZP       As V_Zeitplan

'---------------------------------------------------------------------------------------------------
Public Sub init()
  Set mcoZeitplan = Nothing
  Call ProtErstellenCB(boInit:=True)
End Sub
'---------------------------------------------------------------------------------------------------
Public Sub Reset()
  
  If Not TimerNaechsterAufruf Is Nothing Then
    TimerNaechsterAufruf.Reset
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub ProtErstellenCB(Optional boInit As Boolean = False)

Dim oProtokoll        As C_Protokoll
Dim dtAufruf          As Date
Dim dtNaechsterAufruf As Date
Dim lNextIntervall    As Long
Dim iBtn              As Integer
Dim dtVon             As Date
Dim dtBis             As Date
Dim oMailVerteiler    As C_MailVerteiler
Dim s As String

  s = M_Optionen.getOpt.HostZeitplan
  If (Len(s) > 0) And (s <> M_Tools.HostName) Then Exit Sub

  dtAufruf = Now
  dtNaechsterAufruf = DateAdd("s", 86400, Now)
  If Not boInit Then iBtn = vbYes
  
  If TimerNaechsterAufruf Is Nothing Then
    Set TimerNaechsterAufruf = New C_Timer
    TimerNaechsterAufruf.Funktion = TimerNaechsterAufruf.FktZeitPlan
  End If
  TimerNaechsterAufruf.Reset
  
  If mcoZeitplan Is Nothing Then
    Set mcoZeitplan = coLesen
  End If
  
  For Each oProtokoll In mcoZeitplan.Items
    With oProtokoll
      If DateDiff("s", dtAufruf, .zpNaechterAufruf) < 5 Then
        If .ID = 0 Or .ProtTyp.BasiswertDaten.ID = 0 Then
          .zpAktiv = False
        Else
          'Der zuletzt gueltige Zeitbeich muss erst berechnet werden,
          'da dieser durchaus schon laenger zurueckliegen kann
          dtVon = 0 '.zpNaechterAufruf
          dtBis = 0
          '.ProtTyp.Zeitbereich dtVon, dtBis, True, oProtokoll.Zeitbereich
          .ProtTyp.Zeitbereich dtVon, dtBis, False, oProtokoll.Zeitbereich, .zpNaechterAufruf
          .Von = dtVon
          .Bis = dtBis
          .zpNaechterAufruf = DateAdd(getIntFormatStr(.zpIntEinheit), _
                                      .zpIntervall, _
                                      .zpNaechterAufruf)
        End If
        '
        If iBtn = 0 And .zpAktiv Then
          iBtn = MsgBox(GetResText(21163), _
                        vbYesNo + vbQuestion, _
                        GetResText(20105))
        End If
        If iBtn = vbYes And .zpAktiv Then
          On Error Resume Next
          BugMessage ("Erstelle Protkoll! " & .Vorlage)
          oProtokoll.Username = M_Tools.Username
          oProtokoll.UserFullName = M_Tools.UserFullName
          oProtokoll.RequestType = REQUESTTYPE_TIME
          Call M_Protokoll.ProtErstellen(oProtokoll, True)
          If Err Then
            .zpStatus = 2
          Else
            .zpStatus = 0
            
            'Protokoll per EMail verschicken
            Set oMailVerteiler = M_MailVerteiler.Lesen(.zpMailVerteiler)
            If Not oMailVerteiler Is Nothing Then
              On Error Resume Next
              Call M_MailVerteiler.Senden(oProtokoll, oMailVerteiler)
              
              If Err Then
                Err.Clear
                .zpStatus = 2
              End If
              
              'HTML Speichern
              If oProtokoll.zpHTML Then
                Call M_Protokoll.SpeichernHTML(oProtokoll)
              End If
            
            End If
          End If
          .wbProtokoll.Close SaveChanges:=False
        Else
          'ToDo: Zeitpunkt fuer naechsten Aufruf ab jetzt berechnen!
          lNextIntervall = DateDiff(getIntFormatStr(.zpIntEinheit), _
                                    .zpNaechterAufruf, Now)
          .zpNaechterAufruf = DateAdd(getIntFormatStr(.zpIntEinheit), _
                                      lNextIntervall, .zpNaechterAufruf)
          'Hat DateDiff den nun auf- oder abgerundet?
          If .zpNaechterAufruf < Now Then
            .zpNaechterAufruf = DateAdd(getIntFormatStr(.zpIntEinheit), _
                                        .zpIntervall, .zpNaechterAufruf)
          End If
          .zpStatus = 1
        End If
      End If
      
      If DateDiff("s", dtNaechsterAufruf, .zpNaechterAufruf) < 0 Then
        dtNaechsterAufruf = .zpNaechterAufruf
      End If
      
    End With
    Set oProtokoll = Nothing
  Next oProtokoll

  'Damit auch von anderen Stationen aus der aktuelle Status gesehen wird...
  Call M_ZeitPlan.coSpeichern(mcoZeitplan)

  If Not mvwZP Is Nothing Then
    mvwZP.Protokoll_Anzeigen
  End If

  lNextIntervall = DateDiff("s", Now, dtNaechsterAufruf)
  'Achtung Ueberlauf bei mehr als 25 Tagen (wegen Millisekunden)
  If lNextIntervall > 86400 Then
    lNextIntervall = 86400
  ElseIf lNextIntervall < 5 Then
    lNextIntervall = 5
  End If
  
  Call BugMessage("Naechster Aufruf in " & lNextIntervall & " Sekunden!")
  Call TimerNaechsterAufruf.init(lNextIntervall * 1000)

End Sub


'---------------------------------------------------------------------------------------------------
Public Sub coEdit()

Dim vwProtokoll As V_Zeitplan
Dim coProtokoll As CO_Protokoll

  Set vwProtokoll = New V_Zeitplan
  Set mvwZP = vwProtokoll
  Set coProtokoll = coLesen
  Set vwProtokoll.Protokoll = coProtokoll
  vwProtokoll.Show
  If vwProtokoll.ok Then
    Set mcoZeitplan = Nothing
    Call coSpeichern(coProtokoll)
  Else
    Set mcoZeitplan = Nothing
  End If

  Set mvwZP = Nothing
  Unload vwProtokoll
  Set vwProtokoll = Nothing
  DoEvents
  
  Call ProtErstellenCB

End Sub 'coEdit()

'---------------------------------------------------------------------------------------------------
Public Function coLesen() As CO_Protokoll

Dim recProtokoll  As ADODB.Recordset
Dim sSql          As String
Dim oProtokoll    As C_Protokoll

Dim alId()          As Long
Dim asBezeichnung() As String
Dim lID             As Long
Dim n               As Long
  
  On Error GoTo Protokoll_Lesen_Fehler

  If Not mcoZeitplan Is Nothing Then
    Set coLesen = mcoZeitplan
    Exit Function
  End If

  Set coLesen = New CO_Protokoll
  sSql = "SELECT * FROM tabZeitplan"
  Set recProtokoll = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)
  
  While Not recProtokoll.EOF
    Set oProtokoll = New C_Protokoll
    oProtokoll.ID = recProtokoll.Fields("ID")
    oProtokoll.Bezeichnung = recProtokoll.Fields("Bezeichnung")
    oProtokoll.Vorlage = recProtokoll.Fields("Vorlage")
    
    lID = recProtokoll.Fields("ProtTyp")
    If lID > 0 Then
    Set oProtokoll.ProtTyp = M_ProtokollTyp.Lesen(ID:=lID)
    End If
'    If lID > 0 Then
'      Call getProtTypBezeichner(alID, asBezeichnung)
'      For n = 1 To UBound(alID)
'        If alID(n) = lID Then
'          oProtokoll.ProtTyp.ID = lID
'          oProtokoll.ProtTyp.Bezeichnung = asBezeichnung(n)
'          Exit For
'        End If
'      Next n
'    End If
    
    oProtokoll.Drucken = recProtokoll.Fields("Drucken")
    oProtokoll.Speichern = recProtokoll.Fields("Speichern")
    oProtokoll.Schliessen = False 'ist eigendlich ein 'true', wird
                                  'aber wegen EMail spaeter erledigt!
    oProtokoll.zpIntervall = recProtokoll.Fields("Intervall")
    oProtokoll.zpIntEinheit = recProtokoll.Fields("IntEinheit")
    oProtokoll.zpNaechterAufruf = recProtokoll.Fields("NaechsterAufruf")
    oProtokoll.zpAktiv = recProtokoll.Fields("Aktiv")
    oProtokoll.zpStatus = recProtokoll.Fields("Status")
    oProtokoll.zpMailVerteiler = recProtokoll.Fields("MailVerteiler")
    oProtokoll.zpHTML = recProtokoll.Fields("HTML")
    oProtokoll.Zeitbereich = recProtokoll.Fields("Zeitbereich")
    oProtokoll.zpFilePath = recProtokoll.Fields("FilePath") ' IM 115373 ICSGEAD
    
    recProtokoll.MoveNext
    coLesen.Add oProtokoll
  Wend
  Call M_DB.CloseRecordset(recProtokoll)

Exit Function
Protokoll_Lesen_Fehler:
  Call M_DB.CloseRecordset(recProtokoll)
  Call FehlerAusloesen(30700, Err.Description, False, "M_Zeitplan::coLesen")
End Function 'coLesen()

'---------------------------------------------------------------------------------------------------
Public Function Lesen(ID As Long) As C_Protokoll

Dim recProtokoll  As ADODB.Recordset
Dim oProtokoll    As C_Protokoll
Dim sSql          As String

Dim alId()          As Long
Dim asBezeichnung() As String
Dim lID             As Long
Dim n               As Long

  On Error GoTo Protokoll_Suchen_Fehler

  If Not mcoZeitplan Is Nothing Then
    For Each oProtokoll In mcoZeitplan.Items
      If oProtokoll.ID = ID Then
        Set Lesen = oProtokoll
        Exit Function
      End If
    Next oProtokoll
  End If

  Set oProtokoll = New C_Protokoll

  sSql = "SELECT * FROM tabZeitplan WHERE ID = " & ID & ";"
  Set recProtokoll = M_DB.OpenRecordset(sSql, adOpenForwardOnly, adLockReadOnly)

  If Not recProtokoll.EOF Then
    
    oProtokoll.ID = recProtokoll.Fields("ID")
    oProtokoll.Bezeichnung = recProtokoll.Fields("Bezeichnung")
    oProtokoll.Vorlage = recProtokoll.Fields("Vorlage")
    lID = recProtokoll.Fields("ProtTyp")
    Set oProtokoll.ProtTyp = M_ProtokollTyp.Lesen(ID:=lID)
'    If lID > 0 Then
'      Call getProtTypBezeichner(alID, asBezeichnung)
'      For n = 1 To UBound(alID)
'        If alID(n) = lID Then
'          oProtokoll.ProtTyp.ID = lID
'          oProtokoll.ProtTyp.Bezeichnung = asBezeichnung(n)
'          Exit For
'        End If
'      Next n
'    End If
    oProtokoll.Drucken = recProtokoll.Fields("Drucken")
    oProtokoll.Speichern = recProtokoll.Fields("Speichern")
    oProtokoll.Schliessen = True
    oProtokoll.zpIntervall = recProtokoll.Fields("Intervall")
    oProtokoll.zpIntEinheit = recProtokoll.Fields("IntEinheit")
    oProtokoll.zpNaechterAufruf = recProtokoll.Fields("NaechsterAufruf")
    oProtokoll.zpAktiv = recProtokoll.Fields("Aktiv")
    oProtokoll.zpStatus = recProtokoll.Fields("Status")
    oProtokoll.zpMailVerteiler = recProtokoll.Fields("MailVerteiler")
    oProtokoll.zpHTML = recProtokoll.Fields("HTML")
    oProtokoll.Zeitbereich = recProtokoll.Fields("Zeitbereich")
    oProtokoll.zpFilePath = recProtokoll.Fields("FilePath") ' IM 115373 WOKL additional (?) ICSGEAD
    
  End If
  Call M_DB.CloseRecordset(recProtokoll)
  Set Lesen = oProtokoll

Exit Function
Protokoll_Suchen_Fehler:
  Call M_DB.CloseRecordset(recProtokoll)
  Call FehlerAusloesen(30705, Err.Description, False, "M_Zeitplan::Lesen")
End Function 'Lesen()

'---------------------------------------------------------------------------------------------------
Public Sub coSpeichern(coProtokoll As CO_Protokoll)

Dim recProtokoll  As ADODB.Recordset
Dim oProtokoll    As C_Protokoll
Dim sSql          As String
Dim lLoeschen     As Long

  On Error GoTo Protokoll_Speichern_Fehler

  'Set mcoZeitplan = Nothing

  'DB oeffnen und alle Datensaetz zum Loeschen makieren
  sSql = "UPDATE tabZeitplan SET Loeschen = 1"
  M_DB.getConnection.Execute sSql, lLoeschen

  sSql = "SELECT * FROM tabZeitplan"
  Set recProtokoll = M_DB.OpenRecordset(sSql, adOpenDynamic, adLockOptimistic)
  
  For Each oProtokoll In coProtokoll.Items

    If recProtokoll.BOF And recProtokoll.EOF Then
      recProtokoll.AddNew
    Else
      recProtokoll.MoveFirst 'Reihenfolge ist nicht zwingend vorgegeben
      recProtokoll.Find "ID = " & oProtokoll.ID, , adSearchForward
      If recProtokoll.EOF Then
        recProtokoll.AddNew
      Else
        'recProtokoll.Edit
        recProtokoll.Fields("Loeschen") = 0
        lLoeschen = lLoeschen - 1
      End If
    End If
    
    recProtokoll.Fields("Bezeichnung") = oProtokoll.Bezeichnung
    recProtokoll.Fields("Vorlage") = oProtokoll.Vorlage
    recProtokoll.Fields("ProtTyp") = oProtokoll.ProtTyp.ID
    
    recProtokoll.Fields("Drucken") = oProtokoll.Drucken
    recProtokoll.Fields("Speichern") = oProtokoll.Speichern
    recProtokoll.Fields("Intervall") = oProtokoll.zpIntervall
    recProtokoll.Fields("IntEinheit") = oProtokoll.zpIntEinheit
    recProtokoll.Fields("NaechsterAufruf") = oProtokoll.zpNaechterAufruf
    recProtokoll.Fields("Aktiv") = oProtokoll.zpAktiv
    recProtokoll.Fields("Status") = oProtokoll.zpStatus
    recProtokoll.Fields("MailVerteiler") = oProtokoll.zpMailVerteiler
    recProtokoll.Fields("HTML") = oProtokoll.zpHTML
    recProtokoll.Fields("Zeitbereich") = oProtokoll.Zeitbereich
    recProtokoll.Fields("FilePath") = oProtokoll.zpFilePath ' IM 115373 ICSGEAD
    
    recProtokoll.Update
    'recProtokoll.Bookmark = recProtokoll.LastModified
    oProtokoll.ID = recProtokoll.Fields("ID")

  Next oProtokoll

  Call M_DB.CloseRecordset(recProtokoll)

  sSql = "DELETE FROM tabZeitplan WHERE Loeschen <> 0"
  M_DB.getConnection.Execute sSql

Exit Sub
Protokoll_Speichern_Fehler:
  Set mcoZeitplan = Nothing
  Call M_DB.CloseRecordset(recProtokoll)
  Call FehlerAusloesen(30703, Err.Description, False, "M_Zeitplan::coSpeichern")
End Sub 'coSpeichern()

Attribute VB_Name = "TabMenue"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "lstProtAnwahl, 6, 0, MSForms, ListBox"
Attribute VB_Control = "btnVorlage_Neu, 2, 1, MSForms, CommandButton"
Attribute VB_Control = "btnProtokoll_Oeffnen, 3, 2, MSForms, CommandButton"
Attribute VB_Control = "btnProtokoll_Neu, 4, 3, MSForms, CommandButton"
Attribute VB_Control = "btnVorlage_Oeffnen, 5, 4, MSForms, CommandButton"
Attribute VB_Control = "btnProtErstellen, 7, 5, MSForms, CommandButton"

'===================================================================================================
'TabMenue
'Oliver Seidel 28.09.2000
'  Implementierung der Oberflaeche
'  - Vorlagen und Protokolle koennen erstellt und geoeffnet werden
'  - Schnellanwahl der Protokolle
'  - Steuerelemente werden automatische plaziert und beschriftet
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

'---------------------------------------------------------------------------------------------------
Private Sub btnVorlage_Oeffnen_Click()
  Call M_Menue.mnuVorlage_Oeffnen
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub btnVorlage_Neu_Click()
  Call M_Menue.mnuVorlage_Neu
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnProtokoll_Oeffnen_Click()
  Call M_Menue.mnuProt_Oeffnen
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub btnProtokoll_Neu_Click()
  Call M_Menue.mnuProt_Neu
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnProtErstellen_Click()

Dim lID As Long
Dim oProtokoll As C_Protokoll

  If lstProtAnwahl.ListIndex >= 0 Then
    If lstProtAnwahl.Text <> "" Then
      lID = lstProtAnwahl.List(lstProtAnwahl.ListIndex, 1)
      Set oProtokoll = M_Schnellanwahl.Lesen(lID)
      oProtokoll.Username = M_Tools.Username
      oProtokoll.UserFullName = M_Tools.UserFullName
      oProtokoll.RequestType = REQUESTTYPE_MAN
      Call M_Protokoll.ProtErstellen(oProtokoll, False)
    End If
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub SchnellanwahlAnzeigen()

Dim coProtokoll As CO_Protokoll
Dim n As Long
Dim index As Long

  'Leider ist dies auch ein Klassenobjekt
  'daher keine Fehlerbehandlung moeglich :(
  On Error Resume Next
  
  Set coProtokoll = M_Schnellanwahl.coLesen
  If Err Then Exit Sub
  
  lstProtAnwahl.Clear
  index = 1   ' Z|fffd|hler in der ListBox
  For n = 1 To coProtokoll.Count
    With coProtokoll.Item(n)
      If (M_PVSSLogin.CheckAreaAuth(.Bereich, PL_AREA_PROT_NEW)) Then
        lstProtAnwahl.AddItem
        lstProtAnwahl.List(index - 1, 0) = .Bezeichnung
        lstProtAnwahl.List(index - 1, 1) = .ID
        index = index + 1
      End If
    End With
  Next n
  lstProtAnwahl.AddItem ""
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lstProtAnwahl_DblClick(ByVal cancel As MSForms.ReturnBoolean)
  Call btnProtErstellen_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Worksheet_Activate()
  Call Anzeigen
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Anzeigen()

Dim zOrder(1 To 6) As MsoZOrderCmd
Dim i As Integer
  
  'Warum sich auch immer das bloede Ding
  'beim aktivieren der Arbeitsmappe verstellt...
  lstProtAnwahl.Top = 240
  lstProtAnwahl.Left = btnProtErstellen.Left
  'Es soll ja nicht alles verstellen DOE, 27.06.11 / IM 104679 7.6.11 WOKL
'  lstProtAnwahl.Height = 147
'  lstProtAnwahl.Width = 220

  TabMenue.Activate
  ActiveSheet.Range("A1").Select
  ActiveSheet.Unprotect
  On Error Resume Next
  Range("C8") = GetResText(18101)
  btnVorlage_Oeffnen.Caption = GetResText(18102)
  btnVorlage_Neu.Caption = GetResText(18103)
  Range("G8") = GetResText(18104)
  btnProtokoll_Oeffnen.Caption = GetResText(18105)
  btnProtokoll_Neu.Caption = GetResText(18106)
  Range("K8") = GetResText(18107)
  btnProtErstellen.Caption = GetResText(18108)
  
  ' IM 95750 Polnisch: 0 wird nicht verwendet, 1-deutsch, ...
  ' IM 117752 Russisch: 6
  For i = 1 To 6
    zOrder(i) = msoSendToBack
  Next
  If (M_Optionen.getSpracheID > 0 And M_Optionen.getSpracheID < 7) Then
    zOrder(M_Optionen.getSpracheID) = msoBringToFront
  Else
    zOrder(2) = msoBringToFront ' englisch default
  End If

  'Deutsch: grosse Grafik wird nicht veraendert
  '
  'Englisch
  Call ActiveSheet.Shapes("Template").zOrder(zOrder(2))
  Call ActiveSheet.Shapes("Report").zOrder(zOrder(2))
  Call ActiveSheet.Shapes("QuickSelection").zOrder(zOrder(2))
  'Franzoesisch
  Call ActiveSheet.Shapes("Modele").zOrder(zOrder(3))
  Call ActiveSheet.Shapes("Protocole").zOrder(zOrder(3))
  Call ActiveSheet.Shapes("SelectionRapide").zOrder(zOrder(3))
  'Italienisch
  Call ActiveSheet.Shapes("Modello").zOrder(zOrder(4))
  Call ActiveSheet.Shapes("Protocollo").zOrder(zOrder(4))
  Call ActiveSheet.Shapes("SelizioneRapida").zOrder(zOrder(4))
  'Polnisch
  Call ActiveSheet.Shapes("Zsablon").zOrder(zOrder(5))
  Call ActiveSheet.Shapes("Protokol").zOrder(zOrder(5))
  Call ActiveSheet.Shapes("SzybkiWybor").zOrder(zOrder(5))
  'Russisch
  Call ActiveSheet.Shapes("ru_Vorlage").zOrder(zOrder(6))
  Call ActiveSheet.Shapes("ru_Protokoll").zOrder(zOrder(6))
  Call ActiveSheet.Shapes("ru_Schnellanwahl").zOrder(zOrder(6))

  ActiveSheet.Shapes("LoginName").Select
  Selection.Characters.Text = ""
  
  Call ActiveSheet.Protect(DrawingObjects:=True, Contents:=True, Scenarios:=True)

End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Excel.Range)
  If Target.Address <> "$A$1" Then
    Range("A1").Select
  End If
End Sub

Attribute VB_Name = "TabResText"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True







Attribute VB_Name = "V_ArchivDetail"
Attribute VB_Base = "0{560C5A3E-8859-4A9B-9E7F-E664AD8CB184}{AF4C5A92-40B7-4E39-A224-D69836645C48}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' WOKL 12.9.07 dieses Modul wird derzeit scheinbar nicht benutzt
' habs nicht gefunden im ganzen Projekt

Option Explicit

Private msDPT As String
Private msDPE As String
Private msVStufe As String
Private moArchiv  As C_Archiv

Private mboOK  As Boolean

Public Property Get ok() As Boolean
  ok = mboOK
End Property


Public Property Get Archiv() As C_Archiv
  Set Archiv = moArchiv
End Property

Public Property Let dpt(sDPT As String)
  If msDPT <> sDPT Then
    msDPT = sDPT
  End If
End Property
Public Property Get dpt() As String
  dpt = msDPT
End Property

Public Property Let dpe(sDPE As String)
  msDPE = sDPE
End Property
Public Property Get dpe() As String
  dpe = msDPE
End Property

Public Property Let VStufe(sVStufe As String)
  msVStufe = sVStufe
End Property
Public Property Get VStufe() As String
  VStufe = msVStufe
End Property

Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

Private Sub cboDPE_Change()

Dim asVStufe() As String
Dim i As Integer

  msDPE = cboDPE.Text
  msVStufe = ""
  Call getVStufe(asVStufe, cboDPTyp.value, cboDPE.value)
  cboVStufe.Clear
  For i = 1 To UBound(asVStufe)
    cboVStufe.AddItem asVStufe(i)
  Next i

End Sub

Private Sub cboDPTyp_Change()

Dim asDPE() As String
Dim i As Integer

  msDPT = cboDPTyp.Text
  msDPE = ""
  msVStufe = ""
  Call getArchivDPE(asDPE, "*", cboDPTyp.value)
  cboVStufe.Clear
  cboDPE.Clear
  For i = 1 To UBound(asDPE)
    cboDPE.AddItem asDPE(i)
  Next i

End Sub

Private Sub cboVStufe_Change()
  msVStufe = cboVStufe.Text
  Set moArchiv = M_DB.getArchiv(msDPT, msDPE, msVStufe)
  If Not moArchiv Is Nothing Then
    btnOK.Enabled = True
  Else
    btnOK.Enabled = False
  End If
End Sub


Private Sub UserForm_Initialize()

Dim asDpt() As String
Dim i As Integer

  Call FormularBeschriften(Me)
  btnOK.Enabled = False

  Call getDPTyps("dist_1", asDpt)
  cboDPTyp.Clear
  For i = 1 To UBound(asDpt)
    cboDPTyp.AddItem asDpt(i)
  Next i
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub


Attribute VB_Name = "V_ArchivMsg"
Attribute VB_Base = "0{1E3AA46D-FDC2-476C-9896-DD709E49E9DF}{447AFEB8-5E4D-4493-9BFF-B02BBD061B0F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_ArchivMsg
'Wolfram Klebel, 30.11.11
'
' Display for messages during archiv data import
'
'Changes: -none-
'===================================================================================================
Option Explicit

Private mcArchivMsg       As C_ArchivMsg

'---------------------------------------------------------------------------------------------------
' This property sets the class object as reference
Public Property Set archivMsg(archivMsg As C_ArchivMsg)
  
  Set mcArchivMsg = archivMsg
  
  cbRDBPara.value = mcArchivMsg.mboRDBPara
  cbACPara.value = mcArchivMsg.mboACPara
  lblText.Caption = mcArchivMsg.msMsg
  
  cbRDBPara.Enabled = mcArchivMsg.mbAcRdbSelect
  cbACPara.Enabled = mcArchivMsg.mbAcRdbSelect
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get archivMsg() As C_ArchivMsg
  Set archivMsg = mcArchivMsg
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get keyPressed()
  keyPressed = mcArchivMsg.miLastKeyPressed
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnYes_Click()

  If (cboAllSystems.value = True) Then
    mcArchivMsg.miLastKeyPressed = ARCHMSG_ALL_SYSTEMS
  ElseIf (cboAllSteps.value = True) Then
    mcArchivMsg.miLastKeyPressed = ARCHMSG_THIS_SYSTEM
  Else
    mcArchivMsg.miLastKeyPressed = ARCHMSG_YES
  End If
  
  Me.Hide
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub btnNo_Click()
  mcArchivMsg.miLastKeyPressed = ARCHMSG_NO
  Me.Hide
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub btnCancel_Click()
  mcArchivMsg.miLastKeyPressed = ARCHMSG_CANCEL
  Me.Hide
End Sub


'---------------------------------------------------------------------------------------------------
Private Sub cbACPara_Click()
  mcArchivMsg.mboACPara = cbACPara.value
  If (cbRDBPara.value = False And cbACPara.value = False) Then
    cbRDBPara.value = True
  End If
End Sub

Private Sub cboAllSteps_Click()

  If (cboAllSystems.value = True And cboAllSteps.value = False) Then
    cboAllSteps.value = True
  End If
  
End Sub

Private Sub cboAllSystems_Click()

  If (cboAllSystems.value = True) Then
    cboAllSteps.value = True
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbRDBPara_Click()
  mcArchivMsg.mboRDBPara = cbRDBPara.value
  If (cbRDBPara.value = False And cbACPara.value = False) Then
    cbACPara.value = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

  Call FormularBeschriften(Me)
  
  ' if not RDB, then rearrange the form design
  If (Not IS_RDBACTIVE) Then
    cbRDBPara.Visible = False
    cbACPara.Visible = False
    
    cboAllSteps.Left = 12
    cboAllSystems.Left = 12
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_activate()

  ' hide "for all systems" if there is only one system available
  If (mcArchivMsg.miSysCount <= 1) Then
    cboAllSystems.Enabled = False
  End If
  
  ' first time 'all steps' is default true
  If (mcArchivMsg.miLastKeyPressed = ARCHMSG_INIT) Then
    cboAllSteps.value = True
  End If
  
End Sub

Attribute VB_Name = "V_Archiv_Sucher"
Attribute VB_Base = "0{D77C5B9D-F672-4C8C-B749-8B0045D3FBCD}{66B27A18-12DE-4829-BC2B-2D212BF11AFE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Archiv_Sucher
'Oliver Seidel 14.07.2000
'   Aenderungen: -keine-
'Wolfram Klebel 12.9.07
'   SYS zugebaut IM 79802
'
'===================================================================================================
Option Explicit

Private mcoArchiv As CO_Archiv
Private mboOK As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let IntervallFilterStr(sFilter As String)

Dim i As Integer

  For i = 1 To cboIntervallStr.ListCount
    If cboIntervallStr.List(i - 1) = sFilter Then
      cboIntervallStr.ListIndex = i - 1
      Exit For
    End If
  Next i

End Property

'---------------------------------------------------------------------------------------------------
Public Property Get AusgewaehlteArchive() As CO_Archiv

Dim lstItem As ListItem

  Set AusgewaehlteArchive = New CO_Archiv
  For Each lstItem In lvwArchiv.ListItems
    If lstItem.Selected Then
      AusgewaehlteArchive.Add mcoArchiv.FindItem(CStr(lstItem.Text))
    End If
  Next lstItem

End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboSYS_Change()

Dim asDpt() As String
Dim i As Integer

  cboDPT.Clear
  cboDPT.AddItem "*"
  Call M_DB.getDPTyps(cboSYS.Text, asDpt)
  For i = 1 To UBound(asDpt)
    cboDPT.AddItem asDpt(i)
  Next i
  cboDPT.ListIndex = 0

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPT_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPT_Change()

Dim asDPE() As String
Dim i As Integer

  Call getArchivDPE(asDPE, cboSYS.Text, cboDPT.value)
  cboDPE.Clear
  cboDPE.AddItem "*"
  For i = 1 To UBound(asDPE)
    cboDPE.AddItem asDPE(i)
  Next i
  cboDPE.ListIndex = 0

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPE_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPE_Change()

Dim asInt() As String
Dim i As Integer

  Call getIntervallStr(asInt, cboSYS.Text, cboDPT.value, cboDPE.value)
  
  cboIntervallStr.Clear
  cboIntervallStr.AddItem "*"
  For i = 1 To UBound(asInt)
    cboIntervallStr.AddItem asInt(i)
  Next i
  cboIntervallStr.ListIndex = 0

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboIntervallStr_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboIntervallStr_Change()
  Call ArchivAnzeigen
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwArchiv_ColumnClick(ByVal ColumnHeader As MSComctlLib.ColumnHeader)
  lvwArchiv.SortKey = ColumnHeader.index - 1
  lvwArchiv.Sorted = True
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim lstHeader As ColumnHeader
Dim asSYS()   As String
Dim asDpt()   As String
Dim i         As Integer

  Call FormularBeschriften(Me)
  Set mcoArchiv = New CO_Archiv

  With lvwArchiv
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .MultiSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
   
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16040) '"DP System"
    lstHeader.Width = 57.75
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16000) '"DP Typ"
    lstHeader.Width = 57.75
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16001) '"DP Element"
    lstHeader.Width = 100
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16004) '"VStufe"
    lstHeader.Width = 36
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16011) '"Intervall"
    lstHeader.Width = 66
    .SortKey = 1
    .Sorted = True
  End With
  
  mboOK = False
  
  cboSYS.AddItem "*"
  Call M_DB.getDPSyss(asSYS)
  For i = 1 To UBound(asSYS)
    cboSYS.AddItem asSYS(i)
  Next i
  cboSYS.ListIndex = 0

  Set mcoArchiv = M_Archiv.coLesen
  Call ArchivAnzeigen
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub ArchivAnzeigen()

Dim oArchiv As C_Archiv
Dim lstItem As ListItem

  lvwArchiv.ListItems.Clear
  
  For Each oArchiv In mcoArchiv.Items
    With oArchiv
      If (.SYS Like cboSYS.Text) And _
         (.dpt Like cboDPT.Text) And _
         (.dpe Like cboDPE.Text) And _
         (.IntervallStr Like cboIntervallStr.Text) Then
        
        Set lstItem = lvwArchiv.ListItems.Add
        lstItem.Text = CStr(.ID)
        lstItem.SubItems(1) = .SYS
        lstItem.SubItems(2) = .dpt
        lstItem.SubItems(3) = .dpe
        lstItem.SubItems(4) = .VStufe
        lstItem.SubItems(5) = .IntervallStr
      
      End If
    End With
  Next oArchiv

End Sub

Attribute VB_Name = "V_AuswahlProtTypen"
Attribute VB_Base = "0{DF0EA732-B2FE-4468-89B4-65C4B6041467}{2C0F46BA-35BD-4C9A-951F-35283D4C4D5B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_AuswahlProtTypen
'
'Oliver Seidel
'28.10.98
'
'Auswahl der fuer diese Vorlage geltenden Protokolltypen.
'
'Aenderungen:
'  Moegliche DPTypen entfernt
'===================================================================================================
Option Explicit

Private Type T_ProtTyp
  sProtTyp  As String
  boVorlage As Boolean
  asDpt()   As String
End Type

Private maudProtTyp()   As T_ProtTyp
Private mboOK As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Seitenansicht() As Boolean
  Seitenansicht = chkSeitenansicht.value
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Seitenansicht(boSeitenansicht As Boolean)
  chkSeitenansicht = boSeitenansicht
End Property

'---------------------------------------------------------------------------------------------------
Public Sub setProtokolltypen(ByRef asProtTyp() As String)

Dim i As Integer
Dim j As Integer

  For i = 1 To UBound(asProtTyp)
    For j = 1 To UBound(maudProtTyp)
      If asProtTyp(i) = maudProtTyp(j).sProtTyp Then
        maudProtTyp(j).boVorlage = True
      End If
    Next j
  Next i
  Call AnzeigeAktualisieren
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub getProtokolltypen(ByRef asProtTyp() As String)

Dim i As Integer

  ReDim asProtTyp(0)
  For i = 1 To UBound(maudProtTyp)
    If maudProtTyp(i).boVorlage Then
      ReDim Preserve asProtTyp(UBound(asProtTyp) + 1)
      asProtTyp(UBound(asProtTyp)) = maudProtTyp(i).sProtTyp
    End If
  Next i
  
End Sub

'---------------------------------------------------------------------------------------------------
Public Property Let MinColor(lColor As Long)
  btnMinColor.BackColor = lColor
End Property
Public Property Get MinColor() As Long
  MinColor = btnMinColor.BackColor
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let MaxColor(lColor As Long)
  btnMaxColor.BackColor = lColor
End Property
Public Property Get MaxColor() As Long
  MaxColor = btnMaxColor.BackColor
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let LogChanges(boLogChanges As Boolean)
  chkLogChanges.value = boLogChanges
End Property
Public Property Get LogChanges() As Boolean
  LogChanges = chkLogChanges.value
End Property


'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnMinColor_Click()

Dim vwColor As V_ColorPicker

  Set vwColor = New V_ColorPicker
  vwColor.Color = btnMinColor.BackColor
  vwColor.Show
  If vwColor.ok Then
    btnMinColor.BackColor = vwColor.Color
  End If
  
  Unload vwColor
  Set vwColor = Nothing
  
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub btnMaxColor_Click()

Dim vwColor As V_ColorPicker

  Set vwColor = New V_ColorPicker
  vwColor.Color = btnMaxColor.BackColor
  vwColor.Show
  If vwColor.ok Then
    btnMaxColor.BackColor = vwColor.Color
  End If
  
  Unload vwColor
  Set vwColor = Nothing
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnProtTypAbwahl_Click()
  
Dim i As Integer

  If lstProtTypVorlage.ListIndex >= 0 Then
    i = CInt(lstProtTypVorlage.List(lstProtTypVorlage.ListIndex, 1))
    maudProtTyp(i).boVorlage = False
    Call AnzeigeAktualisieren
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnProtTypAbwahlAlle_Click()

Dim i As Integer
  
  For i = 1 To UBound(maudProtTyp)
    maudProtTyp(i).boVorlage = False
  Next i
  Call AnzeigeAktualisieren
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnProtTypAuswahl_Click()
  
Dim i As Integer

  If lstProtTypVorhanden.ListIndex >= 0 Then
    i = CInt(lstProtTypVorhanden.List(lstProtTypVorhanden.ListIndex, 1))
    maudProtTyp(i).boVorlage = True
    Call AnzeigeAktualisieren
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnProtTypAuswahlAlle_Click()

Dim i As Integer
  
  For i = 1 To UBound(maudProtTyp)
    maudProtTyp(i).boVorlage = True
  Next i
  Call AnzeigeAktualisieren

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lstProtTypVorhanden_DblClick(ByVal cancel As MSForms.ReturnBoolean)
  Call btnProtTypAuswahl_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lstProtTypVorlage_DblClick(ByVal cancel As MSForms.ReturnBoolean)
  Call btnProtTypAbwahl_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim coProtTyp   As CO_ProtokollTyp
Dim oProtTyp    As C_ProtokollTyp
Dim iProtTypID  As Integer
Dim boGefunden  As Boolean
Dim iDPTID      As Integer
Dim i           As Integer
  
  Call FormularBeschriften(Me)
  
  ReDim maudProtTyp(0)

  Set coProtTyp = M_ProtokollTyp.coLesen

  If coProtTyp.Items.Count > 0 Then

    For iProtTypID = 1 To coProtTyp.Count
      With coProtTyp.Items(iProtTypID)

        ReDim Preserve maudProtTyp(iProtTypID)
        maudProtTyp(iProtTypID).sProtTyp = .Bezeichnung
        maudProtTyp(iProtTypID).boVorlage = False

      End With

    Next iProtTypID

    Call AnzeigeAktualisieren

  Else
    'Keine Protokolltypen definiert
    Call MsgBox(GetResText(21100), _
                vbOKOnly + vbCritical, _
                GetResText(20101))
    btnOK.Enabled = False
  End If

  chkSeitenansicht = False

  Set coProtTyp = Nothing

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub AnzeigeAktualisieren()

Dim iProtTypID  As Integer
Dim boGefunden  As Boolean
Dim v As Variant
Dim asDpt() As String
Dim iDPTID  As Integer
Dim i       As Integer

  lstProtTypVorhanden.Clear
  lstProtTypVorlage.Clear
  
  For iProtTypID = 1 To UBound(maudProtTyp)
  
    If maudProtTyp(iProtTypID).boVorlage Then
      lstProtTypVorlage.AddItem maudProtTyp(iProtTypID).sProtTyp
      lstProtTypVorlage.List(lstProtTypVorlage.ListCount - 1, 1) = iProtTypID
    Else
      lstProtTypVorhanden.AddItem maudProtTyp(iProtTypID).sProtTyp
      lstProtTypVorhanden.List(lstProtTypVorhanden.ListCount - 1, 1) = iProtTypID
    End If
    
  Next iProtTypID
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Terminate()
  ReDim maudProtTyp(0)
  ReDim masDPTGesamt(0)
End Sub
Attribute VB_Name = "V_Basiswert"
Attribute VB_Base = "0{25A8563C-5B9F-4A66-AC2F-0F2D373CB19C}{A87006A9-2983-4F0A-8F6A-AFAAE8A5B86D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Basiswert
'Oliver Seidel 14.07.2000
'
'Zeigt eine Uebersicht aller Basiswerte. Von hier aus koennen neue Basiswerte erstellt und bestehende
'geloescht oder geaendert werden.
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoBasiswert  As CO_Basiswert
Private mboOK As Boolean
Private mboChanged As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set Basiswert(coBasiswert As CO_Basiswert)
  Set mcoBasiswert = coBasiswert
  Call Basiswert_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Basiswert() As CO_Basiswert
  Set Basiswert = mcoBasiswert
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get changed() As Boolean
  changed = mboChanged
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Dim rc As Integer
  rc = vbYes  ' default, IM 104031 WOKL 11.3.11
  If (changed = True) Then
    rc = MsgBox(GetResText(22006), vbQuestion + vbYesNo, GetResText(20103))
  End If
  If (rc = vbYes) Then
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem     As ListItem
Dim oBasiswert  As C_Basiswert

  Set lstItem = lvwBasiswert.SelectedItem
  If Not lstItem Is Nothing Then
    mcoBasiswert.Remove lstItem.ListSubItems(1).Text
    mboChanged = True
    Call Basiswert_Anzeigen
  Else
    Call MsgBox(GetResText(21138), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem     As ListItem
Dim vwBasiswert As V_BasiswertDetail
Dim oBasiswert  As C_Basiswert

Dim i As Integer
Dim s As String

  Set lstItem = lvwBasiswert.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.ListSubItems(1).Text
    Set vwBasiswert = New V_BasiswertDetail
    Set oBasiswert = mcoBasiswert.FindItem(s)
    Set vwBasiswert.Basiswert = oBasiswert
    
    i = vbNo
    While i = vbNo
      vwBasiswert.Show
      If vwBasiswert.ok Then
        Set oBasiswert = vwBasiswert.Basiswert
        If s = oBasiswert.Bezeichnung Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          mboChanged = True
          i = vbYes
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoBasiswert.FindItem(oBasiswert.Bezeichnung) Is Nothing Then
            mcoBasiswert.Remove s
            mcoBasiswert.Add oBasiswert
            mboChanged = True
            i = vbYes
          Else
            'Objekt kann nicht umbenannt werden
            Call MsgBox(GetResText(21139), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call Basiswert_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21138), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim lstItem     As ListItem
Dim vwBasiswert As V_BasiswertDetail
Dim oBasiswert  As C_Basiswert

Dim i As Integer
Dim s As String

  Set vwBasiswert = New V_BasiswertDetail
    
  i = vbNo
  While i = vbNo
    vwBasiswert.Show
    If vwBasiswert.ok Then
      Set oBasiswert = vwBasiswert.Basiswert
      If mcoBasiswert.FindItem(oBasiswert.Bezeichnung) Is Nothing Then
        mcoBasiswert.Add oBasiswert
        mboChanged = True
        i = vbYes
      Else
        Call MsgBox(GetResText(21139), _
                    vbOKOnly + vbInformation, _
                    GetResText(20105))
      End If
    Else
      i = vbCancel
    End If
  Wend
  If i = vbYes Then
    Call Basiswert_Anzeigen
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwBasiswert_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False
  mboChanged = False

  With lvwBasiswert
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
       
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16016) '"Bezeichnung"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16011)  '"Intervall"
    lstHeader.Width = 80
    .SortKey = 1
    .Sorted = True
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Basiswert_Anzeigen()

Dim oBasiswert  As C_Basiswert
Dim lstItem     As ListItem

  lvwBasiswert.ListItems.Clear
  For Each oBasiswert In mcoBasiswert.Items
    Set lstItem = lvwBasiswert.ListItems.Add
    lstItem.Text = oBasiswert.ID
    lstItem.SubItems(1) = oBasiswert.Bezeichnung
    If oBasiswert.Intervall > 0 Then
      lstItem.SubItems(2) = CStr(oBasiswert.Intervall) & " " & _
                            GetResText(TXT_ZEIT_EINHEIT_BEGINN + oBasiswert.IntEinheit)
    End If
  Next oBasiswert
End Sub

Attribute VB_Name = "V_BasiswertDetail"
Attribute VB_Base = "0{FC8D7A4A-0398-4E1E-9307-EF747A348D1F}{9CB6B917-5864-43CD-9F69-B11F7F0AAD52}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private moBasiswert As C_Basiswert
Private mboOK       As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set Basiswert(oBasiswert As C_Basiswert)
  Set moBasiswert = oBasiswert
  Call BasiswertAnzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Basiswert() As C_Basiswert
  
  moBasiswert.Bezeichnung = txtBezeichnung.Text
  moBasiswert.Intervall = spnIntervallAnz.value
  moBasiswert.IntEinheit = cboIntervallEinheit.ListIndex + 1
  Set Basiswert = moBasiswert
  
End Property

'---------------------------------------------------------------------------------------------------
Private Sub cboIntervallEinheit_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwArchiv_DblClick()
  Call btnArchivNeu_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub spnIntervallAnz_Change()
  If txtIntervallAnz <> spnIntervallAnz.value Then
    txtIntervallAnz = spnIntervallAnz.value
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtIntervallAnz_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)
  
  If IsNumeric(txtIntervallAnz.Text) Then
    spnIntervallAnz.value = CLng(txtIntervallAnz.Text)
  Else
    cancel = True
    txtIntervallAnz.Text = spnIntervallAnz.value
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnArchivDelete_Click()

Dim lstItem As ListItem

  Set lstItem = lvwArchiv.SelectedItem
  If Not lstItem Is Nothing Then
    moBasiswert.coArchive.Remove lstItem.Text
    Call ArchivAnzeigen
  Else
    Call MsgBox(GetResText(21140), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnArchivNeu_Click()

Dim vwArchiv  As V_Archiv_Sucher
Dim oArchiv   As C_Archiv

Dim lstItem As ListItem

  Set vwArchiv = New V_Archiv_Sucher
  vwArchiv.IntervallFilterStr = spnIntervallAnz & " " & cboIntervallEinheit
  vwArchiv.Show
  If vwArchiv.ok Then
    For Each oArchiv In vwArchiv.AusgewaehlteArchive.Items
      If moBasiswert.coArchive.FindItem(oArchiv.ID) Is Nothing Then
        moBasiswert.coArchive.Add oArchiv
      End If
    Next oArchiv
    Call ArchivAnzeigen
  End If
  
  Unload vwArchiv
  Set vwArchiv = Nothing

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwArchiv_ColumnClick(ByVal ColumnHeader As MSComctlLib.ColumnHeader)
  lvwArchiv.SortKey = ColumnHeader.index - 1
  lvwArchiv.Sorted = True
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim lstHeader As MSComctlLib.ColumnHeader
Dim i           As Integer
  
  Call FormularBeschriften(Me)
  
  mboOK = False
  Set moBasiswert = New C_Basiswert
  
  For i = 1 To TXT_ZEIT_EINHEIT_ANZ
    cboIntervallEinheit.AddItem GetResText(TXT_ZEIT_EINHEIT_BEGINN + i)
  Next i
  spnIntervallAnz = 1
  txtIntervallAnz = 1
  cboIntervallEinheit.ListIndex = erStunde - 1
  
  With lvwArchiv
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
       
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16040) '"System"
    lstHeader.Width = 57.75
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16000) '"DP Typ"
    lstHeader.Width = 57.75
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16001) '"DP Element"
    lstHeader.Width = 100
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16004) '"VStufe"
    lstHeader.Width = 36
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16011) '"Intervall"
    lstHeader.Width = 66
    .SortKey = 1
    .Sorted = True
  End With
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub BasiswertAnzeigen()

  txtBezeichnung = moBasiswert.Bezeichnung
  If moBasiswert.Intervall > 0 Then
    spnIntervallAnz = moBasiswert.Intervall
    txtIntervallAnz = moBasiswert.Intervall
    cboIntervallEinheit.ListIndex = moBasiswert.IntEinheit - 1
  End If
  Call ArchivAnzeigen
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub ArchivAnzeigen()

Dim oArchiv     As C_Archiv
Dim lstItem     As MSComctlLib.ListItem

  lvwArchiv.ListItems.Clear
  
  For Each oArchiv In moBasiswert.coArchive.Items
    Set lstItem = lvwArchiv.ListItems.Add
    lstItem.Text = oArchiv.ID
    lstItem.SubItems(1) = oArchiv.SYS
    lstItem.SubItems(2) = oArchiv.dpt
    lstItem.SubItems(3) = oArchiv.dpe
    lstItem.SubItems(4) = oArchiv.VStufe
    lstItem.SubItems(5) = CStr(oArchiv.Intervall) & " " & _
                          GetResText(TXT_ZEIT_EINHEIT_BEGINN + oArchiv.IntEinheit)
  Next oArchiv

End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean
  
  EingabenPruefen = False
  If Len(txtBezeichnung.Text) = 0 Then
    txtBezeichnung.SetFocus
    Call MsgBox(lblBezeichnung.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    Exit Function
  End If
  EingabenPruefen = True
  
End Function
Attribute VB_Name = "V_Bereichsauswahl"
Attribute VB_Base = "0{1D8311DF-ECF3-4044-B70D-2C91806AA699}{8A2E4600-4AD7-4903-9691-CE1A7A472F7B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Bereichsauswahl
'Wolfram Klebel 23.4.2010
'
'Zeigt die Liste aller verf|fffd|gbaren Bereiche
'Mit der Auswahl wird ein Template einem Bereich zugeordnet
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mboOK             As Boolean
Private mcoAreas          As Collection
Private mstSelectedAreas  As String


'---------------------------------------------------------------------------------------------------
Public Property Set Areas(Areas As Collection)
  Set mcoAreas = Areas
  Call Bereiche_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let selAreas(selAreas As String)
  mstSelectedAreas = selAreas
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get selAreas() As String
  selAreas = mstSelectedAreas
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()

Dim first As Boolean
Dim i As Integer

  mstSelectedAreas = ""
  If (chkAlle.value) Then
    mstSelectedAreas = "0"
  Else
    first = True
    For i = 0 To lvwAreas.ListCount - 1
      If lvwAreas.Selected(i) Then
        If (Not first) Then
          mstSelectedAreas = mstSelectedAreas + "|"
        End If
        mstSelectedAreas = mstSelectedAreas + CStr(i + 1)
        first = False
      End If
    Next
  End If
    
  mboOK = True
  Me.Hide
End Sub


Private Sub lvwAreas_Change()
  chkAlle.value = False
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Bereiche_Anzeigen()

Dim area        As Variant
Dim lstItem     As ListItem
Dim iSelAreas() As String
Dim index       As Integer
Dim i           As Integer

  iSelAreas = Split(mstSelectedAreas, "|", Compare:=vbTextCompare)

  lvwAreas.Clear
  index = 0
  For Each area In mcoAreas
    lvwAreas.AddItem area, index
    If (mstSelectedAreas = "0") Then   ' Alle
      lvwAreas.Selected(index) = True
    Else
      For i = 0 To UBound(iSelAreas)
        If ((CInt(iSelAreas(i)) - 1) = index) Then
          lvwAreas.Selected(index) = True
        End If
      Next
    End If
    index = index + 1
  Next
  
  chkAlle.value = (mstSelectedAreas = "0")
  
End Sub
Attribute VB_Name = "V_BlattOffset"
Attribute VB_Base = "0{731E75B3-C528-4E0C-99C5-A71BB2386AD4}{9582813B-A639-493B-9CAE-E1B0BF7FE877}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'==================================================================================================
'V_BlattOffset
'Wolfram Klebel, 5.4.11
'
'Auswahl eines Offsets, der f|fffd|r die Zeitachse eines Blattes Geltung hat (und ev. die Werte?)
'==================================================================================================
Option Explicit

Private mboOK As Boolean
' Private inhibitRecursion As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let Offset(iOffset As Integer)
  spnOffset.value = iOffset
End Property
'---------------------------------------------------------------------------------------------------
Public Property Let SheetName(sName As String)
  txtSheetName.value = sName
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Offset() As Integer
  On Error Resume Next
  Offset = CInt(txtOffset)
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property


'--------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

Private Sub spnOffset_Change()
  ' inhibitRecursion = True
  txtOffset.value = spnOffset.value
  ' inhibitRecursion = False
End Sub

Private Sub txtOffset_Change()
  On Error Resume Next
  'If (Not inhibitRecursion) Then
    spnOffset.value = CInt(txtOffset.value)
 ' End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  Call FormularBeschriften(Me)
  
  txtOffset = 0
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub


Attribute VB_Name = "V_ColorPicker"
Attribute VB_Base = "0{7412D6AD-D632-4F1F-9EC1-F0A991A43719}{15B9D8A1-417D-4956-B549-4325C5A961E0}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'V_colorPicker
'Oliver Seidel, 22.05.2002
'
'Editieren einer Farbe
'==================================================================================================
Option Explicit

Dim mlColor As Long
Dim mboOK   As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let Color(lColor As Long)

Dim iRed   As Integer
Dim iGreen As Integer
Dim iBlue  As Integer

  mlColor = lColor
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  sbRed.value = iRed
  sbGreen.value = iGreen
  sbBlue.value = iBlue
  
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get Color() As Long
  Color = mlColor
End Property

'---------------------------------------------------------------------------------------------------
Private Sub sbRed_Scroll()
  txtRed = sbRed.value
  changeColor
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub sbRed_Change()
  txtRed = sbRed.value
  changeColor
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub sbGreen_Scroll()
  txtGreen = sbGreen.value
  changeColor
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub sbGreen_Change()
  txtGreen = sbGreen.value
  changeColor
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub sbBlue_Scroll()
  txtBlue = sbBlue.value
  changeColor
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub sbBlue_Change()
  txtBlue = sbBlue.value
  changeColor
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtRed_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)

Dim n As Long
  
  If IsNumeric(txtRed.Text) Then
    n = CLng(txtRed.Text)
    If n > 0 And n < 255 Then
      sbRed.value = CLng(txtRed.Text)
      Exit Sub
    End If
  End If
  cancel = True
  txtRed.Text = sbRed.value

End Sub
'---------------------------------------------------------------------------------------------------
Private Sub txtGreen_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)

Dim n As Long
  
  If IsNumeric(txtGreen.Text) Then
    n = CLng(txtGreen.Text)
    If n > 0 And n < 255 Then
      sbGreen.value = CLng(txtGreen.Text)
      Exit Sub
    End If
  End If
  cancel = True
  txtGreen.Text = sbGreen.value

End Sub
'---------------------------------------------------------------------------------------------------
Private Sub txtBlue_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)

Dim n As Long
  
  If IsNumeric(txtBlue.Text) Then
    n = CLng(txtBlue.Text)
    If n > 0 And n < 255 Then
      sbBlue.value = CLng(txtBlue.Text)
      Exit Sub
    End If
  End If
  cancel = True
  txtBlue.Text = sbBlue.value

End Sub

'--------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'--------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub changeColor()
  
  On Error GoTo Fehler_changeColor
  mlColor = RGB(CLng(txtRed.Text), CLng(txtGreen.Text), CLng(txtBlue.Text))
  lblSample.BackColor = mlColor

Fehler_changeColor:
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  txtRed.Text = 0
  txtGreen.Text = 0
  txtBlue.Text = 0
  Call FormularBeschriften(Me)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

Attribute VB_Name = "V_CostCenter"
Attribute VB_Base = "0{4CC4F788-0C3E-4BE7-9676-7F65473761B0}{7097D2B5-0C79-47DA-80D8-E616EE849182}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'===================================================================================================
'V_CostCenter
'Wolfram Klebel 26.6.09
'
'Zeigt eine Liste der Kostenstellen, die ausgew|fffd|hlt werden k|fffd|nnen
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoCostCenter  As CO_CostCenter
Private mcoTariffset   As CO_Tariffset
Private mboOK As Boolean
Private mboChanged As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set CostCenter(coCostCenter As CO_CostCenter)
  Set mcoCostCenter = coCostCenter
  Call CostCenter_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get CostCenter() As CO_CostCenter
  Set CostCenter = mcoCostCenter
End Property

'---------------------------------------------------------------------------------------------------
' nur zum Durchschleifen der Strings fuer die Tarifset-Combobox
Public Property Set Tariffset(coTariffset As CO_Tariffset)
  Set mcoTariffset = coTariffset
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get changed() As Boolean
  changed = mboChanged
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Dim rc As Integer
  rc = vbYes  ' default, IM 104031 WOKL 11.3.11
  If (changed = True) Then
    rc = MsgBox(GetResText(22006), vbQuestion + vbYesNo, GetResText(20103))
  End If
  If (rc = vbYes) Then
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()
  Dim lstItem     As ListItem

  Set lstItem = lvwCostCenter.SelectedItem
  If Not lstItem Is Nothing Then
    mcoCostCenter.Remove lstItem.Text
    mboChanged = True
    ' Call M_CostCenter.coSpeichern(mcoCostCenter)
    Call CostCenter_Anzeigen
  Else
    Call MsgBox(GetResText(21169), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem       As ListItem
Dim vwCostCenter  As V_CostCenterDetail
Dim oCostCenter   As C_CostCenter

Dim i As Integer
Dim s As String

  Set lstItem = lvwCostCenter.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.Text
    Set vwCostCenter = New V_CostCenterDetail
    Set oCostCenter = mcoCostCenter.FindItem(s)
    Set vwCostCenter.CostCenter = oCostCenter
    Set vwCostCenter.Tariffset = mcoTariffset
    
    i = vbNo
    While i = vbNo
      vwCostCenter.Show
      If vwCostCenter.ok Then
        Set oCostCenter = vwCostCenter.CostCenter
        If s = oCostCenter.Bezeichnung Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          i = vbYes
          mboChanged = True
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoCostCenter.FindItem(oCostCenter.Bezeichnung) Is Nothing Then
            mcoCostCenter.Remove s
            mcoCostCenter.Add oCostCenter
            mboChanged = True
            i = vbYes
          Else
            'Objekt bereits vorhanden
            Call MsgBox(GetResText(21170), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call CostCenter_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21171), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim lstItem       As ListItem
Dim vwCostCenter  As V_CostCenterDetail
Dim oCostCenter   As C_CostCenter

Dim i As Integer
Dim s As String

  If mcoTariffset.Count = 0 Then
    Call MsgBox(GetResText(21180), vbOKOnly + vbInformation, GetResText(20105))
  Else
    Set vwCostCenter = New V_CostCenterDetail
    Set vwCostCenter.Tariffset = mcoTariffset
      
    i = vbNo
    While i = vbNo
      vwCostCenter.Show
      If vwCostCenter.ok Then
        Set oCostCenter = vwCostCenter.CostCenter
        If mcoCostCenter.FindItem(oCostCenter.Bezeichnung) Is Nothing Then
          mcoCostCenter.Add oCostCenter
          mboChanged = True
          i = vbYes
        Else
          Call MsgBox(GetResText(21170), _
                      vbOKOnly + vbInformation, _
                      GetResText(20105))
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      ' Call M_CostCenter.coSpeichern(mcoCostCenter)
      Call CostCenter_Anzeigen
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwCostCenter_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False
  mboChanged = False

  With lvwCostCenter
    .View = lvwReport
    ' Set .SmallIcons = imglstStatus
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
   
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(17611) '"Bezeichnung"
    lstHeader.Width = 142
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(17612) '"Tarifsatz Name[Medium] / ..."
    lstHeader.Width = 275
    
    .SortKey = 0
    .Sorted = True
  End With
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub CostCenter_Anzeigen()

Dim oCostCenter  As C_CostCenter
Dim lstItem     As ListItem
Dim oTs As C_Tariffset
Dim sHelp As String
Dim ocoTs As CO_Tariffset

  On Error GoTo errorExit

  lvwCostCenter.ListItems.Clear
  If mcoCostCenter Is Nothing Then Exit Sub
  
  For Each oCostCenter In mcoCostCenter.Items
  
    Set lstItem = lvwCostCenter.ListItems.Add
    lstItem.Text = oCostCenter.Bezeichnung
    Set ocoTs = oCostCenter.coTariffsets
    sHelp = ""
    For Each oTs In ocoTs.Items
      If sHelp <> "" Then sHelp = sHelp + " / "
      sHelp = sHelp + " " + oTs.Name + "[" + oTs.Medium.Name + "]"
    Next oTs
    lstItem.SubItems(1) = sHelp
    
  Next oCostCenter
  
Exit Sub
errorExit:
  Call MsgBox("ACHTUNG", Err.Description)
     
End Sub

Attribute VB_Name = "V_CostCenterDetail"
Attribute VB_Base = "0{23F4A58F-085C-4071-966D-D4C9F79C7376}{03263EB0-28B3-4FAD-A5C4-E7BC288C43F7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'===================================================================================================
'V_CostCenterDetail
'Wolfram Klebel 30.6.09
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private Const TARIFFSET_COUNT As Integer = 10

Private moCostCenter  As C_CostCenter
Private mcoTariffset  As CO_Tariffset
Private mboOK         As Boolean
Private mcbTariffset(TARIFFSET_COUNT)  As Object
Private mtxMedium(TARIFFSET_COUNT)  As Object

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set CostCenter(cc As C_CostCenter)

  Set moCostCenter = cc
  Call CostCenterAnzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get CostCenter() As C_CostCenter
  Dim ts As C_Tariffset
  Dim coTs As CO_Tariffset
  Dim i As Integer
  Dim tsText As String
  
  moCostCenter.Bezeichnung = txtBezeichnung.Text
  Set coTs = New CO_Tariffset
  
  For i = 1 To TARIFFSET_COUNT
    tsText = mcbTariffset(i).SelText
    If (tsText <> "") Then
      Set ts = mcoTariffset.FindItem(tsText)
      coTs.Add ts
    End If
  Next i
  
  Set moCostCenter.coTariffsets = coTs
  Set CostCenter = moCostCenter
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set Tariffset(ts As CO_Tariffset)

  Set mcoTariffset = ts
  Call CostCenterAnzeigen

End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

Private Sub TariffsetChange(index As Integer)
  Dim ts As C_Tariffset
  Set ts = mcoTariffset.FindItem(mcbTariffset(index).SelText)
  If (Not ts Is Nothing) Then
    mtxMedium(index).Text = ts.Medium.Name & " / " & ts.Medium.unit
  Else
    mtxMedium(index).Text = ""
  End If
End Sub
Private Sub cmbTariffset1_Change(): Call TariffsetChange(1): End Sub
Private Sub cmbTariffset2_Change(): Call TariffsetChange(2): End Sub
Private Sub cmbTariffset3_Change(): Call TariffsetChange(3): End Sub
Private Sub cmbTariffset4_Change(): Call TariffsetChange(4): End Sub
Private Sub cmbTariffset5_Change(): Call TariffsetChange(5): End Sub
Private Sub cmbTariffset6_Change(): Call TariffsetChange(6): End Sub
Private Sub cmbTariffset7_Change(): Call TariffsetChange(7): End Sub
Private Sub cmbTariffset8_Change(): Call TariffsetChange(8): End Sub
Private Sub cmbTariffset9_Change(): Call TariffsetChange(9): End Sub
Private Sub cmbTariffset10_Change(): Call TariffsetChange(10): End Sub

Private Sub txtBezeichnung_Change()
  txtBezeichnung.value = Mid(txtBezeichnung.value, 1, 50)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  Dim i As Integer
  
  Call FormularBeschriften(Me)
  mboOK = False
  Set moCostCenter = New C_CostCenter
  
  Set mcbTariffset(1) = cmbTariffset1
  Set mcbTariffset(2) = cmbTariffset2
  Set mcbTariffset(3) = cmbTariffset3
  Set mcbTariffset(4) = cmbTariffset4
  Set mcbTariffset(5) = cmbTariffset5
  Set mcbTariffset(6) = cmbTariffset6
  Set mcbTariffset(7) = cmbTariffset7
  Set mcbTariffset(8) = cmbTariffset8
  Set mcbTariffset(9) = cmbTariffset9
  Set mcbTariffset(10) = cmbTariffset10

  Set mtxMedium(1) = txtMedium1
  Set mtxMedium(2) = txtMedium2
  Set mtxMedium(3) = txtMedium3
  Set mtxMedium(4) = txtMedium4
  Set mtxMedium(5) = txtMedium5
  Set mtxMedium(6) = txtMedium6
  Set mtxMedium(7) = txtMedium7
  Set mtxMedium(8) = txtMedium8
  Set mtxMedium(9) = txtMedium9
  Set mtxMedium(10) = txtMedium10
  
  For i = 1 To TARIFFSET_COUNT
    mtxMedium(i).ForeColor = &H80000008
    mtxMedium(i).BackColor = &H8000000F
  Next i

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub CostCenterAnzeigen()
  Dim ts As C_Tariffset
  Dim tsFound As C_Tariffset
  Dim found As Integer
  Dim index As Integer
  Dim i As Integer

  txtBezeichnung.Text = moCostCenter.Bezeichnung
  
  If mcoTariffset Is Nothing Then Exit Sub
  
  For i = 1 To TARIFFSET_COUNT
    mcbTariffset(i).Clear
    If (i <= moCostCenter.coTariffsets.Count) Then
      Set tsFound = moCostCenter.coTariffsets.Items.Item(i)
    Else
      Set tsFound = Nothing
    End If
    index = 1
    found = -1
    mcbTariffset(i).AddItem ""
    For Each ts In mcoTariffset.Items
      mcbTariffset(i).AddItem ts.Name
      
      If (Not tsFound Is Nothing) Then
        If (ts.Name = tsFound.Name) Then
          found = index
        End If
      End If
      index = index + 1
    Next ts
    
    If found > 0 Then
      mcbTariffset(i).ListIndex = found
    End If
  Next i
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean
  Dim i As Integer
  Dim j As Integer
  Dim tsText As String
  Dim mdText As String
  Dim tsFound As Boolean

  If txtBezeichnung.Text = "" Then
    Call MsgBox(GetResText(21197), vbCritical + vbOKOnly, GetResText(20104))
    EingabenPruefen = False
  Else
    EingabenPruefen = True
  
    ' check for same tariffset / no duplicate entries allowed
    tsFound = False
    For i = 1 To TARIFFSET_COUNT
      tsText = mcbTariffset(i).SelText
      If (tsText <> "") Then
        tsFound = True
        For j = i + 1 To TARIFFSET_COUNT
          If (tsText = mcbTariffset(j).SelText) Then
            Call MsgBox(GetResText(21196), vbCritical + vbOKOnly, GetResText(20104))
            EingabenPruefen = False
            Exit Function
          End If
        Next j
      End If
    Next i
    
    If (tsFound = False) Then
      Call MsgBox(GetResText(21175), vbCritical + vbOKOnly, GetResText(20104))
      EingabenPruefen = False
      Exit Function
    End If
    
    ' check for same Medium / no duplicate entries allowed
    For i = 1 To TARIFFSET_COUNT
      mdText = mtxMedium(i).Text
      If (mdText <> "") Then
        For j = i + 1 To TARIFFSET_COUNT
          If (mdText = mtxMedium(j).Text) Then
            Call MsgBox(GetResText(21196), vbCritical + vbOKOnly, GetResText(20104))
            EingabenPruefen = False
            Exit Function
          End If
        Next j
      End If
    Next i
    
  End If
  
End Function



Attribute VB_Name = "V_DP"
Attribute VB_Base = "0{2D4CABC2-73FA-4BE2-9AC2-16A609FECC2B}{46C1970A-5BF8-4998-9F63-57176C70B47D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' IM 82753 WOKL 11.2.08: System zugefuegt
Private moComMan As ComManager
Private msSystem  As String
Private msDPT  As String
Private msDP As String
Private msDPE As String
Private msDPFull As String

'---------------------------------------------------------------------------------------------------
' IM 82753 sysName wird initialisiert, muss vor allen anderen Aufrufen geschehen
Public Property Let sysName(sysName As String)
  msSystem = sysName
End Property
'---------------------------------------------------------------------------------------------------
Public Property Set ComMan(oComMan As ComManager)
  Set moComMan = oComMan
  Call setDpt
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Modus(iModus As Integer)

  If iModus = 1 Then
  
    cbDpt.Enabled = True
    cbDpt.BackColor = &H80000005
    
    cbDp.Enabled = False
    cbDp.BackColor = &H80000013
    
    cbDpe.Enabled = False
    cbDpe.BackColor = &H80000013
    
  ElseIf iModus = 2 Then
  
    cbDpt.Enabled = True
    cbDpt.BackColor = &H80000005
    
    cbDp.Enabled = True
    cbDp.BackColor = &H80000005
    
    cbDpe.Enabled = False
    cbDpe.BackColor = &H80000013
    
  ElseIf iModus = 3 Then
  
    cbDpt.Enabled = True
    cbDpt.BackColor = &H80000005
    
    cbDp.Enabled = True
    cbDp.BackColor = &H80000005
    
    cbDpe.Enabled = True
    cbDpe.BackColor = &H80000005
    
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get dpt() As String
  dpt = msDPT
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get dp() As String
  dp = msDP
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get dpe() As String
  dpe = msDPE
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get DPFull() As String
  DPFull = msDPFull
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()

Dim sDPT As String
Dim sDP As String
Dim sDPE As String
Dim sDpFull As String


  sDPT = cbDpt.Text
  sDP = cbDp.Text
  sDPE = cbDpe.Text
  
  sDpFull = sDP
  If Right(sDpFull, 1) <> "." Then
    sDpFull = sDpFull & "."
  End If
  sDpFull = sDpFull & sDPE
  
  msDPT = sDPT
  msDP = sDP
  msDPE = sDPE
  msDPFull = sDpFull
  
  Me.Hide

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub setDpt()

Dim asDptNameComplete() As String
Dim asDptName() As String
Dim n As Integer
  
 
  'Viewelemente steuern
  cbDp.Clear
  cbDpe.Clear
 
  'Ermitteln aller Typen; Erweiterung System mit IM 82753
  Call moComMan.dpTypes(msSystem & ":*", asDptNameComplete)
  Call M_SQLVorlage.getDpTypeNames(asDptNameComplete, asDptName)
  
  For n = 1 To UBound(asDptName)
    cbDpt.AddItem (asDptName(n))
  Next
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbDpt_Click()

Dim sDptName As String
Dim asDpNameComplete() As String
Dim asDpName() As String
Dim n As Integer

  On Error Resume Next
  'Viewelemente steuern
  cbDp.Clear
  cbDpe.Clear
  ReDim asDpName(0)
  
  'Alle Datenpunkte des ausgewaehlten Typen abfragen
  sDptName = cbDpt.Text
  Call moComMan.dpNames(msSystem & ":*", sDptName, asDpNameComplete)
  Call M_SQLVorlage.getDpNames(asDpNameComplete, asDpName)
  
  If UBound(asDpName) > 0 Then
    For n = 1 To UBound(asDpName)
      cbDp.AddItem (asDpName(n))
    Next n
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbDp_Click()

Dim sDpName As String
Dim sDptName As String
Dim asDpeNameComplete() As String
Dim asDpeName() As String
Dim sDpeType As String
Dim asDpeNameSplit() As String
Dim asDpNameSplit() As String
Dim iSplit As Integer
Dim sDPE As String
Dim n As Integer

  On Error Resume Next
  'Viewelemente steuern
  cbDpe.Clear
  
  'Alle Datenpunktelemente des ausgewaehlten Datenpunktes abfragen
  sDpName = cbDp.Text
  sDptName = cbDpt.Text
  Call moComMan.dpNames(msSystem & ":" & sDpName & ".**", sDptName, asDpeNameComplete)
  Call M_SQLVorlage.getDpElementName(asDpeNameComplete, asDpeName)
  
  For n = 1 To UBound(asDpeName)
  
    sDpeType = moComMan.dpElementType(asDpeNameComplete(n))
    If sDpeType = DPE_CHAR Or _
       sDpeType = DPE_UNSIGNED Or _
       sDpeType = DPE_INT Or _
       sDpeType = DPE_FLOAT Or _
       sDpeType = DPE_BOOL Or _
       sDpeType = DPE_BIT32 Or _
       sDpeType = DPE_STRING Or _
       sDpeType = DPE_TIME Then
  
       cbDpe.AddItem (asDpeName(n))
    End If
  Next

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  Call FormularBeschriften(Me)
  Set oComMan = M_PVSS.getComMan
End Sub
Attribute VB_Name = "V_DPEinfuegen"
Attribute VB_Base = "0{ADFF9094-838A-4E57-BAAA-2B3800FCCC00}{C3C97BC6-5AC8-4F83-87F2-9618CC58808B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
 '==================================================================================================
' V_DPEinfuegen
' Oliver Seidel 28.10.98
' Wolfram Klebel 14.7.09
'
' Aenderungen: -keine-
'==================================================================================================
Option Explicit
 
Dim mboOK         As Boolean
Dim mcoDP         As CO_DP

' 1 - Std-Einfuegen
' 2 - Std-Aendern
' 3 - Btr-Einfuegen
' 4 - Btr-Aendern
' 5 - ATV-Einfuegen
' 6 - ATV-Aendern
' 7 - Kst-Einfuegen
' 8 - Kst-Aendern
Dim miModus       As Integer
Dim masRdbDPE()   As String

    
'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let ArchivTyp(iArchivTyp As Integer)
  Dim i     As Integer
  Dim help  As Integer
  
  ' indexes are not any more fixed
  For i = 0 To (cboArchivTyp.ListCount - 1)
    cboArchivTyp.ListIndex = i  ' set type, compare to possible texts
    
    If (iArchivTyp = ARCHIVTYP_ACPERIODE Or _
        iArchivTyp = ARCHIVTYP_ACSINGLE) And _
        cboArchivTyp.Text = GetResText(16034) Then      ' AC Para
      Exit For
    ElseIf (iArchivTyp = ARCHIVTYP_HDBPERIODE Or _
           iArchivTyp = ARCHIVTYP_HDBSINGLE) And _
           cboArchivTyp.Text = GetResText(16035) Then   ' HDB Direkt
      Exit For
    ElseIf (iArchivTyp = ARCHIVTYP_RDBPERIODE Or _
           iArchivTyp = ARCHIVTYP_RDBSINGLE) And _
           cboArchivTyp.Text = GetResText(16048) Then   ' RDB direkt
      Exit For
    ElseIf (iArchivTyp = ARCHIVTYP_RACPERIODE Or _
           iArchivTyp = ARCHIVTYP_RACSINGLE) And _
           cboArchivTyp.Text = GetResText(16049) Then   ' RDB Type
      Exit For
    ElseIf cboArchivTyp.Text = GetResText(16036) Then   ' ONLINE (the last item)
      Exit For
    End If
  Next i
  
End Property

'---------------------------------------------------------------------------------------------------
' get archive type from menu

Public Property Get ArchivTyp() As Integer

  Select Case cboArchivTyp.Text
  
    Case GetResText(16034)
      If miModus = 3 Or miModus = 4 Then
        ArchivTyp = ARCHIVTYP_ACSINGLE
      Else
        ArchivTyp = ARCHIVTYP_ACPERIODE
      End If
    Case GetResText(16035)
      If miModus = 3 Or miModus = 4 Then
        ArchivTyp = ARCHIVTYP_HDBSINGLE
      Else
        ArchivTyp = ARCHIVTYP_HDBPERIODE
      End If
    Case GetResText(16048)    ' RDB Direct
      If miModus = 3 Or miModus = 4 Then    ' WOKL: TODO
        ArchivTyp = ARCHIVTYP_RDBSINGLE
      Else
        ArchivTyp = ARCHIVTYP_RDBPERIODE
      End If
    Case GetResText(16049)    ' RDB AC Para
      If miModus = 3 Or miModus = 4 Then    ' WOKL: TODO
        ArchivTyp = ARCHIVTYP_RACSINGLE
      Else
        ArchivTyp = ARCHIVTYP_RACPERIODE
      End If
    Case GetResText(16036)
      ArchivTyp = ARCHIVTYP_ONLINE

  End Select

End Property

'---------------------------------------------------------------------------------------------------
Public Property Get SimpleArchivTyp() As Integer
  
  Select Case cboArchivTyp.Text
    Case GetResText(16034)
      SimpleArchivTyp = ARCHIVTYP_AC
    Case GetResText(16035)
      SimpleArchivTyp = ARCHIVTYP_HDB
    Case GetResText(16048)
      SimpleArchivTyp = ARCHIVTYP_RDB
    Case GetResText(16049)
      SimpleArchivTyp = ARCHIVTYP_RAC
    Case GetResText(16036)
      SimpleArchivTyp = ARCHIVTYP_ONLINE
  End Select

End Property
'---------------------------------------------------------------------------------------------------
Public Property Get SystemName() As String

  SystemName = cboSystemName.Text
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let SystemName(sysName As String)

  Dim i As Integer
  Dim mySystem As Variant
  
  If sysName = "" Then    ' getDefaultSystem
    
    Call M_PVSS.getReportExt.getSystemName(-1, mySystem)
    sysName = mySystem
  
  End If
  
  For i = 0 To cboSystemName.ListCount - 1
    If sysName = cboSystemName.List(i) Then
      cboSystemName.ListIndex = i
    End If
  Next i
  
End Property

'---------------------------------------------------------------------------------------------------
Private Function hasDpt(sDPT As String)
  
  Dim i As Integer
  Dim found As Boolean
  
  found = False
  For i = 0 To cboDPT.ListCount - 1
    If sDPT = cboDPT.List(i) Then
      found = True
      Exit For
    End If
  Next i
  If found Then
    hasDpt = i
  Else
    hasDpt = -1
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Property Let dpt(sDPT As String)
  
Dim i As Integer
  
  i = hasDpt(sDPT)
  If i >= 0 Then
    cboDPT.ListIndex = i
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get dpt() As String
  If mboOK Then
    dpt = cboDPT.Text
  Else
    dpt = ""
  End If
End Property
'---------------------------------------------------------------------------------------------------
Private Function hasDpe(sDPE As String)
  
  Dim i As Integer
  Dim found As Boolean
  
  found = False
  For i = 0 To cboDPE.ListCount - 1
    If sDPE = cboDPE.List(i) Then
      found = True
      Exit For
    End If
  Next i
  If found Then
    hasDpe = i
  Else
    hasDpe = -1
  End If

End Function
'---------------------------------------------------------------------------------------------------
Public Property Let dpe(sDPE As String)
  Dim i As Integer
  
  i = hasDpe(sDPE)
  If i >= 0 Then
    cboDPE.ListIndex = i
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get dpe() As String
  If mboOK Then
    dpe = cboDPE.Text
  Else
    dpe = ""
  End If
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let DPFkt(sDPFkt As String)

Dim i As Integer
Dim sFktBez As String

  sFktBez = sDPFkt 'M_DPFunktion.CDPFktToName(sDPFkt)
  For i = 0 To cboDPFkt.ListCount - 1
    If sFktBez = cboDPFkt.List(i) Then
      cboDPFkt.ListIndex = i
    End If
  Next i
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get DPFkt() As String
  
  If mboOK Then
    'Funktionen sind immer gleich den Konstanten!
    DPFkt = cboDPFkt.Text
  Else
    DPFkt = ""
  End If

End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Vorperiode(iVorperiode As Integer)
  'txtVorperiode = iVorperiode
  spnVorperiode.value = iVorperiode
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Vorperiode() As Integer
  On Error Resume Next
  Vorperiode = CInt(txtVorperiode)
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let dp(sDP As String)

Dim i As Integer
Dim j As Integer
  
  If mcoDP Is Nothing Then Exit Property
  For i = 1 To mcoDP.Count
    If mcoDP.Item(i).dp = sDP Then
      For j = 0 To lstDP.ListCount - 1
        If lstDP.List(j, 1) = i Then
          lstDP.Selected(j) = True
          Exit Property
        End If
      Next j
    End If
  Next i
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let AutoFormat(iAutoFormat As Integer)
  If iAutoFormat >= 0 And iAutoFormat <= 2 Then
    cboAutoFormat.ListIndex = iAutoFormat
  End If
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get AutoFormat() As Integer
  If cboAutoFormat.ListIndex = -1 Then
    AutoFormat = 0
  Else
    AutoFormat = cboAutoFormat.ListIndex
  End If
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Marker(boMarker As Boolean)
  chkMarker.value = boMarker
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get Marker() As Boolean
  Marker = chkMarker
End Property

'---------------------------------------------------------------------------------------------------
Public Sub DPL(ByRef asDPL() As String, _
               ByRef asKommentar() As String, _
               ByRef asAlias() As String)

Dim iDPL As Long  'IM 118161 Overflow bei >32'Bit - Wandlung von Integer zu Long
  
  ReDim asDPL(0)
  ReDim asKommentar(0)
  ReDim asAlias(0)
  
  If mboOK Then
    For iDPL = 1 To lstDP.ListCount
      If lstDP.Selected(iDPL - 1) Then
        ReDim Preserve asDPL(UBound(asDPL) + 1)
        ReDim Preserve asKommentar(UBound(asKommentar) + 1)
        ReDim Preserve asAlias(UBound(asAlias) + 1)

        asDPL(UBound(asDPL)) = mcoDP.Item(lstDP.List(iDPL - 1, 1)).dp
        asKommentar(UBound(asKommentar)) = mcoDP.Item(lstDP.List(iDPL - 1, 1)).Kommentar
        asAlias(UBound(asAlias)) = mcoDP.Item(lstDP.List(iDPL - 1, 1)).Alias
      End If
    Next iDPL
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Function readDPL() As CO_DP
  Dim coDP As CO_DP
  Dim oDP  As C_DP
  Dim iDP  As Long
  Dim n    As Long

  Set coDP = New CO_DP
  For n = 1 To lstDP.ListCount
    If lstDP.Selected(n - 1) Then
      iDP = lstDP.List(n - 1, 1)
      Set oDP = mcoDP.Item(iDP)
      
      oDP.dpe = Me.dpe
      oDP.dpt = Me.dpt
      oDP.ArchivFkt = Me.DPFkt
      oDP.ArchivTyp = Me.ArchivTyp
      oDP.Marker = Me.Marker
      oDP.AutoFormat = Me.AutoFormat
      oDP.ResultQuery = getResultQuery
      oDP.ResultFkt = getResultFkt
      oDP.Offset = Me.Vorperiode
      If (miModus = 7 Or miModus = 8) Then
        oDP.CostCenter = cmbCostCenter.Text
        oDP.CCWeighting = txtWeighting
        
        oDP.CCMedium = cmbMedia.Text  ' current selection
        oDP.CCUnitFactor = txtUnitFactor
      End If
      
      Call coDP.Add(oDP)
    End If
  Next n
  Set readDPL = coDP

End Function
'---------------------------------------------------------------------------------------------------
Public Function getDPL() As CO_DP

Dim coDP As CO_DP
Dim oDP  As C_DP
Dim iDP  As Long
Dim n    As Long

  If mboOK Then
    Set getDPL = readDPL()
  Else
    Set getDPL = New CO_DP
  End If

End Function

'---------------------------------------------------------------------------------------------------
Public Sub setDp(oDP As C_DP)

Dim i As Integer
Dim j As Integer
  
  If oDP Is Nothing Then Exit Sub
  'Achtung: auf die richtige Reihenfolge muss geachtet werden!
  'mcoDP wird im Hintergrund aufgebaut.
  Me.ArchivTyp = oDP.ArchivTyp
  Me.SystemName = oDP.PVSSSystem
  Me.dpt = oDP.dpt
  Me.dpe = oDP.dpe
  Me.dp = oDP.dp
  Me.DPFkt = oDP.ArchivFkt
  Me.Marker = oDP.Marker
  Me.AutoFormat = oDP.AutoFormat
  Call setResultQuery(oDP.ResultQuery)
  Call setResultFkt(oDP.ResultFkt)
  Me.Vorperiode = oDP.Offset
  
  If (miModus = 7 Or miModus = 8) Then
    cmbCostCenter.Text = oDP.CostCenter
    txtWeighting.Text = oDP.CCWeighting
    
    cmbMedia.Text = oDP.CCMedium
    txtUnitFactor = oDP.CCUnitFactor
  End If
  
  If mcoDP Is Nothing Then Exit Sub
  For i = 1 To mcoDP.Count
    If mcoDP.Item(i).dp = oDP.dp Then
      For j = 0 To lstDP.ListCount - 1
        If lstDP.List(j, 1) = i Then
          lstDP.Selected(j) = True
          Exit Sub
        End If
      Next j
    End If
  Next i

End Sub

'---------------------------------------------------------------------------------------------------
Public Sub DPTypen(ByRef asDPTypen() As String)

Dim iDPTypID

  cboDPT.Clear
  For iDPTypID = 1 To UBound(asDPTypen)
    cboDPT.AddItem asDPTypen(iDPTypID)
  Next iDPTypID
  
  If cboDPT.ListIndex = -1 And cboDPT.ListCount > 0 Then
    cboDPT.ListIndex = 0
  End If
  'IM 54863 Deadlock
  cboDPT.MatchRequired = (cboDPT.ListCount > 0)
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  'ToDo: Optionen Auswahl und FilterDP speichern
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

Private Function EingabenPruefen() As Boolean
  Dim x As Double
  Dim n As Long
  Dim foundDp As Boolean
  Dim coDP As CO_DP
  Dim oDP As C_DP
  Dim oMedium As C_Medium
  Dim ret As Integer
  
  EingabenPruefen = True
  
  If (EingabenPruefen = True) Then
    foundDp = False
    For n = 1 To lstDP.ListCount
      If lstDP.Selected(n - 1) Then
        foundDp = True
      End If
    Next n
    If (Not foundDp) Then
      Call MsgBox(GetResText(21172), vbOKOnly, GetResText(20104))  '"Kein Datenpunkt angew|fffd|hlt"
      EingabenPruefen = False
      Exit Function
    End If
    
    Set oMedium = M_Media.FilterName(cmbMedia.Text)
    Set coDP = Me.readDPL
    If (Not oMedium Is Nothing) Then
      For Each oDP In coDP.Items
        If (oDP.Einheit <> oMedium.unit) Then
          ret = MsgBox(GetResText(21178), vbOKCancel, GetResText(20103))
          If (ret = vbCancel) Then
            EingabenPruefen = False
            Exit Function
          End If
        End If
      Next oDP
    End If
  End If
  
  If (SimpleArchivTyp = ARCHIVTYP_RDB Or SimpleArchivTyp = ARCHIVTYP_RAC) Then
    If cboDPFkt.Text = "" Then    ' "Keine Funktion gewaehlt!"
      Call MsgBox(GetResText(22007), vbOKOnly, GetResText(20104))
      EingabenPruefen = False
      Exit Function
    End If
  End If
  
  ' CostCenter modi insert / update
  If (miModus = 7 Or miModus = 8) Then
  
    If cmbCostCenter.Text = "" Then   ' IM 102529 / 1
      Call MsgBox(GetResText(21169), vbOKOnly, GetResText(20104))
      EingabenPruefen = False
      Exit Function
    End If
    
    If cmbMedia.Text = "" Then        ' IM 102529 / 1
      Call MsgBox(GetResText(21191), vbOKOnly, GetResText(20104))
      EingabenPruefen = False
      Exit Function
    End If
    
    On Error Resume Next
    x = CDbl(txtWeighting.Text)
    If (x > 1 Or x <= 0) Then
      Call MsgBox(GetResText(21173), vbOKOnly, GetResText(20104))   'Gewichtungsfaktor Fehler
      EingabenPruefen = False
      Exit Function
    End If
    
    x = CDbl(txtUnitFactor.Text)
    If (x = 0) Then
      Call MsgBox(GetResText(21199), vbOKOnly, GetResText(20104))   'Unitfaktor Fehler
      EingabenPruefen = False
      Exit Function
    End If
    On Error GoTo 0
    
  End If
  
End Function

  
'---------------------------------------------------------------------------------------------------
Private Sub cboSystemName_Change()

  Dim dpe As String
  Dim dpt As String
  Dim showElement As Boolean
  
  ' bei SYstemauswahl sollen DPT und DPE eingestellt bleiben (wenn moeglich)
  ' lt. Spec von Mauell
  dpe = cboDPE.Text
  dpt = cboDPT.Text
  showElement = True
  Call cboArchivTyp_Change      ' tun wir so als ob
  
  ' eigentlich wollten Sie auch noch eine Meldung, wenns nicht geht ....?
  If dpt <> "" And hasDpt(dpt) < 0 And Me.Visible Then
    ' " Datenpunkttyp konnte nicht beibehalten werden"
    Call MsgBox(GetResText(21165), _
              vbOKOnly & vbInformation, _
              GetResText(20105))    ' Hinweis
    showElement = False
  End If
  Me.dpt = dpt  ' typ setzen
  
  If dpe <> "" And hasDpe(dpe) < 0 And Me.Visible And showElement Then
    ' " Datenpunktelement konnte nicht beibehalten werden"
    Call MsgBox(GetResText(21166), _
              vbOKOnly & vbInformation, _
              GetResText(20105))    ' Hinweis
  End If
  Me.dpe = dpe
  
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub cboArchivTyp_Change()

  Select Case SimpleArchivTyp
    Case ARCHIVTYP_AC      'AC Typen
      Call AC_Init(useRdb:=1)
    Case ARCHIVTYP_RAC      'RDB Typen
      Call AC_Init(useRdb:=2)
    Case ARCHIVTYP_HDB    'HDB direkt
      Call HDB_Init
    Case ARCHIVTYP_RDB    ' RDB ...
      Call RDB_Init
    Case ARCHIVTYP_ONLINE                             ' ONLINE
      Call Online_Init
    Case Else: Stop
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboAuswahl_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboAuswahl_Change()
  M_Optionen.getOpt.Auswahl = cboAuswahl.Text
  Call DPLAnzeigen
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPE_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
      If KeyCode = 9 Then
        KeyCode = 0
        Shift = 0
        'cboAuswahl.SetFocus
      End If
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPE_Change()
  
Dim oComMan     As ComManager
Dim v           As Variant
Dim oDP         As C_DP
Dim sDP         As String
Dim n           As Long
Dim i           As Long
Dim sDPE        As String
Dim asDpFunct() As String
Dim asHelp()    As String

  If cboDPE.ListCount = 0 Then
    Exit Sub
  End If
  
  Set oComMan = M_PVSS.getComMan
  If SimpleArchivTyp = ARCHIVTYP_AC Then    ' AC Para
    For Each oDP In mcoDP.Items
      oDP.dpe = cboDPE.Text
      If oDP.dpe = "" Then
        sDP = oDP.dp & ".value"
      Else
        sDP = oDP.dp & "." & oDP.dpe & ".value"
      End If
      v = oComMan.dpGetDescription(sDP)
      If Not IsError(v) Then oDP.Kommentar = CStr(v)
      v = oComMan.dpGetAlias(sDP)
      If Not IsError(v) Then oDP.Alias = CStr(v)
      v = oComMan.dpGetFormat(sDP)
      If Not IsError(v) Then oDP.Format = CStr(v)
      v = oComMan.dpGetUnit(sDP)
      If Not IsError(v) Then oDP.Einheit = CStr(v)
      
    Next oDP
    Call DPLAnzeigen
    Call AC_DpType_DPEChanged 'IM 47699
  Else
    For Each oDP In mcoDP.Items
      If oDP.dpe = "" Then
        sDP = oDP.dp & "."
      Else
        sDP = oDP.dp & "." & oDP.dpe
      End If
      v = oComMan.dpGetDescription(sDP)
      If Not IsError(v) Then oDP.Kommentar = CStr(v)
      v = oComMan.dpGetAlias(sDP)
      If Not IsError(v) Then oDP.Alias = CStr(v)
      v = oComMan.dpGetFormat(sDP)
      If Not IsError(v) Then oDP.Format = CStr(v)
      v = oComMan.dpGetUnit(sDP)
      If Not IsError(v) Then oDP.Einheit = CStr(v)
    Next oDP
    Call DPLAnzeigen
  End If
  
  ' fill list of configs
  If SimpleArchivTyp = ARCHIVTYP_RDB Then    ' RDB
    cboDPFkt.Clear
    cboDPFkt.AddItem ("")
    cboDPFkt.ListIndex = 0
    If (lstDP.ListIndex >= 0) Then lstDP.Selected(lstDP.ListIndex) = False   ' unselect DP
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPFkt_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPT_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboDPT_Change()

  If cboDPT.ListCount = 0 Then
    cboDPE.Clear
    lstDP.Clear
    Exit Sub
  End If
  
  Select Case SimpleArchivTyp
    Case ARCHIVTYP_AC    'AC Typen
      Call AC_DpType
    Case ARCHIVTYP_RAC    'RDB Compression Typen
      Call RAC_DpType
    Case ARCHIVTYP_HDB    'HDB direkt
      Call HDB_DpType
    Case ARCHIVTYP_RDB
      Call RDB_DpType
    Case ARCHIVTYP_ONLINE
      Call Online_DpType
    Case Else: Stop
  End Select
    
End Sub

'---------------------------------------------------------------------------------------------------
'Public Property Let MehrfachAuswahl(boMehrfach As Boolean)
'  If boMehrfach Then
'    lstDP.MultiSelect = fmMultiSelectMulti
'  Else
'    lstDP.MultiSelect = fmMultiSelectSingle
'  End If
'End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Modus(iModus As Integer)

  Dim coCostCenter  As CO_CostCenter
  Dim oCostCenter   As C_CostCenter
  Dim coMedia       As CO_Media
  Dim oMedium       As C_Medium
  Dim stringArray() As String
  
  miModus = iModus
  
  frmCostCenter.Visible = False
  
  Select Case iModus
  
    'StdProt - DP Einfuegen
    'AtvProt - DP Einfuegen
    Case 1, 5
      Me.Caption = GetResText(16014)
      lstDP.MultiSelect = fmMultiSelectExtended
      lvwDpFkt.Enabled = True
      lvwDpFkt.BackColor = &H80000005 'weiss
    
    'StdProt - DP Aendern
    'AtvProt - DP Aendern
    Case 2, 6
      Me.Caption = GetResText(16015)
      lstDP.MultiSelect = fmMultiSelectSingle
      lvwDpFkt.Enabled = True
      lvwDpFkt.BackColor = &H80000005 'weiss
    
    'BtrProt - DP Einfuegen
    Case 3
      Me.Caption = GetResText(16014)
      lstDP.MultiSelect = fmMultiSelectExtended
      lvwDpFkt.Enabled = False
      lvwDpFkt.BackColor = &H8000000F 'grau
      chkMarker.Enabled = False
    
    'BtrProt - DP Aendern
    Case 4
      Me.Caption = GetResText(16015)
      lstDP.MultiSelect = fmMultiSelectSingle
      lvwDpFkt.Enabled = False
      lvwDpFkt.BackColor = &H8000000F 'grau
      chkMarker.Enabled = False
      
    'CstProt - DP Einfuegen
    Case 7
      Me.Caption = GetResText(16014)
      lstDP.MultiSelect = fmMultiSelectExtended
      lvwDpFkt.Enabled = False
      lvwDpFkt.BackColor = &H80000005 'weiss
      txtWeighting.Text = 1#
      txtUnitFactor = 1#
    
    'CstProt - DP Aendern
    Case 8
      Me.Caption = GetResText(16015)
      lstDP.MultiSelect = fmMultiSelectSingle
      lvwDpFkt.Enabled = False
      lvwDpFkt.BackColor = &H80000005 'weiss
    
  End Select

  cboArchivTyp.AddItem GetResText(16034)  ' AC Typen
  If IS_RDBACTIVE Then cboArchivTyp.AddItem GetResText(16049)  ' RDB 'Types'
  If iModus < 7 Then
    cboArchivTyp.AddItem GetResText(16035)  ' HD direkt
    If IS_RDBACTIVE Then cboArchivTyp.AddItem GetResText(16048)  ' RDB direkt
  Else
    frmCostCenter.Visible = True
    frmExtend.Visible = False
    
    Set coCostCenter = M_CostCenter.coLesen   ' alle
    For Each oCostCenter In coCostCenter.Items
      cmbCostCenter.AddItem oCostCenter.Bezeichnung
    Next
    If (coCostCenter.Count > 0) Then
      cmbCostCenter.ListIndex = 0
      Set oCostCenter = coCostCenter.Items(1)
    Else
      cmbCostCenter.AddItem GetResText(16045) ' keine Kostenstelle
    End If
    
    Let txtDPUnitText.value = ""
  End If
  
  If miModus = 3 Or miModus = 4 Then
    cboArchivTyp.AddItem GetResText(16036) ' PVSS Online
  End If
  
  cboArchivTyp.ListIndex = 0    ' Einstellen auf AC Typen (default)

End Property

'---------------------------------------------------------------------------------------------------
' switch appended media
Private Sub cmbCostCenter_Change()

  Dim coCostCenter As CO_CostCenter
  Dim oCostCenter As C_CostCenter
  Dim coMedia As CO_Media
  Dim oMedium As C_Medium
  
  Set coCostCenter = M_CostCenter.coLesen   ' alle
  Set oCostCenter = coCostCenter.FindItem(cmbCostCenter.Text)

  If (Not oCostCenter Is Nothing) Then
    Set coMedia = M_Media.coFilterCc(oCostCenter.ID)
  End If
  
  cmbMedia.Clear
  If (Not coMedia Is Nothing) Then
    If (coMedia.Count > 0) Then
      For Each oMedium In coMedia.Items
        cmbMedia.AddItem oMedium.Name
      Next oMedium
    Else
      cmbMedia.AddItem GetResText(16046)    ' kein Medium
    End If
  Else
    cmbMedia.AddItem GetResText(16046)    ' kein Medium
  End If
  cmbMedia.ListIndex = 0

End Sub

Private Sub cmbMedia_Change()
  Dim oMedium As C_Medium
  
  Set oMedium = M_Media.coLesen.FindItem(cmbMedia.Text)
  If (Not oMedium Is Nothing) Then
    txtMediaUnit.Text = M_Media.coLesen.FindItem(cmbMedia.Text).unit
  Else
    txtMediaUnit.Text = ""
  End If
End Sub

'---------------------------------------------------------------------------------------------------
' IM 95819: Anzeige von Unit je gew|fffd|hltem DP, |fffd|bereinstimmung wird gepr|fffd|ft
' IM 99915/1: DP change displays unit rsp. not matching unit
Private Sub lstDP_Change()
  'OSeidel Idee: TipText fuer den Text unterhalb des Cursors aktualisieren
Dim i As Integer
Dim firstUnit   As String
Dim isFirstDp   As Boolean
Dim sDP         As String
Dim n           As Long
Dim asDpFunct() As String
Dim asHelp()    As String
Dim sDPE        As String
Dim vHelp       As Variant
Dim lCount      As Long
  
  isFirstDp = True
  
  For i = 1 To lstDP.ListCount
    If lstDP.Selected(i - 1) = True Then
      sDP = mcoDP.Item(i).dp
      If (isFirstDp) Then
        firstUnit = mcoDP.Item(i).Einheit
        isFirstDp = False
      ElseIf (mcoDP.Item(i).Einheit <> firstUnit) Then
          firstUnit = GetResText(16043)   ' "<mismatch>"
      End If
    End If
  Next i
  
  txtDPUnitText.value = firstUnit
  
  ' RDB influence to config
  If ArchivTyp = ARCHIVTYP_RDBPERIODE And sDP <> "" Then      ' RDB Direct: function depends on DP & DPE
  
    cboDPFkt.Clear
    Call M_PVSS.getReportExt.dpRdbElems("", sDP + ".*", vHelp)
    On Error Resume Next
    lCount = UBound(vHelp)  ' something there?
    On Error GoTo 0
    
    If (lCount > 0) Then
      ReDim asDpFunct(UBound(vHelp))
      sDP = sDP & "." & cboDPE.Text
      For n = 1 To UBound(vHelp)
      
        Call M_Tools.StrToArray(asHelp(), vHelp(n), ":")
        sDPE = asHelp(1) & ":" & asHelp(2)
        If (sDP = sDPE) Then
          For i = 1 To UBound(asDpFunct)  ' no duplicated details
            If asDpFunct(i) = asHelp(3) Or _
               asDpFunct(i) = "" Then
              Exit For
            End If
          Next i
          If asDpFunct(i) = "" Then asDpFunct(i) = asHelp(3)
        End If
      Next n
          
      For i = 1 To UBound(asDpFunct)
        If Len(asDpFunct(i)) > 0 Then cboDPFkt.AddItem asDpFunct(i)
      Next i
    End If
       
    If (cboDPFkt.ListCount = 0) Then
      cboDPFkt.AddItem ""
    End If
    cboDPFkt.ListIndex = 0
  End If
    
End Sub

Private Sub spnVorperiode_Change()
  txtVorperiode = spnVorperiode.value
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtFilter_AfterUpdate()
  M_Optionen.getOpt.FilterDP = txtFilter.Text
  Call DPLAnzeigen
End Sub

'---------------------------------------------------------------------------------------------------
'IM 58225 auch wenn es nicht windowskonform ist...
Private Sub txtFilter_Enter()
  btnOK.Default = False
End Sub
Private Sub txtFilter_Exit(ByVal cancel As MSForms.ReturnBoolean)
  btnOK.Default = True
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim oComMan As reportExt
Dim lstItem As ListItem
Dim oDPFkt  As C_DPFunktion
Dim sysName As Variant
Dim mySystem As Variant
Dim i As Integer

  Call FormularBeschriften(Me)
  
  'Set mcoDPL = New CO_DPL
  txtFilter.Text = M_Optionen.getOpt.FilterDP
  frmExtend.Visible = M_Optionen.getOpt.DpInsExtend
  
  ' Systemname beliefern
  Set oComMan = M_PVSS.getReportExt
  cboSystemName.Clear
  Call oComMan.getSystemName(-1, mySystem)   ' default system
  cboSystemName.AddItem mySystem
  For i = 0 To MAX_SYSNO     ' in 3.0 256, spaeter mehr
    Call oComMan.getSystemName(i, sysName)
    If sysName <> "" And sysName <> mySystem Then
        cboSystemName.AddItem sysName
    End If
  Next i
  cboSystemName.ListIndex = 0   ' der eigene
  If cboSystemName.ListCount < 2 Then
    cboSystemName.Enabled = False
  End If

  cboAuswahl.AddItem GetResText(21200)
  cboAuswahl.AddItem GetResText(21201)
  cboAuswahl.AddItem GetResText(21202)
  cboAuswahl.MatchRequired = True
  cboAuswahl.Text = M_Optionen.getOpt.Auswahl
    
  spnVorperiode.value = 0
  txtVorperiode = 0
  
  'Initialisieren des ListViews
  With lvwDpFkt
    .View = lvwReport
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .Gridlines = True
    .CheckBoxes = True
    .FullRowSelect = True
    .ColumnHeaders.Add Text:=GetResText(17065), Width:=80 '"Funktion"
    .ColumnHeaders.Add Text:=GetResText(17066), Width:=50 '"Quelle"
    .ColumnHeaders.Add Text:=GetResText(17067), Width:=0  '"Berechnen"
  End With

  'ListView mit Daten fuellen
  lvwDpFkt.ListItems.Clear
  For Each oDPFkt In M_DPFunktion.coLesen.Items
  
    Set lstItem = lvwDpFkt.ListItems.Add
    lstItem.Text = oDPFkt.Bezeichnung
    lstItem.ListSubItems.Add Text:=GetResText(TXT_STAT_FKT_ABFRAGEN)
    lstItem.ListSubItems.Add Text:=oDPFkt.BerechnungMoeglich
    
  Next oDPFkt
    
  cboAutoFormat.Clear
  cboAutoFormat.AddItem GetResText(TXT_AUTOFORMAT_NOFORMAT)
  cboAutoFormat.AddItem GetResText(TXT_AUTOFORMAT_ONLYFORMAT)
  cboAutoFormat.AddItem GetResText(TXT_AUTOFORMAT_FORMATUNIT)
  cboAutoFormat.ListIndex = 0
    
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Terminate()
  Set mcoDP = Nothing
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub DPLAnzeigen()
  
Dim coDP    As CO_DP
Dim asDP()  As String
Dim iDP     As Integer
Dim iZeile  As Integer
Dim sText   As String
Dim iMausZeigerAlt As Integer
Dim c As Long
  
  If mcoDP Is Nothing Then Exit Sub
  
  iMausZeigerAlt = Me.MousePointer
  Me.MousePointer = fmMousePointerHourGlass
  
  ReDim asDP(0)
  For iDP = 0 To lstDP.ListCount - 1
    If lstDP.Selected(iDP) Then
      c = c + 1
      ReDim Preserve asDP(c)
      asDP(c) = lstDP.List(iDP)
    End If
  Next iDP

  lstDP.Clear
  Select Case cboAuswahl.Text
    'Alias
    Case GetResText(21201)
      For iDP = 1 To mcoDP.Count
        sText = mcoDP.Item(iDP).Alias
        If (sText Like txtFilter) And _
           (Len(mcoDP.Item(iDP).Alias) > 0) Then
          iZeile = lstDP.ListCount
          lstDP.AddItem sText, iZeile
          lstDP.Column(1, iZeile) = iDP
          For c = 1 To UBound(asDP)
            If asDP(c) = sText Then
              lstDP.Selected(iZeile) = True
              Exit For
            End If
          Next c
          If (iDP Mod 50) = 0 Then
            DoEvents
            'Me.Repaint
          End If
        End If
      Next iDP
    'Kommentar
    Case GetResText(21202)
      For iDP = 1 To mcoDP.Count
        sText = mcoDP.Item(iDP).Kommentar
        If (sText Like txtFilter) And _
           (Len(mcoDP.Item(iDP).Kommentar) > 0) Then
          iZeile = lstDP.ListCount
          lstDP.AddItem sText, iZeile
          lstDP.Column(1, iZeile) = iDP
          For c = 1 To UBound(asDP)
            If asDP(c) = sText Then
              lstDP.Selected(iZeile) = True
              Exit For
            End If
          Next c
          If (iDP Mod 50) = 0 Then
            DoEvents
            'Me.Repaint
          End If
        End If
      Next iDP
    'DP
    Case Else
      For iDP = 1 To mcoDP.Count
        sText = mcoDP.Item(iDP).dp
        If (sText Like txtFilter) And _
           (Len(mcoDP.Item(iDP).dp) > 0) Then
          iZeile = lstDP.ListCount
          lstDP.AddItem sText, iZeile
          lstDP.Column(1, iZeile) = iDP
          For c = 1 To UBound(asDP)
            If asDP(c) = sText Then
              lstDP.Selected(iZeile) = True
              Exit For
            End If
          Next c
          If (iDP Mod 50) = 0 Then
            DoEvents
            'Me.Repaint
          End If
        End If
      Next iDP

  End Select

  Me.MousePointer = iMausZeigerAlt

End Sub
'---------------------------------------------------------------------------------------------------
Private Function getResultQuery() As String
  getResultQuery = getResult(1)
End Function
Private Function getResultFkt() As String
  getResultFkt = getResult(2)
End Function
Private Function getResult(iType As Integer) As String
  Dim lsList As ListItem
  Dim s As String

  If lvwDpFkt.Enabled = True Then   ' depending on mode
    For Each lsList In lvwDpFkt.ListItems
      If lsList.Checked = True Then
        If (iType = 1 And lsList.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN)) Or _
           (iType = 2 And lsList.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_BERECHNEN)) Then
          If s = "" Then
            s = lsList
          Else
            s = s & "|" & lsList
          End If
        End If
      End If
    Next lsList
  End If
  getResult = s
End Function

'---------------------------------------------------------------------------------------------------
Private Function setResultQuery(sValue As String)
  Call setResult(sValue, 1)
End Function
Private Function setResultFkt(sValue As String)
  Call setResult(sValue, 2)
End Function
Private Function setResult(sValue As String, iType As Integer)

Dim lsItem As ListItem
Dim i As Integer
Dim asFkt() As String

  Call M_Tools.StrToArray(asFkt, sValue, "|")
  For Each lsItem In lvwDpFkt.ListItems
    For i = 1 To UBound(asFkt)
      If lsItem = asFkt(i) Then
        lsItem.Checked = True
        If iType = 1 Then
          lsItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN)
        Else
          lsItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_BERECHNEN)
        End If
      End If
    Next i
  Next lsItem

End Function

'---------------------------------------------------------------------------------------------------
Public Sub getDPFKT(ByRef asDpFktAuslesen() As String, _
                    ByRef asDpFktBerechnen() As String)
  
Dim iZaehlerAuslesen As Integer
Dim iZaehlerBerechnen As Integer
Dim lsList As ListItem

  ReDim asDpFktAuslesen(0)
  ReDim asDpFktBerechnen(0)
  
  For Each lsList In lvwDpFkt.ListItems
    If lsList.Checked = True Then
      If lsList.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN) Then
        iZaehlerAuslesen = iZaehlerAuslesen + 1
        ReDim Preserve asDpFktAuslesen(iZaehlerAuslesen)
        asDpFktAuslesen(iZaehlerAuslesen) = lsList
      Else
        iZaehlerBerechnen = iZaehlerBerechnen + 1
        ReDim Preserve asDpFktBerechnen(iZaehlerBerechnen)
        asDpFktBerechnen(iZaehlerBerechnen) = lsList
      End If
    End If
  Next
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub setDPFKT(ByRef asDpFktAuslesen() As String, _
                    ByRef asDpFktBerechnen() As String)

Dim lsItem As ListItem
Dim i As Integer

  For Each lsItem In lvwDpFkt.ListItems
    For i = 1 To UBound(asDpFktAuslesen)
      If lsItem = asDpFktAuslesen(i) Then
        lsItem.Checked = True
        lsItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN)
      End If
    Next i
    
    For i = 1 To UBound(asDpFktBerechnen)
      If lsItem = asDpFktBerechnen(i) Then
        lsItem.Checked = True
        lsItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_BERECHNEN)
      End If
    Next i

  Next lsItem
End Sub
' for AC Para only
'---------------------------------------------------------------------------------------------------
Private Sub lvwDpFkt_DblClick()
    
  'Wenn in der zweiten Unterspalte "true" (Berechnen durch Excel ist freigegeben),
  'dann in der ersten Unterspalte Quelle toggeln
  If Not (SimpleArchivTyp = ARCHIVTYP_AC Or _
          SimpleArchivTyp = ARCHIVTYP_RAC) Then
    Exit Sub
  End If
  
  If lvwDpFkt.SelectedItem.ListSubItems(2) = True Then
    If lvwDpFkt.SelectedItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_BERECHNEN) Then
      lvwDpFkt.SelectedItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN)
    Else
      lvwDpFkt.SelectedItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_BERECHNEN)
    End If
  Else
    Call MsgBox(GetResText(21132), _
              vbOKOnly & vbInformation, _
              GetResText(20105))
  End If
End Sub

Private Sub AC_Init(useRdb As Integer)

Dim asDpType() As String
Dim n As Long
Dim lstItem As ListItem

  cboDPFkt.Enabled = True
  cboDPT.Clear
    
  Call M_DB.getDPTyps(cboSystemName.Text, asDpType, 1, useRdb)
  For n = 1 To UBound(asDpType)
    Call cboDPT.AddItem(asDpType(n))
  Next n
  If cboDPT.ListCount > 0 And _
     cboDPT.ListIndex = -1 Then
    cboDPT.ListIndex = 0
  End If
  
  'IM 54863 Deadlock
  cboDPT.MatchRequired = (cboDPT.ListCount > 0)
  
  If lvwDpFkt.Enabled Then
    For Each lstItem In lvwDpFkt.ListItems
      lstItem.ForeColor = RGB(0, 0, 0)
      If Not lstItem.Checked Then
        lstItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN)
      End If
    Next lstItem
  End If

End Sub

Private Sub AC_DpType()

Dim oComMan     As ComManager
Dim sDpType     As String
Dim asDpName()  As String
Dim asDPE()     As String
Dim iDpeType    As Integer
Dim oDP         As C_DP
Dim n As Long
Dim i As Long

  cboDPE.Clear
  lstDP.Clear
  
  Set mcoDP = Nothing
  Set mcoDP = New CO_DP
  
  sDpType = cboDPT.Text
  Set oComMan = M_PVSS.getComMan
  'On Error Resume Next
  Call oComMan.dpNames(cboSystemName.Text & ":*", sDpType, asDpName)
  'On Error GoTo HDB_DpType_Error
  
  For n = 1 To UBound(asDpName)
    'Interne DP ausblenden
    'If Left(asDpName(n), 1) <> "_" Then
    If InStr(1, asDpName(n), ":_") = 0 Then
      Set oDP = New C_DP
      oDP.dp = asDpName(n)
      mcoDP.Add oDP
    End If
  Next n

  cboDPE.Clear
  Call M_DB.getArchivDPE(asDPE, cboSystemName.Text, cboDPT.Text)
  For i = 1 To UBound(asDPE)
    cboDPE.AddItem asDPE(i)
  Next i
  
  If cboDPE.ListCount = 0 Then
    cboDPE.AddItem ""
  End If
  
  If cboDPE.ListIndex = -1 Then
    cboDPE.ListIndex = 0
  End If
  
  Call AC_DpType_DPEChanged
  
End Sub

' -------------------------------------------------------------------------
' rdb compression dp type change
Private Sub RAC_DpType()

Dim oComMan     As ComManager
Dim sDpType     As String
Dim asDpName()  As String
Dim asDPE()     As String
Dim iDpeType    As Integer
Dim oDP         As C_DP
Dim n As Long
Dim i As Long

  cboDPE.Clear
  lstDP.Clear
  
  Set mcoDP = Nothing
  Set mcoDP = New CO_DP
  
  sDpType = cboDPT.Text
  Set oComMan = M_PVSS.getComMan
  'On Error Resume Next
  Call oComMan.dpNames(cboSystemName.Text & ":*", sDpType, asDpName)
  'On Error GoTo HDB_DpType_Error
  
  For n = 1 To UBound(asDpName)
    'Interne DP ausblenden
    'If Left(asDpName(n), 1) <> "_" Then
    If InStr(1, asDpName(n), ":_") = 0 Then
      Set oDP = New C_DP
      oDP.dp = asDpName(n)
      mcoDP.Add oDP
    End If
  Next n

  cboDPE.Clear
  Call M_DB.getArchivDPE(asDPE, cboSystemName.Text, cboDPT.Text)
  For i = 1 To UBound(asDPE)
    cboDPE.AddItem asDPE(i)
  Next i
  
  If cboDPE.ListCount = 0 Then
    cboDPE.AddItem ""
  End If
  
  If cboDPE.ListIndex = -1 Then
    cboDPE.ListIndex = 0
  End If
  
  Call AC_DpType_DPEChanged
  
End Sub


'IM 47699
Private Sub AC_DpType_DPEChanged()

Dim coArchiv  As CO_Archiv
Dim oArchiv   As C_Archiv
Dim oDPFkt    As C_DPFunktion
Dim i As Integer
Dim boGefunden As Boolean
  
  cboDPFkt.Clear
  Set coArchiv = M_Archiv.coSuchen(sDPT:=cboDPT.Text, sDPE:=cboDPE.Text)
  For Each oArchiv In coArchiv.Items
    For Each oDPFkt In oArchiv.coDPFkt.Items
      boGefunden = False
      For i = 1 To cboDPFkt.ListCount
        If cboDPFkt.List(i - 1, 0) = oDPFkt.Bezeichnung Then
          boGefunden = True
          Exit For
        End If
      Next i
      If Not boGefunden Then
        cboDPFkt.AddItem oDPFkt.Bezeichnung
      End If
    Next oDPFkt
  Next oArchiv
  
  If cboDPFkt.ListIndex = -1 And cboDPFkt.ListCount > 0 Then
    cboDPFkt.ListIndex = 0
  End If
  'IM 54863 Deadlock
  cboDPFkt.MatchRequired = (cboDPT.ListCount > 0)


End Sub

Private Sub HDB_Init()
  
Dim oComMan As ComManager
Dim asDpType() As String
Dim n As Long
Dim lstItem As ListItem
Dim s As String

  On Error GoTo HDB_Init_error
  Set oComMan = M_PVSS.getComMan
  Call oComMan.dpTypes(cboSystemName.Text & ":*", asDpType)
  cboDPT.Clear
  For n = 1 To UBound(asDpType)
    If Left(asDpType(n), 1) <> "_" Then
      cboDPT.AddItem asDpType(n)
    End If
  Next n
  If cboDPT.ListCount > 0 And cboDPT.ListIndex = -1 Then
    cboDPT.ListIndex = 0
  End If
  'IM 54863 Deadlock
  cboDPT.MatchRequired = (cboDPT.ListCount > 0)

  cboDPFkt.Clear
  cboDPFkt.AddItem "_offline.._value"
  cboDPFkt.AddItem "_offline.._status64"
  cboDPFkt.AddItem "_offline.._stime"
  cboDPFkt.ListIndex = 0
  
  'cboDPFkt.Enabled = False

  If lvwDpFkt.Enabled Then
    For Each lstItem In lvwDpFkt.ListItems
      If lstItem.SubItems(2) = True Then
        lstItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_BERECHNEN)
        lstItem.ForeColor = RGB(0, 0, 0)
      Else
        lstItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN)
        lstItem.Checked = False
        lstItem.ForeColor = RGB(128, 128, 128)
      End If
    Next lstItem
  End If
  
Exit Sub
HDB_Init_error:
  
  cboDPT.Clear
  cboDPT.AddItem ""
  cboDPFkt.Clear
  cboDPFkt.AddItem ""
  
  If Err.Number = ERR_PVSS_NOLICENSE Then
    MsgBox Err.Description, vbOKOnly + vbCritical, Err.Number
  End If
  
End Sub

Private Sub HDB_DpType()

Dim oComMan     As ComManager
Dim sDpType     As String
Dim asDpName()  As String
Dim asDPE()     As String
Dim iDpeType    As Integer
Dim oDP         As C_DP
Dim n As Long
Dim i As Long

  On Error GoTo HDB_DpType_Error
  cboDPE.Clear
  lstDP.Clear
  sDpType = cboDPT.Text
  Set oComMan = M_PVSS.getComMan
  On Error Resume Next
  Call oComMan.dpNames(cboSystemName.Text & ":*", sDpType, asDpName)
  On Error GoTo HDB_DpType_Error
'
  Set mcoDP = Nothing
  Set mcoDP = New CO_DP
  
  For n = 1 To UBound(asDpName)
    'Interne DP ausblenden
    'If Left(asDpName(n), 1) <> "_" Then
    If InStr(1, asDpName(n), ":_") = 0 Then
      Set oDP = New C_DP
      oDP.dp = asDpName(n)
      mcoDP.Add oDP
    End If
  Next n
  'Wird erst Angezeigt, wenn DPE bekannt ist (wg. Alias und Kommentar)
  
  If UBound(asDpName) > 0 Then
    Call oComMan.dpNames(asDpName(1) & ".**", sDpType, asDPE)
  End If

  Call addDpElements(Len(asDpName(1)), asDPE)
  
Exit Sub
HDB_DpType_Error:

End Sub

Private Sub Online_Init()
  
  Call HDB_Init
  cboDPFkt.Clear
  cboDPFkt.AddItem "_online.._value"
  cboDPFkt.AddItem "_online.._status64"
  cboDPFkt.AddItem "_online.._stime"
  cboDPFkt.AddItem "_dp_fct.._interm"
  cboDPFkt.ListIndex = 0
  
End Sub

Private Sub Online_DpType()

  Call HDB_DpType

End Sub

'----------------------------------------------------------------------
' Init function for RDB direct / direct input of rdb elements
Private Sub RDB_Init()
  
Dim oRepExt  As reportExt
Dim asDpType As Variant
Dim n        As Long
Dim lstItem  As ListItem
Dim s        As String

  On Error GoTo RDB_Init_error
  Set oRepExt = M_PVSS.getReportExt
  ReDim masRdbDPE(0)
  Call oRepExt.dpRdbTypes(cboSystemName.Text & ":*", asDpType)
  cboDPT.Clear
  For n = 1 To UBound(asDpType)
    cboDPT.AddItem asDpType(n)
  Next n
  If cboDPT.ListCount > 0 And cboDPT.ListIndex = -1 Then
    cboDPT.ListIndex = 0
  End If
  'IM 54863 Deadlock
  cboDPT.MatchRequired = (cboDPT.ListCount > 0)

  If lvwDpFkt.Enabled Then
    For Each lstItem In lvwDpFkt.ListItems
      If lstItem.SubItems(2) = True Then
        lstItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_BERECHNEN)
        lstItem.ForeColor = RGB(0, 0, 0)
      Else
        lstItem.ListSubItems(1).Text = GetResText(TXT_STAT_FKT_ABFRAGEN)
        lstItem.Checked = False
        lstItem.ForeColor = RGB(128, 128, 128)
      End If
    Next lstItem
  End If
  
Exit Sub
RDB_Init_error:
  
  cboDPT.Clear
  cboDPT.AddItem ""
  cboDPFkt.Clear
  cboDPFkt.AddItem ""
  
  If Err.Number = ERR_PVSS_NOLICENSE Then
    MsgBox Err.Description, vbOKOnly + vbCritical, Err.Number
  End If
  
End Sub

Private Sub RDB_DpType()

Dim oRepExt     As reportExt
Dim oComMan     As ComManager
Dim sDpType     As String
Dim asDpName    As Variant
Dim vHelp       As Variant
Dim iDpeType    As Integer
Dim oDP         As C_DP
Dim n           As Long
Dim i           As Long
Dim asHelp()    As String
Dim sHelp       As String
Dim sDPE        As String
Dim asDpFunct() As String
Dim asDPE()     As String
Dim found       As Boolean

  On Error GoTo RDB_DpType_Error
  cboDPE.Clear
  lstDP.Clear
  sDpType = cboDPT.Text
  Set oRepExt = M_PVSS.getReportExt
  On Error Resume Next
  Call oRepExt.dpRdbNames(cboSystemName.Text & ":*", sDpType, asDpName)
  On Error GoTo RDB_DpType_Error

  Set mcoDP = Nothing
  Set mcoDP = New CO_DP
  
  For n = 1 To UBound(asDpName)
    Set oDP = New C_DP
    oDP.dp = asDpName(n)
    mcoDP.Add oDP
  Next n
  'Wird erst Angezeigt, wenn DPE bekannt ist (wg. Alias und Kommentar)
  
  If UBound(asDpName) > 0 Then
    Call oRepExt.dpRdbElems("", (asDpName(1) & ".*"), vHelp)
    
    ReDim asDPE(0)
    ReDim masRdbDPE(UBound(vHelp))
    For n = 1 To UBound(masRdbDPE)
      masRdbDPE(n) = vHelp(n)
      Call M_Tools.StrToArray(asHelp(), masRdbDPE(n), ":")
      sDPE = asHelp(1) & ":" & asHelp(2)  ' system:dp.elem without config

      found = False
      For i = 1 To UBound(asDPE)
        If (asDPE(i) = sDPE) Then found = True
      Next i
      If (Not found) Then
        ReDim Preserve asDPE(UBound(asDPE) + 1)
        asDPE(UBound(asDPE)) = sDPE
      End If
    Next n
  End If
  
  Call addDpElements(Len(asDpName(1)), asDPE)

Exit Sub
RDB_DpType_Error:
  Call MsgBox("Error: " & Err.Description)

End Sub

Private Sub addDpElements(dpNameLen As Long, asDPE() As String)
Dim n As Long
Dim i As Long
Dim iDpeType As Integer
  
  If Not UBound(asDPE) = 0 Then
    For n = 1 To UBound(asDPE)
      ' Set oComMan = M_PVSS.getComMan
      iDpeType = M_PVSS.getComMan.dpElementType(asDPE(n))
      Select Case iDpeType
        Case DPE_CHAR, _
             DPE_UINT, _
             DPE_INT, _
             DPE_FLOAT, _
             DPE_BIT, _
             DPE_32BIT, _
             DPE_TEXT, _
             DPE_TIME:
        
          i = Len(asDPE(n)) - dpNameLen - 1
          If i > 0 Then
            cboDPE.AddItem Right(asDPE(n), i)
          End If
      
      End Select
    Next n
  End If

  If cboDPE.ListCount = 0 Then
    cboDPE.AddItem ""
  End If
  cboDPE.ListIndex = 0
  
End Sub


Attribute VB_Name = "V_Datum"
Attribute VB_Base = "0{56965F93-BC1A-46F3-9C80-A092F1A7626B}{D5DB7668-0AFB-4038-A755-BA90813788CB}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Datum
'Wolfram Klebel 8.7.09
'
'Eingabe eines Datums (dzt. fuer die Festlegung der Feiertage im Tarifset-Detail)
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mdtDatum  As Date
Private mboOK As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let Datum(dt As Date)
  Let mdtDatum = dt
  Call Datum_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Datum() As Date
  Let Datum = mdtDatum
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  mdtDatum = dtDatum.value
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
  Call FormularBeschriften(Me)
  mboOK = False

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Datum_Anzeigen()

  dtDatum.value = mdtDatum
     
End Sub





Attribute VB_Name = "V_Info"
Attribute VB_Base = "0{31F9D99F-C4A4-4CFD-B05E-E581110E4BE7}{1D3E60E3-DD4F-479D-A468-F9459D589F40}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'--------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub lblEMail_ETM1_Click()
  
  On Error GoTo lblEMail_ETM_Click_Fehler
  ActiveWorkbook.FollowHyperlink Address:=lblEMail_ETM1.Caption, NewWindow:=True
  Me.Hide

Exit Sub
lblEMail_ETM_Click_Fehler:
  MsgBox "Cannot open " & lblEMail_ETM1.Caption
End Sub
'--------------------------------------------------------------------------------------------------
Private Sub lblEMail_ETM2_Click()
  
  On Error GoTo lblEMail_ETM_Click_Fehler
  ActiveWorkbook.FollowHyperlink Address:=lblEMail_ETM2.Caption, NewWindow:=True
  Me.Hide

Exit Sub
lblEMail_ETM_Click_Fehler:
  MsgBox "Cannot open " & lblEMail_ETM2.Caption
End Sub
'--------------------------------------------------------------------------------------------------
Private Sub lblEMail_ETM3_Click()
  
  On Error GoTo lblEMail_ETM_Click_Fehler
  ActiveWorkbook.FollowHyperlink Address:=lblEMail_ETM3.Caption, NewWindow:=True
  Me.Hide

Exit Sub
lblEMail_ETM_Click_Fehler:
  MsgBox "Cannot open " & lblEMail_ETM3.Caption
End Sub

Private Sub lblEMail_Sales_Click()
  
  On Error GoTo lblEMail_Sales_Click_Fehler
  ActiveWorkbook.FollowHyperlink Address:=lblEMail_Sales.Caption, NewWindow:=True
  Me.Hide

Exit Sub
lblEMail_Sales_Click_Fehler:
  MsgBox "Cannot open " & lblEMail_Sales.Caption
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub lblHyperLink_ETM_Click()

  On Error GoTo lblHyperLink_ETM_Click_Fehler
  ActiveWorkbook.FollowHyperlink Address:=lblHyperLink_ETM.Caption, NewWindow:=True
  Me.Hide

Exit Sub
lblHyperLink_ETM_Click_Fehler:
  MsgBox "Cannot open " & lblHyperLink_ETM.Caption
End Sub



'--------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim dbV As String

  Call FormularBeschriften(Me)
  
  dbV = GetResText(17511)
  If (dbV <> "") Then
    lblDBVersion = dbV & " " & ProjektVersion
  End If
  
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub


Attribute VB_Name = "V_Kennwort"
Attribute VB_Base = "0{4CEC8570-C165-4D2D-BCC9-6AED2BA2A841}{25988B8F-25C1-4968-A794-1EB9EFB94C3E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'==================================================================================================
'V_Kennwort
'
'Oliver Seidel
'27.01.1999
'
'Frage den Benutzer nach einem Kennwort. Ist dieses korrekt, kann das Fenster ueber OK verlassen
'werden.
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Dim msKennwort           As String
Dim mboOK                As Boolean
Dim mboPasswortSpeichern As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let Titel(sTitel As String)
  Me.Caption = sTitel
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let Kennwort(sKennwort As String)
  msKennwort = sKennwort
End Property

'---------------------------------------------------------------------------------------------------
Public Property Let InfoText(sInfo As String)
  lblInfo = sInfo
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get PasswortSpeichern()
  PasswortSpeichern = mboPasswortSpeichern
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()

  mboOK = True
  mboPasswortSpeichern = chkPasswortSpeichern.value
  
  Me.Hide
End Sub

Private Sub lblInfo_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
  If Button = 4 Then
    'mboOK = True
    'mboPasswortSpeichern = True
    'Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtKennwort_Change()
  If txtKennwort = msKennwort Then
    btnOK.Enabled = True
    chkPasswortSpeichern.Enabled = True
  Else
    btnOK.Enabled = False
    chkPasswortSpeichern.Enabled = False
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

  Call FormularBeschriften(Me)
  
  txtKennwort = ""
  mboOK = False
  
  If mboPasswortSpeichern = True Then
    btnOK.Enabled = True
    chkPasswortSpeichern.Enabled = True
    chkPasswortSpeichern.value = True
  Else
    btnOK.Enabled = False
    chkPasswortSpeichern.value = False
    chkPasswortSpeichern.Enabled = False
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub
Attribute VB_Name = "V_KennwortNew"
Attribute VB_Base = "0{05490BFD-6E68-44AC-8132-AEC89776FD3A}{6F8293EC-BAE2-476A-84FD-1F46C7368D65}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'V_KennwortNew
'
'Oliver Seidel, 21.05.2002
'
'Kennwort aendern: Zunaechst muss das alte Kennword eingegeben werden. Dannach zweimal das neue.
'==================================================================================================
Option Explicit

Dim msKennwortOld        As String
Dim msKennwortNew        As String
Dim mboOK                As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let KennwortOld(sKennwort As String)
  msKennwortOld = sKennwort
  msKennwortNew = sKennwort
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get KennwortNew() As String
  KennwortNew = msKennwortNew
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()

  If txtKennwortOld <> msKennwortOld Then
    Call MsgBox(GetResText(21155), vbCritical + vbOKOnly, GetResText(20102))
    txtKennwortOld = ""
    txtKennwortOld.SetFocus
  ElseIf txtKennwortNew1 <> txtKennwortNew2 Then
    Call MsgBox(GetResText(21156), vbCritical + vbOKOnly, GetResText(20102))
    txtKennwortNew1 = ""
    txtKennwortNew2 = ""
    txtKennwortNew1.SetFocus
  Else
    msKennwortNew = txtKennwortNew1
    mboOK = True
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

  Call FormularBeschriften(Me)
  
  txtKennwortOld = ""
  txtKennwortNew1 = ""
  txtKennwortNew2 = ""
  mboOK = False
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub
Attribute VB_Name = "V_KennwortPLogin"
Attribute VB_Base = "0{28FF85EB-1D42-4E4F-A5EE-9FA03ACFA832}{AA557E42-25DD-493E-9687-DEDC76C6491C}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'V_Kennwort
'
'Oliver Seidel
'27.01.1999
'
'Frage den Benutzer nach einem Kennwort. Ist dieses korrekt, kann das Fenster ueber OK verlassen
'werden.
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Dim mboOK                As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let Titel(sTitel As String)
  Me.Caption = sTitel
End Property
'---------------------------------------------------------------------------------------------------
Public Property Let Username(sUserName As String)
  txtUsername = sUserName
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get Username() As String
  Username = txtUsername
End Property
'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()

Dim sPwdPvss As Variant
Dim sPwdEntered As String

  If Len(txtUsername.value) = 0 Then
    Call MsgBox(GetResText(21183), vbOKOnly, GetResText(20101))
  Else
    mboOK = PVSSLoginCheck(txtUsername.value, txtKennwort.value)
    If (mboOK) Then
      Me.Hide
    Else
      Call MsgBox(GetResText(21182), vbOKOnly, GetResText(20101))
    End If
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

  Call FormularBeschriften(Me)
  
  Call M_PVSS.getComMan.dpSet(MY_REPORT_DP & ".Authenticate.LoginValid", False)
  txtKennwort = ""
  mboOK = False
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub
Attribute VB_Name = "V_MAilVerteiler"
Attribute VB_Base = "0{C9503EC9-E877-4B57-A070-903F7D0511A6}{FCE292F7-893B-4B1C-88F6-BCCB36BA7F37}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_MailVerteiler
'Oliver Seidel 03.05.2001
'
'
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoMailVerteiler  As CO_MailVerteiler
Private mboOK As Boolean
Private mboIsGruppe As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Let MailauswahlAlsGruppe(isGruppe As Boolean)

  mboIsGruppe = isGruppe
  lvwMailVerteiler.MultiSelect = isGruppe
  btnNeu.Visible = Not isGruppe
  btnEdit.Visible = Not isGruppe
  btnDelete.Visible = Not isGruppe
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set MailVerteiler(coMailVerteiler As CO_MailVerteiler)

  Set mcoMailVerteiler = coMailVerteiler
  Call MailVerteiler_Anzeigen
  If lvwMailVerteiler.ListItems.Count > 0 Then
    lvwMailVerteiler.ListItems(1).Selected = True
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get MailVerteiler() As CO_MailVerteiler
  Set MailVerteiler = mcoMailVerteiler
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem As ListItem
Dim oMailVerteiler As C_MailVerteiler

  Set lstItem = lvwMailVerteiler.SelectedItem
  If Not lstItem Is Nothing Then
    
    mcoMailVerteiler.Remove lstItem.ListSubItems(1).Text
    Call MailVerteiler_Anzeigen
  Else
    Call MsgBox(GetResText(21185), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem   As ListItem
Dim vwMailVerteiler As V_MailVerteilerDetail
Dim oMailVerteiler  As C_MailVerteiler

Dim i As Integer
Dim s As String

  Set lstItem = lvwMailVerteiler.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.ListSubItems(1).Text
    Set vwMailVerteiler = New V_MailVerteilerDetail
    Set oMailVerteiler = mcoMailVerteiler.FindItem(s)
    Set vwMailVerteiler.MailVerteiler = oMailVerteiler
    Set vwMailVerteiler.coMailVerteiler = mcoMailVerteiler
    
    i = vbNo
    While i = vbNo
      vwMailVerteiler.Show
      If vwMailVerteiler.ok Then
        Set oMailVerteiler = vwMailVerteiler.MailVerteiler
        If s = oMailVerteiler.Bezeichnung Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brauchen wir die Aenderungen nicht speichern
          i = vbYes
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoMailVerteiler.FindItem(oMailVerteiler.Bezeichnung) Is Nothing Then
            mcoMailVerteiler.Remove s
            mcoMailVerteiler.Add oMailVerteiler
            i = vbYes
          Else
            'Objekt kann nicht umbenannt werden
            Call MsgBox(GetResText(21186), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call MailVerteiler_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21185), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim vwMailVerteiler As V_MailVerteilerDetail
Dim lstItem   As ListItem
Dim oMailVerteiler  As C_MailVerteiler

Dim i As Integer
Dim s As String

  Set vwMailVerteiler = New V_MailVerteilerDetail
  Set vwMailVerteiler.coMailVerteiler = mcoMailVerteiler  ' fuer Gruppen
    
  i = vbNo
  While i = vbNo
    vwMailVerteiler.Show
    If vwMailVerteiler.ok Then
      Set oMailVerteiler = vwMailVerteiler.MailVerteiler
      If mcoMailVerteiler.FindItem(oMailVerteiler.Bezeichnung) Is Nothing Then
        mcoMailVerteiler.Add oMailVerteiler
        i = vbYes
      Else    ' Maileintrag schon vorhanden
        Call MsgBox(GetResText(21184), _
                    vbOKOnly + vbInformation, _
                    GetResText(20105))
      End If
    Else
      i = vbCancel
    End If
  Wend
  If i = vbYes Then
    Call MailVerteiler_Anzeigen
  End If


End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()

Dim Item As ListItem
Dim coMV As CO_MailVerteiler
Dim cMV As C_MailVerteiler
Dim sHelp As String

  If (mboIsGruppe) Then
    Set coMV = New CO_MailVerteiler
    For Each Item In lvwMailVerteiler.ListItems
      If Item.Selected Then
        sHelp = Item.SubItems(1)
        Set cMV = mcoMailVerteiler.FindItem(sHelp)
        Call coMV.Add(cMV)
      End If
    Next
    ' Set lstItem = lvwMailVerteiler.SelectedItem
  End If
  Set mcoMailVerteiler = coMV
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwMailVerteiler_DblClick()
  If (Not mboIsGruppe) Then
    Call btnEdit_Click
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False

  With lvwMailVerteiler
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .MultiSelect = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
    
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16016) '"Bezeichnung"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(17241) '"An"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(17242) '"Betreff"
    lstHeader.Width = 180
    .SortKey = 1
    .Sorted = True
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

Private Sub MailVerteiler_Anzeigen()

Dim oMailVerteiler  As C_MailVerteiler
Dim lstItem   As ListItem

  lvwMailVerteiler.ListItems.Clear
  For Each oMailVerteiler In mcoMailVerteiler.Items
    If (Not mboIsGruppe Or _
        (mboIsGruppe And Not oMailVerteiler.isMailGruppe)) Then ' keine Gruppen anbieten
      Set lstItem = lvwMailVerteiler.ListItems.Add
      lstItem.Text = oMailVerteiler.ID
      lstItem.SubItems(1) = oMailVerteiler.Bezeichnung
      lstItem.SubItems(2) = oMailVerteiler.An
      lstItem.SubItems(3) = oMailVerteiler.Betreff
    End If
  Next oMailVerteiler
  
  If lvwMailVerteiler.ListItems.Count > 0 Then
    lvwMailVerteiler.ListItems(1).Selected = True
  End If
End Sub

Attribute VB_Name = "V_MailAdrSucher"
Attribute VB_Base = "0{50824329-4683-47BA-888B-9126D456F8F8}{4C8D3156-B66A-451C-8A8C-1F109873D7F8}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_MailAdrSucher
'Oliver Seidel 07.05.2001
'
'===================================================================================================
Option Explicit

Private mboOK     As Boolean
Private moOutlook As Object   'Outlook.Application

'---------------------------------------------------------------------------------------------------
Public Property Get MailAdr() As String
  MailAdr = txtAdresse
End Property

Public Property Let MailAdr(sAdr As String)
  txtAdresse = sAdr
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbrechen_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboAdresse_Change()
  
Dim s As String
Dim oAddressList As Object 'Outlook.AddressList
Dim oAddressEntry As Object ' Outlook.AddressEntry
Dim arrAdressen() As String
Dim intCounter As Integer
  
  s = cboAdresse.Text
  If moOutlook Is Nothing Then Exit Sub
  On Error Resume Next
  
  Set oAddressList = moOutlook.Session.addresslists(s)
  For Each oAddressEntry In oAddressList.AddressEntries
      
    ReDim Preserve arrAdressen(1 To 2, intCounter)
    arrAdressen(1, intCounter) = oAddressEntry.Name
    arrAdressen(2, intCounter) = oAddressEntry.Address
    intCounter = intCounter + 1
   
  Next oAddressEntry
   
  lstAdressen.Clear
  If intCounter = 0 Then Exit Sub
  lstAdressen.Column = arrAdressen

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lstAdressen_DblClick(ByVal cancel As MSForms.ReturnBoolean)

Dim sAdresse As String
  If lstAdressen.ListIndex = -1 Then Exit Sub
  sAdresse = lstAdressen.List(lstAdressen.ListIndex, 1)
  
  If Len(txtAdresse) Then
    txtAdresse = txtAdresse & "; " & sAdresse
  Else
    txtAdresse = sAdresse
  End If
  txtAdresse.SelStart = Len(txtAdresse.Text)
  txtAdresse.SelLength = 0
  txtAdresse.SetFocus
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim oAddressList  As Object 'Outlook.AddressList
Dim oAddressEntry As Object ' Outlook.AddressEntry
Dim arrAdressen() As String
Dim intCounter    As Integer
   
  On Error GoTo Init_Fehler
  mboOK = False
  Call FormularBeschriften(Me)
  
  Set moOutlook = CreateObject("Outlook.Application")
  
  cboAdresse.Clear
  For Each oAddressList In moOutlook.Session.addresslists
    cboAdresse.AddItem oAddressList.Name
  Next oAddressList
  If cboAdresse.ListCount > 0 Then
    cboAdresse.ListIndex = 0
  End If
  
Exit Sub
Init_Fehler:

  MsgBox GetResText(21157), vbCritical + vbOKOnly, GetResText(20104) & " " & Err.Number
  btnOK.Enabled = False
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Terminate()
  Set moOutlook = Nothing
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

Attribute VB_Name = "V_MailSenden"
Attribute VB_Base = "0{F8F68393-CA68-40DA-9074-DD8767750903}{70D576E4-91C6-49BE-9B66-FF1100629E74}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_MailSenden
'Oliver Seidel 14.05.2001
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoMailVerteiler  As CO_MailVerteiler
Private mboOK As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set MailVerteiler(coMailVerteiler As CO_MailVerteiler)

Dim oMailVerteiler As C_MailVerteiler

  Set mcoMailVerteiler = coMailVerteiler
  
  cboMailVerteiler.Clear
  For Each oMailVerteiler In mcoMailVerteiler.Items
    cboMailVerteiler.AddItem oMailVerteiler.Bezeichnung
  Next oMailVerteiler
  
  If cboMailVerteiler.ListCount > 0 Then
    cboMailVerteiler.ListIndex = 0
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get MailVerteiler() As CO_MailVerteiler
  Set MailVerteiler = mcoMailVerteiler
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get MailTo() As C_MailVerteiler

  If cboMailVerteiler.ListIndex >= 0 Then
    Set MailTo = mcoMailVerteiler.Item(cboMailVerteiler.ListIndex + 1)
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  Call FormularBeschriften(Me)
  mboOK = False
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub


Attribute VB_Name = "V_MailVerteilerDetail"
Attribute VB_Base = "0{105FDC28-0779-4185-A991-94FD6386899F}{F7D0067B-D935-4D13-88FB-92249CDB7CFC}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_MailVerteilerDetail
'Oliver Seidel 03.05.2001
'
'
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moMailVerteiler As C_MailVerteiler
Private mcoMailVerteiler As CO_MailVerteiler
Private mboOK           As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set coMailVerteiler(coMailVerteiler As CO_MailVerteiler)
  Set mcoMailVerteiler = coMailVerteiler
End Property
'---------------------------------------------------------------------------------------------------
Public Property Set MailVerteiler(oMailVerteiler As C_MailVerteiler)
  Set moMailVerteiler = oMailVerteiler
  Call MailVerteilerAnzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get MailVerteiler() As C_MailVerteiler
  
  moMailVerteiler.Bezeichnung = txtBezeichnung.Text
  moMailVerteiler.An = txtAn.Text
  moMailVerteiler.Betreff = txtBereff.Text
  moMailVerteiler.isMailGruppe = chkMailGruppe.value
  
  Set MailVerteiler = moMailVerteiler
  
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAn_Click()
  
Dim vwAdrSucher As V_MailAdrSucher
Dim vwMailVerteiler As V_MAilVerteiler
Dim coMailVerteiler As CO_MailVerteiler
Dim mail As C_MailVerteiler

  If (chkMailGruppe.value = False) Then
    Set vwAdrSucher = New V_MailAdrSucher
    vwAdrSucher.MailAdr = txtAn.Text
    vwAdrSucher.Show
    If vwAdrSucher.ok Then
      txtAn.Text = vwAdrSucher.MailAdr
    End If
    
    Unload vwAdrSucher
    Set vwAdrSucher = Nothing
  Else
    Set vwMailVerteiler = New V_MAilVerteiler
    Let vwMailVerteiler.MailauswahlAlsGruppe = True
    Set vwMailVerteiler.MailVerteiler = mcoMailVerteiler
    
    vwMailVerteiler.Show
    
    If (vwMailVerteiler.ok) Then
      txtAn.Text = ""
      Set coMailVerteiler = vwMailVerteiler.MailVerteiler
      For Each mail In coMailVerteiler.Items
        If txtAn.TextLength > 0 Then txtAn.Text = txtAn.Text + ";"
        txtAn.Text = txtAn.Text + mail.Bezeichnung
      Next
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

  Call FormularBeschriften(Me)
  
  mboOK = False
  Set moMailVerteiler = New C_MailVerteiler
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub MailVerteilerAnzeigen()

  txtBezeichnung.Text = moMailVerteiler.Bezeichnung
  txtAn.Text = moMailVerteiler.An
  txtBereff.Text = moMailVerteiler.Betreff
  chkMailGruppe.value = moMailVerteiler.isMailGruppe
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean
  
Dim asAn()          As String
Dim index           As Integer
Dim oMailVerteiler  As C_MailVerteiler

  EingabenPruefen = True
  If chkMailGruppe.value Then   ' Gruppeneintr|fffd|ge nicht einfach so durchlassen!
    On Error Resume Next
    
    Call StrToArray(asAn, txtAn.Text, ";")
    For index = 1 To UBound(asAn)
      Set oMailVerteiler = mcoMailVerteiler.FindItem(asAn(index))
      If (oMailVerteiler Is Nothing) Then
        
        Call MsgBox(GetResText(21187), vbCritical + vbOKOnly, GetResText(20104))
        EingabenPruefen = False
        
        Exit For
      End If
    Next
    
    On Error GoTo 0
  End If
  
End Function

Attribute VB_Name = "V_Media"
Attribute VB_Base = "0{F8471024-24EB-4A0C-932B-6D4140222B0B}{410CC391-F8CC-49E6-99C9-DC58C1FE84BD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Media
'Wolfram Klebel 10.11.10
'
'Zeigt eine Liste der Medien zur Verwaltung
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoMedia  As CO_Media
Private mboOK As Boolean
Private mboChanged As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set Media(coMedia As CO_Media)
  Set mcoMedia = coMedia
  Call Media_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Media() As CO_Media
  Set Media = mcoMedia
End Property

''---------------------------------------------------------------------------------------------------
'' nur zum Durchschleifen der Strings fuer die Tarifset-Combobox
'Public Property Set Tariffset(coTariffset As CO_Tariffset)
'  Set mcoTariffset = coTariffset
'  'Call CostCenter_Anzeigen
'End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Dim rc As Integer
  rc = vbYes  ' default
  If (changed = True) Then
    rc = MsgBox(GetResText(22006), vbQuestion + vbYesNo, GetResText(20103))
  End If
  If (rc = vbYes) Then
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Property Get changed() As Boolean
  changed = mboChanged
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem     As ListItem
Dim coTariffset As CO_Tariffset
Dim oMedium     As C_Medium

  Set lstItem = lvwMedia.SelectedItem
  If Not lstItem Is Nothing Then
    ' check wether used by any tariffset
    Set oMedium = mcoMedia.FindItem(lstItem.Text)
    Set coTariffset = M_Tariffset.coFilterMediaId(oMedium.ID)
    If (coTariffset.Count > 0) Then
      Call MsgBox(GetResText(21198) & " " & coTariffset.Item(1).Name, vbCritical + vbOKOnly, GetResText(20104))
    Else
      mcoMedia.Remove lstItem.Text
      mboChanged = True
      ' Call M_Media.coSpeichern(mcoMedia)
      Call Media_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21191), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem       As ListItem
Dim vwMedium  As V_MediaDetail
Dim oMedium   As C_Medium

Dim i As Integer
Dim s As String

  Set lstItem = lvwMedia.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.Text
    Set vwMedium = New V_MediaDetail
    Set oMedium = mcoMedia.FindItem(s)
    Set vwMedium.Medium = oMedium
    
    i = vbNo
    While i = vbNo
      vwMedium.Show
      If vwMedium.ok Then
        Set oMedium = vwMedium.Medium
        If s = oMedium.Name Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          i = vbYes
          mboChanged = True
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoMedia.FindItem(oMedium.Name) Is Nothing Then
            mcoMedia.Remove s
            mcoMedia.Add oMedium
            mboChanged = True
            i = vbYes
          Else
            'Objekt bereits vorhanden
            Call MsgBox(GetResText(21192), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call Media_Anzeigen
    End If
  Else  '' xx TODO
    Call MsgBox(GetResText(21191), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim lstItem   As ListItem
Dim vwMedium  As V_MediaDetail
Dim oMedium   As C_Medium

Dim i As Integer
Dim s As String

  Set vwMedium = New V_MediaDetail
    
  i = vbNo
  While i = vbNo
    vwMedium.Show
    If vwMedium.ok Then
      Set oMedium = vwMedium.Medium
      If mcoMedia.FindItem(oMedium.Name) Is Nothing Then
        mcoMedia.Add oMedium
        mboChanged = True
        i = vbYes
      Else
        Call MsgBox(GetResText(21192), _
                    vbOKOnly + vbInformation, _
                    GetResText(20105))
      End If
    Else
      i = vbCancel
    End If
  Wend
  If i = vbYes Then
    ' Call M_Media.coSpeichern(mcoMedia)
    Call Media_Anzeigen
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwMedia_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False
  mboChanged = False

  With lvwMedia
    .View = lvwReport
    ' Set .SmallIcons = imglstStatus
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
    
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(17626) '"Bezeichnung"
    lstHeader.Width = 142
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(17627) '"Unit"
    lstHeader.Width = 142
    
    .SortKey = 0
    .Sorted = True
  End With
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Media_Anzeigen()

Dim oMedium  As C_Medium
Dim lstItem  As ListItem

  lvwMedia.ListItems.Clear
  If mcoMedia Is Nothing Then Exit Sub
  
  For Each oMedium In mcoMedia.Items
  
    Set lstItem = lvwMedia.ListItems.Add
    lstItem.Text = oMedium.Name
    lstItem.SubItems(1) = oMedium.unit
    
  Next oMedium
     
End Sub

Attribute VB_Name = "V_MediaDetail"
Attribute VB_Base = "0{E26B657A-8BF4-489B-89F7-05E387D2E454}{38F381D8-98B8-4181-9DCD-FBAFB8EC0C68}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_CostCenterDetail
'Wolfram Klebel 30.6.09
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moMedium  As C_Medium
Private mboOK         As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set Medium(md As C_Medium)

  Set moMedium = md
  Call MediumAnzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Medium() As C_Medium
  Dim ts As C_Tariffset
  
  moMedium.Name = txtBezeichnung.Text
  moMedium.unit = txtUnit.Text
  
  Set Medium = moMedium
  
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub


'Private Sub txtBezeichnung_Change()
'  txtBezeichnung.Value = Mid(txtBezeichnung.Value, 1, 50)
'End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

  Call FormularBeschriften(Me)
  mboOK = False
  Set moMedium = New C_Medium

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub MediumAnzeigen()

  txtBezeichnung.Text = moMedium.Name
  txtBezeichnung.Enabled = False ' IM 115373 BK 20110421 Bestehende Medien d|fffd|rfen nicht umbenannt werden
  txtUnit.Text = moMedium.unit
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean

  If txtBezeichnung.value = "" Or txtUnit.value = "" Then
    EingabenPruefen = False
  Else
    EingabenPruefen = True
  End If
  
End Function



Attribute VB_Name = "V_Optionen"
Attribute VB_Base = "0{20A82A60-4836-4A24-8087-106F2D02F0EA}{61A6FB2C-806B-4A35-9DC4-B7105838B681}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'V_Einstellungen
'
'Oliver Seidel
'28.10.98
'
'Verwaltet die Einstellungen zum Projekt.
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Private mcoOptionen   As CO_Optionen
Private mlLastItem    As Long
Private mdtSynchZeit  As Date
Private mboOK         As Boolean
Private mboDptHiddenChanged As Boolean
Private mboLoginChanged As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set Optionen(coOptionen As CO_Optionen)
  
Dim o As C_Optionen
Dim sHost As String

  Set mcoOptionen = coOptionen
  sHost = M_Tools.HostName
  
  cboHost.Clear
  For Each o In mcoOptionen.Items
    cboHost.AddItem o.host
    'Eigene Konfiguration zuerst anzeigen
    If o.host = sHost Then
      cboHost.ListIndex = cboHost.ListCount - 1
    End If
  Next o
  If cboHost.ListCount > 0 And cboHost.ListIndex = -1 Then
    cboHost.ListIndex = 0
  End If
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Optionen() As CO_Optionen
  Set Optionen = mcoOptionen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnComManConfig_Click()

Dim vDatei As Variant
  
  Call M_Tools.LaufwertWechsel(M_Tools.getPath(txtComManConfig))
  vDatei = Application.GetOpenFilename
  If Not IsNumeric(vDatei) Then
    If Len(vDatei) > 0 Then
      'Falls die Datei keine Dateierweiterung besitzt, muss der
      'letzte Punkt eventuell geloescht werden - warum auch immer...
      If Right(vDatei, 1) = "." Then vDatei = Left(vDatei, Len(vDatei) - 1)
      txtComManConfig = vDatei
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnHostZeitplan_Click()
  txtHostZeitplan = M_Tools.HostName
End Sub

Private Sub btnHTMPath_Click()

Dim sDatei  As String

  sDatei = GetDirectory(GetResText(21208))
  If Len(sDatei) > 0 Then
    txtHTMPath = sDatei
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  Dim asDpTyp() As String
  Dim i         As Integer
  
  mboOK = True
  If mlLastItem > 0 Then
    Call Optionen_Lesen(mcoOptionen.Item(mlLastItem))
          
    With mcoOptionen.Item(mlLastItem)
      If (.LoginActive = False And mboLoginChanged = True) Then
        Call M_PVSSLogin.ResetPasswordSession
      End If
      If (.AutoLogout > 0) Then
        Call M_Optionen.AutoLogoutInit
      Else
        Call M_Optionen.AutoLogoutReset
      End If
    End With
      
  End If
  
  ' IM 101311 WOKL 14.12.10: DP Filter
  If (mboDptHiddenChanged = True) Then
    ReDim asDpTyp(lvwFilteredDpt.ListItems.Count)
    For i = 1 To lvwFilteredDpt.ListItems.Count
      asDpTyp(i) = lvwFilteredDpt.ListItems(i).Text
    Next i
    
    Call setDPTypHidden("", asDpTyp())
  End If
  
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbrechen_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnSynchZeit_Click()

Dim vSynchZeit As Variant
  On Error Resume Next
  Call M_PVSS.dpGet("_Config.StartHour:_online.._value", vSynchZeit)
  If Err Then
    Call MsgBox(Err.Description, vbCritical + vbOKOnly, "Fehler " & Err.Number)
  Else
    If IsNumeric(vSynchZeit) Then
      dtpSynchZeit = TimeSerial(vSynchZeit, 0, 0)
      mdtSynchZeit = TimeSerial(vSynchZeit, 0, 0)
    End If
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnThisHost_Click()

Dim o As C_Optionen
Dim sHost As String
Dim i As Integer

  sHost = M_Tools.HostName
  For i = 0 To cboHost.ListCount - 1
    If cboHost.List(i) = sHost Then
      cboHost.ListIndex = i
      Exit Sub
    End If
  Next i
  
  Set o = New C_Optionen
  o.host = sHost
  Call Optionen_Lesen(o)
  mcoOptionen.Add o
  
  cboHost.AddItem sHost
  cboHost.ListIndex = cboHost.ListCount - 1

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim o As C_Optionen
Dim sHost As String
Dim i As Integer

  sHost = InputBox(GetResText(21141), GetResText(21209))
  If Len(sHost) = 0 Then Exit Sub
  
  For i = 0 To cboHost.ListCount - 1
    If UCase(cboHost.List(i)) = UCase(sHost) Then
      cboHost.ListIndex = i
      Exit Sub
    End If
  Next i
  
  Set o = New C_Optionen
  o.host = UCase(sHost)
  Call Optionen_Lesen(o)
  mcoOptionen.Add o
  
  cboHost.AddItem UCase(sHost)
  cboHost.ListIndex = cboHost.ListCount - 1

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()
  If cboHost.Text <> DEFAULT_CONFIG Then
    mcoOptionen.Remove cboHost.Text
    
    mlLastItem = 0
    cboHost.RemoveItem cboHost.ListIndex
    If cboHost.ListCount > 0 Then
      cboHost.ListIndex = 0
    End If
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboHost_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboHost_Change()
  
  Call BugAssert(mlLastItem <= mcoOptionen.Count, _
                 "Index ausserhalb der Grenzen!", _
                 "V_Optionen::cboHost_Change")
  If mlLastItem > 0 Then
    Call Optionen_Lesen(mcoOptionen.Item(mlLastItem))
  End If
  
  mlLastItem = cboHost.ListIndex + 1
  If mlLastItem < 1 Then mlLastItem = 1
  Call BugAssert(mlLastItem <= mcoOptionen.Count, _
                 "Index ausserhalb der Grenzen!", _
                 "V_Optionen::cboHost_Change")
  Call Optionen_Anzeigen(mcoOptionen.Item(mlLastItem))
  btnDelete.Enabled = CBool(cboHost.Text <> DEFAULT_CONFIG)
  txtComManConfig.Enabled = CBool(cboHost.Text <> DEFAULT_CONFIG)
  btnComManConfig.Enabled = CBool(cboHost.Text <> DEFAULT_CONFIG)

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboSprache_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
' IM 98626 WOKL: neu
Private Sub chkAutoLogoutFlag_Click()
  txtAutoLogout.Visible = chkAutoLogoutFlag.value
  lblMinuten.Visible = chkAutoLogoutFlag.value
End Sub

Private Sub chkLoginActiveFlag_Click()
  mboLoginChanged = True
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub dtpSynchZeit_Change()
  mdtSynchZeit = dtpSynchZeit.value
End Sub

Private Sub ChangeLvwDptItems(l1 As ListItems, l2 As ListItems, index As Integer)
  Dim sHelp As String
  Dim i As Integer
  
  mboDptHiddenChanged = True
  If index > 0 Then
    Call l2.Add(, , l1.Item(index).Text)
    l1.Remove (index)
  Else
    For i = 1 To l1.Count
      Call l2.Add(, , l1.Item(i).Text)
    Next i
    l1.Clear
  End If
    
End Sub
Private Sub lvwAllDpt_DblClick()
  If Not lvwAllDpt.SelectedItem Is Nothing Then
    Call ChangeLvwDptItems(lvwAllDpt.ListItems, lvwFilteredDpt.ListItems, lvwAllDpt.SelectedItem.index)
  End If
End Sub

Private Sub lvwFilteredDpt_DblClick()
  If Not lvwFilteredDpt.SelectedItem Is Nothing Then
    Call ChangeLvwDptItems(lvwFilteredDpt.ListItems, lvwAllDpt.ListItems, lvwFilteredDpt.SelectedItem.index)
  End If
End Sub
Private Sub btnDptAllRight_Click()
  Call ChangeLvwDptItems(lvwFilteredDpt.ListItems, lvwAllDpt.ListItems, -1)
End Sub
Private Sub btnDptAllLeft_Click()
 Call ChangeLvwDptItems(lvwAllDpt.ListItems, lvwFilteredDpt.ListItems, -1)
End Sub

Private Sub btnDptLeft_Click()
  Call lvwAllDpt_DblClick
End Sub

Private Sub btnDptRight_Click()
  Call lvwFilteredDpt_DblClick
End Sub


'---------------------------------------------------------------------------------------------------
Private Sub MultiPage1_Change()
  If MultiPage1.value = 0 Then
    dtpSynchZeit.value = mdtSynchZeit
  End If
  Me.Repaint  ' IM 104130 WOKL 11.3.11

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtAutoLogout_Change()
Static oldValue As String
Dim iHelp As Integer
  
  On Error Resume Next
  iHelp = CInt(oldValue)
  iHelp = CInt(txtAutoLogout.value) ' vielleicht, - oder auch nicht
  If (iHelp > 720) Then iHelp = 720
  txtAutoLogout.value = CStr(iHelp)
  oldValue = txtAutoLogout.value
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtHostZeitplan_Change()

Dim o As C_Optionen

  For Each o In mcoOptionen.Items
    o.HostZeitplan = txtHostZeitplan
  Next o

End Sub

Private Sub InitListViews(ByRef lv As ListView)
  Dim lstHeader As ColumnHeader
  With lv
    .View = lvwReport
    .Gridlines = False
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = True
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
    
    Set lstHeader = .ColumnHeaders.Add
    ' lstHeader.Text = "Test ABC"
    lstHeader.Width = 110
    
    .HideSelection = False
    .Sorted = True
    .SortKey = 0
  End With
End Sub
  
'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim asSprache() As String
Dim n As Long

  Call FormularBeschriften(Me)
  MultiPage1.Pages("pageAllgemein").Caption = GetResText(17071)
  MultiPage1.Pages("pageComManager").Caption = GetResText(17085)
  MultiPage1.Pages("pageDpFilter").Caption = GetResText(17099)
  
  Call M_Optionen.getSprachen(asSprache)
  cboSprache.Clear
  cboSprache.AddItem DEFAULT_CONFIG
  For n = 1 To UBound(asSprache)
    cboSprache.AddItem asSprache(n)
  Next n
  
  MultiPage1.value = 0
  dtpSynchZeit.Format = dtpTime
  dtpSynchZeit.value = CDate("00:00:00")
  mboLoginChanged = False
  
  MultiPage1.value = 3
  Call InitListViews(lvwAllDpt)
  Call InitListViews(lvwFilteredDpt)
  mboDptHiddenChanged = False

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Optionen_Anzeigen(oOptionen As C_Optionen)
  Dim asDpt() As String
  Dim asFilteredDpt() As String
  Dim i As Integer
  
  If oOptionen Is Nothing Then Exit Sub
  
  With oOptionen
  
    txtHostZeitplan = .HostZeitplan
    txtUserPwd = .UserPwd
    txtComManConfig = .ComManConfig
    txtComManPara = .ComManPara
    chkLoginActiveFlag = .LoginActive
    
    cboSprache.ListIndex = .SpracheID
    
    mdtSynchZeit = .SynchZeit
    'Direkte zuweisung geht nicht wenn das Control
    'auf der versteckten Registerkarte liegt!
    If MultiPage1.value = 0 Then
      dtpSynchZeit.value = .SynchZeit
    End If
    
    txtHTMPath = .HTMLPfad
    
    If .host = HostName() Then
      chkDebugMsgFlag.Enabled = True
      chkDebugMsgFlag.value = getDebugMsgFlag
      chkErrorMsgFlag.Enabled = True
      chkErrorMsgFlag.value = getErrorMsgFlag
    Else
      chkDebugMsgFlag.Enabled = False
      chkDebugMsgFlag.value = False
      chkErrorMsgFlag.Enabled = False
      chkErrorMsgFlag.value = False
    End If
    chkAutoLogoutFlag.value = (.AutoLogout > 0)
    txtAutoLogout.Visible = (.AutoLogout > 0)
    lblMinuten.Visible = (.AutoLogout > 0)
    txtAutoLogout.value = CStr(.AutoLogout)
    
    ' Extend-Flag and DPT Filter
    cboFctExtend.value = .DpInsExtend
    
  End With
  
  Call lvwAllDpt.ListItems.Clear  ' IM 104130 WOKL
  Call M_DB.getDPTyps("*", asDpt, 1)
  For i = 1 To UBound(asDpt)
    Call lvwAllDpt.ListItems.Add(, , asDpt(i))
  Next i
  lvwFilteredDpt.ListItems.Clear   ' IM 104130 WOKL
  Call M_DB.getDPTyps("*", asFilteredDpt, 2)
  For i = 1 To UBound(asFilteredDpt)
    Call lvwFilteredDpt.ListItems.Add(, , asFilteredDpt(i))
  Next i
  MultiPage1.value = 0

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Optionen_Lesen(oOptionen As C_Optionen)

  If oOptionen Is Nothing Then Exit Sub
  
  With oOptionen
  
    .HostZeitplan = txtHostZeitplan
    .UserPwd = txtUserPwd
    .ComManConfig = txtComManConfig
    .ComManPara = txtComManPara
    .LoginActive = chkLoginActiveFlag
    If (chkAutoLogoutFlag.value) Then
      On Error Resume Next
      .AutoLogout = CInt(txtAutoLogout.value)
    Else
      .AutoLogout = 0
    End If
    
    If cboSprache.ListIndex = -1 Then
      .SpracheID = 0
    Else
      .SpracheID = cboSprache.ListIndex
    End If
    
    .SynchZeit = mdtSynchZeit
    .HTMLPfad = txtHTMPath
    
    ' Extend-Flag and DPT Filter
    .DpInsExtend = cboFctExtend.value
    
    ' Aktivitaeten f|fffd|r den aktuellen Host
    If .host = HostName() Then
      Call setDebugMsgFlag(chkDebugMsgFlag.value)
      Call setErrorMsgFlag(chkErrorMsgFlag.value)
    End If
    
  End With

End Sub

Attribute VB_Name = "V_ProtAktualisieren"
Attribute VB_Base = "0{4DB736EC-E208-497C-B3DF-03CBC89AC3D7}{865C26D7-5003-4BC6-A51F-4060C27C749A}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'V_ProtAktualisieren
'
'Marc Haslop
'04.09.00
'
'
'Aenderungen: -keine-
'==================================================================================================

Option Explicit
Private miBefehl As Integer

'--------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  Call FormularBeschriften(Me)
End Sub

'--------------------------------------------------------------------------------------------------
Public Property Get Befehl() As Integer
  Befehl = miBefehl
End Property

'--------------------------------------------------------------------------------------------------
Private Sub btnAbbrechen_Click()
  miBefehl = 0
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnOeffnen_Click()
  miBefehl = 1
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()
  miBefehl = 2
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnAktualisieren_Click()
  miBefehl = 3
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub
Attribute VB_Name = "V_ProtFormat"
Attribute VB_Base = "0{C0E86F3F-2BA3-47C3-846A-7EE8EE5B8C06}{23229CAB-D117-4B44-AB4C-336B259254E5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'V_ProtFormat
'Oliver Seidel, 27.02.2002
'
'Auswahl eines Protokollformats (war V_ProtFormat)
'==================================================================================================
Option Explicit

Private mboOK As Boolean

'--------------------------------------------------------------------------------------------------
Public Property Let ProtFormat(sProtFormat As String)

Dim i As Integer

  For i = 0 To cboFormat.ListCount - 1
    If sProtFormat = CProtFormatToConst(cboFormat.List(i)) Then
      cboFormat.ListIndex = i
    End If
  Next i
  
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get ProtFormat() As String

  If mboOK Then
    ProtFormat = CProtFormatToConst(cboFormat.Text)
  Else
    ProtFormat = ""
  End If
  
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'--------------------------------------------------------------------------------------------------
Public Sub ProtFormate(asProtFormate() As String)

Dim i As Integer

  cboFormat.Clear
  For i = 1 To UBound(asProtFormate)
    cboFormat.AddItem CProtFormatToText(asProtFormate(i))
  Next i
  
  If cboFormat.ListIndex = -1 And cboFormat.ListCount > 0 Then
    cboFormat.ListIndex = 0
  End If
  
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboFormat_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  Call FormularBeschriften(Me)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

Attribute VB_Name = "V_ProtTyp"
Attribute VB_Base = "0{3C4A3D4C-A719-4B39-BA4E-1B5828CDDD0C}{6ED19517-FD68-4C2D-8816-7AEFFB7D7AFE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_ProtTyp
'Oliver Seidel 14.07.2000
'
'
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoProtTyp  As CO_ProtokollTyp
Private mboOK As Boolean
Private mboChanged As Boolean

Public Property Set ProtTyp(coProtTyp As CO_ProtokollTyp)

  Set mcoProtTyp = coProtTyp
  Call ProtTyp_Anzeigen
  If lvwProtTyp.ListItems.Count > 0 Then
    lvwProtTyp.ListItems(1).Selected = True
  End If
  
End Property

Public Property Get ProtTyp() As CO_ProtokollTyp
  Set ProtTyp = mcoProtTyp
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get changed() As Boolean
  changed = mboChanged
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Dim rc As Integer
  rc = vbYes  ' default
  If (changed = True) Then
    rc = MsgBox(GetResText(22006), vbQuestion + vbYesNo, GetResText(20103))
  End If
  If (rc = vbYes) Then
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem As ListItem
Dim oProtTyp As C_ProtokollTyp

  Set lstItem = lvwProtTyp.SelectedItem
  If Not lstItem Is Nothing Then
    
    'Set oProtTyp = mcoProtTyp.FindItem(lstItem.ListSubItems(1).Text)
    'oProtTyp.ObjektStatus = OBJEKT_STATUS_GELOESCHT
    mcoProtTyp.Remove lstItem.ListSubItems(1).Text
    mboChanged = True
    Call ProtTyp_Anzeigen
  
  Else
    Call MsgBox(GetResText(21142), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem   As ListItem
Dim vwProtTyp As V_ProtTypDetail
Dim oProtTyp  As C_ProtokollTyp

Dim i As Integer
Dim s As String

  Set lstItem = lvwProtTyp.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.ListSubItems(1).Text
    Set vwProtTyp = New V_ProtTypDetail
    Set oProtTyp = mcoProtTyp.FindItem(s)
    Set vwProtTyp.ProtTyp = oProtTyp
    
    i = vbNo
    While i = vbNo
      vwProtTyp.Show
      If vwProtTyp.ok Then
        Set oProtTyp = vwProtTyp.ProtTyp
        If s = oProtTyp.Bezeichnung Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          mboChanged = True
          i = vbYes
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoProtTyp.FindItem(oProtTyp.Bezeichnung) Is Nothing Then
            mcoProtTyp.Remove s
            mcoProtTyp.Add oProtTyp
            mboChanged = True
            i = vbYes
          Else
            'Objekt kann nicht umbenannt werden
            Call MsgBox(GetResText(21143), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call ProtTyp_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21142), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim vwProtTyp As V_ProtTypDetail
Dim lstItem   As ListItem
Dim oProtTyp  As C_ProtokollTyp

Dim i As Integer
Dim s As String

  Set vwProtTyp = New V_ProtTypDetail
    
  i = vbNo
  While i = vbNo
    vwProtTyp.Show
    If vwProtTyp.ok Then
      Set oProtTyp = vwProtTyp.ProtTyp
      If mcoProtTyp.FindItem(oProtTyp.Bezeichnung) Is Nothing Then
        mcoProtTyp.Add oProtTyp
        mboChanged = True
        i = vbYes
      Else
        Call MsgBox(GetResText(21143), _
                    vbOKOnly + vbInformation, _
                    GetResText(20105))
      End If
    Else
      i = vbCancel
    End If
  Wend
  If i = vbYes Then
    Call ProtTyp_Anzeigen
  End If


End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwProtTyp_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False
  mboChanged = False

  With lvwProtTyp
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
   
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16016) '"Bezeichnung"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16017) '"Daten"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16018) '"Ergebnis"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16019) '"Periode"
    lstHeader.Width = 50
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16011) '"Intervall"
    lstHeader.Width = 50
    .SortKey = 1
    .Sorted = True
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

Private Sub ProtTyp_Anzeigen()

Dim oProtTyp  As C_ProtokollTyp
Dim lstItem   As ListItem

  lvwProtTyp.ListItems.Clear
  For Each oProtTyp In mcoProtTyp.Items
    'If oProtTyp.ObjektStatus <> OBJEKT_STATUS_GELOESCHT Then
      Set lstItem = lvwProtTyp.ListItems.Add
      lstItem.Text = oProtTyp.ID
      lstItem.SubItems(1) = oProtTyp.Bezeichnung
      If Not oProtTyp.BasiswertDaten Is Nothing Then
        lstItem.SubItems(2) = oProtTyp.BasiswertDaten.Bezeichnung
      End If
      If Not oProtTyp.BasiswertErgebnis Is Nothing Then
        lstItem.SubItems(3) = oProtTyp.BasiswertErgebnis.Bezeichnung
      End If
      If oProtTyp.PerEinheit > 0 Then
        lstItem.SubItems(4) = oProtTyp.Periode & " " & GetResText(TXT_ZEIT_EINHEIT_BEGINN + oProtTyp.PerEinheit)
      End If
      If oProtTyp.Intervall > 0 Then
        lstItem.SubItems(5) = oProtTyp.Intervall & " " & GetResText(TXT_ZEIT_EINHEIT_BEGINN + oProtTyp.IntEinheit)
      End If
    'End If
  Next oProtTyp
End Sub

Attribute VB_Name = "V_ProtTypDetail"
Attribute VB_Base = "0{00E25AA5-636D-49FA-9F3E-8F540B9B7473}{39D65914-2A53-4D66-836E-4968F8881396}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'===================================================================================================
'V_ProtTypDetail
'Oliver Seidel 14.07.2000
'
'===================================================================================================
Option Explicit

Private mboOK         As Boolean
Private moProtTyp     As C_ProtokollTyp
Private mcoBasiswert  As CO_Basiswert

'---------------------------------------------------------------------------------------------------
Public Property Set ProtTyp(oProtTyp As C_ProtokollTyp)
  
  Set moProtTyp = oProtTyp
  Call ProtTypAnzeigen
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ProtTyp() As C_ProtokollTyp
  Set ProtTyp = moProtTyp
End Property

'---------------------------------------------------------------------------------------------------
'Eleminiert alle ungueltigen Zeichen fuer Verzeichnisse
'Anfuehrungszeichen ("), Apostroph ('), Schraegstrich (/), umgekehrter Schraegstrich (\),
'Doppelpunkt (:) und vertikale Linie (|) sowie Wildcards (*), (?)
Private Sub txtProtTyp_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  'Debug.Print KeyCode
  Select Case KeyCode
    Case 191, 221, 111, 219, 190, 226, 106, 187, 219
      KeyCode = 0
      Shift = 0
    Case 50, 55
      If (Shift = 1) Then ' 1=fmShiftMask
        KeyCode = 0
        Shift = 0
      End If
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboBasisDaten_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboBasisDaten_Change()
  
Dim oBasiswert  As C_Basiswert
Dim lIntervall  As Long
Dim lAnz        As Long
Dim iEinheit    As Integer

  Set oBasiswert = mcoBasiswert.FindItem(cboBasisDaten.Text)
  If Not oBasiswert Is Nothing Then
    Set moProtTyp.BasiswertDaten = oBasiswert
        
    If oBasiswert.IntEinheit > 0 Then
      spnIntervallAnz = oBasiswert.Intervall
      cboIntervallEinheit.ListIndex = oBasiswert.IntEinheit - 1
    End If
    
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboBasisErgebnis_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboBasisErgebnis_Change()

Dim oBasiswert  As C_Basiswert
Dim lIntervall  As Long
Dim lAnz        As Long
Dim iEinheit    As Integer

  Set oBasiswert = mcoBasiswert.FindItem(cboBasisErgebnis.Text)
  If Not oBasiswert Is Nothing Then
    Set moProtTyp.BasiswertErgebnis = oBasiswert
        
    If oBasiswert.IntEinheit > 0 Then
      spnPeriodeAnz = oBasiswert.Intervall
      cboPeriodeEinheit.ListIndex = oBasiswert.IntEinheit - 1
    End If
    
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  
  If EingabenPruefen Then
    mboOK = True
    
    With moProtTyp
      .Bezeichnung = txtProtTyp
      Set .BasiswertDaten = mcoBasiswert.FindItem(cboBasisDaten.Text)
      Set .BasiswertErgebnis = mcoBasiswert.FindItem(cboBasisErgebnis.Text)
      .Periode = spnPeriodeAnz.value
      .PerEinheit = cboPeriodeEinheit.ListIndex + 1
      .Intervall = spnIntervallAnz.value
      If chkBonusIntervall Then
        .BonusIntervall = True
      Else
        .BonusIntervall = False
      End If
      
      .IntEinheit = cboIntervallEinheit.ListIndex + 1
      .SynchZeit = dtpSynchZeit.value
      If chkSynchWochenTag Then
        .SynchWochenTag = cboSynchWochenTag.ListIndex + 1
      Else
        .SynchWochenTag = 0
      End If
      If chkSynchMonatsTag Then
        .SynchTag = txtSynchMonatsTag
      Else
        .SynchTag = 0
      End If
      If chkSynchMonat Then
        .SynchMonat = txtSynchMonat
      Else
        .SynchMonat = 0
      End If
    
    End With
    
    Me.Hide
  
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboIntervallEinheit_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboPeriodeEinheit_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub


'---------------------------------------------------------------------------------------------------
Private Sub cboSynchWochenTag_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub spnPeriodeAnz_Change()
  If txtPeriodeAnz <> spnPeriodeAnz.value Then
    txtPeriodeAnz = spnPeriodeAnz.value
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtPeriodeAnz_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)
  
  If IsNumeric(txtPeriodeAnz.Text) Then
    spnPeriodeAnz.value = CLng(txtPeriodeAnz.Text)
  Else
    cancel = True
    txtPeriodeAnz.Text = spnPeriodeAnz.value
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub spnIntervallAnz_Change()
  If txtIntervallAnz <> spnIntervallAnz.value Then
    txtIntervallAnz = spnIntervallAnz.value
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtIntervallAnz_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)
  
  If IsNumeric(txtIntervallAnz.Text) Then
    spnIntervallAnz.value = CLng(txtIntervallAnz.Text)
  Else
    cancel = True
    txtIntervallAnz.Text = spnIntervallAnz.value
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub spnSynchMonatstag_Change()
  If txtSynchMonatsTag <> spnSynchMonatsTag.value Then
    txtSynchMonatsTag = spnSynchMonatsTag.value
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtSynchMonatstag_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)
  
  If IsNumeric(txtSynchMonatsTag.Text) Then
    spnSynchMonatsTag.value = CLng(txtSynchMonatsTag.Text)
  Else
    cancel = True
    txtSynchMonatsTag.Text = spnSynchMonatsTag.value
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub spnSynchMonat_Change()
  If txtSynchMonat <> spnSynchMonat.value Then
    txtSynchMonat = spnSynchMonat.value
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtSynchMonat_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)
  
  If IsNumeric(txtSynchMonat.Text) Then
    spnSynchMonat.value = CLng(txtSynchMonat.Text)
  Else
    cancel = True
    txtSynchMonat.Text = spnSynchMonat.value
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim oBasiswert  As C_Basiswert
Dim i           As Integer
  
  Call FormularBeschriften(Me)
  
  mboOK = False
  dtpSynchZeit = getOpt.SynchZeit
  
  For i = 1 To TXT_ZEIT_EINHEIT_ANZ
    cboIntervallEinheit.AddItem GetResText(TXT_ZEIT_EINHEIT_BEGINN + i)
    cboPeriodeEinheit.AddItem GetResText(TXT_ZEIT_EINHEIT_BEGINN + i)
  Next i
  For i = 1 To 7
    cboSynchWochenTag.AddItem GetResText(TXT_WOCHENTAG_BEGINN + i)
  Next i

  Set moProtTyp = New C_ProtokollTyp
  
  Set mcoBasiswert = M_Basiswert.coLesen
  For Each oBasiswert In mcoBasiswert.Items
    cboBasisDaten.AddItem oBasiswert.Bezeichnung
    cboBasisErgebnis.AddItem oBasiswert.Bezeichnung
  Next oBasiswert
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub ProtTypAnzeigen()

  With moProtTyp
  
    txtProtTyp = .Bezeichnung
    'txtProtTyp.Enabled = False
    
    If Not .BasiswertDaten Is Nothing Then
      cboBasisDaten.Text = .BasiswertDaten.Bezeichnung
    End If
    If Not .BasiswertErgebnis Is Nothing Then
      cboBasisErgebnis = .BasiswertErgebnis.Bezeichnung
    End If
    If .Periode > 0 Then
      spnPeriodeAnz = .Periode
    End If
    txtPeriodeAnz = .Periode
    cboPeriodeEinheit = GetResText(TXT_ZEIT_EINHEIT_BEGINN + .PerEinheit)
    If .Intervall > 0 Then
      spnIntervallAnz = .Intervall
    End If
    If .BonusIntervall Then
      chkBonusIntervall = True
    Else
      chkBonusIntervall = False
    End If
    txtIntervallAnz = .Intervall
    cboIntervallEinheit = GetResText(TXT_ZEIT_EINHEIT_BEGINN + .IntEinheit)
    
    dtpSynchZeit = .SynchZeit
    If .SynchWochenTag > 0 Then
      chkSynchWochenTag.value = True
      cboSynchWochenTag.Text = GetResText(TXT_WOCHENTAG_BEGINN + .SynchWochenTag)
    Else
      chkSynchWochenTag = False
      cboSynchWochenTag.Text = ""
    End If
    If .SynchTag > 0 Then
      chkSynchMonatsTag = True
      spnSynchMonatsTag = .SynchTag
      txtSynchMonatsTag = .SynchTag
    Else
      chkSynchMonatsTag = False
      spnSynchMonatsTag = 1
      txtSynchMonatsTag = 1
    End If
    If .SynchMonat > 0 Then
      chkSynchMonat = True
      spnSynchMonat = .SynchMonat
      txtSynchMonat = .SynchMonat
    Else
      chkSynchMonat = False
      spnSynchMonat = 1
      txtSynchMonat = 1
    End If
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean
  
  EingabenPruefen = False
  If Len(txtProtTyp.Text) = 0 Then
    Call MsgBox(lblProtTyp.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    txtProtTyp.SetFocus
    Exit Function
  End If
  
  If cboPeriodeEinheit.ListIndex = -1 Then
    Call MsgBox(lblPeriode.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    cboPeriodeEinheit.SetFocus
    Exit Function
  End If
  
  If cboIntervallEinheit.ListIndex = -1 Then
    Call MsgBox(lblIntervall.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    cboIntervallEinheit.SetFocus
    Exit Function
  End If
  
  If IntervallWithUnitToSec(spnPeriodeAnz, cboPeriodeEinheit.ListIndex + 1) <= _
     IntervallWithUnitToSec(spnIntervallAnz, cboIntervallEinheit.ListIndex + 1) Then
    Call MsgBox(GetResText(21149), vbCritical + vbOKOnly, GetResText(20104))
    Exit Function
  End If
  
  EingabenPruefen = True
  
End Function

'---------------------------------------------------------------------------------------------------
Private Sub btnTst_Click()

Dim vwZeitbereich As V_ProtZeitbereich
Dim oProtTyp      As C_ProtokollTyp
Dim coProtTyp     As CO_ProtokollTyp

  Set oProtTyp = New C_ProtokollTyp
  With oProtTyp
    .Bezeichnung = txtProtTyp
    Set .BasiswertDaten = mcoBasiswert.FindItem(cboBasisDaten.Text)
    Set .BasiswertErgebnis = mcoBasiswert.FindItem(cboBasisErgebnis.Text)
    .Periode = spnPeriodeAnz.value
    .PerEinheit = cboPeriodeEinheit.ListIndex + 1
    .Intervall = spnIntervallAnz.value
    .BonusIntervall = chkBonusIntervall.value
    .IntEinheit = cboIntervallEinheit.ListIndex + 1
    .SynchZeit = dtpSynchZeit.value
    If chkSynchWochenTag Then
      .SynchWochenTag = cboSynchWochenTag.ListIndex + 1
    Else
      .SynchWochenTag = 0
    End If
    If chkSynchMonatsTag Then
      .SynchTag = txtSynchMonatsTag
    Else
      .SynchTag = 0
    End If
    If chkSynchMonat Then
      .SynchMonat = txtSynchMonat
    Else
      .SynchMonat = 0
    End If
  
  End With
  
  Set coProtTyp = New CO_ProtokollTyp
  coProtTyp.Add oProtTyp
  
  Set vwZeitbereich = New V_ProtZeitbereich
  vwZeitbereich.setProtTypen coProtTyp

  vwZeitbereich.Show
  
  Unload vwZeitbereich
  Set vwZeitbereich = Nothing

End Sub


Attribute VB_Name = "V_ProtZeitbereich"
Attribute VB_Base = "0{91496522-9EC0-48DF-869A-B5B5693451D0}{059D4482-61C8-46A2-A550-08979269ED81}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'==================================================================================================
'V_ProtZeitBereich
'
'Oliver Seidel
'10.11.98
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit

Private mcoProtTypen As CO_ProtokollTyp
Private miModus As Integer
Private mboOK   As Boolean
Private miZeitbereich As Integer
Private mdtDemoZeitbereich As Date

'--------------------------------------------------------------------------------------------------
Public Property Let Zeitbereich(iZeitbereich As Integer)
  miZeitbereich = iZeitbereich
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get Von() As Date
  Von = CDate(dtpVonDatum + dtpVonZeit)
End Property

'--------------------------------------------------------------------------------------------------
Public Property Let Von(dtVon As Date)

Dim dtBis As Date

  dtpVonDatum = Format(dtVon, "Short Date")
  dtpVonZeit = Format(dtVon, "Long Time")
  
  mcoProtTypen.Item(cboProtTyp.ListIndex + 1).Zeitbereich dtVon, dtBis, , miZeitbereich
  Me.Bis = dtBis
  
  If miModus = 2 Then
    dtpBisDatum = dtpVonDatum
    dtpBisZeit = dtpVonZeit
  End If
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get Bis() As Date
  Bis = CDate(dtpBisDatum + dtpBisZeit)
End Property

'--------------------------------------------------------------------------------------------------
Public Property Let Bis(dtBis As Date)
  If miModus <> 2 Then
    dtpBisDatum = Format(dtBis, "Short Date")
    dtpBisZeit = Format(dtBis, "Long Time")
  End If
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'--------------------------------------------------------------------------------------------------
Public Property Get ProtTyp() As String
  ProtTyp = cboProtTyp.Text
End Property

'--------------------------------------------------------------------------------------------------
Public Sub setProtTypen(coProtTypen As CO_ProtokollTyp)
  
Dim iProtTyp As Integer

  Set mcoProtTypen = coProtTypen
  cboProtTyp.Clear
  For iProtTyp = 1 To mcoProtTypen.Count
    cboProtTyp.AddItem mcoProtTypen.Item(iProtTyp).Bezeichnung
  Next iProtTyp
  
  If cboProtTyp.ListCount > 0 Then
    cboProtTyp.ListIndex = 0
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAb_Click()

Dim dtVon As Date
Dim dtBis As Date
Dim dtSynch As Date

  dtVon = 0 'Me.Von
  With mcoProtTypen.Item(cboProtTyp.ListIndex + 1)
  
    dtSynch = DateAdd(getIntFormatStr(.PerEinheit), .Periode * -1, Me.Von)
    'mcoProtTypen.Item(cboProtTyp.ListIndex + 1).Zeitbereich dtVon, dtBis
    mcoProtTypen.Item(cboProtTyp.ListIndex + 1).Zeitbereich dtVon, dtBis, iZeitbereich:=1, dtSynchFrom:=dtSynch
    'Das ist nicht sch|fffd|n, aber im Zeitbereich vom ProtTyp bekomme ich es einfach nicht hin.
    If DateDiff("s", Me.Von, dtVon) = 0 Then
      If .PerEinheit <= erTag Then
        dtVon = DateAdd(getIntFormatStr(.PerEinheit), .Periode * -1, Me.Von)
      End If
    End If
    Me.Von = dtVon
    
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAuf_Click()

Dim dtVon As Date
Dim dtBis As Date
Dim dtSynch As Date

  dtVon = 0 'Me.Von
  With mcoProtTypen.Item(cboProtTyp.ListIndex + 1)
  
    dtSynch = DateAdd(getIntFormatStr(.PerEinheit), .Periode, Me.Von)
    mcoProtTypen.Item(cboProtTyp.ListIndex + 1).Zeitbereich dtVon, dtBis, iZeitbereich:=1, dtSynchFrom:=dtSynch
    'Das ist nicht sch|fffd|n, aber im Zeitbereich vom ProtTyp bekomme ich es einfach nicht hin.
    If DateDiff("s", Me.Von, dtVon) = 0 Then
      If .PerEinheit <= erTag Then
        dtVon = DateAdd(getIntFormatStr(.PerEinheit), .Periode, Me.Von)
      End If
    End If
    Me.Von = dtVon
    
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDemoZeitbereich_Click()
  If mdtDemoZeitbereich > 0 Then
    If cboProtTyp.ListIndex >= 0 Then
      If mcoProtTypen.Item(cboProtTyp.ListIndex + 1).IntEinheit >= 3 Then
        Me.Von = DateSerial(Year(mdtDemoZeitbereich), _
                            Month(mdtDemoZeitbereich), _
                            Day(mdtDemoZeitbereich))
      Else
        Me.Von = mdtDemoZeitbereich
      End If
    End If
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboProtTyp_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub cboProtTyp_Change()

Dim dtVon As Date
Dim dtBis As Date

  If cboProtTyp.ListIndex >= 0 Then
    mcoProtTypen.Item(cboProtTyp.ListIndex + 1).Zeitbereich dtVon, dtBis, , miZeitbereich
    Me.Von = dtVon
    'Me.Bis = dtBis
    
  End If

End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()

Dim lAnz  As Long
Dim lOK   As Long

  If Me.Von > Me.Bis Then
    Call MsgBox(GetResText(21102), _
                vbOKOnly & vbInformation, _
                GetResText(20102))
    dtpBisDatum.SetFocus
  ElseIf Me.Von > Now Then
    Call MsgBox(GetResText(21154), _
                vbOKOnly & vbInformation, _
                GetResText(20102))
    dtpVonDatum.SetFocus
  Else
'    With mcoProtTypen.Item(cboProtTyp.ListIndex + 1)
'      If .Intervall < 2000000 Then
'        lAnz = Aufrunden(DateDiff("s", Me.Von, Me.Bis) / .Intervall)
'      Else
'        lAnz = DateDiff("m", Me.Von, Me.Bis) + 1
'      End If
'    End With
'
'    If lAnz < 2000 Then
'      lOK = vbOK
'
'    ElseIf lAnz < 20000 Then
'      lOK = MsgBox(GetResText(21103) & " " & lAnz & " " & GetResText(21104), _
'                   vbOKCancel + vbInformation, _
'                   GetResText(20103))
'    Else
'      Call MsgBox(GetResText(21103) & " " & lAnz & " " & GetResText(21105), _
'                  vbOKOnly + vbCritical, _
'                  GetResText(20104))
'      lOK = vbCancel
'    End If
'
'    If lOK = vbOK Then
'      mboOK = True
'      Me.Hide
'    End If
    mboOK = True
    Me.Hide
  End If

End Sub


'--------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim i As Integer
Dim vdtDemoStart As Date

  Call FormularBeschriften(Me)

  dtpVonDatum.Format = dtpShortDate
  dtpVonDatum.value = Date
  
  dtpVonZeit.Format = dtpTime
  dtpVonZeit.value = 0
  
  dtpBisDatum.Format = dtpShortDate
  dtpBisZeit.Format = dtpTime
  
  Set mcoProtTypen = New CO_ProtokollTyp

  On Error GoTo InitError
  Call M_PVSS.dpGet("ApplicationProperties.demoDataStart:_online.._value", vdtDemoStart)
  mdtDemoZeitbereich = M_PVSS.CPVSSTime(vdtDemoStart)
  If mdtDemoZeitbereich = 0 Then
    btnDemoZeitbereich.Visible = False
  End If
  
  Exit Sub
  
InitError:
  btnDemoZeitbereich.Visible = False
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'--------------------------------------------------------------------------------------------------
Public Property Let Modus(iModus As Integer)

  miModus = iModus

  Select Case miModus
  
    'StdProt - Protokoll Neu
    'AtvProt - Protokoll Neu
    Case 1, 3
'      Me.Caption = GetResText(16014)
      dtpBisDatum.Enabled = True
      dtpBisZeit.Enabled = True
    
    'BtrProt - Protokoll Neu
    Case 2
'      Me.Caption = GetResText(16014)
      dtpBisDatum.Enabled = False
      dtpBisZeit.Enabled = False
    
  End Select

End Property

'--------------------------------------------------------------------------------------------------
Private Sub dtpVonDatum_change()
  Me.Von = CDate(dtpVonDatum + dtpVonZeit)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub dtpBisDatum_change()
  Me.Bis = CDate(dtpBisDatum + dtpBisZeit)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub dtpVonZeit_change()
  Me.Von = CDate(dtpVonDatum + dtpVonZeit)
End Sub

'--------------------------------------------------------------------------------------------------
Private Sub dtpBisZeit_change()
  Me.Bis = CDate(dtpBisDatum + dtpBisZeit)
End Sub
Attribute VB_Name = "V_SQL"
Attribute VB_Base = "0{ECC1986A-426F-4B84-A3C1-31D134993671}{7D7A1538-F64A-420D-B7B5-85F3D09AA16E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------------------
' Thema: SQL-View "V_SQL" fuer die Erstellung eines SQL-Statements
' Autor: M. Haslop
' Stand: 30.05.02
'---------------------------------------------------------------------------------------------------
Option Explicit

Dim moSQL As New C_SQL

Private oComMan As ComManager
Private oReportExt As reportExt
Private mbFinish As Boolean
Private masKonfigs() As String



'--------------------------------------------------------------------------------------------------
Public Property Get Finish() As Boolean
  Finish = mbFinish
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set SQL(oSQL As C_SQL)
  Set moSQL = oSQL
  Call setViewAlert 'Erste Registerkarte initialisieren
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get SQL() As C_SQL
  Set SQL = moSQL
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnCancel_Click()
  mbFinish = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
' Allgemeine Viewsterung
'---------------------------------------------------------------------------------------------------
Private Sub btnBack_Click()

Dim iTabActual As Integer
Dim iTabMax As Integer
Dim iTabMin As Integer
Dim bOK As Boolean
Dim bBack As Boolean
Dim bForeward As Boolean
Dim bFinish As Boolean


  'Auslesen der Werte aus dem View
  Call getViewValues

  'Steuern der Buttons
  iTabActual = mpSQL.value
  iTabActual = iTabActual - 1
  iTabMax = mpSQL.Pages.Count
  iTabMin = 0
  
  Call enableButtons(iTabActual, iTabMax, iTabMin, _
                     bOK, bBack, bForeward, bFinish)

  If bOK = True Then
    btnBack.Enabled = bBack
    btnForward.Enabled = bForeward
    btnFinish.Enabled = bFinish
    mpSQL.value = iTabActual
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnForward_Click()

Dim sTabName As String

Dim iTabActual As Integer
Dim iTabMax As Integer
Dim iTabMin As Integer
Dim bOK As Boolean
Dim bBack As Boolean
Dim bForeward As Boolean
Dim bFinish As Boolean


  'Auslesen der Werte aus dem View
  Call getViewValues
  
  'Steuern der Buttons
  iTabActual = mpSQL.value
  iTabActual = iTabActual + 1
  iTabMax = mpSQL.Pages.Count
  iTabMin = 0
  
  Call enableButtons(iTabActual, iTabMax, iTabMin, _
                     bOK, bBack, bForeward, bFinish)

  If bOK = True Then
    btnBack.Enabled = bBack
    btnForward.Enabled = bForeward
    btnFinish.Enabled = bFinish
    mpSQL.value = iTabActual
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnFinish_Click()

Dim asSelect() As String
Dim asFrom() As String


  'Speichern der letzten Eingaben
  Call getViewSort
  
  'Pruefen, ob Select- und From-Statement vorhanden sind
  SQL.GetSelect asSelect
  SQL.GetFrom asFrom
  
  If UBound(asSelect) <= 0 Or UBound(asFrom) <= 0 Then
    Call MsgBox(GetResText(21158), vbExclamation + vbOKOnly, GetResText(20102))
  Else
    mbFinish = True
    Me.Hide
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub enableButtons(iTabActual As Integer, iTabMax As Integer, iTabMin As Integer, _
                          bOK As Boolean, bBack As Boolean, bForeward As Boolean, bFinish As Boolean)

  If iTabActual < iTabMax - 1 Then
    bForeward = True
    bFinish = False
    bOK = True
  ElseIf iTabActual = iTabMax - 1 Then
    bForeward = False
    bFinish = True
    bOK = True
  Else
    bOK = False
  End If
  
  If iTabActual > 0 Then
    bBack = True
  Else
    bBack = False
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub getViewValues()

Dim sTabName As String

  'Abhaengig vom Viewnamen die Daten auslesen
  sTabName = mpSQL.SelectedItem.Name
  
  Select Case sTabName
    Case "pgAlert"
      Call getViewAlert
      Call setViewSelect
    Case "pgSelect"
      Call getViewSelect
      Call setViewFrom
    Case "pgFrom"
      Call getViewFrom
      Call setViewWhere
    Case "pgWhere"
      Call getViewWhere
      Call setViewTimerange
    Case "pgTimerange"
      Call getViewTimerange
      Call setViewSort
    Case "pgSort"
      Call getViewSort
  End Select

End Sub

'---------------------------------------------------------------------------------------------------
' Registerkarte ALERT
'---------------------------------------------------------------------------------------------------
Private Sub setViewAlert()

  'Alarme oder Werte ausgewaehlt
  If moSQL.Alert = True Then
    rbAlert.value = True
  Else
    rbValue.value = True
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub getViewAlert()

Dim bAlert As Boolean

  bAlert = rbAlert.value
  moSQL.Alert = bAlert
  
End Sub

'---------------------------------------------------------------------------------------------------
' if CB active show all configured details from rdb compression
Private Sub cbUseRdbDetails_Click()
  Call checkAlert
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub rbAlert_Click()
  cbUseRdbDetails.Enabled = False
  Call checkAlert
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub rbValue_Click()
  cbUseRdbDetails.Enabled = True
  Call checkAlert
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub checkAlert()

Dim asSelect() As String
Dim asWhere() As String
Dim asSort() As String
Dim bEnthalten As Boolean
Dim iAnswer As Integer
Dim asEmpty() As String
Dim n As Integer


  'Konfigs laden
  If rbValue = True Then
  
    'Optionen einlesen
    'Achtung: Sortierung nach Ascii wird vorausgesetzt
    ReDim masKonfigs(13)
    masKonfigs(1) = "_corr.._stime"
    masKonfigs(2) = "_corr.._value"
    masKonfigs(3) = "_default.._value"
    masKonfigs(4) = "_offline.._stime"
    masKonfigs(5) = "_offline.._value"
    masKonfigs(6) = "_online.._stime"
    masKonfigs(7) = "_online.._value"
    masKonfigs(8) = "_original.._stime"
    masKonfigs(9) = "_original.._value"
    masKonfigs(10) = "_pv_range.._max"
    masKonfigs(11) = "_pv_range.._min"
    masKonfigs(12) = "_u_range.._max"
    masKonfigs(13) = "_u_range.._min"
    
    If (IS_RDBACTIVE = True And _
        cbUseRdbDetails.value = True And cbUseRdbDetails.Enabled = True) Then
        
      Call fillRdbDetails(masKonfigs())
    End If

  Else
    'Optionen einlesen
    ReDim masKonfigs(9)
    masKonfigs(1) = "_alert_hdl.._act_text"
    masKonfigs(2) = "_alert_hdl.._act_state_color"
    masKonfigs(3) = "_alert_hdl.._act_state_text"
    masKonfigs(4) = "_alert_hdl.._ack_time"
    masKonfigs(5) = "_alert_hdl.._l_limit"
    masKonfigs(6) = "_alert_hdl.._prior"
    masKonfigs(7) = "_alert_hdl.._text"
    masKonfigs(8) = "_alert_hdl.._u_limit"
    masKonfigs(9) = "_alert_hdl.._value"
  End If


  'Checken, ob die Statements schon verwendet werden
  SQL.GetSelect asSelect
  SQL.GetWhere asWhere
  SQL.GetSort asSort
  
  If UBound(asSelect) > 0 Then
    'Nachsehen, ob die Argumente in der Liste vorkommen
    bEnthalten = False
    For n = 1 To UBound(masKonfigs)
      If masKonfigs(n) = asSelect(1) Then
        bEnthalten = True
      End If
    Next n
    
    If bEnthalten = False Then
    
      iAnswer = MsgBox(GetResText(21159), vbYesNo + vbQuestion, GetResText(20105))
      If iAnswer = vbYes Then
      
        ReDim asEmpty(0)
        SQL.SetSelect asEmpty
        SQL.SetWhere asEmpty
        SQL.SetSort asEmpty
        
      Else
        'Wenn nein, dann Auswahl rueckgaengig machen
        If rbAlert = True Then
          rbValue.value = True
        Else
          rbAlert.value = True
        End If
      End If
    End If
  End If
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub fillRdbDetails(ByRef configs() As String)

Dim startIx   As Integer
Dim vDpTypes  As Variant
Dim vDpNames  As Variant
Dim vDpElems  As Variant
Dim asSplit() As String
Dim i As Integer
Dim j As Integer
Dim k As Integer
Dim sHelp As String
Dim asHelp() As String
Dim l As Integer
Dim found As Boolean

  startIx = 0
  ReDim asHelp(0)
  Call M_PVSS.getReportExt.dpRdbTypes("", vDpTypes)
  For i = 1 To UBound(vDpTypes)
    Call M_PVSS.getReportExt.dpRdbNames("", vDpTypes(i), vDpNames)
    
    For j = 1 To UBound(vDpNames)
      Call M_PVSS.getReportExt.dpRdbElems("", vDpNames(j), vDpElems)
      For k = 1 To UBound(vDpElems)
        sHelp = vDpElems(k)
        Call strSplit(sHelp, ":", asSplit)
        found = False
        
        For l = 1 To UBound(asHelp)
          If asHelp(l) = asSplit(3) Then
            found = True
            Exit For
          End If
        Next l
        If (found = False) Then
          startIx = startIx + 1
          ReDim Preserve asHelp(startIx)
          asHelp(startIx) = asSplit(3)
        End If
      Next k
    Next j
    
  Next i
  
  i = UBound(configs)
  ReDim Preserve configs(i + 2 * UBound(asHelp))
  For j = 1 To UBound(asHelp)
    configs(i + (j * 2) - 1) = "_offline." & asHelp(j) & "._stime"
    configs(i + (j * 2)) = "_offline." & asHelp(j) & "._value"
  Next j
  Call M_Tools.StrSort(configs)
      
End Sub

'---------------------------------------------------------------------------------------------------
' Registerkarte SELECT
'---------------------------------------------------------------------------------------------------
Private Sub setViewSelect()

'Dim asKonfigs() As String
Dim asSelect() As String
Dim iSelect As Integer
Dim bSelect As Boolean
Dim n As Integer

  
  'View steuern
  lbSource.Clear
  lbDestination.Clear
  
  'Laden der darzustellenden Daten
  moSQL.GetSelect asSelect
  
  'Schleife ueber das ausgewaehlte Feld
  For iSelect = 1 To UBound(asSelect)
    lbDestination.AddItem asSelect(iSelect)
  Next iSelect
  
  'Verbleibende Konfigs einfuegen
  For n = 1 To UBound(masKonfigs)
    
    'Pruefen, ob Werte ausgewaehlt sind
    bSelect = False
    For iSelect = 1 To UBound(asSelect)
      If asSelect(iSelect) = masKonfigs(n) Then
        bSelect = True
        Exit For
      End If
    Next iSelect
      
    'Pruefen, ob das Element ausgewaehlt war
    If Not bSelect Then
      lbSource.AddItem masKonfigs(n)
    End If
  
  Next n
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub getViewSelect()

Dim asDestination() As String
Dim n As Integer

  ReDim asDestination(0)

  For n = 1 To lbDestination.ListCount
    ReDim Preserve asDestination(n)
    asDestination(n) = lbDestination.List(n - 1)
  Next n

  moSQL.SetSelect asDestination

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAdd_Click()

Dim iSelected As Integer
Dim sText As String

  iSelected = lbSource.ListIndex
  
  If iSelected > -1 Then
    sText = lbSource.Text
    lbSource.RemoveItem (iSelected)
    lbDestination.AddItem (sText)
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim iSelected As Integer
Dim asWhere() As String
Dim asSort() As String
Dim bStop As Boolean
Dim iAnswer As Integer
Dim asEmpty() As String
Dim sText As String
Dim iPos As Integer
Dim asSourceList() As String
Dim n As Integer


  iSelected = lbDestination.ListIndex
  
  If iSelected > -1 Then
  
    'Checken, ob die Statements schon verwendet werden
    SQL.GetWhere asWhere
    SQL.GetSort asSort
    
    bStop = False
    If UBound(asWhere) > 0 Then
      iAnswer = MsgBox(GetResText(21160), vbYesNo + vbQuestion, GetResText(20105))
      If iAnswer = vbYes Then
        ReDim asEmpty(0)
        SQL.SetWhere asEmpty
      Else
        bStop = True
      End If
    End If
    
    If UBound(asSort) > 0 Then
      iAnswer = MsgBox(GetResText(21161), vbYesNo + vbQuestion, GetResText(20105))
      If iAnswer = vbYes Then
        ReDim asEmpty(0)
        SQL.SetSort asEmpty
      Else
        bStop = True
      End If
    End If
    
    If bStop = False Then
    
      sText = lbDestination.Text
      lbDestination.RemoveItem (iSelected)
      
      'Alphabetisch sortiert einordnen
      ReDim asSourceList(0)
      For n = 1 To lbSource.ListCount
        ReDim Preserve asSourceList(n)
        asSourceList(n) = lbSource.List(n - 1)
      Next n
      
      iPos = M_SQLVorlage.positionAsc(sText, asSourceList)
      iPos = iPos - 1 'Liste beginnt bei 0, Feld bei 1
      lbSource.AddItem sText, iPos
      
    End If
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAuf_Click()

Dim iSelected As Integer
Dim sText As String

  iSelected = lbDestination.ListIndex
  If iSelected >= 1 Then
    sText = lbDestination.List(iSelected)
    lbDestination.List(iSelected) = lbDestination.List(iSelected - 1)
    lbDestination.List(iSelected - 1) = sText
    lbDestination.Selected(iSelected - 1) = True
  End If
  
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub btnAb_Click()

Dim iSelected As Integer
Dim sText As String

  iSelected = lbDestination.ListIndex
  If iSelected < lbDestination.ListCount - 1 Then
    sText = lbDestination.List(iSelected)
    lbDestination.List(iSelected) = lbDestination.List(iSelected + 1)
    lbDestination.List(iSelected + 1) = sText
    lbDestination.Selected(iSelected + 1) = True
  End If

End Sub

'---------------------------------------------------------------------------------------------------
' Registerkarte FROM
'---------------------------------------------------------------------------------------------------
Private Sub setViewFrom()

Dim asSystemName() As String
Dim asDptNameComplete() As String
Dim asDptName() As String
Dim asSelect() As String
Dim n As Integer

Dim sysName As Variant
Dim mySystem As Variant
Dim oldSystem As Variant
Dim i As Integer

  'Uebergebene Werte darstellen
  lbDpList.Clear
  moSQL.GetFrom asSelect
  
  For n = 1 To UBound(asSelect)
    lbDpList.AddItem (asSelect(n))
  Next n

  'Starteinstellung
  ' IM 82753 WOKL 8.2.08 mit Systemname beliefern
  oldSystem = moSQL.Remote
  cbSystem.Clear
  Call oReportExt.getSystemName(-1, mySystem)   ' default system
  cbSystem.AddItem mySystem
  For i = 0 To MAX_SYSNO     ' in 3.0 256, spaeter mehr
    Call oReportExt.getSystemName(i, sysName)
    If sysName <> "" And sysName <> mySystem Then
        cbSystem.AddItem sysName
    End If
  Next i
  n = 0
  If cbSystem.ListCount < 2 Then
    cbSystem.Enabled = False
  Else
    For i = 0 To cbSystem.ListCount - 1
      If (cbSystem.List(i) & ":" = oldSystem) Then
        n = i
        Exit For
      End If
    Next i
  End If
  cbSystem.ListIndex = n        ' mindestens mySystem
  
  btnAddDp.Enabled = False
  Call oComMan.dpTypes(cbSystem.Text & ":*", asDptNameComplete)
  Call M_SQLVorlage.getDpTypeNames(asDptNameComplete, asDptName)
  
  For n = 1 To UBound(asDptName)
    cbDpt.AddItem (asDptName(n))
  Next

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub getViewFrom()

Dim asList() As String
Dim n As Integer

  ReDim asList(0)
  
  For n = 1 To lbDpList.ListCount
    ReDim Preserve asList(n)
    asList(n) = lbDpList.List(n - 1)
  Next n

  moSQL.SetFrom asList

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbSystem_Click()

Dim sSystemName As String
Dim asDptNameComplete() As String
Dim asDptName() As String
Dim dptSave As String
Dim n As Integer
Dim found As Integer
Dim mySystem As Variant
    
  'On Error Resume Next
  Call oReportExt.getSystemName(-1, mySystem)   ' default system
  sSystemName = cbSystem.Text
  dptSave = cbDpt.Text
  cbDpt.Clear
  cbDp.Clear
  cbDpe.Clear
  btnAddDp.Enabled = False
  
  ' moSQL.Remote == "" steht fuer 'eigenes System'
  If (sSystemName & ":" <> moSQL.Remote And _
      (moSQL.Remote <> "" Or sSystemName <> mySystem)) Then
    lbDpList.Clear
    Dim asEmpty(0) As String
    moSQL.SetWhere asEmpty()
  End If
  
  Call oComMan.dpTypes(cbSystem.Text & ":*", asDptNameComplete)
  Call M_SQLVorlage.getDpTypeNames(asDptNameComplete, asDptName)
  
  found = 0
  For n = 1 To UBound(asDptName)
    cbDpt.AddItem (asDptName(n))
    If (dptSave = asDptName(n)) Then
      found = n
    End If
  Next
  If (found > 0) Then
    cbDpt.ListIndex = found - 1   ' der eigene
  End If
  
  If (mySystem = cbSystem.Text) Then
    moSQL.Remote = ""
  Else
    moSQL.Remote = cbSystem.Text & ":"
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbDpt_Click()

Dim sDptName As String
Dim asDpNameComplete() As String
Dim asDpName() As String
Dim n As Integer

  ' On Error Resume Next
  sDptName = cbDpt.Text
  cbDp.Clear
  cbDpe.Clear
  btnAddDp.Enabled = False
  ReDim asDpName(0)
  Call oComMan.dpNames(cbSystem.Text & ":*", sDptName, asDpNameComplete)
  Call M_SQLVorlage.getDpNames(asDpNameComplete, asDpName)
  
  If UBound(asDpName) > 0 Then
    For n = 1 To UBound(asDpName)
      cbDp.AddItem (asDpName(n))
    Next n
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbDp_Click()

Dim sSystemName As String
Dim sDpName As String
Dim sDptName As String
Dim asDpeNameComplete() As String
Dim asDpeName() As String
Dim sDpeType As String
Dim asDpeNameSplit() As String
Dim asDpNameSplit() As String
Dim iSplit As Integer
Dim sDPE As String
Dim n As Integer

  On Error Resume Next
  sSystemName = cbSystem.Text
  sDpName = cbDp.Text
  sDptName = cbDpt.Text
  cbDpe.Clear
  
  Call oComMan.dpNames(sSystemName & ":" & sDpName & ".**", sDptName, asDpeNameComplete)
  Call M_SQLVorlage.getDpElementName(asDpeNameComplete, asDpeName)
  
  For n = 1 To UBound(asDpeName)
  
    sDpeType = oComMan.dpElementType(asDpeNameComplete(n))
    If sDpeType = DPE_CHAR Or _
       sDpeType = DPE_UNSIGNED Or _
       sDpeType = DPE_INT Or _
       sDpeType = DPE_FLOAT Or _
       sDpeType = DPE_BOOL Or _
       sDpeType = DPE_BIT32 Or _
       sDpeType = DPE_STRING Or _
       sDpeType = DPE_TIME Then
       
       'Damit man auch RootKnoten (ExampleDP_Arg1.) auswaehlen kann
       If asDpeName(n) <> "" Then
         cbDpe.AddItem (asDpeName(n))
       Else
         cbDpe.AddItem (".")
       End If
    End If
  Next
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbDpe_Change()
  btnAddDp.Enabled = True
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAddDp_Click()

Dim sDpName As String
Dim sDpeName As String
Dim sList As String


  sDpName = cbDp.Text
  sDpeName = cbDpe.Text
  
  If Len(sDpName) > 0 Then
      
    If Left(sDpeName, 1) <> "." Then
      sList = sDpName & "." & sDpeName
    Else
      sList = sDpName & sDpeName
    End If
    lbDpList.AddItem (sList)
    lbDpList.ListIndex = -1
    
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDeleteDp_Click()

  If lbDpList.ListIndex > -1 Then
    lbDpList.RemoveItem (lbDpList.ListIndex)
  End If

End Sub

'---------------------------------------------------------------------------------------------------
' Registerkarte WHERE
'---------------------------------------------------------------------------------------------------
Private Sub setViewWhere()

Dim asWhere() As String
Dim n As Integer


  'Elemente vorbereiten und mit Standardwerten fuellen
  cbOption.Clear
  cbOperatorGlobal.Clear
  lbListWhere.Clear
  
  btnAddWhere.Enabled = False
  btnDpSelector.Enabled = False
  
  cbOption.BackColor = &H80000005
  cbArgument.BackColor = &H80000013
  cbOperator.BackColor = &H80000013
  cbValue.BackColor = &H80000013

  cbOption.AddItem GetResText(16031)
  cbOption.AddItem GetResText(16032)
  cbOption.AddItem GetResText(16033)
  
  cbOperatorGlobal.AddItem ("AND")
  cbOperatorGlobal.AddItem ("OR")
  cbOperatorGlobal.Text = "AND"
  
  'Bisher parametrierte Werte eintragen
  moSQL.GetWhere asWhere
  For n = 1 To UBound(asWhere)
    lbListWhere.AddItem (asWhere(n))
  Next n
  
  If UBound(asWhere) > 0 Then
    cbOperatorGlobal.Enabled = True
    cbOperatorGlobal.BackColor = &H80000005
  Else
    cbOperatorGlobal.Enabled = False
    cbOperatorGlobal.BackColor = &H80000013
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub getViewWhere()

Dim asWhere() As String
Dim n As Integer

  ReDim asWhere(0)

  For n = 1 To lbListWhere.ListCount
    ReDim Preserve asWhere(n)
    asWhere(n) = lbListWhere.List(n - 1)
  Next n

  moSQL.SetWhere asWhere

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbOption_Change()

Dim iOption As Integer
Dim asSelectList() As String
Dim n As Integer


  cbArgument.Clear
  cbOperator.Text = ""
  cbOperator.BackColor = &H80000013
  cbValue.Text = ""
  btnDpSelector.Enabled = False
  
  
  iOption = cbOption.ListIndex
  If iOption = 0 Then
    Call moSQL.GetSelect(asSelectList)
    
    If UBound(asSelectList) = 0 Then
      Call MsgBox(GetResText(21162), vbExclamation + vbOKOnly, GetResText(20103))
      cbOperator.Clear
      cbOption.TabIndex = 0
    Else
      For n = 1 To UBound(asSelectList)
        cbArgument.AddItem (asSelectList(n))
      Next n
      cbArgument.BackColor = &H80000005
    End If
    
    btnAddWhere.Enabled = False

  ElseIf iOption = 1 Then
  
    cbArgument.AddItem ("_SYS")
    cbArgument.AddItem ("_DP")
    cbArgument.AddItem ("_DPE")
    cbArgument.AddItem ("_DPT")
    cbArgument.AddItem ("_ELC")
    
    cbArgument.BackColor = &H80000005
    btnAddWhere.Enabled = False
    
  ElseIf iOption = 2 Then
  
    cbArgument.AddItem ("_LEAF")
    cbArgument.BackColor = &H80000005
    cbArgument.Text = "_LEAF"
    btnAddWhere.Enabled = True
    cbOperator.Clear
    cbOperator.BackColor = &H80000013
    cbValue.Clear
    cbValue.BackColor = &H80000013
    
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbArgument_Change()
  Call changeArgument
  Call initOperator
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub changeArgument()

Dim iOption As Integer
Dim iArgument As Integer

Dim sDptName As String
Dim asDptName() As String
Dim asDptNameComplete() As String
Dim sDpName As String
Dim asDpName() As String
Dim asDpNameComplete() As String
Dim asDpeName() As String
Dim asDpeNameComplete() As String
Dim n As Integer

  On Error Resume Next
  cbValue.Clear

  iOption = cbOption.ListIndex
  iArgument = cbArgument.ListIndex

  If iOption = 0 Then
    'Wertevergleich
    btnDpSelector.Enabled = False
  ElseIf iOption = 1 Then
    'DP-Namen
    If iArgument = 0 Then
      'System
      btnDpSelector.Enabled = False
      
    ElseIf iArgument = 1 Then
      'Datenpunkt
      ReDim asDpName(0)
      Call selectDp(sDptName)
      Call oComMan.dpNames(cbSystem.Text & ":*", sDptName, asDpNameComplete)
      Call M_SQLVorlage.getDpNames(asDpNameComplete, asDpName)
      
      If UBound(asDpName) > 0 Then
        For n = 1 To UBound(asDpName)
          cbValue.AddItem (asDpName(n))
        Next n
        btnDpSelector.Enabled = True
      End If

    ElseIf iArgument = 2 Then
      'Element
      Call selectDp(sDptName, sDpName)
      If Len(sDptName) > 0 And Len(sDpName) > 0 Then
        Call oComMan.dpNames(cbSystem.Text & ":" & sDpName & ".**", sDptName, asDpeNameComplete)
        Call M_SQLVorlage.getDpElementName(asDpeNameComplete, asDpeName)
        For n = 1 To UBound(asDpeName)
          cbValue.AddItem (asDpeName(n))
        Next n
        btnDpSelector.Enabled = True
      End If

    ElseIf iArgument = 3 Then
      'Datenpunkttyp
      Call oComMan.dpTypes(cbSystem.Text & ":*", asDptNameComplete)
      Call M_SQLVorlage.getDpTypeNames(asDptNameComplete, asDptName)
      For n = 1 To UBound(asDptName)
        cbValue.AddItem (asDptName(n))
      Next n
      btnDpSelector.Enabled = False

    ElseIf iArgument = 4 Then
      'Elementtyp
      cbValue.AddItem ("BOOL")
      cbValue.AddItem ("Bit32")
      cbValue.AddItem ("UNSIGNED")
      cbValue.AddItem ("INTEGER")
      cbValue.AddItem ("FLOAT")
      cbValue.AddItem ("CHAR")
      cbValue.AddItem ("STRING")
      cbValue.AddItem ("TIME")
      btnDpSelector.Enabled = False
      
    End If
    
  ElseIf iOption = 2 Then
    'LEAF
    btnAddWhere.Enabled = True
    cbOperator.Clear
    cbOperator.BackColor = &H80000013
    cbValue.Clear
    cbValue.BackColor = &H80000013
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDpSelector_Click()

Dim iArgument As Integer
Dim sDpName As String
Dim sDptName As String
Dim asDpNameComplete() As String
Dim asDpName() As String
Dim asDpeName() As String
Dim asDpeNameComplete() As String
Dim n As Integer

  On Error Resume Next
  iArgument = cbArgument.ListIndex
  cbValue.Clear

  If iArgument = 1 Then ' WOKL IM 82753: SysName mit in die Auswahl!
    'Datenpunkt
    Call selectDp(sDptName)
    Call oComMan.dpNames(cbSystem.Text & ":*", sDptName, asDpNameComplete)
    Call M_SQLVorlage.getDpNames(asDpNameComplete, asDpName)
    For n = 1 To UBound(asDpName)
      cbValue.AddItem (asDpName(n))
    Next n

  ElseIf iArgument = 2 Then
    'Element
    Call selectDp(sDptName, sDpName)
    Call oComMan.dpNames(cbSystem.Text & ":" & sDpName & ".**", sDptName, asDpeNameComplete)
    Call M_SQLVorlage.getDpElementName(asDpeNameComplete, asDpeName)
    For n = 1 To UBound(asDpeName)
      cbValue.AddItem (asDpeName(n))
    Next n
    
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub initOperator()

Dim iOption As Integer

  cbOperator.Clear
  cbOperator.BackColor = &H80000005
  cbValue.Text = ""
  cbValue.BackColor = &H80000013

  iOption = cbOption.ListIndex
  If iOption = 0 Then
    cbOperator.AddItem ("==")
    cbOperator.AddItem ("!=")
    cbOperator.AddItem (">=")
    cbOperator.AddItem (">")
    cbOperator.AddItem ("<=")
    cbOperator.AddItem ("<")
    cbOperator.AddItem ("LIKE")
  ElseIf iOption = 1 Then
    cbOperator.AddItem ("=")
    cbOperator.AddItem ("!=")
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbOperator_Change()

  cbValue.BackColor = &H80000005

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbValue_Change()

  If Len(cbValue.Text) > 0 Then
    btnAddWhere.Enabled = True
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAddWhere_Click()

Dim iModus As Integer
Dim sArgument As String
Dim sOperator As String
Dim sValue As String


  'Pruefen, ob das Statement vollstaendig ist
  sArgument = cbArgument.Text
  sOperator = cbOperator.Text
  sValue = cbValue.Text
  
  'Bei Bedarf den globalen Parameter anfuegen
  If lbListWhere.ListCount > 0 Then
    lbListWhere.AddItem (cbOperatorGlobal.Text)
  End If
  
  'Das Statement auf Vollstaendigkeit pruefen
  iModus = whereComplete(cbOption.ListIndex, sArgument, sOperator, sValue)
  If iModus = 1 Then
    'Werte OK, Allg. Statement
    lbListWhere.AddItem (sArgument & " " & sOperator & " " & sValue)
  ElseIf iModus = 2 Then
    'Werte OK, LEAF-Statement
    lbListWhere.AddItem (sArgument)
  End If
  
  'Wenn die Liste mindestens ein Element enthaelt, Operator freigeben
  If lbListWhere.ListCount > 0 Then
    cbOperatorGlobal.Enabled = True
    cbOperatorGlobal.BackColor = &H80000005
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDeleteWhere_Click()

Dim iSelected As Integer
Dim sText As String
Dim fTempo As Single


  iSelected = lbListWhere.ListIndex
  
  If iSelected < 0 Then
    'Nichts ist ausgewaehlt
  ElseIf iSelected = 0 Then
    'Sonderfall: Das erste Element
    sText = lbListWhere.Text
    lbListWhere.RemoveItem (iSelected)
    If lbListWhere.ListCount > 0 Then
      'Den Operator des naechsten Statements loeschen
      lbListWhere.RemoveItem (iSelected)
    End If
  Else
    fTempo = iSelected Mod 2
    If fTempo = 0 Then
      'Gerade Zahl ist selektiert: Statement (voran steht der Operator)
      lbListWhere.RemoveItem (iSelected)
      lbListWhere.RemoveItem (iSelected - 1)
    Else
      'Ungerade Zahl ist selektiert: Operator (hinterher steht das Statement)
      lbListWhere.RemoveItem (iSelected + 1)
      lbListWhere.RemoveItem (iSelected)
    End If
  End If

  'Pruefen, ob die Liste leer ist
  If lbListWhere.ListCount = 0 Then
    cbOperatorGlobal.Enabled = False
    cbOperatorGlobal.BackColor = &H80000013
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Function whereComplete(iOption As Integer, sArgument As String, sOperator As String, sValue As String) As Integer

  'Zwei gueltige Faelle:
  '1) Alle Elemente sind nicht leer
  '2) Das Argument heisst LEAF

  If iOption = 2 Then
    'LEAF
    If sArgument = "_LEAF" And sOperator = "" And sValue = "" Then
      whereComplete = 2
    Else
      whereComplete = 0
    End If
    
  Else
    'Wertevergleich (0)
    'DP-Namen (1)
    If sArgument <> "" And sOperator <> "" And sValue <> "" Then
      whereComplete = 1
      If iOption = 0 Then
        sArgument = "'" & sArgument & "'"
      Else
        sValue = """" & sValue & """"
      End If
    Else
      whereComplete = 0
    End If
  End If
  
End Function

'---------------------------------------------------------------------------------------------------
' Registerkarte TIMERANGE
'---------------------------------------------------------------------------------------------------
Private Sub setViewTimerange()

Dim bTimerangeActive As Boolean


  sbBonus.Min = 0
  sbBonus.Max = 100
  
  'Check ob Timerange aktiv ist
  If moSQL.TimerangeActive = True Then
    cbActiveTimerange.value = True
'    rbDpOne.Enabled = True
'    rbDpStarttime.Enabled = True
'    rbDpAll.Enabled = True
    sbBonus.Enabled = True
    txtBonus.BackColor = &H80000005
    
    
'    'Modus
'    If moSQL.TimerangeModus = 1 Then
'      rbDpOne.Value = True
'    ElseIf moSQL.TimerangeModus = 2 Then
'      rbDpStarttime.Enabled = True
'    ElseIf moSQL.TimerangeModus = 3 Then
'      rbDpAll.Value = True
'    End If
    
    'Bonus
    If moSQL.TimerangeBonus <> 0 Then
      txtBonus.Text = moSQL.TimerangeBonus
      sbBonus = moSQL.TimerangeBonus
    Else
      txtBonus.Text = "1"
      sbBonus = 1
    End If
  Else
    'Wenn kein Timerange, dann Startwerte setzen
'    rbDpOne.Value = True
    txtBonus.Text = "1"
    sbBonus = 1
    
    cbActiveTimerange.value = False
'    rbDpOne.Enabled = False
'    rbDpStarttime.Enabled = False
'    rbDpAll.Enabled = False
    sbBonus.Enabled = False
    txtBonus.BackColor = &H80000013

  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub getViewTimerange()

  If cbActiveTimerange.value = True Then
  
    moSQL.TimerangeActive = True
    moSQL.TimerangeBonus = txtBonus.Text
    
    moSQL.TimerangeModus = 1
    
'    If rbDpOne.Value = True Then
'      moSQL.TimerangeModus = 1
'    ElseIf rbDpStarttime.Value = True Then
'      moSQL.TimerangeModus = 2
'    ElseIf rbDpAll.Value = True = True Then
'      moSQL.TimerangeModus = 3
'    End If
    
  Else
    moSQL.TimerangeActive = False
    
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbActiveTimerange_Click()

Dim bEnable As Boolean

  bEnable = cbActiveTimerange.value
'  rbDpOne.Enabled = bEnable
'  rbDpStarttime.Enabled = bEnable
'  rbDpAll.Enabled = bEnable
  sbBonus.Enabled = bEnable
  If bEnable = True Then
    txtBonus.BackColor = &H80000005
  Else
    txtBonus.BackColor = &H80000013
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub sbBonus_Change()
  txtBonus = sbBonus.value
End Sub

'---------------------------------------------------------------------------------------------------
' Registerkarte SORT
'---------------------------------------------------------------------------------------------------
Private Sub setViewSort()

Dim asSort() As String
Dim sTempo As String
Dim iSort As Integer

  'Bisher parametrierte Werte eintragen
  ReDim asSort(0)
  moSQL.GetSort asSort
  
  If UBound(asSort) = 0 Then
    'Keine Sortierung ausgewaehlt
    rbSortNot.value = True
    
  ElseIf UBound(asSort) > 0 Then
    'Sortieren
    If asSort(1) = "0" Then
      'Nach der Zeit
      rbSortTime.value = True
    Else
      'Nach einem DPElement
      rbSortDpe.value = True
      cbSortDpe.ListIndex = asSort(1) - 1
    End If
    
    'Gruppieren
    If UBound(asSort) >= 2 Then
      cbGroup.value = True
      If asSort(1) = "0" Then
        'Sortierung nach Zeit ausgewaehlt
        sTempo = Left(asSort(2), Len(asSort(2)) - 1)
        txtGroup.value = Mid(sTempo, 6)
      End If
    Else
      cbGroup.value = False
    End If
    Call cbGroup_Click
    
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub getViewSort()
  
Dim asSort() As String
Dim iPos As Integer
  
  'Sortierung
  If rbSortNot.value = True Then
    'Keine Sortierung ausgewaehlt
    ReDim asSort(0)
    
  ElseIf rbSortTime.value = True Then
    'Sortierung nach Zeit
    ReDim asSort(1)
    iPos = cbSortDpe.ListIndex
    asSort(1) = "0"
    
  ElseIf rbSortDpe.value = True Then
    'Sortierung nach Wert
    ReDim asSort(1)
    iPos = cbSortDpe.ListIndex
    asSort(1) = iPos + 1 'Listenelemente fangen mit 0 an
    
  End If
  
  'Gruppierung
  If cbGroup.value = True And rbSortNot.value = False Then
    If rbSortTime.value = True Then
      If Len(txtGroup.Text) > 0 Then
        ReDim Preserve asSort(2)
        asSort(2) = "SECS(" & txtGroup.Text & ")"
      End If
    Else
      ReDim Preserve asSort(2)
      asSort(2) = cbSortDpe.ListIndex + 1 'Listenelemente fangen mit 0 an
    End If
  End If
  
  SQL.SetSort asSort
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub rbSortNot_Click()

  cbSortDpe.Enabled = False
  cbSortDpe.BackColor = &H80000013
  cbGroup.Enabled = False
  txtGroup.Enabled = False
  txtGroup.BackColor = &H80000013

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub rbSortTime_Click()

  cbSortDpe.Enabled = False
  cbSortDpe.BackColor = &H80000013
  cbGroup.Enabled = True
  
  If cbGroup.value = True Then
    txtGroup.Enabled = True
    txtGroup.BackColor = &H80000005
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub rbSortDpe_Click()

Dim asSelectList() As String
Dim n As Integer

  cbSortDpe.Enabled = True
  cbSortDpe.BackColor = &H80000005
  cbSortDpe.Clear
  cbGroup.Enabled = True
  
  Call moSQL.GetSelect(asSelectList)
  
  If UBound(asSelectList) > 0 Then
    For n = 1 To UBound(asSelectList)
      cbSortDpe.AddItem (asSelectList(n))
    Next n
    cbSortDpe.value = asSelectList(1)
  Else
    Call MsgBox(GetResText(21162), vbExclamation + vbOKOnly, GetResText(20103))
    Call rbSortNot_Click
    rbSortNot.value = True
  End If
  
  txtGroup.Enabled = False
  txtGroup.BackColor = &H80000013
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cbGroup_Click()

  If cbGroup.value = True Then
    If rbSortTime.value = True Then
      txtGroup.Enabled = True
      txtGroup.BackColor = &H80000005
    Else
      txtGroup.Enabled = False
      txtGroup.BackColor = &H80000013
    End If
  Else
    txtGroup.Enabled = False
    txtGroup.BackColor = &H80000013
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
  Call FormularBeschriften(Me)
  
  Set oComMan = M_PVSS.getComMan
  Set oReportExt = M_PVSS.getReportExt
  
  btnBack.Enabled = False
  btnForward.Enabled = True
  btnFinish.Enabled = False
  mpSQL.value = 0
  
  ' IM 106558/2: not implemented as too slow
  'If (IS_RDBACTIVE = False) Then
    cbUseRdbDetails.Visible = False
  'End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub selectDp(sDPT As String, Optional sDP As String = "NULL", Optional sDPE As String = "NULL")

Dim vDp As V_DP

  Set vDp = New V_DP
  Let vDp.sysName() = cbSystem.Text
  Set vDp.ComMan = oComMan
  
  'Es sollen nur die Werte auswaehlbar sein, die auch hier als Parameter uebergeben wurden
  If sDPE = "NULL" Then
    If sDP = "NULL" Then
      vDp.Modus = 1
    Else
      vDp.Modus = 2
    End If
  Else
    vDp.Modus = 3
  End If
    
  vDp.Show
  
  sDPT = vDp.dpt
  sDP = vDp.dp
  sDPE = vDp.dpe

  Unload vDp
  Set vDp = Nothing

End Sub
Attribute VB_Name = "V_SchnellAnwahlDetail"
Attribute VB_Base = "0{BB22D134-0536-47F0-9EA2-6C505ED6095B}{DFBE713F-B533-48F5-A261-E5940A3E2B6E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_SchnellanwahlDetail
'Oliver Seidel 14.07.2000
'
'
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moProtokoll As C_Protokoll
Private mboOK       As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set Protokoll(oProtokoll As C_Protokoll)
  Set moProtokoll = oProtokoll
  Call ProtokollAnzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Protokoll() As C_Protokoll
  
Dim n As Long
Dim wbTmp As Workbook

  moProtokoll.Bezeichnung = txtBezeichnung.Text
  n = cboProtTyp.ListIndex
  If n > 0 Then
    moProtokoll.ProtTyp.Bezeichnung = cboProtTyp.List(n, 0)
    moProtokoll.ProtTyp.ID = cboProtTyp.List(n, 1)
  Else
    moProtokoll.ProtTyp.Bezeichnung = ""
    moProtokoll.ProtTyp.ID = 0
  End If
  moProtokoll.Vorlage = txtVorlage.Text
  moProtokoll.Drucken = chkDrucken
  moProtokoll.Speichern = chkSpeichern
  moProtokoll.Schliessen = chkSchliessen
  
  If optAktuell Then
    moProtokoll.Zeitbereich = 1
  Else
    moProtokoll.Zeitbereich = 0
  End If
  
  If M_PVSSLogin.PVSSLoginIsValid Then
    On Error Resume Next
    Application.ScreenUpdating = False
    Set wbTmp = Workbooks.Open(txtVorlage.Text, UpdateLinks:=False, ReadOnly:=True)
    wbTmp.Activate
    moProtokoll.Bereich = ActiveWorkbook.Worksheets(TAB_KONFIG).Range(REF_AREA_PERMISSIONS)
    Call wbTmp.Close(SaveChanges:=False)
    Application.ScreenUpdating = True
    On Error GoTo 0
  End If
  
  Set Protokoll = moProtokoll
  
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnPfad_Click()

Dim vDatei      As Variant
Dim sDatei      As String
Dim sDateiTypen As String
Dim asTmp()     As String
Dim n           As Integer

'IM 115373 ICSGEAD
  Call SetCurrentDirectory(ProjektPfad & "\" & VERZ_VORLAGE)
  sDateiTypen = GetResText(21204) & " (*.xltm), *.xltm" & "," & GetResText(21204) & " (*.xlt), *.xlt"
  vDatei = Application.GetOpenFilename(sDateiTypen, , GetResText(21124), , False)
  If Not IsNumeric(vDatei) Then
    sDatei = vDatei
    If Len(sDatei) > 0 Then
      Call StrToArray(asTmp, sDatei, "\")
      For n = UBound(asTmp) To 1 Step -1
        If (LCase(asTmp(n)) = LCase(VERZ_VORLAGE)) Then
          Exit For
        End If
        If (n = UBound(asTmp)) Then
          sDatei = asTmp(n)
        Else
          sDatei = asTmp(n) + "\" + sDatei
        End If
      Next n
      txtVorlage = sDatei
    End If
  End If
  cboProtTyp.SetFocus
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboProtTyp_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub



'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim alId() As Long
Dim asBezeichnung() As String
Dim n As Long

  Call FormularBeschriften(Me)
  
  mboOK = False
  Set moProtokoll = New C_Protokoll
  
  cboProtTyp.Clear
  Call getProtTypBezeichner(alId, asBezeichnung)
  
  cboProtTyp.AddItem
  cboProtTyp.List(0, 0) = "(" & GetResText(16024) & ")"
  cboProtTyp.List(0, 1) = 0
  For n = 1 To UBound(alId)
    cboProtTyp.AddItem
    cboProtTyp.List(n, 0) = asBezeichnung(n)
    cboProtTyp.List(n, 1) = alId(n)
  Next n
  cboProtTyp.ListIndex = 0
  
  chkSpeichern = True
  optAbgeschlossen = True
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub ProtokollAnzeigen()

  txtBezeichnung.Text = moProtokoll.Bezeichnung
  If Len(moProtokoll.ProtTyp.Bezeichnung) Then
    cboProtTyp.Text = moProtokoll.ProtTyp.Bezeichnung
  Else
    cboProtTyp.ListIndex = 0
  End If
  txtVorlage.Text = moProtokoll.Vorlage
  chkDrucken = moProtokoll.Drucken
  chkSpeichern = moProtokoll.Speichern
  chkSchliessen = moProtokoll.Schliessen

  If moProtokoll.Zeitbereich = 1 Then
    optAktuell.value = True
  Else
    optAbgeschlossen.value = True
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean
  
  EingabenPruefen = False
  
  If Len(txtBezeichnung.Text) = 0 Then
    Call MsgBox(lblBezeichnung.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    txtBezeichnung.SetFocus
    Exit Function
  End If
  
  If Len(txtVorlage.Text) = 0 Then
    Call MsgBox(lblVorlage.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    txtVorlage.SetFocus
    Exit Function
  End If
  
  On Error Resume Next
  If Dir(ProjektPfad & "\" & VERZ_VORLAGE & "\" & txtVorlage) = "" Then
    Call MsgBox(GetResText(21123), vbCritical + vbOKOnly, GetResText(20104))
    txtVorlage.SetFocus
    Exit Function
  End If
  
  If chkSchliessen And Not chkDrucken And Not chkSpeichern Then
    Call MsgBox(GetResText(21153), vbCritical + vbOKOnly, GetResText(20104))
    chkDrucken.SetFocus
    Exit Function
  End If
  
  EingabenPruefen = True
  
End Function

Attribute VB_Name = "V_Schnellanwahl"
Attribute VB_Base = "0{A08B5BBC-7C6A-49A7-9EA5-F2FCBAB40D59}{00D8A8AD-24CC-4F80-8C00-CF69D4E6849F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Schnellanwahl
'Oliver Seidel 14.07.2000
'
'Zeigt eine Uebersicht aller Protkolle, die ueber die Schnellanwahl ausgewaehlt werden koennen.
'Von hier aus koennen neue Elemente erstellt und bestehende geloescht oder geaendert werden.
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoProtokoll  As CO_Protokoll
Private mboOK As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set Protokoll(coProtokoll As CO_Protokoll)
  Set mcoProtokoll = coProtokoll
  Call Protokoll_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Protokoll() As CO_ProtokollTyp
  Set Protokoll = mcoProtokoll
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem     As ListItem
Dim oProtokoll  As C_Protokoll

  Set lstItem = lvwProtokoll.SelectedItem
  If Not lstItem Is Nothing Then
    mcoProtokoll.Remove lstItem.ListSubItems(1).Text
    Call Protokoll_Anzeigen
  Else
    Call MsgBox(GetResText(21146), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem     As ListItem
Dim vwProtokoll As V_SchnellAnwahlDetail
Dim oProtokoll  As C_Protokoll

Dim i As Integer
Dim s As String

  Set lstItem = lvwProtokoll.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.ListSubItems(1).Text
    Set vwProtokoll = New V_SchnellAnwahlDetail
    Set oProtokoll = mcoProtokoll.FindItem(s)
    Set vwProtokoll.Protokoll = oProtokoll
    
    i = vbNo
    While i = vbNo
      vwProtokoll.Show
      If vwProtokoll.ok Then
        Set oProtokoll = vwProtokoll.Protokoll
        If s = oProtokoll.Bezeichnung Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          i = vbYes
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoProtokoll.FindItem(oProtokoll.Bezeichnung) Is Nothing Then
            mcoProtokoll.Remove s
            mcoProtokoll.Add oProtokoll
            i = vbYes
          Else
            'Objekt kann nicht umbenannt werden
            Call MsgBox(GetResText(21143), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call Protokoll_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21142), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim lstItem     As ListItem
Dim vwProtokoll As V_SchnellAnwahlDetail
Dim oProtokoll  As C_Protokoll

Dim i As Integer
Dim s As String

  Set vwProtokoll = New V_SchnellAnwahlDetail
    
  i = vbNo
  While i = vbNo
    vwProtokoll.Show
    If vwProtokoll.ok Then
      Set oProtokoll = vwProtokoll.Protokoll
      If mcoProtokoll.FindItem(oProtokoll.Bezeichnung) Is Nothing Then
        oProtokoll.Prio = FindNextPrio
        mcoProtokoll.Add oProtokoll
        i = vbYes
      Else
        Call MsgBox(GetResText(21143), _
                    vbOKOnly + vbInformation, _
                    GetResText(20105))
      End If
    Else
      i = vbCancel
    End If
  Wend
  If i = vbYes Then
    Call Protokoll_Anzeigen
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAuf_Click()

Dim lPrio         As Long
Dim lItemID       As Long
Dim oProtokoll_1  As C_Protokoll
Dim oProtokoll_2  As C_Protokoll

  If lvwProtokoll.ListItems.Count = 0 Then Exit Sub
  lItemID = lvwProtokoll.SelectedItem.index
  If lItemID > 1 Then
    Set oProtokoll_1 = mcoProtokoll.FindItem(lvwProtokoll.ListItems(lItemID - 1).SubItems(1))
    Set oProtokoll_2 = mcoProtokoll.FindItem(lvwProtokoll.ListItems(lItemID).SubItems(1))
    lPrio = oProtokoll_1.Prio
    oProtokoll_1.Prio = oProtokoll_2.Prio
    oProtokoll_2.Prio = lPrio
    lvwProtokoll.ListItems(lItemID - 1).Selected = True
    Call Protokoll_Anzeigen
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAb_Click()

Dim lPrio         As Long
Dim lItemID       As Long
Dim oProtokoll_1  As C_Protokoll
Dim oProtokoll_2  As C_Protokoll

  If lvwProtokoll.ListItems.Count = 0 Then Exit Sub
  lItemID = lvwProtokoll.SelectedItem.index
  If lItemID < lvwProtokoll.ListItems.Count Then
    Set oProtokoll_1 = mcoProtokoll.FindItem(lvwProtokoll.ListItems(lItemID + 1).SubItems(1))
    Set oProtokoll_2 = mcoProtokoll.FindItem(lvwProtokoll.ListItems(lItemID).SubItems(1))
    lPrio = oProtokoll_1.Prio
    oProtokoll_1.Prio = oProtokoll_2.Prio
    oProtokoll_2.Prio = lPrio
    lvwProtokoll.ListItems(lItemID + 1).Selected = True
    Call Protokoll_Anzeigen
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

Private Sub btnTEST_Click()

Dim n As Long

  For n = 1 To lvwProtokoll.ColumnHeaders.Count
    Debug.Print lvwProtokoll.ColumnHeaders(n).Width
  Next n

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwProtokoll_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False

  With lvwProtokoll
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
   
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16012) '"Bezeichnung"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16020) '"Vorlage"
    lstHeader.Width = 67.5
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16003) '"ProtokollTyp"
    lstHeader.Width = 66.75
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16021) '"Drucken"
    lstHeader.Width = 40.5
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16022) '"Speichern"
    lstHeader.Width = 45.75
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16023) '"Schliessen"
    lstHeader.Width = 44.25
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16025) '"Prio"
    lstHeader.Width = 0

    .SortKey = 7
    .Sorted = True
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Protokoll_Anzeigen()

Dim oProtokoll  As C_Protokoll
Dim lstItem     As ListItem
Dim lSelItem    As Long

  With lvwProtokoll
    If Not .SelectedItem Is Nothing Then
      lSelItem = .SelectedItem.index
    End If
    
    .ListItems.Clear
    For Each oProtokoll In mcoProtokoll.Items
      Set lstItem = .ListItems.Add
      lstItem.Text = oProtokoll.ID
      lstItem.SubItems(1) = oProtokoll.Bezeichnung
      lstItem.SubItems(2) = oProtokoll.Vorlage
      lstItem.SubItems(3) = oProtokoll.ProtTyp.Bezeichnung
      lstItem.SubItems(4) = oProtokoll.Drucken
      lstItem.SubItems(5) = oProtokoll.Speichern
      lstItem.SubItems(6) = oProtokoll.Schliessen
      lstItem.SubItems(7) = Format(oProtokoll.Prio, "0000")
    Next oProtokoll
    
    If lSelItem > 0 And lSelItem <= .ListItems.Count Then
      .ListItems(lSelItem).Selected = True
    End If

  End With
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Function FindNextPrio() As Long

Dim oProtokoll  As C_Protokoll
Dim lMax        As Long

  lMax = 1
  For Each oProtokoll In mcoProtokoll.Items
    If lMax <= oProtokoll.Prio Then
      lMax = oProtokoll.Prio + 1
    End If
  Next oProtokoll
  
  FindNextPrio = lMax
  
End Function

Attribute VB_Name = "V_StatusBit"
Attribute VB_Base = "0{81C039AA-7480-463F-8AB4-1E114E11CC3E}{F7C04C7E-9B11-4D9C-8126-29C1CC6614A9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_StatusBit
'Oliver Seidel 14.07.2000
'
'Zeigt eine Uebersicht aller Protkolle, die ueber die StatusBit ausgewaehlt werden koennen.
'Von hier aus koennen neue Elemente erstellt und bestehende geloescht oder geaendert werden.
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoStatusBit  As CO_StatusBit
Private mboOK As Boolean
Private mboChanged As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set StatusBit(coStatusBit As CO_StatusBit)
  Set mcoStatusBit = coStatusBit
  Call StatusBit_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get StatusBit() As CO_StatusBit
  Set StatusBit = mcoStatusBit
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get changed() As Boolean
  changed = mboChanged
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Dim rc As Integer
  rc = vbYes  ' default, IM 104031 WOKL 11.3.11
  If (changed = True) Then
    rc = MsgBox(GetResText(22006), vbQuestion + vbYesNo, GetResText(20103))
  End If
  If (rc = vbYes) Then
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAuf_Click()

Dim lPrio         As Long
Dim lItemID       As Long
Dim oStatusBit_1  As C_StatusBit
Dim oStatusBit_2  As C_StatusBit

  lItemID = lvwStatusBit.SelectedItem.index
  If lItemID > 1 Then
    Set oStatusBit_1 = mcoStatusBit.FindItem(lvwStatusBit.ListItems(lItemID - 1).SubItems(1))
    Set oStatusBit_2 = mcoStatusBit.FindItem(lvwStatusBit.ListItems(lItemID).SubItems(1))
    lPrio = oStatusBit_1.Prio
    oStatusBit_1.Prio = oStatusBit_2.Prio
    oStatusBit_2.Prio = lPrio
    lvwStatusBit.ListItems(lItemID - 1).Selected = True
    Call StatusBit_Anzeigen
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAb_Click()

Dim lPrio         As Long
Dim lItemID       As Long
Dim oStatusBit_1  As C_StatusBit
Dim oStatusBit_2  As C_StatusBit

  lItemID = lvwStatusBit.SelectedItem.index
  If lItemID < lvwStatusBit.ListItems.Count Then
    Set oStatusBit_1 = mcoStatusBit.FindItem(lvwStatusBit.ListItems(lItemID + 1).SubItems(1))
    Set oStatusBit_2 = mcoStatusBit.FindItem(lvwStatusBit.ListItems(lItemID).SubItems(1))
    lPrio = oStatusBit_1.Prio
    oStatusBit_1.Prio = oStatusBit_2.Prio
    oStatusBit_2.Prio = lPrio
    lvwStatusBit.ListItems(lItemID + 1).Selected = True
    Call StatusBit_Anzeigen
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem     As ListItem
Dim oStatusBit  As C_StatusBit

  Set lstItem = lvwStatusBit.SelectedItem
  If Not lstItem Is Nothing Then
    mcoStatusBit.Remove lstItem.ListSubItems(1).Text
    mboChanged = True
    Call StatusBit_Anzeigen
  Else
    Call MsgBox(GetResText(21144), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem     As ListItem
Dim vwStatusBit As V_StatusBitDetail
Dim oStatusBit  As C_StatusBit

Dim i As Integer
Dim s As String

  Set lstItem = lvwStatusBit.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.ListSubItems(1).Text
    Set vwStatusBit = New V_StatusBitDetail
    Set oStatusBit = mcoStatusBit.FindItem(s)
    Set vwStatusBit.StatusBit = oStatusBit
    
    i = vbNo
    While i = vbNo
      vwStatusBit.Show
      If vwStatusBit.ok Then
        Set oStatusBit = vwStatusBit.StatusBit
        If s = oStatusBit.Bezeichnung Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          mboChanged = True
          i = vbYes
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoStatusBit.FindItem(oStatusBit.Bezeichnung) Is Nothing Then
            mcoStatusBit.Remove s
            mcoStatusBit.Add oStatusBit
            mboChanged = True
            i = vbYes
          Else
            'Objekt kann nicht umbenannt werden
            Call MsgBox(GetResText(21145), _
                        vbOKOnly + vbInformation, _
                        GetResText(20104))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call StatusBit_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21144), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim lstItem     As ListItem
Dim vwStatusBit As V_StatusBitDetail
Dim oStatusBit  As C_StatusBit

Dim i As Integer
Dim s As String

  Set vwStatusBit = New V_StatusBitDetail
    
  i = vbNo
  While i = vbNo
    vwStatusBit.Show
    If vwStatusBit.ok Then
      Set oStatusBit = vwStatusBit.StatusBit
      If mcoStatusBit.FindItem(oStatusBit.Bezeichnung) Is Nothing Then
        oStatusBit.Prio = FindNextPrio
        mcoStatusBit.Add oStatusBit
        mboChanged = True
        i = vbYes
      Else
        Call MsgBox(GetResText(21145), _
                    vbOKOnly + vbInformation, _
                    GetResText(20104))
      End If
    Else
      i = vbCancel
    End If
  Wend
  If i = vbYes Then
    Call StatusBit_Anzeigen
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwStatusBit_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader
  mboOK = False
  mboChanged = False

  Call FormularBeschriften(Me)

  With lvwStatusBit
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
   
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16012) '"Bezeichnung"
    lstHeader.Width = 80
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16025) '"Prio"
    lstHeader.Width = 38
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16026) '"BitMuster"
    lstHeader.Width = 300
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16027) '"Werte Ignorieren"
    lstHeader.Width = 38
    
    .SortKey = 2
    .Sorted = True
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub StatusBit_Anzeigen()

Dim oStatusBit  As C_StatusBit
Dim lstItem     As ListItem
Dim lSelItem    As Long

  With lvwStatusBit
    If Not .SelectedItem Is Nothing Then
      lSelItem = .SelectedItem.index
    End If
    .ListItems.Clear
    For Each oStatusBit In mcoStatusBit.Items
      Set lstItem = .ListItems.Add
      lstItem.Text = oStatusBit.ID
      lstItem.SubItems(1) = oStatusBit.Bezeichnung
      lstItem.SubItems(2) = oStatusBit.Prio
      lstItem.SubItems(3) = oStatusBit.BitMuster
      lstItem.SubItems(4) = oStatusBit.WerteIgnorieren
    Next oStatusBit
  
    If lSelItem > 0 And lSelItem <= .ListItems.Count Then
      .ListItems(lSelItem).Selected = True
    End If
  End With
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Function FindNextPrio() As Long

Dim oStatusBit  As C_StatusBit
Dim lMax        As Long

  lMax = 1
  For Each oStatusBit In mcoStatusBit.Items
    If lMax <= oStatusBit.Prio Then
      lMax = oStatusBit.Prio + 1
    End If
  Next oStatusBit
  
  FindNextPrio = lMax
  
End Function
Attribute VB_Name = "V_StatusBitDetail"
Attribute VB_Base = "0{39AE9882-8ABC-4C94-BDF4-B5FE561539CC}{3D432EC4-14AC-4158-AEB6-F6224C1C50FE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Template
'Oliver Seidel 14.07.2000
'
'
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moStatusBit As C_StatusBit
Private mboOK As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set StatusBit(oStatusBit As C_StatusBit)
  Set moStatusBit = oStatusBit
  Call StatusBitAnzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get StatusBit() As C_StatusBit
  
Dim n As Long

  moStatusBit.Bezeichnung = txtBezeichnung.Text
  moStatusBit.BitMuster = lblBitMuster.Caption
  moStatusBit.WerteIgnorieren = chkStatFktBerechnen
  
  Set StatusBit = moStatusBit
  
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnFormat_Click()
  If EingabePruefen Then
    moStatusBit.Format.Name = txtBezeichnung
    Call M_StatusBit.StyleEdit(moStatusBit.Format)
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabePruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lblBitMuster_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, _
                                   ByVal x As Single, ByVal y As Single)

Dim n As Long
Dim s As String

  n = Aufrunden((64 / lblBitMuster.Width) * x)
  s = Mid(lblBitMuster.Caption, n, 1)
  
  Select Case s
    Case "?": s = "1"
    Case "1": s = "0"
    Case "0": s = "?"
  End Select
  
  lblBitMuster.Caption = Left(lblBitMuster.Caption, n - 1) & s & Right(lblBitMuster.Caption, 64 - n)

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim n As Long
Dim s As String

  Call FormularBeschriften(Me)

  lblPosA.WordWrap = False
  lblPosA.Caption = ""
  lblPosB.WordWrap = False
  lblPosB.Caption = ""
  lblBitMuster.WordWrap = False
  lblBitMuster.Caption = ""
  For n = 1 To 64
    If ((n Mod 10) = 1) And (n > 1) Then
      lblPosA.Caption = Left(CStr(n), 1) & lblPosA.Caption
    Else
      lblPosA.Caption = " " & lblPosA.Caption
    End If
    lblPosB.Caption = Right(CStr(n - 1), 1) & lblPosB.Caption
    lblBitMuster.Caption = "?" & lblBitMuster.Caption
  Next n
  lblPosA.AutoSize = True
  lblPosB.AutoSize = True
  lblBitMuster.AutoSize = True
  
  Set moStatusBit = New C_StatusBit
  mboOK = False
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub StatusBitAnzeigen()

  txtBezeichnung.Text = moStatusBit.Bezeichnung
  lblBitMuster.Caption = moStatusBit.BitMuster
  chkStatFktBerechnen = moStatusBit.WerteIgnorieren

End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabePruefen()
  
  EingabePruefen = False
  If Len(txtBezeichnung.Text) = 0 Then
    txtBezeichnung.SetFocus
    Call MsgBox(lblBezeichnung.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    Exit Function
  End If
  EingabePruefen = True
  
End Function
Attribute VB_Name = "V_TST"
Attribute VB_Base = "0{6D35C8E1-3DC2-44B9-BD53-DA1A836DE98F}{A56D1E3E-6605-4207-8D1D-1AE2B69FC14D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub lblPVSS_Click()

Dim Link As String

  Link = "http://www.ETM.at"
  'Link = "mailto:O.Seidel@ETM.at"
  On Error GoTo NoCanDo
  ActiveWorkbook.FollowHyperlink Address:=Link, NewWindow:=True
  Unload Me
  Exit Sub
NoCanDo:
  MsgBox "Cannot open " & Link
End Sub
Attribute VB_Name = "V_Tariffset"
Attribute VB_Base = "0{AC676100-4C4E-4925-A1FA-360F458CDD8E}{BBBA0649-8856-4869-859E-E4F233B61F58}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Tariffset
'Wolfram Klebel 2.7.09
'
'Zeigt eine Liste der Tarifs|fffd|tze, die ausgew|fffd|hlt werden k|fffd|nnen
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoTariffset  As CO_Tariffset
Private mboOK As Boolean
Private mboChanged As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set Tariffset(ccTs As CO_Tariffset)
  Set mcoTariffset = ccTs
  Call Tariffset_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Tariffset() As CO_Tariffset
  Set Tariffset = mcoTariffset
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get changed() As Boolean
  changed = mboChanged
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Dim rc As Integer
  rc = vbYes  ' default, IM 104031 WOKL 11.3.11
  If (changed = True) Then
    rc = MsgBox(GetResText(22006), vbQuestion + vbYesNo, GetResText(20103))
  End If
  If (rc = vbYes) Then
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem     As ListItem
Dim oProtokoll  As C_Tariffset
Dim msgAnswer   As Long
Dim k           As String

  Set lstItem = lvwTariffset.SelectedItem
  If Not lstItem Is Nothing Then
  
    k = M_CostCenter.readTariffset(lstItem.Text)
    If (Not k = "") Then    '"tariffset still used in cost center: "
      Call MsgBox(GetResText(21174) & " " & k, _
                         vbOKOnly, GetResText(20101)) ' Warning
      msgAnswer = vbCancel
    Else
      msgAnswer = vbOK
    End If
    
    If (msgAnswer = vbOK) Then
      mcoTariffset.Remove lstItem.Text
      mboChanged = True
      ' Call M_Tariffset.coSpeichern(mcoTariffset)  ' sonst wirds inkonsistent
      Call Tariffset_Anzeigen
    End If
  Else    ' no tariffset selected
    Call MsgBox(GetResText(21175), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem       As ListItem
Dim vwTariffset  As V_TariffsetDetail
Dim oTariffset   As C_Tariffset

Dim i As Integer
Dim s As String

  Set lstItem = lvwTariffset.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.Text
    Set vwTariffset = New V_TariffsetDetail
    Set oTariffset = mcoTariffset.FindItem(s)
    Set vwTariffset.Tariffset = oTariffset
    
    i = vbNo
    While i = vbNo
      vwTariffset.Show
      If vwTariffset.ok Then
        Set oTariffset = vwTariffset.Tariffset
        If s = oTariffset.Name Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          i = vbYes
          mboChanged = True
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoTariffset.FindItem(oTariffset.Name) Is Nothing Then
            mcoTariffset.Remove s
            mcoTariffset.Add oTariffset
            mboChanged = True
            i = vbYes
          Else
            'Objekt kann nicht umbenannt werden
            Call MsgBox(GetResText(21176), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call Tariffset_Anzeigen
    End If
  Else  ' kein Tarifsatz ausgewaehlt
    Call MsgBox(GetResText(21177), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim lstItem      As ListItem
Dim vwTariffset  As V_TariffsetDetail
Dim oTariffset   As C_Tariffset
Dim tsEntry      As C_TariffsetEntry
Dim coMedia      As CO_Media

Dim i As Integer
Dim s As String

  Set vwTariffset = New V_TariffsetDetail
  Set oTariffset = New C_Tariffset
  Set coMedia = M_Media.coLesen
  If (coMedia.Count < 1) Then
    Call MsgBox(GetResText(21179), vbOKOnly + vbInformation, GetResText(20105))
  Else
    Set oTariffset.Medium = coMedia.Item(1)
    
    Set tsEntry = New C_TariffsetEntry
    Call oTariffset.tsEntry.Add(tsEntry)
    
    Set vwTariffset.Tariffset = oTariffset
      
    i = vbNo
    While i = vbNo
    
      vwTariffset.Show
      If vwTariffset.ok Then
        Set oTariffset = vwTariffset.Tariffset
        If mcoTariffset.FindItem(oTariffset.Name) Is Nothing Then
          mcoTariffset.Add oTariffset
          mboChanged = True
          i = vbYes
        Else
          Call MsgBox(GetResText(21176), _
                      vbOKOnly + vbInformation, _
                      GetResText(20105))
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      ' Call M_Tariffset.coSpeichern(mcoTariffset)
      Call Tariffset_Anzeigen
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwTariffset_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False
  mboChanged = False

  With lvwTariffset
    .View = lvwReport
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru
   
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(17612) '"Bezeichnung"
    lstHeader.Width = 230

    
    .SortKey = 0
    .Sorted = True
  End With
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Tariffset_Anzeigen()

Dim oTariffset  As C_Tariffset
Dim lstItem     As ListItem

  lvwTariffset.ListItems.Clear
  If mcoTariffset Is Nothing Then Exit Sub
  
  For Each oTariffset In mcoTariffset.Items
    Set lstItem = lvwTariffset.ListItems.Add
    lstItem.Text = oTariffset.Name
  Next oTariffset
     
End Sub



Attribute VB_Name = "V_TariffsetDetail"
Attribute VB_Base = "0{DD53DF96-1161-4367-AB5A-8CD45263E524}{8ED46BB4-F2F2-4621-AF6A-FF28CB0DA9F1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_TariffsetDetail
'Wolfram Klebel 30.6.09
'
'Aenderungen:
' IM 101311 Nov. 2010 WOKL: Erweiterungen PowerReport 3.0
'===================================================================================================
Option Explicit

Private moTS          As C_Tariffset
Private mboOK         As Boolean
Private mcoMedia      As CO_Media
Private mboIsDefault  As Boolean
Private mboShowEntry  As Boolean  ' avoid recursion
Private mboBuildEntryName As Boolean  ' avoid recursion
Private mtxOldEntryName As String

Private mcbTariffIsUsed(1 To TARIFFCOUNT) As Object
Private mdtTariffStart(1 To TARIFFCOUNT) As Object ' date/time
Private mdtTariffEnd(1 To TARIFFCOUNT) As Object
Private mflTariffCost(1 To TARIFFCOUNT) As Object
Private mcbTariffOn(1 To TARIFFCOUNT, 8) As Object ' 7 days a week & holliday


'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set Tariffset(cc As C_Tariffset)

  Set moTS = cc
  Call Tariffset_Anzeigen
  
End Property

'---------------------------------------------------------------------------------------------------
' take GUI data to internal data structure
' param entryName is necessary because in case of name changing callback the combobox
' name is already changed, so the last name has to be taken
Private Function AcceptTariffset(entryName As String) As C_Tariffset
  Dim i As Integer
  Dim j As Integer
  Dim tsEntry As C_TariffsetEntry
      
  On Error Resume Next
  With moTS
    .Name = Trim(txtName.Text)
    Set .Medium = mcoMedia.FindItem(cboMedium.Text)
    .CurrName = Trim(txtCurrency.Text)
     
    Set tsEntry = moTS.tsEntry.FindItem(entryName)
    If (Not tsEntry Is Nothing) Then
      With tsEntry
      
        .ValidFrom = dtpValidFromDate + dtpValidFromTime
        .ValidUntil = dtpValidUntilDate + dtpValidUntilTime
        
        For i = 1 To TARIFFCOUNT
          .TariffIsUsed(i) = CBool(mcbTariffIsUsed(i))
          
          ' If .TariffIsUsed(i) = True Then   'IM 104030 WOKL 11.3.11 transfer also disabled info
          .TariffCost(i) = 0  ' default, also for case of error
          If mflTariffCost(i).Text <> "" Then .TariffCost(i) = CDbl(Trim(mflTariffCost(i).Text))
          .TariffStart(i) = mdtTariffStart(i).value
          .TariffEnd(i) = mdtTariffEnd(i).value
          For j = 1 To 8  ' weekday flags
            .TariffOn(i, j) = CBool(mcbTariffOn(i, j).value)
          Next j
          ' End If
        Next i
      End With
    End If
    
    For i = 1 To .Holidays.Count    'Delete holiday
      .Holidays.Remove 1
    Next
    For i = 1 To lvwHolidays.ListItems.Count
      .Holidays.Add CDate(lvwHolidays.ListItems(i).Text)
    Next
       
  End With
  
  Set AcceptTariffset = moTS
  
End Function
'---------------------------------------------------------------------------------------------------
Public Property Get Tariffset() As C_Tariffset
  
  Set Tariffset = AcceptTariffset(cboEntryName.Text)
  
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub Fill_cboEntryName()
  Dim tsEntry As C_TariffsetEntry
  mboBuildEntryName = True
  cboEntryName.Clear
  For Each tsEntry In moTS.tsEntry.Items
    cboEntryName.AddItem (tsEntry.Name)
  Next tsEntry
  mboBuildEntryName = False
End Sub
'---------------------------------------------------------------------------------------------------
Private Sub btnAddEntry_Click()
  Dim tsEntry As C_TariffsetEntry
  Dim entryName As String
  
  entryName = InputBox(GetResText(1227), GetResText(1228), "NewEntry")  ' "Name", "Untertariffsatz"
  If (entryName <> "") Then
    Set tsEntry = moTS.tsEntry.FindItem(entryName)
    If (Not tsEntry Is Nothing) Then
        Call MsgBox(GetResText(21196), vbInformation + vbOKOnly, GetResText(20102))
        Exit Sub
    End If
    Call AcceptTariffset(mtxOldEntryName)
    Set tsEntry = New C_TariffsetEntry
    tsEntry.Name = entryName
    tsEntry.ValidFrom = Now   ' 104028 WOKL 11.3.11
    tsEntry.ValidUntil = Now
    Call moTS.tsEntry.Add(tsEntry)
    Call Fill_cboEntryName
    Call Entry_Anzeigen(entryName)
  End If

End Sub

Private Sub btnCopyEntry_Click()
  Dim tsEntry As C_TariffsetEntry
  Dim tsECopy As C_TariffsetEntry
  Dim entryName As String
  
  entryName = InputBox(GetResText(1227), GetResText(1228), "NewEntry")
  If (entryName <> "") Then
    Set tsEntry = moTS.tsEntry.FindItem(entryName)
    If (Not tsEntry Is Nothing) Then
        Call MsgBox(GetResText(21196), vbInformation + vbOKOnly, GetResText(20102))
        Exit Sub
    End If
    Set tsEntry = moTS.tsEntry.FindItem(cboEntryName.Text)
    If (Not tsEntry Is Nothing) Then
      Call AcceptTariffset(cboEntryName.Text)   ' store changes into objects

      Set tsECopy = tsEntry.Copy
      tsECopy.Name = entryName
          
      Call moTS.tsEntry.Add(tsECopy)
      Call Fill_cboEntryName
      Call Entry_Anzeigen(entryName)
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDeleteEntry_Click()
  
  If (cboEntryName.Text <> "Default") Then
    moTS.tsEntry.Remove (cboEntryName.Text)
    Call Fill_cboEntryName
    Call Entry_Anzeigen("Default")
  Else
    Call MsgBox(GetResText(21195), vbInformation + vbOKOnly, GetResText(20102))
  End If
  
End Sub
'---------------------------------------------------------------------------------------------------
' just change the name of the (already existing) entry; there is no change of contained data
Private Sub btnEditEntry_Click()
  Dim tsEntry As C_TariffsetEntry
  Dim entryName As String
  
  If (cboEntryName.Text <> "Default") Then
    entryName = InputBox(GetResText(1227), GetResText(1228), cboEntryName.Text)
    If (entryName <> "") Then
      Set tsEntry = moTS.tsEntry.FindItem(cboEntryName.Text)
      If (Not tsEntry Is Nothing) Then
        mboBuildEntryName = True    ' avoid change callback
        Call moTS.tsEntry.Remove(cboEntryName.Text)
        tsEntry.Name = entryName
        Call moTS.tsEntry.Add(tsEntry)
        Call Fill_cboEntryName
        cboEntryName = entryName
        Call Entry_Anzeigen(entryName)
      End If
    End If
  Else   ' "must not change default entry"
    Call MsgBox(GetResText(21194), vbInformation + vbOKOnly, GetResText(20102))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
' WOKL 19.8.09: es duerfen nur ganze Stunden eingegeben werden
Private Sub TariffTime_Change(dtObject As Object)

  If (Not dtObject.Minute = 0 Or Not dtObject.Second = 0) Then    ' IM 99915/3: error message language dependent
    Call MsgBox(GetResText(21190), vbInformation + vbOKOnly, GetResText(20102)) 'Only the hour may be changed
    dtObject.value = CDate(CStr(dtObject.Hour) & ":00:00")
  End If

End Sub

Private Sub cboEntryName_Change()
  Dim ts As C_Tariffset
  
  If (mboShowEntry = False And mboBuildEntryName = False) Then
    Call AcceptTariffset(mtxOldEntryName)   ' store changes into objects
    Call Entry_Anzeigen(cboEntryName.Text)
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
' WOKL 22.11.10 fill unit
Private Sub cboMedium_Change()
  Dim oMedium As C_Medium
  
  Set oMedium = mcoMedia.FindItem(cboMedium.Text)
  If Not oMedium Is Nothing Then
    txtUnit.Text = oMedium.unit
    lblCostPerUnit.Caption = txtCurrency.Text & "/" & oMedium.unit
  End If

End Sub

Private Sub dtpValidFromDate_Change()
  Dim tsE As C_TariffsetEntry
  If (mboIsDefault = True) Then
    Call MsgBox(GetResText(21194), vbInformation + vbOKOnly, GetResText(20102))
    Set tsE = moTS.tsEntry.FindItem(cboEntryName.Text)
    dtpValidFromDate = Format(tsE.ValidFrom, "Short Date")
  End If
End Sub

Private Sub dtpValidFromTime_Change()
  Dim tsE As C_TariffsetEntry
  If (mboIsDefault = True) Then
    Call MsgBox(GetResText(21194), vbInformation + vbOKOnly, GetResText(20102))
    Set tsE = moTS.tsEntry.FindItem(cboEntryName.Text)
    dtpValidFromTime = Format(tsE.ValidFrom, "Long Time")
  End If
End Sub

Private Sub dtpValidUntilDate_Change()
  Dim tsE As C_TariffsetEntry
  If (mboIsDefault = True) Then
    Call MsgBox(GetResText(21194), vbInformation + vbOKOnly, GetResText(20102))
    Set tsE = moTS.tsEntry.FindItem(cboEntryName.Text)
    dtpValidUntilDate = Format(tsE.ValidUntil, "Short Date")
  End If
End Sub

Private Sub dtpValidUntilTime_Change()
  Dim tsE As C_TariffsetEntry
  If (mboIsDefault = True) Then
    Call MsgBox(GetResText(21194), vbInformation + vbOKOnly, GetResText(20102))
    Set tsE = moTS.tsEntry.FindItem(cboEntryName.Text)
    dtpValidUntilTime = Format(tsE.ValidUntil, "Long Time")
  End If
End Sub

Private Sub Tariff1Start_Change(): Call TariffTime_Change(Tariff1Start): End Sub
Private Sub Tariff2Start_Change(): Call TariffTime_Change(Tariff2Start): End Sub
Private Sub Tariff3Start_Change(): Call TariffTime_Change(Tariff3Start): End Sub
Private Sub Tariff4Start_Change(): Call TariffTime_Change(Tariff4Start): End Sub
Private Sub Tariff5Start_Change(): Call TariffTime_Change(Tariff5Start): End Sub
Private Sub Tariff6Start_Change(): Call TariffTime_Change(Tariff6Start): End Sub
Private Sub Tariff7Start_Change(): Call TariffTime_Change(Tariff7Start): End Sub
Private Sub Tariff8Start_Change(): Call TariffTime_Change(Tariff8Start): End Sub
Private Sub Tariff9Start_Change(): Call TariffTime_Change(Tariff9Start): End Sub
Private Sub Tariff10Start_Change(): Call TariffTime_Change(Tariff10Start): End Sub
Private Sub Tariff11Start_Change(): Call TariffTime_Change(Tariff11Start): End Sub
Private Sub Tariff12Start_Change(): Call TariffTime_Change(Tariff12Start): End Sub

Private Sub Tariff1End_Change(): Call TariffTime_Change(Tariff1End): End Sub
Private Sub Tariff2End_Change(): Call TariffTime_Change(Tariff2End): End Sub
Private Sub Tariff3End_Change(): Call TariffTime_Change(Tariff3End): End Sub
Private Sub Tariff4End_Change(): Call TariffTime_Change(Tariff4End): End Sub
Private Sub Tariff5End_Change(): Call TariffTime_Change(Tariff5End): End Sub
Private Sub Tariff6End_Change(): Call TariffTime_Change(Tariff6End): End Sub
Private Sub Tariff7End_Change(): Call TariffTime_Change(Tariff7End): End Sub
Private Sub Tariff8End_Change(): Call TariffTime_Change(Tariff8End): End Sub
Private Sub Tariff9End_Change(): Call TariffTime_Change(Tariff9End): End Sub
Private Sub Tariff10End_Change(): Call TariffTime_Change(Tariff10End): End Sub
Private Sub Tariff11End_Change(): Call TariffTime_Change(Tariff11End): End Sub
Private Sub Tariff12End_Change(): Call TariffTime_Change(Tariff12End): End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtCurrency_Change()
  lblCostPerUnit.Caption = txtCurrency.Text & "/" & txtUnit.Text
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtName_Change()
  txtName.value = Mid(txtName.value, 1, 50)
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

  Dim lstHeader As ColumnHeader
  Dim i As Integer
  Dim oMedium As C_Medium
  Dim tsEntry As C_TariffsetEntry

  Call FormularBeschriften(Me)
  mboOK = False
  
  With lvwHolidays
    .View = lvwReport
    .Gridlines = False
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = True
   
    Set lstHeader = .ColumnHeaders.Add
    'lstHeader.Text = "WWW" ' nicht sichtbar (aber noetig?)
    lstHeader.Width = 62
    
    .HideSelection = False
    .Sorted = True
    .SortKey = 0
  End With
  
  ' Initialise objects
  
  Set mcbTariffIsUsed(1) = Tariff1IsUsed:  Set mcbTariffIsUsed(2) = Tariff2IsUsed:
  Set mcbTariffIsUsed(3) = Tariff3IsUsed:  Set mcbTariffIsUsed(4) = Tariff4IsUsed:
  Set mcbTariffIsUsed(5) = Tariff5IsUsed:  Set mcbTariffIsUsed(6) = Tariff6IsUsed:
  Set mcbTariffIsUsed(7) = Tariff7IsUsed:  Set mcbTariffIsUsed(8) = Tariff8IsUsed:
  Set mcbTariffIsUsed(9) = Tariff9IsUsed:  Set mcbTariffIsUsed(10) = Tariff10IsUsed:
  Set mcbTariffIsUsed(11) = Tariff11IsUsed:  Set mcbTariffIsUsed(12) = Tariff12IsUsed:
  
  Set mdtTariffStart(1) = Tariff1Start: Set mdtTariffStart(2) = Tariff2Start
  Set mdtTariffStart(3) = Tariff3Start: Set mdtTariffStart(4) = Tariff4Start
  Set mdtTariffStart(5) = Tariff5Start: Set mdtTariffStart(6) = Tariff6Start
  Set mdtTariffStart(7) = Tariff7Start: Set mdtTariffStart(8) = Tariff8Start
  Set mdtTariffStart(9) = Tariff9Start: Set mdtTariffStart(10) = Tariff10Start
  Set mdtTariffStart(11) = Tariff11Start: Set mdtTariffStart(12) = Tariff12Start
  
  Set mdtTariffEnd(1) = Tariff1End: Set mdtTariffEnd(2) = Tariff2End
  Set mdtTariffEnd(3) = Tariff3End: Set mdtTariffEnd(4) = Tariff4End
  Set mdtTariffEnd(5) = Tariff5End: Set mdtTariffEnd(6) = Tariff6End
  Set mdtTariffEnd(7) = Tariff7End: Set mdtTariffEnd(8) = Tariff8End
  Set mdtTariffEnd(9) = Tariff9End: Set mdtTariffEnd(10) = Tariff10End
  Set mdtTariffEnd(11) = Tariff11End: Set mdtTariffEnd(12) = Tariff12End
  
  Set mflTariffCost(1) = Tariff1Cost:   Set mflTariffCost(2) = Tariff2Cost:
  Set mflTariffCost(3) = Tariff3Cost:  Set mflTariffCost(4) = Tariff4Cost:
  Set mflTariffCost(5) = Tariff5Cost:  Set mflTariffCost(6) = Tariff6Cost:
  Set mflTariffCost(7) = Tariff7Cost:  Set mflTariffCost(8) = Tariff8Cost:
  Set mflTariffCost(9) = Tariff9Cost:  Set mflTariffCost(10) = Tariff10Cost:
  Set mflTariffCost(11) = Tariff11Cost:  Set mflTariffCost(12) = Tariff12Cost:
  
  Set mcbTariffOn(1, 1) = Tariff1OnMo: Set mcbTariffOn(2, 1) = Tariff2OnMo:
  Set mcbTariffOn(3, 1) = Tariff3OnMo: Set mcbTariffOn(4, 1) = Tariff4OnMo:
  Set mcbTariffOn(5, 1) = Tariff5OnMo: Set mcbTariffOn(6, 1) = Tariff6OnMo
  Set mcbTariffOn(7, 1) = Tariff7OnMo: Set mcbTariffOn(8, 1) = Tariff8OnMo
  Set mcbTariffOn(9, 1) = Tariff9OnMo: Set mcbTariffOn(10, 1) = Tariff10OnMo
  Set mcbTariffOn(11, 1) = Tariff11OnMo: Set mcbTariffOn(12, 1) = Tariff12OnMo
  Set mcbTariffOn(1, 2) = Tariff1OnTu: Set mcbTariffOn(2, 2) = Tariff2OnTu:
  Set mcbTariffOn(3, 2) = Tariff3OnTu: Set mcbTariffOn(4, 2) = Tariff4OnTu:
  Set mcbTariffOn(5, 2) = Tariff5OnTu: Set mcbTariffOn(6, 2) = Tariff6OnTu
  Set mcbTariffOn(7, 2) = Tariff7OnTu: Set mcbTariffOn(8, 2) = Tariff8OnTu
  Set mcbTariffOn(9, 2) = Tariff9OnTu: Set mcbTariffOn(10, 2) = Tariff10OnTu
  Set mcbTariffOn(11, 2) = Tariff11OnTu: Set mcbTariffOn(12, 2) = Tariff12OnTu
  Set mcbTariffOn(1, 3) = Tariff1OnWe: Set mcbTariffOn(2, 3) = Tariff2OnWe:
  Set mcbTariffOn(3, 3) = Tariff3OnWe: Set mcbTariffOn(4, 3) = Tariff4OnWe:
  Set mcbTariffOn(5, 3) = Tariff5OnWe: Set mcbTariffOn(6, 3) = Tariff6OnWe
  Set mcbTariffOn(7, 3) = Tariff7OnWe: Set mcbTariffOn(8, 3) = Tariff8OnWe
  Set mcbTariffOn(9, 3) = Tariff9OnWe: Set mcbTariffOn(10, 3) = Tariff10OnWe
  Set mcbTariffOn(11, 3) = Tariff11OnWe: Set mcbTariffOn(12, 3) = Tariff12OnWe
  Set mcbTariffOn(1, 4) = Tariff1OnTh: Set mcbTariffOn(2, 4) = Tariff2OnTh:
  Set mcbTariffOn(3, 4) = Tariff3OnTh: Set mcbTariffOn(4, 4) = Tariff4OnTh:
  Set mcbTariffOn(5, 4) = Tariff5OnTh: Set mcbTariffOn(6, 4) = Tariff6OnTh
  Set mcbTariffOn(7, 4) = Tariff7OnTh: Set mcbTariffOn(8, 4) = Tariff8OnTh
  Set mcbTariffOn(9, 4) = Tariff9OnTh: Set mcbTariffOn(10, 4) = Tariff10OnTh
  Set mcbTariffOn(11, 4) = Tariff11OnTh: Set mcbTariffOn(12, 4) = Tariff12OnTh
  Set mcbTariffOn(1, 5) = Tariff1OnFr: Set mcbTariffOn(2, 5) = Tariff2OnFr:
  Set mcbTariffOn(3, 5) = Tariff3OnFr: Set mcbTariffOn(4, 5) = Tariff4OnFr:
  Set mcbTariffOn(5, 5) = Tariff5OnFr: Set mcbTariffOn(6, 5) = Tariff6OnFr
  Set mcbTariffOn(7, 5) = Tariff7OnFr: Set mcbTariffOn(8, 5) = Tariff8OnFr
  Set mcbTariffOn(9, 5) = Tariff9OnFr: Set mcbTariffOn(10, 5) = Tariff10OnFr
  Set mcbTariffOn(11, 5) = Tariff11OnFr: Set mcbTariffOn(12, 5) = Tariff12OnFr
  Set mcbTariffOn(1, 6) = Tariff1OnSa: Set mcbTariffOn(2, 6) = Tariff2OnSa:
  Set mcbTariffOn(3, 6) = Tariff3OnSa: Set mcbTariffOn(4, 6) = Tariff4OnSa:
  Set mcbTariffOn(5, 6) = Tariff5OnSa: Set mcbTariffOn(6, 6) = Tariff6OnSa
  Set mcbTariffOn(7, 6) = Tariff7OnSa: Set mcbTariffOn(8, 6) = Tariff8OnSa
  Set mcbTariffOn(9, 6) = Tariff9OnSa: Set mcbTariffOn(10, 6) = Tariff10OnSa
  Set mcbTariffOn(11, 6) = Tariff11OnSa: Set mcbTariffOn(12, 6) = Tariff12OnSa
  Set mcbTariffOn(1, 7) = Tariff1OnSu: Set mcbTariffOn(2, 7) = Tariff2OnSu:
  Set mcbTariffOn(3, 7) = Tariff3OnSu: Set mcbTariffOn(4, 7) = Tariff4OnSu:
  Set mcbTariffOn(5, 7) = Tariff5OnSu: Set mcbTariffOn(6, 7) = Tariff6OnSu
  Set mcbTariffOn(7, 7) = Tariff7OnSu: Set mcbTariffOn(8, 7) = Tariff8OnSu
  Set mcbTariffOn(9, 7) = Tariff9OnSu: Set mcbTariffOn(10, 7) = Tariff10OnSu
  Set mcbTariffOn(11, 7) = Tariff11OnSu: Set mcbTariffOn(12, 7) = Tariff12OnSu
  Set mcbTariffOn(1, 8) = Tariff1OnHo: Set mcbTariffOn(2, 8) = Tariff2OnHo:
  Set mcbTariffOn(3, 8) = Tariff3OnHo: Set mcbTariffOn(4, 8) = Tariff4OnHo:
  Set mcbTariffOn(5, 8) = Tariff5OnHo: Set mcbTariffOn(6, 8) = Tariff6OnHo
  Set mcbTariffOn(7, 8) = Tariff7OnHo: Set mcbTariffOn(8, 8) = Tariff8OnHo
  Set mcbTariffOn(9, 8) = Tariff9OnHo: Set mcbTariffOn(10, 8) = Tariff10OnHo
  Set mcbTariffOn(11, 8) = Tariff11OnHo: Set mcbTariffOn(12, 8) = Tariff12OnHo

  For i = 1 To TARIFFCOUNT
    Call TariffUsed(i, False)
  Next i
  frmTimeCostScroll.ScrollTop = 0
  
  Set mcoMedia = M_Media.coLesen
  For Each oMedium In mcoMedia.Items
    cboMedium.AddItem (oMedium.Name)
  Next oMedium
  
  dtpValidFromDate.Format = dtpShortDate
  dtpValidFromDate.value = Date + 1     ' heute + 1 (?)
  dtpValidFromTime.Format = dtpTime
  dtpValidFromTime.value = 0.25

  dtpValidUntilDate.Format = dtpShortDate
  dtpValidUntilDate.value = Date + 1     ' heute + 1 (?)
  dtpValidUntilTime.Format = dtpTime
  dtpValidUntilTime.value = 0.25

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Entry_Anzeigen(entryName As String)
  Dim i As Integer
  Dim j As Integer
  Dim tsEntry As C_TariffsetEntry

  mboShowEntry = True
  Set tsEntry = moTS.tsEntry.FindItem(entryName)  ' default item on start
  mtxOldEntryName = entryName
  If (Not tsEntry Is Nothing) Then
    With tsEntry
      cboEntryName = .Name
      If (.Name = "Default") Then
        mboIsDefault = True
      Else
        mboIsDefault = False
      End If
      dtpValidFromDate = Format(.ValidFrom, "Short Date")
      dtpValidFromTime = Format(.ValidFrom, "Long Time")
      dtpValidUntilDate = Format(.ValidUntil, "Short Date")
      dtpValidUntilTime = Format(.ValidUntil, "Long Time")
      
      For i = 1 To TARIFFCOUNT
        mcbTariffIsUsed(i) = Abs(CInt(.TariffIsUsed(i)))
        Call TariffUsed(i)
        If (mcbTariffIsUsed(i) = True) Then   ' IM 104030 WOKL 11.3.11
          mflTariffCost(i) = CStr(.TariffCost(i))
          mdtTariffStart(i).value = .TariffStart(i)
          mdtTariffEnd(i).value = .TariffEnd(i)
          For j = 1 To 8
            mcbTariffOn(i, j) = Abs(CInt(.TariffOn(i, j)))
          Next j
        End If
      Next i
    End With
  End If
  mboShowEntry = False

End Sub
'---------------------------------------------------------------------------------------------------
Private Sub Tariffset_Anzeigen()

  Dim stringArray() As String
  Dim i As Integer
  Dim j As Integer
  Dim Holiday As String
  Dim tsEntry As C_TariffsetEntry
  
  With moTS
    txtName.Text = .Name
    cboMedium.Text = .Medium.Name
    txtUnit.Text = .Medium.unit
    txtCurrency.Text = .CurrName
    lblCostPerUnit.Caption = .CurrName & "/" & .Medium.unit
    
    Call Fill_cboEntryName
    Call Entry_Anzeigen("Default")

    lvwHolidays.ListItems.Clear
    For i = 1 To .Holidays.Count
      Holiday = .Holidays.Item(i)
      Call lvwHolidays.ListItems.Add(, , Holiday)
    Next
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean
  
Dim dayIx As Integer
Dim countIx As Integer
Dim bRetVal As Boolean
Dim checkBox(TARIFFCOUNT) As Boolean
Dim tsEntry As C_TariffsetEntry
Dim tseNext As C_TariffsetEntry

  On Error GoTo errorHandler:
  
  EingabenPruefen = False   ' in case of any error
  Call AcceptTariffset(cboEntryName.Text)   ' store changes into objects
  
  'Check name
  If txtName.Text = "" Or txtName.Text = "NewName" Then
      Call MsgBox(myLoadResString(DCT_DLGTARIFF_ADD_NONAME), vbCritical, GetResText(20104))
      Exit Function
  End If
  
  'Check Waehrung
  If Trim(Me.txtCurrency.Text) = "" Then
      Call MsgBox(myLoadResString(DCT_DLGTARIFF_WRONG_CURRENCY), vbCritical, GetResText(20104))
      Exit Function
  End If
  
  ' Check for Valid-Relations between entries
  For Each tsEntry In moTS.tsEntry.Items
    If tsEntry.ValidFrom >= tsEntry.ValidUntil Then
      Call MsgBox(myLoadResString(DCT_DLGTARIFF_VALIDITY_ORDER) & " " & tsEntry.Name, vbCritical, GetResText(20104))
      Exit Function
    End If
    
    For Each tseNext In moTS.tsEntry.Items
      If tsEntry.Name <> "Default" And _
         tseNext.Name <> "Default" And _
         tsEntry.Name <> tseNext.Name Then
        If (tseNext.ValidUntil > tsEntry.ValidFrom And tseNext.ValidFrom < tsEntry.ValidUntil) Or _
           (tseNext.ValidFrom < tsEntry.ValidUntil And tseNext.ValidUntil > tsEntry.ValidFrom) Then
          Call MsgBox(myLoadResString(DCT_DLGTARIFF_VALIDITY_INTERSECT) & " " & tsEntry.Name & " / " & tseNext.Name)
          Exit Function
        End If
      End If
    Next tseNext
  
    For Each tseNext In moTS.tsEntry.Items
      If tsEntry.Name <> tseNext.Name Then
        If (tseNext.ValidFrom = tsEntry.ValidFrom And tseNext.ValidUntil = tsEntry.ValidUntil) Then
          Call MsgBox(myLoadResString(DCT_DLGTARIFF_VALIDITY_INTERSECT) & " " & tsEntry.Name & " / " & tseNext.Name)
          Exit Function
        End If
      End If
    Next tseNext
  
  Next tsEntry
  
  For Each tsEntry In moTS.tsEntry.Items
  
    'Check, if costs are right
    For countIx = 1 To TARIFFCOUNT
      If tsEntry.TariffIsUsed(countIx) Then bRetVal = (tsEntry.TariffCost(countIx) <> 0)
      
      If bRetVal = False Then
          Call MsgBox(myLoadResString(DCT_DLGTARIFF_WRONGCOST) & CStr(countIx) & "! (" & tsEntry.Name & ")", vbCritical, GetResText(20104))
          Exit Function
      End If
    Next
  
    'Check, if selections are plausible
    For dayIx = 1 To 8    ' loop running all weekdays
      For countIx = 1 To TARIFFCOUNT
        checkBox(countIx) = tsEntry.TariffOn(countIx, dayIx)
      Next countIx
      bRetVal = CheckTimes(checkBox, tsEntry.aTariffStart(), tsEntry.aTariffEnd(), (dayIx = 8), tsEntry.Name)
      If bRetVal = False Then Exit Function
    Next dayIx
  Next tsEntry
 
  EingabenPruefen = True

errorHandler:
  
End Function

Private Function CheckTimes(ByRef DayChBox() As Boolean, _
                            ByRef TimeFrom() As Date, ByRef TimeTo() As Date, _
                            ByVal bHoliday As Boolean, _
                            ByVal entryName As String) As Boolean
Dim i%
Dim j%
Dim Rememberi%
Dim SelectionCount%
Dim lDateDiff As Long
Dim StartTimeIsEndTime As Boolean

    On Error GoTo errorHandler
    
    CheckTimes = False
    'Check how many tariffs are selected
    SelectionCount = 0
    For i = 1 To TARIFFCOUNT
        If DayChBox(i) <> 0 Then
            SelectionCount = SelectionCount + 1
            Rememberi = i
        End If
    Next
    If SelectionCount = 0 Then
        'If there is no tariff selected
        If bHoliday Then
            CheckTimes = True
            Exit Function
        Else
            CheckTimes = False
            Call MsgBox(myLoadResString(DCT_DLGTARIFF_NOTARIFFSELECTED) & "(" & entryName & ")", vbCritical, GetResText(20104))
            Exit Function
        End If
    ElseIf SelectionCount = 1 Then
        'If there is just on selected, it has to cover the whole day (StartTime = EndTime)
        lDateDiff = DateDiff("h", TimeFrom(Rememberi), TimeTo(Rememberi))
        If lDateDiff <> 0 Then
            CheckTimes = False
            Call MsgBox(myLoadResString(DCT_DLGTARIFF_ONEWRONGTARIFFSELECTED1) & vbCrLf & vbCrLf & myLoadResString(DCT_DLGTARIFF_ONEWRONGTARIFFSELECTED2) & "(" & entryName & ")", _
                        vbCritical, GetResText(20104))
            Exit Function
        End If
    Else
        'If there are more then one tariffs selected, the times of each of the tariffs have to be different
        For i = 1 To TARIFFCOUNT
            If DayChBox(i) <> 0 Then
                If 0 = DateDiff("h", TimeFrom(i), TimeTo(i)) Then
                    CheckTimes = False
                    Call MsgBox(myLoadResString(DCT_DLGTARIFF_WRONGTARIFFSELECTED) & "(" & entryName & ")", vbCritical, GetResText(20104))
                    Exit Function
                End If
            End If
        Next
        'Times are different - check if difference is 24 hours
        lDateDiff = 0
        For i = 1 To TARIFFCOUNT
            If DayChBox(i) <> 0 Then
                If TimeFrom(i) < TimeTo(i) Then
                    lDateDiff = lDateDiff + DateDiff("h", TimeFrom(i), TimeTo(i))
                Else
                    lDateDiff = lDateDiff + (24 - DateDiff("h", TimeTo(i), TimeFrom(i)))
                End If
            End If
        Next
        If lDateDiff <> 24 Then
            CheckTimes = False
            Call MsgBox(myLoadResString(DCT_DLGTARIFF_TARIFF24HOURS) & "(" & entryName & ")", vbCritical, GetResText(20104))
            Exit Function
        End If
        'check, if there is a Starttime for each Endtime
        For i = 1 To TARIFFCOUNT
            If DayChBox(i) <> 0 Then
                StartTimeIsEndTime = False
                For j = 1 To TARIFFCOUNT
                    lDateDiff = 0
                    If (DayChBox(j) <> 0) And (j <> i) Then
                        lDateDiff = DateDiff("h", TimeTo(i), TimeFrom(j))
                        If lDateDiff = 0 Then
                            StartTimeIsEndTime = True
                            Exit For
                        End If
                    End If
                Next
                If StartTimeIsEndTime = False Then
                    CheckTimes = False
                    Call MsgBox(myLoadResString(DCT_DLGTARIFF_TARIFFORDER) & "(" & entryName & ")", vbCritical, GetResText(20104))
                    Exit Function
                End If
            End If
        Next
    End If
    CheckTimes = True
    Exit Function
    
errorHandler:
    CheckTimes = False
End Function

'---------------------------------------------------------------------------------------------------
Private Sub btnAddHolliday_Click()

Dim lstItem     As ListItem
Dim vwDatum     As V_Datum
Dim help As String

  Set vwDatum = New V_Datum
  vwDatum.Datum = DateValue(Now)
  vwDatum.Show
  If vwDatum.ok Then
    help = vwDatum.Datum
    Call lvwHolidays.ListItems.Add(, , help)
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDeleteHolliday_Click()

  Dim index As Integer
  If lvwHolidays.ListItems.Count > 0 Then
    index = lvwHolidays.SelectedItem.index
    If index > 0 Then Call lvwHolidays.ListItems.Remove(index)
  End If

End Sub

Private Sub lvwHolidays_DblClick()
  Dim index As Integer
  Dim vwDatum As V_Datum
  Dim help As String
  
  If lvwHolidays.ListItems.Count > 0 Then
    index = lvwHolidays.SelectedItem.index
 
    Set vwDatum = New V_Datum
    vwDatum.Datum = CDate(lvwHolidays.ListItems(index).Text)
    vwDatum.Show
    If vwDatum.ok Then
      Call lvwHolidays.ListItems.Remove(index)
      help = vwDatum.Datum
      Call lvwHolidays.ListItems.Add(, , help)
    End If
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub TariffUsed(index As Integer, Optional enParam As Boolean = True)

Dim fc As Long
Dim bc As Long
Dim i As Integer
Dim enable As Boolean
    
  If enParam = True Then
    enable = mcbTariffIsUsed(index).value
  Else
    enable = enParam  ' explicit set just to false! (initialisation)
  End If
  
  If (enable) Then
    fc = &H80000008
    bc = &H80000005   ' IM 98284 auf Fensterhintergrund stellen
  Else
    fc = &H80000011
    bc = &H8000000F
  End If
  
  mdtTariffStart(index).Enabled = enable
  mdtTariffEnd(index).Enabled = enable
  mflTariffCost(index).Enabled = enable
  If (Not enable) Then  ' IM 104030 WOKL 11.3.11
    mdtTariffStart(index).value = 0
    mdtTariffEnd(index).value = 0
    mflTariffCost(index).value = 0
  End If
  mflTariffCost(index).ForeColor = fc
  mflTariffCost(index).BackColor = bc
  For i = 1 To 8
    mcbTariffOn(index, i).Enabled = enable
    If (Not enable) Then
      mcbTariffOn(index, i).value = 0
    End If
  Next i
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Tariff1IsUsed_Click(): Call TariffUsed(1): End Sub
Private Sub Tariff2IsUsed_Click(): Call TariffUsed(2): End Sub
Private Sub Tariff3IsUsed_Click(): Call TariffUsed(3): End Sub
Private Sub Tariff4IsUsed_Click(): Call TariffUsed(4): End Sub
Private Sub Tariff5IsUsed_Click(): Call TariffUsed(5): End Sub
Private Sub Tariff6IsUsed_Click(): Call TariffUsed(6): End Sub
Private Sub Tariff7IsUsed_Click(): Call TariffUsed(7): End Sub
Private Sub Tariff8IsUsed_Click(): Call TariffUsed(8): End Sub
Private Sub Tariff9IsUsed_Click(): Call TariffUsed(9): End Sub
Private Sub Tariff10IsUsed_Click(): Call TariffUsed(10): End Sub
Private Sub Tariff11IsUsed_Click(): Call TariffUsed(11): End Sub
Private Sub Tariff12IsUsed_Click(): Call TariffUsed(12): End Sub
'---------------------------------------------------------------------------------------------------

Attribute VB_Name = "V_Zeitplan"
Attribute VB_Base = "0{1B5C4964-ABF7-4D6C-AF67-1E83BB18E61A}{DD0A8194-6176-4A82-B2F4-6C827A54197F}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'V_Zeitplan
'Oliver Seidel 14.07.2000
'
'Zeigt eine Uebersicht aller Protkolle, die ueber die Zeitplan ausgewaehlt werden koennen.
'Von hier aus koennen neue Elemente erstellt und bestehende geloescht oder geaendert werden.
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private mcoProtokoll  As CO_Protokoll
Private mboOK As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Set Protokoll(coProtokoll As CO_Protokoll)
  Set mcoProtokoll = coProtokoll
  Call Protokoll_Anzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Protokoll() As CO_ProtokollTyp
  Set Protokoll = mcoProtokoll
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnDelete_Click()

Dim lstItem     As ListItem
Dim oProtokoll  As C_Protokoll

  Set lstItem = lvwProtokoll.SelectedItem
  If Not lstItem Is Nothing Then
    mcoProtokoll.Remove lstItem.Text
    Call Protokoll_Anzeigen
  Else
    Call MsgBox(GetResText(21146), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnEdit_Click()

Dim lstItem     As ListItem
Dim vwProtokoll As V_ZeitplanDetail
Dim oProtokoll  As C_Protokoll

Dim i As Integer
Dim s As String

  Set lstItem = lvwProtokoll.SelectedItem
  If Not lstItem Is Nothing Then
    
    s = lstItem.Text
    Set vwProtokoll = New V_ZeitplanDetail
    Set oProtokoll = mcoProtokoll.FindItem(s)
    Set vwProtokoll.Protokoll = oProtokoll
    
    i = vbNo
    While i = vbNo
      vwProtokoll.Show
      If vwProtokoll.ok Then
        Set oProtokoll = vwProtokoll.Protokoll
        If s = oProtokoll.Bezeichnung Then
          'OK, Bezeichung hat sich nicht geaendert -> da immer noch das Objekt aus
          'der Collection bearbeitet wird, brachen wir die Aenderungen nicht speichern
          i = vbYes
        Else
          'Wenn die neue Bezeichnung noch nicht in der Collection vorhanden ist,
          'wird das Objekt kurz entfernt und mit neuem Key wieder eingefuegt
          If mcoProtokoll.FindItem(oProtokoll.Bezeichnung) Is Nothing Then
            mcoProtokoll.Remove s
            mcoProtokoll.Add oProtokoll
            i = vbYes
          Else
            'Objekt kann nicht umbenannt werden
            Call MsgBox(GetResText(21143), _
                        vbOKOnly + vbInformation, _
                        GetResText(20105))
          End If
        End If
      Else
        i = vbCancel
      End If
    Wend
    If i = vbYes Then
      Call Protokoll_Anzeigen
    End If
  Else
    Call MsgBox(GetResText(21142), vbCritical + vbOKOnly, GetResText(20104))
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnNeu_Click()

Dim lstItem     As ListItem
Dim vwProtokoll As V_ZeitplanDetail
Dim oProtokoll  As C_Protokoll

Dim i As Integer
Dim s As String

  Set vwProtokoll = New V_ZeitplanDetail
    
  i = vbNo
  While i = vbNo
    vwProtokoll.Show
    If vwProtokoll.ok Then
      Set oProtokoll = vwProtokoll.Protokoll
      If mcoProtokoll.FindItem(oProtokoll.Bezeichnung) Is Nothing Then
        mcoProtokoll.Add oProtokoll
        i = vbYes
      Else
        Call MsgBox(GetResText(21143), _
                    vbOKOnly + vbInformation, _
                    GetResText(20105))
      End If
    Else
      i = vbCancel
    End If
  Wend
  If i = vbYes Then
    Call Protokoll_Anzeigen
  End If

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  mboOK = True
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub lvwProtokoll_DblClick()
  Call btnEdit_Click
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
  
Dim lstHeader As ColumnHeader

  Call FormularBeschriften(Me)

  mboOK = False

  With lvwProtokoll
    .View = lvwReport
    Set .SmallIcons = imglstStatus
    .Gridlines = True
    .FullRowSelect = True
    .LabelWrap = False
    .LabelEdit = lvwManual
    .HideColumnHeaders = False
    .HideSelection = False
    .Font.Charset = GetResText(17516)  ' IM 118695 ansi / ru

    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16012) '"Bezeichnung"
    lstHeader.Width = 110
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = "ID"
    lstHeader.Width = 0
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16020) '"Vorlage"
    lstHeader.Width = 78
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16003) '"ProtokollTyp"
    lstHeader.Width = 66
    Set lstHeader = .ColumnHeaders.Add
    lstHeader.Text = GetResText(16028) '"Naechster Aufruf"
    lstHeader.Width = 90
    
    .SortKey = 1
    .Sorted = True
  End With

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Protokoll_Anzeigen()

Dim oProtokoll  As C_Protokoll
Dim lstItem     As ListItem

  lvwProtokoll.ListItems.Clear
  If mcoProtokoll Is Nothing Then Exit Sub
  
  For Each oProtokoll In mcoProtokoll.Items
    Set lstItem = lvwProtokoll.ListItems.Add
    lstItem.Text = oProtokoll.Bezeichnung
    lstItem.SubItems(1) = oProtokoll.ID
    lstItem.SubItems(2) = oProtokoll.Vorlage
    lstItem.SubItems(3) = oProtokoll.ProtTyp.Bezeichnung
    lstItem.SubItems(4) = oProtokoll.zpNaechterAufruf

    If Not oProtokoll.zpAktiv Then
      lstItem.SmallIcon = 1
    Else
      Select Case oProtokoll.zpStatus
        Case 0: lstItem.SmallIcon = 2
        Case 1: lstItem.SmallIcon = 3
        Case 2: lstItem.SmallIcon = 4
        Case Else: lstItem.SmallIcon = 1
      End Select
    End If

  Next oProtokoll
End Sub

Attribute VB_Name = "V_ZeitplanDetail"
Attribute VB_Base = "0{745B0F2D-F44F-4109-8E7C-3843445A73EB}{2C65724D-D925-4621-B96C-80CE9B86B1FA}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


'===================================================================================================
'V_ZeitplanDetail
'Oliver Seidel 14.07.2000
'
'
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private moProtokoll As C_Protokoll
Private mboOK       As Boolean

'---------------------------------------------------------------------------------------------------
Public Property Get ok() As Boolean
  ok = mboOK
End Property

'---------------------------------------------------------------------------------------------------
Public Property Set Protokoll(oProtokoll As C_Protokoll)
  Set moProtokoll = oProtokoll
  Call ProtokollAnzeigen
End Property

'---------------------------------------------------------------------------------------------------
Public Property Get Protokoll() As C_Protokoll
  
Dim n As Long

  moProtokoll.Bezeichnung = txtBezeichnung.Text
  n = cboProtTyp.ListIndex
  moProtokoll.ProtTyp.Bezeichnung = cboProtTyp.List(n, 0)
  moProtokoll.ProtTyp.ID = cboProtTyp.List(n, 1)
  moProtokoll.Vorlage = txtVorlage.Text
  moProtokoll.Drucken = chkDrucken
  moProtokoll.Speichern = chkSpeichern
  
  moProtokoll.zpIntervall = spnIntervallAnz.value
  moProtokoll.zpIntEinheit = cboIntervallEinheit.ListIndex + 1
  moProtokoll.zpNaechterAufruf = dtpDatum + dtpZeit
  moProtokoll.zpAktiv = chkAktiv
  moProtokoll.zpFilePath = txtFilePath.Text 'ICSGEAD
  
  If chkMail.value Then
    If cboMailVerteiler.ListIndex >= 0 Then
      moProtokoll.zpMailVerteiler = cboMailVerteiler.List(cboMailVerteiler.ListIndex, 1)
    End If
  Else
    moProtokoll.zpMailVerteiler = 0
  End If
  moProtokoll.zpHTML = chkHTML
  If optAktuell Then
    moProtokoll.Zeitbereich = 1
  Else
    moProtokoll.Zeitbereich = 0
  End If
  
  Set Protokoll = moProtokoll
  
End Property
'ICSGEAD IM 115373
Private Sub BrowseButton_Click()

Dim sfolderPath  As String

  sfolderPath = GetDirectory(GetResText(21208))
  If Len(sfolderPath) > 0 Then
    txtFilePath.Text = sfolderPath
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnAbbruch_Click()
  mboOK = False
  Me.Hide
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnOK_Click()
  If EingabenPruefen Then
    mboOK = True
    Me.Hide
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub btnPfad_Click()

Dim vDatei      As Variant
Dim sDatei      As String
Dim sDateiTypen As String
Dim asTmp()     As String
Dim n           As Integer

  Call SetCurrentDirectory(ProjektPfad & "\" & VERZ_VORLAGE)
  'ICSGEAD
  sDateiTypen = GetResText(21204) & " (*.xltm), *.xltm" & "," & GetResText(21204) & " (*.xlt), *.xlt"
  vDatei = Application.GetOpenFilename(sDateiTypen, , GetResText(21124), , False)
  If Not IsNumeric(vDatei) Then
    sDatei = vDatei
    If Len(sDatei) > 0 Then
      Call StrToArray(asTmp, sDatei, "\")
      For n = UBound(asTmp) To 1 Step -1
        If (LCase(asTmp(n)) = LCase(VERZ_VORLAGE)) Then
          Exit For
        End If
        If (n = UBound(asTmp)) Then
          sDatei = asTmp(n)
        Else
          sDatei = asTmp(n) + "\" + sDatei
        End If
      Next n
      txtVorlage = sDatei
    End If
  End If
  cboProtTyp.SetFocus
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboIntervallEinheit_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub cboProtTyp_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
  Select Case KeyCode
    Case 9, 13, 18, 38, 40
    Case Else
      KeyCode = 0
      Shift = 0
  End Select
End Sub

Private Sub chkMail_Click()

Dim n As Long
  
  If chkMail Then
    cboMailVerteiler.Enabled = True
    If moProtokoll.zpMailVerteiler > 0 Then
      For n = 1 To cboMailVerteiler.ListCount
        If cboMailVerteiler.List(n - 1, 1) = moProtokoll.zpMailVerteiler Then
          cboMailVerteiler.ListIndex = n - 1
          Exit For
        End If
      Next n
    End If
  Else
    cboMailVerteiler.ListIndex = -1
    cboMailVerteiler.Enabled = False
  End If
  
End Sub

Private Sub chkSpeichern_Click()
'ICSGEAD
   txtFilePath.Enabled = chkSpeichern.value
   BrowseButton.Enabled = chkSpeichern.value
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub spnIntervallAnz_Change()
  If txtIntervallAnz <> spnIntervallAnz.value Then
    txtIntervallAnz = spnIntervallAnz.value
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub txtIntervallAnz_BeforeUpdate(ByVal cancel As MSForms.ReturnBoolean)
  
  If IsNumeric(txtIntervallAnz.Text) Then
    spnIntervallAnz.value = CLng(txtIntervallAnz.Text)
  Else
    cancel = True
    txtIntervallAnz.Text = spnIntervallAnz.value
  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub chkAktiv_Click()
    
  imgAktiv.Visible = chkAktiv
  imgInaktiv.Visible = Not chkAktiv

End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_Initialize()

Dim alId() As Long
Dim asBezeichnung() As String
Dim asMailVerteiler() As String
Dim n As Long

  Call FormularBeschriften(Me)
  
  mboOK = False
  Set moProtokoll = New C_Protokoll
  
  cboProtTyp.Clear
  Call getProtTypBezeichner(alId, asBezeichnung)
  For n = 1 To UBound(alId)
    cboProtTyp.AddItem
    cboProtTyp.List(n - 1, 0) = asBezeichnung(n)
    cboProtTyp.List(n - 1, 1) = alId(n)
  Next n
  If cboProtTyp.ListCount > 0 Then
    cboProtTyp.ListIndex = 0
  End If
  
  chkSpeichern = True
  txtFilePath.Text = ProjektPfad 'ICSGEAD
  
  cboMailVerteiler.Clear
  Call getMailVerteilerBezeichner(alId, asBezeichnung)
  For n = 1 To UBound(alId)
    cboMailVerteiler.AddItem
    cboMailVerteiler.List(n - 1, 0) = asBezeichnung(n)
    cboMailVerteiler.List(n - 1, 1) = alId(n)
  Next n
  If cboMailVerteiler.ListCount > 0 Then
    cboMailVerteiler.ListIndex = 0
  End If
  chkMail.value = False
  
  For n = 1 To TXT_ZEIT_EINHEIT_ANZ
    cboIntervallEinheit.AddItem GetResText(TXT_ZEIT_EINHEIT_BEGINN + n)
  Next n
  cboIntervallEinheit.ListIndex = 3
  
  dtpDatum.Format = dtpShortDate
  dtpDatum.value = Date + 1
  
  dtpZeit.Format = dtpTime
  dtpZeit.value = 0.25
  
  imgInaktiv.Top = imgAktiv.Top
  imgInaktiv.Left = imgAktiv.Left
  imgAktiv.Visible = False
  imgInaktiv.Visible = True
  
  optAbgeschlossen = True
  
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub UserForm_QueryClose(cancel As Integer, CloseMode As Integer)
  If CloseMode = vbFormControlMenu Then
    cancel = True
  End If
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub ProtokollAnzeigen()

Dim n As Long

  txtBezeichnung.Text = moProtokoll.Bezeichnung
  cboProtTyp.Text = moProtokoll.ProtTyp.Bezeichnung
  txtVorlage.Text = moProtokoll.Vorlage
  
  chkDrucken = moProtokoll.Drucken
  chkSpeichern = moProtokoll.Speichern
  
  If moProtokoll.zpIntervall > 0 Then
    spnIntervallAnz = moProtokoll.zpIntervall
    cboIntervallEinheit = GetResText(TXT_ZEIT_EINHEIT_BEGINN + moProtokoll.zpIntEinheit)
  End If
  
  dtpDatum = Format(moProtokoll.zpNaechterAufruf, "Short Date")
  dtpZeit = Format(moProtokoll.zpNaechterAufruf, "Long Time")
  
  chkAktiv = moProtokoll.zpAktiv
  
  If moProtokoll.zpMailVerteiler > 0 Then
    chkMail.value = True
'    cboMailVerteiler.Enabled = True
'    For n = 1 To cboMailVerteiler.ListCount
'      If cboMailVerteiler.List(n - 1, 1) = moProtokoll.zpMailVerteiler Then
'        cboMailVerteiler.ListIndex = n - 1
'        Exit For
'      End If
'    Next n
  Else
    chkMail.value = False
    cboMailVerteiler.ListIndex = -1
    cboMailVerteiler.Enabled = False
  End If

  chkHTML = moProtokoll.zpHTML
  If moProtokoll.Zeitbereich = 1 Then
    optAktuell.value = True
  Else
    optAbgeschlossen.value = True
  End If

'ICSGEAD start IM 115373

txtFilePath.Enabled = chkSpeichern.value

If moProtokoll.zpFilePath = "" Then
 txtFilePath.Text = ProjektPfad
Else
 txtFilePath.Text = moProtokoll.zpFilePath
End If

'ICSGEAD End

End Sub

'---------------------------------------------------------------------------------------------------
Private Function EingabenPruefen() As Boolean
  
  EingabenPruefen = False
  If Len(txtBezeichnung.Text) = 0 Then
    Call MsgBox(lblBezeichnung.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    txtBezeichnung.SetFocus
    Exit Function
  End If
  
  If Len(txtVorlage.Text) = 0 Then
    Call MsgBox(lblVorlage.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    txtVorlage.SetFocus
    Exit Function
  End If
  
  If Dir(ProjektPfad & "\" & VERZ_VORLAGE & "\" & txtVorlage) = "" Then
    Call MsgBox(GetResText(21123), vbCritical + vbOKOnly, GetResText(20104))
    txtVorlage.SetFocus
    Exit Function
  End If
  
  If cboProtTyp.ListIndex = -1 Then
    Call MsgBox(lblProtTyp.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    cboProtTyp.SetFocus
    Exit Function
  End If
  
  If cboIntervallEinheit.ListIndex = -1 Then
    Call MsgBox(lblIntervall.Caption & Chr(13) & _
                GetResText(21148), vbCritical + vbOKOnly, GetResText(20104))
    cboIntervallEinheit.SetFocus
    Exit Function
  End If
  
  If chkAktiv And Not chkDrucken And Not chkSpeichern And Not chkMail And Not chkHTML Then
    Call MsgBox(GetResText(21153), vbCritical + vbOKOnly, GetResText(20104))
    chkDrucken.SetFocus
    Exit Function
  End If
  
  EingabenPruefen = True
  
End Function

Attribute VB_Name = "mGlobals"
' _________________________________________________________________
'
'   Projekt:    PCS 7 Powerrate
'   Copyright (c) Siemens AG 2008. All rights reserved. Confidential.
' _________________________________________________________________
'
'   Modul:              mGlobals.bas
'
'   Autor:              Ralf Leistner /A&D SE DE21
'   Datum:              20.10.2008
'   Version:            V 1.00
' _________________________________________________________________
'
'   Funktion:           Globale Konstanten und Methoden
' ________________________________________________________________________
'
'   Aenderungshistorie:
'
'   Autor:
'   Datum:
'   Version:
'   Funktion:
'
'--------------------------------------------------------------------
Option Explicit

Option Compare Text

'**********************************************************
'                Definition von Konstanten
'**********************************************************
Private Const c_ModulName = "mGlobals"

Public Const SHALLICHECKLICENSE = "Yes"

'################## EXCEL ##################################################################
Public Const MAX_ROW As Long = 65530    'Maximale Zeilenanzahl (war mal auf 65536)
Public Const MAX_DATA As Long = 65520   'Maximale Datenanzahl (Muss immer mindestens (ROW_DATA_START - 1) kleiner sein als MAX_ROW
Public Const MAX_COL As Integer = 256

'################## PRE REPORTING ##########################################################
Public Const REPORTS_FOLDER_DEFAULT As String = "reports\"
Public Const CONFIG_FOLDER As String = "\config\"

Public Const PRE_ARCHIVE_NAME As String = "pre"
Public Const PRE_USERARCHIVE_NAME As String = "PRE_SUMC_"
Public Const PRE_REPORTS_PREFIX_ACTION As String = "PRE_Reports_"
Private Const ACTION_FILETYPE As String = ".pas"

Public Const WINCC_HOST As String = "WINCCHOST"
Public Const WINCC_DATABASE As String = "WINCCDATABASE"
Public Const WINCC_VERSION_REGPATH As String = "HKEY_LOCAL_MACHINE\SOFTWARE\Siemens\AUTSW\WinCC\TechnVersion"

Public Const REPORT_FILE_ENDING As String = "_yymmdd_hhmm.xls"

Public Const INTERPOLATION_ENERGYEXPORT As Integer = 0
Public Const INTERPOLATION_CCR As Integer = 1
Public Const INTERPOLATION_DCR As Integer = 2

Public Const PRE_ENDING_C_VARIABLE As String = ".C"
Public Const PRE_ENDING_S_VARIABLE As String = ".S"
Public Const PRE_ENDING_V_VARIABLE As String = ".V"

Public Const AGG_TIME_NONE As Long = 0
Public Const AGG_TIME_MINUTE As Long = 60
Public Const AGG_TIME_HOUR As Long = 3600
Public Const AGG_TIME_SHIFT As Long = 28800
Public Const AGG_TIME_DAY As Long = 86400
Public Const AGG_TIME_WEEK As Long = 604800
Public Const AGG_TIME_MONTH As Long = 2592000
Public Const AGG_TIME_YEAR As Long = 31536000

Public Const DATAREADING_WORKBOOK As String = "PRE_Reports.xlt"
'Public Const RAW_DATA_SHEET As String = "RawData"
Public Const RAW_DATA_SHEET_INDEX As Integer = 1
'Public Const DERIVED_DATA_SHEET As String = "DerivedData"
Public Const DERIVED_DATA_SHEET_INDEX As Integer = 2
'Public Const CONSUMPTION_SHEET As String = "Table"
Public Const CONSUMPTION_SHEET_INDEX As Integer = 4
'Public Const CHART_SHEET As String = "Chart"
Public Const CHART_SHEET_INDEX As Integer = 3
'Public Const DURATION_CURVE_SHEET As String = "DurationCurve"
Public Const DURATION_CURVE_SHEET_INDEX As Integer = 5
'Public Const TIME_RELATED_SHEET As String = "TimeRelatedSheet"
Public Const TIME_RELATED_SHEET_INDEX As Integer = 6
'Public Const CHARGE_RELATED_SHEET As String = "ChargeRelatedSheet"
Public Const CHARGE_RELATED_SHEET_INDEX As Integer = 7
'Public Const TEMP_SHEET As String = "temp"
Public Const TEMP_SHEET_INDEX As Integer = 8
Public Const TEMP2_SHEET_INDEX As Integer = 9

Public Const LEN_DATE_TIME As Integer = 21
Public Const LEN_NUMBER As Integer = 16

Public Const TIME_AS_LOCAL As Boolean = False
Public Const TIME_AS_GMT As Boolean = True

'Positions RawDataSheet/DerivedDataSheet
Public Const ROW_DATA_START As Integer = 4
Public Const COL_DATA_START As Integer = 2
Public Const COL_TIMESTAMP As Integer = 1
'Positions Consumption/Charts sheet
Public Const POS_COCE_REPORTNAME As String = "A1"
Public Const POS_TIME_SETTING As String = "A3"
Public Const POS_TIME_START_STR As String = "B5"
Public Const POS_TIME_START_VAL As String = "D5"
Public Const POS_TIME_END_STR As String = "B6"
Public Const POS_TIME_END_VAL As String = "D6"
Public Const POS_TIME_AGGR_STR As String = "B7"
Public Const POS_TIME_AGGR_VAL As String = "D7"
Public Const POS_TIME_COCE As String = "B10"
Public Const POS_TIME_CONS As String = "D10"
Public Const POS_TIME_COST As String = "F10"
'Positions Consumption
Public Const ROW_CONSDATA_START As Integer = 10
Public Const COL_COSTCENTER As Integer = 2
Public Const COL_CONSUMPTION As Integer = 4
Public Const COL_COSTS As Integer = 6
'Positions Charge Raw Data
Public Const COL_CHARGE As Integer = 1
Public Const COL_TIMESTAMPFROM As Integer = 2
Public Const COL_TIMESTAMPTO As Integer = 3
Public Const COL_UNIT As Integer = 4
Public Const COL_ID As Integer = 5
Public Const COL_RECIPENAME As Integer = 6
Public Const COL_VALUE1 As Integer = 7
Public Const COL_UNITVALUE1 As Integer = 8
Public Const COL_TYPEVALUE1 As Integer = 9
Public Const COL_VALUE2 As Integer = 10
Public Const COL_UNITVALUE2 As Integer = 11
Public Const COL_TYPEVALUE2 As Integer = 12
Public Const COL_VALUE3 As Integer = 13
Public Const COL_UNITVALUE3 As Integer = 14
Public Const COL_TYPEVALUE3 As Integer = 15
Public Const COL_VALUE4 As Integer = 16
Public Const COL_UNITVALUE4 As Integer = 17
Public Const COL_TYPEVALUE4 As Integer = 18
Public Const COL_VALUE5 As Integer = 19
Public Const COL_UNITVALUE5 As Integer = 20
Public Const COL_TYPEVALUE5 As Integer = 21
'Positions Time related report sheet
Public Const TR_ROW_DATA_START As Integer = 10
Public Const TR_COL_CHARGE As Integer = 2
Public Const TR_COL_VALUETYPE As Integer = 3
Public Const TR_COL_VALUE As Integer = 4
Public Const TR_COL_VALUEUNIT As Integer = 5
Public Const TR_COL_TIMEFROM As Integer = 4
Public Const TR_COL_TIMETO As Integer = 6
'Positions Charge related report sheet
Public Const POS_FROM As String = "C10"
Public Const POS_TO As String = "D10"
Public Const POS_CONSUMPTION As String = "F10"
Public Const CR_ROW_DATA_START As Integer = 12
Public Const CR_COL_CHARGE As Integer = 2
Public Const CR_COL_TIMEFROM As Integer = 3
Public Const CR_COL_TIMETO As Integer = 4
Public Const CR_COL_VALUETYPE As Integer = 5
Public Const CR_COL_VALUE As Integer = 6
Public Const CR_COL_VALUEUNIT As Integer = 7

'################## FORM CONSTANTS #########################################################
Public Const CNT_TARIFFS As Integer = 2

Public Const SELECTION_NONE As Integer = 0
Public Const SELECTION_ENERGYVALUES As Integer = 1
Public Const SELECTION_CHARGEVALUES As Integer = 2

'Toolbar indexes
Public Const TOOLBAR_SAVE As Integer = 1
Public Const TOOLBAR_NEW As Integer = 3
Public Const TOOLBAR_CCHANGE As Integer = 4
Public Const TOOLBAR_COPY As Integer = 5
Public Const TOOLBAR_DELETE As Integer = 6
Public Const TOOLBAR_REPORT As Integer = 8

'Subcol numbers listviews
Public Const SUBCOL_REPORTTYPE As Integer = 1
Public Const SUBCOL_REPORTPERIOD As Integer = 2
Public Const SUBCOL_TAG_NR_NAME As Integer = 1
Public Const SUBCOL_TAG_NR_UNIT As Integer = 2
Public Const SUBCOL_TAG_NR_COMM As Integer = 3
Public Const SUBCOL_TAG_NR_ARCH As Integer = 4
Public Const SUBCOL_TAG_NR_COCE As Integer = 5
Public Const SUBCOL_TAG_NR_FORM As Integer = 6
Public Const SUBCOL_TAG_NR_ID As Integer = 7
Public Const SUBCOL_CHARGE_NR_ALIAS As Integer = 1
Public Const SUBCOL_CHARGE_NR_NAME As Integer = 2

Public Const OCCURENCE_COMBO_INDEX_MONDAY As Integer = 0
Public Const OCCURENCE_COMBO_INDEX_THUESDAY As Integer = 1
Public Const OCCURENCE_COMBO_INDEX_WEDNESDAY As Integer = 2
Public Const OCCURENCE_COMBO_INDEX_THURSDAY As Integer = 3
Public Const OCCURENCE_COMBO_INDEX_FRIDAY As Integer = 4
Public Const OCCURENCE_COMBO_INDEX_SATURDAY As Integer = 5
Public Const OCCURENCE_COMBO_INDEX_SUNDAY As Integer = 6

'Form constants of report
Public Const RPFORM_TAB_NAMEUNITTYPE As Integer = 0
Public Const RPFORM_TAB_TAGSUSERARCHIVE As Integer = 1
Public Const RPFORM_TAB_REPORTPERIOD As Integer = 2
Public Const RPFORM_TAB_VALIDITYPERIOD As Integer = 3

Public Const RPFORM_COMBOFREQ_NONE As Integer = 0
Public Const RPFORM_COMBOFREQ_DAILY As Integer = 0
Public Const RPFORM_COMBOFREQ_WEEKLY As Integer = 1
Public Const RPFORM_COMBOFREQ_MONTHLY As Integer = 2

Public Const RPFORM_COMBOABSFREQ_ALL As Integer = 0
Public Const RPFORM_COMBOABSFREQ_DAILY As Integer = 1
Public Const RPFORM_COMBOABSFREQ_WEEKLY As Integer = 2
Public Const RPFORM_COMBOABSFREQ_MONTHLY As Integer = 3

Public Const RPFORM_COMBOTRIGGER_MANUAL As Integer = 0
Public Const RPFORM_COMBOTRIGGER_AUTOMATIC As Integer = 1

Public Const RPFORM_COMBOAGGR_NONE As Integer = 0
Public Const RPFORM_COMBOAGGR_HOUR As Integer = 1
Public Const RPFORM_COMBOAGGR_SHIFT As Integer = 2
Public Const RPFORM_COMBOAGGR_DAY As Integer = 3
Public Const RPFORM_COMBOAGGR_WEEK As Integer = 4
Public Const RPFORM_COMBOAGGR_MONTH As Integer = 5
Public Const RPFORM_COMBOAGGR_YEAR As Integer = 6

Public Const RPFORM_COMBOPERIOD_MAN_TIMEINTERVALL As Integer = 0
Public Const RPFORM_COMBOPERIOD_MAN_LASTDAY As Integer = 1
Public Const RPFORM_COMBOPERIOD_MAN_EXPIREDDAY As Integer = 2
Public Const RPFORM_COMBOPERIOD_MAN_LASTWEEK As Integer = 3
Public Const RPFORM_COMBOPERIOD_MAN_EXPIREDWEEK As Integer = 4
Public Const RPFORM_COMBOPERIOD_MAN_LASTMONTH As Integer = 5
Public Const RPFORM_COMBOPERIOD_MAN_EXPIREDMONTH As Integer = 6
Public Const RPFORM_COMBOPERIOD_DAY_TIMEINTERVALL As Integer = 0
Public Const RPFORM_COMBOPERIOD_DAY_LASTDAY As Integer = 1
Public Const RPFORM_COMBOPERIOD_DAY_EXPIREDDAY As Integer = 2
Public Const RPFORM_COMBOPERIOD_WEEK_LASTWEEK As Integer = 0
Public Const RPFORM_COMBOPERIOD_WEEK_EXPIREDWEEK As Integer = 1
Public Const RPFORM_COMBOPERIOD_MONTH_LASTMONTH As Integer = 0
Public Const RPFORM_COMBOPERIOD_MONTH_EXPIREDMONTH As Integer = 1

Public Const RPFORM_COMBOTYPE_ENERGYEXPORT As Integer = 0
Public Const RPFORM_COMBOTYPE_COSTCENTERREPORT As Integer = 1
Public Const RPFORM_COMBOTYPE_DURATIONCURVEREPORT As Integer = 2
Public Const RPFORM_COMBOTYPE_CHARGEEXPORT As Integer = 3
Public Const RPFORM_COMBOTYPE_TIMERELATEDREPORT As Integer = 4
Public Const RPFORM_COMBOTYPE_CHARGERELATEDREPORT As Integer = 5

Attribute VB_Name = "mLanguage"
' _________________________________________________________________
'
'   Projekt:    PCS 7 Powerrate
'   Copyright (c) Siemens AG 2008. All rights reserved. Confidential.
' _________________________________________________________________
'
'   Modul:              mLanguage.bas
'
'   Autor:              Ralf Leistner /A&D SE DE21
'   Datum:              28.10.2008
'   Version:            V 1.00
' _________________________________________________________________
'
'   Funktion:           Sprachverwaltung
' ________________________________________________________________________
'
'   Aenderungshistorie:
'
'   Autor: Wolfram Klebel / ETM
'   Datum: 1.10.09
'   Version: 3.9
'   Funktion: Strings entfernt, die im CCReport bei ETM nicht erforderlich sind
'
'--------------------------------------------------------------------
Option Explicit

Option Compare Text

'**********************************************************
'                Definition von Konstanten
'**********************************************************
Private Const c_ModulName = "mLanguage"
Private Const SM_DBCSENABLED = 42

Public Const LANG_OFFSET_GER As Integer = 1000
Public Const LANG_OFFSET_ENG As Integer = 2000

'################## DICTIONARY #############################################################

'*****Sheet names for Excel*****
'Public Const DCT_SHEETNAME_RAWDATA As Integer = 132
'Public Const DCT_SHEETNAME_DERIVEDDATA As Integer = 133
Public Const DCT_SHEETNAME_COCE_DIAGRAM As Integer = 134
Public Const DCT_SHEETNAME_COCE_TABLE As Integer = 135
'Public Const DCT_SHEETNAME_DURATION As Integer = 136
'Public Const DCT_SHEETNAME_CHARGE_TIME As Integer = 137
'Public Const DCT_SHEETNAME_CHARGE_NAME As Integer = 138

'*****dlgTariffsets*****
'Public Const DCT_DLGTARIFFSETS_CAPTION As Integer = 200
Public Const DCT_DLGTARIFF_ADD_NONAME As Integer = 201
Public Const DCT_DLGTARIFF_WRONG_UNIT As Integer = 202
'Public Const DCT_DLGTARIFF_NOHOLIDAY As Integer = 203
Public Const DCT_DLGTARIFF_WRONGCOST As Integer = 204
'Public Const DCT_DLGTARIFF_PLEASESELHOL As Integer = 205
'Public Const DCT_DLGTARIFF_ASKDELETEHOL1 As Integer = 206
'Public Const DCT_DLGTARIFF_ASKDELETEHOL2 As Integer = 207
Public Const DCT_DLGTARIFF_NOTARIFFSELECTED As Integer = 208
Public Const DCT_DLGTARIFF_ONEWRONGTARIFFSELECTED1 As Integer = 209
Public Const DCT_DLGTARIFF_ONEWRONGTARIFFSELECTED2 As Integer = 210
Public Const DCT_DLGTARIFF_WRONGTARIFFSELECTED As Integer = 211
Public Const DCT_DLGTARIFF_TARIFF24HOURS As Integer = 212
Public Const DCT_DLGTARIFF_TARIFFORDER As Integer = 213
'Public Const DCT_DLGTARIFF_CAPTION_CREATE As Integer = 214
'Public Const DCT_DLGTARIFF_CAPTION_CHANGE As Integer = 215
'Public Const DCT_MONDAY_SHORT As Integer = 216
'Public Const DCT_TUESDAY_SHORT As Integer = 217
'Public Const DCT_WEDNESDAY_SHORT As Integer = 218
'Public Const DCT_THURSDAY_SHORT As Integer = 219
'Public Const DCT_FRIDAY_SHORT As Integer = 220
'Public Const DCT_SATURDAY_SHORT As Integer = 221
'Public Const DCT_SUNDAY_SHORT As Integer = 222
'Public Const DCT_HOLIDAY_SHORT As Integer = 223
Public Const DCT_DLGTARIFF_WRONG_CURRENCY As Integer = 224
Public Const DCT_DLGTARIFF_VALIDITY_ORDER As Integer = 225
Public Const DCT_DLGTARIFF_VALIDITY_INTERSECT As Integer = 226

'*****Report types*****
'Public Const DCT_REPORTTYPE_ENERGYEXPORT As Integer = 400
Public Const DCT_REPORTTYPE_CCREPORT As Integer = 401
'Public Const DCT_REPORTTYPE_DCREPORT As Integer = 402
'Public Const DCT_REPORTTYPE_CHARGEEXPORT As Integer = 403
'Public Const DCT_REPORTTYPE_TRREPORT As Integer = 404
'Public Const DCT_REPORTTYPE_CRREPORT As Integer = 405

'*****Others & PRE*****

Public Const DCT_TOTAL As Integer = 616

Public Const DCT_CONSUMPTION As Integer = 635
Public Const DCT_COST As Integer = 636
Public Const DCT_COSTCENTER As Integer = 637
Public Const DCT_TIMESETTINGS As Integer = 638
Public Const DCT_STARTTIME As Integer = 639
Public Const DCT_ENDTIME As Integer = 640
Public Const DCT_AGGREGATIONTIME As Integer = 641

Public Const DCT_FORMAT_DATETIME As Integer = 900
'Public Const DCT_FORMAT_DATETIME_CHARGE As Integer = 901
Public Const DCT_FORMAT_NUMBER As Integer = 902

'********************************************************************
'                Get String
'********************************************************************
Public Function myLoadResString(TextID As Integer) As String

    On Error GoTo errorHandler
    
    ' Sprachumschaltung de/en ist in der Tabelle realisiert
    myLoadResString = GetResText(TextID + LANG_OFFSET_GER)
    ' myLoadResString = LoadResString(TextID + Config.LanguageOffset)
    Exit Function
    
errorHandler:
    myLoadResString = ""
End Function
Attribute VB_Name = "tabKonfig"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "btnProjektStart, 14, 13, MSForms, CommandButton"


Option Explicit

'---------------------------------------------------------------------------------------------------
Private Sub btnProjektStart_Click()
  Call ReportStart
End Sub


Attribute VB_Name = "xC_Report"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'===================================================================================================
'C_Report
'
'Oliver Seidel
'28.10.98
'
'
'
'Aenderungen: -keine-
'===================================================================================================
Option Explicit

Private WithEvents app As Application
Attribute app.VB_VarHelpID = -1
Private mboSperreSchliessen As Boolean

'---------------------------------------------------------------------------------------------------
Private Sub app_NewWorkbook(ByVal wb As Excel.Workbook)
  'MsgBox "TEST", , "New Workbook"
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub app_WorkbookBeforeSave(ByVal wb As Excel.Workbook, ByVal SaveAsUI As Boolean, cancel As Boolean)

  'On Error GoTo app_WorkbookBeforeSave_Fehler
  If mboSperreSchliessen Then

    Select Case DateiTyp(wb)
    
      Case DATEI_PROJEKT
        
      Case DATEI_VORLAGE
        Call M_Vorlage.Analysieren
        
      Case DATEI_PROTOKOLL
        
    End Select

  End If
  
End Sub

'---------------------------------------------------------------------------------------------------
'Private Sub app_WorkbookBeforeClose(ByVal Wb As Excel.Workbook, Cancel As Boolean)
'
'Dim wbTest        As Workbook
'
'  Call BugMessage("Arbeitsmappe " & ActiveWorkbook.Name & " soll geschlossen werden!", _
'                  "C_Report::app_WorkbookBeforeClose")
'
'  If DateiTyp = DATEI_PROJEKT Then
'
'    Application.ScreenUpdating = False
'    For Each wbTest In Workbooks
'      wbTest.Activate
'      If DateiTyp = DATEI_VORLAGE Or _
'         DateiTyp = DATEI_PROTOKOLL Then
'
'        Call MsgBox("Projekt kann nicht beendet werden, da noch" & Chr(13) & _
'                    "Projektdateien geoeffnet sind!", _
'                    vbOKOnly + vbExclamation, _
'                    "ACHTUNG")
'
'        Application.ScreenUpdating = True
'        Cancel = True
'        Exit Sub
'      End If
'    Next wbTest
'    Wb.Activate
'    Application.ScreenUpdating = True
'    Call M_Report.ReportEnde
'    Cancel = True
'
'  End If
'
'End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Schliessen(Optional ByVal boAenderungenSpeichern As Boolean = True)
  Call BugMessage("Schliesse Workbook " & ActiveWorkbook.Name, "C_Report::Schliessen")
  mboSperreSchliessen = False
  ActiveWorkbook.Close SaveChanges:=boAenderungenSpeichern
  mboSperreSchliessen = True
End Sub

'---------------------------------------------------------------------------------------------------
Public Sub Quit()
  mboSperreSchliessen = False
  app.Quit
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Initialize()
  Call BugMessage("", "C_Report::Class_Initialize")
  Set app = Application
  mboSperreSchliessen = True
End Sub

'---------------------------------------------------------------------------------------------------
Private Sub Class_Terminate()
  Call BugMessage("", "C_Report::Class_Terminate")
  mboSperreSchliessen = False
End Sub
Attribute VB_Name = "xM_test"
'==================================================================================================
'M_test
'
'Oliver Seidel
'28.10.98
'
'
'Aenderungen: -keine-
'==================================================================================================
Option Explicit
Option Private Module




'---------------------------------------------------------------------------------------------------
Sub dummy()

Dim re As Object
Dim v As Variant

Set re = M_PVSS.getReportExt
v = re.rdbCompressionSteps



  MsgBox "Funktion noch nicht implementiert", vbOKOnly, "Achtung"
End Sub

'---------------------------------------------------------------------------------------------------
' Maintenance Funktion / WOKL 12.9.07
Sub xx()
Dim a As String
Dim s As Variant
Dim o As reportExt
Dim com As ComManager
Dim astr() As String


  Dim help As String
  Dim Name As String
  Dim elem As String
  Dim config As String
  Dim detail As String
  Dim num As Long
  Dim fctName As String
  Dim timName As String
  Dim i As Integer
  
  Name = "System1:_mp_Analog1.e1:_offline._1hour_sum._value"
  ' name = "System1:_mp_Analog1.:_offline._277hour_sum._value"
  
  Name = Mid$(Name, InStr(Name, ":") + 1)    ' System weg
  Name = Mid$(Name, InStr(Name, ".") + 1)
  If (InStr(Name, ":") > 1) Then
    elem = Mid$(Name, 1, InStr(Name, ":") - 1)
  Else
    elem = ""
  End If
  config = Mid$(Name, InStr(Name, ":") + 1)
  detail = Mid$(config, InStr(config, ".") + 1)
  detail = Mid$(detail, 1, InStr(detail, ".") - 1)
  
  detail = Mid$(detail, InStr(detail, "_") + 1)
  'On Error Resume Next
  For i = 1 To 5
    help = Mid$(detail, i, 1)
    num = Asc(help)
    If (Asc(help) > 57) Then
      timName = Mid$(detail, i, InStr(detail, "_") - i)
      Exit For
    End If
  Next i
  num = val(detail)
  fctName = Mid$(detail, InStr(detail, "_") + 1)
  

  
End Sub
Sub exportAllModules()

Dim vbComp As VBComponent
Dim dirName As String
Dim i, j As Integer
Dim s As String
Dim ws As Worksheet

  ' Frage nach Verzeichnis
  ' keine Frage
  'MkDir "d:\tmp\compare"
  dirName = "d:\tmp\compare\last"
  MkDir dirName
  
  For Each vbComp In Application.VBE.ActiveVBProject.VBComponents
    With vbComp
      Debug.Print vbComp.Name
      vbComp.Export dirName & "\" & vbComp.Name
    End With
  Next
  
  Open dirName & "\texte.txt" For Output As #1
  Set ws = Sheets("Texte")
  For i = 1 To ws.UsedRange.Rows.Count
    For j = 1 To ws.UsedRange.Columns.Count
      s = s & ws.Cells(i, j).value & ";"
    Next j
    Print #1, s
    s = ""
  Next i
  Close #1
  

End Sub

Sub debugPrintAllNames()

Dim vbComp As Object
Dim dirName As String

 
  For Each vbComp In Application.VBE.ActiveVBProject.VBComponents.VBE.Windows
    With vbComp
      Debug.Print vbComp.Name
    End With
  Next
  

End Sub
'---------------------------------------------------------------------------------------------------
Sub tst()

Dim oProtTyp  As C_ProtokollTyp
Dim dtVon     As Date
Dim dtBis     As Date

  Set oProtTyp = New C_ProtokollTyp
  With oProtTyp
    .IntEinheit = erStunde
    .Intervall = 1
    .PerEinheit = erTag
    .Periode = 1
    .SynchZeit = TimeSerial(8, 0, 0)
  End With
  
'  Call oProtTyp.Zeitbereich(dtVon, dtBis)
'  Debug.Print dtVon, dtBis
  
  dtVon = DateSerial(2000, 10, 28) + 0.25
  Debug.Print dtVon
  Call oProtTyp.Zeitbereich(dtVon, dtBis, True)
  Debug.Print dtVon, dtBis
  
  
End Sub

'---------------------------------------------------------------------------------------------------
Sub TstStyle()

Dim oStyle As C_Style
Dim Style  As Style
Dim StyleCopy As Style
Dim n As Long
Dim i As Integer
Dim asName(6)    As String
Dim alBorder(6)  As Long
Dim v As Variant
Dim b As Border
Dim s As String

  asName(1) = "Oben": alBorder(1) = 9
  asName(2) = "Links": alBorder(2) = xlEdgeLeft
  asName(3) = "Rechts": alBorder(3) = 8
  asName(4) = "Unten": alBorder(4) = 10
  asName(5) = "DiagonalOben": alBorder(5) = xlDiagonalUp
  asName(6) = "DiagonalUnten": alBorder(6) = xlDiagonalDown
  
'  For n = 1 To 6
'
'    Set Style = ThisWorkbook.Styles.Add(asName(n))
'    Style.IncludeNumber = False
'    Style.IncludeFont = False
'    Style.IncludeAlignment = False
'    Style.IncludePatterns = False
'    Style.IncludeProtection = False
'    Style.IncludeBorder = True
'    Style.Borders(alBorder(n)).LineStyle = -4115
'    Style.Borders(alBorder(n)).Weight = 2
'    Style.Borders(alBorder(n)).ColorIndex = 1242548
'    Application.Dialogs(xlDialogApplyStyle).Show asName(n)
'
'  Next n
'
  Debug.Print "Name;BorderNr;Color(Index);Weight;LineStyle"
  For n = 1 To 1
    Set StyleCopy = ThisWorkbook.Styles.Add(asName(n) & "_copy")
    StyleCopy.IncludeBorder = True
    Set Style = ThisWorkbook.Styles(asName(n))
    i = 0
    For Each b In Style.Borders
      i = i + 1
      s = asName(n) & ";" & i & ";"
      
      If b.ColorIndex = xlColorIndexNone Or b.ColorIndex = xlColorIndexAutomatic Then
        s = s & ";(ci);" & b.ColorIndex
        StyleCopy.Borders(i).ColorIndex = b.ColorIndex
      Else
        s = s & ";(c);" & b.Color
        StyleCopy.Borders(i).Color = b.Color
      End If
      s = s & ";" & b.Weight
      StyleCopy.Borders(i).Weight = b.Weight
      s = s & ";" & b.LineStyle
      StyleCopy.Borders(i).LineStyle = b.LineStyle
      Debug.Print s
    Next b
    Debug.Print
    
    
    'Set oStyle = New C_Style
    'Call getStyleFromWb(ThisWorkbook, asName(n), oStyle)
  
  Next n
  
End Sub

Sub tstcolor()

Dim lColor As Long
Dim iRed   As Integer
Dim iGreen As Integer
Dim iBlue  As Integer

  lColor = RGB(0, 0, 0)
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  Debug.Print lColor, iRed, iGreen, iBlue
  
  lColor = RGB(255, 0, 0)
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  Debug.Print lColor, iRed, iGreen, iBlue

  lColor = RGB(0, 255, 0)
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  Debug.Print lColor, iRed, iGreen, iBlue

  lColor = RGB(0, 0, 255)
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  Debug.Print lColor, iRed, iGreen, iBlue

  lColor = RGB(11, 22, 33)
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  Debug.Print lColor, iRed, iGreen, iBlue

  lColor = RGB(127, 128, 129)
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  Debug.Print lColor, iRed, iGreen, iBlue

  lColor = RGB(42, 42, 42)
  Call colorToRGB(lColor, iRed, iGreen, iBlue)
  Debug.Print lColor, iRed, iGreen, iBlue


End Sub


' InQuest injected base64 decoded content
' "{-j|
' "{-j|
' "{-j|
' "{-j|
' "{-j|
' e"{-j|
' eO*H
' Lj)Uz
' -z{-zY^
' ~($z+l
' zjej
' -z{-zY^
' -z{-zY^

INQUEST-PP=macro
