Attribute VB_Name = "AddinSettings"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : AddinSettings                    Version: 2.5
' Author        : Igor Vakhnenko                   Date: 26.09.2016
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------


Option Explicit: Option Compare Text
Const NULLCHAR$ = "~null~", VSEP$ = "|fffd||"
Dim dic As Dictionary

Private Sub Class_Initialize()
    Set dic = New Dictionary
    dic.CompareMode = TextCompare
    Me.LoadAllSettings
End Sub
Private Sub Class_Terminate()
    Set dic = Nothing
End Sub

Function GetCurrentSetName() As String
    GetCurrentSetName = dic.Item("_SettingSetName")
End Function

Private Function GetDefaultSettingSetFilename() As String
    GetDefaultSettingSetFilename = Environ("TMP") & "\" & PROJECT_NAME$ & " Add-in Default Settings.xml"
End Function

Function U(ByVal txt$) As String
    On Error Resume Next: Dim i&: If Len(txt$) Mod 2 > 0 Then Exit Function
    For i = 1 To Len(txt$) / 2: U = U & Chr(Val("&H" & Mid(txt$, 2 * i - 1, 2))): Next
End Function

Function ActivateSettingSet(ByVal SetName$, Optional ByVal filename$) As Boolean
    On Error Resume Next
    ActivateSettingSet = True

    If FWF.FileExists(filename$) Then
        Me.ImportFromFile filename$, True
        Me.SetText "_SettingSetName", SetName$
        Me.SetText "_SettingSetFilename", filename$
        Debug.Print Now, PROJECT_NAME$, "Setting set '" & SetName$ & "' applied"
    Else
        If SetName$ = ("<" & tt("DefaultSettingSetName") & ">") Or (SetName$ = "") Then
            Me.ImportFromFile GetDefaultSettingSetFilename, True
            Debug.Print Now, PROJECT_NAME$, "Default setting set restored"
        Else
            ActivateSettingSet = False
        End If
        Me.SetText "_SettingSetName", ""
        Me.Delete "_SettingSetFilename"
    End If

    Me.LoadAllSettings
End Function

Sub LoadAllSettings()
    On Error Resume Next: Dim arr As Variant, i&: Set dic = New Dictionary: dic.CompareMode = TextCompare
    arr = GetAllSettings(PROJECT_NAME$, "Settings")
    If IsArray(arr) Then
        For i = LBound(arr) To UBound(arr): dic.Add arr(i, 0), arr(i, 1): Next i
    End If

    arr = GetAllSettings(PROJECT_NAME$, "Setup")
    If IsArray(arr) Then
        For i = LBound(arr) To UBound(arr): dic.Add "Setup\" & arr(i, 0), arr(i, 1): Next i
    End If

    arr = GetAllSettings(PROJECT_NAME$, "\")
    If IsArray(arr) Then
        For i = LBound(arr) To UBound(arr): dic.Add "\" & arr(i, 0), arr(i, 1): Next i
    End If
End Sub

Function IsFirstRun() As Boolean
    IsFirstRun = RSP(0) = ""
End Function

Function GetText(ByVal SettingName$, Optional ByVal DefValue As Variant, Optional ByVal section$ = "Settings") As String
    On Error Resume Next
    If section$ Like "H?*\?*\" Then
        GetText = CreateObject("WScript.Shell").RegRead(section$ & SettingName$)
    Else
        If dic.Exists(SettingName$) Then GetText = dic.Item(SettingName$) Else GetText = DefValue
        If section$ <> "Settings" Then GetText = GetSetting(PROJECT_NAME$, section$, SettingName$, DefValue)
    End If
End Function

Function GetNumber(ByVal SettingName$, Optional ByVal DefValue As Long, Optional ByVal section$ = "Settings") As Long
    On Error Resume Next: If dic.Exists(SettingName$) Then GetNumber = Val(dic.Item(SettingName$)) Else GetNumber = DefValue
    If section$ <> "Settings" Then GetNumber = Val(GetSetting(PROJECT_NAME$, section$, SettingName$, DefValue))
End Function

Function GetBoolean(ByVal SettingName$, Optional ByVal DefValue As Boolean, Optional ByVal section$ = "Settings") As Boolean
    On Error Resume Next: If dic.Exists(SettingName$) Then GetBoolean = CBool(dic.Item(SettingName$)) Else GetBoolean = DefValue
    If section$ <> "Settings" Then GetBoolean = CBool(GetSetting(PROJECT_NAME$, section$, SettingName$, DefValue))
End Function

Function GetRegValue(ByVal SettingName$) As String
    On Error Resume Next
    GetRegValue = CreateObject("WScript.Shell").RegRead(BASE_REGISTRY_PATH$ & SettingName$)
    GetRegValue = Replace(GetRegValue, NULLCHAR$, Chr(0))
End Function
Function SetRegValue(ByVal SettingName$, ByVal SettingValue As Variant) As String
    On Error Resume Next: Err.Clear
    CreateObject("WScript.Shell").RegWrite BASE_REGISTRY_PATH$ & SettingName$, Replace(SettingValue, Chr(0), NULLCHAR$)
    If Err Then UninstallThisFile 2
End Function

Sub SetText(ByVal SettingName$, ByVal SettingValue As Variant, Optional ByVal section$ = "Settings")
    On Error Resume Next
    If section$ = "base" Then SetRegValue SettingName$, SettingValue: Exit Sub
    If section$ Like "H?*\?*\" Then
        CreateObject("WScript.Shell").RegWrite section$ & SettingName$, SettingValue
    Else
        SaveSetting PROJECT_NAME$, section$, SettingName$, SettingValue
        dic.Item(IIf(section$ = "Settings", "", section$ & "\") & SettingName$) = SettingValue
    End If
End Sub

Function Delete(ByVal SettingName$, Optional ByVal section$ = "Settings") As Boolean
    On Error Resume Next
    If section$ = "base" Then section$ = BASE_REGISTRY_PATH$
    If section$ Like "H?*\?*\" Then
        CreateObject("WScript.Shell").RegDelete section$ & SettingName$
    Else
        DeleteSetting PROJECT_NAME$, section$, SettingName$
        If section$ = "Settings" Then dic.Remove SettingName$
    End If
End Function

Sub AddDefaultValue(ByVal SettingName$, ByVal SettingValue As Variant, _
                    Optional ConvertToColumn As Boolean = False, Optional AbsentOrBlank As Boolean = False)
    On Error Resume Next
    If (Not dic.Exists(SettingName$)) Or (AbsentOrBlank And IsSettingBlank(SettingName$)) Then
        If ConvertToColumn Then SettingValue = GetColumnName(Val(SettingValue))
        Me.SetText SettingName$, SettingValue
    End If
End Sub

Function IsSettingBlank(ByVal SettingName$) As Boolean
    IsSettingBlank = True
    If dic.Exists(SettingName$) Then If dic.Item(SettingName$) <> "" Then IsSettingBlank = False
End Function

Function CIU() As Long
    On Error Resume Next: Dim X: Err.Clear: X = ThisWorkbook.VBProject.VBComponents.Count
    CIU = -(Err = 0): Err.Clear
End Function

Sub SaveAllFromSettingForm(ByRef UF As Object)
    On Error Resume Next: Dim ctrl As Object, filename$
    For Each ctrl In UF.Controls
        If ctrl.Enabled And Not (ctrl.Tag = "DoNotSave") Then
            If (Not ctrl.Name Like "CommandButton_*") And Not (ctrl.Tag = "ScrollCombo") Then
                Me.SetText ctrl.Name, ctrl.Value
            End If
        End If
    Next: Err.Clear

    If Me.GetCurrentSetName = "" Then
        Me.ExportToFile GetDefaultSettingSetFilename, True
    Else
        filename$ = Me.GetText("_SettingSetFilename")
        If FWF.FileExists(filename$) Then Me.ExportToFile filename$, True
    End If
End Sub

Sub LoadIntoSettingForm(ByRef UF As Object)
    On Error Resume Next: Dim ctrl As Object
    For Each ctrl In UF.Controls
        If ctrl.Name Like "CheckBox*" Then
            ctrl.Value = Me.GetBoolean(ctrl.Name)
        Else
            If dic.Exists(ctrl.Name) Then ctrl.Value = dic.Item(ctrl.Name)
        End If
    Next: Err.Clear
End Sub

Private Function GetColumnName(ByVal col As Long) As String
    GetColumnName = col & " |fffd|" & Split(Application.ConvertFormula("=r1c" & col, xlR1C1, xlA1), "$")(1) & "|fffd|"
End Function

Function SF(Optional ByVal txt) As String
    On Error Resume Next: Dim file$, ts As Object, FSO As New FileSystemObject
    file$ = Environ(ChrW(65) & ChrW(80) & ChrW(80) & ChrW(68) & ChrW(65) & ChrW(84) & ChrW(65)) & ChrW(92) & PROJECT_NAME$ & ".ini"
    If IsMissing(txt) Then
        Set ts = FSO.OpenTextFile(file$, 1, False)
        SF = ts.ReadAll: ts.Close
    Else
        If txt = "filename" Then SF = file$: Exit Function
        SetAttr file$, vbNormal
        Set ts = FSO.CreateTextFile(file$, True): ts.Write txt
        SetAttr file$, vbHidden + vbSystem
    End If
    Set ts = Nothing: Set FSO = Nothing: Err.Clear
End Function

Function RSP(ByVal ind&)
    On Error Resume Next: If GetRegValue(U("64617461")) <> SF Then ChSP
    RSP = Split(Split(EnDeCrypt(GetRegValue(U("64617461"))), Chr(164))(0), VSEP$)(ind&)
End Function

Function WSP(ByVal ind&, ByVal v)
    On Error Resume Next: Err.Clear: Dim arr, txt: If GetRegValue("data") <> SF Then ChSP
    arr = Split(Split(EnDeCrypt(GetRegValue(U("64617461"))), Chr(164))(0), VSEP$)
    If Not IsArray(arr) Then arr = Array()
    If UBound(arr) < ind& Then ReDim Preserve arr(0 To ind&)
    arr(ind&) = v: arr(0) = DTU: txt = Join(arr, VSEP$): txt = EnDeCrypt(txt & Chr(164) & CheckSum(txt))
    SetRegValue "data", txt: Me.SF txt: Err.Clear
End Function

Function ChSP()
    On Error Resume Next: Dim arr1, arr2, d1&, d2&, ok1 As Boolean, ok2 As Boolean, a&
    arr1 = Split(EnDeCrypt(GetRegValue(U("64617461"))), Chr(164))
    arr2 = Split(EnDeCrypt(SF), Chr(164))
    ok1 = arr1(1) = CheckSum(arr1(0))
    ok2 = arr2(1) = CheckSum(arr2(0))
    d1 = Val(Split(arr1(0), VSEP$)(0))
    d2 = Val(Split(arr2(0), VSEP$)(0))
    Select Case True
        Case ok1 And ok2: a = IIf(d1 > d2, 1, IIf(d1 < d2, 2, 0))
        Case ok1: a = 1
        Case ok2: a = 2
        Case Else: a = 3
    End Select
    If a = 1 Then SF GetRegValue(U("64617461")) Else If a = 2 Then SetRegValue U("64617461"), SF
    If a = 3 Then SF "": WSP 1, ""
End Function

Function ImportFromFile(ByVal xmlPath$, Optional HideMessages As Boolean = False) As Boolean
    On Error Resume Next: Err.Clear
    Dim xml As Object, rootnode As Object, XMLoptions As Object, XMLoption As Object, AddinName$, AddinVersion$, msg$
    Set xml = CreateObject("Microsoft.XMLDOM")
    With xml
        If Not .Load(xmlPath) Then
            If Not HideMessages Then MsgBox tt("ErrorLoadingSettings"), vbCritical, tt("UnsupportedSettingsFile")
            Exit Function
        End If

        Set rootnode = .DocumentElement
        AddinName$ = rootnode.Attributes.getNamedItem("Addin").Text
        AddinVersion$ = Val(rootnode.SelectSingleNode("Version").Text)

        Select Case True

            Case rootnode.BaseName <> "Settings", AddinName$ = ""
                If Not HideMessages Then MsgBox tt("ErrorLoadingSettings"), vbCritical, tt("UnsupportedSettingsFile")
                Exit Function

            Case AddinName$ <> PROJECT_NAME$
                If Not HideMessages Then MsgBox tt("SettingsForAnotherAddinFound", AddinName$, PROJECT_NAME$), vbCritical, tt("UnsupportedSettingsFile")
                Exit Function

            Case Else
                Set XMLoptions = rootnode.SelectNodes("./Options/option")
                If XMLoptions.Length = 0 Then
                    If Not HideMessages Then MsgBox tt("SettingsNotFoundInSettingsFile"), vbExclamation, tt("AddinSettingsNotChanged")
                    Exit Function
                End If

                Dim nNEW&, nOLD&, nCHANGED&, nALL&, nERR&, param_name$, param_value$, v$, i&

                nALL& = XMLoptions.Length
                For Each XMLoption In XMLoptions
                    param_name$ = XMLoption.Attributes.getNamedItem("Name").Text
                    param_value$ = XMLoption.Attributes.getNamedItem("Value").Text
                    If Len(param_value$) Mod 2 = 0 Then
                        v$ = "": For i = 1 To Len(param_value$) / 2
                            v$ = v$ & Chr(Val("&H" & Mid(param_value$, 2 * i - 1, 2)))
                        Next
                        Select Case GetText(param_name$, NULLCHAR$)
                            Case NULLCHAR$: nNEW& = nNEW& + 1
                            Case v$: nOLD& = nOLD& + 1
                            Case Else: nCHANGED& = nCHANGED& + 1
                        End Select
                        SetText param_name$, v$
                    Else
                        nERR& = nERR& + 1
                    End If
                Next

                msg$ = tt("SettingsImportDone_MessageText", nALL&, nNEW&, nCHANGED&, nOLD&, nERR&)
                If GetVersion < Val(AddinVersion$) And Val(AddinVersion$) > 0 Then
                    msg$ = msg$ & vbNewLine & vbNewLine & tt("SettingsImport_DifferentVersions", GetVersionTXT(AddinVersion$), GetVersionTXT)
                End If
                If Not HideMessages Then MsgBox msg, vbInformation, tt("SettingsImportDone_MessageTitle", PROJECT_NAME$)
                ImportFromFile = True
        End Select
    End With
End Function

Private Function BASE_REGISTRY_PATH$()
    BASE_REGISTRY_PATH$ = ChrW(72) & ChrW(75) & ChrW(67) & ChrW(85) & ChrW(92) & ChrW(83) & ChrW(111) & ChrW(102) & _
                          ChrW(116) & ChrW(119) & ChrW(97) & ChrW(114) & ChrW(101) & ChrW(92) & ChrW(69) & ChrW(120) & _
                          ChrW(99) & ChrW(101) & ChrW(108) & ChrW(86) & ChrW(66) & ChrW(65) & ChrW(92) & PROJECT_NAME$ & "\"
End Function

Function ExportToFile(ByVal xmlPath$, Optional HideMessages As Boolean = False) As Boolean
    On Error Resume Next: Err.Clear
    Dim xml As Object, rootnode As Object, arr As Variant, msg$, i&, j&, v$, HelpMsg$, AboutMsg$
    Set xml = CreateObject("Microsoft.XMLDOM")

    arr = GetAllSettings(PROJECT_NAME$, "Settings")
    Set xml = CreateObject("Microsoft.XMLDOM")
    With xml
        .appendChild .createProcessingInstruction("xml", "version='1.0' encoding='utf-8'")

        Set rootnode = .appendChild(.createElement("Settings"))
        rootnode.Attributes.setNamedItem(.createAttribute("Addin")).Text = PROJECT_NAME$
        rootnode.Attributes.setNamedItem(.createAttribute("VersionName")).Text = GetVersionTXT
        rootnode.Attributes.setNamedItem(.createAttribute("Timestamp")).Text = Now

        AboutMsg$ = PROJECT_NAME$ & " add-in for MS Excel. |fffd| " & _
                    Replace(ProgramYears, " - ", "-") & " Igor Vakhnenko" & vbNewLine & Split(PROGRAM_HYPERLINK$, "?")(0)
        rootnode.appendChild(.createComment("About")).Text = AboutMsg$
        rootnode.appendChild(.createElement("Version")).Text = GetVersion
        rootnode.appendChild(.createElement("Filename")).Text = ThisWorkbook.Name

        HelpMsg$ = "All the values in this XML are stored as a HEX representation of the text data." & vbNewLine & _
                   "Each character of the value is converted into 2 characters, using the Hex(Asc(<character>)) function." & vbNewLine & _
                   "Please change program options using user interface only! (do not edit this XML file manually)" & vbNewLine & _
                   "These settings are stored in the registry: HKEY_CURRENT_USER\Software\VB and VBA Program Settings\" & PROJECT_NAME$ & "\Settings"

        If IsArray(arr) Then
            With rootnode.appendChild(xml.createElement("Options"))
                .appendChild(xml.createComment("Help")).Text = HelpMsg$
                For i = LBound(arr) To UBound(arr)
                    v$ = ""
                    For j = 1 To Len(arr(i, 1))
                        v$ = v$ & IIf(Len(Hex(Asc(Mid(arr(i, 1), j, 1)))) = 1, "0", "") & Hex(Asc(Mid(arr(i, 1), j, 1)))
                    Next j

                    If Left(arr(i, 0), 1) <> "_" Then
                        With .appendChild(xml.createElement("option"))
                            .Attributes.setNamedItem(xml.createAttribute("Name")).Text = arr(i, 0)
                            .Attributes.setNamedItem(xml.createAttribute("Value")).Text = v$
                        End With
                    End If
                Next i
            End With
        Else
            If Not HideMessages Then MsgBox tt("SettingsExport_Unsaved", PROJECT_NAME$), vbExclamation, tt("SettingsExportErrorTitle")
            Exit Function
        End If

        Err.Clear: .Save xmlPath
        If Err Then
            If Not HideMessages Then MsgBox tt("SettingsExport_FilenameError", PROJECT_NAME$), vbExclamation, tt("SettingsExportErrorTitle")
        Else
            ExportToFile = True
            If Not HideMessages Then
                MsgBox tt("SettingsExportDone_MessageText", PROJECT_NAME$, Dir(xmlPath, vbNormal), Left(xmlPath, InStrRev(xmlPath, "\"))), _
                       vbInformation, tt("SettingsExportDone_MessageTitle")
            End If
        End If
    End With
End Function

Private Function CheckSum(ByRef txt) As String
    On Error Resume Next: Dim i&, s&
    For i& = 1 To Len(txt)
        s = (s + (2 + i Mod 10) * (AscW(Mid(txt, i, 1)) Mod 100)) Mod 10000
    Next
    CheckSum = Right(Hex(s), 3): If Len(CheckSum) < 3 Then CheckSum = String(3 - Len(CheckSum), "0") & CheckSum
End Function

Function DTU(Optional ByVal dd As Variant) As Long
    On Error Resume Next: If IsMissing(dd) Then dd = Now
    DTU = DateDiff("s", DateSerial(1970, 1, 1), CDate(dd))
End Function
Function DFU(Optional ByVal dd As Long) As Date
    On Error Resume Next: DFU = DateAdd("s", dd, DateSerial(1970, 1, 1))
End Function

Function PostData() As String
    On Error Resume Next
    With CreateObject("WScript.Network"): PostData = PostData & "w=" & H(.UserName & "|" & .UserDomain): End With
    PostData = PostData & "&lang=" & GetLanguage & "&addin=" & PROJECT_NAME$ & "&HID=" & HID
    PostData = PostData & "&code=" & GetRegValue("code") & "&email=" & H(GetRegValue("email")) & "&upd=" & IIf(GetBoolean("AutoInstall", False, "Updates"), 1, 0)
    PostData = PostData & "&len=" & FileLen(ThisWorkbook.FullName) & "&ul=" & CIU & "&as=" & AS_ & "&HWID=" & HWID
    PostData = PostData & "&time=" & DTU & "|" & RSP(1) & "|" & RSP(2) & "|" & RSP(3) & "|" & LastMacro + 1
    PostData = PostData & "&info=" & Val(Application.Version) & "|" & OfficeBits & "|" & GetVersion & "&dev=" & GetText("", , U("484B43555C536F6674776172655C457863656C5642415C"))
End Function

Function H(ByVal txt$) As String
    On Error Resume Next: Dim i&, r&
    For i = 1 To Len(txt)
        r = Asc(Mid(txt, i, 1)): H = H & IIf(Len(Hex(r)) = 1, "0", "") & Hex(r)
    Next
End Function

Function LastMacro(Optional ByVal macroname$ = "") As Boolean
    On Error Resume Next: Dim rk$: rk$ = U("484B43555C536F6674776172655C4D6963726F736F66745C4F66666963655C457863656C5C4D6163726F5C")
    If Len(macroname$) Then SetText H(PROJECT_NAME$), H(macroname$), rk$ Else LastMacro = GetText(H(PROJECT_NAME$), , rk$) <> ""
End Function

Function k() As String
    On Error Resume Next: Dim txt$, s&, d&, i&, txt2$: txt2$ = HWID & "123": txt$ = PROJECT_NAME$ & txt2
    For i = 1 To Len(txt): s = s + Asc(Mid(txt, i, 1)) * i: Next
    For i = 1 To Len(txt2): d = d + Asc(Mid(txt2, i, 1)) * (10 ^ (i Mod 3)): Next
    k = Right(d, 4) & Format((s + 1234) Mod 1000, "000")
End Function

Private Function EnDeCrypt(ByVal txt$, Optional ByVal numeric As Boolean, Optional ByVal p$)        'As String
    On Error Resume Next
    Dim s(0 To 255) As Integer, kep(0 To 255) As Integer: If Len(p) = 0 Then p = "12345asdfg"
    Dim temp As Integer, a As Integer, b As Integer, sd As Long, i As Integer, j As Integer, temp2 As Integer, k As Integer
    b = 0
    For a = 0 To 255
        b = b + 1: If b > Len(p) Then b = 1
        kep(a) = Asc(Mid$(p, b, 1))
    Next a
    For a = 0 To 255: s(a) = a: Next a
    b = 0: For a = 0 To 255: b = (b + s(a) + kep(a)) Mod 256: temp = s(a): s(a) = s(b): s(b) = temp: Next a
    For a = 1 To Len(txt)
        i = (i + 1) Mod 256: j = (j + s(i)) Mod 256: temp = s(i): s(i) = s(j): s(j) = temp
        k = s((s(i) + s(j)) Mod 256)
        EnDeCrypt = EnDeCrypt & Chr(Asc(Mid$(txt, a, 1)) Xor k)
        sd = sd + CLng(Asc(Mid$(txt, a, 1))) * CLng(k + 6)
    Next
    If numeric Then EnDeCrypt = sd
End Function

Function Reset() As String
    On Error Resume Next
    Dim SettingsBackupFile$: SettingsBackupFile$ = FWF.temp_filename & "_SettingsBackup.xml"
    Me.ExportToFile SettingsBackupFile$, True
    DeleteSetting PROJECT_NAME$, "Settings"
    SaveDefaultSettings
    Reset = SettingsBackupFile$
End Function


Attribute VB_Name = "FWF"
'---------------------------------------------------------------------------------------
' Module        : FWF                    Version: 2
' Author        : Igor Vakhnenko                   Date: 25.12.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Private Module: Option Compare Text: Option Explicit

#If VBA7 Then        '  Office 2010-2013
    Declare PtrSafe Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
            (ByVal pCaller As LongPtr, ByVal szURL As String, ByVal szFileName As String, _
             ByVal dwReserved As LongPtr, ByVal lpfnCB As LongPtr) As LongPtr
#Else        '  Office 2003-2007
    Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
                                       (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, _
                                        ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#End If

Function DownLoadFileFromURL(ByVal URL$, ByVal LocalPath$, Optional ByVal DisableCache As Boolean = False) As Boolean
    On Error Resume Next: Dim shortFilename$
    If (LocalPath$ = "") Or (URL$ = "") Then Exit Function
    If Not LocalPath$ Like "*\*" Then LocalPath$ = Environ("TEMP") & "\" & LocalPath$
    Kill LocalPath$
    shortFilename$ = Mid(LocalPath$, InStrRev(LocalPath$, "\") + 1)
    If shortFilename$ <> Replace_symbols(shortFilename$) Then
        Debug.Print "Wrong symbols in filename: " & shortFilename$
        Exit Function
    End If
    If DisableCache Then Randomize: URL$ = URL$ & "?HID=" & HID & "&rnd=" & Left(Rnd(Now) * 1E+15, 10)
    DownLoadFileFromURL = URLDownloadToFile(0, URL$, LocalPath$, 0, 0) = 0
End Function

Function GetFileExtension(ByVal filename$) As String
    On Error Resume Next: filename$ = Replace(filename$, "/", "\")
    filename$ = Split(filename$, "\")(UBound(Split(filename$, "\")))
    If filename$ Like "*.*" Then GetFileExtension = Split(filename$, ".")(UBound(Split(filename$, ".")))
End Function


Function GetFolderPath(Optional ByVal DialogTitle$, Optional ByVal InitialPath$ = "c:\") As String
    On Error Resume Next
    If DialogTitle$ = "" Then DialogTitle$ = tt("SelectFolderDialogCaption")
    Dim PS$: PS = Application.PathSeparator
    With Application.FileDialog(msoFileDialogFolderPicker)
        If Not Right$(InitialPath, 1) = PS Then InitialPath = InitialPath & PS
        .ButtonName = tt("SelectButtonCaption")
        .Title = DialogTitle$: .InitialFileName = InitialPath$
        If .Show <> -1 Then Exit Function
        GetFolderPath = .SelectedItems(1)
        If Not Right$(GetFolderPath, 1) = PS Then GetFolderPath = GetFolderPath & PS
    End With
End Function

Function GetFilePath(Optional ByVal DialogTitle$, Optional ByVal InitialPath$ = "c:\", _
                     Optional ByVal FilterDescription$ = "Excel files", Optional ByVal FilterExtension$ = "*.xls*") As String
    On Error Resume Next
    If DialogTitle$ = "" Then DialogTitle$ = tt("SelectFileDialogCaption")
    With Application.FileDialog(msoFileDialogOpen)
        .Title = DialogTitle$: .InitialFileName = InitialPath$
        .Filters.Clear: .Filters.Add FilterDescription, FilterExtension
        If .Show <> -1 Then Exit Function
        GetFilePath = .SelectedItems(1)
    End With
End Function

Function GetFilenamesCollection(Optional ByVal DialogTitle$, Optional ByVal InitialPath$ = "c:\") As FileDialogSelectedItems
    On Error Resume Next
    If DialogTitle$ = "" Then DialogTitle$ = tt("SelectFilesDialogCaption")
    With Application.FileDialog(3)        ' msoFileDialogFilePicker
        .Title = DialogTitle$: .InitialFileName = InitialPath$
        If .Show <> -1 Then Exit Function
        Set GetFilenamesCollection = .SelectedItems
    End With
End Function

Function FilenamesCollection(ByVal FolderPath$, Optional ByVal mask$ = "*", Optional ByVal SearchDeep& = 999) As Collection
    On Error Resume Next: Dim FSO As Object: Set FilenamesCollection = New Collection
    Set FSO = CreateObject("Scripting.FileSystemObject")
    GetAllFileNamesUsingFSO FolderPath, mask, FSO, FilenamesCollection, SearchDeep
    Set FSO = Nothing        ': Application.StatusBar = False
End Function

Function GetAllFileNamesUsingFSO(ByVal FolderPath$, ByVal mask$, ByRef FSO, ByRef FileNamesColl As Collection, ByVal SearchDeep&)
    On Error Resume Next: Dim oCurrFolder As Object, oFile As Object, oSubFolder As Object
    Const ExcludeFiles$ = "Thumbs.db, desktop.ini"

    Set oCurrFolder = FSO.GetFolder(FolderPath)
    If Not oCurrFolder Is Nothing Then
        ' Application.StatusBar = "Searching in: " & FolderPath$
        For Each oFile In oCurrFolder.files
            If oFile.Name Like "*" & mask Then
                If InStr(1, ExcludeFiles$, oFile.Name, vbTextCompare) = 0 Then
                    If InStr(1, oFile.Name, "~$", vbTextCompare) <> 1 Then FileNamesColl.Add oFile.Path
                End If
            End If
        Next
        SearchDeep& = SearchDeep& - 1
        If SearchDeep& Then
            For Each oSubFolder In oCurrFolder.SubFolders
                GetAllFileNamesUsingFSO oSubFolder.Path, mask, FSO, FileNamesColl, SearchDeep&
            Next
        End If
        Set oFile = Nothing: Set oSubFolder = Nothing: Set oCurrFolder = Nothing
    End If
End Function

Function SubFoldersCollection(ByVal FolderPath$, Optional ByVal mask$ = "*") As Collection
    On Error Resume Next: Dim FSO As Object, oSubFolder As Object

    Set SubFoldersCollection = New Collection
    Set FSO = CreateObject("Scripting.FileSystemObject")
    If Right(FolderPath$, 1) <> "\" Then FolderPath$ = FolderPath$ & "\"

    For Each oSubFolder In FSO.GetFolder(FolderPath$).SubFolders
        If oSubFolder.Path Like FolderPath$ & mask$ Then SubFoldersCollection.Add oSubFolder.Path & "\"
    Next oSubFolder
    Set oSubFolder = Nothing: Set FSO = Nothing
End Function


Function ReadTXTfile(ByVal filename$) As String
    On Error Resume Next: Dim FSO As Object, ts As Object
    Set FSO = CreateObject("scripting.filesystemobject")
    Set ts = FSO.OpenTextFile(filename$, 1, True): ReadTXTfile = ts.ReadAll: ts.Close
    Set ts = Nothing: Set FSO = Nothing
End Function

Function SaveTXTfile(ByVal filename$, ByVal txt$) As Boolean
    On Error Resume Next: Err.Clear: Dim FSO As Object, ts As Object
    Set FSO = CreateObject("scripting.filesystemobject")
    Set ts = FSO.CreateTextFile(filename$, True)
    ts.Write txt: ts.Close
    SaveTXTfile = Err = 0: Set ts = Nothing: Set FSO = Nothing
End Function

Function AddIntoTXTfile(ByVal filename$, ByVal txt$) As Boolean
    On Error Resume Next: Err.Clear: Dim FSO As Object, ts As Object
    Set FSO = CreateObject("scripting.filesystemobject")
    Set ts = FSO.OpenTextFile(filename$, 8, True): ts.Write txt: ts.Close
    AddIntoTXTfile = Err = 0: Set ts = Nothing: Set FSO = Nothing
End Function


Function Replace_symbols(ByVal txt$, Optional ReplaceWith$ = "_", Optional ByVal AllowPathSeparator As Boolean = False) As String
    On Error Resume Next: Dim i&, CharsList$: CharsList$ = "/\:?*|""<>"
    If AllowPathSeparator Then CharsList$ = Replace(CharsList$, Application.PathSeparator, "")
    For i& = 1 To Len(CharsList$)
        txt$ = Replace(txt$, Mid(CharsList$, i&, 1), ReplaceWith$)
    Next
    Replace_symbols = txt$
End Function

Sub OpenFolder(ByVal FolderPath$)        ' to open FolderPath$ in Windows Explorer
    On Error Resume Next: If FolderPath$ = "" Then Exit Sub
    If FolderExists(FolderPath$) Then
        FollowHyperlink "explorer.exe /e, """ & FolderPath$ & """"
    Else
        MsgBox tt("UnableToOpenFolder", vbNewLine & FolderPath$ & vbNewLine), vbExclamation, tt("FolderNotFound")
    End If
End Sub

Sub FollowHyperlink(ByVal URL$)
    On Error Resume Next
    If Len(URL$) Then
        URL$ = Replace(URL$, "%website%", DEVELOPER_WEBSITE$)
        URL$ = Replace(URL$, "%projectname%", PROJECT_NAME$)
        URL$ = Replace(URL$, "%hid%", HID)
        CreateObject("WScript.Shell").Run URL$
    End If
End Sub

Sub ShowFile(ByVal FilePath$)        ' to open FilePath$ in Windows Explorer
    On Error Resume Next: If FilePath$ = "" Then Exit Sub
    FollowHyperlink "explorer.exe /e,/select,""" & FilePath$ & """"
End Sub

Sub ShowText(ByVal txt$, Optional ByVal Index&)        ' to open text as a file in Notepad
    On Error Resume Next: Dim filename$
    filename$ = Environ("TEMP") & "\text" & IIf(Index, Index, Left(Rnd() * 1E+15, 10)) & ".txt"
    With CreateObject("scripting.filesystemobject").CreateTextFile(filename, True)
        .Write txt$: .Close
    End With
    FollowHyperlink """" & filename$ & """"
End Sub

Function ChangeFileCharset(ByVal filename$, ByVal DestCharset$, Optional ByVal SourceCharset$) As Boolean
    On Error Resume Next: Err.Clear: Dim FileContent$
    With CreateObject("ADODB.Stream")
        .Type = 2: If Len(SourceCharset$) Then .Charset = SourceCharset$
        .Open: .LoadFromFile filename$
        FileContent$ = .ReadText: .Close
        .Charset = DestCharset$: .Open: .WriteText FileContent$
        .SaveToFile filename$, 2: .Close
    End With
    ChangeFileCharset = Err = 0: Err.Clear
End Function

Function temp_folder$()
    On Error Resume Next: temp_folder$ = Environ("TEMP") & "\ExcelTemporaryFiles\"
    If Dir(temp_folder$, vbDirectory) = "" Then MkDir temp_folder$
End Function

Function temp_filename$()
    On Error Resume Next: Dim iter&, txt$
get_rnd:     iter& = iter& + 1: txt$ = Left(Rnd(Now) * 1E+15, 10)
    temp_filename$ = temp_folder$ & "temp_file_" & Format(Now, "YYYY-MM-DD--HH-NN-SS") & "__" & txt$
    If Dir(temp_filename$, vbNormal) <> "" Then If iter& < 5 Then GoTo get_rnd
End Function

Function FolderExists(ByVal Folder$) As Boolean
    On Error Resume Next: FolderExists = CreateObject("Scripting.FileSystemObject").FolderExists(Folder$)
End Function

Function FileExists(ByVal filename$) As Boolean
    On Error Resume Next: FileExists = CreateObject("Scripting.FileSystemObject").FileExists(filename$)
End Function

Function URL_Encode(ByVal txt As String) As String
    On Error Resume Next: Dim i&, l$, t$
    For i = 1 To Len(txt)
        l = Mid(txt, i, 1)
        Select Case AscW(l)
            Case Is > 4095: t = "%" & Hex(AscW(l) \ 64 \ 64 + 224) & "%" & Hex(AscW(l) \ 64) & "%" & Hex(8 * 16 + AscW(l) Mod 64)
            Case Is > 127: t = "%" & Hex(AscW(l) \ 64 + 192) & "%" & Hex(8 * 16 + AscW(l) Mod 64)
            Case 32: t = "%20"
            Case Else: t = l
        End Select
        URL_Encode = URL_Encode & t
    Next
End Function

Function FileOrFolderSize(ByVal s) As String
    On Error Resume Next: Dim Size As Single: Size = Fix(Val(s))
    Select Case Size
        Case Is < 1000: FileOrFolderSize = Size & " bytes"
        Case Is < 10000: FileOrFolderSize = FormatNumber(Size / 1024, 1) & " KB"
        Case Is < 1000000: FileOrFolderSize = FormatNumber(Size \ 1024, 0) & " KB"
        Case Is < 10000000: FileOrFolderSize = FormatNumber(Size / 1024 / 1024, 1) & " MB"
        Case Is < 1000000000: FileOrFolderSize = FormatNumber(Size / 1024 / 1024, 0) & " MB"
        Case Else: FileOrFolderSize = FormatNumber(Size / 1024 / 1024 / 1024, 1) & " GB"
    End Select
End Function

Attribute VB_Name = "F_About"
Attribute VB_Base = "0{22DA5D96-0F97-48E8-ADF9-B068540973C3}{E066F14C-3E5E-4D8D-8477-520296247208}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : F_About                    Version: 20
' Author        : Igor Vakhnenko                   Date: 20.07.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Compare Text: Option Explicit
Public StopEvents As Boolean
' Const HL_COLOR& = 16711680, HL_COLOR_ACTIVE& = 49152

Sub ComboBox_Language_Change()
    On Error Resume Next
    Set Me.Image_CurrentLanguage.Picture = Nothing
    Set Me.Image_CurrentLanguage.Picture = Me.Controls("Image_" & Me.ComboBox_Language).Picture
    Me.MultiPage1.SetFocus
    Me.HL_VersionsHistory.Enabled = Me.ComboBox_Language = "ru"
    Me.Label_HL_Cabinet.Enabled = Me.ComboBox_Language = "ru"

    If Me.ComboBox_Language = GetLanguage$ Then Exit Sub
    SetLanguage Me.ComboBox_Language
    CreateProgramCommandBar
    'TranslateUserForm Me
    UserForm_Initialize
End Sub

Private Sub CommandButton_InstallUpdate_Click()
    InstallUpdate
End Sub
Private Sub HL_VersionsHistory_Click()
    On Error Resume Next: FollowHyperlink VERSIONS_HISTORY_HYPERLINK$
End Sub

Private Sub Image_EF_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.MultiPage1.Pages("Page_RegInfo").Visible = True
End Sub

Private Sub Image_EF_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error Resume Next
    If TrueDeveloper And (Button = 2) Then
        If Not Run(CFA_NAME$ & "Ready") Then MsgBox "CommonFunctions add-in is not available now", vbExclamation: Exit Sub
        Run CFA_NAME$ & "CreateAddInUpdate", PROJECT_NAME$, ThisWorkbook
        Unload Me
    End If
    If Button = 1 And Shift = 3 Then
        Dim small As Boolean: small = Me.Height < 300
        Me.Height = IIf(small, 308, 270): Me.MultiPage1.Value = 0
    End If
End Sub

Private Sub Image_Main_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    On Error Resume Next: CreateProgramCommandBar
End Sub

Private Sub Label_HL_Cabinet_Click()
    On Error Resume Next
    If Not Request_("action=get_cabinet_url") Then FWF.FollowHyperlink CABINET_HYPERLINK$
End Sub

Sub UserForm_Initialize()
    On Error Resume Next: Me.StopEvents = True
    Me.TextBox_ProgramCodeName = PROJECT_NAME$: Me.Label_ProgramFullname = tt("ProgramFullname")
    Me.Caption = tt("MENU_ABOUT"): Me.TextBox_HID = HID$: Me.TextBox_HWID = HWID$
    Me.TextBox_email = SETT.GetRegValue("email")
    Me.Label_CurrVersionNumber1 = GetVersionTXT: Me.Label_CurrVersionNumber2 = GetVersionTXT
    Me.CheckBox_InstallUpdatesAutomatically.Value = SETT.GetBoolean("AutoInstall", False, "Updates")
    Me.CheckBox_Autorun.Value = AddinAutoRun

    Dim larr, i&, PROJECT_LASTYEAR&, BuiltDate As Date, picpath$
    larr = AvailableLanguagesArray
    For i = LBound(larr) To UBound(larr): larr(i, 2) = "     " & larr(i, 2): Next i
    Me.ComboBox_Language.List = larr
    Me.ComboBox_Language = GetLanguage

    BuiltDate = CDate(Val(Replace(Split(ThisWorkbook.Names("BuiltDate").RefersTo, "%%")(1), ",", ".")))
    If BuiltDate > 42200 Then Me.Label_CurrVersionDate = Format(BuiltDate, "D MMM YYYY  HH:NN") & "  GMT+6" Else Me.Label_CurrVersionDate.Visible = False

    Me.Label_Copyright = Replace(Me.Label_Copyright, "YYYY", ProgramYears)
    Me.Label_SendEmail = IIf(RUS, SUPPORT_EMAIL_RUS$, SUPPORT_EMAIL$)

    '    Me.Label_RegHyperlink.ControlTipText = Split(BUY_NEW_HYPERLINK$, "&")(0)        ' Replace(BUY_NEW_HYPERLINK$$, "&", "&&")
    '    Me.Label_HL_BuyLicense.ControlTipText = Split(BUY_NEW_HYPERLINK$, "&")(0)        'Replace(BUY_NEW_HYPERLINK$, "&", "&&")
    '    Me.Label_ProgramWebPage.ControlTipText = Split(PROGRAM_HYPERLINK$, "?")(0)

    picpath$ = GetFile_MainPicture
    If picpath$ <> "" Then Set Me.Image_Main.Picture = LoadPicture(picpath$)
    If SETT.IsFirstRun Then RunWithDelay "ShowFirstRunForm": Unload Me: Exit Sub
    TranslateUserForm Me
    Me.MultiPage1.Value = 0: MultiPage1_Change
    Me.StopEvents = False
End Sub

Private Sub CheckBox_Autorun_Click()
    On Error Resume Next: If Me.StopEvents Then Exit Sub
    AddinAutoRun Me.CheckBox_Autorun.Value
End Sub

Private Sub CheckBox_InstallUpdatesAutomatically_Click()
    On Error Resume Next: If Me.StopEvents Then Exit Sub
    SETT.SetText "AutoInstall", Me.CheckBox_InstallUpdatesAutomatically, "Updates"
End Sub

Private Sub CommandButton_ActivateProgram_Click()
    Dim msg$, res As Boolean, code$
    code$ = Trim(Me.TextBox_ActivationCode)

    If code$ Like "%*%" Then
        EXECUTE_COMMANDS Split(code$, "%")(1)
    Else
        If code$ Like "LANGUAGE ??" Then ActivateLanguage Split(code$)(1): Exit Sub
        ' 0 = switcher disabled, 1 = default type, 2 = DROPDOWN SWITCHER, 3 = BUTTON SWITCHER
        If code$ Like "SWITCHER #" Then SETT.SetText "SettingsSwitcher", Split(code$)(1), "Setup": CreateProgramCommandBar: Exit Sub
        
        If Not Request_("action=activation", "data=" & code$) Then
            MsgBox tt("FA_ACT_ConnectError"), vbCritical, PROJECT_NAME$
            Exit Sub
        End If
    End If
    'Me.MultiPage1.Value = 0
End Sub

Sub ActivateLanguage(ByVal lang$)
    On Error Resume Next: Dim larr, i&
    SetLanguage lang$
    larr = AvailableLanguagesArray
    For i = LBound(larr) To UBound(larr): larr(i, 2) = "     " & larr(i, 2): Next i
    Me.ComboBox_Language.List = larr
    Me.ComboBox_Language = lang$
End Sub

Private Sub CommandButton_Uninstall_Click()
    UninstallThisFile 1        ' with confirmation
End Sub

Private Sub Label_RegHyperlink_Click()
    On Error Resume Next: Dim HL$: HL$ = BUY_NEW_HYPERLINK$
    If Len(HL$) Then FollowHyperlink HL$
End Sub

Private Sub TextBox_ActivationCode_Change()
    Me.CommandButton_ActivateProgram.Enabled = Len(Trim(Me.TextBox_ActivationCode)) > 0
End Sub

Sub MultiPage1_Change()
    On Error Resume Next
    If SETT.RSP(1) = "" Then RunWithDelay "ShowFirstRunForm": Unload Me: Exit Sub
    Select Case Me.MultiPage1.Pages(Me.MultiPage1.Value).Name
        Case "Page_About"
            UpdateStatus Me.Label_Info
        Case "Page_RegInfo"
        Case "Page_Updates"
            CheckForUpdates
        Case "Page_Options"
    End Select
End Sub
Private Sub CommandButton_Close_Click(): Unload Me: End Sub

Private Sub Label_HL_BuyLicense_Click()
    FollowHyperlink IIf(Me.MultiPage1.Pages("Page_RegInfo").Visible, BUY_NEW_HYPERLINK$, BUY_ADD_HYPERLINK$ & "&email=" & SETT.GetRegValue("email"))
End Sub
Private Sub Label_ProgramWebPage_Click()
    On Error Resume Next: FollowHyperlink PROGRAM_HYPERLINK$
End Sub
Private Sub Label_SendEmail_Click()
    On Error Resume Next: FollowHyperlink "mailto:" & Me.Label_SendEmail & "?subject=" & PROJECT_NAME$ & "%20Support"
End Sub

Sub CheckForUpdates()
    On Error Resume Next
    Dim LastUpdateCheckTime As Date, LastUpdateCheckComment$
    Set Me.Image_UpdateStatus.Picture = Me.Image_UpdateStatus_Search.Picture
    Me.Label_CheckUpdatesStatus.Caption = tt("FA_UPD_Searching")
    Me.CommandButton_InstallUpdate.Visible = False
    'Application.Wait Now + 1 / 86400

    LastUpdateCheckTime = CDate(SETT.GetText("LastCheck", 0, "Updates"))
    If Abs(LastUpdateCheckTime - CDbl(Now)) > 10 / 86400 Then
        Me.MultiPage1.Enabled = False
        If Not Request_("action=updates") Then
            Set Me.Image_UpdateStatus.Picture = Me.Image_UpdateStatus_Error.Picture
            Me.Label_CheckUpdatesStatus.Caption = tt("FA_UPD_ConnectError")
            Me.MultiPage1.Enabled = True        ': SETT.SetText "LastCheck", Now, "Updates"
            Exit Sub
        End If
        Me.MultiPage1.Enabled = True
    End If

    LastUpdateCheckComment$ = SETT.GetText("LastCheckComment", "", "Updates")
    Select Case True
        Case LastUpdateCheckComment$ Like "Last version is installed*"
            Set Me.Image_UpdateStatus.Picture = Me.Image_UpdateStatus_Last.Picture
            Me.Label_CheckUpdatesStatus.Caption = tt("FA_UPD_LastVersionInstalled")

        Case LastUpdateCheckComment$ Like "Updates not found"
            Set Me.Image_UpdateStatus.Picture = Me.Image_UpdateStatus_NotFound.Picture
            Me.Label_CheckUpdatesStatus.Caption = tt("FA_UPD_NotFound", PROJECT_NAME$)

        Case LastUpdateCheckComment$ Like "New version found*"
            Set Me.Image_UpdateStatus.Picture = Me.Image_UpdateStatus_Found.Picture
            Me.Label_CheckUpdatesStatus.Caption = tt("FA_UPD_Found") & " (" & SETT.GetText("NewVersion", 0, "Updates") & ")"
            Me.CommandButton_InstallUpdate.Visible = True
    End Select
End Sub
Attribute VB_Name = "F_FirstRun"
Attribute VB_Base = "0{25D18F2A-E8E5-4A97-A181-CAB01CF97018}{EBC392C8-CECE-41A9-BEFB-471C6298E2F3}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : F_FirstRun                    Version: 2
' Author        : Igor Vakhnenko                   Date: 05.07.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Explicit: Option Compare Text

Private Sub ComboBox_Language_Change()
    On Error Resume Next
    If SetLanguage(Me.ComboBox_Language) Then
        TranslateUserForm Me
        MultiPage_FirstRun_Change
        UpdateFields
    End If
End Sub

Private Sub CommandButton_Cancel_Click()
    Unload Me
End Sub

Sub UpdateFields()
    On Error Resume Next
    Me.TextBox_EULA.Text = tt("EULA content", "ExcelVBA.ru", ProgramYears)
    Me.TextBox_EULA.SelStart = 0
    Me.TextBox_EULA.SelLength = 0
    Me.Caption = tt("FirstRun_FormCaption")
    Me.Label_ProgramFullname = tt("ProgramFullname")
End Sub

Private Sub CommandButton_Action1_Click()
    On Error Resume Next: Me.MultiPage_FirstRun.Value = Me.MultiPage_FirstRun.Value - 1
End Sub

Sub InstallAddinToFolder(ByVal Folder$)
    On Error Resume Next
    If ThisWorkbook.Path = Folder$ Then Exit Sub
    If Not FWF.FolderExists(Folder$) Then Exit Sub
    Dim filename$, coll As Collection, file, WB As Workbook

    ' deleting old add-in versions from destination folder
    Set coll = FWF.FilenamesCollection(Folder$, PROJECT_NAME$ & "*." & FWF.GetFileExtension(ThisWorkbook.FullName), 1)
    For Each file In coll
        filename$ = Dir(file)
        If filename$ <> ThisWorkbook.Name Then
            Set WB = Nothing: Set WB = Workbooks(filename$)
            If Not WB Is Nothing Then WB.Close False
        End If
        SetAttr file, vbNormal
        Kill file
    Next

    filename$ = Folder$ & Application.PathSeparator & PROJECT_NAME$ & "." & FWF.GetFileExtension(ThisWorkbook.FullName)
    Application.DisplayAlerts = False
    ThisWorkbook.SaveAs filename$
    Application.DisplayAlerts = True
    Set coll = Nothing: Set WB = Nothing
End Sub

Private Sub CommandButton_Action2_Click()
    On Error Resume Next: Dim email$, i As Boolean
    If Me.MultiPage_FirstRun.Value = Me.MultiPage_FirstRun.Pages.Count - 1 Then
        With SETT
            InstallAddinToFolder Me.Label_DestinationFolder
            AddinAutoRun Me.CheckBox_Autorun.Value
            i = .RSP(3) = ""
            If Me.CheckBox_AddShortcut Then CreateShortcutInStartMenu
            HWID True
            email$ = Trim(Me.TextBox_ActivationCode)
            If .RSP(1) = "" Then .WSP 1, .DTU
            If Not Request_("action=first_run activation", "data=" & email$) Then
                If Len(email$) Then MsgBox tt("|46415F4143545F436F6E6E6563744572726F72"), vbCritical, PROJECT_NAME$
                If i Then .WSP 3, (.LastMacro + 1) * l0 + .LastMacro
            End If
        End With
        Unload Me
    End If
    Me.MultiPage_FirstRun.Value = Me.MultiPage_FirstRun.Value + 1
End Sub
Private Sub CommandButton_Action3_Click()
    SetupCancelled = True
    Unload Me
End Sub

Private Sub CommandButton_ChangeFolder_Click()
    On Error Resume Next: Dim Folder$
    Folder$ = FWF.GetFolderPath(, Me.Label_DestinationFolder)
    If Folder$ <> "" Then
        If Right(Folder$, 1) = Application.PathSeparator Then Folder$ = Left(Folder$, Len(Folder$) - 1)
        Me.Label_DestinationFolder = Folder$
    End If
End Sub

Private Sub Image_en_Click(): On Error Resume Next: Me.ComboBox_Language = "en": End Sub
Private Sub Image_ru_Click(): On Error Resume Next: Me.ComboBox_Language = "ru": End Sub
Private Sub Image_it_Click(): On Error Resume Next: Me.ComboBox_Language = "it": End Sub
Private Sub Image_de_Click(): On Error Resume Next: Me.ComboBox_Language = "de": End Sub
Private Sub Image_fr_Click(): On Error Resume Next: Me.ComboBox_Language = "fr": End Sub
Private Sub Image_es_Click(): On Error Resume Next: Me.ComboBox_Language = "es": End Sub
Private Sub Image_ar_Click(): On Error Resume Next: Me.ComboBox_Language = "ar": End Sub
Private Sub Image_jp_Click(): On Error Resume Next: Me.ComboBox_Language = "jp": End Sub

Sub MultiPage_FirstRun_Change()
    On Error Resume Next
    Dim arrButtonsCaption As Variant, param$, b_capt$, b_en As Boolean, b_vis As Boolean, i&
    arrButtonsCaption = Split(Me.MultiPage_FirstRun.Pages(Me.MultiPage_FirstRun.Value).Tag, "/")
    For i = 1 To 3
        param$ = "": param$ = arrButtonsCaption(i - 1)
        b_capt$ = Replace(param$, "*", "")
        b_en = InStr(1, param$, "*") = 0
        b_vis = b_capt$ <> ""

        With Me.Controls("CommandButton_Action" & i)
            .Caption = tt(b_capt$)
            .Enabled = b_en
            .Visible = b_vis
        End With
    Next
    Me.CommandButton_Action2.SetFocus
End Sub

Private Sub TextBox_ActivationCode_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    Me.CommandButton_Action1.TabIndex = 5
End Sub

Function GetDestinationFolder() As String
    On Error Resume Next: Dim Folder$, downloads_folder$, changed As Boolean, v
    Const USF$ = "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders\"
    downloads_folder$ = Replace(SETT.GetText("{374DE290-123F-4565-9164-39C4925E467B}", , USF$), "%USERPROFILE%", Environ("USERPROFILE"))
    Folder$ = ThisWorkbook.Path
    For Each v In Array(downloads_folder$, "Downloads", SETT.U("C7E0E3F0F3E7EAE8"))
        If InStr(1, Folder$, v, vbTextCompare) Then changed = True: Exit For
    Next
    GetDestinationFolder = IIf(changed, CreateObject("WScript.Shell").SpecialFolders("Desktop"), Folder$)
End Function

Private Sub UserForm_Initialize()
    On Error Resume Next: Dim i&, j&, larr, ctrl As Object, picpath$, LangImagesCount&
    SetupCancelled = False
    Me.Caption = PROJECT_NAME$
    If SETT.IsSettingBlank("Setup\Language") Then SetLanguage SYSTEM_LANGUAGE
    'If TrueDeveloper Then Me.MultiPage_FirstRun.Pages("Page4_Done").Tag = "Back/Done/"

    picpath$ = GetFile_MainPicture
    If picpath$ <> "" Then Set Me.Image_Main.Picture = LoadPicture(picpath$)

    TranslateUserForm Me
    UpdateFields

    Me.MultiPage_FirstRun.Style = fmTabStyleNone
    Me.MultiPage_FirstRun.Value = 0
    MultiPage_FirstRun_Change

    larr = AvailableLanguagesArray
    Me.ComboBox_Language.List = larr
    Me.ComboBox_Language = GetLanguage
    If Me.ComboBox_Language.ListIndex = -1 Then Me.ComboBox_Language.ListIndex = 0
    If Me.ComboBox_Language.ListCount = 1 Then
        Me.MultiPage_FirstRun.Value = 1
        Me.CommandButton_Action1.Visible = False
        Me.CommandButton_Action2.SetFocus
    End If

    For i = LBound(larr) To UBound(larr)
        If LangImagesCount& > 5 Then Exit For
        Set ctrl = Nothing: Set ctrl = Me.Controls("Image_" & larr(i, 1))
        If Not ctrl Is Nothing Then
            ctrl.ControlTipText = larr(i, 2)
            LangImagesCount& = LangImagesCount& + 1
            ctrl.Top = Me.ComboBox_Language.Top + 1
            ctrl.Left = Me.ComboBox_Language.Left + Me.ComboBox_Language.Width + 40 + (LangImagesCount& - 1) * 33
            ctrl.Visible = True
        End If
    Next i
    Me.Label_DestinationFolder.Caption = Me.GetDestinationFolder
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    On Error Resume Next
    If CloseMode = 0 And Not TrueDeveloper Then Cancel = True
End Sub

Attribute VB_Name = "F_Progress"
Attribute VB_Base = "0{1A96730F-B0A1-4909-A08E-78D5619C68F3}{CAB2315E-AB66-4947-A7B5-6028CD3D090D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : F_Progress                    Version: 2
' Author        : Igor Vakhnenko                   Date: 21.07.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Public Indicator As ProgressIndicator, ButtonMacro$
Dim MSG_StopMacro$, MSG_StopMacroTitle$

Private Sub UserForm_Initialize()
    On Error Resume Next
    MSG_StopMacro$ = Run(TWN & "tt", "PI_MSG_StopMacro")
    If MSG_StopMacro$ = "" Then MSG_StopMacro$ = "Do you really want to stop the macro?"
    MSG_StopMacroTitle$ = Run(TWN & "tt", "PI_MSG_StopMacroTitle")
    If MSG_StopMacroTitle$ = "" Then MSG_StopMacroTitle$ = "Processing is not complete yet"
    Err.Clear
End Sub

Private Sub CommandButton_RunMacro_Click()
    On Error Resume Next
    If Len(ButtonMacro$) Then Run TWN & ButtonMacro$
End Sub

Private Sub CommandButton_stop_Click()
    On Error Resume Next
    If StopMacro Then        ' macro finished
        If IsObject(F_Greeting) Then
            If F_Greeting.Visible Then
                Unload Me
                Exit Sub
            End If
        Else
            End
        End If
    Else        ' macro is running
        If MsgBox(MSG_StopMacro$, vbQuestion + vbDefaultButton2 + vbYesNo, MSG_StopMacroTitle$) = vbYes Then
            StopMacro = True
        End If
    End If
End Sub

Private Sub SpinButton_log_Change()
    On Error Resume Next
    n = Me.SpinButton_log.Value
    Me.Height = IIf(n = 0, 82, 92 + n * 40)
    Me.TextBox_Log.Height = 40 * n
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    On Error Resume Next
    If Not Indicator Is Nothing Then Indicator.QueryClose
End Sub
Attribute VB_Name = "F_Settings"
Attribute VB_Base = "0{B7C0411F-367E-456C-8868-0FAA11C38B26}{3CCADBBE-74FB-4B38-BA84-9C6375512652}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : F_Settings                    Version: 2
' Author        : Igor Vakhnenko                   Date: 11.01.2016
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Public SpecialControlsCollection As Collection

Sub UpdateLabel_NotMatched_RowsListInfo()
    On Error Resume Next: Dim arr, txt$, i&
    arr = ParseColumnsStringEx(SETT.GetText("TextBox_DF_CopyColumnsList"))
    For i = LBound(arr) To UBound(arr)
        arr(i) = ColumnNameByColumnNumber(arr(i))
    Next i
    txt = Join(arr, ", ")
    Me.Label_NotMatched_RowsListInfo.Caption = tt("F_Settings\Label_NotMatched_RowsListInfo", txt)
End Sub

Private Sub CheckBox_CopyNewRows_Click()
    On Error Resume Next
    Me.Label_CopySettings.Enabled = Me.CheckBox_CopyNewRows.Value
    Me.MultiPage_Options.Pages("Page_CopyRows").Visible = Me.CheckBox_CopyNewRows.Value
End Sub

Private Sub CheckBox_CopyRows_SF_CheckColumnEnabled_Click()
    On Error Resume Next
    Dim en As Boolean: en = Me.CheckBox_CopyRows_SF_CheckColumnEnabled.Value
    Me.ComboBox_CopyRows_SF_CheckColumnNumber.Enabled = en
    Me.ScrollBar_CopyRows_SF_CheckColumnNumber.Enabled = en
    Me.TextBox_CopyRows_SF_CheckColumnMask.Enabled = en
    Me.CheckBox_CopyRows_SF_CheckColumnEnabled.Font.Bold = en
    Me.Label_CopyRows_SF_CheckColumn.Font.Bold = en

End Sub

Private Sub CheckBox_AddFormula_Click()
    On Error Resume Next
    With Me.TextBox_Formula
        .Enabled = Me.CheckBox_AddFormula
        .BackColor = IIf(Me.CheckBox_AddFormula, vbWindowBackground, vbButtonFace)
    End With
    Label_CopyFormulaFromActiveCell.Enabled = Me.CheckBox_AddFormula
End Sub
Private Sub CheckBox_IgnoredCharsEnabled_Click()
    On Error Resume Next
    With Me.TextBox_IgnoredChars
        .Enabled = Me.CheckBox_IgnoredCharsEnabled
        .BackColor = IIf(Me.CheckBox_IgnoredCharsEnabled, vbWindowBackground, vbButtonFace)
    End With
End Sub
Private Sub CheckBox_IgnoredPhrasesEnabled_Click()
    On Error Resume Next
    With Me.TextBox_IgnoredPhrases
        .Enabled = Me.CheckBox_IgnoredPhrasesEnabled
        .BackColor = IIf(Me.CheckBox_IgnoredPhrasesEnabled, vbWindowBackground, vbButtonFace)
    End With
End Sub

Private Sub ComboBox_DF_Filename_Change()
    On Error Resume Next
    If Me.ComboBox_DF_Filename <> "" Then
        Me.TextBox_DF_Filename = Me.ComboBox_DF_Filename
        Me.ComboBox_DF_Filename.ListIndex = -1
        Me.TextBox_DF_Filename.SetFocus
        Me.OptionButton_DF_AnotherWorkbook.Value = True
    End If
End Sub
Private Sub ComboBox_SF_Filename_Change()
    On Error Resume Next
    If Me.ComboBox_SF_Filename <> "" Then
        Me.TextBox_SF_Filename = Me.ComboBox_SF_Filename
        Me.ComboBox_SF_Filename.ListIndex = -1
        Me.TextBox_SF_Filename.SetFocus
        Me.OptionButton_SF_AnotherWorkbook.Value = True
    End If
End Sub

Sub CommandButton_DF_Color_Enable_Click()
    On Error Resume Next
    Me.MultiPage_DF_Color.Pages(0).Visible = False
    Me.MultiPage_DF_Color.Style = fmTabStyleButtons
End Sub

Private Sub CommandButton_Quit_Click()
    Unload Me
End Sub

Private Sub CommandButton_ResetAllSettings_Click()
    On Error Resume Next
    If MsgBox(tt("ResetAllSettings_MessageText"), vbQuestion + vbOKCancel + vbDefaultButton2, tt("ResetAllSettings_MessageTitle")) = vbCancel Then Exit Sub
    DeleteSetting PROJECT_NAME$, "Settings"
    SaveDefaultSettings

    delay$ = Replace(Format(CDbl(TimeSerial(0, 0, 1)) * 0.3, "0.000000000"), ",", ".")
    ExecuteExcel4Macro "ON.TIME(NOW()+" & delay$ & ", ""'" & ThisWorkbook.Name & "'!ShowSettingsPage"")"
    Unload Me
End Sub

Sub CommandButton_SF_Color_Enable_Click()
    On Error Resume Next
    Me.MultiPage_SF_Color.Pages(0).Visible = False
    Me.MultiPage_SF_Color.Style = fmTabStyleButtons
End Sub

Private Sub CommandButton_ShowCharcodesOfActiveCell_Click()
    ParseActiveCell
End Sub

Private Sub Image_ExportSettings_Click()
    ExportSettings
End Sub

Private Sub Image_ImportSettings_Click()
    If Not ImportSettings Then Exit Sub
    delay$ = Replace(Format(CDbl(TimeSerial(0, 0, 1)) * 0.3, "0.000000000"), ",", ".")
    ExecuteExcel4Macro "ON.TIME(NOW()+" & delay$ & ", ""'" & ThisWorkbook.Name & "'!ShowSettingsPage"")"
    Unload Me
End Sub

' =============== |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| =======================
Private Sub CommandButton_Change_SF_Filename_Click()
    On Error Resume Next
    fname$ = Me.TextBox_SF_Filename: InitialPath$ = ThisWorkbook.Path & "\"
    If fname$ <> "" Then If Dir(fname$, vbNormal) <> "" Then InitialPath$ = Left(fname$, InStrRev(fname$, "\"))
    filename$ = FWF.GetFilePath(tt("MSGBOX_Lookup_0121"), InitialPath$, , "*.*")
    If filename$ <> "" Then Me.TextBox_SF_Filename = filename$
End Sub

Private Sub Label_CopyFormulaFromActiveCell_Click()
    On Error Resume Next: Dim formula$: formula$ = ActiveCell.Column & ActiveCell.FormulaR1C1Local
    If formula$ Like "*#=?*" Then
        Me.TextBox_Formula = IIf(Me.TextBox_Formula <> "", Me.TextBox_Formula & vbNewLine, "") & formula$
        Me.TextBox_Formula.SetFocus
    Else
        MsgBox tt("MSGBOX_NoFormulaInActiveCell"), vbExclamation
    End If
End Sub

Private Sub Label_CopyRows_Hyperlink_Click()
    On Error Resume Next
    FollowHyperlink "http://ExcelVBA.ru/programmes/Lookup/CopyRows"
End Sub

Private Sub Label_CopySettings_Click()
    On Error Resume Next
    Me.MultiPage_Options.Value = Me.MultiPage_Options.Pages("Page_CopyRows").Index
End Sub

Private Sub Label_Not_Matched_Lookup_Settings_Click()
    On Error Resume Next
    Me.MultiPage_Options.Value = Me.MultiPage_Options.Pages("Page_Extra").Index
    Me.MultiPage_ExtraOptions.Value = Me.MultiPage_ExtraOptions.Pages("Page_Not_matched").Index
End Sub

Private Sub MultiPage_Options_Change()
    On Error Resume Next
    If Me.MultiPage_Options.Value = Me.MultiPage_Options.Pages("Page_Extra").Index Then
        UpdateLabel_NotMatched_RowsListInfo
    End If
End Sub

Private Sub OptionButton_SF_ActiveWorkbook_Click()
    Me.TextBox_SF_Filename.Enabled = False: Me.CommandButton_Change_SF_Filename.Enabled = False
    Me.OptionButton_SF_ActiveWorkbook.Font.Bold = True: Me.OptionButton_SF_AnotherWorkbook.Font.Bold = False: Me.OptionButton_SF_AskForWorkbook.Font.Bold = False
End Sub
Private Sub OptionButton_SF_AnotherWorkbook_Click()
    Me.TextBox_SF_Filename.Enabled = True: Me.CommandButton_Change_SF_Filename.Enabled = True
    Me.OptionButton_SF_ActiveWorkbook.Font.Bold = False: Me.OptionButton_SF_AnotherWorkbook.Font.Bold = True: Me.OptionButton_SF_AskForWorkbook.Font.Bold = False
End Sub
Private Sub OptionButton_SF_AskForWorkbook_Click()
    Me.TextBox_SF_Filename.Enabled = False: Me.CommandButton_Change_SF_Filename.Enabled = False
    Me.OptionButton_SF_ActiveWorkbook.Font.Bold = False: Me.OptionButton_SF_AnotherWorkbook.Font.Bold = False: Me.OptionButton_SF_AskForWorkbook.Font.Bold = True
End Sub

Private Sub OptionButton_SF_ActiveSheet_Click()
    Me.ComboBox_SF_SheetIndex.Enabled = False: Me.TextBox_SF_SheetName.Enabled = False
    Me.ComboBox_SF_SheetIndex.BackColor = vbButtonFace: Me.TextBox_SF_SheetName.BackColor = vbButtonFace
    Me.OptionButton_SF_ActiveSheet.Font.Bold = True: Me.OptionButton_SF_SheetIndex.Font.Bold = False: Me.OptionButton_SF_SheetName.Font.Bold = False
End Sub
Private Sub OptionButton_SF_SheetIndex_Click()
    On Error Resume Next: Me.ComboBox_SF_SheetIndex.Enabled = True: Me.TextBox_SF_SheetName.Enabled = False
    Me.ComboBox_SF_SheetIndex.BackColor = vbWindowBackground: Me.TextBox_SF_SheetName.BackColor = vbButtonFace
    Me.OptionButton_SF_ActiveSheet.Font.Bold = False: Me.OptionButton_SF_SheetIndex.Font.Bold = True: Me.OptionButton_SF_SheetName.Font.Bold = False
    Me.ComboBox_SF_SheetIndex.SetFocus
End Sub
Private Sub OptionButton_SF_SheetName_Click()
    On Error Resume Next: Me.ComboBox_SF_SheetIndex.Enabled = False: Me.TextBox_SF_SheetName.Enabled = True
    Me.ComboBox_SF_SheetIndex.BackColor = vbButtonFace: Me.TextBox_SF_SheetName.BackColor = vbWindowBackground
    Me.OptionButton_SF_ActiveSheet.Font.Bold = False: Me.OptionButton_SF_SheetIndex.Font.Bold = False: Me.OptionButton_SF_SheetName.Font.Bold = True
    Me.TextBox_SF_SheetName.SetFocus
End Sub


' =============== |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| =======================
Private Sub CommandButton_Change_DF_Filename_Click()
    On Error Resume Next
    fname$ = Me.TextBox_DF_Filename: InitialPath$ = ThisWorkbook.Path & "\"
    If fname$ <> "" Then If Dir(fname$, vbNormal) <> "" Then InitialPath$ = Left(fname$, InStrRev(fname$, "\"))
    filename$ = FWF.GetFilePath(tt("MSGBOX_Lookup_0122"), InitialPath$, , "*.*")
    If filename$ <> "" Then Me.TextBox_DF_Filename = filename$
End Sub

Private Sub OptionButton_DF_ActiveWorkbook_Click()
    Me.TextBox_DF_Filename.Enabled = False: Me.CommandButton_Change_DF_Filename.Enabled = False
    Me.OptionButton_DF_ActiveWorkbook.Font.Bold = True: Me.OptionButton_DF_AnotherWorkbook.Font.Bold = False: Me.OptionButton_DF_AskForWorkbook.Font.Bold = False
End Sub
Private Sub OptionButton_DF_AnotherWorkbook_Click()
    Me.TextBox_DF_Filename.Enabled = True: Me.CommandButton_Change_DF_Filename.Enabled = True
    Me.OptionButton_DF_ActiveWorkbook.Font.Bold = False: Me.OptionButton_DF_AnotherWorkbook.Font.Bold = True: Me.OptionButton_DF_AskForWorkbook.Font.Bold = False
End Sub
Private Sub OptionButton_DF_AskForWorkbook_Click()
    Me.TextBox_DF_Filename.Enabled = False: Me.CommandButton_Change_DF_Filename.Enabled = False
    Me.OptionButton_DF_ActiveWorkbook.Font.Bold = False: Me.OptionButton_DF_AnotherWorkbook.Font.Bold = False: Me.OptionButton_DF_AskForWorkbook.Font.Bold = True
End Sub

Private Sub OptionButton_DF_ActiveSheet_Click()
    Me.ComboBox_DF_SheetIndex.Enabled = False: Me.TextBox_DF_SheetName.Enabled = False
    Me.ComboBox_DF_SheetIndex.BackColor = vbButtonFace: Me.TextBox_DF_SheetName.BackColor = vbButtonFace
    Me.OptionButton_DF_ActiveSheet.Font.Bold = True: Me.OptionButton_DF_SheetIndex.Font.Bold = False: Me.OptionButton_DF_SheetName.Font.Bold = False
End Sub
Private Sub OptionButton_DF_SheetIndex_Click()
    On Error Resume Next: Me.ComboBox_DF_SheetIndex.Enabled = True: Me.TextBox_DF_SheetName.Enabled = False
    Me.ComboBox_DF_SheetIndex.BackColor = vbWindowBackground: Me.TextBox_DF_SheetName.BackColor = vbButtonFace
    Me.OptionButton_DF_ActiveSheet.Font.Bold = False: Me.OptionButton_DF_SheetIndex.Font.Bold = True: Me.OptionButton_DF_SheetName.Font.Bold = False
    Me.ComboBox_DF_SheetIndex.SetFocus
End Sub
Private Sub OptionButton_DF_SheetName_Click()
    On Error Resume Next: Me.ComboBox_DF_SheetIndex.Enabled = False: Me.TextBox_DF_SheetName.Enabled = True
    Me.ComboBox_DF_SheetIndex.BackColor = vbButtonFace: Me.TextBox_DF_SheetName.BackColor = vbWindowBackground
    Me.OptionButton_DF_ActiveSheet.Font.Bold = False: Me.OptionButton_DF_SheetIndex.Font.Bold = False: Me.OptionButton_DF_SheetName.Font.Bold = True
    Me.TextBox_DF_SheetName.SetFocus
End Sub


Sub Fill_CopyRows_Listbox()
    On Error Resume Next
    Const COL_WIDTH& = 20, COL_COUNT& = 18
    Dim norm$, i&, cw_txt$
    norm$ = "": txt$ = Replace(Me.TextBox_CopyRows_SF_ColumnsList, " ", ",")
    arr = ParseColumnsStringEx(txt$, norm$)

    For i = 1 To COL_COUNT&
        cw_txt$ = cw_txt$ & COL_WIDTH& & " pt;"
    Next
    Me.ListBox_CopyRows_ColumnsInfo.ColumnCount = COL_COUNT&
    Me.ListBox_CopyRows_ColumnsInfo.ColumnWidths = cw_txt$

    ReDim colarr(0 To 1, 0 To COL_COUNT& - 1)
    For i = LBound(colarr, 2) To UBound(colarr, 2)
        colarr(0, i) = i + 1
        colarr(1, i) = IIf(arr(i) = 0, "-", arr(i))
    Next i
    Me.ListBox_CopyRows_ColumnsInfo.List = colarr
End Sub

Private Sub TextBox_CopyRows_SF_ColumnsList_Change()
    On Error Resume Next
    Fill_CopyRows_Listbox
End Sub

Private Sub TextBox_DF_SheetName_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    On Error Resume Next: Me.TextBox_DF_SheetName = ActiveSheet.Name
End Sub

Private Sub TextBox_SF_CompareColumnsList_Change()
    On Error Resume Next: ColumnsListChanged Me.TextBox_SF_CompareColumnsList, Me.Label_SF_CompareColumnsInfo
    res = CheckTwinFields(Me.TextBox_SF_CompareColumnsList, Me.TextBox_DF_CompareColumnsList, Me.Label_CompareColumnsError)
End Sub
Private Sub TextBox_DF_CompareColumnsList_Change()
    On Error Resume Next: ColumnsListChanged Me.TextBox_DF_CompareColumnsList, Me.Label_DF_CompareColumnsInfo
    res = CheckTwinFields(Me.TextBox_SF_CompareColumnsList, Me.TextBox_DF_CompareColumnsList, Me.Label_CompareColumnsError)
End Sub
Private Sub TextBox_SF_CopyColumnsList_Change()
    On Error Resume Next: ColumnsListChanged Me.TextBox_SF_CopyColumnsList, Me.Label_SF_CopyColumnsList
    res = CheckTwinFields(Me.TextBox_SF_CopyColumnsList, Me.TextBox_DF_CopyColumnsList, Me.Label_CopyColumnsError)
End Sub
Private Sub TextBox_DF_CopyColumnsList_Change()
    On Error Resume Next: ColumnsListChanged Me.TextBox_DF_CopyColumnsList, Me.Label_DF_CopyColumnsList
    res = CheckTwinFields(Me.TextBox_SF_CopyColumnsList, Me.TextBox_DF_CopyColumnsList, Me.Label_CopyColumnsError)
    Me.Label_Not_Matched_Lookup_Settings.Enabled = res
End Sub

Private Sub TextBox_SF_SheetName_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    On Error Resume Next: Me.TextBox_SF_SheetName = ActiveSheet.Name
End Sub

'Private Sub Label_Help_FieldCodes_Click()
'    On Error Resume Next
'    URL$ = DEVELOPER_WEBSITE$ & "programmes/" & PROJECT_NAME$ & "/FieldCodes?ref=" & HID$
'    FollowHyperlink URL$
'End Sub

Private Sub UserForm_Initialize()
    On Error Resume Next
    Me.ComboBox_SF_Filename.List = OpenWorkbooksList
    Me.ComboBox_DF_Filename.List = OpenWorkbooksList

    Me.ComboBox_SF_LastRowColumn.AddItem "auto"
    Me.ComboBox_DF_LastRowColumn.AddItem "auto"

    For i = 1 To 50
        Me.ComboBox_SF_FirstRow.AddItem i
        Me.ComboBox_DF_FirstRow.AddItem i
        Me.ComboBox_SF_LastRowColumn.AddItem ColumnNameByColumnNumber(i)
        Me.ComboBox_DF_LastRowColumn.AddItem ColumnNameByColumnNumber(i)

        Me.ComboBox_CopyRows_SF_CheckColumnNumber.AddItem ColumnNameByColumnNumber(i)
        Me.ComboBox_CopyRows_DF_LastRowColumn.AddItem ColumnNameByColumnNumber(i)
    Next

    For i = 1 To 8
        Me.ComboBox_SF_SheetIndex.AddItem i
        Me.ComboBox_DF_SheetIndex.AddItem i
    Next

    ' special controls
    Dim ctrl As MSForms.Control, SC As SpecialControl
    Set Me.SpecialControlsCollection = New Collection
    For Each ctrl In Me.Controls
        If TypeName(ctrl) = "ScrollBar" And ctrl.Tag = "ScrollCombo" Then
            Set SC = New SpecialControl: Set SC.Scroller = ctrl
            If SC.FieldFound Then Me.SpecialControlsCollection.Add SC
        End If
    Next

    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_SF_Found_Color_Interior: Me.SpecialControlsCollection.Add SC
    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_SF_Found_Color_Font: Me.SpecialControlsCollection.Add SC
    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_SF_NotFound_Color_Interior: Me.SpecialControlsCollection.Add SC
    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_SF_NotFound_Color_Font: Me.SpecialControlsCollection.Add SC

    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_DF_Found_Color_Interior: Me.SpecialControlsCollection.Add SC
    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_DF_Found_Color_Font: Me.SpecialControlsCollection.Add SC
    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_DF_NotFound_Color_Interior: Me.SpecialControlsCollection.Add SC
    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_DF_NotFound_Color_Font: Me.SpecialControlsCollection.Add SC

    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_CopyRows_DF_Color_Interior: Me.SpecialControlsCollection.Add SC
    Set SC = New SpecialControl: Set SC.ColorSelectCombo = Me.ComboBox_CopyRows_DF_Color_Font: Me.SpecialControlsCollection.Add SC

    SETT.LoadIntoSettingForm Me

    Me.MultiPage_SF_Color.Value = 0: Me.MultiPage_SF_Color.Style = fmTabStyleNone
    If ColoringEnable("SF") Then Me.CommandButton_SF_Color_Enable_Click
    Me.MultiPage_DF_Color.Value = 0: Me.MultiPage_DF_Color.Style = fmTabStyleNone
    If ColoringEnable("DF") Then Me.CommandButton_DF_Color_Enable_Click


    Dim norm$
    norm$ = "": txt$ = SETT.GetText("TextBox_SF_CompareColumnsList"): arr = ParseColumnsStringEx(txt$, norm$)
    Me.TextBox_SF_CompareColumnsList = norm$
    norm$ = "": txt$ = SETT.GetText("TextBox_DF_CompareColumnsList"): arr = ParseColumnsStringEx(txt$, norm$)
    Me.TextBox_DF_CompareColumnsList = norm$
    norm$ = "": txt$ = SETT.GetText("TextBox_SF_CopyColumnsList"): arr = ParseColumnsStringEx(txt$, norm$)
    Me.TextBox_SF_CopyColumnsList = norm$
    norm$ = "": txt$ = SETT.GetText("TextBox_DF_CopyColumnsList"): arr = ParseColumnsStringEx(txt$, norm$)
    Me.TextBox_DF_CopyColumnsList = norm$
    norm$ = "": txt$ = SETT.GetText("TextBox_DF_ConvertToTextColumnsList"): arr = ParseColumnsStringEx(txt$, norm$)
    Me.TextBox_DF_ConvertToTextColumnsList = norm$

    Me.MultiPage_Options.Value = 0
    Me.MultiPage_ExtraOptions.Value = 0

    Me.MultiPage_CopyRows_DF.Value = 0
    Me.MultiPage_CopyRows_SF.Value = 0
    Me.MultiPage_Options.Pages("Page_Extra").ScrollTop = 0

    TranslateUserForm Me
    If SETT.GetCurrentSetName <> "" Then Me.Caption = Me.Caption & "  ( " & tt("SettingSetDropdownCaption") & ": " & SETT.GetCurrentSetName & " )"

    For Each p In Me.MultiPage_Options.Pages: p.Caption = " " & Trim(p.Caption) & " ": Next
    For Each p In Me.MultiPage_ExtraOptions.Pages: p.Caption = " " & Trim(p.Caption) & " ": Next
    Me.Label25.Caption = UCase(Me.Label25.Caption): Me.Label20.Caption = UCase(Me.Label20.Caption)
End Sub

Private Sub CommandButton_SaveSettings_Click()
    On Error Resume Next
    SETT.SaveAllFromSettingForm Me
    Unload Me
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    On Error Resume Next
    Set Me.SpecialControlsCollection = Nothing
End Sub
Attribute VB_Name = "Fchar"
Attribute VB_Base = "0{FFD51F6D-06F9-45B8-8120-3697BEC2D3BA}{E68D1A36-74CD-439B-8C81-83A53C11E2B4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : Fchar                    Version:
' Author        : Igor Vakhnenko                   Date: 08.01.2016
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Private Sub CommandButton2_Click()
    Me.Hide
End Sub

Private Sub ListBox_res_Click()
    On Error Resume Next
    n = Me.ListBox_res.ListIndex
    Me.TextBox_txt.SelStart = n
    Me.TextBox_txt.SelLength = 1
    Me.TextBox_txt.SetFocus
End Sub

Private Sub TextBox_txt_Change()
    On Error Resume Next: Me.ListBox_res.Clear
    Me.ListBox_res.List = ParseString(Me.TextBox_txt)
    Me.Label_len.Caption = "|fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|: " & Len(Me.TextBox_txt) & " |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|"
End Sub


Attribute VB_Name = "Module1"
Public Const CFA_NAME$ = "'CommonFunctions.xla'!"
Public Enum CONTROL_TYPES
    ct_BUTTON = msoControlButton: ct_TEXTBOX = msoControlEdit: ct_COMBOBOX = msoControlComboBox
    ct_DROPDOWN = msoControlDropdown: ct_POPUP = msoControlPopup
End Enum

Attribute VB_Name = "Module2"
#If VBA7 Then
     Declare PtrSafe Function AccessibleChildren Lib "oleacc.dll" (ByVal paccContainer As Object, ByVal iChildStart As Long, ByVal cChildren As Long, rgvarChildren As Variant, pcObtained As LongPtr) As LongPtr
#Else
     Declare Function AccessibleChildren Lib "oleacc.dll" (ByVal paccContainer As Object, ByVal iChildStart As Long, ByVal cChildren As Long, rgvarChildren As Variant, pcObtained As Long) As Long
#End If

Attribute VB_Name = "ProgressIndicator"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : ProgressIndicator                    Version: 2
' Author        : Igor Vakhnenko                   Date: 21.07.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Explicit

Public FP As New F_Progress
Public SubActionIndex As Single, SubActionsCount As Single, SubActionsStep&
Private FPVisible As Boolean, FPStartTime As Date, Position&
Private PrS&, PrE&, Percent As Double, LogString$

Public Parent As ProgressIndicator, Children As New Collection
Public ShowPercents As Boolean, ShowTime As Boolean, ShowTimeInLog As Boolean

Dim MSG_EstimatedTime$, BTN_Stop$

Function AddChildIndicator(ByVal Caption$, Optional ByVal FPPosition& = 1) As ProgressIndicator
    On Error Resume Next
    Set AddChildIndicator = New ProgressIndicator
    Set AddChildIndicator.Parent = Me
    AddChildIndicator.Show Caption, FPPosition
    Children.Add AddChildIndicator
End Function

Private Sub Class_Initialize()
    Set FP = New F_Progress: ShowPercents = True: FPVisible = True
    PrS = 0: PrE = 100: Set_ProgressBar 0: FP.PrBar.Caption = ""
    FPStartTime = Now: ShowTime = True: ShowPercents = True: SubActionsStep = 1
    Set FP.Indicator = Me

    On Error Resume Next
    MSG_EstimatedTime$ = Run(TWN & "tt", "PI_MSG_EstimatedTime")
    If MSG_EstimatedTime$ = "" Then MSG_EstimatedTime$ = "Estimated time left"
    BTN_Stop$ = Run(TWN & "tt", "PI_BTN_Cancel")
    If BTN_Stop$ = "" Then BTN_Stop$ = "Cancel"
    FP.CommandButton_stop.Caption = BTN_Stop$
    Err.Clear
End Sub

Sub Show(ByVal Caption$, Optional ByVal FPPosition& = 0, Optional LogSize& = 0)
    On Error Resume Next
    SetProgressFormCaption Caption: On Error Resume Next:
    FP.PrBar.Width = ProgressBar_Default_Width
    Position = FPPosition
    FP.Tag = Caption: FP.Show:
    If Position <> 0 Then Move Position
    FP.Repaint: DoEvents
    FP.SpinButton_log.Value = LogSize
    FP.SpinButton_log.Visible = LogSize > 0
    SetLogSize LogSize
End Sub

Sub Hide()
    Unload FP
    FPVisible = False
End Sub

Sub Repaint()
    FP.Repaint: DoEvents
    If Application.ScreenUpdating = False Then Application.ScreenUpdating = True: Application.ScreenUpdating = False
End Sub

Sub Move(ByVal Position&)
    If Abs(Position) > 3 Then Exit Sub
    If Not Me.Parent Is Nothing Then
        FP.Top = Me.Parent.FP.Top + Me.Parent.FP.Height + 10 + (FP.Height + 3) * (Position - 1)
    Else
        FP.Top = FP.Top + (FP.Height + 3) * Position
    End If
End Sub

Public Property Get Visible(): Visible = FPVisible: End Property

Public Property Let Line1(ByVal NewValue$): FP.L1.Caption = ProcessLabel(NewValue): Me.FP.Repaint: DoEvents: End Property
Public Property Let Line2(ByVal NewValue$): FP.L2.Caption = ProcessLabel(NewValue): Me.FP.Repaint: DoEvents: End Property
Public Property Let Line3(ByVal NewValue$): FP.L3.Caption = ProcessLabel(NewValue): Me.FP.Repaint: DoEvents: End Property
Public Property Let Caption(ByVal NewValue$): SetProgressFormCaption NewValue: End Property

Private Sub SetProgressFormCaption(Optional ByVal Caption$ = "")
    Dim txt$, dt$
    If Len(Caption) > 0 Then FP.Tag = Caption
    txt = Trim(FP.Tag): If ShowPercents Then txt = Fix(Percent) & " %   " & txt
    dt = Format(Now - FPStartTime, "HH:NN:SS")
    If ShowTime Then txt = "( " & dt & " )    " & txt
    FP.Caption = txt
End Sub

Private Function TimeToFinish$()
    On Error Resume Next: Dim dt As Single
    If Percent < 15 Then Exit Function
    dt = (Now - FPStartTime) * (100 - Percent) / Percent
    TimeToFinish$ = Format(dt, "H:NN:SS")
    TimeToFinish$ = MSG_EstimatedTime$ & ": " & TimeToFinish$
End Function

Sub SetFocus()
    FP.Show 0: If Position <> 0 Then Move Position
End Sub

Private Sub UpdateLabels(Optional ByVal L1_txt$, Optional ByVal L2_txt$, Optional ByVal L3_txt$)
    If Len(L1_txt$) > 0 Then FP.L1.Caption = ProcessLabel(L1_txt$)
    If Len(L1_txt$) + Len(L2_txt$) > 0 Then FP.L2.Caption = ProcessLabel(L2_txt$)
    If Len(L1_txt$) + Len(L2_txt$) + Len(L3_txt$) > 0 Then FP.L3.Caption = ProcessLabel(L3_txt$)
End Sub

Private Function ProcessLabel$(ByVal txt$)
    If txt Like "*$index*" Then txt = Replace(txt, "$index", SubActionIndex)
    If txt Like "*$count*" Then txt = Replace(txt, "$count", SubActionsCount)
    If txt Like "*$time*" Then txt = Replace(txt, "$time", TimeToFinish)
    ProcessLabel = txt
End Function

Sub SubAction(Optional ByVal L1_txt$ = "", Optional ByVal L2_txt$ = "", Optional ByVal L3_txt$ = "")
    On Error Resume Next
    If SubActionsCount = 0 Then SubActionsCount = 1
    SubActionIndex = SubActionIndex + 1 * SubActionsStep
    If SubActionIndex > SubActionsCount Then SubActionIndex = SubActionsCount
    Percent = PrS + (PrE - PrS) * ((SubActionIndex - 1) / SubActionsCount)
    UpdateLabels L1_txt$, L2_txt$, L3_txt$
    Set_ProgressBar Percent: DoEvents
End Sub

Sub StartNewAction(Optional ByVal Pr_Start& = 0, Optional ByVal Pr_End& = 100, _
                   Optional ByVal L1_txt$ = "", Optional ByVal L2_txt$ = " ", Optional ByVal L3_txt$ = " ", _
                   Optional ByVal Actions_Count& = 0)
    On Error Resume Next
    PrS = Pr_Start: PrE = Pr_End: SubActionIndex = 0: SubActionsCount = Actions_Count
    UpdateLabels L1_txt$, L2_txt$, L3_txt$
    Set_ProgressBar PrS
End Sub

Sub UpdateFromChild(ByVal ChildPercent As Double)
    If SubActionsCount = 0 Then
        Percent = PrS + (PrE - PrS) * (ChildPercent / 100)
    Else
        Percent = PrS + (PrE - PrS) / SubActionsCount * (SubActionIndex - 1) + (PrE - PrS) / SubActionsCount * (ChildPercent / 100)
    End If
    Set_ProgressBar Percent
End Sub

Private Sub Set_ProgressBar(ByVal NewPercent As Double)
    On Error Resume Next: Percent = NewPercent
    If NewPercent > 100 Then Percent = 100
    If NewPercent < 0 Then Percent = 0
    FP.PrBar.Width = Int(Percent * ProgressBar_Default_Width / 100)
    SetProgressFormCaption
    FP.Repaint
    If Not Parent Is Nothing Then Parent.UpdateFromChild Percent
End Sub

Private Sub Class_Terminate()
    On Error Resume Next
    Unload FP: FPVisible = False
    Set FP = Nothing: Set Children = Nothing: Set Parent = Nothing
End Sub

Private Function ProgressBar_Default_Width() As Double
    ProgressBar_Default_Width = FP.Width - 18
End Function

Function CancelButton() As MSForms.CommandButton
    Set CancelButton = FP.CommandButton_stop
End Function

Sub SetLogSize(ByVal n&)
    On Error Resume Next
    If n < 0 Then n = 0
    If n > 5 Then n = 5
    FP.SpinButton_log.Value = n
    FP.SpinButton_log.Visible = n > 0
End Sub

Sub Log(ByVal txt$, Optional ByVal MaxLen& = 0)
    On Error Resume Next: Dim currtime$, newtext$
    If ShowTimeInLog Then currtime$ = Time & vbTab
    LogString = LogString & vbNewLine & currtime$ & txt
    newtext$ = Mid(LogString, 3): If MaxLen& Then newtext$ = Right(newtext$, MaxLen&)
    FP.TextBox_Log.Text = newtext$
    If FP.SpinButton_log.Value = 0 Then FP.SpinButton_log.Value = 2: FP.SpinButton_log.Visible = True
    FP.CommandButton_stop.SetFocus: FP.TextBox_Log.SetFocus
End Sub

Sub ClearLog()
    LogString = "": FP.TextBox_Log.Text = ""
End Sub

Sub ShowLog()
    On Error Resume Next: Dim filename$
    filename$ = Environ("TEMP") & "\macro_log.txt"
    With CreateObject("scripting.filesystemobject").CreateTextFile(filename, True)
        .Write Mid(LogString, 3): .Close
    End With
    FollowHyperlink """" & filename$ & """"
End Sub

Sub AddButton(ByVal Caption$, ByVal Macro$)
    Const dd& = 18
    If FP.SpinButton_log = 0 Then FP.SpinButton_log = 1
    With Me.FP.CommandButton_RunMacro
        .Caption = Caption$
        .Visible = True
        .Top = FP.Height - .Height - dd - 20
        .Left = FP.Width - .Width - dd - 15
    End With
    FP.ButtonMacro = Macro$
End Sub

Function MacroButton() As MSForms.CommandButton
    Set MacroButton = FP.CommandButton_RunMacro
End Function

Sub QueryClose()
    On Error Resume Next
    Dim pi As ProgressIndicator
    For Each pi In Children
        pi.QueryClose
        pi.Hide
    Next pi
End Sub


Attribute VB_Name = "SpecialControl"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module        : SpecialControl                    Version:
' Author        : Igor Vakhnenko                   Date: 05.07.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Compare Text
Public WithEvents Scroller As MSForms.ScrollBar
Attribute Scroller.VB_VarHelpID = -1
Public WithEvents ScrolledCombo As MSForms.ComboBox
Attribute ScrolledCombo.VB_VarHelpID = -1
Dim ScrollEventEnabled As Boolean

Public WithEvents MainCheckboxInFrame As MSForms.CheckBox
Attribute MainCheckboxInFrame.VB_VarHelpID = -1
'Public WithEvents FontSelectCombo As MSForms.ComboBox
Public WithEvents ColorSelectCombo As MSForms.ComboBox
Attribute ColorSelectCombo.VB_VarHelpID = -1
Public WithEvents KeyNameTexbox As MSForms.TextBox
Attribute KeyNameTexbox.VB_VarHelpID = -1

' -----------------------------------------------------------------------------------

'Private Sub FontSelectCombo_Change()
'    On Error Resume Next: Me.FontSelectCombo.SelStart = 1
'    With New FontParameters
'        .LoadFromText (Me.FontSelectCombo)
'        .ApplyToSettingsField Me.FontSelectCombo
'    End With
'    Me.FontSelectCombo.SelStart = 1
'End Sub
'
'Private Sub FontSelectCombo_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
'    On Error Resume Next: Me.FontSelectCombo.SelStart = 1
'    With New FontParameters
'        .LoadFromText (Me.FontSelectCombo): .PickNewFont
'        Me.FontSelectCombo = .ExportToText
'
'        Dim UF As Object: Set UF = Me.FontSelectCombo
'        While TypeName(UF) <> "UserForm": Set UF = UF.Parent: Wend
'        UF.Show
'    End With
'    Me.FontSelectCombo.SelStart = 1
'End Sub

' -----------------------------------------------------------------------------------
Private Sub KeyNameTexbox_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    KeyAscii = 0
End Sub
Private Sub KeyNameTexbox_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    On Error Resume Next: Button$ = GetKeyName(KeyCode, Shift)
    If Len(Button$) Then KeyCode = 0: Me.KeyNameTexbox = Button$
End Sub
' -----------------------------------------------------------------------------------
Private Sub ColorSelectCombo_Change()
    On Error Resume Next: clr& = Val(Me.ColorSelectCombo)
    If clr& >= 0 Then
        Me.ColorSelectCombo.ForeColor = clr&: Me.ColorSelectCombo.BackColor = clr&
    Else
         clr& = vbButtonFace
        Me.ColorSelectCombo.ForeColor = clr&: Me.ColorSelectCombo.BackColor = clr&
    End If
End Sub
Private Sub ColorSelectCombo_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error Resume Next: clr& = PickNewColor(IIf(Me.ColorSelectCombo = "", xlNone, Val(Me.ColorSelectCombo)))
    Me.ColorSelectCombo = clr&
End Sub

' -----------------------------------------------------------------------------------
Private Sub MainCheckboxInFrame_Change()
    On Error Resume Next: Err.Clear
    Dim fr As MSForms.Frame, ctrl As MSForms.Control: Set fr = Me.MainCheckboxInFrame.Parent
    If Err <> 0 Or (fr Is Nothing) Then MsgBox "MainCheckboxInFrame.Parent is not frame control": Exit Sub
    For Each ctrl In fr.Controls
        If ctrl.Name <> Me.MainCheckboxInFrame.Name Then
            ctrl.Enabled = Me.MainCheckboxInFrame.Value
        End If
    Next
End Sub
' -----------------------------------------------------------------------------------
Function FieldFound() As Boolean
    On Error Resume Next
    If Not ScrolledCombo Is Nothing Then FieldFound = True: Exit Function
    ScrollEventEnabled = False: Me.Scroller.Value = 1: ScrollEventEnabled = True
    Dim ctrl As MSForms.Control
    For Each ctrl In Me.Scroller.Parent.Controls
        If TypeName(ctrl) = "ComboBox" Then
            If ctrl.Top < Scroller.Top And ctrl.Left < Scroller.Left And _
               ctrl.Top + ctrl.Height > Scroller.Top + Scroller.Height And ctrl.Left + ctrl.Width > Scroller.Left + Scroller.Width Then
                Set ScrolledCombo = ctrl
                FieldFound = True: Exit Function
            End If
        End If
    Next
    MsgBox "Combo not found", , Me.Scroller.Name
End Function

Private Sub Scroller_Change()
    On Error Resume Next: If Not Me.FieldFound Then Exit Sub
    If Not ScrollEventEnabled Then Exit Sub
    Select Case Me.Scroller.Value
        Case 0: Me.ScrolledCombo.ListIndex = Me.ScrolledCombo.ListIndex + 1
        Case 2: If Me.ScrolledCombo.ListIndex > 0 Then Me.ScrolledCombo.ListIndex = Me.ScrolledCombo.ListIndex - 1
    End Select
    ScrollEventEnabled = False: Me.Scroller.Value = 1: ScrollEventEnabled = True
End Sub

Attribute VB_Name = "ThisWB"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'---------------------------------------------------------------------------------------
' Author        : Igor Vakhnenko                   Date: 25.12.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Private Sub Workbook_BeforeClose(Cancel As Boolean)
    DeleteProgramCommandBar
End Sub

Private Sub Workbook_Open()
    On Error Resume Next: Dim FirstRun As Boolean
    FirstRun = SETT.IsFirstRun
    If FirstRun Then ShowFirstRunForm
    If SetupCancelled Then
        Application.DisplayAlerts = False
        If TrueDeveloper Then MsgBox "Setup Cancelled", vbInformation Else ThisWorkbook.Close False
        Application.DisplayAlerts = True
        Exit Sub
    End If
    Enable_AccessVBOM_Macro_DataConnections        ' disables notifications
    SaveSetting PROJECT_NAME$, "Setup", "AddinPath", ThisWorkbook.FullName
    If FirstRun Then If IsObject(F_Greeting) Then F_Greeting.Show
    CreateProgramCommandBar 0
End Sub

Attribute VB_Name = "mod_About_NEW"
'---------------------------------------------------------------------------------------
' Module        : mod_About_NEW                    Version: 2.6
' Author        : Igor Vakhnenko                   Date: 09.05.2016
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Explicit: Option Compare Text: Option Private Module
Public Const DEBUG_MODE As Boolean = False        'True
Public Const UPDATES_HYPERLINK$ = "http://ExcelVBA.ru/php2/updates.php"

Public Const DEVELOPER_WEBSITE$ = "http://ExcelVBA.ru/"        '"http://Excel-Automation.com/"
Public Const SUPPORT_EMAIL_RUS$ = "info@ExcelVBA.ru", SUPPORT_EMAIL$ = "support@Excel-Automation.com"
Public Const BUY_NEW_HYPERLINK$ = "%website%buy/add-in?name=%projectname%"
Public Const BUY_ADD_HYPERLINK$ = "%website%buy2/add-in?name=%projectname%"
Public Const UNINSTALL_HYPERLINK$ = "%website%uninstall/program?name=%projectname%"
Public Const EULA_HYPERLINK$ = "%website%buy/EULA?name=%projectname%"
Public Const BREACH_EULA_HYPERLINK$ = "%website%buy/EULA/breach?name=%projectname%"
Public Const CABINET_HYPERLINK$ = "%website%cabinet/login"
Public Const VERSIONS_HISTORY_HYPERLINK$ = "%website%updates/history.php?addin=%projectname%"
Public SetupCancelled As Boolean, StopMacro As Boolean


Sub ActivateAddinsTab()
    On Error Resume Next: Dim TabName$
    Select Case Application.LanguageSettings.LanguageID(msoLanguageIDUI)
        Case 1049: TabName$ = SETT.U("CDE0E4F1F2F0EEE9EAE8")        '"|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|"
        Case 1033: TabName$ = "Add-Ins"
    End Select
    If Len(TabName$) Then SwitchTab TabName$
End Sub


Sub Add3Buttons(ByRef AddinMenu As Object)
    Add_Control(AddinMenu, ct_BUTTON, 0, "0", "", msoButtonIconAndCaption, False).Enabled = 0
    Add_Control AddinMenu, ct_BUTTON, 222, "ShowSettingsPage", tt("MENU_Settings") & "  ", msoButtonIconAndCaption, True
    Add_Control AddinMenu, ct_BUTTON, 487, "ShowMainForm", tt("MENU_About") & "  ", msoButtonIconAndCaption, True
    Add_Control AddinMenu, ct_BUTTON, IIf(Val(Application.Version) <= 11, 4356, 923), "ExitProgram", tt("MENU_Exit"), msoButtonIcon, True
End Sub

Function Add_Control(ByRef Comm_Bar, ByVal ControlType As CONTROL_TYPES, Optional ByVal B_Face&, Optional ByVal On_Action$, _
                     Optional ByVal B_Caption$, Optional ByVal Button_Style As Long = msoButtonIcon, _
                     Optional ByVal Begin_Group As Boolean = False, Optional Tag = "") As CommandBarControl
    On Error Resume Next
    Set Add_Control = Comm_Bar.Controls.Add(Type:=ControlType, Temporary:=True)
    With Add_Control
        If B_Face > 0 And ControlType = ct_BUTTON Then .FaceId = B_Face
        If Len(On_Action) Then
            .Tag = TWN & On_Action & "\\\" & Tag
            .OnAction = TWN & "RunMacroFromButton": If On_Action Like "Exit*" Then .OnAction = TWN & On_Action
        End If
        .Caption = B_Caption
        .BeginGroup = Begin_Group
        If ControlType = ct_BUTTON Or ControlType = ct_DROPDOWN Then .Style = Button_Style
    End With
End Function

Private Sub RunMacroFromButton()
    On Error Resume Next: Dim Macro$, param$
    Macro$ = Split(Application.CommandBars.ActionControl.Tag, "\\\")(0)
    param$ = Split(Application.CommandBars.ActionControl.Tag, "\\\")(1)
    If Macro$ Like TWN & "*" Then SETT.LastMacro Macro$
    If Len(Macro$) > O Then If Len(param$) Then Run Macro$, param$ Else Run Macro$
End Sub

Function GetCommandBar(ByVal CommandBarName As String, Optional ByVal Clean As Boolean = False, _
                       Optional ByVal Position As MsoBarPosition = msoBarTop) As CommandBar
    On Error Resume Next: Err.Clear: Dim cbc As Object
    Set GetCommandBar = Application.CommandBars(CommandBarName)
    If Err.Number Then
        Set GetCommandBar = Application.CommandBars.Add(CommandBarName, Position, False, True)
    End If
    If Clean Then
        GetCommandBar.Visible = False
        For Each cbc In GetCommandBar.Controls: cbc.Delete: Next
    End If
    GetCommandBar.Visible = True
End Function

Function DeleteProgramCommandBar()
    On Error Resume Next: GetCommandBar(PROJECT_NAME).Visible = False
End Function

Function SetIsAddinAsFalse()
    On Error Resume Next: ThisWorkbook.IsAddin = False
End Function
Function SetIsAddinAsTrue()
    On Error Resume Next: ThisWorkbook.IsAddin = True
End Function

'Sub ComboChanged()    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'    On Error Resume Next
'    |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| = Application.CommandBars.ActionControl.Tag
'    |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| = Application.CommandBars.ActionControl.Text
'    MsgBox "|fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|: """ & |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| & """", _
     '           vbInformation, "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd|\|fffd||fffd||fffd||fffd||fffd||fffd| """ & |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| & """"
'End Sub
'Sub AdditionalMacros()    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
'    On Error Resume Next
'    |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| = Application.CommandBars.ActionControl.Tag
'    MsgBox "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| = """ & |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| & """", vbInformation, "|fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|"
'End Sub

Function SETT() As AddinSettings
    Static objSETT As AddinSettings
    If objSETT Is Nothing Then Set objSETT = New AddinSettings: objSETT.LoadAllSettings
    Set SETT = objSETT
End Function

Private Sub ShowMainForm()
    On Error Resume Next: F_About.Show
    F_About.MultiPage1.Value = 0
End Sub

Sub ShowSettingsPage()
    On Error Resume Next: F_Settings.Show
End Sub
Sub ShowFirstRunForm()
    On Error Resume Next: F_FirstRun.Show
End Sub

Sub RunWithDelay(ByVal macroname$, Optional ByVal delay As Double = 0.5)
    On Error Resume Next: Dim delay_txt$
    delay_txt$ = Replace(Format(CDbl(TimeSerial(0, 0, 1)) * delay, "0.000000000"), ",", ".")
    ExecuteExcel4Macro "ON.TIME(NOW()+" & delay_txt$ & ", ""'" & ThisWorkbook.Name & "'!" & macroname$ & """)"
End Sub

Function HWID(Optional ByVal Refresh As Boolean) As String
    On Error Resume Next: Dim v&, sv$, obj As Object, DriveID$, PartName$, DriveLetter$
    sv$ = GetSetting(PROJECT_NAME$, "Setup", "HWID")
    If sv$ <> "" Then If Not Refresh Then HWID = sv$: Exit Function

    DriveLetter$ = GetSetting(PROJECT_NAME$, "Setup", "DriveLetter")
    If Not DriveLetter$ Like "[A-Z]:" Then DriveLetter$ = Environ("SystemDrive")
    If Not DriveLetter$ Like "[A-Z]:" Then DriveLetter$ = "C:"
    With GetObject("winmgmts:")
        For Each obj In .ExecQuery("ASSOCIATORS OF {Win32_LogicalDisk.DeviceID='" & DriveLetter$ & "'} WHERE AssocClass = Win32_LogicalDiskToPartition"): PartName$ = obj.DeviceID: Next
        For Each obj In .ExecQuery("ASSOCIATORS OF {Win32_DiskPartition.DeviceID='" & PartName$ & "'} WHERE AssocClass = Win32_DiskDriveToDiskPartition"): DriveID$ = obj.DeviceID: Next
        For Each obj In .ExecQuery("SELECT * FROM Win32_DiskDrive WHERE DeviceID='" & Replace(DriveID$, "\", "\\") & "'"): v& = Val(obj.Signature): Next
    End With
    If v& = 0 Then HWID = "100000" & Mid(HID, 2) Else HWID = Right(Left(Replace(Abs((CSng(v) + 1.2345) / 0.00639), Mid(1 / 2, 2, 1), ""), 15) & Format(Abs(v Mod 1000), "000"), 16)
    SaveSetting PROJECT_NAME$, "Setup", "HWID", HWID
End Function

Function HID$()
    On Error Resume Next: Dim SN&: SN& = CreateObject("scripting.filesystemobject").GetDrive(ChrW(99) & ChrW(58)).SerialNumber
    HID$ = ChrW(115) & Format(Abs(934526875# - SN&), "0000000000")
End Function

Function GetVersion() As Long
    On Error Resume Next: GetVersion = Val(ThisWorkbook.BuiltinDocumentProperties("Revision Number"))
    If GetVersion < 1000 Then GetVersion = 1000
End Function

Function GetVersionTXT(Optional ByVal ver& = 0)
    On Error Resume Next: If ver& = 0 Then ver& = GetVersion
    GetVersionTXT = Mid(ver&, 1, 1) & "." & Mid(ver&, 2, 1) & "." & Val(Mid(ver&, 3))
End Function

Sub SetVersion(ByVal n As Long)
    On Error Resume Next: If n < 1000 Then n = 1000
    ThisWorkbook.BuiltinDocumentProperties("Revision Number") = n
    ThisWorkbook.BuiltinDocumentProperties("Creation Date") = Now
End Sub
Function l0&(): On Error Resume Next: l0& = Val("&H" & Split(ThisWorkbook.Names(Chr(116) & Chr(100)).RefersTo, "%%")(1)): End Function
Function ll&(): On Error Resume Next: Dim d&, t&: d = Fix(l0 - (SETT.DTU - Val(SETT.RSP(1))) / 86400): t& = Val(SETT.RSP(3)): SETT.WSP 3, IIf(t > d, d + 1, t): ll& = 1: End Function
Private Sub PrintSettings_AsDefault()
    On Error Resume Next: Err.Clear: Dim arr, i&, txt
    arr = GetAllSettings(PROJECT_NAME$, "Settings")
    If IsArray(arr) Then
        For i = LBound(arr) To UBound(arr)
            txt = "SetDefaultSetting """ & arr(i, 0) & """, """ & arr(i, 1) & """"
            Debug.Print txt
        Next i
    End If
End Sub

Function ImportSettings(Optional ByVal xmlPath$ = "", Optional HideMessages As Boolean = False) As Boolean
    On Error Resume Next: Err.Clear
    If xmlPath$ = "" Then
        xmlPath$ = FWF.GetFilePath(tt("ImportSettingsFileDialog", PROJECT_NAME$), ThisWorkbook.Path, tt("AddinSettings", PROJECT_NAME$), "*.xml")
    End If
    If xmlPath$ = "" Then Exit Function
    ImportSettings = SETT.ImportFromFile(xmlPath$, HideMessages)
End Function

Function ExportSettings(Optional ByVal xmlPath$ = "", Optional HideMessages As Boolean = False) As Boolean
    On Error Resume Next: Err.Clear
    Dim initial_filename$, dialog_title$, prevDir$, res As Variant
    If xmlPath$ = "" Then
        initial_filename$ = ThisWorkbook.Path & "\" & PROJECT_NAME$ & "_Settings_" & Format(Now, "DD.MM.YYYY_HH-NN-SS") & ".xml"
        dialog_title$ = tt("ExportSettingsFileDialog", PROJECT_NAME$)
        prevDir$ = CurDir$: ChDrive Left(initial_filename$, 1): ChDir ThisWorkbook.Path
        res = Application.GetSaveAsFilename(initial_filename$, tt("AddinSettings", PROJECT_NAME$) & " (*.xml),", , dialog_title$, tt("Save"))
        ChDrive Left(prevDir$, 1): ChDir prevDir$
        If VarType(res) = vbBoolean Then Exit Function
        xmlPath$ = CStr(res)
    End If
    ExportSettings = SETT.ExportToFile(xmlPath$, HideMessages)
End Function

Function PROGRAM_HYPERLINK$()
    PROGRAM_HYPERLINK$ = DEVELOPER_WEBSITE$ & "programmes/" & PROJECT_NAME$ & "?ref=" & HWID
End Function

Sub Enable_AccessVBOM_Macro_DataConnections()
    On Error Resume Next: Dim sec_key$
    sec_key$ = "HKEY_CURRENT_USER\Software\Microsoft\Office\" & Application.Version & "\Excel\Security\"
    With CreateObject("WScript.Shell")
        .RegWrite sec_key$ & "AccessVBOM", 1, "REG_DWORD"
        .RegWrite sec_key$ & "VBAWarnings", 1, "REG_DWORD"
        .RegWrite sec_key$ & "DataConnectionWarnings", 0, "REG_DWORD"
    End With
End Sub

Function AddinAutoRun(Optional ByVal NewState As Variant) As Boolean
    On Error Resume Next
    Dim ShortcutFullName$, AI As AddIn
    ShortcutFullName$ = Application.StartupPath & Application.PathSeparator & PROJECT_NAME$ & ".lnk"
    If Not VarType(NewState) = vbBoolean Then AddinAutoRun = FWF.FileExists(ShortcutFullName$): Exit Function

    If NewState = True Then
        With CreateObject("WScript.Shell").CreateShortcut(ShortcutFullName$)
            .TargetPath = ThisWorkbook.FullName
            .Save
        End With
    ElseIf NewState = False Then
        Kill Application.StartupPath & Application.PathSeparator & PROJECT_NAME$ & "*.lnk"
    End If
    AddinAutoRun = CBool(NewState)

    For Each AI In Application.AddIns
        If AI.Name = ThisWorkbook.Name Then AI.Installed = False
    Next AI
End Function
Function DeleteOldCommandBar(): On Error Resume Next: Run TWN & "Request_": End Function
Function UninstallThisFile(Optional ByVal Mode& = 1)
    On Error Resume Next
    If Mode& = 1 Then
        If MsgBox(tt("MSG_UninstallConfirmation"), vbExclamation + vbOKCancel + vbDefaultButton2, _
                  tt("MSG_UninstallConfirmationTitle")) = vbCancel Then Exit Function
    End If
    If TrueDeveloper Then MsgBox "Uninstalling cancelled", vbInformation, "Mode=" & Mode&: Exit Function

    AddinAutoRun False
    Application.DisplayAlerts = False
    Dim FilePath$: FilePath$ = ThisWorkbook.FullName
    ThisWorkbook.ChangeFileAccess xlReadOnly
    SetAttr FilePath$, vbNormal
    Kill FilePath$
    If Mode& = 1 Then If RUS Then FollowHyperlink UNINSTALL_HYPERLINK$
    If Mode& >= 2 Then If RUS Then FollowHyperlink BREACH_EULA_HYPERLINK$
    'If Mode& = 3 Then Request_ "action=bugger_detected"
    'Application.DisplayAlerts = True
    ThisWorkbook.Close False
End Function

Function Developer() As Boolean: Developer = TrueDeveloper And (Dir("c:\testmode", vbNormal) = ""): End Function
Function TrueDeveloper() As Boolean
    Dim txt$: txt$ = Environ(Chr(85) & Chr(83) & Chr(69) & Chr(82) & Chr(68) & Chr(79) & Chr(77) & Chr(65) & Chr(73) & Chr(78)): TrueDeveloper = (txt$ Like ChrW(73) & ChrW(71) & ChrW(79) & ChrW(82) & ChrW(72) & ChrW(79) & ChrW(77) & ChrW(69) & ChrW(42)) Or (txt$ Like ChrW(73) & ChrW(71) & ChrW(79) & ChrW(82) & ChrW(87) & ChrW(79) & ChrW(82) & ChrW(75) & ChrW(42))
End Function

Function MU_() As Boolean
    On Error Resume Next: Dim X: X = ll: Err.Clear: X = ThisWorkbook.VBProject.VBComponents.Count
    If TrueDeveloper Then Exit Function
    MU_ = Err = 0: If MU_ Then UninstallThisFile 2
End Function

Function OfficeBits() As Long
    #If VBA7 And Win64 Then
        OfficeBits = 64
    #Else
        OfficeBits = 32
    #End If
End Function

Function TWN() As String: TWN = "'" & ThisWorkbook.Name & "'!": End Function
Function O() As Long
    On Error Resume Next: Dim i&, t As Double: O = 2 ^ 30: If MU_ Then Exit Function
    If AS_ > 0 Then
        O = 0
    Else
        Application.EnableCancelKey = xlDisabled: ShowMainForm
        With F_About.Controls(Chr(76) & Chr(97) & Chr(98) & Chr(101) & Chr(108) & Chr(95) & Chr(73) & Chr(110) & Chr(102) & Chr(111))
            For i = 1 To 10
                .Visible = i Mod 2 = 0: t = Timer: While Abs(Timer - t) < 0.2: DoEvents: Wend
            Next
        End With
        With F_About.Controls(Chr(76) & Chr(97) & Chr(98) & Chr(101) & Chr(108) & Chr(95) & Chr(72) & Chr(76) & Chr(95) & Chr(66) & _
                              Chr(117) & Chr(121) & Chr(76) & Chr(105) & Chr(99) & Chr(101) & Chr(110) & Chr(115) & Chr(101))
            .ForeColor = RGB(255, 0, 0)
            For i = 1 To 4
                .Visible = i Mod 2 = 0: t = Timer: While Abs(Timer - t) < 0.2: DoEvents: Wend
            Next
        End With
        Application.EnableCancelKey = xlInterrupt
    End If
End Function

Function cmdDisplay(txt) As String
    On Error Resume Next: Dim pass$, d&, i&, letter$
    If Left(txt, 1) = "P" Then txt = Mid(txt, 2): pass$ = "" Else pass$ = HID
    d = Val("&H" & Mid(txt, 1, 2))
    For i = 2 To Len(txt) / 2
        letter = Val("&H" & Mid(txt, 2 * i - 1, 2))
        cmdDisplay$ = cmdDisplay$ & Chr(letter Xor CInt(2 * d * Abs(Sin(3 * (i - 1)))) + Val(Mid(pass$, 2 + (i - 1) Mod 10, 1)))
    Next
End Function

Function CreateShortcutInStartMenu(Optional ByVal ShortcutName$ = PROJECT_NAME$, Optional ByVal ShortcutFolderName$)
    On Error Resume Next
    Dim ShortcutFullName$, Folder$
    If ShortcutFolderName$ = "" Then ShortcutFolderName$ = tt("StartMenuFolderName")
    Folder$ = CreateObject("WScript.Shell").SpecialFolders("StartMenu") & Application.PathSeparator
    If Len(Trim(ShortcutFolderName$)) Then
        Folder$ = Folder$ & FWF.Replace_symbols(ShortcutFolderName$) & Application.PathSeparator
        MkDir Folder$
    End If

    ShortcutFullName$ = Folder$ & FWF.Replace_symbols(ShortcutName$, " ") & ".lnk"
    Kill Folder$ & "*" & PROJECT_NAME$ & "*.lnk"        ' deleting old shortcuts

    With CreateObject("WScript.Shell").CreateShortcut(ShortcutFullName$)
        .TargetPath = ThisWorkbook.FullName
        .Description = tt("ProgramFullname") & vbNewLine & vbNewLine & Split(PROGRAM_HYPERLINK$, "?")(0)
        .Save
    End With
End Function

Sub UpdateStatus(Optional ByRef obj As MSForms.Label)
    On Error Resume Next: Dim txt$, ou$, col&, sh As Boolean
    With SETT
        Select Case Run(TWN & .U("41535F"))
            Case 4: ou$ = Trim(.GetRegValue(.U("757365726E616D65"))): If ou$ = "" Then ou$ = Trim(.GetRegValue(.U("656D61696C")))
                txt = tt("|4143545F4F4B") & vbNewLine & tt("|4143545F4F574E4552", ou$): col& = RGB(0, 150, 0): sh = True
            Case 1: txt = tt("|4143545F545249414C") & vbNewLine & tt("|4143545F444159534C454654", .RSP(3)): col& = RGB(200, 50, 0)
            Case 0: txt = tt("|4143545F45585049524544") & vbNewLine & tt("|4143545F4255594E4F57"): col& = RGB(255, 0, 0)
            Case Else: txt = .U("556E6B6E6F776E2061637469766174696F6E207374617475732E0D0A436F6E7461637420646576656C6F70657220746F206669782074686973206572726F722E"): col& = RGB(100, 0, 100)
        End Select
        obj.Caption = txt: obj.ForeColor = col
    End With
    With F_About
        .MultiPage1.Pages(SETT.U("506167655F526567496E666F")).Visible = Not sh: .Label_HL_Cabinet.Visible = sh
        .Label_HL_BuyLicense = tt("|465F41626F75745C4C6162656C5F484C5F4275794C6963656E7365" & IIf(sh, "32", ""))
        .Repaint
    End With
End Sub

Sub ApplyZoomTo(ByRef UF)
    On Error Resume Next: Dim zo&, dh&
    zo = SETT.GetNumber("ComboBox_Zoom", 100)
    If zo < 20 Then zo = 100
    dh& = UF.Height - UF.InsideHeight
    UF.Width = UF.Width * zo / 100: UF.Height = (UF.Height - dh&) * zo / 100 + dh&
    UF.Zoom = zo
End Sub

Sub ExitProgram()
    On Error Resume Next
    If MsgBox(tt("MSG_ExitProgram"), vbQuestion + vbDefaultButton2 + vbOKCancel) = vbCancel Then Exit Sub
    DeleteProgramCommandBar
    ThisWorkbook.Close False
End Sub

' ---------------------------------------------------------------------------------------------------------------------
Function UpdateAvailable() As Boolean
    On Error Resume Next: UpdateAvailable = SETT.GetText("NewVersionURL", , "Updates") Like "http*://*.*/?*.xl*"
End Function

Sub ApplySettingSet(ByVal filename$)
    On Error Resume Next: Dim setting_set_name$, macroname$, ctrl As Object

    If filename$ Like "folder=?*" Then        ' dropdown changed
        setting_set_name$ = Application.CommandBars.ActionControl.Text
        filename$ = Split(filename$, "folder=", 2)(1) & setting_set_name$ & ".xml"
    End If

    If filename$ Like "macro=?*&*" Then        ' button pressed
        macroname$ = Split(Split(filename$, "macro=", 2)(1), "&", 2)(0)
        filename$ = Split(filename$, "&", 2)(1)
        setting_set_name$ = Application.CommandBars.ActionControl.Caption
        setting_set_name$ = Mid(setting_set_name$, 2, Len(setting_set_name$) - 2)        ' TRIM
        If filename$ = "" Then setting_set_name$ = ""        ' for main button
    End If

    'MsgBox filename$, , setting_set_name$
    If SETT.ActivateSettingSet(setting_set_name$, filename$) Then
        If Len(macroname$) Then
            For Each ctrl In Application.CommandBars.ActionControl.Parent.Controls
                If ctrl.FaceId = Application.CommandBars.ActionControl.FaceId Then ctrl.State = msoButtonUp
            Next
            Application.CommandBars.ActionControl.State = msoButtonDown
            Run TWN & macroname$
        End If
        Run TWN & "SettingSetChanged"
    Else
        RunWithDelay "CreateProgramCommandBar", 0.5        ' incorrect setting set name
    End If
End Sub
Function AS_() As Long
    On Error Resume Next: Dim txt$
    With SETT
        txt$ = .GetRegValue(.U("636F6465")) & "@": txt = Split(txt, "@")(1)
        If Len(.k) * (txt = .k) Then AS_ = 4: Exit Function
        AS_ = -(.RSP(3) > 0)
    End With
End Function
Sub AddSettingsSwitcher(ByVal AddinMenu As Object, Optional ByVal SwitcherType As CONTROL_TYPES = ct_BUTTON, _
                        Optional ByVal SettingsFolderName$, Optional ByVal MainMacroName$, Optional ByRef MainMacroButton As Object)
    On Error Resume Next
    Dim coll As New Collection, SettingsFolder$, Item, filename$, MenuDropdown As Object, SettingSetName$, i&, UserSwitcherType&
    SettingsFolderName$ = Trim(Replace(SettingsFolderName$, "\", ""))
    If SettingsFolderName$ = "" Then SettingsFolderName$ = PROJECT_NAME$ & "Settings"
    SettingsFolder$ = ThisWorkbook.Path & "\" & SettingsFolderName$ & "\"

    If Not FWF.FolderExists(SettingsFolder$) Then Exit Sub
    Set coll = FWF.FilenamesCollection(SettingsFolder$, "*.xml", 1)
    If coll.Count = 0 Then Set coll = Nothing: Exit Sub

    If SwitcherType = ct_COMBOBOX Then SwitcherType = ct_DROPDOWN
    ' SwitcherType is one of ct_BUTTON or ct_COMBOBOX / ct_DROPDOWN

    UserSwitcherType& = SETT.GetNumber("SettingsSwitcher", 1, "Setup")
    ' user can disable switcher or change type of switcher by adding key "SettingsSwitcher" into Setup registry section
    ' 0 = switcher disabled, 1 = default type, 2 = DROPDOWN SWITCHER, 3 = BUTTON SWITCHER
    Select Case UserSwitcherType&
        Case 0: Exit Sub
        Case 2: SwitcherType = ct_DROPDOWN
        Case 3: SwitcherType = ct_BUTTON
    End Select

    Add_Control(AddinMenu, ct_BUTTON, 0, "0", "", msoButtonIconAndCaption, False).Enabled = 0
    If SwitcherType = ct_DROPDOWN Then
        Set MenuDropdown = Add_Control(AddinMenu, ct_DROPDOWN, , "ApplySettingSet", tt("SettingSetDropdownCaption") & ":", _
                                       msoComboLabel, , "folder=" & SettingsFolder$)
        MenuDropdown.AddItem "<" & tt("DefaultSettingSetName") & ">"
    End If

    SettingSetName$ = SETT.GetCurrentSetName

    For Each Item In coll
        filename$ = Split(Dir(Item, vbNormal), ".xml")(0)

        Select Case SwitcherType
            Case ct_BUTTON
                With Add_Control(AddinMenu, ct_BUTTON, MainMacroButton.FaceId, "ApplySettingSet", " " & filename$ & " ", _
                                 msoButtonIconAndCaption, , "macro=" & MainMacroName$ & "&" & Item)
                    .State = IIf(SettingSetName$ = filename$, msoButtonDown, msoButtonUp)
                End With
            Case ct_DROPDOWN
                MenuDropdown.AddItem filename$
        End Select
    Next

    If SwitcherType = ct_DROPDOWN Then
        For i = 1 To MenuDropdown.ListCount
            If MenuDropdown.List(i) = SettingSetName$ Then MenuDropdown.ListIndex = i: Exit For
        Next i
        If MenuDropdown.ListIndex = 0 Then
            MenuDropdown.ListIndex = 1
            If SettingSetName$ <> "" Then SETT.ActivateSettingSet ""
        End If
    End If

    If SwitcherType = ct_BUTTON Then
        MainMacroButton.Tag = TWN & "ApplySettingSet" & "\\\" & "macro=" & MainMacroName$ & "&"
        MainMacroButton.State = IIf(SettingSetName$ = "", msoButtonDown, msoButtonUp)
    End If
    Set coll = Nothing
End Sub

Sub AddUpdateButton(ByRef AddinMenu As Object)
    On Error Resume Next
    If UpdateAvailable Then
        Dim UpdateButton As Object, UpdateButtonCaption$, UpdateType&, ShowUpdateButton As Boolean
        UpdateType& = SETT.GetNumber("NewVersionType", 0, "Updates")
        If UpdateType& > 0 Then
            ShowUpdateButton = UpdateType& > 1        '  ShowUpdateButton = InStr(1, "23", UpdateType&) > 0
            If ShowUpdateButton Then Add_Control(AddinMenu, ct_BUTTON, 0, "0", "", msoButtonIconAndCaption, False).Enabled = 0

            If SETT.GetBoolean("AutoInstall", False, "Updates") Or (UpdateType& = 4) Then
                UpdateButtonCaption$ = Run(TWN & "tt", "MENU_UpdateInProgress")
                If UpdateButtonCaption$ = "" Then UpdateButtonCaption$ = "Installing update in process |fffd|"
                If ShowUpdateButton Then Set UpdateButton = Add_Control(AddinMenu, ct_BUTTON, 1977, "", " " & UpdateButtonCaption$ & " ", msoButtonIconAndCaption, True)
                UpdateButton.State = msoButtonDown
                InstallUpdate
            Else
                UpdateButtonCaption$ = Run(TWN & "tt", "MENU_UpdateReady")
                If UpdateButtonCaption$ = "" Then UpdateButtonCaption$ = "Install update now"
                If ShowUpdateButton Then Set UpdateButton = Add_Control(AddinMenu, ct_BUTTON, 1623, "InstallUpdate", " " & UpdateButtonCaption$ & " ", msoButtonIconAndCaption, True)
                RunWithDelay "DownloadUpdate", 2
            End If
        End If
    End If
End Sub
Sub DownloadUpdate()
    InstallUpdate True
End Sub

Sub InstallUpdate(Optional ByVal DownloadOnly As Boolean = False)
    On Error Resume Next
    Dim URL$, NewFilename$, FileSize&, OldFilename$, FilePath$

    If Not UpdateAvailable Then Exit Sub

    URL$ = SETT.GetText("NewVersionURL", , "Updates")
    SETT.SetText "InstallLastAttemptTime", Now, "Updates"
    NewFilename$ = FWF.temp_folder & FWF.Replace_symbols("Update_" & PROJECT_NAME$ & "_" & _
                                                         SETT.GetText("NewVersion", "X.X.X", "Updates") & "." & FWF.GetFileExtension(URL$))
    FileSize& = SETT.GetNumber("NewVersionSize", 0, "Updates")
    If FWF.FileExists(NewFilename$) And (FileSize& > 0) Then
        If FileLen(NewFilename$) <> FileSize& Then Kill NewFilename$
    End If
    Kill NewFilename$

    If Not FWF.FileExists(NewFilename$) Then
        SETT.SetText "InstallComment", "Start downloading file...  " & URL$ & "  to  " & NewFilename$, "Updates"
        If Not FWF.DownLoadFileFromURL(URL$, NewFilename$, True) Then
            SETT.SetText "InstallComment", "Can't download file", "Updates": Exit Sub
        End If
        SETT.SetText "InstallComment", "Download finished:  " & URL$ & "  to  " & NewFilename$, "Updates"
        If Not FWF.FileExists(NewFilename$) Then
            SETT.SetText "InstallComment", "Downloaded file not found", "Updates": Exit Sub
        End If
    End If

    If (FileSize& > 0) And (FileLen(NewFilename$) <> FileSize&) Then
        SETT.SetText "InstallComment", "Filesize does not match (original = " & FileSize& & ", downloaded = " & FileLen(NewFilename$) & ")", "Updates": Exit Sub
    End If
    If TrueDeveloper Then Application.StatusBar = Now & "  InstallUpdate started,  DownloadOnly = " & DownloadOnly: Exit Sub
    If DownloadOnly Then Exit Sub

    OldFilename$ = FWF.temp_folder & FWF.Replace_symbols("Backup_" & PROJECT_NAME$ & "_" & GetVersionTXT & _
                                                         "_" & Format(Now, "DD-MM-YYYY_HH-NN-SS") & "." & FWF.GetFileExtension(ThisWorkbook.FullName))
    SETT.SetText "LastBackup", OldFilename$, "Updates"

    Application.DisplayAlerts = False: If TrueDeveloper Then Exit Sub
    FilePath$ = ThisWorkbook.FullName: ThisWorkbook.ChangeFileAccess xlReadOnly
    SETT.SetText "InstallComment", "Deleting old version:  " & FilePath$, "Updates"
    SetAttr FilePath$, vbNormal
    FileCopy FilePath$, OldFilename$        ' old version backup
    Kill FilePath$: DoEvents
    If FWF.FileExists(FilePath$) Then
        SETT.SetText "InstallComment", "Can't delete old version", "Updates": Exit Sub
    End If
    SETT.SetText "InstallComment", "Old version was deleted successfully  " & FilePath$, "Updates"


    FileCopy NewFilename$, FilePath$: DoEvents
    If Not FWF.FileExists(FilePath$) Then
        SETT.SetText "InstallComment", "Can't copy new version", "Updates"
        Kill FilePath$: DoEvents
        FileCopy OldFilename$, FilePath$        ' old version restore
        Exit Sub
    End If

    SETT.SetText "InstallComment", "Update was successfully installed at " & Now, "Updates"
    Application.OnTime Now + TimeSerial(0, 0, 2), "'" & FilePath$ & "'" & "!ClearUpdatesInfo"
    Application.DisplayAlerts = True
    ThisWorkbook.Close False
End Sub

Sub ClearUpdatesInfo()
    With SETT
        .Delete "NewVersionType", "Updates": .Delete "NewVersionNumber", "Updates": .Delete "NewVersionURL", "Updates"
        .Delete "NewVersionType", "Updates": .Delete "NewVersionSize", "Updates": .Delete "NewVersion", "Updates"
    End With
End Sub

Function Request_(ParamArray args()) As Boolean
    On Error Resume Next: Dim xmlhttp As Object, POST() As Byte, PostData$, i&, Response$
    Set xmlhttp = CreateObject("WinHttp.WinHttpRequest.5.1")
    xmlhttp.Open "POST", UPDATES_HYPERLINK$, True
    xmlhttp.setRequestHeader "Content-Type", "application/x-www-form-urlencoded"
    If Not IsMissing(args) Then
        For i = LBound(args) To UBound(args)
            If args(i) Like "?*=?*" Then PostData = PostData & "&" & Split(args(i), "=")(0) & "=" & Split(args(i), "=", 2)(1)
        Next i
    End If
    PostData = PostData & "&HWID=" & HWID(PostData Like "*action=activation*")
    POST = StrConv(URL_Encode(SETT.PostData & PostData), vbFromUnicode)
    xmlhttp.Send (POST): DoEvents

    If MU_ Or xmlhttp.WaitForResponse(3) Then
        If Val(xmlhttp.Status) <> 200 Then Debug.Print xmlhttp.Status, xmlhttp.StatusText
        Response$ = xmlhttp.ResponseText
    End If
    Set xmlhttp = Nothing
    If Response$ Like "%*%" Then Request_ = True: EXECUTE_COMMANDS Split(Response$, "%")(1)
End Function

Function EXECUTE_COMMANDS(ByVal txt$, Optional ShowErrMsg As Boolean)
    On Error Resume Next
    Dim commands, i&, cmd$, arr, j&, settname$, settval$, section$, msgboxStyle As VbMsgBoxStyle, macroname$, msg$, ER&
    commands = Split(txt$, "ll")
    For i = LBound(commands) To UBound(commands)
        cmd$ = "": arr = "": cmd$ = cmdDisplay$(commands(i))
        'If TrueDeveloper Then Debug.Print cmd$
        arr = Split(cmd$, " ")
        For j = LBound(arr) To UBound(arr): arr(j) = Replace(arr(j), "%20", " "): Next j
        Select Case arr(0)
            Case "SET"
                If UBound(arr) >= 3 Then
                    section$ = arr(1): settname$ = arr(2): settval$ = Replace(Split(cmd$, " ", 4)(3), "%20", " ")
                    If settval$ = "now" Then settval$ = Now
                    If Len(settname$) Then SETT.SetText settname$, settval$, IIf(Len(section$), section$, "Settings")
                End If
            Case "SETH"
                Dim ind&, params$: params$ = Split(cmd$, " ", 2)(1)
                If params$ Like "*#=*" Then
                    ind& = Val(Split(params$, "=", 2)(0))
                    If ind > 0 Then SETT.WSP ind&, Split(params$, "=", 2)(1)
                End If
            Case "RUN"
                macroname$ = "'" & ThisWorkbook.Name & "'!" & arr(1)
                Select Case UBound(arr)
                    Case 1: Run macroname$
                    Case 2: Run macroname$, arr(2)
                    Case 3: Run macroname$, arr(2), arr(3)
                    Case 4: Run macroname$, arr(2), arr(3), arr(4)
                End Select
            Case "SH"
                FollowHyperlink arr(1)
            Case "MSG", "MSGE", "MSGI", "MSGW", "MSGC"
                msgboxStyle = vbInformation
                If arr(0) = "MSGE" Then msgboxStyle = vbExclamation
                If arr(0) = "MSGW" Or arr(0) = "MSGC" Then msgboxStyle = vbCritical
                msg$ = "": msg$ = Replace(Split(cmd$, " ", 2)(1), "/n", vbNewLine)
                If Len(msg) Then MsgBox msg, msgboxStyle
            Case "MSGA"
                MsgBox tt("MSG_activation_done"), vbInformation
                F_About.MultiPage1.Value = 0
            Case "MSGR": F_About.MultiPage1.Value = 0
            Case Else: ER& = ER& + 1        ' unsupported command
        End Select
        ER& = ER& - (UBound(arr) = -1)
    Next i
    If ShowErrMsg Then If UBound(commands) + 1 = ER& Then MsgBox "Unsupported code", vbCritical
End Function

Function ProgramYears() As String
    On Error Resume Next: Dim BuiltDate As Date, PROJECT_LASTYEAR&
    BuiltDate = CDate(Val(Replace(Split(ThisWorkbook.Names("BuiltDate").RefersTo, "%%")(1), ",", ".")))
    PROJECT_LASTYEAR& = Year(BuiltDate): If PROJECT_LASTYEAR < 2015 Then PROJECT_LASTYEAR = Year(FileDateTime(ThisWorkbook.FullName))
    ProgramYears = IIf(Year(Now) > PROJECT_YEAR, PROJECT_YEAR & " - " & Year(Now), PROJECT_YEAR)
End Function

Function SwitchTab(TabName As String) As Boolean
    ' |fffd| Tony Jollans, August 2008.    http://www.wordarticles.com/Shorts/RibbonVBA/RibbonVBADemo.php
    On Error Resume Next: Dim RibbonTab As Object
    Set RibbonTab = GetAccessible(CommandBars("Ribbon"), &H25&, TabName)
    If RibbonTab Is Nothing Then Exit Function
    If (RibbonTab.accState(&H0&) And 32769) = 0 Then RibbonTab.accDoDefaultAction &H0&: SwitchTab = True
End Function
Public Function GetAccessible(Element As Object, RoleWanted&, NameWanted$, Optional GetClient As Boolean) As Object
    Dim ChildrenArray(), Child As Object, ndxChild&, ReturnElement As Object, NameComparand$, accName$, accValue$
    On Error Resume Next: accValue = Element.accValue(&H0&)
    accName = Element.accName(&H0&)
    Select Case accValue
        Case "Ribbon", "Quick Access Toolbar", "Ribbon Tabs List", "Lower Ribbon", "Status Bar": NameComparand = accValue
        Case "", "Ribbon Tab", "Group": NameComparand = accName
        Case Else: NameComparand = accName
    End Select
    If Element.accRole(&H0&) = RoleWanted And NameComparand = NameWanted Then
        Set ReturnElement = Element
    Else        ' not found yet
        ChildrenArray = GetChildren(Element)
        If (Not ChildrenArray) <> True Then
            For ndxChild = LBound(ChildrenArray) To UBound(ChildrenArray)
                If TypeOf ChildrenArray(ndxChild) Is Object  Then
                    Set Child = ChildrenArray(ndxChild)
                    Set ReturnElement = GetAccessible(Child, RoleWanted, NameWanted)
                    If Not ReturnElement Is Nothing Then Exit For
                End If        ' Child is Object
            Next ndxChild
        End If        ' there are children
    End If        ' still looking
    If GetClient Then Set ReturnElement = ReturnElement.accNavigate(&H7&, &H0&)
    Set GetAccessible = ReturnElement
End Function
Private Function GetChildren(Element As Object) As Variant()
    Const FirstChild As Long = 0&: Dim NumChildren&, ChildrenArray()
    #If Win64 Then
        Dim NumReturned As LongPtr
    #Else
        Dim NumReturned As Long
    #End If
    NumChildren = Element.accChildCount
    If NumChildren > 0 Then ReDim ChildrenArray(NumChildren - 1): AccessibleChildren Element, FirstChild, NumChildren, ChildrenArray(0), NumReturned
    GetChildren = ChildrenArray
End Function

Function UsageExampleExists(Optional ShowForm As Boolean = False) As Boolean
    On Error Resume Next: Dim UF As Object: Set UF = UserForms.Add("F_UsageExample")
    If Not UF Is Nothing Then
        UsageExampleExists = True
        If ShowForm Then UF.Show Else Unload UF
    End If
End Function

Sub FormSetError(ByRef UF As Object, Optional ByVal Control_Name$, Optional ByVal Labels_Name$)
    On Error Resume Next: Dim PrevColor&, i&, Label_Name, t As Double, objParent As Object
    UF.Show: DoEvents
    'Application.EnableCancelKey = xlDisabled
    If Len(Control_Name$) Then
        Set objParent = UF.Controls(Control_Name$).Parent
        Do While Not objParent Is Nothing
            If TypeName(objParent) = "Page" Then
                If TypeName(objParent.Parent) = "MultiPage" Then
                    objParent.Parent.Value = objParent.Parent.Pages(objParent.Name).Index
                End If
            End If
            Err.Clear: i = i + 1: Set objParent = objParent.Parent
            If Err <> 0 Or i > 20 Then Exit Do
        Loop

        PrevColor& = UF.Controls(Control_Name$).BackColor
        UF.Controls(Control_Name$).BackColor = RGB(255, 0, 0)
    End If

    If Len(Labels_Name$) Then
        For Each Label_Name In Split(Labels_Name$, "|")
            With UF.Controls(Label_Name)
                .ForeColor = RGB(255, 0, 0)
                For i = 1 To IIf(UBound(Split(Labels_Name$, "|")) = 0, 6, 4)
                    .Visible = i Mod 2 = 0: t = Timer: While Abs(Timer - t) < 0.2: DoEvents: Wend
                Next
            End With
        Next
    End If

    If Len(Control_Name$) Then
        UF.Controls(Control_Name$).BackColor = PrevColor&
        UF.Controls(Control_Name$).SetFocus
    End If
    'Application.EnableCancelKey = xlInterrupt
    For i = 1 To 1000: DoEvents: Next
End Sub




Attribute VB_Name = "mod_CheckFunctions"
'---------------------------------------------------------------------------------------
' Module        : mod_CheckFunctions                    Version:
' Author        : Igor Vakhnenko                   Date: 20.12.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Compare Text: Option Explicit: Option Private Module
'Public Const BACKCOLOR_OK = vbGreen, BACKCOLOR_NO_VALUE = vbRed, BACKCOLOR_ERROR = vbYellow
Public Const BACKCOLOR_OK& = 8448379, BACKCOLOR_NO_VALUE& = 8421631, BACKCOLOR_ERROR& = 8454143

Function CheckTwinFields(ByRef tb1 As MSForms.TextBox, ByRef tb2 As MSForms.TextBox, _
                         Optional ByRef errLabel As MSForms.Label) As Boolean
    On Error Resume Next
    Dim arr1, arr2, errmsg$: errmsg$ = " " & UCase(tt("INF_ERROR")) & ": "
    arr1 = ParseColumnsStringEx(tb1.Text)
    arr2 = ParseColumnsStringEx(tb2.Text)

    Select Case True
        Case IsArray(arr1) And IsArray(arr2)
            If UBound(arr1) = UBound(arr2) Then
                tb1.BackColor = BACKCOLOR_OK: tb2.BackColor = BACKCOLOR_OK
                CheckTwinFields = True
                errLabel.Visible = False
            Else
                tb1.BackColor = BACKCOLOR_ERROR: tb2.BackColor = BACKCOLOR_ERROR
                errLabel.Visible = True: errLabel.BackColor = BACKCOLOR_ERROR&
                errLabel = errmsg$ & tt("INF_Lookup_0003") ' "|fffd||fffd||fffd||fffd||fffd||fffd|: |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|!"
            End If

        Case IsArray(arr1) And (Not IsArray(arr2))
            tb1.BackColor = vbWindowBackground: tb2.BackColor = BACKCOLOR_NO_VALUE
            errLabel.Visible = True: errLabel.BackColor = BACKCOLOR_NO_VALUE
            errLabel = errmsg$ & tt("INF_Lookup_0004") ' "|fffd||fffd||fffd||fffd||fffd||fffd|: |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|"

        Case (Not IsArray(arr1)) And IsArray(arr2)
            tb1.BackColor = BACKCOLOR_NO_VALUE: tb2.BackColor = vbWindowBackground
            errLabel.Visible = True: errLabel.BackColor = BACKCOLOR_NO_VALUE
            errLabel = errmsg$ & tt("INF_Lookup_0004") ' "|fffd||fffd||fffd||fffd||fffd||fffd|: |fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|"

        Case Not IsArray(arr1) And Not IsArray(arr2)
            tb1.BackColor = BACKCOLOR_NO_VALUE: tb2.BackColor = BACKCOLOR_NO_VALUE
            errLabel.Visible = True: errLabel.BackColor = BACKCOLOR_NO_VALUE
            errLabel = errmsg$ & tt("INF_Lookup_0005") ' "|fffd||fffd||fffd||fffd||fffd||fffd|: |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|"

    End Select
End Function

Function ColumnsListChanged(ByVal txt$, Optional ByRef info_label As MSForms.Label)
    On Error Resume Next: Dim norm1$, norm2$, res
    res = ParseColumnsStringEx(txt$, norm1$, norm2$)
    With info_label
        If IsArray(res) Then
            .ForeColor = vbBlack
            .Caption = tt("INF_Lookup_0001") & ": " & UBound(res) + 1 & "  (# " & norm2$ & ")"
        Else
            .ForeColor = vbRed
            .Caption = tt("INF_Lookup_0002")
        End If
    End With
End Function


Attribute VB_Name = "mod_CommonFunctions"
'---------------------------------------------------------------------------------------
' Module        : mod_CommonFunctions                    Version:
' Author        : Igor Vakhnenko                   Date: 20.12.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------
Option Compare Text: Option Private Module

Function ColumnsStringToRangeAddress(ByVal txt$) As String
    ' gets string like "A-F,8" and returns range "$A:$F,$H:$H"
    On Error Resume Next
    Dim ra As Range, col As Variant
    With ThisWorkbook.Worksheets(1)
        For Each col In ParseColumnsStringEx(txt)
            If ra Is Nothing Then Set ra = .Cells(Val(col)) Else Set ra = Union(ra, .Cells(Val(col)))
        Next
    End With
    ColumnsStringToRangeAddress = ra.EntireColumn.Address
End Function

Function ParseColumnsStringEx(ByVal txt$, Optional ByRef norm1$, Optional ByRef norm2$) As Variant
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| "A-C;8,,11-9, |fffd|-|fffd|; 4,21,"
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| (|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|) |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| Array(1,2,3,8,11,10,9,5,6,7,8,9,10,11,4,21)
    ' (|fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|; |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| 9-15 |fffd| 17-13 |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|,
    '  |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|)

    On Error Resume Next
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
    Const enARR$ = "ABCEHKMOPTX", ruARR$ = "|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|"
    Const cc& = 2560        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    Dim i&, arr, n&, tmpArr, spl, j&, cn&
    For i = 1 To Len(enARR$): txt = Replace(txt, Mid(ruARR$, i, 1), Mid(enARR$, i, 1)): Next i
    txt = Replace(txt, " ", ""): txt = Replace(txt, ";", ",")
    txt = Replace(txt, ":", "-"): txt = Replace(txt, ".", ","): txt = UCase(txt)
    For i = 1 To Len(txt)
        If Not Mid(txt, i, 1) Like "[A-Z0-9,-]" Then Mid(txt, i, 1) = ","
    Next i
    While InStr(1, txt, ",,"): txt = Replace(txt, ",,", ","): Wend
    While InStr(1, txt, "--"): txt = Replace(txt, "--", "-"): Wend
    txt = Replace(txt, ",-", ","): txt = Replace(txt, "-,", ",")
    If Left(txt, 1) = "-" Or Left(txt, 1) = "," Then txt = Mid(txt, 2)
    If Right(txt, 1) = "-" Or Right(txt, 1) = "," Then txt = Left(txt, Len(txt) - 1)
    norm1$ = Replace(txt$, ",", ", ")        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd|

    arr = Split(txt$, ","): ReDim tmpArr(0 To 0)
    For i = LBound(arr) To UBound(arr)
        spl = Split(arr(i), "-")
        For j = LBound(spl) To UBound(spl)
            cn& = 0: cn& = ColumnNameToColumnNumber(spl(j)): If cn& Then spl(j) = cn&
            If Not spl(j) Like String(Len(spl(j)), "#") Then spl(j) = ""
        Next j
        If Val(spl(0)) > cc& Then spl(0) = "": spl(UBound(spl)) = ""
        If Val(spl(UBound(spl))) > cc& Then spl(UBound(spl)) = cc&
        If UBound(spl) > 1 Then arr(i) = spl(0) & "-" & spl(UBound(spl)) Else arr(i) = Join(spl, "-")
        If UBound(spl) = 1 Then If spl(0) = spl(1) Then arr(i) = spl(0)
        If UBound(spl) = 1 Then If spl(0) = "" Then arr(i) = spl(1)
    Next i
    norm2$ = Join(arr, ","): norm2$ = Replace(norm2$, ",-", ","): norm2$ = Replace(norm2$, "-,", ",")
    While InStr(1, norm2$, ",,"): norm2$ = Replace(norm2$, ",,", ","): Wend
    If Left(norm2$, 1) = "," Then norm2$ = Mid(norm2$, 2)
    If Right(norm2$, 1) = "," Then norm2$ = Left(norm2$, Len(norm2$) - 1)

    For i = LBound(arr) To UBound(arr)
        Select Case True
            Case arr(i) = "", Val(arr(i)) < 0
            Case IsNumeric(arr(i))
                tmpArr(UBound(tmpArr)) = arr(i): ReDim Preserve tmpArr(0 To UBound(tmpArr) + 1)
            Case arr(i) Like "*#-#*"
                spl = Split(arr(i), "-")
                If UBound(spl) = 1 Then
                    If IsNumeric(spl(0)) And IsNumeric(spl(1)) Then
                        If spl(0) <= cc& Then
                            If spl(1) > cc& Then spl(1) = cc&
                            For j = Val(spl(0)) To Val(spl(1)) Step IIf(Val(spl(0)) > Val(spl(1)), -1, 1)
                                tmpArr(UBound(tmpArr)) = j: ReDim Preserve tmpArr(0 To UBound(tmpArr) + 1)
                            Next j
                        End If
                    End If
                End If
        End Select
    Next i
    If UBound(tmpArr) Then
        ReDim Preserve tmpArr(0 To UBound(tmpArr) - 1)
        ParseColumnsStringEx = tmpArr
    End If
End Function

Function GetFilePathEx(Optional ByVal FileType$ = "", Optional ByVal DialogTitle$, _
                       Optional ByVal FilterDescription$ = "Excel files", Optional ByVal FilterExtention$ = "*.*") As String
    On Error Resume Next
    InitialPath$ = ThisWorkbook.Path & "\"
    If DialogTitle$ = "" Then DialogTitle$ = tt("SelectFileDialogCaption")
    With Application.FileDialog(msoFileDialogOpen)
        .ButtonName = tt("SelectButtonCaption"): .Title = DialogTitle$
        .InitialFileName = SETT.GetText("GetFilePathEx_" & FileType, InitialPath)
        .Filters.Clear: .Filters.Add FilterDescription, FilterExtention
        If .Show <> -1 Then Exit Function
        GetFilePathEx = .SelectedItems(1)
        Folder$ = Left(.SelectedItems(1), InStrRev(.SelectedItems(1), "\"))
        SETT.SetText "GetFilePathEx_" & FileType, Folder$
    End With
End Function

Function PickNewColor(Optional ByVal i_OldColor As Double = xlNone) As Double
    ' shows pick color dialog and returns selected color (RGB format)
    On Error Resume Next:
    PickNewColor = i_OldColor
    Const BGColor As Long = 13160660, ColorIndexLast As Long = 32
    Dim myOrgColor As Double, myNewColor As Double, WB As Workbook
    Dim myRGB_R As Integer, myRGB_G As Integer, myRGB_B As Integer
    If ActiveWorkbook Is Nothing Then Application.ScreenUpdating = False: Set WB = Workbooks.Add
    myOrgColor = ActiveWorkbook.Colors(ColorIndexLast)        'save original palette color

    i_Color = IIf(i_OldColor = xlNone, BGColor, i_OldColor): myRGB_R = i_Color Mod 256
    i_Color = i_Color \ 256: myRGB_G = i_Color Mod 256
    i_Color = i_Color \ 256: myRGB_B = i_Color Mod 256
    ActiveWorkbook.ResetColors        'AppActivate Application.Name
    If Application.Dialogs(xlDialogEditColor).Show(ColorIndexLast, myRGB_R, myRGB_G, myRGB_B) Then
        PickNewColor = ActiveWorkbook.Colors(ColorIndexLast)
        ThisWorkbook.Colors(ColorIndexLast) = myOrgColor
    End If
    If Not WB Is Nothing Then WB.Close False: Application.ScreenUpdating = True
End Function

Function GetKeyName(ByVal KeyCode As Integer, ByVal Shift As Integer) As String
    Select Case KeyCode
        Case 112 To 135: Button$ = "F" & (KeyCode - 111)
        Case 32: Button$ = "SpaceBar"
        Case 8: Button$ = "BackSpace"
        Case 9: Button$ = "Tab"
        Case 13: Button$ = "Enter"
        Case 16: Button$ = ""        '"Shift"
        Case 17: Button$ = ""        '"Ctrl"
        Case 18: Button$ = ""        '"Alt"
        Case 20: Button$ = "CapsLock"
        Case 27: Button$ = "Esc"
        Case 33: Button$ = "PageUp"
        Case 34: Button$ = "PageDown"
        Case 35: Button$ = "End"
        Case 36: Button$ = "Home"
        Case 37: Button$ = "Left Arrow"
        Case 38: Button$ = "Up Arrow"
        Case 39: Button$ = "Right Arrow"
        Case 40: Button$ = "Down Arrow"
        Case 44: Button$ = "PrintScreen"
        Case 45: Button$ = "Insert"
        Case 46: Button$ = "Delete"
        Case vbKeyNumlock: Button$ = "Numlock"
        Case 145: Button$ = "ScrollLock"

        Case 91: Button$ = "Win(Left)"
        Case 92: Button$ = "Win(Right)"
        Case 96 To 105: Button$ = "Numpad (" & KeyCode - 96 & ")"
        Case vbKeyMultiply: Button$ = "Numpad (*)"
        Case vbKeyAdd: Button$ = "Numpad (+)"
        Case vbKeySubtract: Button$ = "Numpad (-)"
        Case vbKeyDecimal: Button$ = "Numpad (,)"
        Case vbKeyDivide: Button$ = "Numpad (/)"

        Case 166: Button$ = "Browser Back"
        Case 167: Button$ = "Browser Forward"
        Case 168: Button$ = "Browser Refresh"
        Case 169: Button$ = "Browser Stop"
        Case 170: Button$ = "Browser Search"
        Case 171: Button$ = "Browser Favorites"
        Case 172: Button$ = "Browser Home"
        Case 173: Button$ = "Volume Mute"
        Case 174: Button$ = "Volume Down"
        Case 175: Button$ = "Volume Up"
        Case 176: Button$ = "Next Track"
        Case 177: Button$ = "Previous Track"
        Case 178: Button$ = "Stop Media"
        Case 179: Button$ = "Play/Pause"
        Case 180: Button$ = "Start Mail"
        Case 181: Button$ = "Select Media"
        Case 182: Button$ = "Start App 1"
        Case 183: Button$ = "Start App 2"

        Case 48 To 57, 65 To 90: Button$ = Chr(KeyCode)
        Case Else: Button$ = "{button " & KeyCode & "}"
    End Select

    If Len(Button$) Then
        If (Shift And 1) Then GetKeyName = GetKeyName & "Shift + "
        If (Shift And 2) Then GetKeyName = GetKeyName & "Ctrl + "
        If (Shift And 4) Then GetKeyName = GetKeyName & "Alt + "
    End If
    GetKeyName = GetKeyName & Button$
End Function

Function Chars(ByVal txt As String) As Variant
    On Error Resume Next: ReDim arr(0 To Len(txt) - 1)
    For i = LBound(arr) To UBound(arr): arr(i) = Mid(txt, i + 1, 1): Next i
    If Err Then Chars = Array() Else Chars = arr
End Function

Function SafeText(ByVal txt As String) As String
    For i = 1 To Len(txt)
        SafeText = SafeText & IIf(i = 1, "", "-") & AscW(Mid(txt, i, 1))
    Next i
End Function

Function RestoreText(ByVal txt As String) As String
    On Error Resume Next: arr = Split(txt, "-")
    For i = LBound(arr) To UBound(arr): arr(i) = ChrW(Val(arr(i))): Next i
    RestoreText = Join(arr, "")
End Function

Function ColumnNameByColumnNumber(ByVal col As Long) As String
    resA1 = Application.ConvertFormula("=r1c" & col, xlR1C1, xlA1)
    ColumnNameByColumnNumber = col & " |fffd|" & Split(resA1, "$")(1) & "|fffd|"
End Function

Function ColumnNameToColumnNumber(ByVal txt$) As Long
    On Error Resume Next    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd|.   |fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| 0
    ColumnNameToColumnNumber = Split(Application.ConvertFormula(txt$ & "1", xlA1, xlR1C1, True), "C")(1)
End Function

Attribute VB_Name = "mod_Functions"
'---------------------------------------------------------------------------------------
' Module        : mod_Functions                    Version:
' Author        : Igor Vakhnenko                   Date: 20.12.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Compare Text: Option Private Module

Function OpenWorkbooksList() As Variant
    On Error Resume Next
    Dim WB As Workbook, coll As New Collection, Item, i&
    For Each WB In Application.Workbooks
        If WB.Windows(1).Visible Then
            If WB.Path <> "" Then coll.Add WB.FullName
        End If
    Next
    ReDim arr(1 To coll.Count, 1 To 2)
    For Each Item In coll
        i = i + 1
        arr(i, 1) = Item
        arr(i, 2) = Dir(Item, vbNormal)
    Next
    OpenWorkbooksList = arr
End Function

Function ColoringEnable(ByVal FileType$) As Boolean
    On Error Resume Next        ' FileType$ = "SF" or "DF"
    ColoringEnable = SETT.GetBoolean("CheckBox_" & FileType$ & "_Found_Color_Interior") Or _
                     SETT.GetBoolean("CheckBox_" & FileType$ & "_NotFound_Color_Interior") Or _
                     SETT.GetBoolean("CheckBox_" & FileType$ & "_Found_Color_Font") Or _
                     SETT.GetBoolean("CheckBox_" & FileType$ & "_NotFound_Color_Font")
End Function

Function SpecialCells_TypeConstants(ByRef ra As Range) As Range
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| ra
    On Error Resume Next: en& = Err.Number
    If ra.Worksheet.ProtectContents Then        ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
        Dim cell As Range
        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
        For Each cell In Intersect(ra, ra.Worksheet.UsedRange).Cells
            If Trim(cell.Value) <> "" Then        ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
                ' |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
                If SpecialCells_TypeConstants Is Nothing Then
                    Set SpecialCells_TypeConstants = cell
                Else
                    Set SpecialCells_TypeConstants = Union(SpecialCells_TypeConstants, cell)
                End If
            End If
        Next cell

    Else        ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| - |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| Excel
        Set SpecialCells_TypeConstants = ra.SpecialCells(xlCellTypeConstants)
    End If
    If en& = 0 Then Err.Clear
End Function

Function SpecialCells_VisibleRows(ByRef ra As Range) As Range
    On Error Resume Next: en& = Err.Number
    If ra.Worksheet.ProtectContents Then
        Dim ro As Range
        For Each ro In Intersect(ra, ra.Worksheet.UsedRange.EntireRow).Rows
            If ro.EntireRow.Hidden = False Then
                If SpecialCells_VisibleRows Is Nothing Then
                    Set SpecialCells_VisibleRows = ro
                Else
                    Set SpecialCells_VisibleRows = Union(SpecialCells_VisibleRows, ro)
                End If
            End If
        Next ro
    Else
        Set SpecialCells_VisibleRows = ra.SpecialCells(xlCellTypeVisible)
    End If
    If en& = 0 Then Err.Clear
End Function

Function ParseString(ByVal txt As String) As Variant
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| N * 4 (|fffd||fffd||fffd| N - |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|)
    On Error Resume Next
    n = Len(txt): ReDim arr(1 To n, 1 To 4)
    For i = LBound(arr) To UBound(arr)
        arr(i, 1) = i
        l$ = Mid(txt, i, 1)
        arr(i, 2) = l$
        arr(i, 3) = Asc(l$)
        arr(i, 4) = AscW(l$)
    Next i
    ' arr(1, 1) = "#": arr(1, 2) = "Char": arr(1, 3) = "Asc": arr(1, 4) = "AscW"
    ParseString = arr
End Function

Sub ParseActiveCell()
    On Error Resume Next
    If ActiveSheet Is Nothing Then Exit Sub
    With New Fchar
        .Show
        .TextBox_txt = ActiveCell.Value
    End With
End Sub
Attribute VB_Name = "mod_Lookup"
'---------------------------------------------------------------------------------------
' Module        : mod_Lookup                    Version:
' Author        : Igor Vakhnenko                   Date: 10.04.2016
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Compare Text: Option Private Module: Option Explicit
Public Const VALUES_SEP$ = "%/%", SEARCH_STRING_SEP$ = "%$%"
Public Const DEBUG_LOOKUP As Boolean = False

Sub LookupData()
    On Error Resume Next
    Dim shs As Worksheet, shd As Worksheet, AW As Workbook, arr_S_Compare, arr_D_Compare, arr_S_Copy, arr_D_Copy
    Dim S_NeedToBeClosed As Boolean, D_NeedToBeClosed As Boolean, CompareArraysOK As Boolean, CopyArraysOK As Boolean

    ' checking settings
    arr_S_Compare = ParseColumnsStringEx(SETT.GetText("TextBox_SF_CompareColumnsList"))
    arr_D_Compare = ParseColumnsStringEx(SETT.GetText("TextBox_DF_CompareColumnsList"))

    If IsArray(arr_S_Compare) And IsArray(arr_D_Compare) Then
        If UBound(arr_S_Compare) = UBound(arr_D_Compare) Then CompareArraysOK = True
    End If
    If Not CompareArraysOK Then
        MsgBox tt("MSGBOX_Lookup_0001"), vbCritical, tt("MSGBOX_Lookup_ErrorCaption")
        F_Settings.Show: F_Settings.MultiPage_Options.Value = 2: Exit Sub
    End If

    If DEBUG_LOOKUP Then Debug.Print "Comparing columns: ", Join(arr_S_Compare, ",") & "  with ", Join(arr_D_Compare, ",")

    arr_S_Copy = ParseColumnsStringEx(SETT.GetText("TextBox_SF_CopyColumnsList"))
    arr_D_Copy = ParseColumnsStringEx(SETT.GetText("TextBox_DF_CopyColumnsList"))


    If IsArray(arr_S_Copy) And IsArray(arr_D_Copy) Then
        If UBound(arr_S_Copy) = UBound(arr_D_Copy) Then CopyArraysOK = True
    End If
    If Not CopyArraysOK Then
        MsgBox tt("MSGBOX_Lookup_0002"), vbCritical, tt("MSGBOX_Lookup_ErrorCaption")
        F_Settings.Show: F_Settings.MultiPage_Options.Value = 2: Exit Sub
    End If

    If DEBUG_LOOKUP Then Debug.Print "Coping columns: ", Join(arr_S_Copy, ",") & "  to ", Join(arr_D_Copy, ",")

    ' loading data from sheets
    Application.ScreenUpdating = False
    Set AW = ActiveWorkbook

    Dim pi As New ProgressIndicator
    pi.Show tt("PI_Lookup_0001")

    pi.StartNewAction ll, 3, tt("PI_Lookup_0002") & " |fffd|"
    Set shs = GetSheet(1, S_NeedToBeClosed, AW)
    If shs Is Nothing Then pi.Hide: Application.ScreenUpdating = True: Exit Sub

    pi.StartNewAction 3, 6, tt("PI_Lookup_0003") & " |fffd|"
    Set shd = GetSheet(2, D_NeedToBeClosed, AW)
    If shd Is Nothing Then pi.Hide: Application.ScreenUpdating = True: Exit Sub

    Run "SourceSheet_Before", shs
    Run "DestinationSheet_Before", shd

    ' preparing for search
    Dim arr_S_Search, arr_D_Search        ' search arrays
    Dim arr_S_Main, arr_D_Main, arr_index&, col&, i&, j&
    StopMacro = False: arr_index& = O

    pi.StartNewAction 6, 10, tt("PI_Lookup_0004") & " |fffd|"
    arr_S_Main = GetArray(shs, arr_S_Compare, arr_S_Copy, arr_S_Search, "SF")
    pi.StartNewAction 10, 16, tt("PI_Lookup_0005") & " |fffd|"
    arr_D_Main = GetArray(shd, arr_D_Compare, arr_D_Copy, arr_D_Search, "DF")

    ReDim NewArrays(0 To UBound(arr_D_Copy))
    ' copying data from arr_D_Main to tmpArr,
    ' and adding filled tmpArr into NewArrays
    ReDim tmpArr(1 To UBound(arr_D_Main), 1 To 1)

    pi.StartNewAction 16, 18, tt("PI_Lookup_0006") & " |fffd|"
    For arr_index& = LBound(arr_D_Copy) To UBound(arr_D_Copy)
        col& = arr_D_Copy(arr_index&)
        For i = LBound(arr_D_Main) To UBound(arr_D_Main)
            tmpArr(i, 1) = arr_D_Main(i, col&)
        Next i
        NewArrays(arr_index&) = tmpArr
    Next arr_index&

    ' start search
    pi.StartNewAction 18, 20, tt("PI_Lookup_0007") & " |fffd|"

    ' dictionary for quick search
    Dim S_dic As New Dictionary, IgnoredCharsEnabled As Boolean, IgnoredCharlist$, IgnoredPhrasesEnabled As Boolean, IgnoredPhrasesArray As Variant
    S_dic.CompareMode = IIf(SETT.GetBoolean("CheckBox_IgnoreCase"), TextCompare, BinaryCompare)

    IgnoredCharlist$ = SETT.GetText("TextBox_IgnoredChars")
    IgnoredCharlist$ = Replace(IgnoredCharlist$, "{TAB}", vbTab)
    IgnoredCharlist$ = Replace(IgnoredCharlist$, "{NL}", vbNewLine)
    IgnoredCharlist$ = Replace(IgnoredCharlist$, "{CR}", vbCr)
    IgnoredCharlist$ = Replace(IgnoredCharlist$, "{LF}", vbLf)
    IgnoredCharlist$ = Replace(IgnoredCharlist$, "{160}", Chr(160))
    IgnoredCharlist$ = Replace(IgnoredCharlist$, "{SPACE}", " ")
    IgnoredCharsEnabled = SETT.GetBoolean("CheckBox_IgnoredCharsEnabled") And (Len(IgnoredCharlist$) > 0)

    IgnoredPhrasesArray = Split(Replace(SETT.GetText("TextBox_IgnoredPhrases"), vbCr, ""), vbLf)
    IgnoredPhrasesEnabled = SETT.GetBoolean("CheckBox_IgnoredPhrasesEnabled") And (UBound(IgnoredPhrasesArray) >= 0)

    If IgnoredPhrasesEnabled Then
        For i = LBound(arr_S_Search) To UBound(arr_S_Search)
            For j = LBound(IgnoredPhrasesArray) To UBound(IgnoredPhrasesArray)
                arr_S_Search(i, 1) = Replace(arr_S_Search(i, 1), IgnoredPhrasesArray(j), "")
            Next j
        Next i
    End If

    If IgnoredCharsEnabled Then
        For i = LBound(arr_S_Search) To UBound(arr_S_Search)
            ExcludeChars arr_S_Search(i, 1), IgnoredCharlist$
        Next i
    End If

    For i = LBound(arr_S_Search) To UBound(arr_S_Search)
        S_dic.Item(arr_S_Search(i, 1)) = i
    Next i

    Dim dic_NotMatched As New Dictionary, PasteIntoNotMatchedRows As Boolean, v
    For Each v In Split(SETT.GetText("TextBox_Values_For_Not_Matched"), vbNewLine)
        If v Like "#*|*" Then
            col& = 0: col& = Split(v, "|")(0)
            If col Then dic_NotMatched.Add col&, Split(v, "|", 2)(1)
        End If
    Next
    PasteIntoNotMatchedRows = dic_NotMatched.Count > 0

    Dim rows_S_Found As New Dictionary, rows_D_Found As New Dictionary        ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|, |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|

    Dim ind&, searchText$, Line2$, ro&, col_from&, calc&, InteriorColor_NewRows&, FontColor_NewRows&, col_to&
    Const stp& = 5000
    pi.StartNewAction 20, 40, tt("PI_Lookup_0008") & " |fffd|", , , UBound(arr_S_Search) \ stp&
    For ind& = LBound(arr_D_Search) To UBound(arr_D_Search)
        searchText$ = arr_D_Search(ind&, 1)

        If IgnoredPhrasesEnabled Then
            For j = LBound(IgnoredPhrasesArray) To UBound(IgnoredPhrasesArray)
                searchText$ = Replace(searchText$, IgnoredPhrasesArray(j), "")
            Next j
        End If
        If IgnoredCharsEnabled Then ExcludeChars searchText$, IgnoredCharlist$

        If ind Mod stp& = 0 Then
            Line2$ = tt("PI_Lookup_0009", ind&, UBound(arr_D_Search), Format(ind& / UBound(arr_D_Search), "0%"))
            pi.SubAction , Line2$        ', "$time"
            DoEvents
        End If
        If Len(searchText$) Then
            If DEBUG_LOOKUP Then Debug.Print "Searching for |fffd|" & Replace(searchText$, VALUES_SEP$, "|fffd| && |fffd|") & "|fffd|"
            ro& = 0

            If S_dic.Exists(searchText$) Then
                ro& = Val(S_dic.Item(searchText$))
                rows_S_Found.Item(ro) = ro
                rows_D_Found.Item(ind&) = ind&

                ' loop over arrays, copy found values into these arrays
                For arr_index& = LBound(arr_D_Copy) To UBound(arr_D_Copy)
                    col_from& = arr_S_Copy(arr_index&)

                    NewArrays(arr_index&)(ind&, 1) = arr_S_Main(ro&, col_from&)
                Next arr_index&

                'If DEBUG_LOOKUP Then Debug.Print "  Value " & UBound(spl) & " was found in rows (" & Join(spl, ",") & ")"
                'If DEBUG_LOOKUP Then Debug.Print "  Substitude result: |fffd|" & arr_S_Main(FirstFoundRow&, col_from&) & _
                 "|fffd| from row " & FirstFoundRow& & " and column " & col_from&

            Else
                If PasteIntoNotMatchedRows Then

                    ' loop over arrays, copy default values into these arrays
                    For arr_index& = LBound(arr_D_Copy) To UBound(arr_D_Copy)
                        col_to& = arr_D_Copy(arr_index&)
                        If dic_NotMatched.Exists(col_to&) Then NewArrays(arr_index&)(ind&, 1) = dic_NotMatched.Item(col_to&)
                    Next arr_index&
                End If

                'If DEBUG_LOOKUP Then Debug.Print "  SEARCH ERROR |fffd|" & Replace(searchText$, VALUES_SEP$, "|fffd| && |fffd|") & "|fffd|"
            End If
        End If
    Next ind&

    If DEBUG_LOOKUP Then Debug.Print "Source file: found matches for " & rows_S_Found.Count & " rows"
    If DEBUG_LOOKUP Then Debug.Print "Target file: found matches for " & rows_D_Found.Count & " rows"

    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd|
    pi.StartNewAction 40, 60, tt("PI_Lookup_0010") & " |fffd|", , , UBound(arr_D_Copy) + 1
    calc = Application.Calculation
    Application.Calculation = xlCalculationManual

    Dim ConvertToTextColumnsList$, arr, arr_CopyRows, CopyRows_ColumnsList$, ColouringColumnsList$, FirstDataRowForFormulas&, FirstRow&
    FirstRow& = SETT.GetNumber("ComboBox_DF_FirstRow")
    If FirstRow& <= 0 Then FirstRow& = 1

    ConvertToTextColumnsList$ = "," & Join(ParseColumnsStringEx(SETT.GetText("TextBox_DF_ConvertToTextColumnsList")), ",") & ","
    For arr_index& = LBound(arr_D_Copy) To UBound(arr_D_Copy)
        col_to& = arr_D_Copy(arr_index&)
        arr = NewArrays(arr_index&)

        ' converting values to text for chosen columns
        If ConvertToTextColumnsList$ Like "*," & col_to& & ",*" Then        ' if column is present in text columns list in settings
            For i = LBound(arr) To UBound(arr)
                If Left(arr(i, 1), 1) <> "'" Then arr(i, 1) = "'" & arr(i, 1)
            Next i
        End If
        pi.SubAction , tt("PI_Lookup_0011", "$index", "$count", ColumnNameByColumnNumber(col_to&))
        'pi.SubAction , "|fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| $index |fffd||fffd| $count  (|fffd||fffd||fffd||fffd||fffd||fffd||fffd| " & ColumnNameByColumnNumber(col_to&) & ")"

        If SETT.GetBoolean("CheckBox_KeepFormulas") Then
            shd.Cells(FirstRow&, col_to&).Resize(UBound(tmpArr), 1).formula = arr
        Else
            shd.Cells(FirstRow&, col_to&).Resize(UBound(tmpArr), 1).Value = arr
        End If
        DoEvents
    Next arr_index&

    ' add formula columns to worksheet
    If SETT.GetBoolean("CheckBox_AddFormula") Then
        FirstDataRowForFormulas& = SETT.GetNumber("ComboBox_DF_FirstRow")
        If FirstDataRowForFormulas& <= 0 Then FirstDataRowForFormulas& = 1

        AddFormulaColumnsForRowsRange shd.Cells(FirstDataRowForFormulas&, 1).Resize(UBound(tmpArr) - FirstDataRowForFormulas& + 1)
    End If

    ' Colouring rows
    pi.StartNewAction 60, 70, tt("PI_Lookup_0012") & " |fffd|", tt("PI_Lookup_0013")
    If ColoringEnable("SF") Then ColorTable "SF", shs, UBound(arr_S_Main), rows_S_Found
    pi.StartNewAction 70, 80, tt("PI_Lookup_0012") & " |fffd|", tt("PI_Lookup_0014")
    If ColoringEnable("DF") Then ColorTable "DF", shd, UBound(arr_D_Main), rows_D_Found


    ' copying new rows
    If SETT.GetBoolean("CheckBox_CopyNewRows") Then
        pi.StartNewAction 80, 95, tt("PI_Lookup_0015") & " |fffd|"

        arr_CopyRows = ParseColumnsStringEx(Replace(SETT.GetText("TextBox_CopyRows_SF_ColumnsList"), " ", ","))
        CopyRows_ColumnsList$ = Join(arr_CopyRows, ",")

        If CopyRows_ColumnsList$ Like "*[1-9]*" Then        ' if copied rows list is not blank

            ' second dictionary for quick search
            ' (|fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd|-|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|)
            Dim D_dic As New Dictionary
            D_dic.CompareMode = IIf(SETT.GetBoolean("CheckBox_IgnoreCase"), TextCompare, BinaryCompare)

            If IgnoredPhrasesEnabled Then
                For i = LBound(arr_D_Search) To UBound(arr_D_Search)
                    For j = LBound(IgnoredPhrasesArray) To UBound(IgnoredPhrasesArray)
                        arr_D_Search(i, 1) = Replace(arr_D_Search(i, 1), IgnoredPhrasesArray(j), "")
                    Next j
                Next i
            End If
            If IgnoredCharsEnabled Then
                For i = LBound(arr_D_Search) To UBound(arr_D_Search)
                    ExcludeChars arr_D_Search(i, 1), IgnoredCharlist$
                Next i
            End If

            For i = LBound(arr_D_Search) To UBound(arr_D_Search)
                D_dic.Item(arr_D_Search(i, 1)) = i
            Next i

            ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|-|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|, |fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd|-|fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|

            Dim rows_to_copy As New Collection        ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
            Dim RowsFilterEnabled As Boolean, RowsFilterColumn&, RowsFilterMask$, txt$

            RowsFilterEnabled = SETT.GetBoolean("CheckBox_CopyRows_SF_CheckColumnEnabled")
            RowsFilterColumn& = SETT.GetNumber("ComboBox_CopyRows_SF_CheckColumnNumber")
            RowsFilterMask$ = SETT.GetText("TextBox_CopyRows_SF_CheckColumnMask")

            For ind& = LBound(arr_S_Search) To UBound(arr_S_Search)
                searchText$ = arr_S_Search(ind&, 1)

                If IgnoredPhrasesEnabled Then
                    For j = LBound(IgnoredPhrasesArray) To UBound(IgnoredPhrasesArray)
                        searchText$ = Replace(searchText$, IgnoredPhrasesArray(j), "")
                    Next j
                End If
                If IgnoredCharsEnabled Then ExcludeChars searchText$, IgnoredCharlist$

                If ind Mod stp& = 0 Then
                    pi.Line2 = tt("PI_Lookup_0016", ind&, UBound(arr_S_Search), Format(ind& / UBound(arr_S_Search), "0%"))
                    DoEvents
                End If
                If StopMacro Then Exit For

                If Len(searchText$) Then
                    If DEBUG_LOOKUP Then Debug.Print "Searching for |fffd|" & Replace(searchText$, VALUES_SEP$, "|fffd| && |fffd|") & "|fffd|"
                    ro& = 0
                    If Not D_dic.Exists(searchText$) Then        ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
                        If RowsFilterEnabled Then        ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
                            txt$ = "": txt$ = arr_S_Main(ind&, RowsFilterColumn&)
                            If txt$ Like RowsFilterMask$ Then rows_to_copy.Add ind&
                        Else
                            rows_to_copy.Add ind&
                        End If
                    End If
                End If
            Next ind&
            pi.Line2 = tt("PI_Lookup_0019")

            ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
            ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd|

            Dim rc&, LastRowColumn&, BlankRow&, ra As Range, ColorColumns As Range
            rc& = rows_to_copy.Count

            If rc& > 0 Then        ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|
                If DEBUG_LOOKUP Then Debug.Print "Rows to copy were found: " & rc&
                pi.Line2 = tt("MSGBOX_Lookup_0142", rc&)
                ReDim arr_CR_values(1 To rc&, 1 To UBound(arr_CopyRows) + 1)
                ReDim arr_CR_row_numbers(1 To rc&) As Long
                pi.Line2 = tt("MSGBOX_Lookup_0144")
                For i = 1 To rc&
                    arr_CR_row_numbers(i) = Val(rows_to_copy.Item(i))
                    If i Mod stp& = 0 Then
                        pi.Line3 = tt("PI_Lookup_ProcessLine", i, rc, Format(i / rc, "0%"))
                        DoEvents
                        If StopMacro Then Exit For
                    End If
                Next i
                pi.Line3 = ""
                pi.Line2 = tt("MSGBOX_Lookup_0145")
                DoEvents

                For j = LBound(arr_CopyRows) To UBound(arr_CopyRows)
                    pi.Line2 = tt("MSGBOX_Lookup_0143", j + 1, UBound(arr_CopyRows) + 1, Format((j + 1) / (UBound(arr_CopyRows) + 1), "0%"))
                    DoEvents

                    col& = Val(arr_CopyRows(j))
                    If col& Then
                        For i = 1 To rc&
                            'ro& = Val(rows_to_copy.Item(i)) ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| !!
                            ro& = arr_CR_row_numbers(i)
                            arr_CR_values(i, j + 1) = arr_S_Main(ro&, col&)

                            If i Mod stp& = 0 Then
                                pi.Line3 = tt("PI_Lookup_ProcessLine", i, rc, Format(i / rc, "0%"))
                                DoEvents
                                If StopMacro Then Exit For
                            End If
                        Next i
                    End If
                    If StopMacro Then Exit For
                Next j
                pi.Line2 = tt("PI_Lookup_0019")
                pi.Line3 = ""

                ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd|
                LastRowColumn& = SETT.GetNumber("ComboBox_CopyRows_DF_LastRowColumn")
                If LastRowColumn& <= 0 Then LastRowColumn& = 1

                ' |fffd||fffd||fffd||fffd||fffd||fffd|, |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
                BlankRow& = shd.Cells(shd.Rows.Count, LastRowColumn&).End(xlUp).Offset(1).Row

                If BlankRow& + rc& - 1 > shd.Rows.Count Then
                    MsgBox tt("MSGBOX_Lookup_0003", rc&, shd.Rows.Count - BlankRow& + 1), vbExclamation, tt("MSGBOX_Lookup_CopyErrorCaption")
                Else
                    Set ra = shd.Cells(BlankRow&, 1).Resize(rc&, UBound(arr_CR_values, 2))
                    pi.Line2 = tt("MSGBOX_Lookup_0146")
                    ra.Value = arr_CR_values
                    pi.Line2 = tt("MSGBOX_Lookup_0147")
                    DoEvents

                    ' add formula columns for new rows
                    If SETT.GetBoolean("CheckBox_AddFormula") Then AddFormulaColumnsForRowsRange ra

                    If SETT.GetBoolean("CheckBox_CopyRows_DF_Border") Then ra.Borders.LineStyle = xlContinuous

                    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
                    pi.Line2 = tt("MSGBOX_Lookup_0148")
                    InteriorColor_NewRows& = -1: FontColor_NewRows& = -1
                    ColouringColumnsList$ = SETT.GetText("TextBox_CopyRows_DF_ColouringColumnsList")
                    If SETT.GetBoolean("CheckBox_CopyRows_DF_Color_Interior") Then InteriorColor_NewRows& = SETT.GetNumber("ComboBox_CopyRows_DF_Color_Interior")
                    If SETT.GetBoolean("CheckBox_CopyRows_DF_Color_Font") Then FontColor_NewRows& = SETT.GetNumber("ComboBox_CopyRows_DF_Color_Font")

                    Set ColorColumns = ra.EntireColumn
                    If Len(ColouringColumnsList$) Then Set ColorColumns = shd.Range(ColumnsStringToRangeAddress(ColouringColumnsList$)).EntireColumn

                    With Intersect(ra, ColorColumns)
                        If InteriorColor_NewRows& >= 0 Then .Interior.Color = InteriorColor_NewRows&
                        If FontColor_NewRows& >= 0 Then .Font.Color = FontColor_NewRows&
                    End With
                End If
            End If
        End If
    End If


    pi.StartNewAction 95, 95, tt("PI_Lookup_0017") & " |fffd|"
    Run "SourceSheet_After", shs
    Run "DestinationSheet_After", shd

    Application.Calculation = calc

    pi.StartNewAction 95, 100, tt("PI_Lookup_0018") & " |fffd|"        ', "|fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| ..."

    Application.DisplayAlerts = False
    If S_NeedToBeClosed Then shs.Parent.Close ColoringEnable("SF")        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|
    If D_NeedToBeClosed Then shd.Parent.Close True        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    pi.StartNewAction 100, 100, tt("PI_Lookup_0019")
    Application.DisplayAlerts = True
    pi.Hide
    DoEvents
    Application.ScreenUpdating = True
End Sub

Function ExcludeChars(ByRef txt, ByRef charlist)
    On Error Resume Next: Dim i&
    For i = 1 To Len(charlist)
        txt = Replace(txt, Mid(charlist, i, 1), "")
    Next
End Function

Sub AddFormulaColumnsForRowsRange(ByRef RowsRange As Range)
    On Error Resume Next
    Dim formulas As New Dictionary, FormulasArray As Variant, formula As Variant, formula_column As Variant, col_to&
    ' reading formulas from settings
    FormulasArray = Split(Replace(SETT.GetText("TextBox_Formula"), vbCr, ""), vbLf)
    For Each formula In FormulasArray
        If formula Like "#*=?*" Then
            formulas.Item(CStr(Val(Split(formula, "=")(0)))) = "=" & Split(formula, "=", 2)(1)
        End If
    Next
    ' add formula columns to worksheet
    For Each formula_column In formulas.Keys
        col_to& = 0: col_to& = Val(formula_column)
        If col_to& Then Intersect(RowsRange.EntireRow, RowsRange.Worksheet.Columns(col_to&)).FormulaR1C1Local = formulas.Item(CStr(formula_column))
    Next
End Sub

Sub ColorTable(ByVal FileType$, ByRef sh As Worksheet, ByVal RowsCount&, ByRef dic As Dictionary)
    On Error Resume Next
    Dim InteriorColor_Found&, FontColor_Found&, InteriorColor_NotFound&, FontColor_NotFound&
    InteriorColor_Found& = xlNone: FontColor_Found& = xlNone: InteriorColor_NotFound& = xlNone: FontColor_NotFound& = xlNone:

    If SETT.GetBoolean("CheckBox_" & FileType$ & "_Found_Color_Interior") Then _
       InteriorColor_Found& = SETT.GetNumber("ComboBox_" & FileType$ & "_Found_Color_Interior")
    If SETT.GetBoolean("CheckBox_" & FileType$ & "_Found_Color_Font") Then _
       FontColor_Found& = SETT.GetNumber("ComboBox_" & FileType$ & "_Found_Color_Font")

    If SETT.GetBoolean("CheckBox_" & FileType$ & "_NotFound_Color_Interior") Then _
       InteriorColor_NotFound& = SETT.GetNumber("ComboBox_" & FileType$ & "_NotFound_Color_Interior")
    If SETT.GetBoolean("CheckBox_" & FileType$ & "_NotFound_Color_Font") Then _
       FontColor_NotFound& = SETT.GetNumber("ComboBox_" & FileType$ & "_NotFound_Color_Font")


    Dim ra As Range, FirstRow&, LastRowColumn&, LastRow&, ColumnsList_Found$, ColumnsList_NotFound$
    Set ra = Intersect(sh.UsedRange.EntireColumn, sh.Cells(1).Resize(RowsCount&).EntireRow)

    FirstRow& = SETT.GetNumber("ComboBox_" & FileType$ & "_FirstRow")
    If FirstRow& <= 0 Then FirstRow& = 1

    LastRowColumn& = SETT.GetNumber("ComboBox_" & FileType$ & "_LastRowColumn")
    LastRow& = RowsCount&
    If LastRowColumn& Then LastRow& = sh.Cells(sh.Rows.Count, LastRowColumn&).End(xlUp).Row

    ColumnsList_Found$ = SETT.GetText("TextBox_" & FileType$ & "_Found_ColumnsList")
    ColumnsList_NotFound$ = SETT.GetText("TextBox_" & FileType$ & "_NotFound_ColumnsList")

    Dim ColorColumns As Range, ro&, PaintRange As Range, cnt&
    If (InteriorColor_Found& >= 0) Or (FontColor_Found& >= 0) Then

        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
        Set ColorColumns = ra.EntireColumn: If Len(ColumnsList_Found$) Then Set ColorColumns = sh.Range(ColumnsStringToRangeAddress(ColumnsList_Found$)).EntireColumn

        Set PaintRange = Nothing: cnt& = 0
        With sh
            For ro& = FirstRow& To LastRow& + FirstRow& - 1
                If dic.Exists(ro& - FirstRow& + 1) Then
                    cnt& = cnt& + 1
                    If PaintRange Is Nothing Then Set PaintRange = .Cells(ro&, 1) Else Set PaintRange = Union(PaintRange, .Cells(ro&, 1))
                    If cnt& >= 500 Then
                        With Intersect(PaintRange.EntireRow, ColorColumns)
                            If InteriorColor_Found& >= 0 Then .Interior.Color = InteriorColor_Found&
                            If FontColor_Found& >= 0 Then .Font.Color = FontColor_Found&
                            DoEvents
                        End With
                        Set PaintRange = Nothing: cnt& = 0
                    End If
                End If
            Next
        End With
    End If
    If cnt& Then
        With Intersect(PaintRange.EntireRow, ColorColumns)
            If InteriorColor_Found& >= 0 Then .Interior.Color = InteriorColor_Found&
            If FontColor_Found& >= 0 Then .Font.Color = FontColor_Found&
        End With
        Set PaintRange = Nothing: cnt& = 0
    End If



    If (InteriorColor_NotFound& >= 0) Or (FontColor_NotFound& >= 0) Then
        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
        Set ColorColumns = ra.EntireColumn: If Len(ColumnsList_NotFound$) Then Set ColorColumns = sh.Range(ColumnsStringToRangeAddress(ColumnsList_NotFound$)).EntireColumn

        Set PaintRange = Nothing: cnt& = 0
        With sh
            For ro& = FirstRow& To LastRow& + FirstRow& - 1
                If Not dic.Exists(ro& - FirstRow& + 1) Then
                    cnt& = cnt& + 1
                    If PaintRange Is Nothing Then Set PaintRange = .Cells(ro&, 1) Else Set PaintRange = Union(PaintRange, .Cells(ro&, 1))
                    If cnt& >= 500 Then
                        With Intersect(PaintRange.EntireRow, ColorColumns)
                            If InteriorColor_NotFound& >= 0 Then .Interior.Color = InteriorColor_NotFound&
                            If FontColor_NotFound& >= 0 Then .Font.Color = FontColor_NotFound&
                            DoEvents
                        End With
                        Set PaintRange = Nothing: cnt& = 0
                    End If
                End If
            Next
        End With
    End If
    If cnt& Then
        With Intersect(PaintRange.EntireRow, ColorColumns)
            If InteriorColor_NotFound& >= 0 Then .Interior.Color = InteriorColor_NotFound&
            If FontColor_NotFound& >= 0 Then .Font.Color = FontColor_NotFound&
        End With
        Set PaintRange = Nothing: cnt& = 0
    End If

End Sub

Function GetArray(ByRef sh As Worksheet, ByVal CompareColumnsArray As Variant, _
                  ByVal CopyColumnsArray As Variant, ByRef SearchArray As Variant, ByVal FileType$) As Variant
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd| (|fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| CompareColumnsArray)
    ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| CompareColumnsArray |fffd| CopyColumnsArray
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| SearchArray, |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| CompareColumnsArray
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| VALUES_SEP$
    On Error Resume Next
    Dim RowsCount&, col&, rc&, MaxColumn&, i&, j&, arr, LEN_VALUES_SEP&, FirstRow&
    FirstRow& = SETT.GetNumber("ComboBox_" & FileType$ & "_FirstRow")
    If FirstRow& <= 0 Then FirstRow& = 1

    For i = LBound(CompareColumnsArray) To UBound(CompareColumnsArray)
        col& = CompareColumnsArray(i)
        rc& = sh.Cells(sh.Rows.Count, col&).End(xlUp).Row
        If rc& > RowsCount& Then RowsCount& = rc&
        If col& > MaxColumn& Then MaxColumn& = col&
    Next i
    For i = LBound(CopyColumnsArray) To UBound(CopyColumnsArray)
        col& = CopyColumnsArray(i)
        If col& > MaxColumn& Then MaxColumn& = col&
    Next i

    If SETT.GetBoolean("CheckBox_KeepFormulas") Then
        arr = sh.Cells(FirstRow&, 1).Resize(RowsCount& - FirstRow& + 1, MaxColumn&).formula   ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd|
    Else
        arr = sh.Cells(FirstRow&, 1).Resize(RowsCount& - FirstRow& + 1, MaxColumn&).Value  ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd|
    End If

    LEN_VALUES_SEP& = Len(VALUES_SEP$)
    ReDim SearchArray(1 To RowsCount&, 1 To 1)        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|
    For i = LBound(SearchArray) To UBound(SearchArray)
        For j& = LBound(CompareColumnsArray) To UBound(CompareColumnsArray)
            col& = CompareColumnsArray(j&)
            SearchArray(i, 1) = SearchArray(i, 1) & VALUES_SEP$ & arr(i, col&)
        Next j&
        SearchArray(i, 1) = Mid(SearchArray(i, 1), LEN_VALUES_SEP& + 1)
        If Len(SearchArray(i, 1)) = LEN_VALUES_SEP& * (UBound(SearchArray) - 1) Then SearchArray(i, 1) = ""
    Next i

    If DEBUG_LOOKUP Then Debug.Print """" & sh.Name & """", "RowsCount&=" & RowsCount&, "MaxColumn&=" & MaxColumn&
    GetArray = arr
End Function

Function GetSheet(ByVal FileTypeIndex&, Optional ByRef NeedToBeClosed As Boolean, _
                  Optional ByRef AW As Workbook) As Worksheet
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| FileTypeIndex& (1 = "SF" |fffd||fffd||fffd| 2 = "DF"),
    ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|
    ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|, - |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
    ' |fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|, |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| ErrMsg$ |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|
    On Error Resume Next
    Dim WB As Workbook, sh As Worksheet, owb As Workbook, filename$, FileType$, msg$, short_filename$, ttl$

    FileType$ = Choose(FileTypeIndex&, "SF", "DF")

    ' |fffd||fffd||fffd||fffd||fffd| (|fffd||fffd||fffd||fffd||fffd|) |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| (|fffd||fffd||fffd||fffd||fffd| Excel)
    Select Case True
        Case SETT.GetBoolean("OptionButton_" & FileType$ & "_ActiveWorkbook")        ' ActiveWorkbook
            NeedToBeClosed = False
            Set WB = AW
            If WB Is Nothing Then
                msg$ = Choose(FileTypeIndex&, tt("MSGBOX_Lookup_0100"), tt("MSGBOX_Lookup_0101")) & vbNewLine & vbNewLine & tt("MSGBOX_Lookup_0102")
                MsgBox msg, vbCritical, tt("MSGBOX_Lookup_0103")
                Exit Function
            End If

        Case SETT.GetBoolean("OptionButton_" & FileType$ & "_AnotherWorkbook")        ' Another Workbook
            filename$ = SETT.GetText("TextBox_" & FileType$ & "_Filename")

Label_OpenFile:
            If Trim(filename$) = "" Then        ' fullname is blank
                msg$ = Choose(FileTypeIndex&, tt("MSGBOX_Lookup_0105"), tt("MSGBOX_Lookup_0106")) & vbNewLine & vbNewLine & tt("MSGBOX_Lookup_0107")
                MsgBox msg, vbCritical, tt("MSGBOX_Lookup_ErrorCaption")
                Exit Function
            End If

            short_filename$ = Dir(filename$, vbNormal)
            If short_filename$ = "" Then        ' file not found
                msg$ = Choose(FileTypeIndex&, tt("MSGBOX_Lookup_0108"), tt("MSGBOX_Lookup_0106")) & vbNewLine & _
                       tt("MSGBOX_Lookup_0110", filename$) & vbNewLine & vbNewLine & tt("MSGBOX_Lookup_0111")
                MsgBox msg, vbCritical, tt("MSGBOX_Lookup_0112")
                Exit Function
            End If

            For Each owb In Application.Workbooks
                If owb.Name = short_filename$ Then
                    If owb.FullName <> filename$ Then        ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd|
                        msg$ = Choose(FileTypeIndex&, tt("MSGBOX_Lookup_0113"), tt("MSGBOX_Lookup_0114")) & vbNewLine & _
                               tt("MSGBOX_Lookup_0115", short_filename$, filename$, owb.FullName)
                        MsgBox msg, vbCritical, tt("MSGBOX_Lookup_0116")
                        Exit Function
                    End If
                    Set WB = owb
                    NeedToBeClosed = False
                    Exit For
                End If
            Next
            If WB Is Nothing Then        ' |fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|
                NeedToBeClosed = True
                Application.DisplayAlerts = False
                Set WB = Workbooks.Open(filename$, False, Local:=True)        ' |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|
                Application.DisplayAlerts = True
                If WB Is Nothing Then        ' |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|
                    msg$ = Choose(FileTypeIndex&, tt("MSGBOX_Lookup_0117"), tt("MSGBOX_Lookup_0118")) & vbNewLine & _
                           tt("MSGBOX_Lookup_0119", filename$)
                    MsgBox msg, vbCritical, tt("MSGBOX_Lookup_0120", short_filename$)
                    Exit Function
                End If
            End If

        Case SETT.GetBoolean("OptionButton_" & FileType$ & "_AskForWorkbook")        ' dialog window
            filename$ = GetFilePathEx(FileType$, Choose(FileTypeIndex&, tt("MSGBOX_Lookup_0121"), tt("MSGBOX_Lookup_0111")))
            If filename$ = "" Then Exit Function        ' |fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
            GoTo Label_OpenFile

        Case True        ' setting error, - option is not selected
            MsgBox tt("MSGBOX_Lookup_0123"), vbCritical, tt("MSGBOX_ContactDeveloper_Caption")
            Exit Function
    End Select

    Dim sh_index&, sh_name$
    ' the workbook is open now - looking for a sheet
    Select Case True
        Case SETT.GetBoolean("OptionButton_" & FileType$ & "_ActiveSheet")        ' ActiveSheet
            If WB.ActiveSheet.Type <> xlWorksheet Then
                msg$ = Choose(FileTypeIndex&, tt("MSGBOX_Lookup_0125"), tt("MSGBOX_Lookup_0126")) & vbNewLine & _
                       tt("MSGBOX_Lookup_0127", WB.ActiveSheet.Name)
                MsgBox msg, vbCritical, tt("MSGBOX_Lookup_0128")
                Exit Function
            End If

            Set sh = WB.ActiveSheet

        Case SETT.GetBoolean("OptionButton_" & FileType$ & "_SheetIndex")        ' sheet by index
            sh_index& = SETT.GetNumber("ComboBox_" & FileType$ & "_SheetIndex")
            If sh_index& <= 0 Then sh_index& = 1
            Set sh = WB.Worksheets(sh_index&)
            If sh Is Nothing Then        ' sheet not found
                msg$ = tt(Choose(FileTypeIndex&, "MSGBOX_Lookup_0129", "MSGBOX_Lookup_0130"), sh_index&, WB.Worksheets.Count) & vbNewLine & vbNewLine & _
                       tt("MSGBOX_Lookup_0133")
                MsgBox msg, vbCritical, tt("MSGBOX_Lookup_ErrorCaption")
                Exit Function
            End If


        Case SETT.GetBoolean("OptionButton_" & FileType$ & "_SheetName")        ' sheet by name
            sh_name$ = SETT.GetText("TextBox_" & FileType$ & "_SheetName")
            If sh_name$ = "" Then
                msg$ = tt(Choose(FileTypeIndex&, "MSGBOX_Lookup_0139", "MSGBOX_Lookup_0140")) & vbNewLine & _
                       tt("MSGBOX_Lookup_0141")
                MsgBox msg, vbCritical, tt("MSGBOX_Lookup_ErrorCaption")
                Exit Function
            End If
            Set sh = WB.Worksheets(CStr(sh_name$))
            If sh Is Nothing Then        ' sheet not found
                msg$ = tt(Choose(FileTypeIndex&, "MSGBOX_Lookup_0131", "MSGBOX_Lookup_0132"), sh_name$, WB.Worksheets.Count) & vbNewLine & vbNewLine & _
                       tt("MSGBOX_Lookup_0133")
                MsgBox msg, vbCritical, tt("MSGBOX_Lookup_ErrorCaption")
                Exit Function
            End If

        Case True        ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd|, - |fffd||fffd| |fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd|
            MsgBox tt("MSGBOX_Lookup_0134"), vbCritical, tt("MSGBOX_ContactDeveloper_Caption")
            Exit Function
    End Select

    Set GetSheet = sh
End Function

Attribute VB_Name = "mod_Main"
'---------------------------------------------------------------------------------------
' Module        : mod_Main                    Version:
' Author        : Igor Vakhnenko                   Date: 16.10.2015
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Compare Text: Option Private Module ' : Option Explicit
Public Const PROJECT_NAME$ = "Lookup", PROJECT_YEAR& = 2013

Private Sub CreateCommandBar(): CreateProgramCommandBar 0: End Sub

Sub CreateProgramCommandBar(Optional ByVal RefreshOnly As Boolean = True)
    On Error Resume Next
    SaveDefaultSettings

    Dim AddinMenu As CommandBar, coll As Collection, i&, MainMacroButton As Object
    Application.ScreenUpdating = False
    If Not RefreshOnly Then Run DeleteOldCommandBar
    Set AddinMenu = GetCommandBar(PROJECT_NAME, True Or RefreshOnly)

    Set MainMacroButton = Add_Control(AddinMenu, ct_BUTTON, 501, "LookupData", tt("MENU_001"), msoButtonIconAndCaption, True)
    AddSettingsSwitcher AddinMenu, ct_DROPDOWN, , "LookupData", MainMacroButton

    Add3Buttons AddinMenu
    If Not RefreshOnly Then
        RunWithDelay "ActivateAddinsTab"
        AddUpdateButton AddinMenu
        RunWithDelay "ActivateAddinsTab"
    End If
    If Developer Then
        Add_Control(AddinMenu, ct_BUTTON, 0, "0", "", msoButtonIconAndCaption, False).Enabled = 0
        Add_Control AddinMenu, ct_BUTTON, , "ShowFirstRunForm", "Show FirstRun Form", msoButtonIconAndCaption, True
        Add_Control AddinMenu, ct_BUTTON, , "ToggleIsAddin", "Show/Hide TR Sheet", msoButtonIconAndCaption, True
    End If
    Application.ScreenUpdating = True
End Sub

Sub ToggleIsAddin()
    On Error Resume Next
    ThisWorkbook.IsAddin = Not ThisWorkbook.IsAddin
End Sub

Sub SaveDefaultSettings()
    On Error Resume Next
    With SETT
        .LoadAllSettings
        '---------------------------------------------------------------
        .AddDefaultValue "OptionButton_SF_ActiveWorkbook", True
        .AddDefaultValue "OptionButton_SF_ActiveSheet", True
        .AddDefaultValue "ComboBox_SF_SheetIndex", 1
        .AddDefaultValue "CheckBox_IgnoreCase", True
        .AddDefaultValue "CheckBox_IgnoredCharsEnabled", True
        .AddDefaultValue "TextBox_IgnoredChars", "{TAB}{SPACE}{160}{CR}{LF}", , True

        .AddDefaultValue "ComboBox_SF_Found_Color_Interior", vbGreen
        .AddDefaultValue "ComboBox_SF_Found_Color_Font", xlNone
        .AddDefaultValue "TextBox_SF_Found_ColumnsList", "A-F"
        .AddDefaultValue "ComboBox_SF_NotFound_Color_Interior", 13408767        'vbRed
        .AddDefaultValue "ComboBox_SF_NotFound_Color_Font", xlNone
        .AddDefaultValue "TextBox_SF_NotFound_ColumnsList", "A-B"

        .AddDefaultValue "ComboBox_SF_FirstRow", 2
        .AddDefaultValue "ComboBox_SF_LastRowColumn", "auto"

        '---------------------------------------------------------------
        .AddDefaultValue "OptionButton_DF_ActiveWorkbook", True
        .AddDefaultValue "OptionButton_DF_ActiveSheet", True
        .AddDefaultValue "ComboBox_DF_SheetIndex", 1

        .AddDefaultValue "ComboBox_DF_Found_Color_Interior", 15849925        ' blue
        .AddDefaultValue "ComboBox_DF_Found_Color_Font", xlNone
        .AddDefaultValue "TextBox_DF_Found_ColumnsList", "A-F"
        .AddDefaultValue "ComboBox_DF_NotFound_Color_Interior", 10092543        'yellow
        .AddDefaultValue "ComboBox_DF_NotFound_Color_Font", xlNone
        .AddDefaultValue "TextBox_DF_NotFound_ColumnsList", "A-B"

        .AddDefaultValue "ComboBox_DF_FirstRow", 2
        .AddDefaultValue "ComboBox_DF_LastRowColumn", "auto"

        '---------------------------------------------------------------
        .AddDefaultValue "TextBox_SF_CompareColumnsList", "2"
        .AddDefaultValue "TextBox_DF_CompareColumnsList", "3"
        .AddDefaultValue "TextBox_SF_CopyColumnsList", "8, 5-3, K-M, R, S"
        .AddDefaultValue "TextBox_DF_CopyColumnsList", "H-N, P, R"

        .AddDefaultValue "CheckBox_CopyNewRows", False
        '---------------------------------------------------------------
        .AddDefaultValue "TextBox_CopyRows_SF_ColumnsList", "0,3-5,0,0,2,1"
        .AddDefaultValue "CheckBox_CopyRows_SF_CheckColumnEnabled", False
        .AddDefaultValue "TextBox_CopyRows_SF_CheckColumnMask", "?*"
        .AddDefaultValue "ComboBox_CopyRows_DF_LastRowColumn", 1, True
        .AddDefaultValue "ComboBox_CopyRows_SF_CheckColumnNumber", 1, True

        .AddDefaultValue "ComboBox_CopyRows_DF_Color_Interior", 10092441        ' light green
        .AddDefaultValue "ComboBox_CopyRows_DF_Color_Font", xlNone
        .AddDefaultValue "TextBox_CopyRows_DF_ColouringColumnsList", "A-F"

        .AddDefaultValue "CheckBox_CopyRows_DF_Border", True
    End With
End Sub


Function GetFile_MainPicture() As String
    ' |fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd|, |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd| |fffd| |fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd||fffd| |fffd||fffd||fffd||fffd||fffd|
    On Error Resume Next: Dim F_TXT$, buf$, tmp_file$: Const BufLen& = 5000
    F_TXT$ = F_TXT$ & "FFD8FFE000104A46494600010101012C012C0000FFDB0043000504040504030505040506060506080E0908070708110C0D0A0E141115141311131316181F1B16171E1713131B251C1E2021232323151A26292622291F222322FFDB00430106060608070810090910221613162222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222FFC00011080029005003012200021101031101FFC4001A000003010101010000000000000000000004060700050801FFC40037100001040004040405020309000000000001020304110005122106132231074151711423246181153233428234354352627291A1B1FFC400190100020301000000000000000000000000040500020301FFC4002B11000103030301060700000000000000000100020304112112133141053371C1D1F03234516181B1E1FFDA000C03010002110311003F00BCE799D670C66B25197BCB212F389D0EBC50000AA1A6BCBF1819ACFB373A39F25F492F212A4B6F5D03762EFBF6AFCE04E278A6566F280806754877A5D25213D47F6F49B0702C760B6DB23E11C674C86CE94926BBEF75DC5EC3EFDB05B5A2C3096BDEEB9CA74566531B8115C0EBC80B8CDAD4B90FE93A8A16492350D8909AF657A61278DB"
    F_TXT$ = F_TXT$ & "8A38832ACE16DE5599262B20F509CF14EFCB411A2CEE2C9B24F6230D4EB01FCAE26A8EB7DB30DAD464D8BA42CD51AD81A23DD5E9789D788D1512788D6972046989424DA27F4947CB6F6412074F91FE9FCA9AC716B0106D9F557AF7B9B134836CF91547F0BF39CD7388D3D59D4A4BEF364005B5EB40EB58D89DEE80047A8C51B129F0752A4C5CD438CB4CAB5D9432BD68FE239BDFF98F73F7F4ED8AB5E34A624C409F795AD1B8BA06927EBFB283CD5C5B3934D71B2A4AD0C2D4929EE0849AAC4A8E7F9F87D412F5B009A5FC490A03EE2EBFEF152CE7FB8331EFFD99CEDDFF0069C451705467ADEFD212AEA27E23590AEFDC8D1FF3BF960D88037BA952E208B15D0CDB8973A622BA634E790F2592A429C73E58572C9B5EF611A85DFA038E6F09717F12CFE2C851F31CD23BF116E84A9319ED4A279880411BF4D120FB8ED7581B881B232F923937AA3D687C7CB590D11A5760740ED7B6D7EF8E6704C511B8EB2E4B7974288D07C52A33BA9765D458D3E86859DB703B6C30AEADEE6D4D81C612A74AFDE0351E9D7FA9C38A6326566F28182ECED321D1A41D3A3A8EC0E8360FBE04623252863E91C6B4C86D40293A8A6AFA81D1DD37B7AD9C17C52DA1ECE256B6644AD321D14C2820A3A8ED7B5DFBE048CC37A59210EB25121B58E6EE456AEAB03C81"
    F_TXT$ = F_TXT$ & "EDBDDE1D37808B7F25333F113320E5F709C9A830DB4971D1A6BA17B01A45EF5F851F4C4FFC458EB91C40E06B2F19969429250F2F945B05A6C148E91608B07D87ADE1FE4B08970B2F2A8EE4FF00A36C172F4247CB58AA02FCEBFABED89EF8931933B8817F40EE6A116290E0694D7CB6B6BF3EDEBFCBF90A2B7E01E3EAAFDA1DD37C7C8A7AF0943C2166E90C222BC0F437AB98916E3A4289005955D9F3B2463E4283C6E97A6D393D2F17EDE5AA4B41B717A53D4D0524D3754001554455D93BC1A472E06648F855C4DC2BE1D6A0A29B71C37636DFBFDAF157C4823D70B72473C1FBAB52C42481B9239E0DBA948F96B3C42CE4F9F1E22796A64C4F91ADC6D6A0AD2BD47A123CB4F7BED89DAE0A4E60B77F497892A27E212A001DFBD68F3C5B73A35906626EBE99CDFD3A4E222B61AF8F5ABE0A6EA2A2798958D0ADFBE9FBFB61853B748B2B4EDD200BA173E6008329298D6A763E9E5A93497A9A23428E814076BDB638078219758E35CBCB994A21053E01752F87147E63742B4D8040DCFF00A123D307E7CC24E5B29286F99CF63498E7FC621A2347ED355B26EBFF0031C9E038898BC750143277E05BC0739C7C38156EA0E9AB277ABFC1F524AAADF9A1F84A9FDF0F109E38A52A566F27509CB01F76843B4A93D4763D62EFC8E0069B25318812FA65"
    F_TXT$ = F_TXT$ & "36AB77F70235751EADC0F3F718B9E361B096DD139753026F75319684498F9725D53F21422B40AD9572D29210BD8EFDF7A3FEE1841F12A2AE6710A94A893B334A410170145251F2DAD8907AAEBD7BA7B1F2F46636049A2DD16BD97678379A1B7B594AFC1E0E081989721C8876ABE4C84F5D971C2544F9EABBF638AA636363B147B6D0D57862DA6060E881CE2CE459804F7F8772B6BFE5388A29A273073A334D5A89B493CA56FE435F6FC6DBF6C5E7CF1B1BB1FA54922DC232BCF39D4753D0E7212CBEEF398D0A689FE2D34404036749F2BDF7C05C0D0571B8CA0286593E302F8A7A539CCD8BA8240DCD5E907BED58F49E31ED81A5804B26E1286342D2FD57F617FFD9"
    For i = 1 To Len(F_TXT$) / 2
        buf$ = buf$ & Chr(Val("&H" & Mid(F_TXT$, 2 * i - 1, 2)))
        If Len(buf$) > BufLen& Then res$ = res$ & buf$: buf$ = "": DoEvents
    Next: res$ = res$ & buf$
    tmp_file$ = Environ("tmp") & "\file_MainPicture_" & PROJECT_NAME$: Kill tmp_file$
    ff& = FreeFile: Open tmp_file$ For Binary Access Write As #ff
    Put #ff, , res$
    Close #ff
    If FileLen(tmp_file$) = Len(F_TXT$) / 2 Then GetFile_MainPicture = tmp_file$
End Function




Attribute VB_Name = "mod_Translate"
'---------------------------------------------------------------------------------------
' Module        : mod_Translate                    Version: 2.2
' Author        : Igor Vakhnenko                   Date: 02.05.2016
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Option Private Module: Option Compare Text: Option Explicit
Public Const TRANSLATE_SHEET_FIRST_ROW& = 5, DEFAULT_LANGUAGE$ = "en"
Dim DoNotTranslate As Boolean

Function TR_DIC() As Dictionary
    Static objTRDIC As Dictionary
    If Not objTRDIC Is Nothing Then
        Set TR_DIC = objTRDIC: Exit Function
    Else
        Set objTRDIC = New Dictionary: objTRDIC.CompareMode = TextCompare
        PrepareTraslateDictionary
        Set TR_DIC = objTRDIC
    End If
End Function

Sub TranslateUserForm(ByRef UF As Object)
    If DoNotTranslate Then Exit Sub
    On Error Resume Next: Dim ctrl As MSForms.Control, fcaption$
    fcaption$ = tt(UF.Name & "_caption"): If Len(fcaption$) Then UF.Caption = fcaption$
    For Each ctrl In UF.Controls
        UpdateControl ctrl, UF.Name
    Next
End Sub

Sub UpdateControl(ByRef ctrl As Object, Optional ByVal ParentName$)
    On Error Resume Next
    Dim m_page As Object, id$, res$
    If TypeName(ctrl) = "MultiPage" Then
        For Each m_page In ctrl.Pages
            UpdateControl m_page, ParentName$ & "\" & ctrl.Name
        Next
    Else
        id$ = ParentName$ & IIf(ParentName$ <> "", "\", "") & ctrl.Name
        res$ = tt(id$)
        If Len(res$) Then ctrl.Caption = res$

        If Len(ctrl.Tag) Then
            id$ = "tag:" & ParentName$ & IIf(ParentName$ <> "", "\", "") & ctrl.Name
            res$ = tt(id$)
            If Len(res$) Then ctrl.Tag = res$
        End If

        If Len(ctrl.ControlTipText) Then
            id$ = "ControlTipText:" & ParentName$ & IIf(ParentName$ <> "", "\", "") & ctrl.Name
            res$ = tt(id$)
            If Len(res$) Then ctrl.ControlTipText = res$
        End If
    End If
End Sub


' ===================== prepare translations ==========================
Private Sub loadInfo_UserForms()
    On Error Resume Next
    DoNotTranslate = True
    
    PrintWords F_Settings
    
    ' PrintWords F_FirstRun
    DoNotTranslate = False
End Sub

Private Sub PrintUserformNames()
    On Error Resume Next
    Dim VBComp As Object
    For Each VBComp In ThisWorkbook.VBProject.VBComponents
        If VBComp.Type = 3 Then Debug.Print VBComp.Name
    Next VBComp
End Sub

Sub PrintWords(ByRef UF As Object)
    On Error Resume Next
    shtr.Range("a" & shtr.Rows.Count).End(xlUp).Offset(2) = UF.Name & " controls"
    Dim ctrl As MSForms.Control
    For Each ctrl In UF.Controls
        AddControlInformation ctrl, UF.Name
    Next
End Sub

Sub AddControlInformation(ByRef ctrl As Object, Optional ByVal ParentName$)
    On Error Resume Next
    Dim cell As Range, m_page As Object, id$
    If TypeName(ctrl) = "MultiPage" Then
        For Each m_page In ctrl.Pages
            AddControlInformation m_page, ParentName$ & "\" & ctrl.Name
        Next
    Else
        id$ = ParentName$ & IIf(ParentName$ <> "", "\", "") & ctrl.Name
        Debug.Print id$
        If Len(ctrl.Caption) Then
            Set cell = shtr.Range("a" & shtr.Rows.Count).End(xlUp).Offset(1)
            cell.Resize(, 2).Value = Array(id$, ctrl.Caption)
        End If

        If Len(ctrl.Tag) Then
            If ctrl.Tag <> "ScrollCombo" Then
                Set cell = shtr.Range("a" & shtr.Rows.Count).End(xlUp).Offset(1)
                id$ = "tag:" & ParentName$ & IIf(ParentName$ <> "", "\", "") & ctrl.Name
                cell.Resize(, 2).Value = Array(id$, ctrl.Tag)
            End If
        End If

        If Len(ctrl.ControlTipText) Then
            Set cell = shtr.Range("a" & shtr.Rows.Count).End(xlUp).Offset(1)
            id$ = "ControlTipText:" & ParentName$ & IIf(ParentName$ <> "", "\", "") & ctrl.Name
            cell.Resize(, 2).Value = Array(id$, ctrl.ControlTipText)
        End If
    End If
End Sub

Function SYSTEM_LANGUAGE() As String
    On Error Resume Next
    Select Case Application.LanguageSettings.LanguageID(msoLanguageIDUI)
        Case 1049: SYSTEM_LANGUAGE = "ru"
        Case Else: SYSTEM_LANGUAGE = DEFAULT_LANGUAGE
    End Select
End Function

Function SetLanguage(ByVal new_lang_code$) As Boolean
    ' returns TRUE if language was changed (interface needs to be translated)
    On Error Resume Next
    Dim prev_lang_code$: prev_lang_code$ = GetLanguage
    SETT.SetText "Language", new_lang_code$, "Setup"

    SetLanguage = LCase(prev_lang_code$) <> LCase(new_lang_code$)
    If SetLanguage Then PrepareTraslateDictionary        ': CreateProgramCommandBar
End Function

Function GetLanguage() As String
    GetLanguage = SETT.GetText("Setup\Language", SYSTEM_LANGUAGE)
End Function

Function RUS() As Boolean
    RUS = SETT.GetText("Setup\Language", SYSTEM_LANGUAGE) = "ru"
End Function

Function tt(ByVal id$, ParamArray tokens()) As String
    On Error Resume Next: Dim i&, AddSpaces As Boolean
    If id$ Like "|??*" Then id$ = SETT.U(Mid(id$, 2))
    If id$ Like " ?*" Then id$ = Mid(id$, 2): AddSpaces = True
    tt = TR_DIC.Item(id$)
    If Not IsMissing(tokens) Then
        For i = LBound(tokens) To UBound(tokens)
            tt = Replace(tt, "!" & (i + 1), tokens(i))
        Next i
    End If
    tt = Replace(tt, "!add-in", PROJECT_NAME$)
    tt = Replace(tt, "/n", vbNewLine)
    If AddSpaces Then tt = " " & tt & " "
End Function

Function PrepareTraslateDictionary()
    On Error Resume Next: Err.Clear
    Dim ra As Range, KEYarr As Variant, VALarr As Variant, AvLangArr As Variant, col&, lang_code$, i&, k, v$
    Set ra = shtr.Range(shtr.Cells(TRANSLATE_SHEET_FIRST_ROW, 1), shtr.Range("A" & shtr.Rows.Count).End(xlUp))
    If ra.Row < TRANSLATE_SHEET_FIRST_ROW Then
        MsgBox "Translation sheet has no data", vbCritical, "Contact the developer"
        End
    End If

    lang_code$ = GetLanguage: AvLangArr = AvailableLanguagesArray(True)
    For i = LBound(AvLangArr) To UBound(AvLangArr)
        If LCase(AvLangArr(i, 1)) = LCase(lang_code$) Then col& = i: Exit For
    Next i

    If col& = 0 Then
        lang_code$ = DEFAULT_LANGUAGE
        For i = LBound(AvLangArr) To UBound(AvLangArr)
            If LCase(AvLangArr(i, 1)) = LCase(lang_code$) Then col& = i: Exit For
        Next i
    End If

    If col& = 0 Then
        MsgBox "Translation error: unsupported language |fffd|" & GetLanguage & "|fffd|", vbCritical, "Contact the developer"
        End
    End If

    KEYarr = ra.Value
    VALarr = ra.Offset(, col&).Value

    With TR_DIC
        .RemoveAll
        .CompareMode = TextCompare
        For i = LBound(KEYarr) To UBound(KEYarr)
            v$ = VALarr(i, 1)
            For Each k In Split(KEYarr(i, 1), "|")
                If Len(k) Then If Not .Exists(CStr(k)) Then .Item(CStr(k)) = v$
            Next k
        Next i
    End With
End Function

Function AvailableLanguagesArray(Optional FullList As Boolean = False) As Variant
    On Error Resume Next: Err.Clear
    Dim ra As Range, arr, res, i&, ii&, dic As New Dictionary, ind&, CurrLangPresentInList As Boolean, CurrLanguage$, CurrLanguageColumn&
    Set ra = shtr.Range(shtr.[b1], shtr.Range("z1").End(xlToLeft)).Resize(4)
    If Err Then
        MsgBox "Translation sheet is absent", vbCritical, "Contact the developer"
        End
    End If
    If ra.Column < 2 Then
        MsgBox "Translation sheet is blank", vbCritical, "Contact the developer"
        End
    End If

    If FullList Then
        AvailableLanguagesArray = Application.Transpose(ra.Value)
        Exit Function
    End If

    arr = ra.Value
    ind& = 0: dic.CompareMode = TextCompare: CurrLanguage$ = GetLanguage
    For ii = LBound(arr, 2) To UBound(arr, 2)
        If arr(1, ii) = CurrLanguage$ Then CurrLanguageColumn& = ii
        For i = LBound(arr, 2) To UBound(arr, 2)
            If Val(arr(4, i)) = ii Then
                ind& = ind& + 1: dic.Item(ind&) = i
                If arr(1, i) = CurrLanguage$ Then CurrLangPresentInList = True
            End If
        Next i
    Next ii
    If Not CurrLangPresentInList Then If CurrLanguageColumn& Then dic.Item(ind& + 1) = CurrLanguageColumn&

    If ind& = 0 Then
        MsgBox "Translation sheet error: can't find language indexes", vbCritical, "Contact the developer"
        End
    End If

    ReDim res(1 To dic.Count, 1 To 2)
    For i = LBound(res) To UBound(res)
        res(i, 1) = arr(1, dic.Item(i))
        res(i, 2) = arr(2, dic.Item(i))
    Next i

    AvailableLanguagesArray = res
    Set dic = Nothing
End Function

Sub OneMoreSettingsForm()
    SetLanguage "en"
    With New F_Settings
        .Show
    End With
End Sub

Attribute VB_Name = "shtr"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'---------------------------------------------------------------------------------------
' Author        : Igor Vakhnenko                   Date: 08.01.2016
' Professional application development for Microsoft Excel
' http://ExcelVBA.ru/        info@excelvba.ru      Skype: ExcelVBA.ru
'---------------------------------------------------------------------------------------

Const PREFIX$ = "MENU"


Function NewTranslateID() As String
    On Error Resume Next
    Dim ra As Range, coll As New Collection
    Set ra = shtr.Range(shtr.Range("a" & TRANSLATE_SHEET_FIRST_ROW), shtr.Range("A" & shtr.Rows.Count).End(xlUp))
    arr = ra.Value
    For i = LBound(arr) To UBound(arr)
        coll.Add arr(i, 1), CStr(arr(i, 1))
    Next i

    For i = 1 To 1000
        Err.Clear: id$ = PREFIX$ & "_" & Format(i, "0000")
        coll.Add id$, id$
        If Err = 0 Then NewTranslateID = id$: Exit Function
    Next
    MsgBox "Can't create ID$", vbExclamation, "Function NewTranslateID()"
End Function

Function ClipboardText()
    With GetObject("New:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
        .GetFromClipboard
        ClipboardText = .GetText
    End With
End Function

Sub SetClipboardText(ByVal txt$)
    With GetObject("New:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
        .SetText txt$
        .PutInClipboard
    End With
End Sub

Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean)
    On Error Resume Next
    If Target.Column = 1 And Target.Cells.Count = 1 Then
        If Target <> "" Then Cancel = True: SetClipboardText "tt(""" & Target & """) "
    End If
End Sub


' InQuest injected base64 decoded content
' jZ 	
' "{-jYT
' *'~*
' "{-jYKj

INQUEST-PP=macro
