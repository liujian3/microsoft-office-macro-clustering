Attribute VB_Name = "DataChecks"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Sub Class_Initialize()
End Sub


Public Function isBoolean(ByRef inta As InternalTable) As Boolean
    Dim dx() As Integer
    dx = inta.GetDimension
    Dim maxD As Integer
    maxD = 2
    Dim i As Integer
    For i = 1 To UBound(dx)
        If maxD < dx(i) Then
            maxD = dx(i)
        End If
    Next
    
    isBoolean = True
    If (maxD > 2) Then
        isBoolean = False
    End If
        
End Function

Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ExtQuine_Base"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim outcome As Integer
Dim rootSet As ExtQuine_ConfSet
Dim i As Integer
   
Sub Class_Initialize()
End Sub

Sub initialiseBase(ByRef TT As InternalTable, ByRef outC As Integer)
    Dim nC As Integer
    nC = TT.GetNCases
    outcome = outC
    Dim cases() As InternalCase
    cases = TT.getCases
    Set rootSet = New ExtQuine_ConfSet
    rootSet.init
    For i = 1 To nC
       Dim k As Integer
       k = cases(i).GetOutcome
       If k = outcome Then
        rootSet.addInternalCase cases(i)
       End If
    Next
    rootSet.freeze
    rootSet.calculateImplicants TT.GetDimension
    rootSet.joinImplicants
    rootSet.setCases TT
End Sub

Sub process(ByRef TT As InternalTable, ByRef TTSheet As Worksheet, ByRef qcanotation As Boolean, ByRef sx As Integer, ByRef cmode As Integer)
    Dim map As GBA_Map
    Set map = New GBA_Map
    map.createMapFromExtQuine TT, rootSet
    If cmode = 1 Then map.calculateCoverageConsistence TT
    map.implicantOutput TTSheet, sx, 1, qcanotation
    Dim mS As New Solution_Map
    Dim mi() As GBA_Implicant
    mi = map.retrieveImplicants
    mS.initaliseMap mi, TT, outcome
    Dim gc As Integer
    gc = TT.getNGoodCases(outcome)
    mS.getSolutions gc
    Dim vN() As String
    vN = TT.getVars
    mS.filterAgents
    If cmode = 1 Then mS.calculateCoverageConsistency TT
    mS.solutionOutput TTSheet, sx + 2 + UBound(mi), 1, vN, qcanotation, cmode
End Sub

Attribute VB_Name = "ExtQuine_ConfSet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim configurations() As ExtQuine_Configuration
Dim cRunner As Integer
Dim cMax As Integer
Dim myImplicants As ExtQuine_ConfSet

Sub Constructor()
End Sub

Sub init()
    cMax = 100
    cRunner = 0
    ReDim configurations(cMax)
End Sub

Public Sub addInternalCase(ByRef ic As InternalCase)
    If cRunner >= cMax Then
        cMax = cMax * 2
        ReDim Preserve configurations(cMax)
    End If
    cRunner = cRunner + 1
    Set configurations(cRunner) = New ExtQuine_Configuration
    configurations(cRunner).setValues ic
End Sub

Public Sub addConfiguration(ByRef econf As ExtQuine_Configuration)
    If cRunner >= cMax Then
        cMax = cMax * 2
        ReDim Preserve configurations(cMax)
    End If
    cRunner = cRunner + 1
    Set configurations(cRunner) = econf
    

End Sub

Public Sub addConfSet(ByRef eqc As ExtQuine_ConfSet)
    Dim i As Integer
    eqc.freeze
    Dim rqcRunner As Integer
    rqcRunner = eqc.getRunner
    
    If cRunner + rqcRunner >= cMax Then
        cMax = cMax * 2
        ReDim Preserve configurations(cMax)
    End If
    
    Dim qq() As ExtQuine_Configuration
    qq = eqc.getConfigurations
    
       
    For i = 1 To rqcRunner
        cRunner = cRunner + 1
        Set configurations(cRunner) = qq(i)
    Next
End Sub

Public Sub freeze()
    ReDim Preserve configurations(cRunner)
    cMax = cRunner
End Sub

Public Function checkHasItem(ByRef eqc As ExtQuine_Configuration) As Boolean
    Dim i As Integer
    
    For i = 1 To cRunner
        If configurations(i).sameValues(eqc) = True Then
            checkHasItem = True
            Exit Function
        End If
    Next
    checkHasItem = False
End Function

Public Function getRunner() As Integer
    getRunner = cRunner
End Function

Public Function getConfigurations() As ExtQuine_Configuration()
    getConfigurations = configurations
End Function

Public Function getConfiguration(ByRef number As Integer) As ExtQuine_Configuration
    'Dim ret As ExtQuine_Configuration
    Set getConfiguration = New ExtQuine_Configuration
    getConfiguration.clone configurations(number)
    'getConfiguration = ret
End Function

Public Sub joinImplicants()
    Dim i As Integer
    
    'Dim yImplicants As ExtQuine_ConfSet
    'Set yImplicants = New ExtQuine_ConfSet
    'yImplicants.init
    'For i = 1 To cRunner
    '    yImplicants.addConfiguration configurations(i)
    'Next
    
    myImplicants.freeze
    For i = 1 To myImplicants.getRunner
        addConfiguration myImplicants.getConfiguration(i)
    Next
    
    myImplicants.freeze
    'getJointImplicants = yImplicants
End Sub

Public Sub calculateImplicants(ByRef dimensions() As Integer)
    Dim i As Integer
    
    Set myImplicants = New ExtQuine_ConfSet
    'Dim ret As ExtQuine_ConfSet
    'Set ret = New ExtQuine_ConfSet
    myImplicants.init
    
    For i = 1 To cRunner
        myImplicants.addConfSet configurations(i).getPossibleImplicants
    Next
    
    myImplicants.flagDuplicants
    myImplicants.checkImplicants configurations, dimensions
    myImplicants.removeFlagged
    If myImplicants.getRunner > 1 Then
        myImplicants.calculateImplicants dimensions
        myImplicants.joinImplicants
        'addConfSet myImplicants.getMyImplicants
        'myImplicants.addConfSet myImplicants.calculateImplicants(dimensions)
        'ret.addConfSet ret.getImplicants(dimensions)
    End If

    'iteration!!
End Sub
'       Hier einf|fffd|gen: Prozedur finde K|fffd|rzungsm_glichkeiten
'           R|fffd|ckgabe: ConfSet mit K|fffd|rzungen (CSK) oder NULL
' OK    In EQ_Configuration: Generiere potentielle k|fffd|rzungen (PK)
' OK      Hier: pr|fffd|fe ob PK existiert
' OK          falls ja: In CSK einf|fffd|gen
'       CSKs filtern? (oder geht das mit dem Filter aus GBA?)
'       IDEE: CSK in GBA_ umwandeln
'       Umwandeln in GBA_Implicants

' this sub can be optimized!!
Public Sub flagDuplicants()
    Dim i As Integer
    Dim j As Integer
    For i = 1 To cRunner
        If configurations(i).isFlagged = False Then
            For j = i + 1 To cRunner
                If configurations(i).sameValues(configurations(j)) = True Then
                    configurations(j).doFlag
                End If
            Next
        End If
    Next
End Sub

Public Sub checkImplicants(ByRef setBefore() As ExtQuine_Configuration, ByRef dimensions() As Integer)
    Dim i As Integer
    For i = 1 To cRunner
        If configurations(i).isFlagged = False Then
             Dim retV As Boolean
             retV = configurations(i).checkNeededConfigurations(dimensions, setBefore)
             If retV = False Then
                configurations(i).doFlag
             End If
        End If
    Next
End Sub

Public Sub removeFlagged()
    Dim nRunner As Integer
    Dim i As Integer
    nRunner = 0
    For i = 1 To cRunner
        If configurations(i).isFlagged = True Then
            
        ElseIf (nRunner + 1 <> i) Then
           nRunner = nRunner + 1
           Set configurations(nRunner) = New ExtQuine_Configuration
           configurations(nRunner).clone configurations(i)
        Else
           nRunner = nRunner + 1
        End If
    Next
    cRunner = nRunner
    freeze
End Sub

Public Sub setCases(ByRef TT As InternalTable)
    Dim i As Integer
    For i = 1 To cRunner
        configurations(i).setCases TT.getCases
    Next
End Sub
Attribute VB_Name = "ExtQuine_Configuration"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim nv As Integer
Dim cId As String
Dim cValues() As Integer
'Dim cOutcome As Integer
Dim i As Integer
Dim flagged As Boolean
Dim lastChanged As Integer
Dim goodCases() As Boolean

Sub Constructor()
End Sub

Public Sub setValues(ByRef ic As InternalCase)
    cValues = ic.getValues
    nv = UBound(cValues)
    'cOutcome = ic.GetOutcome
    cId = ic.getID
    flagged = False
    lastChanged = -1
End Sub

Public Sub clone(ByRef eqc As ExtQuine_Configuration)
    cValues = eqc.getValues
    nv = UBound(cValues)
    'cOutcome = ic.GetOutcome
    cId = eqc.getID
    flagged = False
    lastChanged = -1
End Sub

Public Function getValues() As Integer()
    getValues = cValues
End Function

Public Sub makePossibleImplicant(ByRef aID As String, ByRef aValues() As Integer, ByRef rCond As Integer)
    cValues = aValues
    nv = UBound(cValues)
    cId = aID
    cValues(rCond) = -1
    lastChanged = rCond
    flagged = False
End Sub

Public Sub makeNeededConfiguration(ByRef aID As String, ByRef aValues() As Integer, ByRef rCond As Integer, ByRef rValue As Integer)
    cValues = aValues
    nv = UBound(cValues)
    cId = aID
    cValues(rCond) = rValue
    lastChanged = -1
    flagged = False
End Sub

Public Function checkNeededConfigurations(ByRef dimensions() As Integer, ByRef eqSet() As ExtQuine_Configuration) As Boolean
    For i = 1 To dimensions(lastChanged)
        Dim qr As ExtQuine_Configuration
        Set qr = New ExtQuine_Configuration
        qr.makeNeededConfiguration cId, cValues, lastChanged, i - 1
        Dim j As Integer
        Dim tf As Boolean
        tf = False
        
        For j = 1 To UBound(eqSet)
            If eqSet(j).sameValues(qr) Then
                tf = True
                Exit For
            End If
        Next
        If tf = False Then
            checkNeededConfigurations = False
            Exit Function
        End If
    Next
    checkNeededConfigurations = True
End Function

Public Function getPossibleImplicants() As ExtQuine_ConfSet
    Dim ret As ExtQuine_ConfSet
    Set ret = New ExtQuine_ConfSet
    ret.init
    For i = 1 To nv
        If cValues(i) > -1 Then
            Dim q As ExtQuine_Configuration
            Set q = New ExtQuine_Configuration
            q.makePossibleImplicant cId, cValues, i
            ret.addConfiguration q
        End If
    Next
    ret.freeze
    Set getPossibleImplicants = ret
End Function

Public Sub doFlag()
    flagged = True
End Sub

Public Function isFlagged() As Boolean
    isFlagged = flagged
End Function

Public Function sameValues(ByRef eq As ExtQuine_Configuration) As Boolean
    Dim eV() As Integer
    eV = eq.getValues
    For i = 1 To nv
        If eV(i) <> cValues(i) Then
            sameValues = False
            Exit Function
        End If
    Next
    sameValues = True
End Function

Public Function getLastChanged() As Integer
    getLastChanged = lastChanged
End Function

Public Function getID() As String
    getID = cId
End Function

Public Sub setCases(ByRef tCases() As InternalCase)
    Dim nC As Integer
    Dim i As Integer

    nC = UBound(tCases)
    
    ReDim goodCases(nC)
    
    For i = 1 To nC
        goodCases(i) = caseIsImplied(tCases(i))
    Next
End Sub

Public Function getCases() As Boolean()
    getCases = goodCases
End Function

Function caseIsImplied(ByRef cCase As InternalCase) As Boolean
    Dim i As Integer
    Dim eV() As Integer
    eV = cCase.getValues
    For i = 1 To nv
        If cValues(i) <> -1 And cValues(i) <> eV(i) Then
            caseIsImplied = False
            Exit Function
        End If
    Next
    caseIsImplied = True
    
End Function

Attribute VB_Name = "GBA_Agent"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim goodCases() As Boolean
Dim badCases() As Boolean
Dim nCases As Integer
Dim values() As Integer
Dim nvars As Integer


Sub Class_Initialize()
   
End Sub

Public Sub doClone(ByRef agent As GBA_Agent)
    nCases = agent.GetNCases
    ReDim goodCases(nCases)
    ReDim badCases(nCases)
    goodCases = agent.getGoodCases
    badCases = agent.getBadCases
    nvars = agent.getVars
    ReDim values(nvars)
    values = agent.getValues
    
End Sub

Public Sub createFromExtQuine(ByRef extConf As ExtQuine_Configuration)
    'nCases = agent.GetNCases
    'ReDim goodCases(nCases)
    'ReDim badCases(nCases)
    'goodCases = agent.getGoodCases
    'badCases = agent.getBadCases
    nvars = UBound(extConf.getValues)
    Dim i As Integer
    ReDim values(nvars)
    values = extConf.getValues
    For i = 1 To nvars
        values(i) = values(i) + 1
    Next

End Sub

Public Sub initasroot(ByRef nC As Integer, ByRef nv As Integer)
    nCases = nC
    nvars = nv
    ReDim goodCases(nCases)
    ReDim badCases(nCases)
    Dim i As Integer
    For i = 1 To nCases
        goodCases(i) = True
        badCases(i) = True
    Next
    ReDim values(nvars)
    For i = 0 To nvars
        values(i) = 0
   Next

End Sub

Public Sub proceed(ByRef cell As GBA_Cell, ByRef sVar As Integer, ByRef sValue As Integer)
    values(sVar) = sValue
    goodCases = cell.combineGood(goodCases)
    badCases = cell.combineBad(badCases)
End Sub

Public Function getStatus() As Integer
    Dim i As Integer
    Dim hasGood As Boolean
    Dim hasbad As Boolean
    hasGood = False
    hasbad = False
   
    For i = 1 To nCases
        If badCases(i) = True Then
            hasbad = True
        Exit For
        End If
    Next
    
    For i = 1 To nCases
        If goodCases(i) = True Then
            hasGood = True
        Exit For
        End If
    Next
        
    If hasGood = False Then
        getStatus = 2
    ElseIf hasbad = False Then
        getStatus = 1
    Else
        getStatus = 0
    End If
End Function

Public Function GetNCases() As Integer
    GetNCases = nCases
End Function

Public Function getGoodCases() As Boolean()
    getGoodCases = goodCases
End Function

Public Function getBadCases() As Boolean()
    getBadCases = badCases
End Function

Public Function getVars() As Integer
    getVars = nvars
End Function

Public Function getValues() As Integer()
    getValues = values
End Function

Public Function getValuesString() As String
    Dim r As String
    r = ""
    Dim i As Integer
    For i = 1 To nvars
        r = r + CStr(values(i))
    Next
    getValuesString = r
End Function
Attribute VB_Name = "GBA_Cell"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim goodCases() As Boolean
Dim badCases() As Boolean
Dim nCases As Integer
Dim varNumber As Integer
Dim varValue As Integer


Sub Class_Initialize()

End Sub

Sub init(ByRef nCas As Integer, ByRef vN As Integer, ByRef vv As Integer)
    nCases = nCas
    ReDim goodCases(nCases) As Boolean
    ReDim badCases(nCases) As Boolean
    varNumber = vN
    varValue = vv
    
End Sub

Sub ParseCases(ByRef cases() As InternalCase, ByRef outcome As Integer)
    Dim i As Integer
    Dim tv() As Integer
    Dim tva As Integer
    Dim outC As Integer
    
    For i = 1 To nCases
        outC = cases(i).GetOutcome
        tv = cases(i).getValues
        tva = tv(varNumber)
           
        If tva = varValue Then
            If outC = outcome Then
                goodCases(i) = True
            Else
                badCases(i) = True
            End If
        End If
    Next
End Sub

Public Function combineGood(ByRef agentValues() As Boolean) As Boolean()
    Dim ret() As Boolean
    ReDim ret(nCases)
    Dim i As Integer
    For i = 1 To nCases
        ret(i) = agentValues(i) And goodCases(i)
    Next
    combineGood = ret
End Function

Public Function combineBad(ByRef agentValues() As Boolean) As Boolean()
    Dim ret() As Boolean
    ReDim ret(nCases)
    Dim i As Integer
    For i = 1 To nCases
        ret(i) = agentValues(i) And badCases(i)
    Next
    combineBad = ret
End Function
Attribute VB_Name = "GBA_Implicant"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim goodCases() As Boolean
Dim nCases As Integer
Dim values() As Integer
Dim doShow As Boolean

Public fConsistency As Single
Dim fCalcNum As Single
Dim fCalcDenum As Single
Dim fCalcCovDenum As Single
Public fCoverage As Single


Sub Class_Initialize()
 doShow = True
End Sub


' ----
' returns true if THIS is part of AGENT -> AGENT implies THIS

Public Function isPartOf(ByRef agent As GBA_Implicant) As Boolean
    Dim ct() As Integer
    ct = agent.getValues()
    Dim i As Integer
    For i = 1 To UBound(ct)
        If ct(i) > 0 Then
            If values(i) <> ct(i) Then
                isPartOf = False
                Exit Function
            End If
        End If
    Next
    isPartOf = True
End Function

' ---
' returns true if THIS implies iCASE
Public Function impliesCase(ByRef iCase As InternalCase) As Boolean
    Dim ct() As Integer
    ct = iCase.getValues()
    Dim i As Integer
    For i = 1 To UBound(ct)
        If values(i) > 0 Then
            If values(i) <> ct(i) + 1 Then
                impliesCase = False
                Exit Function
            End If
        End If
    Next
    impliesCase = True
    
End Function

' ----
' returns true if AGENT is part of THIS -> THIS implies AGENT
' this function is used to check if cases are implied by an implicant
' doCorrect increases value by 1

Public Function implies(ByRef ct() As Integer, ByRef doCorrect As Boolean) As Boolean
    Dim cValue As Integer
    cValue = 0
    If doCorrect = True Then
        cValue = 1
    End If
    
    Dim i As Integer
    
    For i = 1 To UBound(ct)
        If values(i) > 0 Then
            If (ct(i) + cValue) <> values(i) Then
                implies = False
                Exit Function
            End If
        End If
    Next
    implies = True
End Function

Sub setImplicantValues(ByRef implicant As GBA_Implicant)
    nCases = implicant.GetNCases
    goodCases = implicant.getGoodCases
    values = implicant.getValues
    doShow = implicant.getShow
    fConsistency = implicant.fConsistency
    fCoverage = implicant.fCoverage
End Sub


Sub setValues(ByRef agent As GBA_Agent)
    nCases = agent.GetNCases
    goodCases = agent.getGoodCases
    values = agent.getValues
End Sub

Function getValues() As Integer()
    getValues = values
End Function

Function getShow() As Boolean
    getShow = show
End Function

Function GetNCases() As Integer
    GetNCases = nCases
End Function

Function getGoodCases() As Boolean()
    getGoodCases = goodCases
End Function

Sub filter()
    doShow = False
End Sub

Public Function show() As Boolean
    show = doShow
End Function

Public Function getText(ByRef VarNames() As String, ByRef qcanotation As Boolean) As String
    Dim r As String
    Dim i As Integer
    For i = 1 To UBound(VarNames)
        If (values(i) > 0) Then
            If qcanotation = True Then
                If values(i) = 1 Then
                   r = r + LCase(VarNames(i)) + "*"
                Else
                   r = r + UCase(VarNames(i)) + "*"
                End If
            Else
                r = r + VarNames(i) + "{" + CStr(values(i) - 1) + "}*"
            End If
        End If
        
    Next
    getText = Left(r, Len(r) - 1)

End Function

Sub initFuzzy()
    fCalcNum = 0
    fCalcDenum = 0
    fCalcCovDenum = 0

End Sub

Sub finishFuzzy()
    fConsistency = fCalcNum / fCalcDenum
    fCoverage = fCalcNum / fCalcCovDenum
End Sub

Sub parseFuzzyCase(ByRef fCase As InternalCase)
    Dim cF As Single
    cF = fCase.getFuzzyImplicantVectorValue(values)
    If cF < fCase.fOutput Then
        fCalcNum = fCalcNum + cF
    Else
        fCalcNum = fCalcNum + fCase.fOutput
    End If
    fCalcDenum = fCalcDenum + cF
    fCalcCovDenum = fCalcCovDenum + fCase.fOutput
End Sub

Function getMin(ByRef vla As Single, ByRef vlb As Single) As Single
    getMin = vla
    If vlb < vla Then
        getMin = vlb
    End If
    
End Function
Attribute VB_Name = "GBA_Implicant1"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim goodCases() As Boolean
Dim nCases As Integer
Dim values() As Integer
Dim doShow As Boolean

Public fConsistency As Single
Dim fCalcNum As Single
Dim fCalcDenum As Single
Dim fCalcCovDenum As Single
Public fCoverage As Single


Sub Class_Initialize()
 doShow = True
End Sub


' ----
' returns true if THIS is part of AGENT -> AGENT implies THIS

Public Function isPartOf(ByRef agent As GBA_Implicant) As Boolean
    Dim ct() As Integer
    ct = agent.getValues()
    Dim i As Integer
    For i = 1 To UBound(ct)
        If ct(i) > 0 Then
            If values(i) <> ct(i) Then
                isPartOf = False
                Exit Function
            End If
        End If
    Next
    isPartOf = True
End Function

' ---
' returns true if THIS implies iCASE
Public Function impliesCase(ByRef iCase As InternalCase) As Boolean
    Dim ct() As Integer
    ct = iCase.getValues()
    Dim i As Integer
    For i = 1 To UBound(ct)
        If values(i) > 0 Then
            If values(i) <> ct(i) + 1 Then
                impliesCase = False
                Exit Function
            End If
        End If
    Next
    impliesCase = True
    
End Function

' ----
' returns true if AGENT is part of THIS -> THIS implies AGENT
' this function is used to check if cases are implied by an implicant
' doCorrect increases value by 1

Public Function implies(ByRef ct() As Integer, ByRef doCorrect As Boolean) As Boolean
    Dim cValue As Integer
    cValue = 0
    If doCorrect = True Then
        cValue = 1
    End If
    
    Dim i As Integer
    
    For i = 1 To UBound(ct)
        If values(i) > 0 Then
            If (ct(i) + cValue) <> values(i) Then
                implies = False
                Exit Function
            End If
        End If
    Next
    implies = True
End Function

Sub setImplicantValues(ByRef implicant As GBA_Implicant)
    nCases = implicant.GetNCases
    goodCases = implicant.getGoodCases
    values = implicant.getValues
    doShow = implicant.getShow
    fConsistency = implicant.fConsistency
    fCoverage = implicant.fCoverage
End Sub


Sub setValues(ByRef agent As GBA_Agent)
    nCases = agent.GetNCases
    goodCases = agent.getGoodCases
    values = agent.getValues
End Sub

Function getValues() As Integer()
    getValues = values
End Function

Function getShow() As Boolean
    getShow = show
End Function

Function GetNCases() As Integer
    GetNCases = nCases
End Function

Function getGoodCases() As Boolean()
    getGoodCases = goodCases
End Function

Sub filter()
    doShow = False
End Sub

Public Function show() As Boolean
    show = doShow
End Function

Public Function getText(ByRef VarNames() As String, ByRef qcanotation As Boolean) As String
    Dim r As String
    Dim i As Integer
    For i = 1 To UBound(VarNames)
        If (values(i) > 0) Then
            If qcanotation = True Then
                If values(i) = 1 Then
                   r = r + LCase(VarNames(i)) + "*"
                Else
                   r = r + UCase(VarNames(i)) + "*"
                End If
            Else
                r = r + VarNames(i) + "{" + CStr(values(i) - 1) + "}*"
            End If
        End If
        
    Next
    getText = Left(r, Len(r) - 1)

End Function

Sub initFuzzy()
    fCalcNum = 0
    fCalcDenum = 0
    fCalcCovDenum = 0

End Sub

Sub finishFuzzy()
    fConsistency = fCalcNum / fCalcDenum
    fCoverage = fCalcNum / fCalcCovDenum
End Sub

Sub parseFuzzyCase(ByRef fCase As InternalCase)
    Dim cF As Single
    cF = fCase.getFuzzyImplicantVectorValue(values)
    If cF < fCase.fOutput Then
        fCalcNum = fCalcNum + cF
    Else
        fCalcNum = fCalcNum + fCase.fOutput
    End If
    fCalcDenum = fCalcDenum + cF
    fCalcCovDenum = fCalcCovDenum + fCase.fOutput
End Sub

Function getMin(ByRef vla As Single, ByRef vlb As Single) As Single
    getMin = vla
    If vlb < vla Then
        getMin = vlb
    End If
    
End Function
Attribute VB_Name = "GBA_Map"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim cells() As GBA_Cell
Dim vDimension() As Integer
Dim VarNames() As String
Dim nVar As Integer
Dim nCases As Integer
Dim cases() As InternalCase
Dim maxDim As Integer
Dim implicants() As GBA_Implicant
Dim foundImplicants As Integer
Dim sizeImplicantArray As Integer



Sub Class_Initialize()

End Sub

Sub initaliseMap(ByRef TT As InternalTable, ByRef outcome As Integer)
    Dim j As Integer
    Dim i As Integer
    
    cases = TT.getCases()
    nCases = UBound(cases)
    
    
    VarNames = TT.getVars()
    nVar = UBound(VarNames)
    vDimension = TT.GetDimension()
    maxDim = vDimension(1)
    
    For i = 1 To nVar
     If maxDim < vDimension(i) Then
        maxDim = vDimension(i)
    End If
    Next
    ReDim cells(nVar, maxDim)
    
    For i = 1 To nVar
        For j = 1 To vDimension(i)
           Set cells(i, j) = New GBA_Cell
           cells(i, j).init nCases, i, (j - 1)
           cells(i, j).ParseCases cases, outcome
        Next
    Next
    foundImplicants = 0
    sizeImplicantArray = 100
    ReDim implicants(sizeImplicantArray)
End Sub

Sub createMapFromExtQuine(ByRef TT As InternalTable, ByRef extSet As ExtQuine_ConfSet)
    Dim i As Integer
    cases = TT.getCases()
    nCases = UBound(cases)
    VarNames = TT.getVars()
    nVar = UBound(VarNames)
    
    foundImplicants = 0
    sizeImplicantArray = 100
    ReDim implicants(sizeImplicantArray)
    
    For i = 1 To extSet.getRunner
        Dim gbaTemp As GBA_Agent
        Set gbaTemp = New GBA_Agent
        gbaTemp.createFromExtQuine extSet.getConfiguration(i)
        AddFoundImplicant gbaTemp
    Next
    
    filterAgents
End Sub

Sub AddFoundImplicant(ByRef fAgent As GBA_Agent)
    If foundImplicants >= sizeImplicantArray Then
        sizeImplicantArray = sizeImplicantArray * 2
        ReDim Preserve implicants(sizeImplicantArray)
    End If
    foundImplicants = foundImplicants + 1
    Set implicants(foundImplicants) = New GBA_Implicant
    implicants(foundImplicants).setValues fAgent

End Sub

Public Sub filterAgents()
    Dim i As Integer
    Dim j As Integer
    
    For i = 1 To foundImplicants
        For j = 1 To foundImplicants
            If i <> j Then
                If implicants(i).isPartOf(implicants(j)) Then
                    implicants(i).filter
                End If
            End If
        Next
    Next

End Sub

Function getCasesImplied(ByRef impl As GBA_Implicant) As String
    getCasesImplied = ""
    Dim i As Integer
    For i = 1 To nCases
        If impl.impliesCase(cases(i)) Then
            getCasesImplied = getCasesImplied + cases(i).getID + ", "
        End If
    Next
    If (getCasesImplied <> "") Then
        getCasesImplied = Left(getCasesImplied, Len(getCasesImplied) - 2)
    End If
End Function


Sub implicantOutput(ByRef ret As Worksheet, ByRef sx As Integer, ByRef sY As Integer, ByRef qcanotation As Boolean)
    Dim i As Integer
    Dim mRunner As Integer
    mRunner = 1
    
    For i = 1 To foundImplicants
        If implicants(i).show Then
            ret.cells(sx + mRunner, sY) = implicants(i).getText(VarNames, qcanotation)
            ret.cells(sx + mRunner, sY + 2) = getCasesImplied(implicants(i))
            ret.cells(sx + mRunner, sY + 2).Font.Color = vbBlue
            ret.cells(sx + mRunner, sY + 1) = Str(implicants(i).fConsistency)
            mRunner = mRunner + 1
        End If
        
    Next
    ret.cells(sx, sY) = "'# Implicants: " + CStr(mRunner - 1)
    ret.cells(sx, sY).Font.Color = vbRed
End Sub

Function retrieveImplicants() As GBA_Implicant()
    Dim mi() As GBA_Implicant
    ReDim mi(foundImplicants)
    
    Dim i As Integer
    Dim mRunner As Integer
    mRunner = 1
    
    For i = 1 To foundImplicants
        If implicants(i).show Then
            Set mi(mRunner) = New GBA_Implicant
            mi(mRunner).setImplicantValues implicants(i)
            mRunner = mRunner + 1
        End If
        
    Next
    ReDim Preserve mi(mRunner - 1)
    retrieveImplicants = mi
End Function

Sub getImplicants()
    Dim rootAgent As New GBA_Agent
    rootAgent.initasroot nCases, nVar
    traversemap rootAgent, 0, 0
End Sub

Sub traversemap(ByRef agent As GBA_Agent, ByRef sVar As Integer, ByRef sValue As Integer)
    Dim i As Integer
     
    If sValue = 0 Then
        If sVar < nVar Then
            Dim nextAgent As New GBA_Agent
            For i = 1 To vDimension(sVar + 1)
                Set nextAgent = New GBA_Agent
                nextAgent.doClone agent
                traversemap nextAgent, (sVar + 1), i
            Next
            Set nextAgent = New GBA_Agent
            nextAgent.doClone agent
            traversemap nextAgent, (sVar + 1), 0
        End If
       
     Else
        agent.proceed cells(sVar, sValue), sVar, sValue
        Dim stat As Integer
        stat = agent.getStatus
        If stat = 1 Then
            Dim f As String
            f = agent.getValuesString()
            AddFoundImplicant agent
        ElseIf stat = 0 Then
             If sVar < nVar Then
                For i = 1 To vDimension(sVar + 1)
                    Set nextAgent = New GBA_Agent
                    nextAgent.doClone agent
                    traversemap nextAgent, (sVar + 1), i
                Next
                Set nextAgent = New GBA_Agent
                nextAgent.doClone agent
                traversemap nextAgent, (sVar + 1), 0
            End If
        End If
    End If
End Sub

Sub calculateCoverageConsistence(ByRef TT As InternalTable)
    Dim i As Integer
    Dim j As Integer
    For i = 1 To foundImplicants
        implicants(i).initFuzzy
        For j = 1 To TT.nOxCases
            implicants(i).parseFuzzyCase TT.getOxCases(j)
        Next
        implicants(i).finishFuzzy
    Next
End Sub
Attribute VB_Name = "InteractiveCode"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Attribute VB_Name = "InternalCase"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim nv As Integer
Dim cId As String
Dim cValues() As Integer
Dim cOutcome As Integer

Public fOutput As Single
Dim fValues() As Single
Public fConsistency As Single
Dim fCalcNum As Single
Dim fCalcDenum As Single

Public iValue As Double

Sub Constructor()
   
End Sub

Public Sub setValuesFromFuzzy(ByRef oTable As Range, ByRef index As Integer, ByRef ncond() As Integer, ByRef nid As Integer, ByRef nout As Integer, ByVal oone As Boolean)
    Dim i As Integer
    Dim cRunner As Integer
    Dim rrunner As Integer
    rrunner = 0
    cRunner = 0
    nv = oTable.Columns.Count - 2
    ReDim cValues(nv)
    ReDim fValues(nv)
    Dim numberConditions As Integer
    numberConditions = UBound(ncond)
   
    
    For i = 1 To nv + 2
        Dim a As String
        a = oTable.cells(index, i)
        If i = nid Then
            cId = a
        ElseIf i = nout Then
            fOutput = CDbl(a)
            If (cOne = False) Then
                fOutput = 1 - fOutput
                End If
            'cOutcome = a
        ElseIf rrunner <= numberConditions Then
            If i = ncond(rrunner) Then
            cRunner = cRunner + 1
            Dim z As Integer
            z = 0
            Dim qq As Double
            qq = CDbl(a)
            If qq > 0.5 Then
                z = 1
            End If
            cValues(cRunner) = z
            fValues(cRunner) = qq
            rrunner = rrunner + 1
            End If
            
        End If
    Next
    ReDim Preserve cValues(numberConditions + 1)
    nv = numberConditions + 1
    
End Sub


Public Sub setValuesWindows(ByRef oTable As Range, ByRef index As Integer, ByRef ncond() As Integer, ByRef nid As Integer, ByRef nout As Integer)
    Dim i As Integer
    Dim cRunner As Integer
    Dim rrunner As Integer
    rrunner = 0
    cRunner = 0
    nv = oTable.Columns.Count - 2
    ReDim cValues(nv)
    Dim numberConditions As Integer
    numberConditions = UBound(ncond)
    
    For i = 1 To nv + 2
        Dim a As String
        a = oTable.cells(index, i)
        If i = nid Then
            cId = a
        ElseIf i = nout Then
            cOutcome = a
        ElseIf rrunner <= numberConditions Then
            If i = ncond(rrunner) Then
            cRunner = cRunner + 1
            cValues(cRunner) = Val(a)
            rrunner = rrunner + 1
            End If
            
        End If
    Next
    ReDim Preserve cValues(numberConditions + 1)
    ReDim Preserve fValues(numberConditions + 1)
    nv = numberConditions + 1
    
End Sub

Sub setIValue()
   iValue = 0
   Dim i As Integer
   Dim k As Double
   k = 1
   'lazy!
   For i = nv To 1 Step -1
    If cValues(i) > 0 Then
        iValue = iValue + k * cValues(i)
    End If
    k = k * 5
   Next
End Sub

Function CheckDimensions(ByRef maxSofar) As Integer()
    Dim ret() As Integer
    ReDim ret(nv)
    Dim i As Integer
    For i = 1 To nv
        If cValues(i) + 1 > maxSofar(i) Then
            ret(i) = cValues(i) + 1
        Else
            ret(i) = maxSofar(i)
        End If
    Next

    CheckDimensions = ret
End Function

Function getValues() As Integer()
    getValues = cValues
End Function

Function getID() As String
    getID = cId
End Function

Function GetOutcome() As Integer
    GetOutcome = cOutcome
End Function

Function GetTTOutcome() As String
    If cOutcome = 9 Then
        GetTTOutcome = "C"
        Exit Function
        End If
    GetTTOutcome = CStr(cOutcome)
End Function

' ----------------------------
' -- Compare Rows in Table
' -- 0: Conditions differ
' -- 1: Conditions equal, Outcome equal
' -- 2: Conditions equal, Outcome differ

Function Compare(ByRef ic As InternalCase) As Integer
    Dim cv() As Integer
    cv = ic.getValues
    Dim i As Integer
    For i = 1 To nv
        If cv(i) <> cValues(i) Then
            Compare = 0
            Exit Function
        End If
    Next
    
    If cOutcome <> ic.GetOutcome() Then
        Compare = 2
        cId = cId + ", " + ic.getID()
        cOutcome = 9
        Exit Function
    End If

cId = cId + ", " + ic.getID()
Compare = 1

End Function

Public Sub msgOut()
    Dim tx As String
    tx = cId + "["
    Dim i As Integer
    For i = 1 To nv
        tx = tx + CStr(cValues(i)) + ","
    Next
    tx = tx + CStr(cOutcome) + "]"
    MsgBox (tx)
End Sub

Sub initFuzzy()
    fCalcNum = 0
    fCalcDenum = 0

End Sub

Sub finishFuzzy()
    fConsistency = fCalcNum / fCalcDenum
End Sub

Sub parseFuzzyCase(ByRef fCase As InternalCase)
    Dim cF As Single
    cF = fCase.getFuzzyVectorValue(cValues)
    If cF < fCase.fOutput Then
        fCalcNum = fCalcNum + cF
    Else
        fCalcNum = fCalcNum + fCase.fOutput
    End If
    fCalcDenum = fCalcDenum + cF
End Sub

Function getMin(ByRef vla As Single, ByRef vlb As Single) As Single
    getMin = vla
    If vlb < vla Then
        getMin = vlb
    End If
    
End Function


Sub applyThreshold(ByRef threshold As Single)
    cOutcome = 1
    If fConsistency < threshold Then
        cOutcome = 0
    End If
End Sub


Function getFuzzyVectorValue(ByRef vectorValues() As Integer) As Single
    Dim ret As Single
    ret = 1
    Dim i As Integer
    For i = 1 To nv
        If vectorValues(i) = 1 Then
            ret = getMin(ret, fValues(i))
        Else
            ret = getMin(ret, (1 - fValues(i)))
        End If
    Next
    getFuzzyVectorValue = ret
End Function

Function getFuzzyImplicantVectorValue(ByRef vectorValues() As Integer) As Single
    Dim ret As Single
    ret = 1
    Dim i As Integer
    For i = 1 To nv
        If vectorValues(i) = 2 Then
            ret = getMin(ret, fValues(i))
        ElseIf vectorValues(i) = 1 Then
            ret = getMin(ret, (1 - fValues(i)))
        End If
    Next
    getFuzzyImplicantVectorValue = ret
End Function
Attribute VB_Name = "InternalTable"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim vNames() As String
Dim nvars As Integer
Dim nCases As Integer
Dim tCases() As InternalCase
Dim nameID As String
Dim nameOutcome As String
Dim nid As Integer
Dim nout As Integer
Dim ncond() As Integer
Dim numberConditions As Integer
Dim oxCases() As InternalCase
Public nOxCases As Integer

Sub Class_Initialize()

End Sub


Public Sub SetVarNamesWindow(ByRef oTable As Range, ByRef vCond() As String, ByRef vID As String, ByRef vOut As String)
    nvars = oTable.Columns.Count - 2
    ReDim vNames(nvars)
    ReDim ncond(nvars)
    
    Dim i As Integer
    Dim cRunner As Integer
    cRunner = 0
    
    For i = 1 To nvars + 2
        Dim cq As String
        cq = oTable.cells(1, i)
        
        If LCase(cq) = LCase(vID) Then
            nid = i
            nameID = cq
        ElseIf LCase(cq) = LCase(vOut) Then
            nout = i
            nameOutcome = cq
        ElseIf cRunner <= UBound(vCond) Then
            If LCase(cq) = LCase(vCond(cRunner)) Then
            ncond(cRunner) = i
            cRunner = cRunner + 1
            vNames(cRunner) = vCond(cRunner - 1)
            End If
        End If
    Next
    numberConditions = cRunner
    ReDim Preserve ncond(0 To numberConditions - 1)
    ReDim Preserve vNames(numberConditions)
    
End Sub

Public Sub CreateFuzzyTruthTable(ByRef oTable As Range, ByRef vCond() As String, ByRef vID As String, ByRef vOut As String, ByRef oone As Boolean)

    SetVarNamesWindow oTable, vCond, vID, vOut
    Dim i As Integer
   
    ' -- extremely lazy coding!!
    
   
    ' -- extract cases
    
    nOxCases = oTable.Rows.Count - 1
    ReDim tCases(nOxCases) As InternalCase
    ReDim oxCases(nOxCases) As InternalCase
    nCases = 0
    For i = 1 To nOxCases
        Set oxCases(i) = New InternalCase
        oxCases(i).setValuesFromFuzzy oTable, i + 1, ncond, nid, nout, oone
        ParseCaseFuzzy oxCases(i), oTable, i + 1, oone
    Next
    
    ' -- getConsistencyValues
    Dim j As Integer
    For j = 1 To nCases
        tCases(j).initFuzzy
        For i = 1 To nOxCases
            'Dim oxCase As InternalCase
            'Set oxCase = New InternalCase
            'oxCase.setValuesFromFuzzy oTable, i + 1, ncond, nid, nout, oone
            tCases(j).parseFuzzyCase oxCases(i)
        Next
        tCases(j).finishFuzzy
    Next
    
    ReDim Preserve tCases(nCases)
End Sub



' -- mode from DialogueWindow
Public Sub CreateTruthTableWindow(ByRef oTable As Range, ByRef vCond() As String, ByRef vID As String, ByRef vOut As String)
    SetVarNamesWindow oTable, vCond, vID, vOut
    Dim i As Integer
   
    ' -- extract cases
    Dim oldCases As Integer
    oldCases = oTable.Rows.Count - 1
    ReDim tCases(oldCases) As InternalCase
    nCases = 0
    For i = 1 To oldCases
        Dim oCase As InternalCase
        Set oCase = New InternalCase
        oCase.setValuesWindows oTable, i + 1, ncond, nid, nout
        ParseCaseWindows oCase, oTable, i + 1
    Next
    ReDim Preserve tCases(nCases)
End Sub

Public Sub ParseCaseFuzzy(ByRef tCase As InternalCase, ByRef oTable As Range, ByRef indexValue As Integer, ByRef oone As Boolean)
    Dim addTCase As Boolean
    addTCase = True
    Dim i As Integer
        
    For i = 1 To nCases
        Dim q As Integer
        q = tCases(i).Compare(tCase)
        If q > 0 Then
            addTCase = False
            Exit For
        End If
    Next
    
    If addTCase = True Then
        nCases = nCases + 1
        Set tCases(nCases) = New InternalCase
        tCases(nCases).setValuesFromFuzzy oTable, indexValue, ncond, nid, nout, oone
    End If
End Sub


Public Sub ParseCaseWindows(ByRef tCase As InternalCase, ByRef oTable As Range, ByRef indexValue As Integer)
    Dim addTCase As Boolean
    addTCase = True
    Dim i As Integer
        
    For i = 1 To nCases
        Dim q As Integer
        q = tCases(i).Compare(tCase)
        If q > 0 Then
            addTCase = False
            Exit For
        End If
    Next
    
    If addTCase = True Then
        nCases = nCases + 1
        Set tCases(nCases) = New InternalCase
        tCases(nCases).setValuesWindows oTable, indexValue, ncond, nid, nout
    End If
End Sub

Public Sub PrintTruthTableWindows(ByRef ret As Worksheet, ByRef cmode As Integer)
    ret.cells(1, 1) = nameID
    ret.cells(1, numberConditions + 2) = nameOutcome
    If cmode > 0 Then
        ret.cells(1, numberConditions + 3) = "Consistency"
    End If
    Dim i As Integer
    'For i = 1 To nvars
    For i = 1 To numberConditions
        ret.cells(1, i + 1) = vNames(i)
    Next
    Dim j As Integer
    For j = 1 To nCases
        tCases(j).setIValue
    Next
    
    For i = 1 To nCases
        For j = nCases To i + 1 Step -1
            If tCases(j).iValue < tCases(i).iValue Then
                Dim q As InternalCase
                Set q = tCases(j)
                Set tCases(j) = tCases(i)
                Set tCases(i) = q
            End If
        Next
    Next
    
    For j = 1 To nCases
        ret.cells(j + 1, 1) = tCases(j).getID()
        If (cmode <> 1) Then
            ret.cells(j + 1, numberConditions + 2) = tCases(j).GetTTOutcome()
        End If
        
         If (cmode > 0) Then
            'Dim f As String
            'f = CStr(Format(tCases(j).fConsistency, "0.000"))
            ret.cells(j + 1, numberConditions + 3) = tCases(j).fConsistency
            'Left(f, 5)
        End If
        
        Dim tv() As Integer
        tv = tCases(j).getValues()
        'For i = 1 To nvars
        For i = 1 To numberConditions
            ret.cells(j + 1, i + 1) = CStr(tv(i))
        Next
    Next
    
' --FORMAT--
Dim ttWidth As Integer
ttWidth = numberConditions + 2
If cmode > 0 Then ttWidth = ttWidth + 1

For i = 1 To ttWidth
    ret.cells(1, i).Interior.Color = RGB(200, 200, 200)
    ret.cells(1, i).Font.Bold = True
Next

For j = 1 To nCases + 1
    ret.cells(j, 1).HorizontalAlignment = xlLeft
    For i = 2 To nvars + 2
    ret.cells(j, i).HorizontalAlignment = xlCenter
Next
Next

End Sub

Function getOxCases(ByRef i As Integer) As InternalCase
    Set getOxCases = oxCases(i)
End Function

Function getCases() As InternalCase()
    getCases = tCases
End Function

Function GetNCases() As Integer
    GetNCases = nCases
End Function

Function GetDimension() As Integer()
 Dim r() As Integer
 'ReDim r(nvars)
 ReDim r(numberConditions)
 
 Dim i As Integer
 For i = 1 To numberConditions
    r(i) = 2
 Next
 
 For i = 1 To nCases
    r = tCases(i).CheckDimensions(r)
 Next
 
 GetDimension = r

End Function

Function getVars() As String()
    getVars = vNames
End Function

Function getNGoodCases(ByRef outC As Integer) As Integer
    Dim i As Integer
    Dim ret As Integer
    
    For i = 1 To nCases
        Dim j As Integer
        j = tCases(i).GetOutcome
        If j = outC Then
            ret = ret + 1
        End If
    Next

    getNGoodCases = ret
End Function

Sub applyThreshold(ByRef threshold As Single)
    Dim i As Integer
    For i = 1 To nCases
        tCases(i).applyThreshold (threshold)
    Next

End Sub
Attribute VB_Name = "Modul1"
Option Explicit

Public lastValues As Variant
Public lastNames As Variant
Public hasValues As Boolean
Public cOne As Boolean
Public cLR As Boolean
Public cUL As Boolean



Public Sub setLastValues(ByRef lv() As Integer, ByRef ln() As String, ByRef oneset As Boolean, ByRef uselr As Boolean, ByRef useulcase As Boolean)
    
    ReDim lastValues(UBound(lv))
    ReDim lastNames(UBound(lv))
    Dim i As Integer
    For i = 1 To UBound(lv)
        lastValues(i) = lv(i)
        lastNames(i) = ln(i)
    Next
    hasValues = True
    cOne = oneset
    cLR = uselr
    cUL = useulcase
    
End Sub


Public Function getLastValue(ByRef i As Integer) As Integer
    getLastValue = lastValues(i)
End Function

Public Function hassamenames(ByRef ln() As String) As Boolean
    If hasValues = False Then
        hassamenames = False
        Exit Function
        End If
     If UBound(ln) <> UBound(lastNames) Then
        hassamenames = False
        Exit Function
        End If
    Dim i As Integer
    For i = 1 To UBound(ln)
        If ln(i) <> lastNames(i) Then
            hassamenames = False
            Exit Function
        End If
        
    Next
    hassamenames = True
    
End Function

Sub startfsqca(ByVal control As IRibbonControl)
    callWindow 1
End Sub

Sub startqca(ByVal control As IRibbonControl)
    callWindow 0
End Sub



Sub callWindow(ByRef cmode As Integer)
    Dim qw As QCAWindows
    Dim SelRange As Range
    Set SelRange = Selection
    
     If (SelRange.Rows.Count + SelRange.Columns.Count) < 4 Then
        MsgBox ("Are you sure you selected data?")
        Exit Sub
    End If
    
    Dim i As Integer
    Dim j As Integer
    
    For i = 1 To SelRange.Columns.Count
        For j = i + 1 To SelRange.Columns.Count
            If LCase(SelRange.cells(1, i).Value) = LCase(SelRange.cells(1, j).Value) Then
                MsgBox "All Columns must have different names"
                Exit Sub
            End If
        Next
    Next
    
    Set qw = New QCAWindows
    qw.setRange SelRange
    'Mode 0 = cs or mv QCA
    'MOde 1 = fsqca
    qw.setMode cmode
   ' qw.setWorkbook ActiveWorkbook
    qw.show

End Sub



Sub Main()



End Sub


Attribute VB_Name = "Modul2"
Public firstNewColumn As Integer
Public nRows As Integer
Public firstColumn As Integer
Public nColumns As Integer
Public firstRow As Integer
Dim VarNames() As String
'Dim interCode As InteractiveCode


Dim cCell As Range
Dim CB As Object
Dim ComboBox1 As OLEObject

Sub startThresholdWizard(ByVal control As IRibbonControl)
    Dim SelRange As Range
    Set SelRange = Selection
    firstRow = SelRange.Row
    firstColumn = SelRange.Column
    nColumns = SelRange.Columns.Count
    nRows = SelRange.Rows.Count
    ReDim VarNames(nColumns)
    
    ActiveSheet.cells(firstRow, 1).EntireRow.Insert
    firstNewColumn = firstColumn + nColumns + 2
    
    Dim i, j As Integer
    For i = 0 To nColumns - 1
        VarNames(i) = ActiveSheet.cells(firstRow + 1, i + firstColumn).Value
    
        With ActiveSheet.cells(firstRow, i + firstNewColumn)
          .Value = 0.5
          .HorizontalAlignment = xlCenter
        End With
        
        With ActiveSheet.cells(firstRow + nRows, i + firstNewColumn)
          .Borders(xlEdgeBottom).LineStyle = xlContinuous
        End With
       
        With ActiveSheet.cells(firstRow + 1, i + firstNewColumn)
            .Value = ActiveSheet.cells(firstRow + 1, i + firstColumn).Value
            .Borders(xlEdgeBottom).LineStyle = xlContinuous
            .Font.Bold = ActiveSheet.cells(firstRow + 1, i + firstColumn).Font.Bold
            .Interior.Color = ActiveSheet.cells(firstRow + 1, i + firstColumn).Interior.Color
        End With
    Next
        
    ActiveSheet.cells(firstRow, firstNewColumn).HorizontalAlignment = xlLeft
        
   Set cCell = Range(cells(firstRow + nRows, firstNewColumn), cells(firstRow + nRows, firstNewColumn))
        
    For j = 1 To nRows - 1
    
        ActiveSheet.cells(j + firstRow + 1, firstNewColumn).Value = ActiveSheet.cells(j + firstRow + 1, firstColumn).Value
        For i = 1 To nColumns - 1
            
            
            With ActiveSheet.cells(firstRow + j + 1, i + firstNewColumn)
                .Formula = "=if(" & cells(j + firstRow + 1, firstColumn + i).Address & " >= " & cells(firstRow, i + firstNewColumn).Address & ",1,0)"
                
            End With
        Next
    Next
       
    With ActiveSheet.cells(firstRow, firstNewColumn)
        .Value = "Threshold"
        .Font.Bold = True
    End With
        

    'addThresholdButton // Funktioniert wohl unter mac nicht!!
    
End Sub




Attribute VB_Name = "QCAWindows"
Attribute VB_Base = "0{5D9A54A5-A4E6-47CE-BD21-3B7B07D4DD9C}{25F51B08-BAD2-4F81-A735-30B5D5F1FE90}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Dim mRange As Range
Dim mBook As Workbook
Dim vNames() As String
Dim vUse() As Integer
Dim vNumber As Integer
Dim hasID As Boolean
Dim hasOut As Boolean

Dim fTruthTable As New InternalTable
    

Dim cmode As Integer

Private Sub bCond_Click()
Dim i As Integer
   For i = 0 To ListBox1.ListCount - 1
       If ListBox1.Selected(i) Then
             changeMode CStr(ListBox1.List(i)), 3
       End If
   Next
   updateWindow
End Sub

Private Sub bID_Click()
    Dim i As Integer
    'MsgBox " " + CStr(hasID)
    If hasID Then
        changeMode tID.Value, 0
    Else
        For i = 0 To ListBox1.ListCount - 1
            If ListBox1.Selected(i) Then
                changeMode CStr(ListBox1.List(i)), 1
                Exit For
            End If
        Next
        'changeMode tID.Value, ListBox1.Selected
    End If
    updateWindow
End Sub

Private Sub bMinfsQCA_Click()
     ' -- Sheet Truthtable erzeugen
    On Error Resume Next
    Application.DisplayAlerts = False
    ActiveWorkbook.Sheets("fsQCA Result").Delete
    ActiveWorkbook.Sheets.Add(After:=Worksheets(1)).Name = "fsQCA Result"
    
    Application.DisplayAlerts = True
    On Error GoTo 0
    
    Dim i As Integer
    tThreshold.Value = Replace(tThreshold.Value, ",", ".")
    fTruthTable.applyThreshold Val(tThreshold.Value)
     Dim TTSheet As Worksheet
    Set TTSheet = ActiveWorkbook.Worksheets("fsQCA Result")
    fTruthTable.PrintTruthTableWindows TTSheet, 2
    
    Dim nCasesTable As Integer
    nCasesTable = fTruthTable.GetNCases
    
    ' -- check settings
    
    Dim dcheck As DataChecks
    Set dcheck = New DataChecks
    
  
    
    Dim qcanotation As Boolean
    qcanotation = cQCANotation.Value
   
    ' -- calculations
    Dim outcome As Integer
    outcome = 1
       
    Dim infoString As String
    Dim infostring2 As String
    infoString = "Outcome: "
    If (OptionButton2.Value = False) Then
        infoString = infoString + "~"
        End If
    infoString = infoString + tOut.Value
    infostring2 = "Including logical Remainders: "
    
    
    If cIncludeLogicalRemainders.Value = True Then
        infostring2 = infostring2 + "YES"
        ' -- Testroutine: PI berechnen
        Dim mT As New GBA_Map
        mT.initaliseMap fTruthTable, outcome
        mT.getImplicants
        mT.filterAgents
        mT.calculateCoverageConsistence fTruthTable
        mT.implicantOutput TTSheet, (nCasesTable + 6), 1, qcanotation

        ' -- Testrouting: SO berechnen
        Dim mS As New Solution_Map
        Dim mi() As GBA_Implicant
        mi = mT.retrieveImplicants
        mS.initaliseMap mi, fTruthTable, outcome
        Dim gc As Integer
        gc = fTruthTable.getNGoodCases(outcome)
        mS.getSolutions gc
        Dim vN() As String
        vN = fTruthTable.getVars
        mS.filterAgents
        mS.calculateCoverageConsistency fTruthTable
        mS.solutionOutput TTSheet, (nCasesTable + 8 + UBound(mi)), 1, vN, qcanotation, 1
    Else
        ' -- Testroutine: PI berechnen
        infostring2 = infostring2 + "NO"
        Dim mTx As New ExtQuine_Base
        mTx.initialiseBase fTruthTable, outcome
        mTx.process fTruthTable, TTSheet, qcanotation, (nCasesTable + 6), 1
    End If

    ' -- sch_n machen und anzeigen
    Dim reportWidth As Integer
    reportWidth = 7
    
    TTSheet.Range(TTSheet.cells(nCasesTable + 4, 1), TTSheet.cells(nCasesTable + 4, reportWidth)).MergeCells = True
    For i = 1 To reportWidth
        TTSheet.cells((nCasesTable + 4), i).Borders(xlEdgeBottom).Weight = xlMedium
    Next
    TTSheet.cells((nCasesTable + 4), 1).Value = infoString
    TTSheet.cells((nCasesTable + 4), 2).Value = infostring2
    TTSheet.Columns("A").EntireColumn.AutoFit
    TTSheet.Activate
    
End Sub

Private Sub bOUT_Click()
    Dim i As Integer
    If hasOut Then
        changeMode tOut.Value, 0
    Else
        For i = 0 To ListBox1.ListCount - 1
            If ListBox1.Selected(i) Then
                changeMode CStr(ListBox1.List(i)), 2
                Exit For
            End If
        Next
    End If
    updateWindow
End Sub

Private Sub bPrepare_Click()
    
    
    ' --save selection in QCA Window for next use--
    Modul1.setLastValues vUse, vNames, OptionButton2.Value, cIncludeLogicalRemainders.Value, cQCANotation.Value
    
    Dim qq As Integer
    qq = ListBox2.ListCount
    Dim cNames() As String
    ReDim cNames(qq - 1)
    Dim i As Integer
    For i = 0 To ListBox2.ListCount - 1
              cNames(i) = CStr(ListBox2.List(i))
    Next
    
    fTruthTable.CreateFuzzyTruthTable mRange, cNames, tID.Value, tOut.Value, OptionButton2.Value
    
    ' -- Sheet Truthtable erzeugen
    On Error Resume Next
    Application.DisplayAlerts = False
    ActiveWorkbook.Sheets("fsQCA Result").Delete
    ActiveWorkbook.Sheets.Add(After:=Worksheets(1)).Name = "fsQCA Result"
    
    Application.DisplayAlerts = True
    On Error GoTo 0
    
    Dim TTSheet As Worksheet
    Set TTSheet = ActiveWorkbook.Worksheets("fsQCA Result")
    
    ' -- Show Truthtable
    fTruthTable.PrintTruthTableWindows TTSheet, 1
    
    bMinfsQCA.Enabled = True
    tThreshold.Enabled = True
    Label5.Enabled = True
    
    TTSheet.Columns("A").EntireColumn.AutoFit
End Sub

Private Sub cBack_Click()
Dim i As Integer
   For i = 0 To ListBox2.ListCount - 1
       If ListBox2.Selected(i) Then
             changeMode CStr(ListBox2.List(i)), 0
       End If
   Next
   updateWindow
End Sub

Private Sub cGO_Click()
    
    ' --save selection in QCA Window for next use--
    Modul1.setLastValues vUse, vNames, OptionButton2.Value, cIncludeLogicalRemainders.Value, cQCANotation.Value
    
    Dim TruthTable As New InternalTable
    Dim qq As Integer
    qq = ListBox2.ListCount
    Dim cNames() As String
    ReDim cNames(qq - 1)
    Dim i As Integer
    For i = 0 To ListBox2.ListCount - 1
              cNames(i) = CStr(ListBox2.List(i))
    Next
    
    TruthTable.CreateTruthTableWindow mRange, cNames, tID.Value, tOut.Value
    
    ' -- Sheet Truthtable erzeugen
    On Error Resume Next
    Application.DisplayAlerts = False
    ActiveWorkbook.Sheets("QCA Result").Delete
    ActiveWorkbook.Sheets.Add(After:=Worksheets(1)).Name = "QCA Result"
    
    Application.DisplayAlerts = True
    On Error GoTo 0
    
    Dim TTSheet As Worksheet
    'Set TTSheet = ThisWorkbook.Worksheets("TruthTable")
    Set TTSheet = ActiveWorkbook.Worksheets("QCA Result")
    
    ' -- Show Truthtable
    TruthTable.PrintTruthTableWindows TTSheet, 0
    
    Dim nCasesTable As Integer
    nCasesTable = TruthTable.GetNCases
    
    ' -- check settings
    
    Dim dcheck As DataChecks
    Set dcheck = New DataChecks
    
  
    
    Dim qcanotation As Boolean
    qcanotation = False
    If cQCANotation.Value = True Then
        
        If dcheck.isBoolean(TruthTable) Then
            qcanotation = True
        Else
            cQCANotation.Value = False
            MsgBox ("QCA Notation is not possible for mvQCA!")
        End If
    End If
    
    ' -- calculations
    Dim outcome As Integer
    
    If OptionButton2.Value = True Then
        outcome = 1
    Else
        outcome = 0
    End If
        
    Dim infoString As String
    Dim infostring2 As String
    infoString = "Outcome: " + CStr(outcome)
    infostring2 = "Including Remainders: "
    
      If cIncludeLogicalRemainders.Value = True Then
        infostring2 = infostring2 + "YES"
        ' -- Testroutine: PI berechnen
        Dim mT As New GBA_Map
        mT.initaliseMap TruthTable, outcome
        mT.getImplicants
        mT.filterAgents
        mT.implicantOutput TTSheet, (nCasesTable + 6), 1, qcanotation

        ' -- Testrouting: SO berechnen
        Dim mS As New Solution_Map
        Dim mi() As GBA_Implicant
        mi = mT.retrieveImplicants
        mS.initaliseMap mi, TruthTable, outcome
        Dim gc As Integer
        gc = TruthTable.getNGoodCases(outcome)
        mS.getSolutions gc
        Dim vN() As String
        vN = TruthTable.getVars
        mS.filterAgents
        mS.solutionOutput TTSheet, (nCasesTable + 8 + UBound(mi)), 1, vN, qcanotation, 0
    Else
        ' -- Testroutine: PI berechnen
        infoString = infoString + "NO"
        Dim mTx As New ExtQuine_Base
        mTx.initialiseBase TruthTable, outcome
        mTx.process TruthTable, TTSheet, qcanotation, (nCasesTable + 6), 0
    End If

   ' -- sch_n machen und anzeigen
    Dim reportWidth As Integer
    reportWidth = 7
    
    TTSheet.Range(TTSheet.cells(nCasesTable + 4, 1), TTSheet.cells(nCasesTable + 4, reportWidth)).MergeCells = True
    For i = 1 To reportWidth
        TTSheet.cells((nCasesTable + 4), i).Borders(xlEdgeBottom).Weight = xlMedium
    Next
    TTSheet.cells((nCasesTable + 4), 1).Value = infoString
    TTSheet.cells((nCasesTable + 4), 2).Value = infostring2
    TTSheet.Columns("A").EntireColumn.AutoFit
    TTSheet.Activate
    
End Sub

Private Sub UserForm_Initialize()

    'If dcheck.differentNames(TruthTable) = False Then
    '    MsgBox "Columns must have different name!"
    '    Exit Sub
    'End If
    'MsgBox "??: " + CStr(Modul1.hasValues)
    
        
    hasID = False
    hasOut = False
End Sub


Public Sub setWorkbook(ByRef book As Workbook)
    mBook = book
End Sub

Public Sub setRange(ByRef iRange As Range)
    Dim i As Integer
    Set mRange = iRange
    vNumber = mRange.Columns.Count
    ReDim vNames(vNumber)
    ReDim vUse(vNumber)
    For i = 1 To vNumber
        vUse(i) = 0
        vNames(i) = mRange.cells(1, i).Value
    Next
    If Modul1.hassamenames(vNames) = True Then
        For i = 1 To vNumber
            vUse(i) = Modul1.getLastValue(i)
        Next
        
        cIncludeLogicalRemainders.Value = Modul1.cLR
        cQCANotation.Value = Modul1.cUL
        OptionButton2.Value = Modul1.cOne
        
    End If
    updateWindow
End Sub

Public Sub setMode(ByRef ix As Integer)
    cmode = ix
    If ix = 0 Then
        bPrepare.Visible = False
        cIncludeLogicalRemainders.Value = True
        bMinfsQCA.Visible = False
        tThreshold.Visible = False
        Label5.Visible = False
    ElseIf ix = 1 Then
        cGO.Visible = False
        bMinfsQCA.Enabled = False
        tThreshold.Enabled = False
        Label5.Enabled = False
    End If
    
    
End Sub

Sub updateWindow()
    ListBox1.Clear
    ListBox2.Clear
    hasID = False
    hasOut = False
    tOut.Value = ""
    tID.Value = ""
    Dim i As Integer
    For i = 1 To vNumber
        If (vUse(i) = 0) Then
             ListBox1.AddItem vNames(i)
        ElseIf (vUse(i) = 1) Then
            tID.Value = vNames(i)
            hasID = True
        ElseIf (vUse(i) = 2) Then
            tOut.Value = vNames(i)
            hasOut = True
        ElseIf (vUse(i) = 3) Then
            ListBox2.AddItem vNames(i)
        End If
        
    Next
    
    If hasID Then
        bID.Caption = "<"
    Else
        bID.Caption = ">"
    End If
        
    If hasOut Then
        bOUT.Caption = "<"
    Else
        bOUT.Caption = ">"
    End If
   
End Sub


Sub changeMode(ByRef vName As String, ByRef newMode As Integer)
    Dim i As Integer
    For i = 1 To vNumber
        If (vNames(i) = vName) Then
            vUse(i) = newMode
            Exit Sub
        End If
            
    Next

End Sub
Attribute VB_Name = "Solution_Map"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim cells() As Solution_cell

Dim nCases As Integer
Dim cases() As InternalCase
Dim implicants() As GBA_Implicant
Dim nImplicants As Integer

Dim foundSolutions As Integer
Dim sizeSolutionArray As Integer
Dim solutions() As Solution_Solution

Dim outcome As Integer

Sub Class_Initialize()

End Sub

Sub initaliseMap(ByRef myImpl() As GBA_Implicant, ByRef TT As InternalTable, ByRef outC As Integer)
    Dim i As Integer
    
    outcome = outC
    
    cases = TT.getCases()
    nCases = UBound(cases)
    
    implicants = myImpl
    nImplicants = UBound(implicants)
        
    ReDim cells(nImplicants, 1)
    
    For i = 1 To nImplicants
        Set cells(i, 1) = New Solution_cell
        Dim mi As GBA_Implicant
        Set mi = New GBA_Implicant
        mi.setImplicantValues myImpl(i)
        cells(i, 1).init nCases, mi
        cells(i, 1).ParseCases cases, outcome
        
    Next
    foundSolutions = 0
    sizeSolutionArray = 100
    ReDim solutions(sizeSolutionArray)

End Sub

Sub getSolutions(ByRef ngoodcases As Integer)
    Dim rootSolutionAgent As New Solution_agent
    rootSolutionAgent.initasroot nImplicants, nCases
    traversemap rootSolutionAgent, 0, 0, ngoodcases

End Sub

Sub traversemap(ByRef agent As Solution_agent, ByRef sImp As Integer, ByRef sValue As Integer, ByRef ngoodcases As Integer)
    If sValue = 0 Then
        If sImp < nImplicants Then
            Dim nextAgent As New Solution_agent
            Set nextAgent = New Solution_agent
            nextAgent.doClone agent
            traversemap nextAgent, (sImp + 1), 1, ngoodcases
            Set nextAgent = New Solution_agent
            nextAgent.doClone agent
            traversemap nextAgent, (sImp + 1), 0, ngoodcases
        End If
     Else
        agent.proceed cells(sImp, sValue), sImp, sValue
        Dim stat As Integer
        stat = agent.getStatus(ngoodcases)
        If stat = 1 Then
           AddFoundSolution agent
        ElseIf stat = 0 Then
             If sImp < nImplicants Then
                Set nextAgent = New Solution_agent
                nextAgent.doClone agent
                traversemap nextAgent, (sImp + 1), 1, ngoodcases
                Set nextAgent = New Solution_agent
                nextAgent.doClone agent
                traversemap nextAgent, (sImp + 1), 0, ngoodcases
            End If
        End If
     End If
End Sub

Sub AddFoundSolution(ByRef fAgent As Solution_agent)
    If foundSolutions >= sizeSolutionArray Then
        sizeSolutionArray = sizeSolutionArray * 2
        ReDim Preserve solutions(sizeSolutionArray)
    End If
    foundSolutions = foundSolutions + 1
    Set solutions(foundSolutions) = New Solution_Solution
    solutions(foundSolutions).setValues fAgent
End Sub

Sub solutionOutput(ByRef ret As Worksheet, ByRef sx As Integer, ByRef sY As Integer, ByRef VarNames() As String, ByRef qcanotation As Boolean, ByRef cmode As Integer)
    Dim i As Integer
    Dim mRunner As Integer
    mRunner = 1
    
    For i = 1 To foundSolutions
        If solutions(i).show Then
            ret.cells(sx + mRunner, sY) = solutions(i).getText(implicants, VarNames, qcanotation)
            
            If (cmode > 0) Then
                ret.cells(sx + mRunner, sY + 1) = solutions(i).fConsistency
                ret.cells(sx + mRunner, sY + 2) = solutions(i).fCoverage
                ret.cells(sx + mRunner, sY).Font.Bold = True
                ret.cells(sx + mRunner, sY + 1).Font.Bold = True
                ret.cells(sx + mRunner, sY + 2).Font.Bold = True
                
                mRunner = mRunner + 1
                Dim j As Integer
                Dim sumCoverage As Single
                sumCoverage = solutions(i).getSingularCoverage(implicants)
                
                
                For j = 1 To nImplicants
                    Dim rx() As Variant
                    rx = solutions(i).getFuzzyImplicantValues(j, implicants, VarNames, qcanotation)
                    If rx(1) <> "xx" Then
                        ret.cells(sx + mRunner, sY) = rx(1)
                        ret.cells(sx + mRunner, sY).HorizontalAlignment = xlRight
                        ret.cells(sx + mRunner, sY + 1) = rx(2)
                        ret.cells(sx + mRunner, sY + 2) = rx(3)
                        If (solutions(i).implicantsUsed = 2) Then
                            ret.cells(sx + mRunner, sY + 3) = solutions(i).fCoverage - sumCoverage + rx(3)
                        Else
                            ret.cells(sx + mRunner, sY + 3) = "**"
                        End If
                        
                        mRunner = mRunner + 1
                    End If
                    
                Next
            End If
            mRunner = mRunner + 1
        End If
        
    Next
    ret.cells(sx, sY) = "'# Solutions: " + CStr(mRunner - 1)
    ret.cells(sx, sY).Font.Color = vbRed
    If (cmode > 0) Then
        ret.cells(sx, sY + 1) = "Consistency"
        ret.cells(sx, sY + 1).Font.Color = vbBlue
        ret.cells(sx, sY + 2) = "Coverage"
        ret.cells(sx, sY + 2).Font.Color = vbBlue
        ret.cells(sx, sY + 3) = "Unique Cov."
        ret.cells(sx, sY + 3).Font.Color = vbBlue
    End If
End Sub


' -- dummy function: # of implicants included (as in Ragin 1987)
Public Sub filterAgents()
    If foundSolutions > 1 Then
        Dim i As Integer
        Dim minLength As Integer
        minLength = solutions(1).implicantsUsed
    
        For i = 2 To foundSolutions
            Dim lI As Integer
            lI = solutions(i).implicantsUsed
            If (lI < minLength) Then
                minLength = lI
            End If
        Next
    
        For i = 1 To foundSolutions
            lI = solutions(i).implicantsUsed
            If (lI > minLength) Then
                solutions(i).filter
            End If
        Next
    End If
    
End Sub

Sub calculateCoverageConsistency(ByRef TT As InternalTable)
    Dim i As Integer
    Dim j As Integer
    For i = 1 To foundSolutions
        solutions(i).initFuzzy
        For j = 1 To TT.nOxCases
            solutions(i).parseFuzzySolution implicants, TT.getOxCases(j)
        Next
        solutions(i).finishFuzzy
    Next
End Sub
Attribute VB_Name = "Solution_Solution"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim goodCases() As Boolean
Dim nCases As Integer
Dim nImplicants As Integer
Dim implicants() As Boolean
Dim doShow As Boolean


Public fConsistency As Single
Dim fCalcNum As Single
Dim fCalcDenum As Single
Dim fCalcCovDenum As Single
Public fCoverage As Single


Sub Class_Initialize()
    doShow = True
End Sub

Sub setValues(ByRef agent As Solution_agent)
    nCases = agent.GetNCases
    goodCases = agent.getGoodCases
    nImplicants = agent.getNImplicants
    implicants = agent.getImplicantsUsed
End Sub

Public Function show() As Boolean
    show = doShow
End Function

Sub filter()
    doShow = False
End Sub

Function implicantsUsed() As Integer
    Dim ret As Integer
    ret = 0
    Dim i As Integer
    For i = 1 To nImplicants
        If implicants(i) = True Then
            ret = ret + 1
        End If
    Next
    implicantsUsed = ret
End Function

Public Function getSingularCoverage(ByRef impls() As GBA_Implicant) As Single
    getSingularCoverage = 0
    Dim i As Integer
    For i = 1 To nImplicants
        If implicants(i) = True Then
            getSingularCoverage = getSingularCoverage + impls(i).fCoverage
        End If
    Next

End Function

Public Function getFuzzyImplicantValues(ByRef i As Integer, ByRef impls() As GBA_Implicant, ByRef VarNames() As String, ByRef qcanotation As Boolean) As Variant()
    Dim ret() As Variant
    ReDim ret(4)
    ret(1) = "xx"
    If implicants(i) = True Then
        ret(1) = impls(i).getText(VarNames, qcanotation)
        ret(2) = impls(i).fConsistency
        ret(3) = impls(i).fCoverage
        ret(4) = "unique"
    End If
    getFuzzyImplicantValues = ret
End Function

Public Function getText(ByRef impls() As GBA_Implicant, ByRef VarNames() As String, ByRef qcanotation As Boolean) As String
    Dim r As String
    Dim i As Integer
    For i = 1 To nImplicants
        If (implicants(i) = True) Then
            r = r + impls(i).getText(VarNames, qcanotation) + " + "
        End If
        
    Next
    getText = Left(r, Len(r) - 2)
End Function

Sub initFuzzy()
    fCalcNum = 0
    fCalcDenum = 0
    fCalcCovDenum = 0

End Sub

Sub finishFuzzy()
    fConsistency = fCalcNum / fCalcDenum
    fCoverage = fCalcNum / fCalcCovDenum
End Sub

Sub parseFuzzySolution(ByRef impls() As GBA_Implicant, ByRef fCase As InternalCase)
    Dim cF As Single
    Dim i As Integer
    
    cF = 0
    
    For i = 1 To nImplicants
        If (implicants(i) = True) Then
            cF = getMax(cF, fCase.getFuzzyImplicantVectorValue(impls(i).getValues))
        End If
    Next
    
    If cF < fCase.fOutput Then
        fCalcNum = fCalcNum + cF
    Else
        fCalcNum = fCalcNum + fCase.fOutput
    End If
    fCalcDenum = fCalcDenum + cF
    fCalcCovDenum = fCalcCovDenum + fCase.fOutput
End Sub

Function getMin(ByRef vla As Single, ByRef vlb As Single) As Single
    getMin = vla
    If vlb < vla Then
        getMin = vlb
    End If
End Function

Function getMax(ByRef vla As Single, ByRef vlb As Single) As Single
    getMax = vla
    If vlb > vla Then
        getMax = vlb
    End If
End Function
Attribute VB_Name = "Solution_agent"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim implicantUsed() As Boolean
Dim nImplicants As Integer
Dim nCases As Integer
Dim goodCases() As Boolean


Sub Class_Initialize()
   
End Sub

Public Sub doClone(ByRef agent As Solution_agent)
    nImplicants = agent.getNImplicants
    ReDim implicantUsed(nImplicants)
    implicantUsed = agent.getImplicantsUsed
    nCases = agent.GetNCases
    ReDim goodCases(nCases)
    goodCases = agent.getGoodCases
End Sub

Public Sub initasroot(ByRef nimpl As Integer, ByRef nC As Integer)
    nImplicants = nimpl
    ReDim implicantUsed(nImplicants)
    Dim i As Integer
    For i = 1 To nImplicants
        implicantUsed(i) = False
    Next
    nCases = nC
    ReDim goodCases(nCases)
    For i = 1 To nCases
        goodCases(i) = False
    Next
End Sub

Public Function getNImplicants() As Integer
    getNImplicants = nImplicants
End Function

Public Function getImplicantsUsed() As Boolean()
    getImplicantsUsed = implicantUsed
End Function

' -- all cases explained returns 1, else 0
Public Function getStatus(ByRef toexplain As Integer) As Integer
    Dim i As Integer
    Dim cSum As Integer
    cSum = 0
   
    For i = 1 To nCases
        If goodCases(i) = True Then
            cSum = cSum + 1
        End If
    Next
         
    If toexplain > cSum Then
        getStatus = 0
    Else
        getStatus = 1
    End If
End Function

Public Function GetNCases() As Integer
    GetNCases = nCases
End Function

Public Function getGoodCases() As Boolean()
    getGoodCases = goodCases
End Function

Public Sub proceed(ByRef cell As Solution_cell, ByRef sImp As Integer, ByRef sValue As Integer)
    If sValue = 1 Then
        implicantUsed(sImp) = True
    Else
        implicantUsed(sImp) = False
    End If
    
    goodCases = cell.combineOrGood(goodCases)
    
End Sub
Attribute VB_Name = "Solution_cell"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim goodCases() As Boolean
Dim nCases As Integer
Dim implicant As GBA_Implicant


Sub Class_Initialize()

End Sub

Sub init(ByRef nCas As Integer, ByRef impl As GBA_Implicant)
    nCases = nCas
    ReDim goodCases(nCases) As Boolean
    Set implicant = New GBA_Implicant
    implicant.setImplicantValues impl
    
End Sub


Sub ParseCases(ByRef cases() As InternalCase, ByRef outcome As Integer)
    Dim i As Integer
    Dim tv() As Integer
    Dim outC As Integer
    
    For i = 1 To nCases
        outC = cases(i).GetOutcome
        tv = cases(i).getValues
        
        If outC = outcome Then
            Dim isP As Boolean
            isP = implicant.implies(tv, True)
            If isP = True Then
                goodCases(i) = True
            End If
        End If
    Next
End Sub

Public Function getNumberExplained() As Integer
    Dim q As Integer
    Dim i As Integer
    For i = 1 To nCases
        If (goodCases(i) = True) Then
            q = q + 1
        End If
    Next
    getNumberExplained = q
End Function

Public Function combineOrGood(ByRef agentValues() As Boolean) As Boolean()
    Dim ret() As Boolean
    ReDim ret(nCases)
    Dim i As Integer
    For i = 1 To nCases
        ret(i) = agentValues(i) Or goodCases(i)
    Next
    combineOrGood = ret
End Function

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "Tabelle4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit


' InQuest injected base64 decoded content
' x*/z
' +-zw
' x*/z
' +-zw2

INQUEST-PP=macro
