Attribute VB_Name = "Bubblediagram"
Attribute VB_Base = "0{6419D7ED-7FA7-40D1-AE63-8A4B9F3A5A83}{79E38363-20FE-459B-8E78-ADA2BC147191}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Dim moresizer As New CFormResizer











Private Sub AddFlow1_Click()
If AddFlow1.SelNodes.Count = 0 Then Exit Sub
If AddFlow1.SelNodes.Count > 1 Then Exit Sub
d = AddFlow1.SelectedNode.Tag
If d = "" Then Exit Sub
Call showformula(d)

End Sub


Sub showformula(d)
Dim results$(3, 300)

Call parser(Range(d), results$(), bits, True, False)
a$ = "": b$ = "": c$ = ""
For i = 1 To bits
    a$ = a$ + results(1, i)
    b$ = b$ + results(2, i)
    c$ = c$ + results(3, i)
Next i
'formulaframe.Caption = "Cell " & Range(d).Address(rowabsolute:=False, columnabsolute:=False)
formulatext = a$
Translationtext = getname(Range(d)) & b$
valuetext = getvalue(Range(d)) & c$

End Sub
Private Sub AddFlow1_DblClick()
'First check that there is a node to expand
If AddFlow1.SelNodes.Count = 0 Then
    MsgBox "Nothing is selected.  Please select a node."
    Exit Sub
End If

If AddFlow1.SelNodes.Count > 1 Then
    MsgBox "Can only expand one node at a time.  Please select a single node."
    Exit Sub
End If
Call expandnode(AddFlow1.SelectedNode.Tag, AddFlow1.SelectedNode)
TFlow1.Orientation = 3
TFlow1.Layout AddFlow1

End Sub
Sub expandnode(a, nde)
Dim results$(3, 300)

'*** Get the selected cell ***
Set t = Range(a)
Set g_selection = t
Set tsheet = t.Worksheet
t.Worksheet.Activate
lastleft = nde.Left
temptop = nde.Top + nde.Height * 2
'g_bubbledecimalplaces = bubbleoptions.bubbledecimalplaces.Value
frmstr$ = "0." & String$(g_bubbledecimalplaces, "0")

If t.Cells.Count = 1 Then
    'Expand normally
    'External references ?
    Call parser(t, results$(), bits, True, False)
    For i = 1 To bits
       p = Null
       On Error Resume Next
       Set p = Range(results$(1, i))
       On Error GoTo expandnode
       If IsObject(p) Then
            If Not (p.HasFormula) Then
                AddFlow1.ForeColor = RGB(255, 0, 0)
                AddFlow1.Shape = 2
            End If
        If p.Cells.Count > 1 Then AddFlow1.Shape = 1
        End If
       If IsObject(p) Or InStr(results$(1, i), "!") <> 0 Then
           If InStr(results$(1, i), "!") <> 0 Then AddFlow1.ForeColor = RGB(0, 0, 255)
           Set node1 = Bubblediagram.AddFlow1.Nodes.Add(200 + lastleft, temptop, 500, 500)
           node1.Tag = Range(results$(1, i)).Address(external:=True)
           node1.UserData = nde.UserData + 1
           '*** Prepare the text for the node
           node1.Text = " " & results$(1, i)
           
           If g_showbubblenames = True Then
                node1.Text = node1.Text & ": " & results(2, i) & " "
           End If
           If g_showbubblevalues = True Then
            ''*** This is wrong should pick up the format of the cells referenced not the output cell.
                'node1.Text = node1.Text & Chr$(13) & "  =" & results(3,i) 'Format$(results$(3, i), t.NumberFormat)
            node1.Text = node1.Text & Chr$(13) & " = " & results$(3, i)
           End If
           If g_showbubbleformulas = True And p.HasFormula = True And p.Cells.Count = 1 Then
                node1.Text = node1.Text & " " & Chr$(13) & "  " & p.Formula
            End If
         
           AddFlow1.ForeColor = RGB(0, 0, 0)
           AddFlow1.Shape = 1
           cellsfound = cellsfound + 1
           node1.inlinks.Add nde
           lastleft = node1.Left + node1.Width
      End If
   Next i
Else

   '*** Decide how to handle a range ***
   bubblerangeoptions.Listofcells.Clear
   For Each c In t.Cells
      bubblerangeoptions.Listofcells.AddItem (c.Address(rowabsolute:=False, columnabsolute:=False))
    Next
    bubblerangeoptions.Listofcells.Text = bubblerangeoptions.Listofcells.list(0)
    bubblerangeoptions.Caption = "Range: " & t.Address(rowabsolute:=False, columnabsolute:=False)
    bubblerangeoptions.Show
    If bubblerangeoptions.expandall.Value = False Then
        Set t = Range(bubblerangeoptions.Listofcells.Text)
    End If
    
    '*** Handle the range ***
    For Each c In t.Cells
      
        If Not (c.HasFormula) Then AddFlow1.ForeColor = RGB(255, 0, 0): AddFlow1.Shape = 1
        Set node1 = Bubblediagram.AddFlow1.Nodes.Add(200 + lastleft, temptop, 500, 500)
        node1.Tag = c.Address(external:=True)
        node1.UserData = nde.UserData + 1
        node1.Text = " " & c.Address(rowabsolute:=False, columnabsolute:=False)
      
        
        If g_showbubblenames = True Then
            node1.Text = node1.Text & ": " & getname(c) & " "
        End If
        If g_showbubblevalues = True Then
            node1.Text = node1.Text & Chr$(13) & "  = " & c.Text '& Format$(c.Value, c.NumberFormat)
        End If
        If g_showbubbleformulas = True And c.HasFormula = True And c.Cells.Count = 1 Then
            node1.Text = node1.Text & " " & Chr$(13) & "  " & c.Formula
        End If
        AddFlow1.ForeColor = RGB(0, 0, 0): AddFlow1.Shape = 1
        
        cellsfound = cellsfound + 1
        node1.inlinks.Add nde
        lastleft = node1.Left + node1.Width
  
    Next
End If
'*** Finally resort diagram so that it remains neatly arranged.
TFlow1.Orientation = 3
TFlow1.Layout AddFlow1
Exit Sub
expandnode:
MsgBox "Error occured"
End Sub



Private Sub AddFlow1_KeyDown(KeyCode As Integer, ByVal Shift As Integer)
Select Case KeyCode
Case 46, 110
    AddFlow1.DeleteSel
Case Else
End Select
TFlow1.Orientation = 3
TFlow1.Layout AddFlow1

End Sub

Private Sub CmdCancel_Click()
Bubblediagram.Hide
End Sub

Private Sub Cmdoptions_Click()
bubbleoptions.Mpoptions.Value = 3
bubbleoptions.Show
g_noredraw = True

'*** Now redraw diagram with new options
'Dim results$(3, 300)

For i = 1 To AddFlow1.Nodes.Count
    
    
    'Call parser(Range(AddFlow1.Nodes(i).Tag), results$(), bits, True, False)
    AddFlow1.Nodes(i).Text = " " & Range(AddFlow1.Nodes(i).Tag).Address(rowabsolute:=False, columnabsolute:=False)
    If g_showbubblenames = True Then
        AddFlow1.Nodes(i).Text = AddFlow1.Nodes(i).Text & ": " & getname(Range(AddFlow1.Nodes(i).Tag)) & " "
    End If
    If g_showbubblevalues = True Then
        ''*** This is wrong should pick up the format of the cells referenced not the output cell.
        'node1.Text = node1.Text & Chr$(13) & "  =" & results(3,i) 'Format$(results$(3, i), t.NumberFormat)
        AddFlow1.Nodes(i).Text = AddFlow1.Nodes(i).Text & Chr$(13) & " = " & getvalue(Range(AddFlow1.Nodes(i).Tag))
        
    End If
    If g_showbubbleformulas = True And Range(AddFlow1.Nodes(i).Tag).HasFormula = True And Range(AddFlow1.Nodes(i).Tag).Cells.Count = 1 Then
        AddFlow1.Nodes(i).Text = AddFlow1.Nodes(i).Text & " " & Chr$(13) & "  " & Range(AddFlow1.Nodes(i).Tag).Formula
    End If
Next i
TFlow1.Orientation = 3
TFlow1.Layout AddFlow1
End Sub

Private Sub cmdpastetoclipboard_Click()
Application.ScreenUpdating = False
workbookname = ActiveWorkbook.Name
Set oldworkbook = ActiveWorkbook

AddFlow1.SaveImage 1, 1, "C:\test"
Call setupworkbook("SP Formula Trace Diagrams")
Application.Workbooks("SP Formula Trace Diagrams.xls").Activate
ActiveWorkbook.Sheets.Add after:=ActiveWorkbook.ActiveSheet
ActiveSheet.Name = "Diagram " & Format(ActiveWorkbook.Sheets.Count - 1)

s = ActiveSheet.Name

ActiveWindow.DisplayGridlines = False
ActiveSheet.PageSetup.Orientation = xlLandscape
ActiveSheet.PageSetup.CenterHeader = "Calculation of " & g_nme
ActiveSheet.PageSetup.LeftFooter = "Produced using WWW.Spreadsheetinnovations.com"
ActiveSheet.PageSetup.RightFooter = "Filename = " & workbookname
ActiveSheet.PageSetup.FitToPagesWide = 1
ActiveSheet.PageSetup.FitToPagesTall = 1
ActiveSheet.PageSetup.PrintGridlines = False
ActiveSheet.PasteSpecial

oldworkbook.Activate
Application.ScreenUpdating = True
MsgBox "The diagram has been added to 'SP Formula Trace Diagrams.xls'. To view the diagram select 'SP Formula Trace Diagrams.xls' from the Window option of the main Excel menu.'", 64
End Sub

Private Sub Cmdprint_Click()

With bubbleprint.VSP
    .Preview = True
    .startdoc
    .rendercontrol = Bubblediagram.AddFlow1.hWnd
    .enddoc
End With
   
bubbleprint.Show
End Sub
Private Sub pastetoclipboard_Click()
AddFlow1.ExportPicture(0, False, False).PutInClipboard
End Sub

'Private Sub CommandButton1_Click()
'Static previoussize
'If Bubblediagram.Height = 472 Then
'    Bubblediagram.Height = previoussize
'Else
'    previoussize = Bubblediagram.Height
'    Bubblediagram.Height = 472
'End If
'End Sub

Private Sub CommandButton2_Click()
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=7

End Sub

Private Sub CommandButton3_Click()
'MsgBox "got here"
g_noredraw = False
Call showbubblediagram

End Sub

Private Sub CommandButton4_Click()
'*** Set up some arrays and a counter
Let initialnumber = AddFlow1.Nodes.Count
Let currentnumber = initialnumber
ReDim Labels$(8000)
For j = 1 To initialnumber
    Labels$(j) = AddFlow1.Nodes(j).Tag
Next j

'*** Main expansion loop ***
For i = 1 To initialnumber
    
    '*** First check that it is not already expanded or is an input cell.
    If AddFlow1.Nodes(i).OutLinks.Count < 1 Then
        '*** Check it has not been expanded elsewhere
     
        found = False
        For j = 1 To currentnumber
            If AddFlow1.Nodes(i).Tag = Labels$(j) Then
               If AddFlow1.Nodes(j).OutLinks.Count > 0 Then
                    found = True
                    Exit For
                End If
            End If
        Next j
        
        If found = False Then
            Call expandnode(AddFlow1.Nodes(i).Tag, AddFlow1.Nodes(i))
            '*** Don't count input cells or formulas that don't have any row references in them
            If AddFlow1.Nodes(i).OutLinks.Count > 0 Then currentnumber = currentnumber + 1
        Else
            
            '*** Put in a different shape
            AddFlow1.Nodes(i).DrawWidth = 1
            AddFlow1.Nodes(i).DrawStyle = 2
            
            'AddFlow1.Nodes(i).Shape = 53 'afTriangleRectangle
        End If
    End If
Next
TFlow1.Orientation = 3
TFlow1.Layout AddFlow1
If initialnumber = currentnumber Then
    MsgBox "Model fully expanded", 64
End If


End Sub



Private Sub CommandButton5_Click()
ReDim del(8000)
initialnumber = AddFlow1.Nodes.Count
'*** Main collapse loop ***
maxfound = -1
For i = 1 To initialnumber
    If AddFlow1.Nodes(i).UserData > maxfound Then
        maxfound = AddFlow1.Nodes(i).UserData
    End If
Next i
If maxfound = 0 Then
    MsgBox "Can't delete the last cell", 64
    Exit Sub
End If

For i = initialnumber To 1 Step -1
   If AddFlow1.Nodes(i).UserData = maxfound Then
        AddFlow1.Nodes(i).Selected = True
    End If
Next
AddFlow1.DeleteSel
TFlow1.Orientation = 3
TFlow1.Layout AddFlow1

End Sub

Private Sub Frame2_Click()

End Sub

Private Sub UserForm_Activate()
Set moresizer.Form = Me

Call showbubblediagram

Exit Sub
userformactivate:
End Sub

Public Sub showbubblediagram()


Dim t As Variant
Dim tsheet As Variant
Dim results$(3, 300)
Dim p As Variant
'ReDim ndes(100) As afNode


If g_noredraw = True Then
    g_noredraw = False
    Exit Sub
End If
'*** Get the selected cell ***
'Call readoptions
Bubblediagram.AddFlow1.Nodes.Clear
g_showbubblevalues = bubbleoptions.optshowvalues.Value
g_showbubblenames = bubbleoptions.optshownames.Value
g_showbubbleformulas = bubbleoptions.optshowformulas.Value
'g_bubbledecimalplaces = bubbleoptions.bubbledecimalplaces.Value
frmstr$ = "0." & String$(g_bubbledecimalplaces, "0")

Bubblediagram.Height = 300
Bubblediagram.Width = 600

Bubblediagram.AddFlow1.Shape = 1 'rectangle with bump
Bubblediagram.AddFlow1.LinkStyle = 1  'bezier curve
Bubblediagram.AddFlow1.arrowdst = 0  'none


Bubblediagram.AddFlow1.AutoSize = 3  'fit to text size
Bubblediagram.AddFlow1.MultiSel = True
Bubblediagram.AddFlow1.SelectMode = True
AddFlow1.ShowToolTip = True

Set t = Selection
Set node1 = Bubblediagram.AddFlow1.Nodes.Add(100, 100, 500, 500)
node1.Text = " " & t.Address(rowabsolute:=False, columnabsolute:=False)
nme = getname(t)
If g_showbubblenames = True Then
    node1.Text = node1.Text & ": " & nme & " "
End If
g_nme = nme & "  (" & t.Address(rowabsolute:=False, columnabsolute:=False) & ")"
If g_showbubblevalues = True Then
    If IsNumeric(t.Value) = True Then
        node1.Text = node1.Text & Chr$(13) & "  =" & t.Text '& Format$(t.Value, t.NumberFormat)
    End If
End If

If g_showbubbleformulas = True And t.HasFormula = True And t.Cells.Count = 1 Then
    node1.Text = node1.Text & " " & Chr$(13) & "  " & t.Formula
End If
node1.Tag = t.Address(rowabsolute:=False, columnabsolute:=False, external:=True)
temptop = node1.Top + node1.Height * 2

Call expandnode(t.Address, node1)
'Call showformula(t.Address)
TFlow1.Orientation = 3
TFlow1.Layout AddFlow1

Exit Sub
End Sub






Private Sub UserForm_Deactivate()
g_noredraw = True
End Sub



Private Sub userform_queryclose(Cancel As Integer, closemode As Integer)
If closemode = vbFormControlMenu Then
    Bubblediagram.Hide
    Cancel = True
End If
g_noredraw = True
End Sub

Private Sub UserForm_Resize()

moresizer.FormResize
End Sub



Private Sub Zoomin_Click()
AddFlow1.xZoom = AddFlow1.xZoom * 1.2
AddFlow1.yZoom = AddFlow1.yZoom * 1.2

End Sub

Private Sub zoomout_Click()
AddFlow1.xZoom = AddFlow1.xZoom / 1.2
AddFlow1.yZoom = AddFlow1.yZoom / 1.2

End Sub
Attribute VB_Name = "CFormResizer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

'***************************************************************************
'*
'* MODULE NAME:     USERFORM RESIZER CLASS
'* AUTHOR & DATE:   STEPHEN BULLEN, Business Modelling Solutions Ltd.
'*
'* CONTACT:         Stephen@BMSLtd.co.uk
'* WEB SITE:        http://www.BMSLtd.co.uk
'*
'* DESCRIPTION:     Handles the resizing and repositioning of controls on a userform
'*
'***************************************************************************

'This class makes a userform resizable and handles the resizing of all the controls on the userform,
'such that their physical dimensions (e.g. size and position) change as the form is resized.
'Note that this is not a form 'magnifier', in that it does not alter font sizes.

'To specify which control(s) to resize (and how), you set the control's .Tag property at design time to
'indicate that the control's top, left, width and height should be adjusted as the form's size changes.
'
'Use the letters t, l, w and h in any order (or not at all) to state that the property should change as the form
'is resized.  Follow the property by a decimal to indicate that the control should change by a percentage of the
'form's change.
'
'For example:
'  hw           Sets the control's height and width to change with the form (e.g. if there's a single list box on the form)
'  tl           Sets the contol's top and left to change in line with the form (e.g. to keep it in the bottom-right corner)
'  w0.5         Sets the control's width to change by 0.5 that of the form's width change
'  w0.5l0.5     Sets the control's width and position to change by 0.5 that of the form's width change

Option Explicit

'Windows API calls to do all the dirty work!
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
Private Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function SetFocus Lib "user32" (ByVal hWnd As Long) As Long

Private Const GWL_STYLE As Long = (-16)           'The offset of a window's style
Private Const WS_THICKFRAME As Long = &H40000     'Style to add a sizable frame
Private Const SW_SHOW As Long = 5

Dim moForm As Object

Dim mdWidth As Double
Dim mdHeight As Double

'Property to set the userform to be resizable
Public Property Set Form(oNew As Object)

    Dim hWndForm As Long, iStyle As Long
    
    'Remember the form for later
    Set moForm = oNew

    'Get the userform's window handle
    If Val(Application.Version) < 9 Then
        hWndForm = FindWindow("ThunderXFrame", moForm.Caption)  'XL97
    Else
        hWndForm = FindWindow("ThunderDFrame", moForm.Caption)  'XL2000
    End If

    'Make the form resizable
    iStyle = GetWindowLong(hWndForm, GWL_STYLE)
    iStyle = iStyle Or WS_THICKFRAME
    SetWindowLong hWndForm, GWL_STYLE, iStyle

    'Show the window with the changes
    ShowWindow hWndForm, SW_SHOW
    DrawMenuBar hWndForm
    SetFocus hWndForm

    'Remember the current size for later
    mdWidth = moForm.Width
    mdHeight = moForm.Height

End Property

'Handle the form's resize event, by resizing and repositioning controls
Public Sub FormResize()

    Dim dWidthAdj As Double, dHeightAdj As Double, sTag As String
    Dim oCtl As MSForms.Control
    
    'If not set before, remember the old width and height
    If mdWidth = 0 Then mdWidth = moForm.Width
    If mdHeight = 0 Then mdHeight = moForm.Height
    
    'How much are we changing by?
    dWidthAdj = moForm.Width - mdWidth
    dHeightAdj = moForm.Height - mdHeight
    
    'Check if we can perform the adjustment (i.e. widths and heights can't be -ve)
    For Each oCtl In moForm.Controls
        With oCtl
            sTag = UCase(.Tag)
            
            'Check if the left would become -ve
            If InStr(1, sTag, "L", vbBinaryCompare) Then
                If .Left + dWidthAdj <= 0 Then moForm.Width = mdWidth
            End If
            
            'Check if the width would become -ve
            If InStr(1, sTag, "W", vbBinaryCompare) Then
                If .Width + dWidthAdj <= 0 Then moForm.Width = mdWidth
            End If

            'Check if the top would become -ve
            If InStr(1, sTag, "T", vbBinaryCompare) Then
                If .Top + dHeightAdj <= 0 Then moForm.Height = mdHeight
            End If
            
            'Check if the height would become -ve
            If InStr(1, sTag, "H", vbBinaryCompare) Then
                If .Height + dHeightAdj <= 0 Then moForm.Height = mdHeight
            End If
        End With
    Next

    'OK to do it, so perform the resize
    dWidthAdj = moForm.Width - mdWidth
    dHeightAdj = moForm.Height - mdHeight
    
    'Loop through the controls on the form, changing their size and/or position
    For Each oCtl In moForm.Controls
        With oCtl
            sTag = UCase(.Tag)
            If InStr(1, sTag, "L", vbBinaryCompare) Then .Left = .Left + dWidthAdj * ResizeFactor(sTag, "L")
            If InStr(1, sTag, "T", vbBinaryCompare) Then .Top = .Top + dHeightAdj * ResizeFactor(sTag, "T")
            If InStr(1, sTag, "W", vbBinaryCompare) Then .Width = .Width + dWidthAdj * ResizeFactor(sTag, "W")
            If InStr(1, sTag, "H", vbBinaryCompare) Then .Height = .Height + dHeightAdj * ResizeFactor(sTag, "H")
        End With
    Next

    'Remember the new dimensions for next time
    mdWidth = moForm.Width
    mdHeight = moForm.Height

End Sub

'Get the resize factor from the control's Tag property
Private Function ResizeFactor(sTag As String, sChange As String)

    Dim i As Integer, d As Double

    'Find the position of the required change designator (L, T, W or H)
    i = InStr(1, sTag, sChange, vbBinaryCompare)
    If i > 0 Then
    
        'Get the value of any numbers following the designator
        d = Val(Mid$(sTag, i + 1))
        
        'If none there, change by 100%
        If d = 0 Then d = 1
    End If

    ResizeFactor = d

End Function
Attribute VB_Name = "ColorButtonClass"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False








'To do
'Application        Issue                           Resolved
'Builder            Tab order

Public WithEvents ColorButton As MSForms.CommandButton
Attribute ColorButton.VB_VarHelpID = -1











Private Sub ColorButton_MouseDown(ByVal Button As Integer, _
    ByVal Shift As Integer, ByVal X As Single, ByVal y As Single)
'   Assign the value and close the dialog
    ColorValue = ColorButton.BackColor
   ' Unload UserForm1
End Sub

Private Sub ColorButton_MouseMove _
    (ByVal Button As Integer, ByVal Shift As Integer, _
     ByVal X As Single, ByVal y As Single)

If bubbleoptions.Optinputs.Value = True Then
    bubbleoptions.Optinputs.BackColor = ColorButton.BackColor
End If

If bubbleoptions.Optcalculations.Value = True Then
    bubbleoptions.Optcalculations.BackColor = ColorButton.BackColor
End If

If bubbleoptions.Optheadings.Value = True Then
    bubbleoptions.Optheadings.BackColor = ColorButton.BackColor
End If

If bubbleoptions.Optoutputs.Value = True Then
    bubbleoptions.Optoutputs.BackColor = ColorButton.BackColor
End If

If bubbleoptions.Optothers.Value = True Then
    bubbleoptions.Optothers.BackColor = ColorButton.BackColor
End If

Exit Sub
'   Update the sample in the dialog
    Dim HexDigits As String
    Dim BluePart As Integer, GreenPart As Integer, RedPart As Integer
'    UserForm1.SampleLabel.BackColor = ColorButton.BackColor
    HexDigits = Hex(ColorButton.BackColor)
    Do Until Len(HexDigits) = 6
        HexDigits = "0" & HexDigits 'pad with zeros
    Loop
    BluePart = Val("&h" & Left(HexDigits, 2))
    GreenPart = Val("&h" & Mid(HexDigits, 3, 2))
    RedPart = Val("&h" & Right(HexDigits, 2))
  '  UserForm1.RGBLabel.Caption = RedPart & " " & GreenPart & " " & BluePart
End Sub

Private Sub ColorButton_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal y As Single)
bubbleoptions.Optinputs.Value = False
bubbleoptions.Optheadings.Value = False
bubbleoptions.Optcalculations.Value = False
bubbleoptions.Optothers.Value = False
bubbleoptions.Optoutputs.Value = False


End Sub
Attribute VB_Name = "Eventclassmodule"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public WithEvents App As Application
Attribute App.VB_VarHelpID = -1





Private Sub App_SheetChange(ByVal Sh As Object, ByVal Target As Range)
'*** Is this an old version which is no longer used?
'If CommandBars("frmbar").Controls(3).Text = "0" Then
'Else
' firstcol = Target.Column
' lastcol = Target.Column + CommandBars("frmbar").Controls(3).Text
' Application.EnableEvents = False
' Range(Cells(Target.Row, firstcol), Cells(Target.Row, lastcol)).Formula = Target.Formula
' Application.EnableEvents = True
'End If
End Sub

Private Sub App_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)

'*** Check to see whether to do this or not. 11/7/03.
On Error GoTo endroutine:
If CommandBars("translationbar").Visible = False Then GoTo endroutine:

'*** Close off events ***
Application.EnableEvents = False
Dim c As Variant
Dim results$(3, 300)

'*** Note: Change introduced 25/3/03 in order to prevent error when whole sheet selected.
Set c = Target.Cells(1, 1)
Call parser(c, results$(), bits, True, False)
b$ = ""
For i = 1 To bits
    b$ = b$ + results(2, i)
Next i

'*** Note: Added to put cell reference at the bottom as well as the translation 25/3/03 - added name as well May 3rd 2003
b$ = c.Address(rowabsolute:=False, columnabsolute:=False) + ": " & getname$(c) + " " + b$
'*** As we know that translationbar exists and is visible we don't have to search through them to get to it. 11/7/03
'For Each cmdbar In CommandBars
   ' If cmdbar.Name = "translationbar" Then
        CommandBars("translationbar").Controls(2).Text = b$
     '   Exit For
    'End If
'Next

'*** Set application bars back
Application.EnableEvents = True

endroutine:
End Sub

Private Sub App_WorkbookAddinUninstall(ByVal Wb As Workbook)

If Wb.Name = "sprdprof.xla" Then
    
    On Error Resume Next
    CommandBars("Spreadsheet Professional V4").Delete
    On Error GoTo unloadexit
    
    On Error Resume Next
    CommandBars("translationbar").Delete
    On Error GoTo unloadexit
    
    On Error Resume Next
    CommandBars("sensitivitybar").Delete
    On Error GoTo unloadexit
    
    On Error Resume Next
    CommandBars("frmbar").Delete
    On Error GoTo unloadexit

    On Error Resume Next
    CommandBars("Spreadsheet Professional").Delete
    On Error GoTo unloadexit


End If
unloadexit:
End Sub


Private Sub App_WorkbookBeforeClose(ByVal Wb As Workbook, Cancel As Boolean)

If Application.Workbooks.Count < 2 Then

    On Error Resume Next
    CommandBars("Spreadsheet Professional V4").Delete
    On Error GoTo unloadexit1
    
    On Error Resume Next
    CommandBars("translationbar").Delete
    On Error GoTo unloadexit1
    
    On Error Resume Next
    CommandBars("sensitivitybar").Delete
    On Error GoTo unloadexit1
    
    On Error Resume Next
    CommandBars("frmbar").Delete
    On Error GoTo unloadexit1

    On Error Resume Next
    CommandBars("Spreadsheet Professional").Delete
    On Error GoTo unloadexit1

End If

unloadexit1:
End Sub
Attribute VB_Name = "Formulabarmod"
Sub setupnewformulabar()
Dim tbar As CommandBar
Dim bfound As Boolean
Dim ctl As CommandBarButton
Dim tctrl As Variant

'*** Find out if it already exists.
bfound = False
For Each tbar In Application.CommandBars
    If LCase$(tbar.Name) = "frmbar" Then
        bfound = True
        Exit For
    End If
Next tbar

If bfound = True Then
    '*** If it exists then delete it.
    On Error Resume Next
    CommandBars("frmbar").Delete
    On Error GoTo 0
    For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Hide Build Bar" Then
                    ctl.Caption = "Show Build Bar"
                End If
            Next ctl
        End If
    Next tctrl

Else
    '*** If it doesn't exist then create it
     For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Show Build Bar" Then
                   ctl.Caption = "Hide Build Bar"
                End If
            Next ctl
        End If
    Next tctrl
    
    'Create a new input bar
    Set tbar = CommandBars.Add
    With tbar
        .Width = CommandBars(1).Width
        .Name = "frmbar"
        .Position = msoBarTop
        .Left = 0
        .Visible = True
    End With
    
    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Build bar"
        .TooltipText = "Enables you to copy and format at the same time."
        .Width = 130
        .Visible = True
        .Style = msoButtonCaption
       
    End With
    
    'Set up a label
    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = " Apply "
        .TooltipText = "Applies the settings on the toolbar to the current cell and copies the number of times indicated."
        .Width = 60
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = "apply"
        .BeginGroup = True
    End With
    
    
    'Set up the number of copies
    For Each l In CommandBars("Spreadsheet Professional V4").Controls
        i = i + 1
        If i > 0 And i < 6 Then
            totalwidth = totalwidth + l.Width
        End If
    Next l

    
    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Number of copies:"
        .TooltipText = "Number of times you want the cell copied. Note:If you do not want to copy cell enter zero."
        .Visible = True
        .Style = msoButtonCaption
        .BeginGroup = True
       ' .Width = totalwidth - 96
       ' .OnAction = "apply"
    End With
    

    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlEdit)
    With newbtn
        .Caption = "Number of copies"
        .TooltipText = "Number of times you want the cell copied. Note:If you do not want to copy cell enter zero."
        .Text = "0"
        .Visible = True
        .Width = 30
    End With
    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Number format: " + "General"
        .TooltipText = "Selects the number format."
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = "changenumformat"
        .BeginGroup = True
    End With
    
    
    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Colour:"
        .TooltipText = "Select the colours you require from the drop down list to hte right. Note: Colours for each type of cell can be changed by using the Option menu."
        .Visible = True
        .Style = msoButtonCaption
        .BeginGroup = True
    End With

    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlDropdown)
    With newbtn
        .Caption = "Colour:"
        .TooltipText = "Sets the colours for the cells. Note: Colours for each type of cell can be changed by using the Option menu."
        .Visible = True
        .Style = msoButtonAutomatic
        .AddItem "None"
        .AddItem "Automatic"
        .AddItem "Input"
        .AddItem "Formula"
        .AddItem "Output"
        .AddItem "Heading"
        .AddItem "Other"
        .ListIndex = 1
    End With

   
    Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Borders: "
        .TooltipText = "Select the borders you require from the dropdown list to the right."
        .Visible = True
        .Style = msoButtonCaption
        .BeginGroup = True
    End With

 
Set newbtn = CommandBars("frmbar").Controls.Add(Type:=msoControlDropdown)
    With newbtn
        .Caption = "Borders:"
        .TooltipText = "Sets the borders for the cells."
        .Visible = True
        .Style = msoButtonAutomatic
        .AddItem "None"
        .AddItem "Top only"
        .AddItem "Bottom only"
        .AddItem "Top and bottom"
        .ListIndex = 1
    End With

End If





End Sub


Sub apply()

If CommandBars("frmbar").Controls(4).Text = "0" Then
    ActiveCell.Select
Else
 firstcol = ActiveCell.Column
 lastcol = ActiveCell.Column + CommandBars("frmbar").Controls(4).Text
 Range(Cells(ActiveCell.Row, firstcol), Cells(ActiveCell.Row, lastcol)).Select
End If


'*** Now lets do what is necessary to the selection.
With Selection
    '*** First put the formula in
    .Formula = ActiveCell.Formula
    
    '*** Now the formatting
     s = CommandBars("frmbar").Controls(5).Caption
    .numberformat = Mid$(s, InStr(s, ":") + 2)
    
    '*** Now the colour
    Select Case CommandBars("frmbar").Controls(7).ListIndex
    
    Case 1 '*** None
    .Interior.ColorIndex = xlColornone
    
    Case 2 '*** Automatic
    If ActiveCell.HasFormula = True Then
 
        clr = bubbleoptions.Optcalculations.BackColor
    Else
        clr = bubbleoptions.Optinputs.BackColor
    End If
    
    Case 3 '*** Input
    clr = bubbleoptions.Optinputs.BackColor
    
    Case 4 '*** Formula
    clr = bubbleoptions.Optcalculations.BackColor
    
    Case 5 '*** Output
    clr = bubbleoptions.Optoutputs.BackColor
    
    Case 6 '*** Heading
    clr = bubbleoptions.Optheadings.BackColor
    
    Case 7 '*** Other
    clr = bubbleoptions.Optothers.BackColor
    
    
    End Select
    
    If CommandBars("frmbar").Controls(7).ListIndex <> 1 Then
       .Interior.Pattern = xlSolid
       .Interior.Color = clr
    End If

    '*** Now the underlining ***
    Select Case CommandBars("frmbar").Controls(9).ListIndex
    
    Case 1 '*** Neither top nor bottom ***
     Selection.Borders(xlEdgeTop).LineStyle = xlNone
     Selection.Borders(xlEdgeBottom).LineStyle = xlNone
    
    Case 2 '*** Top only ***
        .Borders(xlEdgeBottom).LineStyle = xlNone
        With Selection.Borders(xlEdgeTop)
            .LineStyle = xlContinuous
            .Weight = xlMedium
            .ColorIndex = xlAutomatic
        End With
    
    Case 3 '*** Bottom only ***
        Selection.Borders(xlEdgeTop).LineStyle = xlNone
        With Selection.Borders(xlEdgeBottom)
            .LineStyle = xlContinuous
            .Weight = xlMedium
            .ColorIndex = xlAutomatic
        End With
    
    Case 4 '*** Top and bottom ***
        With Selection.Borders(xlEdgeBottom)
            .LineStyle = xlContinuous
            .Weight = xlMedium
            .ColorIndex = xlAutomatic
        End With
        
        With Selection.Borders(xlEdgeTop)
            .LineStyle = xlContinuous
            .Weight = xlMedium
            .ColorIndex = xlAutomatic
        End With
        
    End Select
End With
'
' s = CommandBars("frmbar").Controls(8).Caption
'If fmtheading = True Then
'    With Selection.Interior
'        .Pattern = xlSolid
'        .Color = fmtheading.BackColor
'    End With
'End If


ActiveCell.Select
End Sub

Sub changenumformat()
s = Application.ScreenUpdating
Application.ScreenUpdating = False
Set d = ActiveSheet
ThisWorkbook.Worksheets("sheet2").Activate
Application.Dialogs(xlDialogFormatNumber).Show
CommandBars("frmbar").Controls(5).Caption = "Number format: " + ActiveCell.numberformat
d.Activate
Application.ScreenUpdating = s
End Sub
Attribute VB_Name = "Menumodule"
'*** This module is designed purely to pick up the menu items and direct them to the
'*** right places.
'API function to enable/disable the Excel Window
Sub menu0()
Call readoptions
s = MsgBox("Are you sure you want to set this sheet up in standard format?. All content on sheet will be lost.", 16420, "Setup Standard format sheet", ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", 3)
If s = 6 Then
  
    Range("a1", ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell)).Clear
    Call setupstandardformat
End If


End Sub

Sub menu1()
Attribute menu1.VB_ProcData.VB_Invoke_Func = " \n14"
Call setupnewformulabar
End Sub
Sub menu1excel2000()
createspreadsheet.Show (modal)
Application.OnDoubleClick = "createformula"
End Sub
Sub menu2()
Attribute menu2.VB_ProcData.VB_Invoke_Func = " \n14"
Call readoptions
SPpainter.Show
End Sub
Sub menu3()
Attribute menu3.VB_ProcData.VB_Invoke_Func = " \n14"
Call tracer

End Sub
Sub menu4()
Attribute menu4.VB_ProcData.VB_Invoke_Func = " \n14"
Call calcchecker
End Sub
Sub menu5()
Attribute menu5.VB_ProcData.VB_Invoke_Func = " \n14"
Set g_dialogsht = ThisWorkbook.DialogSheets("reports dialog")
g_dialogsht.CheckBoxes("summry").Value = xlOff
g_dialogsht.CheckBoxes("rangenames").Value = xlOff
g_dialogsht.CheckBoxes("Maps").Value = xlOff
g_dialogsht.CheckBoxes("Listings").Value = xlOff
g_dialogsht.CheckBoxes("blankinput").Value = xlOff
g_dialogsht.CheckBoxes("inputvalues").Value = xlOff
g_dialogsht.CheckBoxes("generaltests").Value = xlOn
g_dialogsht.CheckBoxes("tests").Value = xlOn

Call startdocumentation
End Sub
Sub menu6()
Attribute menu6.VB_ProcData.VB_Invoke_Func = " \n14"
Set g_dialogsht = ThisWorkbook.DialogSheets("reports dialog")
g_dialogsht.CheckBoxes("summry").Value = xlOn
g_dialogsht.CheckBoxes("rangenames").Value = xlOn
g_dialogsht.CheckBoxes("Maps").Value = xlOn
g_dialogsht.CheckBoxes("Listings").Value = xlOn
g_dialogsht.CheckBoxes("blankinput").Value = xlOn
g_dialogsht.CheckBoxes("inputvalues").Value = xlOn
g_dialogsht.CheckBoxes("generaltests").Value = xlOn
g_dialogsht.CheckBoxes("tests").Value = xlOn

Call startdocumentation
End Sub
Sub menu7()
Attribute menu7.VB_ProcData.VB_Invoke_Func = " \n14"
Call tracer
End Sub
Sub menu8()
Attribute menu8.VB_ProcData.VB_Invoke_Func = " \n14"
'MsgBox "This tool is currently undergoing further development to make it more effective. It will be released at a later date.  You will be entitled to a free update when the tool is released."
'Exit Sub
standardreports.Show
Exit Sub
Set g_dialogsht = ThisWorkbook.DialogSheets("reports dialog")
g_dialogsht.CheckBoxes("summry").Value = xlOn
g_dialogsht.CheckBoxes("rangenames").Value = xlOn
g_dialogsht.CheckBoxes("Maps").Value = xlOn
g_dialogsht.CheckBoxes("Listings").Value = xlOn
g_dialogsht.CheckBoxes("blankinput").Value = xlOn
g_dialogsht.CheckBoxes("inputvalues").Value = xlOn
g_dialogsht.CheckBoxes("generaltests").Value = xlOn
g_dialogsht.CheckBoxes("tests").Value = xlOn

Call startdocumentation
End Sub
Sub menu9()
Attribute menu9.VB_ProcData.VB_Invoke_Func = " \n14"

Call setupsensitivitybar
'sensitivitytool.Show
End Sub
Sub menu10()
Attribute menu10.VB_ProcData.VB_Invoke_Func = " \n14"
Call startcompare
End Sub
Sub menu11()
Attribute menu11.VB_ProcData.VB_Invoke_Func = " \n14"
bubbleoptions.Mpoptions.Value = 0
bubbleoptions.Show
End Sub
Sub menu12()
Attribute menu12.VB_ProcData.VB_Invoke_Func = " \n14"
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=0
End Sub
Sub menu13()
Attribute menu13.VB_ProcData.VB_Invoke_Func = " \n14"
Call aboutdialog
End Sub
Sub menu14()
Attribute menu14.VB_ProcData.VB_Invoke_Func = " \n14"
MsgBox "14"
End Sub
Sub menu15()
Attribute menu15.VB_ProcData.VB_Invoke_Func = " \n14"
MsgBox "15"
End Sub


Attribute VB_Name = "SPpainter"
Attribute VB_Base = "0{81B50C1B-4A41-48A6-B662-4B1A88291528}{24C06C54-338F-4AA2-9AC6-121CF9F94293}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False











Private Sub CmdCancel_Click()
SPpainter.Hide
End Sub

Private Sub CmdHelp_Click()
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=8

End Sub

Private Sub Cmdoptions_Click()
bubbleoptions.Mpoptions.Value = 1
bubbleoptions.Show
End Sub

Private Sub Cmdpaint_Click()
Dim ur As Variant

'*** Need to check on which sheets.

'*** Lets get the cells to analyse.
Set actsheet = ActiveSheet
Set actworkbook = ActiveWorkbook
If Optselectedarea = True Then Set actarea = Selection

For Each ur In actworkbook.Worksheets
    If Optallsheets = True Then

    Else
        If ur.Name <> actsheet.Name Then
            GoTo endcmdpaintloop
        End If
    End If


If Optselectedarea = True Then
    Set ur = actarea
Else
    Set ur = ur.UsedRange
End If

'*** Now lets see if unique cells only ***
If SPpainter.optuniqueformulae = True Then
    '*** change 11/7/03
    If Left$(Application.Version, 1) >= "8" Or Left$(Application.Version, 1) = "1" Then
        If ur.Worksheet.UsedRange.MergeCells Or IsNull(ur.Worksheet.UsedRange.MergeCells) Then
            response = MsgBox("There is a feature of Excel 97 and greater that causes Spreadsheet Professional to produce unreliable results when merged cells are contained within the spreadsheet.  Spreadsheet Professional will automatically unmerge the cells if you answer yes. (This question will be asked for each sheet that contains merged cells). Do you want to continue?", vbYesNo)
                If response = 6 Then
                    ur.Worksheet.UsedRange.UnMerge
                Else
                    Exit Sub
                End If
        End If
    End If
   
    ur.Interior.ColorIndex = xlNone
   
    p = Null
    Select Case g_uniqueoption
         
         Case c_horizontal
            Call uniqueformulas(c_horizontal, ur, p)
            
         Case c_vertical
            Call uniqueformulas(c_vertical, ur, p)
         
         Case c_both
            p = Null
            p1 = Null
            p2 = Null
            Call uniqueformulas(c_horizontal, ur, p1)
            If IsObject(p1) Then
                For Each p2 In p1.Areas
                    p3 = Null
                    Call uniqueformulas(c_vertical, p2, p3)
                   
                    If IsObject(p3) Then
                        'Application.StatusBar = "Analysing cells at " & p2.Address(rowabsolute:=False, columnabsolute:=False)
                        If IsObject(p) Then
                            Set p = Union(p, p3)
                        Else
                            Set p = p3
                        End If
                    End If
                Next
            End If
           
    End Select
        
    If IsObject(p) Then
        For Each c In p
           c.Interior.Color = g_calcscolour
           c.Interior.Pattern = xlSolid
        Next
    End If
    GoTo endcmdpaintloop
End If

'*** Color all inputs ***
m = Null
Call getcells(ur, xlConstants, xlNumbers, m)
If IsObject(m) Then
    If SPpainter.optclearformats = False And SPpainter.optuniqueformulae = False Then
        m.Interior.Color = g_inputscolour
        m.Interior.Pattern = xlSolid
    Else
        m.Interior.ColorIndex = xlNone
    End If
End If

'*** Color all labels ***
m = Null
Call getcells(ur, xlConstants, xlTextValues, m)
If IsObject(m) Then
    If SPpainter.optclearformats = False And SPpainter.optuniqueformulae = False Then
        m.Interior.Color = g_headingscolour
        m.Interior.Pattern = xlSolid
    Else
        m.Interior.ColorIndex = xlNone
    End If
End If


'*** Color all formulas ***
m = Null
Call getcells(ur, xlFormulas, 0, m)
If IsObject(m) Then
    If SPpainter.optclearformats = False And SPpainter.optuniqueformulae = False Then
        m.Interior.Color = g_calcscolour
        m.Interior.Pattern = xlSolid
    Else
        m.Interior.ColorIndex = xlNone
    End If
End If

endcmdpaintloop:
Next
End Sub


Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True









Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Workbook_BeforeClose(Cancel As Boolean)

End Sub


Attribute VB_Name = "Tracermod"


'*** This module manages the Tracer option
'Option Explicit



Sub tracer()
Attribute tracer.VB_ProcData.VB_Invoke_Func = " \n14"
Dim t As Variant
Dim tsheet As Variant
Dim results$(3, 300)
Dim p As Variant
'ReDim ndes(100) As afNode

'*** Get the selected cell ***
Call readoptions
Set t = Selection
Set g_selection = t
Set tsheet = t.Worksheet
t.Worksheet.Activate
Call parser(t, results$(), bits, True, False)
Bubblediagram.Show

Exit Sub
tracer1:
MsgBox "error"
End Sub


Sub tracerold()
Attribute tracerold.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo tracer
Dim shts As Variant
Dim reportsheet As Worksheet
Dim r As Variant
Dim s As Variant
Dim i As Integer, j As Integer, k As Integer
Dim results$(3, 300)
Dim temp As String
Dim cellref
Dim t As Variant
Dim bits As Integer
Dim p As Variant
Dim tsheet As Variant
'*** This routine prints out the front summary sheet
If g_abort Then Exit Sub
Application.StatusBar = "Producing Special Report. (Press Esc to cancel)"
'Application.OnDoubleClick = "tracer_dblclick"
'*** Get the selected cell ***
'Call getoptions
Set t = Selection
Set g_selection = t
Set tsheet = t.Worksheet
t.Worksheet.Activate
Call parser(t, results$(), bits, True, False)

ThisWorkbook.Worksheets("tracer").Activate
ThisWorkbook.Worksheets("tracer").Range("a1:iv8191").Clear
ThisWorkbook.Worksheets("tracer").Cells(1, 1).Value = "'" & t.Worksheet.Name & "!" & t.Address(rowabsolute:=False, columnabsolute:=False) & " (" & getname$(t) & ")"

Cells(1, 1).Font.Color = RGB(0, 0, 255)

cellref = 2
temp = "'"
For i = 1 To bits
    p = Null
  
    On Error Resume Next
    Set p = t.Range(results$(1, i))
    On Error GoTo tracer
    If IsObject(p) Or InStr(results$(1, i), "!") <> 0 Then
       '*** Print out the bit of formula beforehand ***
        Cells(cellref, 2) = temp
        'Cells(cellref, 2).Font.Bold = True
        temp = "'"
        cellref = cellref + 1
        
        '*** Print out each cell in the range
        If InStr(results$(1, i), "!") = 0 Then
            For Each r In Range(results$(1, i))
                Set r = tsheet.Range(r.Address)
                Cells(cellref, 2) = "'     " & r.Address(rowabsolute:=False, columnabsolute:=False) & "(" & getname$(r) & ")"
                Cells(cellref, 2).Font.Color = RGB(0, 0, 255)
                Cells(cellref, 2).Font.Italic = True
                cellref = cellref + 1
            Next
        Else
            Cells(cellref, 2) = "'      " & results(1, i)
            Cells(cellref, 2).Font.Color = RGB(0, 0, 255)
            Cells(cellref, 2).Font.Italic = True
            cellref = cellref + 1
        End If
        
    
    
    Else
        '*** Add this bit of the formula to the next bit
        temp = temp & results$(1, i)
    End If
Next

'*** Print out anything that is left.
Cells(cellref, 2) = temp
'Cells(cellref, 2).Font.Bold = True

Exit Sub
r = Null
j = 0
While IsObject(r) Or j < 1
    
    '*** reset the loop and get the values from the column
    i = 0
    j = j + 2
    no_inserts = 0
    r = Null
    On Error Resume Next
    Set r = ActiveSheet.Columns(j - 1).SpecialCells(xlConstants, xlTextValues)
    On Error GoTo tracer
    
    If IsObject(r) Then
        
        s = Null
        '*** For each row reference in the previous column
        For Each s In r
            
            i = 0
            no_inserts = 0
            k = refs_found
            t = Null
            On Error Resume Next
            Set t = g_selection.Worksheet.Range(s.Value)
            On Error GoTo tracer
                       
            If IsObject(t) Then
                Call parser(t, results$(), bits, True, False)
                s.Value = s.Value & ":" & getname$(t)
                
                '*** For each element in the parsed reference
                For i = 0 To bits - 1
                    
                    '*** Test to see if range is on this sheet ***
                    If InStr(results$(1, i + 1), "!") = 0 Then
                        u = Null
                        
                        t.Worksheet.Activate
                        On Error Resume Next
                        Set u = Application.Range(results$(1, i + 1))
                        On Error GoTo tracer
                        reportsheet.Activate
                        '*** If it is a range reference
                        If IsObject(u) Then
                            
                            '*** document on the output sheet
                            Cells(s.Row + no_inserts + 1, j + 1).EntireRow.Insert
                            Cells(s.Row + no_inserts + 1, j + 1) = "'" & temp$
                            no_inserts = no_inserts + 1
                            temp$ = ""
                            For Each v In u
                                'MsgBox Str$(s.Row + no_inserts)
                                Cells(s.Row + no_inserts + 1, j + 1).EntireRow.Insert
                                Cells(s.Row + no_inserts + 1, j + 1) = "'   " & v.Address
                                Cells(s.Row + no_inserts + 1, j + 1).Font.Italic = True
                                no_inserts = no_inserts + 1
                                With ActiveSheet.Lines.Add(x1:=Cells(s.Row + refs_found + 1, j + 1).Left, y1:=Cells(s.Row + refs_found + 1, j + 1).Top - s.Height / 2, x2:=s.Left + s.Width, y2:=s.Top + s.Height / 2)
                                    .ArrowHeadStyle = xlOpen
                                End With
                                refs_found = refs_found + 1
                            Next
                        Else
                            '*** Its not a range reference on this or other sheets
                            temp$ = temp$ + results$(1, i + 1)
                        
                        End If
                    Else
                        'If it is a row reference to a different sheet then stop
                        Cells(s.Row + refs_found + 1, j + 1) = "'" & results$(1, i + 1)
                        Cells(s.Row + refs_found + 2, j + 1).EntireRow.Insert
                         With ActiveSheet.Lines.Add(x1:=Cells(s.Row + refs_found + 1, j + 1).Left, y1:=Cells(s.Row + k + 1, j + 1).Top - s.Height / 2, x2:=s.Left + s.Width, y2:=s.Top + s.Height / 2)
                            .ArrowHeadStyle = xlOpen
                        End With
                        refs_found = refs_found + 1
                    End If
                Next
                '*** Check to see if we have an input cell ***
                If refs_found = 0 Then
                    Cells(s.Row, j - 1).BorderAround LineStyle:=xlContinuous
                End If
            Cells(s.Row + no_inserts + 1, j + 1).EntireRow.Insert
            Cells(s.Row + no_inserts + 1, j + 1) = "'" & temp$
            no_inserts = no_inserts + 1
            temp$ = ""
            End If
          Next
    ActiveSheet.Columns(j + 1).AutoFit
    ActiveSheet.Columns(j - 1).AutoFit
    End If
Wend


Exit Sub
tracer:
Call errorhandler("Tracer ", Err)
Resume
End Sub

Sub tracer_dblclick()
Attribute tracer_dblclick.VB_ProcData.VB_Invoke_Func = " \n14"
Dim results$(3, 300)
Dim t As Variant
Dim bits As Integer
Dim rangeref As Variant
Dim startcell As Variant
Dim tworkbook As Variant
Dim rd As Variant
Set startcell = Selection
a$ = startcell.Value
a$ = Mid$(a$, 1, InStr(a$, "(") - 1)
g_selection.Worksheet.Activate
'*** Note if goes over more than one sheet this won't work.

If InStr(a$, "!") <> 0 Then
    'This bit doesn't work.
    Set t = Worksheets(Mid$(results$(1, i), 2, InStr(results$(1, i), "!") - 3)).Range(results$(1, i))
Else
    Set t = Range(Mid$(a$, InStr(a$, "!") + 1))
End If
'Set t = ActiveSheet.range(Mid$(startcell.Value, 1, InStr(Selection.Value, "(") - 1))
'Set t = ActiveSheet.range("a1")
't.Worksheet.Activate

Call parser(t, results$(), bits, True, False)
ThisWorkbook.Worksheets("tracer").Activate

cellrow = startcell.Row
cellcol = startcell.Column + 1
temp$ = "'"
'For i = 1 To bits
'    MsgBox results$(1, i)
'Next i
For i = 1 To bits
    p = Null
    g_selection.Worksheet.Activate
    On Error Resume Next
    Set p = Application.Range(results$(1, i))
    On Error GoTo tracer_dblclick
    ThisWorkbook.Worksheets("tracer").Activate
  
    If IsObject(p) Or InStr(results(1, i), "!") <> 0 Then
        MsgBox "Range value " & results$(1, i)
        Cells(cellrow, cellcol) = temp$
        'Cells(cellrow, cellcol).Font.Bold = True
        temp$ = "'"
        Cells(cellrow + 1, cellcol).EntireRow.Insert
        cellrow = cellrow + 1
       ' For Each r In range(results$(i, 1))
       '     Cells(cellrow + 1, cellcol).EntireRow.Insert
       ' Next
          
        If InStr(results$(1, i), "!") <> 0 Then
            g_selection.Worksheet.Activate
      
            Set rd = Worksheets(Mid$(results$(1, i), 2, InStr(results$(1, i), "!") - 3)).Range(results$(1, i))
            ThisWorkbook.Worksheets("tracer").Activate
            '*** Note this has to be done first or else the range changes
            For Each r In rd
                Rows(cellrow + 1).Insert
            Next
            For Each r In rd
                'Set r = g_selection.Worksheet.range(r.Address)
                Cells(cellrow, cellcol) = "'     " & r.Address(rowabsolute:=False, columnabsolute:=False, external:=True) & "(" & getname$(r) & ")"
                Cells(cellrow, cellcol).Font.Color = RGB(0, 0, 255)
                Cells(cellrow, cellcol).Font.Italic = True
                Cells(cellrow + 1, cellcol).EntireRow.Insert
                cellrow = cellrow + 1
            Next
        Else
            'This is needed to sort out the name references.
             ' MsgBox "got here " & results$(1, i)
            ' Set rangeref = Workbooks("expmodel.xls").Worksheets("case").Evaluate(results$(1, i))
           ' MsgBox "got here"
            For Each r In rangeref
                MsgBox r.Address
                Rows(cellrow + 1).Insert
            Next
            For Each r In rangeref
                Set t = g_selection.Worksheet.Range(r.Address)
                Cells(cellrow, cellcol) = "'     " & t.Address(rowabsolute:=False, columnabsolute:=False) & "(" & getname$(t) & ")"
                Cells(cellrow, cellcol).Font.Color = RGB(0, 0, 255)
                Cells(cellrow, cellcol).Font.Italic = True
                'Cells(cellrow + 1, cellcol).EntireRow.Insert
                'Rows(cellrow + 1).Insert
                cellrow = cellrow + 1
            Next
        End If
    Else
        temp$ = temp$ + results$(1, i)
    End If
Next
Cells(cellrow, cellcol) = temp$

Exit Sub
tracer_dblclick:
End Sub
Attribute VB_Name = "UserForm1"
Attribute VB_Base = "0{019175FE-2325-452E-8A4B-E474CAC34B43}{6F972B9F-CAA7-4BA9-86B2-5A1A92652C38}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Attribute VB_Name = "bubbleoptions"
Attribute VB_Base = "0{9E872A19-0CB9-4898-916D-30A5004424B8}{6F5F66E2-B038-4264-B31B-7B1355E15C53}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False











Public ColorValue As Variant
Dim Buttons(1 To 56) As New ColorButtonClass







Private Sub CommandButton1_Click()
Call readoptions
End Sub





Function GetAColor() As Variant
'   Displays a dialog box and returns a
'   color value - or False if no color is selected
    Dim ctl As Control
    Dim ButtonCount As Integer
    ButtonCount = 0
    For Each ctl In bubbleoptions.Controls
'       The 56 color buttons have their Tag property set to "ColorButton"
        If ctl.Tag = "ColorButton" Then
            ButtonCount = ButtonCount + 1
            Set Buttons(ButtonCount).ColorButton = ctl
            If WorkbookIsActive Then
'               Get colors from the active workbook's palette
                Buttons(ButtonCount).ColorButton.BackColor = _
                    ActiveWorkbook.Colors(ButtonCount)
            Else
'               Get colors from this workbook's palette
                Buttons(ButtonCount).ColorButton.BackColor = _
                    ThisWorkbook.Colors(ButtonCount)
            End If
        End If
    Next ctl
    'bubbleoptions.Show
    GetAColor = ColorValue
End Function

Function WorkbookIsActive()
'   Returns True if there's an ActiveWorkbook
    Dim X As String
    On Error Resume Next
    X = ActiveWorkbook.Name
    If Err = 0 Then WorkbookIsActive = True Else WorkbookIsActive = False
End Function



Private Sub CommandButton2_Click()
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=10

End Sub

Private Sub CommandButton3_Click()
'*** Saves the values of all the controls and then loads them into the variables again.
Dim ctl As Control
Dim ctrltype As String

'*** Bubble diagram options ***
For Each ctl In Me.Mpoptions.Pages(0).Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "CheckBox" Then
        SaveSetting "SP", "Reports", ctl.Name, ctl.Value
    End If
Next ctl


'*** Format options ***
For Each ctl In Me.Mpoptions.Pages(1).Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "OptionButton" Then
        SaveSetting "SP", "Reports", ctl.Name, ctl.BackColor
    End If
Next ctl

'*** Test options ***
For Each ctl In Me.Mpoptions.Pages(2).Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "CheckBox" Then
      SaveSetting "SP", "Reports", ctl.Name, ctl.Value
    End If
Next ctl

'*** Translation options ***
For Each ctl In Me.Mpoptions.Pages(3).Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "TextBox" Or ctrltype = "OptionButton" Then
        SaveSetting "SP", "Reports", ctl.Name, ctl.Value
    End If
Next ctl
End Sub



Private Sub UserForm_Activate()
s = GetAColor()
End Sub

Attribute VB_Name = "bubblerangeoptions"
Attribute VB_Base = "0{7C2DA736-CB97-40AD-9E42-9FB324007812}{F0F51812-3122-45C3-B0D1-5A22112C835B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False











Private Sub CommandButton1_Click()
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=7

End Sub

Private Sub expandall_Click()
Listofcells.Visible = False
End Sub

Private Sub Expandsinglecell_Click()
Listofcells.Visible = True
End Sub



Private Sub rangeok_Click()
g_noredraw = True
bubblerangeoptions.Hide
End Sub

Attribute VB_Name = "cellcheckmod"


















Sub calcchecker()
Attribute calcchecker.VB_ProcData.VB_Invoke_Func = "m\n14"
On Error GoTo calcchecker
Dim z As Variant
Dim ur As Variant, temp As Variant, un As Variant
Dim response As Integer
Dim c As Variant
Dim s$
Dim oldc As Variant

'*** Check it is being called from a legitimate sheet ***
temp = Null
On Error Resume Next
Set temp = Worksheets(ActiveSheet.Name)
On Error GoTo calcchecker
If IsObject(temp) = False Then
    MsgBox "The calculation checker can only be called from within a worksheet.", 16, "Spreadsheet Professional"
    Exit Sub
End If
If temp.ProtectContents = True Then
    MsgBox "Spreadsheet Professional requires that each sheet to be analysed is unprotected.  Unprotect the sheets (select the protection option from the Tools menu) and then reselect the calculation checker option from the S.P. menu.", 16, "Spreadsheet Professional"
    Exit Sub
End If

If temp.UsedRange.Rows.Count > ThisWorkbook.Worksheets("constants").Range("b7") Then
    Call evalcopy
    Exit Sub
End If

'*** Check it is not being called from within the cell inspector. ***
If ActiveWindow.Caption = "Cell translator" Then
    MsgBox "The calculation checker cannot be called when the cursor is in the cell translator.  Click on the sheet that you wish to check and then choose Calculation Checker from the menu", 48, "Spreadsheet Professional"
    Exit Sub
End If
    

'*** Get the whole range.
Set ur = ActiveCell
Call startchecking(ur)
Exit Sub
calcchecker:
Call errorhandler("Calc checker", Err)
Resume
End Sub


Sub startchecking(ur)
Attribute startchecking.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo startchecking
Dim temp As Variant
Dim tempsheet As Variant
ReDim finder(50) As Integer
Dim firstrow, lastrow
Dim firstcol
Dim rws
Call readoptions
'If ThisWorkbook.DialogSheets("checkeroptions").CheckBoxes("uniquecellsonly").Value = xlOn Then
'    g_unique = True
'Else
'    g_unique = False
'End If
'Call get_unique_options(g_copy)
newrange:
firstrow = ur.Row
firstcol = ur.Column
lastrow = ActiveSheet.UsedRange.Rows(ActiveSheet.UsedRange.Rows.Count).Row

For rws = firstrow To lastrow
    Application.StatusBar = "Checking row " & Str$(rws) & " (Press Esc to cancel)"
    '*** Setup cells to examine ***
    If rws = firstrow Then
        
        Set temp = Range(Cells(rws, firstcol), Cells(rws, 256))
        
    Else
        Set temp = Range(Cells(rws, 1), Cells(rws, 256))
    End If
         
    '*** Get any relevant cells ***
    Call getcells(temp, xlFormulas, 0, ur)
    Call getcells(temp, xlConstants, xlNumbers, un)
         
    '*** Get all the cells in the range to be checked.
    If IsObject(un) And IsObject(ur) Then
        Set ur = Union(ur, un)
    End If

    If (IsObject(un)) And (IsObject(ur) = False) Then
        Set ur = un
    End If




Application.ScreenUpdating = False
If IsObject(ur) Then
    For Each c In ur
       Application.StatusBar = "Checking row " & Str$(rws) & " Cell " & c.Address(rowabsolute:=False, columnabsolute:=False) & " (Press Esc to cancel)"
       If c.HasFormula Then
            If g_unique Then
                '*** Discovering whether it is unique or not.
                tmp = Null
                Select Case g_uniqueoption
                Case c_horizontal
                    Call uniqueformulas(c_horizontal, c, tmp)
                Case c_vertical
                    Call uniqueformulas(c_vertical, c, tmp)
                Case c_both
                    tmp1 = Null
                    Call uniqueformulas(c_vertical, c, tmp)
                    Call uniqueformulas(c_horizontal, c, tmp1)
                    If IsObject(tmp1) = False Then
                        tmp = Null
                    End If
                End Select
           
                If IsObject(tmp) = False Then
                    GoTo nextformulacheck
                Else
                    Call testformulas(c, finder(), errors)
                End If
            Else
                Call testformulas(c, finder(), errors)
            End If
        Else
         Call testinputs(c, finder(), errors)
        End If
        
        If errors > 0 Then
            '*** Transfer the errors to global variables
            ReDim g_finder(30)
            g_errors = errors
            For k = 1 To g_errors
                g_finder(k) = finder(k)
            Next k
            
            '*** Activate the cell so that the grammar checker appears near it.
            c.Activate
           
            '*** Get the first cell and show the appropriate values
            g_count = 1
            g_rule = g_finder(g_count)
            s$ = g_rules(g_finder(g_count)).title
            
            If g_rule = 17 Then
                Call filldepdnsbox(ActiveCell.Offset(0, -1), ActiveCell)
            Else
                ThisWorkbook.DialogSheets("cellchecker").Buttons("references").Visible = False
            End If
            ThisWorkbook.DialogSheets("cellchecker").Labels("cell").Caption = c.Address(rowabsolute:=False, columnabsolute:=False)
            ThisWorkbook.DialogSheets("cellchecker").Labels("rules").Caption = s$
            On Error GoTo specialchecking
            t$ = c.FormulaLocal
            ThisWorkbook.DialogSheets("cellchecker").Labels("contents").Caption = t$
            On Error GoTo startchecking
            '*** Show the grammar checker ***
            Application.ScreenUpdating = True
            ThisWorkbook.DialogSheets("cellchecker").Show
            Application.ScreenUpdating = False
        End If
nextformulacheck:
    Next 'next column
End If
Next 'row

response = MsgBox("           Continue checking from beginning?", vbYesNo + vbQuestion, "Spreadsheet Professional - Calculation Checker")
If response = vbYes Then
    Set ur = ActiveSheet.Cells(ActiveSheet.UsedRange.Row, ActiveSheet.UsedRange.Column)
    GoTo newrange
End If

Application.StatusBar = False
Exit Sub
startchecking:
Call errorhandler("Start checking", Err)
Resume

specialchecking:
MsgBox "Cell " & c.Address(rowabsolute:=False, columnabsolute:=False) & " too complex to analyse. Continuing to next cell", 48, "Spreadsheet Professional"
Resume nextformulacheck
End Sub

Sub cellcheck_continue_click()
Attribute cellcheck_continue_click.VB_ProcData.VB_Invoke_Func = " \n14"
g_count = g_count + 1
If g_count > g_errors Then
 ThisWorkbook.DialogSheets("cellchecker").Hide
Else
    g_rule = g_finder(g_count)
    ThisWorkbook.DialogSheets("cellchecker").Labels("rules").Caption = g_rules(g_rule).title
    
    If g_rule = 17 Then
       Call filldepdnsbox(ActiveCell.Offset(0, -1), ActiveCell)
    Else
        ThisWorkbook.DialogSheets("cellchecker").Buttons("references").Visible = False
    End If
End If
Exit Sub
cellcheck_continue_click:
Call errorhandler("cellcheck_continue_click", Err)
Resume
End Sub


Sub showprecedents()
Attribute showprecedents.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo showprecedents
ReDim results(3, 500) As String
Set g_mwksht = ActiveCell.Worksheet
Call parser(ActiveCell, results(), bits, True, False)
ThisWorkbook.DialogSheets("references").ListBoxes("references").RemoveAllItems
a$ = String$(70, " ")
Mid$(a$, 1) = "Ref"
Mid$(a$, 12) = "Translation"
Mid$(a$, 50) = "Value"
ThisWorkbook.DialogSheets("references").ListBoxes("references").AddItem Text:=a$
For i = 1 To bits
    t = Null
    On Error Resume Next
    Set t = Range(results(1, i))
    On Error GoTo showprecedents
    
    If IsObject(t) Then
        a$ = String(70, " ")
        Mid$(a$, 1) = results(1, i)
        Mid$(a$, 12) = Mid$(Trim$(results(2, i)), 1, 30)
        Mid(a$, 50) = Trim$(results(3, i))
        ThisWorkbook.DialogSheets("references").ListBoxes("references").AddItem Text:=a$
    End If
Next i
ThisWorkbook.DialogSheets("references").Show
    

Exit Sub
showprecedents:
Call errorhandler("Show precedents", Err)
Resume
End Sub

Sub filldepdnsbox(a As Range, b As Range)
Attribute filldepdnsbox.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo filldepdnsbox
ThisWorkbook.DialogSheets("cellchecker").Buttons("references").Visible = True
ThisWorkbook.DialogSheets("refs").Labels("firstcell").Caption = "Cell " & a.Address(rowabsolute:=False, columnabsolute:=False)
ThisWorkbook.DialogSheets("refs").Labels("secondcell").Caption = "Cell " & b.Address(rowabsolute:=False, columnabsolute:=False)
ThisWorkbook.DialogSheets("refs").ListBoxes("firstlist").RemoveAllItems
ThisWorkbook.DialogSheets("refs").ListBoxes("secondlist").RemoveAllItems

On Error Resume Next
Set olddd = a.DirectDependents
On Error GoTo filldepdnsbox
If IsObject(olddd) Then
For Each item In olddd
    ThisWorkbook.DialogSheets("refs").ListBoxes("firstlist").AddItem (item.Address(rowabsolute:=False, columnabsolute:=False))
Next
End If
        
On Error Resume Next
Set dd = b.DirectDependents
On Error GoTo filldepdnsbox
If IsObject(dd) Then
For Each item In dd
    ThisWorkbook.DialogSheets("refs").ListBoxes("secondlist").AddItem (item.Address(rowabsolute:=False, columnabsolute:=False))
Next
End If
Exit Sub
filldepdnsbox:
Call errorhandler("Fill depdns box", Err)
Resume
End Sub
Sub editcell()
Attribute editcell.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo editcell
Application.StatusBar = "Press Ctrl M to continue checking."
Set g_continuecell = ActiveCell
g_abort = True
End
editcell:
Call errorhandler("Edit cell", Err)
Resume
End Sub

Sub Cancel()
Attribute Cancel.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo Cancel
g_abort = True
Application.StatusBar = False
End
Cancel:
Call errorhandler("Cancel ", Err)
Resume
End Sub

Sub listdepdns()
Attribute listdepdns.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo listdepdns
ThisWorkbook.DialogSheets("refs").Show
Exit Sub
listdepdns:
Call errorhandler("List depdendents", Err)
Resume
End Sub

Sub explainrule()
Attribute explainrule.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo explainrule
Dim a$, k

ThisWorkbook.DialogSheets("expl dialog").Labels("rule").Caption = g_rules(g_rule).title

a$ = g_rules(g_rule).expl & " Potential errors to watch for: "
ThisWorkbook.DialogSheets("expl dialog").TextBoxes("explanation").Text = a$

ThisWorkbook.DialogSheets("expl dialog").TextBoxes("error1").Text = g_rules(g_rule).Err(1)
ThisWorkbook.DialogSheets("expl dialog").TextBoxes("error2").Text = g_rules(g_rule).Err(2)
ThisWorkbook.DialogSheets("expl dialog").TextBoxes("error3").Text = g_rules(g_rule).Err(3)
ThisWorkbook.DialogSheets("expl dialog").TextBoxes("error4").Text = g_rules(g_rule).Err(4)

ThisWorkbook.DialogSheets("expl dialog").Show
Exit Sub
explainrule:
Call errorhandler("Explain rule", Err)
Resume
End Sub

Sub showcell()
Attribute showcell.VB_ProcData.VB_Invoke_Func = " \n14"
Dim tempsheet As Variant
Set tempsheet = ActiveSheet
On Error GoTo showcell
If ThisWorkbook.DialogSheets("cellchecker").CheckBoxes("showcelldetails").Value = xlOn Then
    Application.ScreenUpdating = False
    Call cellinspector
    Call ci_dblclick
    Application.ScreenUpdating = True
Else
    Application.ScreenUpdating = False
    g_cititle = "Cell translator"
    z = Null
    On Error Resume Next
    Set z = Windows(g_cititle)
    On Error GoTo showcell
    If IsObject(z) Then z.Close (False)
    Application.ScreenUpdating = True
End If
tempsheet.Activate
Exit Sub
showcell:
Call errorhandler("Show cell", Err)
Resume
End Sub

Sub uniqueonly()
Attribute uniqueonly.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo uniqueonly
If g_unique = True Then
    g_unique = False
    ThisWorkbook.DialogSheets("cellchecker").CheckBoxes("testuniqueonly").Value = xlOff
Else
    g_unique = True
    ThisWorkbook.DialogSheets("cellchecker").CheckBoxes("testuniqueonly").Value = xlOn
End If
Exit Sub
uniqueonly:
Call errorhandler("Unique only", Err)
Resume
End Sub


Sub help()
Attribute help.VB_ProcData.VB_Invoke_Func = " \n14"
End Sub
Attribute VB_Name = "cellinspectmod"


















Sub cellinspector()
Attribute cellinspector.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo cellinspector
Dim z As Variant
Dim w As Variant
'*** All the error trapping is to deal with the situation where the user tries
'*** to close the cell inspector when it is the active sheet.

If Len(Application.OnDoubleClick) >= 1 Then
    If Right$(Application.OnDoubleClick, 11) = "ci_dblclick" Then

        Application.OnDoubleClick = ""
        ActiveMenuBar.Menus("S.P.").MenuItems(2).Caption = "Enable Cell &Translator (Ctrl + Shift + T)"
    Else

        Application.OnDoubleClick = "ci_dblclick"
        ActiveMenuBar.Menus("S.P.").MenuItems(2).Caption = "Disable Cell &Translator"
        MsgBox "Double click on any cell to obtain a translation of its formula." & Chr$(10) & Chr$(10) & "Double click on any cell reference within the Cell Translator to drill down through a spreadsheet to understand how a result is derived.", 64, "Spreadsheet Professional"
    End If
Else

    ActiveMenuBar.Menus("S.P.").MenuItems(2).Caption = "Disable Cell &Translator"
    Application.OnDoubleClick = "ci_dblclick"
    MsgBox "Double click on any cell to obtain a translation of its formula." & Chr$(10) & Chr$(10) & "Double click on any cell reference within the Cell Translator to drill down through a spreadsheet to understand how a result is derived.", 64, "Spreadsheet Professional"
End If

Exit Sub
cellinspector:
Call errorhandler("Cell translator", Err)
Resume
End Sub

Sub ci_dblclick()
Attribute ci_dblclick.VB_ProcData.VB_Invoke_Func = "T\n14"
On Error GoTo ci_dblclick
Dim bits As Integer
ReDim results(3, 300) As String
Dim z As Variant
Dim t As Variant
Dim w As Variant
Dim temp As Variant
Static topleft As Variant
Dim ac As Variant
Dim u$
'*** Setup the name of the window holding the cell translator.
g_cititle = "Cell translator"

'*** Check that the cell inspector is being called from a worksheet.
On Error Resume Next
Set temp = Worksheets(ActiveSheet.Name)
On Error GoTo ci_dblclick
If IsObject(temp) = False Then
    MsgBox "The cell translator can only be called while in a worksheet.", 16, "Spreadsheet Professional"
    Exit Sub
End If

If temp.UsedRange.Rows.Count > ThisWorkbook.Worksheets("constants").Range("b7") Then
    Call evalcopy
    Exit Sub
End If

'Call get_translation_options

'*** Step 1.  See whether the window is available.  If it is then make sure it
'*** is visible, otherwise create it.

On Error Resume Next
Set z = Windows("Cell translator")
On Error GoTo ci_dblclick

If IsObject(z) = False Then
    Application.ScreenUpdating = False
    Application.StatusBar = "Creating Cell translation window."
    'Call makespci
    Application.StatusBar = ""
Else
 '  z.WindowState = xlNormal
End If


'*** If being called from within the cell translator we must do something special.
'*** Otherwise we need to mark where we came from, to ensure that we return there.

Set w = ActiveWindow
Application.ScreenUpdating = False
If ActiveWindow.Caption <> "Cell translator" Then
    '*** We need to store the calling value to ensure that we can get back there.
    Set t = Application.ActiveCell
    Set topleft = t.Worksheet.Cells(ActiveWindow.ScrollRow, ActiveWindow.ScrollColumn)
    
    Set g_mwksht = t.Worksheet '*** Needed to make the parser work.
    Call parser(t, results(), bits, True, False)
Else
    temp = Cells(1, ActiveWindow.ActiveCell.Column).Value
    
    Set oldcell = Range(Cells(6, 1).Value)
    Windows(g_cititle).Visible = False
    Set g_mwksht = ActiveCell.Worksheet
    If InStr(temp, "]") <> 0 Then
        MsgBox "Cannot examine cells that contain an external reference", 48, "Spreadsheet Professional"
    Else
        If InStr(temp, "!") = 0 Then
            On Error Resume Next
            Set t = oldcell.Worksheet.Range(temp)
            On Error GoTo ci_dblclick
        Else
            On Error Resume Next
            Set t = Range(temp)
            On Error GoTo ci_dblclick
        End If
    End If
    
    If IsObject(t) = False Then
        MsgBox "Not a valid cell reference", 48, "Spreadsheet Professional"
        Exit Sub
    Else
        If t.Count > 1 Then
            MsgBox "Cannot drill down a range reference", 48, "Spreadsheet Professional"
            Exit Sub
        End If
        Call parser(t, results(), bits, True, False)
    End If
End If


'*** Now lets fill up with the sheet contents
'Windows(g_cititle).Activate
'Cells(500, 1).Activate
If IsObject(g_ctname) = False Then
    Windows("Cell translator").Activate
    Set g_ctname = ActiveWorkbook
    Windows("cell translator").Visible = False
End If
Set s = g_ctname.Worksheets(1)
s.Rows("1:3").ClearContents

u$ = t.Address(external:=True, rowabsolute:=False, columnabsolute:=False)
s.Cells(1, 1) = "'" & Mid$(u$, InStr(u$, "]") + 1)
s.Cells(2, 1) = "'" & getname(t)
s.Cells(3, 1) = "'" & getvalue(t)

For i = 1 To bits
    s.Cells(1, 1 + i).Value = "'" & results(1, i)
    s.Cells(2, 1 + i).Value = "'" & results(2, i)
    s.Cells(3, 1 + i).Value = "'" & results(3, i)
Next i
s.Cells(6, 1).ClearContents
s.Columns.AutoFit
s.Cells(6, 1) = "'" & t.Address(external:=True)



If IsObject(topleft) Then Application.Goto reference:=topleft, scroll:=True
Windows(g_cititle).Activate
Application.Goto reference:=Cells(1, 1), scroll:=True
Application.ScreenUpdating = True
g_ctname.Saved = True
Application.StatusBar = False
Exit Sub
ci_dblclick:
Call errorhandler("Cell translator dbl click", Err)
Resume Next
End Sub
Attribute VB_Name = "comparemod"






Option Explicit

Sub startcompare()
Attribute startcompare.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo startcompare
Dim i
Dim dial As Variant

Set dial = ThisWorkbook.DialogSheets("comparisons")
dial.ListBoxes("workbooks1").RemoveAllItems
dial.ListBoxes("workbooks2").RemoveAllItems
dial.ListBoxes("sheets1").RemoveAllItems
dial.ListBoxes("sheets2").RemoveAllItems
For i = 1 To Application.Workbooks.Count
    dial.ListBoxes("workbooks1").AddItem (Workbooks(i).Name)
    dial.ListBoxes("workbooks2").AddItem (Workbooks(i).Name)
Next i

For i = 1 To Workbooks(1).Worksheets.Count
    ThisWorkbook.DialogSheets("comparisons").ListBoxes("sheets1").AddItem (Workbooks(1).Worksheets(i).Name)
    ThisWorkbook.DialogSheets("comparisons").ListBoxes("sheets2").AddItem (Workbooks(1).Worksheets(i).Name)
Next i

ThisWorkbook.DialogSheets("comparisons").Show
Exit Sub
startcompare:
Call errorhandler("Start compare", Err)
Resume
End Sub

Sub compare_ok()
Attribute compare_ok.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo compare_ok
Dim i
Dim dial As Variant
Set dial = ThisWorkbook.DialogSheets("comparisons")

If (dial.ListBoxes("workbooks1").ListIndex < 1) Or (dial.ListBoxes("workbooks2").ListIndex < 1) Or (dial.ListBoxes("sheets1").ListIndex < 1) Or (dial.ListBoxes("sheets2").ListIndex < 1) Then
    MsgBox "Select an item from each of the lists displayed by clicking on the item in each listbox", 16, "Spreadsheet Professional"
    Exit Sub
End If

Set g_comp1 = Workbooks(dial.ListBoxes("workbooks1").ListIndex).Worksheets(dial.ListBoxes("sheets1").ListIndex)
Set g_comp2 = Workbooks(dial.ListBoxes("workbooks2").ListIndex).Worksheets(dial.ListBoxes("sheets2").ListIndex)
If (g_comp1.ProtectContents = True) Or (g_comp2.ProtectContents = True) Then
    MsgBox "Spreadsheet Professional requires that each sheet to be analysed is unprotected.  Unprotect the sheets (select the protection option from the Tools menu) and then reselect the comparison option from the S.P. menu.", 16, "Spreadsheet Professional"
    Exit Sub
End If
g_compw1 = Workbooks(dial.ListBoxes("workbooks1").ListIndex).Name
g_compw2 = Workbooks(dial.ListBoxes("workbooks2").ListIndex).Name
dial.Hide
Call setupwindows
Call makecomparisons
Application.StatusBar = False
Exit Sub
compare_ok:
Call errorhandler("Compare ok", Err)
Resume
End Sub

Sub setupwindows()
Attribute setupwindows.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo setupwindows
Dim dial
Set dial = ThisWorkbook.DialogSheets("comparisons")
Application.ScreenUpdating = False
Workbooks.Add
Application.ScreenUpdating = True
Exit Sub
setupwindows:
Call errorhandler("Setup windows", Err)
Resume
End Sub

Sub makecomparisons()
Attribute makecomparisons.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo makecomparisons
Dim rowno
Dim t1 As String
Dim t2 As String
Dim dial As Variant
Dim first As Variant
Dim second As Variant
Dim a As Variant
Dim c As Variant
Dim d As Variant
Dim e As Variant
Dim b As Variant
Dim mult As Single
Dim formulas As Variant
Dim j As Single
Dim i As Single
ReDim f$(1), g$(1)
Dim Header$
Dim cellstobecompared
Dim cellstobecompared2
Dim comparison$
Dim firstrange As Variant
Dim secondrange As Variant
Dim extrarange As Variant
Dim firstcolumn As Single
Dim firstrow As Single
Dim secondrow As Single
Dim secondcolumn As Single
'*** Check the size of each spreadsheet.
first = Null
On Error Resume Next
Set first = g_comp1.UsedRange
On Error GoTo makecomparisons
If IsObject(first) Then
    If first.Rows.Count > ThisWorkbook.Worksheets("constants").Range("b7") Then
        Call evalcopy
        Exit Sub
    End If
End If
first = Null

Set dial = ThisWorkbook.DialogSheets("comparisons")
Application.ScreenUpdating = False
rowno = 1



ActiveWindow.ActiveSheet.Cells(rowno, 1).Value = "Cell"
ActiveWindow.ActiveSheet.Cells(rowno, 2).Value = g_compw1 & ":" & g_comp1.Name
ActiveWindow.ActiveSheet.Cells(rowno, 3).Value = g_compw2 & ":" & g_comp2.Name
Cells(rowno, 1).Font.Bold = True
Cells(rowno, 2).Font.Bold = True
Cells(rowno, 3).Font.Bold = True

Columns(1).ColumnWidth = 7
mult = 7 / Columns(1).Width
Columns(2).ColumnWidth = (ActiveWindow.UsableWidth - Columns(1).Width) * mult / 2
Columns(3).ColumnWidth = Columns(2).ColumnWidth
Application.DisplayStatusBar = True
Application.StatusBar = "Setting up and formatting report"

If dial.OptionButtons("compareformulas").Value = xlOn Then
Header$ = "formulas"
cellstobecompared = xlFormulas
cellstobecompared2 = 0
comparison$ = "formulas"
End If
    
If dial.OptionButtons("compareresults").Value = xlOn Then
Header$ = "results"
cellstobecompared = xlFormulas
cellstobecompared2 = 0
comparison$ = "results"
End If

If dial.OptionButtons("compareinputs").Value = xlOn Then
Header$ = "Inputs & labels"
cellstobecompared = xlConstants
cellstobecompared2 = 0
comparison$ = "inputs"
End If


ActiveSheet.PageSetup.CenterHeader = "Differences in " & Header$ & " between " & g_compw1 & ":" & g_comp1.Name & " and " & g_compw2 & ":" & g_comp2.Name
first = Null
second = Null
On Error Resume Next
Call getcells(g_comp1.UsedRange, cellstobecompared, cellstobecompared2, first)
Call getcells(g_comp2.UsedRange, cellstobecompared, cellstobecompared2, second)
   
On Error GoTo makecomparisons
 
If IsObject(first) Then
    For Each c In first
        Application.StatusBar = "Comparing cell " & c.Address(rowabsolute:=False, columnabsolute:=False)
        
        Select Case comparison$
        
        Case "formulas"
       
        On Error GoTo specialcompare
        '*** This is a fudge because in some circumstances, Excel does not recognize that
        '*** c.formula is an error when it is too long.  Therefore, you have to make a
        '*** call to a function that does create an error i.e. trying to place the result in a
        '*** string.
        t1 = c.Formula
        t2 = g_comp2.Range(c.Address).Formula
        If c.Formula <> g_comp2.Range(c.Address).Formula Then
       
        On Error GoTo makecomparisons
                
            rowno = rowno + 1
            Cells(rowno, 1) = c.Address(rowabsolute:=False, columnabsolute:=False)
            Cells(rowno, 2) = "'" & c.Formula
            Cells(rowno, 3) = "'" & g_comp2.Range(c.Address).Formula
            Cells(rowno, 4) = c.Row
            Cells(rowno, 5) = c.Column
        End If
    
        Case "results"
        On Error GoTo specialcompare
        If c.Value <> g_comp2.Range(c.Address).Value Then
        On Error GoTo makecomparisons
        
            rowno = rowno + 1
            Cells(rowno, 1) = c.Address(rowabsolute:=False, columnabsolute:=False)
            Cells(rowno, 2) = "'" & c.Value
            Cells(rowno, 3) = "'" & g_comp2.Range(c.Address).Value
            Cells(rowno, 4) = c.Row
            Cells(rowno, 5) = c.Column
        End If
    
        Case "inputs"
        On Error GoTo specialcompare
        If c.Value <> g_comp2.Range(c.Address).Value Then
        On Error GoTo makecomparisons
        
            rowno = rowno + 1
            Cells(rowno, 1) = c.Address(rowabsolute:=False, columnabsolute:=False)
            Cells(rowno, 2) = "'" & c.Formula
            Cells(rowno, 3) = "'" & g_comp2.Range(c.Address).Formula
            Cells(rowno, 4) = c.Row
            Cells(rowno, 5) = c.Column
        End If
        End Select
resumefromtoolongerror:
    Next
End If

If IsObject(second) Then
        
    Application.StatusBar = "Checking for new " & Header$ & " on the second spreadsheet"
        
    '*** This part collects all the formulas which have a blank cell or a
    '*** constant in the first spreadsheet and which are within the first
    '*** spreadsheets used range.
    formulas = Null
    d = Null
      
    Call getaddress(second, f$())
    For i = 1 To UBound(f$, 1)
        d = Null
        e = Null
        b = Null
        
        Select Case comparison$
        Case "formulas", "results"
            On Error Resume Next
            Call getcells(g_comp1.Range(f$(i)), xlConstants, 0, d)
            Call getcells(g_comp1.Range(f$(i)), xlBlanks, 0, e)
            On Error GoTo makecomparisons
        Case "inputs"
            On Error Resume Next
            'Call getcells(g_comp1.range(f$(i)), xlConstants, xlTextValues + xlLogical + xlErrors, d)
            Call getcells(g_comp1.Range(f$(i)), xlBlanks, 0, e)
            Call getcells(g_comp1.Range(f$(i)), xlFormulas, 0, b)
            On Error GoTo makecomparisons
        End Select
        
        '*** Now combine them all together ***
        If IsObject(d) = True Then
            Call getaddress(d, g$())
            For j = 1 To UBound(g$, 1)
                If IsObject(formulas) = True Then
                    Set formulas = Union(formulas, g_comp2.Range(g$(j)))
                Else
                    Set formulas = g_comp2.Range(g$(j))
                End If
            Next j
        End If
        
        If IsObject(e) = True Then
            Call getaddress(e, g$())
            For j = 1 To UBound(g$, 1)
                If IsObject(formulas) = True Then
                    Set formulas = Union(formulas, g_comp2.Range(g$(j)))
                Else
                    Set formulas = g_comp2.Range(g$(j))
                End If
            Next j
        End If
  

        If IsObject(b) = True Then
            Call getaddress(b, g$())
            For j = 1 To UBound(g$, 1)
                If IsObject(formulas) = True Then
                    Set formulas = Union(formulas, g_comp2.Range(g$(j)))
                Else
                    Set formulas = g_comp2.Range(g$(j))
                End If
            Next j
        End If
    Next
    '*** Now we need to find all the formulas in the second spreadsheet which
    '*** are not within the used range of the first spreadsheet.  (Not done)
    Set firstrange = g_comp1.UsedRange
    Set secondrange = g_comp2.UsedRange
 
    firstrow = firstrange.Rows.Count + firstrange.Row - 1
    firstcolumn = firstrange.Columns.Count + firstrange.Column - 1
    secondrow = secondrange.Rows.Count + secondrange.Row - 1
    secondcolumn = secondrange.Columns.Count + secondrange.Column - 1
      
    '*** Get additional range to be explored ***
    extrarange = Null
    If secondcolumn <= firstcolumn And secondrow <= firstrow Then
        '*** The same or smaller range in the second spreadsheet therefore
        '*** no need to do anything.
    End If
       
    If secondcolumn <= firstcolumn And secondrow > firstrow Then
        Set extrarange = Range(Cells(firstrow + 1, 1), Cells(secondrow, secondcolumn))
    End If
       
    If secondrow <= firstrow And secondcolumn > firstcolumn Then
        Set extrarange = Range(Cells(1, firstcolumn + 1), Cells(secondrow, secondcolumn))
    End If
      
    If secondrow > firstrow And secondcolumn > firstcolumn Then
        Set extrarange = Range(Cells(1, firstcolumn + 1), Cells(secondrow, secondcolumn))
        Set extrarange = Union(Range(Cells(firstrow + 1, 1), Cells(secondrow, secondcolumn)), extrarange)
    End If
   
    If IsObject(extrarange) Then
        d = Null
        Call getcells(g_comp2.Range(extrarange.Address), cellstobecompared, cellstobecompared2, d)
        
        If IsObject(d) Then
            If IsObject(formulas) Then
                Set formulas = Union(formulas, d)
            Else
                Set formulas = d
            End If
        End If
    End If
 
    '*** This prints all the formulas out.
    If IsObject(formulas) Then
        For Each c In formulas
            rowno = rowno + 1
            Cells(rowno, 1) = c.Address(rowabsolute:=False, columnabsolute:=False)
            Cells(rowno, 4) = c.Row
            Cells(rowno, 5) = c.Column
                    
            On Error GoTo specialcompare
            Select Case comparison$
                Case "formulas", "inputs"
                    Cells(rowno, 2) = "'" & g_comp1.Range(c.Address).Formula
                    Cells(rowno, 3) = "'" & g_comp2.Range(c.Address).Formula
                Case "results"
                    Cells(rowno, 2) = "'" & g_comp1.Range(c.Address).Value
                    Cells(rowno, 3) = "'" & g_comp2.Range(c.Address).Value
            End Select
            On Error GoTo makecomparisons
                    
        Next
    End If
End If
     
'*** Now sort the cells so that they are in the correct order
Range(Cells(2, 1), Cells(rowno, 5)).Sort key1:=Cells(2, 4), key2:=Cells(2, 5)
Columns(4).Clear
Columns(5).Clear
If rowno = 1 Then
    rowno = rowno + 1
    Cells(rowno, 1).Value = "No differences found."
Else
    ActiveSheet.Rows.WrapText = True
End If

Application.StatusBar = "Final formatting"
With ActiveSheet.PageSetup
    .Orientation = xlPortrait
    .LeftFooter = "Spreadsheet Professional"
    .FitToPagesWide = 1
    .FitToPagesTall = False
    .PrintTitleRows = ActiveSheet.Rows(1).Address
End With
Application.StatusBar = ""
Exit Sub
makecomparisons:
Call errorhandler("Make comparisons", Err)
Resume
specialcompare:

'MsgBox "This cell too complex for Spreadsheet Professional, therefore ignored " & c.Address(rowabsolute:=False, columnabsolute:=False), 48, "Spreadsheet Professional"
rowno = rowno + 1
Cells(rowno, 1) = c.Address(rowabsolute:=False, columnabsolute:=False)
Cells(rowno, 2) = "'This cell not analysed because it is too long."
Cells(rowno, 3) = "'"
Cells(rowno, 4) = c.Row
Cells(rowno, 5) = c.Column
Resume resumefromtoolongerror
End Sub

Sub workbooks1_click()
Attribute workbooks1_click.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo workbooks1_click
Dim i
Dim g As Variant, h As Variant
Set g = ThisWorkbook.DialogSheets("comparisons").ListBoxes("sheets1")
Set h = ThisWorkbook.DialogSheets("comparisons").ListBoxes("workbooks1")

g.RemoveAllItems
For i = 1 To Workbooks(h.list(h.ListIndex)).Worksheets.Count
   g.AddItem (Workbooks(h.list(h.ListIndex)).Worksheets(i).Name)
Next i
If Workbooks(h.list(h.ListIndex)).Worksheets.Count = 1 Then
    g.ListIndex = 1
End If
Exit Sub
workbooks1_click:
Call errorhandler("Workbooks 1 click", Err)
Resume
End Sub

Sub workbooks2_click()
Attribute workbooks2_click.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo workbooks2_click
Dim i
Dim g As Variant, h As Variant
Set g = ThisWorkbook.DialogSheets("comparisons").ListBoxes("sheets2")
Set h = ThisWorkbook.DialogSheets("comparisons").ListBoxes("workbooks2")

g.RemoveAllItems
For i = 1 To Workbooks(h.list(h.ListIndex)).Worksheets.Count
   g.AddItem (Workbooks(h.list(h.ListIndex)).Worksheets(i).Name)
Next i

If Workbooks(h.list(h.ListIndex)).Worksheets.Count = 1 Then
    g.ListIndex = 1
End If
Exit Sub
workbooks2_click:
Call errorhandler("Workbooks 2 click", Err)
Resume
End Sub
Attribute VB_Name = "createspreadsheet"
Attribute VB_Base = "0{25B8A14C-B388-47A4-A413-225B52953397}{D8D701A4-E45E-4646-A913-5C89D89F3BC4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function EnableWindow Lib "user32" (ByVal hWnd As Long, ByVal bEnable As Long) As Long

Dim mlHWnd As Long, mbModal As Boolean, mbDragDrop As Boolean







Sub producelistofcells()
ReDim g_lookuptable(2, 64000)

On Error Resume Next
Set a = ActiveSheet.Columns("A").SpecialCells(xlConstants)

For Each l In a
    g_lookuptable(2, i) = Trim$(Format$(l.Row))
    g_lookuptable(1, i) = Trim$(l.Value)
    i = i + 1
Next
ReDim Preserve g_lookuptable(2, i - 1)
Call ShellSort(g_lookuptable())
genlookup1.ColumnCount = i
genlookup1.Column() = g_lookuptable
genlookup1.Visible = True
End Sub




Private Sub Cmdapply_Click()
'*** This routine applies the formula etc and then clears down the formula input.
If Trim$(genrow) = "" Then
    MsgBox "Please ensure that the row field is completed", 16
    Exit Sub
End If

If genfromcol = "" Or gentocol = "" Or gentocol = "0" Then
    If Trim$(gentitle) <> "" Then Range("a" & genrow) = gentitle
    If Trim$(genunits) <> "" Then Range("b" & genrow) = genunits
    If Trim$(gensource) <> "" Then Range("c" & genrow) = gensource
    Exit Sub
End If

firstcol = genfromcol & genrow
lastcol = Cells(Val(genrow), Asc(UCase(genfromcol)) - 64 + Val(gentocol) - 1).Address 'gentocol & genrow

If Trim$(genformula) <> "" Then
      If Trim$(gentocol) <> "" Then
          Range(firstcol, lastcol).Formula = Trim$(genformula)
      Else
          Range(firstcol).Formula = Trim$(genformula)
      End If
End If
        
If Trim$(gentitle) <> "" Then Range("a" & genrow) = gentitle
If Trim$(genunits) <> "" Then Range("b" & genrow) = genunits
If Trim$(gensource) <> "" Then Range("c" & genrow) = gensource



'*** Setup rows ***
If Trim$(gentocol) <> "" Then
    Range(firstcol, lastcol).Select
Else
    Range(firstcol).Select
End If
'GoTo endformatsection


If fmtautomatic Then
    automatic = True
    If Range(firstcol).HasFormula Then
      fmtcalculation = True
    Else
     fmtinput = True
    End If
End If
  
Set tmp = Selection
temp = "A" & genrow
temp1 = "C" & genrow

If Lineabove.Value = True Then
  With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
   
    Range(temp, temp1).Select
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
Else
       Range(temp, temp1).Select
       Selection.Borders(xlEdgeTop).LineStyle = xlNone
       tmp.Select
       Selection.Borders(xlEdgeTop).LineStyle = xlNone
End If
tmp.Select

If linebelow.Value = True Then
  With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    Range(temp, temp1).Select
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
Else
   Range(temp, temp1).Select
   Selection.Borders(xlEdgeBottom).LineStyle = xlNone
   tmp.Select
   Selection.Borders(xlEdgeBottom).LineStyle = xlNone
End If
tmp.Select

If fmtheading = True Then
    With Selection.Interior
        .Pattern = xlSolid
        .Color = fmtheading.BackColor
    End With
End If
 
If fmtnone = True Then
  With Selection.Interior
        .ColorIndex = xlNone
 End With
End If
 
' With Selection.Borders(xlEdgeTop)
'        .LineStyle = xlContinuous
'        .Weight = xlMedium
'        .ColorIndex = xlAutomatic
'  End With
'  With Selection.Borders(xlEdgeBottom)
'        .LineStyle = xlContinuous
'        .Weight = xlMedium
'        .ColorIndex = xlAutomatic
'  End With


If fmtinput = True Then
 With Selection.Interior
    .Pattern = xlSolid
    .Color = fmtinput.BackColor
 End With
End If

If fmtoutput = True Then
 With Selection.Interior
    .Pattern = xlSolid
    .Color = fmtoutput.BackColor
 End With
End If


If fmtcalculation = True Then
 With Selection.Interior
    .Pattern = xlSolid
    .Color = fmtcalculation.BackColor
 End With
End If

If fmtother = True Then
 With Selection.Interior
    .Pattern = xlSolid
    .Color = fmtother.BackColor
 End With
End If

Selection.NumberFormatLocal = createspreadsheet.currentformat.Caption

endformatsection:
'*** Reset variables
genrow = ""
genformula = ""
gentitle = ""
gensource = ""
'genlistofrows.Visible = False
If automatic = True Then fmtautomatic = True
End Sub



Private Sub CmdCancel_Click()
createspreadsheet.Hide
End Sub

Private Sub Cmdclear_Click()

genrow = ""
genfromcol = ""
gentocol = ""
gentitle = ""
genunits = ""
genformula = ""
gensource = ""
End Sub

Private Sub Cmdlookup_Click()
Call producelistofcells
End Sub



Private Sub Cmdoptions_Click()
bubbleoptions.Mpoptions.Value = 2
bubbleoptions.Show
fmtinput.BackColor = g_inputscolour
fmtcalculation.BackColor = g_calcscolour
fmtheading.BackColor = g_headingscolour
fmtoutput.BackColor = g_outputscolour
fmtother.BackColor = g_otherscolour
End Sub

Private Sub CmdHelp_Click()
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=3

End Sub

Private Sub CommandButton3_Click()
bubbleoptions.Show
End Sub

Private Sub fmtautomatic_Click()
formatlabel.Caption = "Automatic"
formatlabel.BackColor = fmtautomatic.BackColor
End Sub


Private Sub fmtcalculation_Click()
formatlabel.Caption = "Calculation"
formatlabel.BackColor = fmtcalculation.BackColor
End Sub

Private Sub fmtheading_Click()
formatlabel.Caption = "Heading"
formatlabel.BackColor = fmtheading.BackColor
End Sub

Private Sub fmtinput_Click()
formatlabel.Caption = "Input"
formatlabel.BackColor = fmtinput.BackColor
End Sub

Private Sub fmtnone_Click()
formatlabel.Caption = "None"
formatlabel.BackColor = fmtnone.BackColor
End Sub

Private Sub fmtother_Click()
formatlabel.Caption = "Other"
formatlabel.BackColor = fmtother.BackColor
End Sub

Private Sub fmtoutput_Click()
formatlabel.Caption = "Output"
formatlabel.BackColor = fmtoutput.BackColor
End Sub






Private Sub numberformat_Click()
'If Trim$(genrow) = "" Or Trim$(genfromcol) = "" Or Trim$(gentocol) = "" Then
'    MsgBox "Please ensure that the row and column fields are completed", 16
'    Exit Sub
'End If
    
'firstcol = genfromcol & genrow
'lastcol = gentocol & genrow
'Range(firstcol, lastcol).Select
Application.ScreenUpdating = False
Set actvesheet = ActiveSheet
ThisWorkbook.Worksheets("constants").Activate
Range("a1").Select
dlg = Application.Dialogs(xlDialogFormatNumber).Show
createspreadsheet.currentformat.Caption = ActiveCell.NumberFormatLocal
actvesheet.Activate
Application.ScreenUpdating = True
End Sub

Private Sub Cmdformat_Click()
If Frame5.Visible = True And Me.Height = 264 Then
    Frame5.Visible = False
    Frame2.Top = 154
    Frame2.Visible = True
    Exit Sub
End If

If Me.Height = 164 Then
    Me.Height = 264
    Frame5.Visible = False
    Frame2.Top = 154
    Frame2.Visible = True
    Exit Sub
End If

If Me.Height = 264 Then
    Me.Height = 164
End If

End Sub

Private Sub CommandButton2_Click()
Call producelistofcells
If Frame2.Visible = True And Me.Height = 264 Then
    Frame5.Visible = True
    Frame2.Top = 154
    Frame2.Visible = False
    Exit Sub
End If

If Me.Height = 164 Then
    Me.Height = 264
    Frame5.Visible = True
    Frame2.Top = 154
    Frame2.Visible = False
    Exit Sub
End If

If Me.Height = 264 Then
    Me.Height = 164
End If
End Sub

Private Sub genformula_Change()
Dim results$(3, 300)
Call parser(genformula, results$(), bits, True, True)
 b$ = ""
For i = 1 To bits
    b$ = b$ + results(2, i)
Next i
gentranslation = b$
End Sub

Private Sub genlookup1_Click()
rowno = genlookup1.ListIndex
genformula = genformula + Trim$(genfromcol) & Trim$(g_lookuptable(2, rowno))
genformula.SetFocus
End Sub





Private Sub genrow_Exit(ByVal Cancel As MSForms.ReturnBoolean)
If Trim$(genrow.Text) = "" Then Exit Sub
gentitle.Text = Range("A" & Format$(genrow.Text)).Value
genunits.Text = Range("B" & Format$(genrow.Text)).Value
gensource.Text = Range("C" & Format$(genrow.Text)).Value
If genfromcol <> "" Then
    genformula = Range(genfromcol & genrow).Formula
End If
End Sub

Private Sub genfromcol_Exit(ByVal Cancel As MSForms.ReturnBoolean)
If Trim$(genfromcol.Text) = "" Then Exit Sub
If genrow <> "" Then
    genformula = Range(genfromcol & genrow).Formula
End If

End Sub


Private Sub UserForm_Activate()
Me.Height = 164
'Find the Excel main window
mlHWnd = FindWindowA("XLMAIN", Application.Caption)

'Enable the Window - makes the userform modeless
EnableWindow mlHWnd, 1
'*** disable drag and drop
mbDragDrop = Application.CellDragAndDrop
Application.CellDragAndDrop = False
'*** Row labels must be in row A if using standard approach ***
bubbleoptions.rowlabelsspecified.Value = True
bubbleoptions.rowlabel.Text = "A"
Call readoptions
fmtheading.BackColor = bubbleoptions.Optheadings.BackColor
fmtinput.BackColor = bubbleoptions.Optinputs.BackColor
fmtoutput.BackColor = bubbleoptions.Optoutputs.BackColor
fmtother.BackColor = bubbleoptions.Optothers.BackColor
fmtcalculation.BackColor = bubbleoptions.Optcalculations.BackColor


Call producelistofcells

Set actveworksheet = ActiveSheet
Application.ScreenUpdating = False
ThisWorkbook.Worksheets("constants").Activate
Range("a1").Select
createspreadsheet.currentformat.Caption = ActiveCell.NumberFormatLocal
actveworksheet.Activate
Application.ScreenUpdating = True

genrow.Text = ""
genrow.SetFocus

If fmtheading = True Then formatlabel.Caption = "Heading": formatlabel.BackColor = fmtheading.BackColor
If fmtinput = True Then formatlabel.Caption = "Input": formatlabel.BackColor = fminput.BackColor
If fmtoutput = True Then formatlabel.Caption = "Output": formatlabel.BackColor = fmtoutput.BackColor
If fmtcalculatoin = True Then formatlabel.Caption = "Calculation": formatlabel.BackColor = fmtcalculation.BackColor
If fmtnone = True Then formatlabel.Caption = "None": formatlabel.BackColor = fmtheading.BackColor
If fmtautomatic = True Then formatlabel.Caption = "Automatic": formatlabel.BackColor = fmtautomatic.BackColor



End Sub


Private Sub UserForm_Deactivate()
Application.CellDragAndDrop = mbDragDrop
Application.OnDoubleClick = ""
End Sub
Attribute VB_Name = "docmod"


















Sub aboutdialog()
Attribute aboutdialog.VB_ProcData.VB_Invoke_Func = " \n14"
ThisWorkbook.DialogSheets("about dialog").Show
End Sub
Sub setupworkbook(a)
workbookname = ActiveWorkbook.Name
cnt = Application.Workbooks.Count
fnd = False
For i = 1 To cnt
    If Application.Workbooks(i).Name = a & ".xls" Then
        fnd = True
    End If
Next i


If fnd = True Then Exit Sub
    
'*** Need to add a workbook
Application.DisplayAlerts = False
Application.SheetsInNewWorkbook = 1
Dim newbook As Workbook

Set newbook = Workbooks.Add
With newbook
    .title = a
    .Subject = "Analysis of Spreadsheet"
    .SaveAs Filename:=a & ".xls"
End With
Application.DisplayAlerts = True
newbook.Activate

ActiveWindow.DisplayGridlines = False
With ActiveSheet
    .Name = "Cover sheet"
    .Cells(1, 2) = a
    .Cells(1, 2).Font.Size = 16
    .Cells(1, 2).Font.Bold = True
    
    
    .Cells(12, 1).Font.Size = 16
    .Cells(12, 1).Font.Bold = 16
    .Cells(12, 2).Font.Size = 16
    .Cells(12, 2).Font.Bold = 16
    .Cells(12, 1) = "Filename"
    .Cells(12, 2) = workbookname
    
    
    
    .Cells(44, 1) = "Produced by"
    .Cells(45, 1) = "Date "
   ' .Cells(45, 2) = FormatDateTime(Date$, 1)
    
    .Columns(1).ColumnWidth = .Columns(1).ColumnWidth * 2
    .Columns(2).ColumnWidth = .Columns(2).ColumnWidth * 2
    
    
    .PageSetup.LeftFooter = "Produced using WWW.spreadsheetinnovations.com"
    .PageSetup.FitToPagesWide = 1
    .PageSetup.FitToPagesTall = False
    .PageSetup.PrintGridlines = False

End With
    
End Sub
Sub startdocumentation()
Attribute startdocumentation.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo startdocumentation
'*** Sets up a work book to store the documentation produced.

Dim tempname As String
Dim i, sheetcounter
Dim dialogsht As Variant
Dim progresssht As Variant
Dim calcsheet As Variant
Dim calcmethod As Variant


'*** Get global data about size of worksheet being documented.
g_mname = Application.ActiveWorkbook.Name
g_msheets = ActiveWorkbook.Worksheets.Count

On Error Resume Next
Set g_selection = Selection
On Error GoTo startdocumentation
'*** Set up the status bar ***
Application.DisplayStatusBar = True
Application.StatusBar = "Initialising Spreadsheet Professional"
g_abort = False
'*** Call up the dialog sheet ***
Set g_dialogsht = ThisWorkbook.DialogSheets("reports dialog")
g_dialogsht.DialogFrame.Left = (Application.Width - g_dialogsht.DialogFrame.Width) / 2
g_dialogsht.DialogFrame.Top = (Application.Height - g_dialogsht.DialogFrame.Height) / 2
Application.StatusBar = "Select documentation options"
If g_year2000 = False Then g_dialogsht.Show
Application.StatusBar = "Initialising documentation file"
'*** Setup temporary display worksheet.
'Call reportsindicator
If g_abort = True Then Exit Sub
'*** Launch into the reports ***
Application.ScreenUpdating = False
Call readoptions
g_calcmethod = Application.Calculation

Application.Calculation = xlCalculationManual

'*** Run some checks on the sheets to be analysed.
'If g_dialogsht.CheckBoxes("uniquecellsonly").Value = xlOn Then
'    g_unique = True
'Else
'    g_unique = False
'End If


If g_dialogsht.OptionButtons("allsheets").Value = xlOn Then
    g_allsheets = True
End If

If g_dialogsht.OptionButtons("selectedsheets").Value = xlOn Then
    g_allsheets = False
End If
   
If g_dialogsht.OptionButtons("selectedarea").Value = xlOn Then
    g_allsheets = Null
End If

'*** Now we need to put in some checks on the sheets that are to be documented. ***
For Each win In Windows
    If win.WindowNumber > 1 Then
        MsgBox "The documentation generator requires that a maximum of one window on each workbook is open.  Close any windows which end in :2, :3 etc and then reselect the documentation generator from the S.P. menu.", 16, "Spreadsheet Professional"
        Exit Sub
    End If
Next

Select Case g_allsheets
    Case True
        For Each calcsheet In Workbooks(g_mname).Worksheets
            If calcsheet.UsedRange.Rows.Count > ThisWorkbook.Worksheets("constants").Range("b7") Then
                Call evalcopy
                Exit Sub
            End If
            
            If calcsheet.ProtectContents = True Then
                MsgBox "Spreadsheet Professional requires that each sheet to be analysed is unprotected.  Unprotect the sheets (select the protection option from the Tools menu) and then reselect the documentation generator from the S.P. menu.", 16, "Spreadsheet Professional"
                Exit Sub
            End If
            '*** change 11/7/03 added = 1 because excel xp has a version number 10
             If Left$(Application.Version, 1) >= "8" Or Left$(Application.Version, 1) = "1" Then
                If calcsheet.UsedRange.MergeCells Or IsNull(calcsheet.UsedRange.MergeCells) Then
                    response = MsgBox("There is a feature of Excel 97 and greater that causes Spreadsheet Professional to produce unreliable results when merged cells are contained within the spreadsheet.  Spreadsheet Professional will automatically unmerge the cells if you answer yes. (This question will be asked for each sheet that contains merged cells). Do you want to continue?", vbYesNo)
                    If response = 6 Then
                        calcsheet.UsedRange.UnMerge
                    Else
                        Exit Sub
                    End If
                End If
            End If
        Next
            
      
        
    Case Else
          
            For Each calcsheet In Windows(g_mname).SelectedSheets
            
                If calcsheet.UsedRange.Rows.Count > ThisWorkbook.Worksheets("constants").Range("b7") Then
                    Call evalcopy
                    Exit Sub
                End If
          
               
                If calcsheet.ProtectContents = True Then
                    MsgBox "Spreadsheet Professional requires that each sheet to be analysed is unprotected.  Unprotect the sheets (select the protection option from the Tools menu) and then reselect the documentation generator from the S.P. menu.", 16, "Spreadsheet Professional"
                    Exit Sub
                End If
                '*** change 11/7/2003
                If Left$(Application.Version, 1) >= "8" Or Left$(Application.Version, 1) = "1" Then
                    If calcsheet.UsedRange.MergeCells Or IsNull(calcsheet.UsedRange.MergeCells) Then
                        response = MsgBox("There is a feature of Excel 97 and greater that causes Spreadsheet Professional to produce unreliable results when merged cells are contained within the spreadsheet.  Spreadsheet Professional will automatically unmerge the cells if you answer yes. (This question will be asked for each sheet that contains merged cells). Do you want to continue?", vbYesNo)
                        If response = 6 Then
                            calcsheet.UsedRange.UnMerge
                        Else
                            Exit Sub
                        End If
                    End If
                End If
            
            Next
End Select


'*** Set up a workbook to take the data
Application.SheetsInNewWorkbook = 1
Workbooks.Add
g_dsheets = 1
g_dname = ActiveWorkbook.Name
ActiveSheet.Name = "Addl notes"
ActiveSheet.Cells(1, 1).Value = "Additional Notes"
ActiveWindow.DisplayGridlines = False
ActiveSheet.PageSetup.Orientation = xlPortrait
ActiveSheet.PageSetup.LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
ActiveSheet.PageSetup.RightFooter = Workbooks(g_mname).Name
ActiveSheet.PageSetup.CenterHeader = "&b&12Additional notes"
ActiveSheet.PageSetup.FitToPagesWide = 1
ActiveSheet.PageSetup.FitToPagesTall = False
ActiveSheet.PageSetup.PrintGridlines = False
    
If g_year2000 = False Then

If g_dialogsht.CheckBoxes("summry").Value = xlOn Then
    Call summary
End If

If g_dialogsht.CheckBoxes("rangenames").Value = xlOn Then
    Call rangenames
End If

If g_dialogsht.CheckBoxes("Maps").Value = xlOn Then
    Call map
End If

If g_dialogsht.CheckBoxes("Listings").Value = xlOn Then
    Call list
End If

If (g_dialogsht.CheckBoxes("blankinput").Value = xlOn) Then
   Call inputs(False)
End If

If (g_dialogsht.CheckBoxes("inputvalues").Value = xlOn) Then
    Call inputs(True)
End If

If (g_dialogsht.CheckBoxes("generaltests").Value = xlOn) Then
    Call general_tests
End If

If (g_dialogsht.CheckBoxes("tests").Value = xlOn) Then
    Call testsreport
End If

Else  '*** This is a year 2000 report.

Call testsreport

End If
'If (g_dialogsht.CheckBoxes("special").Value = xlOn) Then
'    Call tracer
    'Call special
'End If

'***
'*** Return all the parameters we may have changed to normal.
Application.ScreenUpdating = True
Application.StatusBar = False
Application.Calculation = g_calcmethod
Workbooks(g_dname).Worksheets(1).Activate

Exit Sub
startdocumentation:
Call errorhandler("Start documentation", Err)
Resume
End Sub

Sub general_tests()
Attribute general_tests.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo general_tests
Dim rowno
Dim rangeref As Variant
Dim z$
Application.StatusBar = "Producing General tests report (Press Esc to cancel)"
Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
g_dsheets = g_dsheets + 1
Workbooks(g_dname).Sheets(g_dsheets - 1).Activate

ActiveSheet.Name = "General tests"
ActiveWindow.DisplayGridlines = False
ActiveSheet.PageSetup.Orientation = xlPortrait
ActiveSheet.PageSetup.LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
ActiveSheet.PageSetup.RightFooter = Workbooks(g_mname).Name
ActiveSheet.PageSetup.CenterHeader = "&b&12General tests on " & Workbooks(g_mname).Name
ActiveSheet.PageSetup.FitToPagesWide = 1
ActiveSheet.PageSetup.FitToPagesTall = False
ActiveSheet.PageSetup.PrintGridlines = False

rowno = 2
If g_calcmethod = xlManual Then
    rowno = rowno + 1
    ActiveSheet.Cells(rowno, 1) = "Calculation method"
    ActiveSheet.Cells(rowno, 1).Font.Bold = True
    rowno = rowno + 1
    ActiveSheet.Cells(rowno, 1) = "The calculation method is set to manual.  Make sure that the spreadsheet"
    rowno = rowno + 1
    ActiveSheet.Cells(rowno, 1) = "is recalculated after changing the data and before printing out or"
    rowno = rowno + 1
    ActiveSheet.Cells(rowno, 1) = "analysing the results."
End If

If Not IsEmpty(Workbooks(g_mname).LinkSources()) Then
    rowno = rowno + 2
    ActiveSheet.Cells(rowno, 1) = "External links"
    ActiveSheet.Cells(rowno, 1).Font.Bold = True
    rowno = rowno + 1
    ActiveSheet.Cells(rowno, 1) = "This spreadsheet contains external links.  These must be updated"
    rowno = rowno + 1
    ActiveSheet.Cells(rowno, 1) = "before the final results are calculated to ensure consistent answers."
    rowno = rowno + 1
    ActiveSheet.Cells(rowno, 1) = "The external links are as follows:"
    For i = 1 To UBound(Workbooks(g_mname).LinkSources())
        rowno = rowno + 1
        Cells(rowno, 1) = Workbooks(g_mname).LinkSources(i)
    Next
End If

'*** Range name tests ***
found = False
If Workbooks(g_mname).Names.Count <> 0 Then
    For i = 1 To Workbooks(g_mname).Names.Count
        Form$ = Workbooks(g_mname).Names(i).RefersTo
        If (InStr(Form$, "$") = 0) Or (InStr(InStr(Form$, "$") + 1, Form$, "$") = 0) Then
          z$ = Mid$(Form$, 2)
          z$ = Mid$(z$, InStr(z$, "!") + 1)
          rangeref = Null
          On Error Resume Next
          Set rangeref = Evaluate(z$)
          On Error GoTo general_tests
            If IsObject(rangeref) Then
                If found = False Then
                    rowno = rowno + 2
                    ActiveSheet.Cells(rowno, 1) = "Relative range names."
                    ActiveSheet.Cells(rowno, 1).Font.Bold = True
                    rowno = rowno + 1
                    ActiveSheet.Cells(rowno, 1) = "The following names contain relative references.  The cells they refer to depends"
                    rowno = rowno + 1
                    ActiveSheet.Cells(rowno, 1) = "on where they are used. It is strongly recommended that only absolute names are used."
                    rowno = rowno + 1
                    ActiveSheet.Cells(rowno, 1) = "'" & Workbooks(g_mname).Names(i).Name & " " & Form$
                    found = True
                Else
                    rowno = rowno + 1
                    ActiveSheet.Cells(rowno, 1) = "'" & Workbooks(g_mname).Names(i).Name & " " & Form$
                End If
            End If
        End If
    Next i

    found = False
    For i = 1 To Workbooks(g_mname).Names.Count
        For j = i + 1 To Workbooks(g_mname).Names.Count
            Form$ = Workbooks(g_mname).Names(i).RefersTo
            form1$ = Workbooks(g_mname).Names(j).RefersTo
            If Form$ = form1$ Then
                 z$ = Mid$(Form$, 2)
                z$ = Mid$(z$, InStr(z$, "!") + 1)
                rangeref = Null
                On Error Resume Next
                Set rangeref = Evaluate(z$)
                On Error GoTo general_tests
                If IsObject(rangeref) Then
         
                    If found = False Then
                        rowno = rowno + 2
                        ActiveSheet.Cells(rowno, 1) = "Duplicate range names."
                        ActiveSheet.Cells(rowno, 1).Font.Bold = True
                        rowno = rowno + 1
                        ActiveSheet.Cells(rowno, 1) = "The following row names refer to the same range."
                        rowno = rowno + 1
                        ActiveSheet.Cells(rowno, 1) = "To avoid confusion it is recommended that one or other is deleted."
                        rowno = rowno + 1
                        ActiveSheet.Cells(rowno, 1) = "'" & Workbooks(g_mname).Names(i).Name & " & " & Workbooks(g_mname).Names(j).Name & " both refer to " & Form$
                        found = True
                    Else
                        rowno = rowno + 1
                        ActiveSheet.Cells(rowno, 1) = "'" & Workbooks(g_mname).Names(i).Name & " & " & Workbooks(g_mname).Names(j).Name & " both refer to " & Form$
                    End If
                End If
            End If
        Next j
    Next i
End If

If rowno = 2 Then
    ActiveSheet.Cells(rowno, 1) = "No general test errors discovered."
End If
Exit Sub
general_tests:
Call errorhandler("General tests", Err)
Resume
End Sub


Sub summary()
Attribute summary.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo summary
Dim shts As Variant

'*** This routine prints out the front summary sheet
If g_abort Then Exit Sub
Application.StatusBar = "Producing Summary Report. (Press Esc to cancel)"

Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
g_dsheets = g_dsheets + 1
ActiveSheet.Name = "Summary"
ActiveWindow.DisplayHeadings = False
ActiveWindow.DisplayGridlines = False

Columns(1).ColumnWidth = 17
Columns(1).Font.Bold = True
Columns(2).ColumnWidth = 50

Cells(3, 1).Value = "Filename "
Cells(4, 1).Value = "Last modified at"

Cells(6, 1).Value = "Author "
Cells(7, 1).Value = "Title"
Cells(8, 1).Value = "Subject"
Cells(9, 1).Value = "Comments"
Cells(11, 1).Value = "Instructions for use"
Cells(14, 1).Value = "List of sheets"
Cells(15, 1).Value = "Worksheet name"
Cells(15, 2).Value = "Description"
Cells(15, 2).Font.Bold = True


Cells(1, 2).Font.Bold = True
Cells(3, 2).Value = Workbooks(g_mname).Name
On Error Resume Next
Cells(4, 2).Value = "'" & FileDateTime(Workbooks(g_mname).Path & "\" & Workbooks(g_mname).Name)
Cells(6, 2).Value = Workbooks(g_mname).Author
Cells(7, 2).Value = Workbooks(g_mname).title
Cells(8, 2).Value = Workbooks(g_mname).Subject
Cells(9, 2).Value = Workbooks(g_mname).Comments
On Error GoTo summary
i = 15
For Each sht In Workbooks(g_mname).Sheets
    i = i + 1
    Cells(i, 1) = sht.Name
Next
'***  Setup the print settings.
With ActiveSheet.PageSetup
    .Orientation = xlPortrait
    .FitToPagesTall = 1
    .FitToPagesWide = 1
    .LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
    .CenterHeader = "&B&12Documentation for " & Workbooks(g_mname).Name
    .RightFooter = Workbooks(g_mname).Name
End With
Application.StatusBar = ""

Exit Sub
summary:
Call errorhandler("Summary ", Err)
Resume
End Sub

Sub special()
Attribute special.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo special
Dim shts As Variant
Dim reportsheet As Worksheet
Dim r As Variant
Dim s As Variant
Dim i As Integer, j As Integer, k As Integer
Dim results$(3, 300)
Dim temp$
'*** This routine prints out the front summary sheet
If g_abort Then Exit Sub


Application.StatusBar = "Producing Special Report. (Press Esc to cancel)"
Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
g_dsheets = g_dsheets + 1
ActiveSheet.Name = "Special"
Set reportsheet = ActiveSheet
ActiveWindow.DisplayHeadings = False
ActiveWindow.DisplayGridlines = False

'*** Get the selected cell ***
ActiveSheet.Cells(1, 1).Value = "'" & g_selection.Address
r = Null
j = 0
While IsObject(r) Or j < 1
    
    '*** reset the loop and get the values from the column
    i = 0
    j = j + 2
    no_inserts = 0
    r = Null
    On Error Resume Next
    Set r = ActiveSheet.Columns(j - 1).SpecialCells(xlConstants, xlTextValues)
    On Error GoTo special
    
    If IsObject(r) Then
        
        s = Null
        '*** For each row reference in the previous column
        For Each s In r
            
            i = 0
            no_inserts = 0
            k = refs_found
            t = Null
            On Error Resume Next
            Set t = g_selection.Worksheet.Range(s.Value)
            On Error GoTo special
            
            If IsObject(t) Then
                Call parser(t, results$(), bits, True, False)
                s.Value = s.Value & ":" & getname$(t)
                
                '*** For each element in the parsed reference
                For i = 0 To bits - 1
                    
                    '*** Test to see if range is on this sheet ***
                    If InStr(results$(1, i + 1), "!") = 0 Then
                        u = Null
                        
                        t.Worksheet.Activate
                        On Error Resume Next
                        Set u = Application.Range(results$(1, i + 1))
                        On Error GoTo special
                        reportsheet.Activate
                        '*** If it is a range reference
                        If IsObject(u) Then
                            
                            '*** document on the output sheet
                            Cells(s.Row + no_inserts + 1, j + 1).EntireRow.Insert
                            Cells(s.Row + no_inserts + 1, j + 1) = "'" & temp$
                            no_inserts = no_inserts + 1
                            temp$ = ""
                            For Each v In u
                                'MsgBox Str$(s.Row + no_inserts)
                                Cells(s.Row + no_inserts + 1, j + 1).EntireRow.Insert
                                Cells(s.Row + no_inserts + 1, j + 1) = "'   " & v.Address
                                Cells(s.Row + no_inserts + 1, j + 1).Font.Italic = True
                                no_inserts = no_inserts + 1
                                With ActiveSheet.Lines.Add(x1:=Cells(s.Row + refs_found + 1, j + 1).Left, y1:=Cells(s.Row + refs_found + 1, j + 1).Top - s.Height / 2, x2:=s.Left + s.Width, y2:=s.Top + s.Height / 2)
                                    .ArrowHeadStyle = xlOpen
                                End With
                                refs_found = refs_found + 1
                            Next
                        Else
                            '*** Its not a range reference on this or other sheets
                            temp$ = temp$ + results$(1, i + 1)
                        
                        End If
                    Else
                        'If it is a row reference to a different sheet then stop
                        Cells(s.Row + refs_found + 1, j + 1) = "'" & results$(1, i + 1)
                        Cells(s.Row + refs_found + 2, j + 1).EntireRow.Insert
                         With ActiveSheet.Lines.Add(x1:=Cells(s.Row + refs_found + 1, j + 1).Left, y1:=Cells(s.Row + k + 1, j + 1).Top - s.Height / 2, x2:=s.Left + s.Width, y2:=s.Top + s.Height / 2)
                            .ArrowHeadStyle = xlOpen
                        End With
                        refs_found = refs_found + 1
                    End If
                Next
                '*** Check to see if we have an input cell ***
                If refs_found = 0 Then
                    Cells(s.Row, j - 1).BorderAround LineStyle:=xlContinuous
                End If
            Cells(s.Row + no_inserts + 1, j + 1).EntireRow.Insert
            Cells(s.Row + no_inserts + 1, j + 1) = "'" & temp$
            no_inserts = no_inserts + 1
            temp$ = ""
            End If
          Next
    ActiveSheet.Columns(j + 1).AutoFit
    ActiveSheet.Columns(j - 1).AutoFit
    End If
Wend
'Set r = g_selection.DirectPreceden'ts
'i = 0
'For Each s In r
'    i = i + 1
'    Cells(i, 2) = "'" & s.Address
'Next
'***  Setup the print settings.
'With ActiveSheet.PageSetup
'    .Orientation = xlPortrait
'    .FitToPagesTall = 1
'    .FitToPagesWide = 1
 '   .LeftFooter = ThisWorkbook.Worksheets("constants").range("b5")
'    .CenterHeader = "&B&12Documentation for " & Workbooks(g_mname).Name
'    .RightFooter = Workbooks(g_mname).Name
'End With
Application.StatusBar = ""

Exit Sub
special:
Call errorhandler("Special ", Err)
Resume
End Sub




Sub rangenames()
Attribute rangenames.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo rangenames
'*** Lists all the ranges within a spreadsheet.
If g_abort Then Exit Sub
Dim i
Dim nm As Variant
Dim rangeref As Variant
Dim tempname$, ref$
'*** Activate the worksheet and setup sheet format.
Application.StatusBar = "Producing Range names report (Press Esc to cancel)"
Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
g_dsheets = g_dsheets + 1

tempname$ = "Range names in " & Workbooks(g_mname).Name
       
ActiveSheet.Name = Mid$(tempname$, 1, 30)

ActiveWindow.DisplayHeadings = False
ActiveWindow.DisplayGridlines = False

'***  Setup the print settings.

ActiveSheet.PageSetup.Orientation = xlPortrait
ActiveSheet.PageSetup.FitToPagesTall = 1
ActiveSheet.PageSetup.FitToPagesWide = 1
ActiveSheet.PageSetup.LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
ActiveSheet.PageSetup.CenterHeader = ""
ActiveSheet.PageSetup.RightFooter = Workbooks(g_mname).Name

Columns(1).ColumnWidth = 30
Columns(2).ColumnWidth = 30
Cells(1, 2).Value = "Range names and External Links"
Cells(1, 2).Font.Bold = True
Cells(3, 1).Value = "Range name"
Cells(3, 2).Value = "Refers to"
Cells(3, 1).Font.Bold = True
Cells(3, 2).Font.Bold = True

i = 4
For Each nm In Workbooks(g_mname).Names
    Let ref$ = Mid$(nm.RefersTo, 2)
    rangeref = Null
    On Error Resume Next
    If InStr(ref$, "!") <> 0 Then
        ref$ = Mid$(ref$, InStr(ref$, "!") + 1)
    End If
    Set rangeref = Evaluate(ref$)
    On Error GoTo rangenames
    If IsObject(rangeref) Then
        Cells(i, 1).Value = nm.Name
        Cells(i, 2).Value = "'" & Mid$(nm.RefersTo, 2)
        i = i + 1
    End If
Next

If i = 4 Then
    Cells(i, 1).Value = "There are no user defined names  used within this spreadsheet."
End If
i = i + 3
Cells(i, 1).Value = "External Links"
Cells(i, 1).Font.Bold = True

'Added to version 4.5 3/5/03 so only reports active links not all links created.
z = Workbooks(g_mname).LinkSources(xlExcelLinks)
If IsEmpty(z) Then
    Cells(i + 2, 1) = "There are no external links used within this spreadsheet"
Else
    For j = 1 To UBound(z)
        i = i + 1
        Cells(i, 1).Value = z(j)
    Next j
End If
Application.StatusBar = ""

Exit Sub
rangenames:
Call errorhandler("Range names ", Err)
Resume
End Sub

Sub list()
Attribute list.VB_ProcData.VB_Invoke_Func = " \n14"
'*** Produces a listing of all unique cells.
On Error GoTo list
If g_abort Then Exit Sub
Dim mwksht As Worksheet
Dim dwksht As Worksheet

Dim ur As Variant
Dim p As Variant
Dim c As Range
Dim i, j, k, counter, cols
Dim t As Range
Dim rnge As Range
Dim s As Variant
Dim m As Variant, col As Variant
Dim thesheet As Worksheet
ReDim results$(3, 300)
Dim n$, v$, bits
Dim p1 As Variant
Dim p2 As Variant
Dim p3 As Variant
Dim d As Variant, e As Object
Dim combined As Variant
Dim p2count As Long
Dim tempname$

For i = 1 To g_msheets
  '*** Decide whether to process sheet.
    Set g_mwksht = Workbooks(g_mname).Worksheets(i)
   
    ur = Null
    Select Case g_allsheets
    Case True
        Set ur = g_mwksht.UsedRange
    Case False
        For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
                Set ur = g_mwksht.UsedRange
            End If
        Next
    Case Else
          
          For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
               
                Set ur = g_selection
                
            End If
        Next
    End Select
 
   
   If IsObject(ur) Then
        '*** Activate the worksheet and setup sheet format.
        Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
        tempname$ = Workbooks(g_mname).Worksheets(i).Name & " Translation"
         If Len(Workbooks(g_mname).Worksheets(i).Name) > 28 Then tempname$ = "Sheet " + Str$(Workbooks(g_mname).Worksheets(i).Index) + " Translation"
        ActiveSheet.Name = Mid$(tempname$, 1, 30)
        Set dwksht = ActiveSheet
        g_dsheets = g_dsheets + 1
     
         
        dwksht.Columns(1).ColumnWidth = 6
        dwksht.Columns(1).VerticalAlignment = xlCenter
        dwksht.Columns(2).ColumnWidth = 20
        dwksht.Columns(2).VerticalAlignment = xlCenter
        dwksht.Columns(3).ColumnWidth = 70
        dwksht.Columns(3).VerticalAlignment = xlCenter
        dwksht.Columns(4).ColumnWidth = 10
        dwksht.Columns(4).VerticalAlignment = xlCenter
        
    
        ActiveWindow.DisplayGridlines = False
        dwksht.Rows(1).Borders(xlTop).LineStyle = xlContinuous
        dwksht.Rows(1).Borders(xlBottom).LineStyle = xlContinuous
        dwksht.Columns(1).Borders(xlLeft).LineStyle = xlContinuous
        dwksht.Columns(2).Borders(xlLeft).LineStyle = xlContinuous
        dwksht.Columns(3).Borders(xlLeft).LineStyle = xlContinuous
        dwksht.Columns(4).Borders(xlLeft).LineStyle = xlContinuous
        dwksht.Columns(4).Borders(xlRight).LineStyle = xlContinuous
        dwksht.Cells(1, 1).Value = "Ref"
        dwksht.Cells(1, 2).Value = "Label"
        dwksht.Cells(1, 3).Value = "Calculation"
        dwksht.Cells(1, 4).Value = "Result"
        
        '*** Get all the unique formulas ***
        counter = -1
     
        Application.StatusBar = "Producing translation of " & g_mwksht.Name & " (Press Esc to cancel)"
        Set t = ur
        cols = t.Columns.Count
        If cols = 1 Then
            MsgBox "Only one column in the spreadsheet.  It is impossible to produce a meaningful listing.  Aborting listing..."
            Application.StatusBar = ""
            Exit Sub
        End If
 
        '*** Now get each unique formula from the list contained in p.
         'Call get_unique_options(uniqueoption)
  
         Select Case g_uniqueoption
         Case c_horizontal
            Call uniqueformulas(c_horizontal, t, p)
         Case c_vertical
            Call uniqueformulas(c_vertical, t, p)
            
         
         Case c_both
            p = Null
            p1 = Null
            p2 = Null
            Call uniqueformulas(c_horizontal, t, p1)
            If IsObject(p1) Then
                For Each p2 In p1.Areas
                    p3 = Null
                    Call uniqueformulas(c_vertical, p2, p3)
                   
                    If IsObject(p3) Then
                        Application.StatusBar = "Analysing cells at " & p2.Address(rowabsolute:=False, columnabsolute:=False)
                        If IsObject(p) Then
                            Set p = Union(p, p3)
                        Else
                            Set p = p3
                        End If
                    End If
                Next
            End If
           
         End Select
        
         If IsObject(p) Then
            
         For Each c In p
            
            counter = counter + 3
            dwksht.Cells(counter + 1, 1) = c.Address(rowabsolute:=False, columnabsolute:=False)
            dwksht.Cells(counter + 1, 2) = getname(c)
            dwksht.Cells(counter + 1, 4) = c.Value
            '*** These two are used for sorting purposes later. ***
            dwksht.Cells(counter, 5).Value = c.Row
            dwksht.Cells(counter + 1, 5).Value = c.Row
            dwksht.Cells(counter + 2, 5).Value = c.Row
            dwksht.Cells(counter, 6).Value = c.Column
            dwksht.Cells(counter + 1, 6).Value = c.Column
            dwksht.Cells(counter + 2, 6).Value = c.Column

            '*** Now lets get all the directprecedents and replace them ***
            '*** All direct precedents are returned as absolute address ranges ***
            '*** Names are not returned as names.
            ReDim results$(3, 300)
            g_mwksht.Activate '*** Needed because otherwise Excel 5 does not pick up the correct ranges.
            Call parser(c, results$(), bits, True, False)
            dwksht.Activate
            n$ = "": v$ = "": r$ = ""
            For j = 1 To bits
                r$ = r$ + results$(1, j)
                n$ = n$ + results$(2, j)
                v$ = v$ + results$(3, j)
            Next j
            '*** All found so lets put it in the right cell
            dwksht.Cells(counter, 3).Value = "'" & r$
            dwksht.Cells(counter + 1, 3).Value = "'" & n$
            dwksht.Cells(counter + 2, 3).Value = "'" & v$
            dwksht.Range(Cells(counter, 1), Cells(counter + 2, 4)).BorderAround ColorIndex:=xlAutomatic
            Application.StatusBar = "Producing translation of " & g_mwksht.Name & " (Esc to Cancel) Cell " & c.Address(columnabsolute:=False, rowabsolute:=False)
        Next
        End If
    
'*** Now we need to sort the worksheet by the numbers hidden in columns 5 and 6
Application.StatusBar = "Producing translation of " & g_mwksht.Name & " Final formatting. (Esc to cancel)."
dwksht.Range(Cells(2, 1), Cells(counter + 2, 6)).Sort key1:=Cells(2, 5), key2:=Cells(2, 6)
dwksht.Columns(5).Clear
dwksht.Columns(6).Clear
dwksht.Rows.WrapText = True

With dwksht.PageSetup
    .Orientation = xlPortrait
    .Zoom = False
    .FitToPagesWide = 1
    .FitToPagesTall = False
    .PrintTitleRows = dwksht.Rows(1).Address
    .LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
    .CenterHeader = "&B&12Listing of " & g_mwksht.Name
    .RightFooter = Workbooks(g_mname).Name
End With

End If                      'If the worksheet contains anything.
Next i                      'Loop round worksheets.

Exit Sub:
list:
Call errorhandler("List", Err)
Resume
End Sub


Sub map()
Attribute map.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo map

'*** This routine produces a map of all the sheets in the workbook ***
If g_abort Then Exit Sub
Dim ur As Variant
Dim m As Variant
Dim p As Variant
Dim t As Range
Dim col As Range
Dim c As Variant
Dim d As Worksheet
Dim mwksht As Worksheet
Dim thesheet As Worksheet
Dim j As Long
Dim mcount As Long
Dim counter As Long
Dim start, mareas As Variant, res As Variant
Dim k, navkeys As Boolean
'Dim uniqueoption
Dim tempname$
Dim iter As Integer
Dim q As Variant, vert As Variant, horiz As Variant
ReDim f$(1)
Dim leftvalues As Variant, crossvalues As Variant, fvalues As Variant, upvalues As Variant

Dim i, cols
'*** Loop through each of the sheets
For i = 1 To g_msheets
   
    '*** Decide whether to process sheet.
    Set g_mwksht = Workbooks(g_mname).Worksheets(i)
   
    ur = Null
    Select Case g_allsheets
    Case True
        Set ur = g_mwksht.UsedRange
    Case False
        For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
                Set ur = g_mwksht.UsedRange
            End If
        Next
    Case Else
          
          For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
               
                Set ur = g_selection
                
            End If
        Next
    End Select
    
    If IsObject(ur) Then
        
        '*** Activate the worksheet and setup sheet format.
        Workbooks(g_dname).Activate
        Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
        g_dsheets = g_dsheets + 1
       
        tempname$ = Workbooks(g_mname).Worksheets(i).Name & " Map"
         If Len(Workbooks(g_mname).Worksheets(i).Name) > 28 Then tempname$ = "Sheet " + Str$(Workbooks(g_mname).Worksheets(i).Index) + " Map"
        ActiveSheet.Name = Mid$(tempname$, 1, 30)
        
        Set d = ActiveSheet
        d.Range(Columns("A"), Columns("IV")).ColumnWidth = 2 * 1.2
        ActiveWindow.DisplayGridlines = False
        
        Application.StatusBar = "Producing map of " & g_mwksht.Name & " (Press Esc to Cancel)"
       
        '***  Setup the print settings.
        With ActiveSheet.PageSetup
            .Orientation = xlPortrait
            .FitToPagesTall = 100
            .FitToPagesWide = 1
            .LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
            .CenterHeader = "&B&12Map of " & Workbooks(g_mname).Worksheets(i).Name
            .RightFooter = Workbooks(g_mname).Name
            .PrintHeadings = True
        End With
        
        '*** Set the navigation keys correctly.
        If Application.TransitionNavigKeys = True Then
            navkeys = True
            Application.TransitionNavigKeys = False
        Else
            navkeys = False
        End If
        
        '*** Find all the ranges containing numbers and transfer ***
        '*** Need to use a variant, if no cells found then it stays a variant
        '*** otherwise it is converted to an object that we can then test.
      
        m = Null
        Set t = ur
      
        Call getcells(t, xlConstants, xlNumbers, m)
                
                If IsObject(m) Then
                    Call getaddress(m, f$())
                    For j = 1 To UBound(f$, 1)
                        Set p = Range(f$(j))
                        p.Value = "'N"
                         Application.StatusBar = "Producing map. Analysing numbers at " & p.Areas(1).Address(rowabsolute:=False, columnabsolute:=False)
                   Next j
                End If
                
                m = Null
                Call getcells(t, xlConstants, xlTextValues, m)
              
                If IsObject(m) Then
                    'For Each p In m
                    '    iter = iter + 1
                    '    d.Cells(p.Row, p.Column).Value = "L"
                    '    If iter = 20 Then
                    '        Application.StatusBar = "Producing map. Analysing label at " & p.Address(rowabsolute:=False, columnabsolute:=False)
                    '        iter = 0
                    '    End If
                    'Next
                    Call getaddress(m, f$())
                    'q = Null
                    'For Each p In m.Areas
                    '    If IsObject(q) Then
                    '        Set q = Union(q, d.range(p.Address))
                    '    Else
                    '        Set q = d.range(p.Address)
                    '    End If
                       ' d.range(p.Address).Value = "L"
                    '    Application.StatusBar = "Producing map. Analysing labels at " & p.Address(rowabsolute:=False, columnabsolute:=False)
                    'Next
                    'q.Value = "L"
                    For j = 1 To UBound(f$, 1)
                        Set p = Range(f$(j))
                        p.Value = "L"
                        Application.StatusBar = "Producing map. Analysing label at " & p.Areas(1).Address(rowabsolute:=False, columnabsolute:=False)
                    Next j
                End If
                
               
                m = Null
                Application.StatusBar = "Identifying formulas"
                Call getcells(t, xlFormulas, 0, m)
                If IsObject(m) Then
                    Call getaddress(m, f$())
                    For j = 1 To UBound(f$, 1)
                        Set p = d.Range(f$(j))
                       p.Value = "+"
                    Next j
                    
                    Application.StatusBar = "Examining for horizontal copies"
                    'For Each mareas In m.Areas
                        Call uniqueformulas(c_horizontal, t, res)
                        If IsObject(res) Then
                            Call getaddress(res, f$())
                   ' Call uniqueformulas(c_horizontal, t, m)
                   ' If IsObject(m) Then
                   '     Call getaddress(m, f$())
                        For j = 1 To UBound(f$, 1)
                           Set p = d.Range(f$(j))
                            p.Value = "^"
                        Next j
                   End If
                   'Next
                
                    Application.StatusBar = "Examining for vertical copies"
                    For Each mareas In m.Areas
                    Application.StatusBar = "Examining rows for vertical copies at " & mareas(1).Address(rowabsolute:=False, columnabsolute:=False)
                    Call uniqueformulas(c_vertical, mareas, res)
                    If IsObject(res) Then
                        Call getaddress(res, f$())
                        For j = 1 To UBound(f$, 1)
                            Set p = d.Range(f$(j))
                            p.Replace what:="^", replacement:="F"
                            p.Replace what:="+", replacement:="<"
                        Next j
                    End If
                    Next
                
                
                End If
               
      If navkeys = True Then
        Application.TransitionNavigKeys = True
      End If
      End If
Next i

Exit Sub
map:
Call errorhandler("Map", Err)
Resume
End Sub



Sub inputs(showinputs)
Attribute inputs.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo inputs
If g_abort Then Exit Sub
Dim ur As Variant
Dim thecell As Variant
Dim p As Variant
Dim c As Variant
Dim d As Worksheet, thesheet As Worksheet, calcsheet As Worksheet
Dim dp As Variant, thedp As Variant
Dim i, j, lastrow, lastcol, first
Dim tocopy As Variant
Dim temp$
ReDim f$(1)
For Each calcsheet In Workbooks(g_mname).Worksheets
    
  
  '*** Decide whether to process sheet.
    Set g_mwksht = calcsheet
   
    ur = Null
    Select Case g_allsheets
    Case True
        Set ur = g_mwksht.UsedRange
    Case False
        For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
                Set ur = g_mwksht.UsedRange
            End If
        Next
    Case Else
          
          For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
               
                Set ur = g_selection
                
            End If
        Next
    End Select

If IsObject(ur) Then
    g_mwksht.Activate
    p = Null
    On Error Resume Next
    Call getcells(ur, xlConstants, xlNumbers, p)
    On Error GoTo inputs
       
    If IsObject(p) Then
    
    '*** Activate worksheet
    Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
    g_dsheets = g_dsheets + 1
    Workbooks(g_dname).Activate
    Set d = ActiveSheet
    If showinputs Then
        tempname$ = g_mwksht.Name & " Inputs"
        If Len(g_mwksht.Name) > 28 Then tempname$ = "Sheet " + Str$(g_mwksht.Index) + " Inputs"
        ActiveSheet.Name = Mid$(tempname$, 1, 30)
    Else
        tempname$ = g_mwksht.Name & " Blank form"
        If Len(g_mwksht.Name) > 28 Then tempname$ = "Sheet " + Str$(g_mwksht.Index) + " Blank form"
        ActiveSheet.Name = Mid$(tempname$, 1, 30)
    End If
        
   
       
    '*** Now set all cells to greyed.
   ' d.Range(g_mwksht.UsedRange.Address).Interior.Pattern = xlGray50
    ReDim a(80000) As Long
   
    z = 1
    For Each thecell In p.Areas
     
            thecell.Copy destination:=d.Cells(z, thecell.Column)
       
        For j = thecell.Row To thecell.Rows.Count + thecell.Row - 1
            a(z) = j
            z = z + 1
        Next j
       If showinputs = True Then
            Application.StatusBar = "Producing input report for " & g_mwksht.Name & " cell " & thecell.Address(rowabsolute:=False, columnabsolute:=False) & " (Esc to cancel)"
       Else
            Application.StatusBar = "Producing blank input form for " & g_mwksht.Name & " cell " & thecell.Address(rowabsolute:=False, columnabsolute:=False) & " (Esc to cancel)"
       End If
       
    Next

    Set c = d.Range("A:IV").SpecialCells(xlConstants)
    lastcol = c.SpecialCells(xlLastCell).Column
    If lastcol > 252 Then
        MsgBox "No room to insert columns for titles because data in column 252 or later"
        Exit Sub
    End If
    d.Columns(1).Insert
    d.Columns(1).Insert
    d.Columns(1).Insert
    d.Columns(1).Insert
    lastcol = lastcol + 4
 
    '*** Sort out the row headings
    temp1$ = g_colnames
    g_colnames = "none"
    c = Null
    For j = 1 To z - 1
       On Error Resume Next
       first = d.Rows(j).SpecialCells(xlConstants).Column - 4
        On Error GoTo inputs
        If first > 0 Then
            Set p = g_mwksht.Range(Cells(a(j), first).Address)
            d.Cells(j, 2).Value = getname$(p)
        End If
        d.Cells(j, 1).Value = Str$(a(j))
        d.Rows(j).Borders(xlBottom).LineStyle = xlContinuous
        Application.StatusBar = "Formatting input row " & Str$(a(j))
    Next
    g_colnames = temp1$
    
   '*** Now sort the used range so that the rows are all in order.
   d.UsedRange.Sort key1:=Range("a1")
   For j = z - 2 To 1 Step -1
    If d.Cells(j, 1).Value = d.Cells(j + 1, 1).Value Then
         Set tocopy = d.Rows(j + 1).SpecialCells(xlConstants)
         For Each thecell In tocopy.Areas
            thecell.Copy destination:=d.Cells(j, thecell.Column)
         Next
         d.Range(Cells(j + 1, 1), Cells(j + 1, 256)).Delete (xlUp)
   End If
   Next j
   Set tocopy = d.UsedRange.SpecialCells(xlBlanks)
   tocopy.Interior.Pattern = xlGray50
   d.Columns("C:D").Interior.Pattern = xlNone
    
    '*** set the top row characteristics.
    d.Rows(1).Insert
    d.Rows(1).Insert
    d.Rows("1:2").EntireRow.Font.Bold = True
    d.Rows("1:2").Borders(xlBottom).LineStyle = xlContinuous
    d.Rows("1:2").Borders(xlTop).LineStyle = xlContinuous
    d.Rows("1:2").HorizontalAlignment = xlCenter
    d.Rows("1:2").Interior.Pattern = xlNone
   
    

    '***Now sort out the column headings & delete blank columns***
    If showinputs = True Then
        Application.StatusBar = "Producing input report for " & g_mwksht.Name & " Final formatting. (Esc to cancel)"
    Else
        Application.StatusBar = "Producing blank input form for " & g_mwksht.Name & " Final formatting. (Esc to cancel)"
    End If
  
    For j = lastcol To 5 Step -1
        Application.StatusBar = "Formatting column headers " & Str$(j)
        p = Null
        On Error Resume Next
        Set p = d.Columns(j).SpecialCells(xlConstants)
        On Error GoTo inputs
        
        If IsObject(p) = False Then
            d.Columns(j).Delete
            lastcol = lastcol - 1
        Else
            temp$ = Columns(j - 4).Address(columnabsolute:=False)
            d.Cells(1, j) = Mid$(temp$, 1, InStr(temp$, ":") - 1)
            d.Columns(j).Borders(xlRight).LineStyle = xlContinuous
        End If
    
        If showinputs = False Then
            If IsObject(p) Then
                p.Value = String$(10, " ")
            End If
        End If
            
    Next j

    Application.StatusBar = "Final formatting of input report"
    d.Range(Columns(lastcol + 1), Columns(256)).Clear
    d.Cells(1, 1) = "Row"
    d.Cells(1, 2) = "Row label"
    d.Cells(1, 3) = "Units"
    d.Cells(1, 4) = "Source"
        
    If g_colnames <> "none" Then
        If IsEmpty(d.Cells(3, 1)) = False Then
            temp1$ = g_rownames
            g_rownames = "none"
            For j = 5 To lastcol
                d.Cells(2, j).Value = "'" & getname(g_mwksht.Cells(d.Cells(3, 1).Value, d.Cells(1, j).Value))
            Next j
            g_rownames = temp1$
        End If
    End If
    
    '*** Set column characteristics.
    d.Columns("A:B").EntireColumn.Font.Bold = True
    d.Columns("A:iv").EntireColumn.AutoFit
    d.Columns("A:D").Borders(xlRight).LineStyle = xlContinuous
    d.Columns("A").Borders(xlLeft).LineStyle = xlContinuous
   If Val(Left$(Application.Version, 1)) < 8# Then
    lastrow = d.Range(Cells(3, 1), Cells(16384, 1)).SpecialCells(xlConstants).Rows.Count + 3
    d.Rows(Str$(lastrow) & ":16384").Select
   Else
   lastrow = d.Range(Cells(3, 1), Cells(65536, 1)).SpecialCells(xlConstants).Rows.Count + 3
    d.Rows(Str$(lastrow) & ":65536").Select
   End If
   Selection.Clear
    '*** Setup print settings ***
    With d.PageSetup
        .Orientation = xlLandscape
        .LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
        .CenterHeader = "&B&12" & d.Name
        .RightFooter = Workbooks(g_mname).Name
        .PrintTitleColumns = d.Columns("A:D").Address
        .PrintTitleRows = d.Rows("1:2").Address
    End With
   
   '*** Windows characteristics.
    ActiveWindow.DisplayGridlines = False
    ActiveWindow.DisplayHeadings = False
    Cells(1, 1).Activate
End If
End If
Next

Exit Sub
inputs:
Call errorhandler("Inputs", Err)
Resume
End Sub

Sub inputs2(showinputs)
Attribute inputs2.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo inputs2
If g_abort Then Exit Sub
Dim ur As Variant
Dim thecell As Variant
Dim p As Variant
Dim q As Variant
Dim lne As Long
Dim c As Variant
Dim d As Worksheet, thesheet As Worksheet, calcsheet As Worksheet
Dim dp As Variant, thedp As Variant
Dim i, j, lastrow, lastcol, first
Dim temp$
ReDim f$(1)
For Each calcsheet In Workbooks(g_mname).Worksheets
    
   
    Set g_mwksht = calcsheet
   
    ur = Null
    Select Case g_allsheets
    Case True
        Set ur = g_mwksht.UsedRange
    Case False
        For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
                Set ur = g_mwksht.UsedRange
            End If
        Next
    Case Else
          
          For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
               
                Set ur = g_selection
                
            End If
        Next
    End Select

If IsObject(ur) Then
    g_mwksht.Activate
    p = Null
    On Error Resume Next
    Call getcells(ur, xlConstants, xlNumbers, p)
    On Error GoTo inputs2
       
    If IsObject(p) Then
    
    '*** Activate worksheet
    Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
    g_dsheets = g_dsheets + 1
    Workbooks(g_dname).Activate
    Set d = ActiveSheet
    If showinputs Then
        tempname$ = g_mwksht.Name & " Inputs"
        If Len(g_mwksht.Name) > 28 Then tempname$ = "Sheet " + Str$(g_mwksht.Index) + " Inputs"
        ActiveSheet.Name = Mid$(tempname$, 1, 30)
    Else
        tempname$ = g_mwksht.Name & " Blank form"
        If Len(g_mwksht.Name) > 28 Then tempname$ = "Sheet " + Str$(g_mwksht.Index) + " Blank form"
        ActiveSheet.Name = Mid$(tempname$, 1, 30)
    End If
        
   
       
    '*** Now set all cells to greyed.
    d.Range(g_mwksht.UsedRange.Address).Interior.Pattern = xlGray50
                If IsObject(p) Then
                    Call getaddress(p, f$())
                    For j = 1 To UBound(f$, 1)
                        Set q = Range(f$(j))
                        If showinputs = False Then
                            q.Value = String$(8, " ")
                            q.Interior.Pattern = xlNone
                        Else
                            For Each thecell In p.Areas
                                thecell.Copy destination:=d.Cells(thecell.Row, thecell.Column)
                                q.Interior.Pattern = xlNone
                            Next
                        End If
                         Application.StatusBar = "Producing input sheet. Analysing numbers at " & p.Areas(1).Address(rowabsolute:=False, columnabsolute:=False)
                   Next j
                End If
   
    
    '*** Put in row numbers where applicable ***
    lastrow = d.UsedRange.SpecialCells(xlLastCell).Row
    For lne = 1 To lastrow
        Call getcells(d.Range(Cells(lne, 2), Cells(lne, 256)), xlConstants, 0, q)
        If IsObject(q) = True Then
          d.Cells(lne, 1).Value = Format$(lne)
        End If
    Next lne
     For lne = lastrow To 1 Step -1
        Call getcells(d.Range(Cells(lne, 2), Cells(lne, 256)), xlConstants, 0, q)
        If IsObject(q) = False Then
          d.Range(Cells(lne, 1), Cells(lne, 256)).Delete (xlUp)
        End If
    Next lne

  
  
    d.Columns(2).Insert
    d.Columns(2).Insert
    d.Columns(2).Insert
    d.Columns(2).Insert
    d.Columns("A:E").Interior.Pattern = xlNone
    lastcol = lastcol + 4

    '*** Sort out the row headings
    temp1$ = g_colnames
    g_colnames = "none"
    c = Null
    lastrow = d.UsedRange.SpecialCells(xlLastCell).Row
    For j = 1 To lastrow
        Set p = g_mwksht.Cells(d.Cells(j, 1).Value, 255)
        d.Cells(j, 2).Value = "'" & getname$(p)
        d.Rows(j).Borders(xlBottom).LineStyle = xlContinuous
        Application.StatusBar = "Formatting input row " & d.Cells(j, 1).Value
    Next j
    

  
    '*** set the top row characteristics.
    d.Rows(1).Insert
    d.Rows(1).Insert
    d.Rows("1:2").EntireRow.Font.Bold = True
    d.Rows("1:2").Borders(xlBottom).LineStyle = xlContinuous
    d.Rows("1:2").Borders(xlTop).LineStyle = xlContinuous
    d.Rows("1:2").HorizontalAlignment = xlCenter
    d.Rows("1:2").Interior.Pattern = xlNone
   
    '***Now sort out the column headings & delete blank columns***
    lastcol = d.UsedRange.SpecialCells(xlLastCell).Column
    If showinputs = True Then
        Application.StatusBar = "Producing input report for " & g_mwksht.Name & " Final formatting. (Esc to cancel)"
    Else
        Application.StatusBar = "Producing blank input form for " & g_mwksht.Name & " Final formatting. (Esc to cancel)"
    End If

    For j = lastcol To 5 Step -1
        Application.StatusBar = "Formatting column headers " & Str$(j)
        p = Null
        On Error Resume Next
        Set p = d.Columns(j).SpecialCells(xlConstants)
        On Error GoTo inputs2
        
        If IsObject(p) = False Then
            d.Columns(j).Delete
            lastcol = lastcol - 1
        Else
            temp$ = Columns(j - 4).Address(columnabsolute:=False)
            d.Cells(1, j) = Mid$(temp$, 1, InStr(temp$, ":") - 1)
            d.Columns(j).Borders(xlRight).LineStyle = xlContinuous
        End If
    
        If showinputs = False Then
            If IsObject(p) Then
                p.Value = String$(10, " ")
            End If
        End If
            
    Next j
  
    Application.StatusBar = "Final formatting of input report"
    d.Range(Columns(lastcol + 1), Columns(256)).Clear
    d.Cells(1, 1) = "Row"
    d.Cells(1, 2) = "Row label"
    d.Cells(1, 3) = "Units"
    d.Cells(1, 4) = "Source"
     
    g_colnames = temp1$
    If g_colnames <> "none" Then

        If IsEmpty(d.Cells(3, 1)) = False Then
        
            temp1$ = g_rownames
            g_rownames = "none"
            For j = 5 To lastcol
                'MsgBox d.Cells(3, 1).Value & " " & d.Cells(1, j).Value
                d.Cells(2, j).Value = "'" & getname(g_mwksht.Cells(d.Cells(3, 1).Value, d.Cells(1, j).Value))
            Next j
            g_rownames = temp1$
        End If
    End If
    '*** Set column characteristics.
    d.Columns("A:B").EntireColumn.Font.Bold = True
    d.Columns("A:iv").EntireColumn.AutoFit
    d.Columns("A:D").Borders(xlRight).LineStyle = xlContinuous
    d.Columns("A").Borders(xlLeft).LineStyle = xlContinuous
    '*** Setup print settings ***
    With d.PageSetup
        .Orientation = xlLandscape
        .LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
        .CenterHeader = "&B&12" & d.Name
        .RightFooter = Workbooks(g_mname).Name
        .PrintTitleColumns = d.Columns("A:D").Address
        .PrintTitleRows = d.Rows("1:2").Address
    End With
   
   '*** Windows characteristics.
    ActiveWindow.DisplayGridlines = False
    ActiveWindow.DisplayHeadings = False
    Cells(1, 1).Activate
End If
End If
Next

Exit Sub
inputs2:
Call errorhandler("Inputs 2", Err)
Resume
End Sub

Sub testsreport()
Attribute testsreport.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo testsreport
If g_abort Then Exit Sub

Dim ur As Variant
Dim thesheet As Variant
Dim i As Variant, k As Integer
Dim l As Integer
Dim firstcolumn As Integer, lastcolumn As Integer, firstrow As Integer, lastrow As Integer
Dim j As Variant, z
Dim d As Worksheet
Dim c As Variant, e As Object, f As Object, oldc As Variant
Dim dd As Variant, dp As Variant
Dim errors As Integer
ReDim finder(50) As Integer
'*** Basic housekeeping ***
Application.ScreenUpdating = False


'Call get_unique_options(g_copy)

'*** Loop through each of the sheets
For i = 1 To g_msheets
    Call readoptions
    '*** Decide whether to process sheet.
    Set g_mwksht = Workbooks(g_mname).Worksheets(i)
   
 
    ur = Null
    Select Case g_allsheets
    Case True
        Set ur = g_mwksht.UsedRange
    Case False
        For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
                Set ur = g_mwksht.UsedRange
            End If
        Next
    Case Else
          
          For Each thesheet In Windows(g_mname).SelectedSheets
            If thesheet.Name = g_mwksht.Name Then
               
                Set ur = g_selection
                
            End If
        Next
    End Select
   


If IsObject(ur) Then
        
'*** Redimension the error reports.
ReDim g_err(28)
        
'Call setuptests



'*** Now lets loop through each of the tests ***
'*** First lets test the numeric cells to ensure that they are all referenced.
oldc = Null
c = Null
On Error Resume Next
g_mwksht.Activate

up = Null
g_no_unique = 0
Call getcells(ur, xlConstants, xlNumbers, up)

If IsObject(up) Then
    For Each c In up.Areas
        If g_unique Then
            Select Case g_uniqueoption
            Case c_horizontal
                firstrow = c.Row
                lastrow = c.Rows.Count + c.Row - 1
                firstcolumn = c.Column
                lastcolumn = firstcolumn
            Case c_vertical
                firstrow = c.Row
                lastrow = firstrow
                firstcolumn = c.Column
                lastcolumn = c.Column + c.Columns.Count - 1
            Case c_both
                firstrow = c.Row
                lastrow = firstrow
                firstcolumn = c.Column
                lastcolumn = c.Column
            End Select
        Else
            '*** Test every numeric cell in the range.
            firstrow = c.Row
            lastrow = c.Row + c.Rows.Count - 1
            firstcolumn = c.Column
            lastcolumn = c.Column + c.Columns.Count - 1
        End If
        
        For l = firstrow To lastrow
            For j = firstcolumn To lastcolumn
                Set c = g_mwksht.Cells(l, j)
                Application.StatusBar = "Test report for " & g_mwksht.Name & " Checking input at " & c.Address(rowabsolute:=False, columnabsolute:=False)
                Call testinputs(c, finder(), errors)
                For k = 1 To errors
                    Call adderror(d, c, finder(k))
                Next k
            Next j
        Next l
    Next
End If

'*** Now test each formula

up = Null
g_unanalysed = Null
Call getcells(ur, xlFormulas, 0, up)
If IsObject(up) Then
     
     If g_unique Then
        '*** Discovering whether it is unique or not.
        For Each dd In up.Areas
            tmp = Null
            Select Case g_uniqueoption
        
                Case c_horizontal
                Call uniqueformulas(c_horizontal, dd, tmp)
                Case c_vertical
                Call uniqueformulas(c_vertical, dd, tmp)
                Case c_both
                
                tmp1 = Null
                tmp2 = Null
                Call uniqueformulas(c_horizontal, dd, tmp1)
              
                If IsObject(tmp1) Then
                    For Each tmp2 In tmp1.Areas
                       
                        tmp3 = Null
                        Call uniqueformulas(c_vertical, tmp2, tmp3)
                           
                        If IsObject(tmp3) Then
                           
                          ' Application.StatusBar = "Selecting unique formulas at " & tmp2.Address(rowabsolute:=False, columnabsolute:=False)
                            If IsObject(tmp) Then
                                Set tmp = Union(tmp, tmp3)
                            Else
                                Set tmp = tmp3
                            End If
                        End If
                    Next
                End If
            
                'If (IsObject(tmp1) = False) And (IsObject(tmp2) = False) Then tmp = Null
                'If (IsObject(tmp1) = False) And (IsObject(tmp2) = True) Then tmp = Null
                'If (IsObject(tmp1) = True) And (IsObject(tmp2) = False) Then tmp = Null
                'If (IsObject(tmp1) = True) And (IsObject(tmp2) = True) Then
                '    tmp = Null
                   ' If tmp1.Count > tmp2.Count Then
                   '     Set tmp = tmp1
                   '     Set tmp1 = tmp2
                   '     Set tmp2 = tmp
                   ' End If
                    'tmp = Null
                    'For Each c In tmp2
                    '    If tmp1.Count = Union(c, tmp1).Count Then
                            '*** it appears in both therefore is really unique
                    '        If IsObject(tmp) Then
                    '            Set tmp = Union(tmp, c)
                    '        Else
                    '            Set tmp = c
                    '        End If
                    '    End If
                    'Next
                    'On Error Resume Next
                    'For Each c In tmp1
                    '    For Each f In tmp2.Areas
                    '        Set e = Intersect(c, f)
                    '        If IsNull(e) Then
                    '        Else
                    '            If IsObject(tmp) Then
                    '                Set tmp = Union(tmp, e)
                    '            Else
                    '                Set tmp = e
                    '            End If
                    '            Exit For
                    '        End If
                    '    Next
                    'Next
                    'On Error GoTo testsreport
                'End If
            End Select
        
            If IsObject(tmp) = True Then
                For Each c In tmp
                    '*** Now apply the tests one by one ***
                    Application.StatusBar = "Test report for " & g_mwksht.Name & " Checking calculation at " & c.Address(rowabsolute:=False, columnabsolute:=False)
                    g_no_unique = g_no_unique + 1
                    Call testformulas(c, finder(), errors)
                    For j = 1 To errors
                        Call adderror(d, c, finder(j))
                    Next j
                Next
            End If
        Next
    Else
          '*** Now apply the tests one by one ***
        For Each c In up
            Application.StatusBar = "Test report for " & g_mwksht.Name & " Checking calculation at " & c.Address(rowabsolute:=False, columnabsolute:=False)
            g_no_unique = g_no_unique + 1
            Call testformulas(c, finder(), errors)
            For j = 1 To errors
                Call adderror(d, c, finder(j))
            Next j
        Next
    End If
End If
'*** The next two commands refer to whether to check the next sheet or not.
'*** As the review of this sheet has been completed, let us produce a neat errors report.
Call makeerrorsreport(d)
End If
Next i

Exit Sub
testsreport:
Call errorhandler("Tests report ", Err)
Resume
End Sub

Sub makeerrorsreport(sht)
Attribute makeerrorsreport.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo makeerrorsreport:
'*** This subroutine makes an attractive error report.
Dim rep As Worksheet
Dim i As Integer
Dim lineno, j, k
Dim b As String * 7
Dim a As String
Dim t As Range, p As Variant, p1 As Variant, p2 As Variant
Dim tempname$

'*** Activate the worksheet and setup sheet format.
Workbooks(g_dname).Sheets.Add before:=Workbooks(g_dname).Worksheets("Addl notes")
g_dsheets = g_dsheets + 1
Workbooks(g_dname).Sheets(g_dsheets - 1).Activate
tempname$ = g_mwksht.Name & "-Errors"
If Len(g_mwksht.Name) > 28 Then tempname$ = "Sheet " + Str$(Workbooks(g_mname).Worksheets(g_mwksht.Name).Index) + "-Errors"
ActiveSheet.Name = Mid$(tempname$, 1, 30)
Set rep = ActiveSheet
Application.StatusBar = "Formatting test report for sheet " & g_mwksht.Name & " (Esc to cancel)"
'*** Set up summary page ***
ActiveWindow.DisplayGridlines = False
With ActiveSheet.PageSetup
    .PrintGridlines = False
    .Orientation = xlPortrait
    .LeftFooter = ThisWorkbook.Worksheets("constants").Range("b5")
    .CenterHeader = "&B&12Potential errors on " & g_mwksht.Name
    .RightFooter = Workbooks(g_mname).Name
End With

j = 3
Columns(1).ColumnWidth = 25
Cells(j, 1).Value = "Summary statistics"
Cells(j, 1).Font.Bold = True
Cells(j, 1).Font.Size = 12
j = j + 1
Cells(j, 1).Value = "Range analysed"
Cells(j, 1).Font.Bold = True
If (g_allsheets = True) Or (g_allsheets = False) Then
    Cells(j, 2) = "'" & g_mwksht.UsedRange.Address(rowabsolute:=False, columnabsolute:=False)
Else
    Cells(j, 2) = "'" & g_selection.Address(rowabsolute:=False, columnabsolute:=False)
End If
Cells(j, 2).HorizontalAlignment = xlRight

j = j + 1
Cells(j, 1).Value = "Number of numeric inputs"
Cells(j, 1).Font.Bold = True
If (g_allsheets = True) Or (g_allsheets = False) Then
    Call getcells(g_mwksht.UsedRange, xlConstants, xlNumbers, d)
Else
    Call getcells(g_selection, xlConstants, xlNumbers, d)
End If
If IsObject(d) Then
    Cells(j, 2) = d.Count
Else
    Cells(j, 2).Value = 0
End If

j = j + 1
Cells(j, 1).Value = "Number of formulas"
Cells(j, 1).Font.Bold = True
If (g_allsheets = True) Or (g_allsheets = False) Then
    Call getcells(g_mwksht.UsedRange, xlFormulas, 0, d)
Else
    Call getcells(g_selection, xlFormulas, 0, d)
End If

If IsObject(d) Then
    Cells(j, 2) = d.Count
Else
    Cells(j, 2).Value = 0
End If

If g_unique = True Then
     '*** Now get each unique formula from the list contained in p.
     '???
    j = j + 1
    Cells(j, 1).Value = "Number of unique formulas"
    Cells(j, 1).Font.Bold = True

    Set t = g_mwksht.UsedRange
    Application.StatusBar = "Formatting the test report.  Counting the unique formulas."
    Select Case g_uniqueoption
    Case c_horizontal
        Cells(j + 1, 1).Value = "Unique cells are those that are not copies of the cell to their left."
    Case c_vertical
        Cells(j + 1, 1).Value = "Unique cells are those that are not copies of the cell above."
    Case c_both
        Cells(j + 1, 1).Value = "Unique cells are those that are not copies of the cell to the left or above."
    End Select

    Cells(j, 2).Value = g_no_unique
    j = j + 2

    Cells(j, 1).Value = "Percentage of unique formulas "
    Cells(j, 1).Font.Bold = True
    If Cells(j - 2, 2).Value <> 0 Then
        Cells(j, 2) = Format(Cells(j - 2, 2).Value / Cells(j - 3, 2).Value, "##0%")
    End If
End If

j = j + 1
Cells(j, 1).Value = "Number of labels"
Cells(j, 1).Font.Bold = True
If (g_allsheets = True) Or (g_allsheets = False) Then
    Call getcells(g_mwksht.UsedRange, xlConstants, xlTextValues, d)
Else
    Call getcells(g_selection, xlConstants, xlTextValues, d)
End If

If IsObject(d) Then
    Cells(j, 2) = d.Count
Else
    Cells(j, 2).Value = 0
End If

j = j + 2
Cells(j, 1).Value = "Potential errors summary"
Cells(j, 1).Font.Bold = True
Cells(j, 1).Font.Size = 12


j = j + 1
Cells(j, 1).Value = "Possible error condition"
Cells(j, 1).Font.Bold = True
Cells(j, 2).Value = "Frequency"
Cells(j, 2).Font.Bold = True

For i = 1 To 28
    If g_rules(i).number > 0 Then
        j = j + 1
        rep.Cells(j, 1) = g_rules(i).title
        rep.Cells(j, 2) = g_rules(i).number
    End If
Next i

j = j + 2
If g_mwksht.ProtectContents = False Then
    j = j + 1
    rep.Cells(j, 1) = "Protection not enabled."
    rep.Cells(j, 1).Font.Bold = True
    j = j + 1
    rep.Cells(j, 1) = "This sheet is not protected.  Users can overwrite the "
    j = j + 1
    rep.Cells(j, 1) = "contents of any cell even if the cell is locked."
End If

If g_mwksht.TransitionExpEval = True Then
    j = j + 1
    rep.Cells(j, 1) = "Lotus evaluation rules"
    rep.Cells(j, 1).Font.Bold = True
    j = j + 1
    rep.Cells(j, 1) = "Lotus 1-2-3 expression evaluation rules are being used"
    j = j + 1
    rep.Cells(j, 1) = "for this sheet."
End If

If g_mwksht.TransitionFormEntry = True Then
    j = j + 1
    rep.Cells(j, 1) = "Lotus formula entry rules"
    rep.Cells(j, 1).Font.Bold = True
    j = j + 1
    rep.Cells(j, 1) = "Lotus 1-2-3 formula entry rules are being used"
    j = j + 1
    rep.Cells(j, 1) = "for this sheet."
End If

rep.Rows(j + 1).PageBreak = xlManual

'*** Set up details pages ***
j = j + 1
Cells(j, 1).Value = "Test notes."
Cells(j, 1).Font.Bold = True

If g_unique Then
    j = j + 1
    Cells(j, 1).Value = "Only unique cells have been tested. "
    j = j + 1
    Cells(j, 1).Value = "Remember to check cells that are a copy of the cells shown on this report."
    j = j + 1
End If

If g_firstcellonly = True Then
    j = j + 1
    Cells(j, 1).Value = "Only the first cell in each range referenced by a formula has been tested."
    j = j + 1
End If
lineno = j

For i = 1 To 28
    If g_rules(i).number > 0 Then
     
        lineno = lineno + 1
        With rep.Cells(lineno, 1)
            .ColumnWidth = 60
            .Value = g_rules(i).title
            .Font.Bold = True
            .HorizontalAlignment = xlCenter
        End With
    
        lineno = lineno + 1
        Cells(lineno, 1) = g_rules(i).expl & " Potential errors to watch for:"
        Cells(lineno, 1).ColumnWidth = 60
        Cells(lineno, 1).WrapText = True
        
    
       
        For k = 1 To 5
            If g_rules(i).Err(k) <> "" Then
                lineno = lineno + 1
                Cells(lineno, 1).Value = g_rules(i).Err(k)
                Cells(lineno, 1).ColumnWidth = 60
                Cells(lineno, 1).WrapText = True
            End If
        Next k
        
        '*** Add cell references.
        a = ""
  
        For Each r In g_err(i).Areas
            If a <> "" Then a = a + ", "
            a = a + r.Address(rowabsolute:=False, columnabsolute:=False)
            If Len(a) > 66 Then
                lineno = lineno + 1
                rep.Cells(lineno, 1).Value = a
                a = ""
            End If
        Next
     
        If a <> "" Then
            lineno = lineno + 1
            rep.Cells(lineno, 1).Value = a
        End If
        lineno = lineno + 1
    End If
Next i

If IsObject(g_unanalysed) = True Then
    rep.Cells(lineno, 1).Value = "The following cells were too complex to analyse."
    lineno = lineno + 1
    rep.Cells(lineno, 1).Value = "They must be checked by hand."
    lineno = lineno + 1
    rep.Cells(lineno, 1).Value = g_unanalysed.Address(rowabsolute:=False, columnabsolute:=False)
    lineno = lineno + 1
End If

If lineno = j Then
    rep.Cells(lineno, 1).Value = "No cells with potential error conditions discovered."
    lineno = lineno + 1
End If

Exit Sub
makeerrorsreport:
Call errorhandler("Make errors report", Err)
Resume
End Sub

Public Sub setupstandardformat()
ActiveSheet.Range("A1").Value = "Row title"
ActiveSheet.Range("B1").Value = "Units"
ActiveSheet.Range("c1").Value = "Source"

 Columns("A:C").Select
    With Selection.Interior
        .Color = createspreadsheet.fmtheading.BackColor
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
    End With
    Columns("A:C").Select
   
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
   
  
    Range("A2").Select
    With ActiveWindow
        .SplitColumn = 0
        .SplitRow = 0
    End With
    With ActiveWindow
        .SplitColumn = 0
        .SplitRow = 1
    End With


End Sub

Attribute VB_Name = "evaluationform"
Attribute VB_Base = "0{98C426A2-5B2E-4E26-B60D-6CBC59B8A3F6}{B1FCA265-61EE-4F98-B971-9B420A87982E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private Sub CommandButton1_Click()
Unload evaluationform

End Sub

Attribute VB_Name = "mainmod"

'|fffd| Spreadsheet Innovations 1995 All Rights Reserved
'This the main code module for a Spreadsheet Professional add-in.
'*** Code first started 21/11/94.

Option Explicit
DefInt A-Z

Type rule
     number As Integer '*** Used to show how many found
     used As Integer   '*** Used to indicate whether rule should be used
     title As String    '*** The title of the rule
     expl As String    '*** The explanation of the rule
     Err(5) As String     '*** First potential error condition
End Type
    
Public g_rules() As rule
Public g_unanalysed As Variant
'*** Shared variables go in here.
Public g_mname As Variant       '*** Holds the current workbook name.
Public g_mwksht As Worksheet    '*** Holds the current worksheet object.
Public g_msheets                '*** Holds the number of sheets in it.

Public g_dname As Variant       '*** Holds the name of the documentation workbook.
Public g_dsheets                '*** Holds the number of sheets in it.

Public g_cititle As String       '*** Title of the cell inspector window.
Public g_ciworkbook As Object    '*** Reference to the cell inspector workbook
Public g_ciheight As Integer     '*** Standard height of window.

Public g_awtitle As String      '*** Title from which called.
Public g_dialogsht As Variant   '*** Holds the dialog sheet object
Public g_allsheets As Variant   '*** Holds whether all sheets to be analysed or just the selected ones.

Public g_rownames As String     '*** row translation method
Public g_colnames As String     '*** column translation method

Public g_rule As Integer
Public g_abort As Integer
Public g_unique As Integer
Public g_firstcellonly As Integer
Public g_copy As Integer       '*** Holds variable explaining whether copies are from left or above etc.
Public g_comp1 As Variant      '*** comparison sheets.
Public g_comp2 As Variant
Public g_compw1 As Variant      '*** Comparison workbook names.
Public g_compw2 As Variant

Public g_err() As Variant       '*** holds list of errors

Public g_startcol              '*** Where the error checking started from
Public g_startrow
Public g_continuecell As Variant '*** The cell to continue from.
Public g_count As Integer        '*** Holds the value of the rule being displayed in the cell checker
Public g_finder() As Integer    '*** Holds the rule numbers of each error found
Public g_errors As Integer      '*** Holds the number of errors found
Public g_ctname As Variant      '*** Holds the name of the cell translator
Public g_no_unique              '*** Holds the number of unique cells.
Public g_selection As Variant   '*** Holds selected area for reports.
Public g_year2000 As Variant    '*** Holds whether the year 2000 report is calling startdocumentation or not."
Public g_calcmethod             '*** Contains the calculation method before it is changed to manual.


'*** Constants for producing bubble diagrams
Public g_showbubblevalues       '*** Shows bubble values
Public g_showbubblenames
Public g_showbubbleformulas
Public g_bubbledecimalplaces    '*** Number of decimal places
Public g_noredraw               '*** Flag to prevent rewriting


'*** Public variables for spreadsheet builder
Public g_lookuptable() As Variant     '*** Table to lookup row/number selections


'*** Public variables for the sensitivity analysis
Public g_sensitivityrow                 '*** To hold the start of the analysis sheet
Public g_firstsensitivityrow             '*** So that all analyses can be deleted


'*** Used for creating bubble diagrams
Public g_nme As Variant

'*** Public variables for maps and other options
Public g_uniqueoption                   '*** Holds whether unique formulas are up, to the left or both
Public Const c_horizontal = 1
Public Const c_vertical = 2
Public Const c_both = 3

'*** Public variables for painter and formating
Public g_calcscolour As Single
Public g_inputscolour As Single
Public g_headingscolour As Single
Public g_otherscolour As Single
Public g_outputscolour As Single

Sub ShellSort(a() As Variant)

'
' Very fast sort: 2n Log n comparisons
'
' Calling convention:
'   Redim A(1 To 20) as Integer
'   ShellSort A()
'
Dim i As Integer, j As Integer, Low As Integer, Hi As Integer
Dim temp1 As Variant, temp2 As Variant
  Low = LBound(a, 2)
  Hi = UBound(a, 2)
  j = (Hi - Low + 1) \ 2
  Do While j > 0
    For i = Low To Hi - j
      If a(1, i) > a(1, i + j) Then
        temp1 = a(1, i)
        temp2 = a(2, i)
        a(1, i) = a(1, i + j)
        a(2, i) = a(2, i + j)
        a(1, i + j) = temp1
        a(2, i + j) = temp2
      End If
    Next i
    For i = Hi - j To Low Step -1
      If a(1, i) > a(1, i + j) Then
        temp1 = a(1, i)
        temp2 = a(2, i)
        a(1, i) = a(1, i + j)
        a(2, i) = a(2, i + j)
        a(1, i + j) = temp1
        a(2, i + j) = temp2
      End If
    Next i
    j = j \ 2
  Loop
End Sub

Sub showsensitivity()
sensitivitytool.Show
End Sub
Sub startstandardreports()
standardreports.Show
End Sub

Sub getaddress(m As Variant, f$())
Attribute getaddress.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo getaddress
'*** The address function only returns 256 characters or less.  The maximum
'*** length of a string to be added is 9.  Therefore if more than 230 characters
'*** make it up area by area to be sure.
Dim z As Variant
Dim temp As String
ReDim f$(1)
temp = m.Address
If Len(temp) > 230 Then
    temp = ""
    For Each z In m.Areas
        temp = temp + z.Address + ","
        If Len(temp) > 230 Then
            f$(UBound(f$)) = Mid$(temp, 1, Len(temp) - 1)
            ReDim Preserve f$(UBound(f$, 1) + 1)
            temp = ""
        End If
    Next
Else
    f$(1) = temp
    Exit Sub
End If
If Len(temp) > 0 Then
    f$(UBound(f$, 1)) = Mid$(temp, 1, Len(temp) - 1)
Else
    '*** Hit lucky, ended on the last one
    ReDim Preserve f$(UBound(f$, 1) - 1)
End If
Exit Sub
getaddress:
Call errorhandler("Get address", Err)
Resume
End Sub
    


Sub parser(c As Variant, results() As String, bits As Variant, translate, stringpassed)
Attribute parser.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo parser
Dim t As String
Dim temp As String, rangeref As Variant
Dim i As Integer, nextquotes As Integer

bits = 0

If stringpassed Then GoTo stringstart
If c.HasFormula = False Then
    bits = 2
    results(1, 1) = "="
    results(2, 1) = ""
    results(3, 1) = ""
    
    results(1, 2) = "Input"
    results(2, 2) = ""
    results(3, 2) = ""
    Exit Sub
End If

On Error GoTo specialerror
t = c.Formula
On Error GoTo parser

stringstart:
If stringpassed Then t = c
bits = 0

For i = 1 To Len(t)
    
    Select Case Mid$(t, i, 1)
    
    Case Chr$(34) 'There is a string here go on to its end
        nextquotes = InStr(i + 1, t, Chr$(34))
        If nextquotes <> 0 Then
            bits = bits + 1
            results$(1, bits) = Mid$(t, i, nextquotes - i + 1)
            results$(2, bits) = results$(1, bits)
            results$(3, bits) = results$(1, bits)
            i = nextquotes
        Else
            bits = bits + 1
            results$(1, bits) = Mid$(t, i)
            results$(2, bits) = results$(1, bits)
            results$(3, bits) = results$(1, bits)
            i = Len(t)
        End If
    
    Case "'"
        nextquotes = InStr(i + 1, t, "'")
        If nextquotes <> 0 Then
            temp = temp + Mid$(t, i, nextquotes - i + 1)
            i = nextquotes
        Else
            temp = temp + Mid$(t, i)
            i = Len(t)
        End If
    
    Case "%", "+", "-", "*", "/", ",", "&", "^", "(", ")", "{", "}", "=", ";", " ", "<", ">" 'These are all separators ***
        If Len(temp) <> 0 Then
            bits = bits + 1
            results(1, bits) = temp
            If translate = True Then
                rangeref = Null
                On Error Resume Next
                If InStr(temp, "!") = 0 Then
                  If stringpassed Then
                    Set rangeref = ActiveSheet.Range(temp)
                  Else
                    Set rangeref = c.Worksheet.Range(temp)
                  End If
                Else
                    Set rangeref = Range(temp)
                End If
                On Error GoTo parser
            
                If IsObject(rangeref) Then
                    If rangeref.Count > 1 Then
                        results(2, bits) = getname(rangeref(1)) + ":" + getname(rangeref(rangeref.Count))
                        results(3, bits) = getvalue(rangeref(1)) + ":" + getvalue(rangeref(rangeref.Count))
                    Else
                        results(2, bits) = getname(rangeref)
                        results(3, bits) = getvalue(rangeref)
                    End If
                Else
                    results(2, bits) = temp
                    results(3, bits) = temp
                End If
            End If
        temp = ""
        End If
        bits = bits + 1
        results(1, bits) = Mid$(t, i, 1)
        results(2, bits) = Mid$(t, i, 1)
        results(3, bits) = Mid$(t, i, 1)
    
    Case Else
        temp = temp + Mid$(t, i, 1)
    End Select

Next i
                    
If Len(temp) <> 0 Then
    bits = bits + 1
    results(1, bits) = temp
    
    If translate = True Then
        rangeref = Null
        On Error Resume Next
        If InStr(temp, "!") = 0 Then
            If stringpassed Then
                Set rangeref = ActiveSheet.Range(temp)
            Else
                Set rangeref = c.Worksheet.Range(temp)
            End If
        Else
            Set rangeref = Range(temp)
        End If
        On Error GoTo parser
                       
        If IsObject(rangeref) Then
           results(2, bits) = getname(rangeref)
           results(3, bits) = getvalue(rangeref)
        Else
            results(2, bits) = temp
            results(3, bits) = temp
        End If
    End If
    temp = ""
End If
Exit Sub
parser:
Call errorhandler("Parser", Err)
Resume

specialerror:
 bits = 2
    results(1, 1) = "="
    results(2, 1) = ""
    results(3, 1) = ""
    
    results(1, 2) = "Too long to translate."
    results(2, 2) = ""
    results(3, 2) = ""
End Sub



Sub uniqueformulas(verthoriz, r As Variant, p As Variant)
Attribute uniqueformulas.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo uniqueformulas
'*** This routine gets all the unique formulas in r and returns them in p
'*** Both r and p are ranges.  If p is empty it is returned as a null variable.
Dim col As Variant
Dim cols As Variant
Dim m As Variant
Dim t As String
Dim j As Variant
Dim rw As Variant, rws As Variant
'*** Now we have to sort out which formulas are unique ***

If verthoriz = c_horizontal Then
    m = Null
    p = Null
    cols = r.Columns.Count
    For j = r.Column To r.Column + cols - 1
        
        If j = 1 Then
           Call getcells(r.Columns(1), xlFormulas, 0, m)
            
            If IsObject(m) Then
                Set p = m
            End If
        Else
            col = Null
            Set m = r.Worksheet.Range(Cells(r.Row, j - 1).Address, Cells(r.Row + r.Rows.Count - 1, j).Address)
       
            On Error Resume Next
            Set col = m.RowDifferences(r.Worksheet.Cells(r.Row, j - 1))
            On Error GoTo uniqueformulas
           
            If IsObject(col) Then
                Call getcells(col, xlFormulas, 0, m)
                If IsObject(m) Then
                    If IsObject(p) Then
                        Set p = Union(p, m)
                    Else
                        Set p = m
                    End If
                End If
            End If
        End If
    Next j
End If

If verthoriz = c_vertical Then

    p = Null
    rws = r.Rows.Count

    m = Null
    p = Null
    For j = r.Row To r.Row + rws - 1
        If j = 1 Then
            Call getcells(r.Rows(1), xlFormulas, 0, m)
            If IsObject(m) Then
                Set p = m
            End If
        
        Else
    
            rw = Null
            Set m = r.Worksheet.Range(Cells(j - 1, r.Column).Address, Cells(j, r.Column + r.Columns.Count - 1).Address)
       
            On Error Resume Next
            Set rw = m.ColumnDifferences(r.Worksheet.Cells(j - 1, r.Column))
            On Error GoTo uniqueformulas
        
            If IsObject(rw) Then
                Call getcells(rw, xlFormulas, 0, m)
                If IsObject(m) Then
                    If IsObject(p) Then
                        Set p = Union(p, m)
                    Else
                        Set p = m
                    End If
                End If
            End If
        End If
    Next j
End If

Exit Sub
uniqueformulas:
Call errorhandler("Unique formulas", Err)
Resume
End Sub

Function getvalue$(rnge As Variant)
Attribute getvalue.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo getvalue
Dim schar As String, frmt As String, sresult As String
'Dim frmt As Variant
'This function returns the value in the range as a string.

Dim temp As Variant
temp = rnge.Value
If IsEmpty(temp) Then
    temp = "undefined"
End If
                        
If IsArray(temp) Then
    temp = "Range of values"
End If
                        
If IsError(temp) Then
   temp = CInt(temp)
   
   Select Case temp
   Case xlErrDiv0
   temp = "#DIV/0!"
   Case xlErrNA
   temp = "#N/A"
   Case xlErrName
   temp = "#NAME?"
   Case xlErrNull
   temp = "#NULL!"
   Case xlErrNum
   temp = "#NUM!"
   Case xlErrRef
   temp = "#REF!"
   Case xlErrValue
   temp = "#VALUE!"
   End Select
End If
                        
If IsNumeric(temp) Then
   ' On Error GoTo nogoodformat
    frmt = rnge.NumberFormatLocal
   sresult = sortoutformat(frmt)
    'While frmt <> ""
    '    schar = Left(frmt, 1)
    '    If InStr(1, "_", schar) = 0 Then
    '        sresult = sresult & schar
    '        frmt = Mid(frmt, 2)
    '    Else
    '        If Len(frmt) > 2 Then
    '            frmt = Mid(frmt, 3)
    '        Else
    '            frmt = ""
    '        End If
    '    End If
    'Wend
   'If TypeName(temp) = "Boolean" Then 'i.e. a logical
   '     temp = Format$(temp, "General Number")
   'Else
   '    If sresult = "General" Then sresult = "General Number"
      
        'temp = Format$(temp, sresult)
   'End If
    
    'GoTo endofnumeric
'nogoodformat:
temp = Format$(temp, sresult)
   
endofnumeric:
On Error GoTo getvalue
End If
getvalue$ = temp

Exit Function
getvalue:
Call errorhandler("Get value", Err)
Resume
End Function
                        
Function getname$(rnge As Variant)
Attribute getname.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo getname
'*** This function returns the name.
Dim rowrnge As Range
Dim labelrnge As Variant
Dim lr As Range
Dim col As Integer
Dim cellcol As Integer
Dim cellrow As Integer, rw As Integer
Dim colrnge As Variant
Dim foundcol, diff
Dim label As Range
Dim temp As Range
Dim i As Integer
Dim t As Range
getname$ = ""


Select Case g_rownames

    Case "auto" '*** Automatic
    cellrow = rnge.Row
    cellcol = rnge.Column
    Set rowrnge = rnge.EntireRow
    'For i = cellcol - 1 To 1 Step -1
    '    Set t = rnge.Worksheet.range(cellrow, i)
    '    If VarType(t.Value) = 8 Then
    '
    '        getname$ = t.Value
    '        i = 1
    '    End If
    'Next i
    labelrnge = Null
    Call getcells(rowrnge, xlConstants, xlTextValues, labelrnge)
    If IsObject(labelrnge) Then
        diff = 30000
        For Each lr In labelrnge
            col = lr.Column
            If (cellcol - col < diff) And (cellcol - col >= 0) Then
                diff = cellcol - col
                Set label = lr
            End If
        Next
        If diff <> 30000 Then
            getname$ = getvalue(label)
        Else
            getname$ = "undefined"
        End If
    Else
        getname$ = "undefined"
    End If

    Case "none"
        getname$ = ""
    Case Else
        getname$ = getvalue(rnge.Worksheet.Range(Cells(rnge.Row, UCase$(Trim$(g_rownames))).Address))
End Select

Select Case g_colnames

    Case "auto" '*** Automatic
    
    cellrow = rnge.Row
    Set colrnge = rnge.EntireColumn
    
    labelrnge = Null
    Call getcells(colrnge, xlConstants, xlTextValues, labelrnge)
   
    If IsObject(labelrnge) Then
        diff = 30000
        For Each lr In labelrnge
            rw = lr.Row
            If (cellrow - rw < diff) And (cellrow - rw >= 0) Then
                diff = cellrow - rw
                Set label = lr
            End If
        Next
        If diff <> 30000 Then
            getname$ = getname$ & "." & getvalue(label)
        Else
            getname$ = getname$ & "." & "undefined"
        End If
    Else
        getname$ = getname$ & "." & "undefined"
    End If

    Case "none"
        getname$ = getname$
    Case Else
        'Application.Goto (rnge)
        getname$ = getname$ & "." & getvalue(rnge.Worksheet.Range(Cells(Val(g_colnames), rnge.Column).Address))
       'Application.Goto (Application.PreviousSelections(1))
End Select

If Left$(getname$, 1) = "." Then getname$ = Mid$(getname$, 2)
Exit Function
getname:
'This picks up the case where a ref is to a macro sheet.
getname$ = "undefined"
'Call errorhandler("Get name", Err)
'Resume
End Function
                
Sub errorhandler(a$, b)
Attribute errorhandler.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo errorhandler
Err = 0
Dim response
If b = 18 Then
    response = MsgBox("User pressed Escape. Exiting routine", 48, "Spreadsheet Professional")
    Application.StatusBar = ""
    End
Else
    MsgBox "An unexpected error has occured in " & a$ & Chr$(10) & Chr$(10) & "The error is: " & Chr$(10) & Chr$(10) & Error(b) & Chr$(10), 16, "Spreadsheet Professional"
    Application.StatusBar = ""
    End
End If
Exit Sub
errorhandler:
MsgBox (" Ending exit routine ")
End
End Sub

Sub getcells(rnge As Variant, firstarg As Variant, secondarg As Variant, returnedvalue As Variant)
Attribute getcells.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo getcells
'*** This function uses the specialcells function to return a range of
'*** variables.  Because it is so kludgy it is put in its own routine
'*** complete with error traps.
'*** The first and second arguments are as for the special cells function.
'*** If the second function is 0 then it  is not used.
'*** The returned value must be a variant.
'*** This captures the fact that if no cells are returned an error is called.

Dim getcells As Variant

getcells = Null
'*** If only one cell is passed to this function then it returns all the occurances
'*** within the spreadsheet.
'The easiest way round this is to add a cell.  Strictly it should be taken out again.
'*** This assumes iv15000 is blank.
'MsgBox rnge.Count

If rnge.Count = 1 Then
  
    Set rnge = Union(rnge, rnge.Worksheet.Cells(16383, 256))
End If

If secondarg <> 0 Then
    On Error Resume Next
    Set getcells = rnge.SpecialCells(firstarg, secondarg)
    On Error GoTo getcells
Else
    On Error Resume Next
    Set getcells = rnge.SpecialCells(firstarg)
    On Error GoTo getcells
End If

If IsObject(getcells) = True Then
    Set returnedvalue = getcells
Else
    returnedvalue = Null
End If

Exit Sub
getcells:
Call errorhandler("Get cells", Err)
Resume
End Sub

Sub optionsshow()
bubbleoptions.Mpoptions.Value = 0
bubbleoptions.Show
End Sub
Sub testformulas(c As Variant, f() As Integer, errors As Variant)
Attribute testformulas.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo testformulas
'*** Checking to see whether the formula is used elsewhere or not.
Dim dd As Variant, j
Dim dp As Variant, temp$
Dim t$, bits, olddd As Variant
Dim tmp As Variant
Dim tmp1 As Variant
ReDim results$(3, 300)
ReDim found(28)
Dim d As Variant
Dim i, item As Variant
Dim foundreference As Integer
Dim prec As Variant
Dim rnge As Variant
Dim s As Variant

For j = 1 To 28: found(j) = False: Next
errors = 0
'For i = 1 To 25
'    MsgBox g_rules(i).used
'Next i
'*** Check the dependents of the cell ***
'If (g_rules(2).used = True) Or (g_rules(17).used = True) Then
'    dd = Null
'    On Error Resume Next
'    Set dd = c.DirectDependents
 '   On Error GoTo testformulas
'End If

'*** No dependents, therefore an unused cell.
'*** This checks to see whether version 8 or greater is being used because there is a bug in it

If g_rules(2).used = True And (Val(Trim$(Application.Version)) < 8# Or Val(Trim$(Application.Version)) >= 9#) Then
    
    dd = Null
    On Error Resume Next
    Set dd = c.DirectDependents
    On Error GoTo testformulas
    If IsObject(dd) = False Then
        c.Activate
        c.ShowDependents
        c.NavigateArrow False, 1
        c.ShowDependents Remove:=True
        Set d = ActiveCell
        Application.Goto reference:=c
        If d.Address(external:=True) = c.Address(external:=True) Then
            errors = errors + 1
            f(errors) = 2
        End If
    End If
    'If IsObject(dd) = False Then
    '    errors = errors + 1
    '    f(errors) = 2
    'End If
End If

'*** Pattern of dependents test.
If (g_rules(17).used = True) And (g_unique = False) Then
  If IsObject(dd) = True Then
       tmp = Null
       Call uniqueformulas(c_horizontal, c, tmp)
      
        If IsObject(tmp) = False Then
            olddd = Null
            On Error Resume Next
            Set olddd = c.Offset(0, -1).DirectDependents
            On Error GoTo testformulas
            If IsObject(olddd) Then
                If dd.Count <> olddd.Count Then
                        errors = errors + 1
                        f(errors) = 17
                End If
            End If
        End If
    End If
End If



'*** Checking the contents of the cell ***
Call parser(c, results$(), bits, False, False)

foundreference = False
For i = 1 To bits
    
    '*** See if the object is a reference.
    dp = Null
    On Error Resume Next
    Set dp = Range(results$(1, i))
    On Error GoTo testformulas
    
    If IsObject(dp) Then
        foundreference = True
        If InStr(results$(1, i), "]") <> 0 Then
            '*** An external reference has been found
            If (g_rules(25).used = True) And (found(25) = False) Then
                found(25) = True
                errors = errors + 1
                f(errors) = 25
                dp = Null
            End If
        End If
    End If
    
    If IsObject(dp) Then
        '*** We need to first test that this isn't part of a range reference.
        If dp.Count > 1 Then
            If g_firstcellonly = False Then
            Else
                '*** Cumbersome way of getting first cell in range.
                For Each s In dp
                    Set dp = s
                    Exit For
                Next
            End If
        End If
    End If
        
    If IsObject(dp) Then
        For Each s In dp
            'MsgBox s.Address
            '*** Lets analyse the contents of each one.
            Select Case VarType(s.Value)
        
            Case 0, 1 '*** Is empty or null
            If g_rules(4).used = True Then
                If found(4) = False Then
                    found(4) = True
                    errors = errors + 1
                    f(errors) = 4
                End If
            End If
            
            Case 2, 3, 4, 5 '*** Is an integer, short or long
            If g_rules(27).used = True Then
                If s.Value = Int(s.Value) And s.Value > 9 And s.Value < 100 Then
                    If found(27) = False Then
                        found(27) = True
                        errors = errors + 1
                        f(errors) = 27
                    End If
                End If
            End If
            
            If g_rules(28).used = True Then
                If s.Value = 99 Then
                    If found(28) = False Then
                        found(28) = True
                        errors = errors + 1
                        f(errors) = 28
                    End If
                End If
            End If
                
            
            Case 7 '*** Is a date reference
            If g_rules(26).used = True Then
                If found(26) = False Then
                    found(26) = True
                    errors = errors + 1
                    f(errors) = 26
                End If
            End If
            
        
            Case 10 '*** Is an error
            If g_rules(5).used = True Then
                If found(5) = False Then
                    found(5) = True
                    errors = errors + 1
                    f(errors) = 5
                End If
            End If
        
            Case 8 '*** References a string
            If g_rules(6).used = True Then
                If found(6) = False Then
                    If VarType(c.Value) <> 8 Then
                        found(6) = True
                        errors = errors + 1
                        f(errors) = 6
                    End If
                End If
            End If
        
            Case Else '*** Must be a non numeric
        
            End Select
    
            If g_rules(7).used = True Then
            '*** Checking for forward row references
                If ((s.Row > c.Row) And (found(7) = False)) Then
                    found(7) = True
                    errors = errors + 1
                    f(errors) = 7
                End If
            End If
     
            If g_rules(8).used = True Then
            '*** Checking for forward column references
                If ((s.Column > c.Column) And (found(8) = False)) Then
                    found(8) = True
                    errors = errors + 1
                    f(errors) = 8
                End If
            End If
        
            If g_rules(9).used = True Then
                '*** Checking for hidden precedents
                If ((s.FormulaHidden = True And s.HasFormula) Or (s.EntireRow.Hidden = True) Or (s.EntireColumn.Hidden = True)) And (found(9) = False) Then
                    found(9) = True
                    errors = errors + 1
                    f(errors) = 9
                End If
            End If
        Next
    End If
   ' End If
    
    '*** Now check each bit to see whether it is a numeric or not.
    If g_rules(16).used = True Then
        If (IsNumeric(results$(1, i)) = True) And (found(16) = False) Then
            Select Case results$(1, i)
            Case "%", "+", "-", "*", "/", ",", "&", "^", "(", ")", "{", "}", "=", ":", ";", " ", "<", ">"
                '*** Note some separators can be evaluated as numbers.  To play safe all are excluded here.
            Case Else
                found(16) = True
                errors = errors + 1
                f(errors) = 16
            End Select
        End If
    End If
   
Next i

'*** Measure the complexity of the rule
If g_rules(18).used = True Then
    If bits > 15 Then
        found(18) = True
        errors = errors + 1
        f(errors) = 18
    End If
End If

'*** See if it is referenced ***
If foundreference = False Then
    If g_rules(3).used = True Then
        
        '*** Picks up formulas of the form =sum(10:10)
        prec = Null
        On Error Resume Next
        Set prec = c.DirectPrecedents
        On Error GoTo testformulas
        
        If IsObject(prec) = False Then
            errors = errors + 1
            f(errors) = 3
        End If
    End If
End If

'*** See whether protection has been set.
If g_rules(19).used = True Then
    If c.Locked = False Then
        found(19) = True
        errors = errors + 1
        f(errors) = 19
    End If
End If
'*** Now check the contents ***
t$ = ""
On Error GoTo specialtestformulas
'*** Sometimes if a very long formula this bombs out.
t$ = c.FormulaLocal
On Error GoTo testformulas

If g_rules(10).used = True Then
    If InStr(t$, "NPV(") Then
        found(10) = True
        errors = errors + 1
        f(errors) = 10
    End If
End If
        
If g_rules(11).used = True Then
    If InStr(t$, "VLOOKUP(") <> 0 Then
        found(11) = True
        errors = errors + 1
        f(errors) = 11
    End If
End If

If g_rules(12).used = True Then
    If InStr(t$, "HLOOKUP(") <> 0 Then
        found(12) = True
        errors = errors + 1
        f(errors) = 12
    End If
End If

If g_rules(13).used = True Then
    If InStr(t$, "LOOKUP(") <> 0 Then
        temp$ = Mid$(t$, InStr(t$, "LOOKUP(") - 1, 1)
        If (temp$ <> "H") And (temp$ <> "V") Then
            found(13) = True
            errors = errors + 1
            f(errors) = 13
        End If
    End If
End If

If g_rules(14).used = True Then
    If InStr(t$, "IF(") <> 0 Then
        found(14) = True
        errors = errors + 1
        f(errors) = 14
    End If
End If

If g_rules(15).used = True Then
    If InStr(t$, "IF(") <> 0 Then
        If InStr(InStr(t$, "IF(") + 1, t$, "IF(") <> 0 Then
            found(15) = True
            errors = errors + 1
            f(errors) = 15
        End If
    End If
End If





Exit Sub
testformulas:
Call errorhandler("Test formulas", Err)
Resume

specialtestformulas:
If IsObject(g_unanalysed) = True Then
    Set g_unanalysed = Union(c, g_unanalysed)
Else
    Set g_unanalysed = c
End If
Resume Next
End Sub

Sub testinputs(c As Variant, f() As Integer, errors As Variant)
Attribute testinputs.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo testinputs
'Dim dd As Variant
Dim d As Variant


If Not IsNumeric(c) Then Exit Sub
errors = 0
'*** There is a bug in the dependents command with version 8.0
If Val(Trim$(Application.Version)) >= 8# And Val(Trim$(Application.Version)) < 9# Then Exit Sub

If g_rules(1).used Then

    c.Activate
   
    c.ShowDependents
 
    'Note there is a known but unfixed bug here.
    'If you use this when the selected sheets option is chosen and you have
    'more than one selected sheet this produces an error.
    c.NavigateArrow False, 1

    c.ShowDependents Remove:=True
    Set d = ActiveCell
    Application.Goto reference:=c
    If d.Address(external:=True) = c.Address(external:=True) Then
        errors = errors + 1
        f(errors) = 1
    End If
   
    'This doesn't work because it does not show dependents on different sheets.
    'dd = Null
    'On Error Resume Next
    'Set dd = c.DirectDependents
    'On Error GoTo testinputs
    'If IsObject(dd) = False Then
    '   errors = errors + 1
    '   f(errors) = 1
    'End If
End If
Exit Sub
testinputs:
Call errorhandler("Test inputs", Err)
Resume
End Sub



Sub adderror(d As Worksheet, c As Variant, rule)
Attribute adderror.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo adderror
g_rules(rule).number = g_rules(rule).number + 1

If IsObject(g_err(rule)) = False Then
    Set g_err(rule) = c
Else
    Set g_err(rule) = Union(g_err(rule), c)
End If
Exit Sub
adderror:
Call errorhandler("Add error", Err)
Resume
End Sub

Sub year2000()
Attribute year2000.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo year2000

Dim chosen As Variant
Dim year2000choice As Variant
Dim i As Integer
  
g_year2000 = True
Call startdocumentation
g_year2000 = False


Exit Sub
year2000:
Call errorhandler("Year 2000", Err)
Resume
End Sub

Sub setuptests()
Attribute setuptests.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo setuptests
Dim i

ReDim g_rules(50) As rule

'*** Sets up the used/unused rule options
'Call readoptions
'*** Setup parameters
g_abort = False

g_rules(1).title = "Unused input value"
g_rules(1).expl = "A number has been entered which is not used in any calculation."
g_rules(1).Err(1) = "1. A calculation contains an incorrect reference."
g_rules(1).Err(2) = "2. The writer of the spreadsheet may have forgotten that this input value exists and hard coded the value directly into subsequent calculations."


g_rules(2).title = "Unused calculation"
g_rules(2).expl = "The results from this calculation are not used elsewhere on this worksheet"
g_rules(2).Err(1) = "1. The results should be used but there is an incorrect reference in a subsequent calculation."


g_rules(3).title = "No precedents"
g_rules(3).expl = "This formula does not depend on any other cells.  Usually this implies that an input has been entered as a combination of values."
g_rules(3).Err(1) = "1. Unless the individual values that make up the input are documented then it will be impossible to subsequently understand how the results were derived."


g_rules(4).title = "Blank cells referenced"
g_rules(4).expl = "The following calculations reference a blank cell."
g_rules(4).Err(1) = "1. An input value has not been entered."
g_rules(4).Err(2) = "2. The calculation contains an incorrect reference."
g_rules(4).Err(3) = "3. There maybe no error at present but users may subsequently enter values or formulas into the blank cells causing inconsistent results."


g_rules(5).title = "Errors referenced"
g_rules(5).expl = "The following calculations reference one or more cells containing an error."
g_rules(5).Err(1) = "1. Excel is indicating that one or more calculations result in errors. This will lead to unpredictable results."


g_rules(6).title = "Non numeric cells referenced"
g_rules(6).expl = "Although the following calculations have numeric answers they refer to non-numeric cells."
g_rules(6).Err(1) = "1. A value has been entered as a non numeric."
g_rules(6).Err(2) = "2. The calculation contains an incorrect reference."


g_rules(7).title = "Forward row reference"
g_rules(7).expl = "The following calculations refer to a row after the row in which they are situated."
g_rules(7).Err(1) = "1. Well written spreadsheets should be read from top to bottom like a book.  Forward references often indicate a late additional piece of code which has been inadequately checked."
g_rules(7).Err(2) = "2. The calculation contains an incorrect reference."


g_rules(8).title = "Forward column reference"
g_rules(8).expl = "The calculation refers to a column to the right of the column in which it is situated."
g_rules(8).Err(1) = "1. Well written spreadsheets should be read from left to right like a book.  Forward references often indicate a late additional piece of code which has been inadequately checked."
g_rules(8).Err(2) = "2. The calculation contains an incorrect reference."



g_rules(9).title = "Hidden cell referenced"
g_rules(9).expl = "The following calculations reference to hidden cells."
g_rules(9).Err(1) = "1. It is impossible to check these calculations by examining the spreadsheet.  In practice they are often found to contain errors."


g_rules(10).title = "NPV function"
g_rules(10).expl = "The following calculations use the NPV function.  This is used incorrectly in over 30% of all cases examined."
g_rules(10).Err(1) = "1. The Excel NPV function assumes that all cashflows occur at the end of each period.  If you are assuming mid period or opening period cashflows substantial errors will occur."
g_rules(10).Err(2) = "2. The cashflows must also be equally spaced in time."


g_rules(11).title = "VLOOKUP function"
g_rules(11).expl = "The following calculations use the VLOOKUP function."
g_rules(11).Err(1) = "1. The range being searched must be in ascending order or errors may occur."
 


g_rules(12).title = "HLOOKUP function"
g_rules(12).expl = "The following calculations use the HLOOKUP function."
g_rules(12).Err(1) = "1. The range being searched must be in ascending order or errors may occur."
 

g_rules(13).title = "LOOKUP function"
g_rules(13).expl = "The following calculations use the LOOKUP function."
g_rules(13).Err(1) = "1. The range being searched must be in ascending order or errors may occur."
 
g_rules(14).title = "IF function"
g_rules(14).expl = "The following calculations contain an IF statement."
g_rules(14).Err(1) = "1. The calculation used is dependent on the input values to the spreadsheet therefore these cells must be checked particularly carefully."

g_rules(15).title = "Double IF function"
g_rules(15).expl = "The following calculations contain two or more IF statements."
g_rules(15).Err(1) = "1. These are complex calculations which have been found to be incorrect in more than 25% of cases."
g_rules(15).Err(2) = "2. Ensure that all possible values are allowed for. "

g_rules(16).title = "Numeric rule"
g_rules(16).expl = "The following calculations contain a number.  This is the most common cause of errors within a spreadsheet."
g_rules(16).Err(1) = "1. A number has been added to the calculation as a 'quick fix' and not been subsequently removed."
g_rules(16).Err(2) = "2. A number has been used within the calculation even though it is also input elsewhere on the spreadsheet. Changing the input then has no effect. "
g_rules(16).Err(3) = "3. The number is being used to convert from one set of units to another (000s to millions etc).  This is often performed incorrectly."


g_rules(17).title = "Dependents rule"
g_rules(17).expl = "Although this calculation is a copy of the one to its left, it is referenced by a different number of subsequent calculations."
g_rules(17).Err(1) = "1. A calculation contains an incorrect reference."


g_rules(18).title = "Complex calculation"
g_rules(18).expl = "This calculation is particularly complex and therefore likely to contain errors."
g_rules(18).Err(1) = "1. Errors can be of all types."

g_rules(19).title = "Unprotected calculation."
g_rules(19).expl = "This calculation is not protected and can be overwritten by the users of the spreadsheet."
g_rules(19).Err(1) = "1. Subsequent amendment (either accidently or deliberately) may result in incorrect results being derived."

g_rules(20).title = "Range names"
g_rules(21).title = "Lotus eval rules"
g_rules(22).title = "Worksheet protection"
g_rules(23).title = "Calculation manual"
g_rules(24).title = "duplicate range names"

g_rules(25).title = "External reference"
g_rules(25).expl = "This calculation references a value on a separate spreadsheet."
g_rules(25).Err(1) = "1. These cells often contain out of date values which have not been updated."

g_rules(26).title = "Date reference"
g_rules(26).expl = "This calculation references a date.  "
g_rules(26).Err(1) = "1. This calculation may not work over the year 2000. Check formula."

g_rules(27).title = "Two digit integer reference"
g_rules(27).expl = "This calculation references a two digit integer. It maybe a date."
g_rules(27).Err(1) = "1. If this two digit integer is a date, there is a high probability that the formula may not work past the year 2000."

g_rules(28).title = "References the value 99"
g_rules(28).expl = "This calculation references the value 99.  It maybe the year 99."
g_rules(28).Err(1) = "1. If this value represents 1999, check the formula in each column to ensure that it will work past the year 2000."

Exit Sub
setuptests:
Call errorhandler("Setup tests", Err)
Resume
End Sub


Sub abort()
Attribute abort.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo abort
g_abort = True
Application.StatusBar = ""
Exit Sub
abort:
Call errorhandler("Abort", Err)
Resume
End Sub

Sub helpcalcchecker()
Attribute helpcalcchecker.VB_ProcData.VB_Invoke_Func = " \n14"
'Application.help HelpFile:=ThisWorkbook.Path + "\sprdprof.hlp", HelpContextID:=1000
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=4

End Sub

Sub helpcalctranslator()
Attribute helpcalctranslator.VB_ProcData.VB_Invoke_Func = " \n14"
'Application.help HelpFile:=ThisWorkbook.Path + "\sprdprof.hlp", HelpContextID:=1001
End Sub

Sub helpdocumentor()
Attribute helpdocumentor.VB_ProcData.VB_Invoke_Func = " \n14"
'Application.help HelpFile:=ThisWorkbook.Path + "\sprdprof.hlp", HelpContextID:=1004
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=6
End Sub

Sub helpintroduction()
Attribute helpintroduction.VB_ProcData.VB_Invoke_Func = " \n14"
Application.help HelpFile:=ThisWorkbook.Path + "\sprdprof.hlp", HelpContextID:=1006
End Sub

Sub helpcomparisons()
Attribute helpcomparisons.VB_ProcData.VB_Invoke_Func = " \n14"
'Application.help HelpFile:=ThisWorkbook.Path + "\sprdprof.hlp", HelpContextID:=1007
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=5

End Sub

Sub helptestoptions()
Attribute helptestoptions.VB_ProcData.VB_Invoke_Func = " \n14"
'Application.help HelpFile:=ThisWorkbook.Path + "\sprdprof.hlp", HelpContextID:=1008
End Sub

Sub helptranslateoptions()
Attribute helptranslateoptions.VB_ProcData.VB_Invoke_Func = " \n14"
Application.help HelpFile:=ThisWorkbook.Path + "\sprdprof.hlp", HelpContextID:=1009
End Sub

Sub helpmacro()
Attribute helpmacro.VB_ProcData.VB_Invoke_Func = " \n14"
End Sub

Sub evalcopy()
Attribute evalcopy.VB_ProcData.VB_Invoke_Func = " \n14"
ThisWorkbook.DialogSheets("evaldialog").Show
End Sub

Sub savedefaults()
Attribute savedefaults.VB_ProcData.VB_Invoke_Func = " \n14"
ThisWorkbook.Save
End Sub

Sub createformula()
createspreadsheet.genformula.Text = createspreadsheet.genformula.Text + ActiveCell.Address(rowabsolute:=False, columnabsolute:=False)
End Sub

Public Function sortoutformat(frmt As String) As String
 Dim schar As String, sresult As String
 On Error GoTo nogoodformat
   
    While frmt <> ""
        schar = Left(frmt, 1)
        If InStr(1, "_", schar) = 0 Then
            sresult = sresult & schar
            frmt = Mid(frmt, 2)
        Else
            If Len(frmt) > 2 Then
                frmt = Mid(frmt, 3)
            Else
                frmt = ""
            End If
        End If
    Wend
   'If TypeName(temp) = "Boolean" Then 'i.e. a logical
   '     temp = Format$(temp, "General Number")
   'Else
       If sresult = "General" Then sresult = "General Number"
      
        'temp = Format$(temp, sresult)
   'End If
sortoutformat = sresult
Exit Function
nogoodformat:
sortoutformat = "General Number"
End Function

Public Function ReplaceChars( _
  strIn As String, _
  strFind As String, _
  strReplace As String) _
  As String
  ' Comments  : Replaces characters in a string
  ' Parameters: strIn - String to replace in
  '             strFind - Character to find
  '             strReplace - Character to replace with
  ' Returns   : Modified string
  ' Source    : Total VB SourceBook 6
  '
  Dim lngCounter As Long
  Dim strTmp As String
  Dim chrTmp As String * 1
  
  On Error GoTo PROC_ERR

  ' Loop through the string
  For lngCounter = 1 To Len(strIn)
    ' Get the current character
    chrTmp = Mid$(strIn, lngCounter)
    If chrTmp <> strFind Then
      ' Its not a match, do nothing
      strTmp = strTmp & chrTmp
    Else
      ' Its a match, so use the replacement character
      strTmp = strTmp & strReplace
    End If
  Next lngCounter

  ' Return the value
  ReplaceChars = strTmp

PROC_EXIT:
  Exit Function
  
PROC_ERR:
  MsgBox "Error: " & Err.number & ". " & Err.Description, , _
    "ReplaceChars"
  Resume PROC_EXIT
  
End Function


Attribute VB_Name = "securityform"
Attribute VB_Base = "0{B1BDD8B0-0384-411D-99FC-6A42FFE69449}{2DA8D607-3A77-4095-9A38-9038477936C1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Private Sub Cmdexit_Click()

On Error Resume Next
CommandBars("Spreadsheet Professional V4").Delete
On Error GoTo securityexit

Me.Hide
securityexit:
End Sub

Private Sub Softlocx1_LicenseStatus(ByVal Status As String, ByVal Level As Long, ByVal Serial As String, ByVal ExpireVal As String, ByVal NetLicenses As String)

Select Case Status
Case "EXPIRED"
   On Error Resume Next
   CommandBars("Spreadsheet Professional V4").Delete
   On Error GoTo softlocxexit
   securityform.Show
 
Case "EVALUATION"
    l = "You are currently evaluating Spreadsheet Professional" & Chr(13) & Chr(13)
    l = l + "You have " + ExpireVal + " days left before the end of the evaluation period." & Chr(13) & Chr(13)
    l = l + "For details of how to purchase Spreadsheet Professional please" & Chr(13) & "visit our web site.  www.spreadsheetinnovations.com"
    MsgBox l, 0, "Spreadsheet Professional - Evaluation Copy."
    'evaluationform.Show
Case Else
End Select
softlocxexit:
End Sub



Private Sub UserForm_Click()

End Sub

Private Sub UserForm_Deactivate()

On Error Resume Next
CommandBars("Spreadsheet Professional V4").Delete
On Error GoTo securityexit1

Me.Hide

securityexit1:
End Sub
Attribute VB_Name = "sensitivitytool"
Attribute VB_Base = "0{5DEA5BDD-888C-4411-A79C-55B741AAE68B}{01F7F1D4-DC01-4CC3-9C9C-F35EF9BE6332}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



'Dim moresizer As New CFormResizer






Private Sub clearvalues()
inpt1 = ""
Inpt2 = ""
inpt3 = ""
inpt4 = ""
inpt5 = ""
inpt6 = ""
inpt7 = ""
otpt1 = ""
otpt2 = ""
otpt3 = ""
otpt4 = ""
otpt5 = ""
otpt6 = ""
otpt7 = ""
Image2.Picture = LoadPicture("")
'targetcell.Value = ""
'inputcell.Value = ""
End Sub


Private Sub cmdCalculate()
On Error GoTo calculatesensitivity
Application.ScreenUpdating = False
If Optsensitivityanalysis.Value = True Then

'*** First calculate an array of input numbers and place in correct place.
ReDim a(7)
s = sensitivity
For i = 1 To 7
    a(i) = Val(Range(inputcell)) + (i - 4) / 3 * s / 100 * Val(Range(inputcell))
Next i




'*** Now place them on the target cell sheet and create a datatable.

Range(inputcell).Worksheet.Activate
g_calcmethod = Application.Calculation
Application.Calculation = xlCalculationAutomatic

l = ActiveSheet.UsedRange.SpecialCells(xlLastCell).Row
g_sensitivityrow = l + 1
If g_firstsensitivityrow = 0 Then
    g_firstsensitivityrow = g_sensitivityrow
End If

Set t = Range(targetcell)
Set m = Range(inputcell)
s = Range(inputcell).numberformat
For i = 1 To 7
    ActiveSheet.Range("CC" & Format$(l + 1 + i)).Value = a(i)
    ActiveSheet.Range("CC" & Format$(l + 1 + i)).numberformat = s
Next i
inpt1 = ActiveSheet.Range("CC" & Format$(l + 1 + 1)).Text
Inpt2 = ActiveSheet.Range("CC" & Format$(l + 1 + 2)).Text
inpt3 = ActiveSheet.Range("CC" & Format$(l + 1 + 3)).Text
inpt4 = ActiveSheet.Range("CC" & Format$(l + 1 + 4)).Text
inpt5 = ActiveSheet.Range("CC" & Format$(l + 1 + 5)).Text
inpt6 = ActiveSheet.Range("CC" & Format$(l + 1 + 6)).Text
inpt7 = ActiveSheet.Range("CC" & Format$(l + 1 + 7)).Text


Range("CD" & Format$(l + 1)) = "=" & t.Address(external:=True, rowabsolute:=False, columnabsolute:=False)
Range("CC" & Format(l + 1) & ":CD" & Format(l + 8)).Select
Selection.Table ColumnInput:=m

'*** Now get the results and put back together again.
Application.Calculation = g_calcmethod
s = Range(targetcell).numberformat
For i = 1 To 7
    ActiveSheet.Range("CD" & Format$(i + l + 1)).numberformat = s
    a(i) = ActiveSheet.Range("CD" & Format$(i + l + 1))
Next i


otpt1 = ActiveSheet.Range("CD" & Format$(1 + l + 1)).Text
otpt2 = ActiveSheet.Range("CD" & Format$(1 + l + 2)).Text
otpt3 = ActiveSheet.Range("CD" & Format$(1 + l + 3)).Text
otpt4 = ActiveSheet.Range("CD" & Format$(1 + l + 4)).Text
otpt5 = ActiveSheet.Range("CD" & Format$(1 + l + 5)).Text
otpt6 = ActiveSheet.Range("CD" & Format$(1 + l + 6)).Text
otpt7 = ActiveSheet.Range("CD" & Format$(1 + l + 7)).Text
s = ActiveSheet.Name

'*** Create a chart ***
Set srcerange = ActiveSheet.Range("CC" & Format$(l + 2) & ":CD" & Format$(l + 9))
Set tempchart = Charts.Add
With tempchart
    .ChartType = xlXYScatterSmooth
    .SetSourceData Source:=srcerange, PlotBy:=xlColumns
    .Location where:=xlLocationAsObject, Name:=s
End With
cnt = ActiveSheet.ChartObjects.Count
ActiveChart.HasLegend = False
ActiveChart.ChartType = xlLine
ActiveChart.HasTitle = False
With ActiveSheet.ChartObjects(cnt)
    .Width = 180
    .Height = 150
End With

'*** Save the chart and load it into the userform.
Set CurrentChart = ActiveSheet.ChartObjects(cnt).Chart
'   Save chart as GIF
Fname = ThisWorkbook.Path & Application.PathSeparator & "temp.gif"
CurrentChart.Export Filename:=Fname, FilterName:="GIF"
ActiveSheet.ChartObjects(cnt).Delete
'   Show the chart
Image2.Picture = LoadPicture(Fname)
Application.ScreenUpdating = True
Kill ThisWorkbook.Path & Application.PathSeparator & "temp.gif"


Application.ScreenUpdating = True

Else
'*** We are performing a breakeven analysis.
Application.ScreenUpdating = False
'*** First get the original figures
value1 = Range(inputcell).Value
originaltext = Range(inputcell).Formula
Target = sensitivity
Value2 = value1 * 0.9
'*** If we start from a 0 input value we need to seed it with something else.
If value1 = 0 Then Value2 = 100
result1 = Range(targetcell).Value - Target

'*** now start the loop
'*** Set the change parameter to an arbitary value.
Change = 1

Do While i < 30 And Change > 0.0001
    i = i + 1
    Range(inputcell).Value = Value2
    Application.calculate
    result2 = Range(targetcell).Value - Target
    Change = (value1 - Value2) * result2 / (result2 - result1)
    value1 = Value2
    result1 = result2
    Value2 = Value2 + Change
    
Loop

'If Range(inputcell).numberformat = "General" Then
'    fmt$ = "general number"
'Else
'    fmt$ = Range(inputcell).numberformat
'End If
'inpt1 = Format$(Value2, fmt$)
'inpt1 = getvalue$(inputcell)



inpt1 = Format$(Value2, sortoutformat(Range(inputcell).numberformat))
Range(inputcell).Formula = originaltext
Application.ScreenUpdating = True

End If


Exit Sub
calculatesensitivity:
'*** Try and restore spreadsheet to original state.
Range(inputcell).Formula = originaltext
If g_firstsensitivityrow > 0 Then
     l = Range(inputcell).Worksheet.UsedRange.SpecialCells(xlLastCell).Row
     Range(g_firstsensitivityrow & ":" & l).Clear
    g_firstsensitivityrow = 0
End If
MsgBox "An error has occurred in the sensitivity calculation. Your data may not have been changed back to its original values.  Check the input and target range values with care."
Call errorhandler("Calculate sensitivity", Err)
Resume
End Sub

Private Sub calculate_Click()
Call cmdCalculate
End Sub

Private Sub CmdCancel_Click()
If g_firstsensitivityrow > 0 Then
     l = Range(inputcell).Worksheet.UsedRange.SpecialCells(xlLastCell).Row
     Range(g_firstsensitivityrow & ":" & l).Clear
    g_firstsensitivityrow = 0
End If
Me.Hide
End Sub



Sub formatsensitivity()
 ActiveSheet.Range("B9:C16").Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    Selection.Borders(xlInsideVertical).LineStyle = xlNone
    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
    Range("B9:C9").Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    Selection.Borders(xlInsideVertical).LineStyle = xlNone
    Range("B9:B16").Select
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    With Selection.Borders(xlEdgeLeft)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    With Selection.Borders(xlEdgeRight)
        .LineStyle = xlContinuous
        .Weight = xlMedium
        .ColorIndex = xlAutomatic
    End With
    Range("B9:C9").Select
    With Selection.Interior
        .ColorIndex = 15
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
    End With
 Columns("B:B").EntireColumn.AutoFit
 Columns("C:C").EntireColumn.AutoFit
End Sub





Private Sub Cmdclear_Click()
Call clearvalues
targetcell.Value = ""
inputcell.Value = ""
End Sub





Private Sub CommandButton1_Click()
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=2
End Sub

Private Sub inputcell_Exit(ByVal Cancel As MSForms.ReturnBoolean)
'inputcell.Tag = Range(inputcell.Text).Address(external:=True)
'MsgBox inputcell.Text
End Sub

Private Sub sensitivity_Change()
If sensitivity.Value <> "" Then
Sensitivityspin.Value = sensitivity.Value
End If
End Sub

Private Sub targetcell_Exit(ByVal Cancel As MSForms.ReturnBoolean)
'targetcell.Tag = Range(inputcell.Text).Address(external:=True)
'MsgBox targetcell.Text
End Sub
Private Sub Optbreakevenanalysis_Click()
sensitivity.Value = 0
lbltarget.Visible = True
Sensitivityspin.Visible = False
Lblsensitivity.Visible = False
otpt1.Visible = False
otpt2.Visible = False
otpt3.Visible = False
otpt4.Visible = False
otpt5.Visible = False
otpt6.Visible = False
otpt7.Visible = False
Inpt2.Visible = False
inpt7.Visible = False
inpt3.Visible = False
inpt4.Visible = False
inpt5.Visible = False
inpt6.Visible = False
Call clearvalues
End Sub



Private Sub Optsensitivityanalysis_Click()
lbltarget.Visible = False
sensitivity.Value = 30
sensitivity.Visible = True
Sensitivityspin.Visible = True
Lblsensitivity.Visible = True
otpt1.Visible = True
otpt2.Visible = True
otpt3.Visible = True
otpt4.Visible = True
otpt5.Visible = True
otpt6.Visible = True
otpt7.Visible = True
inpt1.Visible = True
Inpt2.Visible = True
inpt3.Visible = True
inpt4.Visible = True
inpt5.Visible = True
inpt6.Visible = True
inpt7.Visible = True
Call clearvalues
End Sub



Private Sub CmdSave_Click()
On Error GoTo reportsensitivity
Application.ScreenUpdating = False

'*** Lets get the right ranges setup.
Range(inputcell).Worksheet.Activate
Set srcerange = ActiveSheet.Range("CC" & Format$(g_sensitivityrow + 1) & ":CD" & Format$(g_sensitivityrow + 8))
workbookname = ActiveWorkbook.Name
worksheetname = ActiveSheet.Name
Set aw = ActiveWorkbook
Set ass = aw.ActiveSheet


'*** Lets get some parameters from the sheet
inf = Range(inputcell).numberformat
outf = Range(targetcell).numberformat
rname = getname(Range(targetcell))
iame = getname(Range(inputcell))

'*** Now lets set up the workbook
Call setupworkbook("SP Analysis Report")
Application.Workbooks("SP Analysis Report.xls").Activate
ActiveWorkbook.Sheets.Add after:=ActiveWorkbook.ActiveSheet
If Optsensitivityanalysis.Value = True Then
    ActiveSheet.Name = "Sensitivity " & Format(ActiveWorkbook.Sheets.Count - 1)
Else
    ActiveSheet.Name = "Breakeven " & Format(ActiveWorkbook.Sheets.Count - 1)
End If
s = ActiveSheet.Name

ActiveWindow.DisplayGridlines = False
ActiveSheet.PageSetup.Orientation = xlPortrait
ActiveSheet.PageSetup.LeftFooter = "Produced using WWW.Spreadsheetinnovations.com"
ActiveSheet.PageSetup.RightFooter = workbookname
ActiveSheet.PageSetup.FitToPagesWide = 1
ActiveSheet.PageSetup.FitToPagesTall = False
ActiveSheet.PageSetup.PrintGridlines = False

'*** Now display the values
If Optsensitivityanalysis = True Then
    With ActiveSheet
        .Cells(1, 2) = "Sensitivity Analysis"
        .Cells(1, 2).Font.Bold = True
        .Cells(1, 2).Font.Size = 16
    
        .Cells(4, 2) = "Results Cell"
        .Cells(5, 2) = "Input Cell"
        .Cells(4, 3) = rname & " (" & targetcell & ")"
        .Cells(5, 3) = iame & " (" & inputcell & ")"
        .Cells(9, 2) = "Input value"
        .Cells(9, 3) = "Result"
        For i = 1 To 7
            .Cells(9 + i, 2).numberformat = inf
            .Cells(9 + i, 3).numberformat = outf
            .Cells(9 + i, 2) = ass.Range("CC" & Format$(g_sensitivityrow + i)).Value
            .Cells(9 + i, 3) = ass.Range("CD" & Format$(g_sensitivityrow + i)).Value
        Next i
    End With
    Call formatsensitivity

    '*** Create a chart ***
    Set srcerange = ActiveSheet.Range("B10:C16")
    Set tempchart = Charts.Add
    With tempchart
        .ChartType = xlXYScatterSmooth
        .SetSourceData Source:=srcerange, PlotBy:=xlColumns
        .Location where:=xlLocationAsObject, Name:=s
    End With
    ActiveChart.HasLegend = False
    ActiveChart.ChartType = xlLine
    ActiveChart.HasTitle = False
    ActiveChart.HasTitle = True
    ActiveChart.ChartTitle.Text = "Sensitivity"
    ActiveChart.Axes(xlCategory, xlPrimary).HasTitle = True
    ActiveChart.Axes(xlCategory, xlPrimary).AxisTitle.Characters.Text = iame & " (" & inputcell & ")"
    ActiveChart.Axes(xlValue).HasTitle = True
    ActiveChart.Axes(xlValue).AxisTitle.Characters.Text = rname & " (" & targetcell & ")"
    cnt = ActiveSheet.ChartObjects.Count
    With ActiveSheet.ChartObjects(cnt)
        .Width = 300
        .Height = 200
        .Top = ActiveSheet.Rows(19).Top
        .Left = ActiveSheet.Columns("B").Left
      
        
    End With
Else
    With ActiveSheet
        .Cells(1, 2) = "Breakeven Analysis"
        .Cells(1, 2).Font.Bold = True
        .Cells(1, 2).Font.Size = 16
    
        .Cells(4, 2) = "Results Cell"
        .Cells(5, 2) = "Input Cell"
        .Cells(4, 3) = rname & " (" & targetcell & ")"
        .Cells(5, 3) = iame & " (" & inputcell & ")"
        .Cells(9, 2) = "Input value"
        .Cells(9, 3) = "Result"
        .Cells(10, 2) = inpt1.Text
        .Cells(10, 3) = sensitivity.Text
    End With
    Range("C9:c10").HorizontalAlignment = xlRight
    Columns("B:B").EntireColumn.AutoFit
    Columns("C:C").EntireColumn.AutoFit
End If


aw.Activate
Range(targetcell).Worksheet.Activate
Application.ScreenUpdating = True
MsgBox "The analysis has been added to  'SP Analysis Report.xls'. To view the analysis select 'SP Analysis Report.xls' from the Window option on the main Excel menu.", 64
Exit Sub
reportsensitivity:
Call errorhandler("Report sensitivity", Err)
Resume
End Sub

Private Sub UserForm_Activate()
''Set moresizer.Form = Me
'Call showsensitivitytool
t$ = CommandBars("Sensitivitybar").Controls(3).Caption
targetcell.Text = Mid$(t$, InStr(t$, ":") + 1)
i$ = CommandBars("Sensitivitybar").Controls(4).Caption
inputcell.Text = Mid$(i$, InStr(i$, ":") + 1)
If CommandBars("Sensitivitybar").Controls(6).ListIndex = 1 Then
    Optsensitivityanalysis.Value = True
Else
    Optbreakevenanalysis.Value = True
End If
sensitivity.Text = CommandBars("Sensitivitybar").Controls(8).Text

Call cmdCalculate
Exit Sub
userformactivate:
End Sub

Private Sub UserForm_Resize()
'moresizer.FormResize
End Sub

Private Sub sensitivity_AfterUpdate()
If Optsensitivityanalysis = True Then
    Sensitivityspin.Value = Val(sensitivity.Text)
End If
End Sub



Private Sub Sensitivityspin_Change()
If Optsensitivityanalysis = True Then
    sensitivity.Text = Sensitivityspin.Value
End If
End Sub




Private Sub UserForm_Initialize()
targetcell.Text = ActiveWindow.RangeSelection.Address
End Sub

Public Sub setupsensitivitybar()
Dim tbar As CommandBar
Dim bfound As Boolean
Dim ctl As CommandBarButton
Dim tctrl As Variant

'*** Find out if it already exists.
bfound = False
For Each tbar In Application.CommandBars
    If LCase$(tbar.Name) = "Sensitivitybar" Then
        bfound = True
        Exit For
    End If
Next tbar

If bfound = True Then
    '*** If it exists then delete it.
    On Error Resume Next
    CommandBars("Sensitivitybar").Delete
    On Error GoTo 0
    For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Hide Sensitivity Bar" Then
                    ctl.Caption = "Show Sensitivity Bar"
                End If
            Next ctl
        End If
    Next tctrl

Else
    '*** If it doesn't exist then create it
     For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Show Sensitivity Bar" Then
                   ctl.Caption = "Hide Sensitivity Bar"
                End If
            Next ctl
        End If
    Next tctrl
    
    'Create a new input bar
    Set tbar = CommandBars.Add
    With tbar
        .Width = CommandBars(1).Width
        .Name = "Sensitivitybar"
        .Position = msoBarTop
        .Left = 0
        .Visible = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Sensitivity bar"
        .Width = 130
        .Visible = True
        .Style = msoButtonCaption
       
    End With
    
    'Set up a label
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = " Apply "
        .Width = 60
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = "applysensitivity"
        .BeginGroup = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Set as target cell"
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = ""
        .BeginGroup = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Set as input cell"
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = ""
        .BeginGroup = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Analysis Value:"
        .Visible = True
        .Style = msoButtonCaption
        .BeginGroup = True
    End With
    

    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlEdit)
    With newbtn
        .Caption = "Analysis value"
        .Text = "30"
        .Visible = True
        .Width = 30
    End With
   
    
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Type of sensitivity:"
        .Visible = True
        .Style = msoButtonCaption
        .BeginGroup = True
    End With

    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlDropdown)
    With newbtn
        .Caption = "Type of sensitivity:"
        .Visible = True
        .Style = msoButtonAutomatic
        .AddItem "Sensitivity"
        .AddItem "Breakeven"
        .OnAction = "changetypeofanalysis"
        .ListIndex = 1
    End With

End If



End Sub


Attribute VB_Name = "standardreports"
Attribute VB_Base = "0{B5F3910F-11E0-4BCE-BB46-BA691436CE9E}{8E9F7155-44FE-4791-AFA7-FF0220C92ED4}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False













Private Sub CmdCancel_Click()
standardreports.Hide
End Sub

Private Sub CmdClearall_Click()
Dim ctl As Control
Dim ctrltype As String

For Each ctl In Me.Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "RefEdit" Or ctrltype = "TextBox" Then
       ctl.Value = ""
    End If
Next ctl

End Sub

Private Sub CmdHelp_Click()
Application.help HelpFile:=ThisWorkbook.Path + "\SPREADSHEET PROFESSIONAL HELP.HLP", HelpContextID:=9

End Sub

Private Sub Cmdreport_Click()
On Error GoTo Cmdreport
Dim ctl As Control
workbookname = ActiveWorkbook.Name
Application.ScreenUpdating = False
Call setupworkbook("SP Analysis Report")

For Each ctl In Me.Controls
    If TypeName(ctl) = "RefEdit" Then

        If Trim$(ctl.Value) <> "" Then
   
            '*** Setup a new sheet
            Application.Workbooks("SP Analysis Report.xls").Activate
            ActiveWorkbook.Sheets.Add after:=ActiveWorkbook.ActiveSheet
            ActiveSheet.Name = "Report " & Format(ActiveWorkbook.Sheets.Count - 1)
            ActiveWindow.DisplayGridlines = False
            ActiveSheet.PageSetup.Orientation = xlPortrait
            ActiveSheet.PageSetup.LeftFooter = "Produced using WWW.Spreadsheetinnovations.com"
            ActiveSheet.PageSetup.RightFooter = workbookname
            ActiveSheet.PageSetup.FitToPagesWide = 1
            ActiveSheet.PageSetup.FitToPagesTall = False
            ActiveSheet.PageSetup.PrintGridlines = False
        
            '*** Copy data across ***
            excl = InStr(ctl.Value, "!")
            shtname$ = Mid$(ctl.Value, 1, excl - 1)
            shtname$ = ReplaceChars(shtname$, "'", "")
            Set rng1 = Workbooks(workbookname).Sheets(shtname$).Range(Mid$(ctl.Value, excl + 1))
            Set rng2 = ActiveSheet.Range("A1")
            
            
            rng1.Copy
            rng2.PasteSpecial Paste:=xlValues, Operation:=xlNone, SkipBlanks:=False, Transpose:=False
         
            
            '*** column widths need working on ***
            'Changed in version 4.01
            'rng1.Copy
            'rng2.PasteSpecial Paste:=xlPasteColumnWidths, Operation:=xlNone, _
            'SkipBlanks:=False, Transpose:=False
            For Each t In rng1.Columns
                n = n + 1
                rng2.Columns(n).ColumnWidth = t.ColumnWidth
            Next
            'rng1.Copy
            rng2.PasteSpecial Paste:=xlFormats, Operation:=xlNone, SkipBlanks:= _
            False, Transpose:=False
            Application.CutCopyMode = False
            Range("a1").Select
        End If
    End If
Next
Application.ScreenUpdating = True
Application.Workbooks(workbookname).Activate
standardreports.Hide
MsgBox "The reports have been added to  'SP Analysis Report.xls'. To view the reports select 'SP Analysis Report.xls' from the Window option on the main Excel menu.", 64
Exit Sub
Cmdreport:
MsgBox "An error has occured in the Quick reports module. Check that the ranges have been entered correctly. The full range must be entered including worksheet name.", vbCritical

End Sub

Private Sub CmdSave_Click()
Dim ctl As Control
Dim ctrltype As String

For Each ctl In Me.Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "RefEdit" Or ctrltype = "TextBox" Then
        SaveSetting "SP", "Reports", ctl.Name, ctl.Value
    End If
Next ctl

End Sub


Private Sub UserForm_Activate()
Dim ctl As Control
Dim ctrltype As String

For Each ctl In Me.Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "RefEdit" Or ctrltype = "TextBox" Then
        ctl.Value = GetSetting("SP", "Reports", ctl.Name, ctl.Value)
    End If
Next ctl

End Sub

Attribute VB_Name = "startmod"

Dim X As New Eventclassmodule

Sub auto_open()
Attribute auto_open.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo auto_open
Call InitializeApp
'*** Check to see if past its expiry date.
'If Date > DateSerial(ThisWorkbook.Worksheets("constants").Range("b1"), ThisWorkbook.Worksheets("constants").Range("b2"), ThisWorkbook.Worksheets("constants").Range("b3")) Then
'    On Error Resume Next
'    MsgBox "This program has now expired.  Contact Spreadsheet Innovations on (UK) 020 7424 0101 for a new copy or visit our web site - WWW.spreadsheetinnovations.com", 16, "Spreadsheet Professional"
'    Application.AddIns("Spreadsheet Professional").Installed = False
'    End
'End If

Call createmainmenubar
'*** Setup the security using Softlocx
securityform.Softlocx1.Application = "spsecurity29"
securityform.Softlocx1.EncryptionKey = "1379"
securityform.Softlocx1.ExpireValue = 30
securityform.Softlocx1.ExpireType = 0
securityform.Softlocx1.License

'*** Switch on the cell translator
'Application.OnDoubleClick = "" ' "ci_dblclick"

'*** Set up the escape key handler
Application.EnableCancelKey = xlErrorHandler
Application.EnableEvents = True 'Version 4.03
'*** Ensure that the year2000 option is switched off.
g_year2000 = False

'*** Set up the test variables
'Call setuptests

'*** Get the options from the registry and load into the Options dialog
Call getoptions

'*** Read the options from the options dialog into global variables
Call readoptions

Exit Sub
auto_open:
Call errorhandler("auto_open", Err)
Resume
End Sub
Sub createmainmenubar()

Dim tbar As CommandBar
For Each tbar In Application.CommandBars
    Select Case LCase$(tbar.Name)
    
    Case "spreadsheet professional"
       '*** For some reason there is a floating bar that will not disappear.  Hence the bug fix."
      tbar.Delete
    Case "translationbar"
        tbar.Controls(2).Text = "Translation will appear here when you click on a cell."
    End Select
Next tbar


bfound = False
For Each tbar In Application.CommandBars
    If LCase$(tbar.Name) = "spreadsheet professional v4" Then
        If tbar.Visible = False Then tbar.Visible = True
        Exit Sub
    End If
Next tbar


Set tbar = CommandBars.Add
With tbar
    .Name = "Spreadsheet Professional V4"
    .Visible = True
    .Position = msoBarTop
End With


'*** Build options ***
Set nbar = tbar.Controls.Add(Type:=msoControlButton)
With nbar
    .Caption = "Spreadsheet Professional"
    .Width = 130
    .Visible = True
    .Style = msoButtonCaption
End With

Set nbar = tbar.Controls.Add(Type:=msoControlPopup)
With nbar
    .Caption = " Build"
    .Visible = True
   .BeginGroup = True
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Set up sheet in standard format"
    .Visible = True
    .TooltipText = "Sets up a sheet in a standard best practice format"
    .OnAction = "menu0"
End With

Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Show Build Bar"
    .Visible = True
    .TooltipText = "Makes for easier and quicker input and formatting of formulas"
    .OnAction = "menu1"
End With

Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Show Translation Bar"
    .Visible = True
    .TooltipText = "Displays a translation of the active cell formula"
    .OnAction = "createtranslationbar"
End With

Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Painter"
    .Visible = True
    .TooltipText = "Paints spreadsheet formulas, inputs and labels different colours"
    .OnAction = "menu2"
End With

Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Formula Tracer"
    .Visible = True
    .TooltipText = "Builds diagram of spreadheet to aid understanding"
    .OnAction = "menu3"
End With

'*** Test options ***
Set nbar = tbar.Controls.Add(Type:=msoControlPopup)
With nbar
    .Caption = "Test"
    .Visible = True
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Checker"
    .Visible = True
    .TooltipText = "Tests formulas for potential errors"
    .OnAction = "menu4"
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Test Reports tool"
    .Visible = True
    .TooltipText = "Produces report of potential errors"
    .OnAction = "menu5"
End With

'*** Document options ***
Set nbar = tbar.Controls.Add(Type:=msoControlPopup)
With nbar
    .Caption = "Document"
    .Visible = True
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Documentor"
    .Visible = True
    .TooltipText = "Produces comprehensive documentation of spreadsheet"
    .OnAction = "menu6"
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Formula Tracer"
    .Visible = True
    .TooltipText = "Produces diagram showing formula links"
    .OnAction = "menu7"
End With

'*** Use options ***
Set nbar = tbar.Controls.Add(Type:=msoControlPopup)
With nbar
    .Caption = "Use"
    .Visible = True
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Quick Reports Tool"
    .Visible = True
    .TooltipText = "Produces quick reports of spreadsheet model"
    .OnAction = "menu8"
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Show Sensitivity bar"
    .Visible = True
    .TooltipText = "Produces sensitivity and breakeven analyses"
    .OnAction = "menu9"
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Spreadsheet Comparisons tool"
    .Visible = True
    .TooltipText = "Produces comparison reports between different spreadsheets"
    .OnAction = "menu10"
End With

'*** Other options ***
Set nbar = tbar.Controls.Add(Type:=msoControlPopup)
With nbar
    .Caption = "Other"
    .Visible = True
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Options"
    .Visible = True
    .OnAction = "menu11"
End With

Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "Help"
    .Visible = True
    .TooltipText = ""
    .OnAction = "menu12"
End With
Set z = nbar.Controls.Add(Type:=msoControlButton)
With z
    .Caption = "About"
    .Visible = True
    .TooltipText = ""
    .OnAction = "menu13"
End With

tbar.Protection = msoBarNoCustomize

End Sub

Sub createtranslationbar()
Dim tbar As CommandBar

'*** Find out if it already exists.
bfound = False
For Each tbar In Application.CommandBars
    If LCase$(tbar.Name) = "translationbar" Then
        bfound = True
        Exit For
    End If
Next tbar

If bfound = True Then
    '*** If it exists then delete it.
    On Error Resume Next
    CommandBars("translationbar").Delete
    On Error GoTo 0
    For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Hide Translation Bar" Then
                    ctl.Caption = "Show Translation Bar"
                End If
            Next ctl
        End If
    Next tctrl
    Exit Sub
Else
    '*** If it doesn't exist then create it
     For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Show Translation Bar" Then
                   ctl.Caption = "Hide Translation Bar"
                End If
            Next ctl
        End If
    Next tctrl
End If

Set tbar = CommandBars.Add
With tbar
    .Name = "translationbar"
    .Visible = True
    .Position = msoBarBottom
End With

Set newbtn = tbar.Controls.Add(Type:=msoControlButton)
With newbtn
    .Caption = "Translation bar"
    .Width = 130
    .Visible = True
    .Style = msoButtonCaption
End With

Set newbtn = tbar.Controls.Add(Type:=msoControlEdit)
With newbtn
    .Caption = "Translation of formulas"
    .Text = "Translation will appear here when you click on a cell"
    .Width = CommandBars(1).Width - 160
    .BeginGroup = True
End With

tbar.Protection = msoBarNoCustomize

End Sub

Sub getoptions()
'*** Loads the values of all the controls and then loads them into the variables again.
Dim ctl As Control
Dim ctrltype As String

'*** Bubble diagram options ***
For Each ctl In bubbleoptions.Mpoptions.Pages(0).Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "CheckBox" Then
        ctl.Value = GetSetting("SP", "Reports", ctl.Name, True)
    End If
Next ctl


'*** Format options ***

For Each ctl In bubbleoptions.Mpoptions.Pages(1).Controls
  
    ctrltype = TypeName(ctl)

    If ctrltype = "OptionButton" Then
   
       ctl.BackColor = GetSetting("SP", "Reports", ctl.Name, 0)
 
    
        If ctl.BackColor = 0 Then
 
            s = s + 1
            Select Case s
            Case 1
                ctl.BackColor = ThisWorkbook.Colors(18) 'bubbleoptions.CommandButton18.BackColor
            Case 2
                ctl.BackColor = ThisWorkbook.Colors(24)
            Case 3
                ctl.BackColor = ThisWorkbook.Colors(31)
            Case 4
                ctl.BackColor = ThisWorkbook.Colors(38)
            Case 5
                ctl.BackColor = ThisWorkbook.Colors(45)
            Case Else
            End Select
        End If
    End If

Next ctl

'*** Test options ***
For Each ctl In bubbleoptions.Mpoptions.Pages(2).Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "CheckBox" Then
      ctl.Value = GetSetting("SP", "Reports", ctl.Name, True)
    End If
Next ctl
'*** Translation options ***
For Each ctl In bubbleoptions.Mpoptions.Pages(3).Controls
    ctrltype = TypeName(ctl)
    If ctrltype = "TextBox" Or ctrltype = "OptionButton" Then
       Select Case ctl.Name
        Case "rowlabelsautomatic", "columnlabelsnone", "calcsboth"
            ctl.Value = GetSetting("SP", "Reports", ctl.Name, True)
        Case "rowlabel"
             ctl.Value = GetSetting("SP", "Reports", ctl.Name, "A")
        Case "columnlabel"
             ctl.Value = GetSetting("SP", "Reports", ctl.Name, 1)
        Case Else
            ctl.Value = GetSetting("SP", "Reports", ctl.Name, 0)
        End Select
    End If
Next ctl
End Sub

Sub readoptions()
On Error GoTo loadingoptions
Dim temp As Variant
Dim temp1 As Variant
Dim i As Variant
Dim ctl As Control
'ReDim Preserve g_rules(50) As rule
Call setuptests
'***
'*** Translation options
'***
'*** Rows
If bubbleoptions.rowlabelsnone.Value = True Then g_rownames = "none"
If bubbleoptions.rowlabelsautomatic.Value = True Then g_rownames = "auto"
If bubbleoptions.rowlabelsspecified.Value = True Then
    temp = Trim$(bubbleoptions.rowlabel.Text)
    
    On Error Resume Next
    Set temp1 = ThisWorkbook.Worksheets("constants").Columns(UCase$(temp))
    On Error GoTo loadingoptions
    If IsObject(temp1) Then
        g_rownames = UCase$(temp)
    Else
        MsgBox "Illegal column for row labels.  Column must be between A and IV", 16, "Spreadsheet Professional"
        'bubbleoptions.rowlabel.Select
        Exit Sub
    End If
End If

'*** Columns
If bubbleoptions.columnlabelsnone.Value = True Then g_colnames = "none"
If bubbleoptions.columnlabelsautomatic.Value = True Then g_colnames = "auto"
If bubbleoptions.Columnlabelsspecified.Value = True Then
    temp = Trim$(bubbleoptions.columnlabel.Text)
    If Val(temp) < 1 Or Val(temp) > 65536 Then
        MsgBox "Illegal row for column labels.  Row must be between 1 and 65536", 16, "Spreadsheet Professional"
        Exit Sub
    Else
        g_colnames = temp
    End If
End If
If bubbleoptions.calcsleft.Value = True Then g_uniqueoption = c_horizontal
If bubbleoptions.calcsabove.Value = True Then g_uniqueoption = c_vertical
If bubbleoptions.calcsboth.Value = True Then g_uniqueoption = c_both

'***
'**** Test options ****
'***

For Each ctl In bubbleoptions.Mpoptions.Pages(2).Controls
    If TypeName(ctl) = "CheckBox" Then
        i = i + 1
        Select Case i
        Case 26
            g_unique = ctl.Value
        Case 27
            g_firstcellonly = ctl.Value
        Case 1 To 25
            g_rules(i).used = ctl.Value
            'MsgBox ctl.Caption
            'MsgBox g_rules(i).used
        Case Else
        End Select
    End If
Next
'***
'**** Options for the bubble diagrams ****
'***
g_showbubblevalues = bubbleoptions.optshowvalues.Value
g_showbubblenames = bubbleoptions.optshownames.Value = True
g_showbubbleformulas = bubbleoptions.optshowformulas.Value
g_noredraw = False

'***
'*** Options for the screen painter
'***

g_calcscolour = bubbleoptions.Optcalculations.BackColor
g_inputscolour = bubbleoptions.Optinputs.BackColor
g_headingscolour = bubbleoptions.Optheadings.BackColor
g_otherscolour = bubbleoptions.Optothers.BackColor
g_outputscolour = bubbleoptions.Optoutputs.BackColor

'*** End of options allocation ***
If bubbleoptions.Visible = True Then bubbleoptions.Hide



Exit Sub
loadingoptions:
Call errorhandler("Read options", Err)
Resume
End Sub

Public Sub setupsensitivitybar()
Dim tbar As CommandBar
Dim bfound As Boolean
Dim ctl As CommandBarButton
Dim tctrl As Variant

'*** Find out if it already exists.
bfound = False
For Each tbar In Application.CommandBars
    If LCase$(tbar.Name) = "sensitivitybar" Then
        bfound = True
        Exit For
    End If
Next tbar

If bfound = True Then
    '*** If it exists then delete it.
    On Error Resume Next
    CommandBars("Sensitivitybar").Delete
    On Error GoTo 0
    For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Hide Sensitivity bar" Then
                    ctl.Caption = "Show Sensitivity bar"
                End If
            Next ctl
        End If
    Next tctrl

Else
    '*** If it doesn't exist then create it
     For Each tctrl In Application.CommandBars("Spreadsheet Professional V4").Controls
        If tctrl.Type = msoControlPopup Then
            For Each ctl In tctrl.Controls
                If ctl.Caption = "Show Sensitivity bar" Then
                   ctl.Caption = "Hide Sensitivity bar"
                End If
            Next ctl
        End If
    Next tctrl
    
    'Create a new input bar
    Set tbar = CommandBars.Add
    With tbar
        .Width = CommandBars(1).Width
        .Name = "Sensitivitybar"
        .Position = msoBarTop
        .Left = 0
        .Visible = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Sensitivity bar"
        .Width = 130
        .Visible = True
        .Style = msoButtonCaption
       
    End With
    
    'Set up a label
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = " Apply "
        .TooltipText = "Calculates the sensitivity of the target cell to variations in the input cell."
        .Width = 60
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = "applysensitivity"
        .BeginGroup = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Set as target cell"
        .TooltipText = "Selects the current cell as the target for which the sensitivity will be calculated."
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = "setastargetcell"
        .BeginGroup = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Set as input cell"
        .TooltipText = "Selects the current cell as the input which will be varied in the sensitivity."
        .Visible = True
        .Style = msoButtonCaption
        .OnAction = "setasinputcell"
        .BeginGroup = True
    End With
    
    

    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Type of analysis:"
        .TooltipText = "Selects the type of analysis to be performed: Sensitivity or breakeven"
        .Visible = True
        .Style = msoButtonCaption
        .BeginGroup = True
    End With

    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlDropdown)
    With newbtn
        .Caption = "Type of analysis:"
        .TooltipText = "Select type of analysis from drop down list."
        .Visible = True
        .Style = msoButtonAutomatic
        .AddItem "Sensitivity"
        .AddItem "Breakeven"
        .ListIndex = 1
    End With


    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlButton)
    With newbtn
        .Caption = "Analysis Value:"
        .TooltipText = "Sensitivity:The % change to the input variable. Breakeven: The target value"
        .Visible = True
        .Style = msoButtonCaption
        .BeginGroup = True
    End With
    
    Set newbtn = CommandBars("Sensitivitybar").Controls.Add(Type:=msoControlEdit)
    With newbtn
        .Caption = "% change if sensitivity analysis. Target value if breakeven analysis"
        .Text = "30"
        .Visible = True
        .Width = 30
    End With


End If



End Sub
Sub setastargetcell()
 For Each tctrl In Application.CommandBars("Sensitivitybar").Controls
    If tctrl.Type = msoControlButton Then
        If InStr(tctrl.Caption, "Set as target cell") <> 0 Then
            tctrl.Caption = "Set as target cell: " & "'" & ActiveSheet.Name & "'!" & Selection.Address(rowabsolute:=False, columnabsolute:=False)
        End If
    End If
Next
End Sub

Sub setasinputcell()
 For Each tctrl In Application.CommandBars("Sensitivitybar").Controls
    If tctrl.Type = msoControlButton Then
        If InStr(tctrl.Caption, "Set as input cell") <> 0 Then
            tctrl.Caption = "Set as input cell: " & "'" & ActiveSheet.Name & "'!" & Selection.Address(rowabsolute:=False, columnabsolute:=False)
           ' tctrl.DescriptionText = Selection.Address(rowabsolute:=False, columnabsolute:=False, external:=True)
        End If
    End If
Next
End Sub

Sub applysensitivity()
sensitivitytool.Show
'sensitivitytool.targetcell.Text = "test"
End Sub
Sub InitializeApp()
    Set X.App = Application
End Sub

Attribute VB_Name = "translationmod"







Sub translateoptions()
Attribute translateoptions.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo translateoptions
ThisWorkbook.DialogSheets("translation dialog").Show
Exit Sub
translateoptions:
Call errorhandler("Translate options ", Err)
Resume
End Sub

Sub ok_click()
Attribute ok_click.VB_ProcData.VB_Invoke_Func = " \n14"
On Error GoTo ok_click
'*** This routine checks the references and sets up the global variables.
Dim temp As Variant
Dim temp1 As Variant


'***
If ThisWorkbook.DialogSheets("translation dialog").OptionButtons("rownone").Value = xlOn Then
    g_rownames = "none"
End If

If ThisWorkbook.DialogSheets("translation dialog").OptionButtons("rowautomatic").Value = xlOn Then
    g_rownames = "auto"
End If

If ThisWorkbook.DialogSheets("translation dialog").OptionButtons("rowspecified").Value = xlOn Then
    temp = Trim$(ThisWorkbook.DialogSheets("translation dialog").EditBoxes("rowlabel").Caption)
    'MsgBox temp
    
    On Error Resume Next
    Set temp1 = Columns(temp)
    On Error GoTo ok_click
    
    If IsObject(temp1) Then
        g_rownames = temp
    Else
        MsgBox "Illegal column for row labels.  Column must be between A and IV", 16, "Spreadsheet Professional"
        ThisWorkbook.DialogSheets("translation dialog").EditBoxes("rowlabel").Select
        Exit Sub
    End If
    
End If

If ThisWorkbook.DialogSheets("translation dialog").OptionButtons("colnone").Value = xlOn Then
    g_colnames = "none"
End If

If ThisWorkbook.DialogSheets("translation dialog").OptionButtons("colautomatic").Value = xlOn Then
    g_colnames = "auto"
End If

If ThisWorkbook.DialogSheets("translation dialog").OptionButtons("colspecified").Value = xlOn Then
    temp = ThisWorkbook.DialogSheets("translation dialog").EditBoxes("columnlabel").Caption
    If Val(temp) < 1 Or Val(temp) > 16384 Then
        MsgBox "Illegal row for column labels.  Row must be between 1 and 16384", 16, "Spreadsheet Professional"
        ThisWorkbook.DialogSheets("translation dialog").EditBoxes("columnlabel").Select
        Exit Sub
    Else
        g_colnames = temp
    End If
End If
ThisWorkbook.DialogSheets("translation dialog").Hide
Exit Sub
ok_click:
Call errorhandler("Ok click", Err)
Resume
End Sub




' InQuest injected base64 decoded content
' lz{"

INQUEST-PP=macro
