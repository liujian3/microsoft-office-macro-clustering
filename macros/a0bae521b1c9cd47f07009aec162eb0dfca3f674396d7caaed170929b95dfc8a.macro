Attribute VB_Name = "ADStuff"
Option Explicit

Public G_MyUserGroups As String

Private Sub TestMyUserGroups()
  Debug.Print GetUserGroups(GetUserName)
  
End Sub

Public Function GetUserGroups(winUser As String) As String

    If G_MyUser = GetUserName And G_MyUser <> "" Then
      If G_MyUserGroups <> "" Then
        GetUserGroups = G_MyUserGroups
        Exit Function
      End If
    End If

    Dim conn As New ADODB.Connection
    Dim rs As ADODB.Recordset
    Dim oRoot ' As IADs
    Dim oDomain ' As IADs
    Dim sBase As String
    Dim sFilter As String
    Dim sDomain As String
    
    Dim sAttribs As String
    Dim sDepth As String
    Dim sQuery As String
    Dim sAns As String
    
    On Error GoTo ErrHandler:
    
    GetUserGroups = ""
    If G_cfgNoAD Then Exit Function
    
    'Get user Using LDAP/ADO.  There is an easier way
    'to bind to a user object using the WinNT provider,
    'but this way is a better for educational purposes
    Set oRoot = GetObject(G_cfgADString & "://rootDSE")
    'work in the default domain
    sDomain = oRoot.Get("defaultNamingContext")
    Set oDomain = GetObject(G_cfgADString & "://" & sDomain)
    sBase = "<" & oDomain.ADsPath & ">"
    
    'Only get user name requested
    ' sFilter = "(&(objectCategory=person)(objectClass=user)(name=" _
    '    & LoginName & "))"
    
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    
    sAttribs = "adsPath"
    sDepth = "subTree"
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    sFilter = "(&(objectCategory=person)(objectClass=user)(sAMAccountName=" & winUser & "))"
    
    
    sQuery = sBase & ";" & sFilter & ";" & sAttribs & ";" & sDepth
                       
    conn.Open "Data Source=Active Directory Provider;Provider=ADsDSOObject"
      
    Dim I As Long
    Dim user ' As IADsUser
    Set rs = conn.Execute(sQuery)
    Dim s As String
    Do While Not rs.EOF
        Set user = GetObject(rs("adsPath"))
        ' If Not IsErrorLastName(user) Then
            Dim objmemberOf
            Dim objGroup
            objmemberOf = user.GetEx("memberOf")
            For Each objGroup In objmemberOf
              Dim p1 As Long
              Dim p2 As Long
              p1 = InStr(objGroup, "CN=")
              p2 = InStr(objGroup, ",")
              If p1 > 0 And p2 > 0 Then
                If s <> "" Then
                  s = s & ","
                End If
                s = s & "'" & Mid(objGroup, p1 + 3, p2 - p1 - 3) & "'"
              End If
            Next
        ' End If
        rs.MoveNext
    Loop
    G_MyUserGroups = s
    GetUserGroups = s
ErrHandler:
    
    On Error Resume Next
    If Not rs Is Nothing Then
        If rs.state <> 0 Then rs.Close
        Set rs = Nothing
    End If
    
    If Not conn Is Nothing Then
        If conn.state <> 0 Then conn.Close
        Set conn = Nothing
    End If
    
    Set oRoot = Nothing
    Set oDomain = Nothing
End Function

Public Function GetDisplayName(winUser As String) As String

    Dim conn As New ADODB.Connection
    Dim rs As ADODB.Recordset
    Dim oRoot ' As IADs
    Dim oDomain ' As IADs
    Dim sBase As String
    Dim sFilter As String
    Dim sDomain As String
    
    Dim sAttribs As String
    Dim sDepth As String
    Dim sQuery As String
    Dim sAns As String
    
    GetDisplayName = ""
    
    On Error GoTo ErrHandler:
    
    If G_cfgNoAD Then Exit Function
    
    'Get user Using LDAP/ADO.  There is an easier way
    'to bind to a user object using the WinNT provider,
    'but this way is a better for educational purposes
    Set oRoot = GetObject(G_cfgADString & "://rootDSE")
    'work in the default domain
    sDomain = oRoot.Get("defaultNamingContext")
    Set oDomain = GetObject(G_cfgADString & "://" & sDomain)
    sBase = "<" & oDomain.ADsPath & ">"
    
    'Only get user name requested
    ' sFilter = "(&(objectCategory=person)(objectClass=user)(name=" _
    '    & LoginName & "))"
    
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    
    sAttribs = "adsPath"
    sDepth = "subTree"
'    sFilter = "(&(objectCategory=person)(objectClass=user)(sn=Neubert))"
    sFilter = "(&(objectCategory=person)(objectClass=user)(sAMAccountName=" & winUser & "))"
    
    
    sQuery = sBase & ";" & sFilter & ";" & sAttribs & ";" & sDepth
                       
    conn.Open "Data Source=Active Directory Provider;Provider=ADsDSOObject"
      
    Dim I As Long
    Dim user ' As IADsUser
    Set rs = conn.Execute(sQuery)
    Dim s As String
    Do While Not rs.EOF
        Set user = GetObject(rs("adsPath"))
        ' If Not IsErrorLastName(user) Then
            GetDisplayName = user.DisplayName ' .GetEx("displayName")
        ' End If
        rs.MoveNext
    Loop
    
ErrHandler:
    
    On Error Resume Next
    If Not rs Is Nothing Then
        If rs.state <> 0 Then rs.Close
        Set rs = Nothing
    End If
    
    If Not conn Is Nothing Then
        If conn.state <> 0 Then conn.Close
        Set conn = Nothing
    End If
    
    Set oRoot = Nothing
    Set oDomain = Nothing
End Function

Function IsErrorLastNameOLD(v As Variant) As Boolean

  On Error GoTo nogo
  Dim s As String
  s = CStr(v.lastname)
  IsErrorLastNameOLD = False
  Exit Function
  
nogo:
  IsErrorLastNameOLD = True

End Function


Public Function ADGetUserInfo(LoginName As String, ByRef lastname As String, ByRef firstname As String, ByRef mailaddress As String) As Boolean
'PURPOSE: Display information that is available in
'the Active Directory about a given user

'PARAMETER: Login Name for user

'RETURNS: String with selected information about
'user, or empty string if there is no such
'login on the current domain

'REQUIRES: Windows 2000 ADSI, LDAP Provider
'Proper Security Credentials.

'EXAMPLE: msgbox ADGetUserMailAddress("Administrator")

Dim conn As Object
Dim rs As Object
Dim oRoot As Object
Dim oDomain As Object
Dim sBase As String
Dim sFilter As String
Dim sDomain As String

Dim sAttribs As String
Dim sDepth As String
Dim sQuery As String
Dim sAns As String

Dim user As Object

If G_cfgNoAD Then Exit Function

Set conn = CreateObject("ADODB.Connection")
On Error GoTo ErrHandler:

'Get user Using LDAP/ADO.  There is an easier way
'to bind to a user object using the WinNT provider,
'but this way is a better for educational purposes
Set oRoot = GetObject(G_cfgADString & "://rootDSE")
'work in the default domain
sDomain = oRoot.Get("defaultNamingContext")
Set oDomain = GetObject(G_cfgADString & "://" & sDomain)
sBase = "<" & oDomain.ADsPath & ">"
'Only get user name requested
sFilter = "(&(objectCategory=person)(objectClass=user)(SAMAccountName=" _
  & LoginName & "))"
sAttribs = "adsPath"
sDepth = "subTree"

sQuery = sBase & ";" & sFilter & ";" & sAttribs & ";" & sDepth
                   
conn.Open _
  "Data Source=Active Directory Provider;Provider=ADsDSOObject"
  
Set rs = conn.Execute(sQuery)

If Not rs.EOF Then
    Set user = GetObject(rs("adsPath"))
    With user
    
    'if the attribute is not stored in AD,
    'an error will occur.  Therefore, this
    'will return data only from populated attributes
    On Error Resume Next
    
      firstname = .firstname
      lastname = .lastname
'    sAns = sAns & "Employee ID: " & .EmployeeID & vbCrLf
'    sAns = sAns & "Title: " & .Title & vbCrLf
'    sAns = sAns & "Division: " & .Division & vbCrLf
'    sAns = sAns & "Department: " & .Department & vbCrLf
'    sAns = sAns & "Manager: " & .Manager & vbCrLf
'    sAns = sAns & "Phone Number: " & .TelephoneNumber & vbCrLf
'    sAns = sAns & "Fax Number: " & .FaxNumber & vbCrLf
'    sAns = sAns & "Email Address: " & .EmailAddress & vbCrLf
'    sAns = sAns & "Web Page: " & .HomePage & vbCrLf
'    sAns = sAns & "Last Login: " & .LastLogin & vbCrLf
'    sAns = sAns & "Last Logoff: " & .LastLogoff & vbCrLf
'    sAns = sAns & "Account Expiration Date: " & .AccountExpirationDate & vbCrLf
    
    'IN RC2, this returned 1/1/1970 when password
    'never expires option is set
'    sAns = sAns & "Password Expiration Date: " & .PasswordExpirationDate
      mailaddress = .EmailAddress
    End With
End If
  ADGetUserInfo = True
ErrHandler:

On Error Resume Next
If Not rs Is Nothing Then
    If rs.state <> 0 Then rs.Close
    Set rs = Nothing
End If

If Not conn Is Nothing Then
    If conn.state <> 0 Then conn.Close
    Set conn = Nothing
End If

Set oRoot = Nothing
Set oDomain = Nothing
End Function



Public Function ADUserAuthorized(ByVal LoginName As String, ByVal pwd As String) As Boolean

'PURPOSE: Check for second user

'PARAMETER: Login Name for user

'RETURNS: String with selected information about
'user, or empty string if there is no such
'login on the current domain

'REQUIRES: Windows 2000 ADSI, LDAP Provider
'Proper Security Credentials.

'EXAMPLE: msgbox ADGetUserMailAddress("Administrator")
  
  ADUserAuthorized = False
  If G_cfgNoAD Then Exit Function
  
  If LoginName = "" Or pwd = "" Then
    ADUserAuthorized = False
  End If

    Dim objRootDSE, dso, ou
    Dim strDNSDomain As String
    strDNSDomain = ""
    If strDNSDomain = "" Then
        Set objRootDSE = GetObject(G_cfgADString & "://RootDSE")
        strDNSDomain = objRootDSE.Get("defaultNamingContext")
        ' Set objRootDSE = Nothing
    End If
    
    Set dso = GetObject(G_cfgADString & ":")
    On Error Resume Next
    Err.Clear
    Set ou = dso.OpenDSObject(G_cfgADString & "://" & strDNSDomain, LoginName, pwd, 1)
    ADUserAuthorized = (Err.Number = 0)
    Set ou = Nothing
End Function



Attribute VB_Name = "AboutDlg"
Attribute VB_Base = "0{C7674C36-1C81-450E-8945-832A16B5A30D}{69D10459-B537-418D-9DB4-4E99D8B6803E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub

Private Sub CommandButton1_Click()
    AboutDlg.Hide
End Sub

Private Sub Image1_Click()
  On Error Resume Next
  Call Shell("explorer.exe http://www.stromwerken.de", 1)
End Sub

Private Sub Label3_Click()
  On Error Resume Next
  Call Shell("explorer.exe http://www.stromwerken.de", 1)
End Sub

Attribute VB_Name = "BitteWarten"
Attribute VB_Base = "0{22E3F3BC-FE8B-4F7F-B5E3-CA0A3A7A640B}{A44FF4A2-D9A5-4833-9527-EA478E561F37}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


Public Sub Refresh()

End Sub

Private Sub UserForm_Initialize()
  gTranslation.TranslateForm Me
End Sub

Attribute VB_Name = "CAppCommand"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Command As String
Public m_ParameterString As String
Public m_Parameter As Collection


Sub Init(ByVal cmdstring As String)
  Dim pos As Long
  pos = InStr(cmdstring, " ")
  If pos > 0 Then
    m_Command = UCase(Trim(Left(cmdstring, pos - 1)))
    m_ParameterString = Trim(Mid(cmdstring, pos + 1, 10000))
  Else
    m_Command = UCase(Trim(cmdstring))
  End If
  Set m_Parameter = New Collection
End Sub

Sub AddParameter(ByVal partype As Long, ByVal parname As String, ByVal paroptional)
  Dim cacp As New CAppCommandParameter
  cacp.Init partype, parname, paroptional
  m_Parameter.Add cacp
End Sub

Function CheckValues(ByRef errString As String) As Boolean

  Dim parstring As String
  parstring = m_ParameterString
  
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    cacp.CheckValue parstring, errString
  Next cacp
    
  If Len(Trim(parstring)) > 0 Then
    errString = errString & IIf(errString <> "", vbCrLf, "") & "Unbekannte oder nicht erlaubte Parameter '" & parstring & "'"
  End If
  
  If errString <> "" Then
    errString = "Error in Command '" & m_Command & "': " & errString
  End If
  
End Function

Function GetValue(ByRef parname As String) As Variant
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    If cacp.m_Name = parname Then
      GetValue = cacp.m_Value
      Exit Function
    End If
  Next cacp
  GetValue = ""
End Function

Function ParameterExists(ByRef parname As String) As Boolean
  Dim cacp As CAppCommandParameter
  For Each cacp In m_Parameter
    If cacp.m_Name = parname Then
      If cacp.m_Found Then
        ParameterExists = True
      End If
      Exit Function
    End If
  Next cacp
  ParameterExists = False
End Function


Attribute VB_Name = "CAppCommandParameter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Type As Long
Public m_Optional As Boolean
Public m_Name As String
Public m_Value As String
Public m_Found As Boolean

Public Sub Init(ByVal partype As Long, ByVal parname As String, ByVal paroptional As Boolean)
  m_Type = partype
  m_Name = UCase(parname)
  m_Optional = paroptional
End Sub

Function CheckValue(ByRef parstring As String, ByRef errString As String) As Boolean
  Dim startPos As Long
  Dim pos As Long
  Dim s As String
  Dim ts As String
  Dim tPos As Long
  
  If InStr(parstring, m_Name) > 0 Then
    CheckValue = True
    startPos = InStr(UCase(parstring), m_Name)
    pos = startPos + Len(m_Name)
    s = GetNextValue(parstring, pos, " ")
    
    Dim ok As Boolean
    Select Case m_Type
      Case 0    ' Kein Wert
        m_Found = True
      Case vbInteger
        If IsNumeric(s) Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist nicht numerisch!"
          CheckValue = False
        End If
      Case vbTime
        ok = True
        If Not IsDate(s) Then
          ok = False
        End If
        
        If ok Then
          tPos = InStr(s, " ")
          If tPos > 0 Then
            s = Trim(Mid(s, tPos + 1))
          End If
          ts = s
          If Len(ts) <> 8 Then ok = False
          If ok Then If Mid(ts, 3, 1) <> ":" Then ok = False
          If ok Then If Mid(ts, 6, 1) <> ":" Then ok = False
          If ok Then
            If IsNumeric(Val(Mid(ts, 1, 2))) Then
              If Val(Mid(ts, 1, 2)) < 0 Or Val(Mid(ts, 1, 2)) > 23 Then ok = False
            Else
              ok = False
            End If
          End If
          If ok Then
            If IsNumeric(Val(Mid(ts, 4, 2))) Then
              If Val(Mid(ts, 4, 2)) < 0 Or Val(Mid(ts, 4, 2)) > 59 Then ok = False
            Else
              ok = False
            End If
          End If
          If ok Then
            If IsNumeric(Val(Mid(ts, 7, 2))) Then
              If Val(Mid(ts, 7, 2)) < 0 Or Val(Mid(ts, 7, 2)) > 59 Then ok = False
            Else
              ok = False
            End If
          End If
        End If
        
        If ok Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist keine Uhrzeit (hh:mm:ss)!"
          CheckValue = False
        End If
      
      Case vbString
        m_Value = s
        m_Found = True
'        Else
'          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & S & "' in " & m_Name & " ist keine String!"
'          CheckValue = False
'        End If
    
      Case vbDate
        If IsDate(s) Then
          m_Value = s
          m_Found = True
        Else
          errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Wert '" & s & "' in " & m_Name & " ist keine Datum!"
          CheckValue = False
        End If
      
      Case Else
        MsgBox "UNDEFINED TYPE in CAppCommandParameter.CheckValue"
    End Select
    Dim newparstring As String
    If startPos > 1 Then
      newparstring = Left(parstring, startPos - 1)
    End If
    If pos < Len(parstring) Then
      newparstring = newparstring & Mid(parstring, pos)
    End If
    parstring = newparstring
  End If

  If m_Found = False And errString = "" And m_Optional = False Then
    CheckValue = False
    errString = errString & IIf(errString <> "", vbCrLf, "") & "Der Parameter " & m_Name & " wurde nicht angegeben, ist aber erforderlich!"
  End If

End Function


Attribute VB_Name = "CArea"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' TODO
' Eingef|fffd|gte Spalten
' Gel|fffd|schte Spalten
' Nicht gefundene Spalten auff|fffd|llen (muss "schlauer" gemacht werden).

Public m_X1 As Long
Public m_X2 As Long
Public m_Y1 As Long
Public m_Y2 As Long

Private m_ColumnMissingInCompareArea() As Boolean
Private m_CorrespondingColumn() As Long

Private m_Results(c_Area_MAX_RES) As Collection

Private Sub Class_Initialize()
  Dim I As Long
  For I = 0 To c_Area_MAX_RES
    Set m_Results(I) = New Collection
  Next I
End Sub

Public Function GetResultCollection(l As Long) As Collection
  Debug.Assert l >= 0
  Debug.Assert l <= c_Area_MAX_RES
  
  Set GetResultCollection = m_Results(l)
End Function


Sub InitColumns()
  ReDim m_ColumnMissingInCompareArea(Width())
  ReDim m_CorrespondingColumn(Width())
  Dim I As Long
  For I = 0 To Width
    m_CorrespondingColumn(I) = -1
  Next I
End Sub
Sub SetColumnMissingInCompareArea(c As Long, b As Boolean)
  m_ColumnMissingInCompareArea(c) = b
End Sub

Function GetCorrespondingColumn(c As Long) As Long
  GetCorrespondingColumn = m_CorrespondingColumn(c)
End Function

Sub SetCorrespondingColumn(c As Long, l As Long)
  m_CorrespondingColumn(c) = l
End Sub

Function FindCorrespondingColumn(c As Long) As Long
  FindCorrespondingColumn = -1
  Dim I As Long
  For I = 0 To Width
    If m_CorrespondingColumn(I) = c Then
      FindCorrespondingColumn = I
      Exit Function
    End If
  Next I
End Function

Function GetColumnMissingInCompareArea(c As Long) As Boolean
  GetColumnMissingInCompareArea = m_ColumnMissingInCompareArea(c)
End Function

Function Width() As Long
  Width = m_X2 - m_X1 + 1
End Function

Function Height() As Long
  Height = m_Y2 - m_Y1 + 1
End Function

Sub SetCell(y As Long, x As Long)
  m_X1 = x
  m_X2 = x
  m_Y1 = y
  m_Y2 = y
End Sub

Function CheckAddCell(y As Long, x As Long) As Boolean
  If x >= m_X1 - G_MaxLeerzellen - 1 And x <= m_X2 + G_MaxLeerzellen + 1 And _
     y >= m_Y1 - G_MaxLeerzellen - 1 And y <= m_Y2 + G_MaxLeerzellen + 1 Then
     
    CheckAddCell = True
    If x < m_X1 Then m_X1 = x
    If y < m_Y1 Then m_Y1 = y
    If x > m_X2 Then m_X2 = x
    If y > m_Y2 Then m_Y2 = y
  End If
End Function

Function CheckAddArea(ByRef c As CArea) As Boolean
  
  If m_X1 <= c.m_X2 + G_MaxLeerzellen And m_X2 >= c.m_X1 - G_MaxLeerzellen And _
     m_Y1 <= c.m_Y2 + G_MaxLeerzellen And m_Y2 >= c.m_Y1 - G_MaxLeerzellen Then
    CheckAddArea = True
    If c.m_X1 < m_X1 Then m_X1 = c.m_X1
    If c.m_Y1 < m_Y1 Then m_Y1 = c.m_Y1
    If c.m_X2 > m_X2 Then m_X2 = c.m_X2
    If c.m_Y2 > m_Y2 Then m_Y2 = c.m_Y2
  End If
End Function



Function GetNewLine(ByRef cl As CLine, l As Long, ByRef ws As Worksheet) As Boolean
    Set cl = Nothing
    If l >= Height Then Exit Function
    Set cl = New CLine
    cl.m_Line = l
    Dim I As Long
    Dim s As String
    s = ""
    Dim sf As String
    sf = ""
    For I = 0 To Width - 1
      If m_CorrespondingColumn(I) >= 0 Then
        
        Dim c1 As Range
        Set c1 = ws.Cells(m_Y1 + l, m_X1 + I)
        
        If c1.HasFormula = True Then
          If FormulaR1C1HasError(c1) Then
            If IsError(c1) Then
              s = s & "F*" & CStr(c1.value)
            Else
              s = s & "F*" & c1.formula
              sf = sf & "F*" & c1.formula
            End If
          Else
            s = s & "F*" & c1.formulaR1C1
            sf = sf & "F*" & c1.formulaR1C1
          End If
        ElseIf Not IsEmpty(c1) Then
          If IsText(CStr(c1.value)) = True Then
            s = s & "T*" & CStr(c1.value)
          Else
            s = s & "V*" & CStr(c1.value)
          End If
        Else
          s = s & "|"
        End If
        Set c1 = Nothing
      End If
    Next I
    If Trim(Replace(s, "|", "")) <> "" Then
      cl.m_Str = s
    End If
    cl.m_StrFormulas = sf
    GetNewLine = True
End Function
Sub FillUpLines(ByRef c As Collection, ByRef ws As Worksheet, ByRef lastline As Long, Optional maxAmLines As Long = -1)
  While c.Count < MAX_LINES_COMPARE
    If maxAmLines > 0 Then
      If lastline >= maxAmLines Then
        Exit Sub
      End If
    End If
  
    Dim cl As CLine
    Dim gotOne As Boolean
    If GetNewLine(cl, lastline, ws) Then
      If cl.m_Str <> "" Then
        c.Add cl
      Else
        Set cl = Nothing
      End If
      lastline = lastline + 1
    Else
      Exit Sub
    End If
  Wend
End Sub

Function Compare(ByRef A As CArea, ByRef ws1 As Worksheet, ByRef ws2 As Worksheet, bereichnr As Long, ws1ParentFullName As String, ws2ParentFullName As String) As Boolean
  
  AreasMatch ws1, ws2, Me, A, True

  ' Jetzt durch jede Zeile durch und schauen, ob sich etwas ge|fffd|ndert hat
  
  Dim clines As Collection
  Set clines = New Collection
  
  Dim lastline As Long
  lastline = 0
  
  A.FillUpLines clines, ws2, lastline
  
  Dim I As Long
  Dim cl1 As CLine
  Dim cl2 As CLine
  
  Dim delLinesCount As Long
  delLinesCount = 0
  Dim h As Long
  h = Height()
  For I = 0 To h - 1
    If Beenden Then Exit Function
    
    If I Mod 30 = 0 Then
      'StatusForm.ProgressTxt.Caption = "Vergleiche Bereich " & bereichnr & " Zeile " & i & " / " & h
      StatusForm.ProgressTxt.Caption = FMT3("CArea_1", bereichnr, I, h)
      DoEvents
    End If
  
    If clines.Count > 0 Then
      ' Gibts |fffd|berhaupt was zu vergleichen?
      GetNewLine cl1, I, ws1
      If cl1.m_Str <> "" Then
          Dim checkFinished As Boolean
          checkFinished = False
          Dim lineCount As Long
          lineCount = 1
          For Each cl2 In clines
            DoEvents
            If cl1.m_Str = cl2.m_Str Then
              clines.Remove lineCount
              A.FillUpLines clines, ws2, lastline
              checkFinished = True
              Exit For
            End If
            lineCount = lineCount + 1
          Next cl2
          
          ' Wenn nichts identisches gefunden wurde muss pro Zeile geschaut werden, welche die
          ' gr|fffd||fffd|te |fffd|bereinstimmung hat.
          If checkFinished = False Then
            Dim bestLine As Long
            Dim compareVal As Long
            bestLine = -1
            compareVal = 0
            lineCount = 1
            For Each cl2 In clines
              DoEvents
              Dim tCompareVal As Long
              tCompareVal = CompareLine(ws1, ws2, A, cl1.m_Line, cl2.m_Line, False)
              If tCompareVal > compareVal Then
                compareVal = tCompareVal
                bestLine = lineCount
              End If
              lineCount = lineCount + 1
            Next cl2
            
            If bestLine >= 0 Then
'              If clines(bestLine).m_Line = 29 Then
'                Debug.Print "gaga"
'              End If
              CompareLine ws1, ws2, A, cl1.m_Line, clines(bestLine).m_Line, True
              clines.Remove bestLine
              A.FillUpLines clines, ws2, lastline
    '          delLinesCount = 0
            Else
              ' Keine Zeile gefunden!
              ' Debug.Print "Zeile gel|fffd|scht: " & m_Y1 + cl1.m_Line
              
              AddAddedOrDeletedRowOrCollumn c_Area_DELETEDLINES, cl1.m_Line
                
              delLinesCount = delLinesCount + 1
              If delLinesCount > MAX_LINES_COMPARE / 2 Then
                If clines.Count > 0 Then
                  AddAddedOrDeletedRowOrCollumn c_Area_ADDEDLINES, clines(1).m_Line
                  clines.Remove 1
                  ' XXX Zeile muss als hinzugef|fffd|gt markiert werden!
                  A.FillUpLines clines, ws2, lastline
                End If
              End If
            End If
            
          End If
      End If
      Set cl1 = Nothing
    Else
      ' Hoppala, nichts mehr zum Comparen?
      ' Debug.Print "Gel|fffd|schte Zeile: " & m_Y1 + i
      AddAddedOrDeletedRowOrCollumn c_Area_DELETEDLINES, I
    End If
  Next I
  
  Do
    A.FillUpLines clines, ws2, lastline
    If clines.Count > 0 Then
      For Each cl2 In clines
        ' Debug.Print "Hinzugef|fffd|gte Zeile: " & a.m_Y1 + cl2.m_Line
        AddAddedOrDeletedRowOrCollumn c_Area_ADDEDLINES, cl2.m_Line
      Next cl2
      Set clines = New Collection
      'StatusForm.ProgressTxt.Caption = "Bereich " & bereichnr & " lastline " & i
      StatusForm.ProgressTxt.Caption = FMT3("CArea_2", bereichnr, lastline, I)
    Else
      Exit Do
    End If
  Loop
  
  PrintResults A, ws1, ws2, ws1ParentFullName, ws2ParentFullName
  
  If HasDifferences = True Or A.HasDifferences = True Then
    Compare = True
  End If

End Function

Public Function GetColumnLetters(zelle As Range) As String
 Dim A As Variant
 A = Split(zelle.Address, "$")
 GetColumnLetters = A(1)
End Function

Public Function GetColumnLettersFromColumn(c As Long, Optional c2 As Long = -1) As String
 Dim A As Variant
 Dim res As String
 
 If c2 = -1 Or c = c2 Then
  A = Split(Cells(1, c).Address, "$")
  res = A(1)
 Else
  A = Split(Cells(1, c).Address, "$")
  res = A(1)
  A = Split(Cells(1, c2).Address, "$")
  res = res & ":" & A(1)
 End If
 GetColumnLettersFromColumn = res
End Function

Sub PrintDifferences(l As Long, Headline As String, isLine As Boolean, fname As String, sheetname As String, ByRef destrange As CArea, ByRef ws As Worksheet)
  Dim d As CDifference
  Dim notDeletedItems As Long
  If m_Results(l).Count > 0 Then
    For Each d In m_Results(l)
      If d.m_Deleted = False Then
        notDeletedItems = notDeletedItems + 1
      End If
    Next d
        
    If notDeletedItems > 0 Then
      With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
        .value = Headline & ":"
        .Font.bold = True
      End With
      For Each d In m_Results(l)
        If d.m_Deleted = False Then
          Dim lnk As String
          Dim lnkTxt As String
          
          If isLine = True Then
            lnk = Range(ActiveSheet.Cells(destrange.m_Y1 + d.m_RangeStart, destrange.m_X1), ActiveSheet.Cells(destrange.m_Y1 + d.m_RangeEnd, destrange.m_X2)).Address
            lnkTxt = IIf(d.m_RangeStart = d.m_RangeEnd, destrange.m_Y1 + d.m_RangeStart, destrange.m_Y1 + d.m_RangeStart & " - " & destrange.m_Y1 + d.m_RangeEnd)
          Else
            lnk = Range(ActiveSheet.Cells(destrange.m_Y1, destrange.m_X1 + d.m_RangeStart), ActiveSheet.Cells(destrange.m_Y2, destrange.m_X1 + d.m_RangeEnd)).Address
            lnkTxt = GetColumnLettersFromColumn(destrange.m_X1 + d.m_RangeStart, destrange.m_X1 + d.m_RangeEnd)
          End If
          
          ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).Value = IIf(d.m_RangeStart = d.m_RangeEnd, "'" & m_Y1 + d.m_RangeStart, "'" & m_Y1 + d.m_RangeStart & " - " & m_Y1 + d.m_RangeEnd)
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(fname)) & "#'" & _
            sheetname & "'!" & _
            lnk _
            & Chr(34) & "," & Chr(34) & _
            lnkTxt _
            & Chr(34) & ")"
    
          G_Result_Y = G_Result_Y + 1
        End If
      Next d
      G_Result_Y = G_Result_Y + 1
    End If
  End If
End Sub

Sub PrintCellDifferences(l As Long, Headline As String, fnameold As String, sheetnameold As String, fnamenew As String, sheetnamenew As String)

  Dim txts()
  'txts = Array("Ge|fffd|nderter Wert", "Ge|fffd|nderte Formel", "Ge|fffd|nderter Formelbereich", "Formel gel|fffd|scht", "Formel eingef|fffd|gt", "Wert gel|fffd|scht", "Wert eingef|fffd|gt", "Wert ge|fffd|ndert")
  txts = Array(FMT0("CArea_3"), FMT0("CArea_4"), FMT0("CArea_5"), FMT0("CArea_6"), FMT0("CArea_7"), FMT0("CArea_8"), FMT0("CArea_9"), FMT0("CArea_10"))

  Dim d As CCellDifference
  If m_Results(l).Count > 0 Then
    With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
      .value = Headline & ":"
      .Font.bold = True
    End With
    With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1)
      '.value = "Zelle alt (+ ggf. Clone):"
      .value = FMT0("CArea_11")
      .Font.bold = True
    End With
    With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2)
      '.value = "Inhalt:"
      .value = FMT0("CArea_12")
      .Font.bold = True
    End With
    With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 3)
      '.value = "Zelle neu:"
      .value = FMT0("CArea_13")
      .Font.bold = True
    End With
    With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4)
      '.value = "Inhalt:"
      .value = FMT0("CArea_12")
      .Font.bold = True
    End With
    G_Result_Y = G_Result_Y + 1
    For Each d In m_Results(l)
      If txts(d.m_ChangeID) <> "" Then
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = txts(d.m_ChangeID)
      End If
      Dim x As Long
      If d.m_CellOld <> "" Then
        ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 3).Value = d.m_CellOld
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(fnameold)) & "#'" & _
          sheetnameold & "'!" & d.m_CellOld _
          & Chr(34) & "," & Chr(34) & _
          d.m_CellOld _
          & Chr(34) & ")"
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).value = "'" & d.m_ValueOld
      End If
      If d.m_CellNew <> "" Then
        ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 5).Value = d.m_CellNew
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 3).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(fnamenew)) & "#'" & _
          sheetnamenew & "'!" & d.m_CellNew _
          & Chr(34) & "," & Chr(34) & _
          d.m_CellNew _
          & Chr(34) & ")"
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).value = "'" & d.m_ValueNew
      End If
      G_Result_Y = G_Result_Y + 1
      
      If Not d.m_CloneRange Is Nothing Then
        Dim rng As CRange
        For Each rng In d.m_CloneRange
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(fnameold)) & "#'" & _
          sheetnameold & "'!" & rng.Address _
          & Chr(34) & "," & Chr(34) & _
          rng.Address _
          & Chr(34) & ")"
          G_Result_Y = G_Result_Y + 1
        Next rng
      End If
      
    Next d
  End If

End Sub

Function HasDifferences() As Boolean
  Dim I As Long
  Dim K As Long
  For I = 0 To c_Area_DELETEDCOLUMNS
    If m_Results(I).Count > 0 Then
      Dim d As CDifference
      For Each d In m_Results(I)
        If d.m_Deleted = False Then
          HasDifferences = True
          Exit Function
        End If
      Next d
    End If
  Next I
  For I = c_Area_VALUECHANGES To c_Area_MAX_RES
    If m_Results(I).Count > 0 Then
      HasDifferences = True
    End If
  Next I
End Function

Sub CheckForOnlyFormulas(l As Long, ByRef ws As Worksheet)
    Dim notDeletedItems As Long
    Dim cnt As Long
    Dim fnd As Boolean
    
    Dim d As CDifference
    If G_ShowOnlyFormulas = True Then
      For Each d In m_Results(l)
        If l = c_Area_DELETEDCOLUMNS Or l = c_Area_ADDEDCOLUMNS Then
          fnd = False
          For cnt = d.m_RangeStart To d.m_RangeEnd
            If ColumnHasFormulas(ws, cnt) Then
              fnd = True
              Exit For
            End If
          Next cnt
          If Not fnd Then
            d.m_Deleted = True
          End If
        ElseIf l = c_Area_DELETEDLINES Or l = c_Area_ADDEDLINES Then
          fnd = False
          For cnt = d.m_RangeStart To d.m_RangeEnd
            If RowHasFormulas(ws, cnt) Then
              fnd = True
              Exit For
            End If
          Next cnt
          If Not fnd Then
            d.m_Deleted = True
          End If
        End If
      Next d
      
    End If
End Sub

Sub PrintResults(ByRef compareArea As CArea, ByRef ws1 As Worksheet, ByRef ws2 As Worksheet, ws1ParentFullName As String, ws2ParentFullName As String)

  CrunchDeletedAndAddedLines ws1, ws2, compareArea
  
  CheckForOnlyFormulas c_Area_DELETEDCOLUMNS, ws1
  CheckForOnlyFormulas c_Area_ADDEDCOLUMNS, ws2
  CheckForOnlyFormulas c_Area_DELETEDLINES, ws1
  CheckForOnlyFormulas c_Area_ADDEDLINES, ws2

  If HasDifferences Then
    With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
      '.value = "Zellbereich: "
      .value = FMT0("CArea_14")
      .Font.Color = RGB(255, 20, 20)
      .Font.Size = 12
      .Font.bold = True
    End With
      
    ' If m_X1 = compareArea.m_X1 And m_Y1 = compareArea.m_Y1 And m_X2 = compareArea.m_X2 And m_Y2 = compareArea.m_Y2 Then
    '  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).Value = Replace(Cells(m_Y1, m_X1).Address & " - " & Cells(m_Y2, m_X2).Address, "$", "")
    'Else
    ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).Value = "Alt: " & Replace(Cells(m_Y1, m_X1).Address & ":" & Cells(m_Y2, m_X2).Address, "$", "")
'    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & ws1ParentFullName & "#'" & _
'      ws1.name & "'!" & Replace(Cells(m_Y1, m_X1).Address & ":" & Cells(m_Y2, m_X2).Address, "$", "") _
'      & Chr(34) & "," & Chr(34) & _
'      "Alt: " & Replace(Cells(m_Y1, m_X1).Address & ":" & Cells(m_Y2, m_X2).Address, "$", "") _
'      & Chr(34) & ")"
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(ws1ParentFullName)) & "#'" & _
      ws1.name & "'!" & Replace(Cells(m_Y1, m_X1).Address & ":" & Cells(m_Y2, m_X2).Address, "$", "") _
      & Chr(34) & "," & Chr(34) & _
      FMT0("CArea_15") & Replace(Cells(m_Y1, m_X1).Address & ":" & Cells(m_Y2, m_X2).Address, "$", "") _
      & Chr(34) & ")"
    
    ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 3).Value = "Neu: " & Replace(Cells(compareArea.m_Y1, compareArea.m_X1).Address & ":" & Cells(compareArea.m_Y2, compareArea.m_X2).Address, "$", "")
'    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).formula = "=HYPERLINK(" & Chr(34) & ws2ParentFullName & "#'" & _
'      ws2.name & "'!" & Replace(Cells(compareArea.m_Y1, compareArea.m_X1).Address & ":" & Cells(compareArea.m_Y2, compareArea.m_X2).Address, "$", "") _
'      & Chr(34) & "," & Chr(34) & _
'      "Neu: " & Replace(Cells(compareArea.m_Y1, compareArea.m_X1).Address & ":" & Cells(compareArea.m_Y2, compareArea.m_X2).Address, "$", "") _
'      & Chr(34) & ")"
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(ws2ParentFullName)) & "#'" & _
      ws2.name & "'!" & Replace(Cells(compareArea.m_Y1, compareArea.m_X1).Address & ":" & Cells(compareArea.m_Y2, compareArea.m_X2).Address, "$", "") _
      & Chr(34) & "," & Chr(34) & _
      FMT0("CArea_16") & Replace(Cells(compareArea.m_Y1, compareArea.m_X1).Address & ":" & Cells(compareArea.m_Y2, compareArea.m_X2).Address, "$", "") _
      & Chr(34) & ")"
    
    'End If
    G_Result_Y = G_Result_Y + 1
    
    'PrintDifferences c_Area_DELETEDCOLUMNS, "Gel|fffd|schte Spalten", False, ws1ParentFullName, ws1.name, Me, ws1
    PrintDifferences c_Area_DELETEDCOLUMNS, FMT0("CArea_17"), False, ws1ParentFullName, ws1.name, Me, ws1
    'PrintDifferences c_Area_ADDEDCOLUMNS, "Hinzugef|fffd|gte Spalten", False, ws2ParentFullName, ws2.name, compareArea, ws2
    PrintDifferences c_Area_ADDEDCOLUMNS, FMT0("CArea_18"), False, ws2ParentFullName, ws2.name, compareArea, ws2
    'PrintDifferences c_Area_DELETEDLINES, "Gel|fffd|schte Zeilen", True, ws1ParentFullName, ws1.name, Me, ws1
    PrintDifferences c_Area_DELETEDLINES, FMT0("CArea_19"), True, ws1ParentFullName, ws1.name, Me, ws1
    'PrintDifferences c_Area_ADDEDLINES, "Hinzugef|fffd|gte Zeilen", True, ws2ParentFullName, ws2.name, compareArea, ws2
    PrintDifferences c_Area_ADDEDLINES, FMT0("CArea_20"), True, ws2ParentFullName, ws2.name, compareArea, ws2
    'PrintCellDifferences c_Area_FORMULACHANGES, "Formelver|fffd|nderungen", ws1ParentFullName, ws1.name, ws2ParentFullName, ws2.name
    PrintCellDifferences c_Area_FORMULACHANGES, FMT0("CArea_21"), ws1ParentFullName, ws1.name, ws2ParentFullName, ws2.name
    If G_ShowOnlyFormulas = False Then
      'PrintCellDifferences c_Area_VALUECHANGES, "Wertver|fffd|nderungen", ws1ParentFullName, ws1.name, ws2ParentFullName, ws2.name
      PrintCellDifferences c_Area_VALUECHANGES, FMT0("CArea_22"), ws1ParentFullName, ws1.name, ws2ParentFullName, ws2.name
    End If
  End If
  
End Sub

Private Sub CrunchDeletedAndAddedLines(ByRef ws1 As Worksheet, ByRef ws2 As Worksheet, ByRef a2 As CArea)
  Dim d1 As CDifference
  Dim d2 As CDifference
  Dim c1 As Range
  Dim c2 As Range
  Dim x As Long
  Dim y As Long
  
  
  If m_Results(c_Area_DELETEDLINES).Count > 0 And m_Results(c_Area_ADDEDLINES).Count > 0 Then
    
    For Each d1 In m_Results(c_Area_DELETEDLINES)
      For Each d2 In m_Results(c_Area_ADDEDLINES)
        If d1.m_RangeStart = d2.m_RangeStart And d1.m_RangeEnd = d2.m_RangeEnd Then
        
          Dim h As Long
          For h = 0 To d1.m_RangeEnd - d1.m_RangeStart
            CompareLine ws1, ws2, a2, d1.m_RangeStart + h, d2.m_RangeStart + h, True
          Next h
          d1.m_Deleted = True
          d2.m_Deleted = True
        End If
      Next d2
    Next d1
  End If

End Sub

Sub AddAddedOrDeletedRowOrCollumn(arrPos As Long, v As Long)
  Dim d As CDifference
  Dim found As Boolean
  For Each d In m_Results(arrPos)
    If v = d.m_RangeStart - 1 Or v = d.m_RangeEnd + 1 Then
      If v = d.m_RangeStart - 1 Then d.m_RangeStart = v
      If v = d.m_RangeEnd + 1 Then d.m_RangeEnd = v
      found = True
      Exit For
    End If
  Next d
  
  If Not found Then
    Set d = New CDifference
    d.m_RangeStart = v
    d.m_RangeEnd = v
    m_Results(arrPos).Add d
  End If
End Sub


Sub FindBestLines(ByRef A As CArea, ByRef ws1 As Worksheet, ByRef ws2 As Worksheet, ByRef l1 As Long, ByRef l2 As Long)

  l1 = -1
  l2 = -2
  
  Dim bestLineVal1 As Long, bestLineVal2 As Long
  
  bestLineVal1 = 0
  bestLineVal2 = 0
  

  ' Jetzt durch jede Zeile durch und schauen, ob sich etwas ge|fffd|ndert hat
  
  Dim clines As Collection
  Set clines = New Collection
  
  Dim lastline As Long
  lastline = 0
  
  A.FillUpLines clines, ws2, lastline, MAX_HEADLINE_CHECK
  
  Dim I As Long
  Dim cl1 As CLine
  Dim cl2 As CLine
  For I = 0 To IIf(Height() - 1 > MAX_HEADLINE_CHECK, MAX_HEADLINE_CHECK, Height() - 1)
    If clines.Count > 0 Then
      GetNewLine cl1, I, ws1
      Dim checkFinished As Boolean
      checkFinished = False
      Dim lineCount As Long
      lineCount = 1
      For Each cl2 In clines
        If cl1.m_Str = cl2.m_Str Then
          clines.Remove lineCount
          A.FillUpLines clines, ws2, lastline, MAX_HEADLINE_CHECK
          checkFinished = True
          Exit For
        End If
        lineCount = lineCount + 1
      Next cl2
      
      ' Wenn nichts identisches gefunden wurde muss pro Zeile geschaut werden, welche die
      ' gr|fffd||fffd|te |fffd|bereinstimmung hat.
      If checkFinished = False Then
        Dim bestLine As Long
        Dim compareVal As Long
        bestLine = -1
        compareVal = 0
        lineCount = 1
        For Each cl2 In clines
          Dim tCompareVal As Long
          tCompareVal = CompareLine(ws1, ws2, A, cl1.m_Line, cl2.m_Line, False)
          If tCompareVal > compareVal Then
            bestLine = lineCount
          End If
          lineCount = lineCount + 1
        Next cl2
        
        If bestLine >= 0 Then
          CompareLine ws1, ws2, A, cl1.m_Line, clines(bestLine).m_Line, True
          clines.Remove bestLine
          A.FillUpLines clines, ws2, lastline, MAX_HEADLINE_CHECK
        Else
          ' Keine Zeile gefunden!
          Debug.Print "Zeile gel|fffd|scht: " & m_Y1 + cl1.m_Line
        End If
        
      End If
      Set cl1 = Nothing
    Else
      ' Hoppala, nichts mehr zum Comparen?
      Debug.Print "Gel|fffd|schte Zeile: " & m_Y1 + I
    End If
  Next I
  
  If clines.Count > 0 Then
    For Each cl2 In clines
      Debug.Print "Hinzugef|fffd|gte Zeile: " & A.m_Y1 + cl2.m_Line
    Next cl2
  End If

End Sub

Sub AddCellChange(l As Long, changeID As Long, ByRef oldcell As Range, ByRef newcell As Range, oldval As String, newval As String, _
  Optional formularR1C1old As String = "", Optional formularR1C1new As String = "")
  
  Dim c As CCellDifference
  If formularR1C1old <> "" Then
    For Each c In m_Results(l)
      If c.CheckForClone(formularR1C1old, formularR1C1new, oldcell) Then
        Exit Sub
      End If
    Next c
  End If
  Set c = New CCellDifference
  c.m_ChangeID = changeID
  If Not oldcell Is Nothing Then
    c.m_CellOld = Replace(oldcell.Address, "$", "")
  End If
  If Not newcell Is Nothing Then
    c.m_CellNew = Replace(newcell.Address, "$", "")
  End If
  c.m_ValueOld = oldval
  c.m_ValueNew = newval
  c.m_FormulaR1C1Old = formularR1C1old
  c.m_FormulaR1C1New = formularR1C1new
  m_Results(l).Add c
End Sub

Function CompareLine(ByRef ws1 As Worksheet, ByRef ws2 As Worksheet, ByRef a2 As CArea, line1 As Long, line2 As Long, PrintResults As Boolean) As Long
  Dim i1 As Long, i2 As Long
  Dim res As Long
  res = 0
  Dim x1 As Long, y1 As Long
  Dim x2 As Long, y2 As Long
  
  x1 = m_X1
  y1 = m_Y1 + line1
  x2 = a2.m_X1
  y2 = a2.m_Y1 + line2
  
  
  ' Erst mal nur f|fffd|r die Zellen in Range 1
  For i1 = 0 To Width - 1
    i2 = GetCorrespondingColumn(i1)
    If i2 >= 0 Then
        CompareCell ws1.Cells(y1, x1 + i1), ws2.Cells(y2, x2 + i2), res, PrintResults
    End If
  Next i1
  
  ' Jetzt k|fffd|nnten aber auch noch Zellen in Range 2 "|fffd|ber" sein. Machen wir aber nur wenn auch printResults = true ist
  If PrintResults = True Then
    If a2.Width > Width Then
      For i1 = i1 To a2.Width - 1
        CompareCell ws1.Cells(y1, x1 + i1), ws2.Cells(y2, x2 + i1), res, PrintResults
      Next i1
    End If
  End If
  
  CompareLine = res

End Function

Sub CompareCell(ByRef c1 As Range, ByRef c2 As Range, ByRef res As Long, ByVal PrintResults As Boolean)
        
        If c1.HasFormula = True And c2.HasFormula = True Then
          If FormulaR1C1HasError(c1) = False And FormulaR1C1HasError(c2) = False Then
            If c1.formulaR1C1 = c2.formulaR1C1 Or _
               c1.formula = c2.formula Then
               res = res + 40
            ElseIf RemoveRelativeCells(c1.formulaR1C1) = RemoveRelativeCells(c2.formulaR1C1) Then
              ' Wenn die Formel, aber nicht die Bereiche identisch sind.
               res = res + 20
               If PrintResults Then
'                  Debug.Print "Formelbereich modifiziert: y:" & y1 & " x: " & x1 + i1 & " ALT: " & CStr(c1.formula) & " NEU: " & CStr(c2.formula)
                  AddCellChange c_Area_FORMULACHANGES, c_Cell_Change_Text_AREA_CHANGED, c1, c2, CStr(c1.formula), CStr(c2.formula), CStr(c1.formulaR1C1), CStr(c2.formulaR1C1)
               End If
            Else
              If PrintResults Then
                AddCellChange c_Area_FORMULACHANGES, c_Cell_Change_Text_FORMULA_CHANGED, c1, c2, CStr(c1.formula), CStr(c2.formula), CStr(c1.formulaR1C1), CStr(c2.formulaR1C1)
              End If
            End If
          Else
            If IsError(c1) = False And IsError(c2) = False Then
              If c1.formula = c2.formula Then
                 res = res + 40
              End If
            End If
          End If
        ElseIf c2.HasFormula = True Then
          If PrintResults Then
            ' Debug.Print "Formel eingef|fffd|gt: y:" & y2 & " x: " & x2 + i2 & " ALT: leer NEU: " & CStr(c2.formula)
            AddCellChange c_Area_FORMULACHANGES, c_Cell_Change_Text_FORMULA_INSERTED, c1, c2, CStr(c1.value), CStr(c2.formula)
          End If
        ElseIf c1.HasFormula = True Then
          If PrintResults Then
'            Debug.Print "Formel gel|fffd|scht: y:" & y1 & " x: " & x1 + i1 & " ALT: " & CStr(c1.formula) & " NEU: leer"
            AddCellChange c_Area_FORMULACHANGES, c_Cell_Change_Text_FORMULA_DELETED, c1, c2, CStr(c1.formula), CStr(c2.value)
          End If
        ElseIf Not IsEmpty(c1) And Not IsEmpty(c2) Then
          If IsText(CStr(c1.value)) = True And IsText(CStr(c2.value)) = True Then
            If CStr(c1.value) = CStr(c2.value) Then
               res = res + 40
            Else
              If PrintResults Then
'                Debug.Print "Text modifiziert: y:" & y1 & " x: " & x1 + i1 & " ALT: " & CStr(c1.Value) & " NEU: " & CStr(c2.Value)
                If G_ShowOnlyFormulas = False Then AddCellChange c_Area_VALUECHANGES, c_Cell_Change_Text_TEXT_CHANGED, c1, c2, CStr(c1.value), CStr(c2.value)
              End If
            End If
          Else
            If CStr(c1.value) = CStr(c2.value) Then
               res = res + 30
            Else
              If PrintResults Then
'                Debug.Print "Wert modifiziert: y:" & y1 & " x: " & x1 + i1 & " ALT: " & CStr(c1.Value) & " NEU: " & CStr(c2.Value)
                If G_ShowOnlyFormulas = False Then AddCellChange c_Area_VALUECHANGES, c_Cell_Change_Text_VALUE_CHANGED, c1, c2, CStr(c1.value), CStr(c2.value)
              End If
            End If
          End If
        ElseIf Not IsEmpty(c1) Then
          If PrintResults Then
            ' Debug.Print "Zelle gel|fffd|scht: y:" & y1 & " x: " & x1 + i1 & " ALT: " & CStr(c1.Value) & " NEU: leer"
            If G_ShowOnlyFormulas = False Then AddCellChange c_Area_VALUECHANGES, c_Cell_Change_Text_VALUE_DELETED, c1, c2, CStr(c1.value), "[leer]"
          End If
        ElseIf Not IsEmpty(c2) Then
          If PrintResults Then
            ' Debug.Print "Zelle eingef|fffd|gt: y:" & y2 & " x: " & x2 + i2 & " ALT: leer NEU: " & CStr(c2.Value)
            If G_ShowOnlyFormulas = False Then AddCellChange c_Area_VALUECHANGES, c_Cell_Change_Text_VALUE_INSERTED, c1, c2, "[leer]", CStr(c2.value)
          End If
        ElseIf IsEmpty(c1) = True And IsEmpty(c2) = True Then
            res = res + 1
        Else
          Debug.Print "Unknown"
        End If
End Sub


Function Touches(ByRef a2 As CArea) As Boolean
If ((a2.m_X1 >= m_X1 And a2.m_X1 <= m_X2) Or _
 (a2.m_X2 >= m_X1 And a2.m_X2 <= m_X2)) And _
 ((a2.m_Y1 >= m_Y2 And a2.m_Y1 <= m_Y1) Or _
 (a2.m_Y2 >= m_Y2 And a2.m_Y2 <= m_Y1)) Then
  Touches = True
 Else
  Touches = False
 End If
 
 
' If ((dblLeft2 >= dblLeft1 And dblLeft2 <= dblRight1) Or _
'  (dblRight2 >= dblLeft1 And dblRight2 <= dblRight1)) And _
'  ((dblTop2 >= dblBottom1 And dblTop2 <= dblTop1) Or _
'  (dblBottom2 >= dblBottom1 And dblBottom2 <= dblTop1)) Then
'  ShapesOverlap = True
'  Else
'  ShapesOverlap = False
'  End If
 
End Function

Function ColumnHasFormulas(ByRef ws As Worksheet, c As Long) As Boolean
  ColumnHasFormulas = False
  On Error GoTo nogo
  
  Dim y As Long
  For y = m_Y1 To m_Y2
    If ws.Cells(y, m_X1 + c).HasFormula And ws.Cells(y, m_X1 + c).formula <> "" Then
      ColumnHasFormulas = True
      Exit Function
    End If
  Next y
  
nogo:
End Function

Function RowHasFormulas(ByRef ws As Worksheet, r As Long) As Boolean
  RowHasFormulas = False
  On Error GoTo nogo
  
  Dim x As Long
  For x = m_X1 To m_X2
    If ws.Cells(m_Y1 + r, x).HasFormula And ws.Cells(m_Y1 + r, x).formula <> "" Then
      RowHasFormulas = True
      Exit Function
    End If
  Next x
  
nogo:
End Function


Function AreaHasFormulas(ByRef ws As Worksheet) As Boolean
  AreaHasFormulas = False
  On Error GoTo nogo
  
  Dim x As Long
  Dim y As Long
  For y = m_Y1 To m_Y2
    For x = m_X1 To m_X2
      If ws.Cells(y, x).HasFormula And ws.Cells(y, x).formula <> "" Then
        AreaHasFormulas = True
        Exit Function
      End If
    Next x
  Next y
  
nogo:
End Function


Attribute VB_Name = "CCellDifference"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_ChangeID As Long
Public m_CellOld As String
Public m_CellNew As String
Public m_ValueOld As String
Public m_ValueNew As String
Public m_FormulaR1C1Old As String
Public m_FormulaR1C1New As String
Public m_CloneRange As Collection

Function CheckForClone(formulaR1C1old As String, formulaR1C1new As String, ByRef c As Range) As Boolean
  If m_FormulaR1C1Old <> "" Then
    If m_FormulaR1C1Old = formulaR1C1old And m_FormulaR1C1Old = formulaR1C1old Then
      CheckForClone = True
      If m_CloneRange Is Nothing Then
        Set m_CloneRange = New Collection
      End If
      Dim r As CRange
      Dim found As Boolean
      found = False
      For Each r In m_CloneRange
        If r.CheckCellInRange(c.Row, c.Column) Then
          r.AddCellToRange c.Row, c.Column
          found = True
          Exit For
        End If
      Next r
      If Not found Then
        Set r = New CRange
        r.SetCell c.Row, c.Column
        m_CloneRange.Add r
      End If
    End If
  End If
End Function
Attribute VB_Name = "CDifference"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_RangeStart As Long
Public m_RangeEnd As Long
Public m_Deleted As Boolean

Attribute VB_Name = "CLine"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Line As Long
Public m_Str As String
Public m_StrFormulas As String
Public m_FilledCollumns As Long
Attribute VB_Name = "CLogEntry"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Datetime As Date
Public m_DebugType As Long
Public m_Str As String
Public m_Dur As Double
Public m_LogExp As Long
Public m_idvDateiID As Long

Attribute VB_Name = "CName"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Name As String
Public m_Value As String
Attribute VB_Name = "CRange"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_X1 As Long
Public m_X2 As Long
Public m_Y1 As Long
Public m_Y2 As Long

Sub SetCell(y As Long, x As Long)
  m_X1 = x
  m_X2 = x
  m_Y1 = y
  m_Y2 = y
End Sub

Function CheckCellInRange(y As Long, x As Long) As Boolean
  If x >= m_X1 - 1 And x <= m_X2 + 1 And _
     y >= m_Y1 - 1 And y <= m_Y2 + 1 Then
    CheckCellInRange = True
  End If
End Function

Sub AddCellToRange(y As Long, x As Long)
  If x < m_X1 Then m_X1 = x
  If y < m_Y1 Then m_Y1 = y
  If x > m_X2 Then m_X2 = x
  If y > m_Y2 Then m_Y2 = y
End Sub

Function CheckAddCell(y As Long, x As Long) As Boolean
  If x >= m_X1 - 1 And x <= m_X2 + 1 And _
     y >= m_Y1 - 1 And y <= m_Y2 + 1 Then
     
    CheckAddCell = True
    If x < m_X1 Then m_X1 = x
    If y < m_Y1 Then m_Y1 = y
    If x > m_X2 Then m_X2 = x
    If y > m_Y2 Then m_Y2 = y
  End If
End Function

Function Address() As String
  If m_X1 = m_X2 And m_Y1 = m_Y2 Then
    Address = Replace(Cells(m_Y1, m_X1).Address, "$", "")
  Else
    Address = Replace(Cells(m_Y1, m_X1).Address & ":" & Cells(m_Y2, m_X2).Address, "$", "")
  End If
End Function


Attribute VB_Name = "CfgReader"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Dim m_Lines As Collection
Dim m_Sec As Collection

Private Function GetNextLine(ByRef s As String) As String

    Dim rs As String
    Do
        rs = GetLine(s)
        If Len(Trim(rs)) > 0 Then
            GetNextLine = Trim(rs)
            Exit Function
        End If
        If Len(Trim(s)) <= 0 Then
            GetNextLine = ""
            s = ""
            Exit Function
        End If
    Loop
End Function


Public Sub GetCFGString(ByVal txt As String)
    If m_Lines Is Nothing Then
      Set m_Lines = New Collection
      Set m_Sec = New Collection
    End If
    If Len(txt) = 0 Then Exit Sub
    Dim s As String
    Do
        s = GetNextLine(txt)
        If Len(s) <= 0 Then Exit Do
        If UCase(Left(s, 9)) = "MERGECFG " Then
          GetCfgUniversal Mid(s, 10)
        Else
          If Len(Trim(s)) > 0 Then
            m_Lines.Add s
          End If
          m_Sec.Add s
        End If
    Loop
End Sub

Function GetCfgUTF8(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    Dim adoStream As Object
    Set adoStream = CreateObject("ADODB.Stream")
    
    adoStream.Charset = "UTF-8"
    adoStream.Open
    adoStream.LoadFromFile fname
    GetCFGString adoStream.ReadText
    adoStream.Close
    Set adoStream = Nothing
    GetCfgUTF8 = True
    Exit Function

couldntOpenFile:
  GetCfgUTF8 = False

End Function

Private Function GetEncodingString(encoding As Long) As String
    Select Case encoding
    Case CP_ACP: GetEncodingString = "ANSI"
    Case CP_UTF8: GetEncodingString = "UTF8"
    Case CP_UTF16_LE: GetEncodingString = "UTF16 LE"
    Case CP_UTF16_BE: GetEncodingString = "UTF16 BE"
    Case CP_UTF32_LE: GetEncodingString = "UTF32 LE"
    Case CP_UTF32_BE: GetEncodingString = "UTF32 BE"
    Case Else: GetEncodingString = "Codepage " & CStr(encoding)
    End Select
End Function

Private Function GetCfgUniversal(fname As String) As Boolean
  On Error GoTo couldntOpenFile
    'Dim ff As Long
    'ff = FreeFile
    'Call OpenForInput(fname, ff, encoding)
    Dim encoding As Long
    Dim fileContents As String
    Dim bom As Boolean
    fileContents = GetContents(fname, encoding, -1, bom)
    DebugPrint tinfo, fname & " opened with encoding: " & GetEncodingString(encoding) & IIf(bom, " BOM", " no BOM")
    
    Call GetCFGString(fileContents)
    GetCfgUniversal = True
    
    Exit Function

couldntOpenFile:
  GetCfgUniversal = False
End Function

Function GetCfg(fname As String) As Boolean
  On Error GoTo couldntOpenFile
'  Dim ff As Long
'  ff = FreeFile
'  Dim s As String
'
'  ' check for UTF8!
'  Open fname For Binary Access Read As #ff
'  Dim l As Byte
'  Get #ff, 1, l
'  Close ff
'
'  If l = 239 Then
'    GetCfg = GetCfgUTF8(fname)
'    Exit Function
'  End If
'
'
'  Open fname For Input As #ff
'  Set m_Lines = New Collection
'  Set m_Sec = New Collection
'
'  Do While Not EOF(ff)
'    Line Input #ff, s
'    If Len(Trim(s)) > 0 Then
'      m_Lines.add s
'    End If
'    m_Sec.add s
'  Loop
'  Close #ff
  Set m_Lines = New Collection
  Set m_Sec = New Collection
  Call GetCfgUniversal(fname)
  
  GetCfg = True
  Exit Function
couldntOpenFile:
  GetCfg = False
End Function

Function GetSection(sec As String) As Boolean
  Set m_Sec = New Collection
  GetSection = GetSectionValues(sec, m_Sec)
End Function

Function GetValue(s As String) As String
  Dim I As Long
  If m_Sec Is Nothing Then Exit Function
  For I = 1 To m_Sec.Count
    If Left(m_Sec(I), Len(s) + 1) = s & "=" Then
      GetValue = Trim(Mid(m_Sec(I), Len(s) + 2))
      Exit Function
    ElseIf Left(m_Sec(I), Len(s) + 1) = s & " " Then
        Dim pos As Long
        pos = InStr(m_Sec(I), "=")
        If pos > 0 Then
            GetValue = Trim(Mid(m_Sec(I), pos + 1))
            Exit Function
        End If
    End If
  Next I
  GetValue = ""
End Function

Function GetSectionValues(sec As String, ByRef c As Collection) As Boolean
  Set c = New Collection
  Dim I As Long
  Dim found As Boolean
  found = False
  If Not m_Lines Is Nothing Then
    For I = 1 To m_Lines.Count
      If m_Lines(I) = "[" & sec & "]" Then
        I = I + 1
        Do While I <= m_Lines.Count
          If Left(m_Lines(I), 1) <> "[" Then
            c.Add m_Lines(I)
            found = True
            I = I + 1
          Else
            Exit Do
          End If
        Loop
      End If
      If I > m_Lines.Count Then Exit For
    Next I
  End If
  GetSectionValues = found
End Function


Attribute VB_Name = "Consts"
Option Explicit

' Gibt an, bis wohin eine Zelle horizontal verschoben sein darf, bis sie noch "als gleich" gilt.
Public Const MAX_COL_CHECK As Long = 5
Public Const MAX_COL_CHECK_X_MAX_COL_CHECK As Long = MAX_COL_CHECK * MAX_COL_CHECK

' Gibt an, wieviele Leerspalten und Zeilen zwischen einer Area liegen d|fffd|rfen, bis sie noch als zusammen-
' geh|fffd|rig gilt
' Public Const MAX_LEERZELLEN As Long = 0

' Gibt an, wie viele Zeilen nach unten gesucht werden soll
Public Const MAX_LINES_COMPARE As Long = 20

' Wie viele Zeilen werden gepr|fffd|ft, um im oberen Bereich eines Zellbereichs gleiche Zellen zu finden. Je mehr
' zeilen es sind, um so mehr muss gepr|fffd|ft werden.
Public Const MAX_HEADLINE_CHECK As Long = 5
' Das Ganze noch mal f|fffd|r die "Breite"
Public Const MAX_WIDTH_CHECK As Long = 20


Public Const c_Area_ADDEDLINES As Long = 0
Public Const c_Area_DELETEDLINES As Long = 1
Public Const c_Area_ADDEDCOLUMNS As Long = 2
Public Const c_Area_DELETEDCOLUMNS As Long = 3
Public Const c_Area_VALUECHANGES As Long = 4
Public Const c_Area_FORMULACHANGES As Long = 5

Public Const c_Area_MAX_RES As Long = c_Area_FORMULACHANGES


Public Const c_Cell_Change_Text_VALUE_CHANGED As Long = 0
Public Const c_Cell_Change_Text_FORMULA_CHANGED As Long = 1
Public Const c_Cell_Change_Text_AREA_CHANGED As Long = 2
Public Const c_Cell_Change_Text_FORMULA_DELETED As Long = 3
Public Const c_Cell_Change_Text_FORMULA_INSERTED As Long = 4
Public Const c_Cell_Change_Text_VALUE_DELETED As Long = 5
Public Const c_Cell_Change_Text_VALUE_INSERTED As Long = 6
Public Const c_Cell_Change_Text_TEXT_CHANGED As Long = 7

Attribute VB_Name = "Crypter"
Option Explicit


Function Crypt(Inp As String, Key As String, encrypt As Boolean) As String
    Dim z As String
    Dim I As Integer, Position As Integer
    Dim cptZahl As Long, orgZahl As Long
    Dim keyZahl As Long, cptString As String
    
    For I = 1 To Len(Inp)
            Position = Position + 1
            If Position > Len(Key) Then Position = 1
            keyZahl = Asc(Mid(Key, Position, 1))
            
            If encrypt Then
            
                'Verschl|fffd|sseln
                orgZahl = Asc(Mid(Inp, I, 1))
                cptZahl = orgZahl Xor keyZahl
                cptString = Hex(cptZahl)
                If Len(cptString) < 2 Then cptString = "0" & cptString
                z = z & cptString
            
            Else
            
                'Entschl|fffd|sseln
                If I > Len(Inp) \ 2 Then Exit For
                cptZahl = CByte("&H" & Mid$(Inp, I * 2 - 1, 2))
                orgZahl = cptZahl Xor keyZahl
                z = z & Chr$(orgZahl)
            
            End If
        Next I
     
        Crypt = z
End Function



Attribute VB_Name = "DBHandler"
Option Explicit


Const dhcHKeyClassesRoot = &H80000000
Const dhcHKeyCurrentUser = &H80000001
Const dhcHKeyLocalMachine = &H80000002

Public Enum ERegistryValueTypes
'Predefined Value Types
    REG_NONE = (0)                         'No value type
    REG_SZ = (1)                           'Unicode nul terminated string
    REG_EXPAND_SZ = (2)                    'Unicode nul terminated string w/enviornment var
    REG_BINARY = (3)                       'Free form binary
    REG_DWORD = (4)                        '32-bit number
    REG_DWORD_LITTLE_ENDIAN = (4)          '32-bit number (same as REG_DWORD)
    REG_DWORD_BIG_ENDIAN = (5)             '32-bit number
    REG_LINK = (6)                         'Symbolic Link (unicode)
    REG_MULTI_SZ = (7)                     'Multiple Unicode strings
    REG_RESOURCE_LIST = (8)                'Resource list in the resource map
    REG_FULL_RESOURCE_DESCRIPTOR = (9)     'Resource list in the hardware description
    REG_RESOURCE_REQUIREMENTS_LIST = (10)
End Enum

Private Const KEY_QUERY_VALUE = &H1
Private Const KEY_ENUMERATE_SUB_KEYS = &H8
Private Const KEY_NOTIFY = &H10

Private Const KEY_READ = KEY_QUERY_VALUE Or _
                         KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY

Public Const ERROR_SUCCESS = 0&

#If VBA7 Then
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
              dwMilliseconds As Long)

Private Declare PtrSafe Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" _
  (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, _
  ByVal samDesired As Long, phkResult As Long) As Long

Private Declare PtrSafe Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" _
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue _
    As Long) As Long

Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" _
    (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As _
    Long, lpType As Long, lpData As Any, lpcbData As Any) As Long

Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

#Else
Public Declare Sub Sleep Lib "kernel32" (ByVal _
              dwMilliseconds As Long)

Private Declare Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" _
  (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, _
  ByVal samDesired As Long, phkResult As Long) As Long

Private Declare Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" _
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal lpValue As String, lpcbValue _
    As Long) As Long

Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" _
    (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As _
    Long, lpType As Long, lpData As Any, lpcbData As Any) As Long

Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

#End If

' Test

Function OpenRS(ByVal sqlstring As String, ByRef conn As Object, ByVal cursorytype As ADODB.CursorTypeEnum, ByVal locktype As ADODB.LockTypeEnum) As Object
        
        Dim rs As Object
        Set rs = CreateObject("ADODB.Recordset")
        On Error Resume Next

        Set OpenRS = Nothing
        Dim cnt As Long
        cnt = 0

        Dim tabname As String
        Dim pos As Integer
        pos = InStr(UCase(sqlstring), " FROM ")
        If pos > 0 Then
            Dim pos2 As Integer
            pos2 = InStr(pos + 6, sqlstring, " ")
            If pos2 > 0 Then
                tabname = Mid(sqlstring, pos + 6, pos2 - pos - 6)
            Else
                tabname = Mid(sqlstring, pos + 6)
            End If
        End If

        DebugPrint DebType.tdebug, tabname & " |fffd|ffnen-" & locktype & "-" & sqlstring

'        rs.CursorLocation = adUseClient

checkAgain:
        rs.Open sqlstring, conn, cursorytype, locktype
'        Debug.Print IsError(rs.Status)
        
        If Err.Number <> 0 Then
            Dim terrs As String
            terrs = Err.Number & "-" & Err.Description
            Err.Clear
            Sleep C_RepeatRSOpenSleep
            cnt = cnt + 1
            If cnt >= G_PARAM_TimeoutTableOpen / C_RepeatRSOpenSleep Then
                rs.Close
                Set rs = Nothing
                DebugPrint DebType.terror, tabname & " |fffd|ffnen fehlgeschlagen-" & terrs
                Set OpenRS = Nothing
                Exit Function
            End If
            GoTo checkAgain
        End If

        DebugPrint DebType.tTime, tabname & " erfolgreich"
        Set OpenRS = rs
    End Function

Function GetConnection(Optional ByVal waitendless As Boolean = False) As Object

        Err.Clear
        On Error Resume Next
        
        If G_UserDeaktiviert Then
          Exit Function
        End If
        
        DebugPrint DebType.tdebug, "Connect Start"
        
'        Dim conn As New ADODB.Connection
        Dim conn As Object
        Set conn = CreateObject("ADODB.Connection")
        If G_Cursorlocation <> ADODB.adUseClient And G_Cursorlocation <> ADODB.adUseServer Then
          G_Cursorlocation = ADODB.adUseClient
        End If
        conn.CursorLocation = G_Cursorlocation
        Set GetConnection = Nothing
        Dim cnt As Long
        cnt = 0

        Dim tim As Single
        tim = Timer
checkAgain:
        conn.ConnectionTimeout = CLng(G_PARAM_TimeoutConnection / 1000)
        
        conn.Open G_DBConnectionString, G_DBUser, G_DBUserPasswort

        If Err.Number <> 0 Then
            Err.Clear
            Sleep C_RepeatConnOpenSleep
            cnt = cnt + 1
            If Not waitendless Then
                If Timer >= tim + G_PARAM_TimeoutConnection / 1000 Then
'                If cnt >= G_PARAM_TimeoutConnection / C_RepeatConnOpenSleep Then
                    Set conn = Nothing
                    Exit Function
                End If
                GoTo checkAgain
            End If
        End If
        ' Debug.Print conn.Properties("Jet OLEDB:Lock Delay")
        ' Debug.Print conn.Properties("Jet OLEDB:Lock Retry")
        
        conn.Execute "SET LOCK_TIMEOUT 5000"
        conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
'        conn.Properties("Jet OLEDB:Lock Retry") = 1 ' 90 + Int(Rnd * 60)
        
        ' Oracle auf Case Insensitive umstellen
        conn.Execute "alter session set nls_comp=linguistic;"
        conn.Execute "alter session set nls_sort=binary_ci"
        
        Err.Clear
        Set GetConnection = conn


End Function

Function GetValueFromField(ByRef rs As Object, fieldname As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetValueFromField = defvalue
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetValueFromField = rs.Fields(fieldname).value
  End If
  
nogo:
  
End Function

Function GetLocValueFromField(ByRef rs As Object, fieldname As String, locFieldName As String, defvalue) As Variant
  On Error GoTo nogo
    
  GetLocValueFromField = defvalue
  If Not IsNull(rs.Fields(locFieldName).value) Then
    GetLocValueFromField = rs.Fields(locFieldName).value
  ElseIf Not IsNull(rs.Fields(fieldname).value) Then
    GetLocValueFromField = rs.Fields(fieldname).value
  End If
  
nogo:
  
  
End Function

Function Verf|fffd|gbar(ByRef conn As Object) As Boolean
  
  On Error GoTo notok
  
  If G_cfgTestuser Then
    Verf|fffd|gbar = True
    Exit Function
  End If
  
  If G_UserDeaktiviert Then
    Verf|fffd|gbar = False
    Exit Function
  End If
  
  Dim rs As Object
  Verf|fffd|gbar = False
  Set rs = OpenRS("SELECT * FROM gParameterSystem", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
  If rs Is Nothing Then
      Exit Function
  End If

  If Not rs.EOF Then
  
      If IsNull(rs.Fields("GlobalLock").value) Then
        DebugPrint DebType.terror, "GlobalLock in gParameterSystem ist NULL (1)"
      ElseIf IsNull(rs.Fields("Deaktiviert").value) Then
        DebugPrint DebType.terror, "Deaktiviert in gParameterSystem ist NULL (1)"
      Else
        If rs.Fields("GlobalLock").value = False And rs.Fields("Deaktiviert").value = False Then
            Verf|fffd|gbar = True
        End If
      End If
  End If

  rs.Close
  Set rs = Nothing
  Exit Function
notok:
    DebugPrint DebType.terror, "Verf|fffd|gbar() fehlgeschlagen" & Err.Number & " - " & Err.Description & " - " & Err.source
End Function


Function Deaktiviert(ByRef conn As Object) As Boolean

    On Error GoTo notok

    Deaktiviert = False

    If G_cfgTestuser Then Exit Function

    If G_UserDeaktiviert Then
      Deaktiviert = True
      Exit Function
    End If
    
    Dim rs As Object
    Set rs = OpenRS("SELECT * FROM gParameterSystem", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)

    If rs Is Nothing Then
        Deaktiviert = True
        Exit Function
    End If

    If rs.EOF Then
        Deaktiviert = True
    Else
        If Not IsNull(rs.Fields("Deaktiviert").value) Then
          Deaktiviert = rs.Fields("Deaktiviert").value
        Else
          DebugPrint DebType.terror, "Deaktiviert in gParameterSystem ist NULL (2)"
          Deaktiviert = True
        End If
    End If
    rs.Close
    Set rs = Nothing
    Exit Function
notok:
    DebugPrint DebType.terror, "Deaktiviert() fehlgeschlagen" & Err.Number & " - " & Err.Description & " - " & Err.source
    Deaktiviert = True
End Function



Function IsRecordLocked(ByRef conn As Object, ByRef rst As Object, table As String, fld As String, testvalue As String) As Boolean
    
    On Error GoTo RecordLockedError
    
    With rst
        ' If no record is found, display message, return False, and exit.
        If .EOF Then
          IsRecordLocked = False
          GoTo IsRecordLockedExit
        End If
        
        ' Attempt to edit a value in the record. If this succeeds,
        ' return False; otherwise an error will be triggered.
        .Field(fld) = testvalue
        IsRecordLocked = False
    End With
    
IsRecordLockedExit:
    rst.CancelUpdate
    Exit Function
    
RecordLockedError:
    Select Case conn.Errors(0).SqlState
    ' Record is locked.
    Case 3260
      IsRecordLocked = True
      GoTo IsRecordLockedExit
    Case Else
      Resume Next
    End Select
End Function


Public Sub SetLastProgramStart(ByRef conn As Object)
    On Error Resume Next
    Dim drs As Object
    Set drs = CreateObject("ADODB.Recordset")
    drs.Open "SELECT * FROM idvLastAccess WHERE LogonID = '" & UCase(GetUserName) & "' AND ProgramID=" & MyAppID, conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    If drs.EOF Then
      drs.AddNew
    End If
    drs.Fields("LogonID").value = UCase(GetUserName)
    drs.Fields("ProgramID").value = MyAppID
    drs.Fields("AccessDate").value = Now
    drs.Update
    drs.Close
    Set drs = Nothing
End Sub



Function GetSafeField(ByRef rs As Object, ByVal fieldname As String) As String
  On Error Resume Next
  GetSafeField = ""
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetSafeField = rs.Fields(fieldname).value
  End If
End Function

Function GetSafeFieldPlus(ByRef rs As Object, ByVal fieldname As String, Optional defaultVal As Variant) As Variant
  On Error GoTo nogo
  If Not IsNull(rs.Fields(fieldname).value) Then
    GetSafeFieldPlus = rs.Fields(fieldname).value
  Else
    If Not IsMissing(defaultVal) Then
      GetSafeFieldPlus = defaultVal
    End If
  End If
  Exit Function
nogo:
  If Not IsMissing(defaultVal) Then
    GetSafeFieldPlus = defaultVal
  End If
End Function

Function FieldExists(ByRef rs As Recordset, fldName As String) As Boolean
  On Error GoTo nogo
  Dim s As String
  s = rs.Fields(fldName).name
  FieldExists = True
  Exit Function
nogo:
End Function

Function GetUserAddress(username As String, ByRef conn As Object) As String
    
    Dim rs As Object
    Set rs = OpenRS("SELECT eMail FROM gWindowsUserAktuell WHERE LogonID='" & username & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)
    
    If Not rs Is Nothing Then
      If Not rs.EOF Then
        GetUserAddress = rs.Fields("eMail").value
      End If
      rs.Close
      Set rs = Nothing
    End If

End Function

Sub GetDBUser(ByRef srccfg As CfgReader)
    Dim s As String
    
    Dim cfg As CfgReader
    If srccfg Is Nothing Then
      Set cfg = New CfgReader
      If FileExists(G_StartupPath & "DB.cfg") = True Or FileExists(G_StartupPath & "..\cfg\DB.cfg") = True Or _
          FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\DB.cfg") = True Or _
          FileExists(G_StartupPath & "DB.cfg") = True Then
          
          If FileExists(G_StartupPath & "DB.cfg") = True Then
            cfg.GetCfg G_StartupPath & "DB.cfg"
          ElseIf FileExists(G_StartupPath & "..\cfg\DB.cfg") = True Then
            cfg.GetCfg G_StartupPath & "..\cfg\DB.cfg"
          ElseIf FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\DB.cfg") = True Then
            cfg.GetCfg G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\DB.cfg"
          ElseIf FileExists(G_StartupPath & "DB.cfg") = True Then
            cfg.GetCfg G_StartupPath & "DB.cfg"
          End If
      End If
    Else
      Set cfg = srccfg
    End If

    If cfg.GetSection("DB") = True Then
        s = cfg.GetValue("USER")
        If s <> "" Then
            G_DBUser = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = cfg.GetValue("PASSWORD")
        If s <> "" Then
            G_DBUserPasswort = Crypt(s, "uIq2%7/=}pJIi39x?", False)
        End If
        s = cfg.GetValue("DBTYPE")
        If s <> "" Then
            G_DBType = CLng(s)
        End If
        s = cfg.GetValue("DBVERSION")
        If s <> "" Then
            G_DBVersion = CLng(s)
        End If
    End If

    Set cfg = Nothing
    
    If G_DBVersion > C_DBVersion Then
      G_UserDeaktiviert = True
      DebugPrint DebType.tdebug, "DB-Version nicht kompatibel"
    End If
End Sub

Function GetADGruppe(ByRef cfg As CfgReader) As String

    GetADGruppe = ""
    
    If cfg.GetSection("ADGRUPPEN") = True Then
#If PROJECT_ACCESSTRACKER = 0 Then
        GetADGruppe = cfg.GetValue("ETAD")
#Else
        GetADGruppe = cfg.GetValue("ATAD")
#End If
    End If

End Function

Public Function RegValueRead(ByRef root As Long, ByRef path As String, _
    ByVal ValueName As String, ByRef value As Variant, ByRef regtype As Long) As Boolean
    
    Dim result As Long, hKey As Long
    Dim lngBuffer As Long, strBuffer As String, DataLength As Long
    
    If RegOpenKeyEx(CLng(root), path, 0&, CLng(KEY_READ), hKey) = ERROR_SUCCESS Then
        If hKey <> 0 Then
            DataLength = 512
            strBuffer = Space$(DataLength)
            
            If ValueName = "" Then
                result = RegQueryValue(hKey, vbNullString, ByVal strBuffer, DataLength)
                value = Left$(strBuffer, DataLength - 1)
            Else
                result = RegQueryValueEx(hKey, ValueName, 0&, regtype, ByVal 0&, DataLength)
            
                If result = ERROR_SUCCESS Then
                    
                    Select Case regtype
                      Case REG_DWORD
                        Dim tLong As Long
                        result = RegQueryValueEx(hKey, ValueName, 0&, regtype, _
                            tLong, DataLength)
                        If result = ERROR_SUCCESS Then value = CStr(tLong)
                      Case REG_SZ
                        result = RegQueryValueEx(hKey, ValueName, 0&, regtype, _
                            ByVal strBuffer, DataLength)
                        If result = ERROR_SUCCESS Then value = Left$(strBuffer, DataLength - 1)
                      Case Else
                        'MsgBox "UNKNOWN REG TYPE", vbCritical, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
                        MsgBox FMT0("DBHANDLER_1"), vbCritical, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
                    End Select
                End If
            End If
        End If
        
        If result = ERROR_SUCCESS Then RegValueRead = True
        Call RegCloseKey(hKey)
    End If
End Function


Attribute VB_Name = "DebugStuff"
Option Explicit


Public G_PARAM_DebugInfosLoggen As Boolean

Public G_LogThisUser As Boolean
Public G_PARAM_CollectDebug As Boolean

Public G_LogToWindow As Boolean
Public G_LogWriteIgnore As Boolean

Private L_InDebugPrint As Boolean
Private L_Log As Collection
Private L_InitLogPrinted As Boolean

Public G_Log As String

Public Const G_LOG_EXTERNE_KOPIE As Long = 1              ' Die Datei wurde durch eine andere Datei au|fffd|erhalb des IDV-Tracker-Systems |fffd|berschrieben. Wahrscheinlich hat der User eine Datei mit dem Explorer |fffd|ber die Originaldatei kopiert.
Public Const G_LOG_NEUE_FREIGABE_ENTFERNT As Long = 2     ' F|fffd|r die Datei wurde eine neue Version erzeugt. Dadurch wurde die Programmfreigabe aufgehoben.
Public Const G_LOG_NEUE_VERSION As Long = 3               ' F|fffd|r die Datei wurde eine neue Version erzeugt.
Public Const G_LOG_BLATSCHUTZ_ENTFERNEN_INIT As Long = 4  ' Blattschutz-Entfernung initiiert
Public Const G_LOG_BLATTSCHUTZ_ENTFERNT As Long = 5       ' Blattschutz entfernt
Public Const G_LOG_BLATTSCHUTZ_ANGEBRACHT As Long = 6     ' Blattschutz angebracht

Private Sub SetConnectTimeout(ByRef conn)
  On Error Resume Next
  conn.Execute "SET LOCK_TIMEOUT 5000"
  conn.Properties("Jet OLEDB:Lock Delay") = 5000 ' 90 + Int(Rnd * 60)
  Err.Clear
End Sub

#If NOLOGTODB = 0 Then
Sub AddTextToLogDB(ByVal md As DebType, ByVal str As String, dur As Double, ByVal logExp As Long, ByVal idvDateiID As Long)
    
    On Error GoTo nogo
    
    Dim conn As Object
    
    If G_UserDeaktiviert And md <> 6 Then
      Exit Sub
    End If
    
    Set conn = GetConnection()
    If conn Is Nothing Then Exit Sub
    SetConnectTimeout conn

    Dim rs As Object
    Set rs = CreateObject("ADODB.Recordset")

    rs.Open "SELECT * FROM idvDateienEventLog WHERE EventTyp = -1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    
    If rs Is Nothing Then
      conn.Close
      Set conn = Nothing
      Exit Sub
    End If
    
    Do While Len(str) > 0
      rs.AddNew
      rs.Fields("EventTyp").value = md
      rs.Fields("EventLogErlaeuterungID").value = logExp
      rs.Fields("Datum").value = Now
      rs.Fields("Text").value = Left(str, 255)
      rs.Fields("Zeit").value = dur
      rs.Fields("AppID").value = MyAppID
      rs.Fields("idvDateiID").value = idvDateiID
      rs.Fields("userLogonId").value = Left(GetUserName, 24)
      rs.Update
      str = Mid(str, 255, 10000)
    Loop

nogo:
'    If Not rs Is Nothing Then
'      rs.Close
      Set rs = Nothing
'    End If
    
    If Not conn Is Nothing Then
      conn.Close
      Set conn = Nothing
    End If


End Sub
#End If

Sub DebugPrint(ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0)

    If L_InDebugPrint Then Exit Sub
    
'    G_ShowTextIDs = IIf(GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowTextIDs", Default:=0) = 1, True, False)
    

    L_InDebugPrint = True
'    Dim memusg As Long
    
    CheckLogSpace
    Dim errprefix As String
    
    ' Ausgabe f|fffd|r Debug-Window
    If md = DebType.terror Then
      If G_cfgShowMSGBoxForAllErrors Then
        MsgBox str, vbCritical, ProgNameLong & " - *ERROR* " & myVersion & " (Build: " & MyInternalVersion & ")"
      End If
      errprefix = "*** ERR: "
    Else
      errprefix = " "
    End If
    
    G_Log = G_Log & IIf(G_Log <> "", vbCrLf, "") & GetTime(Now()) & errprefix & str
    
'    If IsFormLoaded("frmAppInfo") Then
'      If frmAppInfo.Visible Then
'        frmAppInfo.LogText.Text = G_Log
'      End If
'    End If
    
    If GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowLogWindow", Default:=0) = 1 And G_LogToWindow = False Then
      ShowLogWindow
    End If
    
    If GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowLogWindow", Default:=0) = 0 And G_LogToWindow = True Then
      HideLogWindow
    End If
    
    If IsFormLoaded("frmLogWindow") Then
      If frmLogWindow.visible Then
        frmLogWindow.LogText.Text = G_Log
      End If
    End If
    
    ' Wenn schon in die DB / ins File geschrieben werden darf...
    Dim cle As CLogEntry
    If G_AllowLoggingToStorage Then
      If Not L_Log Is Nothing Then
        For Each cle In L_Log
          DebugPrintToStorage cle.m_Datetime, cle.m_DebugType, cle.m_Str, cle.m_Dur, cle.m_LogExp, cle.m_idvDateiID
        Next cle
        Set L_Log = Nothing
      End If
      DebugPrintToStorage Now, md, str, dur, logExp, idvDateiID
    Else
      ' Ansonsten muss das Log im Ram gehalten werden
      If L_Log Is Nothing Then
        Set L_Log = New Collection
      End If
      Set cle = New CLogEntry
      cle.m_Datetime = Now
      cle.m_DebugType = md
      cle.m_Str = str
      cle.m_Dur = dur
      cle.m_LogExp = logExp
      cle.m_idvDateiID = idvDateiID
      L_Log.Add cle
    End If

    L_InDebugPrint = False
End Sub

Private Sub DebugPrintToStorage(ByVal logdate As Date, ByVal md As DebType, ByVal str As String, Optional ByVal dur As Double = 0, Optional ByVal logExp As Long = 0, Optional ByVal idvDateiID As Long = 0)
  
  If md = terror Or _
       md = tMail Or _
       md = tSystem Or _
      (md = tdebug And (G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True)) Or _
      (md = tinfo And (G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True)) Or _
      (md = tTime And (G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True)) Or _
       md = tSystemToFile Then
      
      If md = DebType.terror Then
      
          ' ERrors werden immer geloggt, auch in der DB
          #If PROJECT_PLUGINCHECK <> 1 Then
'          AddTextToLogDB logdate, md, "Err: " & str, dur, logExp, idvDateiID
          #End If
          
          #If PROJECT_IDVSCHEDULER = 1 Then
            AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & "Err: " & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
          #Else
            If G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True Then
              AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & "Err: " & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
            End If
          #End If
      Else
          ' Mails und System werden immer geloggt, auch in der DB
          #If PROJECT_PLUGINCHECK <> 1 Then
          If md = tMail Or md = tSystem Then
'            AddTextToLogDB logdate, md, str, dur, logExp, idvDateiID
          End If
          #End If
          #If PROJECT_IDVSCHEDULER = 1 Then
            AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
          #Else
            If G_cfgDebugInfosLoggen = True Or G_PARAM_DebugInfosLoggen = True Or G_LogThisUser = True Then
              AddTextToLogfile logdate & "," & dur & ", Typ: " & md & ", ID: " & idvDateiID & ", " & Chr(34) & str & Chr(34), G_cfgLogpfad & "\" & ProgNameLong & "-" & GetUserName & ".txt"
            End If
          #End If
      End If
  End If
End Sub


Public Function AddTextToLogfile(ByVal strData As String, _
     ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    If G_LogWriteIgnore = True Then Exit Function
    
    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

goAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToLogfile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToLogfile = False
            G_LogWriteIgnore = True
            If Not G_IgnoreFutureWriteWindows Then
              'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & fullpath & "' gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & myVersion ) = vbYes Then
              If MsgBox(FMT1("DEBUGSTUFF_1", fullpath), vbYesNo + vbCritical, ProgNameLong & " " & myVersion) = vbYes Then
                ShowLogWindow
                G_IgnoreFutureWriteWindows = True
              End If
            End If
            Exit Function
          End If
        End If
      Loop
    Else
      G_LogWriteIgnore = True
      'If MsgBox("ACHTUNG: Die Log-Datei kann nicht in '" & GetPath(fullpath) & "' gespeichert werden, der Pfad existiert nicht. Bitte informieren Sie die Administration. M|fffd|chten Sie, dass das Log in einem Fenster ausgegeben wird?", vbYesNo + vbCritical, ProgNameLong & " " & myVersion ) = vbYes Then
      If MsgBox(FMT1("DEBUGSTUFF_3", GetPath(fullpath)), vbYesNo + vbCritical, ProgNameLong & " " & myVersion) = vbYes Then
        ShowLogWindow
      End If
    End If
    Exit Function

CatchEx:

End Function


Public Function AddTextToFile(ByVal strData As String, _
    ByVal fullpath As String, _
       Optional ByVal ErrInfo As String = "") As Boolean

    On Error GoTo CatchEx

    Dim fn As Long
    Dim cnt As Long
    cnt = 0
    
    fn = FreeFile
    Dim s As String

goAgain:

    If PathExists(GetPath(fullpath)) Then
      Do
        If FOpenAppend(fullpath, fn) Then
          Print #fn, strData
          Close fn
          AddTextToFile = True
          Exit Do
        Else
          Sleep 100
          cnt = cnt + 1
          If cnt >= 10 Then
            AddTextToFile = False
            If Not G_IgnoreFutureWriteWindows Then
              'MsgBox "ACHTUNG: Die Datei '" & fullpath & "' kann nicht gespeichert werden, vermutlich haben Sie keine Schreibrechte in diesem Ordner. Bitte informieren Sie die Administration.", vbCritical, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
              MsgBox FMT1("DEBUGSTUFF_4", fullpath), vbCritical, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
              G_IgnoreFutureWriteWindows = True
            End If
            Exit Function
          End If
        End If
      Loop
    Else
      'MsgBox "ACHTUNG: Die Datei kann nicht in '" & GetPath(fullpath) & "' gespeichert werden, der Pfad existiert nicht. Bitte informieren Sie die Administration.", vbCritical, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
      MsgBox FMT1("DEBUGSTUFF_5", GetPath(fullpath)), vbCritical, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
    End If
    Exit Function

CatchEx:

End Function


Private Function FOpenAppend(fname As String, ByRef fn As Long) As Boolean
  On Error GoTo nogo
  Open fname For Append As fn
  FOpenAppend = True
  Exit Function
nogo:
        
End Function


Sub ShowLogWindow()
  If G_LogToWindow = False Then
    G_LogToWindow = True
    'frmLogWindow.Caption = ProgNameLong & " " & myVersion & " (Build: " & app.Revision & ")" & " - Log..."
    frmLogWindow.Caption = ProgNameLong & " " & myVersion & " (Build: " & MyInternalVersion & ")"
    If Not IsFormLoaded("frmLogWindow") Then Load frmLogWindow
'    frmAppInfo.LogText = G_Log
    frmLogWindow.Show vbModeless
  End If
End Sub

Sub HideLogWindow()
  If G_LogToWindow = True Then
    G_LogToWindow = False
    frmLogWindow.Hide
    Unload frmLogWindow
  End If
End Sub



Sub CheckLogSpace()
  If Len(G_Log) > 15500 Then
    Dim pos As Long
    pos = InStr(G_Log, vbCrLf)
    If pos > 0 Then
      G_Log = Mid(G_Log, pos)
    Else
      G_Log = Right(G_Log, 15500)
    End If
  End If
End Sub

Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "DirSelect"
Option Explicit

Public Type BROWSEINFO
   hOwner As Long
   pidlRoot As Long
   pszDisplayName As String
   lpszTitle As String
   ulFlags As Long
   lpfn As Long
   lParam As Long
   iImage As Long
End Type

#If VBA7 Then
  Declare PtrSafe Function SHGetPathFromIDList Lib "shell32.dll" _
     Alias "SHGetPathFromIDListA" (ByVal pidl As Long, _
     ByVal pszPath As String) As Long
  
  Declare PtrSafe Function SHBrowseForFolder Lib "shell32.dll" _
     Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long

#Else
  Declare Function SHGetPathFromIDList Lib "shell32.dll" _
     Alias "SHGetPathFromIDListA" (ByVal pidl As Long, _
     ByVal pszPath As String) As Long
  
  Declare Function SHBrowseForFolder Lib "shell32.dll" _
     Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long
#End If

Function GetDirectory(Optional msg) As String
   Dim bInfo As BROWSEINFO
   Dim path As String
   Dim r As Long, x As Long, pos As Integer
   bInfo.pidlRoot = 0&
   If IsMissing(msg) Then
      'bInfo.lpszTitle = "W|fffd|hlen Sie bitte einen Ordner aus."
      bInfo.lpszTitle = FMT0("DirSelect_1")
   Else
      bInfo.lpszTitle = msg
   End If
   bInfo.ulFlags = &H1
   x = SHBrowseForFolder(bInfo)
   path = Space$(512)
   r = SHGetPathFromIDList(ByVal x, ByVal path)
   If r Then
      pos = InStr(path, Chr$(0))
      GetDirectory = Left(path, pos - 1)
   Else
      GetDirectory = ""
   End If
End Function
Attribute VB_Name = "ExcelStuff"
Option Explicit

Public gCHR As String


Public Function DateiSchonGeoeffnet(ByRef xlapp As Object, ByVal fname As String) As Boolean
    DateiSchonGeoeffnet = False
    If fname = "" Then Exit Function
    
    ' wenn die Datei schon ge|fffd|ffnet ist, dann nichts machen
    Dim filenameU As String
    ' nur einmal den Filename nach UNC und Uppercase konvertieren
    filenameU = UCase(GetUNCPath(fname))
    Dim intCount As Long
    For intCount = 1 To xlapp.Workbooks.Count
      If UCase(GetUNCPath(xlapp.Workbooks(intCount).FullName)) = filenameU Then
        DateiSchonGeoeffnet = True
        Exit Function
      End If
    Next intCount
    DateiSchonGeoeffnet = False
End Function

Public Function DateiSchonGeoeffnetMitWB(ByRef xlapp As Object, ByVal fname As String, ByRef wb As Object) As Boolean
    DateiSchonGeoeffnetMitWB = False
    If fname = "" Then Exit Function
    
    ' wenn die Datei schon ge|fffd|ffnet ist, dann nichts machen
    Dim filenameU As String
    ' nur einmal den Filename nach UNC und Uppercase konvertieren
    filenameU = GetUNCPath(fname)
    Dim intCount As Long
    For intCount = 1 To xlapp.Workbooks.Count
      If GetUNCPath(xlapp.Workbooks(intCount).FullName) = filenameU Then
        Set wb = xlapp.Workbooks(intCount)
        DateiSchonGeoeffnetMitWB = True
        Exit Function
      End If
    Next intCount
End Function

Public Function DateiOeffnenMitPW(ByRef conn As Object, ByRef xlapp As Object, ByVal fname As String, ByVal pw As String) As Boolean
    On Error GoTo A
    Dim wb As Excel.Workbook
'    If FileInUse(fname) Then
'      MsgBox FMT0("EXCELSTUFF_4"), vbExclamation, ProgNameLong & " " & myVersion ' ' & " (Build: " & MyInternalVersion & ")"
'    End If
    Set wb = xlapp.Workbooks.Open(fname, False, True, , pw, , True, , , True, False, , False)
    
    ' Dann checken wir auch gleich noch die Berechtigungen! Falls es eine ID gibt
    
    Dim fileid As Long
    fileid = WBGetValueLong(wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
    
    If fileid <= 0 Then
      DateiOeffnenMitPW = True
    Else
      Dim q As String
      q = "SELECT * FROM idvDateien WHERE idvDateiID = " & fileid
      Dim rs As Object
      Set rs = CreateObject("ADODB.Recordset")
      rs.Open q, conn, 2, 1
      If Not rs Is Nothing Then
          If Not rs.EOF Then
            If DateiOeffnenStandardPasswordOK(xlapp, wb, conn, rs) Then
              DateiOeffnenMitPW = True
            End If
          Else
            If wb.HasPassword Then
              wb.Close False
              Set wb = Nothing
            Else
              DateiOeffnenMitPW = True
            End If
          End If
          rs.Close
      Else
            If wb.HasPassword Then
              wb.Close False
              Set wb = Nothing
            Else
              DateiOeffnenMitPW = True
            End If
      End If
      Set rs = Nothing
  End If
    
    
  Exit Function
A:

    If Err.Number = 1 Then
    Else
      DateiOeffnenMitPW = False
    End If

End Function

Public Function FileInUse(sFileName) As Boolean
    On Error Resume Next
    Dim ff As Long
    ff = FreeFile
    Open sFileName For Binary Access Read Lock Read As #ff
    Close #ff
    FileInUse = IIf(Err.Number > 0, True, False)
    On Error GoTo 0
End Function

Public Function DateiOeffnenOhnePW(ByRef xlapp As Object, ByVal fname As String) As Boolean
    Dim wb As Excel.Workbook
    On Error GoTo A
'    If UCase(Right(fname, 4)) = "XLTX" Or UCase(Right(fname, 4)) = "XLTM" Or UCase(Right(fname, 3)) = "XLT" Then
      Set wb = xlapp.Workbooks.Open(fname, False, , , , , , , , True)
'    Else
'      Set wb = xlapp.Workbooks.Open(fname)
'    End If
    DateiOeffnenOhnePW = True
    Exit Function
A:
    DateiOeffnenOhnePW = False

End Function


Function WBHasError(ByRef wb As Object) As Boolean
  On Error GoTo nogo
  WBHasError = True
  Dim s As String
  s = wb.FullName
  WBHasError = False
  Exit Function
nogo:
End Function

Public Function GetDateinameInDatenbank(ByVal uncpathfname As String) As String

    GetDateinameInDatenbank = UCase(uncpathfname)
    If IsHttpFilename(uncpathfname) Then
        If True = True Then
            GetDateinameInDatenbank = uncpathfname
        End If
    End If

End Function

Public Function IsHttpFilename(ByVal uncpathfname As String) As Boolean
    IsHttpFilename = False
    If UCase(Left(uncpathfname, 6)) = "HTTPS:" Or UCase(Left(uncpathfname, 5)) = "HTTP:" Then
        IsHttpFilename = True
    End If
'    If UCase(Left(uncpathfname, 16)) = "\\VBOXSRV\MYWORK" Then
'        IsHttpFilename = True
'    End If
End Function

Function GetTargetRSFromFilename(ByRef conn As Object, ByVal uncpathfname, ByRef rs As Object, ByRef curId As Long) As Boolean
    GetTargetRSFromFilename = False
    
    Dim uncpathfnameDB As String
    uncpathfnameDB = GetDateinameInDatenbank(uncpathfname)
    
    Dim hash As String
    hash = GetFileHash(Nothing, uncpathfnameDB)

    Set rs = OpenRS("SELECT * FROM idvDateien WHERE " & _
      gCHR & "HASH" & gCHR & " = '" & hash & "'" & _
      " and geloescht = 0", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly)

    If Not rs Is Nothing Then
        If rs.EOF = False Then
            curId = rs.Fields("idvDateiID").value
            GetTargetRSFromFilename = True
            Exit Function
        End If
        rs.Close
    End If
    Set rs = Nothing

End Function


Attribute VB_Name = "ExportCode"
Option Explicit

Public Sub DoExportCode()
    Dim objVBComponent As Object
    Dim objWorkbook As Workbook
    Dim strType As String
    Set objWorkbook = ActiveWorkbook
    MkFullDir ThisWorkbook.path & "\Code"
    For Each objVBComponent In objWorkbook.VBProject.VBComponents
        With objVBComponent.CodeModule
            Select Case objVBComponent.Type
                Case 1
                    strType = ".bas"
                Case 2, 100
                    strType = ".cls"
                Case 3
                    strType = ".frm"
            End Select
            objWorkbook.VBProject.VBComponents(objVBComponent.name).Export _
                ThisWorkbook.path & "\Code\" & objVBComponent.name & strType
        End With
    Next
End Sub



Attribute VB_Name = "FSPC"
Option Explicit

Global Const SpecialCellToBeFound As String = "EURJPY BW!$H$100"

Global Const C_FindSpecialCell_Check As Boolean = False
Sub FindSpecialCell(c As Range)
  If c.Parent.name & "!" & c.Address = SpecialCellToBeFound Then
    Debug.Print "Found Special Cell"
  End If
End Sub



Attribute VB_Name = "FileStuff"
Option Explicit

'  Shell File Operations

Private Const FO_MOVE = &H1
Private Const FO_COPY = &H2
Private Const FO_DELETE = &H3
Private Const FO_RENAME = &H4
Private Const FOF_MULTIDESTFILES = &H1
Private Const FOF_CONFIRMMOUSE = &H2
Private Const FOF_SILENT = &H4                      '  don't create progress/report
Private Const FOF_RENAMEONCOLLISION = &H8
Private Const FOF_NOCONFIRMATION = &H10             '  Don't prompt the user.
Private Const FOF_WANTMAPPINGHANDLE = &H20          '  Fill in SHFILEOPSTRUCT.hNameMappings
                                      '  Must be freed using SHFreeNameMappings
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_FILESONLY = &H80                  '  on *.*, do only files
Private Const FOF_SIMPLEPROGRESS = &H100            '  means don't show names of files
Private Const FOF_NOCONFIRMMKDIR = &H200            '  don't confirm making any needed dirs


#If VBA7 Then

Private Type SHFILEOPSTRUCT
        Hwnd As LongPtr
        wFunc As LongPtr
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As LongPtr
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type


Private Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#Else

Private Type SHFILEOPSTRUCT
        Hwnd As Long
        wFunc As Long
        pFrom As String
        pTo As String
        fFlags As Integer
        fAnyOperationsAborted As Boolean
        hNameMappings As Long
        lpszProgressTitle As String '  only used if FOF_SIMPLEPROGRESS
End Type

Private Declare Function SHFileOperation Lib "shell32.dll" Alias "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
#End If

Const OFN_READONLY           As Long = &H1
Const OFN_EXPLORER           As Long = &H80000
Const OFN_LONGNAMES          As Long = &H200000
Const OFN_CREATEPROMPT       As Long = &H2000
Const OFN_NODEREFERENCELINKS As Long = &H100000
Const OFN_OVERWRITEPROMPT    As Long = &H2
Const OFN_HIDEREADONLY       As Long = &H4
Const OFN_PATHMUSTEXIST      As Long = &H800
Const OFN_ENABLEHOOK As Long = &H20
Const OFN_ENABLESIZING As Long = &H800000

Public Const OFS_FILE_OPEN_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_CREATEPROMPT _
                                    Or OFN_NODEREFERENCELINKS
Public Const OFS_FILE_SAVE_FLAGS    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_OVERWRITEPROMPT _
                                    Or OFN_HIDEREADONLY
Public Const OFS_FILE_SAVE_FLAGS_NO_PROMPT    As Long = OFN_EXPLORER _
                                    Or OFN_LONGNAMES _
                                    Or OFN_HIDEREADONLY




Type OPENFILENAME
    nStructSize     As Long
    hwndOwner       As Long
    hInstance       As Long
    sFilter         As String
    sCustomFilter   As String
    nCustFilterSize As Long
    nFilterIndex    As Long
    sFile           As String
    nFileSize       As Long
    sFileTitle      As String
    nTitleSize      As Long
    sInitDir        As String
    sDlgTitle       As String
    Flags           As Long
    nFileOffset     As Integer
    nFileExt        As Integer
    sDefFileExt     As String
    nCustData       As Long
    fnHook          As Long
    sTemplateName   As String
End Type

Public Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type

Public Const WM_INITDIALOG As Long = &H110
Private Const SW_SHOWNORMAL As Long = 1

#If VBA7 Then
    Private Declare PtrSafe Function GetParent Lib "user32" _
      (ByVal Hwnd As Long) As Long
    Private Declare PtrSafe Function SetWindowText Lib "user32" _
       Alias "SetWindowTextA" _
      (ByVal Hwnd As Long, _
       ByVal lpString As String) As Long
       
    Private Declare PtrSafe Function MoveWindow Lib "user32" _
      (ByVal Hwnd As Long, _
       ByVal x As Long, _
       ByVal y As Long, _
       ByVal nWidth As Long, _
       ByVal nHeight As Long, _
       ByVal bRepaint As Long) As Long
       
    Private Declare PtrSafe Function GetWindowRect Lib "user32" _
      (ByVal Hwnd As Long, _
       lpRect As RECT) As Long
       
    'defined As Any to support either the
    'OSVERSIONINFO or OSVERSIONINFOEX structure
    Private Declare PtrSafe Function GetVersionEx Lib "kernel32" _
       Alias "GetVersionExA" _
      (lpVersionInformation As Any) As Long
      
    Declare PtrSafe Function GetActiveWindow Lib "user32.dll" () As Long
    Declare PtrSafe Function GetOpenFileName Lib "comdlg32.dll" Alias _
        "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare PtrSafe Function GetSaveFileName Lib "comdlg32.dll" Alias _
        "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" Alias _
        "GetShortPathNameA" (ByVal lpszLongPath As String, _
                             ByVal lpszShortPath As String, _
                             ByVal cchBuffer As Long) As Long

#Else
    Private Declare Function GetParent Lib "user32" _
      (ByVal Hwnd As Long) As Long
    Private Declare Function SetWindowText Lib "user32" _
       Alias "SetWindowTextA" _
      (ByVal Hwnd As Long, _
       ByVal lpString As String) As Long
       
    Private Declare Function MoveWindow Lib "user32" _
      (ByVal Hwnd As Long, _
       ByVal x As Long, _
       ByVal y As Long, _
       ByVal nWidth As Long, _
       ByVal nHeight As Long, _
       ByVal bRepaint As Long) As Long
       
    Private Declare Function GetWindowRect Lib "user32" _
      (ByVal Hwnd As Long, _
       lpRect As RECT) As Long
       
    'defined As Any to support either the
    'OSVERSIONINFO or OSVERSIONINFOEX structure
    Private Declare Function GetVersionEx Lib "kernel32" _
       Alias "GetVersionExA" _
      (lpVersionInformation As Any) As Long
      
    Declare Function GetActiveWindow Lib "user32.dll" () As Long
    Declare Function GetOpenFileName Lib "comdlg32.dll" Alias _
        "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare Function GetSaveFileName Lib "comdlg32.dll" Alias _
        "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
    Declare Function GetShortPathName Lib "Kernel32.dll" Alias _
        "GetShortPathNameA" (ByVal lpszLongPath As String, _
                             ByVal lpszShortPath As String, _
                             ByVal cchBuffer As Long) As Long
#End If



Public Sub SyncCopy(Dateiname$, zielverzeichnis$)

Dim filenames$
Dim I As Integer
Dim shellinfo As SHFILEOPSTRUCT

filenames = Dateiname + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        .fFlags = FOF_FILESONLY + FOF_NOCONFIRMATION + FOF_NOCONFIRMMKDIR + FOF_SILENT
End With

SHFileOperation shellinfo

End Sub

' Dateioperationen

Public Sub CopyFile(Dateiname$, zieldateiname$)

On Error Resume Next
  Dim arr(1) As String
  arr(0) = Dateiname
  
  If UCase(Left(Dateiname, 7)) = "HTTP://" Or UCase(Left(Dateiname, 8)) = "HTTPS://" Then
    DownloadFile Dateiname, zieldateiname & "\" & GetFileNameAndExtension(Dateiname)
  Else
    CopyPlus arr, zieldateiname, False
  End If

End Sub

Public Sub CopyPlus(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim I As Integer
Dim shellinfo As SHFILEOPSTRUCT

For I = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(I) + Chr(0)
Next I
filenames = filenames + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Sub

Public Function Move(dateinamen$(), zielverzeichnis$, Optional inklusiveUnterverzeichnisse)

Dim filenames$
Dim I As Integer
Dim shellinfo As SHFILEOPSTRUCT

For I = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(I) + Chr(0)
Next I
filenames = filenames + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_COPY
        .pFrom = filenames
        .pTo = zielverzeichnis
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function

Public Function Delete(dateinamen$(), Optional inklusiveUnterverzeichnisse)
Dim filenames$
Dim I As Integer
Dim shellinfo As SHFILEOPSTRUCT

For I = 0 To UBound(dateinamen)
    filenames = filenames & dateinamen(I) + Chr(0)
Next I
filenames = filenames + Chr(0)

With shellinfo
        .Hwnd = 0 ' Screen.ActiveForm.Hwnd
        .wFunc = FO_DELETE
        .pFrom = filenames
        .pTo = "" + Chr(0)
        If Not IsMissing(inklusiveUnterverzeichnisse) Then
            If Not inklusiveUnterverzeichnisse Then .fFlags = FOF_FILESONLY
        End If
End With

SHFileOperation shellinfo

End Function



Public Function DelTree(ByVal path As String) As Boolean
' L?scht mithilfe des FileSystemObject (ScrRun.dll) einen
' Verzeichnisbaum (sofern m?glich).
' Kann der Baum nicht komplett gel?scht werden, wird als
' Funktionsr?ckgabewert FALSE verwendet.
' Hinweis: Die Dateien werden direkt gel?scht, nicht
' lediglich in den Papierkorb verschoben!
Dim FSO As Object
  On Error Resume Next
  ' FileSystemObject instanzieren
  Set FSO = CreateObject("Scripting.FileSystemObject")
  ' Konnte das Objekt instanziert werden?
  If Err.Number <> 0 Then
 Exit Function
  End If
  ' Die DeleteFolder-Methode des Objekts aufrufen
  FSO.DeleteFolder path, True
  ' Trat beim L?schen ein Fehler auf?
  If Err.Number <> 0 Then
 Exit Function
  End If
  ' Fehlerfreie Abarbeitung => R?ckgabewert TRUE
  DelTree = True
End Function
Function ReadTextfile(ByVal strFileName As String) As String
  Dim iFile As Integer
  Dim fileWasOpen As Boolean
  fileWasOpen = False
  iFile = FreeFile
  On Error GoTo nogo
  Open strFileName For Input As #iFile
  fileWasOpen = True
  ReadTextfile = Input(LOF(iFile), iFile)
  Close #iFile
  Exit Function
nogo:
  If fileWasOpen Then
      Close #iFile
  End If
End Function
Function WriteTextfile(ByVal strFileName As String, txt As String) As String
  Dim iFile As Integer
  iFile = FreeFile
  On Error GoTo nogo
  Open strFileName For Output As #iFile
  Print #iFile, txt
  Close #iFile
  Exit Function
nogo:
End Function


Attribute VB_Name = "GlobalStuff2"
Option Explicit

' Dieses Plugin l|fffd|uft maximal mit der Version C_DBVersionAllowed der Datenbank. Wenn die Version der DB gr|fffd||fffd|er ist, ist das Plugin inaktiv
' Muss nat|fffd|rlich vor jedem Release gesetzt werden, sonst l|fffd|uft kein Update.
Public Const C_DBVersion = 290

Public G_PARAM_TimeoutConnection As Long
Public G_PARAM_TimeoutTableOpen As Long
Public G_PARAM_SWLCAktivieren As Boolean

Public G_cfgDebugInfosLoggen As Boolean

Public G_UserImportType As Long
Public G_cfgOEUserDeaktivert As Boolean

Public G_IgnoreFutureWriteWindows As Boolean

Public G_CfgPath As String ' Inklusive Backslash am Ende!!!! Nur im Scheduler gesetzt, ACHTUNG!!!
Public G_cfgBinpfad As String
Public G_cfgLogpfad As String
Public G_cfgTemppfad As String
Public G_cfgPasswortpfad As String
Public G_cfgKeypfad As String
Public G_cfgECCPfad As String
Public G_cfgACCPfad As String
Public G_cfgEPPfad As String
Public G_cfgESQAPfad As String
Public G_cfgEFCPfad As String
Public G_cfgShowMSGBoxForAllErrors As Boolean
Public G_cfgCanceltime As String
Public G_cfgLoadtime As String
Public G_cfgSpecialcellstime As String
Public G_cfgFreigabeformspeicherpfad As String
' Das ist jetzt eine Funktion
'Public G_Freigabeformular As String
Private G_MyFreigabeformular As String

Public G_Dokuformular As String
Public G_cfgKonvertierenAktiv As Boolean
Public G_cfgTestarea As Boolean
Public G_cfgNoAD As Boolean
Public G_cfgInfoPfad As String
Public G_cfgADString As String
Public G_cfgTestuser As Boolean
Public G_cfgSBSNoID As Boolean
Public G_cfgFreigabeAbRisiko As Double
Public G_cfgNurScanpfade As Boolean
Public G_Scanpfade As Collection
' Wenn das True ist, wird die txt file Optimierung (kein Lesen aus der DB) fuer die Prozesse Form nicht benutzt
Public G_CfgPANoTextfile As Boolean
Public G_cfgIgnoreWarningPaths As Collection
Public G_cfgIgnoreBlockPaths As Collection

Public G_DOKU_Dateiberechtigungen As Boolean ' Nur im Doku-Screen gesetzt

Public G_StartupPath As String
Public G_Firmenlogo As String

Public G_Lizenznehmer As String
Public G_LizenznehmerAdresse As String
Public G_Lizenzen As Long
Public G_FullDemoBis As Date
Public G_MyLicencseVersion As Long
Public G_Wartung As Boolean
Public G_WartungBis As Date
Public G_FullVersion As Boolean

Public G_frmDoku_Cancel As Boolean

Public G_PARAM_FormelnNichtZaehlenAbKB As Long
Public G_PARAM_WarnungManuelleBerechnung As Boolean
Public G_IgnoreThisOneWarnungManuelleBerechnung As Boolean

Public G_PARAM_OEAusADGruppeLesen As Boolean
Public G_PARAM_ToDoListe As Boolean

Public G_PARAM_DokuInWord As Boolean
Public G_PARAM_FragenAntworten As Boolean
Public G_PARAM_XMinutenNichtBefragen As Long
Public G_PARAM_FragenAntwortenScreen As Boolean
Public G_PARAM_Ampel As Boolean
Public G_PARAM_AmpelRisiko As Double
Public G_PARAM_FreigabenAusVorversionDeaktivieren As Boolean
Public G_PARAM_ChecklisteFreigabeInitiierung As Boolean
Public G_PARAM_ChecklisteFreigabe As Boolean
Public G_PARAM_Dateiberechtigung As Boolean
Public G_PARAM_DateiOeffnen As Boolean
Public G_PARAM_DokuInWordIcon As Boolean
Public G_PARAM_LockButton As Boolean
Public G_PARAM_UnlockButton As Boolean

Public G_PARAM_BlattschutzEntf4AP As Boolean

Public G_UserDeaktiviert As Boolean
Public G_AllowLoggingToStorage As Boolean
Public G_PARAM_StoreMailsToTable As Boolean

Public G_cfgToolbarRechtsOben As Boolean

Public G_DBUser As String
Public G_DBUserPasswort As String

Public G_Cursorlocation As Long

Public G_IDVSuitePath As String


Public Const C_RepeatRSOpenSleep As Long = 50
Public Const C_RepeatRSOpenCount As Long = 10
Public Const C_RepeatConnOpenSleep As Long = 50
Public Const C_RepeatConnOpenCount As Long = 10

Public gCHR As String
Public gCursorLocation As Long

Public G_MyOEGelesen As Boolean
Public G_MyOE As String
Public G_MyOEID As Long

' Derzeit nur gesetzt, wenn MeineDateien aufgerufen wurde, kommt wahrscheinlich irgend wann ins init
Public G_MeineOEsGelesen As Boolean
Public G_MeineOEs As String
Public G_MeineOEsVertretung As String
Public G_OEHierarchie As Boolean
Public G_Freigabeordner As String
Public G_PDFDruckordner As String


Public G_CfgHeaderLeft As String
Public G_CfgHeaderCenter As String
Public G_CfgHeaderRight As String
Public G_CfgFooterLeft As String
Public G_CfgFooterCenter As String
Public G_CfgFooterRight As String
Public G_CfgLogoFarbe As Long

Public G_CfgInformationsklasseAnzeigen As Boolean
Public G_CfgBankfachlichAnzeigen As Boolean
Public G_CfgGOBDAnzeigen As Boolean
Public G_CfgSchutzbedarfsfensterAnzeigen As Boolean
Public G_CfgZeitaufwandZurDokuAnzeigen As Boolean

Public G_CfgPASchluesselPx As Long
Public G_CfgPAProzEbene1Px As Long
Public G_CfgPAProzEbene2Px As Long
Public G_CfgPAProzEbene3Px As Long
Public G_CfgPAReihenfolge As String
Public G_CfgPAReihenfolgeDoku As String
Public G_cfgLnkApp As String
Public G_CfgProzessUnbekanntSichtbar As Boolean

Public G_cfgExcel As String

Public G_DBConnectionString As String

Public G_AntwortenNeuGeben As Boolean
Public G_SelectedProzesse As Collection


' nur f|fffd|r xlam
Public G_Auswahl As Long
Public G_AuswahlName As String

Public G_CriticalAddins As String
Public G_UserOnOff As Boolean
Public G_NoSave As Boolean

Public Const G_SQL_Anywhere As Integer = 1
Public Const G_SQL_Server As Integer = 2
Public Const G_MySQL As Integer = 3
Public Const G_Access As Integer = 4
Public Const G_Oracle As Integer = 5

Public G_DBType As Long
Public G_DBVersion As Long

Public G_SchutzbedarfMussVerfuegbarkeit As Boolean
Public G_SchutzbedarfMussIntegritaet As Boolean
Public G_SchutzbedarfMussVertraulichkeit As Boolean

Public G_Form_InTerminate As Boolean
Public G_Form_InInitialize As Boolean



Enum DebType
    terror = 1
    tinfo = 2
    tTime = 3
    tdebug = 4
    tMail = 5
    tSystem = 6
    tSystemToFile = 7 ' wie tSystem, schreibt aber nur in die Datei
End Enum

Enum PathType
    tLog = 1
    tTemp = 2
    tPassword = 3
    tKey = 4
    tEcc = 5
    tFreigabeform = 6
    tEP = 7
    tAcc = 8
    tEFC = 9
    tESQA = 10
End Enum

#If VBA7 Then
Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDest As Any, pSource As Any, ByVal cb As LongPtr)
Declare PtrSafe Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Declare PtrSafe Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Declare PtrSafe Function timeGetTime Lib "winmm.dll" () As Long

Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)
#Else
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, source As Any, ByVal length As Long)
Declare Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Declare Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Declare Function timeGetTime Lib "winmm.dll" () As Long

Public Declare Sub Sleep Lib "kernel32" (ByVal _
          dwMilliseconds As Long)
#End If


Sub StartupInit(appname As String)
    
    Dim I As Long
    Dim cfg As New CfgReader
    Dim s As String
    Dim tss As String
    Dim pos As Long
    Dim pluginDeaktiviert As Boolean
    
    Set G_cfgIgnoreWarningPaths = Nothing
    Set G_cfgIgnoreBlockPaths = Nothing
    
    G_PARAM_TimeoutConnection = 5000
    G_PARAM_TimeoutTableOpen = 2000
    G_cfgCanceltime = "00:05:00"
    G_cfgLoadtime = "00:03:30"
    G_cfgSpecialcellstime = "00:30:00"
    G_cfgADString = "LDAP"
    
    G_CfgLogoFarbe = -1
    G_CfgInformationsklasseAnzeigen = True
    G_CfgBankfachlichAnzeigen = True
    G_CfgGOBDAnzeigen = True
    G_CfgSchutzbedarfsfensterAnzeigen = True
    G_CfgZeitaufwandZurDokuAnzeigen = True
    G_cfgFreigabeAbRisiko = -10000#
  
    G_CfgProzessUnbekanntSichtbar = True
    
    G_Dokuformular = ""
    G_cfgBinpfad = ThisWorkbook.path & "\"
    G_StartupPath = ThisWorkbook.path & "\"
    
    G_PARAM_TimeoutConnection = 5000
    G_PARAM_TimeoutTableOpen = 2000
    G_PARAM_FormelnNichtZaehlenAbKB = 1000

    G_cfgDebugInfosLoggen = False
    G_cfgLogpfad = ""
    G_cfgTemppfad = ""
    G_cfgPasswortpfad = ""
    G_cfgKeypfad = ""
    G_cfgFreigabeformspeicherpfad = ""
    G_cfgInfoPfad = ""
    
    ' Die Pfade stimmen nicht, es soll aber schon mal was drin stehen
    G_cfgECCPfad = ThisWorkbook.path & "\..\ECC"
    G_cfgACCPfad = ThisWorkbook.path & "\..\ACC"
    G_cfgEPPfad = ThisWorkbook.path & "\..\EP"
    G_cfgEFCPfad = ThisWorkbook.path & "\..\EFC"
    G_cfgESQAPfad = ThisWorkbook.path & "\..\ESQA"
    
'    ThisWorkbook.OleServerBusyRaiseError = True
'    OLEServerBusyTimeout
    
    If FileExists(G_StartupPath & "DBConnect.cfg") = True Or FileExists(G_StartupPath & "..\cfg\DBConnect.cfg") = True Or _
        FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\DBConnect.cfg") = True Or _
        FileExists(G_StartupPath & "DBConnect.cfg") = True Then
        
        If FileExists(G_StartupPath & "DBConnect.cfg") = True Then
          DebugPrint tdebug, "DBConnect.cfg: " & G_StartupPath & "DBConnect.cfg"
          cfg.GetCfg G_StartupPath & "DBConnect.cfg"
        ElseIf FileExists(G_StartupPath & "..\cfg\DBConnect.cfg") = True Then
          DebugPrint tdebug, "DBConnect.cfg: " & G_StartupPath & "..\cfg\DBConnect.cfg"
          cfg.GetCfg G_StartupPath & "..\cfg\DBConnect.cfg"
        ElseIf FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\DBConnect.cfg") = True Then
          DebugPrint tdebug, "DBConnect.cfg: " & G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\DBConnect.cfg"
          cfg.GetCfg G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\DBConnect.cfg"
        ElseIf FileExists(G_StartupPath & "DBConnect.cfg") = True Then
          DebugPrint tdebug, "DBConnect.cfg: " & G_StartupPath & "DBConnect.cfg"
          cfg.GetCfg G_StartupPath & "DBConnect.cfg"
        End If
        
        If cfg.GetSection("DBCONNECT") = True Then
          G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING")
        End If
    End If
    
    G_DBUser = "IDVTTECHUSER"
    G_DBUserPasswort = "12SD3Ax$!d7%fd/"
    G_DBType = 0
    G_DBVersion = 0
    
    GetDBUser Nothing
    
    Set cfg = New CfgReader
    
    Dim tFORCELOGUSERS As Boolean
    Dim tLOGWINDOWVISIBLEUSERS As Boolean

    tLOGWINDOWVISIBLEUSERS = IIf(GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ShowLogWindow", Default:=0) = 1, True, False)
    tFORCELOGUSERS = IIf(GetSetting(appname:="Stromwerken", Section:="Tracker", Key:="ForceLog", Default:=0) = 1, True, False)

    If FileExists(G_StartupPath & "cfg\" & ProgNameLong & ".cfg") = True Or FileExists(G_StartupPath & ProgNameLong & ".cfg") = True Or FileExists(G_StartupPath & "..\cfg\IDV-Suite.cfg") = True Or _
        FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Or _
        FileExists(G_StartupPath & "IDV-Suite.cfg") = True Then
        
        If FileExists(G_StartupPath & "cfg\" & ProgNameLong & ".cfg") = True Then
          cfg.GetCfg G_StartupPath & "cfg\" & ProgNameLong & ".cfg"
        ElseIf FileExists(G_StartupPath & ProgNameLong & ".cfg") = True Then
          cfg.GetCfg G_StartupPath & ProgNameLong & ".cfg"
        ElseIf FileExists(G_StartupPath & "..\cfg\IDV-Suite.cfg") = True Then
          cfg.GetCfg G_StartupPath & "..\cfg\IDV-Suite.cfg"
        ElseIf FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Then
          cfg.GetCfg G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg"
        ElseIf FileExists(G_StartupPath & "idv-suite.cfg") = True Then
          cfg.GetCfg G_StartupPath & "idv-suite.cfg"
        End If
        
        GetDBUser cfg
        
        If cfg.GetSection("DBCONNECTEXT") = True Then
          Dim connnectCount As Long
          Dim drv As String
          For connnectCount = 1 To 10
            drv = cfg.GetValue("DRIVER" & connnectCount)
            If drv <> "" Then
              If FileExists(drv) Then
                G_DBConnectionString = cfg.GetValue("CONNECTIONSTRING" & connnectCount)
                Exit For
              End If
            End If
          Next connnectCount
        End If
        
        If cfg.GetSection("GLOBALS") = True Then
        
          ' Was muss gesetzt sein, damit der Schutzbedarf tats|fffd|chlich gerechnet wird?
          s = cfg.GetValue("SBMUSS")
          If s <> "" Then
            If InStr(UCase(s), "VF") > 0 Then
              G_SchutzbedarfMussVerfuegbarkeit = True
              s = Replace(s, "VF", "")
            End If
            If InStr(UCase(s), "I") > 0 Then
              G_SchutzbedarfMussIntegritaet = True
              s = Replace(s, "I", "")
            End If
            If InStr(UCase(s), "V") > 0 Then
              G_SchutzbedarfMussVertraulichkeit = True
              s = Replace(s, "V", "")
            End If
          End If
          
          s = cfg.GetValue("TESTUSER")
          If s <> "" Then
            If InStr(UCase(s), UCase(GetUserName)) > 0 Then
              G_cfgTestuser = True
            End If
          End If
        
          s = cfg.GetValue("NURSCANPFADE")
          If s <> "" Then
            If InStr(UCase(s), "JA") > 0 Then
              G_cfgNurScanpfade = True
            End If
          End If
          
          s = cfg.GetValue("IGNOREWARNING")
          If s <> "" Then
            pos = 1
            Set G_cfgIgnoreWarningPaths = New Collection
            Do
              tss = GetNextText(s, pos)
              If tss <> "" Then
                If Right(tss, 1) <> "*" Then
                  tss = tss & "*"
                End If
                G_cfgIgnoreWarningPaths.Add tss
              End If
            Loop While tss <> ""
          End If
          
          s = cfg.GetValue("IGNOREBLOCK")
          If s <> "" Then
            pos = 1
            Set G_cfgIgnoreBlockPaths = New Collection
            Do
              tss = GetNextText(s, pos)
              If tss <> "" Then
                If Right(tss, 1) <> "*" Then
                  tss = tss & "*"
                End If
                G_cfgIgnoreBlockPaths.Add tss
              End If
            Loop While tss <> ""
          End If
          
          If Not G_cfgTestuser Then
            If UCase(cfg.GetValue("AKTIV")) = "NEIN" Or UCase(cfg.GetValue("ACTIVE")) = "NO" Then
              pluginDeaktiviert = True
              G_UserDeaktiviert = True
            End If
          End If
          
          For I = 1 To 5
            s = cfg.GetValue("LNKAPP" & I)
            If s <> "" Then
              If Left(s, 2) = "\\" Or Mid(s, 2, 1) = ":" Then
                If FileExists(s) Then
                  G_cfgLnkApp = s
                  Exit For
                End If
              Else
                G_cfgLnkApp = s
                Exit For
              End If
            End If
          
          Next I
          
          'If UCase(cfg.GetValue("INFORMATIONSKLASSEANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("INFORMATIONSKLASSEANZEIGEN")) Then
            G_CfgInformationsklasseAnzeigen = False
          End If
          'If UCase(cfg.GetValue("BANKFACHLICHANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("BANKFACHLICHANZEIGEN")) Then
            G_CfgBankfachlichAnzeigen = False
          End If
          'If UCase(cfg.GetValue("GOBDANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("GOBDANZEIGEN")) Then
            G_CfgGOBDAnzeigen = False
          End If
          'If UCase(cfg.GetValue("SCHUTZBEDARFSFENSTERANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("SCHUTZBEDARFSFENSTERANZEIGEN")) Then
            G_CfgSchutzbedarfsfensterAnzeigen = False
          End If
          'If UCase(cfg.GetValue("ZEITAUFWANDZURDOKUANZEIGEN")) = "NEIN" Then
          If IsNo(cfg.GetValue("ZEITAUFWANDZURDOKUANZEIGEN")) Then
            G_CfgZeitaufwandZurDokuAnzeigen = False
          End If

          G_cfgKeypfad = GetRelativePath(G_cfgKeypfad, cfg.GetValue("KEYPFAD"))
          G_cfgPasswortpfad = GetRelativePath(G_cfgPasswortpfad, cfg.GetValue("PASSWORTPFAD"))
          G_cfgLogpfad = GetRelativePath(G_cfgLogpfad, cfg.GetValue("LOGPFAD"))
          G_cfgTemppfad = GetRelativePath(G_cfgTemppfad, cfg.GetValue("TEMPPFAD"))
          
          If cfg.GetValue("BINPFAD") <> "" Then
            G_cfgBinpfad = GetRelativePath(G_cfgBinpfad, cfg.GetValue("BINPFAD"))
          End If
          
          If cfg.GetValue("ECCPFAD") <> "" Then
            G_cfgECCPfad = GetRelativePath(G_cfgECCPfad, cfg.GetValue("ECCPFAD"))
          End If
          If cfg.GetValue("ACCPFAD") <> "" Then
            G_cfgACCPfad = GetRelativePath(G_cfgACCPfad, cfg.GetValue("ACCPFAD"))
          End If
          If cfg.GetValue("EPPFAD") <> "" Then
            G_cfgEPPfad = GetRelativePath(G_cfgEPPfad, cfg.GetValue("EPPFAD"))
          End If
          If cfg.GetValue("EFCPFAD") <> "" Then
            G_cfgEFCPfad = GetRelativePath(G_cfgEFCPfad, cfg.GetValue("EFCPFAD"))
          End If
          If cfg.GetValue("ESQAPFAD") <> "" Then
            G_cfgESQAPfad = GetRelativePath(G_cfgESQAPfad, cfg.GetValue("ESQAPFAD"))
          End If
          G_cfgFreigabeformspeicherpfad = GetRelativePath(G_cfgFreigabeformspeicherpfad, cfg.GetValue("FREIGABEFORMSPEICHERPFAD"))
        
          If InStr(UCase(cfg.GetValue("FORCELOGUSERS")), UCase(GetUserName())) > 0 Then
            tFORCELOGUSERS = True
          End If
          If InStr(UCase(cfg.GetValue("LOGWINDOWVISIBLEUSERS")), UCase(GetUserName())) > 0 Then
            tLOGWINDOWVISIBLEUSERS = True
          End If
          
          s = cfg.GetValue("SBSNOID")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            G_cfgSBSNoID = True
          End If
          
          G_Dokuformular = cfg.GetValue("DOKUFORMULAR")
          If G_Dokuformular <> "" Then
            G_Dokuformular = GetFullPath(G_Dokuformular)
          Else
            G_Dokuformular = G_cfgBinpfad & "\Filedoku.dot"
          End If
          
          'G_Freigabeformular = cfg.GetValue("FREIGABEFORMULAR")
          Dim freigabeformular As String
          freigabeformular = cfg.GetValue("FREIGABEFORMULAR")
          If freigabeformular <> "" Then
            freigabeformular = GetFullPath(freigabeformular)
            Call SetFreigabeformular(freigabeformular)
            'Debug.Print G_Freigabeformular()
          End If
          
          s = cfg.GetValue("CURSORLOCATION")
          If UCase(s) = "SERVER" Then
            G_Cursorlocation = ADODB.adUseServer
          Else
            G_Cursorlocation = ADODB.adUseClient
          End If
          
          If cfg.GetValue("CONNECTIONTIMEOUT") <> "" Then
              G_PARAM_TimeoutConnection = CLng(Val(cfg.GetValue("CONNECTIONTIMEOUT")))
          End If
          If cfg.GetValue("TABELLENOEFFNENTIMEOUT") <> "" Then
              G_PARAM_TimeoutTableOpen = CLng(Val(cfg.GetValue("TABELLENOEFFNENTIMEOUT")))
          End If
          
          
          s = cfg.GetValue("TESTAREA")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            G_cfgTestarea = True
          End If
          
          s = cfg.GetValue("NOAD")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            G_cfgNoAD = True
          End If
          
          If InStr(UCase(cfg.GetValue("FORCECRASH")), UCase(GetUserName())) > 0 Then
              Dim A(1) As Byte, b(1) As Byte
              ' ReDim b(10000)
              CopyMemory b(0), A(0), 10000
          End If
          
          s = cfg.GetValue("FREIGABEABRISIKO")
          If s <> "" Then
            If IsNumeric(s) Then
              G_cfgFreigabeAbRisiko = Val(s)
            End If
          End If
          
          s = cfg.GetValue("ADSTRING")
          If s <> "" Then
            G_cfgADString = s
          End If
          
          ' This is in ABGR format. So
          ' LOGOFARBE=000000ff
          ' will be pure red
          Dim logoFarbe As String
          logoFarbe = cfg.GetValue("LOGOFARBE")
          If logoFarbe <> "" Then
              If Not (Left(logoFarbe, 2) = "&H") Then
                  logoFarbe = "&H" & logoFarbe
              End If
              If Not (Right(logoFarbe, 1) = "&") Then
                  logoFarbe = logoFarbe & "&"
              End If
              ' wir brauchen hier ARGB, also Werte umdrehen
              'logoFarbe = Left(logoFarbe, 2) & Mid(logoFarbe, 9, 2) & Mid(logoFarbe, 7, 2) & Mid(logoFarbe, 5, 2) & Mid(logoFarbe, 3, 2) & "&"
              
              G_CfgLogoFarbe = Val(logoFarbe)
          End If
  
          ' Prozessauswahl
          G_CfgPASchluesselPx = 120
          G_CfgPAProzEbene1Px = 200
          G_CfgPAProzEbene2Px = 200
          G_CfgPAProzEbene3Px = 200
          If cfg.GetValue("PASCHLUESSELPX") <> "" Then
            G_CfgPASchluesselPx = CLng(Val(cfg.GetValue("PASCHLUESSELPX")))
          End If
          If cfg.GetValue("PAPROZEBENE1PX") <> "" Then
            G_CfgPAProzEbene1Px = CLng(Val(cfg.GetValue("PAPROZEBENE1PX")))
          End If
          If cfg.GetValue("PAPROZEBENE2PX") <> "" Then
            G_CfgPAProzEbene2Px = CLng(Val(cfg.GetValue("PAPROZEBENE2PX")))
          End If
          If cfg.GetValue("PAPROZEBENE3PX") <> "" Then
            G_CfgPAProzEbene3Px = CLng(Val(cfg.GetValue("PAPROZEBENE3PX")))
          End If
          G_CfgPANoTextfile = IsYes(cfg.GetValue("PANOTEXTFILE"))
          If G_CfgPANoTextfile = False Then
            If Not FileExists(G_StartupPath & "..\BIN\Processes.txt") Then
              ' Wenn es die Datei nicht gibt, das feature disablen
              G_CfgPANoTextfile = True
            End If
          End If
          
          ' So war die Anzeige vorher (ohne Ebene 3)
          G_CfgPAReihenfolge = "ABC"
          If cfg.GetValue("PAREIHENFOLGE") <> "" Then
            G_CfgPAReihenfolge = cfg.GetValue("PAREIHENFOLGE")
          End If
          
          G_CfgPAReihenfolgeDoku = "ABC"
          If cfg.GetValue("PAREIHENFOLGEDOKU") <> "" Then
            G_CfgPAReihenfolgeDoku = cfg.GetValue("PAREIHENFOLGEDOKU")
          End If
                    
          s = cfg.GetValue("PROZESSUNBEKANNTSICHTBAR")
          If UCase(s) = "NEIN" Then
            G_CfgProzessUnbekanntSichtbar = False
          End If
                    
          For I = 1 To 5
            G_cfgExcel = cfg.GetValue("EXCEL" & I)
            If G_cfgExcel <> "" Then
              If FileExists(G_cfgExcel) Then
                Exit For
              Else
                G_cfgExcel = ""
              End If
            End If
          Next I
        End If

        If cfg.GetSection(ProgNameLong) = True Then
          s = cfg.GetValue("HELLOWORLD")
          'If UCase(s) = "JA" Then
          If IsYes(s) Then
            'MsgBox "Der " & ProgNameLong & " wurde gestartet.", vbInformation + vbSystemModal, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
            MsgBox FMT1("GS_1", ProgNameLong), vbInformation + vbSystemModal, ProgNameLong & " " & myVersion ' ' & " (Build: " & MyInternalVersion & ")"
          End If
        
          CheckMyCfgStuffApp cfg
        End If
        
        If cfg.GetSection(ProgNameLong & "-" & GetUserName) = True Then
          DebugPrint DebType.terror, "Individual Cfg for: " & GetUserName
          CheckMyCfgStuffApp cfg
        End If
        

        If cfg.GetSection("ECC") = True Then
          G_cfgCanceltime = cfg.GetValue("CANCELTIME")
          If G_cfgCanceltime = "" Then
            G_cfgCanceltime = "00:05:00"
          ElseIf Len(G_cfgCanceltime) <> 8 Or Mid(G_cfgCanceltime, 3, 1) <> ":" Or Mid(G_cfgCanceltime, 6, 1) <> ":" Or IsNumeric(Mid(G_cfgCanceltime, 1, 2)) = False Or IsNumeric(Mid(G_cfgCanceltime, 4, 2)) = False Or IsNumeric(Mid(G_cfgCanceltime, 7, 2)) = False Then
            'MsgBox "Die CANCELTIME in der Sektion [ECC] der Konfiguration entspricht nicht dem Format hh:mm:ss. Der Wert wird auf 00:01:30 gesetzt.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
            MsgBox FMT0("GS_2"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
            G_cfgCanceltime = "00:05:00"
          End If
        
          G_cfgLoadtime = cfg.GetValue("LOADTIME")
          If G_cfgLoadtime = "" Then
            G_cfgLoadtime = "00:03:30"
          ElseIf Len(G_cfgLoadtime) <> 8 Or Mid(G_cfgLoadtime, 3, 1) <> ":" Or Mid(G_cfgLoadtime, 6, 1) <> ":" Or IsNumeric(Mid(G_cfgLoadtime, 1, 2)) = False Or IsNumeric(Mid(G_cfgLoadtime, 4, 2)) = False Or IsNumeric(Mid(G_cfgLoadtime, 7, 2)) = False Then
            'MsgBox "Die LOADTIME in der Sektion [ECC] der Konfiguration entspricht nicht dem Format hh:mm:ss. Der Wert wird auf 00:01:30 gesetzt.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
            MsgBox FMT0("GS_3"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
            G_cfgLoadtime = "00:03:30"
          End If
          
          G_cfgSpecialcellstime = cfg.GetValue("SPECIALCELLSTIME")
          If G_cfgSpecialcellstime = "" Then
            G_cfgSpecialcellstime = "00:30:00"
          ElseIf Len(G_cfgSpecialcellstime) <> 8 Or Mid(G_cfgSpecialcellstime, 3, 1) <> ":" Or Mid(G_cfgSpecialcellstime, 6, 1) <> ":" Or IsNumeric(Mid(G_cfgSpecialcellstime, 1, 2)) = False Or IsNumeric(Mid(G_cfgSpecialcellstime, 4, 2)) = False Or IsNumeric(Mid(G_cfgSpecialcellstime, 7, 2)) = False Then
            'MsgBox "Die SPECIALCELLSTIME in der Sektion [ECC] der Konfiguration entspricht nicht dem Format hh:mm:ss. Der Wert wird auf 00:01:30 gesetzt.", vbCritical + vbSystemModal, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
            MsgBox FMT0("GS_4"), vbCritical + vbSystemModal, ProgNameLong & " " & myVersion ' & " (Build: " & MyInternalVersion & ")"
            G_cfgSpecialcellstime = "00:30:00"
          End If
        
        End If

        If cfg.GetSection("IDV-Suite") = True Then
          'If UCase(cfg.GetValue("OEUSERIMPORTDEAKTIVIERT")) = "JA" Then
          If IsYes(cfg.GetValue("OEUSERIMPORTDEAKTIVIERT")) Then
              G_cfgOEUserDeaktivert = True
          End If
        End If
        
        ' Achtung, dieser Code steht in der DLL an einer anderen Stelle, da bei XLSM und MDA die CFGs gemerged werden
        ' passt ADGruppe?
        If G_UserDeaktiviert = False Then
          Dim ADGruppe As String
          ADGruppe = GetADGruppe(cfg)
          If ADGruppe <> "" Then
              Dim userGroups As String
              userGroups = GetUserGroups(GetUserName())
              If userGroups = "" Then
                If G_cfgTestuser Then
                  DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, keine AD Berechtigungen, aber User ist TESTUSER!"
                Else
                  DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, keine AD Berechtigungen"
                  G_UserDeaktiviert = True
                End If
              Else
                  G_UserDeaktiviert = True
                  
                  ' und alle durchlaufen
                  Dim ts() As String
                  ts = Split(userGroups, ",")
                  For I = LBound(ts) To UBound(ts)
                      If ts(I) = "'" & ADGruppe & "'" Then
                          ' wenn wir die Gruppen finden, dann ist doch alles gut
                          G_UserDeaktiviert = False
                      End If
                  Next I
                  If G_UserDeaktiviert = True Then
                    If G_cfgTestuser Then
                      DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, besitzt AD Berechtigung nicht, aber User ist TESTUSER!"
                      G_UserDeaktiviert = False
                    Else
                      DebugPrint DebType.tinfo, "USER " & GetUserName() & " ausgeschlossen, besitzt AD Berechtigung nicht"
                    End If
                  End If
              End If
          End If
        End If

        ' Die string tables laden!
        Call InitTranslation(G_cfgBinpfad, "EFC", cfg)
        
        Set cfg = Nothing
    Else
        Call InitTranslation(G_cfgBinpfad, "EFC", cfg)
    End If
    
    If Len(G_cfgLogpfad) > 0 And PathExists(G_cfgLogpfad) = False Then Mk_Dir G_cfgLogpfad
    If Len(G_cfgTemppfad) > 0 And PathExists(G_cfgTemppfad) = False Then Mk_Dir G_cfgTemppfad
    If Len(G_cfgPasswortpfad) > 0 And PathExists(G_cfgPasswortpfad) = False Then Mk_Dir G_cfgPasswortpfad
'    If Len(G_cfgECCPfad) > 0 And PathExists(G_cfgECCPfad) = False Then Mk_Dir G_cfgECCPfad
'    If Len(G_cfgACCPfad) > 0 And PathExists(G_cfgACCPfad) = False Then Mk_Dir G_cfgACCPfad
'    If Len(G_cfgEPPfad) > 0 And PathExists(G_cfgEPPfad) = False Then Mk_Dir G_cfgEPPfad
'    If Len(G_cfgEFCPfad) > 0 And PathExists(G_cfgEFCPfad) = False Then Mk_Dir G_cfgEFCPfad
'    If Len(G_cfgESQAPfad) > 0 And PathExists(G_cfgESQAPfad) = False Then Mk_Dir G_cfgESQAPfad
    
' Das Log wird beim Scheduler in Main gel|fffd|scht.
#If PROJECT_IDVSCHEDULER = 0 Then
    If FileExists(GetStorePath(tLog) & ProgNameLong & "-" & GetUserName & ".txt") Then
        MyKill GetStorePath(tLog) & ProgNameLong & "-" & GetUserName & ".txt"
    End If
#End If
    
    If PathExists(G_cfgLogpfad) = False Or PathExists(G_cfgTemppfad) = False Or PathExists(G_cfgPasswortpfad) = False Or PathExists(G_cfgKeypfad) = False Or PathExists(G_cfgECCPfad) = False Or PathExists(G_cfgEPPfad) = False Or PathExists(G_cfgFreigabeformspeicherpfad) = False Or PathExists(G_cfgACCPfad) = False Or PathExists(G_cfgEFCPfad) = False Or PathExists(G_cfgESQAPfad) = False Then
      If Not PathExists(G_cfgLogpfad) Then
        DebugPrint DebType.terror, "Log-Pfad fehlt: " & G_cfgLogpfad
      End If
      If Not PathExists(G_cfgTemppfad) Then
        DebugPrint DebType.terror, "Temppfad fehlt: " & G_cfgTemppfad
      End If
      If Not PathExists(G_cfgPasswortpfad) Then
        DebugPrint DebType.terror, "Passwortpfad fehlt: " & G_cfgPasswortpfad
      End If
      If Not PathExists(G_cfgKeypfad) Then
        DebugPrint DebType.terror, "Keypfad fehlt: " & G_cfgKeypfad
      End If
      If Not PathExists(G_cfgECCPfad) Then
        DebugPrint DebType.terror, "ECC-Pfad fehlt: " & G_cfgECCPfad
      End If
      If Not PathExists(G_cfgACCPfad) Then
        DebugPrint DebType.terror, "ACC-Pfad fehlt: " & G_cfgACCPfad
      End If
      If Not PathExists(G_cfgEPPfad) Then
        DebugPrint DebType.terror, "EP-Pfad fehlt: " & G_cfgEPPfad
      End If
      If Not PathExists(G_cfgEFCPfad) Then
        DebugPrint DebType.terror, "EFC-Pfad fehlt: " & G_cfgEFCPfad
      End If
      If Not PathExists(G_cfgESQAPfad) Then
        DebugPrint DebType.terror, "ESQA-Pfad fehlt: " & G_cfgESQAPfad
      End If
      If Not PathExists(G_cfgFreigabeformspeicherpfad) Then
        DebugPrint DebType.terror, "Freigabeformular-Speicherpfad fehlt: " & G_cfgFreigabeformspeicherpfad
      End If
    End If
    
    If Not PathExists(G_cfgLogpfad) Or Len(G_cfgLogpfad) = 0 Then G_cfgLogpfad = G_StartupPath
    If Not PathExists(G_cfgTemppfad) Or Len(G_cfgTemppfad) = 0 Then G_cfgTemppfad = G_StartupPath
    If Not PathExists(G_cfgPasswortpfad) Or Len(G_cfgPasswortpfad) = 0 Then G_cfgPasswortpfad = G_StartupPath
    If Not PathExists(G_cfgKeypfad) Or Len(G_cfgKeypfad) = 0 Then G_cfgKeypfad = G_StartupPath
    If Not PathExists(G_cfgECCPfad) Or Len(G_cfgECCPfad) = 0 Then G_cfgECCPfad = G_StartupPath
    If Not PathExists(G_cfgACCPfad) Or Len(G_cfgACCPfad) = 0 Then G_cfgACCPfad = G_StartupPath
    If Not PathExists(G_cfgEPPfad) Or Len(G_cfgEPPfad) = 0 Then G_cfgEPPfad = G_StartupPath
    If Not PathExists(G_cfgEFCPfad) Or Len(G_cfgEFCPfad) = 0 Then G_cfgEFCPfad = G_StartupPath
    If Not PathExists(G_cfgESQAPfad) Or Len(G_cfgESQAPfad) = 0 Then G_cfgESQAPfad = G_StartupPath
    If Not PathExists(G_cfgFreigabeformspeicherpfad) Or Len(G_cfgFreigabeformspeicherpfad) = 0 Then G_cfgFreigabeformspeicherpfad = G_StartupPath
    
    If G_Firmenlogo = "" Then
      If FileExists(G_cfgBinpfad & "\firmenlogo.bmp") Then
          G_Firmenlogo = G_cfgBinpfad & "\firmenlogo.bmp"
      ElseIf FileExists(G_cfgBinpfad & "\gfx\firmenlogo.bmp") Then
          G_Firmenlogo = G_cfgBinpfad & "\gfx\firmenlogo.bmp"
      End If
    End If
    

    AddLog appname & " gestartet"
    AddLog "LOGPFAD=" & G_cfgLogpfad
    AddLog "BINPFAD=" & G_cfgBinpfad
    AddLog "TEMPPFAD=" & G_cfgTemppfad
    AddLog "PASSWORTPFAD=" & G_cfgPasswortpfad
    AddLog "KEYPFAD=" & G_cfgKeypfad
    AddLog "ECCPFAD=" & G_cfgECCPfad
    AddLog "ACCPFAD=" & G_cfgACCPfad
    AddLog "EPPFAD=" & G_cfgEPPfad
    AddLog "EFCPFAD=" & G_cfgEFCPfad
    AddLog "ESQAPFAD=" & G_cfgESQAPfad
    AddLog "FREIGABEFORMSPEICHERPFAD=" & G_cfgFreigabeformspeicherpfad
    
    AddLog "CANCELTIME: " & G_cfgCanceltime
    AddLog "LOADTIME: " & G_cfgLoadtime
    AddLog "SPECIALCELLSTIME: " & G_cfgLoadtime
    
    If tFORCELOGUSERS Then
      G_cfgDebugInfosLoggen = True
      G_LogThisUser = True
    End If
    If tLOGWINDOWVISIBLEUSERS Then
      If G_LogToWindow = False Then
        ShowLogWindow
      End If
    End If
    
    
    If pluginDeaktiviert Then
       DebugPrint DebType.tinfo, "*** Plugin |fffd|ber CFG deaktivert!"
    End If
    
    If FileExists(G_StartupPath & ProgNameLong & ".cfg") = True Or FileExists(G_StartupPath & "..\cfg\IDV-Suite.cfg") = True Or _
        FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Or _
        FileExists(G_StartupPath & "IDV-Suite.cfg") = True Then
        
        If FileExists(G_StartupPath & ProgNameLong & ".cfg") = True Then
          DebugPrint tinfo, "CFG: " & G_StartupPath & ProgNameLong & ".cfg"
        ElseIf FileExists(G_StartupPath & "..\cfg\IDV-Suite.cfg") = True Then
          DebugPrint tinfo, "CFG: " & G_StartupPath & "..\cfg\IDV-Suite.cfg"
        ElseIf FileExists(G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg") = True Then
          DebugPrint tinfo, "CFG: " & G_StartupPath & "..\..\IDV-Suite-Plugins\cfg\IDV-Suite.cfg"
        ElseIf FileExists(G_StartupPath & "idv-suite.cfg") = True Then
          DebugPrint tinfo, "CFG: " & G_StartupPath & "idv-suite.cfg"
        End If
    End If
    
    If tFORCELOGUSERS Then
      DebugPrint DebType.tdebug, "** ACHTUNG: FORCELOGUSERS f|fffd|r " & GetUserName & " aktiviert! Alles wird geloggt!"
    End If
    
    DebugPrint DebType.tdebug, "CFG: DebugInfosLoggen=" & IIf(G_cfgDebugInfosLoggen, "Ja", "Nein")
    ' DebugPrint DebType.tdebug, "CFG: NONTFS=" & IIf(G_NoNTFS, "JA", "NEIN")
    DebugPrint DebType.tdebug, "DBConnection String: " & G_DBConnectionString
    
    gCHR = ""
    gCursorLocation = 2
    If FileExists(G_StartupPath & "oracle.cfg") = True Then
        gCHR = """"
        gCursorLocation = 3
    End If
End Sub

Private Sub SetFreigabeformular(name As String)
    G_MyFreigabeformular = name
End Sub

Public Function G_Freigabeformular() As String
    If G_MyFreigabeformular <> "" Then
        Dim Filename As String
        Filename = gTranslation.GetLocalizedFile(G_MyFreigabeformular)
        G_Freigabeformular = Filename
        Exit Function
    End If
    
    G_Freigabeformular = G_MyFreigabeformular
End Function

Private Sub CheckMyCfgStuffApp(ByRef cfg As CfgReader)

    Dim s As String
    
    s = cfg.GetValue("DEBUGINFOSLOGGEN")
    'If UCase(s) = "JA" Then
    If IsYes(s) Then
        G_cfgDebugInfosLoggen = True
    'ElseIf UCase(s) = "NEIN" Then
    ElseIf IsNo(s) Then
        G_cfgDebugInfosLoggen = False
    End If
    
    s = cfg.GetValue("MSGBOXFORERRORS")
    'If UCase(s) = "JA" Then
    If IsYes(s) Then
        G_cfgShowMSGBoxForAllErrors = True
    'ElseIf UCase(s) = "NEIN" Then
    ElseIf IsNo(s) Then
        G_cfgShowMSGBoxForAllErrors = False
    End If
    
    s = cfg.GetValue("KONVERTIERENBUTTON")
    'If UCase(s) = "JA" Then
    If IsYes(s) Then
        G_cfgKonvertierenAktiv = True
    'ElseIf UCase(s) = "NEIN" Then
    ElseIf IsNo(s) Then
        G_cfgKonvertierenAktiv = False
    End If
    
    s = cfg.GetValue("TOOLBARRECHTSOBEN")
    'If UCase(s) = "NEIN" Then
    If IsNo(s) Then
      G_cfgToolbarRechtsOben = False
    Else
      G_cfgToolbarRechtsOben = True
    End If

    If cfg.GetValue("KEYPFAD") <> "" Then
      G_cfgKeypfad = GetRelativePath("", cfg.GetValue("KEYPFAD"))
    End If
    If cfg.GetValue("PASSWORTPFAD") <> "" Then
      G_cfgPasswortpfad = GetRelativePath("", cfg.GetValue("PASSWORTPFAD"))
    End If
    If cfg.GetValue("LOGPFAD") <> "" Then
      G_cfgLogpfad = GetRelativePath("", cfg.GetValue("LOGPFAD"))
    End If
    If cfg.GetValue("TEMPPFAD") <> "" Then
      G_cfgTemppfad = GetRelativePath("", cfg.GetValue("TEMPPFAD"))
    End If
    If cfg.GetValue("INFOPFAD") <> "" Then
      G_cfgInfoPfad = GetRelativePath("", cfg.GetValue("INFOPFAD"))
    End If
    
    G_CriticalAddins = cfg.GetValue("CRITICALADDIN")
    
    
    If IsNumeric(cfg.GetValue("LEERZELLEN")) Then
      G_MaxLeerzellen = CLng(cfg.GetValue("LEERZELLEN"))
    End If
    If IsYes(cfg.GetValue("NURFORMELN")) Then
      G_ShowOnlyFormulas = True
    End If
    If IsYes(cfg.GetValue("VBADIFF")) Then
      G_ShowVBADifferences = True
    End If
    
End Sub

Function GetStandardData() As String
  On Error GoTo noData
  
  Dim trs As String
  
  G_Lizenzen = -3
  G_Lizenznehmer = ""
  
  If FileExists(GetStorePath(tKey) & "swres.swk") = True Or FileExists(G_StartupPath & "swres.swk") = True Or FileExists(G_StartupPath & "..\swres.swk") = True Or FileExists(G_StartupPath & "..\BIN\swres.swk") = True Then
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    s = GetSWResItem(1500, ff)
    G_Lizenznehmer = GetSWResItem(2000, ff)
    
    If InStr(s, "IDVT,") > 0 Then
    
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = Val(GetSWResItem(3000, ff))
      G_Lizenzen = Val(GetSWResItem(3100, ff))
      Dim ts As String
      ts = GetSWResItem(3200, ff)
      If IsDate(ts) Then
        G_FullDemoBis = ConvGermanDateKey(ts)
      End If
      'G_Wartung = IIf(UCase(GetSWResItem(3300, ff)) = "JA", True, False)
      G_Wartung = IIf(IsYes(GetSWResItem(3300, ff)), True, False)
      G_WartungBis = ConvGermanDateKey(GetSWResItem(3400, ff))
      G_FullVersion = True
      
      If G_Lizenzen = -1 Then
        'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trs = FMT2("GS_5", G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_6", G_FullDemoBis, G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("GS_7", G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = -2 Then
        'trs = G_Lizenzen & "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_8", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
      ElseIf G_Lizenzen = 1 Then
        'trs = G_Lizenzen & "Lizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_9", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
      Else
        'trs = G_Lizenzen & "Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("GS_10", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
      End If
      
      If G_Wartung Then
        'trs = trs & vbCrLf & vbCrLf & "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", "")
        trs = trs & FMT1("GS_11", G_WartungBis) & IIf(Now > G_WartungBis, FMT0("GS_12"), "")
      End If
      
      s = GetSWResItem(6500, ff)
      If s <> "" Then
          Dim tCfg As New CfgReader
          tCfg.GetCFGString s
          s = tCfg.GetValue("INR")
          If s <> "" Then
              G_PARAM_Institutsnummer = s & "_"
              DebugPrint tdebug, "Institutsnummer: " & s
          End If
      End If
      
    End If
  End If
  
  GetStandardData = trs
  Exit Function
  
noData:
  Exit Function
End Function


Function GetStorePath(ptype As PathType)

    Dim tpath As String
    tpath = G_StartupPath
    
    Select Case ptype
      Case PathType.tLog
        tpath = G_cfgLogpfad
      Case PathType.tTemp
        tpath = G_cfgTemppfad
      Case PathType.tPassword
        tpath = G_cfgPasswortpfad
      Case PathType.tKey
        tpath = G_cfgKeypfad
      Case PathType.tEcc
        tpath = G_cfgECCPfad
      Case PathType.tAcc
        tpath = G_cfgACCPfad
      Case PathType.tEP
        tpath = G_cfgEPPfad
      Case PathType.tEFC
        tpath = G_cfgEFCPfad
      Case PathType.tESQA
        tpath = G_cfgESQAPfad
      Case PathType.tFreigabeform
        tpath = G_cfgFreigabeformspeicherpfad
    End Select

    If Right(tpath, 1) <> "\" And Right(tpath, 1) <> "/" Then
      tpath = tpath & "\"
    End If

    GetStorePath = tpath
    
End Function




Attribute VB_Name = "Globals"
Option Explicit

Public Const MyVersionNumber As String = "2.5"
Public Const MyProgramReleaseDate As Date = #7/15/2018#
Public Const MyProgramLicenseVersion As Long = 1
Public Const MyInternalVersion As Long = 9
Public Const progNameShort As String = "EFC"
Public Const ProgNameLong As String = "Excel-File-Compare"
Public Const StartProgCopyright As String = "2007"
Public Const MyAppID = 8

Public Const C_CheckForLibs As Boolean = False
Public Const C_ShowUpdates As Boolean = False
Public Const C_Unused As Long = 10000

Public Const C_PARAM_UseOnlyOneLV As Boolean = False

Public Const C_PARAM_ChangedFormulasWithIdenticalResultAreEqual As Boolean = False

Public Const C_PARAM_AllowedR1C1Compares As Boolean = True

Public Const C_PARAM_AllowedBlanksBetweenAreasX As Long = 1
Public Const C_PARAM_AllowedBlanksBetweenAreasY As Long = 1

' Public Const C_PARAM_AllowedBlanksBetweenAreasX As Long = 12
' Public Const C_PARAM_AllowedBlanksBetweenAreasY As Long = 3


Public Const C_PARAM_UseMultipleCompares As Boolean = True
Public Const C_PARAM_CompareAdjacentCellsDistance As Long = 3

Public Const C_PARAM_MaxCompareLineLVs As Long = 3

Public Const C_PARAM_PercentIdent1 As Long = 100
Public Const C_PARAM_PercentIdent2 As Long = 100
Public Const C_PARAM_PercentIdent3 As Long = 60
Public Const C_PARAM_PercentIdent4 As Long = 70
Public Const C_PARAM_PercentIdent5 As Long = 55
Public Const C_PARAM_PercentIdent As Long = 70

Public Const C_PARAM_Area_Column_Move As Long = 10
Public Const C_PARAM_Area_Row_Move As Long = 40
Public Const C_PARAM_Check_Rows_Before_And_After As Long = 10


Public xlsDateien As Collection
Public inaccessablePaths As Collection
Public Funcs As Collection
Public FuncArray
Public TotalUsedBytes As Long
Public TotalUsedFiles As Long
Public TotalUnusedBytes As Long
Public TotalUnusedFiles As Long
Public TotalUnusedBytesOlder As Long
Public TotalUnusedFilesOlder As Long
Public TotalUnusedBytesSmaller As Long
Public TotalUnusedFilesSmaller As Long
Public TotalUnusedBytesDouble As Long
Public TotalUnusedFilesDouble As Long

Public ShowSingleFileAnalysis As Boolean

Private AmountScanned As Long

Public ChangedWorksheets As Collection
Public ChangedWorksheetsForPrint As Collection

Public Trans

Public G_LogEnabled As Boolean

Public G_EFCPro As Boolean

Public FullVersion As Boolean

Public G_QuickstartMode As Boolean
Public G_UnattendedMode As Boolean

Public G_conn As Object
Public AR_UseDB  As Boolean
Public AR_StartedByApp As StromwerkenAppID

Public G_Sheets As Collection
Public G_Result_X As Long
Public G_Result_Y As Long
Public G_Endresult_X As Long
Public G_Endresult_Y As Long

Public G_MaxLeerzellen As Long
Public G_ShowOnlyFormulas As Boolean
Public G_ShowVBADifferences As Boolean

Public G_PARAM_Datenbankprefix As String
Public G_PARAM_Institutsnummer As String

Public G_ChangedWorkbook As Boolean

Public G_HiglyEncryptedSheetPW As Long
Public G_HiglyEncryptedWorkbookPW  As Long

Public NextTime As Date

Public Function myVersion() As String
    myVersion = "V" & MyVersionNumber
End Function

Public Sub EFCCreateHeaderAndFooter()
    On Error Resume Next
    ' Datum der Generierung in die Fu|fffd|zeile eintragen
    With ActiveSheet.PageSetup
        Dim usr As String
        usr = Environ("USERNAME")
        If Len(usr) Then
            '.LeftFooter = "Generiert am " & Now() & " von " & usr
            .LeftFooter = FMT2("Globals_2", Now(), usr)
        Else
            '.LeftFooter = "Generiert am " & Now()
            .LeftFooter = FMT1("Globals_3", Now())
        End If
        '.RightHeader = "&7" & ProgNameLong & IIf(FullVersion, IIf(G_EFCPro, " PRO", ""), " (DEMO)") & " " & MainMenu.Vers & vbLf & MainMenu.Cop
        .RightHeader = "&7" & ProgNameLong & IIf(FullVersion, IIf(G_EFCPro, FMT0("Globals_4"), ""), FMT0("Globals_5")) & " " & MainMenu.Vers & vbLf & MainMenu.Cop
        .LeftHeader = "&7" & trsShrt
    End With

End Sub

Function GenerateSheet(outputSheetName As String, Optional oldWorkbookName As String = "") As String
    
    Dim myFilename As String
    Dim I As Long
    If Len(oldWorkbookName) = 0 Then
        Workbooks.Add
        myFilename = ActiveWorkbook.name
    Else
        myFilename = oldWorkbookName
    End If
    Application.DisplayAlerts = False
    If Len(oldWorkbookName) = 0 Then
        For I = ActiveWorkbook.Worksheets.Count To 2 Step -1
          ActiveWorkbook.Worksheets(I).Delete
        Next I
        'ActiveWorkbook.Worksheets(i).name = "LeeresBlatt"
        ActiveWorkbook.Worksheets(I).name = FMT0("Globals_6")
        'ThisWorkbook.Worksheets(outputSheetName & "Leer").Activate
        ThisWorkbook.Worksheets(outputSheetName & FMT0("Globals_7")).Activate
        'ThisWorkbook.Worksheets(outputSheetName & "Leer").Copy Workbooks(myFilename).Sheets(1)
        ThisWorkbook.Worksheets(outputSheetName & FMT0("Globals_7")).Copy Workbooks(myFilename).Sheets(1)
        'ActiveWorkbook.Worksheets(outputSheetName & "Leer").name = outputSheetName
        ActiveWorkbook.Worksheets(outputSheetName & FMT0("Globals_7")).name = outputSheetName
        
        'ActiveWorkbook.Worksheets("LeeresBlatt").Delete
        ActiveWorkbook.Worksheets(FMT0("Globals_6")).Delete
    Else
'        ActiveWorkbook.workSheets.Add after:=ActiveWorkbook.workSheets(ActiveWorkbook.workSheets.Count)
        'ThisWorkbook.Worksheets(outputSheetName & "Leer").Copy after:=Workbooks(myFilename).Worksheets(Workbooks(myFilename).Worksheets.Count)
        ThisWorkbook.Worksheets(outputSheetName & FMT0("Globals_7")).Copy After:=Workbooks(myFilename).Worksheets(Workbooks(myFilename).Worksheets.Count)
        'Workbooks(myFilename).Worksheets(outputSheetName & "Leer").name = outputSheetName
        Workbooks(myFilename).Worksheets(outputSheetName & FMT0("Globals_7")).name = outputSheetName
    End If
    
    Application.DisplayAlerts = True

    Globals.EFCCreateHeaderAndFooter
    GenerateSheet = myFilename
End Function

Function SheetHasPassword(oxlwsheet)
    SheetHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwsheet.Unprotect "12%%XXy<11!A"
    SheetHasPassword = False
password_notok:
End Function

Function WorkbookHasPassword(oxlwbook)
    WorkbookHasPassword = True
    On Error GoTo password_notok
    ' Wir probieren das Ganze mit einem idiotischen Passwort
    oxlwbook.Unprotect "12%%XXy<11!A"
    WorkbookHasPassword = False
password_notok:
End Function

'********************************************
'* Diese Funktion pr|fffd|ft, ob Felder durch "ziehen" eines links oder dar|fffd|ber
'* befindlichen anderen Feldes entstanden sind. Hierf|fffd|r werden nur direkt
'* anliegende Felder |fffd|berpr|fffd|ft.
'********************************************
Function ZellAbweichung(formula As String, cmpString As String) As Boolean
    Dim cc As Long
    Dim cf As Long
    cf = 1
    cc = 1
    ZellAbweichung = True
    If (Len(cmpString) = 0 And Len(formula) > 0) Or _
       (Len(cmpString) > 0 And Len(formula) = 0) Then
        Exit Function
    End If
    Do While cc <= Len(cmpString)
        If cf > Len(formula) Then Exit Function
        ' wenns ein Buchstabe ist...
        If Mid(cmpString, cc, 1) >= "A" And _
           Mid(cmpString, cc, 1) <= "Z" Then
           
           ' Maximal eine Abweichung ist erlaubt
            If Asc(Mid(formula, cf, 1)) < Asc(Mid(cmpString, cc, 1)) - 1 Or _
               Asc(Mid(formula, cf, 1)) > Asc(Mid(cmpString, cc, 1)) + 1 Then
                  ' Hmmm, wenn die 2 Zeichen au|fffd|erhalb liegen, dann k|fffd|nnte es noch AZ etc. sein
                  If (Mid(formula, cf, 1) <> "A" And Mid(cmpString, cc, 1) <> "Z") And _
                     (Mid(formula, cf, 1) <> "a" And Mid(cmpString, cc, 1) <> "z") And _
                     (Mid(formula, cf, 1) <> "Z" And Mid(cmpString, cc, 1) <> "A") And _
                     (Mid(formula, cf, 1) <> "z" And Mid(cmpString, cc, 1) <> "a") Then
                      ' Das ist eine Abweichung
                      Exit Function
                  End If
            End If
            cf = cf + 1
            cc = cc + 1
        ' Wenns ne Zahl ist muss die Zahl ermittelt werden
        ElseIf Mid(cmpString, cc, 1) >= "0" And _
               Mid(cmpString, cc, 1) <= "9" Then
               ' Zahl besorgen
               Dim ccstart As Long
               Dim cfstart As Long
               
               ccstart = cc
               cfstart = cf
               
               ' hm, das ist auch keine Abweichung, dann m|fffd|ssen wir nur noch
               ' die counter bis zum ende der Zahlen erh|fffd|hen
               While Mid(cmpString, cc, 1) >= "0" And _
                     Mid(cmpString, cc, 1) <= "9"
                        cc = cc + 1
               Wend
               While Mid(formula, cf, 1) >= "0" And _
                     Mid(formula, cf, 1) <= "9"
                        cf = cf + 1
               Wend
               
               Dim num1 As Double
               Dim num2 As Double
               num1 = Val(Mid(cmpString, ccstart, cc - ccstart))
               num2 = Val(Mid(formula, cfstart, cf - cfstart))
               If num1 < num2 - 1 Or num1 > num2 + 1 Then
                    Exit Function
               End If
        
        ElseIf Mid(cmpString, cc, 1) <> Mid(formula, cf, 1) Then
          Exit Function
        Else
          cf = cf + 1
          cc = cc + 1
        End If
    Loop
    ZellAbweichung = False
End Function

Public Function StringAdd(stringlist, txt As String) As Boolean
    StringAdd = False
    Dim item
    For Each item In stringlist
        If item = txt Then Exit Function
    Next item
    StringAdd = True
    stringlist.Add txt
End Function

Function CheckVBAAccessAllowed() As Boolean
  CheckVBAAccessAllowed = True
  On Error GoTo noVBA
  If ThisWorkbook.VBProject.Protection = 1 Then ' vbext_pp_locked
  End If
  Exit Function
noVBA:
  CheckVBAAccessAllowed = False
End Function

Function FormulaAnalyzable(c) As Boolean
  FormulaAnalyzable = True
  On Error GoTo notAnalyzable
  If c.formula = "a" Then
  End If
  Exit Function
notAnalyzable:
  FormulaAnalyzable = False
End Function

Function TranslateFunc(s As String) As String
  On Error GoTo noTrans
  TranslateFunc = Trans(s)
  Exit Function
noTrans:
  TranslateFunc = s
End Function


Sub FreeAllMem()
  Set Trans = Nothing
  Set xlsDateien = Nothing
  Set inaccessablePaths = Nothing
  Set Funcs = Nothing
  Set FuncArray = Nothing
End Sub

Function FilenameDoesntExistAbove(Pfad As String, name As String) As Boolean
  Dim item
  Dim pos As Long
  FilenameDoesntExistAbove = True
  If Len(Pfad) <= 1 Then Exit Function
  pos = Len(Pfad)
  pos = pos - 1
  Do
    pos = InStrMyRev(Pfad, "\", pos)
    If pos < 0 Then Exit Do
    For Each item In xlsDateien
      If Left(Pfad, pos) & name = item Then
        FilenameDoesntExistAbove = False
        Exit Function
      End If
    Next item
    pos = pos - 1
  Loop While pos > 0
End Function

Sub ScanDirs(Pfad As String, nichtaelterals As Long, nichtkleinerals As Long, gleichenamenignorieren As Boolean, unterverzeichnisseIgnorieren As Boolean, infoLabel, Optional firstscan As Boolean = True)

'   .MousePointer = fmMousePointerHourGlass
'  Me.MousePointer = fmMousePointerDefault

  If firstscan Then AmountScanned = 0

  Dim name As String
  Dim Verzeichnisse As New Collection
  ' Erst mal alle Verzeichnisse holen!
  On Error GoTo inaccessablePath
  name = Dir(Pfad & "\*.*", vbDirectory) ' Ersten Eintrag abrufen.
'    On Error GoTo 0
  On Error Resume Next
    Do While name <> ""    ' Schleife beginnen.
        ' Aktuelles und |fffd|bergeordnetes Verzeichnis ignorieren.
        If name <> "." And name <> ".." Then
            ' Mit bit-weisem Vergleich sicherstellen, da|fffd| name ein
            ' Verzeichnis ist.
            Err.Number = 0
            If (GetAttr(Pfad & "\" & name) And vbDirectory) = vbDirectory Then
                If Err.Number = 0 Then Verzeichnisse.Add Pfad & "\" & name  ' Eintrag nur anzeigen, wenn es sich
            Else
                ' Ansonsten ist es eine Datei! Wenn es ein Excel-Sheet ist, dann wird
                ' es in die xlsDateien - Collection mitaufgenommen
                If UCase(Right(name, 4)) = ".XLS" Or UCase(Right(name, 4)) = ".XLT" Or UCase(Right(name, 4)) = ".XLA" Then
                    ' Nicht die eigene Datei!!!!!
                    If ThisWorkbook.FullName <> Pfad & "\" & name Then
                      Dim used As Boolean
                      used = False
                      ' Wenn die Dateikriterien passen
                      If MyFileLen(Pfad & "\" & name) >= nichtkleinerals * 1024 Then
                        Dim fd As Date
                        fd = Format(MyFileDateTime(Pfad & "\" & name), "Short Date")
                        If Format(DateAdd("m", -nichtaelterals, Now()), "Short Date") <= fd Then
                          If gleichenamenignorieren = True Then
                            If FilenameDoesntExistAbove(Pfad, name) Then
                              AmountScanned = AmountScanned + 1
                              If Not unterverzeichnisseIgnorieren Then
                                'infoLabel.Caption = "    " & AmountScanned & " Dateien bisher gefunden..."
                                infoLabel.Caption = "    " & AmountScanned & FMT0("Globals_8")
                                DoEvents
                              End If
                              xlsDateien.Add Pfad & "\" & name
                              used = True
                            Else
                              TotalUnusedBytesDouble = TotalUnusedBytesDouble + MyFileLen(Pfad & "\" & name)
                              TotalUnusedFilesDouble = TotalUnusedFilesDouble + 1
                            End If
                          Else
                            AmountScanned = AmountScanned + 1
                            xlsDateien.Add Pfad & "\" & name
                            If Not unterverzeichnisseIgnorieren Then
                              'infoLabel.Caption = "    " & AmountScanned & " Dateien bisher gefunden..."
                              infoLabel.Caption = "    " & AmountScanned & FMT0("Globals_8")
                              
                              DoEvents
                            End If
                            used = True
                          End If
                        Else
                          TotalUnusedBytesOlder = TotalUnusedBytesOlder + MyFileLen(Pfad & "\" & name)
                          TotalUnusedFilesOlder = TotalUnusedFilesOlder + 1
                        End If
                      Else
                        TotalUnusedBytesSmaller = TotalUnusedBytesSmaller + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFilesSmaller = TotalUnusedFilesSmaller + 1
                      End If
                      If Not used Then
                        TotalUnusedBytes = TotalUnusedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUnusedFiles = TotalUnusedFiles + 1
                      Else
                        TotalUsedBytes = TotalUsedBytes + MyFileLen(Pfad & "\" & name)
                        TotalUsedFiles = TotalUsedFiles + 1
                      End If
                    End If
                End If
            End If
        End If
        name = Dir ' N|fffd|chsten Eintrag abrufen.
    Loop
    
    Dim item
    Dim tString As String
    If Not unterverzeichnisseIgnorieren Then
      For Each item In Verzeichnisse
          tString = item
          ScanDirs tString, nichtaelterals, nichtkleinerals, gleichenamenignorieren, unterverzeichnisseIgnorieren, infoLabel, False
      Next item
    End If
    
    Set Verzeichnisse = Nothing

    Exit Sub
    
inaccessablePath:
    inaccessablePaths.Add Pfad

End Sub



Function RemoveCommentsLineFeedsAndEmptyRows(ByVal txt As String) As String
  Dim I As Long
  Dim nutxt As String
  Dim t As String
  Do
    t = Trim(RemoveCommentsAndLineFeeds(GetLine(txt)))
    If t <> "" Then
      nutxt = nutxt & t
    End If
  Loop While txt <> ""
    
  RemoveCommentsLineFeedsAndEmptyRows = nutxt
End Function

Function RemoveCommentsAndLineFeeds(ByVal txt As String) As String
  Dim I As Long
  Dim nutxt As String
  For I = 1 To Len(txt)
    If Mid(txt, I, 1) = Chr(34) Then
      nutxt = nutxt + Mid(txt, I, 1)
      I = I + 1
      While Mid(txt, I, 1) <> Chr(34)
        nutxt = nutxt + Mid(txt, I, 1)
        I = I + 1
      Wend
      nutxt = nutxt + Mid(txt, I, 1)
    ElseIf Mid(txt, I, 1) = "'" Then
      While Mid(txt, I, 1) <> Chr(10) And Mid(txt, I, 1) <> Chr(13) And I < Len(txt)
        I = I + 1
      Wend
    ElseIf Mid(txt, I, 1) <> vbCr And Mid(txt, I, 1) <> vbLf Then
      nutxt = nutxt + Mid(txt, I, 1)
    End If
  Next I
  RemoveCommentsAndLineFeeds = nutxt
End Function


Function RemoveStringArea(ByVal txt As String, ByVal leftdelimiter As String, ByVal rightdelimiter As String) As String
  Dim I As Long
  Dim nutxt As String
  For I = 1 To Len(txt)
    If Mid(txt, I, 1) = Chr(34) Then
      nutxt = nutxt + Mid(txt, I, 1)
      I = I + 1
      While Mid(txt, I, 1) <> Chr(34)
        nutxt = nutxt + Mid(txt, I, 1)
        I = I + 1
      Wend
      nutxt = nutxt + Mid(txt, I, 1)
    ElseIf Mid(txt, I, 1) = leftdelimiter Then
      I = I + 1
      While Mid(txt, I, 1) <> rightdelimiter
        I = I + 1
      Wend
      I = I + 1
    Else
      nutxt = nutxt + Mid(txt, I, 1)
    End If
  Next I
  RemoveStringArea = nutxt
End Function

Function RemoveRelativeCells(ByVal txt As String) As String
  Dim I As Long
  Dim nutxt As String
  For I = 1 To Len(txt)
    If Mid(txt, I, 1) = Chr(34) Then
      nutxt = nutxt + Mid(txt, I, 1)
      I = I + 1
      While Mid(txt, I, 1) <> Chr(34)
        nutxt = nutxt + Mid(txt, I, 1)
        I = I + 1
      Wend
      nutxt = nutxt + Mid(txt, I, 1)
    ElseIf Mid(txt, I, 1) = "[" Then
      I = I + 1
      While Mid(txt, I, 1) <> "]"
        I = I + 1
      Wend
      I = I + 1
    ElseIf Mid(txt, I, 1) = "R" Or Mid(txt, I, 1) = "C" Then
      If I < Len(txt) - 1 Then
        If Mid(txt, I + 1, 1) >= "0" And Mid(txt, I + 1, 1) <= "9" Then
          I = I + 1
          Do While I < Len(txt)
            If Mid(txt, I, 1) >= "0" And Mid(txt, I, 1) <= "9" Then
              I = I + 1
            Else
              Exit Do
            End If
          Loop
        Else
          nutxt = nutxt + Mid(txt, I, 1)
        End If
      Else
        nutxt = nutxt + Mid(txt, I, 1)
      End If
    Else
      nutxt = nutxt + Mid(txt, I, 1)
    End If
  Next I
  RemoveRelativeCells = nutxt
End Function



Attribute VB_Name = "Hash"
Option Explicit

Private Const BITS_TO_A_BYTE = 8
Private Const BYTES_TO_A_WORD = 4
Private Const BITS_TO_A_WORD = 32

Function GetFileHash(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal uncpathfname As String) As String

    If Mid(uncpathfname, 2, 1) <> ":" Then
        GetFileHash = SHA256(uncpathfname)
'        GetFileHash = SHA256(uncpathfname & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    Else
        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName)
'        GetFileHash = SHA256(uncpathfname & "|" & GetComputerName & "|" & GetDocProp(wb, "Author") & GetDocProp(wb, "Creation date"))
    End If

End Function

Private Function LShift(lValue, iShiftBits)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

Dim m_l2Power
m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)


    If iShiftBits = 0 Then
        LShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And 1 Then
            LShift = &H80000000
        Else
            LShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    If (lValue And m_l2Power(31 - iShiftBits)) Then
        LShift = ((lValue And m_lOnBits(31 - (iShiftBits + 1))) * m_l2Power(iShiftBits)) Or &H80000000
    Else
        LShift = ((lValue And m_lOnBits(31 - iShiftBits)) * m_l2Power(iShiftBits))
    End If
End Function



Private Function RShift(lValue, iShiftBits)

  Dim m_l2Power
  m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)

    If iShiftBits = 0 Then
        RShift = lValue
        Exit Function
    ElseIf iShiftBits = 31 Then
        If lValue And &H80000000 Then
            RShift = 1
        Else
            RShift = 0
        End If
        Exit Function
    ElseIf iShiftBits < 0 Or iShiftBits > 31 Then
        Err.Raise 6
    End If
    
    RShift = (lValue And &H7FFFFFFE) \ m_l2Power(iShiftBits)
    
    If (lValue And &H80000000) Then
        RShift = (RShift Or (&H40000000 \ m_l2Power(iShiftBits - 1)))
    End If
End Function



Private Function AddUnsigned(lX, lY)
    Dim lX4, lY4, lX8, lY8, lResult
 
    lX8 = lX And &H80000000
    lY8 = lY And &H80000000
    lX4 = lX And &H40000000
    lY4 = lY And &H40000000
 
    lResult = (lX And &H3FFFFFFF) + (lY And &H3FFFFFFF)
 
    If lX4 And lY4 Then
        lResult = lResult Xor &H80000000 Xor lX8 Xor lY8
    ElseIf lX4 Or lY4 Then
        If lResult And &H40000000 Then
            lResult = lResult Xor &HC0000000 Xor lX8 Xor lY8
        Else
            lResult = lResult Xor &H40000000 Xor lX8 Xor lY8
        End If
    Else
        lResult = lResult Xor lX8 Xor lY8
    End If
 
    AddUnsigned = lResult
End Function



Private Function Ch(x, y, z)
    Ch = ((x And y) Xor ((Not x) And z))
End Function



Private Function Maj(x, y, z)
    Maj = ((x And y) Xor (x And z) Xor (y And z))
End Function



Private Function s(x, n)
Dim m_lOnBits, m_l2Power, K
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

m_l2Power = Array(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)

    s = (RShift(x, (n And m_lOnBits(4))) Or LShift(x, (32 - (n And m_lOnBits(4)))))
End Function



Private Function r(x, n)
Dim m_lOnBits
m_lOnBits = Array(CLng(1), CLng(3), CLng(7), CLng(15), CLng(31), CLng(63), CLng(127), CLng(255), CLng(511), CLng(1023), CLng(2047), CLng(4095), CLng(8191), CLng(16383), CLng(32767), CLng(65535), CLng(131071), CLng(262143), CLng(524287), CLng(1048575), CLng(2097151), CLng(4194303), CLng(8388607), CLng(16777215), CLng(33554431), CLng(67108863), CLng(134217727), CLng(268435455), CLng(536870911), CLng(1073741823), CLng(2147483647))

    r = RShift(x, CLng(n And m_lOnBits(4)))
End Function



Private Function Sigma0(x)
    Sigma0 = (s(x, 2) Xor s(x, 13) Xor s(x, 22))
End Function



Private Function Sigma1(x)
    Sigma1 = (s(x, 6) Xor s(x, 11) Xor s(x, 25))
End Function



Private Function Gamma0(x)
    Gamma0 = (s(x, 7) Xor s(x, 18) Xor r(x, 3))
End Function



Private Function Gamma1(x)
    Gamma1 = (s(x, 17) Xor s(x, 19) Xor r(x, 10))
End Function



Private Function ConvertToWordArray(sMessage)
    Dim lMessageLength, lNumberOfWords, lWordArray(), lBytePosition, lByteCount
    Dim lWordCount, lByte
    
    Const MODULUS_BITS = 512
    Const CONGRUENT_BITS = 448
    
    lMessageLength = Len(sMessage)
    
    lNumberOfWords = (((lMessageLength + ((MODULUS_BITS - CONGRUENT_BITS) \ BITS_TO_A_BYTE)) \ (MODULUS_BITS \ BITS_TO_A_BYTE)) + 1) * (MODULUS_BITS \ BITS_TO_A_WORD)
    ReDim lWordArray(lNumberOfWords - 1)
    
    lBytePosition = 0
    lByteCount = 0
    Do Until lByteCount >= lMessageLength
        lWordCount = lByteCount \ BYTES_TO_A_WORD
        
        lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE
        
        lByte = AscB(Mid(sMessage, lByteCount + 1, 1))
        
        lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(lByte, lBytePosition)
        lByteCount = lByteCount + 1
    Loop

    lWordCount = lByteCount \ BYTES_TO_A_WORD
    lBytePosition = (3 - (lByteCount Mod BYTES_TO_A_WORD)) * BITS_TO_A_BYTE

    lWordArray(lWordCount) = lWordArray(lWordCount) Or LShift(&H80, lBytePosition)

    lWordArray(lNumberOfWords - 1) = LShift(lMessageLength, 3)
    lWordArray(lNumberOfWords - 2) = RShift(lMessageLength, 29)
    
    ConvertToWordArray = lWordArray
End Function



Public Function SHA256(sMessage)

Dim K
K = Array(&H428A2F98, &H71374491, &HB5C0FBCF, &HE9B5DBA5, &H3956C25B, &H59F111F1, &H923F82A4, &HAB1C5ED5, &HD807AA98, &H12835B01, &H243185BE, &H550C7DC3, &H72BE5D74, &H80DEB1FE, &H9BDC06A7, &HC19BF174, &HE49B69C1, &HEFBE4786, &HFC19DC6, &H240CA1CC, &H2DE92C6F, &H4A7484AA, &H5CB0A9DC, &H76F988DA, &H983E5152, &HA831C66D, &HB00327C8, &HBF597FC7, &HC6E00BF3, &HD5A79147, &H6CA6351, &H14292967, &H27B70A85, &H2E1B2138, &H4D2C6DFC, &H53380D13, &H650A7354, &H766A0ABB, &H81C2C92E, &H92722C85, &HA2BFE8A1, &HA81A664B, &HC24B8B70, &HC76C51A3, &HD192E819, &HD6990624, &HF40E3585, &H106AA070, &H19A4C116, &H1E376C08, &H2748774C, &H34B0BCB5, &H391C0CB3, &H4ED8AA4A, &H5B9CCA4F, &H682E6FF3, &H748F82EE, &H78A5636F, &H84C87814, &H8CC70208, &H90BEFFFA, &HA4506CEB, &HBEF9A3F7, &HC67178F2)
    Dim hash, m, w(63), A, b, c, d, e, f, g, h, I, j, T1, T2
    
    hash = Array(&H6A09E667, &HBB67AE85, &H3C6EF372, &HA54FF53A, &H510E527F, &H9B05688C, &H1F83D9AB, &H5BE0CD19)
    
    m = ConvertToWordArray(sMessage)
    
    For I = 0 To UBound(m) Step 16
        A = hash(0)
        b = hash(1)
        c = hash(2)
        d = hash(3)
        e = hash(4)
        f = hash(5)
        g = hash(6)
        h = hash(7)
        
        For j = 0 To 63
            If j < 16 Then
                w(j) = m(j + I)
            Else
                w(j) = AddUnsigned(AddUnsigned(AddUnsigned(Gamma1(w(j - 2)), w(j - 7)), Gamma0(w(j - 15))), w(j - 16))
            End If
                
            T1 = AddUnsigned(AddUnsigned(AddUnsigned(AddUnsigned(h, Sigma1(e)), Ch(e, f, g)), K(j)), w(j))
            T2 = AddUnsigned(Sigma0(A), Maj(A, b, c))
            
            h = g
            g = f
            f = e
            e = AddUnsigned(d, T1)
            d = c
            c = b
            b = A
            A = AddUnsigned(T1, T2)
        Next
        
        hash(0) = AddUnsigned(A, hash(0))
        hash(1) = AddUnsigned(b, hash(1))
        hash(2) = AddUnsigned(c, hash(2))
        hash(3) = AddUnsigned(d, hash(3))
        hash(4) = AddUnsigned(e, hash(4))
        hash(5) = AddUnsigned(f, hash(5))
        hash(6) = AddUnsigned(g, hash(6))
        hash(7) = AddUnsigned(h, hash(7))
    Next
    
    SHA256 = LCase(Right("00000000" & Hex(hash(0)), 8) & Right("00000000" & Hex(hash(1)), 8) & Right("00000000" & Hex(hash(2)), 8) & Right("00000000" & Hex(hash(3)), 8) & Right("00000000" & Hex(hash(4)), 8) & Right("00000000" & Hex(hash(5)), 8) & Right("00000000" & Hex(hash(6)), 8) & Right("00000000" & Hex(hash(7)), 8))
End Function



Public Function Hash32Bit(ByVal s As String) As Long

    Dim h As Long
    h = 0
    
    Dim I As Long
    For I = 1 To Len(s)
      h = 31 * h + Asc(Mid(s, I, 1))
      h = h And &HFFFFF
    Next I
    Hash32Bit = h
End Function




Attribute VB_Name = "Helpers"
Option Explicit

'In ein Modul mit Namen "myLaufwerke"
Private Const DRIVE_CDROM = 5
Private Const DRIVE_FIXED = 3
Private Const DRIVE_RAMDISK = 6
Private Const DRIVE_REMOTE = 4
Private Const DRIVE_REMOVABLE = 2

' Declare for call to mpr.dll.
Const NoError = 0       'The Function call was successful

Public Const vbTime As Long = 1000


#If VBA7 Then
Declare PtrSafe Function GetLogicalDrives& Lib "kernel32" ()
Private Declare PtrSafe Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare PtrSafe Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare PtrSafe Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Public Declare PtrSafe Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Public Declare PtrSafe Function GetTempFileName Lib "kernel32" Alias "GetTempFileNameA" (ByVal lpszPath As String, ByVal lpPrefixString As String, ByVal wUnique As Long, ByVal lpTempFileName As String) As Long

#Else
Declare Function GetLogicalDrives& Lib "kernel32" ()
Private Declare Function GetDriveType Lib _
    "kernel32" Alias "GetDriveTypeA" _
    (ByVal nDrive As String) As Long

Declare Function WNetGetUser Lib "mpr.dll" _
      Alias "WNetGetUserA" (ByVal lpName As String, _
      ByVal lpUserName As String, lpnLength As Long) As Long


Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long
Public Declare Function FindExecutable Lib "shell32.dll" Alias _
    "FindExecutableA" (ByVal lpFile As String, ByVal lpDirectory As String, ByVal lpResult As String) As Long

Private Declare Function GetShortPathName Lib "Kernel32.dll" _
  Alias "GetShortPathNameA" ( _
  ByVal lpszLongPath As String, _
  ByVal lpszShortPath As String, _
  ByVal cchBuffer As Long) As Long

Public Declare Function apiGetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Public Declare Function GetTempFileName Lib "kernel32" _
         Alias "GetTempFileNameA" (ByVal lpszPath As String, _
         ByVal lpPrefixString As String, ByVal wUnique As Long, _
         ByVal lpTempFileName As String) As Long
#End If

Function GetLine(ByRef txt As String) As String
    Dim pos As Long
    Dim res As String
    pos = InStr(txt, vbCr)
    If pos > 0 Then
        res = Left(txt, pos - 1)
    Else
        res = txt
    End If
    If pos > 0 Then
        txt = Mid(txt, 2 + pos)
    Else
        txt = ""
    End If

    GetLine = res

End Function


'Sub PopupErzeugen()
'Dim a As Long, l As Long, CBName As String
'Dim LW  As String, Prozedur  As String
'Dim VBCount As Long
'Dim meineLeiste As CommandBar
'Dim KonBef As CommandBarButton
'On Error Resume Next
'VBCount = Application.VBE.VBProjects.Count
''Objektvariable myLaufwerk erstellen, notfalls Komponente hinzu
'With Application.VBE.VBProjects(VBCount).VBComponents("myLaufwerke").CodeModule
'    'Commandbar "Laufwerk" l|fffd|schen, wenn vorhanden
'    'ansonsten On Error Resume Next
'    'Application.CommandBars("Laufwerk").Delete
'    Application.CommandBars(FMT0("Helpers_1")).Delete
'    'Commandbar "Laufwerk" hinzuf|fffd|gen
'    Set meineLeiste = Application.CommandBars _
'    '.Add(name:="Laufwerk", Position:=msoBarPopup, Temporary:=True)
'    .Add(name:="Laufwerk", Position:=msoBarPopup, Temporary:=True)
'    'Bitmaske mit Laufwerken holen
'    l = GetLogicalDrives
'    For a = 97 To 123
'        If l And 2 ^ (a - 97) Then
'            'Wenn Bit 0 gesetzt, dann LW a vorhanden
'            'Wenn Bit 1 gesetzt, dann LW b vorhanden
'            'usw.
'            LW = Chr(a)
'            If Not .Find("Sub LW_" & LW & "()", 1, 1, .CountOfLines, .CountOfLines) Then
'                'Prozeduren f|fffd|r die Laufwerke hinzuf|fffd|gen
'                'wenn |fffd|nderungen hier, vorher alle l|fffd|schen
'                Prozedur = "Sub LW_" & LW & " " & vbCrLf
'                Prozedur = Prozedur & "LaufwerktypAnzeigen """ & LW & """" & vbCrLf
'                Prozedur = Prozedur & "End Sub"
'                .AddFromString (Prozedur)
'            End If
'            'Control hinzuf|fffd|gen f|fffd|r jedes Laufwerk
'            Set KonBef = meineLeiste.Controls.Add(msoControlButton)
'            With KonBef
'                'Im Popup angezeigter Text
'                .Caption = "Laufwerk : " & Chr(a)
'                'Im Popup angezeigtes Icon
'                .FaceId = 3
'                'Prozedur, die nach Klick aufgerufen wird
'                .OnAction = "LW_" & Chr(a)
'            End With
'        End If
'    Next
'End With
''Wenn die Prozeduren hinzugef|fffd|gt wurden, gibt
''es beim direkten Aufruf manchmal Probleme
'Application.OnTime Now + TimeSerial(0, 0, 1), "PopupAnzeigen"
'End Sub


'Private Sub LaufwerktypAnzeigen(a As String)
'Dim Meldung As String
'Select Case GetDriveType(a & ":\")
'    Case DRIVE_CDROM
'        Meldung = "CDROM"
'    Case DRIVE_FIXED
'        Meldung = "Festplatte"
'    Case DRIVE_RAMDISK
'        Meldung = "RAMDISK"
'    Case DRIVE_REMOTE
'        Meldung = "Netzlaufwerk"
'    Case DRIVE_REMOVABLE
'        Meldung = "Diskette"
'End Select
'MsgBox "Laufwerk = " & a & vbCrLf & "Typ = " & Meldung
'End Sub
'
'
'Public Sub PopupAnzeigen()
'    Application.CommandBars("Laufwerk").ShowPopup
'End Sub

Function GetWorksheet(ByRef wbname As String, sheetname As String, ByRef Beenden As Boolean) As Worksheet
    Dim objApp As Object
    On Error Resume Next
    Set objApp = GetObject(wbname)
    
    Dim ws As Worksheet
    Set ws = objApp.Sheets(sheetname)
    
    If objApp Is Nothing Or ws Is Nothing Then
      Beenden = True
      Exit Function
    End If
    
    Set GetWorksheet = ws
End Function


Function GetColumnText(c As Long)
  If c > 26 Then
    GetColumnText = Chr((c - 1) \ 26 + 64) & Chr((c - 1) Mod 26 + 65)
  Else
    GetColumnText = Chr(c + 64)
  End If
End Function

'Function GetCellType(c As Range)
'  If c.HasFormula Then
'    GetCellType = "Formel"
'    Exit Function
'  End If
'
'  If IsNumeric(c.value) Then
'    GetCellType = "Zahl"
'    Exit Function
'  End If
'
''  If IsChar(c.Value) Then
''    GetCellType = "Text"
''    Exit Function
''  End If
'
'  If IsDate(c.value) Then
'    GetCellType = "Datum"
'    Exit Function
'  End If
'
'  GetCellType = "Text"
'
'End Function

Sub AddChangedSheet(ws As Object)
  On Error Resume Next
  ChangedWorksheets.Add ws.name, ws.name
  G_ChangedWorkbook = True
End Sub

Function SheetChanged(ws As Object)
  On Error GoTo notExistant
  Dim s As String
  s = ChangedWorksheets(ws.name)
  SheetChanged = True
  Exit Function
notExistant:
  SheetChanged = False
End Function

Function GetRelativePath(ByVal stdpath As String, ByVal cfgpath As String) As String
  Dim s As String
  If cfgpath = "" Then s = stdpath
  
  If cfgpath = "USERTEMP" Then
    cfgpath = GetTempPath
    If Right(cfgpath, 1) = "\" Then
      cfgpath = Left(cfgpath, Len(cfgpath) - 1)
    End If
  End If
  
  If Left(cfgpath, 2) = "\\" Or Left(cfgpath, 2) = "//" Or Mid(cfgpath, 2, 1) = ":" Then
    s = cfgpath
  Else
    s = ThisWorkbook.path & "\" & cfgpath
  End If
  
  If Not PathExists(s) Then
    MkFullDir s
    If Not PathExists(s) Then
      'MsgBox "ACHTUNG: Der Pfad '" & s & "' konnte nicht erzeugt werden. Das Programm wird voraussichtlich nicht korrekt funktionieren. Bitte gew|fffd|hrleisten Sie, dass der Pfad existiert!", vbCritical
      MsgBox FMT1("Helpers_1", s), vbCritical
    End If
  End If
  
  GetRelativePath = s
End Function

Function ConvGermanDateKey(d As String) As String
    Dim sp() As String
    sp = Split(d, ".")
    If UBound(sp) - LBound(sp) + 1 = 3 Then
        ConvGermanDateKey = DateSerial(CInt(sp(2)), CInt(sp(1)), CInt(sp(0)))
    Else
        ConvGermanDateKey = d
    End If
End Function

Function ConvGermanDate(d As String) As Date
    Dim td As Date
    
    On Error GoTo errorEnd
    td = DateSerial(1900, 1, 1)
    
    If IsDate(d) Then
        td = CDate(d)
    Else
      Dim dots As Long
      Dim pos1 As Long
      Dim pos2 As Long
      Dim endPos As Long
      
      dots = 0
      
      pos1 = InStr(d, ".")
      If pos1 > 0 Then
          dots = dots + 1
          
          pos2 = InStr(pos1 + 1, d, ".")
          If pos2 > 0 Then
              dots = dots + 1
              endPos = InStr(pos2 + 1, d, " ")
              If endPos <= 0 Then endPos = Len(d) + 1
          End If
      End If
      
      If dots = 2 Then
          Dim day As String
          Dim month As String
          Dim year As String
          day = Mid(d, 1, pos1 - 1)
          month = Mid(d, pos1 + 1, pos2 - pos1 - 1)
          year = Mid(d, pos2 + 1, endPos - pos2 - 1)
          td = DateSerial(year, month, day) & IIf(CDate(d) <> DateSerial(year, month, day), " " & Hour(d) & ":" & Minute(d) & ":" & Second(d), "")
      End If
    End If
    
    If td < DateSerial(1900, 1, 1) Then
      td = DateSerial(1900, 1, 1) & " " & Hour(d) & ":" & Minute(d) & ":" & Second(d)
    End If
    
errorEnd:
    ConvGermanDate = td
End Function


Sub MyKill(fname As String)
  On Error Resume Next
  Kill fname
End Sub

Public Function AnwendungFuerDatei(ByVal a_Datei As String) As String
  'Datei: Pfad + Dateinamen einer existierenden Datei
  Dim Pfad As String * 255
  
  Call FindExecutable(a_Datei, vbNullString, Pfad)
  
  If "" <> Trim(Pfad) Then
     Pfad = Trim(Left(Pfad, InStr(Pfad, vbNullChar) - 1))
  End If
  AnwendungFuerDatei = Trim(Pfad)
End Function

Sub OpenFileWithApp(fname As String)
  If FileExists(fname) Then
    Dim s2 As String, s3 As String, n As Long
    
    s2 = AnwendungFuerDatei(fname)
    If "" <> s2 Then
       s3 = Chr(34) & ShortFileName(s2) & Chr(34) & " " & Chr(34) & ShortFileName(fname) & Chr(34)
       n = Shell(s3, vbNormalFocus)
    Else
       'MsgBox "Anwendungprogramm f|fffd|r " & fname & " nicht gefunden/installiert!"
       MsgBox FMT1("Helpers_2", fname)
    End If
  Else
    'MsgBox "Datei '" & fname & "' nicht vorhanden.", vbCritical
    MsgBox FMT1("Helpers_3", fname), vbCritical
  End If
End Sub

' Return the short file name for a long file name.
Public Function ShortFileName(ByVal long_name As String) As String
    If UCase(Left(long_name, 5)) = "HTTP:" Or UCase(Left(long_name, 6)) = "HTTPS:" Then
      ShortFileName = long_name
      Exit Function
    End If
    
    'Returns the short filename associated w
    '     ith sLongFilename
    Dim lRet As Long
    Dim sShortFilename As String
    'First attempt using 1024 character buff
    '     er.
    sShortFilename = String$(1024, " ")
    lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    
    'If buffer is too small lRet contains bu
    '     ffer size needed.


    If lRet > Len(sShortFilename) Then
        'Increase buffer size...
        sShortFilename = String$(lRet + 1, " ")
        'and try again.
        lRet = GetShortPathName(long_name, sShortFilename, Len(sShortFilename))
    End If
    
    'lRet contains the number of characters
    '     returned.


    If lRet > 0 Then
        ShortFileName = Left$(sShortFilename, lRet)
    End If
    
    If Trim(ShortFileName) = "" Then
      ShortFileName = long_name
    End If
    
End Function

Sub DeleteCollectionItem(ByRef c As Collection, s As String)
  On Error Resume Next
  c.Remove s
End Sub
 
Function CollectionStringExists(ByRef c As Collection, s As String)
  On Error GoTo nogo
  
  Dim t
  t = c(s)
  CollectionStringExists = True
nogo:

End Function
 
Function CollectionObjectExists(ByRef c As Collection, s As String)
  On Error GoTo nogo
  
  Dim t
  Set t = c(s)
  Set t = Nothing
  CollectionObjectExists = True
nogo:
End Function

Function MyFileLen(ByVal fname As String) As Long
  On Error GoTo nogo:
  MyFileLen = 0
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileLen = sz
    End If
  Else
    MyFileLen = FileLen(fname)
  End If
  Exit Function
nogo:
End Function

Function MyFileDateTime(ByVal fname As String) As Date
  MyFileDateTime = 0
  On Error GoTo nogo
  If UCase(Left(fname, 5)) = "HTTP:" Or UCase(Left(fname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    If URLExists(fname, sz, modDate) Then
      MyFileDateTime = modDate
    End If
  Else
    MyFileDateTime = FileDateTime(fname)
  End If
  Exit Function
nogo:
  If Len(fname) > 260 Then
     MyFileDateTime = MyFileDateTimeLongName(fname)
  Else
    DebugPrint tdebug, "MyFileDateTime failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
  End If
End Function

Function MyFileDateTimeLongName(fname As String) As Date
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Dim f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(fname)
    
    MyFileDateTimeLongName = f.DateLastModified
    Exit Function
nogo:
    DebugPrint tdebug, "MyFileDateTimeLongName failed for: '" & fname & "' - " & Err.Number & " - " & Err.Description
    MyFileDateTimeLongName = 0
End Function
Sub fileSplit(ByVal s$, ByRef path$, ByRef File$, ByRef ext$)
    ' die Prozedur zerlegt den Dateinamen S in Path, Name, Extension
    Dim I%
    For I = Len(s) To 1 Step -1
        If Mid(s, I, 1) = "\" Or Mid(s, I, 1) = "/" Then   ' keine Extension vorhanden
            ext = ""
            Exit For
        End If
        If Mid(s, I, 1) = "." Then
            ext = Right(s, Len(s) - I)
            s = Left(s, I - 1)
            Exit For
        End If
    Next I
    I = Len(s)
    If InStr(s, "\") <> 0 Then
        While Mid(s, I, 1) <> "\"
            I = I - 1
        Wend
    ElseIf InStr(s, "/") <> 0 Then
        While Mid(s, I, 1) <> "/"
            I = I - 1
        Wend
    End If
    path = Left(s, I)
    File = Right(s, Len(s) - I)

End Sub

Function GetNextText(s As String, ByRef pos As Long) As String
  If Len(s) > 0 And pos > 0 Then
    Dim lastpos As Long
    lastpos = pos
      
    pos = InStr(pos, s, ",")
    If pos > 0 Then
      
      GetNextText = Trim(Mid(s, lastpos, pos - lastpos))
      pos = pos + 1
      Exit Function
    ElseIf lastpos < Len(s) Then
      GetNextText = Trim(Mid(s, lastpos))
      pos = -1
      Exit Function
    Else
      pos = -1
      GetNextText = ""
      Exit Function
    End If
  Else
    pos = -1
    GetNextText = ""
    Exit Function
  End If

End Function

Function GetFullPath(ByVal Filename As String) As String
  Dim s As String
  If Left(Filename, 2) = "\\" Or Left(Filename, 2) = "//" Or Mid(Filename, 2, 1) = ":" Or InStr(Filename, "://") > 0 Then
    s = Filename
  Else
    s = G_cfgBinpfad & "\" & Filename
  End If
  
  GetFullPath = s
End Function

Function Mk_Dir(ByVal bez1$) As Boolean
    'Die Funktion erzeugt einen kompletten Unterverzeichnisbaum : z.B.  c:\test\backup\access\nr1
    On Error Resume Next
    Dim verz$, Bez$
    Mk_Dir = True

    If Len(bez1) < 3 And Mid(bez1, 2, 1) = ":" Then Exit Function

    Bez = bez1
    verz = Left(Bez, 3)
    Bez = Right(Bez, Len(Bez) - 3)
    If Right(Bez, 1) <> "\" Then Bez = Bez & "\"
    verz = verz & Mid(Bez, 1, InStr(Bez, "\") - 1)
    Bez = Right(Bez, Len(Bez) - InStr(Bez, "\"))
    While Right(verz, 1) <> "\"
        Err.Number = 0
        MkDir verz
        '    If Err.Number <> 0 Then
        '        MsgBox "Das Verzeichnis '" & verz & "' konnte nicht angelegt werden! (" & Err.Description & ") Setup wird abgebrochen!", vbCritical
        '        Mk_Dir = False
        '        Exit Function
        '    End If
        If Bez <> "" Then
            verz = verz & "\" + Mid(Bez, 1, InStr(Bez, "\") - 1)
        Else
            verz = verz & "\"
        End If
        Bez = Right(Bez, Len(Bez) - InStr(Bez, "\"))
    Wend

    Err.Number = 0
    
'    FileDateTime bez1
    
    If Err.Number <> 0 Then
        '      MsgBox "Das Verzeichnis '" & bez1 & "' konnte nicht angelegt werden! (" & Err.Description & ") Setup wird abgebrochen!", vbCritical
        Mk_Dir = False
    End If

End Function

Sub AddLog(txt As String, Optional dt As DebType = tinfo)
  DebugPrint dt, txt
End Sub

Function GetPath(ByVal p As String) As String
  If InStrRev(p, "\") > 0 Then
    GetPath = Left(p, InStrRev(p, "\") - 1)
    Exit Function
  End If
  GetPath = p
End Function


Function GetFileNameAndExtension(ByVal fn As String) As String
    Dim File As String
    Dim path As String
    Dim ext As String

    fileSplit fn, path, File, ext
    GetFileNameAndExtension = File & "." & ext
End Function

Function WBGetValueLong(ByRef wbInExcelCurrentProjectInAccess As Object, ByVal vname As String) As Long

    WBGetValueLong = -100
    
#If PROJECT_ACCESSTRACKER <> 0 Then
    Dim l
    Dim foundProp As Boolean
    l = GetStartUpProperty(wbInExcelCurrentProjectInAccess, vname, foundProp)
    If foundProp Then
      WBGetValueLong = CLng(l)
    End If
#Else
    Dim nameItem As Excel.name

    For Each nameItem In wbInExcelCurrentProjectInAccess.names
        If nameItem.visible = False Then
            If nameItem.name = vname Then
                WBGetValueLong = Val(Mid(nameItem.RefersTo, 2))
                Exit Function
            End If
        End If
    Next nameItem
#End If
End Function

Function GetFileExtension(ByVal fn As String)
    Dim File As String
    Dim path As String
    Dim ext As String
    
    fileSplit fn, path, File, ext
    GetFileExtension = ext
End Function

Function GetTempPath() As String
  Dim RetVal As Long
  Dim pathbuffer As String * 512
  
  Dim l As Long
  l = apiGetTempPath(512, pathbuffer)
  If l > 0 Then
    GetTempPath = Trim(Left(pathbuffer, l))
  End If
End Function

Function GetExcelVersion() As Long
  GetExcelVersion = 0
  On Error Resume Next
  ' >= 12 = Excel 2007
  GetExcelVersion = CLng(Val(Application.Version))
End Function

Function GetRangeCount(ByRef rng) As Double
  On Error Resume Next
  
  GetRangeCount = CDbl(rng.Count)
  If Err.Number <> 0 Then
    Err.Clear
    GetRangeCount = CDbl(rng.CountLarge)
  End If
  
End Function

Function MyMsgBox(ByVal automatedAnswerValue As VbMsgBoxResult, ByVal prompt As String, Optional ByVal buttons As VbMsgBoxStyle = vbOKOnly, _
  Optional ByVal title As String) As VbMsgBoxResult

  If G_UnattendedMode Then
    MyMsgBox = automatedAnswerValue
    Exit Function
  End If
  
  MyMsgBox = MsgBox(prompt, buttons, IIf(title <> "", title & " ", "") & progNameShort & " V" & MyVersionNumber)

End Function
Sub LogPrint(ByVal str As String)
  DebugPrint tinfo, str
End Sub

Public Function GetNextValue(ByVal sbsValue As String, ByRef startIndex As Long, Optional delim As String = ";") As String

    Dim l As Long
    l = Len(sbsValue)
    Dim startAnfuehrungsstriche As Long
    Dim anfuehrungsstriche As Long
    Dim laenge As Long
    
    Dim nextValue As String
    nextValue = ""
    
    If startIndex <= l Then
        laenge = 0
        If Mid(sbsValue, startIndex, 1) = Chr$(34) Then
            startAnfuehrungsstriche = 1
            anfuehrungsstriche = 1
            startIndex = startIndex + 1
        End If
        
        While startIndex + laenge <= l
            Dim c As String
            c = Mid(sbsValue, startIndex + laenge, 1)
            If c = Chr$(34) Then
                ' 3 Anf|fffd|hrungszeichen sind dann
                If Mid(sbsValue, startIndex + laenge, 2) = Chr$(34) & Chr$(34) Then
                    laenge = laenge + 2
                Else
                    anfuehrungsstriche = 1 - anfuehrungsstriche
                    laenge = laenge + 1
                End If
            ElseIf c = delim Then
                If anfuehrungsstriche = 0 Then
                    GoTo raus
                Else
                    laenge = laenge + 1
                End If
            Else
                laenge = laenge + 1
            End If
        Wend
raus:
        nextValue = Mid(sbsValue, startIndex, laenge - startAnfuehrungsstriche)
        ' nextValue = Replace(nextValue, Chr$(34) & Chr$(34), "'") ' Chr$(34))
        startIndex = startIndex + laenge + 1
    End If
    GetNextValue = nextValue

End Function
 
Public Function IsTestUser() As Boolean
  Dim curUser As String
  curUser = GetUserName
    If curUser = "dirk" Or _
        curUser = "dwinter" Or _
        curUser = "norman" Or _
        curUser = "nneubert" Or _
        curUser = "rolf" Or _
        curUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function


Function GetTime(d As Date) As Date
  On Error Resume Next
  GetTime = CDate("00:00:00")
  GetTime = TimeValue(d)
End Function

Function IsFormLoaded(ByVal fname As String) As Boolean
'Pr|fffd|fen, ob Formular geladen

  Dim I As Integer

  IsFormLoaded = False
  For I = 0 To UserForms.Count - 1
    If LCase$(UserForms(I).name) = LCase$(fname) Then
      IsFormLoaded = True
      Exit For
    End If
  Next I
  
End Function

Sub CopyTextToClipboard(txt As String)
    'VBA Macro using late binding to copy text to clipboard.
    'By Justin Kay, 8/15/2014
    'Thanks to http://akihitoyamashiro.com/en/VBA/LateBindingDataObject.htm
    On Error Resume Next
    Dim MSForms_DataObject As Object
    Set MSForms_DataObject = CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
    MSForms_DataObject.SetText txt
    MSForms_DataObject.PutInClipboard
    Set MSForms_DataObject = Nothing
End Sub

Public Function CreateTempFile(ByVal sPrefix As String) As String
   Dim sTmpPath As String * 512
   Dim sTmpName As String * 576
   Dim nRet As Long

   nRet = apiGetTempPath(512, sTmpPath)
   If (nRet > 0 And nRet < 512) Then
      nRet = GetTempFileName(sTmpPath, sPrefix, 0, sTmpName)
      If nRet <> 0 Then
         CreateTempFile = Left$(sTmpName, _
            InStr(sTmpName, vbNullChar) - 1)
         MyKill CreateTempFile
      End If
   End If
End Function

Public Function CreateTempFileWithExt(ByVal sPrefix As String, ByVal ext As String) As String
  Dim s As String
  s = CreateTempFile(sPrefix)
  s = s & "." & ext
  MyKill s
  CreateTempFileWithExt = s
End Function


Attribute VB_Name = "HighResTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare PtrSafe Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare PtrSafe Function timeGetTime Lib "winmm.dll" () As Long

#Else

Private Declare Function QueryPerformanceCounter Lib "kernel32" _
                                 (x As Currency) As Boolean
Private Declare Function QueryPerformanceFrequency Lib "kernel32" _
                                 (x As Currency) As Boolean
      
Private Declare Function timeGetTime Lib "winmm.dll" () As Long

#End If



Enum TimeState
    started
    Stopped
End Enum


Private startTime, endTime As Long
Private dur As Double
Private state As Currency
Private m_TimeCol As Collection
Private m_TimeName As Collection
Private m_TotalTimeCol As Collection

Private m_LastCount As String

Private Sub Class_Initialize()
Static started As Boolean
    If started Then
      Dim msg As String
      msg = "HighResTimer already started!"
'      MsgBox msg
      Exit Sub
    End If
    started = True
    state = TimeState.Stopped
    DoStart

    StartCounting "TotalCount"

End Sub

Private Sub Class_Terminate()
    DoStop
    Set m_TimeCol = Nothing
    Set m_TotalTimeCol = Nothing
    Set m_TimeName = Nothing
    
End Sub

Public Sub StartCounting(s As String)
  
  If m_LastCount <> "" Then
    Dim d As Double
    d = m_TotalTimeCol(m_LastCount) + CDbl(timeGetTime() - m_TimeCol(m_LastCount))
    m_TotalTimeCol.Remove m_LastCount
    m_TotalTimeCol.Add d, m_LastCount
  End If
  
  
  If CollectionStringExists(m_TimeCol, s) Then
    m_TimeCol.Remove s
  End If
  m_TimeCol.Add timeGetTime(), s
  If Not CollectionStringExists(m_TotalTimeCol, s) Then
    m_TotalTimeCol.Add 0#, s
  End If
  If Not CollectionStringExists(m_TimeName, s) Then
    m_TimeName.Add s, s
  End If
End Sub
Public Sub StopCounting(s As String)
  If Not CollectionStringExists(m_TimeCol, s) Then
    Dim msg As String
    msg = "No count for: " & s
'    MsgBox msg
    Exit Sub
  End If

  Dim d As Double
  d = m_TotalTimeCol(s) + CDbl(timeGetTime() - m_TimeCol(s))
  m_TotalTimeCol.Remove s
  m_TotalTimeCol.Add d, s
  
  
  m_LastCount = s & " - After"
  
  If CollectionStringExists(m_TimeCol, m_LastCount) Then
    m_TimeCol.Remove m_LastCount
  End If
  m_TimeCol.Add timeGetTime(), m_LastCount
  If Not CollectionStringExists(m_TotalTimeCol, m_LastCount) Then
    m_TotalTimeCol.Add 0#, m_LastCount
  End If
  If Not CollectionStringExists(m_TimeName, m_LastCount) Then
    m_TimeName.Add m_LastCount, m_LastCount
  End If
  
  

End Sub

Function GetCount(s As String) As Double
  If Not CollectionStringExists(m_TotalTimeCol, s) Then
    Dim msg As String
    msg = "No count for: " & s
'    MsgBox msg
    Exit Function
  End If
  
  GetCount = m_TotalTimeCol(s) / 1000
End Function


Private Sub DoStart()
    If state = TimeState.started Then
        Dim msg As String
        msg = "Cant' start, already started"
'        MsgBox msg, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion
        Exit Sub
    End If
    state = TimeState.started
    startTime = timeGetTime()
    Set m_TimeCol = New Collection
    Set m_TotalTimeCol = New Collection
    Set m_TimeName = New Collection
End Sub

Private Function DoStop() As Double
    endTime = timeGetTime()
    If state = TimeState.Stopped Then
        Dim msg As String
        msg = "Cant' stop, already stopped"
'        MsgBox msg, vbCritical + vbSystemModal, ProgNameLong & " " & myVersion
        Exit Function
    End If
    state = TimeState.Stopped
    dur = CDbl((endTime - startTime) / 1000)
    DoStop = dur
End Function


Public Sub Dump()
  Dim s As String
  Dim I As Long
  Dim ts As String
  
  StopCounting "TotalCount"
  ts = ""
  
  Dim tot As Double
  tot = GetCount("TotalCount")
  
  Dim checked As Double
  checked = 0
  
  If m_TimeName.Count > 0 Then
    For I = 1 To m_TimeName.Count
      s = m_TimeName(I)
      ts = ts & s & ":" & IIf(Len(s) < 8, vbTab, "") & IIf(Len(s) < 16, vbTab, "") & IIf(Len(s) < 22, vbTab, "") & IIf(Len(s) < 30, vbTab, "") & vbTab & Format(GetCount(s), "000.00") & " Sec" & vbTab & Format(GetCount(s) / tot, "00.0%") & vbCrLf
      Debug.Print s & ": " & GetCount(s) & " Sec - " & Format(GetCount(s) / tot, "0.0%")
      checked = checked + GetCount(s)
    Next I
  End If
  
  ts = ts & vbCrLf & "Checked: " & Format((checked - tot) / tot, "0.0%")
 
  MyKill ThisWorkbook.path & "\ECC-Profile.txt"
  AddTextToFile ts, ThisWorkbook.path & "\ECC-Profile.txt"
  
End Sub
Function GetCurrentCount(s As String) As Double
  If Not CollectionStringExists(m_TotalTimeCol, s) Then
    Dim msg As String
    msg = "No count for: " & s
'    MsgBox msg
    Exit Function
  End If
  GetCurrentCount = (m_TotalTimeCol(s) + CDbl(timeGetTime() - m_TimeCol(s))) / 1000
End Function


Attribute VB_Name = "INetStuff"
Option Explicit

#If VBA7 Then
  Declare PtrSafe Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
  (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, _
  ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#Else
  Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" _
  (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, _
  ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#End If

Public Function URLEncode(StringVal As String) As String

  ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=
  Dim I As Long
  Dim r As String
  For I = 1 To Len(StringVal)
    If InStr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=", Mid(StringVal, I, 1)) > 0 Then
      r = r & Mid(StringVal, I, 1)
    Else
      r = r & "%" & Hex(Asc(Mid(StringVal, I, 1)))
    End If
  Next I
  
  URLEncode = r

End Function
Public Function DownloadFile(fname As String, destFName As String, Optional fsize As Long = 0) As Boolean
'    DownloadFile = IIf(URLDownloadToFile(0, fname, destFName, 0, 0) = 0, True, False)
  On Error GoTo nogo
  DownloadFile = False
  
  Dim WinHttpReq As Object
  Set WinHttpReq = CreateObject("Microsoft.XMLHTTP")
  WinHttpReq.Open "GET", URLEncode(fname), False ' , "username", "password"
  WinHttpReq.Send
  
  ' myURL = WinHttpReq.responseBody
  Dim oStream
  If WinHttpReq.status = 200 Then
      Set oStream = CreateObject("ADODB.Stream")
      oStream.Open
      oStream.Type = 1
      oStream.Write WinHttpReq.responseBody
      oStream.SaveToFile destFName, 2 ' 1 = no overwrite, 2 = overwrite
      oStream.Close
  End If
  DownloadFile = True
  
  Exit Function
nogo:
  
End Function










Attribute VB_Name = "LZW"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

'Private Data Members
Private flgFirstTime As Boolean
Private arr() As String
Private m_CharacterBytesCount As Integer


'Properties
Public Property Get CharacterBytesCount() As Integer
    CharacterBytesCount = m_CharacterBytesCount
End Property

Public Property Let CharacterBytesCount(ByVal vNewValue As Integer)
    m_CharacterBytesCount = vNewValue
End Property

'Private Methods
Private Function Add(ByVal Entry As String) As Long

   If flgFirstTime Then
        flgFirstTime = False
    Else
        ReDim Preserve arr(UBound(arr) + 1)
    End If
    
    arr(UBound(arr)) = Entry
    'Arr(UBound(Arr)).Code = ubund(
    
    Add = UBound(arr)
    
End Function

Private Function IsExists(ByVal Entry As String) As Boolean
    Dim I As Long
    Dim flg As Boolean
    flg = False
    
    For I = LBound(arr) To UBound(arr)
        If arr(I) = Entry Then
            flg = True
            Exit For
        End If
    Next I
    
    IsExists = flg
    
End Function

Private Function IsIndexExists(ByVal index As Long) As Boolean
    
    Dim flg As Boolean
    flg = False
    
    If index <= UBound(arr) Then
        flg = True
    Else
        flg = False
    End If
    
    IsIndexExists = flg
    
End Function

Private Function GetValue(ByVal index As Long) As String
    If IsIndexExists(index) Then
        GetValue = arr(index)
    Else
        GetValue = ""
    End If
End Function

Private Function GetIndexOf(ByVal Entry As String) As Long
    
    Dim I As Long
    Dim ReturnCode As Long
    ReturnCode = -1
    
    For I = LBound(arr) To UBound(arr)
        If arr(I) = Entry Then
            ReturnCode = I
            Exit For
        End If
    Next I
    
    GetIndexOf = ReturnCode
    
End Function

Private Sub Class_Initialize()
    ReDim arr(0) As String
    flgFirstTime = True
    m_CharacterBytesCount = 2
End Sub

Private Function mrtLeft(ByVal InputString As String, ByVal length As Long) As String
    If Len(InputString) >= length Then
        mrtLeft = Left(InputString, length)
    Else
        mrtLeft = InputString
    End If
End Function

Private Sub InitializeDictionary()
    Dim I As Long
    For I = 0 To (2 ^ (m_CharacterBytesCount * 8)) - 1
        Add (ChrW(I))
    Next
End Sub

Private Function length() As Long
    length = UBound(arr)
End Function

'Public methods
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function Compress(ByVal UncompressedData As String, ByRef valam As Long, ByRef arr() As Long) As String

    Dim w As String
    Dim c As String
    Dim wc As String
    'Dim dic As New Dictionary
    Dim Output As String
    Dim Code As Long
    
    Dim I As Long
    InitializeDictionary
    valam = 0
    
    ReDim arr(1024)
    Dim curarrsize As Long
    curarrsize = 1024
     
    w = ""
    For I = 1 To Len(UncompressedData)
        
        c = Mid(UncompressedData, I, 1)
        wc = w + c
        If IsExists(wc) Then
            w = wc
        Else
            Code = Add(wc)
            Code = GetIndexOf(w)
            Output = Output & IIf(Output = "", "", ",") & Code
            arr(valam) = Code
            valam = valam + 1
            If valam > curarrsize Then
              curarrsize = curarrsize + 1024
              ReDim Preserve arr(curarrsize)
            End If
            w = c
        End If
        
        '?
    
    Next I
    
    Output = Output & IIf(Output = "", "", ",") & GetIndexOf(w)
    arr(valam) = GetIndexOf(w)
    valam = valam + 1
    
    Compress = Output

End Function


Public Function DecompressArray(valam As Long, arr() As Long) As String
  Dim compresseddata As String
  Dim I As Long
  For I = 0 To valam - 1
    compresseddata = compresseddata & IIf(compresseddata = "", "", ",") & arr(I)
  Next I
  DecompressArray = Decompress(compresseddata)
End Function

Public Function Decompress(ByVal compresseddata As String) As String
    
    If compresseddata = "" Then Exit Function
    
    'Dim dic As New Dictionary
    
    InitializeDictionary

    Dim Output As String
    Dim Entry As String

    Dim K As String
    Dim w As String
    Dim I As Long
    
    Dim arrCompressedData() As String
    ListSplit arrCompressedData, compresseddata, "," '  arrCompressedData = Split(compresseddata, ",")
    
    K = arrCompressedData(0)
    Output = Output & GetValue(K)
    w = K
    
    For I = 1 To UBound(arrCompressedData)
    
        K = arrCompressedData(I)
        
        If IsIndexExists(K) Then
        
            Entry = GetValue(K)
            
        ElseIf IsIndexExists(K) = False And K = length + 1 Then
            
            Entry = GetValue(w) + mrtLeft(GetValue(w), 1)
            
        Else
        
            'MsgBox "Bad compressed."
            Dim errMsg As String
            errMsg = "Bad compressed."
            MsgBox errMsg
            
        End If
        
        Output = Output + Entry
        
        Add (GetValue(w) + mrtLeft(Entry, 1))
        
        w = GetIndexOf(Entry)
        
    Next
    
    Decompress = Output
    
End Function


 Function ListSplit(ArrayReturn() As String, ByVal StringToSplit As String, _
 SplitAt As String) As Integer
   Dim intInstr As Integer
   Dim intCount As Integer
   Dim strTemp As String

   intCount = -1
   intInstr = InStr(StringToSplit, SplitAt)
   Do While intInstr > 0
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = Left(StringToSplit, intInstr - 1)
     StringToSplit = Mid(StringToSplit, intInstr + 1)
     intInstr = InStr(StringToSplit, SplitAt)
   Loop
   If Len(StringToSplit) > 0 Then
     intCount = intCount + 1
     ReDim Preserve ArrayReturn(0 To intCount)
     ArrayReturn(intCount) = StringToSplit
   End If
   ListSplit = intCount
 End Function






Attribute VB_Name = "Libs"
Option Explicit

'Function InitSWLib(enginename As String) As Boolean
'  InitSWLib = False
'
'  On Error GoTo couldntInit
'  Dim item
'  For Each item In ActiveWorkbook.VBProject.References
'    If item.name = enginename Then
'      ExitSWLib enginename
'      Exit For
'    End If
'  Next item
'
''  On Error GoTo couldntInit
'  If FileExists(ThisWorkbook.path & "\" & enginename & ".xla") Then
'    ThisWorkbook.VBProject.References.AddFromFile ThisWorkbook.path & "\" & enginename & ".xla"
''    Application.VBE.ActiveVBProject.References.AddFromFile ThisWorkbook.Path & "\" & enginename & ".xla"
'    InitSWLib = True
'  ElseIf FileExists("d:\development\excel97\" & enginename & "\" & enginename & ".xls") Then
'    ThisWorkbook.VBProject.References.AddFromFile "d:\development\excel97\" & enginename & "\" & enginename & ".xls"
''    Application.VBE.ActiveVBProject.References.AddFromFile "d:\development\excel97\" & enginename & "\" & enginename & ".xls"
'    InitSWLib = True
'  ElseIf FileExists("i:\documents\migo synchronized computers\krassmasta(1)\my computer\d\development\excel97\" & enginename & "\" & enginename & ".xls") Then
'    ThisWorkbook.VBProject.References.AddFromFile "i:\documents\migo synchronized computers\krassmasta(1)\my computer\d\development\excel97\" & enginename & "\" & enginename & ".xls"
''    Application.VBE.ActiveVBProject.References.AddFromFile "d:\development\excel97\" & enginename & "\" & enginename & ".xls"
'    InitSWLib = True
'  End If
'  Exit Function
'couldntInit:
'  MsgBox "Die Funktion 'InitSWLib(" & enginename & ")' konnte nicht ausgef|fffd|hrt werden. Bitte schalten Sie unter 'Extras/Makros/Sicherheit' im Reiter 'Vertrauensw|fffd|rdige Herausgeber' die Option 'Zugriff auf Visual-Basic vertrauen' an.", vbCritical
'End Function

Sub ExitSWLib(enginename As String)
  On Error Resume Next
  ThisWorkbook.VBProject.References.Remove ThisWorkbook.VBProject.References(enginename)
  Exit Sub
End Sub

Function FileExists(ByVal Dateiname$) As Boolean
    'Die Funktion pr|fffd|ft, ob eine Datei vorhanden ist
On Error GoTo fehler:
  Dim res As Boolean
  If UCase(Left(Dateiname, 5)) = "HTTP:" Or UCase(Left(Dateiname, 6)) = "HTTPS:" Then
    Dim sz As Long
    Dim modDate As Date
    FileExists = URLExists(Dateiname, sz, modDate)
  Else
    res = Dir$(Dateiname) <> ""
    If res = False Then
      res = Dir$(GetDriveAndPathFromUNC(Dateiname)) <> ""
    End If
    FileExists = res
  End If
    Exit Function
fehler:
    FileExists = False
    If Len(Dateiname) > 260 Then
        FileExists = MyFileExistsLongName(Dateiname)
    End If
End Function

Function MyFileExistsLongName(ByVal fname As String) As Boolean
On Error GoTo nogo
    If Len(fname) > 260 Then
        fname = "\\?\UNC\" & Mid$(fname, 3)
    End If
    
    Dim fs
    Set fs = CreateObject("Scripting.FileSystemObject")
    MyFileExistsLongName = fs.FileExists(fname)
    Exit Function
nogo:
    MyFileExistsLongName = False
End Function

Function URLExists(url As String, ByRef sz As Long, ByRef modDate As Date) As Boolean
    Dim Request As Object
    Dim ff As Integer
    Dim rc As Variant
    On Error GoTo EndNow
    sz = 0
    modDate = 0
    URLExists = False
    Set Request = CreateObject("MSXML2.XMLHTTP")
    With Request
      .Open "HEAD", url, False
      Request.SetRequestHeader "Cache-Control", "no-store, no-cache"
      Request.SetRequestHeader "Pragma", "no-cache"
      .Send
      If .readyState = 4 Then
        URLExists = True
        sz = .getResponseHeader("Content-Length")
        Dim s As String
        s = Mid(Request.getResponseHeader("Last-Modified"), 6, 1000)
        s = Left(s, Len(s) - 4)
        modDate = CDate(s)
      Else
        .abort
      End If
    End With
    Set Request = Nothing
    Exit Function
EndNow:
    Debug.Print Err.Description
    Set Request = Nothing
End Function

Attribute VB_Name = "MLastCells"
Option Explicit

Private LastCells As Collection
Public Sub InitLastCells()
  Set LastCells = New Collection
End Sub
Public Sub ExitLastCells()
  Set LastCells = Nothing
End Sub

Function GetLastCell(ByRef ws, wsParentFullName As String) As Range

  Dim c As Range
  
  If ObjectNameExists(LastCells, wsParentFullName & "|" & ws.name) Then
    Set GetLastCell = LastCells(wsParentFullName & "|" & ws.name)
    Exit Function
  End If
  
  On Error Resume Next
  Set c = Nothing
  
  Set c = ws.Cells(ws.Cells.Find(What:="*", _
    SearchOrder:=xlByRows, _
    SearchDirection:=xlPrevious).Row, _
    ws.Cells.Find(What:="*", _
    SearchOrder:=xlByColumns, _
    SearchDirection:=xlPrevious).Column)

  If Not c Is Nothing Then LastCells.Add c, wsParentFullName & "|" & ws.name
  
  Set GetLastCell = c

  Exit Function
  
  
  Set c = ws.UsedRange
  
'  Debug.Print c.Parent.Parent.Path & "|" & c.Parent.name & "|" & c.Address
  If ObjectNameExists(LastCells, c.Parent.Parent.path & "|" & c.Parent.name & "|" & c.Address) Then
    Set GetLastCell = LastCells(c.Parent.Parent.path & "|" & c.Parent.name & "|" & c.Address)
    Exit Function
  End If
  
  ' Jetzt erst durch jede Zeile durch, um zu schauen, ob da was ist.
  Dim y As Long
  Dim x As Long
  Dim r As Range
  Set r = Nothing
  Set r = ws.Cells.SpecialCells(xlCellTypeLastCell)
  
  
  Dim found As Boolean
  
  If r.Row > c.Row Then
    For y = r.Row To c.Row + 1 Step -1
      found = False
      For x = r.Column To c.Column Step -1
        If Not IsEmpty(c.Parent.Cells(y, x)) Then
          found = True
          Exit For
        End If
      Next x
      If found Then Exit For
      Set r = c.Parent.Cells(y - 1, r.Column)
    Next y
  End If
  
  
  If r.Column > c.Column Then
    For x = r.Column To c.Column + 1 Step -1
      found = False
      For y = r.Row To c.Row Step -1
        If Not IsEmpty(c.Parent.Cells(y, x)) Then
          found = True
          Exit For
        End If
      Next y
      If found Then Exit For
      Set r = c.Parent.Cells(r.Row, x - 1)
    Next x
  End If
  
  
'  Debug.Print "Lastcell: y: " & r.Row & " x: " & r.Column
  
  Set GetLastCell = r
  LastCells.Add r, c.Parent.Parent.path & "|" & c.Parent.name & "|" & c.Address
  
End Function
Attribute VB_Name = "MainMenu"
Attribute VB_Base = "0{9D5650CB-2909-4195-98B1-81E8E145E1BD}{C343427E-9624-4357-A701-92BD9728EB18}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub Datei1_Change()
  If Datei1 = "" Then Exit Sub
  If FileExists(Datei1) Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="Datei1", _
       setting:=Datei1
    AddFileToComboboxList 1, Datei1, Datei1
  End If
End Sub

Private Sub Datei2_Change()
  If Datei2 = "" Then Exit Sub
  If FileExists(Datei2) Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="Datei2", _
       setting:=Datei2
    AddFileToComboboxList 2, Datei2, Datei2
  End If
End Sub

Private Sub ShowVBADifferences_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="ShowVBADifferences", _
     setting:=IIf(ShowVBADifferences.value = True, 1, 0)
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub

Private Sub Abbrechen_Click()
    Beenden = True
End Sub


Private Sub AdjacentColsAndRows_Change()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="AdjacentColsAndRows", _
     setting:=AdjacentColsAndRows.value

End Sub

Private Sub AktualisierungenSuchen_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="NoAutoUpdate", _
     setting:=0

  CheckVersion 0, progNameShort, progNameShort & "\SWUpdate" & progNameShort & ".txt", MyInternalVersion, True

End Sub




Private Sub HelpButton_Click()
  OpenFileWithApp ThisWorkbook.path & "\Excel-File-Compare.pdf"

End Sub

Private Sub Label16_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe " & FMT0("About_2"), 1)
End Sub


Private Sub Analyse_Click()

  ShowSingleFileAnalysis = False
  Beenden = False
  
  Dim Filename
  
  
  'Filename = Application.GetOpenFilename("Excel-Dateien,*.xl?", 1, "Excel Datei laden")
  Filename = Application.GetOpenFileName("Excel-Dateien,*.xl?", 1, FMT0("Main_12"))

  ' War die Eingabe ok?
  If Filename = False Then Exit Sub
  
  Me.Hide
  
  theFilename = Filename
  
  Me.Hide
  Application.OnTime Now + TimeValue("00:00:02"), "DoEinzelanalyse"
  ShowStatusForm
End Sub
  
Private Sub ProgrammBeenden_Click()
  On Error Resume Next
'    ThisWorkbook.Close
  MainMenu.Hide
End Sub

Private Sub RoundNumbers_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="RoundNumbers", _
     setting:=IIf(RoundNumbers.value = True, 1, 0)

End Sub

Private Sub SelectDatei1_Click()
  Dim Filename
  
  'Filename = Application.GetOpenFilename("Excel-Dateien (*.xl*),*.xl*", 1, "Excel Datei 1 festlegen")
  Filename = Application.GetOpenFileName("Excel-Dateien (*.xl*),*.xl*", 1, FMT0("Main_13"))
'  Filename = Application.GetOpenFilename("Excel-Dateien,*.xls", 1, "Excel Datei 1 festlegen")

  If Filename = False Then Exit Sub
    
  Me.Datei1 = Filename

  AddFileToComboboxList 1, Datei1, Filename
End Sub



Private Sub SelectDatei2_Click()
  Dim Filename
  
  'Filename = Application.GetOpenFilename("Excel-Dateien (*.xl*),*.xl*", 1, "Excel Datei 2 festlegen")
  Filename = Application.GetOpenFileName("Excel-Dateien (*.xl*),*.xl*", 1, FMT0("Main_14"))
'  Filename = Application.GetOpenFilename("Excel-Dateien,*.xls", 1, "Excel Datei 2 festlegen")

  If Filename = False Then Exit Sub
    
  Me.Datei2 = Filename


  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="Datei2", _
     setting:=Datei2

End Sub

Private Sub ShowAboutDlg_Click()
    'ShowInfoMenu 8, ProgNameLong, ProgNameLong, IIf(CLng(StartProgCopyright) = year(Now), "Copyright |fffd|" & year(Now), "Copyright |fffd|" & StartProgCopyright & " - " & year(Now)) & " Stromwerken", MyVersion
    ShowInfoMenu 8, ProgNameLong, ProgNameLong, IIf(CLng(StartProgCopyright) = year(Now), FMT0("Main_15") & year(Now), FMT0("Main_15") & StartProgCopyright & " - " & year(Now)) & " Stromwerken", myVersion
End Sub

Private Sub ProgressOn(b As Boolean, twoProgresses As Boolean)
    MainMenu.Progress.Width = 0
    MainMenu.ProgressTxt.Caption = "0%"
    MainMenu.Progress.visible = b
    MainMenu.ProgressTxt.visible = b
End Sub


Private Sub Datei1_Exit(ByVal Cancel As MSForms.ReturnBoolean)
  If Datei1 = "" Then Exit Sub
  If FileExists(Datei1) Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="Datei1", _
       setting:=Datei1
    AddFileToComboboxList 1, Datei1, Datei1
  End If
End Sub

Private Sub Datei2_Exit(ByVal Cancel As MSForms.ReturnBoolean)
  If Datei2 = "" Then Exit Sub
  If FileExists(Datei2) Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="Datei2", _
       setting:=Datei2
    AddFileToComboboxList 2, Datei2, Datei2
  End If
End Sub


Private Sub ShowOnlyFormulas_Click()

  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="ShowOnlyFormulas", _
     setting:=IIf(ShowOnlyFormulas.value = True, 1, 0)
End Sub

Private Sub Vergleichen_Click()
  
  If Not IsNumeric(AdjacentColsAndRows.value) Then
    'MsgBox "Sie haben keine Zahl im Feld f|fffd|r 'Erlaubte Leerspalten- und Zeilen in einem Bereich' angegeben. Der Wert wird auf 0 gesetzt.", vbInformation
    MsgBox FMT0("Main_16"), vbInformation
    AdjacentColsAndRows.value = 0
  End If
  
  G_MaxLeerzellen = CLng(AdjacentColsAndRows.value)
  G_ShowOnlyFormulas = ShowOnlyFormulas
  G_ShowVBADifferences = ShowVBADifferences
  
  Me.Hide
  
'  Application.OnTime Now + TimeValue("00:00:01"), "DoCompare"
  ShowStatusForm
  DoCompare MainMenu.Datei1.value, MainMenu.Datei2.value, "", "", MainMenu.Datei1.value, MainMenu.Datei2.value, "", "", True, False

End Sub

Attribute VB_Name = "MyCompare"
Option Explicit

Function NewCompareSheet(ByRef ws1 As Worksheet, ByRef wb2 As Workbook, ws1ParentFullName As String, ws2ParentFullName As String) As Boolean
  
  Dim rnginfo1 As Collection
  Dim rnginfo2 As Collection
  
  If Not WorksheetExists(wb2, ws1.name) Then
    AddChangedSheet ws1
    NewCompareSheet = True
    Exit Function
  End If
  
  Dim ws2 As Worksheet
  Set ws2 = wb2.Worksheets(ws1.name)
  
  UnfoldGroups ws1
  ShowAllCells ws1
  UnfoldGroups ws2
  ShowAllCells ws2
  
  
  
  Dim a1 As CArea
  Dim a2 As CArea
  
  Dim c1 As New Collection
  Dim c2 As New Collection
  
  'StatusForm.ProgressTxt.Caption = "Pr|fffd|fe Bereiche"
  StatusForm.ProgressTxt.Caption = FMT0("MyCompare_1")
  GetAreas ws1, c1, ws1ParentFullName
  GetAreas ws2, c2, ws2ParentFullName
  
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    '.value = "Tabellenblatt: " & ws1.name
    .value = FMT1("MyCompare_2", ws1.name)
    .Font.bold = True
    .Font.Size = 14
  End With
  G_Result_Y = G_Result_Y + 1
  
  ' Haben sie beide Areas?
  If c1.Count > 0 And c2.Count > 0 Then
    
    Dim compared() As Boolean
    ReDim compared(c2.Count)
    
    Dim areaarray() As Long
    ReDim areaarray(c1.Count, c2.Count)
    
    Dim i1 As Long, i2 As Long
    i1 = 1
    For Each a1 In c1
      i2 = 1
      For Each a2 In c2
        'StatusForm.ProgressTxt.Caption = "Pr|fffd|fe |fffd|bereinstimmung von Bereich " & i1 & " mit " & i2
        StatusForm.ProgressTxt.Caption = FMT2("MyCompare_3", i1, i2)
        DoEvents
        areaarray(i1, i2) = AreasMatch(ws1, ws2, a1, a2, False)
        If Beenden Then
            EndStep FMT0("Scan_25")
            Exit Function
        End If
        i2 = i2 + 1
      Next a2
      i1 = i1 + 1
    Next a1
    
    ' Ok, jetzt sind die Vergleichswerte der Area bekannt und es m|fffd|ssen immer die Areas mit dem "gr|fffd||fffd|ten" Wert
    ' verglichen Werden.
    
    Dim hadDifferences As Boolean
    hadDifferences = False
    
    For i1 = 1 To c1.Count
      Dim largestComparePos As Long
      largestComparePos = -1
      Dim largestCompare As Long
      largestCompare = 0
      For i2 = 1 To c2.Count
        If Not compared(i2) Then
          If largestCompare < areaarray(i1, i2) Then
            largestCompare = areaarray(i1, i2)
            largestComparePos = i2
          End If
        End If
      Next i2
      
      ' Haben wir etwas zum Vergleichen?
      If largestComparePos >= 0 Then
        If c1(i1).Compare(c2(largestComparePos), ws1, ws2, i1, ws1ParentFullName, ws2ParentFullName) Then
          If Beenden Then
            'EndStep "Vergleiche '" & s.name & "' - Abgebrochen!"
            EndStep FMT0("Scan_25")
            Exit Function
          End If
          hadDifferences = True
        End If
        compared(largestComparePos) = True
      Else
        ' Nein, es gibt nichts zum Vergleichen, also einfach alle Felder als gel|fffd|scht markieren.
'        Debug.Print "Gel|fffd|schter Bereich: Y1: " & c1(i1).m_Y1 & " X1: " & c1(i1).m_X1 & " Y2: " & c1(i1).m_Y2 & " X2: " & c1(i1).m_X2
        If (c1(i1).AreaHasFormulas(ws1) = True And G_ShowOnlyFormulas = True) Or G_ShowOnlyFormulas = False Then
          With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
            '.value = "Zellbereich:"
            .value = FMT0("MyCompare_4")
            .Font.Color = RGB(255, 20, 20)
            .Font.Size = 12
            .Font.bold = True
          End With
'          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & ws1ParentFullName & "#'" & _
'            ws1.name & "'!" & Replace(Cells(c1(i1).m_Y1, c1(i1).m_X1).Address & ":" & Cells(c1(i1).m_Y2, c1(i1).m_X2).Address, "$", "") _
'            & Chr(34) & "," & Chr(34) & _
'            Replace(Cells(c1(i1).m_Y1, c1(i1).m_X1).Address & ":" & Cells(c1(i1).m_Y2, c1(i1).m_X2).Address, "$", "") & " gel|fffd|scht" _
'            & Chr(34) & ")"
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(ws1ParentFullName)) & "#'" & _
            ws1.name & "'!" & Replace(Cells(c1(i1).m_Y1, c1(i1).m_X1).Address & ":" & Cells(c1(i1).m_Y2, c1(i1).m_X2).Address, "$", "") _
            & Chr(34) & "," & Chr(34) & _
            Replace(Cells(c1(i1).m_Y1, c1(i1).m_X1).Address & ":" & Cells(c1(i1).m_Y2, c1(i1).m_X2).Address, "$", "") & FMT0("MyCompare_5") _
            & Chr(34) & ")"
          G_Result_Y = G_Result_Y + 1
          hadDifferences = True
        End If
      End If
    Next i1
    
    ' Und noch pr|fffd|fen, ob es neue Bereiche gibt
    For i2 = 1 To c2.Count
      If compared(i2) = False Then
        ' Debug.Print "Neuer Bereich: Y1: " & c2(i2).m_Y1 & " X1: " & c2(i2).m_X1 & " Y2: " & c2(i2).m_Y2 & " X2: " & c2(i2).m_X2
        If (c2(i2).AreaHasFormulas(ws2) = True And G_ShowOnlyFormulas = True) Or G_ShowOnlyFormulas = False Then
          With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
            '.value = "Zellbereich:"
            .value = FMT0("MyCompare_4")
            .Font.Color = RGB(255, 20, 20)
            .Font.Size = 12
            .Font.bold = True
          End With
'          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & ws2ParentFullName & "#'" & _
'            ws2.name & "'!" & Replace(Cells(c2(i2).m_Y1, c2(i2).m_X1).Address & ":" & Cells(c2(i2).m_Y2, c2(i2).m_X2).Address, "$", "") _
'            & Chr(34) & "," & Chr(34) & _
'            Replace(Cells(c2(i2).m_Y1, c2(i2).m_X1).Address & ":" & Cells(c2(i2).m_Y2, c2(i2).m_X2).Address, "$", "") & " hinzugef|fffd|gt" _
'            & Chr(34) & ")"
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).formula = "=HYPERLINK(" & Chr(34) & GetCachedMappedDrive(UCase(ws2ParentFullName)) & "#'" & _
            ws2.name & "'!" & Replace(Cells(c2(i2).m_Y1, c2(i2).m_X1).Address & ":" & Cells(c2(i2).m_Y2, c2(i2).m_X2).Address, "$", "") _
            & Chr(34) & "," & Chr(34) & _
            Replace(Cells(c2(i2).m_Y1, c2(i2).m_X1).Address & ":" & Cells(c2(i2).m_Y2, c2(i2).m_X2).Address, "$", "") & FMT0("MyCompare_6") _
            & Chr(34) & ")"
          G_Result_Y = G_Result_Y + 1
          hadDifferences = True
        End If
      End If
    Next i2
  ElseIf c1.Count = 0 And c2.Count > 0 Then
    ' Debug.Print "Alle Tabelleninhalte neu"
    'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).FormulaLocal = "Alle Tabelleninhalte neu"
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).FormulaLocal = FMT0("MyCompare_7")
    G_Result_Y = G_Result_Y + 1
    hadDifferences = True
  ElseIf c1.Count > 0 And c2.Count = 0 Then
    ' Debug.Print "Alle Tabelleninhalte gel|fffd|scht"
    'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).FormulaLocal = "Alle Tabelleninhalte gel|fffd|scht"
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).FormulaLocal = FMT0("MyCompare_8")
    G_Result_Y = G_Result_Y + 1
    hadDifferences = True
  End If
  
  Set c1 = Nothing
  Set c2 = Nothing
  
  If hadDifferences Then
    AddChangedSheet ws1
  End If
  
  NewCompareSheet = hadDifferences
End Function

Sub GetAreas(ByRef ws As Worksheet, ByRef c As Collection, ByVal wsParentFullName As String)
  Dim lc As Range
  
  Set lc = GetLastCell(ws, wsParentFullName)
  
  Dim x As Long
  Dim y As Long
  Dim xend As Long
  Dim yend As Long
  
  If lc Is Nothing Then Exit Sub
  
  xend = lc.Column
  yend = lc.Row
  
  If xend <= 0 Then Exit Sub
  If yend <= 0 Then Exit Sub
  
  Dim ca As CArea
  For y = 1 To yend
    For x = 1 To xend
      If Not IsEmpty(ws.Cells(y, x)) Then
        Dim found As Boolean
        found = False
        For Each ca In c
          If ca.CheckAddCell(y, x) Then
            found = True
            Exit For
          End If
        Next ca
        If Not found Then
          Set ca = New CArea
          ca.SetCell y, x
          c.Add ca
        End If
      End If
    Next x
    'StatusForm.ProgressTxt.Caption = "Suche Zellbereiche - Zeile " & y
    StatusForm.ProgressTxt.Caption = FMT1("MyCompare_9", y)
  Next y
  
  ' Am Ende muss noch aufger|fffd|umt werden. Es kann Areas geben, die zusammen geh|fffd|ren, diese m|fffd|ssen dann
  ' auch zusammen gef|fffd|hrt werden. Ist zum Beispiel m|fffd|glich, wenn in der ersten Zeile leere Zellen sind,
  ' in der zweiten Zeile aber nicht.
  
  found = True
  Do While found
    found = False
    If c.Count > 1 Then
      Dim i1 As Long, i2 As Long
      For i1 = 1 To c.Count - 1
        For i2 = i1 + 1 To c.Count
          If c(i1).CheckAddArea(c(i2)) Then
            found = True
            c.Remove i2
            Exit For
          End If
        Next i2
        If found Then Exit For
      Next i1
    End If
  Loop

'  If c.Count > 0 Then
'    For Each ca In c
'      Debug.Print ca.m_X1, ca.m_Y1, ca.m_X2, ca.m_Y2
'    Next ca
'  End If


End Sub

Function IsText(t As String) As Boolean
  Dim l As Long
  l = Len(t)
  If l <= 0 Then Exit Function
  If Left(t, 1) >= "0" And Left(t, 1) <= "9" Then
    Exit Function
  End If
  IsText = True
End Function

Function AreasMatch(ByRef ws1 As Worksheet, ByRef ws2 As Worksheet, ByRef a1 As CArea, ByRef a2 As CArea, storeAddedAndDeleted As Boolean) As Long

  Dim I As Long
  Dim y1 As Long, y2 As Long
  Dim h As Long
  
  h = MAX_HEADLINE_CHECK
  If a1.Height < MAX_HEADLINE_CHECK Then h = a1.Height
  If a2.Height < h Then h = a2.Height
  
  Dim w As Long
  If storeAddedAndDeleted Then
    w = a1.Width
    If a2.Width < w Then w = a2.Width
  Else
    w = MAX_WIDTH_CHECK
    If a1.Width < MAX_WIDTH_CHECK Then w = a1.Width
    If a2.Width < w Then w = a2.Width
  End If
  
  Dim w2 As Long
  w2 = w
  If a2.Width < w2 Then w2 = a2.Width
  
  Dim cc() As Long
  ReDim cc(h * h, w * w)
  For y1 = 0 To h - 1
    For y2 = 0 To h - 1
      For I = 0 To w
        cc(y1 * h + y2, I) = -1
      Next I
    Next y2
  Next y1
  Dim results() As Long
  ReDim results(h, h)
  Dim res As Long
  
  Dim i1 As Long, i2 As Long
  Dim r2() As Long
  For y1 = 0 To h - 1
    For y2 = 0 To h - 1
    
        ReDim r2(w2)
        For i2 = 0 To w2
          r2(i2) = 0
        Next i2
        
        res = 0
        For i1 = 0 To w - 1
          ' Jetzt schauen wir bei jeder Zelle mal, ob sie zu einer aus der zweiten area passt
          
          Dim tres As Long
          Dim trespos As Long
          trespos = -1
          tres = 0
          For i2 = 0 To w2 - 1
            
'            If storeAddedAndDeleted = True Then
'              If y1 = 0 And y2 = 0 And i1 = 0 And (i2 = 0 Or i2 = 0) Then
'                Debug.Print "Gaga"
'              End If
'            End If
            If r2(i2) <= 0 Then
            
              Dim distance As Long
              distance = Abs(i1 - i2)
              Dim distanceXdistance As Long
              distanceXdistance = distance * distance
            
              If distance < MAX_COL_CHECK + 1 Then
                    Dim c1 As Range
                    Dim c2 As Range
                    
                    Set c1 = ws1.Cells(a1.m_Y1 + y1, a1.m_X1 + i1)
                    Set c2 = ws2.Cells(a2.m_Y1 + y2, a2.m_X1 + i2)
                    
                    If c1.HasFormula = True And c2.HasFormula = True Then
                      If FormulaR1C1HasError(c1) = False And FormulaR1C1HasError(c2) = False Then
                        If c1.formulaR1C1 = c2.formulaR1C1 Or _
                           c1.formula = c2.formula Then
                          If tres < 9 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance) Then
                            tres = 9 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance)
                            trespos = i2
                          End If
                        ElseIf RemoveRelativeCells(c1.formulaR1C1) = RemoveRelativeCells(c2.formulaR1C1) Then
                          ' Wenn die Formel, aber nicht die Bereiche identisch sind.
                            If tres < 7 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance) Then
                              tres = 7 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance)
                              trespos = i2
                            End If
                        End If
                      Else
                        If c1.formula = c2.formula Then
                          If tres < MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance Then
                            tres = MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance
                            trespos = i2
                          End If
                        End If
                      End If
                    ElseIf Not IsEmpty(c1) And Not IsEmpty(c2) Then
                      If IsText(CStr(c1.value)) = True And IsText(CStr(c2.value)) = True Then
                        If CStr(c1.value) = CStr(c2.value) Then
                          If tres < 10 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance) Then
                            tres = 10 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance)
                            trespos = i2
                          End If
                        End If
                      Else
                        If CStr(c1.value) = CStr(c2.value) Then
                          If tres < 8 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance) Then
                            tres = 8 * (MAX_COL_CHECK_X_MAX_COL_CHECK - distanceXdistance)
                            trespos = i2
                          End If
                        End If
                      End If
                    End If
                    Set c1 = Nothing
                    Set c2 = Nothing
              End If
            End If
          Next i2
          If trespos > -1 And tres > 0 Then
            r2(trespos) = tres
            res = res + tres
          End If
          
          ' Wenn trespos >= 0 ist, dann wurde eine Spalte gefunden, ansonsten hei|fffd|t das,
          ' dass die Spalte gel|fffd|scht wurde!
          If trespos >= 0 Then
            ' Die Spalte speichern, in der sich ab jetzt die Werte befinden
            cc(y1 * h + y2, i1) = trespos
          End If
        Next i1
        results(y1, y2) = res
        
        
    Next y2
  Next y1

  ' Jetzt sind die besten Compares gefunden. Von jeder Zeile wird jetzt nur der h|fffd|chste Wert verwendet.
  Dim ty1 As Long, ty2 As Long
  Dim finished As Boolean
  finished = False
  Dim totalres As Long
  totalres = 0
  
  If storeAddedAndDeleted Then
    a1.InitColumns
    a2.InitColumns
  End If
  
  While Not finished
    res = 0
    ty1 = -1
    ty2 = -1
    
    For y1 = 0 To h - 1
      For y2 = 0 To h - 1
        If results(y1, y2) > res Then
          ty1 = y1
          ty2 = y2
          res = results(y1, y2)
        End If
      Next y2
    Next y1
    
    If ty1 >= 0 And ty2 >= 0 Then
      ' Jetzt haben wir den gr|fffd||fffd|ten Wert, d.h. beide Zeilen k|fffd|nnen nicht mehr verwendet werden
      For I = 0 To h - 1
        results(ty1, I) = 0
      Next I
      For I = 0 To h - 1
        results(I, ty2) = 0
      Next I
      totalres = totalres + res
      ' Nun werden die CCs gesetzt
      If storeAddedAndDeleted = True Then
        For I = 0 To a1.Width
          If a1.GetCorrespondingColumn(I) < 0 Then
            If I <= w Then
              If cc(ty1 * h + ty2, I) >= 0 Then
                a1.SetCorrespondingColumn I, cc(ty1 * h + ty2, I)
                a2.SetCorrespondingColumn cc(ty1 * h + ty2, I), I
              End If
            Else
              Exit For
            End If
          End If
        Next I
      End If
    Else
      finished = True
    End If
  Wend
  
  ' Wenn TotalRes immer noch null ist, dann scheinen sich die Bereiche |fffd|berhaupt nicht zu |fffd|hneln.
  ' Dann wird noch die Position gepr|fffd|ft und auch die Gr|fffd||fffd|e. Daf|fffd|r gibt es dann auch ein paar Punkte
  ' F|fffd|r gleiche Position und Breite/H|fffd|he gibt es 4 Punkte
  ' F|fffd|r gleiche Position und Breite ODER H|fffd|he gibt es 3 Punkte
  ' F|fffd|r gleiche Position gibt es 2 Punkte
  ' F|fffd|r gleiche eine |fffd|berschneidung im Bereich gibt es 1 Punkt
  If totalres = 0 Then
    If a1.m_X1 = a2.m_X1 And _
       a1.m_X2 = a2.m_X2 And _
       a1.m_Y1 = a2.m_Y1 And _
       a1.m_Y2 = a2.m_Y2 Then
      totalres = 4
    ElseIf a1.m_X1 = a2.m_X1 And _
       a1.m_Y1 = a2.m_Y1 And _
       (a1.Height = a2.Height Or a1.Width = a2.Width) Then
      totalres = 3
    ElseIf a1.m_X1 = a2.m_X1 And _
       a1.m_Y1 = a2.m_Y1 Then
      totalres = 2
    ElseIf a1.Touches(a2) Then
      totalres = 1
    End If
  
    If totalres > 0 Then
      If storeAddedAndDeleted = True Then
        For I = 0 To a1.Width
          If I < a2.Width Then
            a1.SetCorrespondingColumn I, I
            a2.SetCorrespondingColumn I, I
          End If
        Next I
      End If
    End If
  End If
  
  
  
  
  
  ' Jetzt muss noch durch die Corresponding Collumns (cc) gegangen werden
  ' und alles, was noch nicht gef|fffd|llt ist, gef|fffd|llt werden
  If storeAddedAndDeleted = True Then
    ' Debug.Print "gaga"
  
    ' Jetzt m|fffd|ssen noch alle "leeren" CCs gef|fffd|llt werden
    For i1 = 0 To a1.Width - 1
      If a1.GetCorrespondingColumn(i1) < 0 Then
      
        ' Jetzt wird die Spalte gesucht, die am ehesten in meiner N|fffd|he war
        ' Daf|fffd|r wird die Spalte links von mir genommen, die dazugeh|fffd|rige
        ' Corresponding Column ermittelt und ab da nach der ersten ungenutzten
        ' Spalte gesucht.
        
        Dim tCnt As Long
        tCnt = i1 - 1
        i2 = 0
        Do While tCnt > 0
          If a1.GetCorrespondingColumn(tCnt) >= 0 Then
            i2 = a1.GetCorrespondingColumn(tCnt)
            Exit Do
          End If
          tCnt = tCnt - 1
        Loop
      
        If i2 <= a2.Width - 1 Then
          For i2 = i2 To a2.Width - 1
            If a2.GetCorrespondingColumn(i2) < 0 Then
                a1.SetCorrespondingColumn i1, i2
                a2.SetCorrespondingColumn i2, i1
                Exit For
            End If
          Next i2
        End If
      End If
    Next i1
    
    ' Bleibt als letztes noch die Frage, welche Spalten keine Corresponding Column haben...
    ' Vorsicht: Alle Ver|fffd|nderungen werden ausschlie|fffd|lich in der ersten Area gespeichert!
    For i1 = 0 To a1.Width - 1
      If a1.GetCorrespondingColumn(i1) < 0 Then
        a1.AddAddedOrDeletedRowOrCollumn c_Area_DELETEDCOLUMNS, i1
      End If
    Next i1
    
    For i2 = 0 To a2.Width - 1
      If a2.GetCorrespondingColumn(i2) < 0 Then
        a1.AddAddedOrDeletedRowOrCollumn c_Area_ADDEDCOLUMNS, i2
      End If
    Next i2
  
  End If
  AreasMatch = totalres
End Function

Sub GetNameCollection(ByRef c As Collection, ByRef wb As Workbook)

  Dim nameItem As name
  
  For Each nameItem In wb.names
    If Left(nameItem.name, 11) <> "_IDVTracker" Then
      If UCase(Right(nameItem.name, Len("!Print_Area"))) <> "!PRINT_AREA" And UCase(Right(nameItem.name, Len(".PrintArea"))) <> ".PRINTAREA" And UCase(Right(nameItem.name, Len(".FILTERDATA"))) <> ".FILTERDATA" Then
        If nameItem.visible = True Then
          Dim v As CName
          Set v = New CName
          v.m_Name = nameItem.NameLocal
          v.m_Value = nameItem.RefersToLocal
          c.Add v, v.m_Name
        End If
      End If
    End If
  Next nameItem
End Sub
    


Sub CompareNames(ByRef wb1 As Workbook, ByRef wb2 As Workbook)
  Dim c1 As Collection
  Dim c2 As Collection
  
  Set c1 = New Collection
  Set c2 = New Collection
  
  GetNameCollection c1, wb1
  GetNameCollection c2, wb2
  
  Dim foundDiff As Boolean
  foundDiff = False
  
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    ' .value = "Ver|fffd|nderungen an Namen:"
    .value = FMT0("Scan_42")
    .Font.Size = 14
    .Font.bold = True
  End With
  G_Result_Y = G_Result_Y + 1
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = FMT0("Scan_43")
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.bold = True
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2) = FMT0("Scan_44")
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).Font.bold = True
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4) = FMT0("Scan_45")
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).Font.bold = True
  G_Result_Y = G_Result_Y + 1
  
  Dim fv As CName
  For Each fv In c1
    If CollectionObjectExists(c2, fv.m_Name) Then
      If fv.m_Value <> c2(fv.m_Name).m_Value Then
        G_ChangedWorkbook = True
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "'" & fv.m_Name
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.Color = RGB(255, 20, 20)
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.bold = True
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2) = "'" & fv.m_Value
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4) = "'" & c2(fv.m_Name).m_Value
        G_Result_Y = G_Result_Y + 1
        foundDiff = True
      End If
      ' Der Name wurde gepr|fffd|ft, raus damit
      DeleteCollectionItem c2, fv.m_Name
    Else
      G_ChangedWorkbook = True
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "'" & fv.m_Name
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.Color = RGB(255, 20, 20)
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.bold = True
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2) = "'" & fv.m_Value
      G_Result_Y = G_Result_Y + 1
      foundDiff = True
    End If
  Next fv

  ' Jetzt sind in C2 nur noch Namen enthalten, die in C1 fehlen!
  For Each fv In c2
    G_ChangedWorkbook = True
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "'" & fv.m_Name
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.Color = RGB(255, 20, 20)
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.bold = True
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4) = "'" & fv.m_Value
    G_Result_Y = G_Result_Y + 1
    foundDiff = True
  Next fv

  If foundDiff = False Then
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = FMT0("Scan_22")
    G_Result_Y = G_Result_Y + 1
  End If

  G_Result_Y = G_Result_Y + 1

End Sub

Sub ShowAllCells(ByRef oxlwsheet)
On Error Resume Next
  oxlwsheet.Rows.AutoFit
  oxlwsheet.Columns.AutoFit
End Sub

Sub UnfoldGroups(ByRef oxlwsheet)
On Error Resume Next
  oxlwsheet.Outline.ShowLevels 8, 8
End Sub


Sub CompareCode(ByRef wb1 As Workbook, ByRef wb2 As Workbook)

  Dim foundDiff As Boolean
  foundDiff = False
  
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    ' .value = "Ver|fffd|nderungen an VBA-Code:"
    .value = FMT0("Scan_46")
    .Font.Size = 14
    .Font.bold = True
  End With
  G_Result_Y = G_Result_Y + 1
  
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    '.value = "Keine Unterschiede"
    .value = FMT0("Scan_13")
  End With
  
On Error GoTo nogo
  
  If Not CheckVBAAccessAllowed Then
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = FMT0("Scan_47") ' "Keine Pr|fffd|fung m|fffd|glich, kein Zugriff auf VBA (Passwort gesch|fffd|tzt)!"
    G_Result_Y = G_Result_Y + 2
    Exit Sub
  ElseIf wb1.VBProject.Protection = 1 Or wb2.VBProject.Protection = 1 Then ' vbext_pp_locked
    theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = FMT0("Scan_47") ' "Keine Pr|fffd|fung m|fffd|glich, kein Zugriff auf VBA (Passwort gesch|fffd|tzt)!"
    G_Result_Y = G_Result_Y + 2
    Exit Sub
  End If
  
  Dim cm
  Dim counter As Long
  counter = 1
  Dim checkedCodeModules As Collection
  Set checkedCodeModules = New Collection
  For Each cm In wb1.VBProject.VBComponents
    If Not IsNull(cm) Then
      checkedCodeModules.Add cm.name, "O" & cm.name
      If cm.CodeModule.CountOfLines > 0 Then
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = cm.name
        ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.bold = True
        ' G_Result_Y = G_Result_Y + 1
        If CodeModuleExists(wb2, cm.name) Then
          If Not IsNull(wb2.VBProject.VBComponents(cm.name)) Then
            ' Vergleiche VBA-Modul '%1'
            AddStatus FMT1("Scan_51", cm.name)
            If CompareCodeModule(cm.CodeModule, wb2.VBProject.VBComponents(cm.name).CodeModule, counter, cm.name, wb1.FullName, wb2.FullName) Then
              If Beenden Then
                'EndStep "Vergleiche '" & s.name & "' - Abgebrochen!"
                EndStep FMT1("Scan_14", cm.name)
                Exit Sub
              End If
              ' Vergleiche VBA-Modul '%1' - Identisch
              UpdateStatus FMT1("Scan_53", cm.name)
              theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1) = FMT0("Scan_22") ' "Identisch"
              G_Result_Y = G_Result_Y + 1
            Else
              If Beenden Then
                'EndStep "Vergleiche '" & s.name & "' - Abgebrochen!"
                EndStep FMT1("Scan_14", cm.name)
                Exit Sub
              End If
              ' Vergleiche VBA-Modul '%1' - Ver|fffd|ndert
              UpdateStatus FMT1("Scan_52", cm.name)
              theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1) = FMT0("Scan_21") ' "Ver|fffd|ndert"
              theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
              ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.bold = True
              G_ChangedWorkbook = True
              G_Result_Y = G_Result_Y + 1
            End If
          Else
            theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1) = FMT0("Scan_48") ' "Code Modul in Vergleichsdatei leer"
            theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
            ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.bold = True
            G_ChangedWorkbook = True
            G_Result_Y = G_Result_Y + 1
          End If
        Else
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1) = FMT0("Scan_49") ' "Code Modul fehlt in Vergleichsdatei"
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
          ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.bold = True
          G_ChangedWorkbook = True
          G_Result_Y = G_Result_Y + 1
        End If
      End If
    End If
  Next cm

  For Each cm In wb2.VBProject.VBComponents
    If Not IsNull(cm) Then
      If Not CollectionStringExists(checkedCodeModules, "O" & cm.name) Then
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = cm.name
        ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).Font.bold = True
        ' G_Result_Y = G_Result_Y + 1
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1) = FMT0("Scan_50") ' "Code Modul nur in Vergleichsdatei vorhanden"
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
        ' theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.bold = True
        G_ChangedWorkbook = True
        G_Result_Y = G_Result_Y + 1
      End If
    End If
  Next cm

  Set checkedCodeModules = Nothing
  G_Result_Y = G_Result_Y + 1
  Exit Sub
nogo:
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = FMT0("Scan_47") ' "Keine Pr|fffd|fung m|fffd|glich, kein Zugriff auf VBA (Passwort gesch|fffd|tzt)!"
  G_Result_Y = G_Result_Y + 2

End Sub


' nr wird um 1 erh|fffd|ht, wenn die Module sich unterscheiden, ansonsten nicht!
Function CompareCodeModule(ByRef cm1, ByRef cm2, ByRef nr As Long, ByVal cmname As String, ByVal leftfile As String, ByVal rightfile As String) As Boolean

  ' Vergleiche '%1'
  CompareCodeModule = True

  Dim lineAmount1 As Long
  Dim lineAmount2 As Long
  
  lineAmount1 = cm1.CountOfLines
  lineAmount2 = cm2.CountOfLines
  If lineAmount1 <= 0 And lineAmount2 <= 0 Then Exit Function
  
  ' Als erstes mal pr|fffd|fen, ob sie komplett identisch sind (bis auf blanks und CRLF und C0mments
  
  Dim txt1 As String
  Dim txt2 As String
  If lineAmount1 > 0 Then
    txt1 = UCase(RemoveCommentsLineFeedsAndEmptyRows(cm1.Lines(1, lineAmount1)))
    
  End If
  If lineAmount2 > 0 Then
    txt2 = UCase(RemoveCommentsLineFeedsAndEmptyRows(cm2.Lines(1, lineAmount2)))
  End If
  
  If txt1 = txt2 Then
    Exit Function
  End If
  
  CompareCodeModule = False
  
  If G_ShowVBADifferences = False Then Exit Function
  
  Dim line1 As Long
  Dim line2 As Long
  
  line2 = 1
  
  Dim amFound() As Long
  ReDim amFound(lineAmount1)
  Dim linkFound() As Long
  ReDim linkFound(lineAmount1)
  
  
  ' foundline2 ist immer die Zeile, von der zuletzt nur eine gleiche Zeile gefunden wurde.
  Dim foundline2 As Long
  foundline2 = 0
  For line1 = 1 To lineAmount1
    If line1 Mod 40 = 0 Then
      UpdateStatus FMT1("Scan_51", cmname) & " - " & line1 & " / " & lineAmount1
    End If
    txt1 = Trim(RemoveCommentsAndLineFeeds(cm1.Lines(line1, 1)))
    If txt1 <> "" Then
      If foundline2 + 1 <= lineAmount2 Then
        For line2 = foundline2 + 1 To lineAmount2
          txt2 = Trim(RemoveCommentsAndLineFeeds(cm2.Lines(line2, 1)))
          If txt2 <> "" Then
            If txt1 = txt2 Then
              amFound(line1) = amFound(line1) + 1
              linkFound(line1) = line2
              ' Wenns die schon 2 mal gibt ist sie im Folgenden egal
              If amFound(line1) >= 2 Then
                Exit For
              End If
            End If
          End If
        Next line2
      End If
    End If
  
    If amFound(line1) = 1 Then
      foundline2 = linkFound(line1)
    End If
  
  
    If Beenden Then
      Exit Function
    End If
  Next line1
  
  ' Jetzt kennen wir alle Lines, die UNIQUE sind und k|fffd|nnen, basierend auf diesen eindeutigen Verbindungen, die Differenzen ermitteln.
  ' Daf|fffd|r wird jeder Block zwischen dem Anfang, jeder Uniqe Line und dem Ende einzeln analysieren
  
  Dim ws As Worksheet
  Set ws = AddNewCodePage(Left(CStr(nr & "-" & cmname), 31), leftfile, rightfile)
  
  Dim leftEnd As Long
  Dim rightEnd As Long
  
  Dim leftcnt As Long
  Dim rightcnt As Long
  leftcnt = 1
  rightcnt = 1
  Dim linepos As Long
  linepos = 1
  
  Do While leftcnt <= lineAmount1 And rightcnt <= lineAmount2
'    DoEvents
    
    ' Gut, jetzt gibt es die erste Abweichung!
    leftEnd = leftcnt
    rightEnd = rightcnt
    
    Do While leftEnd < lineAmount1
      If amFound(leftEnd) = 1 Then
        If linkFound(leftEnd) >= rightcnt Then
          rightEnd = linkFound(leftEnd)
          Exit Do
        End If
      End If
      leftEnd = leftEnd + 1
    Loop
    If leftEnd = lineAmount1 Then
      rightEnd = lineAmount2
    End If
    
    ' Jetzt ist also der n|fffd|chste Block bekannt, der zwischen zwei "gleichen" Zeilen liegt, die es nur ein mal gab
    Do While leftcnt <= leftEnd And rightcnt <= rightEnd
      If Beenden Then Exit Function
      
      If leftcnt Mod 40 = 0 Then
        'AddStatus "Vergleiche '" & s.name & "'"
        UpdateStatus FMT1("Scan_51", cmname) & " - " & leftcnt & " / " & lineAmount1
      End If
      
      ' Gleich? Dann beide ausgeben!
      txt1 = UCase(Trim(RemoveCommentsAndLineFeeds(cm1.Lines(leftcnt, 1))))
      txt2 = UCase(Trim(RemoveCommentsAndLineFeeds(cm2.Lines(rightcnt, 1))))
      If txt1 = txt2 Then
        PrintLine ws, cm1, linepos, 1, leftcnt, 2, False
        PrintLine ws, cm2, linepos, 3, rightcnt, 4, False
        linepos = linepos + 1
        leftcnt = leftcnt + 1
        rightcnt = rightcnt + 1
      Else
        ' Wenn die ersten 5 Zeichen gleich sind gehen wir davon aus, dass sie mal zusammen geh|fffd|rt haben
        If Left(txt1, 5) = Left(txt2, 5) Then
          PrintLine ws, cm1, linepos, 1, leftcnt, 2, True
          PrintLine ws, cm2, linepos, 3, rightcnt, 4, True
          linepos = linepos + 1
          leftcnt = leftcnt + 1
          rightcnt = rightcnt + 1
        Else
        
          ' Wenn es rechts noch mehr auszugeben gibt als links, dann geben wir rechts aus
          If rightEnd - rightcnt > leftEnd - leftcnt Then
            PrintLine ws, cm2, linepos, 3, rightcnt, 4, True
            linepos = linepos + 1
            rightcnt = rightcnt + 1
          Else
          ' Ansonsten wird einfach links pr|fffd|feriert ausgegben
            PrintLine ws, cm1, linepos, 1, leftcnt, 2, True
            ' PrintLine ws, Nothing, linepos, 3, rightcnt, 4, True
            linepos = linepos + 1
            leftcnt = leftcnt + 1
          End If
        End If
      End If
    Loop
  Loop
  
  ' Und noch die Restarbeiten
  ' links gibts noch was, rechts nicht mehr.
  If leftcnt <= lineAmount1 And rightcnt > lineAmount2 Then
    Do While leftcnt <= lineAmount1
      PrintLine ws, cm1, linepos, 1, leftcnt, 2, True
      linepos = linepos + 1
      leftcnt = leftcnt + 1
      If leftcnt Mod 40 = 0 Then
      UpdateStatus FMT1("Scan_51", cmname) & " - " & leftcnt & " / " & lineAmount1
      End If
    Loop
  End If
  ' rechts gibts noch was, links nicht mehr.
  If leftcnt > lineAmount1 And rightcnt <= lineAmount2 Then
    Do While rightcnt <= lineAmount2
      PrintLine ws, cm2, linepos, 3, rightcnt, 4, True
      linepos = linepos + 1
      rightcnt = rightcnt + 1
      If rightcnt Mod 40 = 0 Then
      UpdateStatus FMT1("Scan_51", cmname) & " - " & rightcnt & " / " & lineAmount2
      End If
    Loop
  End If
  
  nr = nr + 1

End Function

Sub PrintLine(ByRef ws As Worksheet, ByRef cm, ByVal y As Long, ByVal lineColumn As Long, ByVal line As Long, ByVal codeColumn As Long, ByVal colorCell As Boolean)
    ws.Cells(y + 1, lineColumn).value = line
    With ws.Cells(y + 1, codeColumn)
      If Not cm Is Nothing Then
        .value = "'" & cm.Lines(line, 1)
        If Left(Trim(cm.Lines(line, 1)), 1) = "'" Then
          .Font.Color = RGB(180, 180, 180)
        ElseIf colorCell Then
          ' .Font.Color = RGB(255, 50, 50)
          .Interior.Color = RGB(255, 200, 200)
          ws.Cells(y + 1, 5) = "X"
        End If
      End If
    End With
End Sub


Function CodeModuleExists(ByRef wb As Workbook, cmname As String) As Boolean
  On Error GoTo nogo:
  
  Dim cm
  Set cm = wb.VBProject.VBComponents(cmname)
  Set cm = Nothing
  
  CodeModuleExists = True
  Exit Function
nogo:
  CodeModuleExists = False
End Function


Function CheckVBAAccessAllowed() As Boolean
  CheckVBAAccessAllowed = True
  On Error GoTo noVBA
  If ThisWorkbook.VBProject.Protection = 1 Then ' vbext_pp_locked
  End If
  Exit Function
noVBA:
  CheckVBAAccessAllowed = False
End Function


Function AddNewCodePage(name As String, ByVal leftfile As String, ByVal rightfile As String) As Worksheet
  theResultWB.Sheets.Add After:=theResultWB.Sheets(theResultWB.Sheets.Count)
    
  With theResultWB.Sheets(theResultWB.Sheets.Count)
      .name = "_" & name
      .Columns("A:A").ColumnWidth = 5.22
      .Columns("C:C").ColumnWidth = 5.22
      .Columns("B:B").ColumnWidth = 93.22
      .Columns("D:D").ColumnWidth = 93.22
      .Columns("E:E").ColumnWidth = 2.22
      
      With .Range("A1:E1").Interior
        .Pattern = xlSolid
        .PatternColorIndex = xlAutomatic
        .ThemeColor = xlThemeColorDark1
        .TintAndShade = -0.14996795556505
        .PatternTintAndShade = 0
      End With
      
'      .SplitColumn = 0
'      .SplitRow = 1
'      .FreezePanes = True
      
      .Cells(1, 1).value = "Zeile"
      .Cells(1, 3).value = "Zeile"
      .Cells(1, 2).value = leftfile
      .Cells(1, 4).value = rightfile
      
      With .Columns("A:E")
          .HorizontalAlignment = xlLeft
          .VerticalAlignment = xlTop
          .WrapText = True
          .Orientation = 0
          .AddIndent = False
          .IndentLevel = 0
          .ShrinkToFit = False
          .ReadingOrder = xlContext
          .MergeCells = False
      End With
      .Columns("A:E").Borders(xlDiagonalDown).LineStyle = xlNone
      .Columns("A:E").Borders(xlDiagonalUp).LineStyle = xlNone
      With .Columns("A:E").Borders(xlEdgeLeft)
          .LineStyle = xlContinuous
          .ColorIndex = xlAutomatic
          .TintAndShade = 0
          .Weight = xlThin
      End With
      With .Columns("A:E").Borders(xlEdgeTop)
          .LineStyle = xlContinuous
          .ColorIndex = xlAutomatic
          .TintAndShade = 0
          .Weight = xlThin
      End With
      With .Columns("A:E").Borders(xlEdgeBottom)
          .LineStyle = xlContinuous
          .ColorIndex = xlAutomatic
          .TintAndShade = 0
          .Weight = xlThin
      End With
      With .Columns("A:E").Borders(xlEdgeRight)
          .LineStyle = xlContinuous
          .ColorIndex = xlAutomatic
          .TintAndShade = 0
          .Weight = xlThin
      End With
      With .Columns("A:E").Borders(xlInsideVertical)
          .LineStyle = xlContinuous
          .ColorIndex = xlAutomatic
          .TintAndShade = 0
          .Weight = xlThin
      End With
      With .Columns("A:E").Borders(xlInsideHorizontal)
          .LineStyle = xlContinuous
          .ColorIndex = xlAutomatic
          .TintAndShade = 0
          .Weight = xlThin
      End With
  End With
  
  Application.PrintCommunication = False
  With theResultWB.Sheets(theResultWB.Sheets.Count).PageSetup
      .CenterHeader = name
      .Zoom = False
      .FitToPagesWide = 1
      .FitToPagesTall = False
      .Orientation = xlLandscape
  End With
  Application.PrintCommunication = True
  
  Set AddNewCodePage = theResultWB.Sheets(theResultWB.Sheets.Count)
End Function


Attribute VB_Name = "Passwoerter"
Option Explicit

Public G_CheckDateiberechtigungBeimOeffnen As Boolean

Public Function CryptPasswort(ByVal s As String) As String
    CryptPasswort = Crypt(s, "T0)7/hJy+\1TrcpI?", True)
End Function

Public Function DecryptPasswort(ByVal s As String) As String
    DecryptPasswort = Crypt(s, "T0)7/hJy+\1TrcpI?", False)
End Function

Public Function CreateRandomPasswort() As String
    CreateRandomPasswort = GetStandardPassword() ' Format$(Now, "dd.mm.yyyy")
End Function

Public Function GetStandardPassword() As String
    GetStandardPassword = FirmenPasswort(G_LizenznehmerAdresse)   ' "NDR9)oio0(rrl5/mfk677&" & Left(G_Lizenznehmer & "        ", 8)
End Function
Public Function GetStandardPasswordBlattschutz() As String
    GetStandardPasswordBlattschutz = Left(FirmenPasswort(Right(G_Lizenznehmer, 8) & G_LizenznehmerAdresse), 16)  ' "NDR9)oio0(rrl5/mfk677&" & Left(G_Lizenznehmer & "        ", 8)
End Function

    Public Sub SortiereIndex(ByVal zeile As String, ByRef zIndex() As Long)
        Dim I As Long
        Dim l As Long

        For I = 1 To 8
            Dim kl As String
            kl = Mid(zeile, I, 1)
            Dim klindex As Integer
            klindex = 1
            For l = 2 To 8
                If kl = " " Or Mid(zeile, l, 1) < kl Then
                    If Mid(zeile, l, 1) <> " " Then
                        kl = Mid(zeile, l, 1)
                        klindex = l
                    End If
                End If
            Next
            zIndex(I) = klindex
            Mid(zeile, klindex, 1) = " "
        Next
    End Sub

    Public Function FirmenPasswort(ByVal firmenname As String) As String
        Dim zeichen(8) As String
        
        firmenname = Replace(firmenname, vbCr, "")
        firmenname = Replace(firmenname, vbLf, "")
        firmenname = Replace(firmenname, vbTab, "")

        zeichen(3) = "mnbvcxy&"
        zeichen(4) = "ASDFGHJK"
        zeichen(5) = "12345678"
        zeichen(6) = "QWER?\{}"
        zeichen(7) = "&[]*+-/|fffd|"
        zeichen(8) = "!(/&abcd"

        Dim zeile As String
        Dim spalte As String

        zeile = ""
        spalte = ""

        Dim I As Long
        Dim l As Long
        Dim m As Long
        If Len(firmenname) < 16 Then
            firmenname = firmenname & Left("Ein16stellenText", 16 - Len(firmenname))
        End If
        m = Len(firmenname) / 2
        For I = 0 To 3
            zeile = zeile & Mid(firmenname, m - I, 1)
            zeile = zeile & Mid(firmenname, m + I + 1, 1)
            spalte = spalte & Mid(firmenname, m - I - 4, 1)
            spalte = spalte & Mid(firmenname, m + I + 5, 1)
        Next I
        zeile = Replace(zeile, " ", "A")
        spalte = Replace(spalte, " ", "B")
        zeichen(1) = zeile
        zeichen(2) = spalte

        ' Sortieren und Indizes merken
        Dim zIndex(8) As Long
        Dim sindex(8) As Long
        SortiereIndex zeile, zIndex
        SortiereIndex spalte, sindex

        For I = 1 To 8
            Dim z As String
            z = ""
            For l = 1 To 8
                z = z & Mid(zeichen(I), zIndex(l), 1)
            Next
            zeichen(I) = z
        Next

        Dim result(8) As String

        For I = 1 To 8
            result(I) = "00000000"
        Next

        Dim s As Long
        For s = 1 To 8
            For l = 1 To 8
                Mid(result(l), s, 1) = Mid(zeichen(sindex(l)), s, 1)
            Next
        Next

        FirmenPasswort = result(1) & result(2) & result(3) & result(4) & result(7) & result(8)

    End Function



Public Function StoreRandomPasswordFuerDatei(ByRef conn As Object, ByVal idvDateiID As String)

    Dim rs As Object
    ' wenn es noch kein Passwort gibt, dann erstellen wir ein neues
On Error GoTo fehler
    Set rs = CreateObject("ADODB.Recordset")
    
    rs.Open "SELECT * from idvDateienPW WHERE idvDateiID = " & idvDateiID & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    If rs Is Nothing Then
        StoreRandomPasswordFuerDatei = False
        Exit Function
    End If
    
    If rs.EOF = True Then
        rs.AddNew
        rs.Fields("idvDateiID").value = idvDateiID
        rs.Fields("LogonID").value = Left(GetUserName(), 20)
        rs.Fields("Datum").value = Now
    End If
    Dim pw As String
    pw = CryptPasswort(CreateRandomPasswort())
    rs.Fields("Passwort").value = pw
    rs.Fields("PWTyp").value = 1
    rs.Update
        
    ' zur Sicherheit noch in die Log Tabelle schreiben
    'Dim rsAllePW As Object
    'Set rsAllePW = CreateObject("ADODB.Recordset")
    'If Not rsAllePW Is Nothing Then
    '    rsAllePW.Open "SELECT * from idvDateienPWLog", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    '    rsAllePW.AddNew
    '    rsAllePW.Fields("idvDateiID").Value = idvDateiID
    '    rsAllePW.Fields("Passwort").Value = pws
    '    rsAllePW.Update
    '    rsAllePW.Close
    'End If
    'Set rsAllePW = Nothing
    
    Set rs = Nothing
    StoreRandomPasswordFuerDatei = True
    Exit Function
    
fehler:
    StoreRandomPasswordFuerDatei = False
End Function


Public Function RemoveFileOpenPasswordFuerDatei(ByRef conn As Object, ByVal idvDateiID As String)

    Dim rs As Object
    ' wenn es noch kein Passwort gibt, dann erstellen wir ein neues
On Error GoTo fehler
    Set rs = CreateObject("ADODB.Recordset")
    
    rs.Open "SELECT * from idvDateienPW WHERE idvDateiID = " & idvDateiID & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
    If rs Is Nothing Then
        RemoveFileOpenPasswordFuerDatei = False
        Exit Function
    End If
    
    If rs.EOF = False Then
        rs.Delete
        rs.Update
        rs.Close
    End If
    RemoveFileOpenPasswordFuerDatei = True
fehler:
    Set rs = Nothing
End Function



Public Function GetFileOpenPassword(ByRef rs As Object) As String
    GetFileOpenPassword = ""
    
    ' wenn es noch kein Passwort gibt, dann erstellen wir ein neues
On Error GoTo fehler
    If Not rs Is Nothing Then
        Dim berechtigungAn As Boolean
        berechtigungAn = False
        If rs.Fields("Dateiberechtigungen").value <> 0 Then
            berechtigungAn = True
        End If
        If berechtigungAn = True Then
            GetFileOpenPassword = GetStandardPassword()
'            rs.Open "SELECT * from idvDateienPW WHERE idvDateiID = " & idvDateiID & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockOptimistic
'            If Not rs Is Nothing Then
'                GetFileOpenPassword = DecryptPasswort(rs.Fields("Passwort").Value)
'                rs.Close
'            End If
        End If
    End If
    Exit Function
    
fehler:
    GetFileOpenPassword = ""
    
End Function


Public Function GetFilePassword(ByRef conn As Object, ByVal fname As String) As String
    GetFilePassword = ""
    
    Dim rs As Object
    Dim curId As Long
    Dim hash As String

    ' Wenn Sie bereits gespeichert wurde...
    Dim wasLocked As Boolean
    If GetTargetRSFromFilename(conn, GetUNCPath(fname), rs, curId) Then
        If Not rs Is Nothing Then
            If rs.Fields("Dateiberechtigungen").value <> 0 Then
                ' Berechtigung des aktuellen Users pr|fffd|fen
                
                Dim rsBerechtigung As Object
                Set rsBerechtigung = CreateObject("ADODB.Recordset")
                rsBerechtigung.Open "Select * from idvDateienBerechtigungen where idvDateiID = " & curId & " and typ = 1 and Berechtigungstraeger = '" & GetUserName() & "'", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                If Not rsBerechtigung Is Nothing Then
                    If rsBerechtigung.EOF = False Then
                        GetFilePassword = GetStandardPassword()
                    End If
                    rsBerechtigung.Close
                End If
                Set rsBerechtigung = Nothing
            
                rs.Close
                Set rs = Nothing
                Exit Function
            Else
                Dim rsPW As Object
                Set rsPW = CreateObject("ADODB.Recordset")
                rsPW.Open "Select Passwort from idvDateienPW where idvDateiID = " & curId & " and PWTyp = 1", conn, ADODB.CursorTypeEnum.adOpenDynamic, ADODB.LockTypeEnum.adLockReadOnly
                If Not rsPW Is Nothing Then
                    If rsPW.EOF = False Then
                        GetFilePassword = DecryptPasswort(rsPW.Fields("Passwort").value)
                    End If
                    rsPW.Close
                End If
                Set rsPW = Nothing
            End If
            rs.Close
            Set rs = Nothing
        End If
    End If
    Exit Function
    
fehler:
    GetFilePassword = ""
    
End Function


' Achtung, pr|fffd|ft und schlie|fffd|t die Datei, wenn nicht ok!
' Setzt auch Application.WindowState = G_ActiveWindowStatus, WIRD AUSSCHLIESSLICH BEI gecrypteten Dateien genutzt!!!
Function DateiOeffnenStandardPasswordOK(ByRef xlapp As Object, ByRef wb As Object, ByRef conn As Object, ByRef rs As Recordset) As Boolean

    If Not G_CheckDateiberechtigungBeimOeffnen Then
      DateiOeffnenStandardPasswordOK = True
      Exit Function
    End If
    
    G_CheckDateiberechtigungBeimOeffnen = False

    DateiOeffnenStandardPasswordOK = False
     
    If Not wb Is Nothing Then
        ' Nur wenn das Workbook auch ein Passwort hat UND auch keine Dateiberechtigungen wird das hier gepr|fffd|ft. Ansonsten kann es eh jeder |fffd|ffnen.
        If wb.HasPassword = False And GetSafeFieldPlus(rs, "Dateiberechtigungen", False) = False Then
          DateiOeffnenStandardPasswordOK = True
          Exit Function
        Else

           ' Ok, Passwort war drauf und Dateiberechtigungen an
           Dim q As String
           ' Hat der User eine Berechtigung f|fffd|r diese Datei?
           Dim idvDateiID As Long
           idvDateiID = WBGetValueLong(wb, "_IDVTrackerID" & G_PARAM_Institutsnummer & G_PARAM_Datenbankprefix)
           
           q = "SELECT b.idvDateiID from idvDateienBerechtigungen b WHERE idvDateiID = " & idvDateiID & " and b.Berechtigungstraeger = '" & GetUserName() & "'"
           Dim rsBerechtigung As New Recordset
           rsBerechtigung.Open q, conn, 2, 1
           If Not rsBerechtigung Is Nothing Then
               If rsBerechtigung.EOF = False Then
                  ' alles gut, dann Datei offen lassen
                  rsBerechtigung.Close
                  Set rsBerechtigung = Nothing
                  DateiOeffnenStandardPasswordOK = True
                  Exit Function
               End If
               rsBerechtigung.Close
           End If
           ' Berechtigung gibt es nicht, also Workbook wieder schlie|fffd|en
           Set rsBerechtigung = Nothing
        End If
    End If
    wb.Close False
    Set wb = Nothing

End Function


Attribute VB_Name = "QuickStart"
Attribute VB_Base = "0{219DEBC1-D62C-40C5-8018-B8E8BBA793BB}{7B79B15F-43EB-4FDC-BDD3-AE1D839E99E9}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub ShowVBADifferences_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="ShowVBADifferences", _
     setting:=IIf(ShowVBADifferences.value = True, 1, 0)
End Sub

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub

Private Sub Abbrechen_Click()
    Beenden = True
End Sub


Private Sub AdjacentColsAndRows_Change()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="AdjacentColsAndRows", _
     setting:=AdjacentColsAndRows.value

End Sub

Private Sub AktualisierungenSuchen_Click()
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="NoAutoUpdate", _
     setting:=0

  CheckVersion 0, progNameShort, progNameShort & "\SWUpdate" & progNameShort & ".txt", MyInternalVersion, True

End Sub




Private Sub HelpButton_Click()
  OpenFileWithApp ThisWorkbook.path & "\Excel-File-Compare.pdf"

End Sub

Private Sub Label16_Click()
  On Error Resume Next
  'Call Shell("explorer.exe http://www.stromwerken.de", 1)
  Call Shell("explorer.exe " & FMT0("About_2"), 1)
End Sub


Private Sub Analyse_Click()

  ShowSingleFileAnalysis = False
  Beenden = False
  
  Dim Filename
  
  
  'Filename = Application.GetOpenFilename("Excel-Dateien,*.xl?", 1, "Excel Datei laden")
  Filename = Application.GetOpenFileName("Excel-Dateien,*.xl?", 1, FMT0("Main_12"))

  ' War die Eingabe ok?
  If Filename = False Then Exit Sub
  
  Me.Hide
  
  theFilename = Filename
  
  Me.Hide
  Application.OnTime Now + TimeValue("00:00:02"), "DoEinzelanalyse"
  ShowStatusForm
End Sub

  
Private Sub ProgrammBeenden_Click()
  On Error Resume Next
'    ThisWorkbook.Close
  QuickStart.Hide
'  Unload QuickStart
  Application.Quit
End Sub

Private Sub ShowAboutDlg_Click()
    'ShowInfoMenu 8, ProgNameLong, ProgNameLong, IIf(CLng(StartProgCopyright) = year(Now), "Copyright |fffd|" & year(Now), "Copyright |fffd|" & StartProgCopyright & " - " & year(Now)) & " Stromwerken", MyVersion
    ShowInfoMenu 8, ProgNameLong, ProgNameLong, IIf(CLng(StartProgCopyright) = year(Now), FMT0("Main_15") & year(Now), FMT0("Main_15") & StartProgCopyright & " - " & year(Now)) & " Stromwerken", myVersion
End Sub

Private Sub ShowOnlyFormulas_Click()

  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="ShowOnlyFormulas", _
     setting:=IIf(ShowOnlyFormulas.value = True, 1, 0)
End Sub

Private Sub Vergleichen_Click()
  
  If Not IsNumeric(AdjacentColsAndRows.value) Then
    'MsgBox "Sie haben keine Zahl im Feld f|fffd|r 'Erlaubte Leerspalten- und Zeilen in einem Bereich' angegeben. Der Wert wird auf 0 gesetzt.", vbInformation
    MsgBox FMT0("Main_16"), vbInformation
    AdjacentColsAndRows.value = 0
  End If
  
  G_MaxLeerzellen = CLng(AdjacentColsAndRows.value)
  G_ShowOnlyFormulas = ShowOnlyFormulas
  G_ShowVBADifferences = ShowVBADifferences
  
  Me.Hide
  
'  Application.OnTime Now + TimeValue("00:00:01"), "DoCompare"
  ShowStatusForm
  DoCompare G_File1, G_File2, "", "", G_DisplayName1, G_DisplayName2, G_PW1, G_PW2, False, False

End Sub



Attribute VB_Name = "RemovePassword"
Option Explicit

Dim LastPassword As String

Sub CreateFileCopyOpenAndDeleteIt(ByRef oxlwbook As Excel.Workbook, ByVal pw As String)
    Dim fname As String
    Dim tempdir As String
    tempdir = GetTempPath
    If UCase(Left(oxlwbook.FullName, Len(tempdir))) = UCase(tempdir) Then Exit Sub
    
    fname = tempdir & oxlwbook.name ' tempdir & "EFC-" & oxlwbook.name & "-" & GetUserName & "." & GetFileExtension(oxlwbook.name)
    MyKill fname
    CopyFile oxlwbook.FullName, IIf(Right(tempdir, 1) = "\", Left(tempdir, Len(tempdir) - 1), tempdir)
    oxlwbook.Close False
    Set oxlwbook = Nothing
    GetFile fname, oxlwbook, pw
    MyKill fname
End Sub

Function RemoveAllPasswords(ByRef oxlwbook As Excel.Workbook, ByVal pw As String) As Boolean
  
  Dim wasHighlyEncrypted As Boolean
  wasHighlyEncrypted = False
  
  Dim fname As String
  DebugPrint tinfo, "RemoveAllPasswords10"
  If IsHighlyEncrypted(oxlwbook.name) = False Then
    DebugPrint tinfo, "RemoveAllPasswords20"
    CreateFileCopyOpenAndDeleteIt oxlwbook, pw
    DebugPrint tinfo, "RemoveAllPasswords30"
    RemovePWWorkbook oxlwbook
    DebugPrint tinfo, "RemoveAllPasswords40"
    Dim ws As Worksheet
    For Each ws In oxlwbook.Worksheets
      DebugPrint tinfo, "RemoveAllPasswords50.1-" & ws.name
      RemovePW ws
      DebugPrint tinfo, "RemoveAllPasswords50.2-" & ws.name
    Next ws
    DebugPrint tinfo, "RemoveAllPasswords60"
    RemoveAllPasswords = True
  Else
    wasHighlyEncrypted = True
    G_HighlyEncryptedFileExtension = GetFileExtension(oxlwbook.name)
    fname = GetTempPath & "EFC-" & oxlwbook.name & "-" & GetUserName
    DebugPrint tinfo, "RemoveAllPasswords70-" & fname
    If CreateUnprotectedFile(oxlwbook.name, fname, G_cfgTemppfad) Then
      Set oxlwbook = Nothing
      DebugPrint tinfo, "RemoveAllPasswords80-" & fname & "." & G_HighlyEncryptedFileExtension
      GetFile fname & "." & G_HighlyEncryptedFileExtension, oxlwbook, pw
      DebugPrint tinfo, "RemoveAllPasswords90"
      MyKill fname
      DebugPrint tinfo, "RemoveAllPasswords100"
      RemoveAllPasswords = True
    End If
  End If
End Function


Sub RemovePWWorkbook(oxlwbook As Excel.Workbook)
  
  DebugPrint tinfo, "RemovePWWorkbook10"
  If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
    DebugPrint tinfo, "RemovePWWorkbook20"
    Exit Sub
  End If
  
  On Error Resume Next
  Dim Pwc As Long
  
  'AddStatus "Entferne Passwort aus Excel-Mappe"
  AddStatus FMT0("RemovePwd_1")
  DebugPrint tinfo, "RemovePWWorkbook30"
  oxlwbook.Unprotect LastPassword
  DebugPrint tinfo, "RemovePWWorkbook40"
  If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
      'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!"
      DebugPrint tinfo, "RemovePWWorkbook50"
      UpdateStatus FMT0("RemovePwd_2")
      Exit Sub
  End If

  Dim MyIndex, FileNumber
  Dim tpw As String
  DebugPrint tinfo, "RemovePWWorkbook60"
  If FileExists(ThisWorkbook.path & "\ECCPW.txt") Then
    DebugPrint tinfo, "RemovePWWorkbook70"
    FileNumber = FreeFile
    Do
      Err.Clear
      Open ThisWorkbook.path & "\ECCPW.txt" For Input As #FileNumber   ' Create file name.
    Loop While Err.Number <> 0
    Do While Not EOF(FileNumber)
      Input #1, tpw
      oxlwbook.Unprotect tpw
      If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
        Close #FileNumber
        'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig!"
        UpdateStatus FMT0("RemovePwd_2")
        Exit Sub
      End If
    Loop
    Close #FileNumber   ' Close file.
  End If
  DebugPrint tinfo, "RemovePWWorkbook80"

  Dim A(0 To 17) As Byte, I&, K%, b
  For I = 0 To 2 ^ 17
      For K = 0 To 17
          A(17 - K) = Asc(CStr(Abs((I And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne Passwort aus Excel-Mappe (" & Pwc & " Versuche)"
        UpdateStatus FMT1("RemovePwd_3", Pwc)
      End If
      oxlwbook.Unprotect StrConv(A, vbUnicode)
      If oxlwbook.ProtectStructure = False And oxlwbook.ProtectWindows = False Then
        DebugPrint tinfo, "RemovePWWorkbook90"
        LastPassword = StrConv(A, vbUnicode)
        'UpdateStatus "Entferne Passwort aus Excel-Mappe - Fertig! (" & Pwc & " Versuche)"
        UpdateStatus FMT1("RemovePwd_4", Pwc)
        Debug.Print "Password: " & LastPassword
        FileNumber = FreeFile
        Do
          Err.Clear
          Open ThisWorkbook.path & "\ECCPW.txt" For Append As #FileNumber   ' Create file name.
        Loop While Err.Number <> 0
        Write #FileNumber, LastPassword
        Close #FileNumber
        Exit Sub
      End If
  Next


  DebugPrint tinfo, "RemovePWWorkbook100"
  'UpdateStatus "Entferne Passwort aus Excel-Mappe (Fehlgeschlagen)"
  UpdateStatus FMT0("RemovePwd_5")

End Sub

Sub RemovePW(oxlwsheet As Excel.Worksheet)
  On Error Resume Next
  Dim Pwc As Long
  
  oxlwsheet.Activate
  
  If oxlwsheet.ProtectContents = False Then
    'UpdateStatus "Tabelle '" & oXLWsheet.name & "' ungesch|fffd|tzt!"
    UpdateStatus FMT1("RemovePwd_6", oxlwsheet.name)
    Exit Sub
  End If
  
  'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "'"
  UpdateStatus FMT1("RemovePwd_7", oxlwsheet.name)
  oxlwsheet.Unprotect LastPassword
  If oxlwsheet.ProtectContents = False Then
      'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!"
      UpdateStatus FMT1("RemovePwd_8", oxlwsheet.name)
      Exit Sub
  End If

  Dim MyIndex, FileNumber
  Dim tpw As String
  If FileExists(ThisWorkbook.path & "\ECCPW.txt") Then
    FileNumber = FreeFile
    Do
      Err.Clear
      Open ThisWorkbook.path & "\ECCPW.txt" For Input As #FileNumber   ' Create file name.
    Loop While Err.Number <> 0
    Do While Not EOF(FileNumber)
      Input #1, tpw
      oxlwsheet.Unprotect tpw
      If oxlwsheet.ProtectContents = False Then
        Close #FileNumber
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig!"
        UpdateStatus FMT1("RemovePwd_8", oxlwsheet.name)
        Exit Sub
      End If
    Loop
    Close #FileNumber   ' Close file.
  End If

  Dim A(0 To 17) As Byte, I&, K%, b
  For I = 0 To 2 ^ 17
      For K = 0 To 17
          A(17 - K) = Asc(CStr(Abs((I And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (" & Pwc & " Versuche)"
        UpdateStatus FMT2("RemovePwd_9", oxlwsheet.name, Pwc)
      End If
      oxlwsheet.Unprotect StrConv(A, vbUnicode)
      If oxlwsheet.ProtectContents = False Then
        LastPassword = StrConv(A, vbUnicode)
        'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' - Fertig! (" & Pwc & " Versuche)"
        UpdateStatus FMT2("RemovePwd_10", oxlwsheet.name, Pwc)
        Debug.Print "Password: " & LastPassword
        FileNumber = FreeFile
        Do
          Err.Clear
          Open ThisWorkbook.path & "\ECCPW.txt" For Append As #FileNumber   ' Create file name.
        Loop While Err.Number <> 0
        Write #FileNumber, LastPassword
        Close #FileNumber
        Exit Sub
      End If
  Next


  'UpdateStatus "Entferne Passwort aus Tabelle '" & oXLWsheet.name & "' (Fehlgeschlagen)"
  UpdateStatus FMT1("RemovePwd_11", oxlwsheet.name)
  Debug.Print "Password removal failed."

End Sub

Sub TestRemovePWVBA()
  RemovePWVBA Workbooks("PWCrack.xls")
End Sub

Sub CheckVBAPassword(oxlwbook As Workbook, pw As String)

  oxlwbook.Activate
  
'  Application.EnableEvents = True
  If Left(Application.Version, 3) = "8.0" Then
'    SendKeys "%{F11}%Xs{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%{F11}%Xs" & pw & "{enter}{esc}{esc}%{F4}", True
  ElseIf Left(Application.Version, 3) = "9.0" Then
'    SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%xkv%xi" & pw & "{enter}{esc}{esc}%{F4}", True
  ElseIf Left(Application.Version, 4) = "10.0" Then
'    SendKeys "%xkv%xi{TAB 9}{RIGHT}{tab}a{tab}" & tpassword & "{TAB}" & tpassword & "{tab}{enter}%q", True
    SendKeys "%xkv%xi" & pw & "{enter}{esc}{esc}%{F4}", True
  End If
'  Application.EnableEvents = False
  
End Sub
  

Sub RemovePWVBA(oxlwbook As Excel.Workbook)
  On Error Resume Next
  Dim Pwc As Long
  
  If oxlwbook.VBProject.Protection <> 1 Then
    'UpdateStatus "VBA ungesch|fffd|tzt!"
    UpdateStatus FMT0("RemovePwd_17")
    Exit Sub
  End If
  
  oxlwbook.Application.ScreenUpdating = False
   
  If Len(LastPassword) > 0 Then CheckVBAPassword oxlwbook, LastPassword
  
  'UpdateStatus "Entferne VBA-Passwort aus Projekt"
  UpdateStatus FMT0("RemovePwd_12")
  If oxlwbook.VBProject.Protection <> 1 Then
      'UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig!"
      UpdateStatus FMT0("RemovePwd_13")
      oxlwbook.Application.ScreenUpdating = True
      Exit Sub
  End If
  
  Dim MyIndex, FileNumber
  Dim tpw As String
  If FileExists(ThisWorkbook.path & "\ECCPW.txt") Then
    FileNumber = FreeFile
    Do
      Err.Clear
      Open ThisWorkbook.path & "\ECCPW.txt" For Input As #FileNumber   ' Create file name.
    Loop While Err.Number <> 0
    Do While Not EOF(FileNumber)
      Input #1, tpw
      CheckVBAPassword oxlwbook, tpw
      If oxlwbook.VBProject.Protection <> 1 Then
        Close #FileNumber
        'UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig!"
        UpdateStatus FMT0("RemovePwd_13")
        oxlwbook.Application.ScreenUpdating = True
        Exit Sub
      End If
    Loop
    Close #FileNumber   ' Close file.
  End If

  Dim A(0 To 17) As Byte, I&, K%, b
  For I = 0 To 2 ^ 17
      For K = 0 To 17
          A(17 - K) = Asc(CStr(Abs((I And 2 ^ K) = 0)))
      Next
      Pwc = Pwc + 1
      If Pwc Mod 1000 = 0 Then
        'UpdateStatus "Entferne VBA-Passwort aus Projekt (" & Pwc & " Versuche)"
        UpdateStatus FMT1("RemovePwd_14", Pwc)
      End If
      
      CheckVBAPassword oxlwbook, StrConv(A, vbUnicode)
'      SendKeys StrConv(a, vbUnicode) & "{enter}", True
      If oxlwbook.VBProject.Protection <> 1 Then
        LastPassword = StrConv(A, vbUnicode)
        'UpdateStatus "Entferne VBA-Passwort aus Projekt - Fertig! (" & Pwc & " Versuche)"
        UpdateStatus FMT1("RemovePwd_15", Pwc)
        Debug.Print "Password: " & LastPassword
        FileNumber = FreeFile
        Do
          Err.Clear
          Open ThisWorkbook.path & "\ECCPW.txt" For Append As #FileNumber   ' Create file name.
        Loop While Err.Number <> 0
        Write #FileNumber, LastPassword
        Close #FileNumber
        oxlwbook.Application.ScreenUpdating = True
        Exit Sub
      End If
  Next

  'UpdateStatus "Entferne VBA-Passwort aus Projekt (Fehlgeschlagen)"
  UpdateStatus FMT0("RemovePwd_16")
  Debug.Print "Password removal failed."

  oxlwbook.Application.ScreenUpdating = True

End Sub

Sub PrepareHighlyEncryptedCheck()

  If GetExcelVersion < 12 Then
    Exit Sub
  End If
  
  ' erst mal 7z ausprobieren
  If Test7z Then
    Exit Sub
  End If

  If G_HiglyEncryptedSheetPW > 0 Then Exit Sub
  
  If Not FileExists(ThisWorkbook.path & "\PWTester.xlsx") Then Exit Sub

  Workbooks.Open ThisWorkbook.path & "\PWTester.xlsx"

  On Error Resume Next
  
  Dim oldEnableEvents As Boolean
  oldEnableEvents = Application.EnableEvents
  Dim oldScreenUpdating As Boolean
  oldScreenUpdating = Application.ScreenUpdating
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  Dim hrt As New HighResTimer
  Dim I As Long
  Dim cnt As Long
  cnt = 0
  
  hrt.StartCounting "PWTest"
  Do
    Workbooks("PWTester.xlsx").Sheets("Tabelle1").Unprotect "Test"
    cnt = cnt + 1
    If hrt.GetCurrentCount("PWTest") > 0.5 Then Exit Do
  Loop
  hrt.StopCounting "PWTest"
  
  G_HiglyEncryptedSheetPW = cnt
  Set hrt = Nothing
  
  Set hrt = New HighResTimer
  cnt = 0
  hrt.StartCounting "PWTest"
  Do
    Workbooks("PWTester.xlsx").Unprotect "Test"
    cnt = cnt + 1
    If hrt.GetCurrentCount("PWTest") > 0.5 Then Exit Do
  Loop
  hrt.StopCounting "PWTest"
  
  G_HiglyEncryptedWorkbookPW = cnt
  Set hrt = Nothing
  
  Application.EnableEvents = oldEnableEvents
  Application.ScreenUpdating = oldScreenUpdating
  
  Workbooks("PWTester.xlsx").Close
  
End Sub

Function IsHighlyEncrypted(wbname As String) As Boolean

  If GetExcelVersion < 12 Then
    IsHighlyEncrypted = False
    Exit Function
  End If

  On Error Resume Next
  
  If UCase(GetFileExtension(wbname)) <> "XLSX" And _
     UCase(GetFileExtension(wbname)) <> "XLSM" And _
     UCase(GetFileExtension(wbname)) <> "XLTX" And _
     UCase(GetFileExtension(wbname)) <> "XLTM" And _
     UCase(GetFileExtension(wbname)) <> "XLSB" And _
     UCase(GetFileExtension(wbname)) <> "XLAM" Then
     IsHighlyEncrypted = False
     Exit Function
  End If

  If G_7ZAvailable Then
    IsHighlyEncrypted = True
    Exit Function
  End If
  
  Dim oldEnableEvents As Boolean
  oldEnableEvents = Application.EnableEvents
  Dim oldScreenUpdating As Boolean
  oldScreenUpdating = Application.ScreenUpdating
  
  Application.EnableEvents = False
  Application.ScreenUpdating = False
  
  
  IsHighlyEncrypted = False
  Dim hrt As HighResTimer
  Dim I As Long
  
  Dim ws
  
  For Each ws In Workbooks(wbname).Sheets
    If TypeName(ws) = "Worksheet" Then
      If SheetHasPassword(ws) Then
      Dim wsname As String
      wsname = ws.name
      
      Set hrt = New HighResTimer
      hrt.StartCounting "PWTest"
      
      For I = 1 To G_HiglyEncryptedSheetPW
        Workbooks(wbname).Sheets(wsname).Unprotect "X_!S"
        If hrt.GetCurrentCount("PWTest") > 0.5 And I * 4 < G_HiglyEncryptedSheetPW Then
          IsHighlyEncrypted = True
          Exit For
        End If
      Next I
      
      hrt.StopCounting "PWTest"
      Set hrt = Nothing
      
      If IsHighlyEncrypted = True Then Exit For
      End If
    End If
  Next ws
  
  If Not IsHighlyEncrypted Then
    If WorkbookHasPassword(Workbooks(wbname)) Then
      Set hrt = New HighResTimer
      hrt.StartCounting "PWTest"
      For I = 1 To G_HiglyEncryptedWorkbookPW
        Workbooks(wbname).Unprotect "Test_ABC_"
      
        If hrt.GetCurrentCount("PWTest") > 0.5 And I * 4 < G_HiglyEncryptedWorkbookPW Then
          IsHighlyEncrypted = True
          Exit For
        End If
      
      Next I
      hrt.StopCounting "PWTest"
      Set hrt = Nothing
    End If
  End If
  
  Application.EnableEvents = oldEnableEvents
  Application.ScreenUpdating = oldScreenUpdating
  
End Function


' xlOpenXMLAddIn = 55 Open XML-Add-In
' xlOpenXMLStrictWorkbook = 61 Strict Open XML-Datei
' xlOpenXMLTemplate = 54 Open XML-Vorlage
' xlOpenXMLTemplateMacroEnabled = 53 Open XML-Vorlagenmakro aktiviert
' xlOpenXMLWorkbook = 51 Open XML-Arbeitsmappe
' xlOpenXMLWorkbookMacroEnabled = 52 Open XML-Arbeitsmappenmakro aktiviert


Function GetHighlyEncryptedFiletype() As Long
  Select Case UCase(G_HighlyEncryptedFileExtension)
    Case "XLSB"
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
    Case "XLSX"
      GetHighlyEncryptedFiletype = 51 '
      G_HighlyEncryptedFileExtension = "XLSX"
    Case "XLSM"
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
    Case "XLTX"
      GetHighlyEncryptedFiletype = 54 '
      G_HighlyEncryptedFileExtension = "XLTX"
    Case "XLTM"
      GetHighlyEncryptedFiletype = 53 '
      G_HighlyEncryptedFileExtension = "XLTM"
    Case "XLAM"
      GetHighlyEncryptedFiletype = 55 '
      G_HighlyEncryptedFileExtension = "XLAM"
    Case Else
      GetHighlyEncryptedFiletype = 52 ' xlOpenXMLWorkbookMacroEnabled
      G_HighlyEncryptedFileExtension = "XLSM"
  End Select

End Function


Function CreateUnprotectedFile(ByVal wbname As String, filenamedest As String, ByVal tmppth As String) As Boolean
  ' erst mal die DAtei kopieren
  
  DebugPrint tinfo, "CreateUnprotectedFile10"
  If GetExcelVersion < 12 Then
    DebugPrint tinfo, "CreateUnprotectedFile20"
    CreateUnprotectedFile = False
    Exit Function
  End If
  
  ' Erzeuge tempor|fffd|re Datei...
  AddStatus FMT0("REMOVEPWD_18")
  DebugPrint tinfo, "Erzeuge tempor|fffd|re Datei..."
  
On Error GoTo cleanUp

  DebugPrint tinfo, "CreateUnprotectedFile30"
  Dim wb As Workbook
  Set wb = Workbooks(wbname)
  DebugPrint tinfo, "Datei: " & wbname
  
  SetLiveStatus
  Dim alrt As Long
  alrt = Application.DisplayAlerts
  Application.DisplayAlerts = False
  
  Dim ftype As Long
  Dim newFileType As String
  ftype = GetHighlyEncryptedFiletype
  DebugPrint tinfo, "CreateUnprotectedFile40-FType: " & ftype

  DebugPrint tinfo, "CreateUnprotectedFile50-Kill: " & filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip"
  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip"
  
  If FileExists(filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip") Then
    DebugPrint terror, "File " & filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip" & " still Exists"
  End If
  
  
  DebugPrint tinfo, "CreateUnprotectedFile60"
  SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOneWarning", setting:="True"
  wb.SaveAs filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip", ftype, "" ' xlOpenXMLWorkbookMacroEnabled
  DebugPrint tinfo, "CreateUnprotectedFile70"
  SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOneWarning", setting:=""
  
  Application.DisplayAlerts = alrt
  
  SetLiveStatus
  wb.Close
  Set wb = Nothing
  DelTree tmppth & "\" & GetUserName & ".tmp"
  MkFullDir tmppth & "\" & GetUserName & ".tmp"
  DebugPrint tinfo, "CreateUnprotectedFile80"
  SetLiveStatusFunc "SpecialCells", True
  ExtractZip filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip", tmppth & "\" & GetUserName & ".tmp"
  DebugPrint tinfo, "CreateUnprotectedFile90"
  SetLiveStatusFunc "SpecialCells", False
  SetLiveStatus
  
  Dim cFnames As Collection
  Set cFnames = New Collection
  
  Dim strFile As String
  strFile = Dir(tmppth & "\" & GetUserName & ".tmp\xl\worksheets\*.xml")
  Do While Len(strFile) > 0
      cFnames.Add strFile
      strFile = Dir
  Loop
  DebugPrint tinfo, "CreateUnprotectedFile100"
  
  Dim I As Long
  If cFnames.Count > 0 Then
    For I = 1 To cFnames.Count
      DebugPrint tinfo, "CreateUnprotectedFile110-" & tmppth & "\" & GetUserName & ".tmp\xl\worksheets\" & cFnames(I)
      RemoveTextInTextfile tmppth & "\" & GetUserName & ".tmp\xl\worksheets\" & cFnames(I), "<sheetProtection ", "/>"
      DebugPrint tinfo, "CreateUnprotectedFile120"
    Next I
  End If
  Set cFnames = Nothing
  
  DebugPrint tinfo, "CreateUnprotectedFile130-" & tmppth & "\" & GetUserName & ".tmp\xl\workbook.xml"
  RemoveTextInTextfile tmppth & "\" & GetUserName & ".tmp\xl\workbook.xml", "<workbookProtection ", "/>"
  DebugPrint tinfo, "CreateUnprotectedFile140"
  SetLiveStatus
  
  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip"
  SetLiveStatusFunc "SpecialCells", True
  DebugPrint tinfo, "CreateUnprotectedFile150"
  If Not ZipFolder(tmppth & "\" & GetUserName & ".tmp", filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip") Then
    DebugPrint tinfo, "CreateUnprotectedFile160"
    GoTo cleanUp
  End If
  DebugPrint tinfo, "CreateUnprotectedFile170"
  SetLiveStatusFunc "SpecialCells", False
  
  SetLiveStatus
  MyKill filenamedest & "." & G_HighlyEncryptedFileExtension
  
  DebugPrint tinfo, "CreateUnprotectedFile170-" & filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip --> " & filenamedest & "." & G_HighlyEncryptedFileExtension
  Name filenamedest & "." & G_HighlyEncryptedFileExtension & ".zip" As filenamedest & "." & G_HighlyEncryptedFileExtension
  DebugPrint tinfo, "CreateUnprotectedFile180"
  CreateUnprotectedFile = True
  
cleanUp:
  DelTree tmppth & "\" & GetUserName & ".tmp"
  DebugPrint tinfo, "CreateUnprotectedFile190"
  Exit Function
End Function


Function RemoveTextInTextfile(ByVal strFile As String, ByVal startstring As String, ByVal endstring As String) As Boolean
  Dim pos1 As Long
  Dim pos2 As Long
  Dim tFile As String
  On Error GoTo binCheck
  tFile = ReadTextfile(strFile)
  If Len(tFile) > 0 Then
    pos1 = InStr(tFile, startstring)
    If pos1 > 0 Then
      pos2 = InStr(pos1, tFile, endstring)
      If pos2 > 0 Then
        tFile = Left(tFile, pos1 - 1) & Mid(tFile, pos2 + 2)
        MyKill strFile
        WriteTextfile strFile, tFile
      End If
    End If
    RemoveTextInTextfile = True
    Exit Function
  End If
  
binCheck:
  
  ' Mist, es gab nen error oder die Datei war leer, wahrscheinlich war die Datei zu gro|fffd|, zeilenweise vorgehen
 
  AddStatus "Pr|fffd|fe " & GetFileNameAndExtension(strFile)
  
  pos1 = SearchFileForText(strFile, startstring)
  If pos1 > 0 Then
    pos2 = SearchFileForText(strFile, endstring, pos1)
    If pos2 > 0 Then
      ReplaceFileChars strFile, pos1, pos2 - pos1 + 2
    End If
  End If
  RemoveTextInTextfile = True
End Function

Sub ReplaceFileChars(ByVal sFile As String, ByVal pos As Long, ByVal amnt As Long)
  
  Dim f As Integer
  Dim sTemp As String
  sTemp = Space$(amnt)
  
  f = FreeFile
  Open sFile For Binary Access Write As #f
  Seek #f, pos
  Put #f, , sTemp
  Close #f

End Sub
' Durchsucht eine Datei nach einem bestimmten Text
' und gibt die Position der Funstelle zur|fffd|ck,
' bzw. den Wert 0, wenn der Text nicht gefunden wurde
Public Function SearchFileForText(ByVal sFile As String, _
  ByVal sText As String, _
  Optional ByVal lngStart As Long = 1) As Long
 
  Dim f As Integer
  Dim lngStrLen As Long
  Dim lngFound As Long
  Dim lngFileSize As Long
  Dim lngFilePos As Long
  Dim lngReadSize As Long
  Dim sTemp As String
  Dim sPrev As String
  Dim intProz As Integer
  
  
  Dim lastproz As Integer
  lastproz = 0
 
  ' Gr|fffd||fffd|e eines einzelnen einzulesenden Datenblocks
  Const lngBlockSize = 8192
 
  ' L|fffd|nge des gesuchten Textes
  lngStrLen = Len(sText)
 
  ' Falls die Datei gar nicht existiert, oder der
  ' kein Suchtext angegeben wurde, wird die Funktion
  ' hier verlassen
  If Dir$(sFile) = "" Or lngStrLen = 0 Then Exit Function
 
  ' Datei im Bin|fffd|rmodus |fffd|ffnen
  f = FreeFile
  Open sFile For Binary As #f
 
  ' Gr|fffd||fffd|e der Datei
  lngFileSize = LOF(f)
 
  ' Start-Position
  If lngStart > 1 Then
    Seek #f, lngStart
    lngFilePos = lngStart - 1
  End If
 
  ' Solange "blockweise" einlesen, bis entweder das
  ' Dateiende erreicht oder der Text gefunden wurde
  While lngFilePos < lngFileSize And lngFound = 0
 
    If lngFilePos + lngBlockSize > lngFileSize Then
      ' Falls aktuelle Position + Blockgr|fffd||fffd|e |fffd|ber das
      ' Dateiende hinaus geht -> Blockgr|fffd||fffd|e neu festlegen
      ' (maximal bis Dateiende)
      lngReadSize = lngFileSize - lngFilePos
    Else
      ' ansonsten: festgelegte Blockgr|fffd||fffd|e einlesen
      lngReadSize = lngBlockSize
    End If
 
    ' Variable vorbereiten (mit Leerzeichen f|fffd|len)
    sTemp = Space$(lngReadSize)
 
    ' Datenblock einlesen (Gr|fffd||fffd|e = lngReadSize)
    Get #f, , sTemp
 
    ' die letzten Zeichen des vorigen Blocks nochmals
    ' mit in den Suchvorgang einbeziehen, denn es
    ' k|fffd|nnte ja sein, dass sich der gesuchte Text
    ' genau an zwischen dem letzten und dem aktuell
    ' eingelesenen Block befindet
    sTemp = sPrev + sTemp
 
    ' Ist der gesuchte Text enthalten?
    lngFound = InStr(sTemp, sText)
    If lngFound > 0 Then
      ' JA, Suchtext ist enthalten!
      ' Position ermitteln
      lngFound = lngFilePos + lngFound - Len(sPrev) ' lngStrLen
    End If
 
    ' aktuelle Position aktualisieren
    lngFilePos = lngFilePos + lngReadSize
 
    ' Fortschritt anzeigen
    intProz = Int(lngFilePos / lngFileSize * 100 + 0.5)
    If intProz >= lastproz + 5 Then
      lastproz = intProz
      UpdateStatus FMT2("REMOVEPWD_19", GetFileNameAndExtension(sFile), CStr(intProz))
    End If
    sPrev = Right$(sTemp, lngStrLen)
  Wend
 
  ' nachfolgender Code nur zu Testzwecken
  ' (einfach sp|fffd|ter dann auskommentieren)
  If lngFound > 0 Then
    sTemp = Space$(lngStrLen)
    Seek #f, lngFound
    Get #f, , sTemp
  End If
 
  ' Datei schliessen
  Close #f
 
  UpdateStatus FMT2("REMOVEPWD_19", GetFileNameAndExtension(sFile), "100")
  
  ' Funktionsr|fffd|ckgabewert: Fundstelle (Position)
  SearchFileForText = lngFound
End Function

Function WBHasProtectedSheets(ByRef wb As Workbook) As Boolean
  Dim oxlwsheet As Worksheet
  WBHasProtectedSheets = False
  For Each oxlwsheet In wb.Worksheets
    If TypeName(oxlwsheet) = "Worksheet" Then
      ' Ist ein Blattschutz vorhanden?
      If oxlwsheet.ProtectContents = True Then
        ' Sehr sch|fffd|n, dann schaun wir mal, ob auch ein Passwort daf|fffd|r eingesetzt wurde
        If SheetHasPassword(oxlwsheet) Then
          WBHasProtectedSheets = True
          Exit Function
        End If
      End If
    End If
  Next oxlwsheet
End Function

Attribute VB_Name = "SWAppIDs"
Option Explicit

Public Enum StromwerkenAppID
SWAPPID_IDVSuite = 1
SWAPPID_ExcelTracker = 2
SWAPPID_AccessTracker = 3
SWAPPID_ExcelSheetChecker = 4
SWAPPID_IDVSuiteScheduler = 5
SWAPPID_PluginCheck = 6
SWAPPID_ECCDaemon = 7
SWAPPID_ExcelFileCompare = 8
SWAPPID_ExcelSheetQA = 9
SWAPPID_ExcelProtect = 10
SWAPPID_ACCDaemon = 11
SWAPPID_SWKeyManager = 12
SWAPPID_AccessChecker = 13
SWAPPID_FileTracker = 14
End Enum


Attribute VB_Name = "SWFuncsHelpers"
Option Explicit

Private Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Private Const INTERNET_FLAG_RELOAD = &H80000000
Private Const INTERNET_FLAG_KEEP_CONNECTION = &H400000
Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000

Private Const PROCESS_QUERY_INFORMATION = &H400
Private Const PROCESS_ALL_ACCESS = &H1F0FFF
Private Const STILL_ACTIVE = &H103

Private Const NORMAL_PRIORITY_CLASS = &H20
Private Const IDLE_PRIORITY_CLASS = &H40
Private Const HIGH_PRIORITY_CLASS = &H80
Private Const REALTIME_PRIORITY_CLASS = &H100


'Declares for direct ping
#If VBA7 Then
    Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
    Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
    Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
    Private Declare PtrSafe Function InternetReadFile Lib "wininet.dll" _
        (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
        lNumberOfBytesRead As Long) As Integer
    
    Private Declare PtrSafe Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
        (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
    
    Private Declare PtrSafe Function SetPriorityClass Lib _
      "kernel32" (ByVal hProcess As Long, _
      dwPriorityClass As Long) As Long
    
    Private Declare PtrSafe Function GetExitCodeProcess Lib _
      "kernel32" (ByVal hProcess As Long, _
      lpExitCode As Long) As Long
    
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal _
      dwMilliseconds As Long)
    
    Private Declare PtrSafe Function OpenProcess Lib "kernel32" _
      (ByVal dwDesiredAccess As Long, _
      ByVal bInheritHandle As Long, _
      ByVal dwProcessId As Long) As Long
    
    Private Declare PtrSafe Function TerminateProcess Lib "kernel32" ( _
        ByVal hProcess As Long, _
        ByVal uExitCode As Long _
        ) As Long
        
    Public Declare PtrSafe Function CloseHandle Lib "kernel32" ( _
        ByVal hObject As Long _
        ) As Long
#Else
    Private Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal lpszAgent As String, ByVal dwAccessType As Long, ByVal lpszProxyName As String, ByVal lpszProxyBypass As String, ByVal dwFlags As Long) As Long
    Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hInet As Long, ByVal lpszUrl As String, ByVal lpszHeaders As String, ByVal dwHeadersLength As Long, ByVal dwFlags As Long, ByVal dwContext As Long) As Long
    Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
    Private Declare Function InternetReadFile Lib "wininet.dll" _
        (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
        lNumberOfBytesRead As Long) As Integer
    Private Declare Function InternetGetLastResponseInfo Lib "wininet.dll" Alias "InternetGetLastResponseInfoA" _
        (lpdwError As Long, ByVal lpszBuffer As String, ByVal lpdwBufferLength As Long) As Integer
    
    Private Declare Function SetPriorityClass Lib _
      "kernel32" (ByVal hProcess As Long, _
      dwPriorityClass As Long) As Long
    
    Private Declare Function GetExitCodeProcess Lib _
      "kernel32" (ByVal hProcess As Long, _
      lpExitCode As Long) As Long
    
    Public Declare Sub Sleep Lib "kernel32" (ByVal _
      dwMilliseconds As Long)
    
    Private Declare Function OpenProcess Lib "kernel32" _
      (ByVal dwDesiredAccess As Long, _
      ByVal bInheritHandle As Long, _
      ByVal dwProcessId As Long) As Long
    
    Private Declare Function TerminateProcess Lib "kernel32" ( _
        ByVal hProcess As Long, _
        ByVal uExitCode As Long _
        ) As Long
        
    Public Declare Function CloseHandle Lib "kernel32" ( _
        ByVal hObject As Long _
        ) As Long
#End If

Public trs As String
Public trsShrt As String
Public trsDrCount As Long



Public Function CheckINetConnection() As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de", vbNullString, 0, Flags, 0)
    If hUrl Then
        CheckINetConnection = True
        Call InternetCloseHandle(hUrl)
      Else
        CheckINetConnection = False
      End If
   End If
   Call InternetCloseHandle(hInet)
End Function

Public Sub CheckVersion(checkEveryDays As Long, sec As String, fname As String, _
  currentInternalVersion As Long, Optional msgboxIfNoUpdate As Boolean = False)

  If GetSetting( _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="NoAutoUpdate", _
     Default:=0) = 1 Then Exit Sub


  Dim d As Date
  d = GetSetting( _
    appname:="Stromwerken", _
    Section:=sec, _
    Key:="VersionDate", Default:=DateSerial(2000, 1, 1))

  If DateAdd("d", checkEveryDays, d) > Now Then Exit Sub
 
  SaveSetting _
     appname:="Stromwerken", _
     Section:=sec, _
     Key:="VersionDate", _
     setting:=Now
 
  Dim fTxt As String
  If LoadInetFile(fname, fTxt) Then
  
    Dim regName As String
    Dim internetInternalVersion As Long
    Dim internetVersion As String
    Dim programName As String
    
    regName = GetLine(fTxt)
    internetInternalVersion = Val(GetLine(fTxt))
    internetVersion = GetLine(fTxt)
    programName = GetLine(fTxt)
    
'    If Len(programName) = 0 Then
'    End If
    
    Dim intver As Long
    If Len(internetVersion) > 0 Then
      intver = Val(GetSetting( _
        appname:="Stromwerken", _
        Section:=sec, _
        Key:="InternalVersion", Default:=-1))
        
      If intver < 0 Or internetInternalVersion <= intver Then
        If msgboxIfNoUpdate Then
          'MsgBox "Es ist kein Update f|fffd|r die Software vorhanden."
          MsgBox FMT0("SWFUNC_1")
        End If
        Exit Sub
      End If
      
      Dim tWb As Workbook
      For Each tWb In Workbooks
        If tWb.Saved = False Then
          If Not tWb Is ThisWorkbook Then
            'MsgBox "Im Internet liegt die " & internetVersion & " des Programms '" & programName & "' vor (Sie haben " & GetSetting( _
            '  appName:="Stromwerken", _
            '  Section:=regName, _
            '  Key:="Version", Default:="") & "). Das Update kann erst ausgef|fffd|hrt werden, wenn Sie alle ge|fffd|ffneten und modifzierten Dateien gespeichert und geschlossen haben. Bitte rufen Sie dann im Hauptmen|fffd| den Punkt 'Nach Aktualisierungen suchen' auf.", vbCritical
            MsgBox FMT3("SWFUNC_2", internetVersion, programName, GetSetting( _
              appname:="Stromwerken", _
              Section:=regName, _
              Key:="Version", Default:="")), vbCritical
            Exit Sub
          End If
        End If
      Next tWb
      
      'If MsgBox("Im Internet liegt die " & internetVersion & " des Programms '" & programName & "' vor (Sie haben " & GetSetting( _
      '    appName:="Stromwerken", _
      '    Section:=regName, _
      '    Key:="Version", Default:="") & "). M|fffd|chten Sie die Aktualisierung herunterladen?", vbYesNo) = vbYes Then
      If MsgBox(FMT3("SWFUNC_3", internetVersion, programName, GetSetting( _
          appname:="Stromwerken", _
          Section:=regName, _
          Key:="Version", Default:="")), vbYesNo) = vbYes Then
      
        SaveSetting _
           appname:="Stromwerken", _
           Section:="General", _
           Key:="UpdateCaller", _
           setting:=sec
      
        On Error Resume Next
        If FileExists(ThisWorkbook.path & "\SWUpdater.xla") Then
          Call Shell(Application.path & "\Excel.exe " & ThisWorkbook.path & "\SWUpdater.xla")
        Else
          Call Shell("explorer.exe " & "http://www.stromwerken.de/html/downloads.html", 1)
        End If
        
        ThisWorkbook.Close False
        Application.Quit
        Exit Sub
      Else
        'If MsgBox("Falls Sie auch zuk|fffd|nftig NICHT mehr |fffd|ber Updates informiert werden wollen, klicken Sie einfach auf JA. (Um die automatische Pr|fffd|fung beim Start des Programmes wieder einzuschalten, brauchen Sie lediglich im Hauptmen|fffd| den 'Nach Updates suchen'-Button anzuklicken.)", vbYesNo) = vbYes Then
        If MsgBox(FMT0("SWFUNC_4"), vbYesNo) = vbYes Then
          SaveSetting _
             appname:="Stromwerken", _
             Section:=sec, _
             Key:="NoAutoUpdate", _
             setting:=1
        End If
        Exit Sub
      End If
    End If
  Else
    If msgboxIfNoUpdate Then
      'MsgBox "Es konnte keine Internetverbindung hergestellt werden."
      MsgBox FMT0("SWFUNC_5")
      Exit Sub
    End If
  End If

End Sub

Public Function LoadInetFile(fname As String, ByRef Ret As String, Optional fsize As Long = 0) As Boolean
  Dim hInet As Long
  Dim hUrl As Long
  Dim Flags As Long
  Dim url As Variant
  
  LoadInetFile = False
  
  hInet = InternetOpen(" ", INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0&)
  If hInet Then
    Flags = INTERNET_FLAG_KEEP_CONNECTION Or INTERNET_FLAG_NO_CACHE_WRITE Or INTERNET_FLAG_RELOAD
    'hUrl = InternetOpenUrl(hInet, "http://www.stromwerken.de/" & fname, vbNullString, 0, Flags, 0)
    hUrl = InternetOpenUrl(hInet, FMT0("SWFUNC_6") & fname, vbNullString, 0, Flags, 0)
    If hUrl Then
        
        Dim sReadBuf As String * 1024
        Dim flagMoreData As Boolean
        Dim bytesRead As Long
        Dim wRet As Integer
        Dim lastErr As Long
        Dim s As String
        
        flagMoreData = True
        Do While flagMoreData
            sReadBuf = vbNullString
            wRet = InternetReadFile(hUrl, sReadBuf, Len(sReadBuf), bytesRead)
            If Err.LastDllError <> 0 Then
                lastErr = Err.LastDllError
                Ret = "Error (wininet.dll," & lastErr & ")"
                GoTo exitfunc
            End If
            If wRet <> 1 Then
                Ret = "Error"
                GoTo exitfunc
            End If
            s = s & Left$(sReadBuf, bytesRead)
            If Not CBool(bytesRead) Then flagMoreData = False
        Loop
        Ret = s
        
        Call InternetCloseHandle(hUrl)
        Call InternetCloseHandle(hInet)
        LoadInetFile = True
        Exit Function
    Else
      Call InternetCloseHandle(hInet)
    End If
  End If
  Exit Function

exitfunc:
    If hUrl <> 0 Then InternetCloseHandle (hUrl)
    If hInet <> 0 Then InternetCloseHandle (hInet)
End Function

Private Function GetLine(ByRef txt As String) As String
  Dim pos As Long
  Dim res As String
  pos = InStr(txt, vbCr)
  If pos > 0 Then
    res = Left(txt, pos - 1)
  Else
    res = txt
  End If
  If pos > 0 Then
    txt = Mid(txt, 2 + pos)
  Else
    txt = ""
  End If
  
  GetLine = res

End Function

Function MySpc(l As Long) As String
  If l > 0 Then
    Dim I As Long
    For I = 1 To l
      MySpc = MySpc + " "
    Next I
  End If
End Function

Function MakeFileName(n As String)
  Dim newn As String
  Dim I As Long
  If Len(I) > 0 Then
    For I = 1 To Len(n)
      Select Case Mid(n, I, 1)
        Case ":"
          newn = newn & "-"
        Case "\", "/", "*", "?", Chr(34), "<", ">", "|"
          newn = newn & "_"
        Case Else
          newn = newn + Mid(n, I, 1)
      End Select
    Next I
  End If
  MakeFileName = newn
End Function

Function InStrMyRev(str As String, v As String, Optional pos As Long = 0) As Long
  Dim I As Long
  If Not IsMissing(pos) And pos > 0 Then
    I = pos
  Else
    I = Len(str)
  End If
  Do While I > 0
    If Mid(str, I, Len(v)) = v Then
      InStrMyRev = I
      Exit Function
    End If
    I = I - 1
  Loop
  InStrMyRev = 0
End Function

Function FileUpToDate(dst As String, src As String)
  FileUpToDate = True
'  If Not FileExists(dst) Then
'    FileUpToDate = False
'    Exit Function
'  ElseIf MyFileDateTime(dst) < MyFileDateTime(src) Then
  On Error GoTo dstFileMissing
  
  If MyFileDateTime(dst) < MyFileDateTime(src) Then
    FileUpToDate = False
    Exit Function
  End If
  
  Exit Function
dstFileMissing:
  FileUpToDate = False
  
End Function

Function PathExists(Dateiname$) As Boolean
  On Error GoTo fehler:
  Dim b As Boolean
  
  b = Dir$(Dateiname, vbDirectory) <> ""
  If Not b Then
    b = Dir$(Dateiname & "\", vbDirectory) <> ""
  End If
  PathExists = b
  Exit Function
fehler:
    PathExists = False
    Resume Next
End Function


Sub MkFullDir(ByVal p As String)
  On Error Resume Next
  Dim pos As Long
  pos = 4
  Do
    pos = InStr(pos, p, "\")
    If pos > 0 Then
      MkDir Left(p, pos - 1)
    Else
      MkDir p
      Exit Sub
    End If
    pos = pos + 1
  Loop While pos > 0
End Sub

Public Sub CallAndWaitForProg(Programmname As String)
  Dim hwndShell As Long, hwndProzess As Long
  hwndShell = Shell(Programmname, 1)
  hwndProzess = OpenProcess(PROCESS_ALL_ACCESS, _
    0&, hwndShell)
  Do While ProgStillActive(hwndProzess)
    Sleep 10
  Loop
  CloseHandle hwndProzess
End Sub

Public Function CallProg(Programmname As String) As Long
  Dim hwndShell As Long
  hwndShell = Shell(Programmname, vbMinimizedNoFocus)
  CallProg = OpenProcess(PROCESS_ALL_ACCESS, 0&, hwndShell)
  SetPriorityClass CallProg, HIGH_PRIORITY_CLASS
End Function

Public Function ProgStillActive(ByVal hwndProzess As Long) As Long
  Dim lngLaeuft As Long
  
  GetExitCodeProcess hwndProzess, lngLaeuft
  If lngLaeuft = STILL_ACTIVE Then
    ProgStillActive = True
  Else
    ProgStillActive = False
  End If
    
End Function

Public Sub KillProg(ByVal hwndProzess As Long)
  TerminateProcess hwndProzess, 0&
'  CloseHandle hwndProzess
End Sub

Sub ShowInfoMenu(line As Long, ueberschrift As String, Progname As String, Copyright As String, Version As String)
    GetData
    If Len(trs) Then AboutDlg.Label1 = trs
    AboutDlg.Caption = ueberschrift
    AboutDlg.Progname = Progname
    AboutDlg.Copyright = Copyright
    AboutDlg.CVersion = Version
    AboutDlg.Show
End Sub

Public Sub NachAktualisierungenSuchen(progNameShort As String, internalversion As Long)
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="NoAutoUpdate", _
     setting:=0

  CheckVersion 0, progNameShort, progNameShort & "\SWUpdate" & progNameShort & ".txt", internalversion, True

End Sub

Public Sub SaveStartSettings(progNameShort As String, Version As String, internalversion As Long)
    
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="Path", _
       setting:=ThisWorkbook.path
    
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="Version", _
       setting:=Version
    
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="InternalVersion", _
       setting:=internalversion

End Sub



Function DoThat(t As String) As String

    Dim I As Long
    Dim s2 As String
    For I = 1 To Len(t)
        If Mid(t, I, 1) = "@" Then
            s2 = s2 + vbLf
        ElseIf Mid(t, I, 1) = "^" Then
            s2 = s2 + " "
        ElseIf Mid(t, I, 1) >= "0" And Mid(t, I, 1) <= "9" Then
          s2 = s2 + Chr(Asc("0") + Asc("9") - Asc(Mid(t, I, 1)))
        ElseIf Mid(t, I, 1) >= "a" And Mid(t, I, 1) <= "z" Then
          s2 = s2 + Chr(Asc("a") + Asc("z") - Asc(Mid(t, I, 1)))
        ElseIf Mid(t, I, 1) >= "A" And Mid(t, I, 1) <= "Z" Then
          s2 = s2 + Chr(Asc("A") + Asc("Z") - Asc(Mid(t, I, 1)))
        Else
            s2 = s2 + Mid(t, I, 1)
        End If
    Next I
    
    DoThat = s2
End Function


Function SheetExists(ByRef wb As Workbook, wsname As String, wstype As Long)
  On Error GoTo doesntExist
  SheetExists = False
  
  Dim s As String
  s = wb.Sheets(wsname).name
  If wb.Sheets(wsname).Type <> wstype Then Exit Function
  SheetExists = True
  Exit Function
doesntExist:
End Function

Function WorksheetExists(ByRef wb As Workbook, wsname As String)
  On Error GoTo doesntExist
  WorksheetExists = False
  
  Dim s As String
  s = wb.Sheets(wsname).name
  WorksheetExists = True
  Exit Function
doesntExist:
End Function

Function StripChars(txt As String, charstobestripped As String)
  If Len(txt) <= 0 Or Len(charstobestripped) <= 0 Then
    StripChars = ""
    Exit Function
  End If
  Dim n As String
  Dim I As Long
  For I = 1 To Len(txt)
    If InStr(charstobestripped, Mid(txt, I, 1)) <= 0 Then
      n = n & Mid(txt, I, 1)
    End If
  Next I
  StripChars = n
End Function

Function GetCellRange(oxlwsheet, t As Long, Optional T2)
  Set GetCellRange = Nothing
  Application.DisplayAlerts = False
  On Error Resume Next
  If Not IsMissing(T2) Then
    Set GetCellRange = oxlwsheet.Cells.SpecialCells(t, T2)
  Else
    Set GetCellRange = oxlwsheet.Cells.SpecialCells(t)
  End If
  Application.DisplayAlerts = True
End Function

Function ListItemsSelected(lb) As Boolean
  ListItemsSelected = False
  Dim I As Long
  For I = 1 To lb.ListCount
    If lb.Selected(I - 1) = True Then
      ListItemsSelected = True
      Exit Function
    End If
  Next I
End Function

Function ListItemSelected(lb, txt As String)
  ListItemSelected = False
  Dim I As Long
  For I = 1 To lb.ListCount
    If lb.Selected(I - 1) = True Then
      If lb.List(I - 1) = txt Then
        ListItemSelected = True
        Exit Function
      End If
    End If
  Next I
End Function


Attribute VB_Name = "Scan"
Option Explicit

Dim cfgAusf|fffd|hrlich As Long
Dim cfgProgressVisible As Long
Dim cfgFunktionenAuswerten As Long

Dim CurrentStatus As Long
Public VBAFailure As Long
Public Beenden As Boolean

Public theResultWB As Workbook
Public theFilename As String

Public LastProgText As String
Public ProgText As String

Global Const ChecksumMod As Long = &H100000
Global Const StartEnums As Long = 30
Const StartMassenanalyseY As Long = 11

Public LastTimeStamp As Date
Public theSheetSelectOK As Boolean

Public G_SelectedSheets As Collection
Public G_CheckAll As Boolean

Public G_HighlyEncryptedFileExtension As String

Sub DoCompare(ByVal f1 As String, ByVal f2 As String, ByVal v1 As String, ByVal v2 As String, _
  ByVal displayName1 As String, ByVal displayName2 As String, ByVal pw1 As String, ByVal pw2 As String, _
  ByVal tableSelect As Boolean, ByVal printSelect As Boolean)

 On Error GoTo nogo

  Beenden = False
  G_ChangedWorkbook = False

  Dim ws As Excel.Worksheet
  Set ws = Nothing
  
  InitStatus
  
  If UCase(GetFileNameAndExtension(f1)) = UCase(GetFileNameAndExtension(f2)) Then
    Dim tmpFile As String
    tmpFile = CreateTempFileWithExt("tmp", GetFileExtension(f2))
    CopyFile f2, tmpFile
    f2 = tmpFile
  End If

  If Not FileExists(f1) Then
    'MsgBox "Die Datei '" & f1 & "' existiert nicht mehr oder wurde verschoben", vbCritical
    MsgBox FMT1("Scan_1", f1), vbCritical
    GoTo cleanUp
  End If
  If Not FileExists(f2) Then
    'MsgBox "Die Datei '" & f2 & "' existiert nicht mehr oder wurde verschoben", vbCritical
    MsgBox FMT1("Scan_1", f2), vbCritical
    GoTo cleanUp
  End If
  
  ' Und der Test
  Dim wb1 As Workbook
  Dim wb2 As Workbook
  
  'AddStatus "|fffd|ffne Datei '" & f1 & "'"
  AddStatus FMT1("Scan_2", f1)
  
  If GetFile(f1, wb1, pw1) = False Then
    'MsgBox "Die Datei '" & f1 & "' konnte nicht ge|fffd|ffnet werden!", vbCritical
    MsgBox FMT1("Scan_3", f1), vbCritical
    StatusForm.Hide
    Exit Sub
  End If
  'AddStatus "|fffd|ffne Datei '" & f2 & "'"
  AddStatus FMT1("Scan_2", f2)
  If GetFile(f2, wb2, pw2) = False Then
    'MsgBox "Die Datei '" & f2 & "' konnte nicht ge|fffd|ffnet werden!", vbCritical
    MsgBox FMT1("Scan_3", f2), vbCritical
    wb1.Close False
    StatusForm.Hide
    Exit Sub
  End If
  
  ' Selektion
  If tableSelect Then
    SheetSelect.ListBox1.Clear
    Dim sht As Object
    For Each sht In wb1.Sheets
      SheetSelect.ListBox1.AddItem sht.name
    Next sht
    
    Set G_SelectedSheets = New Collection
    G_CheckAll = False
    SheetSelect.Show
    
    If Not theSheetSelectOK Then
      wb1.Close False
      wb2.Close False
      StatusForm.Hide
      Exit Sub
    End If
  Else
    G_CheckAll = True
  End If
  Dim I As Long
  
  
  
  
  
  Dim app As Excel.Application
  Set app = New Excel.Application
  CheckForET app
  
  Set theResultWB = Nothing
  Dim resultFile As String
  
  If G_ResfileTemplate <> "" Then
    resultFile = gTranslation.GetLocalizedFile(G_ResfileTemplate)
    Set theResultWB = app.Workbooks.Add(resultFile)
  ElseIf G_Resfile <> "" Then
    resultFile = gTranslation.GetLocalizedFile(G_Resfile)
    Set theResultWB = app.Workbooks.Open(resultFile)
  ElseIf FileExists(ThisWorkbook.path & "\EFC-Results_Indiv.xltx") Then
    resultFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\EFC-Results_Indiv.xltx")
    Set theResultWB = app.Workbooks.Add(resultFile)
  Else
    resultFile = gTranslation.GetLocalizedFile(ThisWorkbook.path & "\EFC-Results.xltx")
    Set theResultWB = app.Workbooks.Add(resultFile)
  End If

  Dim resultC As Range
  
  Set resultC = theResultWB.Worksheets(1).Cells.Find(What:="<EFCRESULTS>", LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  If resultC Is Nothing Then
    wb1.Close False
    wb2.Close False
    theResultWB.Close False
    StatusForm.Hide
    'MsgBox "Keinen Eintrag '<RESULTS>' im Ergebnisdokument gefunden!"
    MsgBox FMT0("Scan_4")
    Exit Sub
  End If
  
  G_Result_X = resultC.Column
  G_Result_Y = resultC.Row
  
  G_Endresult_X = resultC.Column
  G_Endresult_Y = resultC.Row
  
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    '.value = "Ergebnis:"
    .value = FMT0("Scan_41")
    .Font.Size = 14
    .Font.bold = True
  End With
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1)
    .value = "'???"
    .Font.Size = 14
    .Font.bold = True
  End With
  
  G_Result_Y = G_Result_Y + 2
  
  Set resultC = Nothing
  
  app.Calculation = xlCalculationManual
  app.visible = C_ShowUpdates
  app.ScreenUpdating = C_ShowUpdates
  app.EnableEvents = C_ShowUpdates

  
  XLScriptInitGlobals
  
  'XLScriptAddSimpleVar "PROGNAMEANDVERSION", ProgNameLong & IIf(FullVersion, IIf(G_EFCPro, " PRO", ""), " (DEMO)") & " " & MyVersion & " - " & IIf(CLng(StartProgCopyright) = year(Now), "Copyright |fffd|" & year(Now), "Copyright |fffd|" & StartProgCopyright & " - " & year(Now)) & " Stromwerken"
  XLScriptAddSimpleVar "PROGNAMEANDVERSION", ProgNameLong & IIf(FullVersion, IIf(G_EFCPro, FMT0("Globals_4"), ""), FMT0("Globals_5")) & " " & myVersion & " - " & IIf(CLng(StartProgCopyright) = year(Now), "Copyright |fffd|" & year(Now), "Copyright |fffd|" & StartProgCopyright & " - " & year(Now)) & " Stromwerken"
  XLScriptAddSimpleVar "STARTOFSCAN", Now
  XLScriptAddSimpleVar "DATEINAME1", displayName1 & IIf(v1 <> "", " (V" & v1 & ")", "")
  XLScriptAddSimpleVar "DATEIDATUM1", IIf(G_FileDate1 <> "", G_FileDate1, MyFileDateTime(f1))
  XLScriptAddSimpleVar "DATEINAME2", displayName2 & IIf(v2 <> "", " (V" & v2 & ")", "")
  XLScriptAddSimpleVar "DATEIDATUM2", MyFileDateTime(f2)

  ' XLScriptAddSimpleVar "RoundNumbers", IIf(MainMenu.RoundNumbers = True, "Ja", "Nein")
  XLScriptAddSimpleVar "ShowOnlyFormulas", IIf(G_ShowOnlyFormulas = True, "Ja", "Nein")

  For Each ws In theResultWB.Worksheets
    XLScriptInit ws, "EFCS"
    XLScriptExecCode ws.Cells
    XLScriptExit
  Next ws
  
  ' Do that test
  
  'AddStatus "Entferne Passw|fffd|rter"
  AddStatus FMT0("Scan_5")
  
  DebugPrint tinfo, "PrepareHighlyEncryptedCheck Start"
  PrepareHighlyEncryptedCheck
  DebugPrint tinfo, "PrepareHighlyEncryptedCheck End"
  
  DebugPrint tinfo, "DoCompare100"
  If WBHasProtectedSheets(wb1) Then
    DebugPrint tinfo, "DoCompare110"
    If Not RemoveAllPasswords(wb1, G_PW1) Then
      DebugPrint tinfo, "DoCompare120"
      MsgBox FMT1("Scan_3", f1), vbCritical
      StatusForm.Hide
      Exit Sub
    End If
    DebugPrint tinfo, "DoCompare130"
  Else
    DebugPrint tinfo, "DoCompare140"
    CreateFileCopyOpenAndDeleteIt wb1, G_PW1
    DebugPrint tinfo, "DoCompare150"
  End If
  
  DebugPrint tinfo, "DoCompare160"
  If WBHasProtectedSheets(wb2) Then
    DebugPrint tinfo, "DoCompare170"
    If Not RemoveAllPasswords(wb2, G_PW2) Then
      DebugPrint tinfo, "DoCompare180"
      MsgBox FMT1("Scan_3", f2), vbCritical
      StatusForm.Hide
      Exit Sub
    End If
    DebugPrint tinfo, "DoCompare190"
  Else
    DebugPrint tinfo, "DoCompare200"
    CreateFileCopyOpenAndDeleteIt wb2, G_PW2
    DebugPrint tinfo, "DoCompare210"
  End If
  
  DebugPrint tinfo, "DoCompare120"
  Set ChangedWorksheets = New Collection
  
  InitLastCells
  
  ' *******************************************************
  ' CHANGED NAMES
  ' *******************************************************
  CompareNames wb1, wb2
  
    
  'AddStatus "Pr|fffd|fe auf gel|fffd|schte / hinzugef|fffd|gte Tabellenbl|fffd|tter"
  AddStatus FMT0("Scan_6")
  ' *******************************************************
  ' MISSINGWORKSHEETS
  ' *******************************************************
  
  Dim foundDeletedOrAddedWorkseehts As Boolean
  foundDeletedOrAddedWorkseehts = False
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    '.value = "Gel|fffd|schte und hinzugef|fffd|gte Tabellenbl|fffd|tter:"
    .value = FMT0("Scan_7")
    .Font.Size = 14
    .Font.bold = True
  End With
  G_Result_Y = G_Result_Y + 1
  
  For Each sht In wb1.Sheets
    If Not SheetExists(wb2, sht.name, sht.Type) Then
      ' XLScriptGetArray("DELETEDWORKSHEETS").AddValue sht.name, sht.name & IIf(sht.Type = xlWorksheet, " (Tabelle)", IIf(sht.Type = 3, " (Chart)", ""))
      'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "'" & sht.name & IIf(sht.Type = xlWorksheet, " (Tabelle)", IIf(sht.Type = 3, " (Chart)", "")) & " gel|fffd|scht"
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "'" & sht.name & IIf(sht.Type = xlWorksheet, FMT0("Scan_8"), IIf(sht.Type = 3, FMT0("Scan_9"), "")) & FMT0("Scan_10")
      G_Result_Y = G_Result_Y + 1
      foundDeletedOrAddedWorkseehts = True
      G_ChangedWorkbook = True
    End If
  Next sht
  
  ' *******************************************************
  ' ADDEDWORKSHEETS
  ' *******************************************************
  For Each sht In wb2.Sheets
    If Not SheetExists(wb1, sht.name, sht.Type) Then
      ' XLScriptGetArray("ADDEDWORKSHEETS").AddValue sht.name, sht.name & IIf(sht.Type = xlWorksheet, " (Tabelle)", IIf(sht.Type = 3, " (Chart)", ""))
      AddChangedSheet sht
      'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "'" & sht.name & IIf(sht.Type = xlWorksheet, " (Tabelle)", IIf(sht.Type = 3, " (Chart)", "")) & " hinzugef|fffd|gt"
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "'" & sht.name & IIf(sht.Type = xlWorksheet, FMT0("Scan_8"), IIf(sht.Type = 3, FMT0("Scan_9"), "")) & FMT0("Scan_11")
      G_Result_Y = G_Result_Y + 1
      foundDeletedOrAddedWorkseehts = True
      G_ChangedWorkbook = True
    End If
  Next sht
  
  If Not foundDeletedOrAddedWorkseehts Then
      'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = "Keine"
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X) = FMT0("Scan_12")
      G_Result_Y = G_Result_Y + 1
  End If
  G_Result_Y = G_Result_Y + 1
  
  

  ' Erst mal kurz durchz|fffd|hlen
  
  CurrentStepCount = 0
  CurrentStepCountAmount = 0
  
  ComplexCalculateTotalStepAmount wb1
  
  InitStepping
  
  Dim wscnt As Long
  wscnt = 0
  
  Dim s As Object
 
  For Each s In wb1.Sheets
    If Beenden Then GoTo beendenCheck
    If G_CheckAll Or CollectionStringExists(G_SelectedSheets, s.name) Then
      'AddStatus "Vergleiche '" & s.name & "'"
      AddStatus FMT1("Scan_15", s.name)
      If s.Type = xlWorksheet Then
        ' ComplexCompareSheet s, wb2
        
        NewCompareSheet s, wb2, wb1.FullName, wb2.FullName
        If Beenden Then GoTo beendenCheck
        If SheetExists(wb2, s.name, 3) = True Or SheetExists(wb2, s.name, xlWorksheet) = True Then
          CompareDiagrams s, wb2.Sheets(s.name)
          If Beenden Then GoTo beendenCheck
          ComparePivots s, wb2.Sheets(s.name)
        End If
      ElseIf s.Type = 3 Or s.Type = -4100 Or s.Type = xlChart Or s.Type = -4102 Then
        If Beenden Then GoTo beendenCheck
        CompareChart s, wb2
      End If
      
      If Not SheetChanged(s) Then
        With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
          '.value = "Keine Unterschiede"
          .value = FMT0("Scan_13")
        End With
        G_Result_Y = G_Result_Y + 1
      End If
      G_Result_Y = G_Result_Y + 1
      
beendenCheck:
      If Beenden Then
        'EndStep "Vergleiche '" & s.name & "' - Abgebrochen!"
        EndStep FMT1("Scan_14", s.name)
      Else
        'EndStep "Vergleiche '" & s.name & "' - " & IIf(SheetChanged(s), "Ver|fffd|ndert", "Identisch")
        EndStep IIf(SheetChanged(s), FMT1("Scan_16", s.name), FMT1("Scan_17", s.name))
      End If
      
      If Beenden Then Exit For
    End If
    wscnt = wscnt + 1
    SetStep wscnt * C_ComplexTotalSteps
  Next s
  
  ' Und das Ganze noch mal mit den Sheets der anderen Datei (zumindest mit denen, die es nicht in der ersten gibt!)
  For Each s In wb1.Sheets
    If Not SheetExists(wb1, s.name, s.Type) Then
      'AddStatus "'" & s.name & "' neu hinzugef|fffd|gt"
      AddStatus FMT1("Scan_18", s.name)
      AddChangedSheet s
    End If
  Next s
  
'  For Each sht In wb1.Sheets
'    If G_CheckAll Or ListItemSelected(SheetSelect.ListBox1, sht.name) Then
'      AddStatus "Vergleiche Chart '" & sht.name & "'"
'        Select Case sht.Type
'          Case 3
'            CompareChart sht, wb2
'        End Select
'      If Beenden Then Exit For
'    End If
'    wscnt = wscnt + 1
'    SetStep wscnt * C_ComplexTotalSteps
'  Next sht
  
  
  ExitLastCells
  
  ' *******************************************************
  ' CHANGED VBA-CODE
  ' *******************************************************
  If Not Beenden Then
    CompareCode wb1, wb2
  End If
  
  
    'Aktiven Drucker merken
'    DruckerAktiv = Application.ActivePrinter
    'PDF-Drucker w|fffd|hlen
'    Application.ActivePrinter = "Adobe PDF auf Ne01:" '###Zeile ggf. anpassen
'    ActiveWorkbook.workSheets(arrBlatt).PrintOut
    'Drucker zur|fffd|cksetzen
'    Application.ActivePrinter = DruckerAktiv
  
  
  ' Ehemals Close WB
  If Not Beenden Then
    
    If G_ChangedWorkbook = True And G_QuickstartMode = False Then
        Dim countChangedInSecondWorkbook As Long
        countChangedInSecondWorkbook = 0
        For I = 1 To ChangedWorksheets.Count
          If WorksheetExists(wb2, ChangedWorksheets(I)) Then
            countChangedInSecondWorkbook = countChangedInSecondWorkbook + 1
          End If
        Next I
        
        If countChangedInSecondWorkbook > 0 And printSelect = True Then
          'If MsgBox("Sollen die hinzugef|fffd|gten und ver|fffd|nderten Tabellenbl|fffd|tter gedruckt werden?", vbYesNo) = vbYes Then
          If MsgBox(FMT0("Scan_19"), vbYesNo) = vbYes Then
            Dim A() As String
            ReDim A(countChangedInSecondWorkbook - 1)
            Dim cnt As Long
            cnt = 0
            For I = 1 To ChangedWorksheets.Count
              ' sh.Add wb2.workSheets(ChangedWorksheets(i))
              If WorksheetExists(wb2, ChangedWorksheets(I)) Then
                  A(cnt) = ChangedWorksheets(I)
                  cnt = cnt + 1
                  wb2.Sheets(ChangedWorksheets(I)).visible = True
              End If
            Next I
            wb2.Sheets(A).Select ' Array("Risikoparameter", "Kursliste", "Kreditn.  Renten")).Select
            
            Dim p
            p = Application.Dialogs(xlDialogPrinterSetup).Show
            If Not p = False Then PrintChangedSheets wb2
          End If
        End If
    End If
  End If
    
    
'  XLScriptAddSimpleVar "SCANRESULT", IIf(ChangedWorksheets.Count > 0 Or foundDeletedOrAddedWorkseehts = True, "Ver|fffd|ndert", "Identisch")
nogo:
  If Err.Number <> 0 Then
    Dim errnr As Long
    Dim errdesc As String
    errnr = Err.Number
    errdesc = Err.Description
    Debug.Print Err.Number, Err.Description
    'XLScriptAddSimpleVar "SCANRESULT", "Bei der Pr|fffd|fung sind Fehler aufgetreten: " & Err.Number & " - " & Err.Description
    XLScriptAddSimpleVar "SCANRESULT", FMT2("Scan_20", errnr, errdesc)
    'MsgBox "Bei der Pr|fffd|fung sind Fehler aufgetreten: " & Err.Number & " - " & Err.Description
    If Not theResultWB Is Nothing Then
      With theResultWB.Worksheets(1).Cells(G_Endresult_Y, G_Endresult_X + 1)
        .value = "'" & errnr & " - " & errdesc
        .Font.Color = RGB(255, 20, 20)
        .Font.Size = 14
        .Font.bold = True
      End With
    End If
    MsgBox FMT2("Scan_20", errnr, errdesc)
  Else
    If Beenden Then
      ' "Abgebrochen"
      XLScriptAddSimpleVar "SCANRESULT", FMT0("Scan_25")
    Else
      'XLScriptAddSimpleVar "SCANRESULT", IIf(ChangedWorksheets.Count > 0 Or foundDeletedOrAddedWorkseehts = True, "Ver|fffd|ndert", "Identisch")
      XLScriptAddSimpleVar "SCANRESULT", IIf(G_ChangedWorkbook, FMT0("Scan_21"), FMT0("Scan_22"))
    End If
  
    If Not theResultWB Is Nothing Then
      With theResultWB.Worksheets(1).Cells(G_Endresult_Y, G_Endresult_X + 1)
        If Beenden Then
          ' "Abgebrochen"
          .value = FMT0("Scan_25")
          .Font.Color = RGB(255, 20, 20)
          .Font.bold = True
        Else
          .value = IIf(G_ChangedWorkbook, FMT0("Scan_21"), FMT0("Scan_22"))
          If G_ChangedWorkbook Then
            .Font.Color = RGB(255, 20, 20)
            .Font.bold = True
          End If
        End If
        .Font.Size = 14
        .Font.bold = True
      End With
    End If
  End If
    
  Set ChangedWorksheets = Nothing
  
  If Not wb1 Is Nothing Then
    wb1.Close False
  End If
  If Not wb2 Is Nothing Then
    wb2.Close False
  End If
  
  'AddStatus "Erzeuge Ergebnisse"
  AddStatus FMT0("Scan_23")

  If Not theResultWB Is Nothing Then
    For Each ws In theResultWB.Worksheets
      If Left(ws.name, 1) <> "_" Then
        'UpdateStatus "Generiere Ergenbisbl|fffd|tter (" & ws.name & ")"
        UpdateStatus FMT1("Scan_24", ws.name)
        XLScriptInit ws, "EFC"
        XLScriptExecCode ws.Cells
        XLScriptExit
        ws.Cells(1, 1).Select
      End If
    Next ws
  End If
  
  If Beenden = True Then
    'XLScriptAddSimpleVar "SCANSTATUS", "Abgebrochen"
    XLScriptAddSimpleVar "SCANSTATUS", FMT0("Scan_25")
  Else
    XLScriptAddSimpleVar "SCANSTATUS", FMT0("Scan_26")
  End If
  XLScriptAddSimpleVar "ENDOFSCAN", Now
  
  If G_CheckAll Then
    'XLScriptAddSimpleVar "SCANSHEETS", "Alle"
    XLScriptAddSimpleVar "SCANSHEETS", FMT0("Scan_27")
  Else
    Dim ts As String
    If G_SelectedSheets.Count > 0 Then
      For I = 1 To G_SelectedSheets.Count
        If Len(ts) > 0 Then
          ts = ts & ", '" & G_SelectedSheets(I) & "'"
        Else
          ts = "''" & G_SelectedSheets(I) & "'"
        End If
      Next I
    End If
    XLScriptAddSimpleVar "SCANSHEETS", ts
  End If
  
  
  If Not theResultWB Is Nothing Then
    For Each ws In theResultWB.Worksheets
      If Left(ws.name, 1) <> "_" Then
        XLScriptInit ws, "EFCE"
        XLScriptExecCode ws.Cells
        XLScriptCleanUpTags ws.Cells
        XLScriptExit
      End If
    Next ws
  End If
 
  app.visible = True
  app.ScreenUpdating = True
  app.Calculation = xlCalculationAutomatic
  app.EnableEvents = True

  XLScriptExitGlobals

'  CheckFunktionen tString, True, EinzelMappe
  
  If Not theResultWB Is Nothing Then
    theResultWB.Worksheets(1).Activate
    theResultWB.Worksheets(1).Cells(1, 1).Activate
'    theResultWB.Worksheets(1).Protect "GagaLulu"
  End If
  
cleanUp:
  FreeAllMem
  
  ThisWorkbook.Saved = True

  StatusForm.Hide

  If G_QuickstartMode = True Then
  
    'If MsgBox("F|fffd|r die Analyse wurde tempor|fffd|r die Datei '" & GetSetting(appName:="Stromwerken", Section:=progNameShort, Key:="Datei1", Default:="") & _
    '  "' erzeugt. Soll die tempor|fffd|re Datei gel|fffd|scht werden (JA), oder m|fffd|chten Sie die Datei f|fffd|r weitere Analysen zur Einsicht behalten (NEIN)? Falls die Datei nicht gel|fffd|scht wird, sollten Sie nach Abschluss der Analysen die tempor|fffd|re Datei manuell l|fffd|schen." & vbCrLf & vbCrLf & "Soll die tempor|fffd|re Vergleichsdatei gel|fffd|scht werden?", vbYesNo) = vbYes Then
'    If MsgBox(FMT1("Scan_28", G_File1), vbYesNo) = vbYes Then
'      MyKill G_File1
'    End If
    ThisWorkbook.Close False
    Application.Quit
  End If
  
  If G_CreateResfile = 4 And G_Resfile <> "" Then
    theResultWB.Save
    theResultWB.Close False
    Set theResultWB = Nothing
    Set app = Nothing
    Application.Quit
  End If
  
  
  If 1 = 2 Then
      Dim ts2 As String
      ts2 = GetSetting( _
        appname:="Stromwerken", _
        Section:=progNameShort, _
        Key:="ResultFileDate", Default:="")
    
    
    SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOneWarning", setting:="True"
    theResultWB.SaveAs G_cfgTemppfad & "\VersionCompare-" & GetUserName & "." & ts2 & ".xls"
    SaveSetting appname:="Stromwerken", Section:="ExcelTracker", Key:="IgnoreThisOneWarning", setting:=""
    theResultWB.Close False
    Set theResultWB = Nothing
    Set app = Nothing
    Application.Quit
  End If
End Sub



Sub InitStatus()
  LastProgText = ""
  ProgText = ""
  StatusForm.ProgressTxt.Caption = "0 %"
  StatusForm.ProgressB.Width = 1

End Sub

Sub AddStatus(txt As String, Optional col As Long = 196)
  LastProgText = ProgText
  If Len(ProgText) > 0 Then
    ProgText = ProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
  StatusForm.ProgText = ProgText
  StatusForm.Repaint
  StatusForm.ProgText.SelStart = Len(ProgText)
  WriteTimeStamp
  DoEvents
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt, col
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus), col

'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "SSTATUS", txt
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "CURSTATUS", CStr(CurrentStatus)

End Sub

Function GetFileSub(Filename As String, ByRef oxlwbook As Excel.Workbook) As Boolean
  On Error GoTo nogo
  Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
  GetFileSub = True
  Exit Function
nogo:
End Function

Function GetFile(Filename As String, ByRef oxlwbook As Excel.Workbook, ByVal pw As String) As Boolean
  Dim msgBoxText As String
  
  GetFile = True
  ' |fffd|ffnen der Datei - Bei Error auf Passwort pr|fffd|fen
  On Error GoTo hatPasswort
  
  BitteWarten.BitteWartenText.Caption = FMT0("ETDLL_29")
  BitteWarten.Label1.Caption = ""
  BitteWarten.Show vbModeless
  DoEvents
  Application.visible = False
  
  Dim oldenev As Boolean
  oldenev = Application.EnableEvents
  Application.EnableEvents = False
  Dim oldalert As Boolean
  oldalert = ThisWorkbook.Application.DisplayAlerts
  ThisWorkbook.Application.DisplayAlerts = False
  ThisWorkbook.Application.AskToUpdateLinks = False
  Dim oldAutomation As Long
  oldAutomation = ThisWorkbook.Application.AutomationSecurity
  ThisWorkbook.Application.AutomationSecurity = msoAutomationSecurityLow

'  If UCase(right(Filename, 5)) = ".XLSX" Then
'    GetFile = False
'    Exit Function
'  End If
  
'  SetLiveStatusFunc "WorkbooksOpen", True
'  SetLiveStatus
  
  If Not G_QuickstartMode Then
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , , , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
  Else
'        If Application.Version = "12.0" Or Application.Version = "13.0" Then
          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , IIf(pw = "", "Testpasswort", pw), , True, , , IIf(UCase(Right(Filename, 5)) = ".XLTX", True, IIf(UCase(Right(Filename, 4)) = ".XLT", True, False)), False, , False)
'        Else
'          Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(ShortFileName(Filename), False, True, , "Testpasswort", , True, , , IIf(UCase(Right(Filename, 4)) = ".XLT", True, False), False, , False)
'        End If
  End If
  
  
secondOpenOk:
  ThisWorkbook.Application.AutomationSecurity = oldAutomation
    
  ThisWorkbook.Application.AskToUpdateLinks = True
  ThisWorkbook.Application.DisplayAlerts = oldalert
  Application.EnableEvents = oldenev
  BitteWarten.Hide
  Application.visible = True
  GoTo openOk
  
hatPasswort:

  If pw <> "" Then
    If GetFileSub(Filename, oxlwbook) Then
      GoTo secondOpenOk
    End If
  End If

  
  BitteWarten.Hide
  Application.visible = True

  MsgBox FMT1("Scan_29", Err.Description)
    
    On Error GoTo 0
    
    ThisWorkbook.Application.AutomationSecurity = oldAutomation
    ThisWorkbook.Application.AskToUpdateLinks = True
    ThisWorkbook.Application.DisplayAlerts = oldalert
    Application.EnableEvents = oldenev
    
    GetFile = False
    Exit Function

openOk:
  ' On Error wieder zur|fffd|cksetzen
  On Error GoTo 0
      
  ' 3.4.03 - Nt
  ' Wenn das Projekt gesch|fffd|tzt ist, muss ein gesonderter Warnvermerk ausgegeben werden!
  VBAFailure = 0
  On Error GoTo CheckNewerVersion
  
'  If Not CheckVBAAccessAllowed() Then
'  End If
  
  
  If oxlwbook.VBProject.Protection = 1 Then ' vbext_pp_locked
      VBAFailure = 1
    
    
Debug.Print "XXX Hier muss noch der VBA-Test rein"
'    If Len(EinzelMappe) > 0 Then
'      msgBoxText = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'      MsgBox msgBoxText
'    Else
        ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'        Workbooks(massenmappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, 2).Value = "Das VBA-Projekt ist gesch|fffd|tzt, bitte entfernen Sie den Schutz zuerst."
'    End If
'    oXLWBook.Close False
'    Exit Sub
  End If
  GoTo continueCheck

CheckNewerVersion:
Debug.Print "XXX Hier muss noch der VBA-Test raus"
  On Error GoTo 0
'  If Len(EinzelMappe) > 0 And Len(MassenMappe) = 0 Then
'    msgBoxText = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'    MsgBox msgBoxText
'  End If
'  If Len(MassenMappe) > 0 Then
    ' Ansonsten wird nur beim Status eingetragen, dass die Datei gesch|fffd|tzt ist
'    Workbooks(MassenMappe).Sheets(Texte(GSprache, TXT_ANS_MASSENANALYSE)).Cells(line, tabxM2).Value = Texte(GSprache, TXT_VBAPR|fffd|FUNG)
'  End If
  VBAFailure = 2
  
continueCheck:

End Function




Function GetFileOLD(Filename As String, ByRef oxlwbook As Excel.Workbook) As Boolean
  
  GetFileOLD = True
  ' |fffd|ffnen der Datei - Bei Error auf Passwort pr|fffd|fen
  On Error GoTo hatPasswort
  Dim oldenev As Boolean
  oldenev = ThisWorkbook.Application.EnableEvents
  ThisWorkbook.Application.EnableEvents = False
  
  Dim loaded As Boolean
  If G_DBType > 0 Then
    Dim dateiGeoeffnet As Boolean
    Dim conn As Object
    Set conn = GetConnection()
    If Not conn Is Nothing Then
        BitteWarten.BitteWartenText.Caption = FMT0("ETDLL_29")
        BitteWarten.Label1.Caption = ""
        BitteWarten.Show vbModeless
        DoEvents
        Application.visible = False
        If DateiOeffnenMitPW(conn, Application, Filename, GetStandardPassword()) = True Then
            Set oxlwbook = GetWorkbookByFilename(Application, Filename)
            If Not oxlwbook Is Nothing Then
              loaded = True
            End If
        End If
        BitteWarten.Hide
        Application.visible = True
    End If
  End If
  
  If Not loaded Then
    Set oxlwbook = ThisWorkbook.Application.Workbooks.Open(Filename, False, True, , , , True, , , True, False, , False)
  End If
  ThisWorkbook.Application.EnableEvents = oldenev
  GoTo openOk
  
hatPasswort:
  ThisWorkbook.Application.EnableEvents = oldenev

  ' Sollte die Datei ein Passwort haben, dann geben wir einen enstprechenden Text aus
  'msgBoxText = "Die Datei konnte nicht ge|fffd|ffnet werden." & vbCrLf & _
  '    "Bitte beachten Sie hierzu den folgenden Fehlertext!" & vbCrLf & Err.Description
  MsgBox FMT1("Scan_29", Err.Description)
  On Error GoTo 0
  
  GetFileOLD = False
  Exit Function


openOk:
  ' On Error wieder zur|fffd|cksetzen
  On Error GoTo 0
      


Exit Function
      
      
  ' 3.4.03 - Nt
  ' Wenn das Projekt gesch|fffd|tzt ist, muss ein gesonderter Warnvermerk ausgegeben werden!
  VBAFailure = 0
  On Error GoTo CheckNewerVersion
  
'  If Not CheckVBAAccessAllowed() Then
'  End If
  
  
  If oxlwbook.VBProject.Protection = 1 Then ' vbext_pp_locked
      VBAFailure = 1
  End If
  GoTo continueCheck

CheckNewerVersion:
  On Error GoTo 0
    MsgBox FMT0("Scan_30")
  VBAFailure = 2
  
continueCheck:

End Function

Function IsChar(t As String) As Boolean
    IsChar = False
    If (t >= "A" And t <= "Z") Or (t >= "a" And t <= "z") Then IsChar = True
End Function
Function IsCharOrNumber(t As String) As Boolean
    IsCharOrNumber = False
    If (t >= "A" And t <= "Z") Or (t >= "a" And t <= "z") Or IsNumeric(t) Then IsCharOrNumber = True
End Function

Sub CrackSheet(oxlwsheet)
  On Error Resume Next
  oxlwsheet.Protect "", userinterfaceonly:=True
  CrackSheet2 (oxlwsheet)
End Sub
Sub CrackSheet2(oxlwsheet)
  On Error Resume Next
  oxlwsheet.[a1].Copy oxlwsheet.[a1]
  oxlwsheet.[B1].Copy oxlwsheet.[B1]
  oxlwsheet.[a2].Copy oxlwsheet.[a2]
  oxlwsheet.[A3].Copy oxlwsheet.[A3]
  oxlwsheet.[AA2].Copy oxlwsheet.[AA2]
End Sub


Sub UpdateStatus(txt As String)
  If Len(LastProgText) > 0 Then
    ProgText = LastProgText & vbCrLf & txt
  Else
    ProgText = txt
  End If
'  If cfgProgressVisible = 1 Then
    StatusForm.ProgText = ProgText
    StatusForm.Repaint
    StatusForm.ProgText.SelStart = Len(ProgText)
'    StatusForm.ProgText.CurLine = 10000
'  Else
'    SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "STATUS", ProgText
'  End If
  WriteTimeStamp
  DoEvents
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 2, txt
'  WriteToSheet cfgMappenname, Texte(GSprache, TXT_ANS_MASSENANALYSE), TheMassAnalysisY, 3, CStr(CurrentStatus)
  
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "SSTATUS", txt
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "CURSTATUS", CStr(CurrentStatus)
End Sub

Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore As Boolean
  
  inIgnore = False
  
  For txtPos = 1 To Len(txt)
    If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
      If Not inIgnore Then
        inIgnore = True
      Else
        inIgnore = False
      End If
    End If
    
    If Not inIgnore Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function




Function MyReplace2(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim ok As Boolean
  txtPos = 1
  Do
    txtPos = InStr(txtPos, txt, searchtxt)
    If txtPos > 0 Then
      ok = True
      Dim tval As String
      If checkStartAndEnd Then
        If txtPos > 1 Then
          tval = Mid(txt, txtPos - 1, 1)
          If (tval >= "a" And tval <= "z") Or _
             (tval >= "A" And tval <= "Z") Or _
             (tval >= "0" And tval <= "9") Or _
             tval = "_" Then
              ok = False
          End If
        End If
        If txtPos + Len(searchtxt) <= Len(txt) Then
          tval = Mid(txt, txtPos + Len(searchtxt), 1)
          If (tval >= "a" And tval <= "z") Or _
             (tval >= "A" And tval <= "Z") Or _
             (tval >= "0" And tval <= "9") Or _
             tval = "_" Then
              ok = False
          End If
        End If
      End If
      If ok Then
          If txtPos - 1 > 0 Then
              tStringRep = Left(txt, txtPos - 1)
          Else
              tStringRep = ""
          End If
          tStringRep = tStringRep + replacetxt
          tStringRep = tStringRep + Mid(txt, txtPos + Len(searchtxt))
          txt = tStringRep
          txtPos = 1
      Else
        txtPos = txtPos + 1
      End If
    End If
  Loop While txtPos > 0 And txtPos < Len(txt)
  MyReplace2 = txt
End Function


Sub StripExcelSpecificStuff(ByRef tName As String)
  Dim tPos As Long
  tPos = InStr(tName, "[")
  If tPos > 0 Then
    Dim t As String
    If tPos > 1 Then
      t = Left(tName, tPos - 1)
    End If
    Dim tPosR As Long
    
    tPosR = InStr(tName, "]")
    If tPosR > 0 Then
      t = t + Mid(tName, tPos + 1, tPosR - tPos - 1)
      tName = t
    End If
  End If
  
End Sub

Public Sub WriteTimeStamp()
  On Error Resume Next
  ' Alle 30 Sekunden wird ein Timestamp gesetzt
  If LastTimeStamp + TimeValue("0:00:30") > Now Then Exit Sub
  LastTimeStamp = Now
'  SaveSetting "Stromwerken", "ECCEngine" & cfgSlotID, "TIMESTAMP", CStr(LastTimeStamp)

'  Open ThisWorkbook.Path & "\ECCEngineTimeStamp" & cfgSlotID & ".Cfg" For Output As #1
'  Write #1, LastTimeStamp
'  Close #1
End Sub

  



    
    
    
Function FindCell(c As Range, rng2 As Range) As Range
  Set FindCell = Nothing
  Dim r As Range
  For Each r In rng2
    If r.Address = c.Address Then
      Set FindCell = r
      Exit Function
    End If
  Next r
End Function




Sub PrintChangedSheets(ByRef wb As Workbook)
  On Error Resume Next
  wb.Windows(1).SelectedSheets.PrintOut Copies:=1, Collate:=True
End Sub




Function DiagramExists(ws As Object, n As String) As Boolean
  On Error GoTo nogo
  Dim d As Object
  Set d = ws.ChartObjects(n)
  Set d = Nothing
  DiagramExists = True
  Exit Function
nogo:
End Function

Function GetSeriesCollectionNames(ByRef col As SeriesCollection) As String
  If col Is Nothing Then Exit Function
  Dim s As Series
  Dim res As String
  For Each s In col
    If res <> "" Then
      res = res & ", " & s.name
    Else
      res = s.name
    End If
  Next s
  GetSeriesCollectionNames = res
End Function


Sub CompareDiagrams(ByRef ws1 As Object, ByRef ws2 As Object)
  
  If ws1.ChartObjects.Count = 0 And ws2.ChartObjects.Count = 0 Then Exit Sub
   
  Dim diagrammyUeberschrift As Long
  diagrammyUeberschrift = G_Result_Y
  Dim diagrammeChanged As Boolean
  Dim diagrammy As Long
  
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    '.value = "Diagramme:"
    .value = FMT0("Scan_31")
    .Font.Size = 12
    .Font.bold = True
  End With
  G_Result_Y = G_Result_Y + 1
      
   ' Diagramme betrachten
   Dim coitem As ChartObject
   Dim cgitem1 As ChartGroup
   Dim cgitem2 As ChartGroup
   
   If ws1.ChartObjects.Count > 0 Then
     For Each coitem In ws1.ChartObjects
     
     
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = coitem.name
      theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT0("Scan_22") ' Identisch
      diagrammy = G_Result_Y
      G_Result_Y = G_Result_Y + 1
     
     
      If Not DiagramExists(ws2, coitem.name) Then
        AddChangedSheet ws1
        'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "'" & coitem.name & " gel|fffd|scht"
        theResultWB.Worksheets(1).Cells(diagrammy, G_Result_X + 1).value = FMT1("Scan_32", coitem.name)
        theResultWB.Worksheets(1).Cells(diagrammy, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
        G_Result_Y = G_Result_Y + 1
        diagrammeChanged = True
      Else
           Dim cgcnt As Long
           
           If coitem.Chart.ChartGroups.Count <> ws2.ChartObjects(coitem.name).Chart.ChartGroups.Count Then
              AddChangedSheet ws1
              'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "'" & coitem.name & " Chartgruppen unterschiedlich"
              theResultWB.Worksheets(1).Cells(diagrammy, G_Result_X + 1).value = FMT1("Scan_33", coitem.name)
              theResultWB.Worksheets(1).Cells(diagrammy, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
              G_Result_Y = G_Result_Y + 1
              diagrammeChanged = True
           Else
                 For cgcnt = 1 To coitem.Chart.ChartGroups.Count
                   Set cgitem1 = coitem.Chart.ChartGroups(cgcnt)
                   Set cgitem2 = ws2.ChartObjects(coitem.name).Chart.ChartGroups(cgcnt)
                   
                   If Not CompareSeriesCollection(cgitem1, cgitem2, ws1, ws2, coitem.name) Then
                     diagrammeChanged = True
                     theResultWB.Worksheets(1).Cells(diagrammy, G_Result_X + 1).value = FMT0("Scan_21") ' Ver|fffd|ndert
                     theResultWB.Worksheets(1).Cells(diagrammy, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
                   End If
                Next cgcnt
            End If
        End If
     Next coitem
   End If


  If ws2.ChartObjects.Count > 0 Then
     For Each coitem In ws2.ChartObjects
      If Not DiagramExists(ws1, coitem.name) Then
        AddChangedSheet ws2
        'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "'" & coitem.name & " hinzugef|fffd|gt"
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT1("Scan_34", coitem.name)
        theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
        G_Result_Y = G_Result_Y + 1
        diagrammeChanged = True
      End If
    Next
  End If
  
  If diagrammeChanged Then
    theResultWB.Worksheets(1).Cells(diagrammyUeberschrift, G_Result_X).Font.Color = RGB(255, 20, 20)
  End If

End Sub


Sub CompareChart(ws1 As Object, wb2 As Object)
  
   If SheetExists(wb2, ws1.name, 3) = False And SheetExists(wb2, ws1.name, xlChart) = False And SheetExists(wb2, ws1.name, -4100) = False And SheetExists(wb2, ws1.name, -4102) = False Then Exit Sub
   
   Dim ws2 As Object
   Set ws2 = wb2.Sheets(ws1.name)
      
   ' Diagramme betrachten
   Dim coitem As ChartObject
   Dim cgitem1 As ChartGroup
   Dim cgitem2 As ChartGroup

   With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
     '.value = "Diagramm: " & ws1.name
     .value = FMT1("Scan_35", ws1.name)
     .Font.Size = 14
     .Font.bold = True
   End With
   Dim diagrammy As Long
   diagrammy = G_Result_Y
   G_Result_Y = G_Result_Y + 1

   If Not CompareSeriesCollection(ws1, ws2, ws1, ws2, ws1.name) Then
    theResultWB.Worksheets(1).Cells(diagrammy, G_Result_X).Font.Color = RGB(255, 20, 20)
   End If
End Sub


Function CompareSeriesCollection(ByRef cgitem1 As Object, ByRef cgitem2 As Object, ByRef ws1 As Object, ByRef ws2 As Object, coitemName As String) As Boolean
  Dim sccnt As Long
  Dim scitem1 As Series
  Dim scitem2 As Series
  
  CompareSeriesCollection = True

  If cgitem1.SeriesCollection.Count <> cgitem2.SeriesCollection.Count Then
     AddChangedSheet ws1
     'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "Datenreihe ver|fffd|ndert"
     theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT0("Scan_36")
     theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
     'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).value = "Alt: " & GetSeriesCollectionNames(cgitem1.SeriesCollection)
     theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).value = FMT1("Scan_37", GetSeriesCollectionNames(cgitem1.SeriesCollection))
     'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).value = "Neu: " & GetSeriesCollectionNames(cgitem2.SeriesCollection)
     theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).value = FMT1("Scan_38", GetSeriesCollectionNames(cgitem2.SeriesCollection))
     theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).Font.Color = RGB(255, 20, 20)
     theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).Font.Color = RGB(255, 20, 20)
     G_Result_Y = G_Result_Y + 1
     CompareSeriesCollection = False
  Else
          For sccnt = 1 To cgitem1.SeriesCollection.Count
            Set scitem1 = cgitem1.SeriesCollection(CLng(sccnt))
            Set scitem2 = cgitem2.SeriesCollection(CLng(sccnt))
            If IsReadableFormula(scitem1) = True And IsReadableFormula(scitem2) = False Then
                 AddChangedSheet ws1
                 'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "Datenreihe " & scCnt & " (neu) nicht lesbar"
                 theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT1("Scan_39", sccnt)
                 theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
                 G_Result_Y = G_Result_Y + 1
                 CompareSeriesCollection = False
            ElseIf IsReadableFormula(scitem1) = False And IsReadableFormula(scitem2) = True Then
                 AddChangedSheet ws1
                 'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "Datenreihe " & scCnt & " (alt) nicht lesbar"
                 theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT1("Scan_40", sccnt)
                 theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
                 G_Result_Y = G_Result_Y + 1
                 CompareSeriesCollection = False
            ElseIf IsReadableFormula(scitem1) = True And IsReadableFormula(scitem2) = True Then
                 If scitem1.formula <> scitem2.formula Then
                   AddChangedSheet ws1
                   'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "Datenreihe ver|fffd|ndert"
                   theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT0("Scan_36")
                   theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
                   'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).value = "Alt: " & scitem1.formula
                   theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).value = FMT1("Scan_37", scitem1.formula)
                   'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).value = "Neu: " & scitem2.formula
                   theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).value = FMT1("Scan_38", scitem2.formula)
                   theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).Font.Color = RGB(255, 20, 20)
                   theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).Font.Color = RGB(255, 20, 20)
                   G_Result_Y = G_Result_Y + 1
                   CompareSeriesCollection = False
                 End If
            End If
          Next sccnt
  End If
End Function



Function GetPivotText(var As String, ByRef pt As PivotTable)

On Error GoTo nogo

  Dim s As String
  Dim objPivotFld As Object
  Dim objCubeFld As CubeField
  Dim pivotForm As PivotFormula
  Select Case var
    
    Case "SourceData"
      s = pt.SourceData
    Case "PageFields"
        For Each objPivotFld In pt.PageFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "ColumnFields"
        For Each objPivotFld In pt.ColumnFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "RowFields"
        For Each objPivotFld In pt.RowFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "DataFields"
        For Each objPivotFld In pt.DataFields
            s = s & IIf(s <> "", ", ", "") & objPivotFld.name
        Next objPivotFld
    Case "CubeFields"
        For Each objCubeFld In pt.CubeFields
'            If objCubeFld.Orientation = xlDataField Then
                s = s & IIf(s <> "", ", ", "") & objCubeFld.name
'            End If
        Next objCubeFld
    Case "PivotFormulasLocal"
        For Each pivotForm In pt.PivotFormulas
             s = s & IIf(s <> "", vbCrLf, "") & pivotForm.formula
        Next pivotForm
    Case "PivotFormulas"
        For Each pivotForm In pt.PivotFormulas
             s = s & IIf(s <> "", vbCrLf, "") & pivotForm.StandardFormula
        Next pivotForm
  End Select
  If s <> "" Then
    GetPivotText = s
  Else
    GetPivotText = "-\-"
  End If
  Exit Function
nogo:
  GetPivotText = "-\-"

End Function

Function PivotExists(ws As Object, n As String) As Boolean
  On Error GoTo nogo
  Dim d As Object
  Set d = ws.PivotTables(n)
  Set d = Nothing
  PivotExists = True
  Exit Function
nogo:
End Function


Sub ShowChange(ByVal t As String, ByVal c1 As String, ByVal c2 As String)
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = t
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).value = c1
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 2).Font.Color = RGB(255, 20, 20)
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).value = c2
  theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 4).Font.Color = RGB(255, 20, 20)
  G_Result_Y = G_Result_Y + 1
   
End Sub


Sub ComparePivots(ByRef ws1 As Object, ByRef ws2 As Object)

  If ws1.PivotTables.Count = 0 And ws2.PivotTables.Count = 0 Then Exit Sub
   
  With theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X)
    '.value = "Diagramme:"
    .value = FMT0("Scan_56")
    .Font.Size = 12
    .Font.bold = True
  End With
  G_Result_Y = G_Result_Y + 1
  Dim pivotyUeberschrift As Long
  pivotyUeberschrift = G_Result_Y
      
  Dim pt As PivotTable
   
  Dim pivotsChanged As Boolean
  If ws1.PivotTables.Count > 0 Then
     For Each pt In ws1.PivotTables
          
          Dim thisPivotChanged As Boolean
          Dim pivoty As Long
          thisPivotChanged = False
          
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = pt.name
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT0("Scan_22") ' Identisch
          pivoty = G_Result_Y
          G_Result_Y = G_Result_Y + 1
          
          
          If Not PivotExists(ws2, pt.name) Then
            AddChangedSheet ws1
            'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "'" & coitem.name & " gel|fffd|scht"
            theResultWB.Worksheets(1).Cells(pivoty, G_Result_X + 1).value = FMT0("Scan_54")
            theResultWB.Worksheets(1).Cells(pivoty, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
            G_Result_Y = G_Result_Y + 1
            pivotsChanged = True
          Else
                Dim pt2 As PivotTable
                Set pt2 = ws2.PivotTables(pt.name)
                Dim s1 As String
                Dim s2 As String
                
                s1 = GetPivotText("SourceData", pt)
                s2 = GetPivotText("SourceData", pt2)
                If s1 <> s2 Then
                  ShowChange "Datenquelle ge|fffd|ndert", s1, s2
                  AddChangedSheet ws1
                  thisPivotChanged = True
                End If
                
                s1 = GetPivotText("PageFields", pt)
                s2 = GetPivotText("PageFields", pt2)
                If s1 <> s2 Then
                  ShowChange "Seitenfelder ge|fffd|ndert", s1, s2
                  AddChangedSheet ws1
                  thisPivotChanged = True
                End If
                
                s1 = GetPivotText("ColumnFields", pt)
                s2 = GetPivotText("ColumnFields", pt2)
                If s1 <> s2 Then
                  ShowChange "Spaltenfelder ge|fffd|ndert", s1, s2
                  AddChangedSheet ws1
                  thisPivotChanged = True
                End If
                
                s1 = GetPivotText("RowFields", pt)
                s2 = GetPivotText("RowFields", pt2)
                If s1 <> s2 Then
                  ShowChange "Zeilenfelder ge|fffd|ndert", s1, s2
                  AddChangedSheet ws1
                  thisPivotChanged = True
                End If
                
                s1 = GetPivotText("CubeFields", pt)
                s2 = GetPivotText("CubeFields", pt2)
                If s1 <> s2 Then
                  ShowChange "W|fffd|rfelfelder ge|fffd|ndert", s1, s2
                  AddChangedSheet ws1
                  thisPivotChanged = True
                End If
                
                s1 = GetPivotText("DataFields", pt)
                s2 = GetPivotText("DataFields", pt2)
                If s1 <> s2 Then
                  ShowChange "Datenfelder ge|fffd|ndert", s1, s2
                  AddChangedSheet ws1
                  thisPivotChanged = True
                End If
                
                s1 = GetPivotText("PivotFormulas", pt)
                s2 = GetPivotText("PivotFormulas", pt2)
                If s1 <> s2 Then
                  ShowChange "Pivotformeln ge|fffd|ndert", s1, s2
                  AddChangedSheet ws1
                  thisPivotChanged = True
                End If
                
            End If
            If thisPivotChanged Then
              theResultWB.Worksheets(1).Cells(pivoty, G_Result_X + 1) = FMT0("Scan_21") ' "Ver|fffd|ndert"
              theResultWB.Worksheets(1).Cells(pivoty, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
            End If
     Next pt
   End If


   If ws2.PivotTables.Count > 0 Then
     For Each pt In ws2.PivotTables
        If Not PivotExists(ws1, pt.name) Then
          AddChangedSheet ws2
          'theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X).value = "'" & coitem.name & " hinzugef|fffd|gt"
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).value = FMT0("Scan_55")
          theResultWB.Worksheets(1).Cells(G_Result_Y, G_Result_X + 1).Font.Color = RGB(255, 20, 20)
          G_Result_Y = G_Result_Y + 1
          pivotsChanged = True
        End If
      Next
    End If

  If pivotsChanged Then
    theResultWB.Worksheets(1).Cells(pivotyUeberschrift, G_Result_X).Font.Color = RGB(255, 20, 20)
  End If

End Sub

Sub SetLiveStatus()

  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatusTime", _
     setting:=Now
  
  SaveSetting _
     appname:="Stromwerken", _
     Section:=progNameShort, _
     Key:="LiveStatus", _
     setting:="Alive"

  NextTime = Now + TimeValue("00:10:00")
  Application.OnTime NextTime, "SetLiveStatus"
  
End Sub


Sub SetLiveStatusFunc(funcname As String, enab As Boolean)
  If enab Then
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="LiveStatusFunc", _
       setting:=funcname
  Else
    SaveSetting _
       appname:="Stromwerken", _
       Section:=progNameShort, _
       Key:="LiveStatusFunc", _
       setting:=""
  End If
End Sub



Sub CheckForET(ByRef app As Excel.Application)
On Error Resume Next
  Dim s As String
'  If WorkbookExists(ThisWorkbook.Application, "ExcelTracker.xlam") Then
'    s = "ExcelTracker.xlam"
'  ElseIf WorkbookExists(ThisWorkbook.Application, "ExcelTracker.xla") Then
'    s = "ExcelTracker.xla"
'  ElseIf WorkbookExists(ThisWorkbook.Application, "ExcelTracker.xlsm") Then
'    s = "ExcelTracker.xlsm"
'  End If
  
'  MsgBox s

  s = GetSetting(appname:="Stromwerken", Section:="ET", Key:="LoadET", Default:="")
  SaveSetting appname:="Stromwerken", Section:="ET", Key:="LoadET", setting:=""
  
  If s <> "" Then
    app.Workbooks.Open s, False, True, , , , True, , , , , , False
    app.Run "'" & s & "'!MyWorkbookOpen"
    app.Workbooks(GetFileNameAndExtension(s)).Saved = True
  End If
  
  Dim CurrAddin As Excel.AddIn
  Dim destAddin As Excel.AddIn

  For Each CurrAddin In Application.AddIns
      If CurrAddin.Installed Then
        For Each destAddin In app.AddIns
          If CurrAddin.FullName = destAddin.FullName Then
            destAddin.Installed = False
            destAddin.Installed = True
            Exit For
          End If
        Next destAddin
      End If
  Next CurrAddin
  
End Sub


Attribute VB_Name = "SheetSelect"
Attribute VB_Base = "0{72A0216D-308F-4EA9-AFB8-1C8301036F42}{405EB924-00EB-4408-9A28-CA25D66450D1}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub

Private Sub cmdAbbruch_Click()
  theSheetSelectOK = False
  Me.Hide
End Sub

Private Sub cmdOK_Click()
  theSheetSelectOK = True
  
  Dim I As Long
  If ListBox1.ListCount > 0 Then
    If Not ListItemsSelected(ListBox1) Then
      G_CheckAll = True
    Else
      For I = 1 To ListBox1.ListCount
        If ListBox1.Selected(I - 1) = True Then
          G_SelectedSheets.Add ListBox1.List(I - 1), ListBox1.List(I - 1)
        End If
      Next I
    End If
  End If
  Me.Hide
End Sub

Attribute VB_Name = "Start"
Option Explicit

Dim Startpath As String

Public G_PW1 As String
Public G_PW2 As String
Public G_File1 As String
Public G_File2 As String
Public G_Version1 As String
Public G_Version2 As String
Public G_DisplayName1 As String
Public G_DisplayName2 As String
Public G_FileDate1 As String

Public G_CreateResfile As Long
Public G_ResfileDestID As Long
Public G_ResfileTemplate As String
Public G_Resfile As String


Sub Auto_Open()

  G_MaxLeerzellen = 0
  G_ShowOnlyFormulas = True
  G_ShowVBADifferences = True


'SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", _
'  setting:="COMP /IDCALLER:" & SWAPPID_ExcelSheetChecker & _
'  " /FILE1:" & Chr(34) & "d:\development\Excel-File-Compare\Testfiles\EinfachNeu.xls" & Chr(34) & _
'  " /FILE2:" & Chr(34) & "d:\development\Excel-File-Compare\Testfiles\EinfachAlt.xls" & Chr(34) & _
'  " /PW1:" & Chr(34) & Chr(34) & _
'  " /PW2:" & Chr(34) & Chr(34) & _
'  " /DISPLAYNAME1:" & Chr(34) & "d:\development\Excel-File-Compare\Testfiles\EinfachNeu.xls" & Chr(34) & _
'  " /DISPLAYNAME2:" & Chr(34) & "EinfachAlt.xls" & Chr(34) & _
'  " /VERSION1:" & Chr(34) & "2.0" & Chr(34) & _
'  " /VERSION2:" & Chr(34) & "1.0" & Chr(34) & _
'  " /LEERZELLEN:0" & _
'  " /NURFORMELN:1" & _
'  " /VBADIFF:1"

' SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", _
'   setting:="COMPQUICK /IDCALLER:" & SWAPPID_ExcelSheetChecker & _
'   " /FILE1:" & Chr(34) & "d:\development\Excel-File-Compare\Testfiles\EinfachNeu.xls" & Chr(34) & _
'   " /FILE2:" & Chr(34) & "d:\development\Excel-File-Compare\Testfiles\EinfachAlt.xls" & Chr(34) & _
'   " /PW1:" & Chr(34) & Chr(34) & _
'   " /PW2:" & Chr(34) & Chr(34) & _
'   " /DISPLAYNAME1:" & Chr(34) & "d:\development\Excel-File-Compare\Testfiles\EinfachNeu.xls" & Chr(34) & _
'   " /DISPLAYNAME2:" & Chr(34) & "EinfachAlt.xls" & Chr(34) & _
'   " /VERSION1:" & Chr(34) & "2.0" & Chr(34) & _
'   " /VERSION2:" & Chr(34) & "1.0" & Chr(34) & _
'   " /FILEDATE1:" & Chr(34) & Now & Chr(34)

  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="ProcessID", setting:=GetCurrentProcessId
  SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:=progNameShort & "ScanFinished", setting:="0"

  G_PW1 = GetSetting(appname:="Stromwerken", Section:="EFC", Key:="PW1", Default:="")
  G_PW2 = GetSetting(appname:="Stromwerken", Section:="EFC", Key:="PW2", Default:="")
  
  SaveSetting appname:="Stromwerken", Section:="EFC", Key:="PW1", setting:=""
  SaveSetting appname:="Stromwerken", Section:="EFC", Key:="PW2", setting:=""

  SetLiveStatus

'  If C_CheckForLibs Then
'    If Not InitSWLib("SWFuncs") Then Exit Sub
'    If Not InitSWLib("XLScriptEngine") Then Exit Sub
'  End If
    
  Startpath = ThisWorkbook.path
  
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Path", setting:=Startpath
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Version", setting:=myVersion
  SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="InternalVersion", setting:=MyInternalVersion
  
  Set G_conn = Nothing

  Dim commandString As String
  Dim appc As New CAppCommand
  Dim errString As String
  
  commandString = GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", Default:="")
  
  Dim errstr As String
  
  ' MsgBox "COMMAND: " & commandString
  If commandString <> "" Then
    DebugPrint tinfo, "Command String: " & commandString
    SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="COMMAND", setting:=""
    appc.Init commandString
    Select Case appc.m_Command
      
      Case "COMP", "COMPQUICK"
        appc.AddParameter vbInteger, "/IDCALLER:", False
        appc.AddParameter vbString, "/FILE1:", False
        appc.AddParameter vbString, "/FILE2:", False
        appc.AddParameter vbString, "/DISPLAYNAME1:", False
        appc.AddParameter vbString, "/DISPLAYNAME2:", False
        appc.AddParameter vbString, "/VERSION1:", False
        appc.AddParameter vbString, "/VERSION2:", False
        appc.AddParameter vbString, "/PW1:", False
        appc.AddParameter vbString, "/PW2:", False
        appc.AddParameter vbString, "/FILEDATE1:", True
        
        If appc.m_Command = "COMP" Then
          appc.AddParameter vbInteger, "/LEERZELLEN:", True
          appc.AddParameter vbInteger, "/NURFORMELN:", True
          appc.AddParameter vbInteger, "/VBADIFF:", True
          
          appc.AddParameter vbInteger, "/RES:", True
          appc.AddParameter vbInteger, "/DESTID:", True
          appc.AddParameter vbString, "/RESTEMPLATE:", True
          appc.AddParameter vbString, "/RESFILE:", True
        End If
        
        appc.CheckValues errString
        If errString = "" Then
          AR_StartedByApp = Val(appc.GetValue("/IDCALLER:"))
          G_File1 = appc.GetValue("/FILE1:")
          G_File2 = appc.GetValue("/FILE2:")
          G_DisplayName1 = appc.GetValue("/DISPLAYNAME1:")
          G_DisplayName2 = appc.GetValue("/DISPLAYNAME2:")
          G_Version1 = appc.GetValue("/VERSION1:")
          G_Version2 = appc.GetValue("/VERSION2:")
          G_PW1 = appc.GetValue("/PW1:")
          G_PW2 = appc.GetValue("/PW2:")
          G_FileDate1 = appc.GetValue("/FILEDATE1:")
        
          If appc.m_Command = "COMP" Then
            If appc.ParameterExists("/LEERZELLEN:") Then G_MaxLeerzellen = Val(appc.GetValue("/LEERZELLEN:"))
            If appc.ParameterExists("/NURFORMELN:") Then G_ShowOnlyFormulas = appc.GetValue("/NURFORMELN:") > 0
            If appc.ParameterExists("/VBADIFF:") Then G_ShowVBADifferences = appc.GetValue("/VBADIFF:") > 0
          
            G_CreateResfile = Val(appc.GetValue("/RES:")) ' 1 Save in Command. 2 Just open, don't save. 3 Save in ZusDateien. 4 Save in RESFILE
            G_ResfileDestID = Val(appc.GetValue("/DESTID:"))
            G_ResfileTemplate = appc.GetValue("/RESTEMPLATE:")
            G_Resfile = appc.GetValue("/RESFILE:")
          End If
        
        End If
    End Select
  End If
  
  StartupInit progNameShort
  
  ' ------------------------------------------------------------------------------
  ' Commands
  ' ------------------------------------------------------------------------------
  If commandString <> "" Then
    If errString <> "" Then
      errString = errString & " (|fffd|bergebener Command-String: " & commandString & ")"
      LogPrint errString
      ' LogPrintECCSCanLog 0, 9, errString, True
      If AR_StartedByApp <> SWAPPID_IDVSuiteScheduler Then
        MsgBox errString, vbCritical, progNameShort & " V" & myVersion
      End If
      ThisWorkbook.Saved = True
      Application.Quit
      Exit Sub
    End If
  
    ' Ab hier werden die einzelnen Kommandos ausgef|fffd|hrt
    If AR_UseDB Then
      LogPrint "CheckConnection"
      Set G_conn = GetConnection()
      
      If G_conn Is Nothing Then
        ' LogPrintECCSCanLog 0, 9, "Keine DB-Connection vorhanden", True
        If AR_StartedByApp <> SWAPPID_IDVSuiteScheduler Then
'          If theTrackerFreigabe Then
            'MsgBox "Eine Freigabe ist kann nicht durchgef|fffd|hrt werden, da das Datenbanksystem nicht erreichbar ist.", vbCritical
'            MsgBox FMT0("START_1"), vbCritical
'          End If
        End If
        ThisWorkbook.Saved = True
        Application.EnableEvents = True
        Application.Quit
        Exit Sub
      Else
        LogPrint "1. Connect erfolgreich"
      End If
    
    End If
  
    ' ------------------------------------------------------------------------------
    ' Command Execution
    ' ------------------------------------------------------------------------------
    Dim rs
    Select Case appc.m_Command
      
      Case "COMP"
        ShowStatusForm
        DoCompare G_File1, G_File2, G_Version1, G_Version2, G_DisplayName1, G_DisplayName2, G_PW1, G_PW2, False, False
        SaveSetting appname:="Stromwerken", Section:="IDVSS", Key:=progNameShort & "ScanFinished", setting:="1"
      
      Case "COMPQUICK"
        ExcelFileCompareShowQuickMenu
      
      Case Else
        LogPrint "Unknown Command: " & commandString
        ' LogPrintECCSCanLog 0, 9, "Unknown Command: " & commandString, True
        If IsTestUser Then
          MsgBox "Unknown Command: " & commandString
        End If
        If Not G_conn Is Nothing Then
          G_conn.Close
          Set G_conn = Nothing
        End If
        ThisWorkbook.Saved = True
        Application.EnableEvents = True
        Application.Quit
    End Select
    Exit Sub
  End If
  
  Dim found As Boolean
  Dim c
  For Each c In Application.CommandBars("Worksheet Menu Bar").Controls
      If c.Caption = "EFC" Then
          Application.CommandBars("Worksheet Menu Bar").Controls("EFC").Delete
          Exit For
      End If
  Next c
  
  Dim cbb As CommandBarPopup
  Dim scbb As CommandBarButton
  
  Set cbb = Application.CommandBars("Worksheet Menu Bar").Controls.Add(Type:=msoControlPopup)
  
  cbb.Caption = progNameShort
  Set scbb = cbb.Controls.Add
  scbb.BeginGroup = False
  scbb.Style = msoButtonCaption
  'scbb.Caption = "Start"
  scbb.Caption = FMT0("Start_2")
  scbb.OnAction = "auto_open"
  'scbb.TooltipText = "Startet EFC"
  scbb.TooltipText = FMT0("Start_3")
  
  Set scbb = cbb.Controls.Add
  scbb.BeginGroup = False
  scbb.Style = msoButtonCaption
  'scbb.Caption = "Aus Men|fffd| entfernen"
  scbb.Caption = FMT0("Start_4")
  scbb.OnAction = "ExcelFileCompareRemoveMenu"
  'scbb.TooltipText = "Entfernt EFC"
  scbb.TooltipText = FMT0("Start_5")
  
  Set scbb = cbb.Controls.Add
  scbb.BeginGroup = False
  scbb.Style = msoButtonCaption
  'scbb.Caption = "Dokumentation"
  scbb.Caption = FMT0("Start_6")
  scbb.OnAction = "EFCShowDoku"
  'scbb.DescriptionText = "Zeigt die Dokumentation des Programms an."
  scbb.DescriptionText = FMT0("Start_7")
  
  If UCase(ThisWorkbook.name) = UCase(ProgNameLong) & ".XLS" Or UCase(ThisWorkbook.name) = UCase(ProgNameLong) & ".XLA" Then
      ExcelFileCompareShowMainMenu
  End If
End Sub

Sub Auto_Close()
    On Error Resume Next
'    Application.CommandBars("Worksheet Menu Bar").Controls(ProgNameLong).Delete
End Sub

Public Sub GetData()
  On Error GoTo noData
  FullVersion = False
  
  G_Lizenzen = -3
  G_EFCPro = False
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Or FileExists(ThisWorkbook.path & "\..\swres.swk") Then
    Dim ff As Long
    ff = FreeFile
    Dim s As String
    
    s = GetSWResItem(1000, ff)
    If InStr(s, "EFC,") > 0 Or InStr(s, "EFCPRO,") > 0 Then
    
      If InStr(s, "EFCPRO,") > 0 Then
        G_EFCPro = True
      End If
    
      G_Lizenznehmer = GetSWResItem(2000, ff)
      G_LizenznehmerAdresse = GetSWResItem(2400, ff)
      G_MyLicencseVersion = Val(GetSWResItem(3600, ff))
      G_Lizenzen = Val(GetSWResItem(3700, ff))
      
      
'      s = GetSWResItem(3200, ff)
      s = ConvGermanDateKey(GetSWResItem(3800, ff))
      If Len(s) > 0 Then
        If IsDate(s) Then
          G_FullDemoBis = CDate(s)
        End If
      End If
      'G_Wartung = IIf(UCase(GetSWResItem(3900, ff)) = "JA", True, False)
      G_Wartung = IIf(IsYes(GetSWResItem(3900, ff)), True, False)
      
      If G_Wartung Then
        ' s = GetSWResItem(3400, ff)
        s = ConvGermanDateKey(GetSWResItem(4000, ff))
        If Len(s) > 0 Then
          If IsDate(s) Then
            G_WartungBis = CDate(s)
          End If
        End If
      End If
      
      FullVersion = True
      
      If G_Lizenzen = -1 Then
        'trs = "Full-Demo" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & G_LizenznehmerAdresse & vbCrLf & vbCrLf & "Einsatz nur zu Testzwecken!"
        trs = FMT2("Start_8", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo " & G_Lizenznehmer & " - Einsatz nur zu Testzwecken!"
        trsShrt = FMT1("Start_9", G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now < G_FullDemoBis Then
        'trs = "Full-Demo bis zum " & G_FullDemoBis & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("Start_10", G_FullDemoBis, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Full-Demo bis zum " & G_FullDemoBis & " - " & G_Lizenznehmer
        trsShrt = FMT2("Start_11", G_FullDemoBis, G_Lizenznehmer)
      ElseIf G_Lizenzen = 0 And Now >= G_FullDemoBis Then
        'trs = "Demoversion" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("Start_12", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Demoversion " & G_Lizenznehmer
        trsShrt = FMT1("Start_13", G_Lizenznehmer)
      ElseIf G_Lizenzen = -2 Then
        'trs = "Gesamthauslizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT2("Start_14", G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = "Gesamthauslizenz " & G_Lizenznehmer
        trsShrt = FMT1("Start_15", G_Lizenznehmer)
      ElseIf G_Lizenzen = 1 Then
        'trs = G_Lizenzen & " Lizenz" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("Start_16", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenz " & G_Lizenznehmer
        trsShrt = FMT2("Start_17", G_Lizenzen, G_Lizenznehmer)
      Else
        'trs = G_Lizenzen & " Lizenzen" & vbCrLf & vbCrLf & G_Lizenznehmer & vbCrLf & vbCrLf & G_LizenznehmerAdresse
        trs = FMT3("Start_18", G_Lizenzen, G_Lizenznehmer, G_LizenznehmerAdresse)
        'trsShrt = G_Lizenzen & "Lizenzen " & G_Lizenznehmer
        trsShrt = FMT2("Start_19", G_Lizenzen, G_Lizenznehmer)
      End If
      
      If G_Wartung Then
        If G_WartungBis <> DateSerial(1900, 1, 1) Then
          'trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, "Wartung bis: " & G_WartungBis & IIf(Now > G_WartungBis, " (ABGELAUFEN)", ""), "")
          trs = trs & vbCrLf & vbCrLf & IIf(G_WartungBis <> 0, FMT1("Start_20", G_WartungBis) & IIf(Now > G_WartungBis, FMT0("Start_22"), ""), "")
        End If
      End If
      
    End If
  End If
  
  Exit Sub
noData:
  Exit Sub
End Sub

Private Sub PrepareMenuStuff()
'  CheckVersion 0, progNameShort, progNameShort & "\SWUpdate" & progNameShort & ".txt", MyInternalVersion
    
  GetData
  
  CheckLicense
  
  If G_Wartung = True And Now > G_WartungBis Then
    If G_WartungBis < MyProgramReleaseDate = True And G_MyLicencseVersion < MyProgramLicenseVersion Then
      FullVersion = False
    End If
  Else
    If G_MyLicencseVersion < MyProgramLicenseVersion And FullVersion = True Then
      FullVersion = False
    End If
  End If
    
'  If Not CheckVBAAccessAllowed Then
'      MsgBox Texte(GSprache, TXT_EXCEL2000), vbCritical
'  End If

  If Len(Startpath) = 0 Then
      Startpath = ThisWorkbook.path
  End If

End Sub

Public Sub ExcelFileCompareShowQuickMenu()

  PrepareMenuStuff

  QuickStart.AdjacentColsAndRows = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="AdjacentColsAndRows", Default:=0)
  
  QuickStart.ShowOnlyFormulas = IIf(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="ShowOnlyFormulas", Default:=1) = 1, True, False)
  
  QuickStart.ShowVBADifferences = IIf(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="ShowVBADifferences", Default:=0) = 1, True, False)
      
  G_QuickstartMode = True
  ' Clear the auto-start flag!
  SaveSetting _
      appname:="Stromwerken", _
      Section:=progNameShort, _
      Key:="StartedByTracker", _
      setting:="False"
                     
  ' Application.OnTime Now + TimeValue("00:00:01"), "DoCompare"
  ' ShowStatusForm
  QuickStart.Vers.Caption = myVersion
  QuickStart.Cop = IIf(CLng(StartProgCopyright) = year(Now), FMT0("Main_15") & year(Now), FMT0("Main_15") & StartProgCopyright & " - " & year(Now)) & " Stromwerken"
  QuickStart.Show

End Sub

Sub LoadComboboxList(ByVal lst As Long, ByRef ctrl As ComboBox)
  ctrl.Clear
  Dim I As Long
  For I = 0 To 7
    If Trim(GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="Datei" & lst & "-" & I, Default:="")) <> "" Then
      ctrl.AddItem Trim(GetSetting(appname:="Stromwerken", Section:=progNameShort, Key:="Datei" & lst & "-" & I, Default:=""))
    End If
  Next I
End Sub


Sub AddFileToComboboxList(ByVal lst As Long, ByRef ctrl As ComboBox, ByVal newitemtext As String)
Static inChange As Boolean
If inChange Then Exit Sub

If Trim(newitemtext) = "" Then Exit Sub

inChange = True
  Dim I As Long
  If ctrl.ListCount > 0 Then
    For I = 0 To ctrl.ListCount - 1
      If ctrl.List(I) = newitemtext Then
        ctrl.RemoveItem I
        Exit For
      End If
    Next I
  End If
  
  
  If ctrl.ListCount <= 7 Then
    ctrl.AddItem ""
  End If
  For I = 6 To 0 Step -1
    If I < ctrl.ListCount - 1 Then
      ctrl.List(I + 1) = ctrl.List(I)
    End If
  Next I
  ctrl.List(0) = newitemtext
    
  For I = 0 To 7
    If I < ctrl.ListCount Then
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Datei" & lst & "-" & I, setting:=ctrl.List(I)
    Else
      SaveSetting appname:="Stromwerken", Section:=progNameShort, Key:="Datei" & lst & "-" & I, setting:=""
    End If
  Next I
inChange = False
End Sub


Public Sub ExcelFileCompareShowMainMenu()
  
  PrepareMenuStuff
  
  MainMenu.Vers.Caption = myVersion
  
  LoadComboboxList 1, MainMenu.Datei1
  MainMenu.Datei1 = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="Datei1", Default:="")
    
  LoadComboboxList 2, MainMenu.Datei2
  MainMenu.Datei2 = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="Datei2", Default:="")
  
  'MainMenu.Headline = ProgNameLong & IIf(FullVersion, IIf(G_EFCPro, " PRO", ""), " (DEMO)")
  MainMenu.Headline = ProgNameLong & IIf(FullVersion, IIf(G_EFCPro, FMT0("Globals_4"), ""), FMT0("Globals_5"))
  'MainMenu.Cop = IIf(CLng(StartProgCopyright) = year(Now), "Copyright |fffd|" & year(Now), "Copyright |fffd|" & StartProgCopyright & " - " & year(Now)) & " Stromwerken"
  MainMenu.Cop = IIf(CLng(StartProgCopyright) = year(Now), FMT0("Main_15") & year(Now), FMT0("Main_15") & StartProgCopyright & " - " & year(Now)) & " Stromwerken"
  
  MainMenu.AdjacentColsAndRows = GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="AdjacentColsAndRows", Default:=0)
  
  MainMenu.RoundNumbers = IIf(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="RoundNumbers", Default:=1) = 1, True, False)
    
  MainMenu.ShowOnlyFormulas = IIf(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="ShowOnlyFormulas", Default:=1) = 1, True, False)
  
  MainMenu.ShowVBADifferences = IIf(GetSetting( _
    appname:="Stromwerken", _
    Section:=progNameShort, _
    Key:="ShowVBADifferences", Default:=0) = 1, True, False)
  
  MainMenu.Show

End Sub

Sub ShowStatusForm()
  StatusForm.ProgressB.Width = 0
  StatusForm.ProgText = ""
  StatusForm.Show vbModeless
End Sub

Sub ExcelFileCompareRemoveMenu()
    On Error Resume Next
    'If MsgBox("Sind Sie sicher, dass Sie EFC aus der Men|fffd|leiste entfernen m|fffd|chten?", vbYesNo) = vbYes Then
    If MsgBox(FMT0("Start_22"), vbYesNo) = vbYes Then
        Application.CommandBars("Worksheet Menu Bar").Controls("EFC").Delete
        ThisWorkbook.Close
    End If
End Sub

Function GetSWResItem(ByVal pos As Long, ff As Long) As String
  Dim res As String
  
  If FileExists(G_cfgKeypfad & "\swres.swk") Then
    Open G_cfgKeypfad & "\swres.swk" For Binary Access Read As #ff ' Len = 4
  ElseIf FileExists(ThisWorkbook.path & "\..\swres.swk") Then
    Open ThisWorkbook.path & "\..\swres.swk" For Binary Access Read As #ff ' Len = 4
  End If
  
  Dim l As Long
  Get #ff, pos, l

  Dim charc As Long

  ' ENC2
  If l = 1 Then
    Get #ff, pos + 4, l
  
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    For charc = 1 To l
      Dim tchar As Byte
      Get #ff, pos + 7 + charc, tchar
      tchar = tchar Xor (1 + 2 + 4 + 16 + 64)
      res = res & Chr(tchar)
    Next charc
    Close ff
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  
  ' ENC3 - LZW
  ElseIf l = 2 Then
    Get #ff, pos + 4, l
  
  '  Close ff
  '  Open AktVerz & "\swres.swk" For Binary Access Read As #ff ' Len = 1
    Dim lval As Long
    Dim arr() As Long
    ReDim arr(l)
    
    For charc = 1 To l
      Get #ff, pos + 4 + charc * 4, lval
      arr(charc - 1) = lval
    Next charc
    Close ff
    
    Dim LZW As New LZW
    res = LZW.DecompressArray(l, arr)
    Set LZW = Nothing
    
    Do
      pos = InStr(res, "\n")
      If pos <= 0 Then Exit Do
      res = Left(res, pos - 1) & vbCrLf & Mid(res, pos + 2)
    Loop
    GetSWResItem = res
  End If
End Function


Sub CheckLicense()
  If G_Lizenzen = 0 And Now > G_FullDemoBis And G_QuickstartMode = False Then
    'MsgBox "Die Full-Demo f|fffd|r dieses Programm ist abgelaufen. Wenden Sie sich bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-File-Compare"
    MsgBox FMT0("Start_23"), vbCritical, "Excel-File-Compare"
    FullVersion = False
  End If
    
  If G_Wartung = True And Now > G_WartungBis Then
    If G_WartungBis < MyProgramReleaseDate = True And G_MyLicencseVersion < MyProgramLicenseVersion Then
      'MsgBox "Ihr Wartungsvertrag umfasst diese Programmversion nicht mehr. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-File-Compare"
      MsgBox FMT0("Start_24"), vbCritical, "Excel-File-Compare"
      FullVersion = False
    End If
  Else
    If G_MyLicencseVersion < MyProgramLicenseVersion And FullVersion = True Then
      'MsgBox "Ihr Lizenzkey f|fffd|r dieses Programm ist veraltet. Um diese Version nutzen zu k|fffd|nnen, ben|fffd|tigen Sie einen neuen Lizenzkey, wenden Sie sich hierzu bitte an info@stromwerken.de. Das Programm wird jetzt als Demoversion ausgef|fffd|hrt.", vbCritical, "Excel-File-Compare"
      MsgBox FMT0("Start_25"), vbCritical, "Excel-File-Compare"
      FullVersion = False
    End If
  End If
End Sub

Sub EFCShowDoku()
  OpenFileWithApp ThisWorkbook.path & "\Excel-File-Compare.pdf"
End Sub





Attribute VB_Name = "StartOff"
Attribute VB_Base = "0{5D86A5A8-EFAE-495A-9898-A26F684432B7}{FA51E8D5-1DE4-459B-A9A6-845A1EC2895E}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub

Private Sub CommandButton1_Click()
    Me.Hide
End Sub

Private Sub UserForm_Activate()
    TextBox1.SetFocus
    TextBox1.CurLine = 0
End Sub

Attribute VB_Name = "StatusForm"
Attribute VB_Base = "0{C0B98FB2-66C5-40D0-AAB7-DAFE5535E392}{0E067569-B79D-4E29-B843-DE0D434B226B}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub UserForm_Initialize()
    gTranslation.TranslateForm Me
End Sub

Private Sub cmdAbbrechen_Click()
  Beenden = True
End Sub

Attribute VB_Name = "Stepping"
Option Explicit

Public CurrentStepCount As Double
Public CurrentStepCountAmount As Long
Public CurrentStep As Long
Public TotalSteps As Long

Public PartialIncrease As Double
Public PartialIncreaseAmount As Double

Private BitteWartenIndex As Long
Private BitteWartenCnt As Long

Const BitteWartenAm As Long = 4
Const BitteWartenCntAm As Long = 50

Private CheckDelayTime As Date

Global Const C_ComplexTotalSteps = 7

Sub InitStepping()
  CurrentStep = 0
  UpdateStatusBar
End Sub

Sub NextStep(c As Long, txt As String)
  CurrentStep = CurrentStep + 1
  CurrentStepCount = 0
  CurrentStepCountAmount = c
'  UpdateStatus txt & " (Schritt " & CurrentStep & " von " & TotalSteps & ")"

End Sub

Sub EndStep(txt As String)
  UpdateStatus txt
  LastProgText = ProgText
End Sub
Sub SetStep(stp As Long)
  CurrentStep = stp
  CurrentStepCount = 0
  CurrentStepCountAmount = 0
  UpdateStatusBar
End Sub


Sub IncreaseCurrentStep()
  CurrentStepCount = CurrentStepCount + 1
  UpdateStatusBar
End Sub

Sub UpdateStatusBar()
  Dim pos As Double
  Dim csc As Long
  If CurrentStepCountAmount = 0 Then
    pos = CurrentStep / TotalSteps
    ' StatusForm.ProgressTxt.Caption = "0 %"
    ' StatusForm.ProgressB.Width = 1
    ' Exit Sub
  Else
    If CurrentStepCount > CurrentStepCountAmount Then
      csc = CurrentStepCountAmount
    Else
      csc = CurrentStepCount
    End If
    pos = csc / CurrentStepCountAmount / TotalSteps + (CurrentStep - 1) / TotalSteps
  End If
  If pos > 0 And pos < 1 Then
    
    If BitteWartenCnt > 200 Then
      If BitteWartenIndex < 1 Then
        BitteWartenIndex = 0
      End If
      BitteWartenIndex = BitteWartenIndex + 1
      If BitteWartenIndex > BitteWartenAm Then
        BitteWartenIndex = 1
      End If
      BitteWartenCnt = 0
    End If
    BitteWartenCnt = BitteWartenCnt + 1
    
    If BitteWartenIndex < 1 Then
        BitteWartenIndex = 1
    End If
    StatusForm.ProgressTxt.Caption = Format(pos, "PERCENT")
    StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width * pos
  Else
    StatusForm.ProgressTxt.Caption = "100 %"
    StatusForm.ProgressB.Width = StatusForm.ProgressTxt.Width
  End If
  DoEvents
End Sub

Sub ComplexCalculateTotalStepAmount(ByRef wb As Workbook)
  TotalSteps = C_ComplexTotalSteps * wb.Sheets.Count
End Sub


Sub PartialIncreaseCurrentStep()
  CurrentStepCount = CurrentStepCount + PartialIncrease
  UpdateStatusBar
End Sub

Sub CalcPartialIncrease(stps As Long)
  PartialIncrease = PartialIncreaseAmount / stps
End Sub

Sub EnablePartialIncrease(totalam As Double)
  PartialIncreaseAmount = totalam
  PartialIncrease = 0
End Sub

Sub DisablePartialIncrease()
  PartialIncrease = 0
End Sub

Sub ShowBitteWarten()

  BitteWartenCnt = BitteWartenCnt + 1
  If BitteWartenCnt < BitteWartenCntAm * 70 Then Exit Sub
  
  Dim A
  A = Array("\", "|", "/", "|")
  
  If BitteWartenIndex < 1 Then
    BitteWartenIndex = 0
  End If
  BitteWartenIndex = BitteWartenIndex + 1
  
  If BitteWartenIndex > BitteWartenAm Then
    BitteWartenIndex = 1
  End If
  
  'StatusForm.ProgressTxt.Caption = "Bitte warten..." & a(BitteWartenIndex - 1)
  StatusForm.ProgressTxt.Caption = FMT0("Stepping_1") & A(BitteWartenIndex - 1)
  DoEvents
  BitteWartenCnt = 0
  
End Sub

Sub CheckDelayInit()
  CheckDelayTime = Now
End Sub

Sub CheckDelay()
  BitteWartenCnt = BitteWartenCnt + 1
  If Now < DateAdd("s", 3, CheckDelayTime) Then Exit Sub
  If BitteWartenCnt < BitteWartenCntAm Then Exit Sub
  Dim A
  A = Array("\", "|", "/", "|")
  
  If BitteWartenIndex < 1 Then
    BitteWartenIndex = 0
  End If
  BitteWartenIndex = BitteWartenIndex + 1
  
  If BitteWartenIndex > BitteWartenAm Then
    BitteWartenIndex = 1
  End If
  
  'StatusForm.ProgressTxt.Caption = "Bitte warten..." & a(BitteWartenIndex - 1)
  StatusForm.ProgressTxt.Caption = FMT0("Stepping_1") & A(BitteWartenIndex - 1)
  DoEvents
  BitteWartenCnt = 0
End Sub

Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Control = "CommandButton1, 1, 0, MSForms, CommandButton"
Private Sub CommandButton1_Click()
  Auto_Open
End Sub
Attribute VB_Name = "Translation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

' ------------------------------------------------------------------
Private Const NoError = 0       'The Function call was successful

Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SISO639LANGNAME = &H59
Private Const LOCALE_SISO3166CTRYNAME = &H5A

#If VBA7 Then
    Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
          
    ' Caution:  If the user default locale is a custom locale, an application cannot accurately tag data
    ' with the value or exchange it. In this case, the application should use GetUserDefaultLocaleName
    ' (available starting with Windows Vista) in preference to GetUserDefaultLCID.
    Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    ' List of Language Identifier Constants and Strings:
    ' https://msdn.microsoft.com/library/dd318693.aspx
    Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long

    ' Available since Vista
    'GetUserDefaultUILanguage
    
#Else
    Private Declare Function WNetGetUser Lib "mpr.dll" _
          Alias "WNetGetUserA" (ByVal lpName As String, _
          ByVal lpUserName As String, lpnLength As Long) As Long
    
    Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
    
    Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" ( _
        ByVal Locale As Long, _
        ByVal LCType As Long, _
        ByVal lpLCData As String, _
        ByVal cchData As Long) As Long
    
#End If

' ------------------------------------------------------------------


' 0 = fallback language
Private mStringTables(2) As Collection
Private mLangIDs(2) As String
Private mCurrentUser As String


Public Property Get CurrentUser() As String
    CurrentUser = mCurrentUser
End Property


Private Sub Class_Initialize()
    mCurrentUser = GetTranslationUserName
End Sub

Public Function StartupInit(installRoot As String, app As String, Optional overrideLang As String = "") As Boolean
    On Error GoTo nogo
    ' User Language ermitteln (xy-uv)
    Dim lang As String
    If overrideLang <> "" Then
        lang = overrideLang
    Else
        'lang = GetUserLanguage
        ' Direkt das nehmen was Windows reportet
        lang = GetWindowsLanguageString
    End If
    
    
    Dim path As String
    Dim paths(1) As String
    Dim userPaths(1) As String
    
    Dim tries As Long
    For tries = 0 To 1
    
      paths(0) = installRoot & "\Translate\" & app & "_" & lang & ".txt"
      userPaths(0) = installRoot & "\Translate\" & app & "_" & lang & "_indiv.txt"
      
      paths(1) = installRoot & "\..\Translate\" & app & "_" & lang & ".txt"
      userPaths(1) = installRoot & "\..\Translate\" & app & "_" & lang & "_indiv.txt"
      
      Dim I As Long
      For I = 0 To UBound(paths)
          If Init(0, paths(I), lang) = True Then
              ' Und auch versuchen die user strings zu laden (falls es die gibt)
              StartupInit = True
          End If
          Init 1, userPaths(I), lang
      Next I
      
      ' Nix gefunden -> Fallback language setzen
      If Not StartupInit Then
      lang = GetFallbackLanguage(lang)
      Else
        Exit Function
      End If
    Next tries
    
nogo:
    StartupInit = False
End Function

Public Function Init(index As Long, path As String, langId As String) As Boolean
    Init = False
    If index >= UBound(mLangIDs) Then
        Exit Function
    End If
    
    mLangIDs(index) = UCase(langId)
    Dim c As Collection
    Set c = LoadStringTable(path)
    If c Is Nothing Then
        Exit Function
    End If
    Set mStringTables(index) = c
    Init = True
End Function

Public Sub Clear()
    Set mStringTables(0) = New Collection
    Set mStringTables(1) = New Collection
End Sub


Public Function GetLocalizedFile(path As String) As String
    Dim lang As String
    If UBound(mLangIDs) > 0 Then
        If mLangIDs(0) <> "" Then
            lang = mLangIDs(0)
        End If
    End If
    If lang = "" Then
        lang = GetWindowsLanguageString
    End If
    
    GetLocalizedFile = LocalizedFileExists(path, lang)
End Function

' Splitted path\filename.ext aus path
' Und sucht dann nach
' path\filename_lang.ext
' Wenn nix gefunden, wird lang mit einem fallback replaced.
' de-de fuer alles was de-xy
' en-gb fuer alles andere
' Oder halt den original path wenn es nichts davon gibt.
' Der gefundene pfad wird returned oder "" wenn es gar nix gibt.
Public Function LocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    LocalizedFileExists = path
    Dim newPath As String
    
    If lang <> "" Then
        ' Direkt nach der uebergebenen Sprache in lang suchen
        newPath = InternalLocalizedFileExists(path, lang)
        If newPath <> "" Then
            LocalizedFileExists = newPath
            Exit Function
        End If
        
        ' Nix gefunden -> fallback Sprache nehmen
        If Len(lang) > 2 Then
            ' Wenn es was deutsches ist, dann nach de-de suchen
            If UCase(lang) <> "DE-DEB" And InStr(UCase(lang), "DE") > 0 Then
                newPath = InternalLocalizedFileExists(path, "de-de")
                If newPath <> "" Then
                    LocalizedFileExists = newPath
                    Exit Function
                End If
            End If
        End If
        
        ' Bis hier hin nix gefunden -> nach "en-gb" suchen
        If UCase(lang) <> "DE-DE" Then
            newPath = InternalLocalizedFileExists(path, "en-gb")
            If newPath <> "" Then
                LocalizedFileExists = newPath
                Exit Function
            End If
        End If
    End If
    
nogo:
    If Not FileExists(LocalizedFileExists) Then
        LocalizedFileExists = ""
    End If
End Function

Private Function InternalLocalizedFileExists(path As String, lang As String) As String
    On Error GoTo nogo
    
    Dim newPath As String
    Dim p As String
    Dim Filename As String
    Dim ext As String
    fileSplit path, p, Filename, ext

    newPath = FmtInternal("%1%2_%3.%4", p, Filename, lang, ext)
    If newPath <> "" And FileExists(newPath) Then
        InternalLocalizedFileExists = newPath
        Exit Function
    End If
nogo:
End Function

Public Sub AddString(tableIdx As Long, id As String, s As String)
    mStringTables(tableIdx).Add s, id
End Sub

Public Function StringExists(id As String) As Boolean
    If id = "" Then
        StringExists = True
        Exit Function
    End If
    On Error GoTo nogo
    Dim s As String
    If CollectionStringExists(mStringTables(1), UCase(id)) Then
        StringExists = True
    ElseIf CollectionStringExists(mStringTables(0), UCase(id)) Then
        StringExists = True
    End If
    Exit Function
nogo:
    StringExists = False
End Function

Public Function GetString(id As String) As String
    On Error GoTo nogo
    If id = "" Then
        Exit Function
    End If
    
    If mStringTables(1) Is Nothing Then
        GetString = GetFallbackString(id)
        Exit Function
    End If
    GetString = mStringTables(1).item(UCase(id))
    Exit Function
nogo:
    GetString = GetFallbackString(id)
End Function

Public Function GetSafeString(ByVal id As String, Optional defaultVal As String = "") As String
    If StringExists(id) Then
        GetSafeString = GetString(id)
        Exit Function
    End If
    GetSafeString = defaultVal
End Function

Public Function GetSafeStringReplace(ByVal id As String, Optional defaultVal As String = "") As String
    If StringExists(id) Then
        GetSafeStringReplace = FMT0(id)
        Exit Function
    End If
    GetSafeStringReplace = defaultVal
End Function

Public Function GetFallbackString(id As String) As String
    On Error GoTo nogo
    If mStringTables(0) Is Nothing Then
        GetFallbackString = id & ": ***MISSING***"
        Exit Function
    End If
    
    GetFallbackString = mStringTables(0).item(UCase(id))
    Exit Function
nogo:
    GetFallbackString = id & ": ***MISSING***"
End Function

Public Function FormatString(FMT As String, _
                             Optional arg1 As String = vbNullChar, _
                             Optional arg2 As String = vbNullChar, _
                             Optional arg3 As String = vbNullChar, _
                             Optional arg4 As String = vbNullChar, _
                             Optional arg5 As String = vbNullChar, _
                             Optional arg6 As String = vbNullChar, _
                             Optional arg7 As String = vbNullChar, _
                             Optional arg8 As String = vbNullChar, _
                             Optional arg9 As String = vbNullChar _
                             ) As String
                             
    On Error GoTo nogo
    
    Dim argarray(8) As String
    If IsTestUser Then
        argarray(0) = arg1
        argarray(1) = arg2
        argarray(2) = arg3
        argarray(3) = arg4
        argarray(4) = arg5
        argarray(5) = arg6
        argarray(6) = arg7
        argarray(7) = arg8
        argarray(8) = arg9
        
        Dim I As Long
        ' Erstmal checken ob wir fuer jeden Placeholder einen Parameter uebergeben bekommen haben
        ' Hier koennte man auch IsMissing nehmen - aber dann muessen alle args vom Type Variant sein.
        For I = 1 To 9
            If InStr(FMT, "%" & I) > 0 Then
                If argarray(I - 1) = vbNullChar Then
                    MsgBox FMT & vbCrLf & vbCrLf & "ERROR in FormatString: No arg for %" & I, vbCritical
                    Exit Function
                End If
            End If
        Next I
    Else
        argarray(0) = IIf(arg1 = vbNullChar, "", arg1)
        argarray(1) = IIf(arg2 = vbNullChar, "", arg2)
        argarray(2) = IIf(arg3 = vbNullChar, "", arg3)
        argarray(3) = IIf(arg4 = vbNullChar, "", arg4)
        argarray(4) = IIf(arg5 = vbNullChar, "", arg5)
        argarray(5) = IIf(arg6 = vbNullChar, "", arg6)
        argarray(6) = IIf(arg7 = vbNullChar, "", arg7)
        argarray(7) = IIf(arg8 = vbNullChar, "", arg8)
        argarray(8) = IIf(arg9 = vbNullChar, "", arg9)
    End If
    
    Dim r As String
    r = FMT
    
    r = Replace(r, "%%", "%")
    r = Replace(r, "\n", vbCrLf)
    r = Replace(r, "\t", vbTab)
    
    For I = 1 To 9
        If Not argarray(I - 1) = vbNullChar Then
        r = Replace(r, "%" & I, argarray(I - 1))
        End If
    Next I
    
    FormatString = r
    Exit Function

nogo:
    FormatString = "ERROR " & FMT
End Function

#If TEST_BUILD = 1 Then
#Else
#End If

'Public Function FormatString(fmt As String, _
'                             Optional arg1 As String, _
'                             Optional arg2 As String, _
'                             Optional arg3 As String, _
'                             Optional arg4 As String, _
'                             Optional arg5 As String, _
'                             Optional arg6 As String, _
'                             Optional arg7 As String, _
'                             Optional arg8 As String, _
'                             Optional arg9 As String _
'                             ) As String
'    On Error GoTo nogo
'
'    Dim argarray(8) As String
'    argarray(0) = arg1
'    argarray(1) = arg2
'    argarray(2) = arg3
'    argarray(3) = arg4
'    argarray(4) = arg5
'    argarray(5) = arg6
'    argarray(6) = arg7
'    argarray(7) = arg8
'    argarray(8) = arg9
'    Dim i As Long
'    Dim r As String
'    r = fmt
'    For i = 1 To 9
'        r = Replace(r, "%" & i, argarray(i - 1))
'    Next i
'    r = Replace(r, "%%", "%")
'    r = Replace(r, "\n", vbCrLf)
'    r = Replace(r, "\t", vbTab)
'
'    FormatString = r
'    Exit Function
'
'nogo:
'    FormatString = "ERROR " & fmt
'End Function

Private Function GetTranslationTags(controlTag As String) As String()
    Dim tags() As String
    ' Argh.  Die Split Funktion in VBA gibt ein Element zurueck bei Split("test", ",")
    ' In VB6 aber nicht.
    ' Dann haben wir eine eigene implementierung fuer Split in MailSenden.bas. Die ist wie die VB6 version
    ' Also immer stur ein ',' dranhaengen
    tags = Split(controlTag & ",", ",")
    
    Dim invalidTags() As String
    invalidTags = Split("FIXLEFT,FIXTOP,NORESIZE", ",")
    
    Dim result As String
    
    Dim t As Variant
    For Each t In tags
        t = Trim(t)
        If t <> "" And Not IsOneOf(UCase(t), invalidTags) Then
            If Len(result) > 0 Then
                result = result & "," & t
            Else
                result = t
            End If
        End If
    Next t
    GetTranslationTags = Split(result & ",", ",")
End Function

Private Function IsOneOf(s As String, arr() As String) As Boolean
    IsOneOf = False
    If Len(s) = 0 Then
        Exit Function
    End If
    
    Dim e As Variant
    For Each e In arr
        If s = e Then
            IsOneOf = True
            Exit Function
        End If
    Next e
End Function

Private Sub TranslateControl(ctl As Object)
    On Error GoTo nogo
    Dim tag As String
    tag = ctl.tag
    If tag <> "" Then
        Dim tags() As String
        tags = GetTranslationTags(tag)
    
        ' Caption
        Dim s As String
        s = FMT0(tags(0))
        If s <> "" Then
            If TypeOf ctl Is MSForms.TextBox Then
                ctl.Text = s
            'ElseIf TypeOf ctl Is MSForms.UserForm Then
            Else
                ctl.Caption = s
            End If
        End If
        
        ' ControlTipText
        If UBound(tags) > 0 Then
            s = FMT0(tags(1))
            If s <> "" Then
                If TypeOf ctl Is MSForms.MultiPage Then
                    ' MultiPage hat keinen tooltip
                Else
                    ctl.ControlTipText = s
                End If
            End If
        End If
    End If

    Exit Sub
nogo:
    Debug.Print Err.Description
End Sub

Public Sub TranslateForm(frm As Object)
    TranslateControl frm
    
    
    Dim ctl As Object
    For Each ctl In frm.Controls
        
        'If ctl.ControlType = acTextBox Then
        If TypeOf ctl Is MSForms.MultiPage Then
            TranslateControl ctl
            Dim page As Object
            For Each page In ctl.Pages
                TranslateControl page
            Next page
        ElseIf TypeOf ctl Is MSForms.Frame Then
            TranslateForm ctl
        Else
            TranslateControl ctl
        'ElseIf ctl.ControlType = acSubform Then
        '    TranslateForm frm(ctl.name).Form
        End If
    Next ctl
    
End Sub

' Die Sprache die der user in Windows eingestellt hat
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetUserLanguage() As String
    Dim lcid As Long
    lcid = GetUserDefaultLCID()
    GetUserLanguage = MapLCIDToInternalLanguage(lcid)
End Function

' Die Sprache des installierten Ms Office
' Rueckgabewert: Eine unserer supporteten languages
Public Function GetMsOfficeLanguage() As String
    Dim lcid As Long
    lcid = Application.LanguageSettings.LanguageID(msoLanguageIDUI)
    GetMsOfficeLanguage = MapLCIDToInternalLanguage(lcid)
End Function



' -------------------------------------------------------------------
'
' -------------------------------------------------------------------

Function LoadStringTable(path As String) As Collection
    On Error GoTo nogo
    Set LoadStringTable = Nothing
    
    Const ForReading = 1
    Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0
    
    Dim fs, f, ts
    Set ts = Nothing
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set ts = fs.OpenTextFile(path, ForReading, False, TristateTrue)
    
    'Dim sheet As Worksheet
    'Set sheet = ThisWorkbook.Sheets("Test")
    'Dim y As Long
    'y = 1
    
    Dim c As New Collection
    Dim s As String
    Do While ts.AtEndOfStream <> True
        ' This really is a Unicode string, although the debugger and MsgBox show ??
        s = ts.ReadLine
        'sheet.Cells(y, 1) = s
        'y = y + 1
        
        If ExtractString(s, c) Then
        End If
    Loop
    Set LoadStringTable = c
nogo:
    If Not ts Is Nothing Then
        ts.Close
        Set ts = Nothing
    End If
    If Not fs Is Nothing Then
        Set fs = Nothing
    End If
End Function

Function ExtractString(line As String, c As Collection) As Boolean
    On Error GoTo nogo
    
    ExtractString = False
    If line = "" Then
        Exit Function
    End If
    If Left(line, 1) = "'" Then
        Exit Function
    End If
    
    Dim startp As Long
    Dim endp As Long
    Dim ofs As Long
    If Left(line, 1) = """" Then
        ' id ist alles zwischen den ""
        startp = 2
        endp = InStr(2, line, """")
        ofs = 2
    Else
        startp = 1
        endp = InStr(line, " ")
        ofs = 1
    End If
    If startp <= 0 Or endp <= 0 Then
        Exit Function
    End If
    
    Dim id As String
    Dim value As String
    id = Mid(line, startp, endp - startp)
    'value = Mid(line, endp + 1, Len(line) - endp)
    value = Mid(line, endp + ofs)
    If Not CollectionStringExists(c, id) Then
        c.Add value, id
    End If
    
    ExtractString = True
    Exit Function
nogo:
    MsgBox Err.Description
End Function

Private Function IsTestUser() As Boolean
    If mCurrentUser = "dirk" Or _
        mCurrentUser = "dwinter" Or _
        mCurrentUser = "norman" Or _
        mCurrentUser = "nneubert" Or _
        mCurrentUser = "rolf" Or _
        mCurrentUser = "rlangenberg" Then
        
        IsTestUser = True
    End If
End Function

Private Function GetTranslationUserName() As String
   ' Buffer size for the return string.
   Const lpnLength As Integer = 255

   ' Get return buffer space.
   Dim status As Integer

   ' For getting user information.
   Dim lpName, lpUserName As String

   ' Assign the buffer size constant to lpUserName.
   lpUserName = Space$(lpnLength + 1)

   ' Get the log-on name of the person using product.
   status = WNetGetUser(lpName, lpUserName, lpnLength)

   ' See whether error occurred.
   If status = NoError Then
      ' This line removes the null character. Strings in C are null-
      ' terminated. Strings in Visual Basic are not null-terminated.
      ' The null character must be removed from the C strings to be used
      ' cleanly in Visual Basic.
      lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
   Else
      lpUserName = "Unbekannt"
   End If

    GetTranslationUserName = lpUserName
End Function

Private Function LCIDToLanguageCode(lcid As Long) As String

    ' Locale IDs
    ' https://msdn.microsoft.com/en-us/goglobal/bb964664
    'Arabic (Saudi Arabia)                1025
    'Arabic (Iraq)                        2049
    'Arabic (Egypt)                       3073
    'Arabic (Libya)                       4097
    'Arabic (Algeria)                     5121
    'Arabic (Morocco)                     6145
    'Arabic (Tunisia)                     7169
    'Arabic (Oman)                        8193
    'Arabic (Yemen)                       9217
    'Arabic (Syria)                      10241
    'Arabic (Jordan)                     11265
    'Arabic (Lebanon)                    12289
    'Arabic (Kuwait)                     13313
    'Arabic (U.A.E.)                     14337
    'Arabic (Bahrain)                    15361
    'Arabic (Qatar)                      16385
    'Bulgarian                            1026
    'Catalan                              1027
    'Chinese (Taiwan)                     1028
    'Chinese (PRC)                        2052
    'Chinese (Hong Kong SAR               3076
    'Chinese (Singapore)                  4100
    'Czech                                1029
    'Danish                               1030
    'German (Germany)                     1031
    'German (Swiss)                       2055
    'German (Austrian)                    3079
    'German (Luxembourg)                  4103
    'German (Liechtenstein)               5127
    'Greek                                1032
    'English (United States)              1033
    'English (United Kingdom)             2057
    'English (Australian)                 3081
    'English (Canadian)                   4105
    'English (New Zealand)                5129
    'English (Ireland)                    6153
    'English (South Africa)               7177
    'English (Jamaica)                    8201
    'English (Caribbean)                  9225
    'English (Belize)                    10249
    'English (Trinidad)                  11273
    'Spanish (Traditional Sort)           1034
    'Spanish (Mexican)                    2058
    'Spanish (Modern Sort)                3082
    'Spanish (Guatemala)                  4106
    'Spanish (Costa Rica)                 5130
    'Spanish (Panama)                     6154
    'Spanish (Dominican Republic)         7178
    'Spanish (Venezuela)                  8202
    'Spanish (Colombia)                   9226
    'Spanish (Peru)                      10250
    'Spanish (Argentina)                 11274
    'Spanish (Ecuador)                   12298
    'Spanish (Chile)                     13322
    'Spanish (Uruguay)                   14346
    'Spanish (Paraguay)                  15370
    'Spanish (Bolivia)                   16394
    'Spanish (El Salvador)               17418
    'Spanish (Honduras)                  18442
    'Spanish (Nicaragua)                 19466
    'Spanish (Puerto Rico)               20490
    'Finnish                              1035
    'French (Standard)                    1036
    'French (Belgian)                     2060
    'French (Canadian)                    3084
    'French (Swiss)                       4108
    'French (Luxembourg)                  5132
    'Hebrew                               1037
    'Hungarian                            1038
    'Icelandic                            1039
    'Italian (Standard)                   1040
    'Italian (Swiss)                      2064
    'Japanese                             1041
    'Korean                               1042
    'Korean (Johab)                       2066
    'Dutch (Standard)                     1043
    'Dutch (Belgian)                      2067
    'Norwegian (Bokmal)                   1044
    'Norwegian (Nynorsk)                  2068
    'Polish                               1045
    'Portuguese (Brazil)                  1046
    'Portuguese (Portugal)                2070
    'Romanian                             1048
    'Russian                              1049
    'Croatian                             1050
    'Serbian (Latin)                      2074
    'Serbian (Cyrillic)                   3098
    'Slovak                               1051
    'Albanian                             1052
    'Swedish                              1053
    'Swedish (Finland)                    2077
    'Thai                                 1054
    'Turkish                              1055
    'Indonesian                           1057
    'Ukrainian                            1058
    'Belarusian                           1059
    'Slovenian                            1060
    'Estonian                             1061
    'Latvian                              1062
    'Lithuanian                           1063
    'Farsi                                1065
    'Vietnamese                           1066
    'Basque                               1069
    'Afrikaans                            1078
    'Faeroese                             1080

    'Dim langs As Variant
    'langs = [{1031, "de-de"; 2055, "de-ch"}]
    'langs = Array( _
    '        1031, "de-de" _
    '    )
    
    ' Default ist Englisch
    LCIDToLanguageCode = "en-gb"

    ' https://msdn.microsoft.com/en-us/library/ee825488(v=cs.20).aspx
    Select Case lcid
    Case 1031
        'German (Germany)
        LCIDToLanguageCode = "de-de"
    Case 2055
        'German (Swiss)
        LCIDToLanguageCode = "de-ch"
    Case 3079
        'German (Austrian)
        LCIDToLanguageCode = "de-at"
    Case 4103
        'German (Luxembourg)
        LCIDToLanguageCode = "de-lu"
    Case 5127
        'German (Liechtenstein)
        LCIDToLanguageCode = "de-li"
        
    Case 1033
        'English (United States)
        LCIDToLanguageCode = "en-us"
    Case 2057
        'English (United Kingdom)
        LCIDToLanguageCode = "en-gb"
    Case 3081
        'English (Australian)
        LCIDToLanguageCode = "en-au"
    Case 4105
        'English (Canadian)
        LCIDToLanguageCode = "en-ca"
    Case 5129
        'English (New Zealand)
        LCIDToLanguageCode = "en-nz"
    Case 6153
        'English (Ireland)
        LCIDToLanguageCode = "en-ie"
    Case 7177
        'English (South Africa)
        LCIDToLanguageCode = "en-za"
    Case 8201
        'English (Jamaica)
        LCIDToLanguageCode = "en-jm"
    Case 9225
        'English (Caribbean)
        LCIDToLanguageCode = "en-cb"
    Case 10249
        'English (Belize)
        LCIDToLanguageCode = "en-bz"
    Case 11273
        'English (Trinidad and Tobago)
        LCIDToLanguageCode = "en-tt"
    End Select
End Function

Private Function MapLCIDToInternalLanguage(lcid As Long) As String
    Dim langCulture As String
    langCulture = LCIDToLanguageCode(lcid)
    
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(langCulture, 2) = "de" Then
        MapLCIDToInternalLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        MapLCIDToInternalLanguage = LANG_EN_GB
    End If
    
End Function

Public Function GetWindowsLanguageString() As String
    On Error GoTo nogo
    
    Dim Ret As Long
    Dim loc As String
    Dim windowsLang As String
    
    loc = Space$(255)
    Ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = loc & "-"
    
    loc = Space$(255)
    Ret = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SISO3166CTRYNAME, loc, 9)
    loc = Left$(loc, InStr(loc, Chr(0)) - 1)
    windowsLang = windowsLang & loc
    
    GetWindowsLanguageString = LCase(windowsLang)
    Exit Function
nogo:
    GetWindowsLanguageString = "en-gb"
End Function

Private Function GetFallbackLanguage(lang As String) As String
    ' Alles was de-xy hat wird auf de-de abgebildet
    If Left(lang, 2) = "de" Then
        GetFallbackLanguage = LANG_DE_DE
    Else
        ' Alles andere wird en-gb
        GetFallbackLanguage = LANG_EN_GB
    End If
End Function




Attribute VB_Name = "TranslationHelpers"
Option Explicit

' Fallbacksprachen
' Regeln:
 '  File APP_en-xy.txt nicht da -> APP_en-gb.txt benutzen
 '  File APP_de-xy.txt nicht da -> APP_de-de.txt benutzen
 '  File APP_xy-uv.txt nicht da -> APP_en-gb.txt benutzen
Public Const LANG_EN_GB As String = "en-gb"
Public Const LANG_DE_DE As String = "de-de"


Public gTranslation As New Translation

Public Function InitTranslation(path As String, langFile As String, cfg As CfgReader) As Boolean
    InitTranslation = False
    Dim overrideLanguage As String
    If Not cfg Is Nothing Then
        If cfg.GetSection("GLOBALS") = True Then
            overrideLanguage = cfg.GetValue("LANGUAGE")
        End If
    End If
    If Not gTranslation.StartupInit(path, langFile, overrideLanguage) Then
        ' Sprachdateien wurden nicht geladen
        MsgBox FmtInternal("Missing language files ('%1_en-gb.txt')!" & vbCrLf & vbCrLf & "Die Sprachdateien wurden nicht gefunden ('%1_de-de.txt')!", langFile), vbCritical
        Exit Function
    End If
    InitTranslation = True
End Function

Public Function FMT0(f As String) As String
    FMT0 = FmtInternal(TR(f))
End Function

Public Function FMT1(f As String, _
                     ByVal arg1 As String) As String
    FMT1 = FmtInternal(TR(f), arg1)
End Function

Public Function FMT2(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String) As String
    FMT2 = FmtInternal(TR(f), arg1, arg2)
End Function

Public Function FMT3(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String) As String
    FMT3 = FmtInternal(TR(f), arg1, arg2, arg3)
End Function

Public Function FMT4(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String) As String
    FMT4 = FmtInternal(TR(f), arg1, arg2, arg3, arg4)
End Function

Public Function FMT5(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String) As String
    FMT5 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5)
End Function
Public Function FMT6(f As String, _
                     ByVal arg1 As String, _
                     ByVal arg2 As String, _
                     ByVal arg3 As String, _
                     ByVal arg4 As String, _
                     ByVal arg5 As String, _
                     ByVal arg6 As String) As String
    FMT6 = FmtInternal(TR(f), arg1, arg2, arg3, arg4, arg5, arg6)
End Function

Public Function GetTranslationString(id As String, fallback As String) As String
    If gTranslation.StringExists(id) Then
        GetTranslationString = gTranslation.GetString(id)
        Exit Function
    End If
    GetTranslationString = fallback
End Function

Public Function TR(id As String) As String
'    If gTranslation Is Nothing Then
'        TR = "gTranslation Not Initialized"
'        Exit Function
'    End If
    TR = gTranslation.GetString(id)
End Function

Public Function FmtInternal(f As String, _
                    Optional arg1 As String = vbNullChar, _
                    Optional arg2 As String = vbNullChar, _
                    Optional arg3 As String = vbNullChar, _
                    Optional arg4 As String = vbNullChar, _
                    Optional arg5 As String = vbNullChar, _
                    Optional arg6 As String = vbNullChar, _
                    Optional arg7 As String = vbNullChar, _
                    Optional arg8 As String = vbNullChar, _
                    Optional arg9 As String = vbNullChar _
                    ) As String
    FmtInternal = gTranslation.FormatString(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
End Function

Public Function IsYes(s As String) As Boolean
  If UCase(s) = "JA" Or UCase(s) = "YES" Then
    IsYes = True
  End If
End Function

Public Function IsNo(s As String) As Boolean
  If UCase(s) = "NEIN" Or UCase(s) = "NO" Then
    IsNo = True
  End If
End Function

Public Function IsTrue(s As String) As Boolean
    If UCase(s) = "WAHR" Or UCase(s) = "TRUE" Then
        IsTrue = True
    End If
End Function

Public Function IsFalse(s As String) As Boolean
    If UCase(s) = "FALSCH" Or UCase(s) = "FALSE" Then
        IsFalse = True
    End If
End Function

Public Function TranslationSheetExists(ByRef wb As Workbook, names As Variant) As String
    On Error GoTo nogo
    Dim name As String
    If IsArray(names) Then
        Dim n As Variant
        For Each n In names
            name = CStr(n)
            If WorksheetExists(wb, name) Then
                TranslationSheetExists = name
                Exit Function
            End If
        Next n
        If UBound(names) >= 0 Then
            TranslationSheetExists = CStr(names(0))
            Exit Function
        End If
    Else
        name = CStr(names)
        If WorksheetExists(wb, name) Then
            TranslationSheetExists = name
            Exit Function
        End If
    End If
nogo:
    
End Function

' Das gleiche wie Cells.Find - aber probiert mehrere Strings zu finden (fuer mehrere Sprachen)
Public Function TranslationFindCells(ws As Worksheet, What As Variant, LookIn As Excel.XlFindLookIn, _
                                     LookAt As Excel.XlLookAt, SearchOrder As Excel.XlSearchOrder, _
                                     SearchDirection As Excel.XlSearchDirection, MatchCase As Boolean) As Range
  Set TranslationFindCells = Nothing
  Dim s As Variant
  For Each s In What
    Dim r As Range
    Set r = ws.Cells.Find(CStr(s), LookIn:=LookIn, LookAt:=LookAt, SearchOrder:=SearchOrder, SearchDirection:=SearchDirection, MatchCase:=MatchCase)
    If Not r Is Nothing Then
      Set TranslationFindCells = r
      Exit Function
    End If
  Next s
End Function

' This works because Debug.Print is omitted in the compiled code
Public Function InIDE() As Boolean
  On Error Resume Next
  Debug.Print 0 / 0
  InIDE = Err.Number <> 0
End Function






Attribute VB_Name = "UNC"

Option Explicit
    

' Fuer CacheMappedDrives()
'Dim mMappedDrives As Collection
Dim mMappedDrives(0 To 25) As String
Dim mUsedDriveLetters(0 To 25) As String
Dim mNumUsedDrives As Integer
    
#If VBA7 Then
Private Declare PtrSafe Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#Else
Private Declare Function WNetGetConnectionA Lib "mpr.dll" ( _
  ByVal lpszLocalName As String, _
  ByVal lpszRemoteName As String, _
  cbRemoteName As Long) As Long
#End If

Public Function GetUNCPath(ByVal sLocalPath As String) As String
    '// -----------------------------------------------------------------
    '// Methode:   | Konvertiert einen Pfad in UNC-Pfad (\\SERVER\...)
    '// -----------------------------------------------------------------
    '// Parameter: | sLocalPath = g|fffd|ltiger, lokaler Pfad (X:\..)
    '// -----------------------------------------------------------------
    '// R|fffd|ckgabe:  | bei Erfolg = UNC-Pfad
    '//            | bei Fehler = sLocalPath
    '// -----------------------------------------------------------------
    Const NO_ERROR As Long = 0
    Dim sUNCPath As String
    Dim sResult As String
    Dim sDrive As String

    On Error Resume Next
    GetUNCPath = sLocalPath
    If Mid$(sLocalPath, 2, 1) <> ":" Then Exit Function
    '// Die API-Funktion ben|fffd|tigt nur das Laufwerk!
    sDrive = Left$(sLocalPath, 2)
    sUNCPath = Space$(260)
    If WNetGetConnectionA(sDrive, sUNCPath, Len(sUNCPath)) = NO_ERROR Then
        sResult = Left$(sUNCPath, InStr(sUNCPath, vbNullChar) - 1)
        If Len(sResult) > 0 Then
            GetUNCPath = sResult & Mid$(sLocalPath, 3)
        End If
    End If

End Function

Public Sub CacheMappedDrives()
    mNumUsedDrives = 0
    Dim I As Integer
    For I = 65 To 90
        Dim strUNCPath As String
        strUNCPath = ""
        If GetUNCPathShort(Chr(I) & ":", strUNCPath) = 0 Then
            mMappedDrives(mNumUsedDrives) = UCase(strUNCPath)
            mUsedDriveLetters(mNumUsedDrives) = Chr(I)
            mNumUsedDrives = mNumUsedDrives + 1
        Else
        
        End If
    Next I
End Sub

' Wir nehmen an uncPath ist all upper case
Public Function GetCachedMappedDrive(uncPath As String) As String
    GetCachedMappedDrive = uncPath
    Dim I As Integer
    For I = 0 To mNumUsedDrives - 1
        If mMappedDrives(I) = Left$(uncPath, Len(mMappedDrives(I))) Then
            GetCachedMappedDrive = mUsedDriveLetters(I) & ":" & Mid$(uncPath, Len(mMappedDrives(I)) + 1)
            Exit For
        End If
    Next I
End Function

Function GetDriveAndPathFromUNC(ByVal strFullPath As String) As String

    If Mid(strFullPath, 2, 1) = ":" Then
      GetDriveAndPathFromUNC = strFullPath
      Exit Function
    End If

    Dim strUNC As String
    Dim I As Integer
    Dim s As String

    s = strFullPath

    For I = 65 To 90
        If GetUNCPathShort(Chr(I) & ":", strUNC) = 0 Then
            If UCase(strUNC) = UCase(Left(strFullPath, Len(strUNC))) Then
              If Len(Chr(I) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))) < Len(s) Then
                s = Chr(I) & ":" & Mid(strFullPath, Len(strUNC) + 1, Len(strFullPath) - (Len(strUNC)))
              End If
            End If
        End If
    Next I
    
    GetDriveAndPathFromUNC = s
    
End Function


Function GetUNCPathShort(ByVal strDriveLetter As String, _
    ByRef strUNCPath As String) As Long
    On Local Error GoTo GetUNCPath_Err
    Dim strMsg As String
    Dim lngReturn As Long
    Dim strLocalName As String
    Dim strRemoteName As String
    Dim lngRemoteName As Long
    strLocalName = strDriveLetter
    strRemoteName = String$(255, Chr$(32))
    
    lngRemoteName = Len(strRemoteName)
    'Attempt to grab UNC
    lngReturn = WNetGetConnectionA(strLocalName, _
    strRemoteName, _
    lngRemoteName)


    If lngReturn = 0 Then
        
        'No problems - return the UNC
        'to the passed ByRef string
        GetUNCPathShort = 0
        
        
        ' only works for omni 2 build
        ' strUNCPath = LTrim(strRemoteName)
        ' strUNCPath = Left$(strUNCPath, Len(str
        '     UNCPath) - 1)
        
        
        ' less acurate potential for error if se
        '     rver or share contains spaces.
        
        If InStr(strRemoteName, Chr(0)) > 0 Then
          strUNCPath = Left(strRemoteName, InStr(strRemoteName, Chr(0)) - 1)
        Else
          strUNCPath = Mid(strRemoteName, 1, (InStr(1, strRemoteName, " ", 1)) - 2)
        End If
        
        
    Else
        'Problems - so return original
        'drive letter and error number
        GetUNCPathShort = lngReturn
        strUNCPath = strDriveLetter & "\"
    End If
GetUNCPath_End:
    Exit Function
GetUNCPath_Err:
    GetUNCPathShort = 1
    strUNCPath = strDriveLetter
    Resume GetUNCPath_End
End Function



Attribute VB_Name = "UnicodeFile"
Option Explicit

#If VBA7 And Win64 Then

  Private Declare PtrSafe Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As LongPtr, _
      ByVal cbMultiByte As LongPtr, _
      ByVal lpWideCharStr As LongPtr, _
      ByVal cchWideChar As Long _
  ) As Long

  Private Declare PtrSafe Function WideCharToMultiByte Lib "kernel32" ( _
      ByVal codePage As Long, ByVal dwFlags As Long, _
      ByVal lpWideCharStr As LongPtr, ByVal cchWideChar As LongPtr, _
      ByVal lpMultiByteStr As LongPtr, ByVal cchMultiByte As LongPtr, _
      ByVal lpDefaultChar As LongPtr, ByVal lpUsedDefaultChar As LongPtr) As Long
        
#Else
  Private Declare Function MultiByteToWideChar Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long _
  ) As Long
  
  Private Declare Function WideCharToMultiByte Lib "Kernel32.dll" ( _
      ByVal codePage As Long, _
      ByVal dwFlags As Long, _
      ByVal lpWideCharStr As Long, _
      ByVal cchWideChar As Long, _
      ByVal lpMultiByteStr As Long, _
      ByVal cbMultiByte As Long, _
      ByVal lpDefaultChar As Long, _
      ByVal lpUsedDefaultChar As Long _
  ) As Long
#End If

Public Const CP_ACP        As Long = 0          ' Default ANSI code page.
Public Const CP_UTF8       As Long = 65001      ' UTF8.
Public Const CP_UTF16_LE   As Long = 1200       ' UTF16 - little endian.
Public Const CP_UTF16_BE   As Long = 1201       ' UTF16 - big endian.
Public Const CP_UTF32_LE   As Long = 12000      ' UTF32 - little endian.
Public Const CP_UTF32_BE   As Long = 12001      ' UTF32 - big endian.

' Purpose:  Heuristic to determine whether bytes in a file are UTF-8.
Private Function FileBytesAreUTF8(ByVal the_iFileNo As Integer) As Boolean

    Const knSampleByteSize          As Long = 2048
    Dim nLof                        As Long
    Dim nByteCount                  As Long
    Dim nByteIndex                  As Long
    Dim nCharExtraByteCount         As Long
    Dim bytValue                    As Byte

    ' We look at the first <knSampleByteSize> bytes of the file. However, if the file is smaller, we will have to
    ' use the smaller size.
    nLof = LOF(the_iFileNo)
    If nLof < knSampleByteSize Then
        nByteCount = nLof
    Else
        nByteCount = knSampleByteSize
    End If

    ' Go to the start of the file.
    Seek #the_iFileNo, 1

    For nByteIndex = 1 To nByteCount

        Get #the_iFileNo, , bytValue

        ' If the character we are processing has bytes beyond 1, then we are onto the next character.
        If nCharExtraByteCount = 0 Then
            '
            ' The UTF-8 specification says that the first byte of a character has masking bits which indicate how many bytes follow.
            '
            ' See: http://en.wikipedia.org/wiki/UTF-8#Description
            '
            ' Bytes in
            ' sequence   Byte 1   Byte 2   Byte 3   Byte 4
            ' 1          0xxxxxxx
            ' 2          110xxxxx 10xxxxxx
            ' 3          1110xxxx 10xxxxxx 10xxxxxx
            ' 4          11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            '
            If (bytValue And &H80) = &H0 Then
                nCharExtraByteCount = 0
            ElseIf (bytValue And &HE0) = &HC0 Then
                nCharExtraByteCount = 1
            ElseIf (bytValue And &HF0) = &HE0 Then
                nCharExtraByteCount = 2
            ElseIf (bytValue And &HF8) = &HF0 Then
                nCharExtraByteCount = 3
            Else
                ' If none of these masks were matched, then this can't be a UTF-8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        Else
            ' All following bytes must be masked as in the table above.
            If (bytValue And &HC0) = &H80 Then
                nCharExtraByteCount = nCharExtraByteCount - 1
                If nCharExtraByteCount = 0 Then
                    FileBytesAreUTF8 = True
                End If
            Else
                ' Not a UTF8 character.
                FileBytesAreUTF8 = False
                Exit Function
            End If
        End If

    Next nByteIndex

End Function

' Purpose:  Take a string whose bytes are in the byte array <the_abytCPString>, with code page <the_nCodePage>, convert to a VB string.
Private Function FromCPString(ByRef the_abytCPString() As Byte, ByVal the_nCodePage As Long) As String

    Dim sOutput                     As String
    Dim nValueLen                   As Long
    Dim nOutputCharLen              As Long

    ' If the code page says this is already compatible with the VB string, then just copy it into the string. No messing.
    If the_nCodePage = CP_UTF16_LE Then
        FromCPString = the_abytCPString()
    Else

        ' Cache the input length.
        nValueLen = UBound(the_abytCPString) - LBound(the_abytCPString) + 1

        ' See how big the output buffer will be.
        nOutputCharLen = MultiByteToWideChar(the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, 0&, 0&)

        ' Resize output byte array to the size of the UTF-8 string.
        sOutput = Space$(nOutputCharLen)

        ' Make this API call again, this time giving a pointer to the output byte array.
        MultiByteToWideChar the_nCodePage, 0&, VarPtr(the_abytCPString(LBound(the_abytCPString))), nValueLen, StrPtr(sOutput), nOutputCharLen

        ' Return the array.
        FromCPString = sOutput

    End If

End Function

Public Function GetContents(ByVal the_sTextFile As String, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean) As String

    Dim iFileNo                     As Integer
    Dim abytFileContents()          As Byte
    Dim nDataSize                   As Long

    iFileNo = FreeFile

    OpenForInput the_sTextFile, iFileNo, out_nCodePage, the_nDesiredCodePage, out_bContainedBOM

    ' We want to read the entire contents of the file (not including any BOM value).
    ' After calling OpenForInput(), the file pointer should be positioned after any BOM.
    ' So size file contents buffer to <file size> - <current position> + 1.
    nDataSize = LOF(iFileNo) - Seek(iFileNo) + 1
    ReDim abytFileContents(1 To nDataSize)
    Get #iFileNo, , abytFileContents()

    Close iFileNo

    ' Now we must convert this to UTF-8. But we have to first convert to the Windows NT standard UTF-16 LE.
    GetContents = FromCPString(abytFileContents(), out_nCodePage)

End Function


' Diese Funktion ist langsam!!!!!!!!!!!!!

' Purpose:  Reads up to the end of the current line of the file, repositions to the beginning of the next line, if any, and
'           outputs all characters found.
' Inputs:   the_nFileNo     The number of the file.
' Outputs:  out_sLine       The line from the current position in the file.
' Return:   True if there is more data.
Public Function LineInputUTF8(ByVal the_nFileNo As Integer, ByRef out_sLine As String) As Boolean

    Dim bytValue            As Byte
    Dim abytLine()          As Byte
    Dim nStartOfLinePos     As Long
    Dim nEndOfLinePos       As Long
    Dim nStartOfNextLine    As Long
    Dim nLineLen            As Long

    ' Save the current file position as the beginning of the line, and cache this value.
    nStartOfLinePos = Seek(the_nFileNo)

    ' Retrieves the first byte from the current position.
    Get #the_nFileNo, , bytValue

    ' Loop until the end of file is encountered.
    Do Until EOF(the_nFileNo)

        ' Check whether this byte represents a carriage return or line feed character (indicating new line).
        If bytValue = 13 Or bytValue = 10 Then
            ' By this point, the current position is *after* the CR or LF character, so to get the position of the
            ' last byte in the line, we must go back two bytes.
            nEndOfLinePos = Seek(the_nFileNo) - 2

            ' If this is a carriage return, then we must check the next character.
            If bytValue = 13 Then
                Get #the_nFileNo, , bytValue
                ' Is this a line feed?
                If bytValue = 10 Then
                ' Yes. Assume that CR-LF counts as a single NewLine. So the start of the next line should skip over the line feed.
                    nStartOfNextLine = nEndOfLinePos + 3
                Else
                ' No. The start of the next line is the current position.
                    nStartOfNextLine = nEndOfLinePos + 2
                End If
            ElseIf bytValue = 10 Then
            ' If this is a line feed, then the start of the next line is the current position.
                nStartOfNextLine = nEndOfLinePos + 2
            End If

            ' Since we have processed all the bytes in the line, exit the loop.
            Exit Do
        End If

        ' Get the next byte.
        Get #the_nFileNo, , bytValue
    Loop

    ' Check to see if there was an end of line.
    If nEndOfLinePos = 0 Then
    ' No, this is the end of the file - so use all the remaining characters.
        nLineLen = Seek(the_nFileNo) - nStartOfLinePos - 1
    Else
    ' Yes - so use all the characters up to the end of line position.
        nLineLen = nEndOfLinePos - nStartOfLinePos + 1
    End If

    ' Is this line empty?
    If nLineLen = 0 Then
    ' Yes - just return an empty string.
        out_sLine = vbNullString
    Else
    ' No - pull all the bytes from the beginning to the end of the line into a byte array, and then convert that from UTF-8 to a VB string.
        ReDim abytLine(1 To nLineLen)
        Get #the_nFileNo, nStartOfLinePos, abytLine()
        out_sLine = FromCPString(abytLine(), CP_UTF8)
    End If

    ' If there is a line afterwards, then move to the beginning of the line, and return True.
    If nStartOfNextLine > 0 Then
        Seek #the_nFileNo, nStartOfNextLine
        LineInputUTF8 = True
    End If

End Function

' Purpose:  Analogue of 'Open "fileName" For Input As #fileNo' - but also return what type of text this is via a Code Page value.
' Inputs:   the_sFileName
'           the_iFileNo
'           (the_nDesiredCodePage)  The code page that you want to use with this file.
'                                   If this value is set to the default, -1, this indicates that the code page will be ascertained from the file.
' Outputs:  out_nCodePage           There are only six valid values that are returned if <the_nDesiredCodePage> was set to -1.
'               CP_ACP        ANSI code page
'               CP_UTF8       UTF-8
'               CP_UTF16LE    UTF-16 Little Endian (VB and NT default string encoding)
'               CP_UTF16BE    UTF-16 Big Endian
'               CP_UTF32LE    UTF-32 Little Endian
'               CP_UTF32BE    UTF-32 Big Endian
'           (out_bContainedBOM)     If this was set to True, then the file started with a BOM (Byte Order Marker).
Public Sub OpenForInput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, ByRef out_nCodePage As Long, Optional ByVal the_nDesiredCodePage As Long = -1, Optional ByRef out_bContainedBOM As Boolean)

    ' Note if we want to take account of every case, we should read in the first four bytes, and check for UTF-32 low and high endian BOMs, check
    ' the first three bytes for the UTF-8 BOM, and finally check the first two bytes for UTF-16 low and hight endian BOMs.
    Dim abytBOM(1 To 4)             As Byte
    Dim nCodePage                   As Long

    ' By default, there is no BOM.
    out_bContainedBOM = False

    Open the_sFilename For Binary Access Read As #the_iFileNo

    ' We are interested in -1 (ascertain code page), and then various UTF encodings.
    Select Case the_nDesiredCodePage
    Case -1, CP_UTF8, CP_UTF16_BE, CP_UTF16_LE, CP_UTF32_BE, CP_UTF32_LE

        ' Default code page.
        nCodePage = CP_ACP

        ' Pull in the first four bytes to determine the BOM (byte order marker).
        Get #the_iFileNo, , abytBOM()

        ' The following are the BOMs for text files:
        '
        ' FF FE         UTF-16, little endian
        ' FE FF         UTF-16, big endian
        ' EF BB BF      UTF-8
        ' FF FE 00 00   UTF-32, little endian
        ' 00 00 FE FF   UTF-32, big-endian
        '
        ' Work out the code page from this information.

        Select Case abytBOM(1)
        Case &HFF
            If abytBOM(2) = &HFE Then
                If abytBOM(3) = 0 And abytBOM(4) = 0 Then
                    nCodePage = CP_UTF32_LE
                Else
                    nCodePage = CP_UTF16_LE
                End If
            End If
        Case &HFE
            If abytBOM(2) = &HFF Then
                nCodePage = CP_UTF16_BE
            End If
        Case &HEF
            If abytBOM(2) = &HBB And abytBOM(3) = &HBF Then
                nCodePage = CP_UTF8
            End If
        Case &H0
            If abytBOM(2) = &H0 And abytBOM(3) = &HFE And abytBOM(4) = &HFF Then
                nCodePage = CP_UTF32_BE
            End If
        End Select

        ' Did we match any BOMs?
        If nCodePage = CP_ACP Then
        ' No - we are still defaulting to the ANSI code page.
            ' Special check for UTF-8. The BOM is not specified in the standard for UTF-8, but according to Wikipedia (which is always right :-) ),
            ' only Microsoft includes this marker at the beginning of files.
            If FileBytesAreUTF8(the_iFileNo) Then
                out_nCodePage = CP_UTF8
            Else
                out_nCodePage = CP_ACP
            End If
        Else
        ' Yes - we have worked out the code page from the BOM.
            ' If no code page was suggested, we now return the code page we found.
            If the_nDesiredCodePage = -1 Then
                out_nCodePage = nCodePage
            End If

            ' Inform the caller that a BOM was found.
            out_bContainedBOM = True
        End If

        ' Reset the file pointer to the beginning of the file data.
        If out_bContainedBOM Then
            ' Note that if the code page found was one of the two UTF-32 values, then we are already in the correct position.
            ' Otherwise, we have to move to just after the end of the BOM.
            Select Case nCodePage
            Case CP_UTF16_BE, CP_UTF16_LE
                Seek #the_iFileNo, 3
            Case CP_UTF8
                Seek #the_iFileNo, 4
            End Select
        Else
            ' There is no BOM, so simply go the beginning of the file.
            Seek #the_iFileNo, 1
        End If

    Case Else
        out_nCodePage = the_nDesiredCodePage
    End Select

End Sub

' Purpose:  Analogue of 'Open "fileName" For Append As #fileNo'
Public Sub OpenForAppend(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Open the file and move to the end of the file.
    Open the_sFilename For Binary Access Write As #the_iFileNo
    Seek the_iFileNo, LOF(the_iFileNo) + 1

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of 'Open "fileName" For Output As #fileNo'
Public Sub OpenForOutput(ByRef the_sFilename As String, ByVal the_iFileNo As Integer, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bPrefixWithBOM As Boolean = True)

    ' Ensure we overwrite the file by deleting it ...
    On Error Resume Next
    Kill the_sFilename
    On Error GoTo 0

    ' ... before creating it.
    Open the_sFilename For Binary Access Write As #the_iFileNo

    If the_bPrefixWithBOM Then
        WriteBOM the_iFileNo, the_nCodePage
    End If

End Sub

' Purpose:  Analogue of the 'Print #fileNo, value' statement. But only one value allowed.
'           Setting <the_bAppendNewLine> = False is analagous to 'Print #fileNo, value;'.
Public Sub Print_(ByVal the_iFileNo As Integer, ByRef the_sValue As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional ByVal the_bAppendNewLine As Boolean = True)

    Const kbytNull                  As Byte = 0
    Const kbytCarriageReturn        As Byte = 13
    Const kbytNewLine               As Byte = 10

    Put #the_iFileNo, , ToCPString(the_sValue, the_nCodePage)

    If the_bAppendNewLine Then
        Select Case the_nCodePage
        Case CP_UTF16_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF16_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
        Case CP_UTF32_BE
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
        Case CP_UTF32_LE
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNewLine
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
            Put #the_iFileNo, , kbytNull
        Case Else
            Put #the_iFileNo, , kbytCarriageReturn
            Put #the_iFileNo, , kbytNewLine
        End Select
    End If

End Sub

Public Sub PutContents(ByRef the_sFilename As String, ByRef the_sFileContents As String, Optional ByVal the_nCodePage As Long = CP_ACP, Optional the_bPrefixWithBOM As Boolean)

    Dim iFileNo                     As Integer

    iFileNo = FreeFile
    OpenForOutput the_sFilename, iFileNo, the_nCodePage, the_bPrefixWithBOM
    Print_ iFileNo, the_sFileContents, the_nCodePage, False
    Close iFileNo

End Sub

' Purpose:  Converts a VB string (UTF-16) to UTF8 - as a binary array.
Private Function ToCPString(ByRef the_sValue As String, ByVal the_nCodePage As Long) As Byte()

    Dim abytOutput()                As Byte
    Dim nValueLen                   As Long
    Dim nOutputByteLen              As Long

    If the_nCodePage = CP_UTF16_LE Then
        ToCPString = the_sValue
    Else

        ' Cache the input length.
        nValueLen = Len(the_sValue)

        ' See how big the output buffer will be.
        nOutputByteLen = WideCharToMultiByte(the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, 0&, 0&, 0&, 0&)

        If nOutputByteLen > 0 Then
            ' Resize output byte array to the size of the UTF-8 string.
            ReDim abytOutput(1 To nOutputByteLen)

            ' Make this API call again, this time giving a pointer to the output byte array.
            WideCharToMultiByte the_nCodePage, 0&, StrPtr(the_sValue), nValueLen, VarPtr(abytOutput(1)), nOutputByteLen, 0&, 0&
        End If

        ' Return the array.
        ToCPString = abytOutput()

    End If

End Function

Private Sub WriteBOM(ByVal the_iFileNo As Integer, ByVal the_nCodePage As Long)

    ' FF FE         UTF-16, little endian
    ' FE FF         UTF-16, big endian
    ' EF BB BF      UTF-8
    ' FF FE 00 00   UTF-32, little endian
    ' 00 00 FE FF   UTF-32, big-endian

    Select Case the_nCodePage
    Case CP_UTF8
        Put #the_iFileNo, , CByte(&HEF)
        Put #the_iFileNo, , CByte(&HBB)
        Put #the_iFileNo, , CByte(&HBF)
    Case CP_UTF16_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
    Case CP_UTF16_BE
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    Case CP_UTF32_LE
        Put #the_iFileNo, , CByte(&HFF)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
    Case CP_UTF32_BE
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&H0)
        Put #the_iFileNo, , CByte(&HFE)
        Put #the_iFileNo, , CByte(&HFF)
    End Select

End Sub





Attribute VB_Name = "WinStuff"
Option Explicit

' Access the GetUserNameA function in advapi32.dll and
' call the function GetUserName.
#If VBA7 Then
Declare PtrSafe Function apiGetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
(ByVal lpBuffer As String, nSize As Long) As Long

Private Declare PtrSafe Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long

Declare PtrSafe Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal Hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare PtrSafe Function GetForegroundWindow Lib "user32.dll" () As Long
Declare PtrSafe Function GetWindow Lib "user32" (ByVal Hwnd As Long, ByVal wCmd As Long) As Long
Public Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
#Else
Declare Function apiGetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
(ByVal lpBuffer As String, nSize As Long) As Long

Private Declare Function apiGetComputerName Lib "kernel32" Alias _
    "GetComputerNameA" (ByVal lpBuffer As String, nSize As Long) As Long

Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal Hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetForegroundWindow Lib "user32.dll" () As Long
Declare Function GetWindow Lib "user32" (ByVal Hwnd As Long, ByVal wCmd As Long) As Long
Public Declare Function GetTickCount Lib "kernel32" () As Long
#End If

 Public G_MyUser As String
 Public Const GW_HWNDNEXT = 2
 Public Const GW_CHILD = 5



' Main routine to Dimension variables, retrieve user name
' and display answer.
Public Function GetUserName() As String

    If G_MyUser <> "" Then
      GetUserName = G_MyUser
      Exit Function
    End If
    
    ' Dimension variables
    Dim lpBuff As String * 25
    Dim Ret As Long
    
    ' Get the user name minus any trailing spaces found in the name.
    Ret = apiGetUserName(lpBuff, 25)
    G_MyUser = Left(lpBuff, InStr(lpBuff, Chr(0)) - 1)
    GetUserName = G_MyUser
    
End Function

Public Function GetComputerName() As String
'Returns the computername
    Dim lngLen As Long, lngX As Long
    Dim strCompName As String
    lngLen = 16
    strCompName = String$(lngLen, 0)
    lngX = apiGetComputerName(strCompName, lngLen)
    If lngX <> 0 Then
        GetComputerName = Left$(strCompName, lngLen)
    Else
        GetComputerName = ""
    End If
End Function






''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modWaitForFileClose
' By Chip Pearson, www.cpearson.com chip@cpearson.com
'
' This module contains the WaitForFileClose and IsFileOpen functions.
' See http://www.cpearson.com/excel/WaitForFileClose.htm for more documentation.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function WaitForFileClose(Filename As String, ByVal TestIntervalMilliseconds As Long, _
    ByVal TimeOutMilliseconds As Long) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' WaitForFileClose
' This function tests to see if a specified file is open. If the file is not
' open, it returns a value of True and exists immediately. If FileName is
' open, the code goes into a wait loop, testing whether the is still open
' every TestIntervalMilliSeconds. If the is closed while the function is
' waiting, the function exists with a result of True. If TimeOutMilliSeconds
' is reached and file remains open, the function exits with a result of
' False. The function will return True is FileName does not exist.
' If TimeOutMilliSeconds is reached and the file remains open, the function
' returns False.
' If FileName refers to a workbook that is open Shared, the function returns
' True and exits immediately.
' This function requires the IsFileOpen function and the Sleep and GetTickCount
' API functions.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim StartTickCount As Long
Dim EndTickCount As Long
Dim TickCountNow As Long
Dim FileIsOpen As Boolean
Dim Done As Boolean
' Dim CancelKeyState As Long

'''''''''''''''''''''''''''''''''''''''''''''''
' Before we do anything, first test if the file
' is open. If it is not, get out immediately.
'''''''''''''''''''''''''''''''''''''''''''''''
FileIsOpen = IsFileOpen(Filename:=Filename)
If FileIsOpen = False Then
    WaitForFileClose = True
    Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' If TestIntervalMilliseconds <= 0, use a default value of 500.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If TestIntervalMilliseconds <= 0 Then
    TestIntervalMilliseconds = 500
End If


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Here, we save the state of EnableCancelKey, and set it to
' xlErrorHandler. This will cause an error 18 to raised if the
' user press CTLR+BREAK. In this case, we'll abort the wait
' procedure and return False.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' CancelKeyState = Application.EnableCancelKey
' Application.EnableCancelKey = xlErrorHandler
On Error GoTo ErrHandler:

'''''''''''''''''''''''''''''''
' Get the current tick count.
'''''''''''''''''''''''''''''''
StartTickCount = GetTickCount()
If TimeOutMilliseconds <= 0 Then
    ''''''''''''''''''''''''''''''''''''''''
    ' If TimeOutMilliSeconds is negative,
    ' we'll wait forever.
    ''''''''''''''''''''''''''''''''''''''''
    EndTickCount = -1
Else
    ''''''''''''''''''''''''''''''''''''''''
    ' If TimeOutMilliseconds > 0, get the
    ' tick count value at which we will
    ' give up on the wait and return
    ' false.
    ''''''''''''''''''''''''''''''''''''''''
    EndTickCount = StartTickCount + TimeOutMilliseconds
End If

Done = False
Do Until Done
    ''''''''''''''''''''''''''''''''''''''''''''''''
    ' Test if the file is open. If it is closed,
    ' exit with a result of True.
    ''''''''''''''''''''''''''''''''''''''''''''''''
    If IsFileOpen(Filename:=Filename) = False Then
        WaitForFileClose = True
        ' Application.EnableCancelKey = CancelKeyState
        Exit Function
    End If
    ''''''''''''''''''''''''''''''''''''''''''
    ' Go to sleep for TestIntervalMilliSeconds
    ' milliseconds.
    '''''''''''''''''''''''''''''''''''''''''
    Sleep dwMilliseconds:=TestIntervalMilliseconds
    TickCountNow = GetTickCount()
    If EndTickCount > 0 Then
        '''''''''''''''''''''''''''''''''''''''''''''
        ' If EndTickCount > 0, a specified timeout
        ' value was provided. Test if we have
        ' exceeded the time. Do one last test for
        ' FileOpen, and exit.
        '''''''''''''''''''''''''''''''''''''''''''
        If TickCountNow >= EndTickCount Then
            WaitForFileClose = Not (IsFileOpen(Filename))
            ' Application.EnableCancelKey = CancelKeyState
            Exit Function
        Else
            '''''''''''''''''''''''''''''''''''''''''
            ' TickCountNow is less than EndTickCount,
            ' so continue to wait.
            '''''''''''''''''''''''''''''''''''''''''
        End If
    Else
        ''''''''''''''''''''''''''''''''
        ' EndTickCount < 0, meaning wait
        ' forever. Test if the file
        ' is open. If the file is not
        ' open, exit with a TRUE result.
        ''''''''''''''''''''''''''''''''
        If IsFileOpen(Filename:=Filename) = False Then
            WaitForFileClose = True
            ' Application.EnableCancelKey = CancelKeyState
            Exit Function
        End If
        
    End If
    DoEvents
Loop

'''''''''''''''''''''''''''''''''''''''''''''''''''
' The following Exit Function line will never be
' executed, but it included for logical consistency.
' The return code is set and the function is
' terminated within the Loop above.
'''''''''''''''''''''''''''''''''''''''''''''''''''
Exit Function

ErrHandler:
'''''''''''''''''''''''''''''''''''
' This is the error handler block.
' For any error, return False.
'''''''''''''''''''''''''''''''''''
' Application.EnableCancelKey = CancelKeyState
WaitForFileClose = False

End Function


Private Function IsFileOpen(Filename As String) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsFileOpen
' By Chip Pearson www.cpearson.com/excel chip@cpearson.com
' This function determines whether a file is open by any program. Returns TRUE or FALSE
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim filenum As Integer
Dim ErrNum As Integer

On Error Resume Next   ' Turn error checking off.

'''''''''''''''''''''''''''''''''''''''''''
' If we were passed in an empty string,
' there is no file to test so return FALSE.
'''''''''''''''''''''''''''''''''''''''''''
If Filename = vbNullString Then
    IsFileOpen = False
    Exit Function
End If

'''''''''''''''''''''''''''''''
' If the file doesn't exist,
' it isn't open so get out now.
'''''''''''''''''''''''''''''''
If Dir(Filename) = vbNullString Then
    IsFileOpen = False
    Exit Function
End If
''''''''''''''''''''''''''
' Get a free file number.
''''''''''''''''''''''''''
filenum = FreeFile()
'''''''''''''''''''''''''''
' Attempt to open the file
' and lock it.
'''''''''''''''''''''''''''
Err.Clear
Open Filename For Input Lock Read As #filenum
''''''''''''''''''''''''''''''''''''''
' Save the error number that occurred.
''''''''''''''''''''''''''''''''''''''
ErrNum = Err.Number
On Error GoTo 0        ' Turn error checking back on.
Close #filenum       ' Close the file.
''''''''''''''''''''''''''''''''''''
' Check to see which error occurred.
''''''''''''''''''''''''''''''''''''
Select Case ErrNum
    Case 0
    '''''''''''''''''''''''''''''''''''''''''''
    ' No error occurred.
    ' File is NOT already open by another user.
    '''''''''''''''''''''''''''''''''''''''''''
        IsFileOpen = False

    Case 70
    '''''''''''''''''''''''''''''''''''''''''''
    ' Error number for "Permission Denied."
    ' File is already opened by another user.
    '''''''''''''''''''''''''''''''''''''''''''
        IsFileOpen = True

    '''''''''''''''''''''''''''''''''''''''''''
    ' Another error occurred. Assume the file
    ' cannot be accessed.
    '''''''''''''''''''''''''''''''''''''''''''
    Case Else
        IsFileOpen = True
        
End Select

End Function

Sub EnableVBOM(ByVal enab As Boolean)
  On Error GoTo nogo
  Dim myRegKey As String
  Dim myValue As String
  Dim myFileAs As String
  Dim myAnswer As Integer
  
  myRegKey = "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Office\11.0\Excel\Security\AccessVBOM"
  RegKeySave myRegKey, IIf(enab, 1, 0)
  myRegKey = "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Office\12.0\Excel\Security\AccessVBOM"
  RegKeySave myRegKey, IIf(enab, 1, 0)
  myRegKey = "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Office\14.0\Excel\Security\AccessVBOM"
  RegKeySave myRegKey, IIf(enab, 1, 0)
  Exit Sub
nogo:
 
End Sub




'reads the value for the registry key i_RegKey
'if the key cannot be found, the return value is ""
Function RegKeyRead(i_RegKey As String) As String
Dim myWS As Object
 
  On Error Resume Next
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'read key from registry
  RegKeyRead = myWS.RegRead(i_RegKey)
End Function
 
'sets the registry key i_RegKey to the
'value i_Value with type i_Type
'if i_Type is omitted, the value will be saved as string
'if i_RegKey wasn't found, a new registry key will be created
 
' change REG_DWORD to the correct key type
Sub RegKeySave(i_RegKey As String, _
               i_Value As String, _
      Optional i_Type As String = "REG_DWORD")
Dim myWS As Object
 
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'write registry key
  myWS.RegWrite i_RegKey, i_Value, i_Type
 
End Sub
 
'returns True if the registry key i_RegKey was found
'and False if not
Function RegKeyExists(i_RegKey As String) As Boolean
Dim myWS As Object
 
  On Error GoTo ErrorHandler
  'access Windows scripting
  Set myWS = CreateObject("WScript.Shell")
  'try to read the registry key
  myWS.RegRead i_RegKey
  'key was found
  RegKeyExists = True
  Exit Function
   
ErrorHandler:
  'key was not found
  RegKeyExists = False
End Function



Attribute VB_Name = "XLCompare"
Option Explicit

Function FormulaHasError(c As Range)
  On Error GoTo hasError
  Dim s As String
  s = c.formula
  FormulaHasError = False
  Exit Function
hasError:
  FormulaHasError = True
End Function

Function FormulaR1C1HasError(c As Range)
  On Error GoTo hasError
  Dim s As String
  s = c.formulaR1C1
  FormulaR1C1HasError = False
  Exit Function
hasError:
  FormulaR1C1HasError = True
End Function

Attribute VB_Name = "XLFldVal"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public m_Value As Long
Public m_Txt As String

Attribute VB_Name = "XLForNext"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Public m_Name As String
Public m_Ref
Public m_Current As Long
Public m_Width As Long
Public m_WidthCurrent As Long
Attribute VB_Name = "XLScript"
Option Explicit

' Public m_LogY As Long
Private m_WS As Excel.Worksheet
Public m_Flds As Collection
Private m_FN As Collection
Private m_Excel As Excel.Application
Private m_CodeStart As String
Private m_Log As Collection

Private m_SimpleVars As Collection
Private m_Vars As Collection
Private m_VarArray As Collection
Private m_VarArray2D As Collection
Private m_GlobalObjects As Collection

Private m_inFor As Boolean

#Const USE_LATE_BINDING_MDB = True
#Const USE_LATE_BINDING_XLS = True

#If USE_LATE_BINDING_MDB = True Then
  Public m_App As Object
  Public m_DB As Object
  Public m_Workspace As Object
#Else
  Public m_App As Access.Application
  Public m_DB As Database
  Public m_Workspace As Workspace
#End If

#If USE_LATE_BINDING_XLS = True Then
  Global m_Workbook As Object
#Else
  Global m_Workbook As Excel.Workbook
#End If

Public Function XLScriptCreateAccessApp(v As Long) As Object
  Set XLScriptCreateAccessApp = CreateObject("Access.Application." & v)
End Function

Public Function XLScriptCheckAccessVersion(v As Long) As Boolean
XLScriptCheckAccessVersion = False
On Error Resume Next
  Dim o As Object
  Set o = CreateObject("Access.Application." & v)
  If Not o Is Nothing Then
    XLScriptCheckAccessVersion = True
    o.CloseCurrentDatabase
    o.Quit
    Set o = Nothing
  End If
End Function

Public Sub XLScriptStore(fn As String)
  Dim ff As Integer
  ff = FreeFile
  Open fn For Output As #ff
    Dim item
    If m_VarArray2D.Count > 0 Then
      For Each item In m_VarArray2D
        item.Store ff
      Next item
    End If
    If m_VarArray.Count > 0 Then
      For Each item In m_VarArray
        item.Store ff
      Next item
    End If
    If m_Vars.Count > 0 Then
      For Each item In m_Vars
        item.Store ff
      Next item
    End If
  Close #ff
End Sub

Public Sub XLScriptRegisterGlobalObject(n As String, o As Variant)
  
  On Error Resume Next
  m_GlobalObjects.Remove n
  
  Dim gob As XLScriptGlobalObject
  Set gob = New XLScriptGlobalObject
  gob.m_Name = n
  gob.m_Object = o
  m_GlobalObjects.Add gob, CStr(n)

End Sub

Public Function XLScriptGetGlobalObject(n As String) As Variant
  On Error GoTo NoObject
  Set XLScriptGetGlobalObject = Nothing
  Set XLScriptGetGlobalObject = m_GlobalObjects(n)
  
  Exit Function
NoObject:
  'MsgBox "ERROR: XLScriptGetGlobalObject: Object '" & n & "' not found!", vbCritical
  MsgBox FMT1("XLScript_3", n), vbCritical
End Function

Public Sub XLScriptInitGlobals()
  trsDrCount = 0
'  If m_LogY <= 0 Then m_LogY = 1
  Set m_GlobalObjects = New Collection
  Set m_FN = New Collection
  Set m_Flds = New Collection
  Set m_VarArray2D = New Collection
  Set m_VarArray = New Collection
  Set m_Vars = New Collection
  Set m_SimpleVars = New Collection
  Set m_Log = New Collection
End Sub
Public Sub XLScriptExitGlobals()
  Set m_FN = Nothing
  Set m_Flds = Nothing
  Set m_VarArray2D = Nothing
  Set m_VarArray = Nothing
  Set m_Vars = Nothing
  Set m_SimpleVars = Nothing
  Set m_Log = Nothing
  Set m_GlobalObjects = Nothing
End Sub

Public Sub XLScriptInit(ByRef ws As Excel.Worksheet, passstring As String)
  Set m_WS = ws
  m_WS.Activate
  m_CodeStart = "<!" & passstring & " "
End Sub
Public Sub XLScriptExit()
  Set m_WS = Nothing
End Sub

Public Function XLScriptCreateArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init n
  Set XLScriptCreateArray2D = da
End Function

Public Function XLScriptAddArray2D(n As String) As XLScriptArray2D
  Dim da As XLScriptArray2D
  Set da = XLScriptCreateArray2D(n)
  m_VarArray2D.Add da, CStr(n)
  Set XLScriptAddArray2D = da
End Function

Public Function XLScriptAddArray(n As String) As XLScriptArray
  Dim da As XLScriptArray
  Set da = New XLScriptArray
  da.Init n
  m_VarArray.Add da, CStr(n)
  Set XLScriptAddArray = da
End Function

Public Function XLScriptGetArray(n As String) As XLScriptArray
On Error GoTo notFound
  Set XLScriptGetArray = Nothing
  Set XLScriptGetArray = m_VarArray(CStr(n))
  Exit Function
notFound:
  'MsgBox "ERROR: XLScriptGetArray: Array '" & n & "' not found!", vbCritical
  MsgBox FMT1("XLScript_4", n), vbCritical
End Function

Public Function XLScriptGetArray2D(n As String) As XLScriptArray2D
On Error GoTo notFound
  Set XLScriptGetArray2D = Nothing
  Set XLScriptGetArray2D = m_VarArray2D(CStr(n))
  Exit Function
notFound:
  'MsgBox "ERROR: XLScriptGetArray2D: Array '" & n & "' not found!", vbCritical
  MsgBox FMT1("XLScript_5", n), vbCritical
End Function

Public Function XLScriptAddVar(n As String) As XLScriptVar
  Dim da As XLScriptVar
  Set da = New XLScriptVar
  da.Init n
  m_Vars.Add da, CStr(n)
  Set XLScriptAddVar = da
End Function

Public Function XLScriptAddSimpleVar(n As String, v) As XLScriptSimpleVar
  Dim da As XLScriptSimpleVar
  Set da = New XLScriptSimpleVar
  da.m_Txt = n
  da.m_Value = CStr(v)
  On Error GoTo nogo
  m_SimpleVars.Add da, CStr(n)
  Set XLScriptAddSimpleVar = da
  Exit Function
nogo:
End Function

Public Function XLScriptGetSimpleVar(n As String) As XLScriptSimpleVar
  Set XLScriptGetSimpleVar = Nothing
  On Error Resume Next
  Set XLScriptGetSimpleVar = m_SimpleVars(n)
End Function

' Public Sub XLScriptSetValues(c As Collection, ByRef rng As Range)
'   Dim item
'   For Each item In c
'     SetValue rng, item.m_Txt, CStr(item.m_Value)
'   Next item
' End Sub

' Private Sub SetValue(ByRef rng As Range, varTag As String, cellVal As String)
'   On Error GoTo 0
'   Dim c
'   Do
'     Set c = rng.Find(What:="<<" & varTag & ">>", LookIn:=xlValues, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Value = MyReplace(c.Value, "<<" & varTag & ">>", cellVal)
'     End If
'   Loop While Not c Is Nothing
'   Do
'     Set c = rng.Find(What:="__" & varTag & "__", LookIn:=xlFormulas, LookAt:= _
'           xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
'     If Not c Is Nothing Then
'       c.Formula = MyReplace(c.Formula, "__" & varTag & "__", cellVal)
'     End If
'   Loop While Not c Is Nothing
' End Sub

Private Function MyReplace(txt As String, searchtxt As String, replacetxt As String, Optional checkStartAndEnd As Boolean = False, Optional ignoreIn As String = "") As String
  Dim txtPos As Long
  Dim tStringRep As String
  Dim res As String
  Dim ok As Boolean
  MyReplace = txt
  If InStr(txt, searchtxt) = 0 Then Exit Function
  Dim inIgnore As Boolean
  
  inIgnore = False
  
  For txtPos = 1 To Len(txt)
    If Len(ignoreIn) > 0 Then
      If Mid(txt, txtPos, Len(ignoreIn)) = ignoreIn Then
        If Not inIgnore Then
          inIgnore = True
        Else
          inIgnore = False
        End If
      End If
    End If
    
    If Not inIgnore Then
      If Mid(txt, txtPos, Len(searchtxt)) = searchtxt Then
        ok = True
        Dim tval As String
        If checkStartAndEnd Then
          If txtPos > 1 Then
            tval = Mid(txt, txtPos - 1, 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
          If txtPos + Len(searchtxt) <= Len(txt) Then
            tval = Mid(txt, txtPos + Len(searchtxt), 1)
            If (tval >= "a" And tval <= "z") Or _
               (tval >= "A" And tval <= "Z") Or _
               (tval >= "0" And tval <= "9") Or _
               tval = "_" Then
                ok = False
            End If
          End If
        End If
        If ok Then
          res = res + replacetxt
          txtPos = txtPos + Len(searchtxt) - 1
        Else
          res = res + Mid(txt, txtPos, 1)
        End If
      Else
        res = res + Mid(txt, txtPos, 1)
      End If
    Else
      res = res + Mid(txt, txtPos, 1)
    End If
  Next txtPos
  MyReplace = res
End Function

Sub XLScriptCleanUpTags(rng As Range)
'  On Error GoTo 0
  
  Dim arr As Variant
  arr = Array("S", "0", "1", "2", "E")
  
  
  Dim c As Range
  Dim item
  For Each item In arr
    Do
      Set c = rng.Find(What:="<!" & item & " INSERTLINEABOVE", LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
      If c Is Nothing Then Exit Do
      c.Parent.Rows(c.Row).Delete Shift:=xlUp
    Loop
    
    Do
      Set c = rng.Find(What:="<!" & item & " PRINTBELOW", LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
      If c Is Nothing Then Exit Do
      c.Delete Shift:=xlUp
    Loop
  Next item
End Sub


Function XLScriptExecCode(rng As Range, Optional rightoffset As Long = 0) As Long
  Dim addedLines As Long
  addedLines = 0
  
  On Error GoTo 0
  Dim c As Range
  Dim tString As String
  Dim tLeft As String
  Dim tRight As String
  Set c = Nothing
  
  Dim firstC As Range
  Set firstC = Nothing
  Dim nextC As Range
  
  Do
    
'    Cells.Find(What:=m_CodeStart, After:=ActiveCell, LookIn:=xlValues, LookAt:= _
'        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True, _
'        SearchFormat:=False).Activate
    
    If GetRangeCount(rng) = 1 Then
      If InStr(rng.value, m_CodeStart) > 0 Then
        Set c = rng
      Else
        Set c = Nothing
      End If
    Else
      
      ' Erste gefundene Zelle abfragen
      If Not c Is Nothing And IsValid(c) And Not firstC Is Nothing And IsValid(firstC) = True Then
        If firstC.Row = c.Row And firstC.Column = c.Column Then
          Set c = Nothing
        End If
      ElseIf c Is Nothing Or Not IsValid(c) Then
        Set c = rng.Find(What:=m_CodeStart, LookIn:=xlValues, LookAt:= _
            xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=True)
        ' Erste gefundene Zelle speichern
        If Not c Is Nothing And firstC Is Nothing Then
          Set firstC = c
        End If
      Else
        Exit Do
      End If
    End If
    
    If Not c Is Nothing And IsValid(c) Then
    
      Set nextC = rng.FindNext(c)
        
      Dim pos As Long
      Dim pos2 As Long
      pos = 0
      ' ---------------------------------------------------
      
      Dim cValue As String
      cValue = c.value
      
      Do
        
        If c Is Nothing Then Exit Do
        If Not IsValid(c) Then Exit Do
        
        pos = InStr(pos + 1, cValue, m_CodeStart)
        If pos = 0 Then Exit Do
        
        Dim codeVal As String
        codeVal = Mid(cValue, pos + Len(m_CodeStart))
        
        Do
          Dim tok As String
          tok = GetToken(codeVal)
          If Len(tok) > 0 Then
            Select Case UCase(tok)
              Case "ADDRIGHT"
                tString = GetExpression(codeVal, c)
                c.Parent.Cells(c.Row, c.Column + 1).value = _
                  c.Parent.Cells(c.Row, c.Column + 1).value + _
                  Val(tString)
                  
              Case "INSERTLINEABOVE"
                If firstC.Row = c.Row Then
                  Set firstC = Cells(c.Row + 1, c.Column)
                End If
                m_WS.Rows(c.Row).Insert
                Set c = c.Parent.Cells(c.Row + 1, c.Column)
              Case "PRINT"
'                If pos > 1 Then
'                  Debug.Print "Test"
'                End If
                tString = DoPrint(codeVal, c, rightoffset)
                tLeft = ""
                If pos > 1 Then
                  tLeft = Left(cValue, pos - 1)
                End If
                pos2 = InStr(pos, cValue, ";")
                tRight = ""
                If pos2 > 0 Then
                  If pos2 + 1 < Len(cValue) Then
                    tRight = Mid(cValue, pos2 + 1)
                  End If
                ElseIf InStr(cValue, m_CodeStart) <> 1 Then
                  XLScriptAddLogEntry "Error: Command should be followed by ';'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
                End If
                c.Parent.Cells(c.Row, c.Column).value = tLeft & tString & tRight
                cValue = tLeft & tString & tRight
                pos = 0
                Exit Do
              Case "PRINTBELOW"
                DoPrintBelow codeVal, c, rightoffset
              Case "PRINTBITFIELD"
                DoPrintBitfield codeVal, c
              Case "FOR"
                m_inFor = True
                trsDrCount = 0
                addedLines = addedLines + DoFor(codeVal, c, rng)
                m_inFor = False
              Case "ROWAUTOFIT"
                c.Parent.Cells.EntireRow.AutoFit
                c.value = ""
              Case "COLUMNAUTOFIT"
                c.Parent.Cells.EntireColumn.AutoFit
                c.value = ""
              Case "DEBUG"
                Err.Raise vbObjectError + 1, "XLScript", "DEBUG forced by XLScript"
                Debug.Print "Debug forced"
                c.value = ""
              Case "DIAGDATA"
                addedLines = addedLines - 2
                DoDiagData codeVal, c, rng
              Case Else
                XLScriptAddLogEntry "Error: Unknown command '" & tok & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
                If Left(c.value, 3) = m_CodeStart Then c.value = ""
            End Select
          End If
        Loop While tok <> ""
      Loop
      
    End If
  
    If Not GetRangeCount(rng) = 1 And Not c Is Nothing Then
      Set c = nextC
    End If
  
  Loop While Not c Is Nothing
  
  XLScriptExecCode = addedLines
End Function

Private Sub OverreadLine(ByRef codeValRet As String)
  On Error GoTo 0
  Dim I As Long
  I = 1
  Do While I < Len(codeValRet) And Mid(codeValRet, I, 1) <> vbCr And Mid(codeValRet, I, 1) <> vbLf
    I = I + 1
  Loop
  Do While I < Len(codeValRet) And (Mid(codeValRet, I, 1) = vbCr Or Mid(codeValRet, I, 1) = vbLf)
    I = I + 1
  Loop
  If I > 1 Then
    codeValRet = Mid(codeValRet, I)
  End If
End Sub

Private Sub OverreadBlanks(ByRef codeValRet As String)
  On Error GoTo 0
  Dim I As Long
  I = 1
  Do While Mid(codeValRet, I, 1) = " " Or Mid(codeValRet, I, 1) = vbCr Or Mid(codeValRet, I, 1) = vbLf
    I = I + 1
  Loop
  If I > 1 Then
    codeValRet = Mid(codeValRet, I)
  End If
End Sub

Private Sub GetComma(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) <> "," Then
    XLScriptAddLogEntry "Error: Missing comma! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  codeValRet = Mid(codeValRet, 2)
End Sub

Private Function GetDef(ByRef codeValRet As String, ByRef c As Range) As xlFld
  On Error GoTo 0
  OverreadBlanks codeValRet
  
  Dim tok As String
  tok = GetToken(codeValRet)
  
  Dim item As xlFld
  For Each item In m_Flds
    If item.m_Name = tok Then
      Set GetDef = item
      Exit Function
    End If
  Next item
  
  XLScriptAddLogEntry "Error: Undefined Def '" & tok & "'! " & m_WS.name & "!" & c.Address & " Value: " & c.value
End Function

Private Function GetNumber(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim I As Long
  I = 0
  OverreadBlanks codeValRet
  
  Do While ((Mid(codeValRet, I + 1, 1) >= "0" And Mid(codeValRet, I + 1, 1) <= "9") Or _
    (Mid(codeValRet, I + 1, 1) = ".")) And I < Len(codeValRet)
    I = I + 1
  Loop
  If I > 0 Then
    token = Left(codeValRet, I)
    codeValRet = Mid(codeValRet, I + 1)
    OverreadBlanks codeValRet
  End If
  
  GetNumber = token
End Function

Private Function GetLine(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  Dim I As Long
  I = 0
  Do While I < Len(codeValRet) - 1 And Mid(codeValRet, I + 1, 1) <> vbCr And Mid(codeValRet, I + 1, 1) <> vbLf
    I = I + 1
  Loop
  If I > 0 Then
    GetLine = Left(codeValRet, I)
    codeValRet = Mid(codeValRet, I + 1)
  End If
End Function

Private Function GetNextChar(ByRef codeValRet As String) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  If Len(codeValRet) > 0 Then
    GetNextChar = Left(codeValRet, 1)
    codeValRet = Mid(codeValRet, 2)
  End If
End Function

Function GetString(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim I As Long
  I = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, I + 1, 1) <> Chr(34) And I < Len(codeValRet)
      I = I + 1
    Loop
    If I > 0 Then
      token = Left(codeValRet, I)
      codeValRet = Mid(codeValRet, I + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  End If
  
  GetString = token
End Function


Private Function GetToken(ByRef codeValRet As String) As String
  On Error GoTo 0
  Dim token As String
  Dim I As Long
  I = 0
  OverreadBlanks codeValRet
  If Left(codeValRet, 1) = Chr(34) Then
    codeValRet = Mid(codeValRet, 2)
    Do While Mid(codeValRet, I + 1, 1) <> Chr(34) And I < Len(codeValRet)
      I = I + 1
    Loop
    If I > 0 Then
      token = Left(codeValRet, I)
      codeValRet = Mid(codeValRet, I + 1)
      If Left(codeValRet, 1) = Chr(34) Then
        codeValRet = Mid(codeValRet, 2)
      End If
      OverreadBlanks codeValRet
    End If
  Else
    If ((Mid(codeValRet, I + 1, 1) >= "a" And Mid(codeValRet, I + 1, 1) <= "z") Or _
      (Mid(codeValRet, I + 1, 1) >= "A" And Mid(codeValRet, I + 1, 1) <= "Z")) And I < Len(codeValRet) Then
      Do While ((Mid(codeValRet, I + 1, 1) >= "a" And Mid(codeValRet, I + 1, 1) <= "z") Or _
        (Mid(codeValRet, I + 1, 1) >= "A" And Mid(codeValRet, I + 1, 1) <= "Z") Or _
        (Mid(codeValRet, I + 1, 1) >= "0" And Mid(codeValRet, I + 1, 1) <= "9") Or _
         Mid(codeValRet, I + 1, 1) = "_") And I < Len(codeValRet)
        I = I + 1
      Loop
      If I > 0 Then
        token = Left(codeValRet, I)
        codeValRet = Mid(codeValRet, I + 1)
        OverreadBlanks codeValRet
      End If
    Else
      token = GetNextChar(codeValRet)
    End If
  End If
  
  GetToken = token
End Function

Private Function DoPrint(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0) As String
  On Error GoTo 0
  Dim res As String
  res = GetExpression(codeValRet, c)
  If res = "" Then
    DoPrint = "'-/-"
'    c.Parent.Cells(c.Row, c.Column + rightoffset).Value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  DoPrint = res
  If Not FullVersion Then
    If m_inFor Then
      trsDrCount = trsDrCount + 1
      If trsDrCount >= 30 Then
        'DoPrint = "DEMO"
        DoPrint = FMT0("XLScript_1")
      End If
    End If
  End If
  
'  c.Parent.Cells(c.Row, c.Column + rightoffset).Value = res
End Function

Private Sub DoPrintBelow(ByRef codeValRet As String, ByRef c As Range, Optional rightoffset As Long = 0)
  On Error GoTo 0
  Dim res As String
  res = GetExpression(codeValRet, c)
  
  Dim y As Long
  y = c.Row + 1
  Do While Not IsEmpty(m_WS.Cells(y, c.Column))
    y = y + 1
  Loop
  
  If res = "" Then
    m_WS.Cells(y, c.Column).value = "'-/-"
    Exit Sub
  End If
  
  m_WS.Cells(y, c.Column).value = res
End Sub

Private Sub DoPrintBitfield(ByRef codeValRet As String, ByRef c As Range)
  On Error GoTo 0
  Dim res As String
  Dim tCodeValRet As String
  tCodeValRet = codeValRet
  res = GetExpression(codeValRet, c)
  
  If res = "" Then
    XLScriptAddLogEntry "Error: Expression not found (" & tCodeValRet & ")! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  GetComma codeValRet, c
  
  Dim f As xlFld
  Set f = GetDef(codeValRet, c)
  GetComma codeValRet, c
  
  Dim sep As String
  sep = GetExpression(codeValRet, c)
  
  Dim onlyExistant As Boolean
  onlyExistant = True
  
  Dim foundOne As Boolean
  foundOne = False
  c.value = ""
  Dim item As XLFldVal
  
  Dim cnt As Long
  Dim x As Long
  Dim rv As String
  Dim First As Boolean
  First = False
  x = &H80000000
  
  If Not onlyExistant Then
    c.value = "0x" & Hex(CLng(res)) & " (" & res & ")"
  End If
  
  Dim I As Long
  
  For cnt = 1 To 32
    If (res And x) <> 0 Then
    
      foundOne = False
      For Each item In f.m_Col
        If x = item.m_Value Then
          foundOne = True
          If Len(c.value) > 0 Then
            For I = 1 To Len(sep)
              If Mid(sep, I, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, I, 1)
              End If
            Next I
          End If
          
          If onlyExistant Then
            c.value = c.value & item.m_Txt
          Else
            c.value = c.value & "0x" & Hex(item.m_Value) & " - " & item.m_Txt
          End If
          
        End If
      Next item
      
      If Not onlyExistant Then
        If Not foundOne Then
          If Len(c.value) > 0 Then
            For I = 1 To Len(sep)
              If Mid(sep, I, 1) = "n" Then
                c.value = c.value & vbLf
              Else
                c.value = c.value & Mid(sep, I, 1)
              End If
            Next I
          End If
          
          c.value = c.value & "0x" & Hex(x) & " - ???"
        End If
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next cnt
  If Len(c.value) = 0 Then
   c.value = "'-"
  End If
'  If Not foundOne Then c.Value = res
End Sub

Private Function ValToBin(v As Long) As String
  Dim I As Long
  Dim x As Long
  Dim rv As String
  Dim First As Boolean
  First = True
  x = &H80000000
  rv = "b"
  For I = 1 To 32
    If (v And x) <> 0 Then
      First = False
      rv = rv & "1"
    Else
      If Not First Then
        rv = rv & "0"
      End If
    End If
    x = x / 2
    If x < 0 Then x = x * (-1)
  Next I
  If First Then
    rv = "b0"
  End If
  ValToBin = rv
End Function

Private Function DoFor(ByRef codeValRet As String, ByRef c As Range, rng As Range) As Long
  
  DoFor = 0
  On Error GoTo 0
  Dim tok As String
  tok = GetToken(codeValRet)
  
'  If c.Value = "<! FOR EACH item IN FuncAm" Then
'    Debug.Print "gaga"
'  End If
  

'  If c.Value = "<! FOR EACH subitem IN item.items WIDTH 4" Then
'    Debug.Print "gaga"
'  End If
  
  If UCase(tok) <> "EACH" Then
    XLScriptAddLogEntry "Error: EACH expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Exit Function
  End If
  
  Dim res As String
  res = GetVarName(codeValRet, c)
  If res = "" Then
    c.value = "'-/-"
'    XLScriptAddLogEntry "Error: PRINT missing expression! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
    Exit Function
  End If
  
  tok = GetToken(codeValRet)
  If UCase(tok) <> "IN" Then
    XLScriptAddLogEntry "Error: IN expected! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Exit Function
  End If
  
  Dim ref
  Set ref = GetRef(codeValRet, c)
  
  Dim widthAm As Long
  widthAm = 1
  tok = GetToken(codeValRet)
  If UCase(tok) = "WIDTH" Then
    tok = GetNumber(codeValRet)
    If Not IsNumeric(tok) Then
      XLScriptAddLogEntry "Error: WIDTH must be followed by numeric value! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    Else
      widthAm = CLng(tok)
    End If
  End If
  
  
  ' OK, jetzt das Ende des FOR Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "NEXT " & res, LookIn:=xlValues, LookAt:= _
        xlWhole, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: FOR EACH missing NEXT! " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  
  Dim forwidth As Long
  forwidth = cEnd.Column - c.Column + 1
  Dim forheight As Long
  forheight = cEnd.Row - c.Row + 1 - 2
  If CountReadable(ref) Then
  
    Dim fn As XLForNext
    Set fn = New XLForNext
    fn.m_Name = res
    Set fn.m_Ref = ref
    fn.m_Current = 1
    fn.m_Width = widthAm
    fn.m_WidthCurrent = 0
    m_FN.Add fn
    
    ' Ok, kopieren, dann exec
    
    Dim cnt As Long
    
    Dim addedLines As Long
    addedLines = 0
    Dim maxAddLines As Long
    maxAddLines = -10000
    
    If ref.Count > 0 Then
      For cnt = 1 To ref.Count
      
        If Beenden Then Exit For
          
        'If cnt Mod 10 = 0 Then UpdateStatus "Ausgabe: " & Format(cnt / ref.Count, "PERCENT")
        If cnt Mod 10 = 0 Then UpdateStatus FMT0("XLScript_2") & Format(cnt / ref.Count, "PERCENT")
        
        fn.m_Current = cnt - 1 + GetCollectionStart(fn.m_Ref)
        
        If fn.m_WidthCurrent = 0 Then
          m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column), _
                m_WS.Cells(cEnd.Row + 1 + addedLines + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
          maxAddLines = -10000
          ' Range(Cells(c.Row + 1, c.Column), Cells(cEnd.Row - 1, cEnd.Column)).Copy
          ' Cells(cEnd.Row + 1 + addedLines, c.Column).Insert Shift:=xlDown
        ' Else
          ' Range(Cells(c.Row + 1, c.Column), Cells(cEnd.Row - 1, cEnd.Column)).Copy
          ' Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth).Insert Shift:=xlDown
        End If
        
        m_WS.Range(m_WS.Cells(c.Row + 1, c.Column), m_WS.Cells(cEnd.Row - 1, cEnd.Column)).Copy
        m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth).PasteSpecial xlPasteAll
        
        Dim newlines As Long
        newlines = XLScriptExecCode(m_WS.Range(m_WS.Cells(cEnd.Row + 1 + addedLines, c.Column + fn.m_WidthCurrent * forwidth), m_WS.Cells(cEnd.Row + 1 + addedLines + cEnd.Row - c.Row - 2, cEnd.Column + fn.m_WidthCurrent * forwidth)), fn.m_WidthCurrent)
        If newlines > maxAddLines Then
          maxAddLines = newlines
        End If
        
        fn.m_WidthCurrent = fn.m_WidthCurrent + 1
        
        If fn.m_WidthCurrent = fn.m_Width Then
          addedLines = addedLines + maxAddLines
          addedLines = addedLines + cEnd.Row - c.Row - 1
          fn.m_WidthCurrent = 0
        End If
      Next cnt
      'UpdateStatus "Ausgabe: 100%"
      UpdateStatus FMT0("XLScript_2") & "100%"
      
      If fn.m_WidthCurrent > 0 Then
        addedLines = addedLines + maxAddLines
        addedLines = addedLines + cEnd.Row - c.Row - 1
      End If
    Else
    
      m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
            m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
      m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
      addedLines = 1
    End If
    
    cnt = 1
    Dim item As XLForNext
    For Each item In m_FN
      If item.m_Name = fn.m_Name Then
        m_FN.Remove cnt
        Exit For
      End If
      cnt = cnt + 1
    Next item
  
  Else
  
    m_WS.Range(m_WS.Cells(cEnd.Row + 1, c.Column), _
          m_WS.Cells(cEnd.Row + 1 + forheight - 1, c.Column + forwidth * widthAm - 1)).Insert Shift:=xlDown
    m_WS.Cells(cEnd.Row + 1, c.Column) = "'-/-"
    addedLines = 1
  End If
  
  addedLines = addedLines - (cEnd.Row - c.Row + 1)
  m_WS.Range(m_WS.Cells(c.Row, c.Column), m_WS.Cells(cEnd.Row, c.Column + forwidth * widthAm - 1)).Delete Shift:=xlUp
  
  
  DoFor = addedLines
End Function

Private Sub DoDiagData(ByRef codeValRet As String, ByRef c As Range, rng As Range)
  
  On Error GoTo 0
  
  Dim endofline As String
  endofline = codeValRet
  Dim tok As String
  tok = GetToken(codeValRet)
  
  ' OK, jetzt das Ende des DIAGDATA Befehls suchen
  Dim cEnd As Range
  Set cEnd = rng.Find(What:=m_CodeStart & "DIAGDATAEND " & endofline, LookIn:=xlValues, LookAt:= _
        xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False)
  
  If cEnd Is Nothing Then
    XLScriptAddLogEntry "Error: DIAGDATA " & tok & " missing DIAGDATAEND " & tok & "! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    c.EntireRow.Delete
    Exit Sub
  End If
  
  Dim coitem As ChartObject
  Dim cgitem As ChartGroup
  Dim scitem As Series
  If m_WS.ChartObjects.Count > 0 Then
    For Each coitem In m_WS.ChartObjects
      If UCase(coitem.name) = UCase(tok) Then
        For Each cgitem In coitem.Chart.ChartGroups
          Set scitem = cgitem.SeriesCollection(1)
          If IsReadableFormula(scitem) Then
            scitem.formula = "=SERIES(," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, c.Column).Address & _
              ":" & m_WS.Cells(cEnd.Row - 1, c.Column).Address & _
              "," & m_WS.name & "!" & m_WS.Cells(c.Row + 1, cEnd.Column).Address & ":" & _
              m_WS.Cells(cEnd.Row - 1, cEnd.Column).Address & ",1)"
          End If
        Next cgitem
      End If
    Next coitem
  End If
  
  cEnd.EntireRow.Delete
  c.EntireRow.Delete
  
End Sub


Private Function GetCollectionStart(c)
  On Error GoTo start1
  If IsObject(c(0)) Then
  End If
  GetCollectionStart = 0
  Exit Function
start1:
  GetCollectionStart = 1
End Function

Private Function GetExpression(ByRef codeValRet As String, c As Range) As String
  On Error GoTo 0
  OverreadBlanks codeValRet
  ' Summe auf eine Variable eines Arrays bilden
  If UCase(Left(codeValRet, 4)) = "SUM " Then
    codeValRet = Mid(codeValRet, 4)
    Dim ref
    Set ref = GetRef(codeValRet, c)
    If Not ref Is Nothing Then
      GetComma codeValRet, c
      Dim tok As String
      tok = GetToken(codeValRet)
      Dim item
      Dim s As Long
      s = 0
      For Each item In ref
        If PropertyNameExists(item, tok) Then
          s = s + CLng(item.Properties(UCase(tok)))
        Else
          XLScriptAddLogEntry "Warning: Variable '" & tok & "' not existant! " & m_WS.name & "!" & c.Address & " Value: " & c.value
        End If
      Next item
      GetExpression = s
      Exit Function
    End If
'  ElseIf Left(codeValRet, 1) >= "0" And Left(codeValRet, 1) <= "9" Then
  ElseIf (Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z") Then
    GetExpression = GetVarValue(codeValRet, c)
    Exit Function
  ElseIf Left(codeValRet, 1) = Chr(34) Then
    Dim pos As Long
    pos = InStr(2, codeValRet, Chr(34))
    If pos > 0 Then
      GetExpression = Mid(codeValRet, 2, pos - 2)
      codeValRet = Mid(codeValRet, pos + 1)
      Exit Function
    Else
      XLScriptAddLogEntry "Error: " & Chr(22) & " missing! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    End If
  End If
End Function

Private Function GetVarName(ByRef codeValRet As String, ByRef c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(tok, 1) >= "a" Or Left(tok, 1) <= "z" Or Left(tok, 1) >= "A" Or Left(tok, 1) <= "Z" Then
      GetVarName = tok
      Exit Function
    End If
  End If
  XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
End Function

Private Function GetVarValue(ByRef codeValRet As String, c As Range) As String
  On Error GoTo 0
  Dim tok As String
  Dim res As String
  
  Dim goitem As XLScriptGlobalObject
  
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
  
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
    End If
    
    
'      Case "DB"
'        res = GetDBVarValue(codeValRet, m_DB, c)
'      Case "WS"
'        res = GetDBVarValue(codeValRet, m_Workspace, c)
'      Case "APP"
'        res = GetDBVarValue(codeValRet, m_App, c)
'      Case "XL"
'        res = GetDBVarValue(codeValRet, m_Excel, c)
'      Case "XLWB"
'        res = GetDBVarValue(codeValRet, m_Workbook, c)
'      Case Else
    
    Dim found As Boolean
    found = False
    
    For Each goitem In m_GlobalObjects
      If UCase(goitem.m_Name) = UCase(tok) Then
        res = GetDBVarValue(codeValRet, goitem.m_Object, c)
        found = True
        Exit For
      End If
    Next goitem
    
    If Not found Then
      Dim item As XLForNext
      For Each item In m_FN
        If UCase(item.m_Name) = UCase(tok) Then
          res = GetDBVarValue(codeValRet, item.m_Ref(item.m_Current), c, item)
          found = True
          Exit For
        End If
      Next item
    End If
    
    ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
    If Not found Then
      Dim vaitem2d As XLScriptArray2D
      For Each vaitem2d In m_VarArray2D
        If UCase(vaitem2d.Properties("NAME")) = UCase(tok) Then
          res = GetDBVarValue(codeValRet, vaitem2d.items, c, item)
          found = True
          Exit For
        End If
      Next vaitem2d
    End If
    
        
    If Not found Then
      Dim svitem As XLScriptSimpleVar
      For Each svitem In m_SimpleVars
        If UCase(svitem.m_Txt) = UCase(tok) Then
          res = svitem.m_Value
          found = True
          Exit For
        End If
      Next svitem
    End If
    
    
    If Not found Then
      Dim vaitem As XLScriptArray
      For Each vaitem In m_VarArray
        If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
          res = GetDBVarValue(codeValRet, vaitem.items, c, item)
          found = True
          Exit For
        End If
      Next vaitem
    End If
    
    
    If Not found Then
      XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    End If
  
  End If
  GetVarValue = res
End Function

Private Function GetDBVarValue(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing) As String
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    GetDBVarValue = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res As String
  
'  If Left(codeValRet, 1) = "(" Then
'    codeValRet = Mid(codeValRet, 2)
'    res = GetExpression(codeValRet, c)
  
'    If Not Left(codeValRet, 1) = ")" Then
'      XLScriptAddLogEntry "Error: '" & tok & "(' is missing ')'! " & m_WS.name & "!" & c.Address & " Value: " & c.Value
'    End If
    
  
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
    End If
    
    If VarNameExists(par, tok) Then
      res = par(tok)
    ElseIf PropertyNameExists(par, tok) Then
      res = par.Properties(tok)
    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
          End If
        Case "ADAPTIVEMENUS"
          res = par.AdaptiveMenus
        Case "ADAPTIVEMENU"
          res = par.AdaptiveMenu
        Case "BUILD"
          res = par.Build
        Case "BUILTIN"
          res = par.BuiltIn
        Case "COMADDINS"
          res = GetDBVarValue(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          res = GetDBVarValue(codeValRet, par.CommandBars, c)
        Case "CONNECT"
          res = par.Connect
        Case "CONTEXT"
          res = par.Context
        Case "COUNT"
          res = par.Count
        Case "CREATOR"
          res = par.Creator
        Case "DBENGINE"
          res = GetDBVarValue(codeValRet, par.DBEngine, c)
        Case "DESCRIPTION"
          res = par.Description
        Case "DISABLEASKAQUESTIONDROPDOWN"
          res = par.DisableAskAQuestionDropdown
        Case "DISABLECUSTOMIZE"
          res = par.DisableCustomize
        Case "DISPLAYFONTS"
          res = par.DisplayFonts
        Case "DISPLAYKEYSINTOOLTIPS"
          res = par.DisplayKeysInTooltips
        Case "DISPLAYTOOLTIPS"
          res = par.DisplayTooltips
        Case "ENABLED"
          res = par.Enabled
        Case "FIELDS"
          res = GetDBVarValue(codeValRet, par.Fields, c)
        Case "FULLPATH"
          res = par.fullpath
        Case "GUID"
          res = par.Guid
        Case "INDEXES"
          res = GetDBVarValue(codeValRet, par.Indexesm, c)
        Case "ISBROKEN"
          res = par.isbroken
        Case "ISCOMPILED"
          res = par.IsCompiled
        Case "ITEMS"
          res = par.items
        Case "NAME"
          res = par.name
        Case "NAMELOCAL"
          res = par.NameLocal
        Case "PRINTERS"
          res = GetDBVarValue(codeValRet, par.Printers, c)
        Case "PRODUCTCODE"
          res = par.ProductCode
        Case "PROGID"
          res = par.progID
        Case "REFERENCES"
          res = GetDBVarValue(codeValRet, par.References, c)
        Case "REFERSTO"
          res = par.RefersTo
        Case "RELATIONS"
          res = GetDBVarValue(codeValRet, par.Relations, c)
        Case "SHEETS"
          res = par.Worksheets
        Case "VERSION"
          res = par.Version
        Case "VISIBLE"
          res = par.visible

        Case Else
          res = GetDBVarValue(codeValRet, par.Properties(UCase(tok)), c)
      End Select
    End If
  End If
  GetDBVarValue = res
  Exit Function
getError:
  If Len(tok) > 0 Then
    XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  
End Function

Private Function GetRef(ByRef codeValRet As String, c As Range)
  On Error GoTo 0
  Dim tok As String
  Dim res
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Trim(Mid(codeValRet, 2))
    End If
'    Select Case UCase(tok)
'      Case "DB"
'        Set res = GetDBRef(codeValRet, m_DB, c)
'      Case "WS"
'        Set res = GetDBRef(codeValRet, m_Workspace, c)
'      Case "APP"
'        Set res = GetDBRef(codeValRet, m_App, c)
'      Case "XL"
'        Set res = GetDBRef(codeValRet, m_Excel, c)
'      Case "XLWB"
'        Set res = GetDBRef(codeValRet, m_Workbook, c)
'      Case Else
        
    Dim found As Boolean
    found = False
    
    Dim goitem As XLScriptGlobalObject
    For Each goitem In m_GlobalObjects
      If UCase(goitem.m_Name) = UCase(tok) Then
        res = GetDBRef(codeValRet, goitem.m_Object, c)
        found = True
        Exit For
      End If
    Next goitem
        
        
    ' Ansonsten muss es eigentlich eine Variable sein...
    Dim item As XLForNext
    For Each item In m_FN
      If UCase(item.m_Name) = UCase(tok) Then
        Set res = GetDBRef(codeValRet, item.m_Ref(item.m_Current), c, item)
        found = True
        Exit For
      End If
    Next item
    
    ' Dann wollen wir doch mal nach "normalen" VariablenArrays schauen, die das Programm ermittelt hat
    If Not found Then
      Dim vaitem As XLScriptArray2D
      For Each vaitem In m_VarArray2D
        If UCase(vaitem.Properties("NAME")) = UCase(tok) Then
          Set res = vaitem.items
          found = True
          Exit For
        End If
      Next vaitem
    End If
    
    If Not found Then
      Dim vasitem As XLScriptArray
      For Each vasitem In m_VarArray
        If UCase(vasitem.Properties("NAME")) = UCase(tok) Then
          Set res = vasitem.items
          found = True
          Exit For
        End If
      Next vasitem
    End If
    
    If Not found Then
      XLScriptAddLogEntry "Error: '" & tok & "' is not a variable name! " & m_WS.name & "!" & c.Address & " Value: " & c.value
    End If
  End If
  If Not IsEmpty(res) Then
    Set GetRef = res
  Else
    Set GetRef = Nothing
  End If
End Function

Private Function GetDBRef(ByRef codeValRet As String, par, c As Range, Optional obj = Nothing)
  On Error GoTo getError
  
  If Len(codeValRet) = 0 Or _
    (Left(codeValRet, 1) <> "." And _
    Not ((Left(codeValRet, 1) >= "a" And Left(codeValRet, 1) <= "z") Or (Left(codeValRet, 1) >= "A" And Left(codeValRet, 1) <= "Z"))) Then
    Set GetDBRef = par
    Exit Function
  End If
  
  Dim tok As String
  Dim res
  tok = GetToken(codeValRet)
  If Len(tok) > 0 Then
    If Left(codeValRet, 1) = "." Then
      codeValRet = Mid(codeValRet, 2)
    End If
    
    
'    If PropertyNameExists(par, tok) Then
'      Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
'    Else
      Select Case UCase(tok)
        Case "FNCOUNT"
          If Not obj Is Nothing Then
            res = obj.m_Current
          Else
            XLScriptAddLogEntry "Error: '" & tok & "' is not initialized! " & m_WS.name & "!" & c.Address & " Value: " & c.value
          End If
        Case "CONTAINERS"
          Set res = GetDBRef(codeValRet, par.Containers, c)
        Case "DBENGINE"
          Set res = GetDBRef(codeValRet, par.DBEngine, c)
        Case "REFERENCES"
          Set res = GetDBRef(codeValRet, par.References, c)
        Case "RELATIONS"
          Set res = GetDBRef(codeValRet, par.Relations, c)
        Case "FIELDS"
          Set res = GetDBRef(codeValRet, par.Fields, c)
        Case "INDEXES"
          Set res = GetDBRef(codeValRet, par.Indexes, c)
        Case "PRINTERS"
          Set res = GetDBRef(codeValRet, par.Printers, c)
        Case "COMADDINS"
          Set res = GetDBRef(codeValRet, par.COMAddIns, c)
        Case "COMMANDBARS"
          Set res = GetDBRef(codeValRet, par.CommandBars, c)
        Case "COUNT"
          Set res = par.Count
        Case "BUILD"
          Set res = par.Build
        Case "ISCOMPILED"
          Set res = par.IsCompiled
        Case "PRODUCTCODE"
          Set res = par.ProductCode
        Case "VERSION"
          Set res = par.Version
        Case "TABLEDEFS"
          Set res = GetDBRef(codeValRet, par.TableDefs, c)
        Case "GROUPS"
          Set res = GetDBRef(codeValRet, par.Groups, c)
        Case "USERS"
          Set res = GetDBRef(codeValRet, par.Users, c)
        Case "NAMES"
          Set res = GetDBRef(codeValRet, par.names, c)
        Case "ITEMS"
          Set res = par.items
          
        Case Else
          If PropertyNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par.Properties(UCase(tok)), c)
          ElseIf ObjectNameExists(par, UCase(tok)) Then
            Set res = GetDBRef(codeValRet, par(UCase(tok)), c)
          End If
      End Select
'    End If
  End If
  Set GetDBRef = res
  Exit Function
getError:
  
  If Len(tok) > 0 Then
    XLScriptAddLogEntry "Warning: " & Err.Description & "  - Token: '" & tok & "' - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  Else
    XLScriptAddLogEntry "Warning: " & Err.Description & " - " & m_WS.name & "!" & c.Address & " Value: " & c.value
  End If
  Set GetDBRef = Nothing
End Function


Public Sub XLScriptAddLogEntry(s As String)
'  If Not m_ResultWorkbook Is Nothing Then
'    m_ResultWorkbook.Sheets("Log").Cells(m_LogY, 1) = s
'    m_LogY = m_LogY + 1
'  End If
  Debug.Print s
  m_Log.Add s
End Sub


Private Function CountReadable(ref) As Boolean
  On Error GoTo notReadable
  Dim I As Long
  I = ref.Count
  CountReadable = True
  Exit Function
  
notReadable:
  CountReadable = False
End Function


Public Function IsReadableFormula(anything) As Boolean
  On Error GoTo nopeNotReadable
  Dim s As String
  s = CStr(anything.formula)
  IsReadableFormula = True
  Exit Function
nopeNotReadable:
  IsReadableFormula = False
End Function

Function XLScriptGetNewObject(s As String) As Object
  Select Case s
    Case "XLScriptVar"
      Set XLScriptGetNewObject = New XLScriptVar
      Exit Function
    Case "XLScriptSimpleVar"
      Set XLScriptGetNewObject = New XLScriptSimpleVar
      Exit Function
    Case Else
      Err.Raise vbObjectError + 27, "XLScript.XLScript", "Unknown XLScriptGetNewObject type '" & s & "'"
  End Select
End Function


Function IsValid(c As Range) As Boolean
  IsValid = False
  On Error GoTo notValid
  Dim tstr
  tstr = c.value
  IsValid = True
  Exit Function
notValid:
End Function
Public Function VarNameExists(par, name As String) As Boolean
  On Error GoTo notReadable
  Dim s As String
  s = CStr(par(name))
  VarNameExists = True
  Exit Function
  
notReadable:
  VarNameExists = False
End Function

Public Function ObjectNameExists(par, name As String) As Variant
  On Error GoTo notReadable
  Dim s As Variant
  Set s = par(name)
  ObjectNameExists = True
  Exit Function
  
notReadable:
  ObjectNameExists = False
End Function

Public Function PropertyNameExists(par, name As String) As Boolean
  On Error Resume Next
  PropertyNameExists = True
  Dim s As String
  s = CStr(par.Properties(UCase(name)))
  If Err.Number = 0 Then Exit Function
  
  Err.Clear
  Dim t
  Set t = par.Properties(UCase(name))
  If Err.Number = 0 Then Exit Function
  
  PropertyNameExists = False
End Function

Public Sub XLScriptSortArray2D(name As String, _
  p1 As String, isnum1 As Boolean, _
  p2 As String, isnum2 As Boolean, _
  p3 As String, isnum3 As Boolean, _
  p4 As String, isnum4 As Boolean, _
  p5 As String, isnum5 As Boolean)
  
  
  
  Dim xlsa As XLScriptArray2D
  Set xlsa = XLScriptGetArray2D(name)
  
  If xlsa.items.Count = 0 Then Exit Sub
  
'  xlsa.Sort p1, isnum1, p2, isnum2, p3, isnum3
'  Exit Sub

  Dim arrs() As String
  ReDim arrs(xlsa.items.Count)
  Dim arrc() As Collection
  ReDim arrc(xlsa.items.Count)
  Dim arrk() As Collection
  ReDim arrk(xlsa.items.Count)
  
  Dim item As Collection
  Dim I As Long
  I = 1
  For Each item In xlsa.items
    Set arrc(I) = xlsa.items(I)
    Set arrk(I) = xlsa.itemKeys(I)
    If isnum1 = True Then
      arrs(I) = Format(item(UCase(p1)), "000000")
    Else
      arrs(I) = item(UCase(p1))
    End If
    If VarNameExists(item, UCase(p2)) Then
      If isnum2 = True Then
        arrs(I) = arrs(I) & "|" & Format(item(UCase(p2)), "000000")
      Else
        arrs(I) = arrs(I) & "|" & item(UCase(p2))
      End If
    End If
    If VarNameExists(item, UCase(p3)) Then
      If isnum3 = True Then
        arrs(I) = arrs(I) & "|" & Format(item(UCase(p3)), "000000")
      Else
        arrs(I) = arrs(I) & "|" & item(UCase(p3))
      End If
    End If
    If VarNameExists(item, UCase(p4)) Then
      If isnum4 = True Then
        arrs(I) = arrs(I) & "|" & Format(item(UCase(p4)), "000000")
      Else
        arrs(I) = arrs(I) & "|" & item(UCase(p4))
      End If
    End If
    If VarNameExists(item, UCase(p5)) Then
      If isnum5 = True Then
        arrs(I) = arrs(I) & "|" & Format(item(UCase(p5)), "000000")
      Else
        arrs(I) = arrs(I) & "|" & item(UCase(p5))
      End If
    End If
    I = I + 1
  Next item
  
  
  QuickSortOld arrs, arrc, arrk, 1, xlsa.items.Count
  
  Set xlsa.items = New Collection
  Set xlsa.itemKeys = New Collection
  For I = 1 To UBound(arrc)
'    Debug.Print arrs(i)
'    If i < UBound(arrc) - 1 Then
'      Debug.Assert arrs(i) <= arrs(i + 1)
'    End If
    xlsa.items.Add arrc(I)
    xlsa.itemKeys.Add arrk(I)
  Next I
  
End Sub

Public Sub QuickSort(ByRef MyArray() As String, SortList2() As Collection, SortList3() As Collection, ByVal lngLBound As Long, ByVal lngUBound As Long)
    Dim lngPivot As String
    Dim K As Long
    Dim p As Long
'    Dim lngTemp As Long
    Dim Temp As Variant
    
    If lngLBound >= lngUBound Then
        Exit Sub
    End If
    
    K = lngLBound + 1
    
    If lngUBound = K Then
        If StrComp(MyArray(lngLBound), MyArray(lngUBound)) > 0 Then
            'swap MyArray(lngLBound) and MyArray(lngUBound)
            Temp = MyArray(lngLBound)
            MyArray(lngLBound) = MyArray(lngUBound)
            MyArray(lngUBound) = Temp
            Set Temp = SortList2(lngLBound)                ' Swap the elements.
            Set SortList2(lngLBound) = SortList2(lngUBound)
            Set SortList2(lngUBound) = Temp
            Set Temp = SortList3(lngLBound)                ' Swap the elements.
            Set SortList3(lngLBound) = SortList3(lngUBound)
            Set SortList3(lngUBound) = Temp
        End If
        Exit Sub
    End If
    
    lngPivot = MyArray(lngLBound)
    p = lngUBound
    
    Do Until StrComp(MyArray(K), lngPivot) > 0 Or (K >= lngUBound)
        K = K + 1
    Loop
    
    Do Until StrComp(MyArray(p), lngPivot) <= 0
        p = p - 1
    Loop
    
    Do While K < p
        'swap MyArray(k) and MyArray(p)
'        lngTemp = MyArray(k)
'        MyArray(k) = MyArray(p)
'        MyArray(p) = lngTemp
        
        
        Temp = MyArray(K)
        MyArray(K) = MyArray(p)
        MyArray(p) = Temp
        Set Temp = SortList2(K)                ' Swap the elements.
        Set SortList2(K) = SortList2(p)
        Set SortList2(p) = Temp
        Set Temp = SortList3(K)                ' Swap the elements.
        Set SortList3(K) = SortList3(p)
        Set SortList3(p) = Temp
        
        
        Do
            K = K + 1
        Loop Until StrComp(MyArray(K), lngPivot) > 0
        
        Do
            p = p - 1
        Loop Until StrComp(MyArray(p), lngPivot) <= 0
    Loop
    
    'swap MyArray(p) and MyArray(lngLBound)
'    lngTemp = MyArray(p)
'    MyArray(p) = MyArray(lngLBound)
'    MyArray(lngLBound) = lngTemp
    
        Temp = MyArray(p)
        MyArray(p) = MyArray(lngLBound)
        MyArray(lngLBound) = Temp
        Set Temp = SortList2(p)                ' Swap the elements.
        Set SortList2(p) = SortList2(lngLBound)
        Set SortList2(lngLBound) = Temp
        Set Temp = SortList3(p)                ' Swap the elements.
        Set SortList3(p) = SortList3(lngLBound)
        Set SortList3(lngLBound) = Temp
    
    
    
    QuickSort MyArray, SortList2, SortList3, lngLBound, p - 1
    QuickSort MyArray, SortList2, SortList3, p + 1, lngUBound
End Sub


Sub testmich()
  
  Dim arrs() As String
  ReDim arrs(5)
  Dim arrc() As Collection
  ReDim arrc(5)
  Dim arrk() As Collection
  ReDim arrk(5)
  
  arrs(1) = "L_Anlagespiegel-000010-000008"
  arrs(2) = "L_Anlagespiegel-000009-000008"
  arrs(3) = "M_Unterschriften-000010-000008"
  arrs(4) = "L_Anlagespiegel-000010-000007"
  arrs(5) = "L_Anlagespiegel-000008-000007"

  QuickSortOld arrs, arrc, arrk, 1, 5

  
End Sub

Public Sub QuickSortOld(SortList() As String, SortList2() As Collection, SortList3() As Collection, ByVal First As Long, ByVal Last As Long)
    Dim Low As Long, High As Long         'Use Integer for lists up to 32,767 entries.
    Dim Temp As Variant, TestElement As Variant 'Variant can handle any type of list.
    Low = First
    High = Last
    TestElement = SortList((First + Last) / 2)  'Select an element from the middle.
    Do
        Do While SortList(Low) < TestElement    'Find lowest element that is >= TestElement.
            Low = Low + 1
        Loop
        Do While SortList(High) > TestElement   'Find highest element that is <= TestElement.
            High = High - 1
        Loop
        If (Low <= High) Then                   'If not done,
            Temp = SortList(Low)                ' Swap the elements.
            SortList(Low) = SortList(High)
            SortList(High) = Temp
            Set Temp = SortList2(Low)                ' Swap the elements.
            Set SortList2(Low) = SortList2(High)
            Set SortList2(High) = Temp
            Set Temp = SortList3(Low)                ' Swap the elements.
            Set SortList3(Low) = SortList3(High)
            Set SortList3(High) = Temp
            Low = Low + 1
            High = High - 1
        End If
'        ShowBitteWarten
    Loop While (Low <= High)
    If (First < High) Then QuickSortOld SortList, SortList2, SortList3, First, High
    If (Low < Last) Then QuickSortOld SortList, SortList2, SortList3, Low, Last
End Sub

Attribute VB_Name = "XLScriptArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_SortName As String
Public items As Collection
Public Properties As Collection

Public Sub Store(nr As Integer)
'  assert 0
  Write #nr, "XLScriptArray"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.Count
  Dim I As Long
  For I = 1 To items.Count
    Select Case TypeName(items(I))
      Case "XLScriptVar"
        items(I).Store nr
      Case Else
        Debug.Print "Unknown type: " & TypeName(items(I))
    End Select
  Next I
  Write #nr, Properties.Count
  For Each item In Properties
    item.Store nr
  Next item
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim I As Long
  Set Properties = New Collection
  For I = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next I
End Sub

Public Sub Init(Optional n As String = "", Optional v As String = "")
  Set Properties = New Collection
  m_SortName = n
  Properties.Add n, "NAME"
  Properties.Add v, "VAL"
  Set items = New Collection
End Sub

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items.Add v, UCase(n)
  Else
    items.Add v
  End If
End Sub

Function AddNameAndValue(n As String, v As String) As XLScriptVar
  Dim dv As XLScriptVar
  Set dv = New XLScriptVar
  dv.Init n
  dv.Properties.Add n, "NAME"
  dv.Properties.Add v, "VAL"
  items.Add dv, CStr(n)
  Set AddNameAndValue = dv
End Function

Sub AddXLScriptVar(ByRef xlsv As XLScriptVar)
  items.Add xlsv
End Sub

Public Sub AddToValue(propertyName As String, v)
'  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName) + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
End Sub


Attribute VB_Name = "XLScriptArray2D"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_SortName As String
Public items As Collection
Public itemKeys As Collection
Public Properties As Collection
Public PropertyKeys As Collection

Public Sub Store(nr As Integer)
'  assert 0
'  Close #1
  Write #nr, "XLScriptArray2D"
  Write #nr, m_SortName
  Dim item
  Write #nr, items.Count
  Dim I As Long
  If items.Count > 0 Then
    For I = 1 To items.Count
      Select Case TypeName(items(I))
        Case "Collection"
          Dim tcoll As Collection
          Set tcoll = items(I)
          Dim tcollkeys As Collection
          Set tcollkeys = itemKeys(I)
          Dim ti As Long
          If tcoll.Count > 0 Then
            For ti = 1 To tcoll.Count
              Select Case TypeName(tcoll(ti))
                Case "String"
                  Write #nr, tcollkeys(ti), tcoll(ti)
                Case Else
                  Debug.Print "Unknown type: " & TypeName(tcoll(ti))
              End Select
            Next ti
          End If
          Set tcoll = Nothing
          Set tcollkeys = Nothing
        Case "XLScriptArray"
          items(I).Store nr
        Case Else
          Debug.Print "Unknown type: " & TypeName(items(I))
      End Select
  '    Write #nr, itemKeys(i)
  '    Write #nr, items(i)
    Next I
  End If
  Write #nr, Properties.Count
  If Properties.Count > 0 Then
    For I = 1 To Properties.Count
      Write #nr, PropertyKeys(I), Properties(I)
    Next I
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim I As Long
  Set Properties = New Collection
  For I = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    tObject.ReStore nr
  Next I
End Sub


Public Sub Init(Optional name As String = "")
  m_SortName = name
  Set items = New Collection
  Set itemKeys = New Collection
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  Properties.Add name, "NAME"
  PropertyKeys.Add "NAME", "NAME"
End Sub

Public Sub AddLine()
  Dim al As Collection
  Set al = New Collection
  items.Add al
  Set al = New Collection
  itemKeys.Add al
End Sub

Public Function CurrentLine() As Variant
  Set CurrentLine = items(items.Count)
End Function

Public Sub AddValue(n As String, v As String)
  If Len(n) > 0 Then
    items(items.Count).Add v, UCase(n)
    itemKeys(items.Count).Add UCase(n), UCase(n)
  Else
    items(items.Count).Add v
    itemKeys(items.Count).Add ""
  End If
End Sub

Public Sub AddToValue(n As String, v)
'  On Error Resume Next
  If Len(n) > 0 Then
    Dim nv
    nv = items(items.Count).item(UCase(n)) + v
    items(items.Count).Remove UCase(n)
    items(items.Count).Add nv, UCase(n)
  End If
End Sub

Public Sub AddNameAndValue(n As String, v As String)
  items(items.Count).AddNameAndValue n, v
End Sub

Public Function AddXLScriptArray(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items.Add dsa, UCase(n)
  itemKeys.Add UCase(n), UCase(n)
  
  Set AddXLScriptArray = dsa

End Function

Public Function AddXLScriptArray2D(n As String) As XLScriptArray2D
' TODO: Funktionsname falsch, hier wird beim letzten Objekt eine 2D array geadded
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.Count).Add da, UCase(n)
  itemKeys(items.Count).Add UCase(n), UCase(n)
  
  AddXLScriptArray2D = da

End Function

Public Function AddXLScriptArray2DToCurrentLine(n As String) As XLScriptArray2D
' TODO: Funktionsname falsch, hier wird beim letzten Objekt eine 2D array geadded
  Dim da As XLScriptArray2D
  Set da = New XLScriptArray2D
  da.Init
  items(items.Count).Add da, UCase(n)
  itemKeys(items.Count).Add UCase(n), UCase(n)
  
  AddXLScriptArray2DToCurrentLine = da

End Function

Public Function AddXLScriptArrayToCurrentLine(n As String, Optional v As String = "") As XLScriptArray
  
  Dim dsa As XLScriptArray
  Set dsa = New XLScriptArray
  dsa.Init n, v
  items(items.Count).Add dsa, UCase(n)
  itemKeys(items.Count).Add UCase(n), UCase(n)
  
  Set AddXLScriptArrayToCurrentLine = dsa

End Function


Public Sub Sort(p1 As String, isnum1 As Boolean, p2 As String, isnum2 As Boolean, p3 As String, isnum3 As Boolean)
  Dim finished As Boolean
  
  Dim ti1 As Collection
  Dim ti2 As Collection
  
  Do
    finished = True
    Dim I As Long
    For I = 1 To items.Count - 1
      
      ShowBitteWarten
      Set ti1 = items(I)
      Set ti2 = items(I + 1)
      
      If CheckSwap(ti1, ti2, p1, isnum1, p2, isnum2, p3, isnum3) Then
          If I < items.Count - 1 Then
            items.Remove I + 1
            items.Remove I
            items.Add ti1, , I
            items.Add ti2, , I
          Else
            items.Remove I + 1
            items.Remove I
            items.Add ti2
            items.Add ti1
          End If
          finished = False
'          Exit For
      End If
    Next I
  Loop While Not finished
  'StatusForm.ProgressTxt.Caption = "Bitte warten..."
  StatusForm.ProgressTxt.Caption = FMT0("Stepping_1")
End Sub

' 1 = gleich
' 2 = gr|fffd||fffd|er
Function CompareValue(ti1 As Collection, ti2 As Collection, p As String, isnum As Boolean) As Long
  CompareValue = 0
  If (isnum = True And Val(ti1(UCase(p))) = Val(ti2(UCase(p)))) Or _
     (isnum = False And ti1(UCase(p)) = ti2(UCase(p))) Then
     CompareValue = 1
  ElseIf (isnum = True And Val(ti1(UCase(p))) > Val(ti2(UCase(p)))) Or _
         (isnum = False And ti1(UCase(p)) > ti2(UCase(p))) Then
      CompareValue = 2
  End If
     

End Function
Function CheckSwap(ti1 As Collection, ti2 As Collection, _
  p1 As String, isnum1 As Boolean, p2 As String, isnum2 As Boolean, p3 As String, isnum3 As Boolean) As Boolean
  Dim res1 As Long
  Dim res2 As Long
  Dim res3 As Long
  res1 = CompareValue(ti1, ti2, p1, isnum1)
  res2 = CompareValue(ti1, ti2, p2, isnum2)
  res3 = CompareValue(ti1, ti2, p3, isnum3)
  
  CheckSwap = False
  If res1 = 1 Then
    If res2 = 1 Then
      If res3 = 2 Then
        CheckSwap = True
      End If
    ElseIf res2 = 2 Then
        CheckSwap = True
    End If
  ElseIf res1 = 2 Then
    CheckSwap = True
  End If
  

End Function

Attribute VB_Name = "XLScriptGlobalObject"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_Object As Variant
Public m_Name As String

Attribute VB_Name = "XLScriptSimpleVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Public m_Value As String
Public m_Txt As String

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptSimpleVar"
  Write #nr, m_Value
  Write #nr, m_Txt
End Sub
Public Sub ReStore(nr As Integer)
  Input #nr, m_Value
  Input #nr, m_Txt
End Sub

Attribute VB_Name = "XLScriptVar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Public m_SortName As String
Public Properties As Collection
Public PropertyKeys As Collection

Public Sub Store(nr As Integer)
  Write #nr, "XLScriptVar"
  Write #nr, m_SortName
  Write #nr, Properties.Count
  Dim I
  If Properties.Count > 0 Then
    For I = 1 To Properties.Count
      Write #nr, PropertyKeys(I), Properties(I)
    Next I
  End If
End Sub
Public Sub ReStore(nr As Integer)
  Dim am As Long
  Input #nr, am
  Dim I As Long
  Set Properties = New Collection
  For I = 1 To am
    Dim otype As String
    Input #nr, otype
    Dim sortname As String
    Input #nr, sortname
    Dim tObject
    Set tObject = XLScriptGetNewObject(otype)
    tObject.m_SortName = sortname
    Properties.Add tObject, sortname
    PropertyKeys.Add sortname, sortname
    tObject.ReStore nr
  Next I
End Sub
Public Sub Init(ByVal n As String)
  Set Properties = New Collection
  Set PropertyKeys = New Collection
  m_SortName = n
End Sub

Function GetScriptVar(n As String) As XLScriptVar
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptVar
    Set tsv = New XLScriptVar
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptVar = Properties(UCase(n))
End Function

Function GetScriptArray(n As String) As XLScriptArray
  If Not ScriptVarExists(n) Then
    Dim tsv As XLScriptArray
    Set tsv = New XLScriptArray
    tsv.Init n
    tsv.m_SortName = UCase(n)
    Properties.Add tsv, UCase(n)
    PropertyKeys.Add UCase(n), UCase(n)
  End If
  Set GetScriptArray = Properties(UCase(n))
End Function

Function ScriptVarExists(n As String) As Boolean
  On Error GoTo doesntExist
  ScriptVarExists = True
  Dim tobj
  Set tobj = Properties(UCase(n))
doesntExist:
  ScriptVarExists = False
End Function

Public Sub AddToValue(propertyName As String, v)
'  On Error Resume Next
  If Len(propertyName) > 0 Then
    Dim nv
    nv = Properties(propertyName) + v
    Properties.Remove UCase(propertyName)
    Properties.Add nv, UCase(propertyName)
  End If
End Sub


Attribute VB_Name = "ZipStuff"
Option Explicit

Public G_7ZAvailable As Boolean
Public G_7ZTested As Boolean


Sub ExtractZip(ByVal myZipFile, ByVal myTargetDir)
     Dim intOptions, objShell, objSource, objTarget

    If G_7ZAvailable Then
      Dim errstr As String
      If ExtractZip7Z(myZipFile, myTargetDir, errstr) Then
        Exit Sub
      End If
    End If

     Set objShell = CreateObject("Shell.Application")
     Set objSource = objShell.Namespace(myZipFile).items()
     Set objTarget = objShell.Namespace(myTargetDir)

      ' These are the available CopyHere options, according to MSDN
      ' (http://msdn2.microsoft.com/en-us/library/ms723207.aspx).
     ' On my test systems, however, the options were completely ignored.
     '      4: Do not display a progress dialog box.
     '      8: Give the file a new name in a move, copy, or rename
     '         operation if a file with the target name already exists.
     '     16: Click "Yes to All" in any dialog box that is displayed.
     '     64: Preserve undo information, if possible.
     '    128: Perform the operation on files only if a wildcard file
     '         name (*.*) is specified.
     '    256: Display a progress dialog box but do not show the file
     '         names.
     '    512: Do not confirm the creation of a new directory if the
     '         operation requires one to be created.
     '   1024: Do not display a user interface if an error occurs.
     '   4096: Only operate in the local directory.
     '         Don't operate recursively into subdirectories.
     '   8192: Do not copy connected files as a group.
     '         Only copy the specified files.
      intOptions = 256

      ' UnZIP the files
     objTarget.CopyHere objSource, intOptions

     ' Release the objects
     Set objSource = Nothing
     Set objTarget = Nothing
     Set objShell = Nothing
  End Sub
  
  
Sub NewZip(sPath)
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
End Sub
  
Function ZipFolder(ByVal myFolder As String, ByVal myZipFile As String) As Boolean
    Dim oFolder
    Dim oApp As Object

    If G_7ZAvailable Then
      Dim errstr As String
      If ZipFolder7Z(myFolder, myZipFile, errstr) Then
        ZipFolder = True
        Exit Function
      End If
    End If


    Set oApp = CreateObject("Shell.Application")

    NewZip myZipFile

    If Right(myFolder, 1) <> "\" Then
        myFolder = myFolder & "\"
    End If

    'Keep script waiting until Compressing is done
    On Error GoTo nogo
    
    'Copy the files to the compressed folder
    oApp.Namespace(CStr(myZipFile)).CopyHere oApp.Namespace(CStr(myFolder)).items

    Do Until oApp.Namespace(CStr(myZipFile)).items.Count = _
    oApp.Namespace(CStr(myFolder)).items.Count
        Application.Wait (Now + TimeValue("0:00:01"))
    Loop
    ZipFolder = True
    Exit Function
nogo:
End Function



Public Function ZipErrorDesc(Code As Long) As String
' Check the 7-zip exit codes
    '   See
    '       <a href="http://linux.die.net/man/1/7za">http://linux.die.net/man/1/7za</a>
    '   for details
    Dim errdesc$
    Select Case Code
        Case 0
            errdesc$ = ""
        Case 1
            errdesc$ = "Warning (Non fatal error(s)). For example, some files cannot be read during compressing. So they were not compressed"
        Case 2
            errdesc$ = "Fatal error"
        Case 7
            errdesc$ = "Bad command line parameters"
        Case 8
            errdesc$ = "Not enough memory for operation"
        Case 255
            errdesc$ = "User stopped the process with control-C" & _
                       "(or similar)"
        Case Else
            errdesc$ = "Unknown exit code"
    End Select
    
    ZipErrorDesc = errdesc$
    
End Function

Function ZipFolder7Z(ByVal myFolder As String, ByVal myZipFile As String, ByRef errstr As String) As Boolean
    If Not PathExists(myFolder) Then
      errstr = myFolder & " existiert nicht!"
      Exit Function
    End If
    If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
      errstr = ThisWorkbook.path & "\7za.exe existiert nicht!"
      Exit Function
    End If

    Dim shellStr As String
    shellStr = Chr(34) & ThisWorkbook.path & "\7za.exe" & Chr(34) & " a " _
             & Chr(34) & myZipFile & Chr(34) & " " _
             & Chr(34) & myFolder & "\*.*" & Chr(34) & " -r"

    Dim res As Long
    res = ShellAndWait(shellStr)  ', vbHide
    If res = 0 Then
      ZipFolder7Z = True
    Else
      errstr = ZipErrorDesc(res)
    End If

End Function

Public Function ExtractZip7Z(ByVal myZipFile As String, ByVal myTargetDir As String, ByRef errstr As String) As Boolean
    
    If Not FileExists(myZipFile) Then
      errstr = myZipFile & " existiert nicht!"
      Exit Function
    End If
    If Not PathExists(myTargetDir) Then
      errstr = myTargetDir & " existiert nicht!"
      Exit Function
    End If
    If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
      errstr = ThisWorkbook.path & "\7za.exe existiert nicht!"
      Exit Function
    End If
   'There are a few commands/Switches that you can change in the ShellStr
    'We use x command now to keep the folder stucture, replace it with e if you want only the files
    '-aoa Overwrite All existing files without prompt.
    '-aos Skip extracting of existing files.
    '-aou aUto rename extracting file (for example, name.txt will be renamed to name_1.txt).
    '-aot auto rename existing file (for example, name.txt will be renamed to name_1.txt).
    'Use -r if you also want to unzip the subfolders from the zip file
    'You can add -ppassword if you want to unzip a zip file with password (only .7z files)
    'Change "*.*" to for example "*.txt" if you only want to unzip the txt files
    'Use "*.xl*" for all Excel files: xls, xlsx, xlsm, xlsb
    Dim shellStr As String
    shellStr = Chr(34) & ThisWorkbook.path & "\7za.exe" & Chr(34) & " x -aoa -r " _
             & Chr(34) & myZipFile & Chr(34) _
             & " -o" & Chr(34) & myTargetDir & Chr(34) & " " & "*.*"

    Dim res As Long
    res = ShellAndWait(shellStr)  ', vbHide
    If res = 0 Then
      ExtractZip7Z = True
    Else
      errstr = ZipErrorDesc(res)
    End If
End Function

Private Function ShellAndWait(ByVal strPathName As String) As Long
    Dim WshShell As Object
    On Error GoTo Fin
    ShellAndWait = 999
    Set WshShell = CreateObject("WScript.Shell")
    ShellAndWait = WshShell.Run(strPathName, 0, True)
Fin:
    Set WshShell = Nothing
    ' If Err.Number <> 0 Then MsgBox "Error: " & _
    '     Err.Number & " " & Err.Description
End Function


Sub TestExt()
  Dim errstr As String
  If Not ExtractZip7Z("D:\IDV-SuiteNV\IDV-Suite\ESQA\PWTester.xlsx.zip", "D:\IDV-SuiteNV\IDV-Suite\ESQA\Testdepack", errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If

  If Not ZipFolder7Z("D:\IDV-SuiteNV\IDV-Suite\ESQA\Testdepack", "D:\IDV-SuiteNV\IDV-Suite\ESQA\PWTester.xlsx.Test.zip", errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If
End Sub

Function Test7z() As Boolean
  
  If G_7ZTested Then
    Test7z = G_7ZAvailable
    Exit Function
  End If
  
  G_7ZTested = True
  
  
  If Not FileExists(ThisWorkbook.path & "\7za.exe") Then
    Debug.Print ThisWorkbook.path & "\7za.exe existiert nicht!"
    Exit Function
  End If
  If Not FileExists(ThisWorkbook.path & "\PWTester.xlsx") Then
    Debug.Print ThisWorkbook.path & "\PWTester.xlsx existiert nicht!"
    Exit Function
  End If
  Dim errstr As String
  MkFullDir G_cfgTemppfad & "\" & GetUserName
  If Not PathExists(G_cfgTemppfad & "\" & GetUserName) Then
    Debug.Print G_cfgTemppfad & "\" & GetUserName & " existiert nicht!"
    Exit Function
  End If
  
  If Not ExtractZip7Z(ThisWorkbook.path & "\PWTester.xlsx", G_cfgTemppfad & "\" & GetUserName, errstr) Then
    Debug.Print errstr
  Else
    Debug.Print "OK"
  End If
  If Not FileExists(G_cfgTemppfad & "\" & GetUserName & "\xl\workbook.xml") Then
    Debug.Print ThisWorkbook.path & "\PWTester.xlsx existiert nicht!"
    Exit Function
  End If
  
  DelTree G_cfgTemppfad & "\" & GetUserName
  
  G_7ZAvailable = True
  Test7z = True

End Function


Attribute VB_Name = "aaa_ExportCode"

Option Explicit

Private Sub CreateXLAXLAM()
  Application.DisplayAlerts = False
  ThisWorkbook.IsAddin = True
  WBRemoveTags
'  ThisWorkbook.SaveAs ThisWorkbook.Path & "\Excel-Sheet-Checker.xlam", xlOpenXMLAddIn
  ThisWorkbook.SaveAs ThisWorkbook.path & "\Excel-File-Compare.xla", xlAddIn
  ThisWorkbook.IsAddin = False
  ThisWorkbook.Saved = True
  Application.DisplayAlerts = True
End Sub


Private Sub WBRemoveTags()

    Dim nameItem As Excel.name

goAgain:
    Dim I As Long
    If ThisWorkbook.names.Count > 0 Then
      For I = 1 To ThisWorkbook.names.Count
          If ThisWorkbook.names(I).visible = False Then
              If Left(ThisWorkbook.names(I).name, Len("_IDVTracker")) = "_IDVTracker" Then
                  ThisWorkbook.names.item(I).Delete
                  GoTo goAgain
              End If
          End If
      Next I
    End If

End Sub



Private Sub ExportMyModules()
  Dim cm
  Dim counter As Long
  MkFullDir ThisWorkbook.path & "\vba"
  MyKill ThisWorkbook.path & "\vba\*.bas"
  MyKill ThisWorkbook.path & "\vba\*.cls"
  MyKill ThisWorkbook.path & "\vba\*.frx"
  MyKill ThisWorkbook.path & "\vba\*.frm"
  For Each cm In ThisWorkbook.VBProject.VBComponents
    If Not IsNull(cm) Then
      If cm.CodeModule.CountOfLines > 0 Then
        ExportVBComponent cm, ThisWorkbook.path & "\vba"
      End If
    End If
  Next

End Sub


Private Function ExportVBComponent(ByRef VBComp, _
                FolderName As String, _
                Optional Filename As String, _
                Optional OverwriteExisting As Boolean = True) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This function exports the code module of a VBComponent to a text
    ' file. If FileName is missing, the code will be exported to
    ' a file with the same name as the VBComponent followed by the
    ' appropriate extension.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim Extension As String
    Dim fname As String
    Extension = GetFileExtension(VBComp:=VBComp)
    If Trim(Filename) = vbNullString Then
        fname = VBComp.name & Extension
    Else
        fname = Filename
        If InStr(1, fname, ".", vbBinaryCompare) = 0 Then
            fname = fname & Extension
        End If
    End If
    
    If StrComp(Right(FolderName, 1), "\", vbBinaryCompare) = 0 Then
        fname = FolderName & fname
    Else
        fname = FolderName & "\" & fname
    End If
    
    If Dir(fname, vbNormal + vbHidden + vbSystem) <> vbNullString Then
        If OverwriteExisting = True Then
            Kill fname
        Else
            ExportVBComponent = False
            Exit Function
        End If
    End If
    
    VBComp.Export Filename:=fname
    ExportVBComponent = True
    
    End Function
    
Private Function GetFileExtension(ByRef VBComp) As String
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This returns the appropriate file extension based on the Type of
' the VBComponent.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Select Case VBComp.Type
        Case 2 ' vbext_ct_ClassModule
            GetFileExtension = ".cls"
        Case 100 ' vbext_ct_Document
            GetFileExtension = ".cls"
        Case 3 ' vbext_ct_MSForm
            GetFileExtension = ".frm"
        Case 1 ' vbext_ct_StdModule
            GetFileExtension = ".bas"
        Case Else
            GetFileExtension = ".bas"
    End Select
    
End Function




Attribute VB_Name = "frmLogWindow"
Attribute VB_Base = "0{C310A16F-84C4-4DCD-B3ED-9B2C389D81EE}{123724DE-8836-4E58-AF30-3E497EE222CD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub ClearLog_Click()
  LogText.Text = ""
  G_Log = ""
End Sub

Private Sub PrintTags_Click()

    Dim nameItem As Excel.name

    DebugPrint tinfo, "----- " & ActiveWorkbook.name & " -----"
    Dim I As Long
    If ActiveWorkbook.names.Count > 0 Then
      For I = 1 To ActiveWorkbook.names.Count
          If ActiveWorkbook.names(I).visible = False Then
              If InStr(ActiveWorkbook.names(I).name, "_IDVTracker") > 0 Then
                  DebugPrint tinfo, ActiveWorkbook.names.item(I).name & " = " & ActiveWorkbook.names.item(I).value
              End If
          End If
      Next I
    End If

End Sub

Private Sub ToClibboard_Click()
  CopyTextToClipboard LogText.Text
End Sub

Private Sub UserForm_Initialize()
  ' Debug.Print "Log"
  ' gTranslation.TranslateForm Me
End Sub
Attribute VB_Name = "xlFld"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Public m_Name As String
Public m_Col As Collection

Public Sub Init(n As String)
  m_Name = n
  Set m_Col = New Collection
End Sub
Attribute VB_Name = "xlHelpers"
Option Explicit

#If VBA7 And Win64 Then
' Done
Declare PtrSafe Function GetCurrentProcessId Lib "kernel32" () As Long
#Else
Declare Function GetCurrentProcessId Lib "kernel32" () As Long
#End If

Function GetCommentRange(oxlwsheet)
  Set GetCommentRange = Nothing
'  Application.DisplayAlerts = False
  On Error Resume Next
  Set GetCommentRange = oxlwsheet.Cells.SpecialCells(xlCellTypeComments)
'  Application.DisplayAlerts = CurrentDisplayAlerts
End Function


Function CommentExists(ByRef c As Range) As Boolean
  Dim s As String
  On Error GoTo doesntExist
  s = c.Comment.Text
  CommentExists = True
  Exit Function
doesntExist:
End Function

Function WorkbookExists(ByRef xlapp, wbname As String) As Boolean
  On Error GoTo nogo
  Dim wb As Workbook
'  Set wb = Workbooks(wbname)
  
  For Each wb In xlapp.Workbooks
    If UCase(wb.name) = UCase(wbname) Then
      WorkbookExists = True
      Exit Function
    End If
  Next wb
  Set wb = Nothing
  Exit Function
nogo:
End Function

Function WorkbookExistsByFilename(ByRef xlapp, wbname As String) As Boolean
  Dim wb As Workbook
  For Each wb In xlapp.Workbooks
    If UCase(wb.FullName) = UCase(wbname) Then
      WorkbookExistsByFilename = True
      Exit Function
    End If
  Next wb
  Exit Function
End Function

Function GetWorkbookByFilename(ByRef xlapp, wbname As String) As Workbook
  Dim wb As Workbook
  For Each wb In xlapp.Workbooks
    If UCase(wb.FullName) = UCase(wbname) Then
      Set GetWorkbookByFilename = wb
      Exit Function
    End If
  Next wb
  Set GetWorkbookByFilename = Nothing
End Function

Function CriticalAddinExists(ByRef xlapp As Excel.Application) As Boolean
    If CriticalAddinExistsXLA(xlapp) Then
      CriticalAddinExists = True
    End If
    If CriticalAddinExistsDLL(xlapp) Then
      CriticalAddinExists = True
    End If
    Exit Function
End Function


Private Function GetVBAProjectFilename(v) As String
  On Error Resume Next
  GetVBAProjectFilename = ""
  GetVBAProjectFilename = GetFileNameAndExtension(v.Filename)
End Function
Private Function GetVBAProjectName(v) As String
  On Error Resume Next
  GetVBAProjectName = ""
  GetVBAProjectName = v.name
End Function
Private Function GetVBAProjectDescription(v) As String
  On Error Resume Next
  GetVBAProjectDescription = ""
  GetVBAProjectDescription = v.Description
End Function

' F|fffd|r XLAM und CO
Function CriticalAddinExistsXLA(ByRef xlapp As Excel.Application) As Boolean
    On Error GoTo nogo
    CriticalAddinExistsXLA = False
    
    If G_CriticalAddins = "" Then Exit Function
    
    Dim v
    For Each v In xlapp.VBE.VBProjects
      If GetVBAProjectFilename(v) <> "" Then
        If InStr(UCase(G_CriticalAddins), UCase(GetVBAProjectFilename(v))) > 0 Then
          CriticalAddinExistsXLA = True
          Exit Function
        End If
      End If
      If GetVBAProjectName(v) <> "" Then
        If InStr(UCase(G_CriticalAddins), UCase(GetVBAProjectName(v))) > 0 Then
          CriticalAddinExistsXLA = True
          Exit Function
        End If
      End If
      If GetVBAProjectDescription(v) <> "" Then
        If InStr(UCase(G_CriticalAddins), UCase(GetVBAProjectDescription(v))) > 0 Then
          CriticalAddinExistsXLA = True
          Exit Function
        End If
      End If
      Dim A
    Next v
    Exit Function
nogo:
End Function

' f|fffd|r DLL
Function CriticalAddinExistsDLL(ByRef xlapp As Excel.Application) As Boolean
    On Error GoTo nogo
    CriticalAddinExistsDLL = False
    
    If G_CriticalAddins = "" Then Exit Function
    
    Dim s() As String
    s = Split(G_CriticalAddins, ",")
    Dim I As Long
    Dim A
    For I = LBound(s) To UBound(s)
        Dim oCOMAddin As COMAddIn
        For Each oCOMAddin In Application.COMAddIns
            If UCase(oCOMAddin.progID) = UCase(s(I)) Or UCase(oCOMAddin.Description) = UCase(s(I)) Then
              CriticalAddinExistsDLL = True
              Exit Function
            End If
        Next oCOMAddin
    Next I
    
    Exit Function
nogo:
End Function



Function GetMemUsage()
  
  ' Returns the current Excel.Application
  ' memory usage in MB
  Dim objSWbemServices
  Set objSWbemServices = GetObject("winmgmts:")
  GetMemUsage = objSWbemServices.Get( _
    "Win32_Process.Handle='" & _
    GetCurrentProcessId & "'").WorkingSetSize / 1024
    
  Set objSWbemServices = Nothing
  
End Function



' InQuest injected base64 decoded content
' ,"{^
' C9eHH
' 8AE4CS 
' z{BzYl
' +-jw
' KnjX
' KnjX
' BjW.
' L\zT
' bjR'r
' -"{^
' -"{^
' W-'+

INQUEST-PP=macro
