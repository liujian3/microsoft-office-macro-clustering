Attribute VB_Name = "CCostCode"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Name As String
Public Amount As Double
Public AllowanceAmount As Double
Public OptionAmount As Double

Public SheetName As String

Public SectionRows As Collection
Public SpecSectionRows As Collection
Public AllowanceRows As Collection
Public OptionRows As Collection

Public SheetIndex As Long



Public Function DescriptionIsBlank() As Boolean
   Dim i As Long
    Dim sRow As ItemSectionRow
    Dim v As Variant
    Dim bIsBlank As Boolean
    bIsBlank = True
    For i = 1 To SectionRows.Count
        Set sRow = SectionRows(i)
        
        If sRow.Section.ColumnExists("Description") Then
            v = sRow.Section.value(sRow.Row, sRow.Section.GetColumnIndex("Description"))
            If v <> "" And v <> 0 Then
                bIsBlank = False
            End If
        End If
    Next
    DescriptionIsBlank = bIsBlank
End Function

Public Function GetColumnTotal(sColumnKey As String) As Double
    Dim i As Long
    Dim sRow As ItemSectionRow
    Dim v As Variant
    
    For i = 1 To SectionRows.Count
        Set sRow = SectionRows(i)
        
        If sRow.Section.ColumnExists(sColumnKey) Then
            v = sRow.Section.value(sRow.Row, sRow.Section.GetColumnIndex(sColumnKey))
            If v <> "" And v <> 0 Then
                If IsNumeric(v) Then
                    d = d + CDbl(v)
                End If
            End If
        End If
    Next
    GetColumnTotal = d
End Function

Public Sub CalculateProperties()
    Dim i As Long
    Dim secRow As ItemSectionRow
    
    Amount = 0
    AllowanceAmount = 0
    OptionAmount = 0
    
    
    For i = 1 To SectionRows.Count
        Set secRow = SectionRows(i)
        If secRow.IsAllowance Then AllowanceRows.Add secRow
        If secRow.IsOption Then OptionRows.Add secRow
        If secRow.IsSpec Then
            If secRow.Description <> "[Enter customer notes here]" Then SpecSectionRows.Add secRow
        End If

        'If secRow.Total <> 0 Then
            Amount = Amount + secRow.Total
            If secRow.IsAllowance Then
                AllowanceAmount = AllowanceAmount + secRow.Total
            ElseIf secRow.IsQuote Then
                QuoteAmount = QuoteAmount + secRow.Total
            End If
            If secRow.IsOption Then
                OptionAmount = OptionAmount + secRow.Total
            Else
                If secRow.OptionCostTotal <> 0 Then
                    OptionAmount = OptionAmount + secRow.OptionCostTotal
                End If
            End If
        'End If
    Next
End Sub

Private Sub Class_Initialize()
    Set SectionRows = New Collection
    Set SpecSectionRows = New Collection
    Set AllowanceRows = New Collection
    Set OptionRows = New Collection
End Sub
Attribute VB_Name = "CFilter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'Private mValidValues As Collection
Private mOrValues As Collection
Private mAndValues As Collection
Private mOrValuesUcase As Collection
Private mAndValuesUcase As Collection
Private mOrOperators As Collection
Private mAndOperators As Collection


'Public IsNumeric As Boolean

Public Enum FilterOperator_E
    NotOperator_E
    Equals_E
    DoesNotEqual_E
    IsGreaterThan_E
    IsGreaterThanOrEqualTo_E
    IsLessThan_E
    IsLessThanOrEqualTo_E
    BeginsWith_E
    DoesNotBeginWith_E
    EndsWith_E
    DoesNotEndWith_E
    Contains_E
    DoesNotContain_E
End Enum
Public Enum FilterConditionType_E
    AndConditions_E
    OrConditions_E
End Enum
Public Event FilterChanged()

Private mFilterConditionType As FilterConditionType_E
Public Sub MiscMethod(strKey As String, ParamArray arr() As Variant)

End Sub
Public Function Clone() As filter
    Dim f As filter
    Dim i As Long
    Dim v As Variant
    Dim op As FilterOperator_E
    Dim t As FilterConditionType_E
    
    For i = 1 To ConditionCount
        GetCondition i, v, op, t
        f.AddCondition op, CStr(v), t
    Next
    Set Clone = f
End Function
Public Property Get ConditionCount() As Long
    ConditionCount = mOrValues.Count + mAndValues.Count
End Property
Public Function GetCondition(Index As Long, outValue As Variant, outOperator As FilterOperator_E, outType As FilterConditionType_E)
    'show the and conditions first
    If Index <= mAndValues.Count Then
        outValue = mAndValues(Index)
        outOperator = OperatorFromSymbol(mAndOperators(Index))
        outType = AndConditions_E
    ElseIf Index <= mAndValues.Count + mOrValues.Count Then
        outValue = mOrValues(Index - mAndValues.Count)
        outOperator = OperatorFromSymbol(mOrOperators(Index - mAndValues.Count))
        outType = OrConditions_E
    End If
End Function
Public Function ToString()
    Dim i As Long
    Dim str As String
    For i = 1 To mOrValues.Count
        str = str & IIf(Len(str) > 0, "<|>", "") & mOrOperators(i) & "||" & mOrValues(i) & "||" & "OR"
    Next
    For i = 1 To mAndValues.Count
        str = str & IIf(Len(str) > 0, "<|>", "") & mAndOperators(i) & "||" & mAndValues(i) & "||" & "AND"
    Next
    ToString = str
End Function
Public Function ToStringInWords() As String
    Dim i As Long
    Dim str As String
    For i = 1 To mOrValues.Count
        str = str & IIf(Len(str) > 0, " or ", "") & mOrOperators(i) & """" & mOrValues(i) & """"
    Next
    For i = 1 To mAndValues.Count
        str = str & IIf(Len(str) > 0, " and ", "") & mAndOperators(i) & """" & mAndValues(i) & """"
    Next
    ToStringInWords = str
End Function
Public Sub FillFromString(strValue As String)
    Dim str() As String
    Dim i As Long
    Dim values() As String
    str = Split(strValue, "<|>")
    For i = LBound(str) To UBound(str)
        values() = Split(str(i), "||")
        
        If UBound(values) >= 2 Then
            If values(2) = "OR" Then
                Me.AddCondition OperatorFromSymbol(values(0)), values(1), OrConditions_E
            Else
                Me.AddCondition OperatorFromSymbol(values(0)), values(1), AndConditions_E
            End If
        End If
    Next
    
End Sub
Public Property Get FilterConditionType() As FilterConditionType_E
    FilterConditionType = mFilterConditionType
End Property

Public Property Let FilterConditionType(ByVal FilterConditionType As FilterConditionType_E)
    mFilterConditionType = FilterConditionType
End Property

Public Function OperatorToSymbol(op As FilterOperator_E) As String
    Dim str As String
    Select Case op
        Case Equals_E:                  str = "="
        Case DoesNotEqual_E:            str = "!="
        Case IsGreaterThan_E:           str = ">"
        Case IsGreaterThanOrEqualTo_E:  str = ">="
        Case IsLessThan_E:              str = "<"
        Case IsLessThanOrEqualTo_E:     str = "<="
        Case BeginsWith_E:              str = "A"
        Case DoesNotBeginWith_E:        str = "!A"
        Case EndsWith_E:                str = "Z"
        Case DoesNotEndWith_E:          str = "!Z"
        Case Contains_E:                str = "C"
        Case DoesNotContain_E:          str = "!C"
    End Select
    OperatorToSymbol = str
End Function
Public Function GetOperatorNames() As Collection
    Dim col As Collection
    Set col = New Collection
    col.Add OperatorName(Equals_E)
    col.Add OperatorName(DoesNotEqual_E)
    col.Add OperatorName(IsGreaterThan_E)
    col.Add OperatorName(IsGreaterThanOrEqualTo_E)
    col.Add OperatorName(IsLessThan_E)
    col.Add OperatorName(IsLessThanOrEqualTo_E)
    col.Add OperatorName(BeginsWith_E)
    col.Add OperatorName(DoesNotBeginWith_E)
    col.Add OperatorName(EndsWith_E)
    col.Add OperatorName(DoesNotEndWith_E)
    col.Add OperatorName(Contains_E)
    col.Add OperatorName(DoesNotContain_E)
    Set GetOperatorNames = col
End Function
Public Function OperatorFromSymbol(str As String) As FilterOperator_E
    Dim op As FilterOperator_E
    op = NotOperator_E
    Select Case str
        Case "=": op = Equals_E
        Case "!=": op = DoesNotEqual_E
        Case "<>": op = DoesNotEqual_E
        Case ">": op = IsGreaterThan_E
        Case ">=": op = IsGreaterThanOrEqualTo_E
        Case "<": op = IsLessThan_E
        Case "<=": op = IsLessThanOrEqualTo_E
        Case "A": op = BeginsWith_E
        Case "!A": op = DoesNotBeginWith_E
        Case "Z": op = EndsWith_E
        Case "!Z": op = DoesNotEndWith_E
        Case "C": op = Contains_E
        Case "!C": op = DoesNotContain_E
        Case "": op = Equals_E
    End Select
    OperatorFromSymbol = op
End Function
Public Function OperatorFromName(strOperator As String) As FilterOperator_E
    Dim op As FilterOperator_E
    Dim str As String
    str = UCase$(Trim$(strOperator))
    
    If str = UCase$("not operator") Then
        op = NotOperator_E
    ElseIf str = UCase$("equals") Then op = Equals_E
    ElseIf str = UCase$("does not equal") Then op = DoesNotEqual_E
    ElseIf str = UCase$("is greater than") Then op = IsGreaterThan_E
    ElseIf str = UCase$("is greater than or equal to") Then op = IsGreaterThanOrEqualTo_E
    ElseIf str = UCase$("is less than") Then op = IsLessThan_E
    ElseIf str = UCase$("is less than or equal to") Then op = IsLessThanOrEqualTo_E
    ElseIf str = UCase$("begins with") Then op = BeginsWith_E
    ElseIf str = UCase$("does not begin with") Then op = DoesNotBeginWith_E
    ElseIf str = UCase$("ends with") Then op = EndsWith_E
    ElseIf str = UCase$("does not end with") Then op = DoesNotEndWith_E
    ElseIf str = UCase$("contains") Then op = Contains_E
    ElseIf str = UCase$("does not contain") Then op = DoesNotContain_E
    Else
        op = NotOperator_E
    End If
    
    OperatorFromName = op
End Function
Public Function OperatorName(operator As FilterOperator_E, Optional returnInLowerCase As Boolean = True) As String
    Dim str As String
    Select Case operator
        Case NotOperator_E: str = "not operator"
        Case Equals_E: str = "equals"
        Case DoesNotEqual_E: str = "does not equal"
        Case IsGreaterThan_E: str = "is greater than"
        Case IsGreaterThanOrEqualTo_E: str = "is greater than or equal to"
        Case IsLessThan_E: str = "is less than"
        Case IsLessThanOrEqualTo_E: str = "is less than or equal to"
        Case BeginsWith_E: str = "begins with"
        Case DoesNotBeginWith_E: str = "does not begin with"
        Case EndsWith_E: str = "ends with"
        Case DoesNotEndWith_E: str = "does not end with"
        Case Contains_E: str = "contains"
        Case DoesNotContain_E: str = "does not contain"
    End Select
    If Not returnInLowerCase Then str = StrConv(str, vbProperCase)
    OperatorName = str
End Function
Public Sub Clear()
    ResetCollections
    RaiseEvent FilterChanged
End Sub

Private Sub ResetCollections()
    Set mOrValues = New Collection
    Set mAndValues = New Collection
    Set mOrValuesUcase = New Collection
    Set mAndValuesUcase = New Collection
    Set mOrOperators = New Collection
    Set mAndOperators = New Collection
End Sub
    
Public Sub AddCondition(operator As FilterOperator_E, operand As String, Optional conditionType As FilterConditionType_E = AndConditions_E)
    If conditionType = AndConditions_E Then
        mAndValues.Add operand
        mAndValuesUcase.Add UCase$(Trim$(operand))
        mAndOperators.Add OperatorToSymbol(operator)
    Else
        mOrValues.Add operand
        mOrValuesUcase.Add UCase$(Trim$(operand))
        mOrOperators.Add OperatorToSymbol(operator)
    End If
    RaiseEvent FilterChanged
End Sub
Public Property Get HasFilter() As Boolean
    If mOrValues.Count > 0 Or mAndValues.Count > 0 Then
        HasFilter = True
    End If
End Property
Private Function ValueMeetsCondition(value As String, operator As String, operand As String) As Boolean
    Dim b As Boolean
    Dim str As String
    Dim v1 As Variant
    Dim v2 As Variant
    Dim FirstNumeric As Boolean
    
    If IsNumeric(value) Then
        FirstNumeric = True
        If InStr(1, value, ".") > 0 Then
            v1 = CDbl(value)
        Else
            v1 = CLng(value)
        End If
    Else
        v1 = UCase$(Trim$(value))
    End If
    If IsNumeric(operand) And FirstNumeric Then
        If InStr(1, operand, ".") > 0 Then
            v2 = CDbl(operand)
        Else
            v2 = CLng(operand)
        End If
    Else
        v2 = UCase$(Trim$(operand))
    End If

    b = False
    On Error Resume Next
    
    If InStr(1, operand, "*") > 0 Or InStr(1, operand, "?") Then
        Select Case operator
            Case "=": If v1 Like v2 Then b = True
            Case "!=": If Not (v1 Like v2) Then b = True
            Case ">": If v1 > v2 Then b = True
            Case ">=": If v1 >= v2 Then b = True
            Case "<": If v1 < v2 Then b = True
            Case "<=": If v1 <= v2 Then b = True
            Case "A": If Left$(v1, Len(v2)) Like v2 Then b = True
            Case "!A": If Not (Left$(v1, Len(v2)) Like v2) Then b = True
            Case "Z": If Right$(v1, Len(v2)) Like v2 Then b = True
            Case "!Z": If Not (Right$(v1, Len(v2)) Like v2) Then b = True
            Case "C": If v1 Like "*" & v2 & "*" Then b = True
            Case "!C": If Not (v1 Like "*" & v2 & "*") Then b = True
            Case Else:
                b = False
        End Select
    Else
        Select Case operator
            Case "=": If v1 = v2 Then b = True
            Case "!=": If v1 <> v2 Then b = True
            Case ">": If v1 > v2 Then b = True
            Case ">=": If v1 >= v2 Then b = True
            Case "<": If v1 < v2 Then b = True
            Case "<=": If v1 <= v2 Then b = True
            Case "A": If Left$(v1, Len(v2)) = v2 Then b = True
            Case "!A": If Left$(v1, Len(v2)) <> v2 Then b = True
            Case "Z": If Right$(v1, Len(v2)) = v2 Then b = True
            Case "!Z": If Right$(v1, Len(v2)) <> v2 Then b = True
            Case "C": If InStr(1, v1, v2) > 0 Then b = True
            Case "!C": If InStr(1, v1, v2) = 0 Then b = True
            Case Else:
                b = False
        End Select
    End If

    ValueMeetsCondition = b
End Function

Public Function FilterValueUsingOrConditions(value As String) As Boolean
    Dim i As Long
    If mOrValues.Count = 0 And mAndValues.Count = 0 Then
        FilterValueUsingOrConditions = False
        Exit Function
    End If
    
    FilterValueUsingOrConditions = False
    
    'if the value meets any of the OR filters then the value shouldn't be filtered
    For i = 1 To mOrValues.Count
        If ValueMeetsCondition(value, mOrOperators(i), mOrValuesUcase(i)) Then
            FilterValueUsingOrConditions = False
            Exit Function
        End If
    Next

    If mOrValues.Count > 0 Then
        FilterValueUsingOrConditions = True 'didn't meet any of the OR filters
    End If
End Function
Public Function FilterValueUsingAndConditions(value As String) As Boolean
    Dim i As Long
    If mOrValues.Count = 0 And mAndValues.Count = 0 Then
        FilterValueUsingAndConditions = False
        Exit Function
    End If
    
    FilterValueUsingAndConditions = False

    'if the value doesn't meet any of the AND values the filter it
    For i = 1 To mAndValues.Count
        If Not ValueMeetsCondition(value, mAndOperators(i), mAndValuesUcase(i)) Then
            FilterValueUsingAndConditions = True
            Exit Function
        End If
    Next

End Function

Public Function FilterValue(value As String) As Boolean
    Dim i As Long
    If mOrValues.Count = 0 And mAndValues.Count = 0 Then
        FilterValue = False
        Exit Function
    End If
    
    FilterValue = False
    
    'if the value meets any of the OR filters then the value shouldn't be filtered
    For i = 1 To mOrValues.Count
        If ValueMeetsCondition(value, mOrOperators(i), mOrValuesUcase(i)) Then
            FilterValue = False
            Exit Function
        End If
    Next
    
    'if the value doesn't meet any of the AND values the filter it
    For i = 1 To mAndValues.Count
        If Not ValueMeetsCondition(value, mAndOperators(i), mAndValuesUcase(i)) Then
            FilterValue = True
            Exit Function
        End If
    Next
    
  
    If mOrValues.Count > 0 Then
        FilterValue = True 'didn't meet any of the OR filters
    End If
End Function




Private Sub Class_Initialize()
    ResetCollections
    mFilterConditionType = AndConditions_E
End Sub


Attribute VB_Name = "CFilteredArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private mFilteredRows() As Variant
Private mFilteredRowsIndex() As Variant
Private mFilterRowCount As Long
Private mFilterApplied As Boolean


Private mRowFilters As Collection

Private mFilters As Collection
Private mFilterColIndexes As Collection


Private mItemsSet As Boolean
Private mItems As Variant

Public Sub Clear()
    On Error Resume Next
    Erase mItems
    mItemsSet = False
End Sub
Public Property Get ItemArray() As Variant
    ItemArray = mItems
End Property

Public Property Let ItemArray(ByVal Items As Variant)
    mItems = Items
    mItemsSet = True
End Property

Public Property Get Count() As Long
    On Error Resume Next
    If mItemsSet Then
        If IsArray(mItems) Then
            Count = UBound(mItems)
        Else
            If mItems <> "" Then
                Count = 1
            End If
        End If
    End If
End Property

Public Sub ClearFilters()
    Dim changed As Boolean
    Set mFilters = New Collection
    Set mFilterColIndexes = New Collection
    Set mRowFilters = New Collection
End Sub
Public Sub ClearColumnFilter(colIndex As Long)
    Dim f As CFilter
    Set f = GetFilterForColumn(colIndex)
    If Not f Is Nothing Then
        f.Clear
        Me.ApplyFilters 1, colIndex
        
    End If
End Sub
Public Property Get FilterCount() As Long
    On Error Resume Next
    If Not mFilters Is Nothing Then
        FilterCount = mFilters.Count
    End If
End Property
Private Function GetFilter(Index As Long) As CFilter
    On Error Resume Next
    Set GetFilter = mFilters(Index)
End Function
Private Function GetFilterForColumn(colIndex As Long) As CFilter
    Dim i As Long
    On Error Resume Next
    If mFilterColIndexes Is Nothing Then Exit Function
    For i = 1 To mFilterColIndexes.Count
        If mFilterColIndexes(i) = colIndex Then
            Set GetFilterForColumn = mFilters(i)
        End If
    Next
End Function

'if any value in a row meets the filter conditions then show the row
Public Sub AddRowFilter(filter As CFilter)
    If mRowFilters Is Nothing Then Set mRowFilters = New Collection
    mRowFilters.Add filter
End Sub
Public Sub AddFilter(colIndex As Long, filter As CFilter)
    If mFilters Is Nothing Then Set mFilters = New Collection
    If mFilterColIndexes Is Nothing Then Set mFilterColIndexes = New Collection
    
    mFilters.Add filter
    mFilterColIndexes.Add colIndex
End Sub
Public Sub ApplyFilters(infoColumn As Long, headerIndicatorColumn As Long)
    Dim cnt As Long
    Dim filterFound As Boolean
    Dim y As Long
    Dim i As Long, z As Long
    If Me.Count < 1 Then Exit Sub
    
    ReDim mFilteredRows(LBound(mItems) To UBound(mItems), 1 To 2) As Variant
    Dim changed As Boolean
    Dim arr() As Variant
    
    On Error Resume Next
    For i = LBound(mItems) To UBound(mItems)
        mFilteredRows(i, 1) = i
        mFilteredRows(i, 2) = True
    Next
    
    Dim f As CFilter
    Dim colIndex As Long
    
    
    If Not mFilters Is Nothing Then
        
        Dim orFiltersMet As Boolean
        Dim andFiltersMet As Boolean
        
        For y = LBound(mItems) To UBound(mItems)
            If mFilteredRows(y, 2) = True Then
                orFiltersMet = True
                andFiltersMet = True
                For i = 1 To mFilters.Count
                    Set f = mFilters(i)
                    colIndex = mFilterColIndexes(i)
                    If colIndex > 0 Then
                        filterFound = True
                        If f.FilterValueUsingAndConditions(CStr(mItems(y, colIndex))) = True Then
                            andFiltersMet = False
                            Exit For
                        End If
                        If f.FilterValueUsingOrConditions(CStr(mItems(y, colIndex))) = True Then
                            orFiltersMet = False
                        Else
                            orFiltersMet = True
                        End If
                    End If
                Next
                
                If orFiltersMet = False Or andFiltersMet = False Then
                    mFilteredRows(y, 2) = False
                End If
            End If
        Next
        
        
    End If
    
    
'    If Not mFilters Is Nothing Then
'        For i = 1 To mFilters.Count
'            filterFound = True
'            Set f = mFilters(i)
'            colIndex = mFilterColIndexes(i)
'            If colIndex > 0 Then
'                For y = LBound(mItems) To UBound(mItems)
'                    If mFilteredRows(y, 2) = True Then
'                        If f.FilterValue(CStr(mItems(y, colIndex))) = True Then
'                            mFilteredRows(y, 2) = False
'                        End If
'                    End If
'                Next
'            End If
'        Next
'    End If
    
    If Not mRowFilters Is Nothing Then
        For i = 1 To mRowFilters.Count
            filterFound = True
            Set f = mRowFilters(i)
            For y = LBound(mItems) To UBound(mItems)
                If mFilteredRows(y, 2) = True Then
                    For z = LBound(mItems, 2) To UBound(mItems, 2)
                        If f.FilterValue(CStr(mItems(y, z))) = False Then  'a value on the row meets the condition so keep the row
                            mFilteredRows(y, 2) = True
                            Exit For
                        End If
                        If z = UBound(mItems, 2) Then
                            mFilteredRows(y, 2) = False
                        End If
                    Next
                End If
            Next
        Next
    End If
    
       'remove any header rows that don
    'infoColumn as long, headerIndicatorColumn as Long
    'look for header rows
    Dim bIsHeader As Boolean
    Dim bIsHeader2 As Boolean
    For i = 1 To UBound(mFilteredRows)
        bIsHeader = False
        If infoColumn > 0 Then
            If InStr(1, mItems(i, infoColumn), "Header", vbTextCompare) > 0 Then
                bIsHeader = True
            End If
        End If
        If headerIndicatorColumn > 0 Then
            If mItems(i, headerIndicatorColumn) <> "" Then
                bIsHeader = True
            End If
        End If
        If bIsHeader And mFilteredRows(i, 2) = True Then
            'make sure there are rows to show under the header
            For y = i + 1 To UBound(mItems)
                bIsHeader2 = False
                If infoColumn > 0 Then
                    If InStr(1, mItems(y, infoColumn), "Header", vbTextCompare) > 0 Then
                        bIsHeader2 = True
                    End If
                End If
                If headerIndicatorColumn > 0 Then
                    If mItems(y, headerIndicatorColumn) <> "" Then
                        bIsHeader2 = True
                    End If
                End If
                If bIsHeader2 Then
                    mFilteredRows(i, 2) = False
                    Exit For
                Else
                    If mFilteredRows(y, 2) = True Then
                        'keep the row
                        Exit For
                    Else
                        'continue the loop
                    End If
                
                End If
                
                If y = UBound(mItems) Then
                    mFilteredRows(i, 2) = False
                End If
            Next
        End If
        
        Set f = mRowFilters(i)

    Next
        
        
    
    If filterFound Then
        For i = 1 To UBound(mFilteredRows)
            If mFilteredRows(i, 2) = True Then
                cnt = cnt + 1
            End If
        Next
        Dim cnt2 As Long
        If cnt > 0 Then
            ReDim arr(1 To cnt, LBound(mItems, 2) To UBound(mItems, 2))
            cnt2 = 1
            For i = 1 To UBound(mFilteredRows)
                If mFilteredRows(i, 2) = True Then
                    For y = LBound(mItems, 2) To UBound(mItems, 2)
                        arr(cnt2, y) = mItems(i, y)
                    Next
                    cnt2 = cnt2 + 1
                End If
            Next
        End If
        mItems = arr
    End If
End Sub







Attribute VB_Name = "CGroup"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mGroups As CGroupCollection
Private mGroupCols As Collection
Private mGroupOrders As Collection

Private mSortCols As Collection
Private mSortOrders As Collection

Private mTotalCols As Collection

Private mItems As CSortedArray
Private mCaption As String

Public Property Get GroupColumnCount() As Long
    If Not mGroupCols Is Nothing Then
        GroupColumnCount = mGroupCols.Count
    End If
End Property
Public Property Get SortColumnCount() As Long
    If Not mSortCols Is Nothing Then
        SortColumnCount = mSortCols.Count
    End If
End Property
Public Property Get TotalColumnCount() As Long
    If Not mTotalCols Is Nothing Then
        TotalColumnCount = mTotalCols.Count
    End If
End Property
Public Sub AddTotalColumn(columnIndex As Long)
    Dim alreadyAdded As Boolean
    Dim i As Long, y As Long
    If mTotalCols Is Nothing Then Set mTotalCols = New Collection
    
    For i = 1 To mTotalCols.Count
        If mTotalCols(i) = columnIndex Then
            alreadyAdded = True
        End If
    Next
    If Not alreadyAdded Then
        mTotalCols.Add columnIndex
    End If
    
    
    If Not mGroups Is Nothing Then
        For i = 1 To mGroups.Count
            mGroups.Item(i).AddTotalColumn columnIndex
        Next
    End If
End Sub
Public Sub AddSortColumn(columnIndex As Long, sortorder As ESortOrder)
    Dim alreadyAdded As Boolean
    Dim i As Long, y As Long
    If mSortCols Is Nothing Then Set mSortCols = New Collection
    If mSortOrders Is Nothing Then Set mSortOrders = New Collection
    
    For i = 1 To mSortCols.Count
        If mSortCols(i) = columnIndex Then
            alreadyAdded = True
            mSortOrders.Add sortorder, , i
            mSortOrders.Remove i + 1
        End If
    Next
    If Not alreadyAdded Then
        mSortCols.Add columnIndex
        mSortOrders.Add sortorder
    End If
    
    
    If Not mGroups Is Nothing Then
        For i = 1 To mGroups.Count
            mGroups.Item(i).AddSortColumn columnIndex, sortorder
        Next
    End If
End Sub

Public Sub Sort()
    Me.Items.ClearSort
    If Not mSortCols Is Nothing Then
        If mSortCols.Count > 0 Then
            If Me.Items.Count > 0 Then
                For i = 1 To mSortCols.Count
                    Me.Items.AddSortColumn mSortCols(i), mSortOrders(i)
                Next
            End If
        End If
    End If
    Me.Items.Sort
    If Not mGroups Is Nothing Then
        For i = 1 To mGroups.Count
            mGroups.Item(i).Sort
        Next
    End If
End Sub
Public Sub Group()
    If mItems Is Nothing Then Exit Sub
    If mItems.Count = 0 Then Exit Sub
    If mGroupCols Is Nothing Then Exit Sub
    If mGroupCols.Count = 0 Then Exit Sub

    'get unique values
    Dim arr As Variant
    arr = mItems.ItemArray
    Dim v() As Variant
    If IsArray(arr) Then v = arr
    Set mGroups = GroupOnColumn(mItems.ItemArray, mGroupCols(1), mGroupOrders(1))
    mItems.Clear
    
    If Not mGroups Is Nothing Then
    If Not mSortCols Is Nothing Then
        If mSortCols.Count > 0 Then
            For i = 1 To mGroups.Count
                For y = 1 To mSortCols.Count
                    mGroups.Item(i).AddSortColumn mSortCols(y), mSortOrders(y)
                Next
            Next
        End If
    End If
    If Not mTotalCols Is Nothing Then
        If mTotalCols.Count > 0 Then
            For i = 1 To mGroups.Count
                For y = 1 To mTotalCols.Count
                    mGroups.Item(i).AddTotalColumn mTotalCols(y)
                Next
            Next
        End If
    End If
    
    If mGroupCols.Count > 1 Then
        For i = 1 To mGroups.Count
            For y = 2 To mGroupCols.Count
                mGroups.Item(i).AddGroupColumn mGroupCols(y), mGroupOrders(y)
            Next
            mGroups.Item(i).Group
        Next
    End If
    End If
End Sub
Public Sub Clear()
    Set mGroupCols = New Collection
    Set mGroupOrders = New Collection
    Set mGroups = Nothing
    If Not mItems Is Nothing Then mItems.Clear
    Set mItems = Nothing
End Sub
Public Sub AddGroupColumn(columnIndex As Long, sortorder As ESortOrder)
    Dim alreadyAdded As Boolean
    
    If mGroupCols Is Nothing Then Set mGroupCols = New Collection
    If mGroupOrders Is Nothing Then Set mGroupOrders = New Collection
    
    If columnIndex < 1 Then Exit Sub
    
    For i = 1 To mGroupCols.Count
        If mGroupCols(i) = columnIndex Then
            alreadyAdded = True
            mGroupOrders.Add sortorder, , i
            mGroupOrders.Remove i + 1
        End If
    Next
    If Not alreadyAdded Then
        mGroupCols.Add columnIndex
        mGroupOrders.Add sortorder
    End If
    
End Sub
Private Sub Class_Terminate()
    Set mGroups = Nothing
End Sub
Private Function GroupOnColumn(arr As Variant, groupOnColumnIndex As Long, sortorder As ESortOrder) As CGroupCollection
    Dim uniqueValues As Collection
    
    
    Dim i As Long, y As Long, z As Long

    Set uniqueValues = New Collection
    
    On Error Resume Next
    'get unique values
    For i = LBound(arr) To UBound(arr)
        uniqueValues.Add arr(i, groupOnColumnIndex), CStr(UCase(Trim(arr(i, groupOnColumnIndex))))
    Next
    
    'sort uniquevalues
    Dim sortValues() As String
    ReDim sortValues(1 To uniqueValues.Count, 1 To 1) As String
    For i = 1 To uniqueValues.Count
        sortValues(i, 1) = uniqueValues(i)
    Next
    If sortorder = SortAscending_e Then
        QuickSort2D sortValues, , , , , True
    ElseIf sortorder = SortDescending_e Then
        QuickSort2D sortValues, , , , , False
    End If
    
    Dim allGroups As CGroupCollection
    Set allGroups = New CGroupCollection
    

    Dim rowCnt As Long
    Dim rowIndexes As Collection
    Dim groupItems() As Variant
    Dim rowIndex As Long
    
    Dim g As CGroup
    
    'fill the each unique group's items
    For i = 1 To UBound(sortValues)
        Set g = New CGroup
        g.Caption = sortValues(i, 1)
        rowCnt = 0
        Set rowIndexes = New Collection
        For y = LBound(arr) To UBound(arr)
            If CStr(UCase(Trim(arr(y, groupOnColumnIndex)))) = UCase(Trim(sortValues(i, 1))) Then
                rowCnt = rowCnt + 1
                rowIndexes.Add y
            End If
        Next
        
        ReDim groupItems(1 To rowIndexes.Count, LBound(arr, 2) To UBound(arr, 2))
        For y = 1 To rowIndexes.Count
            rowIndex = rowIndexes(y)
            For z = LBound(arr, 2) To UBound(arr, 2)
                groupItems(y, z) = arr(rowIndex, z)
            Next
        Next
        g.Items.ItemArray = groupItems
        allGroups.Add g
    Next
    
    Set GroupOnColumn = allGroups
End Function

'Be able to group on multiple columns
'Be able to sort the group ascending, descending, or no sort

Public Property Get Caption() As String
    Caption = mCaption
End Property

Public Property Let Caption(ByVal Caption As String)
    mCaption = Caption
End Property


Public Property Get Items() As CSortedArray
    If mItems Is Nothing Then Set mItems = New CSortedArray
    Set Items = mItems
End Property

Public Property Let Items(ByVal Items As CSortedArray)
    Set mItems = Items
End Property
    

Public Property Get Groups() As CGroupCollection
    If mGroups Is Nothing Then Set mGroups = New CGroupCollection
    Set Groups = mGroups
End Property
'Public Property Set Groups(value As CGroupCollection)
'    Set mGroups = value
'End Property


'columnCountForOutArray
Public Function GetArrayOfValues(columnIndexForGroupCaptions As Long, _
                            Optional outCaptionRows As Collection, _
                            Optional outCaptionRowLevels As Collection, _
                            Optional outTotalRows As Collection, _
                            Optional outTotalRowLevels As Collection, _
                            Optional outStartRows As Collection, _
                            Optional outEndRows As Collection, _
                            Optional columnCountForOutArray As Long = 0) As Variant
    Dim values() As Variant
    Dim i As Long, y As Long, z As Long
    Dim Row As Long
    If outCaptionRows Is Nothing Then Set outCaptionRows = New Collection
    If outCaptionRowLevels Is Nothing Then Set outCaptionRowLevels = New Collection
    If outTotalRows Is Nothing Then Set outTotalRows = New Collection
    If outTotalRowLevels Is Nothing Then Set outTotalRowLevels = New Collection
    If outStartRows Is Nothing Then Set outStartRows = New Collection
    If outEndRows Is Nothing Then Set outEndRows = New Collection
    
    'find an array to get the columns count
    If columnCountForOutArray = 0 Then
        columnCountForOutArray = FindArrayColumnCount(Me)
    End If
    If columnCountForOutArray = 0 Then Exit Function
    Dim rowCnt As Long
    rowCnt = Me.rowCount
    ReDim values(1 To rowCnt, 1 To columnCountForOutArray)
    Row = 0
    
    'Group Caption
    'If Me.Groups.Count > 0 Or Me.Caption <> "" Then
    
    Dim strCaption As String
    If Me.Caption = "" Then
        strCaption = "" '"(none)"
    Else
        strCaption = Me.Caption
    End If
         If columnIndexForGroupCaptions < 1 Or columnIndexForGroupCaptions > columnCountForOutArray Then
            values(1, 1) = strCaption
         Else
            values(1, columnIndexForGroupCaptions) = strCaption
        End If
        Row = 1
   ' End If
    
    'Items
    Dim arr As Variant
    If Me.Items.Count > 0 Then
        arr = Me.Items.ItemArray
        For i = 1 To UBound(arr)
            For y = 1 To UBound(arr, 2)
                values(Row + i, y) = arr(i, y)
            Next
        Next
        Row = Row + UBound(arr)
    End If
    
    'Caption and Total levels
    'the following lines of code affect the caption rows in th estimate item report
    'If Me.Groups.Count > 0 Or Me.Caption <> "" Then
        outCaptionRows.Add 1
        outCaptionRowLevels.Add 1
    'End If
    
    outStartRows.Add 1
    outEndRows.Add UBound(values)
    
     
    'groups
    Dim col As Collection
    Dim col2 As Collection
    Dim col3 As Collection
    Dim col4 As Collection
    Dim col5 As Collection
    Dim col6 As Collection
    
    For z = 1 To Me.Groups.Count
        Set col = New Collection
        Set col2 = New Collection
        Set col3 = New Collection
        Set col4 = New Collection
        Set col5 = New Collection
        Set col6 = New Collection
        
        
        arr = Me.Groups.Item(z).GetArrayOfValues(columnIndexForGroupCaptions, col, col2, col3, col4, col5, col6, columnCountForOutArray)
        For i = 1 To col.Count
            outCaptionRows.Add Row + col(i)
            outCaptionRowLevels.Add col2(i) + 1
        Next
        For i = 1 To col3.Count
           outTotalRows.Add col3(i) + Row
           outTotalRowLevels.Add col4(i) + 1
        Next
        For i = 1 To col5.Count
            outStartRows.Add col5(i) + Row
            outEndRows.Add col6(i) + Row
        Next
        For i = 1 To UBound(arr)
            For y = 1 To UBound(arr, 2)
                values(Row + i, y) = arr(i, y)
            Next
            
        Next
        Row = Row + UBound(arr)
    Next
    'Total row
    
     
     If Not mTotalCols Is Nothing Then
        If mTotalCols.Count > 0 Then
            outTotalRows.Add rowCnt
            outTotalRowLevels.Add 1
            If columnIndexForGroupCaptions < 1 Or columnIndexForGroupCaptions > columnCountForOutArray Then
                values(Row + 1, 1) = "Total " & Me.Caption
            Else
                values(Row + 1, columnIndexForGroupCaptions) = "Total " & Me.Caption
            End If
            For i = 1 To mTotalCols.Count
                values(Row + 1, mTotalCols(i)) = TotalArrayColumn(values, mTotalCols(i), outTotalRows)
            Next
        End If
        

    End If
    
    GetArrayOfValues = values
End Function
Private Function TotalArrayColumn(arr As Variant, colIndex As Long, rowsToExclude As Collection) As Double
    Dim i As Long
    On Error Resume Next
    Dim d As Double
    Dim exclude As Boolean
    For i = LBound(arr) To UBound(arr)
        exclude = False
        If Not rowsToExclude Is Nothing Then
            For y = 1 To rowsToExclude.Count
                If rowsToExclude(y) = i Then
                    exclude = True
                    Exit For
                End If
            Next
        End If
        If exclude = False Then d = CDbl(arr(i, colIndex)) + d
    Next
    TotalArrayColumn = d
End Function
Public Property Get rowCount() As Long
    Dim cnt As Long
    'Caption
    cnt = 1
    'If Me.Groups.Count > 0 Or Me.Caption <> "" Then cnt = 1
    
    'items
    cnt = cnt + Me.Items.Count
    
    For i = 1 To Me.Groups.Count
        cnt = cnt + Me.Groups.Item(i).rowCount
    Next
    If Not mTotalCols Is Nothing Then
        If mTotalCols.Count > 0 Then
            cnt = cnt + 1
        End If
    End If
    rowCount = cnt
End Property
    
Private Function FindArrayColumnCount(rootGroup As CGroup) As Long
    Dim g As CGroup
    Dim i As Long
    Dim colCount As Long
    
    If rootGroup.Items.Count > 0 Then
        FindArrayColumnCount = UBound(rootGroup.Items.ItemArray, 2)
    Else
        For i = 1 To rootGroup.Groups.Count
            Set g = rootGroup.Groups.Item(i)
            If g.Items.Count > 0 Then
                FindArrayColumnCount = UBound(g.Items.ItemArray, 2)
                Exit For
            End If
            If g.Groups.Count > 0 Then
                colCount = FindArrayColumnCount(g)
                If colCount > 0 Then
                    FindArrayColumnCount = colCount
                    Exit Function
                End If
            End If
        Next
    End If
End Function








Attribute VB_Name = "CGroupCollection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'-----------------------------------------------
' The  collection class
'-----------------------------------------------

Option Explicit
Private mGroups As New Collection

Public Enum ESortOrder
    NoSort_e
    SortAscending_e
    SortDescending_e
End Enum


'Public Sub SortGroups(sortOrder As ESortOrder)
'    Dim sortedGroups() As Variant
'    ReDim sortedGroups(1 To uniqueValues.Count, 1 To 2)
'
'        sortedGroups(i, 1) = i
'        sortedGroups(i, 2) = str
'
'            If sortOrder <> NoSort_E Then
'        If sortOrder = SortAscending_E Then
'            BubbleSort2D sortedGroups, 2, False
'        Else
'            BubbleSort2D sortedGroups, 2, True
'        End If
'
'        Dim Col As Collection
'        Set Col = New Collection
'        For i = 1 To UBound(sortedGroups)
'            Col.Add Groups.Item(CLng(sortedGroups(i, 1)))
'        Next
'        Set Groups = Col
'    End If
'End Sub

Public Function GetGroupByCaption(Caption As String)
    Dim g As CGroup
    For Each g In mGroups
        If UCase(Trim(g.Caption)) = UCase(Trim(Caption)) Then
            Set GetGroupByCaption = g
            Exit For
        End If
    Next
End Function

Sub Add(Item As CGroup, Optional key As Variant)
    mGroups.Add Item, key
End Sub
Public Sub Remove(Index As Variant)
    mGroups.Remove Index
End Sub

' Return a Group item from the collection
Function Item(Index As Variant) As CGroup
    Set Item = mGroups.Item(Index)
End Function

' Return the number of items in the collection
Property Get Count() As Long
    Count = mGroups.Count
End Property

' Remove all items from the collection
Public Sub Clear()
    Set mGroups = New Collection
End Sub







Attribute VB_Name = "CRangeUnion"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mRngs As Collection
Private mAddresses As Collection

Private mSheetName As String
Private mSht As Worksheet

Sub SetSheet(sht As Worksheet)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mSht = sht
    mSheetName = sht.Name
End Sub
Sub AddAddress(strAddr As String)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mRngs.Add strAddr
    ParseAddresses
End Sub
Sub AddRange(rng As Range)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim addr As String
    
    
    If rng Is Nothing Then Exit Sub
    If mSht Is Nothing Then Set mSht = rng.Worksheet
    If mSheetName = "" Then mSheetName = rng.Worksheet.Name
    
    'ranges have to be on the same sheet
    If rng.Worksheet.Name = mSheetName Then
        addr = rng.Address(False, False)
        mRngs.Add addr
        ParseAddresses
    End If
End Sub

Private Sub ParseAddresses()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim str As String
    Dim i As Long
    Dim temp As String

    Set mAddresses = New Collection
    
    'excel only allows a 256 length string for the range
    
    For i = 1 To mRngs.Count
        temp = str & IIf(str <> "", ",", "") & mRngs(i)
        If Len(temp) > 255 Then
            mAddresses.Add str
            str = mRngs(i)
        Else
            str = temp
        End If
    Next
    mAddresses.Add str
End Sub

Public Property Get Count() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    Count = mAddresses.Count
End Property
Public Property Get Address(Index As Long) As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    Address = mAddresses(Index)
End Property
Public Property Get Range(Index As Long) As Range
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim rng As Range
    On Error Resume Next
    Set rng = mSht.Range(mAddresses(Index))
    Set Range = rng
End Property


Private Sub Class_Initialize()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mRngs = New Collection
End Sub

Attribute VB_Name = "CReport"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mSec As ItemSection

Private mCaptionRows As Collection
Private mCaptionRowLevels As Collection
Private mTotalRows As Collection
Private mTotalRowLevels As Collection
Private mStartRows As Collection
Private mEndRows As Collection
                                            
Private mFirstVisibleColumn As Long

Private Enum RowType
    eCaptionRow = 1
    eTotalRow
End Enum
Private Type RowInfo
    IsCaptionRow As Boolean
    CaptionRowLevel As Long
    IsTotalRow As Boolean
    TotalRowLevel As Long
    IsDeleted As Boolean
    ValueRowIndex As Long
    InsertBlankRowBelow As Boolean
    CaptionLevelStartRow As Long
    CaptionLevelEndRow As Long
    TotalLevelStartRow As Long
    TotalLevelEndRow As Long
    IsHeaderRow As Boolean
    ReportRangeRowIndex As Long
    DeleteRow As Boolean
End Type

Private mValues() As Variant
Private mFormulas() As Variant

Private rows() As RowInfo

Private mIncludeHeaders As Boolean
Private mIncludeBlankHeaders As Boolean
Private mFormatHeaders As Boolean
Private mUseSummaryRows As Boolean
Private mUseSummaryRowsNoLinked As Boolean
Private mAllCaptionRows As CRangeUnion
Private mAllTotalRows As CRangeUnion
Private mAllHeaderRows As CRangeUnion

Private mSettings As CReportSettings

Public Sub Init(sec As ItemSection)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mSec = sec
    Set mSettings = New CReportSettings
    mSettings.Init sec.Range.Worksheet
    
    mFirstVisibleColumn = GetFirstVisibleColumn(sec)
    
    mIncludeHeaders = mSettings.includeHeaders
    mIncludeBlankHeaders = mSettings.IncludeBlankHeaders
    mFormatHeaders = mSettings.FormatHeaders
    mUseSummaryRows = mSettings.UseSummaryRows
    mUseSummaryRowsNoLinked = mSettings.UseSummaryRowsNoLinked
    
End Sub

Private Function HasOptionItems(wkbk As Workbook, secs As Collection, strReportType As String) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    'if it is "EstimateItems" then see if there are any options
    Dim secs2 As Collection
    Dim i As Long, y As Long
    Dim s As ItemSection
    Dim hasOptions As Boolean
    Dim colIndex As Long
    
    Set secs2 = GetWorkbookSections(wkbk, "OptionItems")
    
    If secs2.Count > 0 Then
        'see if any items are being used in the sections
        For i = 1 To secs2.Count
            Set s = secs2(i)
            If s.ColumnExists("Use") Then
                colIndex = s.GetColumnIndex("Use")
                For y = 2 To s.rowCount - 1
                    If s.IsHeaderRow(y) = False Then
                        If s.IsRowEmpty(y) = False Then
                            If s.value(y, colIndex) <> "" Then
                                hasOptions = True
                                Exit For
                            End If
                        End If
                    End If
                Next
            End If
            
            If hasOptions = True Then Exit For
        Next
    End If
    
    Dim bAddOptions As Boolean
    
    If hasOptions = True Then
        If InStr(1, strReportType, "OptionSummary", vbTextCompare) > 0 Then
            bAddOptions = False
        ElseIf InStr(1, strReportType, "Option", vbTextCompare) > 0 Then
            bAddOptions = True
        ElseIf vbYes = MsgBox("Option items found. " & vbCrLf & vbCrLf & "Include option items in report?", vbYesNo, "Option Items Found") Then
            bAddOptions = True
        End If
        If bAddOptions = True Then
            For i = 1 To secs2.Count
                secs.Add secs2(i)
            Next
        End If
    End If
    
    HasOptionItems = hasOptions
End Function

Public Sub Generate(WbWithInfo As Workbook)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim secs As Collection
    Dim str As String
    Dim values As SectionGroupValues
    Set values = New SectionGroupValues
    Dim incHeaders As Boolean
    Dim incHeadersOn As Boolean
    
    Dim FormatHeaders As Boolean
    Dim i As Long
    Dim y As Long
    Dim s As ItemSection
    Dim colIndex As Long
    Dim HasOptionItem As Boolean
    
    'fill the sections
    Set secs = GetWorkbookSections(WbWithInfo, Me.ReportType)
    
                    
    str = Me.ReportType

    If secs.Count = 0 And str = "Estimate" Then
        str = "EstimateItems"
        Set secs = GetWorkbookSections(WbWithInfo, str)
    End If
    
    'only ask to use the options if this contains estimate items
    If InStr(1, str, "Estimate", vbTextCompare) > 0 Then
        HasOptionItem = HasOptionItems(WbWithInfo, secs, str)
    End If

    Dim summarySec As ItemSection
    Dim nm As Name
    
    If mUseSummaryRows = True And InStr(1, str, "Estimate", vbTextCompare) > 0 Then
        'if we are generating for estimate sections, then we can use summary rows for blank rows
        
        If summarySec Is Nothing Then
            Set nm = WbWithInfo.names("Summary")
            If Not nm Is Nothing Then
                Set summarySec = New ItemSection
                summarySec.Init nm.RefersToRange, True
            End If
        End If
        values.Init secs, mIncludeHeaders, True, True, True, True, True, True, , summarySec, mUseSummaryRowsNoLinked
    Else
        values.Init secs, mIncludeHeaders, True, True, True, True, True, True, , , mUseSummaryRowsNoLinked
    End If
    
    'if using option items then filter them
    If HasOptionItem = True Then
        If values.Columns.ColumnKeyExists("Use") = True Then
            Dim f As CFilter
            Set f = New CFilter
            f.AddCondition DoesNotEqual_E, "", AndConditions_E
            values.AddFilterForSection values.Columns("Use").Index, f, "OptionItems"
        End If
    End If
    
    'make sure all the header rows have an "a" in the use column
    If values.Columns.ColumnKeyExists("Use") And values.Columns.ColumnKeyExists("Info") Then
        Dim infoColumn As Long
        Dim useColumn As Long
        
        infoColumn = values.Columns.Item("Info").Index
        useColumn = values.Columns.Item("Use").Index
        For i = 1 To values.rowCount
            If InStr(1, values.value(i, infoColumn), "Header", vbTextCompare) > 0 Then
                If values.value(i, useColumn) = "" Then
                    values.value(i, useColumn) = "a"
                End If
            End If
        Next
    End If

    GenerateReport values, HasOptionItem, mIncludeHeaders
    
    'hide the rows of the report
'    If mSec.ColumnExists("Description") = True Then
'        If mSec.Columns("Description").CustomProperties("HideRows") = "True" Then
'            mSec.NamedRange.RefersToRange.EntireRow.Hidden = True
'        End If
'    End If
End Sub

Private Sub GenerateReport(values As SectionGroupValues, containsOptionItems As Boolean, Optional bIncludeHeaders As Boolean = False)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim g As CGroup
    Set g = New CGroup
    
    On Error Resume Next
    
   ' settings.PrepareApplication reportList.NamedRange.Application, , False, False, True


    'Clear any borders around the area
    Dim rng As Range
    Set rng = mSec.Range
    If rng.rows.Count > 2 Then
        Set rng = rng.rows(2).Resize(rng.rows.Count - 2, rng.Columns.Count)
        rng.Borders(xlEdgeLeft).LineStyle = xlLineStyleNone
        rng.Borders(xlEdgeRight).LineStyle = xlLineStyleNone
        rng.Borders(xlInsideHorizontal).LineStyle = xlLineStyleNone
        rng.Borders(xlInsideVertical).LineStyle = xlLineStyleNone
    End If

    'Only use the values in columns of reportlist
    Dim colValues() As Variant
    Dim ItemsWith_0_Qty As Collection

    Dim infoCol As Long
    Dim headerIndicatorColumn As Long
    colValues = GetValuesInColumns(mSec, values, infoCol, mIncludeHeaders, headerIndicatorColumn)

    'prepare all the columns information in the CGroup object
    PrepareSortGroupAndTotalColumns mSec, g
    
    'Filters
    Dim filteredArr() As Variant
    filteredArr() = ApplyColumnFilters(colValues, mSec, infoCol, headerIndicatorColumn)
    g.Items.ItemArray = filteredArr
    'apply grouping and Sorts
    g.Group
    
    Dim g2 As CGroup
    g.Sort
    
  
    SendReportToExcel g, values, infoCol, headerIndicatorColumn

    'Progress.Increase
   ' settings.RestoreApplication
    'Progress.Increase
    Application.Calculation = xlCalculationAutomatic
    Dim sht As Worksheet
    Set sht = ActiveSheet
    sht.Calculate
End Sub

Public Property Get ReportType() As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim str As String
    
    On Error Resume Next
    'get the report type of the section
    'this information is normally stored in the ReportType property of a column
    
    If mSec.ColumnExists("Description") Then
        
        str = mSec.GetColumnSetting(mSec.GetColumnIndex("Description"), "ReportType")
    End If
    If str = "" Then
        For i = 1 To mSec.columnCount
            If mSec.GetColumnSetting(i, "ReportType") <> "" Then
                str = mSec.GetColumnSetting(i, "ReportType")
                Exit For
            End If
        Next
    End If
 
    'default to estimateitems
    If str = "" Then str = "EstimateItems"
    
    ReportType = str
End Property

Private Sub PrepareReportRange(reportList As ItemSection)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim rng As Range
    Set rng = reportList.Range
    
    ClearReportPictures reportList.Range.Worksheet
    ClearGroups rng.Resize(rng.rows.Count + 1)
    rng.EntireRow.Hidden = False
    mSec.SetRowCount 0
End Sub

Private Function PrepareValueArray(groupValues As CGroup, infoCol As Long, Optional includeHeaders As Boolean, Optional headerIndicatorColumn As Long) As Variant()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    
    mValues = groupValues.GetArrayOfValues(mFirstVisibleColumn, mCaptionRows, mCaptionRowLevels, _
                                            mTotalRows, mTotalRowLevels, mStartRows, mEndRows)
    
    'cut off any additional columns off end
'    If UBound(mValues) > mSec.Columns.Count Then
'        ReDim Preserve mValues(1 To mSec.Columns.Count)
'    End If
    
    Dim i As Long
    
    Dim rowCount As Long
    rowCount = UBound(mValues)
    
    If rowCount = 0 Then
        ReDim rows(0 To 0)
        
    
    ElseIf groupValues.rowCount = 0 Then
        ReDim mValues(1 To 1, 1 To reportList.Columns.Count)
        mValues(1, mFirstVisibleColumn).value = "(none)"
    Else
        'Fill Row Info
        ReDim rows(1 To UBound(mValues))
        Dim Index As Long
        
        For i = 1 To UBound(rows)
            rows(i).ValueRowIndex = i
        Next
        For i = 1 To mTotalRows.Count
            Index = CLng(mTotalRows(i))
            rows(Index).IsTotalRow = True
            rows(Index).TotalRowLevel = mTotalRowLevels(i)
            'Rows(CLng(mTotalRows(i))).InsertBlankRowBelow = True
            rows(Index).TotalLevelEndRow = Index
        Next
        
        For i = 1 To mCaptionRows.Count
            Index = CLng(mCaptionRows(i))
            rows(Index).IsCaptionRow = True
            rows(Index).CaptionRowLevel = mCaptionRowLevels(i)
            rows(Index).CaptionLevelStartRow = mStartRows(i)
            rows(Index).CaptionLevelEndRow = mEndRows(i)
            If rows(mEndRows(i)).IsTotalRow = True Then
                rows(mEndRows(i)).TotalLevelStartRow = Index
            End If
        Next
        
        'find header rows
 
        Dim bRowEmpty As Boolean
        
        'remove blank header rows
        If infoCol > 0 Then
            For i = 1 To UBound(rows)
                If CheckIsHeaderRow(i, infoCol, headerIndicatorColumn) Then
                    rows(i).IsHeaderRow = True
                    'if it is blank then delete the row
                    If mIncludeBlankHeaders = False Then
                        If mSec.ColumnExists("Description") Then
                            If mValues(i, mSec.GetColumnIndex("Description")) = "" Then
                                rows(i).IsDeleted = True
                            End If
                        Else
                            bRowEmpty = True
                            For y = 1 To mSec.columnCount
                                If y <> infoCol And mValues(i, y) <> "" Then
                                    bRowEmpty = False
                                    Exit For
                                End If
                            Next
                            If bRowEmpty = True Then rows(i).IsDeleted = True
                        End If
                    End If
                End If
            Next
        End If
        
        'if there are leading zeros in the cost codes then add a ' so excel won't make them disappear
        If mSec.ColumnExists("CostCode") Then
            Dim colIndex As Long
            colIndex = mSec.GetColumnIndex("CostCode")
            For i = LBound(mValues) To UBound(mValues)
                If IsNumeric(mValues(i, colIndex)) Then
                    If Left(mValues(i, colIndex), 1) = "0" Then
                        mValues(i, colIndex) = "'" & mValues(i, colIndex)
                    End If
                End If
            Next
        End If
        
    
        'if the array is grouped, then i want to decrease all the levels by one.  This effectively will ignore
        'the main group
        For i = 1 To UBound(rows)
            If rows(i).IsCaptionRow = True Then
                rows(i).CaptionRowLevel = rows(i).CaptionRowLevel - 1
            End If
            If rows(i).IsTotalRow = True Then
                rows(i).TotalRowLevel = rows(i).TotalRowLevel - 1
            End If
        Next
        
    End If
End Function

Private Function CheckIsHeaderRow(lRow As Long, infoCol As Long, headerIndicatorColumn As Long)
    On Error Resume Next
    
    Dim s As String
    s = mValues(lRow, infoCol)
    If InStr(1, s, "Header", vbTextCompare) > 0 Then
        CheckIsHeaderRow = True
    Else
        If headerIndicatorColumn > 0 Then
            s = mValues(lRow, headerIndicatorColumn)
            If s <> "" Then CheckIsHeaderRow = True
        End If
    End If
End Function

Private Function SendReportToExcel(groupValues As CGroup, origValues As SectionGroupValues, Optional infoCol As Long, Optional headerIndicatorColumn As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim rng As Range

    On Error Resume Next

    Dim Levels As Collection
    Dim SectionEmpty As Boolean
    Dim tempCol As Collection

    Dim colIndexes As Collection
    
    Dim values() As Variant
    Dim i As Long
    
    'if there are no total rows then add a blank row below each section

    

    PrepareReportRange mSec

    PrepareValueArray groupValues, infoCol, , headerIndicatorColumn


    Dim arr() As Variant
    
    arr = CreateRangeValues
    mSec.SetRowCount UBound(arr)
    arr = CreateRangeValues
    
    'replace total formulas
    Dim lastCaptionRow As Long
    Dim sheetRow As Long
    Dim sheetCol As Long
    Dim strLetter As String
    
    sheetRow = mSec.Range.Row
    sheetCol = mSec.Range.Column
    
    Dim tempRow As Long
    
    For i = 1 To mSec.columnCount
        If UCase(Trim(mSec.GetColumnSetting(i, "TotalColumn"))) = "TRUE" Then
            strLetter = ColumnLetter(sheetCol + i - 1)
            For y = 1 To UBound(rows)
                If rows(y).IsTotalRow = True Then
                    If rows(y).TotalLevelStartRow > 0 Then
                        tempRow = rows(rows(y).TotalLevelStartRow).ReportRangeRowIndex + 1
                        arr(rows(y).ReportRangeRowIndex, i) = "=Subtotal(9," & strLetter & (sheetRow + tempRow) & ":" & strLetter & (sheetRow + rows(y).ReportRangeRowIndex - 1) & ")"
                    End If
                End If
            Next
        End If
    Next

    
    mSec.SetRowCount UBound(arr)

    'make sure each row has same height as templaterow
    Dim templateRange As Range
    Set templateRange = mSec.TemplateRow
    
    Dim checkForWordWrapRange As Range
    Dim wordWrapRows As Boolean
    Set checkForWordWrapRange = templateRange.Application.Intersect(templateRange, mSec.Range.EntireColumn)
    If Not checkForWordWrapRange Is Nothing Then
        For i = 1 To checkForWordWrapRange.Columns.Count
            If checkForWordWrapRange.Cells(1, i).WrapText = True Then
                wordWrapRows = True
            End If
        Next
    End If

    If wordWrapRows = False Then
        If Not templateRange Is Nothing Then
            If templateRange.EntireRow.Hidden = True Then
                templateRange.EntireRow.Hidden = False
                mSec.ItemRange.EntireRow.RowHeight = templateRange.RowHeight
                templateRange.EntireRow.Hidden = True
            Else
                mSec.ItemRange.EntireRow.RowHeight = templateRange.RowHeight
            End If
        End If
    Else
        mSec.ItemRange.EntireRow.AutoFit
    End If

    
    

    'Set the font
    Set rng = mSec.ItemRange
    'rng.Font.Name = mSec.DefaultFontName
    

    ConvertCurrencyToDouble arr

    Err.Clear
    
    
    Application.EnableEvents = False
    rng.value = arr

    If Err.Number <> 0 Then
        FillManually arr, rng
    End If
    Application.EnableEvents = True
    
    'any column that has a formula and a filter will need to be filtered here
    'Dim secCol As SectionColumn
    Dim tempCell As Range

    FillCaptionAndTotalRowAddresses

    FormatReport
    Dim v As Variant
    Dim colValues() As Variant
    
    On Error Resume Next
    Dim addedRows As Collection
    Dim rowsToDelete As CRangeUnion
    Dim deleteRowAdded As Boolean
    
    Set rowsToDelete = New CRangeUnion
    Set addedRows = New Collection
    
    For i = 1 To mSec.columnCount
        Dim f As CFilter
        Set f = Nothing
        Set f = mSec.GetColumnFilter(i)
        
        If mSec.GetTemplateRowCell(i).Formula <> "" Then
            If Left(mSec.GetTemplateRowCell(i).Formula, 1) = "=" Then
                If Not f Is Nothing Then
                    colValues = rng.Columns(i).value
                    'loop through the rows and see which ones need to be filtered
                    For y = 1 To UBound(rows)
                        If rows(y).IsDeleted = False And rows(y).IsTotalRow = False And rows(y).IsCaptionRow = False And rows(y).IsHeaderRow = False Then
                            v = colValues(rows(y).ValueRowIndex, 1)
                            If secCol.filter.FilterValue(CStr(v)) = True Then
                                Set tempCell = rng.Cells(rows(y).ValueRowIndex, i)
                                If Not tempCell Is Nothing Then
                                    rows(y).DeleteRow = True
                                    'tempCell.Interior.ColorIndex = 20
                                End If
                            End If
                        End If
                    Next
                End If
            End If
        End If
    Next
    
    
    
    'see if there are any sections that are blank
    Dim lastRowIsCaption As Boolean
    Dim lastCaptionRowIndex As Long
    Dim lastCaptionRowLevel As Long
    
    Dim captionRows As CRangeUnion
    Set captionRows = New CRangeUnion
    
    For i = 1 To UBound(rows)
        If rows(i).IsDeleted = False Then
            If rows(i).IsCaptionRow = True Then
                If lastRowIsCaption = True And lastCaptionRowLevel = rows(i).CaptionRowLevel Then
                    'there was an empty caption row last, remove it
                    rows(lastCaptionRowIndex).DeleteRow = True
                End If
                lastRowIsCaption = True
                lastCaptionRowIndex = i
                lastCaptionRowLevel = rows(i).CaptionRowLevel
                
                
                If rows(i).DeleteRow = False Then
                    captionRows.AddRange rng.Cells(rows(i).ValueRowIndex, 1)
                End If
            ElseIf rows(i).IsTotalRow = True Then
                If lastRowIsCaption = True Then
                    'empty section
                    rows(lastCaptionRowIndex).DeleteRow = True
                    rows(i).DeleteRow = True
                End If
            ElseIf rows(i).DeleteRow = False Then
                lastRowIsCaption = False
                lastCaptionRowIndex = 0
            End If
        End If
    Next
    
    For i = 1 To UBound(rows)
        If rows(i).DeleteRow = True Then
            Set tempCell = Nothing
            Set tempCell = rng.Cells(rows(i).ValueRowIndex, 1)
            rowsToDelete.AddRange tempCell
            deleteRowAdded = True
        End If
    Next
                         
    If mTotalRows.Count = 0 Then
        For i = captionRows.Count To 1 Step -1
            captionRows.Range(i).EntireRow.RowHeight = 23
        Next
    End If
    If deleteRowAdded = True Then
        For i = rowsToDelete.Count To 1 Step -1
            rowsToDelete.Range(i).EntireRow.Delete
        Next
    End If

End Function
Private Sub ConvertCurrencyToDouble(arr() As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    'when the values are sent to Excel, if it is marked as currency, only 2 decimal places are recognized by Excel
    'so, I need to convert the currency type to double
    Dim i As Long
    Dim y As Long
    
    Dim rowCount As Long
    rowCount = UBound(arr)
    If rowCount = 0 Then Exit Sub
    
    For i = LBound(arr) To UBound(arr)
        For y = LBound(arr, 2) To UBound(arr, 2)
            If TypeName(arr(i, y)) = "Currency" Then
                arr(i, y) = CDbl(arr(i, y))
            End If
        Next
    Next
End Sub
Private Sub FillManually(arr() As Variant, rng As Range)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim y As Long
    On Error Resume Next
    If rng Is Nothing Then Exit Sub
    
    For i = 1 To rng.rows.Count
        For y = 1 To rng.Columns.Count
            rng.Cells(i, y).value = arr(i, y)
        Next
    Next
End Sub
Private Sub FillCaptionAndTotalRowAddresses()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mAllCaptionRows = New CRangeUnion
    Set mAllTotalRows = New CRangeUnion
    Set mAllHeaderRows = New CRangeUnion
    
    Dim firstColLetter As String
    Dim lastColLetter As String
    Dim sheetRow As Long
    Dim addrRow As Long
    
    mAllCaptionRows.SetSheet mSec.Range.Worksheet
    mAllTotalRows.SetSheet mSec.Range.Worksheet
    mAllHeaderRows.SetSheet mSec.Range.Worksheet
    
    firstColLetter = ColumnLetter(mSec.Range.Column)
    lastColLetter = ColumnLetter(mSec.Range.Column + mSec.Range.Columns.Count - 1)
    sheetRow = mSec.Range.Row
    
    For i = 1 To UBound(rows)
        addrRow = sheetRow + rows(i).ReportRangeRowIndex
        If rows(i).IsHeaderRow = True Then
            mAllHeaderRows.AddAddress firstColLetter & addrRow & ":" & lastColLetter & addrRow
        End If
        If rows(i).IsCaptionRow = True Then
            mAllCaptionRows.AddAddress firstColLetter & addrRow & ":" & lastColLetter & addrRow
        End If
        If rows(i).IsTotalRow = True Then
            mAllTotalRows.AddAddress firstColLetter & addrRow & ":" & lastColLetter & addrRow
        End If
    Next
End Sub
Function ColumnLetter(ByVal colNum As Long) As String
'<CSCustomCode> 1
On Error Resume Next
'</CSCustomCode> 1
Dim i As Long, x As Long
    For i = Int(Log(CDbl(25 * (CDbl(colNum) + 1))) / Log(26)) - 1 To 0 Step -1
        x = (26 ^ (i + 1) - 1) / 25 - 1
        If colNum > x Then
            ColumnLetter = ColumnLetter & Chr$(((colNum - x - 1) \ 26 ^ i) Mod 26 + 65)
        End If
    Next
End Function
Function CreateRangeValues() As Variant()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim y As Long
    Dim cnt As Long
    
    cnt = 0
      Dim arr() As Variant
    Dim rowCount As Long
    rowCount = UBound(rows)
    
    If rowCount = 0 Then
        ReDim arr(0 To 0, 1 To mSec.columnCount)
        CreateRangeValues = arr
        Exit Function
    End If
    
    'find the row count
    For i = 1 To UBound(rows)
        If rows(i).IsDeleted = True Then
            'don't count it
        ElseIf rows(i).InsertBlankRowBelow = True Then
            rows(i).ReportRangeRowIndex = cnt + 1
            cnt = cnt + 2
        Else
            rows(i).ReportRangeRowIndex = cnt + 1
            cnt = cnt + 1
        End If
    Next
    
  
    
    ReDim arr(1 To cnt, 1 To mSec.columnCount)
    
    cnt = 0
    For i = 1 To UBound(rows)
        If rows(i).IsDeleted = True Then
            'ignore row
        Else
            For y = 1 To mSec.columnCount
                arr(cnt + 1, y) = mValues(i, y)
            Next
            cnt = cnt + 1
            rows(i).ValueRowIndex = cnt
            If rows(i).InsertBlankRowBelow = True Then cnt = cnt + 1
        End If
    Next
    
    
    Dim AddFormulasToHeaders As Boolean
    
    If mSettings.AddFormulasToHeaders Then
        AddFormulasToHeaders = True
    End If
    
    'fill column formulas
    
    For i = 1 To mSec.columnCount
        If mSec.GetTemplateRowCell(i).Formula <> "" Then
            If Left(mSec.GetTemplateRowCell(i).Formula, 1) = "=" Then
            
                Dim sFormula As String
                sFormula = mSec.GetColumnFormula(i)
                
                For y = 1 To UBound(rows)
                    If sFormula <> "" Then
                        arr(rows(y).ReportRangeRowIndex, i) = mSec.Formula(rows(y).ReportRangeRowIndex + 1, i)
                    End If
                    If rows(y).IsDeleted = False And rows(y).IsCaptionRow = False And rows(y).IsTotalRow = False Then
                        If rows(y).IsHeaderRow = True And AddFormulasToHeaders = True Then
                            arr(rows(y).ReportRangeRowIndex, i) = mSec.Formula(rows(y).ReportRangeRowIndex + 1, i)
                        Else
                            arr(rows(y).ReportRangeRowIndex, i) = mSec.Formula(rows(y).ReportRangeRowIndex + 1, i)
                        End If
                    End If
                Next
            End If
        End If
    Next
    
    

    
    'headers can't have numbers in them
    Dim strNum As String
    For i = 1 To UBound(rows)
        If rows(i).IsHeaderRow = True And rows(i).IsDeleted = False Then
            For y = 1 To mSec.columnCount
                strNum = ""
                strNum = arr(rows(i).ReportRangeRowIndex, y)
                If IsNumeric(strNum) = True Then
                    If strNum <> "0" And strNum <> "" Then
                        If IsNumeric(rows(i).ReportRangeRowIndex) Then
                            'make sure there are no currency symbols
                            arr(rows(i).ReportRangeRowIndex, y) = "=Text(" & CStr(CDbl(arr(rows(i).ReportRangeRowIndex, y))) & "," & """" & mSec.NumberFormatForTextFormula(y) & """" & ")"
                            arr(rows(i).ReportRangeRowIndex, y) = ""
                        Else
                            arr(rows(i).ReportRangeRowIndex, y) = "=Text(" & arr(rows(i).ReportRangeRowIndex, y) & "," & """" & mSec.NumberFormatForTextFormula(y) & """" & ")"
                            arr(rows(i).ReportRangeRowIndex, y) = ""
                        End If
                        
                    End If
                End If
            Next
        End If
    Next
    
    CreateRangeValues = arr
End Function


Sub FormatReport()
    On Error Resume Next

    
    Dim i As Long
    'Dim f As SectionFormatter
    Dim itemCnt As Long
    Dim rngUnion As CRangeUnion
    Dim rngUnion2 As CRangeUnion
    
    On Error Resume Next
    
    'Set f = mSec.Formatter
    itemCnt = mSec.rowCount - 2
    
    
'    mSec.ApplyFormattingToRow i
'
'    For i = 1 To mSec.Columns.Count
'        f.ApplyTemplateRowFormattingToColumn i, 1, itemCnt, False
'
'    Next

    Dim rng As Range
    
    'format Total Rows
    Set rngUnion = New CRangeUnion
    For i = 1 To mAllTotalRows.Count
        Set rng = mAllTotalRows.Range(i)
        rngUnion.AddRange rng
        
        
    Next
    For i = 1 To rngUnion.Count
        With rngUnion.Range(i)
            .Font.Bold = True
            
            .EntireRow.RowHeight = rng.Cells(1, 1).EntireRow.RowHeight * 2
            .VerticalAlignment = xlTop
        End With
    Next
    
    
    
    'format Caption Rows
    Set rngUnion = New CRangeUnion
    For i = 1 To mAllCaptionRows.Count
        Set rng = mAllCaptionRows.Range(i)
        rngUnion.AddRange rng
    Next
    For i = 1 To rngUnion.Count
        With rngUnion.Range(i)
            .Font.Bold = True
            .VerticalAlignment = xlBottom
        End With
    Next

    'Format Header Rows
    'Dim sc As SectionColumn
    Set rngUnion = New CRangeUnion
    Set rngUnion2 = New CRangeUnion
    
    For i = 1 To UBound(rows)
        If rows(i).IsHeaderRow = True Then
            'bold the description
            'rngUnion.AddRange mSec.GetCell("Description", Rows(i).ReportRangeRowIndex)
            rngUnion.AddRange mSec.ItemRange.rows(rows(i).ReportRangeRowIndex)
            
            If mFormatHeaders = True Then
                rngUnion2.AddRange mSec.Range.rows(rows(i).ReportRangeRowIndex + 1)
            End If
        End If
    Next
    If mFormatHeaders = True Then
        For i = 1 To rngUnion.Count
            rngUnion.Range(i).Font.Bold = True
        Next
        For i = 1 To rngUnion2.Count
            'rngUnion2.Range(i).Interior.ColorIndex = 15
            rngUnion2.Range(i).Interior.Color = 15921906
           ' rngUnion2.Range(i).Font.Underline = True
        Next
    End If
    
    'Progress.Increase

    'Format headers
    Dim tempRng As Range


    'progress.Increase
    'make sure the plus/minus at top
    If mSec.Range.Worksheet.Outline.SummaryRow <> xlSummaryAbove Then
        mSec.Range.Worksheet.Outline.SummaryRow = xlSummaryAbove
    End If
    
    
    'format Caption Rows
    Set rngUnion = New CRangeUnion
    For i = 1 To UBound(rows)
        If rows(i).IsCaptionRow = True Then
            Set rng = Nothing
            If rows(rows(i).CaptionLevelEndRow).IsTotalRow = True Then
                Set rng = mSec.Range.rows(rows(i).ReportRangeRowIndex + 2).Resize(rows(i).CaptionLevelEndRow - rows(i).CaptionLevelStartRow - 1)
            Else
                Set rng = mSec.Range.rows(rows(i).ReportRangeRowIndex + 2).Resize(rows(i).CaptionLevelEndRow - rows(i).CaptionLevelStartRow)
            End If
            If Not rng Is Nothing Then
                Set tempRng = rng.Application.Intersect(rng, mSec.Range.Columns(mFirstVisibleColumn))
                If rows(i).CaptionRowLevel = 1 Then
                    tempRng.InsertIndent 1
                End If
                If rows(i).CaptionRowLevel < 2 Then
                    tempRng.EntireRow.Group
                End If
                tempRng.Cells(1, 1).HorizontalAlignment = xlLeft  'make sure the heading of the section is left aligned
            End If
            
            
            If rows(i).CaptionRowLevel = 1 Then
                Set rng = mSec.Range.rows(rows(i).ReportRangeRowIndex + 1)
                rngUnion.AddRange rng
            End If
        End If
    Next
    For i = 1 To rngUnion.Count
        With rngUnion.Range(i)
            .Borders(xlEdgeBottom).Weight = xlThin
            .Borders(xlEdgeBottom).ColorIndex = 15
        End With
    Next
    
    
    'format total rows
    Set rngUnion = New CRangeUnion
    For i = 1 To UBound(rows)
        If rows(i).IsTotalRow = True Then
            If rows(i).TotalRowLevel = 1 Then
                Set rng = mSec.Range.rows(rows(i).ReportRangeRowIndex + 1)
                rngUnion.AddRange rng
            End If
        End If
    Next
    For i = 1 To rngUnion.Count
        With rngUnion.Range(i)
            .Borders(xlEdgeTop).Weight = xlThin
            .Borders(xlEdgeTop).ColorIndex = 15
        End With
    Next
    
    
    
'    Progress.Increase
'
    'Dim c As SectionColumn
'
'    For Each c In mSec.Columns
'        If c.Visible Then mSec.Formatter.FormatColumnBorders c.columnIndex, , , False, False
'    Next
'
    'Pictures
    'see if there is a picture column
    Dim pictureIndex As Long
    Dim Pic As Excel.Shape
    Dim cell As Range
    Dim str As String
    Dim picPath As String
    Dim ratio As Double
    Dim colIndex2 As Long

'    'Dim l As Long
'    If mSec.Columns.Exists("PictureID") And Not manDB Is Nothing Then
'        pictureIndex = mSec.Columns("PictureID").columnIndex
'        For i = 1 To UBound(rows)
'            str = ""
'            If rows(i).IsCaptionRow = False And rows(i).IsHeaderRow = False And rows(i).IsTotalRow = False Then
'                Set cell = mSec.GetCellByIndex(rows(i).ReportRangeRowIndex - 1, pictureIndex)
'
'                str = cell.Value
'                If str <> "" Then
'                    picPath = ""
'
'                    If manDB.PictureExists(str, picPath) = True Then
'                        If picPath <> "" Then
'                            Dim picWidth As Double, picHeight As Double
'                            Dim picDimensions As IPictureDisp
'                            Set picDimensions = LoadPicture(picPath)
'
'                            picHeight = picDimensions.Height / 20
'                            If picHeight > 69 Then picHeight = 69
'                            picWidth = picHeight * (picDimensions.Width / 20) / (picDimensions.Height / 20)
'                            Set Pic = mSec.NamedRange.RefersToRange.Worksheet.Shapes.AddPicture(picPath, 0, -1, cell.Left, cell.Top, picWidth, picHeight)
'                            ''Max row height is 69.00 points
'                            If cell.EntireRow.RowHeight <> picHeight Then
'                                cell.EntireRow.RowHeight = picHeight
'                            End If
'                            'Pic.Height = picHeight
'                            'Pic.Width = picWidth
'
'                            Pic.Visible = True
'                            'Pic.ScaleHeight 1, True
'
'                            'Pic.ScaleWidth 1, True
'                            'ratio = Pic.Width / Pic.Height
'                            'Pic.Height = cell.Height
'                            'Pic.Width = Pic.Height * ratio
'                            Pic.Left = cell.Left + (cell.Width - Pic.Width) / 2
'                            Pic.Name = GetNextReportPictureName(mSec.NamedRange.RefersToRange.Worksheet)
'                        cell.Value = ""
'                        End If
'                    End If
'
'    '                Set pic = ManageDB.GetPictureFromDB(str)
'                End If
'            End If
'        Next
'    End If
'    RaiseProgress
    
'    Progress.Increase
'    FormatSpecialRows CaptionRows, rng, CaptionRowLevels
'    Progress.Increase
'
'Exit_Here:
'    If mSec.ItemRowCount > rows Then
'        'mSec.namedRange.Application.ScreenUpdating = True
'        mSec.SetRowCount mSec.ItemRowCount, False, False, False
'
'        Dim r As Long
'        r = mSec.NamedRange.RefersToRange.rows.Count
'        For Each c In mSec.Columns
'            If c.Visible Then mSec.Borders.FormatColumnBorders c.columnIndex, rows, r, False, False
'        Next
'
'    End If
'    Progress.Increase
End Sub


Attribute VB_Name = "CReportSettings"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public includeHeaders As Boolean
Public FormatHeaders As Boolean
Public IncludeBlankHeaders As Boolean
Public UseSummaryRows As Boolean
Public UseSummaryRowsNoLinked As Boolean
Public AddFormulasToHeaders As Boolean
Public AutoGenerate As Boolean
Public AutoGenerateDelay As String

Private mSettings As SettingsParser

Public Sub Init(sht As Worksheet)
    Set settings = New SettingsParser
    settings.Init sht
    
    If UCase(Trim(settings.Setting("IncHeader"))) = "TRUE" Then includeHeaders = True
    If UCase(Trim(settings.Setting("IncBlankHead"))) = "TRUE" Then IncludeBlankHeaders = True Else IncludeBlankHeaders = False
    If UCase(Trim(settings.Setting("FormatHeader"))) = "TRUE" Then FormatHeaders = True
    If UCase(Trim(settings.Setting("UseSummaryRows"))) = "TRUE" Then UseSummaryRows = True
    If UCase(Trim(settings.Setting("UseUnlinkedSummaryRows"))) = "TRUE" Then UseSummaryRowsNoLinked = True
    
    If UCase(Trim(settings.Setting("AddFormulasToHeaders"))) = "TRUE" Then AddFormulasToHeaders = True
    If UCase(Trim(settings.Setting("AutoGenerateDelay"))) <> "" Then AutoGenerateDelay = settings.Setting("AutoGenerateDelay")
End Sub

    

Attribute VB_Name = "CSheetCostCodes"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public SheetName As String
Public SheetTitle As String

Private mCostCodes As Collection

Public Property Get CostCodes() As Collection
    If mCostCodes Is Nothing Then Set mCostCodes = New Collection
    Set CostCodes = mCostCodes
End Property
Public Property Set CostCodes(value As Collection)
    Set CostCodes = mCostCodes
End Property

Public Sub Init(sht As Worksheet)
    SheetName = sht.Name
    
    On Error Resume Next
    Dim nm As Name
    Set nm = sht.names("Title")
    If Not nm Is Nothing Then
        SheetTitle = nm.RefersToRange.value
    End If
End Sub


Public Function GetColumnTotal(sColumnKey As String, Optional roundToDecimal As Integer = 4) As Double
    Dim i As Long
    If mCostCodes Is Nothing Then Exit Function
    Dim cc As CCostCode
    Dim d As Double
    For i = 1 To mCostCodes.Count
        Set cc = mCostCodes(i)
        d = d + cc.GetColumnTotal(sColumnKey)
    Next
    GetColumnTotal = Round(d, 4)
End Function

Public Sub RemoveBlankCostCodes(bCheckDescription As Boolean, colColumnTotalsToCheck As Collection)
    Dim i As Long
    If mCostCodes Is Nothing Then Exit Sub
    Dim cc As CCostCode
    Dim d As Double
    Dim y As Long
    Dim bIsBlank As Boolean
    
    On Error Resume Next
    For i = mCostCodes.Count To 1 Step -1
        bIsBlank = True
        Set cc = mCostCodes(i)
        For y = 1 To colColumnTotalsToCheck.Count
            d = 0
            d = cc.GetColumnTotal(colColumnTotalsToCheck(y))
            If d <> 0 Then
                bIsBlank = False
                Exit For
            End If
        Next
        If bCheckDescription And bIsBlank = True Then
            If cc.DescriptionIsBlank = False Then
                bIsBlank = False
            End If
        End If
        
        If bIsBlank Then
            mCostCodes.Remove i
        End If
    Next
    
End Sub
Attribute VB_Name = "CSortedArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mItemsSet As Boolean
Private mItems As Variant

Private mSortCols As Collection
Private mSortOrders As Collection

Private mSortArray() As Variant

'Return a list just like a grid
Public Sub Clear()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    Erase mItems
    mItemsSet = False
End Sub

Private Sub CreateSortArray()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim colIndex As Long
    Dim mDivisions As Collection
    
    If Me.Count < 1 Then Exit Sub
    ReDim mSortArray(LBound(mItems) To UBound(mItems), 1 To 2)
    Set mDivisions = New Collection
    
    'Fill the indexes
    For i = LBound(mItems) To UBound(mItems)
        mSortArray(i, 1) = i
        
        Dim sTemp As String
        sTemp = ""
        For y = 1 To mSortCols.Count
            sTemp = IIf(sTemp <> "", sTemp, "") & mItems(i, mSortCols(y))
           
        Next
        
       ' mSortArray(i, 2) = sTemp
    Next
    
    'sortsearch.
    mDivisions.Add LBound(mItems)
    mDivisions.Add UBound(mItems) + 1
    
    Dim Left As Long
    Dim Right As Long
    For y = 1 To mSortCols.Count
        colIndex = mSortCols(y)
        
        'Fill with the column values
        For i = LBound(mItems) To UBound(mItems)
            mSortArray(i, 2) = mItems(mSortArray(i, 1), colIndex)
        Next
        
        'Sort the Array
        For i = 1 To mDivisions.Count - 1
            Left = mDivisions(i)
            Right = mDivisions(i + 1) - 1
            If Left < Right Then
                SortArray mSortArray, 2, mSortOrders(y), Left, Right
            End If
        Next
        
        If y < mSortCols.Count Then
            'store the locations of divisions in the Sort
            For i = LBound(mSortArray) + 1 To UBound(mSortArray)
                If mSortArray(i, 2) <> mSortArray(i - 1, 2) Then
                    AddToCollection i, mDivisions
                End If
            Next
        End If
    Next
End Sub
Private Sub SortArray(ItemArray As Variant, colIndex As Long, _
                        sortorder As ESortOrder, startIndex As Long, _
                        endIndex As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If sortorder = -1 Then sortorder = SortAscending_e
    If UBound(ItemArray) < 1000 Then
        
        If sortorder = SortAscending_e Then
            modSortSearch.BubbleSort2D ItemArray, colIndex, False, startIndex, endIndex
        ElseIf sortorder = SortDescending_e Then
            modSortSearch.BubbleSort2D ItemArray, colIndex, True, startIndex, endIndex
        End If
    Else
        If sortorder = SortAscending_e Then
            modSortSearch.QuickSort2D ItemArray, colIndex, 2, startIndex, endIndex, True
        ElseIf sortorder = SortDescending_e Then
            modSortSearch.QuickSort2D ItemArray, colIndex, 2, startIndex, endIndex, False
        End If
    End If
End Sub
Private Sub AddToCollection(value As Long, col As Collection)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    If col.Count = 0 Then
        col.Add value
        Exit Sub
    End If
    For i = 1 To col.Count
        If value < col(i) Then
            col.Add value, , i
            Exit For
        ElseIf i = col.Count Then
            col.Add value
        End If
    Next
End Sub

Public Sub Sort()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If Me.Count < 1 Then Exit Sub
    CreateSortArray
    
    Dim newArray() As Variant
    Dim rowIndex As Long
    Dim i As Long, y As Long
    ReDim newArray(LBound(mItems) To UBound(mItems), LBound(mItems, 2) To UBound(mItems, 2))
    
    'Create a new sorted array
    For i = LBound(mItems) To UBound(mItems)
        rowIndex = mSortArray(i, 1)
        For y = LBound(mItems, 2) To UBound(mItems, 2)
            If IsObject(mItems(rowIndex, y)) Then
                Set newArray(i, y) = mItems(rowIndex, y)
            Else
                newArray(i, y) = mItems(rowIndex, y)
            End If
        Next
    Next
    Erase mItems
    mItems = newArray
End Sub
Public Sub ClearSort()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mSortCols = New Collection
    Set mSortOrders = New Collection
End Sub
Public Sub AddSortColumn(columnIndex As Long, sortorder As ESortOrder)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim alreadyAdded As Boolean
    
    If mSortCols Is Nothing Then Set mSortCols = New Collection
    If mSortOrders Is Nothing Then Set mSortOrders = New Collection
    
    For i = 1 To mSortCols.Count
        If mSortCols(i) = columnIndex Then
            alreadyAdded = True
            mSortOrders.Add sortorder, , i
            mSortOrders.Remove i + 1
        End If
    Next
    If Not alreadyAdded Then
        mSortCols.Add columnIndex
        mSortOrders.Add sortorder
    End If
End Sub
Public Property Get ItemArray() As Variant
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    ItemArray = mItems
End Property

Public Property Let ItemArray(ByVal Items As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mItems = Items
    mItemsSet = True
End Property

Public Property Get Count() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    If mItemsSet Then
        If IsArray(mItems) Then
            Count = UBound(mItems)
        Else
            If mItems <> "" Then
                Count = 1
            End If
        End If
    End If
End Property








Attribute VB_Name = "ColumnInfo"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mKey As String
Private mHeaders As Collection
Private mNumberFormats As Collection
Private mVisible As Boolean
Private mShowInGrid As Boolean

Private mGroupColumn As Boolean
Private mTotalColumn As Boolean
Private mAlignment As String
Private mIndex As Long
Private mAllValuesNumeric As Boolean

Private mWidths As Collection

Public Property Get Widths() As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mWidths Is Nothing Then
        Set mWidths = New Collection
    End If
    Set Widths = mWidths
End Property

Public Property Get AllValuesNumeric() As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1

    AllValuesNumeric = mAllValuesNumeric

End Property

Public Property Let AllValuesNumeric(ByVal value As Boolean)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1

    mAllValuesNumeric = value

End Property

Public Property Get Alignment() As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Alignment = mAlignment
End Property

Public Property Let Alignment(ByVal Alignment As String)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mAlignment = Alignment
End Property

Private Sub Class_Initialize()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mColumnSort = NoColumnSort_E
End Sub
Public Sub MiscMethod(strKey As String, ParamArray arr() As Variant)
'<CSCustomCode> 1
On Error Resume Next
'</CSCustomCode> 1
'
End Sub
Public Property Get Index() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Index = mIndex
End Property

Public Property Let Index(ByVal Index As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mIndex = Index
End Property

Private Sub Class_Terminate()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mHeaders = Nothing
    Set mColumnKeys = Nothing
End Sub

Public Property Get key() As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    key = mKey
End Property

Public Property Let key(ByVal key As String)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mKey = key
End Property

Public Sub ClearHeaders()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mHeaders = New Collection
End Sub

Public Property Get Headers() As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mHeaders Is Nothing Then Set mHeaders = New Collection
    Set Headers = mHeaders
End Property

Public Property Get NumberFormats() As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mNumberFormats Is Nothing Then Set mNumberFormats = New Collection
    Set NumberFormats = mNumberFormats
End Property

Public Property Get ShowInGrid() As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    ShowInGrid = mShowInGrid
End Property

Public Property Let ShowInGrid(ByVal ShowInGrid As Boolean)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mShowInGrid = ShowInGrid
End Property





Attribute VB_Name = "ColumnInfoCollection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private mColumnInfos As New Collection

Sub Add(Item As ColumnInfo, Optional key As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mColumnInfos.Add Item, key
End Sub
Sub FillWithAllSectionColumns(secs As Collection, _
            Optional AddSectionNameColumn As Boolean = True, _
            Optional AddItemHeaderColumn As Boolean = True, _
            Optional AddRowIndexColumn As Boolean = True, _
            Optional AddSectionIndexColumn As Boolean = True, _
            Optional AddPictureIDColumn As Boolean = True, _
            Optional CheckHiddenColumnWidths As Boolean = False)
      FillWithAllSectionColumns secs, AddSectionNameColumn, AddItemHeaderColumn, AddRowIndexColumn, AddSectionIndexColumn, AddPictureIDColumn, CheckHiddenColumnWidths
End Sub
Sub FillWithAllSectionColumns2(secs As Collection, _
            Optional AddSectionNameColumn As Boolean = True, _
            Optional AddItemHeaderColumn As Boolean = True, _
            Optional AddRowIndexColumn As Boolean = True, _
            Optional AddSectionIndexColumn As Boolean = True, _
            Optional AddPictureIDColumn As Boolean = True, _
            Optional CheckHiddenColumnWidths As Boolean = False, _
            Optional AddEstimateIDColumn As Boolean = False)
            '<CSCustomCode> 1
            On Error Resume Next
            '</CSCustomCode> 1
            
    Dim s As ItemSection
  
    Dim Update As Boolean
    Dim xlApp As Excel.Application
    
    Set mColumnInfos = New Collection
    On Error Resume Next
    Dim newColumnInfo As ColumnInfo
    Dim tempCol As Collection
    Dim Index As Long
    Dim tempIndex As Long
    
    If AddSectionNameColumn Then
        Set newColumnInfo = New ColumnInfo
        newColumnInfo.key = "SectionName"
        newColumnInfo.Headers.Add "Sheet"
        
        mColumnInfos.Add newColumnInfo
        
        Set newColumnInfo = New ColumnInfo
        newColumnInfo.key = "SheetName"
        newColumnInfo.Headers.Add "Sheet Name"
        
        mColumnInfos.Add newColumnInfo
    End If
    If AddSectionIndexColumn Then
        Set newColumnInfo = New ColumnInfo
        newColumnInfo.key = "SectionIndex"
        newColumnInfo.Headers.Add "Sheet Number"
        mColumnInfos.Add newColumnInfo
    End If
    If AddEstimateIDColumn Then
        Set newColumnInfo = New ColumnInfo
        newColumnInfo.key = "EstimateID"
        newColumnInfo.Headers.Add "Estimate ID"
        mColumnInfos.Add newColumnInfo
    End If
    
    If CheckHiddenColumnWidths = True Then
        Update = Application.ScreenUpdating
        If Update = True Then Application.ScreenUpdating = False
    End If
    Dim i As Long
    For Each s In secs
        For i = 1 To s.columnCount
            
        
            'If c.Key <> "Info" Then   'will now allow the info column to appear
                Index = 0
                If ColumnKeyExists(s.columnKeys(i), Index) Then
                    Set tempCol = mColumnInfos(Index).Headers
                    If Not tempCol Is Nothing Then
                        If Not ValueInCollection(tempCol, s.cell(i, 1).value, tempIndex) Then
                            tempCol.Add s.cell(i, 1).value
                        End If
                        
                    End If
                    
                    If s.GetColumnSetting(i, "NumberFormat") <> "" Then
                        Set tempCol = mColumnInfos(Index).NumberFormats
                        If Not tempCol Is Nothing Then
                            If Not ValueInCollection(tempCol, s.GetColumnSetting(i, "NumberFormat"), tempIndex) Then
                                tempCol.Add s.GetColumnSetting(i, "NumberFormat")
                            End If
                        End If
                    End If
                Else
                    Set newColumnInfo = New ColumnInfo
                    newColumnInfo.key = s.columnKeys(i)
                    newColumnInfo.Headers.Add s.cell(i, 1).value
                    
                    If s.cell(i, 1).EntireColumn.Hidden = True Then
                        newColumnInfo.ShowInGrid = False
                        If CheckHiddenColumnWidths = True Then
                            'I have to unhide the column to get it's width
                            s.cell(i, 1).EntireColumn.Hidden = False
                            newColumnInfo.Widths.Add s.cell(i, 1).ColumnWidth '/ (Screen.TwipsPerPixelX / 20!)  'convert points to pixels
                            s.cell(i, 1).EntireColumn.Hidden = True
                        End If
                    Else
                        newColumnInfo.ShowInGrid = True
                        newColumnInfo.Widths.Add s.cell(i, 1).ColumnWidth ' / (Screen.TwipsPerPixelX / 20!)  'convert points to pixels
                    End If
                    Dim tempRng As Range

                    If s.GetColumnSetting(i, "NumberFormat") <> "" Then newColumnInfo.NumberFormats.Add s.GetColumnSetting(i, "NumberFormat")
                    If s.GetColumnSetting(i, "Alignment") <> "" Then newColumnInfo.Alignment = s.GetColumnSetting(i, "Alignment")
                    
                    mColumnInfos.Add newColumnInfo
                End If
           ' End If
        Next
    Next
    
    If AddItemHeaderColumn Then
        Set newColumnInfo = New ColumnInfo
        newColumnInfo.key = "ItemHeader"
        newColumnInfo.Headers.Add "Item Header"
        newColumnInfo.Widths.Add 40
        mColumnInfos.Add newColumnInfo
    End If
    If AddItemHeaderColumn Then
        Set newColumnInfo = New ColumnInfo
        newColumnInfo.key = "RowIndex"
        newColumnInfo.Headers.Add "Row Number"
        newColumnInfo.Widths.Add 40
        mColumnInfos.Add newColumnInfo
    End If
    If AddPictureIDColumn Then
        Set newColumnInfo = New ColumnInfo
        newColumnInfo.key = "PictureID"
        newColumnInfo.Headers.Add "Picture"
        mColumnInfos.Add newColumnInfo
        newColumnInfo.Widths.Add 40
    End If
    

    For i = 1 To mColumnInfos.Count
        mColumnInfos(i).Index = i
    Next
    
    If CheckHiddenColumnWidths = True Then
        If Update = True Then Application.ScreenUpdating = True
    End If
End Sub
Private Function ValueInCollection(col As Collection, value As String, ByRef outIndex As Long) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim str As String
    str = UCase(Trim(value))
    For i = 1 To col.Count
        If UCase(Trim(col(i))) = str Then
            ValueInCollection = True
            outIndex = i
            Exit Function
        End If
    Next
End Function

Public Sub MiscMethod(strKey As String, ParamArray arr() As Variant)
'<CSCustomCode> 1
On Error Resume Next
'</CSCustomCode> 1
'
End Sub
Public Function ColumnKeyExists(key As String, Optional outIndex As Long) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim str As String
    str = UCase(Trim(key))
    For i = 1 To mColumnInfos.Count
        If UCase(Trim(mColumnInfos(i).key)) = str Then
            ColumnKeyExists = True
            outIndex = i
            Exit Function
        End If
    Next
End Function

Public Sub Remove(Index As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mColumnInfos.Remove Index
End Sub

' Return a ColumnInfo item from the collection
Function Item(Index As Variant) As ColumnInfo
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    If IsNumeric(Index) Then
        Set Item = mColumnInfos.Item(Index)
    Else
        Dim i As Long
        Dim c As ColumnInfo
        For i = 1 To mColumnInfos.Count
            Set c = mColumnInfos(i)
            If c.key = Index Then
                Set Item = c
                Exit For
            End If
        Next
    End If
    
    
'    If Not item Is Nothing Then
'        If item.Parent Is Nothing Then
'            If Not mParent Is Nothing Then
'                Set item.Parent = mParent
'            End If
'        End If
'    End If
End Function
Public Sub Insert(Item As ColumnInfo, Optional key As String, Optional before As Variant, Optional after As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If key = "" Then
        If Not IsMissing(before) Then
            If before > Me.Count Then
                If mColumnInfos.Count = 0 Then
                    mColumnInfos.Add Item
                Else
                    mColumnInfos.Add Item, , , mColumnInfos.Count
                End If
            Else
                mColumnInfos.Add Item, , before
            End If
        ElseIf Not IsMissing(after) Then
            If after > Me.Count Then
                If mColumnInfos.Count = 0 Then
                    mColumnInfos.Add Item
                Else
                    mColumnInfos.Add Item, , , mColumnInfos.Count
                End If
            Else
                mColumnInfos.Add Item, , , after
            End If
        End If
    Else
        If Not IsMissing(before) Then
            If before > Me.Count Then
                If mColumnInfos.Count = 0 Then
                    mColumnInfos.Add Item
                Else
                    mColumnInfos.Add Item, key, , mColumnInfos.Count
                End If
            Else
                mColumnInfos.Add Item, key, before
            End If
        ElseIf Not IsMissing(after) Then
            If after > Me.Count Then
                If mColumnInfos.Count = 0 Then
                    mColumnInfos.Add Item
                Else
                    mColumnInfos.Add Item, key, , mColumnInfos.Count
                End If
            Else
                mColumnInfos.Add Item, key, , after
            End If
        End If
    End If
End Sub
' Return the number of items in the collection
Property Get Count() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Count = mColumnInfos.Count
End Property

' Remove all items from the collection
Public Sub Clear()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mColumnInfos = New Collection
End Sub

' Implement support for enumeration (For Each)
Function NewEnum() As IUnknown
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    ' delegate to the private collection
    Set NewEnum = mColumnInfos.[_NewEnum]
End Function










Attribute VB_Name = "FilterCondition"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit


'Private mValidValues As Collection
Private mOrValues As Collection
Private mOrValuesOrig As Collection
Private mAndValues As Collection

'Public IsNumeric As Boolean


Private mAllowBlanks As Boolean
Private mAllowNonBlanks As Boolean
Private mAllowNonZeros As Boolean
Private mAllowBlanksSet As Boolean
Private mAllowNonBlanksSet As Boolean
Private mAllowNonZerosSet As Boolean
Private mColumnIndex As Long
Private mAllowNoValues As Boolean
Private mAllowNoValuesSet As Boolean

Public Function OperatorToString(op As FilterOperator_E) As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim str As String
    Select Case op
        Case Equals_E:                  str = "="
        Case DoesNotEqual_E:            str = "/="
        Case IsGreaterThan_E:           str = ">"
        Case IsGreaterThanOrEqualTo_E:  str = ">="
        Case IsLessThan_E:              str = "<"
        Case IsLessThanOrEqualTo_E:     str = "<="
        Case BeginsWith_E:              str = "A"
        Case DoesNotBeginWith_E:        str = "/A"
        Case EndsWith_E:                str = "Z"
        Case DoesNotEndWith_E:          str = "/Z"
        Case Contains_E:                str = "C"
        Case DoesNotContain_E:          str = "/C"
    End Select
    OperatorToString = str
End Function
Public Sub MiscMethod(strKey As String, ParamArray arr() As Variant)
'<CSCustomCode> 1
On Error Resume Next
'</CSCustomCode> 1
'
End Sub
Public Function OperatorFromString(str As String) As FilterOperator_E
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim op As FilterOperator_E
    op = NotOperator_E
    Select Case str
        Case "=": op = Equals_E
        Case "/=": op = DoesNotEqual_E
        Case ">": op = IsGreaterThan_E
        Case ">=": op = IsGreaterThanOrEqualTo_E
        Case "<": op = IsLessThan_E
        Case "<=": op = IsLessThanOrEqualTo_E
        Case "A": op = BeginsWith_E
        Case "/A": op = DoesNotBeginWith_E
        Case "Z": op = EndsWith_E
        Case "/Z": op = DoesNotEndWith_E
        Case "C": op = Contains_E
        Case "/C": op = DoesNotContain_E
    End Select
    OperatorFromString = op
End Function
    

Public Function ToString(Optional addLineBreaks As Boolean = True) As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim str As String
    Dim i As Long
    
    Dim lineBreak As String
    If addLineBreaks = False Then
        lineBreak = ": "
    Else
        lineBreak = vbCrLf
    End If
    
    If Not mOrValues Is Nothing Then
        For i = 1 To mOrValues.Count
            str = str & IIf(str <> "", lineBreak, "") & mOrValuesOrig(i)
        Next
    End If
    
    If mAllowBlanksSet = True And mAllowBlanks = True Then
        str = str & IIf(str <> "", lineBreak, "") & "(Blanks)"
    End If
    ToString = str
End Function

Public Property Get AllowNoValues() As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    AllowNoValues = mAllowNoValues
End Property

Public Property Let AllowNoValues(ByVal AllowNoValues As Boolean)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1

    mAllowNoValues = AllowNoValues
    mAllowNoValuesSet = True
End Property

Public Property Get AllowAllValues() As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    AllowAllValues = True
    If mAllowBlanksSet = True Then
        AllowAllValues = False
    ElseIf mAllowNonBlanksSet Then
        AllowAllValues = False
    ElseIf mAllowNonZerosSet Then
        AllowAllValues = False
    ElseIf mAllowNoValuesSet Then
        AllowAllValues = False
    ElseIf Not mOrValues Is Nothing Then
        If mOrValues.Count > 0 Then
            AllowAllValues = False
        End If

    End If
End Property

Public Sub ClearFilter()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mAllowBlanksSet = False
    mAllowNonBlanksSet = False
    mAllowNonZerosSet = False
    mAllowBlanks = False
    mAllowNoValues = False
    mAllowNonBlanks = False
    mAllowNonZeros = False
    mAllowNoValuesSet = False
    Set mOrValues = New Collection
    Set mOrValuesOrig = New Collection
End Sub
Public Property Get columnIndex() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    columnIndex = mColumnIndex
End Property

Public Property Let columnIndex(ByVal value As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mColumnIndex = value
End Property

Public Property Get AllowBlanks() As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    AllowBlanks = mAllowBlanks
End Property

Public Property Let AllowBlanks(ByVal AllowBlanks As Boolean)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mAllowBlanks = AllowBlanks
    mAllowBlanksSet = True
End Property

Public Property Get AllowNonBlanks() As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    AllowNonBlanks = mAllowNonBlanks
End Property

Public Property Let AllowNonBlanks(ByVal AllowNonBlanks As Boolean)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mAllowNonBlanks = AllowNonBlanks
    mAllowNonBlanksSet = True
End Property

Public Property Get AllowNonZeros() As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    AllowNonZeros = mAllowNonZeros
End Property

Public Property Let AllowNonZeros(ByVal value As Boolean)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mAllowNonZeros = value
    mAllowNonZerosSet = True
End Property


Public Sub AddValidValue(value As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mOrValues Is Nothing Then
        Set mOrValues = New Collection
        
    End If
    If mOrValuesOrig Is Nothing Then Set mOrValuesOrig = New Collection
    mOrValuesOrig.Add value
    mOrValues.Add UCase(Trim(value))
End Sub

'Public Sub AddOrValue(value As Variant)
'    If mOrValues Is Nothing Then Set mOrValues = New Collection
'    mOrValues.Add value
'End Sub

'Public Sub AddAndValue(value As Variant)
'    If mAndValues Is Nothing Then Set mAndValues = New Collection
'    mValidValues.Add value
'End Sub
Public Function ValueMeetsCondition(value As String) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    ValueMeetsCondition = False
    
    If mAllowNoValuesSet Then
        If mAllowNoValues = True Then
            Exit Function
        End If
    End If
    
    If AllowAllValues Then
        ValueMeetsCondition = True
        Exit Function
    End If
    
    If mAllowBlanksSet Then
        If value = "" Then
            ValueMeetsCondition = True
            Exit Function
        End If
    End If
        
    If mAllowNonBlanksSet Then
        If value <> "" Then
            ValueMeetsCondition = True
            Exit Function
        End If
    End If
    
    If mAllowNonZerosSet Then
        If value <> "0" And value <> "" Then
            ValueMeetsCondition = True
            Exit Function
        End If
    End If
        
    Dim str As String
    str = UCase(Trim(value))
    
    ValueMeetsCondition = False
    If Not mOrValues Is Nothing Then
        For i = 1 To mOrValues.Count
            If mOrValues(i) = str Then
                ValueMeetsCondition = True
                Exit For
            End If
        Next
    End If
End Function





Attribute VB_Name = "FormulaReference"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public Enum FormulaReferenceTypes
    Name_E
    CellAddress_E
    Variable_E
End Enum

Private mExcelApp As Excel.Application
Private mType As FormulaReferenceTypes
Private mFullFormula As String
Private mText As String
Private mSheetName As String
Private mWorkbookName As String
Private mWorkbookPath As String
Private mStartIndex As Integer
Private mFormulaLocation As Range

Private mNameRef As String
Private mCellRangeRef As String
Private mVariableRef As String
Private mVariableHeading As String

Private mCellRange As Excel.Range
Private mCellRangeChecked As Boolean
Private mName As Excel.Name
Private mNameChecked As Boolean

Public Sub Init(sFullFormula As String, _
                sReferenceText As String, _
                iStartIndex As Long, _
                rFormulaLocation As Range)
'                , _
'                eReferenceType As FormulaReferenceTypes, _
'                Optional sSheetName As String, _
'                Optional sWorkbookName As String, _
'                Optional nRefersToName As Excel.Name)
    mFullFormula = sFullFormula
    mText = sReferenceText
    mStartIndex = iStartIndex
    Set mFormulaLocation = rFormulaLocation
    If Not rFormulaLocation Is Nothing Then Set mExcelApp = rFormulaLocation.Application
    
    mSheetName = ""
    mWorkbookName = ""
    mWorkbookPath = ""
    Set mName = Nothing
    Set mCellRange = Nothing
    
    Dim sheetText As String
    Dim refText As String
    Dim pos As String
    
    'Separate the text into the sheet part and the cell reference part
    pos = InStr(1, mText, "!", vbTextCompare)
    If pos > 0 Then
        'left side
        sheetText = Left(mText, pos - 1)
        'Right side
        refText = Right(mText, Len(mText) - pos)
    Else
        refText = mText
    End If
    If InStr(1, refText, "=") Then refText = Replace(refText, "=", "")
    If InStr(1, sheetText, "=") Then sheetText = Replace(sheetText, "=", "")
    
    'Reference Type
    Dim i As Long
    If IsVariableText(refText) Then
        mType = Variable_E
        mVariableRef = Replace(refText, "[", "", 1, 1)
        mVariableRef = Left(mVariableRef, Len(mVariableRef) - 1)
        i = InStr(1, mVariableRef, ":")
        If i > 0 Then
            mVariableHeading = Trim(Left(mVariableRef, i - 1))
            mVariableRef = Trim(Right(mVariableRef, Len(mVariableRef) - i))
        End If
    ElseIf IsTextACellReference(refText) Then
        mType = CellAddress_E
        mCellRangeRef = refText
    Else
        mType = Name_E
        mNameRef = refText
    End If
    
    If sheetText <> "" Then ParseSheetText sheetText
End Sub
Private Function IsVariableText(str As String) As Boolean
    Dim temp As String
    temp = UCase(Trim(str))
    If Left(str, 1) = "[" And Right(str, 1) = "]" Then
        'make sure it isn't a cell reference
        'If InStr(1, str, "!") = 0 Then
        IsVariableText = True
    End If
End Function
Private Sub ParseSheetText(ByVal strText As String)
    Dim bracket1 As Long, bracket2 As Long
    Dim path As String, wkbkName As String, shtName As String
    strText = Trim(strText)
    'ignore = and '
    If InStr(1, strText, "=") Then strText = Replace(strText, "=", "")
    ' the ' is used in formula with spaces
    If InStr(1, strText, "'") Then strText = Replace(strText, "'", "")
    
    'Formula is arranged like this:
    '=Path[WorkbookName]SheetName!CellReference
    bracket1 = InStr(1, strText, "[")
    bracket2 = InStrRev(strText, "]")
    
    If bracket1 > 1 Then mWorkbookPath = Left(strText, bracket1 - 1)
    If bracket1 > 0 And bracket2 > 0 Then
        mWorkbookName = Mid(strText, bracket1 + 1, bracket2 - bracket1 - 1)
    End If
    
    If bracket2 > 0 Then
        mSheetName = Right(strText, Len(strText) - bracket2)
    Else
        mSheetName = strText
    End If
End Sub
Private Function IsTextACellReference(strText As String) As Boolean
    Dim temp As String
    On Error GoTo Error_Exit
    If Not mExcelApp Is Nothing Then
        If mExcelApp.ReferenceStyle = xlA1 Then
            temp = mExcelApp.ConvertFormula(strText, mExcelApp.ReferenceStyle, xlR1C1, True)
        Else
            temp = mExcelApp.ConvertFormula(strText, mExcelApp.ReferenceStyle, xlA1, True)
        End If
    End If
    
    'if the text was actually changed then it was a valid cell reference
    If temp <> strText Then
        IsTextACellReference = True
    End If
    'if error occurs then it wasn't a valid cell reference
Error_Exit:
End Function
Public Property Get FormulaLocation() As Excel.Range
    Set FormulaLocation = mFormulaLocation
End Property
Public Property Get ReferenceType() As FormulaReferenceTypes
    ReferenceType = mType
End Property
Public Property Get FullFormula() As String
    FullFormula = mFullFormula
End Property
Public Property Get Text() As String
    Text = mText
End Property
Public Property Get SheetName() As String
    If mSheetName = "" Then
        If Not Me.Range Is Nothing Then mSheetName = mCellRange.Worksheet.Name
    End If
    
    SheetName = mSheetName
End Property
Public Property Get WorkbookName() As String
    If mWorkbookName = "" Then
        If Not Me.Range Is Nothing Then mWorkbookName = mCellRange.Worksheet.Parent.Name
    End If

    WorkbookName = mWorkbookName

End Property
Public Property Get WorkbookPath() As String
    If WorkbookPath = "" Then
        If Not Me.Range Is Nothing Then mWorkbookPath = mCellRange.Worksheet.Parent.path
    End If
    
    WorkbookPath = mWorkbookPath
End Property
Public Property Get startIndex() As Integer
    startIndex = mStartIndex
End Property
Public Property Get VariableHeading() As String
    VariableHeading = mVariableHeading
End Property
Public Property Get VariableText() As String
    VariableText = mVariableRef
End Property
Public Property Get Range() As Range
    'If mType = Name_E Then Exit Property
    'If the type is Name then this will return the refer to range
    
    On Error Resume Next
    If Not mCellRange Is Nothing Then
        Set Range = mCellRange
    Else
        'This should save some time when getting the cell reference, there are much less calls to the Excel object model
        If Not mCellRangeChecked Then
            Set mCellRange = mFormulaLocation.Worksheet.Evaluate(mText)
            If Not mCellRange Is Nothing Then Set Range = mCellRange
        End If
        mCellRangeChecked = True
'        'can't open another workbook to get the reference to the range
'        'if the path is in the formula, then the other workbook is closed
'        If mWorkbookPath <> "" Then Exit Property
'
'        Dim wkbk As Workbook
'        If mWorkbookName <> "" Then
'            Set wkbk = mExcelApp.Workbooks(mWorkbookName)
'            'couldn't find the workbook
'            If wkbk Is Nothing Then Exit Property
'        Else
'            Set wkbk = mFormulaLocation.Worksheet.Parent
'        End If
'
'        Dim sht As Worksheet
'        If mSheetName <> "" Then
'            Set sht = wkbk.Worksheets(mSheetName)
'            'sheet couldn't be found
'            If sht Is Nothing Then Exit Property
'        Else
'            Set sht = mFormulaLocation.Worksheet
'        End If
'
'        If mCellRangeRef <> "" Then
'            Set mCellRange = sht.Range(mCellRange)
'            Set Range = mCellRange
'        End If
    End If
End Property
Public Property Get Name() As Excel.Name
    If mType = CellAddress_E Then Exit Property
    
    On Error Resume Next
    If Not mName Is Nothing Then
        Set Name = mName
    Else
        Dim r As Range
        'This should save some time when getting the cell reference, there are much less calls to the Excel object model
        If Not mNameChecked Then
            Set r = mFormulaLocation.Worksheet.Evaluate(mText)
            Set mName = r.Name
            If Not mName Is Nothing Then Set Name = mName
        End If
        mNameChecked = True
'        'can't open another workbook to get the reference to the name
'        'if the path is in the formula, then the other workbook is closed
'        If mWorkbookPath <> "" Then Exit Property
'
'        Dim wkbk As Workbook
'        If mWorkbookName <> "" Then
'            Set wkbk = mExcelApp.Workbooks(mWorkbookName)
'            'couldn't find the workbook
'            If wkbk Is Nothing Then Exit Property
'        Else
'            Set wkbk = mFormulaLocation.Worksheet.Parent
'        End If
'
'        Dim sht As Worksheet
'        If mSheetName <> "" Then
'            Set sht = wkbk.Worksheets(mSheetName)
'            'sheet couldn't be found
'            If sht Is Nothing Then Exit Property
'        Else
'            Set sht = mFormulaLocation.Worksheet
'        End If
'
'        If mNameRef <> "" Then
'            If sht Is Nothing Then
'                Set mName = wkbk.Names(mNameRef)
'            Else
'                Set mName = sht.Names(mNameRef)
'            End If
'            Set Name = mName
'        End If
    End If
End Property













Attribute VB_Name = "FormulaReferences"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'-----------------------------------------------
' The FormulaReferences collection class
'-----------------------------------------------

Option Explicit

Private m_LastInvoiceNumber As Long
' the internal collection of invoices
Private mFormulaReferences As New Collection
Public Event ColumnAdded()
Private mNamedRange As Name

Sub Add(Item As FormulaReference, Optional key As Variant)
    mFormulaReferences.Add Item, key
End Sub

Public Sub Remove(Index As Variant)
    mFormulaReferences.Remove Index
End Sub

' Return a FormulaReference item from the collection
Function Item(Index As Variant) As FormulaReference
    If Index > 0 And Index <= mFormulaReferences.Count Then
        Set Item = mFormulaReferences.Item(Index)
    End If
End Function

' Return the number of items in the collection
Property Get Count() As Long
    Count = mFormulaReferences.Count
End Property

' Remove all items from the collection
Public Sub Clear()
    Set mFormulaReferences = New Collection
End Sub









Attribute VB_Name = "ItemReports"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mReportTemplatePath As String
Private mReport As CReport
Attribute mReport.VB_VarHelpID = -1



Private Function FileNameOnly(strPath As String) As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If InStr(1, strPath, "\") > 0 Then
        FileNameOnly = Trim(Right(strPath, Len(strPath) - InStrRev(strPath, "\")))
    Else
        FileNameOnly = strPath
    End If
End Function
Public Function AddReportToWorkbook(FileName As String, wkbk As Workbook, Optional Index As Long = 0, _
                                    Optional bGenerateReport As Boolean = True, Optional newReportName As String) As Worksheet
'    '<CSCustomCode> 1
'    On Error Resume Next
'    '</CSCustomCode> 1
'    On Error Resume Next
'    Dim sht As Worksheet
'    Dim mt As MaderaTemplates
'    Set mt = New MaderaTemplates
'
'    Dim strName As String
'    strName = Replace(FileNameOnly(FileName), ".xls", "", , , vbTextCompare)
'    If newReportName = "" Then newReportName = "Report - " & strName
'
'    mTracker.PrepareApplication , False, False
'
'    Set sht = mt.AddTemplateToWorkbook(mTracker, FileName, wkbk, Index, newReportName)
'
'
'    mTracker.RestoreApplication
'
'    If bGenerateReport = True Then
'        Me.GenerateItemReport sht, g.ManageDB
'    End If
'    Set AddReportToWorkbook = sht
End Function
Public Sub SaveSheetAsReportTemplate(ReportSheet As Worksheet, strTitle As String)
'    '<CSCustomCode> 1
'    On Error Resume Next
'    '</CSCustomCode> 1
'    Dim wkbk As Workbook
'    Dim appSettings As ExcelAppManager
'    On Error Resume Next
'
'    Dim ap As Excel.Application
'    Set ap = ReportSheet.Application
'    Set appSettings = New ExcelAppManager
'    If strTitle = "" Then strTitle = ReportSheet.names("Title").RefersToRange.Value
'
'    appSettings.PrepareApplication ap, , False, False, True
'    ap.DisplayAlerts = False
'
'    Set wkbk = ReportSheet.Application.Workbooks.Add
'
'    ReportSheet.Copy wkbk.Sheets(1)
'
'    wkbk.Application.DisplayAlerts = False
'    For i = 2 To wkbk.Sheets.Count
'        wkbk.Sheets(2).Delete
'    Next
'
'    Err.Clear
'    Dim wkbkName As String
'    Dim strPath As String
'
'    wkbkName = strTitle
'    strPath = Me.ReportTemplatePath & IIf(Right(Me.ReportTemplatePath, 1) <> "\", "\", "")
'
'    'get rid of all names linking to an external workbook
'    Dim nm As Name
'    Dim str As String
'    Dim pos As Long
'    For Each nm In wkbk.names
'        str = ""
'        str = nm.RefersTo
'        If Left(str, 1) = "=" Then
'            pos = InStr(1, str, "[")
'            If pos > 0 Then
'                'if the bracket isn't surrounded by quotation marks then this is probably a reference
'                'to an external workbook.
'                'Delete it
'                If Mid(str, pos - 1, 1) <> """" Then
'                    nm.Delete
'                End If
'            End If
'        End If
'    Next
'
'    'delete any files with the same name
'    If FileExists(strPath & wkbkName & ".xls") Then
'        If vbYes = MsgBox("Would you like to overwrite the existing report?", vbYesNo, "Overwrite Report") Then
'            Kill strPath & wkbkName & ".xls"
'        Else
'            For i = 1 To 100
'                If Not FileExists(strPath & wkbkName & CStr(i) & ".xls") Then
'                    wkbkName = wkbkName & CStr(i)
'                    Exit For
'                End If
'            Next
'        End If
'    End If
'
''    Dim secs As SectionCollection
''    Dim strCategory As String
''    Set secs = New SectionCollection
''    secs.FillSectionsFromSheet ReportSheet
''    For i = 1 To secs.Count
''        If secs(i).sectionType = Report_E Then
''            If secs(i).ReportType <> "" Then
''                strCategory = secs(i).ReportType
''                Exit For
''            End If
''        End If
''    Next
''
''    secs.Dispose
'
'    wkbk.Sheets(1).Name = VerifySheetName(strTitle, wkbk, False)
'    wkbk.Sheets(1).names("Title").RefersToRange.Value = strTitle
''    If strCategory <> "" Then
''        SetReportCategory wkbk, strCategory
''    End If
'    wkbk.SaveAs strPath & wkbkName & ".xls"
'    wkbk.Close False
'    ap.DisplayAlerts = True
'    appSettings.RestoreApplication
'
End Sub

Public Function GetSheetReportSection(sht As Worksheet) As Collection
    Dim reportSections As Collection
    Set reportSections = New Collection
    
    Dim i As Long
    Dim nm As Name
    Dim sec As ItemSection
    Dim rng As Range
    On Error Resume Next
    For i = 1 To sht.names.Count
        Set nm = sht.names(i)
        If Not nm Is Nothing Then
            If InStr(1, nm.Name, "ReportList", vbTextCompare) > 0 Then
                Set sec = New ItemSection
                Set rng = Nothing
                Set rng = nm.RefersToRange
                If Not rng Is Nothing Then
                    sec.Init nm.RefersToRange, True
                    reportSections.Add sec
                End If
            End If
        End If
    Next
    Set GetSheetReportSection = reportSections
End Function
Public Sub ClearReport(ReportSheet As Worksheet)
    On Error Resume Next
    Dim reportSections As Collection
    Set reportSections = GetSheetReportSection(ReportSheet)

    If reportSections.Count = 0 Then Exit Sub
    
    Dim sec As ItemSection
    For i = 1 To reportSections.Count
        Set sec = reportSections(i)
        sec.SetRowCount 0
    Next
    ClearReportPictures ReportSheet
End Sub




Private Function GetWorkbookToImportFrom(sht As Worksheet) As Workbook
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim strFileName As String
    Dim wkbk As Workbook
    On Error Resume Next
    strFileName = sht.names("ImportFilename").RefersToRange.value
    If strFileName <> "" Then
        If FileExists(strFileName) Then
            Set wkbk = OpenWorkbook(strFileName, False, False)
        End If
        Set GetWorkbookToImportFrom = wkbk
    End If
End Function
Public Sub GenerateItemReport(ReportSheet As Worksheet)
    On Error Resume Next

    'get the report sections on the sheet
    Dim reportSections As Collection
    Set reportSections = GetSheetReportSection(ReportSheet)
    If reportSections.Count = 0 Then Exit Sub
   
    Dim s As ItemSection
    Dim wkbk As Workbook

    Dim continue As Boolean
    Dim r As CReport
    
    'mTracker.PrepareApplication ReportSheet, False, False
    continue = True

    For i = 1 To reportSections.Count
        Set s = reportSections(i)
        
        Set mReport = New CReport
        mReport.Init reportSections(i)
        
        Set wkbk = GetWorkbookToImportFrom(ReportSheet)
   
        If continue = True Then
            If wkbk Is Nothing Then Set wkbk = ReportSheet.Parent
            If UCase(Trim(mReport.ReportType)) = "COSTCODE" Then
                'see if we need to sort the report
                Dim bSort As Boolean
                If s.ColumnExists("Description") Then
                    If s.GetColumnSetting(s.GetColumnIndex("Description"), "GroupSort") = "Ascending" Then
                        bSort = True
                    End If
                End If
                FillCostCodeReport ReportSheet, bSort
            ElseIf UCase(Trim(mReport.ReportType)) = "SPEC" Then
                FillSpecReport ReportSheet
            Else
                mReport.Generate wkbk
            End If
        End If
        Set mReport = Nothing
        
    Next
End Sub

Private Function FileExists(FileName As String) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim vFlag As Variant
    
    On Error Resume Next
    vFlag = Dir(FileName)
    
    If Err <> 0 Then Exit Function
    
    If Not IsNull(vFlag) Then
        If Len(vFlag) > 0 Then
            FileExists = True
        End If
    End If
End Function





Attribute VB_Name = "ItemSection"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' (c) 2011 - Lorin Boyer  Email:lorin@maderasoft.com  Phone:210-568-8151
'  All rights to use, reproduce or publish this code reserved.
' -------------------------------------------------------------

Private mValues() As Variant
Private mCellFormulas() As Variant
Private mValuesSet As Boolean
Private mKeys As Collection
Private mFormulas As Collection
Private mHeadings As Collection
Private mColumnSettings As Collection
Private mCaption As String
Private mCaptionChecked As Boolean
Private mColSheetIndexes As Collection
Private mRng As Range
Private mItemRng As Range

Private mDirty As Boolean

Public Enum CriteriaType
    CriteriaEquals_E = 1
    GreaterThan_E = 2
    GreaterThanOrEqualTo_E = 3
    LessThan_E = 4
    LessThanOrEqualTo_E = 5
    TextEquals_E = 6
End Enum
Private mProtectSheet As Boolean
Private mLayouts As ItemSectionLayouts

Public MainSectionHeaderRow As ItemSectionHeaderRow
Private mHeaderRows As Collection
Public Property Get ItemSectionHeaderRows() As Collection
    If mHeaderRows Is Nothing Then Set mHeaderRows = New Collection
    Set ItemSectionHeaderRows = mHeaderRows
End Property

Public Property Get SheetName() As String
    SheetName = Range.Worksheet.Name
End Property
Public Property Get Layouts() As ItemSectionLayouts
    Dim rng As Range
    
    On Error Resume Next
    If mLayouts Is Nothing Then
        Set mLayouts = New ItemSectionLayouts
        Set rng = mRng.Worksheet.names("ColumnLayouts").RefersToRange
        If rng Is Nothing Then
            MsgBox "Could not find column layouts"
            Exit Property
        Else
            mLayouts.Init rng
        End If
    End If
    Set Layouts = mLayouts
End Property
Public Sub PrepareSheet(Optional unprotectSheet As Boolean = True)

    mProtectSheet = False
    
    If unprotectSheet = True Then
        'unprotect the sheet
        If mRng.Worksheet.ProtectContents = True Then
            mRng.Worksheet.Unprotect
            mProtectSheet = True
        End If
    End If
End Sub
Public Sub RestoreSheet()
    If mProtectSheet = True Then
        If mRng.Worksheet.ProtectContents = False Then
            mRng.Worksheet.protect
        End If
    End If
End Sub
Public Property Get columnKeys() As Collection
    Set columnKeys = mKeys
End Property
Public Property Get ColumnHeaders() As Collection
    Set ColumnHeaders = mHeadings
End Property

Public Property Get Range() As Range
    Set Range = mRng
End Property
Public Property Get value(Row As Long, col As Long) As Variant
    On Error Resume Next
    If mDirty = True Then
        mValues = mRng.value
        mCellFormulas = mRng.Formula
        mDirty = False
    End If
    value = mValues(Row, col)
End Property
Public Property Get Formula(Row As Long, col As Long) As Variant
    On Error Resume Next
    If mDirty = True Then
        mValue = mRng.value
        mCellFormulas = mRng.Formula
        mDirty = False
    End If
    Formula = mCellFormulas(Row, col)
End Property
Public Property Get ItemRange() As Range
    If mRng.Cells.Count > 2 Then
        Set ItemRange = mRng.offset(1).Resize(mRng.rows.Count - 2)
    End If
End Property
'returns the cell at the row/column
Public Function GetCell(columnKey As String, Row As Long) As Range
    Dim col As Long
    col = GetColumnIndex(columnKey)
    If col = 0 Then Exit Function
    
    Set GetCell = mRng.Cells(Row, col)
End Function
'return the cell at the row/column
Public Property Get cell(columnIndex As Long, rowIndex As Long) As Range
    Set cell = mRng.Cells(columnIndex, rowIndex)
End Property

Public Property Let value(Row As Long, col As Long, newValue As Variant)
    On Error Resume Next
    If mDirty = True Then
        mValues = mRng.value
        mDirty = False
    End If
    mValues(Row, col) = newValue
    mRng.Cells(Row, col).value = newValue
End Property

Public Property Get rowCount() As Long
    rowCount = UBound(mValues)
End Property
Public Property Let Caption(value As String)
    mCaption = value
End Property
Public Property Get Caption() As String
    On Error Resume Next
    If Len(mCaption) = 0 Then
        If mCaptionChecked = False Then
            mCaption = GetSheetTitle(Me.Range.Worksheet)
            mCaptionChecked = True
        End If
    End If
    Caption = mCaption
End Property
Private Function GetSheetTitle(sht As Worksheet) As String
    'see if the sheet have a "Title" range
    Dim nm As Name
    Dim str As String

    On Error Resume Next
    Set nm = sht.names("Title")
    If Not nm Is Nothing Then
        str = nm.RefersToRange.value
    Else
        str = sht.Name
    End If
    GetSheetTitle = str
End Function
Public Function RowMeetsCriteria(Row As Long, columnIndex As Long, criteriaValue As Variant, criteria As CriteriaType) As Boolean
    On Error Resume Next
    
    If Row - 1 > 0 And Row <= UBound(mValues) Then
        If columnIndex > 0 And columnIndex <= UBound(mValues, 2) Then
            If criteria = CriteriaEquals_E Then
                If mValues(Row, columnIndex) = criteriaValue Then RowMeetsCriteria = True
            ElseIf criteria = GreaterThan_E Then
                If mValues(Row, columnIndex) > criteriaValue Then RowMeetsCriteria = True
            ElseIf criteria = GreaterThanOrEqualTo_E Then
                If mValues(Row, columnIndex) >= criteriaValue Then RowMeetsCriteria = True
            ElseIf criteria = LessThan_E Then
                If mValues(Row, columnIndex) < criteriaValue Then RowMeetsCriteria = True
            ElseIf criteria = LessThanOrEqualTo_E Then
                If mValues(Row, columnIndex) <= criteriaValue Then RowMeetsCriteria = True
            ElseIf criteria = TextEquals_E Then
                If UCase(Trim(mValues(Row, columnIndex))) = UCase(Trim(criteriaValue)) Then RowMeetsCriteria = True
            End If
        End If
    End If
End Function
Public Function GetColumnFilter(lColumnIndex As Long) As CFilter
    Dim sFilter As String
    Set GetColumnFilter = Nothing
    sFilter = Me.GetColumnSetting(lColumnIndex, "FilterValue")
    sFilter = Me.GetColumnSetting(lColumnIndex, "Filter")
    If sFilter <> "" Then
        Dim f As CFilter
        Set f = New CFilter
        f.FillFromString sFilter
        Set GetColumnFilter = f
    End If
End Function
Public Function GetColumnSetting(lColumnIndex As Long, strSettingName As String) As String
    On Error Resume Next
    Dim sp As SettingsParser
    Set sp = mColumnSettings(lColumnIndex)
    If Not sp Is Nothing Then
        GetColumnSetting = sp.Setting(strSettingName)
    End If

End Function
Public Sub Init(rngOrSheet As Object, Optional isMaderaSection As Boolean = False)
    Dim i As Long
    
    On Error Resume Next
    If TypeName(rngOrSheet) = "Range" Then
        Set mRng = rngOrSheet
    Else
        Set mRng = rngOrSheet.names("SectionRange").RefersToRange
    End If
    

    Set mItemRng = mRng.offset(1).Resize(mRng.rows.Count - 2)
    Set mKeys = New Collection
    Set mHeadings = New Collection
    Set mFormulas = New Collection
    Set mColumnSettings = New Collection

    'Store the values
    mValues = mRng.value
    mCellFormulas = mRng.Formula
    
    'the keys are always 2 rows above the section
    If isMaderaSection = True Then
        Dim rngTemp As Range
        Dim sKey As String
        Dim sFormula As String
        Dim sp As SettingsParser
        
        Set rngTemp = FindMaderaSettingsRow
        If Not rngTemp Is Nothing Then
            For i = 1 To rngTemp.Columns.Count
                sKey = ""
                sFormula = ""
                ParseMaderaSettings rngTemp.Cells(1, i), sKey, sFormula
                mKeys.Add sKey
                mFormulas.Add sFormula
                mHeadings.Add mRng.Cells(1, i).value
                Set sp = New SettingsParser
                sp.SettingString = rngTemp.Cells(1, i)
                mColumnSettings.Add sp
            Next
        End If
    Else
        For i = 1 To mRng.Columns.Count
            mKeys.Add mRng.Cells(-1, i).value
            mHeadings.Add mRng.Cells(1, i).value
            mFormulas.Add mRng.Cells(-3, i).value
            
            Set sp = New SettingsParser
            sp.SettingString = mRng.Cells(-1, i).value
            mColumnSettings.Add sp
        Next
    End If
End Sub

Private Sub ParseMaderaSettings(cell As Range, outKey As String, outFormula As String)
    Dim values() As String
    values = Split(cell.value, "::")
    For i = LBound(values) To UBound(values) Step 2
        Select Case UCase(Trim(values(i)))
            Case "KEY"
                outKey = Trim(values(i + 1))
            Case "FORMULA"
                outFormula = Trim(values(i + 1))
        End Select
    Next
End Sub
Private Function FindMaderaSettingsRow() As Range
    Dim i As Long
    Dim rng As Range
    Dim c As Range
    Dim values() As Variant
    
    Dim y As Long
    Dim z As Long
    
    For i = 1 To 4
        If i > 0 Then
            Set rng = mRng.rows(1).offset(-i)
            values = rng.value
            
            For y = LBound(values, 2) To UBound(values, 2)
                If InStr(1, values(1, y), "::") > 0 Then
                    Set FindMaderaSettingsRow = rng
                    Exit Function
                End If
            Next
        End If
    Next
End Function

Public Function FindItem(columnKey As String, value As Variant) As Long
    Dim i As Long
    Dim col As Long
    
    'set the default value
    FindItem = -1
    
    'find the column
    col = Me.GetColumnIndex(columnKey)
    If col < 1 Then Exit Function
    
    'search the column for the value
    
    For i = 2 To Me.rowCount - 1
        If IsNumeric(mValues(i, col)) Then
            If mValues(i, col) = value Then
                FindItem = i
                Exit For
            End If
        ElseIf UCase(Trim(CStr(mValues(i, col)))) = UCase(Trim(value)) Then
            FindItem = i
            Exit For
        End If
    Next
End Function

Public Function GetColumnIndex(strKey As String) As Long
    Dim i As Long
    Dim str As String
    
    If strKey = "" Then Exit Function
    
    str = UCase(Trim(strKey))
    
    For i = 1 To mKeys.Count
        If Trim(UCase(mKeys(i))) = str Then
            GetColumnIndex = i
            Exit For
        End If
    Next
    
End Function

Public Function IsHeaderRow(Row As Long) As Boolean
    Dim sInfo As String
    If Me.ColumnExists("Info") = True Then
        sInfo = UCase(Trim(Me.value(Row, Me.GetColumnIndex("Info"))))
        If Len(sInfo) >= 5 Then
            If Left(sInfo, 6) = "HEADER" Then
                IsHeaderRow = True
            End If
        End If
'        If InStr(1, Me.Value(row, Me.GetColumnIndex("Info")), "Header", vbTextCompare) > 0 Then
'            IsHeaderRow = True
'        End If
    End If
    
    If IsHeaderRow = False Then
        If Me.ColumnExists("IsHeader") Then
            If Me.value(Row, Me.GetColumnIndex("IsHeader")) <> "" Then IsHeaderRow = True
        End If
    End If
    
    If IsHeaderRow = False Then
        If Me.ColumnExists("HeaderIndicator") Then
            If Me.value(Row, Me.GetColumnIndex("HeaderIndicator")) <> "" Then IsHeaderRow = True
        End If
    End If
End Function

Public Function IsAssemblyRow(Row As Long) As Boolean
    If Me.ColumnExists("Info") = True Then
        If InStr(1, Me.value(Row, Me.GetColumnIndex("Info")), "Assembly", vbTextCompare) > 0 Then IsAssemblyRow = True
    End If
End Function

'Returns true if a column exists with the Key
Function ColumnExists(strColumnKey As String) As Boolean
    If GetColumnIndex(strColumnKey) > 0 Then
        ColumnExists = True
    Else
        ColumnExists = False
    End If
End Function

'returns the number of columns in the section
Function columnCount() As Long
    columnCount = mRng.Columns.Count
End Function

Public Function SumColumn(columnKey As String, Optional FilterColumn As String, Optional FilterValue As String) As Variant
    Dim i As Long
    Dim v As Variant
    Dim colIndex As Long
    Dim b As Boolean
    Dim filterCol As Long
    
    colIndex = GetColumnIndex(columnKey)
    
    If FilterColumn <> "" Then filterCol = Me.GetColumnIndex(FilterColumn)
    If colIndex = 0 Then Exit Function
    For i = LBound(mValues) To UBound(mValues)
        b = True
        If filterCol > 0 Then
            If UCase(Trim(mValues(i, filterCol))) <> UCase(Trim(FilterValue)) Then
                b = False
            End If
        End If
        If b = True Then v = v + mValues(i, colIndex)
    Next
    
    SumColumn = v
End Function

Public Function AverageColumn(columnKey As String, Optional IgnoreBlanks As Boolean = False, _
                                Optional FilterColumn As String, Optional FilterValue As String) As Variant
    Dim i As Long
    Dim v As Variant
    Dim colIndex As Long
    Dim cnt As Long
    Dim b As Boolean
    Dim filterCol As Long

    colIndex = GetColumnIndex(columnKey)
    If FilterColumn <> "" Then filterCol = Me.GetColumnIndex(FilterColumn)
        
    If colIndex = 0 Then Exit Function
    For i = LBound(mValues) To UBound(mValues)
            b = True
            If filterCol > 0 Then
                If UCase(Trim(mValues(i, filterCol))) <> UCase(Trim(FilterValue)) Then
                    b = False
                End If
            End If
            
            If b = True Then
                If IgnoreBlanks = True Then
                    If IsEmpty(mValues(i, colIndex)) = False Then
                        v = v + mValues(i, colIndex)
                        cnt = cnt + 1
                    End If
                Else
                    v = v + mValues(i, colIndex)
                    cnt = cnt + 1
                End If
            End If
    Next
    
    If v <> 0 Then
        AverageColumn = v / cnt
    End If
End Function

Private Function ValueInCollection(col As Collection, value As Variant, ByRef outIndex As Long) As Boolean
    Dim i As Long

    For i = 1 To col.Count
        If UCase(Trim(col(i))) = UCase(Trim(value)) Then
            ValueInCollection = True
            outIndex = i
            Exit Function
        End If
    Next
End Function

Public Property Get TemplateRow() As Range
    Dim rng As Range
    On Error Resume Next
    Set rng = mRng.Worksheet.names("TemplateRow").RefersToRange
    If rng Is Nothing Then Set rng = mRng.Worksheet.names("SectionTemplateRow").RefersToRange
    If rng Is Nothing Then Set rng = mRng.rows(1).offset(-3)
    Set TemplateRow = rng
    'the template row is always 3 rows above
    'Set TemplateRow = mRng.rows(1).Offset(-3)
End Property

Public Function GetTemplateRowCell(colIndex As Long)
    Dim rng As Range
    Set rng = Application.Intersect(TemplateRow.EntireRow, Me.Range.EntireColumn)
    Set GetTemplateRowCell = rng.Cells(1, colIndex)
End Function
Public Function AddMultipleRows(rowCount As Long, Optional rowToAddAbove As Long = 0, Optional unprotectSheet As Boolean = True) As Boolean
    Dim rng As Range
    Dim rng2 As Range
    Dim sht As Worksheet
    Dim strFormula As String
    Dim protect As Boolean
    Dim newRng As Range
    
    If rowCount < 1 Then Exit Function
    
    If unprotectSheet = True Then Me.PrepareSheet True
    
    protect = mRng.Worksheet.ProtectContents
    If protect = True Then mRng.Worksheet.Unprotect

    
    On Error Resume Next
    'make sure the sheet is selected
    mRng.Worksheet.Activate
    
    If rowToAddAbove = 0 Then rowToAddAbove = mRng.rows.Count
    
    Dim InsertRow As Range
    Set InsertRow = mRng.rows(rowToAddAbove).EntireRow
    Set InsertRow = InsertRow.Resize(rowCount)
    InsertRow.Insert
    
    Set newRng = InsertRow.offset(-rowCount)

    'add the row (by copying the template row)
    Me.TemplateRow.EntireRow.Copy
    newRng.EntireRow.PasteSpecial xlPasteAll
    
    'mTotals.Offset(-1).EntireRow.Hidden = True
    newRng.Hidden = False
    Dim newRow As Range
    Set newRow = mRng.rows(rowToAddAbove).offset(-2)
    
    Application.CutCopyMode = xlNone
    
    If unprotectSheet = True Then Me.RestoreSheet
    
End Function

Public Sub ApplyFormattingToRow(rowIndex As Long)
    If rowIndex < 1 Then Exit Sub
    If rowIndex >= Me.rowCount Then Exit Sub
    
    Dim protect As Boolean
    protect = mRng.Worksheet.ProtectContents
    If protect = True Then mRng.Worksheet.Unprotect
    
    Dim h As Boolean
    h = mRng.rows(rowIndex).EntireRow.Hidden
    Me.TemplateRow.EntireRow.Copy
    mRng.rows(rowIndex).EntireRow.PasteSpecial xlPasteFormats
    mRng.rows(rowIndex).EntireRow.Hidden = h
    Application.CutCopyMode = xlNone
    If protect = True Then mRng.Worksheet.protect , , , , True
End Sub


Public Function addRow(Optional rowIndex As Long, _
                        Optional groupRow As Boolean = False, _
                        Optional atActiveCell As Boolean = False) As Long
    'see if there is a template row
    Dim Index As Range
    Dim origSelection As Range
    Dim protect As Boolean
    
    On Error Resume Next
    protect = mRng.Worksheet.ProtectContents
    If protect = True Then mRng.Worksheet.Unprotect
    
    Set origSelection = Application.Selection
    
    If atActiveCell = True Then
        If ActiveCellOnSectionRow = True Then
            rowIndex = ActiveCellRangeRow
        End If
    End If
    
    Application.CutCopyMode = xlNone
    
    If rowIndex = 0 Then
        rowIndex = mRng.rows.Count
    ElseIf rowIndex > mRng.rows.Count Then
        rowIndex = mRng.rows.Count
    End If
    
    mRng.rows(rowIndex).EntireRow.Insert
    Dim tempRow As Range
    Set tempRow = Me.TemplateRow.EntireRow

    tempRow.Copy
    
    Dim newRow As Range
    Set newRow = mRng.rows(rowIndex).EntireRow
    
    newRow.PasteSpecial xlPasteAll
    newRow.EntireRow.Hidden = False
    
    
    Dim rng2 As Range
    Set rng2 = mRng.rows(rowIndex).EntireRow
    If rng2.OutlineLevel > 1 Then rng2.Ungroup
    If rng2.OutlineLevel > 1 Then rng2.Ungroup
    If rng2.OutlineLevel > 1 Then rng2.Ungroup
    
    Application.CutCopyMode = xlNone
    addRow = rowIndex
    
   ' If AtActiveCell = True Then
        'make sure the same cell is selected
        origSelection.Select
   ' End If
    If groupRow = True Then mRng.rows(rowIndex).EntireRow.Group
    
    mDirty = True
    
    If protect = True Then mRng.Worksheet.protect , , , , True
End Function


'use the ItemSection (values) to fill a row in this section
Public Sub FillRowFromSection(rowIndex As Long, values As ItemSection, valuesRow As Long, _
    Optional overwriteFormulasInCells As Boolean = True, Optional CreateLinkFormulasToValues As Boolean = False)
    Dim i As Long
    Dim rng As Range
    Dim col As Long
    Dim strKey As String
    Dim strHeading As String
    
    'copy the template row first
    Set rng = mRng.rows(rowIndex)
    TemplateRow.Copy
    rng.PasteSpecial xlPasteAll
    'rng.Group   'make sure the row is grouped so that the whole section can be collapsed
    
    'fill in values from the other section
    For i = 1 To rng.Columns.Count
        strKey = mKeys(i)
        strHeading = mHeadings(i)

        col = 0
        col = values.GetColumnIndex(strKey)
        If col > 0 Then
            If overwriteFormulasInCells = False Then
                If rng.Cells(1, i).HasFormula = False Then
                    If CreateLinkFormulasToValues Then
                        rng.Cells(1, i).Formula = "=" & values.Range.Cells(valuesRow, col).Address(, , , True)
                    Else
                        rng.Cells(1, i).value = values.value(valuesRow, col)
                    End If
                End If
            Else
                If CreateLinkFormulasToValues Then
                    rng.Cells(1, i).Formula = "=" & values.Range.Cells(valuesRow, col).Address(, , , True)
                Else
                    rng.Cells(1, i).value = values.value(valuesRow, col)
                End If
            End If
        End If
    Next
    mDirty = True
End Sub
Public Function GetColumnKey(colIndex As Long) As String
    Dim str As String
    GetColumnKey = mKeys(colIndex)
End Function
Public Function GetColumnFormula(colIndex As Long) As String
    Dim str As String
    If colIndex > 0 Then
        GetColumnFormula = mFormulas(colIndex)
    End If
End Function
Public Function GetAllColumnValues(strKey As String) As Variant()
 
    Dim col As Long
    col = GetColumnIndex(strKey)
    
    If col = 0 Then Exit Function
 
    If mItemRng.rows.Count = 1 Then
        Dim val(1 To 1) As Variant
        val(1) = mItemRng.Cells(1, col).value
        GetAllColumnValues = val
    ElseIf mItemRng.rows.Count > 0 Then
        GetAllColumnValues = mItemRng.Columns(col).value
    End If
End Function
'Returns the row in the section that the activecell is on.
'The activecell might be on the 10th row of the sheet, but only on the 3rd row of
'the section. This will return 3.
Public Function ActiveCellRangeRow() As Long
    If ActiveCellOnSectionRow = True Then
        ActiveCellRangeRow = ActiveCell.Row - mRng.Row + 1
    End If
End Function
'Returns true if the active cell is on a row in the section
Public Function ActiveCellOnSectionRow() As Boolean
    If ActiveCell.Worksheet.Parent.Name = mRng.Worksheet.Parent.Name Then
        If ActiveCell.Worksheet.Name = mRng.Worksheet.Name Then
            If ActiveCell.Row > mRng.Row And ActiveCell.Row < mRng.Row + mRng.rows.Count - 1 Then
                ActiveCellOnSectionRow = True
            End If
        End If
    End If
End Function

Public Sub DeleteAllRows(Optional unprotectSheet As Boolean = True)
    Dim rows As Long
    
    Dim sht As Worksheet
    Dim rngToDelete As Range
    Set sht = mRng.Worksheet
    If mRng.rows.Count > 2 Then
        If unprotectSheet = True Then Me.PrepareSheet True
        If mRng.rows.Count = 3 Then
            mRng.rows(2).EntireRow.Delete
        Else
            Set rngToDelete = sht.Range(mRng.Cells(2, 1), mRng.Cells(mRng.rows.Count - 1, 1))
            Set rngToDelete = rngToDelete.EntireRow
            Debug.Print rngToDelete.Address
            rngToDelete.Delete
            
            'mRng.Worksheet.Range(mRng.Cells(2, 1), mRng.Cells(mRng.rows.Count - 1, 1)).EntireRow.Delete
        End If
        If unprotectSheet = True Then Me.RestoreSheet
    End If
    mDirty = True
End Sub

Public Sub DeleteRows(startRow As Long, endrow As Long)
    If startRow <= mRng.rows.Count And startRow >= 1 And endrow >= 1 And endrow <= mRng.rows.Count Then
        Dim protect As Boolean
        protect = mRng.Worksheet.ProtectContents
        If protect = True Then mRng.Worksheet.Unprotect
        

        mRng.Worksheet.Range(mRng.Cells(startRow, 1), mRng.Cells(endrow, 1)).EntireRow.Delete
        mDirty = True
        
        If protect = True Then mRng.Worksheet.protect , , , , True
    End If
End Sub
'Deletes a row in the section
Public Sub DeleteRow(Row As Long)
    Dim protect As Boolean
    protect = mRng.Worksheet.ProtectContents
    If protect = True Then mRng.Worksheet.Unprotect
    
    mRng.rows(Row).EntireRow.Delete
    mDirty = True
'    If row = mRng.rows.Count - 1 Then
'        Selection.Offset(-1).Select
'    End If
    
    If protect = True Then mRng.Worksheet.protect , , , , True
End Sub
Public Property Get NumberFormatText(lColumnIndex As Long) As String
    Dim strFormat As String
    strFormat = GetColumnSetting(lColumnIndex, "NumberFormat")
    If strFormat = "Currency" Then
        NumberFormatText = "_($* #,##0.00_);_($* (#,##0.00);_($* ""-""??_);_(@_)"
    Else
        If Left$(strFormat, 32) = "_($* #,##0.00_);_($* (#,##0.00);" Then
            strFormat = "_($* #,##0.00_);_($* (#,##0.00);_($* ""-""??_);_(@_)"
        End If
        NumberFormatText = strFormat
    End If
End Property
Public Property Get NumberFormatForTextFormula(lColumnIndex As Long) As String
    Dim numFormat As String
    Dim currencyFormat As String
    Dim baseNumberFormat As String
    
    numFormat = NumberFormatText(lColumnIndex)
    
    If numFormat = "" Then numFormat = "@"
  
    If currencyFormat = "" Then currencyFormat = "$ #,###.00"
    If baseNumberFormat = "" Then baseNumberFormat = "#,###"

    If InStr(1, numFormat, "_($* #,##0.00_)") Then
        NumberFormatForTextFormula = currencyFormat
    ElseIf Len(numFormat) = 0 Then
        NumberFormatForTextFormula = baseNumberFormat
    ElseIf InStr(1, numFormat, ";") Then
        Dim tempStr As String
        tempStr = Left$(numFormat, InStr(1, numFormat, ";") - 1)
        NumberFormatForTextFormula = tempStr
    Else
        NumberFormatForTextFormula = numFormat
    End If
     
End Property
'Set the number of rows the section needs to have
Public Sub SetRowCount(lRowCount As Long)
    Dim i As Long
    
    DeleteAllRows
    AddMultipleRows lRowCount
    
End Sub


Public Property Get RowEmpty(Row As Long) As Boolean
    Dim i As Long
    Dim b As Boolean
    
    b = True
    For i = 1 To mRng.Columns.Count
        If Me.value(Row, i) <> "" Then
            If Me.value(Row, i) <> "0" Then
                b = False
                Exit For
            End If
        End If
    Next
    RowEmpty = b
End Property

Public Sub RemoveEmptyRows()
    Dim i As Long
    For i = Me.rowCount - 1 To 1 Step -1
        If Me.RowEmpty(i) Then
            Me.DeleteRow i
        End If
    Next
End Sub

'returns then last row that is not empty
Public Property Get LastNonEmptyRow() As Long
    Dim i As Long
    
    'check each row to see if it is empty
    For i = mRng.rows.Count - 1 To 2 Step -1
        If RowEmpty(i) = False Then
            LastNonEmptyRow = i
            Exit For
        ElseIf i = 2 Then
            'the whole section is empty
            LastNonEmptyRow = 1
            Exit For
        End If
    Next
End Property

'Clears all values in the section
Public Sub ClearValues()
    Dim origSelection As Range
    Dim rng As Range
    
    Dim protect As Boolean
    protect = mRng.Worksheet.ProtectContents
    If protect = True Then mRng.Worksheet.Unprotect
    
    On Error Resume Next
    Set origSelection = Selection
    Set rng = mRng
    
    'ignore the first (column headers) and last row (totals)
    Set rng = rng.offset(1).Resize(rng.rows.Count - 2)
    rng.ClearContents
    
    'copy the template row
    mTemplateRow.EntireRow.Copy
    rng.EntireRow.PasteSpecial xlPasteAll
    rng.EntireRow.Hidden = False
    Application.CutCopyMode = xlNone
    
    origSelection.Select
    
    If protect = True Then mRng.Worksheet.protect , , , , True
End Sub

Public Sub SortTwoColumns(columnIndex1 As Long, columnIndex2 As Long)
    Dim rng As Range
    Dim rng2 As Range
    Set rng = mRng.Cells(1, columnIndex1)
    Set rng2 = mRng.Cells(1, columnIndex2)
    On Error Resume Next
    mRng.Sort rng, xlAscending, rng2, , xlAscending, , , xlYes
End Sub
Public Sub Sort(columnIndex As Long, Optional sortAscending As Boolean = True)
    'mRng.Sort mRng.Cells(1, columnIndex), xlAscending, , , , , , xlYes
    
    
    mRng.Worksheet.Sort.SortFields.Clear
    If sortAscending = True Then
        mRng.Worksheet.Sort.SortFields.Add mRng.Cells(1, columnIndex), xlSortOnValues, xlAscending, xlSortNormal
    Else
        mRng.Worksheet.Sort.SortFields.Add mRng.Cells(1, columnIndex), xlSortOnValues, xlDescending, xlSortNormal
    End If
    With mRng.Worksheet.Sort
        .SetRange Me.ItemRange
        .Header = xlNo
        .MatchCase = False
        .Orientation = xlTopToBottom
        .SortMethod = xlPinYin
        .Apply
    End With
End Sub

'returns true if there is no data on the row
Public Property Get IsRowEmpty(rowIndex As Long) As Boolean
    Dim i As Long
    Dim cell As Range
    Dim IsEmpty As Boolean
    
    IsEmpty = True
    
    'check each cell to see if it has a value
    For i = 1 To mRng.Columns.Count
        Set cell = mRng.Cells(rowIndex, i)
        If cell.value <> "" And cell.value <> 0 Then
            IsEmpty = False
            Exit For
        End If
    Next
    
    IsRowEmpty = IsEmpty
End Property


'This function will replace the column references in a formula with the cell references of the column.
'Example: =[Qty]*[Cost]  will become  =B7*C7
Public Function ReplaceColumnKeysInFormula(strFormula As String, Row As Long)
    Dim i As Long, y As Long
    Dim str() As String
    Dim temp As String
    Dim bracketIndex As Long
    str = Split(strFormula, "[")
    For i = LBound(str) To UBound(str)
        'find the text before "]"
        bracketIndex = InStr(1, str(i), "]")
        If bracketIndex > 0 Then
            temp = UCase(Trim(Left(str(i), bracketIndex - 1)))
            For y = 1 To mKeys.Count
                If temp = UCase(Trim(mKeys(y))) Then
                    str(i) = mRng.Cells(Row, y).Address(False, False) & Right(str(i), Len(str(i)) - bracketIndex)
                    Exit For
                End If
            Next
        End If
    Next
    ReplaceColumnKeysInFormula = Join(str, "")
End Function
Public Function SetCellFormula(Row As Long, col As Long, strFormula As String)
    On Error Resume Next
    Dim str As String
    On Error Resume Next
    If strFormula = "" Then Exit Function
    str = ReplaceColumnKeysInFormula(strFormula, Row)
    
    If Left(str, 1) = "'" Then str = Right(str, Len(str) - 1)
    If Left(str, 1) <> "=" Then str = "=" & str
    If UCase(Trim(str)) <> UCase(Trim(mRng.Cells(Row, col))) Then
        mRng.Cells(Row, col).Formula = str
    End If
    mRng.Cells(Row, col).Locked = True
End Function
Public Sub CheckRowFormulas(Row As Long)
    Dim i As Long
    Dim keys As Collection
    Dim formulas As Collection
    Dim sheetColIndexes As Collection
    Dim cell As Range
    Dim str As String
    

    If formulas Is Nothing Or keys Is Nothing Then Exit Sub
    
    On Error Resume Next
    For i = 1 To mKeys.Count
        If mFormulas(i) <> "" Then
            str = ReplaceColumnKeysInFormula(mFormulas(i), Row)
            If Left(str, 1) <> "=" Then str = "=" & str
            Set cell = mRng.Cells(Row, i)
            If cell.Formula <> str Then cell.Formula = str
        End If
    Next
End Sub
Public Sub HideAllColumns(Optional onlyHideColumnsWithKey As Boolean = True, Optional unprotectSheet As Boolean = True)
    Dim i As Long
    
    If unprotectSheet = True Then Me.PrepareSheet True
    
    If onlyHideColumnsWithKey = False Then
        mRng.EntireColumn.Hidden = True
    Else
        Application.ScreenUpdating = False
        For i = 1 To mKeys.Count
            If mKeys(i) <> "" Then mRng.Columns(i).EntireColumn.Hidden = True
        Next
        Application.ScreenUpdating = True
    End If
    If unprotectSheet = True Then Me.RestoreSheet
End Sub

Public Sub ShowAllColumns(Optional unprotectSheet As Boolean = True)
    On Error Resume Next
    If unprotectSheet = True Then Me.PrepareSheet True
    mRng.EntireColumn.Hidden = False
    If unprotectSheet = True Then Me.RestoreSheet
End Sub
Public Sub ShowColumns(columnKeys As Collection, Optional unprotectSheet As Boolean = True)
    Dim i As Long
    For i = 1 To columnKeys.Count
        If unprotectSheet = True Then Me.PrepareSheet True
        ShowColumn columnKeys(i), False
        If unprotectSheet = True Then Me.RestoreSheet
    Next
End Sub
Public Function ShowColumn(columnKey As String, Optional unprotectSheet As Boolean = True)
    Dim col As Long
    On Error Resume Next
    col = Me.GetColumnIndex(columnKey)
    If col > 0 Then
        If mRng.Columns(col).EntireColumn.Hidden = True Then
            If unprotectSheet = True Then Me.PrepareSheet True
            mRng.Columns(col).EntireColumn.Hidden = False
            If unprotectSheet = True Then Me.RestoreSheet
        End If
    End If
    
End Function
Public Sub ClearFilter(Optional unprotectSheet As Boolean = True)
   On Error Resume Next
    Dim sht As Object
    Set sht = mRng.Worksheet
    
    If unprotectSheet = True Then Me.PrepareSheet True
    If Application.version >= 12 Then
        sht.AutoFilter.ShowAllData
    Else
        sht.ShowAllData
    End If
    If unprotectSheet = True Then Me.RestoreSheet
End Sub

Public Sub ApplyFilter(FilterName As String, Optional unprotectSheet As Boolean = True)
    Dim filters As Collection
    Dim filterKeys As Collection
    
    Dim cell As Range
    Dim colIndex As Long
    Dim f() As String
    
    If unprotectSheet = True Then Me.PrepareSheet True
    
    Set filters = Me.Layouts.GetLayoutFilters(FilterName)
    Set filterKeys = Me.Layouts.GetLayoutFiltersColumnKeys(FilterName)
    If filters.Count > 0 Then
        Me.ClearFilter False
        For i = 1 To filters.Count
            
            Set cell = Nothing
            Set cell = Me.cell(Me.GetColumnIndex(filterKeys(i)), 1)
            If Not cell Is Nothing Then
                colIndex = cell.Column - mRng.Worksheet.AutoFilter.Range.Column + 1
                If InStr(1, filters(i), " OR ", vbTextCompare) > 0 Then
                    f = Split(filters(i), " OR ", , vbTextCompare)
                    cell.AutoFilter colIndex, f(0), xlOr, f(1)
                ElseIf InStr(1, filters(i), " AND ", vbTextCompare) > 0 Then
                    f = Split(filters(i), " AND ", , vbTextCompare)
                    cell.AutoFilter colIndex, f(0), xlAnd, f(1)
                Else
                    cell.AutoFilter colIndex, filters(i)
                End If
            End If
        Next
    End If
    If unprotectSheet = True Then Me.RestoreSheet
End Sub
Public Sub ApplyLayout(strLayoutTitle As String, Optional unprotectSheet As Boolean = True)
    Application.ScreenUpdating = False
    If unprotectSheet = True Then Me.PrepareSheet True
    
    Me.HideAllColumns False
    Me.ShowColumns Me.Layouts.GetLayoutColumns(strLayoutTitle), False
    
    'Clear filters?
    If Me.Layouts.ClearFilterWhenApplying = True Then Me.ClearFilter
    
    'Sort Column
    Dim strSortColumnKey As String
    strSortColumnKey = Me.Layouts.GetLayoutSortColumnKey(strLayoutTitle)
    If strSortColumnKey <> "" Then
        If InStr(1, strSortColumnKey, "<|>") > 0 Then
            Me.SortTwoColumns Me.GetColumnIndex(Left(strSortColumnKey, _
            InStr(1, strSortColumnKey, "<|>", vbTextCompare) - 1)), _
            Me.GetColumnIndex(Right(strSortColumnKey, Len(strSortColumnKey) - _
            InStr(1, strSortColumnKey, "<|>", vbTextCompare) - 2))
        Else
            Me.Sort Me.GetColumnIndex(strSortColumnKey), True
        End If
    End If
    
    'apply the filters
    If strLayoutTitle <> "" Then Me.ApplyFilter strLayoutTitle, False
    

    If unprotectSheet = True Then Me.RestoreSheet
    Application.ScreenUpdating = True
End Sub
Public Sub ShowLayoutMenu(ProcedureToRun As String, EditLayoutsProcedureToRun As String)

    On Error Resume Next
    'create shortcut menu
    CommandBars("ColumnLayout").Delete
    
    Dim cb As CommandBar
    Set cb = CommandBars.Add("ColumnLayout", msoBarPopup, , True)
    
    Dim i As Long
    Dim col As Collection
    Set col = Me.Layouts.LayoutNames
    
    For i = 1 To col.Count
        With cb.Controls.Add(msoControlButton, , , , True)
            .Caption = col(i)
            .OnAction = ProcedureToRun
        End With
    Next
    
    With cb.Controls.Add(msoControlButton, , , , True)
        .Caption = "Edit Column Layouts..."
        .BeginGroup = True
        .OnAction = EditLayoutsProcedureToRun
    End With
    
    cb.ShowPopup
    
    CommandBars("ColumnLayout").Delete
End Sub

Public Sub ShowColumnVisibleMenu(ProcedureToRun As String)
    On Error Resume Next
    'create shortcut menu
    CommandBars("ColumnVisibleMenu").Delete
    
    Dim cb As CommandBar
    Set cb = CommandBars.Add("ColumnVisibleMenu", msoBarPopup, , True)
    
    Dim i As Long
    Dim b As CommandBarButton
    Dim col As Collection
    Set col = Me.ColumnHeaders
    
    For i = 1 To col.Count
        Set b = cb.Controls.Add(msoControlButton, , , , True)
        With b
            .Caption = col(i)
            .OnAction = ProcedureToRun
            If mRng.Columns(i).EntireColumn.Hidden = False Then
                .FaceId = 1664
            End If
        End With
    Next
    
    
    cb.ShowPopup
    
    CommandBars("ColumnVisibleMenu").Delete
End Sub

Public Function ColumnHasFormula(columnIndex As Long) As Boolean
    Dim cell As Range
    Set cell = GetTemplateRowCell(columnIndex) 'TemplateRow.Cells(1, columnIndex)
    If Not cell Is Nothing Then
        If cell.HasFormula = True Then
            ColumnHasFormula = True
        End If
    End If
End Function
Public Sub ApplyColumnFormula(columnIndex As Long)
    Dim cell As Range
    On Error Resume Next
    Set cell = Me.GetTemplateRowCell(columnIndex)
    If Not cell Is Nothing Then
        If cell.HasFormula = True Then
            cell.Copy
            Me.ItemRange.Columns(columnIndex).PasteSpecial xlPasteFormulas
            Application.CutCopyMode = xlNone
        End If
    End If
End Sub
Public Sub CheckAllColumnFormulas()
    Dim i As Long
    For i = 1 To mKeys.Count
        If ColumnHasFormula(i) = True Then
            ApplyColumnFormula i
        End If
    Next
End Sub




Attribute VB_Name = "ItemSectionCategory"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mHeaderRows As Collection
Public SheetName As String
Public Caption As String
Public MainSectionHeaderRow As ItemSectionHeaderRow
Public Property Get ItemSectionHeaderRows() As Collection
    If mHeaderRows Is Nothing Then Set mHeaderRows = New Collection
    Set ItemSectionHeaderRows = mHeaderRows
End Property



Attribute VB_Name = "ItemSectionHeaderRow"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Private mSectionRows As Collection
Private mSpecRows As Collection
Private mAllowanceRows As Collection
Private mSpecAndAllowanceRows As Collection
Public Section As ItemSection
Public Row As Long

Public Description As String

Public Property Get SectionRows() As Collection
    If mSectionRows Is Nothing Then Set mSectionRows = New Collection
    Set SectionRows = mSectionRows
End Property
Public Property Get SpecRows() As Collection
    If mSpecRows Is Nothing Then Set mSpecRows = New Collection
    Set SpecRows = mSpecRows
End Property

Public Property Get AllowanceRows() As Collection
    If mAllowanceRows Is Nothing Then Set mAllowanceRows = New Collection
    Set AllowanceRows = mAllowanceRows
End Property
Public Property Get SpecAndAllowanceRows() As Collection
    If mSpecAndAllowanceRows Is Nothing Then Set mSpecAndAllowanceRows = New Collection
    Set SpecAndAllowanceRows = mSpecAndAllowanceRows
End Property

Public Function GetTotal(strColumnKey As String) As Double
    Dim i As Long
    Dim d As Double
    Dim secRow As ItemSectionRow
    For i = 1 To mSectionRows.Count
        Set secRow = mSectionRows(i)
        d = d + secRow.Total
    Next
    If d < 0.0001 Then d = 0
    GetTotal = d
End Function

Attribute VB_Name = "ItemSectionLayouts"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
' (c) 2008 - Lorin Boyer  Email:lorin@maderasoft.com  Phone:210-568-8151
'  All rights to use, reproduce or publish this code reserved.
' -------------------------------------------------------------
Private mRng As Range

Private mNames As Collection
Private mColumns As Collection

Private mFiltersColumnKeys As Collection
Private mFilters As Collection

Private mSortColumnKeys As Collection


Public Sub SetLayoutSaveRange(layoutSaveRange As Range)
    Set mRng = layoutSaveRange
    ParseLayouts
End Sub
Public Sub Init(layoutSaveRange As Range)
    SetLayoutSaveRange layoutSaveRange
End Sub

Public Sub SaveLayouts()
    Dim i As Long, y As Long
    Dim str As String
    Dim col As Collection
    Dim colFilters As Collection
    Dim colFilterKeys As Collection
    
    str = ""
    For i = 1 To mNames.Count
        If i > 1 Then str = str & "||"
        str = str & mNames(i) & "::"
        Set col = mColumns(i)
        For y = 1 To col.Count
            str = str & col(y) & IIf(y < col.Count, ",", "")
        Next
            
        Set colFilters = mFilters(i)
        Set colFilterKeys = mFiltersColumnKeys(i)
        str = str & "::"
        If colFilters.Count > 0 Then
            
            For y = 1 To colFilters.Count
                str = str & colFilterKeys(y) & "<|>" & colFilters(y) & IIf(y < colFilters.Count, "<|>", "")
            Next
        End If
        
        If mSortColumnKeys(i) <> "" Then
            str = str & "::" & mSortColumnKeys(i)
        End If
    Next
    If Not mRng Is Nothing Then
        mRng.value = str
    End If
End Sub

Public Function GetLayoutIndex(layoutName As String) As Long
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            GetLayoutIndex = i
            Exit For
        End If
    Next
End Function
Public Sub ChangeLayoutIndex(layoutName As String, newIndex As Long)
    Dim i As Long
    Dim str As String
    Dim col As Collection
    Dim colFilter As Collection
    Dim colFilterKeys As Collection
    Dim strSort As String
    
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            str = mNames(i)
            Set col = mColumns(i)
            Set colFilter = mFilters(i)
            Set colFilterKeys = mFiltersColumnKeys(i)
            strSort = mSortColumnKeys(i)
            
            mNames.Remove i
            mColumns.Remove i
            mFilters.Remove i
            mFiltersColumnKeys.Remove i
            mSortColumnKeys.Remove i
            
            If newIndex > mNames.Count Then
                mNames.Add str
                mColumns.Add col
                mFilters.Add colFilter
                mFiltersColumnKeys.Add colFilterKeys
                mSortColumnKeys.Add strSort
            ElseIf newIndex < i Then
                mNames.Add str, , newIndex
                mColumns.Add col, , newIndex
                mFilters.Add colFilter, , newIndex
                mFiltersColumnKeys.Add colFilterKeys, , newIndex
                mSortColumnKeys.Add strSort, , newIndex
            Else
                mNames.Add str, , newIndex
                mColumns.Add col, , newIndex
                mFilters.Add colFilter, , newIndex
                mFiltersColumnKeys.Add colFilterKeys, , newIndex
                mSortColumnKeys.Add strSort, , newIndex
            End If
            Exit For
        End If
    Next
End Sub
Public Sub CreateLayout(layoutName As String, visibleColumns As Collection, Optional Index As Long, Optional FiltersColumnKeys As Collection, Optional filters As Collection, Optional strSortColumnKeys As String)
    If FiltersColumnKeys Is Nothing Then Set FiltersColumnKeys = New Collection
    If filters Is Nothing Then Set filters = New Collection
    
    If Index > 0 And Index < mNames.Count Then
        mNames.Add layoutName, , Index
        mColumns.Add visibleColumns, , Index
        mFilters.Add filters, , Index
        mFiltersColumnKeys.Add FiltersColumnKeys, , Index
        mSortColumnKeys.Add strSortColumnKeys, , Index
    Else
        mNames.Add layoutName
        mColumns.Add visibleColumns
        mFilters.Add filters
        mFiltersColumnKeys.Add FiltersColumnKeys
        mSortColumnKeys.Add strSortColumnKeys
    End If
End Sub
Public Sub DeleteLayout(layoutName As String)
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            mNames.Remove i
            mColumns.Remove i
            mFilters.Remove i
            mFiltersColumnKeys.Remove i
            mSortColumnKeys.Remove i
            Exit For
        End If
    Next
End Sub
Public Property Get Count() As Long
    Count = mNames.Count
End Property
Public Property Get Name(Index As Long) As String
    Name = mNames(Index)
End Property
Public Property Get LayoutNames() As Collection
    Set LayoutNames = mNames
End Property
Public Sub ChangeLayoutName(layoutName As String, newName As String)
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            mNames.Add newName, , i
            mNames.Remove i + 1
            Exit For
        End If
    Next
End Sub
Public Function GetLayoutSortColumnKey(layoutName As String) As String
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            GetLayoutSortColumnKey = mSortColumnKeys(i)
            Exit For
        End If
    Next
End Function
Public Function GetLayoutColumns(layoutName As String) As Collection
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            Set GetLayoutColumns = mColumns(i)
            Exit For
        End If
    Next
End Function
Public Function GetLayoutFiltersColumnKeys(layoutName As String) As Collection
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            Set GetLayoutFiltersColumnKeys = mFiltersColumnKeys(i)
            Exit For
        End If
    Next
End Function
Public Function GetLayoutFilters(layoutName As String) As Collection
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            Set GetLayoutFilters = mFilters(i)
            Exit For
        End If
    Next
End Function
Public Sub SetLayoutColumns(layoutName As String, columnKeys As Collection, Optional FiltersColumnKeys As Collection, Optional filters As Collection, Optional strSortColumnKeys As String)
    Dim i As Long
    For i = 1 To mNames.Count
        If UCase(Trim(mNames(i))) = UCase(Trim(layoutName)) Then
            mColumns.Add columnKeys, , i
            mColumns.Remove i + 1
            
            If FiltersColumnKeys Is Nothing Then Set FiltersColumnKeys = New Collection
            If filters Is Nothing Then Set filters = New Collection
            
            mFiltersColumnKeys.Add FiltersColumnKeys, , i
            mFiltersColumnKeys.Remove i + 1
            
            mFilters.Add filters, , i
            mFilters.Remove i + 1
            
            mSortColumnKeys.Add strSortColumnKeys, , i
            mSortColumnKeys.Remove i + 1
        End If
    Next
End Sub
Private Sub ParseLayouts()
    'layout format:    name::visible columns::Filters::SortColumnKey||name::visible columns::Filters::SortColumnKey||name::visible columns::Filters::SortColumnKey
    'the visible columns contains the keys to the columns separated by a comma
    'Example:  January::JanActual,JanBudget,JanVariance:://=68000||February::FebActual,FebBudget,FebVariance
    Dim str As String
    Dim i As Long, y As Long, z As Long
    Dim strName As String
    Dim Columns() As String
    Dim allLayouts() As String
    Dim colLayoutValues() As String
    Dim filterValues() As String
    
    Dim colFilterColumns As Collection
    Dim colFilters As Collection
    
    Dim col As Collection
    
    Dim colKeyInfo() As String
    
    If mRng Is Nothing Then Exit Sub
    str = mRng.value
    'str = " January::JanActual,JanBudget,JanVariance::JanActual,>89000,JanBudget,<90000||February::FebActual,FebBudget,FebVariance"
    
    allLayouts = Split(str, "||")
    
    Set mNames = New Collection
    Set mColumns = New Collection
    Set mFilters = New Collection
    Set mFiltersColumnKeys = New Collection
    Set mSortColumnKeys = New Collection
    
    For i = LBound(allLayouts) To UBound(allLayouts)
        
        colLayoutValues = Split(allLayouts(i), "::")
        strName = Trim(colLayoutValues(0))
        mNames.Add strName
        
        If UBound(colLayoutValues) > 2 Then
            mSortColumnKeys.Add colLayoutValues(3)
        Else
            mSortColumnKeys.Add ""
        End If
        
        Columns = Split(colLayoutValues(1), ",")
        If UBound(colLayoutValues) >= 2 Then
            filterValues = Split(colLayoutValues(2), "<|>")
        Else
            ReDim filterValues(0 To 0)
        End If
        
        Set col = New Collection
        Set colFilters = New Collection
        Set colFilterColumns = New Collection
        
        For y = LBound(Columns) To UBound(Columns)
            col.Add Trim(Columns(y))
        Next
        
        If UBound(filterValues) > 0 Then
            For y = 0 To UBound(filterValues) - 1 Step 2
                colFilterColumns.Add filterValues(y)
                colFilters.Add filterValues(y + 1)
            Next
        End If
        
        mFilters.Add colFilters
        mFiltersColumnKeys.Add colFilterColumns
        mColumns.Add col
    Next
End Sub

Public Property Get ClearFilterWhenApplying() As Boolean
    Dim nm As Name
    Dim str As String
    
    On Error Resume Next
    str = "=True"
    Set nm = mRng.Worksheet.Parent.names("ClearFiltersOnShowColumns")
    If nm Is Nothing Then
        Set nm = mRng.Worksheet.Parent.names.Add("ClearFiltersOnShowColumns", "=True", False)
    End If
    
    If StrComp(nm.RefersTo, "=True", vbTextCompare) = 0 Then
        ClearFilterWhenApplying = True
    Else
        ClearFilterWhenApplying = False
    End If
End Property
Public Property Let ClearFilterWhenApplying(bValue As Boolean)
    Dim nm As Name
    Dim str As String
    
    On Error Resume Next
    str = "=" & CStr(bValue)
    Set nm = mRng.Worksheet.Parent.names("ClearFiltersOnShowColumns")
    If nm Is Nothing Then
        Set nm = mRng.Worksheet.Parent.names.Add("ClearFiltersOnShowColumns", str, False)
    Else
        nm.RefersTo = str
    End If
End Property

Attribute VB_Name = "ItemSectionRow"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public IsSpec As Boolean
Public IsAllowance As Boolean
Public IsOption As Boolean
Public IsQuote As Boolean

Public SpecSection As String

Public Row As Long

Public Description As String
Public Note As String
Public Total As Double
Public BaseCostTotal As Double
Public OptionCostTotal As Double

Public SheetName As String
Private mSection As ItemSection

Private mRow As Long

Public Property Get Section() As ItemSection
    Set Section = mSection
End Property
Public Property Set Section(value As ItemSection)
    Set mSection = value
    If Not value Is Nothing Then
        SheetName = value.Range.Worksheet.Name
    End If
End Property

Public Property Get IsValidRow() As Boolean
    If IsSpec Or IsAllowance Or IsOption Then
        If IsSpec Then
            IsValidRow = True
        Else
            IsValidRow = (Description <> "")
        End If
    Else
        IsValidRow = (Total <> 0)
    End If

End Property
Attribute VB_Name = "Module1"
Public Sub UpdateWordDocument(wbName As String, strFileName As String)
    Dim c As UpdateWordDocuments
    Set c = New UpdateWordDocuments
    
    Dim wb As Workbook
    Set wb = Workbooks(wbName)
    c.SendProjectVariablesToWordDocument wb, strFileName
End Sub
Sub asdfsadffsd()
    Dim s As String
    
    Dim cell As Range
    Dim pos As Integer
    
    Dim rng As Range
    Set rng = Selection.Cells
    
    Dim values() As Variant
    values = rng.value
    
    For i = 1 To UBound(values)
    
        s = values(i, 1)
        
        If InStr(1, s, "::") Then
            If Left(s, 3) = "Hea" Then
                 pos = InStr(8, s, "::")
                If pos > 0 Then
                    s = Left(s, pos + 1)
                End If
            
            ElseIf Left(s, 3) = "ID:" Then
                'remove everything after the second ::
                
                pos = InStr(4, s, "::")
                If pos > 0 Then
                    s = Left(s, pos + 1)
                End If
            Else
                Debug.Print cell.Address
            End If
        Else
            If s = "Header" Then
                s = "Header::true::"
            ElseIf Left(s, 3) = "Hea" Then
                'leave it
            Else
                s = "ID::" & s & "::"
            End If
        End If
        
        If s <> values(i, 1) Then
            values(i, 1) = s
        End If
    Next
    rng.value = values
End Sub

Sub UpdateItemIDs()
    Dim wb As Workbook
    Set wb = ActiveWorkbook
    
    Dim sec As ItemSection

    Dim colSections As Collection
    Set colSections = GetWorkbookSections(wb, "EstimateItems")
    
    Dim i As Long
    Dim y As Long
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    For y = 1 To colSections.Count
        Set sec = colSections(y)
        
        Dim headerCol As Long
        Dim idCol As Long
        idCol = sec.GetColumnIndex("Info")
        headerCol = sec.GetColumnIndex("HeaderIndicator")
        
        Dim values() As Variant
        
        values = sec.Range.Columns(idCol).value
        
        Dim p As SettingsParser
        
        
        For i = 2 To sec.rowCount - 1
            If sec.value(i, headerCol) <> "" Then
                'header row
                If sec.value(i, idCol) <> "" Then
                    values(i, 1) = ""
                End If
            ElseIf sec.value(i, idCol) <> "" Then
                Set p = New SettingsParser
                p.Delimiter = "::"
                p.SettingString = sec.value(i, idCol)
                Dim sOut As String
                sOut = ""
                If p.Setting("ID") <> "" Then
                    sOut = "ID::" & p.Setting("ID") & "::"
                End If
                If p.Setting("EstimateID") <> "" Then
                    sOut = sOut & " EstimateID::" & p.Setting("EstimateID") & "::"
                End If
                If p.Setting("DBSection") <> "" Then
                    sOut = sOut & " DBSection::" & p.Setting("DBSection") & "::"
                End If
                sOut = Trim(sOut)
                values(i, 1) = sOut
            End If
        Next
        
        sec.Range.Columns(idCol).value = values
    Next
    
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    
End Sub
Sub UpdateFile()
    Dim wb As Workbook
    Set wb = ActiveWorkbook
    
    Dim sec As ItemSection

    Dim colSections As Collection
    Set colSections = GetWorkbookSections(Workbooks("Estimate Template v4-2 (6).xlsx"), "EstimateItems")
    
    Dim colSections2 As Collection
    Set colSections2 = GetWorkbookSections(Workbooks("Estimate Template v4-2-Updated1.xlsx"), "EstimateItems")
    
    
    Dim i As Long
    Dim sLast As String
    Dim sec2 As ItemSection
    Dim tempSection As ItemSection
    
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual
    For y = 1 To colSections.Count
        Set sec = colSections(y)
        Set sec2 = Nothing
        For i = 1 To colSections2.Count
            Set tempSection = colSections2(i)
            If sec.Range.Worksheet.Name = tempSection.Range.Worksheet.Name Then
                Set sec2 = tempSection
                Exit For
            End If
        Next
        
        Dim bCheckColor As Boolean
        Dim sKey As String
        sKey = "EstQty"
        bCheckColor = True
        
        Dim col1 As Long
        Dim col2 As Long
        
        col1 = sec.GetColumnIndex(sKey)
        col2 = sec2.GetColumnIndex(sKey)
        
        Dim formulas1() As Variant
        Dim formulas2() As Variant
        Dim bChanged As Boolean
        bChanged = False
        formulas1 = sec.Range.Columns(col1).Formula
        formulas2 = sec2.Range.Columns(col2).Formula
        For i = 2 To sec2.rowCount - 1
'            If sec.Range.Worksheet.Name = "Permit Fees" Then
'                Debug.Print "Dude"
'            End If
            If bCheckColor Then
                If sec.GetCell(sKey, col1).Interior.Color <> sec2.GetCell(sKey, col2).Interior.Color Then
                   ' sec2.GetCell(sKey, col2).Interior.Color = sec.GetCell(sKey, col1).Interior.Color
                End If
            End If
            If IsError(formulas1(i, 1)) Or IsError(formulas2(i, 1)) Then
                'Debug.Print "Error:" & sec.Range.Worksheet.Name
                Dim sF As String
                formulas2(i, 1) = ""
            ElseIf formulas1(i, 1) <> formulas2(i, 1) Then
                If sec.Range.Worksheet.Name <> "Floor Cover" And sec.Range.Worksheet.Name <> "Hardware" And sec.Range.Worksheet.Name <> "Tile Shower" And sec.Range.Worksheet.Name <> "Backsplash" Then
                    Debug.Print sec.Range.Worksheet.Name & " : " & sec.Range.Row + i - 1 & " : " & formulas1(i, 1) & " : " & formulas2(i, 1)
                    
                    
                End If
                'sec2.GetCell(sKey, i).Formula = sec.GetCell(sKey, col2).Formula
                'formulas2(i, 1) = formulas1(i, 1)
                'bChanged = True
            End If
           ' If sec.Value(i, col1) <> sec2.Value(i, col2) Then
                'Debug.Print sec.Range.Worksheet.Name
                'sec2.GetCell(sKey, i).Value = sec.Value(i, col1)
           ' End If
        Next
        
        If bChanged = True Then
            sec2.Range.Columns(col2).Formula = formulas2
        End If

'        If sec2 Is Nothing Then
'            Debug.Print "Dude"
'        Else
'            If sec.rowCount = sec2.rowCount Then
'                'check the description of each row
'                Dim v As Variant
'                Dim v2 As Variant
'
'                For i = 2 To sec.rowCount - 2
'                    v = sec.Value(i, sec.GetColumnIndex("Description"))
'                    v2 = sec2.Value(i, sec2.GetColumnIndex("Description"))
'
'                    If IsError(v) And IsError(v2) Then
'                        Debug.Print "Dude"
'                    ElseIf IsError(v) Then
'                        Debug.Print "Dude"
'                    ElseIf IsError(v2) Then
'                        Debug.Print "Dude"
'
'                    ElseIf v <> v2 Then
'                        Debug.Print sec.Value(i, sec.GetColumnIndex("Description")) & " | " & sec2.Value(i, sec2.GetColumnIndex("Description"))
'                        Debug.Print sec.Range.Worksheet.Name & "  " & i
'                    End If
'                Next
'            End If
'            If sec.rowCount <> sec2.rowCount Then
'                Debug.Print sec.Range.Worksheet.Name & "  " & sec2.rowCount - sec.rowCount
'            End If
'        End If
'        sLast = ""

    Next
    Application.EnableEvents = True
    Application.Calculation = xlCalculationAutomatic
    Beep
    Beep
    Beep
    
End Sub

Public Sub SendExcelTableToWordDoc(wbName As String, SheetName As String, rangeAddress As String, strFileName As String, strTableName As String, columnKeys As String)

    Dim doc As Object
    Dim c As UpdateWordDocuments
    Set c = New UpdateWordDocuments
    Set doc = c.GetWordDoc(strFileName)
    Dim rng As Range
    Dim wb As Workbook
    Set wb = Workbooks(wbName)
    Set sht = wb.Worksheets(SheetName)

    Set rng = sht.Range(rangeAddress)
    
    Dim col As Collection
    Dim values() As String
    values = Split(columnKeys, ",")
    
    Set col = New Collection
    For i = LBound(values) To UBound(values)
        col.Add values(i)
    Next
    c.SendExcelTableToWordDoc doc, strTableName, rng, col
End Sub
Public Sub SelectActivecell()
    ActiveCell.Select
    ActiveCell.Activate
End Sub
Public Sub RunReport()
    Dim ir As ItemReports
    Set ir = New ItemReports
    ir.GenerateItemReport ActiveSheet
End Sub

Public Function AddConditionToRange(rng As Range, sFormula As String) As FormatCondition
    Dim conditions As FormatConditions
    Set conditions = rng.FormatConditions
    Dim o As Object
    Debug.Print rng.Address & "  " & sFormula
    On Error Resume Next
    Set o = conditions.Add(2, "", sFormula)
    Dim c As FormatCondition
    Set c = o
    Set AddConditionToRange = c
End Function

Public Function GetConditionalFormatPriority(condition As FormatCondition) As Long
    GetConditionalFormatPriority = condition.Priority
End Function
Public Function TestCondition() As Boolean
    TestCondition = True
End Function
Public Function SetConditionStopIfTrue(condition As FormatCondition, value As Boolean) As Boolean
    condition.StopIfTrue = value
    SetConditionStopIfTrue = True
End Function
Public Function SetConditionFontBold(condition As FormatCondition, value As Boolean) As Boolean
    condition.Font.Bold = value
    SetConditionFontBold = True
End Function
Public Function SetConditionFontColorIndex(condition As FormatCondition, value As Long) As Boolean
    condition.Font.ColorIndex = value
    SetConditionFontColorIndex = True
End Function
Public Function SetConditionFontColor(condition As FormatCondition, value As Long) As Boolean
    condition.Font.Color = value
    SetConditionFontColor = True
End Function
Public Function SetConditionFontUnderline(condition As FormatCondition, value As Long) As Boolean
    condition.Font.Underline = value
    SetConditionFontUnderline = True
End Function

Public Function SetConditionInteriorThemeColor(condition As FormatCondition, value As Long) As Boolean
    condition.Interior.ThemeColor = value
    SetConditionInteriorThemeColor = True
End Function
Public Function SetConditionInteriorTintAndShade(condition As FormatCondition, value As Long) As Boolean
    condition.Interior.TintAndShade = value
    SetConditionInteriorTintAndShade = True
End Function
Public Function SetConditionInteriorColorIndex(condition As FormatCondition, value As Long) As Boolean
    condition.Interior.ColorIndex = value
    SetConditionInteriorColorIndex = True
End Function
Public Function SetConditionInteriorColor(condition As FormatCondition, value As Long) As Boolean
    condition.Interior.Color = value
    SetConditionInteriorColor = True
End Function

Public Function AddConditionMadera(conditions As FormatConditions, conditionType As Integer, sFormula As String) As FormatCondition
    
End Function

Public Function OpenWorkbook(wkbkFullName As String, Optional AskToOpen As Boolean = True, _
    Optional ActivateWkbk As Boolean = False, _
    Optional ByRef OutWorkbookAlreadyOpen As Boolean = False, _
    Optional HideWkBk As Boolean = False) As Workbook

    'AskToOpen - if the workbook isn't already open then the user will be asked if they
    'want to open the workbook, otherwise the workbook will automatically be opened
    
    Dim msg As String
    Dim wkbkName As String
    Dim wkbk As Workbook
    Dim origWkbk As Workbook
    Dim enableUpdating As Boolean
    

    wkbkName = FileNameOnly(wkbkFullName)
    Set origWkbk = Application.ActiveWorkbook

    If InternalIsWorkBookOpen(wkbkName) Then
        Set wkbk = Application.Workbooks(wkbkName)
        OutWorkbookAlreadyOpen = True
    Else
        If FileExists(wkbkFullName) And wkbkFullName <> "" Then
            Dim openWorkbook2 As Boolean
            openWorkbook2 = True
            
            If AskToOpen Then
                msg = wkbkName & " must be open to run this." & vbCrLf & _
                "Would you like to open " & wkbkName & "?"
                If MsgBox(msg, vbYesNo) <> vbYes Then OpenWorkbook = False
            End If
            
            If openWorkbook2 Then
                On Error GoTo Exit_Here
                
                Dim enableUpdating2 As Boolean
                

                On Error Resume Next
                Set wkbk = Application.Workbooks.Open(wkbkFullName)

                If Not ActivateWkbk Then
                    
                    origWkbk.Activate
                End If

            End If
        End If
        


    End If

    Dim w As Window
    If Not wkbk Is Nothing And HideWkBk Then
        For Each w In wkbk.Windows
            w.Visible = False
        Next
    End If

    If Not wkbk Is Nothing Then
        If ActivateWkbk And Not HideWkBk Then
            wkbk.Activate
        Else
            If Not origWkbk Is Nothing Then origWkbk.Activate
        End If
        Set OpenWorkbook = wkbk
    End If


    Exit Function
Exit_Here:
    Debug.Print Err.Description
End Function
Private Function FileExists(FileName As String) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim vFlag As Variant
    
    On Error Resume Next
    vFlag = Dir(FileName)
    
    If Err <> 0 Then Exit Function
    
    If Not IsNull(vFlag) Then
        If Len(vFlag) > 0 Then
            FileExists = True
        End If
    End If
End Function
Private Function InternalIsWorkBookOpen(wkbkName As String) As Boolean
    Dim wkbk As Workbook
    On Error Resume Next
   
    Set wkbk = Application.Workbooks(wkbkName)
    If Not wkbk Is Nothing Then InternalIsWorkBookOpen = True
End Function
Private Function FileNameOnly(strPath As String) As String
    If InStr(1, strPath, "\") > 0 Then
        FileNameOnly = Trim(Right(strPath, Len(strPath) - InStrRev(strPath, "\")))
    Else
        FileNameOnly = strPath
    End If
End Function


Public Sub CenterFormInExcel(frm As Object)
    frm.Left = Application.Left + (Application.Width - frm.Width) / 2
    frm.Top = Application.Top + (Application.Height - frm.Height) / 2
    
End Sub


Attribute VB_Name = "PSItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public IsLine As Boolean
Public IsArea As Boolean
Public IsSegment As Boolean
Public IsCount As Boolean
Public IsItem As Boolean
Public IsPart As Boolean

Public Name As String
Public ItemPath As String

Public ItemProperties As Collection
Public MainProperties As Collection
Public EstimatingProperties As Collection
Public TakeoffDataProperties As Collection

Public Function GetProperty(sPropertyName As String) As PSItemProperty
    Dim i As Long
    Dim prop As PSItemProperty
    For i = 1 To ItemProperties.Count
        Set prop = ItemProperties(i)
        If UCase(Trim(prop.Name)) = UCase(Trim(sPropertyName)) Then
            Set GetProperty = prop
            Exit For
        End If
    Next
End Function

Private Sub Class_Initialize()
    Set ItemProperties = New Collection
    Set MainProperties = New Collection
    Set EstimatingProperties = New Collection
    Set TakeoffDataProperties = New Collection
End Sub

Public Sub Init(jobItem As Object) 'PlanSwift9.Item
    Dim prop As Object 'PlanSwift9.PropertyObject
    Dim pItemProperty As PSItemProperty
    
    Me.Name = jobItem.Name
    Me.ItemPath = jobItem.fullpath
    Dim i As Long
    Dim qtyPropertyFound As Boolean
    
    
    If jobItem.GetPropertyResultAsBoolean("isPart", False) = True Then
        IsPart = True
    End If
    
    For i = 1 To jobItem.PropertyCount
        Set prop = jobItem.PropertyItem(i)
        Set pItemProperty = New PSItemProperty
        pItemProperty.Init prop, Me.Name
        ItemProperties.Add pItemProperty
        
        If pItemProperty.IsLine Then IsLine = pItemProperty.IsLine
        If pItemProperty.IsArea Then IsArea = pItemProperty.IsArea
        If pItemProperty.IsSegment Then IsSegment = pItemProperty.IsSegment
        If pItemProperty.IsCount Then IsCount = pItemProperty.IsCount
        If pItemProperty.IsItem Then IsItem = pItemProperty.IsItem
        If pItemProperty.IsPart Then IsPart = pItemProperty.IsPart
    
        
        If pItemProperty.Name = "Qty" Then
            MainProperties.Add pItemProperty
            qtyPropertyFound = True
        End If
        If pItemProperty.Group = "Takeoff Data" Then
            TakeoffDataProperties.Add pItemProperty
        End If
        If pItemProperty.Group = "Estimating" Then
            EstimatingProperties.Add pItemProperty
        End If

    Next
    'get main properties
    For i = 1 To ItemProperties.Count
        Set pItemProperty = ItemProperties(i)
        If IsLine And pItemProperty.Name = "Linear Total" Then
            MainProperties.Add pItemProperty
        End If
        If IsArea And pItemProperty.Name = "Area" Then
            MainProperties.Add pItemProperty
        End If
        If IsCount And pItemProperty.Name = "Point Count" Then
            MainProperties.Add pItemProperty
        End If
        If qtyPropertyFound = False And pItemProperty.Name = "Takeoff" Then
            MainProperties.Add pItemProperty
        End If
    Next
End Sub
Attribute VB_Name = "PSItemProperty"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public IsLine As Boolean
Public IsArea As Boolean
Public IsSegment As Boolean
Public IsCount As Boolean
Public IsItem As Boolean
Public IsPart As Boolean

Public Formula As String
Public Group As String
Public Guid As String
Public Name As String
Public value As String
Public ItemName As String

Public PropertyType As String  'Text,Number,Image,CheckBox,Memo,Color,Slider,
Public Units As String


Public Sub Init(prop As Object, sItemName As String)
    PropertyType = prop.PropertyType
    Me.Units = prop.Units
    Me.Group = prop.Group
    Me.Guid = prop.Guid
    Me.Name = prop.Name
    Me.value = prop.ResultAsString
    Me.ItemName = sItemName
    Me.Formula = prop.Formula
    If prop.Name = "IsLine" Then
        If prop.ResultAsString = "-1" Then 'true
            IsLine = True
        End If
    ElseIf prop.Name = "IsArea" Then
        If prop.ResultAsString = "-1" Then 'true
            IsArea = True
        End If
    ElseIf prop.Name = "IsSegment" Then
        If prop.ResultAsString = "-1" Then 'true
            IsSegment = True
        End If
    ElseIf prop.Name = "IsCount" Then
        If prop.ResultAsString = "-1" Then 'true
            IsCount = True
        End If
    ElseIf prop.Name = "IsItem" Then
        If prop.ResultAsString = "-1" Then 'true
            IsItem = True
        End If
    ElseIf prop.Name = "IsPart" Then
        If prop.ResultAsString = "-1" Then 'true
            IsPart = True
        End If
    End If

End Sub
Attribute VB_Name = "PSJob"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Public JobDescription As String
Public JobName As String
Public Items As Collection


Public Function GetItem(sItemName As String) As Collection
    Dim i As Long
    Dim pItem As PSItem
    Dim col As Collection
    Set col = New Collection
    
    If Not Items Is Nothing Then
        For i = 1 To Items.Count
            Set pItem = Items(i)
            If UCase(Trim(pItem.Name)) = UCase(Trim(sItemName)) Then
                col.Add pItem
            End If
        Next
    End If
    Set GetItem = col
End Function

Attribute VB_Name = "ParseFormula"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Public Function ReplaceNamesInFormula(strFormula As String, _
            NamesToFind As Collection, _
            NamesToReplaceWith As Collection, _
            Optional outNamesNotFound As Collection)
    
    If NamesToFind Is Nothing Or NamesToReplaceWith Is Nothing Then Exit Function
    'If NamesToFind.Count <> NamesToReplaceWith.Count Then Exit Function
    ReplaceNamesInFormula = InternalReplaceNamesAndCellAddresses(strFormula, NamesToFind, NamesToReplaceWith, outNamesNotFound)
End Function
Private Function InternalReplaceNamesAndCellAddresses(Formula As String, NamesToFind As Collection, _
        NamesToReplaceWith As Collection, _
        Optional outNamesNotFound As Collection) As String
    Dim position As Long, nextDividerIndex As Long
    Dim endLoop As Boolean
    Dim divider As String
    Dim Text As String
    Dim isGoodCellReference As Boolean
    Dim cnt As Long
    Dim newFormula As String
    
    position = 1
    newFormula = ""
    nextDividerIndex = 0
    endLoop = False
    Do Until endLoop
        If Not FindNextDivider(Formula, position, nextDividerIndex) Then
            endLoop = True
        End If
        
        divider = Mid(Formula, nextDividerIndex, 1)
        Text = Trim(Mid(Formula, position, nextDividerIndex - position))
        isGoodCellReference = True
        If Text = "" Then
            isGoodCellReference = False
        ElseIf UCase(Text) = "INDIRECT" Then
            'TODO-In the future I would like to add support the the indirect function, it would
            'resolve everything in the parenthesis into a valid address
            isGoodCellReference = False
        ElseIf divider = "(" Then
            'if divider is "(" then that means the text is a Function
            isGoodCellReference = False
        ElseIf InStr(1, Text, """") > 0 And Left(Text, 1) <> "[" Then
            'if there is a " in the text, then it is a string
            'if it is inside brackets, then we will accept the parenthesis
            If InStr(1, Text, "[") = 0 And InStr(1, Text, "]") = 0 Then
                isGoodCellReference = False
            End If
         
            'NOTE - when replacing values this doesn't matter
            'ElseIf IsNumeric(Left(Text, 1)) Then
                
            'names for cell address cannot start with a number
            isGoodCellReference = False
             
        ElseIf IsNumeric(Text) Then
            'ignore if it only contains numbers
            isGoodCellReference = False
        ElseIf UCase(Text) = "TRUE" Or UCase(Text) = "FALSE" Then
             'ignore boolean values
            isGoodCellReference = False
        End If
        
         'if we got here then it is a good cell reference
        Dim addFormula As Boolean
        Dim strTemp As String
        Dim bracketsFound As Boolean
        If isGoodCellReference Then
            addFormula = True
            strTemp = ""
            bracketsFound = False
            'ignore brackets that surround a name
            If Left(Text, 1) = "[" And Right(Text, 1) = "]" Then
                strTemp = Right(Text, Len(Text) - 1)
                strTemp = Left(strTemp, Len(strTemp) - 1)
                bracketsFound = True
            End If
            For i = 1 To NamesToFind.Count
                If NamesToReplaceWith.Count >= i Then
                    If UCase(Trim(Text)) = UCase(Trim(NamesToFind(i))) Then
                        If Left(NamesToReplaceWith(i), 1) = "=" Then
                            newFormula = newFormula & Right(NamesToReplaceWith(i), Len(NamesToReplaceWith(i)) - 1) & divider
                        Else
                            newFormula = newFormula & NamesToReplaceWith(i) & divider
                        End If
                        addFormula = False
                        Exit For
                    ElseIf strTemp <> "" Then
                        If UCase(Trim(strTemp)) = UCase(Trim(NamesToFind(i))) Then
                            If Left(NamesToReplaceWith(i), 1) = "=" Then
                                newFormula = newFormula & Right(NamesToReplaceWith(i), Len(NamesToReplaceWith(i)) - 1) & divider
                            Else
                                newFormula = newFormula & NamesToReplaceWith(i) & divider
                            End If
                            addFormula = False
                            Exit For
                        End If
                    End If
                End If
            Next
            If addFormula Then
                newFormula = newFormula & Text & divider
                If Not outNamesNotFound Is Nothing Then
                    outNamesNotFound.Add Text
                End If
            End If
        Else
            newFormula = newFormula & Text & divider
        End If
        position = nextDividerIndex + 1
    Loop

    InternalReplaceNamesAndCellAddresses = newFormula
End Function
Public Function GetFormulaReferencesFromText(Formula As String, _
            Optional ReturnDuplicateReferences As Boolean = True) As FormulaReferences
    Dim tempReferences As FormulaReferences


'    If cell.HasFormula Then
        Set tempReferences = InternalGetNamesAndCellAddresses(Formula, , , ReturnDuplicateReferences)
'    Else
'        Set tempReferences = New FormulaReferences
'    End If
    Set GetFormulaReferencesFromText = tempReferences
End Function

'The sheet the cell is on must be activated for this code to work
Public Function GetFormulaReferences(cell As Range, _
            Optional ReturnDuplicateReferences As Boolean = True, _
            Optional newFormula As String) As FormulaReferences
    On Error Resume Next
    Dim strFormula As String
    Dim tempReferences As FormulaReferences
    
    If newFormula <> "" Then
        strFormula = newFormula
    Else
        
        If cell.Application.ReferenceStyle <> xlA1 Then
            Err.Clear
            strFormula = cell.Application.ConvertFormula(cell.Formula, cell.Application.ReferenceStyle, Excel.xlA1)
            'if the formula contain only variable then excel can't convertformula and will throw an error
            If Err <> 0 Then strFormula = cell.Formula
        Else
            strFormula = cell.Formula
        End If
        
    End If
    
    
    If newFormula <> "" Then
        Set tempReferences = InternalGetNamesAndCellAddresses(strFormula, cell, , ReturnDuplicateReferences)
    ElseIf cell.HasFormula Then
        Set tempReferences = InternalGetNamesAndCellAddresses(strFormula, cell, , ReturnDuplicateReferences)
    ElseIf Len(strFormula) > 1 Then
        If Left(strFormula, 1) = "=" Or Left(strFormula, 2) = "'=" Then
            Set tempReferences = InternalGetNamesAndCellAddresses(strFormula, cell, , ReturnDuplicateReferences)
        ElseIf InStr(1, strFormula, "[") > 0 And InStr(1, strFormula, "]") > 0 Then
            Set tempReferences = InternalGetNamesAndCellAddresses(strFormula, cell, , ReturnDuplicateReferences)
        Else
            Set tempReferences = New FormulaReferences
        End If
    Else
        Set tempReferences = New FormulaReferences
    End If
    Set GetFormulaReferences = tempReferences
End Function
Private Function InternalGetNamesAndCellAddresses(ByVal Formula As String, Optional cell As Range, Optional ByRef OutAllParts As Collection, _
                    Optional ReturnDuplicateRangeReferences As Boolean = True) As FormulaReferences
    Dim position As Long, nextDividerIndex As Long
    Dim endLoop As Boolean
    Dim divider As String
    Dim Text As String
    Dim cellReferences As Collection
    Dim isGoodCellReference As Boolean
    Dim outCollection As Collection
    Set outCollection = New Collection
    Dim cnt As Long
    Dim col As FormulaReferences
    Dim r As FormulaReference
     
    Set cellReferences = New Collection
    Set col = New FormulaReferences
    Formula = Trim(Formula)
    If Len(Formula) > 1 Then
        If Left(Formula, 2) = "'=" Then Formula = Right(Formula, Len(Formula) - 1)
    End If
    
    position = 1
    Do Until endLoop
        If Not FindNextDivider(Formula, position, nextDividerIndex) Then
            endLoop = True
        End If
        
        divider = Mid(Formula, nextDividerIndex, 1)
        Text = Trim(Mid(Formula, position, nextDividerIndex - position))
        isGoodCellReference = True
        If Text = "" Then
            isGoodCellReference = False
        ElseIf UCase(Text) = "INDIRECT" Then
            'TODO-In the future I would like to add support the the indirect function, it would
            'resolve everything in the parenthesis into a valid address
            isGoodCellReference = False
             
        ElseIf divider = "(" Then
            'if divider is "(" then that means the text is a Function
            isGoodCellReference = False
             
        ElseIf InStr(1, Text, """") > 0 And Left(Text, 1) <> "[" Then
            'if there is a " in the text, then it is a string
            'if it is inside brackets, then we will accept the reference
            If InStr(1, Text, "[") = 0 And InStr(1, Text, "]") = 0 Then
                isGoodCellReference = False
            End If
             
        ElseIf IsNumeric(Left(Text, 1)) Then
            'names for cell address cannot start with a number
            isGoodCellReference = False
             
        ElseIf IsNumeric(Text) Then
            'ignore if it only contains numbers
            isGoodCellReference = False
            
        ElseIf UCase(Text) = "TRUE" Or UCase(Text) = "FALSE" Then
             'ignore boolean values
            isGoodCellReference = False
        End If
        
         'if we got here then it is a good cell reference
        Dim addFormula As Boolean
        If isGoodCellReference Then
             'ignore duplicate cell addresses
            On Error Resume Next
            addFormula = True
            If Not ReturnDuplicateRangeReferences Then
                Err.Clear
                cellReferences.Add Text, CStr(Text)
                If Err <> 0 Then addFormula = False
            End If
            If addFormula Then
                Set r = New FormulaReference
                r.Init Formula, Text, position, cell
                col.Add r
            End If
            outCollection.Add Text
            On Error GoTo 0
        Else
            outCollection.Add Text
        End If
        position = nextDividerIndex + 1
    Loop
    Set OutAllParts = outCollection
    Set InternalGetNamesAndCellAddresses = col
End Function
 
Private Function FindNextDivider(Formula As String, position As Long, _
    ByRef outNextDividerIndex As Long) As Boolean
    
    'ignore dividers between " and [] and '
    Dim betweenBrackets As Boolean
    Dim betweenQuotes As Boolean
    Dim betweenApostrophe As Boolean
    
    Dim str As String
    
    For outNextDividerIndex = position To Len(Formula)
        str = Mid(Formula, outNextDividerIndex, 1)
        If str = """" Then
            If betweenBrackets = False Then
                betweenQuotes = Not betweenQuotes
            End If
        End If
        
        If str = "[" Then betweenBrackets = True
        
        If str = "]" Then
            betweenBrackets = False
        End If
        
        'the apostrophe is ignored unless it is the first letter
        If str = "'" And outNextDividerIndex = position And InStr(outNextDividerIndex, Formula, "'!") > 0 Then
            betweenApostrophe = True
        End If
        
        If Mid(Formula, outNextDividerIndex, 2) = "'!" And betweenApostrophe Then betweenApostrophe = False
        
        If IsDivider(str) And Not betweenBrackets And Not betweenQuotes And Not betweenApostrophe Then
            FindNextDivider = True
            Exit Function
        End If
    Next
    
    FindNextDivider = False
End Function
 
Public Function IsDivider(char As String) As Boolean
    If char Like "[=,+,*,/,(,),^,&,{,},&,>,<]" Or char = "-" Then IsDivider = True
End Function


Public Function ContainsDivider(str As String) As Boolean
    Dim i As Long
    For i = 1 To Len(str)
        If IsDivider(Mid(str, i, 1)) Then
            ContainsDivider = True
            Exit Function
        End If
    Next
End Function












Attribute VB_Name = "SectionGroupValues"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private mSVs As Collection
Private mSecs As Collection
Private mRows As Long
Private mValues() As Variant
Private mRowSec() As ItemSection
Private mRowSecType() As String

Private mRowNumber() As Long

Private mFilteredRows() As Variant
Private mFilteredRowsIndex() As Variant
Private mFilterRowCount As Long
Private mFilterApplied As Boolean

Private mColumnKeys As Collection
Private mColumns As ColumnInfoCollection

Private mFilters As Collection
Private mFilterColIndexes As Collection
Private mFilterSectionType As Collection


Public Sub MiscMethod(strKey As String, ParamArray arr() As Variant)
'<CSCustomCode> 1
On Error Resume Next
'</CSCustomCode> 1
'
End Sub

Public Sub ClearFilters()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim changed As Boolean
    If Not mFilters Is Nothing Then
        If mFilters.Count > 0 Then
            changed = True
        End If
    End If
    Set mFilters = New Collection
    Set mFilterColIndexes = New Collection
    Set mFilterSectionType = New Collection
    
    mFilterApplied = False
    
    If changed Then
        'RaiseEvent FilterChanged
    End If
End Sub
Public Sub ClearColumnFilter(colIndex As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim f As CFilter
    Set f = GetFilterForColumn(colIndex)
    If Not f Is Nothing Then
        f.Clear
        Me.ApplyFilters
        'RaiseEvent FilterChanged
    End If
End Sub
Public Property Get FilterCount() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    FilterCount = mFilters.Count
End Property
Public Function GetFilter(Index As Long) As CFilter
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    Set GetFilter = mFilters(Index)
End Function
Public Function GetFilterForColumn(colIndex As Long) As CFilter
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    On Error Resume Next
    If mFilterColIndexes Is Nothing Then Exit Function
    For i = 1 To mFilterColIndexes.Count
        If mFilterColIndexes(i) = colIndex Then
            Set GetFilterForColumn = mFilters(i)
        End If
    Next
End Function
Public Sub AddFilter(colIndex As Long, filter As CFilter)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mFilters Is Nothing Then Set mFilters = New Collection
    If mFilterColIndexes Is Nothing Then Set mFilterColIndexes = New Collection
    If mFilterSectionType Is Nothing Then Set mFilterSectionType = New Collection
    
    mFilters.Add filter
    mFilterColIndexes.Add colIndex
    mFilterSectionType.Add ""
    
    ApplyFilters
End Sub
Public Sub AddFilterForSection(colIndex As Long, filter As CFilter, sectionType As String)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mFilters Is Nothing Then Set mFilters = New Collection
    If mFilterColIndexes Is Nothing Then Set mFilterColIndexes = New Collection
    If mFilterSectionType Is Nothing Then Set mFilterSectionType = New Collection
    
    mFilters.Add filter
    mFilterColIndexes.Add colIndex
    mFilterSectionType.Add sectionType
    
    ApplyFilters
End Sub
Public Sub ApplyFilters()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim cnt As Long
    Dim fc As FilterCondition
    Dim filterFound As Boolean
    Dim y As Long
    Dim i As Long
    ReDim mFilteredRows(1 To mRows, 1 To 2)
    Dim changed As Boolean
    Dim strSectionType As String
    
    For i = 1 To UBound(mValues)
        mFilteredRows(i, 1) = i
        mFilteredRows(i, 2) = True
    Next
    
    Dim f As CFilter
    Dim colIndex As Long
    For i = 1 To mFilters.Count
        filterFound = True
        Set f = mFilters(i)
        colIndex = mFilterColIndexes(i)
        strSectionType = mFilterSectionType(i)
        
        If colIndex > 0 Then
            For y = 1 To UBound(mValues)
                If mFilteredRows(y, 2) = True Then
                    If strSectionType = "" Then
                        If f.FilterValue(CStr(mValues(y, colIndex))) Then
                            mFilteredRows(y, 2) = False
                        End If
                    Else
                        If UCase(Trim(mRowSecType(y))) = UCase(Trim(strSectionType)) Then
                            If f.FilterValue(CStr(mValues(y, colIndex))) Then
                                mFilteredRows(y, 2) = False
                            End If
                        End If
                    End If
                End If
            Next
        End If
    Next
    
    If filterFound Then
        For i = 1 To UBound(mFilteredRows)
            If mFilteredRows(i, 2) = True Then
                cnt = cnt + 1
            End If
        Next
        If cnt > 0 Then
            ReDim mFilteredRowsIndex(1 To cnt, 1 To 2)
            cnt = 0
            For i = 1 To UBound(mFilteredRows)
                If mFilteredRows(i, 2) = True Then
                    cnt = cnt + 1
                    mFilteredRowsIndex(cnt, 1) = cnt
                    mFilteredRowsIndex(cnt, 2) = i
                End If
            Next
        End If
        mFilterRowCount = cnt
        
        mFilterApplied = True
        changed = True
    Else
        If mFilterApplied Then
            mFilterApplied = False
            changed = True
        End If
        mFilterRowCount = mRows
    End If
    
    'If changed Then RaiseEvent FilterChanged
    
End Sub

Public Property Get Columns() As ColumnInfoCollection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mColumns Is Nothing Then
        Set mColumns = New ColumnInfoCollection
    End If
    Set Columns = mColumns
End Property
Public Property Get rowCount() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mFilterApplied Then
        rowCount = mFilterRowCount
    Else
        rowCount = mRows
    End If
End Property
Public Property Get values() As Variant
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    values = mValues
End Property
Public Function GetUniqueValues(col As Long, Optional ByRef outHasBlanks As Boolean) As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim val As Collection
    Set val = New Collection
    
    On Error Resume Next
    For i = 1 To UBound(mValues)
        If mValues(i, col) = "" Then
            outHasBlanks = True
        Else
            val.Add Trim(mValues(i, col)), Trim(UCase(CStr(mValues(i, col))))
        End If
    Next
    Set GetUniqueValues = val
End Function
Public Property Get value(Row As Long, col As Long) As Variant
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    If mFilterApplied Then
        value = mValues(mFilteredRowsIndex(Row, 2), col)
    Else
        value = mValues(Row, col)
    End If
End Property
Public Property Let value(Row As Long, col As Long, v As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    If mFilterApplied Then
        mValues(mFilteredRowsIndex(Row, 2), col) = v
    Else
        mValues(Row, col) = v
    End If
End Property
Public Function GetSectionAndRow(rowIndex As Long, outSection As ItemSection, outItemRow As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If mFilterApplied Then
        Set outSection = mRowSec(mFilteredRowsIndex(rowIndex))
        outItemRow = mRowNumber(mFilteredRowsIndex(rowIndex))
    Else
        Set outSection = mRowSec(rowIndex + 1)
        outItemRow = mRowNumber(rowIndex + 1)
    End If
End Function

Private Function FindBlankSections(secs As Collection, IncludeHeaderRows As Boolean) As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim s As ItemSection
    Dim isBlank As Boolean
    Dim secBlank As Boolean
    Dim col As Collection
    Set col = New Collection
    Dim y As Long
    For i = 1 To secs.Count
        Set s = secs.Item(i)
        secBlank = True
        For y = 2 To s.rowCount - 1
            isBlank = True
            If s.IsHeaderRow(y) = True And IncludeHeaderRows = True Then
                isBlank = False
            ElseIf s.IsRowEmpty(y) = False Then
                isBlank = False
            End If
            If isBlank = False Then
                secBlank = False
                Exit For
            End If
        Next
        
        If secBlank = True Then
            col.Add i
        End If
    Next
    Set FindBlankSections = col
End Function


Public Sub Init(secs As Collection, Optional IncludeHeaderRows As Boolean = True, _
                            Optional AddItemHeaderColumn As Boolean = False, _
                            Optional AddRowIndexColumn As Boolean = False, _
                            Optional AddSectionNameColumn As Boolean = True, _
                            Optional AddSectionIndexColumn As Boolean = True, _
                            Optional RemoveEmptyRows As Boolean = False, _
                            Optional AddPictureIDColumn As Boolean = False, _
                            Optional CheckHiddenColumnWidths As Boolean = False, _
                            Optional SummarySectionToUseForBlankSections As ItemSection, _
                            Optional AddSummaryRowNotLinkedToEstimateSection As Boolean = False)
                            
                            
    Init2 secs, IncludeHeaderRows, AddItemHeaderColumn, AddRowIndexColumn, AddSectionNameColumn, AddSectionIndexColumn, RemoveEmptyRows, AddPictureIDColumn, CheckHiddenColumnWidths, SummarySectionToUseForBlankSections, AddSummaryRowNotLinkedToEstimateSection
End Sub

Public Sub Init2(secs As Collection, Optional IncludeHeaderRows As Boolean = True, _
                            Optional AddItemHeaderColumn As Boolean = False, _
                            Optional AddRowIndexColumn As Boolean = False, _
                            Optional AddSectionNameColumn As Boolean = True, _
                            Optional AddSectionIndexColumn As Boolean = True, _
                            Optional RemoveEmptyRows As Boolean = False, _
                            Optional AddPictureIDColumn As Boolean = False, _
                            Optional CheckHiddenColumnWidths As Boolean = False, _
                            Optional SummarySectionToUseForBlankSections As ItemSection, _
                            Optional AddSummaryRowNotLinkedToEstimateSection As Boolean = False, _
                            Optional AddEstimateIDColumn As Boolean = False)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1

    Dim sv As SectionValues
    Dim s As ItemSection
    Dim i As Long
    mRows = 0
    
    Set mSecs = secs
    Set mSVs = New Collection

    For i = 1 To secs.Count
        Set s = secs(i)
        Set sv = New SectionValues
        sv.SetSection2 s, IncludeHeaderRows, , AddEstimateIDColumn
        sv.SectionIndex = i
        mRows = mRows + sv.rowCount
        mSVs.Add sv
    Next

    If mRows = 0 Then Exit Sub
    Set mColumns = New ColumnInfoCollection
    
    'If SummarySectionToUseForBlankSections Is Nothing Then
        mColumns.FillWithAllSectionColumns2 secs, AddSectionNameColumn, AddItemHeaderColumn, AddRowIndexColumn, AddSectionIndexColumn, AddPictureIDColumn, CheckHiddenColumnWidths, AddEstimateIDColumn
'    Else
'        'add the summary section's columns
'        secs.Add SummarySectionToUseForBlankSections
'        mColumns.FillWithAllSectionColumns2 secs, AddSectionNameColumn, AddItemHeaderColumn, AddRowIndexColumn, AddSectionIndexColumn, AddPictureIDColumn, CheckHiddenColumnWidths, AddEstimateIDColumn
'        secs.Remove secs.Count
'
'        'need to add the row from the summary for each blank section
'        Dim blankSections As Collection
'        Set blankSections = FindBlankSections(secs, IncludeHeaderRows)
'
'        'find the summary rows for each blank section
'        Dim ssu As New SummarySecUtilities
'        Dim summaryRows As Collection
'        Dim summaryRowsToAdd As Collection
'
'        Set summaryRowsToAdd = New Collection
'
'        For i = 1 To blankSections.Count
'            Set s = secs.Item(CLng(blankSections(i)))
'            If s.IsHeaderRow(i) = False Then
'            Set summaryRows = ssu.GetSummaryRowsFromSheetName(s.NamedRange.RefersToRange.Worksheet.Name, SummarySectionToUseForBlankSections)
'            If summaryRows.Count > 0 Then
'                'GetSummaryRowsFromSheetName returns the row in the section which is always one
'                'more than the item row, so subtract 1
'                summaryRowsToAdd.Add summaryRows(1)
'            End If
'            End If
'        Next
'
'        'add all the summary rows that aren't linked to an estimate sheet
'        Dim tempCol As Collection
'        If AddSummaryRowNotLinkedToEstimateSection = True Then
'            For i = 1 To SummarySectionToUseForBlankSections.ItemCount
'                'GetSheetsFromSummaryRow expects to get the row in the section, not the item row (section
'                'row is always 1 less)
'                If SummarySectionToUseForBlankSections.IsHeaderRow(i) = False Then
'                    Set tempCol = ssu.GetSheetsFromSummaryRow(i + 1, SummarySectionToUseForBlankSections)
'                    If tempCol.Count = 0 Then
'                        summaryRowsToAdd.Add i
'                    End If
'                End If
'            Next
'        End If
'
'        'get values for the summary rows
'        If summaryRowsToAdd.Count > 0 Then
'            Set sv = New SectionValues
'            sv.SetSection2 SummarySectionToUseForBlankSections, False, summaryRowsToAdd, AddEstimateIDColumn
'            sv.SectionIndex = secs.Count + 1
'            mRows = mRows + sv.RowCount
'            mSVs.Add sv
'        End If
'    End If
    
    ReDim mValues(1 To mRows, 1 To mColumns.Count)
    ReDim mRowSec(1 To mRows) As ItemSection
    ReDim mRowSecType(1 To mRows) As String
    ReDim mRowNumber(1 To mRows) As Long
    
    Dim Row As Long
    Dim Index As Long
    Dim str As String
    Dim secIndex As Long
    Row = 1

    Dim v As Variant
    For Each sv In mSVs
        secIndex = secIndex + 1
        For y = 1 To mColumns.Count
            Index = sv.GetColIndex(mColumns.Item(y).key)
            If Index > 0 Then
                For i = 1 To sv.rowCount
                    mValues(i + Row - 1, y) = sv.value(i, Index)
                Next
            ElseIf mColumns.Item(y).key = "SectionIndex" Then
                For i = 1 To sv.rowCount
                    mValues(i + Row - 1, y) = secIndex
                Next
            End If

        Next
        'store the section and row for each item
        Dim rowIndexCol As Long
        rowIndexCol = sv.GetColIndex("RowIndex")
        For i = 1 To sv.rowCount
            Set mRowSec(i + Row - 1) = sv.Section
            'mRowSecType(i + row - 1) = sv.Section.
            
            mRowNumber(i + Row - 1) = sv.value(i, rowIndexCol)
        Next
        Row = Row + sv.rowCount
    Next

    'Check for numeric values
    Dim allNumeric As Boolean
    On Error Resume Next
    
    Dim colIndex As Long
    For i = 1 To UBound(mValues, 2)
        allNumeric = True
        For y = 1 To UBound(mValues)
            v = mValues(y, i)
            If IsEmpty(v) Then
            
            ElseIf IsNumeric(v) Then
                'mValues(y, i) = v
                'If TypeName(v) <> "Long" And TypeName(v) <> "Double" Then
                 '   mValues(y, i) = CDbl(v)
                'End If
            Else
                allNumeric = False
                Exit For
            End If
        Next
        mColumns.Item(i).AllValuesNumeric = allNumeric
    Next

End Sub








Attribute VB_Name = "SectionValues"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private mSection As ItemSection
Private mValue As Variant
Private mKeyValue As Variant
Private mSecValues() As Variant
Private mColumnKeys As Collection
Private mColIndexes As Collection
Private mRowCount As Long
Private mSectionIndex As Long
Private mRowIndexColumn As Long

Private mRowsToInclude As Collection
Private mRowsToIncludeSectionRow() As Long

Public Sub MiscMethod(strKey As String, ParamArray arr() As Variant)
'<CSCustomCode> 1
On Error Resume Next
'</CSCustomCode> 1
'
End Sub
Public Property Get SectionIndex() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    SectionIndex = mSectionIndex
End Property

Public Property Let SectionIndex(ByVal SectionIndex As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    mSectionIndex = SectionIndex
End Property

Public Property Get value(Row As Long, col As Long) As Variant
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    If mRowsToInclude Is Nothing Then
        value = mSecValues(Row, col)
    Else
        
        value = mSecValues(CLng(mRowsToIncludeSectionRow(Row)), col)
    End If
End Property
Private Sub Class_Terminate()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set mSection = Nothing
End Sub


Public Property Get rowCount() As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    rowCount = mRowCount
End Property


Public Property Get Section() As ItemSection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Set Section = mSection
End Property

Public Sub SetSection(sec As ItemSection, Optional includeHeaders As Boolean = False, Optional rowsToInclude As Collection)
    SetSection2 sec, includeHeaders, rowsToInclude
End Sub
Public Sub SetSection2(sec As ItemSection, Optional includeHeaders As Boolean = False, Optional rowsToInclude As Collection, Optional includeEstimateIDs As Boolean = False)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim colKeys As Collection
    Set mSection = sec
    Dim ignore As Boolean
    On Error Resume Next
    Dim cell As Range
    If Not sec Is Nothing Then
        ignore = False
        If sec.Range.rows.Count = 3 Then  '1 item
            If sec.ColumnExists("Description") Then
                Set cell = sec.Range.Cells(2, sec.GetColumnIndex("Description"))
                If cell.value = "" Then
                    'Blank item - ignore the values for this secion
                    ignore = True
                End If
            End If
        End If
        If ignore Then
            ReDim mSecValues(0 To 0, 0 To 0)
        Else
            mSecValues = GetAllValuesWithExtras2(sec, includeHeaders, True, True, True, True, True, , includeEstimateIDs)
        End If
        
        Set mColumnKeys = New Collection
        
        For i = 1 To sec.columnKeys.Count
            mColumnKeys.Add sec.columnKeys(i)
        Next

        mColumnKeys.Add "ItemHeader"
        mColumnKeys.Add "RowIndex"
        mColumnKeys.Add "SheetName"
        mColumnKeys.Add "PictureID"
        
        If includeEstimateIDs = True Then mColumnKeys.Add "EstimateID"
        mColumnKeys.Add "SectionName"
        Set mRowsToInclude = rowsToInclude
        
        If Not rowsToInclude Is Nothing Then
            mRowCount = rowsToInclude.Count
        Else
            mRowCount = UBound(mSecValues)
        End If
        Set mColumnKeysUcase = New Collection
        Set mColIndexes = New Collection
        For i = 1 To mColumnKeys.Count
            mColIndexes.Add i, UCase(Trim(mColumnKeys(i)))
            If mColumnKeys(i) = "RowIndex" Then
                mRowIndexColumn = i
            End If
        Next
        
        Dim y As Long
        Dim Row As Long
        
        'convert the section rows on the actual sheet to the rows stored in the item array (mSecValues)
        'there is a row index column that I will search through
        If Not mRowsToInclude Is Nothing Then
            ReDim mRowsToIncludeSectionRow(1 To mRowsToInclude.Count)
            
            For i = 1 To mRowsToInclude.Count
                Row = CLng(mRowsToInclude(i))
                For y = LBound(mSecValues) To UBound(mSecValues)
                    If mSecValues(y, mRowIndexColumn) = Row Then
                        mRowsToIncludeSectionRow(i) = y
                        Exit For
                    End If
                Next
            Next
        
        End If

    End If
End Sub

Public Property Get KeyValue(Row As Long, colKey As String) As Variant
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim col As Long
    col = GetColIndex(colKey)
    If col > 0 Then
        KeyValue = value(Row, col)
    End If
End Property

Public Function GetColIndex(colKey As String) As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim str As String
    On Error Resume Next
    str = UCase(Trim(colKey))
    GetColIndex = mColIndexes(UCase(Trim(colKey)))
End Function


Public Function GetAllValuesWithExtras2(sec As ItemSection, Optional IncludeHeaderRows As Boolean = True, _
                            Optional AddItemHeaderColumn As Boolean = False, _
                            Optional AddRowIndexColumn As Boolean = False, _
                            Optional AddSectionNameColumn As Boolean, _
                            Optional RemoveEmptyRows As Boolean = False, _
                            Optional AddPictureIDColumn As Boolean, _
                            Optional RemovePermenantPrefixFromItemIDs As Boolean = True, _
                            Optional AddEstimateIDColumn As Boolean = False) As Variant()
    Dim values() As Variant, rows As Long, rng As Range
    Dim i As Long, y As Long
    Dim itemInfos As Collection
    Dim rowCount As Long
    Dim colCount As Long
    Dim errorOccured As Boolean
        
    If sec Is Nothing Then Exit Function
    
    If sec.Range Is Nothing Then
        GoTo ExitHere:
        'Exit Function
    End If
    Set rng = sec.Range
    
    On Error Resume Next
    If rng.rows.Count > 2 Then
        Set rng = rng.offset(1, 0).Resize(rng.rows.Count - 2, rng.Columns.Count)
    Else
        'there are not values
        ReDim values(0 To 0, 0 To 0)
        GetAllValuesWithExtras2 = values
        GoTo ExitHere:
        'Exit Function
    End If
    Err.Clear
    values = rng.value
    If Err.Number <> 0 Then
        'need to manually get all the values
        errorOccured = True

        rowCount = rng.rows.Count
        colCount = rng.Columns.Count
        
        'max of 1000 rows
        If rowCount > 1000 Then rowCount = 1000
        ReDim values(1 To rowCount, 1 To colCount)
        For i = 1 To rowCount
            For y = 1 To colCount
                values(i, y) = rng.Cells(i, y).value
            Next
        Next
    Else
        rowCount = UBound(values)  ' no values
        If rowCount = 0 Then Exit Function
    End If
    
    'remove any cells formated as dates incorrectly
    RemoveInvalidFormatedDates sec, values

    
    
    Dim DeleteRows() As Boolean
    ReDim DeleteRows(1 To UBound(values))

    Dim ColsToAdd As Long
    Dim additionalColIndex As Long

    If RemovePermenantPrefixFromItemIDs Then
'        remove any P:: from item infos
        Dim infoIndex As Long

        If sec.ColumnExists("Info") Then
            infoIndex = sec.GetColumnIndex("Info")
            If infoIndex > 0 Then
                For i = LBound(values) To UBound(values)
                    If Left$(values(i, infoIndex), 3) = "P::" Then
                        values(i, infoIndex) = Right$(values(i, infoIndex), Len(values(i, infoIndex)) - 3)
                    End If
                Next
            End If
        End If
    End If
'

    ColsToAdd = IIf(AddItemHeaderColumn, 1, 0) + IIf(AddRowIndexColumn, 1, 0) + IIf(AddSectionNameColumn, 1, 0) + _
        IIf(AddPictureIDColumn, 1, 0) + IIf(AddEstimateIDColumn, 1, 0) + IIf(AddSectionNameColumn, 1, 0)
        
    additionalColIndex = UBound(values, 2) + 1
    ReDim Preserve values(1 To UBound(values), 1 To UBound(values, 2) + ColsToAdd)
    If RemoveEmptyRows = True Then
        For i = 1 To UBound(values)
            If IsRowBlank(values, i) Then DeleteRows(i) = True
        Next
    End If
    
    If IncludeHeaderRows = False Or AddItemHeaderColumn = True Then
        Dim indexes As Collection
        Set indexes = New Collection
        
        For i = 2 To sec.rowCount - 1
            If sec.IsHeaderRow(i) Then indexes.Add i - 1
        Next
        
        If IncludeHeaderRows = False Then
            For i = 1 To indexes.Count
                'Use the indexes to show the rows to delete
                DeleteRows(indexes(i)) = True
            Next
        End If

        Dim nextIndex As Long, currentIndex As Long, strHeader As String

        If AddItemHeaderColumn Then
            Dim descCol As Long
            'descCol = Me.Columns("Description").ColumnIndex
             descCol = 0
            descCol = sec.GetColumnIndex("Description")
            'descCol = 5
            If indexes.Count > 0 Then
                For i = 1 To indexes.Count
                    currentIndex = indexes(i)
                    If i < indexes.Count Then
                        nextIndex = indexes(i + 1) - 1
                    Else
                        nextIndex = UBound(values)
                    End If

                    'Use the indexes to fill in the Item Header Column
                    strHeader = InternalGetHeaderRowText(values, indexes(i), descCol)
                    For y = currentIndex + 1 To nextIndex
                        values(y, additionalColIndex) = strHeader
                    Next
                Next
            End If
            additionalColIndex = additionalColIndex + 1
        End If
    End If


    Dim lastCol As Long

    If AddRowIndexColumn = True Then
        For i = 1 To UBound(values)
            values(i, additionalColIndex) = i
        Next
        additionalColIndex = additionalColIndex + 1
    End If

    Dim strCaption As String
    If AddSectionNameColumn = True Then
        'strCaption = Me.Caption
        strCaption = sec.Range.Worksheet.Name
        'if there is a column with SheetName or SectionName as key,
        'then let values in that column override
        Dim sheetNameCol As Long
        If sec.ColumnExists("SheetName") = True Then sheetNameCol = sec.GetColumnIndex("SheetName")
        If sheetNameCol = 0 Then
            If sec.ColumnExists("SectionName") = True Then sheetNameCol = sec.GetColumnIndex("SectionName")
        End If
        
        For i = 1 To UBound(values)
            If sheetNameCol > 0 Then
                If values(i, sheetNameCol) = "" Then
                    values(i, sheetNameCol) = strCaption
                    values(i, additionalColIndex) = strCaption
                Else
                    values(i, additionalColIndex) = values(i, sheetNameCol)
                End If
            Else
                values(i, additionalColIndex) = strCaption
                values(i, UBound(values, 2)) = sec.Caption
            End If
        Next
        additionalColIndex = additionalColIndex + 1
    End If
    
    Dim str As String
    Dim s As SettingsParser
    If AddPictureIDColumn = True Then
        
        
        Set s = New SettingsParser
        Set itemInfos = InternalGetItemInfos(sec)
        If itemInfos.Count > 0 Then
            For i = 1 To itemInfos.Count
                str = vbNullString
                str = itemInfos(i)
                If Len(str) > 0 Then
                    If InStr(1, str, "PictureID", vbTextCompare) > 0 Then
                        Set s = New SettingsParser
                        s.SettingString = str
                        s.Delimiter = "::"
                        values(i, additionalColIndex) = s.Setting("PictureID")
                    End If
                End If
            Next
            additionalColIndex = additionalColIndex + 1
        End If
    End If

    If AddEstimateIDColumn = True Then
        Set s = New SettingsParser
        Set itemInfos = InternalGetItemInfos(sec)
        If itemInfos.Count > 0 Then
            For i = 1 To itemInfos.Count
                str = vbNullString
                str = itemInfos(i)
                If Len(str) > 0 Then
                    If InStr(1, str, "EstimateID", vbTextCompare) > 0 Then
                        Set s = New SettingsParser
                        s.SettingString = str
                        s.Delimiter = "::"
                        values(i, additionalColIndex) = s.Setting("EstimateID")
                    End If
                End If
            Next
            additionalColIndex = additionalColIndex + 1
        End If
    End If
    
    If IncludeHeaderRows = False Or RemoveEmptyRows = True Then

        Dim newValues() As Variant
        Dim cols As Long
        Dim cnt As Long
        rows = GetRowCountFromDeleteRows(DeleteRows)

        If rows <> UBound(values) Then
            If rows = 0 Then
                'rows = 1
                'DeleteRows(1) = False
                ReDim newValues(0, 0)
            Else
            ReDim newValues(1 To rows, 1 To UBound(values, 2))

                cnt = 0
                For i = 1 To UBound(values)
                    If DeleteRows(i) = False Then
                        cnt = cnt + 1
                        For y = 1 To UBound(values, 2)
                            newValues(cnt, y) = values(i, y)
                        Next
                    End If
                Next
            End If
            GetAllValuesWithExtras2 = newValues
        Else
            GetAllValuesWithExtras2 = values
        End If
    Else
        GetAllValuesWithExtras2 = values
    End If
ExitHere:
End Function
Private Function InternalGetItemInfos(sec As ItemSection) As Collection
    Dim i As Long
    Dim Index As Long
    Dim str As String
    Dim col As Collection
    Dim rng As Range

    On Error Resume Next
    Set col = New Collection
    Set InternalGetItemInfos = col

    If sec.ColumnExists("Info") = False Then
        Exit Function
    End If

    Index = sec.GetColumnIndex("Info")
    Set rng = mNamedRange.RefersToRange
    Set rng = rng.rows(2).Resize(rng.rows.Count - 2)
    For i = 1 To rng.rows.Count
        str = vbNullString
        str = rng.Cells(i, Index).Comment.Text
        col.Add str
    Next
End Function
Private Function InternalGetHeaderRowText(var() As Variant, Row As Long, descCol As Long)
    Dim i As Long, col As Long
    If descCol > 0 Then
        If Len(var(Row, descCol)) > 0 Then
            InternalGetHeaderRowText = var(Row, descCol)
            Exit Function
        End If
    End If
    For i = 1 To UBound(var, 2)
        If Len(var(Row, i)) > 0 Then
            If Left(UCase(var(Row, i)), 10) <> "HEADER" Then
                InternalGetHeaderRowText = var(Row, i)
                Exit Function
            End If
        End If
    Next
End Function
Private Sub RemoveInvalidFormatedDates(sec As ItemSection, values As Variant)
    On Error Resume Next
    Dim isDateColumn As Boolean
    Dim columnsAreDates() As Boolean
    ReDim columnsAreDates(1 To sec.columnCount) As Boolean
    
    Dim i As Long
    Dim y As Long
    
    Dim strNumberFormat As String
    For i = 1 To sec.columnCount
        strNumberFormat = sec.GetColumnSetting(i, "NumberFormat")
        If UCase(Trim(strNumberFormat)) = "GENERAL" Then
            isDateColumn = False
        ElseIf InStr(1, strNumberFormat, "##") > 0 Then
            isDateColumn = False
        ElseIf InStr(1, strNumberFormat, "Date", vbTextCompare) > 0 Then
            isDateColumn = True
        ElseIf InStr(1, strNumberFormat, "mm", vbTextCompare) > 0 Then
            isDateColumn = True
        ElseIf InStr(1, strNumberFormat, "dd", vbTextCompare) > 0 Then
            isDateColumn = True
        ElseIf InStr(1, strNumberFormat, "yy", vbTextCompare) > 0 Then
            isDateColumn = True
        Else
            isDateColumn = False
        End If
        columnsAreDates(i) = isDateColumn
    Next
    For i = 1 To UBound(values)
        For y = 1 To UBound(values, 2)
            If IsDate(values(i, y)) Then
                If columnsAreDates(y) = False Then
                    If CDbl(values(i, y)) < 20000 Then
                        'this is probably not a valid date, convert to number
                        values(i, y) = CDbl(values(i, y))
                    End If
                End If
            End If
        Next
    Next
    
End Sub
Private Function IsRowBlank(var() As Variant, Row As Long, Optional showMsg As Boolean = False) As Boolean
    Dim i As Long
    Dim isBlank As Boolean
    Dim itemBlank As Boolean
    Dim dimensions As Long
    
    On Error Resume Next
    itemBlank = True
    
    Err.Clear
    dimensions = UBound(var, 2)

    If Row = 0 Then Exit Function
    

    If Row <= UBound(var) Then

        If IsArray(var) = True Then
            For i = 1 To UBound(var, 2)
                isBlank = False
                If IsEmpty(var(Row, i)) Then isBlank = True
                If Len(var(Row, i)) = 0 Then isBlank = True
                If var(Row, i) = 0 Then isBlank = True
                If var(Row, i) = "0" Then isBlank = True
                If isBlank = False Then
                    itemBlank = False
                    Exit For
                End If
            Next
        End If
    End If
 
    IsRowBlank = itemBlank
End Function
Private Function GetRowCountFromDeleteRows(dr() As Boolean) As Long
    Dim i As Long
    Dim cnt As Long
    For i = LBound(dr) To UBound(dr)
        If dr(i) = False Then cnt = cnt + 1
    Next
    GetRowCountFromDeleteRows = cnt
End Function
Attribute VB_Name = "SettingsParser"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Private mSettings As String
Private mDelimiter As String
Private mIDs As Collection
Private mValues As Collection
Private mFullSettingString As String
Private mSettingString As String

Public Sub Init(sht As Worksheet)
    On Error Resume Next
    Dim str As String
    
    Dim settingsName As Name
    Set settingsName = sht.names("Settings")

    If settingsName Is Nothing Then
        Exit Sub
    End If
    str = Trim$(settingsName.RefersTo)
    str = Replace(str, """", "")
    If Left$(str, 1) = "=" Then str = Right$(str, Len(str) - 1)
    'sometimes excel puts a one in, I need to remove it
    If Left$(str, 5) = "1::::" Then str = Right$(str, Len(str) - 5)
    str = Trim$(str)

    Me.Delimiter = "::"
    Me.SettingString = str
End Sub

Public Sub DeleteSetting(settingName As String)
    On Error Resume Next
    Dim i As Long
    For i = 1 To mIDs.Count
        If Trim(UCase(mIDs(i))) = Trim(UCase(settingName)) Then
            mIDs.Remove i
            mValues.Remove i
            Exit For
        End If
    Next
End Sub
Public Property Get SettingString() As String
    Dim i As Long, str As String
    
    If mIDs Is Nothing Then Set mIDs = New Collection
    If mValues Is Nothing Then Set mValues = New Collection
    For i = 1 To mIDs.Count
        str = str & IIf(str = "", "", mDelimiter & "  ") & mIDs(i) & mDelimiter & mValues(i)
    Next
    'If str <> "" Then str = str & "::"
    mSettingString = str
    SettingString = mSettingString
End Property

Public Property Let SettingString(ByVal SettingString As String)
    mSettingString = SettingString
    Parse SettingString
End Property

Public Property Get Delimiter() As String
    Delimiter = mDelimiter
End Property

Public Property Let Delimiter(ByVal Delimiter As String)
    mDelimiter = Delimiter
End Property

Private Sub Parse(str As String)
    Dim i As Long, values() As String
    Set mIDs = New Collection
    Set mValues = New Collection
    
    values = Split(str, mDelimiter)
    For i = LBound(values) To UBound(values) Step 2
        mIDs.Add Trim(values(i))
        If UBound(values) > i Then
            mValues.Add Trim(values(i + 1))
        Else
            mValues.Add ""
        End If
    Next
End Sub

Public Property Get IDs() As Collection
    Set IDs = mIDs
End Property
Public Property Get values() As Collection
    Set values = mValues
End Property

Public Property Get Setting(settingName As String) As String
    On Error Resume Next
    Dim i As Long
    If mIDs Is Nothing Then Set mIDs = New Collection
    If mValues Is Nothing Then Set mValues = New Collection
    For i = 1 To mIDs.Count
        If Trim(UCase(mIDs(i))) = Trim(UCase(settingName)) Then
            Setting = mValues(i)
            
            Exit For
        End If
    Next

End Property
Public Property Let Setting(settingName As String, value As String)
    On Error Resume Next
    If mIDs Is Nothing Then Set mIDs = New Collection
    If mValues Is Nothing Then Set mValues = New Collection
    
    Dim i As Long, added As Boolean
    For i = 1 To mIDs.Count
        If Trim(UCase(mIDs(i))) = Trim(UCase(settingName)) Then
            mValues.Add value, , , i
            mValues.Remove i
            added = True
            Exit For
        End If
    Next
    If Not added Then
        mIDs.Add settingName
        mValues.Add value
    End If
End Property

Private Sub Class_Initialize()
    Set mIDs = New Collection
    Set mValues = New Collection
    mDelimiter = "::"
End Sub

Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "UpdateWordDocuments"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit



Public Function SendProjectVariablesToWordDocument(wkbk As Workbook, strFileName As String) As Object    ' Word.Document
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim names As Collection
    Dim values As Collection
    Dim isTemplate As Boolean
    Dim wordApp As Object 'Word.Application
    Dim docAlreadyOpen As Boolean
    Dim doc As Object
    
    Set names = New Collection
    Set values = New Collection
    
    GetProjectVariables wkbk, names, values
    GetExcelNames wkbk, names, values
    
    Dim str As String
    'Dim doc As Object ' Word.Document
    
    If Right(UCase(strFileName), 1) = "T" Then isTemplate = True
    Set wordApp = CreateObject("Word.Application") '  New Word.Application
    If isTemplate = True Then
        Set doc = wordApp.Documents.Add(strFileName)
    Else
        Set doc = wordApp.Documents.Open(strFileName)
    End If
    wordApp.Visible = True

    
    If doc Is Nothing Then
        MsgBox "Could not open the file: " & vbCrLf & _
        strFileName
        Exit Function
    End If
    
    Set wordApp = doc.Application
    Set SendProjectVariablesToWordDocument = doc
    
    ReplaceTextInWordDocument2 doc, names, values
    'SendProjectListsToWordDocument wkbk, doc
    
End Function

Public Function GetWordDoc(strFileName As String) As Object
    Dim wordApp As Object
    Dim doc As Object
    Set wordApp = CreateObject("Word.Application") '  New Word.Application
    
    Dim isTemplate As Boolean
    If Right(UCase(strFileName), 3) = "DOT" Or Right(UCase(strFileName), 4) = "DOXT" Then isTemplate = True
    
    If isTemplate = True Then
        Set doc = wordApp.Documents.Add(strFileName)
    Else
        Set doc = wordApp.Documents.Open(strFileName)
    End If
    wordApp.Visible = True
    
    Set GetWordDoc = doc
End Function

Private Sub GetExcelNames(wkbk As Workbook, outNames As Collection, outValues As Collection)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim nm As Name
    Dim rng As Range
    On Error Resume Next
    For Each nm In wkbk.names
        outNames.Add "[" & nm.Name & "]"
        Set rng = Nothing
        Set rng = nm.RefersToRange
        If Not rng Is Nothing Then
            outValues.Add rng.Cells(1, 1).Text 'rng.Cells(1, 1).value
        Else
            outValues.Add ""
        End If
    Next
End Sub
Private Sub GetProjectVariables(wkbk As Workbook, outNames As Collection, outValues As Collection)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim nm As Name
    Dim rng As Range
    Dim i As Long
    Dim descCol As Long, valueCol As Long
    On Error Resume Next
    Set nm = wkbk.names("Variables")
    If nm Is Nothing Then Exit Sub
    Set rng = nm.RefersToRange
    If rng Is Nothing Then Exit Sub
    Dim s As Object
    Set s = CreateObject("MaderaSection.Section")
    s.Init nm, "Variables", "Variables"
    If s.Columns.Exists("Description") = False Then Exit Sub
    If s.Columns.Exists("Value") = False Then Exit Sub
    
    descCol = s.Columns("Description").columnIndex
    valueCol = s.Columns("Value").columnIndex
    
    For i = 1 To s.ItemCount
        If s.IsRowEmpty(i) = False Then
            If s.IsHeaderRow(i) = False Then
                If s.value(i, descCol) <> "" Then
                
                    'If rng.Cells(i, valueCol).value <> "" Then
                        outNames.Add "[" & s.value(i, descCol) & "]"
                        Dim s2 As ItemSection
                        's2.GetCellByIndex(i, valueCol).Text
                        outValues.Add s.GetCellByIndex(i, valueCol).Text  '.value(i, valueCol)
    
                    'End If
                End If
            End If
        End If
    Next
End Sub
Private Sub ReplaceTextInWordDocument2(doc As Object, namesToLookFor As Collection, valuesToReplaceWith As Collection) 'Word.Document
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim TextToSearch As String
    Dim rngSearchRange As Object ' Word.Range
    Dim rngContext As Object  'Word.Range
    Dim WasFound As Boolean
    Dim NrHits As Long

    Set rngSearchRange = doc.Content
    NrHits = 0
    Dim f As Object
    
    Dim str As String
    Dim strName As String
    Dim rng As Object
    Dim b As Boolean
    Dim col As Collection
    Set col = New Collection
    
    Dim pos As Long
    Dim pos2 As Long
    Dim i As Long
    
    
    
    'First replace any field values
    ReplaceTextInWordDocumentCommentFields doc, namesToLookFor, valuesToReplaceWith
    
    
    Do
        With rngSearchRange
            With .Find
                .Forward = True
                .MatchWildcards = True
                .Text = "\[*\]"
                WasFound = .Execute
                
            End With
            If WasFound = True Then
                'Set rngContext = .Sentences(1)
                pos = 0
                pos2 = 0
                str = ""
                Set rng = Nothing
                
                Set rngContext = rngSearchRange
                strName = rngContext.Text

                pos = InStr(1, strName, "[", vbTextCompare)
                pos2 = InStr(1, strName, "]", vbTextCompare)

                Dim strVariable As String
                If pos > 0 And pos2 > 0 Then
                    Set rng = doc.Range(rngContext.Characters(pos).Start, rngContext.Characters(pos2).End)
                    b = False
                    str = FindValueInCollections(Trim(rng.Text), namesToLookFor, valuesToReplaceWith, b)
                    If b = True Then
                        If str = "" Then str = "_"  'the value in that goes in the word field can't be blank, otherwise the field will disappear
                        If str <> rng.Text Then    'And str <> ""
    
                            Set f = Nothing
                            strVariable = rng.Text
                            Set f = doc.Fields.Add(Range:=rng, Type:=-1, Text:="COMMENTS  Code", PreserveFormatting:=True)  'wdFieldEmpty = -1
                            f.Code.Text = "COMMENTS  " & """" & str & """" & " \* MERGEFORMAT " & strVariable
                            f.Update
                            f.ShowCodes = False
    
                            'rng.Text = str
                        Else
                            col.Add rng.Text
                        End If
                    Else
                        col.Add rng.Text
                    End If
                End If
                NrHits = NrHits + 1
            End If
            .Collapse Direction:=0 'wdCollapseEnd
            '.MoveEnd Unit:=6 'wdStory
        End With
    Loop Until WasFound = False
    
    
    
    Dim str1 As String
    If col.Count > 0 Then
        For i = 1 To col.Count
            'ignore spec sections
            If InStr(1, col(i), "Spec1", vbTextCompare) = 0 Then
                str1 = str1 & IIf(str1 <> "", vbCrLf, "") & col(i)
            End If
        Next
        If str <> "" Then
            MsgBox "The following variables were not replaced: " & vbCrLf & str1
        End If
    End If
End Sub
Private Sub ReplaceTextInWordDocumentCommentFields(doc As Object, namesToLookFor As Collection, valuesToReplaceWith As Collection)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim strName As String
    Dim rng As Object 'Range
    Dim i As Long
    Dim f As Object 'Field
    Dim str As String
    Dim strVariable As String
    Dim pos As Long
    Dim pos2 As Long
    Dim strText As String
    Dim newFieldText As String
    Dim b As Boolean
    
    For i = 1 To doc.Fields.Count
        Set f = doc.Fields(i)
        str = Trim(f.Code.Text)
        If Left(str, 8) = "COMMENTS" Then
            If InStr(1, str, "[&") > 0 Then
                strVariable = ""
                pos = 0
                pos2 = 0
                strText = ""
                newFieldText = ""
                
                strVariable = Right(str, Len(str) - InStr(1, str, "[&") + 1)
                strVariable = Left(strVariable, InStr(1, strVariable, "]"))
                pos = InStr(1, str, "COMMENTS")
                pos2 = InStr(1, str, "\*")
                
                
                If strVariable <> "" And pos2 > 0 Then
                    b = False
                    newFieldText = FindValueInCollections(strVariable, namesToLookFor, valuesToReplaceWith, b)
                    If b = True Then
                        If newFieldText = "" Then newFieldText = "_"  'the value in that goes in the word field can't be blank, otherwise the field will disappear
                        If newFieldText <> "" Then
                            strText = Left(str, pos - 1) & "COMMENTS" & "  " & """" & newFieldText & """" & " " & Right(str, Len(str) - pos2 + 1)
                        End If
                    End If
                End If
                
                If strText <> "" Then
                    f.Code.Text = strText
                    f.Update
                    f.ShowCodes = False
                End If
            End If
        End If
    Next
End Sub

Private Sub ReplaceTextInWordDocument(doc As Object, namesToLookFor As Collection, valuesToReplaceWith As Collection) 'Word.Document
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    'Debug.Print Application.ActiveDocument.Content.Text
    Dim i As Long
    Dim d As Object 'Word.Document
    Dim w As Object 'Word.Range
    Set d = doc
    
    Dim lastCloseBracket As Long
    
    For i = d.Words.Count To 1 Step -1
        Set w = d.Words(i)
        
        If Right(Trim(w.Text), 1) = "]" Then
            lastCloseBracket = i
        End If
        
        Dim textRng As Object 'Word.Range
        Dim str As String
        Dim col As Collection
        Set col = New Collection

        If InStr(1, Trim(w.Text), "[&", vbTextCompare) > 0 Then
            'find the text in the Excel file
            If lastCloseBracket >= i Then
                Set textRng = d.Range(w.Start, d.Words(lastCloseBracket).End)
                str = FindValueInCollections(Trim(textRng.Text), namesToLookFor, valuesToReplaceWith)
                If str <> "" Then
                    textRng.Text = str
                Else
                    col.Add textRng.Text
                End If
            End If
        End If
    Next
    
    
    Dim str1 As String
    If col.Count > 0 Then
        For i = 1 To col.Count
            str1 = str1 & IIf(str1 <> "", vbCrLf, "") & col(i)
        Next
        MsgBox "The following variables were not replaced: " & vbCrLf & str1
        
    End If
End Sub


Private Function FindValueInCollections(strName As String, names As Collection, values As Collection, Optional valueExists As Boolean = False) As String
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim str As String
    Dim i As Long
    str = UCase(Trim(strName))
    
    Dim pos As Long, pos2 As Long
    strName = strName
    pos = InStr(1, strName, "[&", vbTextCompare)
    pos2 = InStr(1, strName, "]", vbTextCompare)
    
    If pos > 0 And pos2 > 0 Then
        str = Mid(strName, pos + 2, pos2 - pos - 2)
        str = UCase(str)
    End If
    
'    If Left(str, 2) = "[&" Then str = Right(str, Len(str) - 2)
'    If Right(str, 1) = "]" Then str = Left(str, Len(str) - 1)
    
    Dim strTemp As String
    For i = 1 To names.Count
        strTemp = UCase(Trim(names(i)))
        If strTemp = str Or strTemp = "[&" & str & "]" Then
            FindValueInCollections = values(i)
            valueExists = True
            Exit Function
        End If
    Next
    
    
End Function









Sub SendExcelTableToWordDoc(doc As Object, strTableKey As String, xlRange As Range, columnKeys As Collection)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim t As Object '
    Dim values() As Variant
    Dim rng As Range
    
    'TODO: ignore any empty rows at the end of the range
    Set rng = xlRange.rows(2).Resize(xlRange.rows.Count - 2)
    Set t = FindTableFromKey(doc, strTableKey)
    If t Is Nothing Then Exit Sub
    
    FillTable t, columnKeys, values
End Sub

Sub FillTable(t As Object, columnKeys As Collection, values() As Variant)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim tableKeys As Collection
    Dim i As Long
    Dim y As Long
    Dim colIndex As Long
    Dim rowCount As Long
    
    If t Is Nothing Then Exit Sub
    
    Set tableKeys = GetTableColumnKeys(t)
    
    rowCount = UBound(values) + 1
    If rowCount < 2 Then rowCount = 2
    SetTableRows t, rowCount
    ClearTableText t
    
    
    If UBound(values) = 0 Then Exit Sub
    
    For i = 1 To tableKeys.Count
        colIndex = 0
        colIndex = GetColumnIndex(tableKeys(i), columnKeys)
        
        If colIndex > 0 Then
            'fill in the columns values
            For y = 2 To t.rows.Count
                t.cell(y, i).Range.Text = values(y - 1, colIndex)  'the first row of the table will contain the column headings
            Next
        End If
    Next

    
End Sub
Private Function GetColumnIndex(strKey As String, columnKeys As Collection) As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    
    For i = 1 To columnKeys.Count
        If UCase(Trim(strKey)) = UCase(Trim(columnKeys(i))) And columnKeys(i) <> "" Then
            'fill in the columns values
            GetColumnIndex = i
            Exit Function
        End If
    Next
End Function

Sub AddIndentToTableCell(t As Object, Row As Long, col As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long

    For i = 1 To t.cell(Row, col).Range.Paragraphs.Count
        t.cell(Row, col).Range.Paragraphs(i).Indent
    Next
    
End Sub

Sub ClearTableFormats(t As Object)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1

    On Error Resume Next
    t.Range.ListFormat.RemoveNumbers
    t.Range.Font.Bold = False
    t.Range.Font.Underline = 0 'wdUnderlineNone
    t.Range.Font.Color = -16777216 'wdColorAutomatic

    Dim strFont As String
    Dim lSize As Long
    
    strFont = t.cell(1, 1).Range.Font.Name
    lSize = t.cell(1, 1).Range.Font.Size
    
    If strFont <> "" Then
        t.Range.Font.Name = strFont
    End If
    If lSize > 0 Then
        t.Range.Font.Size = lSize
    End If
End Sub
Sub ClearTableText(t As Object) 'Table)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    'note:  clears all the text in a table except the text in the first row
    Dim r As Object 'Range
    If t Is Nothing Then Exit Sub
    Set r = t.Range
    r.Start = t.cell(2, 1).Range.Start
    r.End = t.cell(t.rows.Count, t.Columns.Count).Range.End
    r.Delete
End Sub
Sub ClearTableIndents(t As Object)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim y As Long
    
    For i = 1 To t.rows.Count
        For y = 1 To t.cell(i, 1).Range.Paragraphs.Count
            t.cell(i, 1).Range.Paragraphs(y).Outdent
            t.cell(i, 1).Range.Paragraphs(y).Outdent
        Next
    Next
    t.Range.ListFormat.RemoveNumbers
End Sub
Sub SetTableRows(t As Object, rowCount As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim r As Object
    
    If rowCount < 2 Then rowCount = 2
    If t Is Nothing Then Exit Sub
    If t.rows.Count > rowCount Then
        Set r = t.Range
        r.Start = t.cell(rowCount + 1, 1).Range.Start
        r.rows.Delete
    ElseIf t.rows.Count < rowCount Then
        Set r = t.Application.Selection.Range
        t.rows(t.rows.Count).Select
        
        If t.rows.Count = 1 Then
            t.Application.Selection.InsertRowsBelow rowCount - t.rows.Count
        Else
            t.Application.Selection.InsertRowsAbove rowCount - t.rows.Count
        End If
        If Not r Is Nothing Then r.Select
    End If
End Sub
Function GetTableColumnKeys(t As Object) As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim colKeys As Collection
    Dim str As String
    Dim strVariable As String
    Dim i As Long
    Dim f As Object 'Field
        
        
    Set colKeys = New Collection
    If t Is Nothing Then Exit Function
    
    For i = 1 To t.Columns.Count
        strVariable = ""

        
        If t.cell(1, i).Range.Fields.Count > 0 Then
            Set f = t.cell(1, i).Range.Fields(1)
            str = Trim(f.Code.Text)
            If InStr(1, str, "[&") > 0 Then
                strVariable = Right(str, Len(str) - InStr(1, str, "[&") - 1)
                strVariable = Left(strVariable, InStr(1, strVariable, "]") - 1)
            End If
        End If
        
        colKeys.Add strVariable
    Next
    
    Set GetTableColumnKeys = colKeys
End Function
Function FindTableFromKey(doc As Object, strKey As String) As Object
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim TextToSearch As String
    Dim rngSearchRange As Object 'Word.Range
    Dim rngContext As Object 'Word.Range
    Dim WasFound As Boolean
    Dim pos As Long
    Dim pos2 As Long

    Set rngSearchRange = doc.Content
    
    Dim str As String
    Dim strName As String
    Dim rng As Object 'Word.Range
    Dim f As Object 'Field
    
    'search through the text of the document
    With rngSearchRange
        With .Find
            .Forward = True
            .MatchWildcards = True
            .MatchCase = False
            .Text = "\[Table:" & strKey & "\]"
            If .Execute = False Then
                If Left(strKey, 5) <> "Table" Then
                    Set f = FindCommentFieldFromKey(doc, "Table:" & strKey)
                Else
                    Set f = FindCommentFieldFromKey(doc, strKey)
                End If
                If Not f Is Nothing Then
                    Set rng = f.Result
                    If rng.Tables.Count > 0 Then
                        'the inner table contains all the columns
                        If rng.Tables(1).cell(1, 1).Tables.Count > 0 Then
                            Set FindTableFromKey = rng.Tables(1).cell(1, 1).Tables(1)
                        End If
                    End If
                End If
            Else
                Set rngContext = rngSearchRange
                strName = rngContext.Text
                
    
                pos = InStr(1, strName, "[", vbTextCompare)
                pos2 = InStr(1, strName, "]", vbTextCompare)

                Dim strVariable As String
                If pos > 0 And pos2 > 0 Then
                    Set rng = doc.Range(rngContext.Characters(pos).Start, rngContext.Characters(pos2).End)
                    
                    If rng.Tables.Count > 0 Then
                        'the inner table contains all the columns
                        If rng.Tables(1).cell(1, 1).Tables.Count > 0 Then
                            Set FindTableFromKey = rng.Tables(1).cell(1, 1).Tables(1)
                        End If
                    End If
                End If
            End If
        End With
    End With

    'search through the comment fields

End Function
Function FindCommentFieldFromKey(doc As Object, strKey As String) As Object  'Field
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim f As Object 'Field
    Dim str As String
    Dim strVariable As String
    
    For i = 1 To doc.Fields.Count
        Set f = doc.Fields(i)
        str = Trim(f.Code.Text)
        If f.Type = 19 Then  'wdFieldComments = 19
            If InStr(1, str, "[&") > 0 Then
                strVariable = ""

                strVariable = Right(str, Len(str) - InStr(1, str, "[&") - 1)
                strVariable = Left(strVariable, InStr(1, strVariable, "]") - 1)
                If UCase(Trim(strVariable)) = UCase(Trim(strKey)) Then
                    Set FindCommentFieldFromKey = f
                    Exit For
                End If
            End If
        End If
    Next
End Function




Attribute VB_Name = "frmPlanswift"
Attribute VB_Base = "0{60FFFB54-E38E-49EB-B2FD-3A1EB44D8D51}{DCCCABCF-E4A2-4C65-B373-2AD89783AE86}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False





Dim pItems As Collection

Dim PropertyList As Collection

Dim pJob As PSJob

Private Sub CommandButton1_Click()
    If ListBox2.ListIndex < 0 Then
        MsgBox "Select a planswift property before clicking 'Add'"
        Exit Sub
    End If
    
    Dim prop As PSItemProperty
    On Error Resume Next
    Set prop = PropertyList(ListBox2.ListIndex + 1)
    
    If prop Is Nothing Then
        MsgBox "Select a valid property (starts with =)"
        Exit Sub
    End If
    
    Dim variablesRange As Range
    
    On Error Resume Next
    Set variablesRange = ActiveWorkbook.names("Variables").RefersToRange
    If variablesRange Is Nothing Then Exit Sub
    
    Dim sec As ItemSection
    Set sec = New ItemSection
    sec.Init variablesRange, True
    
    If sec.ColumnExists("PSVariableName") = False Or sec.ColumnExists("Value") = False Then
        MsgBox "Invalid project variables sheet, cannot add planswift variables to it."
    End If
    
    Dim rng As Range
    Set rng = sec.Range.Columns(sec.GetColumnIndex("PSVariableName")) ' ThisWorkbook.names("PlanswiftKeys").RefersToRange
    
    Dim rngValues As Range
    If sec.ColumnExists("BaseValue") Then
        Set rngValues = sec.Range.Columns(sec.GetColumnIndex("BaseValue")) ' ThisWorkbook.names("PlanswiftValues").RefersToRange
    Else
        Set rngValues = sec.Range.Columns(sec.GetColumnIndex("Value")) ' ThisWorkbook.names("PlanswiftValues").RefersToRange
    End If
    
    
    On Error Resume Next
    Dim tempRange As Range
    Set tempRange = Application.Intersect(rng, ActiveCell)
    If Not tempRange Is Nothing Then
        If tempRange.Address = ActiveCell.Address Then
            ActiveCell.value = prop.ItemName & ":" & prop.Name
            
            If Not rngValues Is Nothing Then
                Application.Intersect(rngValues, ActiveCell.EntireRow).value = prop.value
            End If
        End If
    End If
End Sub

Private Sub CommandButton2_Click()
    Unload Me
End Sub

Private Sub ListBox1_Click()
    FillProperties
End Sub

Private Sub FillProperties()
    On Error Resume Next
    Set PropertyList = New Collection
    ListBox2.Clear
    If ListBox1.ListIndex < 0 Then Exit Sub
        
    Dim pItem As PSItem
    Set pItem = pItems(ListBox1.ListIndex + 1)
    
    Dim i As Long
    Dim propertySymbol As String
    Dim prop As PSItemProperty
    
    propertySymbol = "="
    
    ListBox2.AddItem UCase("Main Properties")
    PropertyList.Add ""
    For i = 1 To pItem.MainProperties.Count
        Set prop = pItem.MainProperties(i)
        ListBox2.AddItem "    " & propertySymbol & prop.Name
        ListBox2.List(ListBox2.ListCount - 1, 1) = prop.value & " " & prop.Units
        PropertyList.Add prop
    Next
    
    ListBox2.AddItem UCase("Estimating Properties")
    PropertyList.Add ""
    For i = 1 To pItem.EstimatingProperties.Count
        Set prop = pItem.EstimatingProperties(i)
        ListBox2.AddItem "    " & propertySymbol & prop.Name
        ListBox2.List(ListBox2.ListCount - 1, 1) = prop.value & " " & prop.Units
        PropertyList.Add prop
    Next
    
    ListBox2.AddItem UCase("Takeoff Properties")
    PropertyList.Add ""
    For i = 1 To pItem.TakeoffDataProperties.Count
        Set prop = pItem.TakeoffDataProperties(i)
        ListBox2.AddItem "    " & propertySymbol & prop.Name
        ListBox2.List(ListBox2.ListCount - 1, 1) = prop.value & " " & prop.Units
        PropertyList.Add prop
    Next
    
'    ListBox2.AddItem UCase("ALL Properties")
'    PropertyList.Add ""
'    For i = 1 To pItem.ItemProperties.Count
'        Set prop = pItem.ItemProperties(i)
'        ListBox2.AddItem "    " & propertySymbol & prop.Name
'        ListBox2.List(ListBox2.ListCount - 1, 1) = prop.Value & " " & prop.Units
'        PropertyList.Add prop
'    Next
End Sub

Private Sub ListBox2_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    CommandButton1_Click
End Sub

Private Sub UserForm_Initialize()
    On Error Resume Next
    Set pJob = GetPlanswiftJob
    
        Dim variablesRange As Range
    
    On Error Resume Next
    Set variablesRange = ActiveWorkbook.names("Variables").RefersToRange
    If variablesRange Is Nothing Then Exit Sub
    
    Dim sec As ItemSection
    Set sec = New ItemSection
    sec.Init variablesRange, True
    
    On Error Resume Next
    If sec.ColumnExists("PSVariableName") = True Then
        Dim rng As Range
        Set rng = sec.Range.Columns(sec.GetColumnIndex("PSVariableName")).EntireColumn
        rng.Hidden = False
        
        Dim selectRng As Range
        Set selectRng = Application.Intersect(ActiveCell.EntireRow, rng)
        If Not selectRng Is Nothing Then
            selectRng.Select
        Else
            Set selectRng = Application.Intersect(sec.Range.rows(2).EntireRow, rng)
        End If
    End If
    
    
    If pJob Is Nothing Then
        MsgBox "Error communcating with Planswift." & vbCrLf & vbCrLf & _
        "Make sure a job is open in Planswift!"
        Exit Sub
    End If
    
    Set pItems = pJob.Items
    
    For i = 1 To pItems.Count
        Set pItem = pItems(i)
        ListBox1.AddItem pItem.Name
    Next
End Sub
Attribute VB_Name = "modConEd"
Public Function IsConEdFile(sht As Worksheet) As Boolean
    Dim nm As Name
    On Error Resume Next
    Set nm = sht.Parent.names("AFDCRate")
    If Not nm Is Nothing Then
        IsConEdFile = True
    End If
End Function

Public Sub FillConEdSummaryReport(sht As Worksheet, Optional sortCostCodes As Boolean = False)
    Dim allSheets As Collection
    Set allSheets = GetAllCostCodes(sht.Parent, "SortColumn", True)
    Dim cc As CCostCode
    
    
    Dim i As Long
    Dim y As Long
    Dim z As Long
    Dim cSheet As CSheetCostCodes
    
    Dim sec As ItemSection
    
    Dim nm As Name
    On Error Resume Next
    Set nm = sht.names("SectionRange")
    
    If nm Is Nothing Then
        Set nm = sht.names("ReportList1")
    End If
    
    If Not nm Is Nothing Then
        Set sec = New ItemSection
        sec.Init nm.RefersToRange, True
        sec.DeleteAllRows
    End If
    
    Dim lRowCount As Long
    Dim colColumnKeys As Collection
    Set colColumnKeys = New Collection
    colColumnKeys.Add "TotalCost"
    colColumnKeys.Add "TotalAdjCost"
    
    For i = allSheets.Count To 1 Step -1
        Set cSheet = allSheets(i)
        cSheet.RemoveBlankCostCodes False, colColumnKeys
        If cSheet.CostCodes.Count = 0 Then
            allSheets.Remove i
        Else
            lRowCount = lRowCount + 1 + cSheet.CostCodes.Count
        End If
    Next
    
    Dim formulas() As Variant
    Dim lRow As Long
    
    If Not sec Is Nothing And lRowCount > 0 Then
        sec.AddMultipleRows lRowCount
        sec.Init nm.RefersToRange, True
        
        formulas = sec.ItemRange.value
        Dim sKey As String
        Dim sFormat As String
        For i = 1 To sec.columnCount
            lRow = 1
            sKey = sec.GetColumnKey(i)
            If UCase(Trim(sKey)) = "DESCRIPTION" Then
                For y = 1 To allSheets.Count
                    Set cSheet = allSheets(y)
                    formulas(lRow, i) = IIf(cSheet.SheetTitle <> "", cSheet.SheetTitle, cSheet.SheetName)
                    lRow = lRow + 1
                    For z = 1 To cSheet.CostCodes.Count
                        Set cc = cSheet.CostCodes(z)
                        formulas(lRow, i) = cc.Name
                        lRow = lRow + 1
                    Next
                Next
            ElseIf UCase(Trim(sKey)) = "ISSHEETROW" Then
                For y = 1 To allSheets.Count
                    Set cSheet = allSheets(y)
                    formulas(lRow, i) = "X"
                    lRow = lRow + 1 + cSheet.CostCodes.Count
                Next
            ElseIf UCase(Trim(sec.GetColumnSetting(i, "TotalColumn"))) = "TRUE" Then
                For y = 1 To allSheets.Count
                    Set cSheet = allSheets(y)
                    sFormat = sec.GetTemplateRowCell(i).NumberFormat
                    formulas(lRow, i) = "=TEXT(" & cSheet.GetColumnTotal(sKey) & "," & """" & sFormat & """" & ")"
                    lRow = lRow + 1
                    For z = 1 To cSheet.CostCodes.Count
                        Set cc = cSheet.CostCodes(z)
                        formulas(lRow, i) = cc.GetColumnTotal(sKey)
                        lRow = lRow + 1
                    Next
                Next
            End If
        Next
        sec.ItemRange.value = formulas
    End If

End Sub
Attribute VB_Name = "modCostCodeReport"

Public Sub FillCostCodeReport(sht As Worksheet, Optional sortCostCodes As Boolean = False)
    If IsConEdFile(sht) Then
        FillConEdSummaryReport sht, sortCostCodes
        Exit Sub
    End If
    
    Dim colCostCodes As Collection
    Set colCostCodes = GetAllCostCodes(sht.Parent)
    Dim cc As CCostCode
    
    Dim nm As Name
    On Error Resume Next
    Set nm = sht.names("SectionRange")
    
    If nm Is Nothing Then
        Set nm = sht.names("ReportList1")
    End If
    
    If Not nm Is Nothing Then
        If sortCostCodes Then
            'sort by name
        Else
            'sort by sheetindex
        End If
        Dim sec As ItemSection
        Set sec = New ItemSection
        sec.Init nm.RefersToRange, True
        
        sec.DeleteAllRows
        If colCostCodes.Count > 0 Then
            Dim sortValues() As Variant
            ReDim sortValues(1 To colCostCodes.Count, 1 To 2) As Variant
            
            For i = 1 To colCostCodes.Count
                Set sortValues(i, 1) = colCostCodes(i)
                If sortCostCodes Then
                    sortValues(i, 2) = colCostCodes(i).Name
                Else
                    sortValues(i, 2) = colCostCodes(i).SheetIndex
                End If
            Next
            
            If sortCostCodes Then
                QuickSort2D sortValues, 2
            End If
            
            Dim colTemp As Collection
            Set colTemp = New Collection
            For i = 1 To colCostCodes.Count
                colTemp.Add sortValues(i, 1)
            Next
            
            Set colCostCodes = colTemp
            
            sec.AddMultipleRows colCostCodes.Count
            
            'CostCode,Name/Description,Amount,AllowanceAmount,OptionAmount
            
            Dim values() As Variant
            sec.Init sec.Range, True
            
            ReDim values(1 To colCostCodes.Count, 1 To 1) As Variant
            If sec.ColumnExists("CostCode") Then
                
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.Name
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("CostCode")).value = values
            End If
            If sec.ColumnExists("Description") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.Name
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("Description")).value = values
            End If
            If sec.ColumnExists("SectionName") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.SheetName
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("SectionName")).value = values
            End If
            If sec.ColumnExists("Amount") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.Amount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("Amount")).value = values
            End If
             If sec.ColumnExists("Total") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.Amount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("Total")).value = values
            End If
             If sec.ColumnExists("TotalCost") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.Amount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("TotalCost")).value = values
            End If
            
            
            'CostCode,Name/Description,Amount,AllowanceAmount,OptionAmount
            If sec.ColumnExists("AllowanceAmount") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.AllowanceAmount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("AllowanceAmount")).value = values
            End If
             If sec.ColumnExists("AllowanceTotal") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.AllowanceAmount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("AllowanceTotal")).value = values
            End If
             If sec.ColumnExists("OptionsAmount") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.OptionAmount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("OptionsAmount")).value = values
            End If
             If sec.ColumnExists("OptionsTotal") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.OptionAmount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("OptionsTotal")).value = values
            End If
            If sec.ColumnExists("OptionAmount") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.OptionAmount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("OptionAmount")).value = values
            End If
             If sec.ColumnExists("OptionTotal") Then
                For i = 1 To colCostCodes.Count
                    Set cc = colCostCodes(i)
                    values(i, 1) = cc.OptionAmount
                Next
                sec.ItemRange.Columns(sec.GetColumnIndex("OptionTotal")).value = values
            End If
        End If
    End If
End Sub


Public Function ValueInCollection(col As Collection, strValue As String) As Boolean
    Dim i As Long
    For i = 1 To col.Count
        If UCase(Trim(strValue)) = UCase(Trim(col(i))) Then
            ValueInCollection = True
            Exit For
        End If
    
    Next

End Function


Public Function GetAllCostCodes(wb As Workbook, Optional costcodeColumnKey As String = "CostCode", Optional groupBySheets As Boolean = False) As Collection
    Dim secs As Collection
    Dim sectionKeys As Collection
    Set sectionKeys = New Collection
    sectionKeys.Add "EstimateItems"
    
    
    Dim shtsToIgnore As Collection
    Set shtsToIgnore = SheetsToIgnore(wb)

    Set secs = GetAllSectionsWithNames(wb, sectionKeys)
    
    'remove sections that are turned off on summary
    
    On Error Resume Next
    Dim s As ItemSection
    Dim y As Long
    Dim v As Variant
    Dim codeIndex As Long
    Dim totalIndex As Long
    Dim specIndex As Long
    Dim allowanceIndex As Long
    Dim descIndex As Long
    Dim optionIndex As Long
    Dim isQuoteIndex As Long
    Dim noteIndex As Long
    
    Dim strCostCode As String
    Dim cc As CCostCode
                    
    Dim colCostCodes As Collection
    Set colCostCodes = New Collection
    Dim bAddRow As Boolean
    Dim bIsAllowance As Boolean
    Dim bIsSpec As Boolean
    Dim bIsOption As Boolean
    Dim useColumnIndex As Long
    Dim optionCostIndex As Long
    Dim baseCostIndex As Long
    
    
    Dim secRow As ItemSectionRow
    Dim allSheets As Collection
    Dim sSheet As CSheetCostCodes
    
    Set allSheets = New Collection
    
    For i = 1 To secs.Count
        Set s = secs(i)
        If s.ColumnExists(costcodeColumnKey) = True And (s.ColumnExists("Total") Or s.ColumnExists("TotalCost")) And _
        ValueInCollection(shtsToIgnore, s.Range.Worksheet.Name) = False Then
            If groupBySheets Then
                Set sSheet = New CSheetCostCodes
                sSheet.Init s.Range.Worksheet
                allSheets.Add sSheet
                Set sSheet.CostCodes = New Collection
                Set colCostCodes = sSheet.CostCodes
            End If
        
            codeIndex = s.GetColumnIndex(costcodeColumnKey)
            
            If s.ColumnExists("Total") Then
                totalIndex = s.GetColumnIndex("Total")
            Else
                totalIndex = s.GetColumnIndex("TotalCost")
            End If
            specIndex = s.GetColumnIndex("IsSpec")
            allowanceIndex = s.GetColumnIndex("Allowance")
            descIndex = s.GetColumnIndex("Description")
            optionIndex = s.GetColumnIndex("IsOption")
            noteIndex = s.GetColumnIndex("Note")
            optionCostIndex = s.GetColumnIndex("OptionCost")
            baseCostIndex = s.GetColumnIndex("BaseCostTotal")
            
            If optionIndex = 0 Then
                optionIndex = s.GetColumnIndex("IsOptionItem")
            End If
            
            If s.ColumnExists("Use") Then
                useColumnIndex = s.GetColumnIndex("Use")
            Else
                useColumnIndex = -1
            End If
            
            For y = 2 To s.rowCount - 1
                v = s.value(y, totalIndex)
                strCostCode = Trim(s.value(y, codeIndex))
                Set cc = Nothing
                bAddRow = True
                bIsAllowance = False
                bIsSpec = False
                bIsOption = False
                
                If useColumnIndex > 0 Then
                    If s.value(y, useColumnIndex) = "" Then
                        bAddRow = False
                    End If
                End If
                If specIndex > 0 Then
                    If s.value(y, specIndex) <> "" Then
                        'if there is a value in the spec row, then include it
                        'bAddRow = False
                    End If
                End If
                If allowanceIndex > 0 Then
                    If s.value(y, allowanceIndex) <> "" Then
                        bIsAllowance = True
                    End If
                End If
                If optionIndex > 0 Then
                    If s.value(y, optionIndex) <> "" Then
                        bIsOption = True
                    End If
                End If
                If s.IsHeaderRow(y) Then
                    bAddRow = False
                End If
                    
                If bAddRow Then
                    Set secRow = New ItemSectionRow
                    secRow.IsOption = bIsOption
                    secRow.IsAllowance = bIsAllowance
                    
                   
                    If optionCostIndex > 0 Then
                        Dim option1 As Variant
                        option1 = s.value(y, optionCostIndex)
                        If option1 <> 0 Then
                            secRow.OptionCostTotal = secRow.OptionCostTotal + CDbl(option1)
                        End If
                    End If
                    If baseCostIndex > 0 Then
                        Dim base1 As Variant
                        base1 = s.value(y, baseCostIndex)
                        If base1 <> 0 Then
                            secRow.BaseCostTotal = secRow.BaseCostTotal + CDbl(base1)
                        End If
                    End If
                    If IsNumeric(v) Then
                        If v <> 0 Then
                            secRow.Total = CDbl(v)
                        End If
                    End If
                    Set secRow.Section = s
                    secRow.Row = y
                    secRow.Description = s.value(y, descIndex)
                    If noteIndex > 0 Then secRow.Note = s.value(y, noteIndex)
                    
       
                    If bAddRow Then
                    'If secRow.IsValidRow Then
                        Set cc = colCostCodes(UCase(strCostCode))
                        If cc Is Nothing Then
                            Set cc = New CCostCode
                            cc.Name = strCostCode
                            colCostCodes.Add cc, UCase(strCostCode)
                            cc.SheetName = s.Range.Worksheet.Name
                            cc.SheetIndex = s.Range.Worksheet.Index
                            
                        End If
                        
                        cc.SectionRows.Add secRow

                    End If
                    
                End If
            Next
        End If
    Next
    
    Dim totalRowCount As Long
    For i = 1 To colCostCodes.Count
        Set cc = colCostCodes(i)
        cc.CalculateProperties
    Next
    
    For i = colCostCodes.Count To 1 Step -1
        Set cc = colCostCodes(i)
        If Trim(cc.Name) = "" Then
            If cc.AllowanceAmount = 0 And cc.OptionAmount = 0 And cc.Amount = 0 Then
                colCostCodes.Remove i
            End If
        End If
    Next
    If groupBySheets Then
        Set GetAllCostCodes = allSheets
    Else
        Set GetAllCostCodes = colCostCodes
    End If
End Function

Public Function SheetsToIgnore(wb As Workbook) As Collection
    Dim sht As Workbook
    Dim sec As ItemSection
    
    Dim nm As Name
    
    Dim col As Collection
    Set col = New Collection
    Dim i As Long
    Dim y As Long
    
    On Error Resume Next
    Set nm = wb.names("Summary")
    If Not nm Is Nothing Then
        Set sec = New ItemSection
        sec.Init nm.RefersToRange, True
        
        
        Dim useColumn As Long
        Dim totalColumn As Long
        Dim sheetNameColumn As Long
        Dim isSubPhaseColumn As Long
        
        If sec.ColumnExists("Use") Then useColumn = sec.GetColumnIndex("Use")
        If sec.ColumnExists("SheetName") Then sheetNameColumn = sec.GetColumnIndex("SheetName")
        If sec.ColumnExists("EstimateSheetTotal") Then totalColumn = sec.GetColumnIndex("EstimateSheetTotal")
        If sec.ColumnExists("IsSubPhase") Then isSubPhaseColumn = sec.GetColumnIndex("IsSubPhase")
        
        Dim cell As Range
        Dim linkedSheets As Collection
        If useColumn > 0 And (sheetNameColumn > 0 Or totalColumn > 0) Then
            For i = 2 To sec.rowCount - 1
                If sec.value(i, useColumn) = "" And IsSubPhaseRow(sec, i, isSubPhaseColumn) = False Then
                    If sheetNameColumn > 0 Then
                        Set cell = Nothing
                        Set cell = sec.GetCell("SheetName", i)
                        If Not cell Is Nothing Then
                            Set linkedSheets = Nothing
                            If CellLinkedToEstimateSheet(cell, linkedSheets) Then
                                'remove the section
                                For y = 1 To linkedSheets.Count
                                    col.Add linkedSheets(y), linkedSheets(y)
                                Next
                            End If
                        End If
                    End If
                    If totalColumn > 0 Then
                        Set cell = Nothing
                        Set cell = sec.GetCell("EstimateSheetTotal", i)
                        If Not cell Is Nothing Then
                            Set linkedSheets = Nothing
                            If CellLinkedToEstimateSheet(cell, linkedSheets) Then
                                'remove the section
                                For y = 1 To linkedSheets.Count
                                    col.Add linkedSheets(y), linkedSheets(y)
                                Next
                            End If
                        End If
                    End If
                End If
            Next
        End If
    End If
    Set SheetsToIgnore = col
End Function

Private Function IsSubPhaseRow(sec As ItemSection, lRow As Long, lIsSubPhaseColumn As Long) As Boolean
    If lIsSubPhaseColumn > 0 Then
        If sec.value(lRow, lIsSubPhaseColumn) <> "" Then
            IsSubPhaseRow = True
        End If
    End If
End Function
Public Function CellLinkedToEstimateSheet(cell As Range, Optional outLinkedToSheets As Collection) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim col As Collection
    Dim outCol As Collection
    Dim i As Long
    Dim rng As Range
    Dim wkbk As Workbook
    Dim nm As Name
     
    'Set rng = summarySection.ItemsRange
    If cell.HasFormula = False Then Exit Function
    
    Set col = GetSheetNamesInFormula(cell.Formula)
    Set wkbk = cell.Worksheet.Parent
    Set outCol = New Collection
    Dim sht As Worksheet
    If outLinkedToSheets Is Nothing Then Set outLinkedToSheets = New Collection
    For i = 1 To col.Count
        Set sht = Nothing
        If SheetExists(col(i), wkbk) Then
            Set sht = wkbk.Worksheets(col(i))
            Set nm = Nothing
            If Not sht Is Nothing Then
                If IsEstimateSheet(sht) Then
                    outLinkedToSheets.Add col(i)
                    CellLinkedToEstimateSheet = True
                End If
            End If
        End If
    Next
End Function
Public Function SheetExists(sName As String, wb As Workbook) As Boolean
    On Error Resume Next
    Dim sht As Worksheet
    Set sht = wb.Worksheets(sName)
    If Not sht Is Nothing Then SheetExists = True
End Function
Public Function IsEstimateSheet(sht As Worksheet) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim nm As Name
    
    On Error Resume Next
    If Not sht Is Nothing Then
        Set nm = sht.names("EstimateItems")
        If Not nm Is Nothing Then
            IsEstimateSheet = True
        End If
    End If
End Function
Public Function GetSheetNamesInFormula(Formula As String, Optional origCollection As Collection = Nothing, _
    Optional excludeSheetName As String) As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim col As Collection, Start As Long, cnt As Long
    Dim i As Long, y As Long, findApostrophe As Boolean
    Dim shtName As String
    Dim char As String, charFound As Boolean
    
    If origCollection Is Nothing Then
        Set col = New Collection
    Else
        Set col = origCollection
    End If
    
    Start = 1
    
    On Error Resume Next
    
    Dim pf As ParseFormula
    Set pf = New ParseFormula
    
    Dim refs As FormulaReferences
    Set refs = pf.GetFormulaReferencesFromText(Formula, False)
    
    Dim ref As FormulaReference
    
    For i = 1 To refs.Count
        Set ref = refs.Item(i)
        If ref.SheetName <> "" Then col.Add ref.SheetName, ref.SheetName
    Next
    Set GetSheetNamesInFormula = col
End Function



Function GetAllSectionsWithNames(wb As Workbook, namedRanges As Collection) As Collection
    Dim nm As Name
    Dim i As Long
    
    Dim sName As String
    Dim s As ItemSection
    Dim colSections As Collection
    Set colSections = New Collection
    
    Dim colNames As Collection
    Set colNames = New Collection
    For i = 1 To namedRanges.Count
        colNames.Add 1, UCase(Trim(namedRanges(i)))
    Next
    
    On Error Resume Next
    Dim v As Variant
    Dim tempRng As Range
    
    For i = 1 To wb.Worksheets.Count
        For y = 1 To namedRanges.Count
            Set nm = Nothing
            Set nm = wb.Worksheets(i).names(namedRanges(y))
            If Not nm Is Nothing Then
                Set s = New ItemSection
                Set tempRng = Nothing
                Set tempRng = nm.RefersToRange
                If Not tempRng Is Nothing Then
                
                s.Init nm.RefersToRange, True
                    colSections.Add s
                Else
    
                End If
            End If
        Next
    Next
    
'    For i = 1 To wb.names.Count
'        sName = ""
'        Set nm = wb.names(i)
'        sName = nm.Name
'        If InStr(1, sName, "!") > 0 Then
'            sName = Right(sName, Len(sName) - InStr(1, sName, "!"))
'        End If
'        v = ""
'        v = colNames(UCase(Trim(sName)))
'        If v = 1 Then
'            'add the name
'            Set s = New ItemSection
'            Set tempRng = Nothing
'            Set tempRng = nm.RefersToRange
'            If Not tempRng Is Nothing Then
'
'            s.Init nm.RefersToRange, True
'                colSections.Add s
'            Else
'
'            End If
'        End If
'    Next
    
    Set GetAllSectionsWithNames = colSections
End Function

Attribute VB_Name = "modPlanswift"
Sub MakeAllCostsYellow()
'    Dim sec As Section
'    Dim secs As SectionCollection
'    Set secs = New SectionCollection
'
'    secs.FillFromWorkbookSingle ThisWorkbook, "EstimateItems"
'
'    Dim i As Long
'    Dim y As Long
'
'    For Each sec In secs
'        Dim rng As Range
'        For i = 1 To sec.ItemCount
'            Set rng = sec.ItemsRange.Columns(sec.Columns("Cost").columnIndex)
'            For y = 1 To rng.Rows.Count
'                If rng.Cells(y, 1).Interior.ColorIndex = -4142 Then
'                    If rng.Cells(y, 1).Value <> 0 Then
'                        rng.Cells(y, 1).Interior.Color = 65535
'                    End If
'                End If
'            Next
'        Next
'    Next
End Sub

Public Sub SelectPlanswiftProperty()
    frmPlanswift.Show vbModeless
    frmPlanswift.Left = Application.Left + (Application.Width - frmPlanswift.Width) / 2
    frmPlanswift.Top = Application.Top + (Application.Height - frmPlanswift.Height) / 2
End Sub

Public Sub ImportPlanswiftValues()
    Dim pJob As Object ' PSJob
    
    Dim variablesRange As Range
    
    On Error Resume Next
    Set variablesRange = ActiveWorkbook.names("Variables").RefersToRange
    If variablesRange Is Nothing Then Exit Sub
    
    Dim sec As ItemSection
    Set sec = New ItemSection
    sec.Init variablesRange, True
    
    If sec.ColumnExists("PSVariableName") = False Or sec.ColumnExists("Value") = False Then
        MsgBox "Invalid project variables sheet, cannot add planswift variables to it."
        Exit Sub
    End If
    
    Dim rng As Range
    Set rng = sec.Range.Columns(sec.GetColumnIndex("PSVariableName")) ' ThisWorkbook.names("PlanswiftKeys").RefersToRange
    
    Dim rngValues As Range
    If sec.ColumnExists("BaseValue") Then
        Set rngValues = sec.Range.Columns(sec.GetColumnIndex("BaseValue")) ' ThisWorkbook.names("PlanswiftValues").RefersToRange
    Else
        Set rngValues = sec.Range.Columns(sec.GetColumnIndex("Value")) ' ThisWorkbook.names("PlanswiftValues").RefersToRange
    End If
    
    Dim sItemName As String
    Dim sItemProperty As String
    Dim values() As String
    Dim colItems As Collection
    Dim pItem As PSItem
    Dim pProperty As PSItemProperty
    
    If Not rng Is Nothing And Not rngValues Is Nothing Then
        Set pJob = GetPlanswiftJob
        If pJob Is Nothing Then
            MsgBox "Error communcating with Planswift." & vbCrLf & vbCrLf & _
            "Make sure a job is open in Planswift!" & vbCrLf & "If Planswift is open, then close and reopen it."
            Exit Sub
        End If
        
        Dim colMultipleItems As Collection
        Dim colNotFoundItems As Collection
        
        Dim colNotFoundItemValues As Collection
        Dim colMultipleItemValues As Collection
        
        Set colMultipleItems = New Collection
        Set colNotFoundItems = New Collection
        
        Set colMultipleItemValues = New Collection
        Set colNotFoundItemValues = New Collection
        
        
        For i = 1 To rng.rows.Count
            If rng.Cells(i, 1).value <> "" Then
                If InStr(1, rng.Cells(i, 1).value, ":") Then
                    values = Split(rng.Cells(i, 1).value, ":")
                    sItemName = values(0)
                    sItemProperty = values(1)
                    
                    'find the item's property value
                    Set colItems = pJob.GetItem(sItemName)
                    
                    If colItems.Count = 0 Then
                        'not found
                        rng.Cells(i, 1).Interior.ColorIndex = 36
                        colNotFoundItems.Add sItemName & "  (Not Found)"
                        colNotFoundItemValues.Add Application.Intersect(rngValues, rng.Cells(i, 1).EntireRow)
                    Else
                        Dim dValue As Double
                        Dim dText As String
                        Dim dValueFound As Boolean
                        Dim dTextFound As Boolean
                        
                        dValue = 0
                        dText = ""
                        For y = 1 To colItems.Count
                            If rng.Cells(i, 1).Interior.ColorIndex = 36 Or rng.Cells(i, 1).Interior.ColorIndex = 3 Then
                                rng.Cells(i, 1).Interior.ColorIndex = xlAutomatic
                            End If
                            Set pItem = colItems(y)
                            Set pProperty = pItem.GetProperty(sItemProperty)
                            If Not pProperty Is Nothing Then
                                If IsNumeric(pProperty.value) Then
                                    dValue = dValue + CDbl(pProperty.value)
                                    dValueFound = True
                                Else
                                    If dText <> pProperty.value Then
                                        dText = dText & IIf(dText = "", "", ", ") & pProperty.value
                                        dTextFound = True
                                    End If
                                End If
                            End If
                        Next
                        If dValueFound Then
                            Application.Intersect(rngValues, rng.Cells(i, 1).EntireRow).value = dValue
                            rng.Cells(i, 1).Interior.ColorIndex = 35
                        ElseIf dTextFound Then
                            Application.Intersect(rngValues, rng.Cells(i, 1).EntireRow).value = dText
                            rng.Cells(i, 1).Interior.ColorIndex = 35
                        Else
                            rng.Cells(i, 1).Interior.ColorIndex = 36
                            colNotFoundItems.Add sItemName & ":" & sItemProperty & "  ('" & sItemProperty & "' Property Not Found)"
                            colNotFoundItemValues.Add Application.Intersect(rngValues, rng.Cells(i, 1).EntireRow)
                        End If
                    'Else
                        'more than 1 item in Planswift with the same name
                        'rng.Cells(i, 1).Interior.ColorIndex = 3 'red
                        'rng.Cells(i, 1).Interior.ColorIndex = 36
                        'colMultipleItems.Add sItemName & ":" & sItemProperty & "  (Multiple Items in Planswift with same name)"
                    End If
                End If
            End If
        Next
        
        If colMultipleItems.Count > 0 Or colNotFoundItems.Count > 0 Then
            Dim msg As String
            msg = "Warning! There was an error updating the following items: " & vbCrLf & vbCrLf
            If colNotFoundItems.Count > 0 Then
                'msg = msg & vbCrLf & vbCrLf & "ITEMS NOT FOUND IN PLANSWIFT [Yellow Cells]" & vbCrLf & vbCrLf
                For i = 1 To colNotFoundItems.Count
                    msg = msg & " -" & colNotFoundItems(i) & vbCrLf
                Next
            End If
            
            If colMultipleItems.Count > 0 Then
                'msg = msg & vbCrLf & vbCrLf & "MULTIPLE ITEMS IN PLANSWIFT WITH SAME NAME [Red Cells]" & vbCrLf & vbCrLf
                For i = 1 To colMultipleItems.Count
                    msg = msg & " -" & colMultipleItems(i) & vbCrLf
                Next
                
            End If
            
            MsgBox msg
            
            Dim cellValue As Range
            If colNotFoundItemValues.Count > 0 Then
                If vbYes = MsgBox("Would you like to clear the values for the items not found?", vbYesNo, "Clear Variables") Then
                    For i = 1 To colNotFoundItemValues.Count
                        Set cellValue = colNotFoundItemValues(i)
                        If cellValue.value <> "" Then
                            If cellValue.HasFormula = False Then
                                cellValue.value = ""
                            End If
                        End If
                    Next
                End If
            End If
        End If
    End If
End Sub



Public Function GetPlanswiftJob() As PSJob
    Dim ps As Object 'PlanSwift9.PlanSwift
    
    On Error Resume Next
    Set ps = GetObject(, "PlanSwift9.PlanSwift")
    
    Dim job As PSJob
    Dim jobItem As Object 'PlanSwift9.Item
    Dim takeOffItem As Object 'PlanSwift9.Item
    Dim rootItem As Object 'PlanSwift9.Item
    
      
    Dim i As Long
    Dim y As Long
    
    Dim pItem As PSItem
    Dim pItems As Collection
    Set pItems = New Collection
      
    If Not ps Is Nothing Then
        If ps.IsJobOpen Then
            Set rootItem = ps.Root
            
            
            Set jobItem = ps.GetItem("Job")
            Set takeOffItem = ps.GetItem("\Job\Takeoff")
            LoadTakeOffItems takeOffItem, pItems
            
'            For i = 0 To takeOffItem.ChildCount - 1
'                Set pSubItem = takeOffItem.ChildItem(i)
'                Set pItem = New PSItem
'                pItem.Init pSubItem
'                pItems.Add pItem
'            Next
            Set job = New PSJob
            job.JobName = jobItem.GetPropertyResultAsString("Name")
            job.JobDescription = jobItem.GetPropertyResultAsString("Description")
            Set job.Items = pItems
        End If
    End If
    
    Set GetPlanswiftJob = job
End Function


Private Function LoadTakeOffItems(takeOffItem As Object, colItems As Collection)
    Dim i As Long
    Dim pSubItem As Object 'PlanSwift9.Item
    'Dim pSubItem As PlanSwift9.Item
    Dim pItem As PSItem
    Debug.Print takeOffItem.ChildCount
    For i = 0 To takeOffItem.ChildCount - 1
        Set pSubItem = takeOffItem.ChildItem(i)
        If pSubItem.GetProperty("Type").ResultAsString = "Folder" Then
            'LoadTakeOffItems pSubItem, colItems
        Else
            If pSubItem.GetPropertyResultAsBoolean("IsItem", False) Then
                Set pItem = New PSItem
                pItem.Init pSubItem
                colItems.Add pItem
            End If
            If pSubItem.ChildCount > 0 Then
                'LoadTakeOffItems pSubItem, colItems
            End If
        End If
    Next
End Function




Attribute VB_Name = "modReports"



Public Function ApplyColumnFilters(values() As Variant, sec As ItemSection, infoColumn As Long, headerIndicatorColumn As Long) As Variant()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim arr As CFilteredArray
    Dim f As CFilter
    Dim val As Variant
    Dim op As Long
    Dim typ As Long
    Dim nm As Name
    Dim strTemp As String
    Dim newValue As String
    'Dim c As SectionColumn
    Dim i As Long
    Dim y As Long
    
    Set arr = New CFilteredArray
    arr.ItemArray = values
    
    Dim sF As CFilter
    
    For i = 1 To sec.columnCount
        If sec.GetTemplateRowCell(i).Formula = "" Then
            Set sF = Nothing
            Set sF = sec.GetColumnFilter(i)
            If Not sF Is Nothing Then

                Set f = New CFilter
                For y = 1 To sF.ConditionCount
                    sF.GetCondition y, val, op, typ
                    
                    If TypeName(val) = "String" Then
                        strTemp = Trim(CStr(val))
                        If Left(strTemp, 1) = "[" Then
                            newValue = ""
                            If FindNameValue(sec.Range.Worksheet, strTemp, newValue) = True Then
                                val = newValue
                            End If
                        End If
                    End If
                    f.AddCondition op, CStr(val), typ
                Next
                arr.AddFilter i, f
            End If
            
        End If
    Next
    On Error Resume Next
    
 
    
    
    If arr.FilterCount > 0 Then arr.ApplyFilters infoColumn, headerIndicatorColumn
    ApplyColumnFilters = arr.ItemArray
End Function
Private Function FindNameValue(sht As Worksheet, strName As String, outValue As String) As Boolean
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim nm As Name
    Dim str As String
    On Error Resume Next
    str = strName
    If Left(str, 1) = "[" Then str = Right(str, Len(str) - 1)
    If Right(str, 1) = "]" Then str = Left(str, Len(str) - 1)
                        
    Set nm = sht.names(str)
    If nm Is Nothing Then Set nm = sht.Parent.names(str)
    If Not nm Is Nothing Then
        Err.Clear
        outValue = nm.RefersToRange.value
        If Err = 0 Then
            FindNameValue = True
        End If
    End If
End Function
Public Sub PrepareSortGroupAndTotalColumns(sec As ItemSection, g As CGroup)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim c As Long
    
    'Sort
    Dim cols As Collection
    'Dim c As SectionColumn
    Set cols = GetSortColumns(sec)
    For i = 1 To cols.Count
        c = cols(i)
    
        If UCase(Trim(sec.GetColumnSetting(c, "Sort"))) = "DESCENDING" Then
            g.AddSortColumn c, ESortOrder.SortDescending_e
        Else
            g.AddSortColumn c, ESortOrder.SortAscending_e
        End If
    Next
    
    'Grouping
    Set cols = GetGroupColumns(sec)
    For i = 1 To cols.Count
        c = cols(i)
    
        If UCase(Trim(sec.GetColumnSetting(c, "GroupSort"))) = "NONE" Then
            g.AddGroupColumn c, NoSort_e
        ElseIf UCase(Trim(sec.GetColumnSetting(c, "GroupSort"))) = UCase("DESCENDING") Then
            g.AddGroupColumn c, SortDescending_e
        Else
            g.AddGroupColumn c, SortAscending_e
        End If
    Next
    
    'Total Rows
    Set cols = GetTotalColumns(sec)
    For i = 1 To cols.Count
        c = cols(i)
        If sec.GetColumnSetting(c, "TotalFunction") = "" Or UCase(Trim(sec.GetColumnSetting(c, "TotalFunction"))) = "SUM" Then
            g.AddTotalColumn c
        End If
    Next
End Sub
Public Function GetTotalColumns(sec As ItemSection) As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim col As Collection
    Dim i As Long
    Set col = New Collection
    For i = 1 To sec.columnCount
        
        If UCase(Trim(sec.GetColumnSetting(i, "TotalColumn"))) = "TRUE" Then
            col.Add i
        End If
    Next
    Set GetTotalColumns = col
End Function
Public Function GetGroupColumns(sec As ItemSection) As Collection
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim col As Collection
    Dim i As Long
    Set col = New Collection
    Dim cIndex As Long
    
    Dim columnIndexes As Collection
    Dim groupIndexes As Collection
    
    Set columnIndexes = New Collection
    Set groupIndexes = New Collection
    For i = 1 To sec.columnCount
        If sec.GetColumnSetting(i, "GroupColumn") <> "" And UCase(sec.GetColumnSetting(i, "GroupColumn")) <> "FALSE" Then
        'If cols(i).GroupColumn <> "" And UCase(cols(i).GroupColumn) <> "FALSE" Then
            cIndex = 1000
            If sec.GetColumnSetting(i, "GroupIndex") <> "" Then cIndex = CLng(sec.GetColumnSetting(i, "GroupIndex"))
            columnIndexes.Add i
            groupIndexes.Add cIndex
        End If
    Next
    If columnIndexes.Count > 1 Then
        Dim values() As Variant
        ReDim values(1 To columnIndexes.Count, 1 To 2) As Variant
        For i = 1 To columnIndexes.Count
            values(i, 2) = columnIndexes(i)
            values(i, 1) = groupIndexes(i)
        Next
        QuickSort2D values, 1
        
        Set columnIndexes = New Collection
        For i = 1 To UBound(values)
            columnIndexes.Add values(i, 2)
        Next
    End If
    
    For i = 1 To columnIndexes.Count
        col.Add columnIndexes(i)
    Next
    Set GetGroupColumns = col
End Function
Public Function GetSortColumns(sec As ItemSection) As Collection
    On Error Resume Next
    Dim col As Collection
    Dim i As Long
    Set col = New Collection
    Dim cIndex As Long
    
    Dim columnIndexes As Collection
    Dim groupIndexes As Collection
    Set columnIndexes = New Collection
    Set groupIndexes = New Collection
    For i = 1 To sec.columnCount
        If sec.GetColumnSetting(i, "Sort") <> "" Then
        'If cols(i).GroupColumn <> "" And UCase(cols(i).GroupColumn) <> "FALSE" Then
            cIndex = 1000
            If sec.GetColumnSetting(i, "SortIndex") <> "" Then cIndex = CLng(sec.GetColumnSetting(i, "SortIndex"))
            columnIndexes.Add i
            groupIndexes.Add cIndex
        End If
    Next
    If columnIndexes.Count > 1 Then
        Dim values() As Variant
        ReDim values(1 To columnIndexes.Count, 1 To 2) As Variant
        For i = 1 To columnIndexes.Count
            values(i, 2) = columnIndexes(i)
            values(i, 1) = groupIndexes(i)
        Next
        QuickSort2D values, 1
        
        Set columnIndexes = New Collection
        For i = 1 To UBound(values)
            columnIndexes.Add values(i, 2)
        Next
    End If
    
    For i = 1 To columnIndexes.Count
        col.Add columnIndexes(i)
    Next
    Set GetSortColumns = col
End Function

Public Function GetValuesInColumns(sec As ItemSection, values As SectionGroupValues, outInfoCol As Long, includeHeaders As Boolean, outHeaderIndicatorColumn As Long) As Variant()
                                '<CSCustomCode> 1
                                On Error Resume Next
                                '</CSCustomCode> 1
                                
    Dim origValues As Variant
    Dim colCount As Long
    Dim colValues() As Variant
    Dim keys As Collection
    Dim colIndex As Long
    Dim tempColIndex As Long
    Dim qtyCol As Long
    Dim estQtyCol As Long
    Dim descCol As Long
    Dim i As Long, y As Long, z As Long
    
    
    On Error Resume Next
    descCol = sec.GetColumnIndex("Description")
    qtyCol = sec.GetColumnIndex("Qty")
    estQtyCol = sec.GetColumnIndex("EstQty")
    
    origValues = values.values
    Set keys = New Collection
    For i = 1 To sec.columnCount
        keys.Add sec.GetColumnKey(i)
        'Set keys = sec.Columns.GetColumnKeys
    Next
    
    'make sure there is always an info column
    If sec.ColumnExists("Info") = False Then
        keys.Add "Info"
        outInfoCol = keys.Count
    Else
        outInfoCol = sec.GetColumnIndex("Info")
    End If
    
    'make sure there is always a header indicator column
    If sec.ColumnExists("HeaderIndicator") = False Then
        keys.Add "HeaderIndicator"
        outHeaderIndicatorColumn = keys.Count
    Else
        outHeaderIndicatorColumn = sec.GetColumnIndex("HeaderIndicator")
    End If
    
    ReDim colValues(1 To UBound(origValues), 1 To keys.Count)
    
    Dim otherKeys As Collection
    Dim colHasFormula As Boolean
    
    For i = 1 To keys.Count
        'get the column index in the original values
        colIndex = GetColumnIndex(keys(i), values)
        Set otherKeys = Nothing
        Set otherKeys = New Collection
        
        If sec.GetTemplateRowCell(i).Formula <> "" Then
            If Left(sec.GetTemplateRowCell(i).Formula, 1) = "=" Then colHasFormula = True
        End If
        'If sec.Columns(keys(i)).Formula <> "" Then colHasFormula = True
        
        If colIndex > 0 Then
            If otherKeys.Count > 1 Then
                For y = 1 To UBound(colValues)

                    'if the value is empty see if one of the other columns keys contains a value
                    If IsError(origValues(y, colIndex)) = True Then
                        'do nothing
                    ElseIf IsEmpty(origValues(y, colIndex)) = True Then
                        For z = 1 To otherKeys.Count
                            tempColIndex = 0
                            If values.Columns.ColumnKeyExists(otherKeys(z)) = True Then
                                tempColIndex = values.Columns.Item(otherKeys(z)).Index
                            End If
                            If tempColIndex > 0 Then
                                If IsEmpty(origValues(y, tempColIndex)) = False Then
                                    colValues(y, i) = origValues(y, tempColIndex)
                                    Exit For
                                End If
                            End If
                        Next
                    Else
                        colValues(y, i) = origValues(y, colIndex)
                    End If
                Next
            Else
                For y = 1 To UBound(colValues)
                    If IsError(origValues(y, colIndex)) = False Then
                        colValues(y, i) = origValues(y, colIndex)
                    End If
                Next
            End If
            

        End If
    Next
    
    Dim ps As ParseFormula
    Dim strFormula As String
    Dim sht As Worksheet
    Dim v As Variant
    Dim evalFormula As String
    Dim containsVariable As Boolean
    
    Set ps = New ParseFormula
    
    For i = 1 To keys.Count
        'check to see if there is a formula in the column
        If sec.GetColumnFormula(sec.GetColumnIndex(keys(i))) <> "" Then
            If sht Is Nothing Then Set sht = sec.Range.Worksheet
            strFormula = sec.GetColumnFormula(sec.GetColumnIndex(keys(i)))
            containsVariable = False
            For y = 1 To keys.Count
                If InStr(1, strFormula, keys(y), vbTextCompare) > 0 Then
                    containsVariable = True
                End If
            Next

            If containsVariable Then
                For y = 1 To UBound(colValues)
                    'value is blank
                    'If IsEmpty(colValues(y, i)) = True Then
                    If colValues(y, i) = "" Or CStr(colValues(y, i) = "0") Then
                        'calculate the formula value
                        Dim rowValues As Collection
                        Set rowValues = New Collection
                        For z = 1 To keys.Count
                            If IsNumeric(colValues(y, z)) = True Then

                                rowValues.Add colValues(y, z)
                            Else
                                rowValues.Add """" & colValues(y, z) & """"
                            End If
                        Next
                        evalFormula = ps.ReplaceNamesInFormula(strFormula, keys, rowValues)

                        v = sht.Evaluate(evalFormula)
                        If IsError(v) = False Then
                            colValues(y, i) = v
                        End If
                    End If
                Next
            End If
        End If
    Next
    
'    Next
    GetValuesInColumns = colValues
End Function
Private Function GetColumnIndex(strKey As String, values As SectionGroupValues)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    For i = 1 To values.Columns.Count
        If UCase(Trim(values.Columns.Item(i).key)) = UCase(Trim(strKey)) Then
            GetColumnIndex = i
            Exit For
        End If
    Next
End Function

Public Function GetWorkbookSections(wb As Workbook, sSectionName As String) As Collection
    Dim col As Collection
    Set col = New Collection
    
    Dim i As Long
    
    Dim nm As Name
    Dim strName As String
    Dim rng As Range
    Dim sec As ItemSection
    
    Dim shtsToIgnore As Collection
    
    If sSectionName = "EstimateItems" Then
        Set shtsToIgnore = SheetsToIgnore(wb)
    End If
    
    
    Dim sht As Worksheet
    On Error Resume Next
    Dim bAddSec As Boolean
    For i = 1 To wb.Worksheets.Count
    'For Each nm In wb.names
        Set nm = Nothing
        Set sht = wb.Worksheets(i)
        Set nm = sht.names(sSectionName)
        If Not nm Is Nothing Then
            'strName = RemoveSheetName(nm.Name)
            'If UCase(Trim(strName)) = UCase(Trim(sSectionName)) Then
            Set rng = Nothing
            Set rng = nm.RefersToRange
            bAddSec = True
            If Not rng Is Nothing Then
                If Not shtsToIgnore Is Nothing Then
                    If ValueInCollection(shtsToIgnore, sht.Name) Then
                        bAddSec = False
                    End If
                End If
                If bAddSec Then
                    Set sec = New ItemSection
                    sec.Init rng, True
                    col.Add sec
                End If
            End If
        End If
    Next
    
    'look for workbook names as well
    For Each nm In wb.names
        strName = nm.Name
        If UCase(Trim(strName)) = UCase(Trim(sSectionName)) Then
            Set rng = Nothing
            Set rng = nm.RefersToRange
            If Not rng Is Nothing Then
                Set sec = New ItemSection
                sec.Init rng, True
                col.Add sec
            End If
        End If
    Next
    
    Set GetWorkbookSections = col
End Function
Public Sub ClearGroups(rng As Range)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    On Error Resume Next
    'clears up to 6 levels of groups
    rng.EntireRow.Ungroup
    rng.EntireRow.Ungroup
    rng.EntireRow.Ungroup
    rng.EntireRow.Ungroup
    rng.EntireRow.Ungroup
    rng.EntireRow.Ungroup
End Sub
Public Function GetFirstVisibleColumn(sec As ItemSection) As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim rng As Range
    
    Set rng = sec.Range
    For i = 1 To rng.Columns.Count
        If rng.Columns(i).EntireColumn.Hidden = False Then
            GetFirstVisibleColumn = i
            Exit For
        End If
    Next
End Function
Public Sub ClearReportPictures(sht As Worksheet)
    On Error Resume Next
    Dim i As Long
    Dim sh As Excel.Shape
    On Error Resume Next
    For Each sh In sht.Shapes
        If UCase(Left(sh.Name, 13)) = "REP ORTPICTURE" Then
            sh.Delete
        End If
    Next
End Sub
Public Function RemoveSheetName(str As String) As String
    If InStr(1, str, "!") Then
        RemoveSheetName = Right$(str, Len(str) - InStr(1, str, "!"))
    Else
        RemoveSheetName = str
    End If
End Function


Private Function FileNameOnly(strPath As String) As String
    If InStr(1, strPath, "\") > 0 Then
        FileNameOnly = Trim(Right(strPath, Len(strPath) - InStrRev(strPath, "\")))
    Else
        FileNameOnly = strPath
    End If
End Function
Private Function InternalIsWorkBookOpen(wkbkName As String) As Boolean
    Dim wkbk As Workbook
    On Error Resume Next
   
    Set wkbk = Application.Workbooks(wkbkName)
    If Not wkbk Is Nothing Then InternalIsWorkBookOpen = True
End Function
Private Function FileExists(FileName As String) As Boolean
    Dim vFlag As Variant
    
    On Error Resume Next
    vFlag = Dir(FileName)
    
    If Err <> 0 Then
        Exit Function
    End If
    
    If Not IsNull(vFlag) Then
        If Len(vFlag) > 0 Then
            FileExists = True
        End If
    End If
End Function
Attribute VB_Name = "modSortSearch"
Option Explicit

'returns -1 if not found
'list must be sorted (doesn't matter is ascending or descending)
Function BinarySearchString(arr() As String, search As Variant, _
    Optional lastEl As Variant) As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim Index As Long
    Dim first As Long
    Dim last As Long
    Dim middle As Long
    Dim inverseOrder As Boolean
    
    ' account for optional arguments
    If IsMissing(lastEl) Then lastEl = UBound(arr)
    
    first = LBound(arr)
    last = lastEl

    ' deduct direction of sorting
    inverseOrder = (arr(first) > arr(last))

    ' assume searches failed
    BinarySearchString = first - 1
    
    Do
        middle = (first + last) \ 2
        If arr(middle) = search Then
            BinarySearchString = middle
            Exit Do
        ElseIf ((arr(middle) < search) Xor inverseOrder) Then
            first = middle + 1
        Else
            last = middle - 1
        End If
    Loop Until first > last
End Function
Function BinarySearch(arr As Variant, search As Variant, _
    Optional lastEl As Variant) As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim Index As Long
    Dim first As Long
    Dim last As Long
    Dim middle As Long
    Dim inverseOrder As Boolean
    
    ' account for optional arguments
    If IsMissing(lastEl) Then lastEl = UBound(arr)
    
    first = LBound(arr)
    last = lastEl

    ' deduct direction of sorting
    inverseOrder = (arr(first) > arr(last))

    ' assume searches failed
    BinarySearch = first - 1
    
    Do
        middle = (first + last) \ 2
        If arr(middle) = search Then
            BinarySearch = middle
            Exit Do
        ElseIf ((arr(middle) < search) Xor inverseOrder) Then
            first = middle + 1
        Else
            last = middle - 1
        End If
    Loop Until first > last
End Function
Sub QuickSort(varArray As Variant, _
 Optional intLeft As Integer = -1, _
 Optional intRight As Integer = -1)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Integer
    Dim j As Integer
    Dim varTestVal As Variant
    Dim intMid As Integer

    If intLeft = -1 Then intLeft = LBound(varArray)
    If intRight = -1 Then intRight = UBound(varArray)
   
    If intLeft < intRight Then
        intMid = (intLeft + intRight) \ 2
        varTestVal = varArray(intMid)
        i = intLeft
        j = intRight
        Do
            Do While varArray(i) < varTestVal
                i = i + 1
            Loop
            Do While varArray(j) > varTestVal
                j = j - 1
            Loop
            If i <= j Then
                SwapElementsSimple varArray, i, j
                i = i + 1
                j = j - 1
            End If
        Loop Until i > j
        ' To optimize the sort, always sort the
        ' smallest segment first.
        If j <= intMid Then
            Call QuickSort(varArray, intLeft, j)
            Call QuickSort(varArray, i, intRight)
        Else
            Call QuickSort(varArray, i, intRight)
            Call QuickSort(varArray, intLeft, j)
        End If
    End If
End Sub


Private Sub SwapElementsSimple(varItems As Variant, intItem1 As Integer, intItem2 As Integer)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim varTemp As Variant
    varTemp = varItems(intItem2)
    varItems(intItem2) = varItems(intItem1)
    varItems(intItem1) = varTemp
End Sub

'Expects a 2d array
Sub QuickSort2D(varArray As Variant, Optional sortColumn As Long = 1, _
 Optional columnCount As Long = -1, _
 Optional intLeft As Long = -1, _
 Optional intRight As Long = -1, _
 Optional sortAscending As Boolean = True)
 '<CSCustomCode> 1
 On Error Resume Next
 '</CSCustomCode> 1
 
    ' SortColumn - the column that will be used to sort the array
    ' arrayDimensions - the number of dimensions in array
    ' Out:
    '       The data in varArray will be sorted.
    
    Dim i As Long
    Dim j As Long
    Dim varTestVal As Variant
    Dim intMid As Long
    
    If columnCount = -1 Then columnCount = UBound(varArray, 2)
    If intLeft = -1 Then intLeft = LBound(varArray)
    If intRight = -1 Then intRight = UBound(varArray)
   
    If intLeft < intRight Then
        intMid = (intLeft + intRight) \ 2
        varTestVal = varArray(intMid, sortColumn)
        i = intLeft
        j = intRight
        Do
            Do While CompareValues(varArray(i, sortColumn), varTestVal, sortAscending) = -1 'left side less than right side
                i = i + 1
            Loop
            Do While CompareValues(varArray(j, sortColumn), varTestVal, sortAscending) = 1 'left side greater than right side
                j = j - 1
            Loop
            If i <= j Then
                SwapElements varArray, columnCount, i, j
                i = i + 1
                j = j - 1
            End If
        Loop Until i > j
        ' To optimize the sort, always sort the
        ' smallest segment first.
        If j <= intMid Then
            Call QuickSort2D(varArray, sortColumn, columnCount, intLeft, j, sortAscending)
            Call QuickSort2D(varArray, sortColumn, columnCount, i, intRight, sortAscending)
        Else
            Call QuickSort2D(varArray, sortColumn, columnCount, i, intRight, sortAscending)
            Call QuickSort2D(varArray, sortColumn, columnCount, intLeft, j, sortAscending)
        End If
    End If
End Sub

Private Sub SwapElements(varItems As Variant, columnCount As Long, rowIndex1 As Long, rowIndex2 As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim temp As Variant, i As Long
    For i = 1 To columnCount
        If IsObject(varItems(rowIndex1, i)) Then
            Set temp = varItems(rowIndex1, i)
            Set varItems(rowIndex1, i) = varItems(rowIndex2, i)
            Set varItems(rowIndex2, i) = temp
        Else
            temp = varItems(rowIndex1, i)
            varItems(rowIndex1, i) = varItems(rowIndex2, i)
            varItems(rowIndex2, i) = temp
        End If
    Next
End Sub
Function FindArrayDimensions(varArray As Variant) As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Integer, y As Integer
    'max 100 arrays
    On Error GoTo Exit_Here:
    i = -1
    For i = 1 To 100
        y = UBound(varArray, i)
    Next

Exit_Here:
    FindArrayDimensions = i - 1
End Function
Public Function CompareValues(ByRef value1 As Variant, ByRef value2 As Variant, Optional sortAscending As Boolean = True) As Long
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    If sortAscending = True Then
        If value1 > value2 Then
            CompareValues = 1
        ElseIf value1 < value2 Then
            CompareValues = -1
        Else
            CompareValues = 0
        End If
    Else
        If value1 < value2 Then
            CompareValues = 1
        ElseIf value1 > value2 Then
            CompareValues = -1
        Else
            CompareValues = 0
        End If
    
    End If
End Function



Sub BubbleSort(arr As Variant, Optional numEls As Variant, _
    Optional descending As Boolean)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1

    Dim value As Variant
    Dim Index As Long
    Dim firstItem As Long
    Dim indexLimit As Long, lastSwap As Long

    ' account for optional arguments
    If IsMissing(numEls) Then numEls = UBound(arr)
    firstItem = LBound(arr)
    lastSwap = numEls

    Do
        indexLimit = lastSwap - 1
        lastSwap = 0
        For Index = firstItem To indexLimit
            value = arr(Index)
            If (value > arr(Index + 1)) Xor descending Then
                ' if the items are not in order, swap them
                arr(Index) = arr(Index + 1)
                arr(Index + 1) = value
                lastSwap = Index
            End If
        Next
    Loop While lastSwap
End Sub

Sub BubbleSort2D(arr As Variant, sortColumn As Long, _
    Optional descending As Boolean, Optional startIndex As Long, Optional endIndex As Long)
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    
    Dim numEls As Long
    Dim value As Variant
    Dim Index As Long
    Dim firstItem As Long
    Dim indexLimit As Long, lastSwap As Long
    Dim columnCount As Long
    
    ' account for optional arguments
    If endIndex > 0 Then
        numEls = endIndex
    Else
        numEls = UBound(arr)
    End If
    If startIndex > 0 Then
        firstItem = startIndex
    Else
        firstItem = LBound(arr)
    End If
    lastSwap = numEls
    columnCount = UBound(arr, 2)
    
    Do
        indexLimit = lastSwap - 1
        lastSwap = 0
        For Index = firstItem To indexLimit
            value = arr(Index, sortColumn)
            If (value > arr(Index + 1, sortColumn)) Xor descending Then
                ' if the items are not in order, swap them
                SwapElements arr, columnCount, Index, Index + 1
                'arr(index) = arr(index + 1)
                'arr(index + 1) = value
                lastSwap = Index
            End If
        Next
    Loop While lastSwap
End Sub


Sub test()
    '<CSCustomCode> 1
    On Error Resume Next
    '</CSCustomCode> 1
    Dim i As Long
    Dim arr(1 To 10, 1 To 2) As Long
    For i = 1 To 10
        arr(i, 1) = i
    Next
    arr(1, 2) = 52
    arr(2, 2) = 77
    arr(3, 2) = 5
    arr(4, 2) = 59
    arr(5, 2) = 47
    arr(6, 2) = 30
    arr(7, 2) = 62
    arr(8, 2) = 65
    arr(9, 2) = 100
    arr(10, 2) = 28
    
    BubbleSort2D arr, 2, True
    
    For i = 1 To 10
        Debug.Print arr(i, 1) & "    " & arr(i, 2)
    Next
End Sub




Attribute VB_Name = "modSpecReport"
Private Type SpecReportRow
    SectionCaption As String
    HeaderDesc As String
    SpecDesc As String
    RowTotal As Double
    IsSpec As Boolean
    IsHeader As Boolean
    IsSection As Boolean
    SectionSheetName As String
    AlwaysShowTotal As Boolean
End Type
Public Sub FillSpecReport(sht As Worksheet, Optional sortSectionsAlphabetically As Boolean = False)
    'Dim sht As Worksheet
    'Set sht = ActiveSheet
    
    Dim bShowTotals As Boolean
    Dim bShowItemTotals As Boolean
    Dim bShowHeaderRows As Boolean
    Dim bShowHeaderRowTotals As Boolean
    
    bShowHeaderRows = True
    bShowTotals = True
    bShowHeaderRowTotals = True
    
    Dim bShowTotalsRangeExists As Boolean
    Dim bShowItemTotalsRangeExists As Boolean
    Dim bShowHeaderRowTotalsRangeExists As Boolean
    
    Dim i As Long
    Dim y As Long
    Dim z As Long
    
    Dim colSections As Collection
    Set colSections = FillSectionHeaderRows(sht.Parent, sortSectionsAlphabetically)

    Dim nm As Name
    Dim hRow As ItemSectionHeaderRow
    Dim estSec As ItemSection
    
    On Error Resume Next

    Set nm = sht.names("ShowHeaderRows")
    If Not nm Is Nothing Then bShowHeaderRows = nm.RefersToRange.value
    
    Set nm = Nothing
    Set nm = sht.names("ShowTotals")
    If Not nm Is Nothing Then
        bShowTotals = nm.RefersToRange.value
        bShowTotalsRangeExists = True
    End If
    
     Set nm = Nothing
    Set nm = sht.names("ShowItemTotals")
    If Not nm Is Nothing Then
        bShowItemTotals = nm.RefersToRange.value
        bShowItemTotalsRangeExists = True
    End If
    
    Set nm = Nothing
    Set nm = sht.names("ShowHeaderSubtotals")
    If Not nm Is Nothing Then
        bShowHeaderRowTotals = nm.RefersToRange.value
        bShowHeaderRowTotalsRangeExists = True
    End If
    
    Set nm = Nothing
    Set nm = sht.names("SectionRange")
    If nm Is Nothing Then Set nm = sht.names("ReportList1")

    If Not nm Is Nothing Then
        Dim sec As ItemSection
        Set sec = New ItemSection
        sec.Init nm.RefersToRange, True

        sec.DeleteAllRows
        
        Dim rowCnt As Long
        Dim colDescriptions As Collection
        Dim colHeaders As Collection
        Dim colSpecs As Collection
        Dim colTotals As Collection
        Dim secRow As ItemSectionRow
        
        Set colDescriptions = New Collection
        Set colSpecs = New Collection
        Set colTotals = New Collection
        
        
        
        Dim mValues(1 To 20000) As SpecReportRow
        'ReDim mValues(1 To 20000, 1 To 7) As Variant  '1=Section Caption, 2=Header Desc, 3=Spec Desc, 4=Total, 5=IsSpec, 6=IsHeader, 7=IsSection
        Dim strSheetName As String
        Dim dTotal As Double
        
        rowCnt = 0
        If colSections.Count > 0 Then
            'calculate needed rows
            Dim bAddSection As Boolean
            Dim colAllowanceRows As Collection
            Dim colExcludedRows As Collection
            Dim colOwnerPerformedRows As Collection
            
            Set colAllowanceRows = New Collection
            Set colExcludedRows = New Collection
            Set colOwnerPerformedRows = New Collection
            
            For i = 1 To colSections.Count
                Set estSec = colSections(i)
                bAddSection = False
                
                'remove allowance, excluded, & owner performed rows
                If estSec.MainSectionHeaderRow.SpecRows.Count > 0 Then
                    RemoveAllowanceExcludedOwnerRows estSec.MainSectionHeaderRow.SpecRows, colAllowanceRows, colExcludedRows, colOwnerPerformedRows
                End If
                If estSec.ItemSectionHeaderRows.Count > 0 Then
                    For y = 1 To estSec.ItemSectionHeaderRows.Count
                        If estSec.ItemSectionHeaderRows(y).SpecRows.Count > 0 Then
                            RemoveAllowanceExcludedOwnerRows estSec.ItemSectionHeaderRows(y).SpecRows, colAllowanceRows, colExcludedRows, colOwnerPerformedRows
                        End If
                    Next
                End If
                
                If estSec.MainSectionHeaderRow.SpecRows.Count > 0 Then
                    bAddSection = True
                Else
                    If estSec.ItemSectionHeaderRows.Count > 0 Then
                        For y = 1 To estSec.ItemSectionHeaderRows.Count
                            Set hRow = estSec.ItemSectionHeaderRows(y)
                            Dim d As Double
                            d = 0
                            d = hRow.GetTotal("Total")
                            
                            If hRow.SpecRows.Count > 0 Then
                                bAddSection = True
                                Exit For
                            ElseIf d <> 0 Then
                                'bAddSection = True
                                'Exit For
                            End If
                        Next
                    End If
                End If
                
                'If estSec.MainSectionHeaderRow.specRows.Count > 0 Or estSec.ItemSectionHeaderRows.Count > 0 Then
                If bAddSection Then
                    'section row
                    rowCnt = rowCnt + 1
                    mValues(rowCnt).SectionCaption = estSec.Caption
                    mValues(rowCnt).IsSection = True
                    mValues(rowCnt).RowTotal = estSec.Range.Worksheet.names("Total").RefersToRange.value
                    strSheetName = estSec.SheetName 'Range.Worksheet.Name
                    mValues(rowCnt).SectionSheetName = strSheetName
                    
                    'spec rows
                    If estSec.MainSectionHeaderRow.SpecRows.Count > 0 Then
                        For y = 1 To estSec.MainSectionHeaderRow.SpecRows.Count
                            Set secRow = estSec.MainSectionHeaderRow.SpecRows(y)
                            mValues(rowCnt + y).SpecDesc = secRow.Description
                            mValues(rowCnt + y).RowTotal = secRow.Total
                            mValues(rowCnt + y).IsSpec = True
                            mValues(rowCnt).SectionSheetName = secRow.SheetName
                            
                        Next
                        rowCnt = rowCnt + estSec.MainSectionHeaderRow.SpecRows.Count
                    End If
                    
                    If estSec.ItemSectionHeaderRows.Count > 0 Then
                        For y = 1 To estSec.ItemSectionHeaderRows.Count
                            Set hRow = estSec.ItemSectionHeaderRows(y)
                            
                            'only show a header row is it has a total or has specs
                            dTotal = hRow.GetTotal("Total")
                            
                            If hRow.SpecRows.Count > 0 Then  'Or dTotal <> 0
                                If bShowHeaderRows Then
                                    mValues(rowCnt + 1).HeaderDesc = hRow.Description
                                    mValues(rowCnt + 1).RowTotal = dTotal
                                    mValues(rowCnt + 1).IsHeader = True
                                    mValues(rowCnt + 1).SectionSheetName = strSheetName
                                    rowCnt = rowCnt + 1
                                End If
                                
                                If hRow.SpecRows.Count > 0 Then
                                    For z = 1 To hRow.SpecRows.Count
                                        Set secRow = hRow.SpecRows(z)
                                        mValues(rowCnt + z).SpecDesc = secRow.Description
                                        mValues(rowCnt + z).RowTotal = secRow.Total
                                        mValues(rowCnt + z).IsSpec = True
                                        mValues(rowCnt + z).SectionSheetName = strSheetName
                                    Next
                                    rowCnt = rowCnt + hRow.SpecRows.Count
                                End If
                            End If
                            dTotal = 0
                        Next
                    End If
                    'separator row
                    rowCnt = rowCnt + 1
                End If
            Next
            
            'add allowances
            Dim prevSheet As String
            Dim bAllowanceTotal As Double
            Dim bLastHeader As Long
            
            Dim lPrevHeaderRow As Long
            
            dTotal = 0
            'remove invalid allowance rows
            If colAllowanceRows.Count > 0 Then
                For i = colAllowanceRows.Count To 1 Step -1
                    Set secRow = colAllowanceRows(i)
                    If secRow.Total = 0 Then
                        colAllowanceRows.Remove i
                    End If
                Next
            End If
            If colAllowanceRows.Count > 0 Then
                rowCnt = rowCnt + 1
                mValues(rowCnt).SectionCaption = "Allowances"
                mValues(rowCnt).IsSection = True
                mValues(rowCnt).RowTotal = GetRowsTotal(colAllowanceRows)
                mValues(rowCnt).SectionSheetName = secRow.SheetName
                mValues(rowCnt).AlwaysShowTotal = True
                For i = 1 To colAllowanceRows.Count
                    Set secRow = colAllowanceRows(i)
                    If secRow.SheetName <> prevSheet Then
                        mValues(rowCnt + 1).HeaderDesc = secRow.SheetName
                        mValues(rowCnt + 1).IsHeader = True
                        If lPrevHeaderRow > 0 And dTotal <> 0 Then mValues(lPrevHeaderRow).RowTotal = dTotal
                        dTotal = 0
                        lPrevHeaderRow = rowCnt + 1
                        mValues(rowCnt + 1).SectionSheetName = secRow.SheetName
                        mValues(rowCnt + 1).AlwaysShowTotal = True
                        rowCnt = rowCnt + 1
                        prevSheet = secRow.SheetName
                    End If
                    
                    mValues(rowCnt + 1).SpecDesc = secRow.Description
                    mValues(rowCnt + 1).RowTotal = secRow.Total
                    mValues(rowCnt + 1).IsSpec = True
                    dTotal = dTotal + secRow.Total
                    mValues(rowCnt + 1).SectionSheetName = secRow.SheetName
                    rowCnt = rowCnt + 1
             
                    
                Next
                
                If lPrevHeaderRow > 0 And dTotal <> 0 Then mValues(lPrevHeaderRow).RowTotal = dTotal
                rowCnt = rowCnt + 1
            End If
            
            'add by owner
            prevSheet = ""
            If colOwnerPerformedRows.Count > 0 Then
                rowCnt = rowCnt + 1
                mValues(rowCnt).SectionCaption = "Owner Performed"
                mValues(rowCnt).IsSection = True
                mValues(rowCnt).RowTotal = 0 'GetRowsTotal(colOwnerPerformedRows)
                mValues(rowCnt).SectionSheetName = secRow.SheetName
                
                For i = 1 To colOwnerPerformedRows.Count
                    Set secRow = colOwnerPerformedRows(i)
                    If secRow.SheetName <> prevSheet Then
                        mValues(rowCnt + 1).HeaderDesc = secRow.SheetName
                        mValues(rowCnt + 1).IsHeader = True
                        mValues(rowCnt + 1).SectionSheetName = secRow.SheetName
                        rowCnt = rowCnt + 1
                        prevSheet = secRow.SheetName
                    End If
                    
                    mValues(rowCnt + 1).SpecDesc = secRow.Description
                    mValues(rowCnt + 1).RowTotal = secRow.Total
                    mValues(rowCnt + 1).IsSpec = True
                    mValues(rowCnt + 1).SectionSheetName = secRow.SheetName
                    rowCnt = rowCnt + 1
                Next
                
                rowCnt = rowCnt + 1
            End If
            
            'add exclusions
            If colExcludedRows.Count > 0 Then
                rowCnt = rowCnt + 1
                mValues(rowCnt).SectionCaption = "Exclusions"
                mValues(rowCnt).IsSection = True
                mValues(rowCnt).RowTotal = 0 'colExcludedRows(colAllowanceRows)
                mValues(rowCnt).SectionSheetName = secRow.SheetName
                
                For i = 1 To colExcludedRows.Count
                    Set secRow = colExcludedRows(i)
                    If secRow.SheetName <> prevSheet Then
                        mValues(rowCnt + 1).HeaderDesc = secRow.SheetName
                        mValues(rowCnt + 1).IsHeader = True
                        mValues(rowCnt + 1).SectionSheetName = secRow.SheetName
                        rowCnt = rowCnt + 1
                        prevSheet = secRow.SheetName
                    End If
                    
                    mValues(rowCnt + 1).SpecDesc = secRow.Description
                    mValues(rowCnt + 1).RowTotal = secRow.Total
                    mValues(rowCnt + 1).IsSpec = True
                    mValues(rowCnt + 1).SectionSheetName = secRow.SheetName
                    rowCnt = rowCnt + 1
                Next
                
                rowCnt = rowCnt + 1
            End If
            
         
            sec.AddMultipleRows rowCnt
            'Fill the columns

            'CostCode,Name/Description,Amount,AllowanceAmount,OptionAmount
            Dim values() As Variant
            Dim lRowCount As Long
            Dim lColumnIndex As Long
            
            Dim bShowHeaderTotals As Boolean
            
            
            sec.Init sec.Range, True
            values = sec.ItemRange.Formula
            lRowCount = sec.ItemRange.rows.Count
            If sec.ColumnExists("SectionName") Then
                lColumnIndex = sec.GetColumnIndex("SectionName")
                For i = 1 To lRowCount
                    values(i, lColumnIndex) = mValues(i).SectionSheetName
                Next
            End If
            If sec.ColumnExists("IsSection") And bShowHeaderRows Then
                lColumnIndex = sec.GetColumnIndex("IsSection")
                For i = 1 To lRowCount
                    If mValues(i).IsSection Then values(i, lColumnIndex) = "X"
                Next
            End If
            If sec.ColumnExists("IsSpec") Then
                lColumnIndex = sec.GetColumnIndex("IsSpec")
                For i = 1 To lRowCount
                    If mValues(i).IsSpec Then values(i, lColumnIndex) = "X"
                Next
            End If
            If sec.ColumnExists("IsHeader") Then
                lColumnIndex = sec.GetColumnIndex("IsHeader")
                For i = 1 To lRowCount
                    If mValues(i).IsHeader Then values(i, lColumnIndex) = "X"
                Next
            End If
            If sec.ColumnExists("Description") Then
                lColumnIndex = sec.GetColumnIndex("Description")
                For i = 1 To lRowCount
                    If mValues(i).IsSection Then values(i, lColumnIndex) = mValues(i).SectionCaption
                    If mValues(i).IsHeader Then values(i, lColumnIndex) = "    " & mValues(i).HeaderDesc
                Next
            End If
            If sec.ColumnExists("Spec") Then
                lColumnIndex = sec.GetColumnIndex("Spec")
                For i = 1 To lRowCount
                    If mValues(i).IsSpec Then values(i, lColumnIndex) = mValues(i).SpecDesc
                Next
            End If
            If sec.ColumnExists("Total") Then
                lColumnIndex = sec.GetColumnIndex("Total")
                For i = 1 To lRowCount
                    If mValues(i).RowTotal <> 0 Then
                        If mValues(i).IsSection Then
                            If mValues(i).AlwaysShowTotal = True Then
                                values(i, lColumnIndex) = "=TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")"
                            ElseIf bShowTotalsRangeExists Then
                                If bShowItemTotalsRangeExists Then
                                    values(i, lColumnIndex) = "=If(ShowTotals=True,IF(ShowItemTotals=TRUE,TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")," & mValues(i).RowTotal & ")," & """""" & ")"
                                Else
                                    values(i, lColumnIndex) = "=If(ShowTotals=True,TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")," & """""" & ")"
                                End If
                            Else
                                values(i, lColumnIndex) = mValues(i).RowTotal
                            End If
                        ElseIf mValues(i).IsHeader Then
                            If mValues(i).AlwaysShowTotal = True Then
                                values(i, lColumnIndex) = "=TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")&""         """
                            ElseIf bShowHeaderRowTotalsRangeExists Then
                                values(i, lColumnIndex) = "=If(And(ShowHeaderSubtotals,ShowTotals),TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")&""         """ & "," & """""" & ")"
                            ElseIf bShowTotalsRangeExists Then
                                values(i, lColumnIndex) = "=If(ShowTotals=True,TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")&""         """ & "," & """""" & ")"
                            Else
                                values(i, lColumnIndex) = "=TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")&""         """
                            End If
                        Else
                            If mValues(i).AlwaysShowTotal = True Then
                                values(i, lColumnIndex) = mValues(i).RowTotal
                            ElseIf bShowTotalsRangeExists Then
                                If bShowItemTotalsRangeExists Then
                                    values(i, lColumnIndex) = "=If(ShowItemTotals=True," & mValues(i).RowTotal & "," & """""" & ")"
                                Else
                                    values(i, lColumnIndex) = "=If(ShowTotals=True," & mValues(i).RowTotal & "," & """""" & ")"
                                End If
                            Else
                                If bShowItemTotalsRangeExists Then
                                    values(i, lColumnIndex) = "=If(ShowItemTotals=True," & mValues(i).RowTotal & "," & """""" & ")"
                                Else
                                    values(i, lColumnIndex) = mValues(i).RowTotal
                                End If
                            End If
                        End If
                        
'                        If bShowTotalsRangeExists Then
'                            If mValues(i).IsHeader Then
'                                If bShowHeaderRowTotalsRangeExists Then
'                                    values(i, lColumnIndex) = "=If(And(ShowHeaderSubtotals,ShowTotals),TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")&""         """ & "," & """""" & ")"
'                                Else
'                                    values(i, lColumnIndex) = "=If(ShowTotals=True,TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")&""         """ & "," & """""" & ")"
'                                End If
'                            Else
'                                values(i, lColumnIndex) = "=If(ShowTotals=True," & mValues(i).RowTotal & "," & """""" & ")"
'                            End If
'                        Else
'                            If bShowTotals Then
'                                If mValues(i).IsHeader Then
'                                    If bShowHeaderRowTotals Then values(i, lColumnIndex) = "=TEXT(" & mValues(i).RowTotal & ",""$#,##0.00"")&""         """
'                                Else
'                                    values(i, lColumnIndex) = mValues(i).RowTotal
'                                End If
'                            End If
'                        End If
                    End If
                Next
            End If
            
            sec.ItemRange.Formula = values
 

'
'            ReDim values(1 To colCostCodes.Count, 1 To 1) As Variant
'            If sec.ColumnExists("CostCode") Then
'
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.Name
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("CostCode")).value = values
'            End If
'            If sec.ColumnExists("Description") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.Name
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("Description")).value = values
'            End If
'            If sec.ColumnExists("Amount") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.Amount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("Amount")).value = values
'            End If
'             If sec.ColumnExists("Total") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.Amount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("Total")).value = values
'            End If
'             If sec.ColumnExists("TotalCost") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.Amount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("TotalCost")).value = values
'            End If
'
'
'            'CostCode,Name/Description,Amount,AllowanceAmount,OptionAmount
'            If sec.ColumnExists("AllowanceAmount") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.AllowanceAmount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("AllowanceAmount")).value = values
'            End If
'             If sec.ColumnExists("AllowanceTotal") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.AllowanceAmount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("AllowanceTotal")).value = values
'            End If
'             If sec.ColumnExists("OptionsAmount") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.OptionAmount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("OptionsAmount")).value = values
'            End If
'             If sec.ColumnExists("OptionsTotal") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.OptionAmount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("OptionsTotal")).value = values
'            End If
'            If sec.ColumnExists("OptionAmount") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.OptionAmount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("OptionAmount")).value = values
'            End If
'             If sec.ColumnExists("OptionTotal") Then
'                For i = 1 To colCostCodes.Count
'                    Set cc = colCostCodes(i)
'                    values(i, 1) = cc.OptionAmount
'                Next
'                sec.ItemRange.Columns(sec.GetColumnIndex("OptionTotal")).value = values
'            End If
        End If
    End If
End Sub

Public Function GetRowsTotal(colRows As Collection) As Double
    Dim i As Long
    Dim d As Double
    Dim secRow As ItemSectionRow
    For i = 1 To colRows.Count
        Set secRow = colRows(i)
        d = d + secRow.Total
    Next
    If d < 0.0001 Then d = 0
    GetRowsTotal = d
End Function
Private Sub RemoveAllowanceExcludedOwnerRows(colRows As Collection, colAllowanceRows As Collection, colExcludedRows As Collection, colOwnerPerformedRows As Collection)
    Dim i As Long
    Dim secRow As ItemSectionRow
    
    For i = colRows.Count To 1 Step -1
        Set secRow = colRows(i)
        If secRow.IsAllowance Then
            colAllowanceRows.Add secRow
            colRows.Remove i
        ElseIf secRow.IsSpec Then
            If UCase(Trim(secRow.SpecSection)) = "EXCLUDED" Then
                colExcludedRows.Add secRow
                colRows.Remove i
            ElseIf UCase(Trim(secRow.SpecSection)) = "BY OWNER" Then
                colOwnerPerformedRows.Add secRow
                colRows.Remove i
            End If
        End If
    Next
End Sub
Private Function FillSectionHeaderRows(wb As Workbook, bSortSectionsAlphabetically As Boolean) As Collection
    Dim secs As Collection
    Dim sectionKeys As Collection
    Set sectionKeys = New Collection
    sectionKeys.Add "EstimateItems"

    Set secs = GetAllSectionsWithNames(wb, sectionKeys)
    

    
    On Error Resume Next
    Dim s As ItemSection
    Dim y As Long
    Dim v As Variant
    Dim codeIndex As Long
    Dim totalIndex As Long
    Dim specIndex As Long
    Dim specSectionIndex As Long
    Dim allowanceIndex As Long
    Dim descIndex As Long
    Dim optionIndex As Long
    Dim isQuoteIndex As Long
    Dim noteIndex As Long
    
    Dim strCostCode As String
    Dim cc As CCostCode

    Dim bAddRow As Boolean
    Dim bIsAllowance As Boolean
    Dim bIsSpec As Boolean
    Dim bIsOption As Boolean
    Dim useColumnIndex As Long
    Dim specNoteIndex As Long
    
    
    Dim secRow As ItemSectionRow
    
    Set outHeaderRows = New Collection
    
    Dim strSpecNote As String
    
    Dim hRow As ItemSectionHeaderRow
    Dim sSortValues() As Variant
    If secs.Count > 0 Then ReDim sSortValues(1 To secs.Count, 1 To 2) As Variant
    
    For i = 1 To secs.Count
        Set s = secs(i)
        If bSortSectionsAlphabetically Then
            sSortValues(i, 1) = s.Caption
            Set sSortValues(i, 2) = s
        End If
    
        Set hRow = Nothing
        strCostCode = ""
        
        Set s.MainSectionHeaderRow = New ItemSectionHeaderRow
        
        codeIndex = s.GetColumnIndex("CostCode")
        totalIndex = s.GetColumnIndex("Total")
        specIndex = s.GetColumnIndex("IsSpec")
        allowanceIndex = s.GetColumnIndex("Allowance")
        descIndex = s.GetColumnIndex("Description")
        optionIndex = s.GetColumnIndex("IsOption")
        noteIndex = s.GetColumnIndex("Note")
        specNoteIndex = s.GetColumnIndex("SpecNote")
        specSectionIndex = s.GetColumnIndex("SpecSection")
        
        If s.ColumnExists("Use") Then
            useColumnIndex = s.GetColumnIndex("Use")
        Else
            useColumnIndex = -1
        End If
        
        
        For y = 2 To s.rowCount - 1
            strSpecNote = ""
            
            If s.IsHeaderRow(y) Then
                Set hRow = New ItemSectionHeaderRow
                s.ItemSectionHeaderRows.Add hRow
                hRow.Description = s.value(y, descIndex)
                Set hRow.Section = s
                hRow.Row = y
            Else
            
                If totalIndex > 0 Then v = s.value(y, totalIndex)
                If codeIndex > 0 Then strCostCode = Trim(s.value(y, codeIndex))
                If specNoteIndex > 0 Then strSpecNote = Trim(s.value(y, specNoteIndex))
                
                Set cc = Nothing
                bAddRow = True
                bIsAllowance = False
                bIsSpec = False
                
                If useColumnIndex > 0 Then
                    If s.value(y, useColumnIndex) = "" Then bAddRow = False
                End If
                If specIndex > 0 Then
                    If s.value(y, specIndex) <> "" Then bIsSpec = True
                End If
                If allowanceIndex > 0 Then
                    If s.value(y, allowanceIndex) <> "" Then
                        bIsAllowance = True
                    End If
                End If
                If optionIndex > 0 Then
                    If s.value(y, optionIndex) <> "" Then
                        bIsOption = True
                    End If
                End If
                
                If s.IsHeaderRow(y) Then bAddRow = False
                    
                If bAddRow Then
                    Set secRow = New ItemSectionRow
                    secRow.IsOption = bIsOption
                    secRow.IsAllowance = bIsAllowance
                    secRow.IsSpec = bIsSpec
                    If IsNumeric(v) Then
                        If v <> 0 Then
                            secRow.Total = CDbl(v)
                        End If
                    End If
                    If specSectionIndex > 0 Then
                        If s.value(y, specSectionIndex) <> "" Then
                            secRow.SpecSection = s.value(y, specSectionIndex)
                        End If
                    End If
                    
                    Set secRow.Section = s
                    secRow.Row = y
                    secRow.Description = s.value(y, descIndex)
                    If noteIndex > 0 Then secRow.Note = s.value(y, noteIndex)
            
      
                    If hRow Is Nothing Then
                        s.MainSectionHeaderRow.SectionRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then s.MainSectionHeaderRow.SpecRows.Add secRow
                        If secRow.IsAllowance Then s.MainSectionHeaderRow.AllowanceRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then s.MainSectionHeaderRow.SpecAndAllowanceRows.Add secRow
                    Else
                        hRow.SectionRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then hRow.SpecRows.Add secRow
                        If secRow.IsAllowance Then hRow.AllowanceRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then hRow.SpecAndAllowanceRows.Add secRow
                    End If
   
                End If
                
                If strSpecNote <> "" Then
                    Set secRow = New ItemSectionRow
                    secRow.IsOption = False
                    secRow.IsAllowance = False
                    secRow.IsSpec = True
                    
                    Set secRow.Section = s
                    secRow.Row = y
                    secRow.Description = "-" & strSpecNote
                               
                 
                    If hRow Is Nothing Then
                        s.MainSectionHeaderRow.SectionRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then s.MainSectionHeaderRow.SpecRows.Add secRow
                        If secRow.IsAllowance Then s.MainSectionHeaderRow.AllowanceRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then s.MainSectionHeaderRow.SpecAndAllowanceRows.Add secRow
                    Else
                        hRow.SectionRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then hRow.SpecRows.Add secRow
                        If secRow.IsAllowance Then hRow.AllowanceRows.Add secRow
                        If secRow.IsSpec Or secRow.IsAllowance Then hRow.SpecAndAllowanceRows.Add secRow
                    End If
                 
                
                End If
            End If
        Next
    Next
    
     If bSortSectionsAlphabetically Then
        QuickSort2D sSortValues, 1
        
        Dim colTemp As Collection
        Set colTemp = New Collection
        For i = 1 To secs.Count
            colTemp.Add sSortValues(i, 2)
        Next
        
        Set secs = colTemp
    End If

    Set FillSectionHeaderRows = secs
End Function
Function GetAllSectionsWithNames(wb As Workbook, namedRanges As Collection) As Collection
    Dim nm As Name
    Dim i As Long
    
    Dim sName As String
    Dim s As ItemSection
    Dim colSections As Collection
    Set colSections = New Collection
    
    Dim colNames As Collection
    Set colNames = New Collection
    For i = 1 To namedRanges.Count
        colNames.Add 1, UCase(Trim(namedRanges(i)))
    Next
    
    On Error Resume Next
    Dim v As Variant
    Dim tempRng As Range
    
    For i = 1 To wb.Worksheets.Count
        For y = 1 To namedRanges.Count
            Set nm = Nothing
            Set nm = wb.Worksheets(i).names(namedRanges(y))
            If Not nm Is Nothing Then
                Set s = New ItemSection
                Set tempRng = Nothing
                Set tempRng = nm.RefersToRange
                If Not tempRng Is Nothing Then
                    If UCase(Trim(wb.Worksheets(i).Name)) <> "ESTIMATE TEMPLATE" Then
                        s.Init nm.RefersToRange, True
                        colSections.Add s
                    End If
                Else
    
                End If
            End If
        Next
    Next
    Set GetAllSectionsWithNames = colSections
End Function

' InQuest injected base64 decoded content
' :.nW
' :-j[
' )eZ+a
' Kk*.
' Kk*.
' *'jQh
' *'"{^
' *'"{^
' *+N)
' *'"{^
' wBzY@u
' wBzY@u
' btZ+
' j+t:
' j+t:
' :-j[
' :-j[

INQUEST-PP=macro
