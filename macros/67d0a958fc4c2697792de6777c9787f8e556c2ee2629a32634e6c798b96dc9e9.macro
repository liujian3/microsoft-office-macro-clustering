Attribute VB_Name = "DieseArbeitsmappe"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Private Sub Workbook_Open()

Application.StatusBar = ""

End Sub
Attribute VB_Name = "FrmDatum"
Attribute VB_Base = "0{4668EDD7-609A-4787-9AF8-684C9F00462E}{615B2E1D-4CFE-4D0C-969F-29E847E30806}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private WithEvents Calendar1 As cCalendar
Attribute Calendar1.VB_VarHelpID = -1
Public Target As Range
Public Initialdate As Date

Private Sub Cb_Weekend_ok_Click()

If Cb_Weekend_ok.Value = True Then
    Calendar1.SundaySelectable = True
    Calendar1.SaturdaySelectable = True
Else
    Calendar1.SundaySelectable = False
    Calendar1.SaturdaySelectable = False
End If

End Sub

Private Sub CommandButton1_Click()
Me.Hide
End Sub

'Private Sub DTPicker1_DblClick()
' Me.Hide
'End Sub

Private Sub UserForm_Initialize()

    If CLng(Initialdate) = 0 Then
        DTPicker1.Text = Date
        Debug.Print CLng(Initialdate)
    Else
        DTPicker1.Text = Initialdate
    End If

    If Calendar1 Is Nothing Then
        Set Calendar1 = New cCalendar
        With Calendar1
            .Add_Calendar_into_Frame Me.Frame1
            .UseDefaultBackColors = False
            .DayLength = 3
            .MonthLength = mlENShort
            If Cb_Weekend_ok.Value = True Then
                .SundaySelectable = True
                .SaturdaySelectable = False
            Else
                .SundaySelectable = False
                .SaturdaySelectable = False
            End If
           ' .Height = 265 '120
           ' .Width = 180
            .GridFont.Size = 7
            .DayFont.Size = 7
            .Refresh
        End With
      '  Me.Height = 153 'Win7 Aero
       ' Me.Width = 197
    End If
End Sub

Private Sub UserForm_Activate()

    If CLng(Initialdate) = 0 Then
        DTPicker1.Text = Date
        Debug.Print CLng(Initialdate)
    Else
        DTPicker1.Text = Initialdate
    End If
    
    If Not Target Is Nothing Then
        If IsDate(Target.Value) Then
            Calendar1.Value = Target.Value
        End If
    Else
        If IsDate(DTPicker1.Text) Then
            Calendar1.Value = CDate(DTPicker1.Text)
        End If
    End If
        
    If Cb_Weekend_ok.Value = True Then
        Calendar1.SundaySelectable = True
        Calendar1.SaturdaySelectable = True
    Else
        Calendar1.SundaySelectable = False
        Calendar1.SaturdaySelectable = False
    End If

End Sub

Private Sub Calendar1_Click()
    DTPicker1.Text = Calendar1.Value
    'Call CloseDatePicker(True) ' true Zelle
    
End Sub

Sub CloseDatePicker(Save As Boolean)

    If Not Target Is Nothing Then
        If Save And IsDate(Calendar1.Value) Then
            Target.Value = Calendar1.Value
        End If
    End If
    Set Target = Nothing
    Me.Hide
    
End Sub

Private Sub Calendar1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = vbKeyEscape Then
        Call CloseDatePicker(False)
    End If
    
End Sub
Attribute VB_Name = "ModDef"
'---------------------------------------------------------------------------------------
' Module    : ModDef
' Author    : Renko Schmidt
' Date      : 16.07.2016
' Purpose   : Allgemeine Definitionen
'---------------------------------------------------------------------------------------
Option Explicit

    Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
    Public Declare Function GetTickCount Lib "kernel32" () As Long
    Global Const MaxPdfTKFiles = 250
    Global Const PDFTKBuilder_2003 = "C:\Programme\PDFTKBuilder\pdftk.exe"
    Global Const PDFTKBuilder_2008 = "C:\Program Files\PDFTK Builder\pdftk.exe"
    Global PDFTKBuilder As String    ' Name XLAM Datei
    Global Reg As New RegistryHandler
    Global Const RegKey As String = "Software\KZVN\Controlling"
    Global Const Wochentage = ",Mo,Di,Mi,Do,Fr,Sa,"
    Global FSO As New Scripting.FileSystemObject
    Public ClsProg As New clsProcess                ' Programme starten und |fffd|berwachen
    Public Const SE_OK_NORMAL = 42&
    Public Const ERROR_BAD_FORMAT = 11&
    Public Const SE_ERR_ACCESSDENIED = 5
    Public Const SE_ERR_ASSOCINCOMPLETE = 27
    Public Const SE_ERR_DDEBUSY = 30
    Public Const SE_ERR_DDEFAIL = 29
    Public Const SE_ERR_DDETIMEOUT = 28
    Public Const SE_ERR_DLLNOTFOUND = 32
    Public Const SE_ERR_FNF = 2
    Public Const SE_ERR_NOASSOC = 31
    Public Const SE_ERR_OOM = 8
    Public Const SE_ERR_PNF = 3
    Public Const SE_ERR_SHARE = 26

    Global EndPointer
    Global BeginPointer
    Global TCa As Double:
    Global TCb As Double
 
    Global strgMeldungen
    Global Selectionsdatum As Date
    Global dhLastDayInMonth As Date
    Global WoTag_Jan1 As Integer ' Wochentag 1.1 des Jahres Mo-So 1-7
    Global intFirstWeekOfSelection As Integer
    Global intLastweekOfSelection As Integer
    Global actWoNummer As Integer
    Global intAnzahlWochen As Integer
    Global AnzahlZuordnungen As Long    ' zu verarbeitende B|fffd|gen
    Global AnzahlPdfDateien As Long     ' zusammengef|fffd|hrte PDF Dateien
    ' Angaben f|fffd|r Arbeitsbl|fffd|tter
    
    Global Spalte_PNRCol
    Global Spalte_NameCol
    Global Spalte_KostenstelleCol
    Global Spalte_AbteilungCol
    Global Spalte_OrdnerCol
    Global Spalte_ErfassungsbogenCol
    
    Global PersonalnummerCol
    Global PersonalnummerRow
    Global MitarbeiterNameCol
    Global MitarbeiterNameRow
    Global Zelle_KWCol
    Global Zelle_KWRow
    Global Zelle_MonatCol
    Global Zelle_MonatRow
    Global AbteilungsnameCol
    Global AbteilungsnameRow
    Global ersteWochenBezeichnungCol
    Global ersteWochenBezeichnungRow
    Global ersterWochentagCol
    Global ersterWochentagRow

    Global WB_Mitarbeiterzuordnung As Workbook
    Global WS_Mitarbeiterzuordnung As Worksheet
    Global WS_MitarbeiterzuordnungLastCol
    Global WS_MitarbeiterzuordnungLastRow
    Global WS_MitarbeiterzuordnungPNRBereich As Range
    
    Global WB_Erfassungsbogen As Workbook
    Global WS_Erfassungsbogen As Worksheet

Attribute VB_Name = "ModPED"
'---------------------------------------------------------------------------------------
' Module    : ModPED
' Author    : Renko Schmidt
' Date      : 16.07.2016
' Purpose   : Prozeduren und Functionen f|fffd|r den Druck der Personalerfassungsb|fffd|gen
'---------------------------------------------------------------------------------------
    Option Explicit
    

Sub Main()

    ' das letzte Selektionsdatum aus der Registry auslesen
    Dim ReadValue, ret

    'call  Variable Pr|fffd|fen
    If Not AngabenMyVarPr|fffd|fen Then
        Call MsgBox("Bitte korrigieren Sie die Angaben und starten Sie erneut!", vbCritical, "Die |fffd|berpr|fffd|fung der Bereichsnamen war nicht erfolgreich!")
        Application.StatusBar = "Die |fffd|berpr|fffd|fung der Bereichsnamen war nicht erfolgreich!"
        Exit Sub
    End If
    ' call Dateinamen in Datei pr|fffd|fen
    AnzahlZuordnungen = 0
    If Not |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung Then
        Call MsgBox("Bitte korrigieren Sie die Angaben und starten Sie erneut!", vbCritical, "Die |fffd|berpr|fffd|fung der Dateinamen war nicht erfolgreich!")
        Application.StatusBar = "Die |fffd|berpr|fffd|fung der Dateinamen war nicht erfolgreich!"
        Exit Sub
    End If
    
    ReadValue = Reg.GetRegValue(HKEY_CURRENT_USER, RegKey, "Selektionsdatum")
    If IsDate(ReadValue) Then
        Selectionsdatum = CDate(ReadValue)
    Else
        Selectionsdatum = Date
    End If
    ' Auswahl des Monats durch den Benutzer
    Select Case MsgBox("Mit dem Datum den Berichtsmonat festlegen", vbYesNo, "Startdatum anklicken / Monat festlegen!")
        Case vbNo
            Application.StatusBar = "Sie haben die Ausf|fffd|hrung abgebrochen!"
            Exit Sub
        Case vbYes
            Load FrmDatum
            FrmDatum.Initialdate = Selectionsdatum
            FrmDatum.Cb_Weekend_ok.Value = True
            FrmDatum.Show
            Selectionsdatum = FrmDatum.DTPicker1.Value
            
            ' Selektiertes Datum in der Registry hinterlegen
            ret = Reg.WriteRegValue(HKEY_CURRENT_USER, RegKey, "Selektionsdatum", Format(Selectionsdatum, "DD-MMM-YYYY"))
            ' Debug.Print "Tageswahl:" & Selectionsdatum
            
    End Select
    
   ' Ausgangsdaten festlegen
    Selectionsdatum = DateSerial(Year(Selectionsdatum), Month(Selectionsdatum), 1)  ' Stichtagsdatum auf den ersten Tag des gew|fffd|hlten Monats setzen
    dhLastDayInMonth = DateSerial(Year(Selectionsdatum), Month(Selectionsdatum) + 1, 0)
    intFirstWeekOfSelection = DayOfWeekEurop(Selectionsdatum)
    If intFirstWeekOfSelection = 0 Then ' 0 wenn die erste Woche in das Vorjahr f|fffd|llt
        Selectionsdatum = DateAdd("d", (7 - WoTag_Jan1) + 1, Selectionsdatum) '  7 - WoTag_Jan1 ' Starttag auf den n|fffd|chsten Montag setzen
        intFirstWeekOfSelection = DayOfWeekEurop(Selectionsdatum)
    End If
    intLastweekOfSelection = DayOfWeekEurop(dhLastDayInMonth)
    actWoNummer = intFirstWeekOfSelection
    actWoNummer = IIf(actWoNummer = 0, 1, actWoNummer)
    ThisWorkbook.Sheets("myVar").Range("letztes_Auswahldatum").Value = Selectionsdatum
    intAnzahlWochen = intLastweekOfSelection - intFirstWeekOfSelection
    Application.StatusBar = "Mitarbeiterzuordnung und PDF Erzeugung f|fffd|r " & AnzahlZuordnungen & " MA f|fffd|r " & intAnzahlWochen + 1 & " Wochen gestartet!"
    AnzahlZuordnungen = 0

    BeginPointer = GetTickCount()
    EndPointer = 0
    If DruckMitarbeiterzuordnung Then  ' Dateien wurden erstellt

        If PdfZusammenfassen Then
        ' PDF Einzeldateien l|fffd|schen
            EndPointer = GetTickCount()
            Application.StatusBar = "Zusammenfassen er PDF Erzeugung gestartet!"
            If Not AnzahlPdfDateien = AnzahlZuordnungen Then
                Application.StatusBar = "Anzahl der zu druckenden Personaleinsatzb|fffd|gen weicht von der Anzahl der PDF Dateien ab!"
                Call MsgBox("Personaleinsatzb|fffd|gen:" & AnzahlPdfDateien & "AnzahlZuordnungen:" & AnzahlZuordnungen, vbInformation + vbOKOnly, "Anzahl der zu druckenden Personaleinsatzb|fffd|gen weicht von der Anzahl der PDF Dateien ab!")
            Else
                EndPointer = GetTickCount()
                Call MsgBox("Die Druckdatei mit " & AnzahlPdfDateien & " Seiten wurde erfolgreich ergestellt!", vbInformation + vbOKOnly, "Beim zusammenf|fffd|hren der PDF Dateien ist kein Fehler aufgetreten!")
                Application.StatusBar = "Druckdatei wurde erfolgreich erstellt und liegt im Ordner:" & ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value
            End If
        End If
    Else
        EndPointer = GetTickCount()
        Application.StatusBar = "Beim erstellen der Personaleinsatzb|fffd|gen ist ein Fehler aufgetreten!"
        Call MsgBox("Bitte Pr|fffd|fen Sie das Teilergebniss!", vbInformation + vbOKOnly, "Beim erstellen der Personaleinsatzb|fffd|gen ist ein Fehler aufgetreten!")
    End If
    
    Debug.Print "Ende DruckMitarbeiterzuordnung:" & ElapsedTime
    ' XLS lesen 312  340 MS
    ' PDF speichern 500 - 1300 MS
End Sub


'---------------------------------------------------------------------------------------
' Procedure : DruckMitarbeiterzuordnung
' Author    : Renko Schmidt
' Date      : 16.07.2016
' Purpose   : F|fffd|r jede Woche im Monat f|fffd|r jeden Mitarbeiter ein Erfassungsbogen speichern
'---------------------------------------------------------------------------------------
'
Function DruckMitarbeiterzuordnung() As Boolean
 '
    
  Dim intZeile: Dim Zelle: Dim ret: Dim strKST: Dim strPNR:
  Dim strgOrdnerName: Dim strgDateiName: Dim strgPdfDateiName: Dim strgFehlermeldung: Dim FehlerInFunctionAufgetreten As Boolean
  
   On Error GoTo DruckMitarbeiterzuordnung_Error

    DruckMitarbeiterzuordnung = False
    
    strgMeldungen = "": FehlerInFunctionAufgetreten = False
    
    If FSO.FileExists(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value) Then
        If WB_Exists(Get_FileName(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value)) Then
            Set WB_Mitarbeiterzuordnung = Workbooks(Get_FileName(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value))
            Set WS_Mitarbeiterzuordnung = WB_Mitarbeiterzuordnung.Sheets(1)  ' Worksheet
            WS_Mitarbeiterzuordnung.Activate '.Select
        Else
            Workbooks.Open ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value, Notify:=False, UpdateLinks:=False, ReadOnly:=True
            ' die ge|fffd|ffnete Datei dem Object zuordnen
            Set WB_Mitarbeiterzuordnung = ActiveWorkbook
            Set WS_Mitarbeiterzuordnung = WB_Mitarbeiterzuordnung.Sheets(1)  ' Worksheet
        End If
    Else
        Call MsgBox(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value, vbCritical, "Abbruch: Datei ist nicht vorhanden!")
        Exit Function
    End If
    
    WS_MitarbeiterzuordnungLastCol = FindLastColumn
    WS_MitarbeiterzuordnungLastRow = FindLastRow
    Set WS_MitarbeiterzuordnungPNRBereich = WS_Mitarbeiterzuordnung.Range(Cells(4, Spalte_PNRCol), Cells(WS_MitarbeiterzuordnungLastRow, Spalte_PNRCol))
    
    For Each Zelle In WS_MitarbeiterzuordnungPNRBereich
    
        strgOrdnerName = ThisWorkbook.Sheets("myvar").Range("Ordner_Wochenbericht").Value & "\" & WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_OrdnerCol).Value
        strgDateiName = strgOrdnerName & "\" & WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_ErfassungsbogenCol).Value

        ' f|fffd|r jeden Dateieintrag in der Steuerdatei der Mitarbeiterzuordnungen den Ausdruck erzeugen
        If Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_PNRCol).Value) And _
            Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_KostenstelleCol).Value) And _
            Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_OrdnerCol).Value) And _
            FSO.FolderExists(strgOrdnerName) And _
            Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_ErfassungsbogenCol).Value) Then
                
                If FSO.FileExists(strgDateiName) Then
                    If WB_Exists(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_ErfassungsbogenCol).Value) Then
                        Set WB_Erfassungsbogen = Workbooks(Get_FileName(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value))
                        Set WS_Erfassungsbogen = WB_Erfassungsbogen.Sheets(1)  ' Worksheet
                        WS_Mitarbeiterzuordnung.Activate '.Select
                    Else
                        Workbooks.Open strgDateiName, Notify:=False, UpdateLinks:=False, ReadOnly:=True
                        ' die ge|fffd|ffnete Datei dem Object zuordnen
                        Set WB_Erfassungsbogen = ActiveWorkbook
                        Set WS_Erfassungsbogen = WB_Erfassungsbogen.Sheets(1)  ' Worksheet
                    End If
                Else
                    Call MsgBox(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value, vbCritical, "Abbruch: Datei ist nicht vorhanden!")
                    Exit Function
                End If
               
                ' F|fffd|r jeden Erfassungsbogen eine Funktion zum Ausf|fffd|llen aufrufen
                ' Schleife |fffd|ber die zu druckenden Wochen
                For actWoNummer = intFirstWeekOfSelection To intLastweekOfSelection
                 '   Debug.Print "Wochennummer:" & actWoNummer & " " & intLastweekOfSelection
                    If ErfassungsbogenF|fffd|llen(Zelle) Then
                        ' WB_Erfassungsbogen       ' WS_Erfassungsbogen
                        '  ausgef|fffd|llten  Erfassungsbogen als PDF Speichern
                        strgOrdnerName = ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value
                        strKST = Right(CStr(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_KostenstelleCol).Value), 4)
                        strPNR = Right(CStr(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_PNRCol).Value), 4)
                        'strgPdfDateiName = strKST & "_" & strPNR & "_" & Left(WB_Erfassungsbogen.Name, InStr(WB_Erfassungsbogen.Name, ".") - 1) & _
                                                                                            "_WoNr" & CStr(actWoNummer) & ".pdf" ' |fffd|nderung 01.03.2018
                        strgPdfDateiName = strKST & "_" & strPNR & "_" & Left(WB_Erfassungsbogen.Name, InStr(WB_Erfassungsbogen.Name, ".") - 1) & _
                                                                                            "_WoNr" & Right$("0" & CStr(actWoNummer), 2) & ".pdf"
                        strgPdfDateiName = Replace(strgPdfDateiName, " ", "_") ' Leerzeichen eliminieren
                        strgPdfDateiName = strgOrdnerName & "\" & strgPdfDateiName
                        If FSO.FileExists(strgPdfDateiName) Then
                            FSO.DeleteFile strgPdfDateiName, True
                        End If
                        
                        WS_Erfassungsbogen.ExportAsFixedFormat Type:=xlTypePDF, Filename:=strgPdfDateiName _
                            , Quality:=xlQualityStandard, IncludeDocProperties:=True, IgnorePrintAreas _
                            :=False, OpenAfterPublish:=False
                        
                        AnzahlZuordnungen = AnzahlZuordnungen + 1
                    Else
                    ' nicht Drucken, da kein Erfassungstag angefallen
                    End If
 
                Next actWoNummer
                WB_Erfassungsbogen.Close SaveChanges:=False
       
        End If ' Datei war zugeordnet
    
    Next Zelle
    
    If FehlerInFunctionAufgetreten Then
        Call MsgBox(strgMeldungen, vbCritical, "Abbruch!: In der Tabelle " & WB_Mitarbeiterzuordnung.Name & " sind nachfolgende Fehler aufgetreten!")
    Else
        DruckMitarbeiterzuordnung = True
    End If

   On Error GoTo 0
   Exit Function

DruckMitarbeiterzuordnung_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure DruckMitarbeiterzuordnung of Modul ModPED"
    
End Function


'---------------------------------------------------------------------------------------
' Procedure : ErfassungsbogenF|fffd|llen
' Author    : Renko Schmidt
' Date      : 17.07.2016
' Purpose   : Erfassungsbogen ausf|fffd|llen
'---------------------------------------------------------------------------------------
'
Function ErfassungsbogenF|fffd|llen(Zelle) As Boolean

Dim firstDateOfWeek, actDateOfWeek, actWotagOfWeek: Dim intWotagIndex As Integer
Dim AnzahlErfassungstageWoche As Integer
'    actWoNummer dhLastDayInMonth sind festgelegt
'    Selectionsdatum  Stichtagsdatum auf den ersten Tag des gew|fffd|hlten Monats setzen
'
   On Error GoTo ErfassungsbogenF|fffd|llen_Error

    ErfassungsbogenF|fffd|llen = False
    'Debug.Print "Monat:" & Format(Selectionsdatum, "mmmm")
    firstDateOfWeek = Week2Date(CLng(actWoNummer), VBA.Year(Selectionsdatum))
    actWotagOfWeek = Format(Week2Date(CLng(actWoNummer), VBA.Year(Selectionsdatum)), "ddd")

    WS_Erfassungsbogen.Cells(Zelle_KWRow, Zelle_KWCol).Value = actWoNummer
    WS_Erfassungsbogen.Cells(Zelle_MonatRow, Zelle_MonatCol).Value = Format(Selectionsdatum, "mmmm")
    WS_Erfassungsbogen.Cells(MitarbeiterNameRow, MitarbeiterNameCol).Value = WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_NameCol).Value
    WS_Erfassungsbogen.Cells(PersonalnummerRow, PersonalnummerCol).Value = WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_PNRCol).Value
    WS_Erfassungsbogen.Cells(AbteilungsnameRow, AbteilungsnameCol).Value = WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_AbteilungCol).Value
    AnzahlErfassungstageWoche = 0
    For intWotagIndex = 0 To 5 ' von Montag bis Samstag
    
        actDateOfWeek = DateAdd("d", intWotagIndex, firstDateOfWeek)
        WS_Erfassungsbogen.Cells(ersteWochenBezeichnungRow, ersteWochenBezeichnungCol + intWotagIndex).Value = Format(actDateOfWeek, "ddd")  ' Wochentag
        If Not Format(actDateOfWeek, "ddd") = FeierTag(CDate(actDateOfWeek)) Then
           Debug.Print FeierTag(CDate(actDateOfWeek))
        End If
        If (actDateOfWeek < Selectionsdatum) Or (actDateOfWeek > dhLastDayInMonth) Or (Format(actDateOfWeek, "ddd") <> FeierTag(CDate(actDateOfWeek))) Then   ' nicht ausgeben
            WS_Erfassungsbogen.Cells(ersterWochentagRow, ersterWochentagCol + intWotagIndex).ClearContents
        Else
            WS_Erfassungsbogen.Cells(ersterWochentagRow, ersterWochentagCol + intWotagIndex).Value = actDateOfWeek
            AnzahlErfassungstageWoche = AnzahlErfassungstageWoche + 1
        End If
    
    Next intWotagIndex
    
    If AnzahlErfassungstageWoche > 0 Then
        ErfassungsbogenF|fffd|llen = True
    Else
        ErfassungsbogenF|fffd|llen = False
    End If
    
   On Error GoTo 0
   Exit Function

ErfassungsbogenF|fffd|llen_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure ErfassungsbogenF|fffd|llen of Modul ModPED"
    
End Function

Sub testPdfZusammenfassen()

    Debug.Print "Start PdfZusammenfassen:" & Time
    Debug.Print PdfZusammenfassen
    Debug.Print "Ende PdfZusammenfassen:" & Time
End Sub
'---------------------------------------------------------------------------------------
' Procedure : pdfzusammenfassen
' Author    : Renko Schmidt
' Date      : 17.07.2016
' Purpose   : PDF Dateien eines Ordners zu einer PDF-Datei zusammenf|fffd|hren
'---------------------------------------------------------------------------------------
'
Function PdfZusammenfassen() As Boolean

    Dim strgTempOrdnerName: Dim Pdf_Ablage: Dim I: Dim CMD_Args
    Dim objPdfFolder As Folder: Dim objFile As File: Dim TempFile: Dim arrDateiname As Variant
    Dim AnzahlSerienbriefe, AnzZwischenDatei, ZwischenDatei
    
   On Error GoTo pdfzusammenfassen_Error

    If Not AngabenMyVarPr|fffd|fen Then ' testweise
        Exit Function
    End If
    
    ' je nach Umgebung wird der Pfad zur Ladebibliothek zum PDFTK Builder eingestellt
    If InStr(getVersion, "2008") > 0 Then
        PDFTKBuilder = PDFTKBuilder_2008
    Else ' 2003
        PDFTKBuilder = PDFTKBuilder_2003
    End If
    
    Pdf_Ablage = ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value
    strgTempOrdnerName = ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value
    If Not FSO.FolderExists(ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value & "\Temp") Then
        FSO.CreateFolder strgTempOrdnerName & "\Temp"
    End If
    TempFile = "PE" & "_TEMP_" & Format(Selectionsdatum, "mmmm") & "_" & Format(Date, "DDMMYYYY") & "_" & CStr(GetTickCount) & ".pdf"
    Set objPdfFolder = FSO.GetFolder(Pdf_Ablage)
    AnzahlSerienbriefe = MaxPdfTKFiles
    AnzahlPdfDateien = 0: AnzZwischenDatei = 0: CMD_Args = "": I = 0
    For Each objFile In objPdfFolder.Files
        If (InStr(objFile.Type, "Adobe Acrobat") > 0) And (Not Left(objFile.Name, 8) = "PE_TEMP_") And (Not Left(objFile.Name, 13) = "ZwischenDatei") Then
            AnzahlPdfDateien = AnzahlPdfDateien + 1
        End If
    Next objFile
    I = 0
    If objPdfFolder.Files.Count > 0 Then
        ' PDF Dateien aneinander h|fffd|ngen cat
        Application.StatusBar = "PDF zusammenf|fffd|gen von : " & AnzahlPdfDateien & " Dateien wird gestartet! Bitte warten Sie."
        ClsProg.ProgramName = PDFTKBuilder
        
        For Each objFile In objPdfFolder.Files
         
            If (InStr(objFile.Type, "Adobe Acrobat") > 0) And (Not Left(objFile.Name, 8) = "PE_TEMP_") And (Not Left(objFile.Name, 13) = "ZwischenDatei") Then
                 I = I + 1
                 CMD_Args = CMD_Args & " " & Pdf_Ablage & "\" & objFile.Name
                 
                 If (I >= AnzahlSerienbriefe) Or (I = AnzahlPdfDateien) Then  ' PDF Ausgeben
 
                    AnzahlSerienbriefe = AnzahlSerienbriefe + MaxPdfTKFiles
                    AnzZwischenDatei = AnzZwischenDatei + 1
                    ZwischenDatei = "ZwischenDatei" & CStr(AnzZwischenDatei) & ".PDF"
                    If FSO.FileExists(Pdf_Ablage & "\" & ZwischenDatei) Then
                        FSO.DeleteFile Pdf_Ablage & "\" & ZwischenDatei
                    End If
 
                    CMD_Args = CMD_Args & " " & " cat output " & Pdf_Ablage & "\" & ZwischenDatei
                    ' Debug.Print "L|fffd|nge CMD_Args:" & Len(CMD_Args)
                    ' Debug.Print CMD_Args
                    ClsProg.Arguments = CMD_Args
                    If ClsProg.ExecHide = 0 Then
                        Call MsgBox(TempFile & vbCrLf & "Fehler beim Aufruf PdfToolkit!", vbCritical, "Zusammenf|fffd|gen der Dateien im Archivordner")
                        GoTo ExitSub
                    Else
                        Do While Not ClsProg.IsTerminated '(Status=259)
                            DoEvents
                            Sleep 100
                         '   Exit Do
                        Loop
                        If ClsProg.ProcessStatus <> 0 Then
                            Call MsgBox("EC:" & CStr(ClsProg.ProcessStatus) & " " & TempFile & vbCrLf & _
                                "Fehler beim Aufruf PdfToolkit!", vbCritical, "Zusammenf|fffd|gen der Dateien im Archivordner")
                        End If
                        CMD_Args = ""
                    End If ' ExecHide
                    
                End If ' AnzahlSerienbriefe
                
            End If ' nicht leer <> ""
        Next objFile ' Ende Loop |fffd|ber Files
        
        AnzahlPdfDateien = I ' selektierte Anzahl
        ' PDF Zwischendateien zusammenf|fffd|hren
        CMD_Args = ""
        For I = 1 To AnzZwischenDatei
            CMD_Args = CMD_Args & " " & Pdf_Ablage & "\" & "ZwischenDatei" & CStr(I) & ".PDF"
        Next I

        CMD_Args = CMD_Args & " " & " cat output " & Pdf_Ablage & "\" & TempFile
        ClsProg.Arguments = CMD_Args
        
        If ClsProg.ExecHide = 0 Then
            Call MsgBox(TempFile & vbCrLf & "Fehler beim Aufruf PdfToolkit!", vbCritical, "Zusammenf|fffd|gen der Dateien im Archivordner")
            GoTo ExitSub
        Else
            Do While Not ClsProg.IsTerminated '(Status=259)
                DoEvents
                Sleep 100
             '   Exit Do
            Loop
            If ClsProg.ProcessStatus <> 0 Then
                Call MsgBox("EC:" & CStr(ClsProg.ProcessStatus) & " " & TempFile & vbCrLf & _
                    "Fehler beim Aufruf PdfToolkit!", vbCritical, "Zusammenf|fffd|gen der Dateien im Archivordner")
                Debug.Print CMD_Args
            End If
        End If ' ExecHide
        
        ' PDF Zwischendateien l|fffd|schen
        For I = 1 To AnzZwischenDatei ' PDF Zwischendateien zusammenf|fffd|hren
            FSO.DeleteFile Pdf_Ablage & "\ZwischenDatei" & CStr(I) & ".PDF"
        Next I
    End If
    
   ' L|fffd|schen der Einzeldateien
   For Each objFile In objPdfFolder.Files
    If (InStr(objFile.Type, "Adobe Acrobat") > 0) And (Not Left(objFile.Name, 8) = "PE_TEMP_") Then
        arrDateiname = Split(objFile.Name, "_") '  7611_1210_PE_DV_
        If UBound(arrDateiname) > 3 Then
            If IsNumeric(arrDateiname(0)) And IsNumeric(arrDateiname(1)) And arrDateiname(2) = "PE" Then ' Einzeldatei gefunden
                ' l|fffd|schen der Einzeldatei
                objFile.Delete
            End If
        End If
    End If
   Next objFile
   
   PdfZusammenfassen = True
   Application.StatusBar = "PDF zusammenf|fffd|gen von : " & AnzahlPdfDateien & " Dateien wurde beendet!"
    Exit Function
    
ExitSub: 'es ist ein Fehler aufgetreten
PdfZusammenfassen = False

   On Error GoTo 0
   Exit Function

pdfzusammenfassen_Error:
PdfZusammenfassen = False

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure pdfzusammenfassen of Modul ModPED"
    
End Function

'---------------------------------------------------------------------------------------
' Procedure : AngabenMyVarPr|fffd|fen
' Author    : Renko Schmidt
' Date      : 16.07.2016
' Purpose   : Angaben in der Worksheet myVar pr|fffd|fen
'---------------------------------------------------------------------------------------
'
Function AngabenMyVarPr|fffd|fen() As Boolean


   On Error GoTo AngabenMyVarPr|fffd|fen_Error
    
    ' letztes Datum
    If Not BereichsnameOK("letztes_Auswahldatum", ThisWorkbook.Sheets("myVar")) Then
        Call MsgBox("Sheet 'myvar' Bereichsname: 'letztes_Auswahldatum'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    If BereichsnameOK("Datei_Mitarbeiterzuordnung", ThisWorkbook.Sheets("myVar")) Then
        If Not FSO.FileExists(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value) Then
            Debug.Print ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value & " nicht vorhanden!"
            Call MsgBox(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value, vbCritical, "Datei ist nicht vorhanden oder hat einen anderen Namen!")
            AngabenMyVarPr|fffd|fen = False
            Exit Function
        End If
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Datei_Mitarbeiterzuordnung'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
    End If

    If BereichsnameOK("Ordner_Wochenbericht", ThisWorkbook.Sheets("myVar")) Then
        If Not FSO.FolderExists(ThisWorkbook.Sheets("myvar").Range("Ordner_Wochenbericht").Value) Then
            Debug.Print ThisWorkbook.Sheets("myvar").Range("Ordner_Wochenbericht").Value & " nicht vorhanden!"
            Call MsgBox(ThisWorkbook.Sheets("myvar").Range("Ordner_Wochenbericht").Value, vbCritical, "Datei ist nicht vorhanden oder hat einen anderen Namen!")
            AngabenMyVarPr|fffd|fen = False
            Exit Function
        End If
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Ordner_Wochenbericht'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
    End If
    
    ' Ordner_Druckdateien
    If BereichsnameOK("Ordner_Druckdateien", ThisWorkbook.Sheets("myVar")) Then
        If Not FSO.FolderExists(ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value) Then
            Debug.Print ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value & " nicht vorhanden!"
            Call MsgBox(ThisWorkbook.Sheets("myvar").Range("Ordner_Druckdateien").Value, vbCritical, "Datei ist nicht vorhanden oder hat einen anderen Namen!")
            AngabenMyVarPr|fffd|fen = False
            Exit Function
        End If
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Ordner_Druckdateien'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
    End If
    
    ' Spalte_PNR
    If BereichsnameOK("Spalte_PNR", ThisWorkbook.Sheets("myVar")) Then
        Spalte_PNRCol = Range(ThisWorkbook.Sheets("myvar").Range("Spalte_PNR").Value & "1").Column
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Spalte_PNR'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    ' Spalte_Name
    If BereichsnameOK("Spalte_Name", ThisWorkbook.Sheets("myVar")) Then
        Spalte_NameCol = Range(ThisWorkbook.Sheets("myvar").Range("Spalte_Name").Value & "1").Column
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Spalte_Name'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    ' Spalte_Kostenstelle
    If BereichsnameOK("Spalte_Kostenstelle", ThisWorkbook.Sheets("myVar")) Then
        Spalte_KostenstelleCol = Range(ThisWorkbook.Sheets("myvar").Range("Spalte_Kostenstelle").Value & "1").Column
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Spalte_Kostenstelle'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    ' Spalte_Abteilung
    If BereichsnameOK("Spalte_Abteilung", ThisWorkbook.Sheets("myVar")) Then
        Spalte_AbteilungCol = Range(ThisWorkbook.Sheets("myvar").Range("Spalte_Abteilung").Value & "1").Column
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Spalte_Abteilung'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    ' Spalte_Ordner
    If BereichsnameOK("Spalte_Ordner", ThisWorkbook.Sheets("myVar")) Then
        Spalte_OrdnerCol = Range(ThisWorkbook.Sheets("myvar").Range("Spalte_Ordner").Value & "1").Column
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Spalte_Ordner'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    ' Spalte_Erfassungsbogen
    If BereichsnameOK("Spalte_Erfassungsbogen", ThisWorkbook.Sheets("myVar")) Then
        Spalte_ErfassungsbogenCol = Range(ThisWorkbook.Sheets("myvar").Range("Spalte_Erfassungsbogen").Value & "1").Column
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Spalte_Erfassungsbogen'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    'Personalnummer
    If BereichsnameOK("Mitarbeitername", ThisWorkbook.Sheets("myVar")) Then
        PersonalnummerCol = Range(ThisWorkbook.Sheets("myvar").Range("Personalnummer").Value).Column
        PersonalnummerRow = Range(ThisWorkbook.Sheets("myvar").Range("Personalnummer").Value).Row
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Personalnummer'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    ' Mitarbeitername
    If BereichsnameOK("Mitarbeitername", ThisWorkbook.Sheets("myVar")) Then
        MitarbeiterNameCol = Range(ThisWorkbook.Sheets("myvar").Range("Mitarbeitername").Value).Column
        MitarbeiterNameRow = Range(ThisWorkbook.Sheets("myvar").Range("Mitarbeitername").Value).Row
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Mitarbeitername'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    ' Zelle_KW
    If BereichsnameOK("Zelle_KW", ThisWorkbook.Sheets("myVar")) Then
        Zelle_KWCol = Range(ThisWorkbook.Sheets("myvar").Range("Zelle_KW").Value).Column
        Zelle_KWRow = Range(ThisWorkbook.Sheets("myvar").Range("Zelle_KW").Value).Row
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Zelle_KW'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    ' Zelle_Monat
    If BereichsnameOK("Zelle_Monat", ThisWorkbook.Sheets("myVar")) Then
        Zelle_MonatCol = Range(ThisWorkbook.Sheets("myvar").Range("Zelle_Monat").Value).Column
        Zelle_MonatRow = Range(ThisWorkbook.Sheets("myvar").Range("Zelle_Monat").Value).Row
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Zelle_Monat'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    ' Abteilungsname
    If BereichsnameOK("Abteilungsname", ThisWorkbook.Sheets("myVar")) Then
        AbteilungsnameCol = Range(ThisWorkbook.Sheets("myvar").Range("Abteilungsname").Value).Column
        AbteilungsnameRow = Range(ThisWorkbook.Sheets("myvar").Range("Abteilungsname").Value).Row
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'Abteilungsname'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    ' ersteWochenBezeichnung
    If BereichsnameOK("ersteWochenBezeichnung", ThisWorkbook.Sheets("myVar")) Then
        ersteWochenBezeichnungCol = Range(ThisWorkbook.Sheets("myvar").Range("ersteWochenBezeichnung").Value).Column
        ersteWochenBezeichnungRow = Range(ThisWorkbook.Sheets("myvar").Range("ersteWochenBezeichnung").Value).Row
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'ersteWochenBezeichnung'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    ' ersterWochentag
    If BereichsnameOK("ersterWochentag", ThisWorkbook.Sheets("myVar")) Then
        ersterWochentagCol = Range(ThisWorkbook.Sheets("myvar").Range("ersterWochentag").Value).Column
        ersterWochentagRow = Range(ThisWorkbook.Sheets("myvar").Range("ersterWochentag").Value).Row
    Else
        Call MsgBox("Sheet 'myvar' Bereichsname: 'ersterWochentag'", vbCritical, "Bereichsname nicht vorhanden oder hat einen anderen Namen!")
        AngabenMyVarPr|fffd|fen = False
        Exit Function
    End If
    
    AngabenMyVarPr|fffd|fen = True

   On Error GoTo 0
   Exit Function

AngabenMyVarPr|fffd|fen_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure AngabenMyVarPr|fffd|fen of Modul ModPED"
    
End Function


'---------------------------------------------------------------------------------------
' Procedure : |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung
' Author    : Renko Schmidt
' Date      : 16.07.2016
' Purpose   : Alle Dateinamen in der Steuertabelle Pr|fffd|fen
'---------------------------------------------------------------------------------------
'
Function |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung() As Boolean
 '
    
  Dim intZeile: Dim Zelle
  Dim strgOrdnerName: Dim strgDateiName: Dim strgFehlermeldung: Dim FehlerInFunctionAufgetreten As Boolean
  
   On Error GoTo |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung_Error

    If Not AngabenMyVarPr|fffd|fen Then Exit Function
    strgMeldungen = "": FehlerInFunctionAufgetreten = False
    
    If FSO.FileExists(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value) Then
        If WB_Exists(Get_FileName(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value)) Then
            Set WB_Mitarbeiterzuordnung = Workbooks(Get_FileName(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value))
            Set WS_Mitarbeiterzuordnung = WB_Mitarbeiterzuordnung.Sheets(1)  ' Worksheet
            WS_Mitarbeiterzuordnung.Activate '.Select
        Else
            Workbooks.Open ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value, Notify:=False, UpdateLinks:=False, ReadOnly:=True
            ' die ge|fffd|ffnete Datei dem Object zuordnen
            Set WB_Mitarbeiterzuordnung = ActiveWorkbook
            Set WS_Mitarbeiterzuordnung = WB_Mitarbeiterzuordnung.Sheets(1)  ' Worksheet
        End If
    Else
        Call MsgBox(ThisWorkbook.Sheets("myvar").Range("Datei_Mitarbeiterzuordnung").Value, vbCritical, "Abbruch: Datei ist nicht vorhanden!")
        Exit Function
    End If
    
    WS_MitarbeiterzuordnungLastCol = FindLastColumn
    WS_MitarbeiterzuordnungLastRow = FindLastRow
    Set WS_MitarbeiterzuordnungPNRBereich = WS_Mitarbeiterzuordnung.Range(Cells(5, Spalte_PNRCol), Cells(WS_MitarbeiterzuordnungLastRow, Spalte_PNRCol))
    
  '  Debug.Print WB_Mitarbeiterzuordnung.Name
  '  Debug.Print WS_Mitarbeiterzuordnung.Name & " " & WS_MitarbeiterzuordnungPNRBereich.Rows.Count
    
    For Each Zelle In WS_MitarbeiterzuordnungPNRBereich
        ' alle Eintr|fffd|ge in der Steuerdatei mit den Mitarbeiterzuordnungen pr|fffd|fen
        If Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_PNRCol).Value) Then
            If Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_KostenstelleCol).Value) Then
                If Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_OrdnerCol).Value) Then
                    strgOrdnerName = ThisWorkbook.Sheets("myvar").Range("Ordner_Wochenbericht").Value & "\" & WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_OrdnerCol).Value
                    If InStr(Trim(strgOrdnerName), " ") > 0 Then ' Fehler im Ordnernamen
                        FehlerInFunctionAufgetreten = True
                        strgMeldungen = strgMeldungen & strgOrdnerName & " Leerzeichen sind nicht erlaubt!" & vbCrLf
                    End If
                    If Not FSO.FolderExists(strgOrdnerName) Then
                        Debug.Print strgOrdnerName & " nicht vorhanden!"
                        strgMeldungen = strgMeldungen & strgOrdnerName & " nicht vorhanden!" & vbCrLf
                        FehlerInFunctionAufgetreten = True
                        |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung = False
                    Else
                        If Not IsEmpty(WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_ErfassungsbogenCol).Value) Then
                            strgDateiName = strgOrdnerName & "\" & WS_Mitarbeiterzuordnung.Cells(Zelle.Row, Spalte_ErfassungsbogenCol).Value
                            If InStr(Trim(strgDateiName), " ") > 0 Then ' Fehler im DateiNamen
                                FehlerInFunctionAufgetreten = True
                                strgMeldungen = strgMeldungen & strgDateiName & " Leerzeichen sind nicht erlaubt!" & vbCrLf
                            End If
                            If Not FSO.FileExists(strgDateiName) Then
                                strgFehlermeldung = "Zeile:" & CStr(Zelle.Row) & " Spalte:" & CStr(Spalte_ErfassungsbogenCol) & " " & strgDateiName
                                Debug.Print strgFehlermeldung & " nicht vorhanden!"
                                strgMeldungen = strgMeldungen & strgFehlermeldung & " nicht vorhanden!" & vbCrLf
                                FehlerInFunctionAufgetreten = True
                                |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung = False
                            Else
                                AnzahlZuordnungen = AnzahlZuordnungen + 1
                            End If
                        End If
                    End If
                End If
            End If
        End If
    
    Next Zelle
    
    If FehlerInFunctionAufgetreten Then
        |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung = False
        Call MsgBox(strgMeldungen, vbCritical, "Abbruch!: In der Tabelle " & WB_Mitarbeiterzuordnung.Name & " sind nachfolgende Fehler aufgetreten!")
    Else
        |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung = True
    End If

   On Error GoTo 0
   Exit Function

|fffd|ffnenPr|fffd|fenMitarbeiterzuordnung_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure |fffd|ffnenPr|fffd|fenMitarbeiterzuordnung of Modul ModPED"
    
End Function
Attribute VB_Name = "Prozeduren"
'---------------------------------------------------------------------------------------
' Module    : Prozeduren
' Author    : Renko Schmidt
' Date      : 14.07.2016
' Purpose   : Sammlung von allgemeinen Funktionen und Prozeduren
'---------------------------------------------------------------------------------------
Option Explicit

Public Declare Function GetVersionExA Lib "kernel32" (lpVersionInformation As OSVERSIONINFO) As Integer

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128
End Type

Function DayOfWeekEurop(dtmDate As Date) As Integer
' Wochennummer nach europ|fffd|ischer Norm
' F|fffd|r die WEEKNUM-Funktion wird angenommen, dass die Woche, in die der 1. Januar f|fffd|llt, die erste Woche des Jahres darstellt.
' Es gibt jedoch einen europ|fffd|ischen Standard, nach dem die erste Woche als so festgelegt wird, dass die meisten Tage (mindestens vier) in das neue Jahr fallen.
' Dies bedeutet, dass die WEEKNUM-Funktion f|fffd|r Jahre, in denen drei oder weniger Tage in die erste Januarwoche fallen, Wochenzahlen zur|fffd|ckgibt,
' die laut europ|fffd|ischem Standard falsch sind.
    WoTag_Jan1 = WorksheetFunction.Weekday(VBA.DateSerial(VBA.Year(dtmDate), 1, 1), 2)
    If WoTag_Jan1 > 3 Then ' Jahr beginnt mit der zweiten Woche
        DayOfWeekEurop = WorksheetFunction.WeekNum(dtmDate, 2) - 1
    Else
        DayOfWeekEurop = WorksheetFunction.WeekNum(dtmDate, 2)
    End If

End Function

Function fnDateFromWeek(iYear As Integer, iWeek As Integer, iWeekDday As Integer)
' get the date from a certain day in a certain week in a certain year
Dim curDate
    If iYear = 2016 Then
        curDate = DateSerial(iYear, 1, ((iWeek) * 7) _
          + iWeekDday - Weekday(DateSerial(iYear, 1, 1)) + 1)
    Else
        curDate = DateSerial(iYear, 1, ((iWeek - 1) * 7) _
          + iWeekDday - Weekday(DateSerial(iYear, 1, 1)) + 1)
    End If
    fnDateFromWeek = curDate
    
End Function

Function dhFirstDayInWeek(Optional dtmDate As Date = 0) As Date
    ' Returns the first day in the week specified
    ' by the date in dtmDate.
    ' Uses localized settings for the first day of the week.

    If dtmDate = 0 Then
        ' Did the caller pass in a date? If not, use
        ' the current date.
        dtmDate = Date
    End If
    dhFirstDayInWeek = dtmDate - Weekday(dtmDate, _
     vbUseSystem) + 1
End Function

Function dhLastDayInWeek(Optional dtmDate As Date = 0) As Date
    ' Returns the last day in the week specified by
    ' the date in dtmDate.
    ' Uses localized settings for the first day of the week.
    If dtmDate = 0 Then
        ' Did the caller pass in a date? If not, use
        ' the current date.
        dtmDate = Date
    End If
    dhLastDayInWeek = dtmDate - Weekday(dtmDate, vbUseSystem) + 7
End Function

Function dhPreviousDOW(intDOW As Integer, _
 Optional dtmDate As Date = 0) As Date
 
    ' Find the previous specified day of the week
    ' before the specified date.
    Dim intTemp As Integer
    If dtmDate = 0 Then
        ' Did the caller pass in a date? If not, use
        ' the current date.
        dtmDate = Date
    End If
    intTemp = Weekday(dtmDate, vbMonday)
    dhPreviousDOW = dtmDate - intTemp + intDOW - IIf(intTemp > intDOW, 0, 7)
    
End Function

Function dhNextDOW(intDOW As Integer, _
 Optional dtmDate As Date = 0) As Date
 
    ' Find the next specified day of the week after the specified date.
    Dim intTemp As Integer
    If dtmDate = 0 Then
        ' Did the caller pass in a date? If not, use
        ' the current date.
        dtmDate = Date
    End If
    intTemp = Weekday(dtmDate, vbMonday)
    dhNextDOW = dtmDate - intTemp + intDOW + IIf(intTemp < intDOW, 0, 7)
    
End Function
Public Function Week2Date(WeekNo As Long, Optional ByVal Yr As Long = 0, _
        Optional ByVal DOW As VBA.VbDayOfWeek = VBA.VbDayOfWeek.vbUseSystemDayOfWeek, _
        Optional ByVal FWOY As VBA.VbFirstWeekOfYear = VBA.VbFirstWeekOfYear.vbUseSystem) As Date
 ' Returns First Day of week
 Dim Jan1 As Date
 Dim Sub1 As Boolean
 Dim ret As Date

 If Yr = 0 Then
   Jan1 = VBA.DateSerial(VBA.Year(VBA.Date()), 1, 1)
 Else
   Jan1 = VBA.DateSerial(Yr, 1, 1)
 End If
 Sub1 = (VBA.Format(Jan1, "ww", DOW, FWOY) = 1)
 ret = VBA.DateAdd("ww", WeekNo + Sub1, Jan1)
 ret = ret - VBA.Weekday(ret, DOW) + 1
 Week2Date = ret
 
End Function

'---------------------------------------------------------------------------------------
' Procedure : FeierTag
' DateTime  : 26.11.2007 14:46
' Author    : Renko Schmidt
' Purpose   : Prozedur ermittelt ob ein Tag auf einem Feiertag f|fffd|llt.
'---------------------------------------------------------------------------------------
'
Public Function FeierTag(DATUM As Date) As String

    Dim Jahr As Integer
   On Error GoTo FeierTag_Error

    Jahr = Year(DATUM)
    If (Jahr > 1904) And (Jahr < 2100) Then
        Select Case Format$(DATUM, "dd.mm")
            ' Gesetzliche Feiertage
            Case "01.01": FeierTag = "Neujahr"
      '      Case "06.01": FeierTag = "Heilige Drei K|fffd|nige"
            Case "01.05": FeierTag = "Tag der Arbeit"
       '     Case "15.08": FeierTag = "Mari|fffd| Himmelfahrt"
            Case "03.10": FeierTag = "Tag der Deutschen Einheit"
       '     Case "31.10": FeierTag = "Reformationstag"
       '     Case "01.11": FeierTag = "Allerheiligen"
            Case "24.12": FeierTag = "Heiligabend"
            Case "25.12": FeierTag = "1. Weihnachtsfeiertag"
            Case "26.12": FeierTag = "2. Weihnachtsfeiertag"
            Case "31.12": FeierTag = "Sylvester"
            Case Else
                ' Bewegliche Feste:
                Select Case DATUM - Ostern(Year(DATUM))
       '             Case -52: FeierTag = "Weiberfastnacht"
       '             Case -48: FeierTag = "Rosenmontag"
                    Case -2:  FeierTag = "Karfreitag"
                    Case 0:  FeierTag = "Ostersonntag"
                    Case 1:  FeierTag = "Ostermontag"
                    Case 39:  FeierTag = "Christi Himmelfahrt"
                    Case 49:  FeierTag = "Pfingstsonntag"
                    Case 50:  FeierTag = "Pfingstmontag"
        '            Case 60:  FeierTag = "Fronleichnam"
                    Case Else
                            FeierTag = Format$(DATUM, "ddd")  ' Kein Feiertag
         
                End Select
        End Select
        
    Else: FeierTag = vbNullString
    End If

   On Error GoTo 0
   Exit Function

FeierTag_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure FeierTag of Modul Prozeduren"
    
End Function

'---------------------------------------------------------------------------------------
' Procedure : Ostern
' DateTime  : 26.11.2007 14:45
' Author    : Renko Schmidt
' Purpose   : Funktion errechnet den Ostersonntag f|fffd|r ein bestimmtes Jahr
'---------------------------------------------------------------------------------------
'
Function Ostern(Yr As Integer) As Date

   Dim d As Integer
   On Error GoTo Ostern_Error

   d = (((255 - 11 * (Yr Mod 19)) - 21) Mod 30) + 21
   Ostern = DateSerial(Yr, 3, 1) + d + (d > 48) + 6 - _
    ((Yr + Yr \ 4 + d + (d > 48) + 1) Mod 7)

   On Error GoTo 0
   Exit Function

Ostern_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure Ostern of Modul Prozeduren"
End Function

'---------------------------------------------------------------------------------------
' Procedure : BereichsnameOK
' DateTime  : 06.11.2006 14:56
' Author    : schmidt
' Purpose   : Funktion soll pr|fffd|fen, ob ein Bereichsname vorhaden ist
'---------------------------------------------------------------------------------------
'
Function BereichsnameOK(Name As String, sws As Worksheet)

On Error GoTo KeinBereich

If sws.Range(Name).Column > 0 Then ' Test ob Appl. Error auftritt
End If
GoTo BereichOK

KeinBereich:
BereichsnameOK = False
Err.Clear
On Error GoTo 0
GoTo EndeFunktion

BereichOK:
BereichsnameOK = True

EndeFunktion:

End Function

'---------------------------------------------------------------------------------------
' Procedure : WB_Exists
' DateTime  : 07.11.2006 06:18
' Author    : schmidt
' Purpose   : Funktion |fffd|berpr|fffd|ft die Liste der Workbooks auf vorhandensein einer bestimmten Workbook
'---------------------------------------------------------------------------------------
'
Function WB_Exists(WB_Name) As Boolean

Dim Wb As Workbook

WB_Exists = False ' default
If Workbooks.Count = 0 Then Exit Function

For Each Wb In Workbooks
    'Debug.Print WB.Name
    If Right(WB_Name, 1) = "%" Then ' left
    
        If Left(Wb.Name, Len(WB_Name) - 1) = Left(WB_Name, Len(WB_Name) - 1) Then
            WB_Exists = True
        End If

    Else
        If Wb.Name = WB_Name Then
            WB_Exists = True
        End If
    End If
Next Wb

End Function

'---------------------------------------------------------------------------------------
' Procedure : WS_Exists
' DateTime  : 07.11.2006 06:18
' Author    : schmidt
' Purpose   : Funktion |fffd|berpr|fffd|ft die Liste der Worksheets auf vorhandensein einer bestimmten Worksheet
'---------------------------------------------------------------------------------------
'
Function WS_Exists(WS_Name) As Boolean

Dim Wb As Workbook
Dim WS As Worksheet

WS_Exists = False ' default
If Workbooks.Count = 0 Then Exit Function

Set Wb = ActiveWorkbook
For Each WS In Wb.Sheets
    'Debug.Print ws.name
    If WS.Name = WS_Name Then
        WS_Exists = True
    End If
Next WS

End Function

'---------------------------------------------------------------------------------------
' Procedure : Get_FileName
' DateTime  : 06.11.2006 14:53
' Author    : schmidt
' Purpose   : Ermittlung eines Dateinamens im Pfad
'---------------------------------------------------------------------------------------
'
Function Get_FileName(F_FilePath)
'
Dim I

   On Error GoTo Get_FileName_Error
I = 1
Do While InStr(I + 1, F_FilePath, "/") > 0
    I = InStr(I + 1, F_FilePath, "/")
    F_FilePath = Left(F_FilePath, I - 1) & "\" & Right(F_FilePath, Len(F_FilePath) - I)
Loop

I = 1
Do While InStr(I + 1, F_FilePath, "\") > 0
    I = InStr(I + 1, F_FilePath, "\")
Loop
Get_FileName = Right(F_FilePath, Len(F_FilePath) - I)

   On Error GoTo 0
   Exit Function

Get_FileName_Error:

 MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure Get_FileName of Modul Main_Modul"

    
End Function

' Procedure : FindLastRow
' DateTime  : 01.12.2006 15:32
' Author    : Renko Schmidt
' Purpose   : letzte belegte Zeile finden
'---------------------------------------------------------------------------------------
'
Function FindLastRow()

Dim LastRow As Long

   On Error GoTo FindLastRow_Error

    If WorksheetFunction.CountA(Cells) > 0 Then
        'Search for any entry, by searching backwards by Rows.
        LastRow = Cells.Find(What:="*", After:=[A1], _
              SearchOrder:=xlByRows, _
              SearchDirection:=xlPrevious).Row
        FindLastRow = LastRow
    End If

   On Error GoTo 0
   Exit Function

FindLastRow_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure FindLastRow of Modul Prozeduren"
    
End Function

'---------------------------------------------------------------------------------------
' Procedure : FindLastColumn
' DateTime  : 01.12.2006 15:32
' Author    : Renko Schmidt
' Purpose   : letzte belegte Spalte finden
'---------------------------------------------------------------------------------------
'
Function FindLastColumn()

Dim LastColumn As Integer
   On Error GoTo FindLastColumn_Error

    If WorksheetFunction.CountA(Cells) > 0 Then
        'Search for any entry, by searching backwards by Columns.
        LastColumn = Cells.Find(What:="*", After:=[A1], _
                           SearchOrder:=xlByColumns, _
                       SearchDirection:=xlPrevious).Column
        FindLastColumn = LastColumn
    End If

   On Error GoTo 0
   Exit Function

FindLastColumn_Error:

    MsgBox "Error " & Err.Number & " (" & Err.Description & ") in procedure FindLastColumn of Modul Prozeduren"
    
End Function

Public Function getVersion() As String

    Dim osinfo As OSVERSIONINFO
    Dim retvalue As Integer

    osinfo.dwOSVersionInfoSize = 148
    osinfo.szCSDVersion = Space$(128)
    retvalue = GetVersionExA(osinfo)

    Select Case osinfo.dwMajorVersion + osinfo.dwMinorVersion / 10
        Case 5#
            getVersion = "Windows 2000"
        Case 5.1
            getVersion = "Windows XP (32-bit)"
        Case 5.2
            getVersion = "Windows XP (64-bit), 2003 Server, Home Server"
        Case 6#
            getVersion = "Windows Vista, 2008 Server"
        Case 6.1
            getVersion = "Windows 7, 2008 Server R2"
        Case Else
            getVersion = "Other version"
    End Select
    

End Function


'---------------------------------------------------------------------------------------
' Procedure : ElapsedTime
' DateTime  : 30.12.2003 14:46
' Author    : Schmidt
' Purpose   : ermittelt zwischen 2 Tickcounts die abgelaufende Uhrzeit
'---------------------------------------------------------------------------------------
'
Public Function ElapsedTime() As String

Dim TempMilliTime As Long
Dim TempTime As Long
Dim HoursVar As Integer
Dim MinutesVar As Integer
Dim SecondsVar As Integer

   If EndPointer = 0 Then
      TempMilliTime = GetTickCount() - BeginPointer
   Else
      TempMilliTime = EndPointer - BeginPointer
   End If

   TempTime = TempMilliTime \ 1000 ' Sekunden

   'Is TempTime equal to or more than 60 seconds
   If TempTime >= 60 Then
      MinutesVar = TempTime \ 60
      SecondsVar = TempTime Mod 60

      If MinutesVar >= 60 Then

         HoursVar = MinutesVar \ 60
         MinutesVar = MinutesVar Mod 60
         ElapsedTime = Format(HoursVar & ":" & MinutesVar & ":" & SecondsVar, "hh:mm:ss")
         
      Else

         ElapsedTime = Format("00" & ":" & MinutesVar & ":" & SecondsVar, "hh:mm:ss")
      End If
   
   'The elapsed time is < a minute
   Else
      ElapsedTime = Format("00:" & "00:" & TempTime, "hh:mm:ss")
   End If

End Function
Attribute VB_Name = "RegHandApi"
Option Explicit
Option Private Module
'-------------------------------------------------------------------------------------------'
'   This Registry handler is developed by Ronald Kas (r.kas@kaycys.com)                     '
'   from Kaycys (http://www.kaycys.com).                                                    '
'                                                                                           '
'   You may use this Registry Handler for all purposes except from making profit with it.   '
'   Check our site regulary for updates.                                                    '
'-------------------------------------------------------------------------------------------'


' Declare Windows API functions...
Public Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long
Public Declare Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" (ByVal hKey As Long, _
                        ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, _
                        ByVal dwOptions As Long, ByVal samDesired As Long, _
                        ByRef lpSecurityAttributes As SECURITY_ATTRIBUTES, ByRef phkResult As Long, _
                        ByRef lpdwDisposition As Long) As Long
Public Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As Long, _
                        ByVal lpSubKey As String) As Long
Public Declare Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As Long, _
                        ByVal dwIndex As Long, ByVal lpName As String, ByRef lpcbName As Long, _
                        ByVal lpReserved As Long, ByVal lpClass As String, ByRef lpcbClass As Long, _
                        lpftLastWriteTime As FILE_TIME) As Long
Public Declare Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" (ByVal hKey As Long, _
                        ByVal dwIndex As Long, ByVal lpValueName As String, ByRef lpcbValueName As Long, _
                        ByVal lpReserved As Long, ByRef lpType As Long, ByRef lpData As Any, _
                        ByRef lpcbData As Long) As Long
Public Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, _
                        ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, _
                        ByRef phkResult As Long) As Long
Public Declare Function RegQueryValueEx Lib "advapi32" Alias "RegQueryValueExA" (ByVal hKey As Long, _
                        ByVal lpValueName As String, ByVal lpReserved As Long, ByRef lpType As Long, _
                        ByVal lpData As String, ByRef lpcbData As Long) As Long
Public Declare Function RegQueryInfoKey Lib "advapi32.dll" Alias "RegQueryInfoKeyA" (ByVal hKey As Long, _
                        ByVal lpClass As String, ByRef lpcbClass As Long, ByVal lpReserved As Long, _
                        ByRef lpcSubKeys As Long, ByRef lpcbMaxSubKeyLen As Long, ByRef lpcbMaxClassLen As Long, _
                        ByRef lpcValues As Long, ByRef lpcbMaxValueNameLen As Long, ByRef lpcbMaxValueLen As Long, _
                        ByRef lpcbSecurityDescriptor As Long, ByRef lpftLastWriteTime As FILE_TIME) As Long
Public Declare Function RegSetValueExString Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, _
                        ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, _
                        ByVal lpValue As String, ByVal cbData As Long) As Long
Public Declare Function RegSetValueExBoolean Lib "advapi32" Alias "RegSetValueExA" (ByVal hKey As Long, _
                        ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, _
                        ByRef lpData As Boolean, ByVal cbData As Long) As Long
Public Declare Function RegSetValueExLong Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, _
                        ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, _
                        ByRef lpValue As Long, ByVal cbData As Long) As Long
Public Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long
Public Declare Function RegFlushKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

                        
' Declare Windows API constants...
Public Const lngHKEY_CLASSES_ROOT = &H80000000
Public Const lngHKEY_CURRENT_USER = &H80000001
Public Const lngHKEY_LOCAL_MACHINE = &H80000002
Public Const lngHKEY_USERS = &H80000003

Public Const lngERROR_SUCCESS = 0&
Public Const lngERROR_FAILURE = 13&
Public Const lngUNREADABLE_NODE = 234&
Public Const lngNO_MORE_NODES = 259&
Public Const lngERROR_MORE_DATA = 234&

Public Const lngREG_OPTION_NON_VOLATILE = 0
Public Const lngSYNCHRONIZE = &H100000
Public Const lngSTANDARD_RIGHTS_READ = &H20000
Public Const lngKEY_QUERY_VALUE = &H1
Public Const lngKEY_ENUMERATE_SUB_KEYS = &H8
Public Const lngKEY_NOTIFY = &H10
Public Const lngKEY_SET_VALUE = &H2
Public Const lngKEY_CREATE_SUB_KEY = &H4
Public Const lngKEY_CREATE_LINK = &H20
Public Const lngSTANDARD_RIGHTS_ALL = &H1F0000
Public Const lngKEY_READ = ((lngSTANDARD_RIGHTS_READ Or lngKEY_QUERY_VALUE Or lngKEY_ENUMERATE_SUB_KEYS Or _
                             lngKEY_NOTIFY) And (Not lngSYNCHRONIZE))
Public Const lngKEY_ALL_ACCESS = ((lngSTANDARD_RIGHTS_ALL Or lngKEY_QUERY_VALUE Or lngKEY_SET_VALUE Or _
                                   lngKEY_CREATE_SUB_KEY Or lngKEY_ENUMERATE_SUB_KEYS Or lngKEY_NOTIFY Or _
                                   lngKEY_CREATE_LINK) And (Not lngSYNCHRONIZE))
Public Const lngREG_SZ = 1
Public Const lngREG_BINARY = 3
Public Const lngREG_DWORD = 4

' Declare Windows API types...
Public Type FILE_TIME
  dwLowDateTime As Long
  dwHighDateTime As Long
End Type
Type SECURITY_ATTRIBUTES
  nLength As Long
  lpSecurityDescriptor As Long
  bInheritHandle As Boolean
End Type



Attribute VB_Name = "RegistryHandler"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'-------------------------------------------------------------------------------------------'
'   This Registry handler is developed by Ronald Kas (r.kas@kaycys.com)                     '
'   from Kaycys (http://www.kaycys.com).                                                    '
'                                                                                           '
'   You may use this Registry Handler for all purposes except from making profit with it.   '
'   Check our site regulary for updates.                                                    '
'-------------------------------------------------------------------------------------------'


Enum HKEYS
    HKEY_CLASSES_ROOT = &H80000000
    HKEY_CURRENT_USER = &H80000001
    HKEY_LOCAL_MACHINE = &H80000002
    HKEY_USERS = &H80000003
End Enum

Public Function WriteRegValue(ByVal vhRootKey As HKEYS, ByVal vstrKeyName As String, ByVal vstrValueName As String, ByVal vvntValue As Variant) As String
  Dim strMessage As String, strError As String, strResult As String
  Dim hKeyHandle As Long
  
  ' Call each of the neccessary functions in turn starting with OpenRegistryKey...
  Call OpenRegistryKey(vhRootKey, vstrKeyName, hKeyHandle)
    Call CreateRegistryKey(vhRootKey, vstrKeyName, hKeyHandle)
  
  ' then Write the value...
  Call WriteRegistryValue(hKeyHandle, vstrValueName, vvntValue)
  
  ' and close the opened key.
  Call CloseRegistryKey(hKeyHandle)

End Function

Public Function GetRegValue(RootKey As HKEYS, sKey As String, sValueName As String) As Variant
    Dim hKeyHandle As Long
    Dim vTemp As Variant
    Call RegOpenKeyEx(RootKey, sKey, 0&, lngKEY_ALL_ACCESS, hKeyHandle)
    If hKeyHandle = 0 Then Exit Function
    ReadRegistryValue hKeyHandle, sValueName, vTemp
    Call RegCloseKey(hKeyHandle)
    GetRegValue = vTemp
End Function


Public Function EnumKeys(RootKey As HKEYS, sKey As String) As Variant
    Dim hKeyHandle As Long
    Dim x As Variant
    Call RegOpenKeyEx(RootKey, sKey, 0&, lngKEY_ALL_ACCESS, hKeyHandle)
    If hKeyHandle = 0 Then Exit Function
    Call EnumerateRegistryKeys(hKeyHandle, x)
    Call RegCloseKey(hKeyHandle)
    EnumKeys = x
End Function


Public Sub DeleteKey(RootKey As HKEYS, sKey As String)
    Dim x As Variant
    Dim I As Integer
    Dim OrgKey As String
    OrgKey = sKey
    Do
        x = EnumKeys(RootKey, sKey)
        If IsEmpty(x) = False Then
            If UBound(x) <= 0 Then
                DeleteRegistryKey RootKey, sKey
                For I = Len(sKey) To 1 Step -1
                    If Mid$(sKey, I, 1) = "\" Then
                        sKey = Left$(sKey, I - 1)
                        Exit For
                    End If
                Next I
                If Len(sKey) < Len(OrgKey) Then
                    Exit Sub
                End If
            Else
                sKey = sKey & "\" & x(0)
            End If
        Else
            Exit Do
        End If
    Loop
End Sub

Public Sub DeleteValue(RootKey As HKEYS, sKey As String, sValueName As String)
    Dim lHandle As Long
    Call OpenRegistryKey(RootKey, sKey, lHandle)
    RegDeleteValue lHandle, sValueName
    CloseRegistryKey lHandle

End Sub


Public Function EnumValues(RootKey As HKEYS, sKey As String) As Variant
    Dim vEnum As Variant
    Dim lHandle As Long
    Dim vRet As Variant
    Dim I As Integer
    
    Call OpenRegistryKey(RootKey, sKey, lHandle)
    If lHandle = 0 Then Exit Function
    EnumerateRegistryValuesByHandle lHandle, vEnum
    Call CloseRegistryKey(lHandle)
    ReDim vRet(UBound(vEnum, 2))
    For I = 0 To UBound(vEnum, 2)
         vRet(I) = vEnum(1, I)
    Next I
    
    
    EnumValues = vRet
    


End Function

Public Sub RegFlush(RootKey As HKEYS)

Dim lngReturn As Long
lngReturn = RegFlushKey(RootKey)

End Sub

'------------------------------------------------------------------

Private Function CloseRegistryKey(ByVal vhKeyHandle As Long) As Boolean
    Dim lngReturn As Long
    
    lngReturn = RegCloseKey(vhKeyHandle)
    If lngReturn <> lngERROR_SUCCESS Then
        CloseRegistryKey = False
    Else
        CloseRegistryKey = True
    End If
End Function

Private Function CreateRegistryKey(ByVal vhKeyHandle As Long, ByVal vstrKeyName As String, ByRef rhNewKeyHandle As Long) As Long
  Dim lngReturn As Long, lngResult As Long, lngDepth As Long
  Dim typSecurityAttributes As SECURITY_ATTRIBUTES
  
  
  ' and then create the key.
  typSecurityAttributes.nLength = 50
  typSecurityAttributes.lpSecurityDescriptor = 0
  typSecurityAttributes.bInheritHandle = True
  lngReturn = RegCreateKeyEx(vhKeyHandle, vstrKeyName, 0, lngREG_SZ, lngREG_OPTION_NON_VOLATILE, lngKEY_ALL_ACCESS, typSecurityAttributes, rhNewKeyHandle, lngDepth)
  If lngReturn <> lngERROR_SUCCESS Then
    
  End If
Exit Function

End Function

Private Function DeleteRegistryKey(ByVal vhKeyHandle As Long, ByVal vstrKeyName As String) As String
  Dim lngReturn As Long
  
  ' and then delete the key.
  lngReturn = RegDeleteKey(vhKeyHandle, vstrKeyName)
End Function


Private Function EnumerateRegistryKeys(ByVal vhKeyHandle As Long, ByRef rvntKeys As Variant) As String
    Dim StrValue As String, strClass As String, strMessage As String, strError As String
    Dim hKeyHandle As Long, lngDataLen As Long, lngValueLen As Long, lngReturn As Long, lngIndex As Long
    Dim lngClass As Long
    Dim strNodes() As String
    Dim typFileTime As FILE_TIME
    
    lngIndex = 0
    
    ' then loop through the nodes under the 'base node'...
    Do
      lngValueLen = 2000
      StrValue = String(lngValueLen, 0)
      lngDataLen = 2000
    
      ' and read the names of all the nodes under it...
      lngReturn = RegEnumKeyEx(vhKeyHandle, lngIndex, StrValue, lngValueLen, 0&, strClass, lngClass, typFileTime)
      StrValue = Left(StrValue, lngValueLen)
      ' checking for problems.
      If lngReturn <> lngERROR_SUCCESS And lngReturn <> lngNO_MORE_NODES Then
      End If
      
      ' Add each node into an array...
      ReDim Preserve strNodes(lngIndex)
      strNodes(lngIndex) = StrValue
      lngIndex = lngIndex + 1
      
      ' and loop until the enumeration return fails.
    Loop While lngReturn <> lngNO_MORE_NODES
    rvntKeys = strNodes()
    Erase strNodes
End Function

Private Function EnumerateRegistryValuesByHandle(ByVal vhKeyHandle As Long, ByRef rvntValues As Variant) As String
    Dim StrValue As String, strMessage As String, strError As String
    Dim lngData As Long, lngDataLen As Long, lngValueLen As Long, lngReturn As Long, lngIndex As Long
    Dim lngValueType As Long
    Dim strNodes() As String
    Dim typFileTime As FILE_TIME
    
    ' then loop through the nodes under the 'base node'...
    Do
      lngValueLen = 2000
      StrValue = String(lngValueLen, 0)
      lngDataLen = 2000
    
      ' and read the names of all the nodes under it...
      lngReturn = RegEnumValue(vhKeyHandle, lngIndex, ByVal StrValue, lngValueLen, 0&, lngValueType, _
                               ByVal lngData, lngDataLen)
      StrValue = Left(StrValue, lngValueLen)
      
      ' checking for problems.
      If lngReturn <> lngERROR_SUCCESS And lngReturn <> lngNO_MORE_NODES Then
      End If
      
      ' Add each node into an array...
      ReDim Preserve strNodes(0 To 1, 0 To lngIndex)
      strNodes(0, lngIndex) = CStr(lngValueType)
      strNodes(1, lngIndex) = StrValue
      lngIndex = lngIndex + 1
      
      ' and loop until the enumeration return fails.
    Loop While lngReturn <> lngNO_MORE_NODES
    rvntValues = strNodes()
    Erase strNodes
End Function

Private Function OpenRegistryKey(ByVal vhRootKey As Long, ByVal vstrKeyName As String, ByRef rhKeyHandle As Long) As String
    Dim lngReturn As Long, hKeyHandle As Long
    
    ' then open the passed registry node (key) in the passed root key...
    lngReturn = RegOpenKeyEx(vhRootKey, vstrKeyName, 0&, lngKEY_ALL_ACCESS, hKeyHandle)
    If lngReturn <> lngERROR_SUCCESS Then
    End If
    
    rhKeyHandle = hKeyHandle
End Function


Private Function ReadRegistryValue(ByVal vhKeyHandle As Long, ByVal vstrValueName As String, _
                                  ByRef rvntValue As Variant) As String
  Dim strMessage As String, strError As String, strValueName As String, strData As String
  Dim lngReturn As Long, lngIndex As Long, lngValuesCount As Long, lngValueType As Long, lngValueLen As Long
  Dim lngValueMax As Long, lngData As Long, lngDataLen As Long
  Dim blnData As Boolean
  Dim vntValues As Variant
  Dim typFileTime As FILE_TIME
  
  ' Check that all required variables have been passed...
  If vhKeyHandle <= 0 Then
  End If
  If vstrValueName = "" Then
  End If
  
  ' and enumerate the keys to see what type of value is stored in the one to return. First get the number of values
  ' and the maximum name length of those stored in the passed key...
  lngReturn = RegQueryInfoKey(vhKeyHandle, "", 0&, 0&, 0&, 0&, 0&, lngValuesCount, lngValueMax, _
                              0&, 0&, typFileTime)
  If lngReturn <> lngERROR_SUCCESS Then
  End If
  lngValueLen = Len(vstrValueName) + 1
  
  ' then loop through the values until the requested value name is found.
  Call EnumerateRegistryValuesByHandle(vhKeyHandle, vntValues)
  For lngIndex = 0 To UBound(vntValues, 2)
    lngReturn = lngERROR_FAILURE
    strValueName = vntValues(1, lngIndex)
      
    
    ' Check that the currently enumerated key is the one requested...
    If LCase(vstrValueName) = LCase(strValueName) Then
      lngValueType = vntValues(0, lngIndex)
      lngValueLen = Len(strValueName)
      
      ' and, depending on the value type, read and return the stored value...
      Select Case lngValueType
        Case lngREG_BINARY
    
          ' it's a binary value...
          lngDataLen = 1
          lngReturn = RegEnumValue(vhKeyHandle, lngIndex, strValueName, lngValueLen, 0&, lngValueType, _
                                   blnData, lngDataLen)
          rvntValue = blnData
          Exit For
        Case lngREG_DWORD
    
          ' it's a DWord...
          lngDataLen = 4
          lngReturn = RegEnumValue(vhKeyHandle, lngIndex, strValueName, lngValueLen, 0&, lngValueType, _
                                   lngData, lngDataLen)
          rvntValue = lngData
          Exit For
        Case lngREG_SZ
    
          ' it's a string value.
          lngDataLen = 2048
          strData = String(lngDataLen, 0)
          lngReturn = RegQueryValueEx(vhKeyHandle, strValueName, 0&, lngValueType, strData, lngDataLen)
          rvntValue = Left(strData, lngDataLen - 1)
          Exit For
      End Select
    End If
  Next
  If lngReturn <> lngERROR_SUCCESS And lngReturn <> lngERROR_MORE_DATA Then
  End If

End Function

Private Function ReadValue(ByVal vhRootKey As Long, ByVal vstrKeyName As String, ByVal vstrValueName As String, ByRef rvntValue As Variant, Optional ByVal vvntDefault As Variant) As String
  Dim strReturn As String, strLanguageOffset As String, strMessage As String, strError As String
  Dim hKeyHandle As Long, lngReturn As Long, lngValueType As Long, hNewKeyHandle As Long
  
 
  ' Call each of the neccessary functions in turn starting with OpenRegistryKey...
  Do
    Call OpenRegistryKey(vhRootKey, vstrKeyName, hKeyHandle)
    If Not IsMissing(vvntDefault) Then
      Call CreateRegistryKey(vhRootKey, vstrKeyName, hKeyHandle)
      GoSub ValueWrite
    End If
  
    ' then read the value...
    strReturn = ReadRegistryValue(hKeyHandle, vstrValueName, rvntValue)
    If strReturn <> "" Then
      If Not IsMissing(vvntDefault) And rvntValue = "" Or rvntValue = 0 Then
        GoSub ValueWrite
      Else
        ReadValue = strReturn
        Exit Function
      End If
    Else
      Exit Do
    End If
  
    ' and close the opened key.
    Call CloseRegistryKey(hKeyHandle)
  Loop
  
  ' and close the opened key.
  Call CloseRegistryKey(hKeyHandle)
Exit Function

ValueWrite:
  strReturn = WriteRegistryValue(hKeyHandle, vstrValueName, vvntDefault)
  If strReturn <> "" Then
    ReadValue = strReturn
    Exit Function
  End If
  Return
End Function

Private Function WriteRegistryValue(ByVal vhKeyHandle As Long, ByVal vstrValueName As String, ByVal vvntValue As Variant) As String
  Dim strMessage As String, strError As String, StrValue As String
  Dim lngReturn As Long, lngValue As Long, lngLength As Long
  Dim blnValue As Boolean
  
  ' Check that all passed parameters are filled...
  
  ' and then write the value to the Value.
  Select Case VarType(vvntValue)
    Case vbString
      StrValue = vvntValue & Chr(0)
      lngLength = Len(StrValue)
      lngReturn = RegSetValueExString(vhKeyHandle, vstrValueName, 0&, lngREG_SZ, StrValue, lngLength)
    Case vbBoolean
      blnValue = CBool(vvntValue)
      lngReturn = RegSetValueExBoolean(vhKeyHandle, vstrValueName, 0&, lngREG_BINARY, blnValue, 1&)
    Case vbInteger, vbLong
      lngValue = CLng(vvntValue)
      lngReturn = RegSetValueExLong(vhKeyHandle, vstrValueName, 0&, lngREG_DWORD, lngValue, 4&)
    Case Else
    
      ' Unsupported value type...
      strMessage = "Unsupported value type"
  End Select
  If lngReturn <> lngERROR_SUCCESS Then
  End If
End Function


Attribute VB_Name = "Tabelle1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Tabelle2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "cCalendar"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

'###############################################################
'# Team authors:                                               #
'# Krisztina Szab|fffd|                                             #
'# G|fffd|bor Mad|fffd|cs                                                #
'# Roberto Mensa (nick r)                                      #
'# https://sites.google.com/site/e90e50/calendar-control-class #
'###############################################################

'# Event Triggered By Main Object
Public Event AfterUpdate()
Public Event BeforeUpdate(ByRef Cancel As Integer)
Public Event Click()
Public Event DblClick()
Public Event KeyDown( _
    ByVal KeyCode As MSForms.ReturnInteger, _
    ByVal Shift As Integer)

'# Members for Main Object
Private WithEvents CBxY As MSForms.ComboBox
Attribute CBxY.VB_VarHelpID = -1
Private WithEvents CBxM As MSForms.ComboBox
Attribute CBxM.VB_VarHelpID = -1

Private CLb As MSForms.Label
Private mDayButtons() As cCalendar
Private mLabelButtons() As cCalendar

Private PTitleNewFont As MSForms.NewFont
Private PDayNewFont As MSForms.NewFont
Private PGridNewFont As MSForms.NewFont
'# Members for Button Object
Private WithEvents CmB As MSForms.CommandButton
Attribute CmB.VB_VarHelpID = -1
Private CmBl As MSForms.Label
Private CmBlNum As MSForms.Label
Private mcMain As cCalendar

'# For Properties
Private lPFontSize As Long
Private lPMonthLength As calMonthLength
Private lPDayLength As Long
Private bPYearFirst As Boolean
Private lPTitleFontColor As Long
Private lPGridFontColor As Long
Private lPDayFontColor As Long
Private lPFirstDay As calDayOfWeek
Private dValue As Date
Private lPBackColor As Long
Private lPMonth As Long
Private lPYear As Long
Private lPDay As Long
Private lPHeaderBackColor As Long
Private lPUseDefaultBackColors  As Boolean
Private bPVisible As Boolean
Private sPHeight As Single
Private sPWidth As Single
Private sPTop As Single
Private sPLeft As Single
Private lPSaturdayBackColor As Long
Private lPSundayBackColor As Long
Private lPSelectedBackColor As Long
Private sPControlTipText As String
Private bPTabStop As Boolean
Private lPTabIndex As Long
Private sPTag As String

Private bPShowDays As Boolean
Private bPShowTitle As Boolean
Private bPShowDateSelectors As Boolean
Private bPValueIsNull As Boolean
Private bPRightToLeft As Boolean

Private bPMACFix As Boolean 'Fix MAC transparency errors
Private bPSaturdaySelectable As Boolean
Private bPSundaySelectable As Boolean

Private Const cDayFontColorSelected As Long = &H80000012 'Button text - Black
Private Const cDayFontColorInactive As Long = &H80000011 'Disabled text - Dark gray
Private Const cDefaultWidth As Single = 216
Private Const cDefaultHeight As Single = 144

Public Enum calDayOfWeek
    dwMonday = 1
    dwTuesday = 2
    dwWednesday = 3
    dwThursday = 4
    dwFriday = 5
    dwSaturday = 6
    dwSunday = 7
End Enum

Public Enum calMonthLength '(Used for month and day names too.)
    mlLocalLong = 0 'Local name, long form
    mlLocalShort = 1 'Local name, short form
    mlENLong = 2 'English name, long form
    mlENShort = 3 'English name, short form
End Enum



'################################################
'# Properties for Main object - Not available

Public Property Get GridCellEffect() As Long
'Property Blank - not work
'Determines the effect used to display the grid.
End Property

Public Property Get GridLinesColor() As Long
'Property Blank - not work
'Determines the color used to display the lines in the grid.
End Property

Public Property Get ShowHorizontalGrid() As Boolean
'Property Blank - not work
'Specifies whether the calendar display horizontal gridlines.
End Property

Public Property Get ShowVerticalGrid() As Boolean
'Property Blank - not work
'Specifies whether to display vertical gridlines.
End Property

Public Property Get HelpContextID() As Long
'Property Blank - not work
'Specifies Help identifier
End Property


'###########################
'# Properties for Main object

Public Property Get Tag() As String
    Tag = sPTag
End Property

Public Property Let Tag(sTag As String)
    sPTag = sTag
End Property

Public Property Get Parent() As Control
    If bInit Then
        Set Parent = CBxY.Parent.Parent
    Else
        Set Parent = Nothing
    End If
End Property

Public Property Get ValueIsNull() As Boolean
    ValueIsNull = bPValueIsNull
End Property

Public Property Let ValueIsNull(ByVal bValueIsNull As Boolean)
    bPValueIsNull = bValueIsNull
    If bInit Then
        Value = Value
    End If
End Property

Public Property Get ShowTitle() As Boolean
    ShowTitle = bPShowTitle
End Property

Public Property Let ShowTitle(ByVal bShowTitle As Boolean)
    bPShowTitle = bShowTitle
    If bInit Then
        CLb.Visible = bPShowTitle
        Call Move
    End If
End Property

Public Property Get ShowDays() As Boolean
    ShowDays = bPShowDays
End Property

Public Property Let ShowDays(ByVal bShowDays As Boolean)
    Dim I As Long
    bPShowDays = bShowDays
    If bInit Then
        For I = 0 To 6
            mLabelButtons(I).Obj_CmBl.Visible = bShowDays
        Next
        Call Move
    End If
End Property

Public Property Get ShowDateSelectors() As Boolean
    ShowDateSelectors = bPShowDateSelectors
End Property

Public Property Let ShowDateSelectors(ByVal bShowDateSelectors As Boolean)
    bPShowDateSelectors = bShowDateSelectors
    If bInit Then
        CBxY.Visible = bShowDateSelectors
        CBxM.Visible = bShowDateSelectors
        Call Move
    End If
End Property

Public Property Get TabIndex() As Long
    TabIndex = lPTabIndex
End Property

Public Property Let TabIndex(ByVal lTabIndex As Long)
    lPTabIndex = lTabIndex
    If bInit Then
        CBxY.Parent.TabIndex = lTabIndex
    End If
End Property

Public Property Get TabStop() As Boolean
    TabStop = bPTabStop
End Property

Public Property Let TabStop(ByVal bTabStop As Boolean)
    bPTabStop = bTabStop
    If bInit Then
        CBxY.Parent.TabStop = bTabStop
    End If
End Property

Public Property Get ControlTipText() As String
    ControlTipText = sPControlTipText
End Property

Public Property Let ControlTipText(ByVal sControlTipText As String)
    Dim I As Long
    sPControlTipText = sControlTipText
    If bInit Then
        For I = 0 To 6
            mLabelButtons(I).Obj_CmBl.ControlTipText = sControlTipText
        Next
        For I = 0 To 41
            mDayButtons(I).Obj_Cmb.ControlTipText = sControlTipText
        Next
        CBxM.ControlTipText = sControlTipText
        CBxY.ControlTipText = sControlTipText
        CLb.ControlTipText = sControlTipText
        'CBxY.Parent.ControlTipText = sControlTipText
    End If
End Property

Public Property Get GridFont() As MSForms.NewFont
    Set GridFont = PGridNewFont
End Property

Public Property Set GridFont(ByRef clGridNewFont As MSForms.NewFont)
    Set PGridNewFont = clGridNewFont
End Property

Public Property Get DayFont() As MSForms.NewFont
    Set DayFont = PDayNewFont
End Property

Public Property Set DayFont(ByRef clDayNewFont As MSForms.NewFont)
    Set PDayNewFont = clDayNewFont
End Property

Public Property Get TitleFont() As MSForms.NewFont
    Set TitleFont = PTitleNewFont
End Property

Public Property Set TitleFont(ByRef clTitleNewFont As MSForms.NewFont)
    Set PTitleNewFont = clTitleNewFont
End Property

Public Property Get Visible() As Boolean
    Visible = bPVisible
End Property

Public Property Let Visible(ByVal bVisible As Boolean)
    bPVisible = bVisible
    If bInit Then
        CBxY.Parent.Visible = bVisible
    End If
End Property

Public Property Get Left() As Single
    Left = sPLeft
End Property

Public Property Let Left(ByVal sLeft As Single)
    sPLeft = sLeft
    If bInit Then
        CBxY.Parent.Left = sLeft
    End If
End Property

Public Property Get Top() As Single
    Top = sPTop
End Property

Public Property Let Top(ByVal ssTop As Single)
    sPTop = ssTop
    If bInit Then
        CBxY.Parent.Top = ssTop
    End If
End Property

Public Property Get Height() As Single
    Height = sPHeight
End Property

Public Property Let Height(ByVal sHeight As Single)
    sPHeight = sHeight
    If bInit Then
        CBxY.Parent.Height = sHeight
        Call Move
    End If
End Property


Public Property Get Width() As Single
    Width = sPWidth
End Property

Public Property Let Width(ByVal sWidth As Single)
    'sWidth = Zero_Negative_Value(sWidth)
    sPWidth = sWidth
    If bInit Then
        CBxY.Parent.Width = sWidth
        Call Move
    End If
End Property

Public Property Get BackColor() As Long
    BackColor = lPBackColor
End Property

Public Property Let BackColor(ByVal lBackColor As Long)
    lPBackColor = lBackColor
    If bInit Then
        CBxY.Parent.BackColor = lBackColor
    End If
End Property

Public Property Get HeaderBackColor() As Long
    HeaderBackColor = lPHeaderBackColor
End Property

Public Property Let HeaderBackColor(ByVal lHeaderBackColor As Long)
Dim I As Long
    lPHeaderBackColor = lHeaderBackColor
    UseDefaultBackColors = False
End Property

Public Property Get UseDefaultBackColors() As Boolean
    UseDefaultBackColors = lPUseDefaultBackColors
End Property

Public Property Let UseDefaultBackColors(ByVal lUseDefaultBackColors As Boolean)
    lPUseDefaultBackColors = lUseDefaultBackColors
    Call Refresh
End Property

Public Property Get SaturdayBackColor() As Long
    SaturdayBackColor = lPSaturdayBackColor
End Property

Public Property Let SaturdayBackColor(ByVal lSaturdayBackColor As Long)
    lPSaturdayBackColor = lSaturdayBackColor
    UseDefaultBackColors = False
End Property

Public Property Get SundayBackColor() As Long
    SundayBackColor = lPSundayBackColor
End Property

Public Property Let SundayBackColor(ByVal lSundayBackColor As Long)
    lPSundayBackColor = lSundayBackColor
    UseDefaultBackColors = False
End Property

Public Property Get SelectedBackColor() As Long
    SelectedBackColor = lPSelectedBackColor
End Property

Public Property Let SelectedBackColor(ByVal lSelectedBackColor As Long)
    lPSelectedBackColor = lSelectedBackColor
    Call Refresh
End Property

Public Property Get SaturdaySelectable() As Boolean
    SaturdaySelectable = bPSaturdaySelectable
End Property

Public Property Let SaturdaySelectable(ByVal bSaturdaySelectable As Boolean)
    bPSaturdaySelectable = bSaturdaySelectable
    Call Refresh
End Property

Public Property Get SundaySelectable() As Boolean
    SundaySelectable = bPSundaySelectable
End Property

Public Property Let SundaySelectable(ByVal bSundaySelectable As Boolean)
    bPSundaySelectable = bSundaySelectable
    Call Refresh
End Property

Public Property Get FirstDay() As calDayOfWeek
    FirstDay = lPFirstDay
End Property

Public Property Let FirstDay(ByVal vbFirstDay As calDayOfWeek)
    Select Case vbFirstDay
        Case 1 To 7
        Case Else
            vbFirstDay = 1
    End Select
    
    lPFirstDay = vbFirstDay
    If bInit Then
        Call ApplyWeekDayLabelChanges
        Call Refresh
    End If
End Property

Public Property Get DayFontColor() As Long
    DayFontColor = lPDayFontColor
End Property

Public Property Let DayFontColor(ByVal lFontColor As Long)
    Dim I As Long
    
    lPDayFontColor = lFontColor
    If bInit Then
        For I = 0 To 6
            mLabelButtons(I).Obj_CmBl.ForeColor = lFontColor
        Next
    End If
End Property

Public Property Get GridFontColor() As Long
    GridFontColor = lPGridFontColor
End Property

Public Property Let GridFontColor(ByVal lFontColor As Long)
    lPGridFontColor = lFontColor
    Call Refresh
End Property

Public Property Let TitleFontColor(ByVal lFontColor As Long)
    lPTitleFontColor = lFontColor
    If bInit Then
        CLb.ForeColor = lFontColor
    End If
End Property

Public Property Get TitleFontColor() As Long
    TitleFontColor = lPTitleFontColor
End Property

Public Property Get Month() As Long
    Month = lPMonth
End Property

Public Property Let Month(ByVal lMonth As Long)
    If lMonth = 0 Then
        Value = Empty
    Else
        If lMonth < 0 Then lMonth = lPMonth
        lMonth = fMin(lMonth, 12)
        Value = SumMonthsToDate(dValue, lMonth - lPMonth)
    End If
    lPMonth = lMonth
End Property

Public Property Get Year() As Long
    Year = lPYear
End Property

Public Property Let Year(ByVal lYear As Long)
    If lYear = 0 Then
        Value = Empty
    Else
        Value = VBA.DateSerial(CheckYear(lYear), VBA.Month(dValue), VBA.Day(dValue))
    End If
    lPYear = lYear
End Property

Public Property Get Day() As Long
    Day = lPDay
End Property

Public Property Let Day(ByVal lDay As Long)
    If lDay = 0 Then
        Value = Empty
    Else
        If lDay < 0 Then lDay = lPDay
        lDay = fMin(lDay, VBA.Day(VBA.DateSerial(VBA.Year(dValue), VBA.Month(dValue) + 1, 0)))
        Value = VBA.DateSerial(VBA.Year(dValue), VBA.Month(dValue), lDay)
    End If
    lPDay = lDay
End Property

Public Property Get Value() As Variant
    If bPValueIsNull Then
        Value = Empty
    Else
        Value = dValue
    End If
End Property

Public Property Let Value(ByVal newDate As Variant)
    Dim Cancel As Integer '*** Integer for backward compatibility
    
    If CheckValue(newDate) = False Then newDate = Empty

    RaiseEvent BeforeUpdate(Cancel)
    
    If Cancel = 0 Then 'Not canceled.

        If bInit And Not IsEmpty(newDate) Then
            CBxY.ListIndex = VBA.Year(newDate) - 1904
            CBxM.ListIndex = VBA.Month(newDate) - 1
        End If
        
        If (bPValueIsNull = IsEmpty(newDate)) Or (newDate <> dValue) Then
            If Not IsEmpty(newDate) Then
                dValue = newDate
            End If
            bPValueIsNull = IsEmpty(newDate)
            
            Call Refresh
        End If
        
        RaiseEvent AfterUpdate
    End If
End Property

Public Property Get DayLength() As calMonthLength
    DayLength = lPDayLength
End Property

Public Property Let DayLength(ByVal bDayLength As calMonthLength)
    lPDayLength = bDayLength
    If bInit Then
        Call ApplyWeekDayLabelChanges
    End If
End Property

Public Property Get MonthLength() As calMonthLength
    MonthLength = lPMonthLength
End Property

Public Property Let MonthLength(ByVal iMonthLength As calMonthLength)
    lPMonthLength = iMonthLength

    If bInit Then
        CBxM.List = fMonthName(CLng(iMonthLength))
        Value = Value
    End If
End Property

Public Property Get YearFirst() As Boolean
    YearFirst = bPYearFirst
End Property

Public Property Let YearFirst(ByVal bYearFirst As Boolean)
    bPYearFirst = bYearFirst
    Call RenderLabel
End Property


Public Property Get MACFix() As Boolean
    MACFix = bPMACFix
End Property

Public Property Let MACFix(ByVal bMACFix As Boolean)
    bPMACFix = bMACFix
    Call Refresh
End Property


Public Property Get RightToLeft() As Boolean
    RightToLeft = bPRightToLeft
End Property

Public Property Let RightToLeft(ByVal bRightToLeft As Boolean)
    bPRightToLeft = bRightToLeft
    If bInit Then
        Call ApplyWeekDayLabelChanges
        Call Refresh
    End If
End Property


'###########################
'# Properties for Day button objects

Public Property Set Main(ByVal theMain As cCalendar)
    Set mcMain = theMain
End Property

Private Property Get Main() As cCalendar
    Set Main = mcMain
End Property

Public Property Get Obj_Cmb() As MSForms.CommandButton
    Set Obj_Cmb = CmB
End Property

Public Property Set Obj_Cmb(ByVal vNewValue As MSForms.CommandButton)
    Set CmB = vNewValue
End Property

Public Property Get Obj_CmBl() As MSForms.Label
    Set Obj_CmBl = CmBl
End Property

Public Property Set Obj_CmBl(ByVal vNewValue As MSForms.Label)
    Set CmBl = vNewValue
End Property

Public Property Set Obj_CmBlNum(ByVal vNewValue As MSForms.Label)
    Set CmBlNum = vNewValue
End Property

Public Property Get Obj_CmBlNum() As MSForms.Label
    Set Obj_CmBlNum = CmBlNum
End Property


'###########################
'# Public Methods

Public Sub AboutBox()
    MsgBox "Autori: r, Kris, Gabor"
End Sub

Public Sub Add(ByVal fForm As MSForms.UserForm)

    Dim cFrame As MSForms.Frame
    Set cFrame = fForm.Controls.Add("Forms.Frame.1")
    
    With cFrame
        .Width = IIf(sPWidth < 0, cDefaultWidth, sPWidth)
        .Height = IIf(sPHeight < 0, cDefaultHeight, sPHeight)
    End With
    
    Call Add_Calendar_into_Frame(cFrame)
    
End Sub

Public Sub Add_Calendar_into_Frame(ByVal cFrame As MSForms.Frame)
    Dim I As Long
    Dim v(199) As Variant
    Dim w As Variant
    Dim dTemp As Date
    
    For I = 0 To 199
        v(I) = CStr(1904 + I)
    Next
    
    With cFrame
        .BackColor = BackColor
        .Caption = ""
        .SpecialEffect = 0
        '.Top = IIf(sPTop = -1, .Top, sPTop)
        '.Left = IIf(sPLeft = -1, .Left, sPLeft)
        '.Width = IIf(sPWidth < 0, .Width, sPWidth)
        '.Height = IIf(sPHeight < 0, .Height, sPHeight)
        .Visible = bPVisible
        'Top = .Top
        'Left = .Left
        'Width = .Width
        'Height = .Height
    End With
    
    
    'Add this first, for proper taborder (Need TabStop.)
    Set CLb = cFrame.Controls.Add("Forms.Label.1")
    Set CBxY = cFrame.Controls.Add("Forms.ComboBox.1")
    Set CBxM = cFrame.Controls.Add("Forms.ComboBox.1")
    
    ReDim mLabelButtons(6)
    ReDim mDayButtons(41)
    w = fWeekdayName(CInt(lPDayLength))
    
    For I = 0 To 6
        Set mLabelButtons(I) = New cCalendar
        Set mLabelButtons(I).Main = Me
        Set mLabelButtons(I).Obj_CmBl = cFrame.Controls.Add("Forms.Label.1")
        With mLabelButtons(I).Obj_CmBl
            .Caption = w(((I + lPFirstDay - 1) Mod 7))
            .ForeColor = DayFontColor
            .TextAlign = fmTextAlignCenter
            .BorderStyle = fmBorderStyleSingle
            .BorderColor = &H80000010 'Button shadow  &H80000015 'Button dark shadow
            '.SpecialEffect = fmSpecialEffectEtched
            If HeaderBackColor = -1 Then
                .BackColor = cDayFontColorSelected 'Dark gray
                .BackStyle = fmBackStyleTransparent
            Else
                .BackColor = HeaderBackColor
                .BackStyle = fmBackStyleOpaque
            End If
        End With
    Next
            
    For I = 0 To 41
        Set mDayButtons(I) = New cCalendar
        Set mDayButtons(I).Main = Me
        
        Set mDayButtons(I).Obj_CmBl = cFrame.Controls.Add("Forms.Label.1")
        With mDayButtons(I).Obj_CmBl 'MAC Fix
            .TextAlign = fmTextAlignCenter
        End With
        
        Set mDayButtons(I).Obj_CmBlNum = cFrame.Controls.Add("Forms.Label.1")
        With mDayButtons(I).Obj_CmBlNum
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
        End With
        
        Set mDayButtons(I).Obj_Cmb = cFrame.Controls.Add("Forms.CommandButton.1")
        With mDayButtons(I).Obj_Cmb
            .BackStyle = fmBackStyleTransparent 'MAC Problem: No button transparency
        End With
        
        mDayButtons(I).RightToLeft = bPRightToLeft
    Next
    
    With CBxY
        .ListRows = 5
        .List = v
        .ListIndex = VBA.Year(dValue) - 1904
        .ShowDropButtonWhen = fmShowDropButtonWhenFocus
        .font.Bold = True
        .MatchRequired = True
    End With

    With CBxM
        .ListRows = 12
        .List = fMonthName(lPMonthLength)
        .ListIndex = VBA.Month(dValue) - 1
        .ShowDropButtonWhen = fmShowDropButtonWhenFocus
        .font.Bold = True
        .MatchRequired = True
    End With
    
    With CLb
        .ForeColor = TitleFontColor
        .TextAlign = fmTextAlignCenter
        .BackStyle = fmBackStyleTransparent
    End With
    
    Call ApplyWeekDayLabelChanges
    
    Call ApplyFontChanges
    
    Call Refresh_Properities
    
    Call Move
    
End Sub

Private Sub ApplyWeekDayLabelChanges()
    Dim I As Long
    Dim w
    
    w = fWeekdayName(CInt(lPDayLength))
    For I = 0 To 6
        If bPRightToLeft Then
            mLabelButtons(6 - I).Obj_CmBl.Caption = w((I + lPFirstDay - 1) Mod 7)
        Else
            mLabelButtons(I).Obj_CmBl.Caption = w((I + lPFirstDay - 1) Mod 7)
        End If
    Next
End Sub

Private Sub ApplyFontChanges()
    Dim font As MSForms.NewFont
    Dim I As Long

    If Not PDayNewFont Is Nothing Then
        For I = 0 To 6
            With mLabelButtons(I).Obj_CmBl
                If .font.Bold <> DayFont.Bold Then _
                    .font.Bold = DayFont.Bold
                If .font.Weight <> DayFont.Weight Then _
                    .font.Weight = DayFont.Weight
                If .font.Charset <> DayFont.Charset Then _
                    .font.Charset = DayFont.Charset
                If .font.Italic <> DayFont.Italic Then _
                    .font.Italic = DayFont.Italic
                If .font.Name <> DayFont.Name Then _
                    .font.Name = DayFont.Name
                If .font.Size <> DayFont.Size Then _
                    .font.Size = DayFont.Size
                If DayFont.Strikethrough Then _
                    .font.Strikethrough = True
                If DayFont.Underline Then _
                    .font.Underline = True
            End With
        Next
    End If
            
    If Not PGridNewFont Is Nothing Then
        For I = 0 To 41
            If Not bPMACFix Then
                Set font = mDayButtons(I).Obj_CmBlNum.font
            Else
                Set font = mDayButtons(I).Obj_Cmb.font
            End If
        
            With font
                If .Bold <> GridFont.Bold Then _
                    .Bold = GridFont.Bold
                If .Weight <> GridFont.Weight Then _
                    .Weight = GridFont.Weight
                If .Charset <> GridFont.Charset Then _
                    .Charset = GridFont.Charset
                If .Italic <> GridFont.Italic Then _
                    .Italic = GridFont.Italic
                If .Name <> GridFont.Name Then _
                    .Name = GridFont.Name
                If .Size <> GridFont.Size Then _
                    .Size = GridFont.Size
                If GridFont.Strikethrough Then _
                    .Strikethrough = True
                If GridFont.Underline Then _
                    .Underline = True
            End With
        Next
    End If
    
    If Not PTitleNewFont Is Nothing Then
        With CLb
                If .font.Bold <> TitleFont.Bold Then _
                    .font.Bold = TitleFont.Bold
                If .font.Weight <> TitleFont.Weight Then _
                    .font.Weight = TitleFont.Weight
                If .font.Charset <> TitleFont.Charset Then _
                    .font.Charset = TitleFont.Charset
                If .font.Italic <> TitleFont.Italic Then _
                    .font.Italic = TitleFont.Italic
                If .font.Name <> TitleFont.Name Then _
                    .font.Name = TitleFont.Name
                If .font.Size <> TitleFont.Size Then _
                    .font.Size = TitleFont.Size
                If TitleFont.Strikethrough Then _
                    .font.Strikethrough = True
                If TitleFont.Underline Then _
                    .font.Underline = True
        End With
    End If

End Sub

Public Sub Move( _
        Optional vLeft, _
        Optional vTop, _
        Optional vWidth, _
        Optional vHeight, _
        Optional vLayout)
        
    Dim I As Long, l As Currency, b As Currency, lc As Currency, bc As Currency
    Dim t As Long, b_ym As Currency, b_combo_m As Currency
    
    Const h_combo As Long = 16
    Const b_combo_y As Long = 42
    b_combo_m = IIf(lPMonthLength = mlENShort Or lPMonthLength = mlLocalShort, 42, 66) '66
    b_ym = b_combo_y + 2 + b_combo_m
    
    If bInit Then
        t = IIf(ShowDays, 7, 6)
        
        With CBxY.Parent 'Frame
            sPTop = IIf(IsMissing(vTop), IIf(Top = -1, .Top, Top), vTop)
            sPLeft = IIf(IsMissing(vLeft), IIf(Left = -1, .Left, Left), vLeft)
            sPHeight = IIf(IsMissing(vHeight), IIf(Height = -1, .Height, Height), vHeight)
            sPWidth = IIf(IsMissing(vWidth), IIf(Width = -1, .Width, Width), vWidth)
            
            l = Height
            b = Width
            l = Zero_Negative_Value(l - IIf(ShowTitle Or ShowDateSelectors, h_combo, 0) - 1)
            lc = CCur(l / t)
            bc = CCur(b / 7)
            b = bc * 7
        End With
        
        If ShowTitle Then
            With CLb
                .Width = Zero_Negative_Value(IIf(ShowDateSelectors, b - b_ym, b))
                .Height = h_combo
                .Left = 0
            End With
        End If
        
        If ShowDateSelectors Then
            With CBxY
                .Width = b_combo_y
                .Height = h_combo
                .Left = IIf(ShowTitle, CLb.Width, Int((b - b_ym) / 2)) + _
                       IIf(YearFirst, 0, b_combo_m + 2)
            End With
        
            With CBxM
                .Width = b_combo_m
                .Height = h_combo
                .Left = IIf(ShowTitle, CLb.Width, Int((b - b_ym) / 2)) + _
                       IIf(YearFirst, b_combo_y + 2, 0)
            End With
        End If
        If ShowDays Then
            For I = 0 To 6
                With mLabelButtons(I).Obj_CmBl
                    .Top = IIf(ShowTitle Or ShowDateSelectors, h_combo + 2, 0)
                    .Left = (I Mod 7) * bc - IIf(I > 0, 1, 0)
                    .Height = lc
                    .Width = bc + IIf(I > 0, 1, 0)
                End With
            Next
        End If
        For I = 0 To 41
            With mDayButtons(I).Obj_Cmb
                .Top = Int(I / 7) * lc + _
                       IIf(ShowTitle Or ShowDateSelectors, h_combo + 2, 0) + _
                       IIf(ShowDays, lc, 0)
                .Left = (I Mod 7) * bc
                .Height = lc
                .Width = bc
            End With
            With mDayButtons(I).Obj_CmBl
                .Top = mDayButtons(I).Obj_Cmb.Top
                .Left = mDayButtons(I).Obj_Cmb.Left
                .Height = mDayButtons(I).Obj_Cmb.Height
                .Width = mDayButtons(I).Obj_Cmb.Width
            End With
            
            With mDayButtons(I).Obj_CmBlNum
                .Top = Int(I / 7) * lc + _
                       IIf(ShowTitle Or ShowDateSelectors, h_combo, 0) + _
                       IIf(ShowDays, lc, 0) + 6
                .Left = (I Mod 7) * bc + 3
                .Height = Zero_Negative_Value(lc - 6)
                .Width = Zero_Negative_Value(bc - 6)
            End With

        Next
        
    Else
        sPHeight = IIf(IsMissing(Height), cDefaultHeight, Height)
        sPWidth = IIf(IsMissing(Width), cDefaultWidth, Width)
    End If
End Sub

Public Sub NextDay()
    Dim d As Date
    d = dValue + 1
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub NextWeek()
    Dim d As Date
    d = dValue + 7
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub NextMonth()
    Value = SumMonthsToDate(dValue, 1)
End Sub

Public Sub NextYear()
    Dim d As Date
    d = VBA.DateSerial(CheckYear(VBA.Year(dValue) + 1), VBA.Month(dValue), VBA.Day(dValue))
    Value = d
End Sub

Public Sub PreviousDay()
    Dim d As Date
    d = dValue - 1
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub PreviousWeek()
    Dim d As Date
    d = dValue - 7
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub PreviousMonth()
    Value = SumMonthsToDate(dValue, -1)
End Sub

Public Sub PreviousYear()
    Dim d As Date
    d = VBA.DateSerial(CheckYear(VBA.Year(dValue) - 1), VBA.Month(dValue), VBA.Day(dValue))
    Value = d
End Sub

Public Sub Today()
    Value = VBA.Date
End Sub

Public Sub Refresh()
    If bInit Then
        Call Refresh_Panel(VBA.Month(dValue), VBA.Year(dValue))
        Call ApplyFontChanges
    End If
End Sub


'###########################
'# Events for Main Object Components
'###########################

Private Sub CBxY_Change()
    RenderLabel
    Refresh_Panel CBxM.ListIndex + 1, CBxY.ListIndex + 1904
End Sub

Private Sub CBxM_Change()
    RenderLabel
    Refresh_Panel CBxM.ListIndex + 1, CBxY.ListIndex + 1904
End Sub

Private Sub CmB_Click()
    Main.Value = dValue
    Call Main.Event_click
End Sub

Private Sub CmB_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Call Main.Event_DblClick
End Sub


Private Sub CmB_KeyDown( _
    ByVal KeyCode As MSForms.ReturnInteger, _
    ByVal Shift As Integer)
    
    Dim newDate As Date

    '38 Up
    '37 Left
    '39 Right
    '40 Down
    
    newDate = dValue
    
    Select Case KeyCode
    Case 37
        If bPRightToLeft Then
            newDate = newDate + 1
        Else
            newDate = newDate - 1
        End If
    Case 39
        If bPRightToLeft Then
            newDate = newDate - 1
        Else
            newDate = newDate + 1
        End If
    Case 38
        newDate = newDate - 7
    Case 40
        newDate = newDate + 7
    Case 9
    End Select
    
    If newDate <> dValue Then
        Main.Value = newDate
        KeyCode = 0
    Else
        Call Main.Event_KeyDown(KeyCode, Shift)
    End If
End Sub


Private Sub Class_Initialize()
    bPShowDays = True
    bPShowTitle = True
    bPShowDateSelectors = True
    dValue = VBA.Date
    lPMonth = VBA.Month(VBA.Date)
    lPYear = VBA.Year(VBA.Date)
    lPDay = VBA.Day(VBA.Date)
    lPFontSize = 8
    lPMonthLength = 1
    lPDayLength = 1
    bPYearFirst = False
    lPTitleFontColor = &HA00000
    lPGridFontColor = &HA00000
    lPDayFontColor = &H0&
    lPFirstDay = 1
    lPBackColor = &H8000000F
    lPHeaderBackColor = 10053171 '&HFFAA99
    lPUseDefaultBackColors = True
    lPSaturdayBackColor = &H80000002
    lPSundayBackColor = &HFFAA99 '&H80000002
    lPSelectedBackColor = &H80000011
    bPVisible = True
    sPHeight = -1
    sPWidth = -1
    sPTop = -1
    sPLeft = -1
    sPControlTipText = ""
    bPRightToLeft = False
    bPSaturdaySelectable = True
    bPSundaySelectable = True
    
    Set TitleFont = New MSForms.NewFont
    With TitleFont
        .Name = "Arial"
        .Size = lPFontSize + 4
        .Bold = True
    End With
    
    Set DayFont = New MSForms.NewFont
    With DayFont
        .Name = "Arial"
        .Size = lPFontSize + 2
        .Bold = True
    End With
    
    Set GridFont = New MSForms.NewFont
    With GridFont
        .Name = "Arial"
        .Size = lPFontSize
    End With

End Sub

Private Sub Class_Terminate()
    Erase mDayButtons
    Erase mLabelButtons
    Set mcMain = Nothing
    Set PTitleNewFont = Nothing
    Set PDayNewFont = Nothing
    Set PGridNewFont = Nothing
    Set CBxY = Nothing
    Set CBxM = Nothing
    Set CmB = Nothing
    Set CLb = Nothing
    Set CmBl = Nothing
End Sub

'###########################
'# Private Function

Private Function ArraY_Days(ByVal lMonth As Long, ByVal lYear As Long)
    Dim v(0 To 41) As Date, I As Long, g As Long, l As Long, p As Long, t As Date
    
    I = VBA.DateTime.Weekday(VBA.DateSerial(lYear, lMonth, 1), 1 + lPFirstDay Mod 7) - 1
    
    If I = 0 Then I = 7
    
    g = VBA.Day(VBA.DateSerial(lYear, lMonth + 1, 0)) + I
    
    p = 1
    For l = I To 0 Step -1
        v(l) = VBA.DateSerial(lYear, lMonth, p)
        p = p - 1
    Next
    
    p = 0
    For l = I To g
        p = p + 1
        v(l) = VBA.DateSerial(lYear, lMonth, p)
    Next
    
    For l = g To 41
        v(l) = VBA.DateSerial(lYear, lMonth, p)
        p = p + 1
    Next
    
    If bPRightToLeft Then
        For l = 0 To 5
            For I = 0 To 2
                t = v(l * 7 + I)
                v(l * 7 + I) = v(l * 7 + (6 - I))
                v(l * 7 + (6 - I)) = t
            Next
        Next
    End If
    
    ArraY_Days = v
End Function

Private Sub RenderLabel()
    Dim b As Currency, b_ym As Currency, b_combo_m As Long
    
    Const b_combo_y As Long = 42
    b_combo_m = IIf(lPMonthLength = mlENShort Or lPMonthLength = mlLocalShort, 42, 66) '66
    b_ym = b_combo_y + 2 + b_combo_m
    
    If bInit Then
        b = CBxY.Parent.Width
        If bPYearFirst Then
            CLb.Caption = CBxY.Value & " " & CBxM.Value
        Else
            CLb.Caption = CBxM.Value & " " & CBxY.Value
        End If
        CLb.Width = Zero_Negative_Value(IIf(ShowDateSelectors, b - b_ym, b))
        CBxM.Width = b_combo_m
        CBxY.Left = IIf(ShowTitle, CLb.Width, CCur((b - b_ym) / 2)) + _
                       IIf(YearFirst, 0, b_combo_m + 2)
        CBxM.Left = IIf(ShowTitle, CLb.Width, CCur((b - b_ym) / 2)) + _
                       IIf(YearFirst, b_combo_y + 2, 0)
        'CBxY.Left = IIf(ShowTitle, CLb.Width, IIf(CLb.Width, Int(CLb.Width / 2), 0)) + _
        '           IIf(YearFirst, 0, b_combo_m + 2)
        '
        'CBxM.Left = IIf(ShowTitle, CLb.Width, IIf(CLb.Width, Int(CLb.Width / 2), 0)) + _
        '           IIf(YearFirst, b_combo_y + 2, 0)
    End If
End Sub

Private Function bInit() As Boolean
    If Not CBxY Is Nothing Then bInit = True
End Function


Private Function SumMonthsToDate(dDate As Date, Optional lMonth As Long = 1) As Date
    Dim d As Date
    
    d = VBA.DateSerial( _
            VBA.Year(dDate), _
            VBA.Month(dDate) + lMonth, _
            fMin( _
                VBA.Day(dDate), _
                VBA.Day( _
                    VBA.DateSerial( _
                    VBA.Year(dDate), _
                    VBA.Month(dDate) + 1 + VBA.Abs(lMonth), _
                    0))))
                    
    If d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d)) Then
        SumMonthsToDate = d
    Else
        SumMonthsToDate = dDate
    End If
End Function

Private Function fMin(vFirstValue, ParamArray vValues())
    Dim I As Long
    fMin = vFirstValue
    
    If IsMissing(vValues) = False Then
    For I = 0 To UBound(vValues)
        If fMin > vValues(I) Then
            fMin = vValues(I)
        End If
    Next
    End If
End Function

Private Function fMonthName(lIndex As Long)
    Dim m(11), I As Long, v As Variant
    lIndex = lIndex Mod 4
    If Int(lIndex / 2) Then
        If lIndex Mod 2 Then
            v = Array("Jan", "Feb", "Mar", "Apr", "May", _
                "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
        Else
            v = Array("January", "February", "March", _
                "April", "May", "June", "July", "August", _
                "September", "October", "November", "December")
        End If
        fMonthName = v
    Else
        For I = 0 To 11
            m(I) = VBA.Strings.MonthName(I + 1, lIndex Mod 2)
        Next
        fMonthName = m
    End If
End Function


Private Function fWeekdayName(lIndex As Long)
    Dim m(6), I As Long, v As Variant
    lIndex = lIndex Mod 4
    If Int(lIndex / 2) Then
        If lIndex Mod 2 Then
            v = Array("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
        Else
            v = Array("Monday", "Tuesday", "Wednesday", _
                "Thursday", "Friday", "Saturday", "Sunday")
        End If
        fWeekdayName = v
    Else
        For I = 0 To 6
            m(I) = VBA.Strings.WeekdayName(I + 1, lIndex Mod 2, vbMonday)
        Next
        fWeekdayName = m
    End If
End Function


Private Function CheckYear(ByVal lYear As Long) As Long
    Select Case lYear
    Case Is < 1904
        CheckYear = 1904
    Case 1904 To 2103
        CheckYear = lYear
    Case Else
        CheckYear = 2103
    End Select
End Function

'###########################
'# Private Sub

Public Sub Event_DblClick()
    RaiseEvent DblClick
End Sub

Public Sub Event_click()
    RaiseEvent Click
End Sub

Public Sub Event_KeyDown( _
    ByVal KeyCode As MSForms.ReturnInteger, _
    ByVal Shift As Integer)
    
    RaiseEvent KeyDown(KeyCode, Shift)
End Sub

Private Sub Refresh_Properities()
    With Me
        .BackColor = .BackColor
        .ControlTipText = .ControlTipText
        .DayFontColor = .DayFontColor
        .DayLength = .DayLength
        .GridFontColor = .GridFontColor
        .MonthLength = .MonthLength
        If .UseDefaultBackColors = False Then
            .SaturdayBackColor = .SaturdayBackColor
            .SundayBackColor = .SundayBackColor
            .HeaderBackColor = .HeaderBackColor
        End If
        .ShowDateSelectors = .ShowDateSelectors
        .ShowDays = .ShowDays
        .ShowTitle = .ShowTitle
        .TabIndex = .TabIndex
        .TabStop = .TabStop
        .TitleFontColor = .TitleFontColor
        .ValueIsNull = .ValueIsNull
        .YearFirst = .YearFirst
    End With
End Sub

Private Sub Refresh_Selected_Day(ByVal dValue As Date)
    Dim I As Long, c As MSForms.Label
    For I = 0 To 41
        If mDayButtons(I).Value = dValue And Not bPValueIsNull Then
            On Error Resume Next
            mDayButtons(I).Obj_Cmb.SetFocus
            On Error GoTo 0
            If Not bPMACFix Then
                With mDayButtons(I).Obj_CmBl
                    .BackStyle = fmBackStyleOpaque
                    .BackColor = lPSelectedBackColor
                    .ForeColor = cDayFontColorSelected
                End With
            Else
                With mDayButtons(I).Obj_Cmb
                    .BackStyle = fmBackStyleOpaque
                    .BackColor = lPSelectedBackColor
                    .ForeColor = cDayFontColorSelected
                End With
            End If
            lPMonth = VBA.Month(dValue)
            lPYear = VBA.Year(dValue)
            lPDay = VBA.Day(dValue)
        End If
    Next

End Sub

Private Sub Refresh_Panel(ByVal lMonth As Long, ByVal lYear As Long)
    Dim v As Variant, I As Long, l As Long
    Dim iDay As Long
    
    If bInit Then
        v = ArraY_Days(lMonth, lYear)
        For I = 0 To 41
            mDayButtons(I).Value = v(I)
            If Not bPMACFix Then 'MAC: no label - command button text
                '# Normal mode
                ' Text day label
                With mDayButtons(I).Obj_CmBlNum
                    If .Caption <> VBA.Day(v(I)) Then
                        .Caption = VBA.Day(v(I))
                    End If
                    If lMonth = VBA.Month(v(I)) Then
                        If .ForeColor <> GridFontColor Then
                            .ForeColor = GridFontColor
                        End If
                    Else
                        If .ForeColor <> cDayFontColorInactive Then
                            .ForeColor = cDayFontColorInactive
                        End If
                    End If
                End With
                ' Day background label
                With mDayButtons(I).Obj_CmBl
                    iDay = VBA.DateTime.Weekday(v(I))
                    If .BackStyle = fmBackStyleOpaque Then
                        .BackStyle = fmBackStyleTransparent
                    End If
                    If UseDefaultBackColors = False Then
                        If iDay = vbSaturday Then
                            If .BackColor <> lPSaturdayBackColor Then
                                .BackColor = lPSaturdayBackColor
                            End If
                            If .BackStyle <> fmBackStyleOpaque Then
                                .BackStyle = fmBackStyleOpaque
                            End If
                        ElseIf iDay = vbSunday Then
                            If .BackColor <> lPSundayBackColor Then
                                .BackColor = lPSundayBackColor
                            End If
                            If .BackStyle <> fmBackStyleOpaque Then
                                .BackStyle = fmBackStyleOpaque
                            End If
                        End If
                    End If
                    If Not SaturdaySelectable And iDay = vbSaturday Then
                        mDayButtons(I).Obj_Cmb.Enabled = False
                    ElseIf Not SundaySelectable And iDay = vbSunday Then
                        mDayButtons(I).Obj_Cmb.Enabled = False
                    Else
                        mDayButtons(I).Obj_Cmb.Enabled = True
                    End If
                End With
                ' Button not altered
                With mDayButtons(I).Obj_Cmb
                    If .Caption <> "" Then 'After MACFix
                        .Caption = ""
                    End If
                    If .BackStyle <> fmBackStyleTransparent Then 'Button visible
                        .BackStyle = fmBackStyleTransparent
                    End If
                End With
            Else
                '# MAC Fix mode
                With mDayButtons(I).Obj_CmBlNum
                    If .Caption <> "" Then
                        .Caption = ""
                    End If
                End With
                With mDayButtons(I).Obj_CmBl
                    If .BackStyle = fmBackStyleOpaque Then
                        .BackStyle = fmBackStyleTransparent
                    End If
                End With
                With mDayButtons(I).Obj_Cmb
                    If .Caption <> VBA.Day(v(I)) Then
                        .Caption = VBA.Day(v(I))
                    End If
                    If lMonth = VBA.Month(v(I)) Then
                        If .ForeColor <> GridFontColor Then
                            .ForeColor = GridFontColor
                        End If
                    Else
                        If .ForeColor <> cDayFontColorInactive Then
                            .ForeColor = cDayFontColorInactive
                        End If
                    End If
                    If .BackStyle <> fmBackStyleOpaque Then 'Button visible
                        .BackStyle = fmBackStyleOpaque
                    End If
                    If UseDefaultBackColors = False Then
                        iDay = VBA.DateTime.Weekday(v(I))
                        If iDay = vbSaturday Then
                            If .BackColor <> lPSaturdayBackColor Then
                                .BackColor = lPSaturdayBackColor
                            End If
                        ElseIf iDay = vbSunday Then
                            If .BackColor <> lPSundayBackColor Then
                                .BackColor = lPSundayBackColor
                            End If
                        Else
                            If .BackColor <> BackColor Then
                                .BackColor = BackColor
                            End If
                        End If
                    Else
                        If .BackColor <> BackColor Then
                            .BackColor = BackColor
                        End If
                    End If
                End With
            End If
            If CheckValue(v(I)) = False Then
                mDayButtons(I).Obj_Cmb.Locked = True
            Else
                If mDayButtons(I).Obj_Cmb.Locked = True Then
                    mDayButtons(I).Obj_Cmb.Locked = False
                End If
            End If
        Next
        
        If UseDefaultBackColors = False Then
            For l = 0 To 6
                If mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleTransparent Then
                    mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleOpaque
                End If
                If mLabelButtons(l).Obj_CmBl.BackColor <> lPHeaderBackColor Then
                    mLabelButtons(l).Obj_CmBl.BackColor = lPHeaderBackColor
                End If
            Next
        Else
            For l = 0 To 6
                If mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleOpaque Then
                   mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleTransparent
                End If
        Next
        End If
        
        If lMonth = VBA.Month(dValue) And lYear = VBA.Year(dValue) Then
            Call Refresh_Selected_Day(dValue)
        Else
            lPMonth = 0
            lPYear = 0
            lPDay = 0
        End If
    End If
End Sub

Private Function CheckValue(d) As Boolean
    If VarType(d) = vbDate Then
        Select Case d
            Case 1462 To 74510
                CheckValue = CLng(d) = d
        End Select
    End If
End Function

Private Function Zero_Negative_Value(sNumber As Single) As Single
    If sNumber > 0 Then
        Zero_Negative_Value = sNumber
    End If
End Function

Attribute VB_Name = "clsListPrcIds"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, _
    ByVal blnheritHandle As Long, ByVal dwAppProcessId As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Private Declare Function TerminateProcess Lib "kernel32" (ByVal ApphProcess As Long, _
    ByVal uExitCode As Long) As Long
Private Declare Function CreateToolhelp32Snapshot Lib "kernel32" _
     (ByVal lFlags As Long, lProcessID As Long) As Long
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" _
    (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare Function GetCurrentProcessId Lib "kernel32" () As Long
Private Declare Function GetWindowThreadProcessId& Lib "user32" (ByVal hwnd As Long, _
    lpdwProcessId As Long)
Private Declare Function ProcessFirst Lib "kernel32" Alias "Process32First" _
    (ByVal mSnapShot As Long, uProcess As PROCESSENTRY32) As Long
Private Declare Function ProcessNext Lib "kernel32" Alias "Process32Next" _
    (ByVal mSnapShot As Long, uProcess As PROCESSENTRY32) As Long
Private Declare Function SetPriorityClass Lib "kernel32" (ByVal hProcess As Long, _
    ByVal dwPriorityClass As Long) As Long
Private Declare Function GetVersionEx Lib "kernel32.dll" Alias "GetVersionExA" _
    (osinfo As OSVERSIONINFO) As Long

Private Type PROCESSENTRY32
    dwSize As Long
    cntUsage As Long
    th32ProcessID As Long
    th32DefaultHeapID As Long
    th32ModuleID As Long
    cntThreads As Long
    th32ParentProcessID As Long
    pcPriClassBase As Long
    dwFlags As Long
    szexeFile As String * 260&                ' Must be a value of 260 and type of Long
End Type

Private Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128
End Type

Private Const TH32CS_SNAPPROCESS As Long = 2&

Private Const REALTIME_PRIORITY_CLASS = &H100
Private Const HIGH_PRIORITY_CLASS = &H80
Private Const NORMAL_PRIORITY_CLASS = &H20
Private Const IDLE_PRIORITY_CLASS = &H40

Dim mresult
Private OwnerVBExplorer As Boolean  ' Prozess Owner ist VB oder Explorer
Public Property Get OwnerIsService() As Boolean

OwnerIsService = IIf(OwnerVBExplorer = True, False, True)

End Property
Public Function FindPrcInList(findPrcid As Long) As Boolean
    Dim uProcess As PROCESSENTRY32
    Dim mSnapShot As Long
    Dim mName As String
    Dim I As Integer

    DoEvents
    FindPrcInList = False
    uProcess.dwSize = Len(uProcess)
    mSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0&)

    If mSnapShot Then
        mresult = ProcessFirst(mSnapShot, uProcess)

        Do While mresult
             I = InStr(1, uProcess.szexeFile, Chr(0))
             mName = LCase$(Left$(uProcess.szexeFile, I - 1))
       '      Set mlistitem = lvwPrss.ListItems.Add(, , Text:=uProcess.th32ProcessID)
        '     mlistitem.SubItems(1) = uProcess.th32ParentProcessID
       '      mlistitem.SubItems(2) = mName
       ' Debug.Print uProcess.th32ProcessID & " " & mName
       If uProcess.th32ProcessID = findPrcid Then
            FindPrcInList = True
            Exit Do
       End If
            
             mresult = ProcessNext(mSnapShot, uProcess)
        Loop
    End If
  
End Function

Public Function FindExeInList(findExe As String) As Boolean
    Dim uProcess As PROCESSENTRY32
    Dim mSnapShot As Long
    Dim mName As String
    Dim I As Integer

    DoEvents
    FindExeInList = False
    uProcess.dwSize = Len(uProcess)
    mSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0&)

    If mSnapShot Then
        mresult = ProcessFirst(mSnapShot, uProcess)

        Do While mresult
             I = InStr(1, uProcess.szexeFile, Chr(0))
             mName = LCase$(Left$(uProcess.szexeFile, I - 1))
       '      Set mlistitem = lvwPrss.ListItems.Add(, , Text:=uProcess.th32ProcessID)
        '     mlistitem.SubItems(1) = uProcess.th32ParentProcessID
       '      mlistitem.SubItems(2) = mName
     '  Debug.Print uProcess.th32ProcessID & " " & mName
       If UCase(mName) = UCase(findExe) Then
            FindExeInList = True
            Exit Do
       End If
            
             mresult = ProcessNext(mSnapShot, uProcess)
        Loop
    End If
  
End Function

Public Function FindChildInList(findPrcid As Long, findExe As String) As String
    Dim uProcess As PROCESSENTRY32
    Dim mSnapShot As Long: Dim OwnerPrcID As Long
    Dim mName As String
    Dim I As Integer

    DoEvents
    FindChildInList = ""
    uProcess.dwSize = Len(uProcess)
    mSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0&)

    If mSnapShot Then
        mresult = ProcessFirst(mSnapShot, uProcess)

        Do While mresult
             I = InStr(1, uProcess.szexeFile, Chr(0))
             mName = LCase$(Left$(uProcess.szexeFile, I - 1))
       '      Set mlistitem = lvwPrss.ListItems.Add(, , Text:=uProcess.th32ProcessID)
        '     mlistitem.SubItems(1) = uProcess.th32ParentProcessID
       '      mlistitem.SubItems(2) = mName
       '   Debug.Print uProcess.th32ProcessID & " " & mName
            If uProcess.th32ParentProcessID = findPrcid Then
                Debug.Print uProcess.th32ProcessID & " " & mName
                FindChildInList = FindChildInList & mName & ";"
                'If UCase(mName) = UCase(findExe) Then
                '    FindChildInList = uProcess.th32ProcessID
                    'Exit Do
                'End If
            End If
            
             mresult = ProcessNext(mSnapShot, uProcess)
        Loop
        
    End If
  
End Function

Public Function FindOwnerInList(findPrcid As Long) As String
    Dim uProcess As PROCESSENTRY32
    Dim mSnapShot As Long: Dim OwnerPrcID As Long
    Dim mName As String
    Dim I As Integer

    DoEvents
    FindOwnerInList = ""
    uProcess.dwSize = Len(uProcess)
    mSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0&)

    If mSnapShot Then
        mresult = ProcessFirst(mSnapShot, uProcess)

        Do While mresult
             I = InStr(1, uProcess.szexeFile, Chr(0))
             mName = LCase$(Left$(uProcess.szexeFile, I - 1))
       '      Set mlistitem = lvwPrss.ListItems.Add(, , Text:=uProcess.th32ProcessID)
        '     mlistitem.SubItems(1) = uProcess.th32ParentProcessID
       '      mlistitem.SubItems(2) = mName
        '  Debug.Print uProcess.th32ProcessID & " " & mName
            If uProcess.th32ProcessID = findPrcid Then
                OwnerPrcID = uProcess.th32ParentProcessID
                Exit Do
            End If
            
             mresult = ProcessNext(mSnapShot, uProcess)
        Loop
        
               mresult = ProcessFirst(mSnapShot, uProcess)

        Do While mresult
             I = InStr(1, uProcess.szexeFile, Chr(0))
             mName = LCase$(Left$(uProcess.szexeFile, I - 1))
            If uProcess.th32ProcessID = OwnerPrcID Then
                FindOwnerInList = mName
                Exit Do
            End If
            
             mresult = ProcessNext(mSnapShot, uProcess)
        Loop
    End If
  
End Function

Public Function FindExeNameInList(findPrcid As Long) As String
    Dim uProcess As PROCESSENTRY32
    Dim mSnapShot As Long
    Dim mName As String
    Dim I As Integer

    DoEvents
    FindExeNameInList = ""
    uProcess.dwSize = Len(uProcess)
    mSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0&)

    If mSnapShot Then
        mresult = ProcessFirst(mSnapShot, uProcess)

        Do While mresult
             I = InStr(1, uProcess.szexeFile, Chr(0))
             mName = LCase$(Left$(uProcess.szexeFile, I - 1))
       '      Set mlistitem = lvwPrss.ListItems.Add(, , Text:=uProcess.th32ProcessID)
        '     mlistitem.SubItems(1) = uProcess.th32ParentProcessID
       '      mlistitem.SubItems(2) = mName
     '  Debug.Print uProcess.th32ProcessID & " " & mName
       If uProcess.th32ProcessID = findPrcid Then
            FindExeNameInList = mName
            Exit Do
       End If
            
             mresult = ProcessNext(mSnapShot, uProcess)
        Loop
    End If
  
End Function

Private Sub Class_Initialize()

If (FindExeNameInList(CStr(GetCurrentProcessId)) = "vb6.exe") Or _
    (FindOwnerInList(CStr(GetCurrentProcessId)) = "explorer.exe") Then
        OwnerVBExplorer = True
    Else
        OwnerVBExplorer = False
End If

End Sub
Attribute VB_Name = "clsProcess"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'---------------------------------------------------------------------------------------
' Module    : clsProcess
' DateTime  : 07.11.2006 05:58
' Author    : schmidt
' Purpose   : s.u.
' KLASSE:   clsProcess
' ------
'
'   Ein Object der Klasse clsProcess wird verwendet, um eine Applikation zu starten,
'   und den Status derselbigen ermitteln zu k|fffd|nnen
'   Die Benutzung der Klasse ist sowohl mit 16Bit als auch mit 32 Bit mit identischer
'   Syntax m|fffd|glich.
'
'
' Interface
' ---------
'
'   Property    Programmname    Name des zu startenden Programms
'   Property    Arguments       Zus|fffd|tzliche Argumente
'   Method      Exec            Ausf|fffd|hren
'   Property    IsTerminated    Ist der Process beendet.
'----------------------------------------------------------------
Option Explicit

Private Enum ProcessCreationFlags
   DEBUG_PROCESS = &H1
   DEBUG_ONLY_THIS_PROCESS = &H2
   CREATE_SUSPENDED = &H4
   DETACHED_PROCESS = &H8
   CREATE_NEW_CONSOLE = &H10
   NORMAL_PRIORITY_CLASS = &H20
   IDLE_PRIORITY_CLASS = &H40
   HIGH_PRIORITY_CLASS = &H80
   REALTIME_PRIORITY_CLASS = &H100
   CREATE_NEW_PROCESS_GROUP = &H200
   CREATE_UNICODE_ENVIRONMENT = &H400
   CREATE_SEPARATE_WOW_VDM = &H800
   CREATE_SHARED_WOW_VDM = &H1000
   CREATE_FORCEDOS = &H2000
   CREATE_DEFAULT_ERROR_MODE = &H4000000
   CREATE_NO_WINDOW = &H8000000
End Enum

'----- API Declarationen ---------------------------------------

     Private Type STARTUPINFO
          cb As Long
          lpReserved As String
          lpDesktop As String
          lpTitle As String
          dwX As Long
          dwY As Long
          dwXSize As Long
          dwYSize As Long
          dwXCountChars As Long
          dwYCountChars As Long
          dwFillAttribute As Long
          dwFlags As Long
          wShowWindow As Integer
          cbReserved2 As Integer
          lpReserved2 As Long
          hStdInput As Long
          hStdOutput As Long
          hStdError As Long
       End Type
     
       Private Type PROCESS_INFORMATION
          hProcess As Long
          hThread As Long
          dwProcessID As Long
          dwThreadID As Long
       End Type
       
       Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" _
            (ByVal lpClassName As Any, ByVal lpWindowName As Any) As Long
            
       Private Declare Function ShowWindow Lib "user32" _
                (ByVal hwnd As Long, ByVal nCmdShow As Long) As Long
                
       Private Declare Function SetForegroundWindow Lib "user32" _
                (ByVal hwnd As Long) As Long

       Private Declare Function GetExitCodeProcess Lib "kernel32" _
                (ByVal hProcess As Long, lpExitCode As Long) As Long
                
       Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal _
          hHandle As Long, ByVal dwMilliseconds As Long) As Long
     
       Private Declare Function CreateProcessA Lib "kernel32" (ByVal _
          lpApplicationName As Long, ByVal lpCommandLine As String, ByVal _
          lpProcessAttributes As Long, ByVal lpThreadAttributes As Long, _
          ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, _
          ByVal lpEnvironment As Long, ByVal lpCurrentDirectory As Long, _
          lpStartupInfo As STARTUPINFO, lpProcessInformation As _
          PROCESS_INFORMATION) As Long
          
        Private Declare Function TerminateProcess Lib "kernel32" _
            (ByVal hProcess As Long, ByVal uExitCode As Long) As Long

        Private Declare Function CloseHandle Lib "kernel32" (ByVal _
          hObject As Long) As Long
          Private Const STANDARD_RIGHTS_REQUIRED As Long = &HF0000
          
        Private Declare Function OpenProcess Lib "kernel32.dll" _
                (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Boolean, ByVal dwProcessID As Long) As Long
  
        Private Const SYNCHRONIZE As Long = &H100000
        Private Const PROCESS_TERMINATE As Long = &H1
        Private Const PROCESS_CREATE_THREAD As Long = &H2
        Private Const PROCESS_SET_SESSIONID As Long = &H4
        Private Const PROCESS_VM_OPERATION As Long = &H8
        Private Const PROCESS_VM_READ As Long = &H10
        Private Const PROCESS_VM_WRITE As Long = &H20
        Private Const PROCESS_DUP_HANDLE As Long = &H40
        Private Const PROCESS_CREATE_PROCESS As Long = &H80
        Private Const PROCESS_SET_QUOTA As Long = &H100
        Private Const PROCESS_SET_INFORMATION As Long = &H200
        Private Const PROCESS_QUERY_INFORMATION As Long = &H400
        Private Const PROCESS_ALL_ACCESS As Long = (STANDARD_RIGHTS_REQUIRED Or SYNCHRONIZE Or &HFFF)
        
        
   '    Private Const NORMAL_PRIORITY_CLASS = &H20&
       Private Const INFINITE = -1&
       Private Const STILL_ACTIVE = &H103
        Private Const SW_SHOWNORMAL = 1
        Private Const SW_SHOWMAXIMIZED = 3
        Private Const SW_RESTORE = 9
        Private Const SW_MINIMIZE = 6
        Private Const GW_HWNDFIRST = 0
        Private Const GW_HWNDNEXT = 2
'-------------------------------------------------------------------------------------
'-------------------------------------------------------------------------------------
' Internal Members
'-------------------------------------------------------------------------------------
'-------------------------------------------------------------------------------------

Private m_ProcessInfo As PROCESS_INFORMATION
Private m_StartupInfo As STARTUPINFO

Private m_ProgramName As String
Private m_Arguments As String
Private m_WinState As Integer
Private prclist As clsListPrcIds

'-------------------------------------------------------------------------------------
' INTERFACE
' ProgramName
' -----------
'
' Name des zu startenden Programmes (ohne Argumente)
' ------------------------------------------------------------------------------------
Public Property Let ProgramName(szName As String)
    m_ProgramName = szName
End Property

' ------------------------------------------------------------------------------------
' Argmuments
' ----------
' zus|fffd|tzliche Argumente f|fffd|r das zu startende Programm
' ------------------------------------------------------------------------------------
Public Property Let Arguments(szArg As String)
    m_Arguments = szArg
End Property
' ------------------------------------------------------------------------------------
' Exec()
' ----
'
' Starten des Programmes und sichern der relevanten Informationen in den internen
' Member-Variablen
'
Public Function Exec()

        Dim ret As Long
        
        ' Initialisierung der STARTUPINFO Structure.
        ' (im ersten Element erwartet die API-Funktion die Gr|fffd|sse der Struktur)
        m_StartupInfo.cb = Len(m_StartupInfo)
        
        ' Start der Applikation |fffd|ber die API-Funktion CreateProcess anstelle
        ' der Verwendung der VB-internen Shell-Funktion
        '
        ret = CreateProcessA(0&, m_ProgramName & " " & m_Arguments, 0&, 0&, 1&, _
                ProcessCreationFlags.NORMAL_PRIORITY_CLASS, 0&, 0&, m_StartupInfo, m_ProcessInfo)

        Exec = ret
        
End Function
Public Function ExecHide()

        Dim ret As Long
        
        ' Initialisierung der STARTUPINFO Structure.
        ' (im ersten Element erwartet die API-Funktion die Gr|fffd|sse der Struktur)
        m_StartupInfo.cb = Len(m_StartupInfo)
        
        ' Start der Applikation |fffd|ber die API-Funktion CreateProcess anstelle
        ' der Verwendung der VB-internen Shell-Funktion
        '
        'RET = CreateProcessA(0&, m_ProgramName & " " & m_Arguments, 0&, 0&, 1&, _
                NORMAL_PRIORITY_CLASS, 0&, 0&, m_StartupInfo, m_ProcessInfo)
        ret = CreateProcessA(0&, m_ProgramName & " " & m_Arguments, 0&, 0&, 1&, _
                ProcessCreationFlags.CREATE_NO_WINDOW + _
                ProcessCreationFlags.NORMAL_PRIORITY_CLASS, 0&, 0&, m_StartupInfo, m_ProcessInfo)
                '&H8000020
        'RET = CreateProcessA(0&, m_ProgramName & " " & m_Arguments, 0&, 0&, 1&, _
                &H8000020, 0&, 0&, m_StartupInfo, m_ProcessInfo)
        ExecHide = ret
        
End Function
' ------------------------------------------------------------------------------------
' toTerminate
' Liefert xx zur|fffd|ck, schliesst die Applikation
' ------------------------------------------------------------------------------------
Public Property Get toTerminate(Optional hProcess As Long) As Long
If hProcess > 0 Then
    toTerminate = TerminateProcess(hProcess, 0)
Else
    toTerminate = TerminateProcess(m_ProcessInfo.hProcess, 0)
End If

End Property

' ------------------------------------------------------------------------------------
' IsTerminated
' Liefert zur|fffd|ck, ob die gestartete Applikation beendet wurde
' ------------------------------------------------------------------------------------
Public Property Get IsTerminated() As Boolean

IsTerminated = (WaitForSingleObject(m_ProcessInfo.hProcess, 10) = 0)

End Property
Public Property Get ProcessStatus() As Long
 
Dim lngRetval As Long
'Do
   ' Attempt to retrieve the exit code
   lngRetval = GetExitCodeProcess(m_ProcessInfo.hProcess, ProcessStatus)
  ' DoEvents
'Loop While ProcessStatus = STILL_ACTIVE

End Property
Public Property Get Inf_ProcessStatus(hProcess As Long) As Long
 
Dim lngRetval As Long
'Do
   ' Attempt to retrieve the exit code
   lngRetval = GetExitCodeProcess(hProcess, Inf_ProcessStatus)
  ' DoEvents
'Loop While Inf_ProcessStatus = STILL_ACTIVE

End Property
Public Property Get ProcessID() As Long
ProcessID = m_ProcessInfo.dwProcessID
End Property

Public Property Get ThreadID() As Long
ThreadID = m_ProcessInfo.dwThreadID
End Property

Public Property Get Process() As Long
Process = m_ProcessInfo.hProcess
End Property

Public Property Get Thread() As Long
Thread = m_ProcessInfo.hThread
End Property

Public Property Get ProgrammFinden(F_ProgName As String) As Boolean
Dim aName As String
Dim hwndPrev 'As SysInt

aName = F_ProgName
ProgrammFinden = False
hwndPrev = FindWindow(vbNullString, aName)
If hwndPrev <> 0 Then
    'MsgBox "Eine Instanz dieses Programmes wurde gefunden. Klicken Sie auf OK, um diese Instanz zu beenden und die vorherige anzuzeigen.", 64
    Call ShowWindow(hwndPrev, SW_SHOWNORMAL)
    Call SetForegroundWindow(hwndPrev)
    ProgrammFinden = True
End If

End Property

'---------------------------------------------------------------------------------------
' Procedure : Process_Kill
' DateTime  : 20.11.2004 11:07
' Author    : Schmidt
' Purpose   : beendet einen Process
'---------------------------------------------------------------------------------------
'
Public Function Process_Kill(P_ID As Long) As Boolean

    Dim hProcess As Long
    Dim lExitCode As Long
    Process_Kill = True
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION Or PROCESS_TERMINATE, False, P_ID)
    If hProcess = 0 Then
        If Not prclist.OwnerIsService Then
            Call MsgBox(Err.LastDllError & " OpenProcess failed Kill_Process", vbCritical, Application.ActiveWorkbook.Name)
        End If
        Process_Kill = False
    End If
    If GetExitCodeProcess(hProcess, lExitCode) = False Then
        If Not prclist.OwnerIsService Then
            Call MsgBox(Err.LastDllError & " GetExitCodeProcess failed Kill_Process", vbCritical, Application.ActiveWorkbook.Name)
        End If
        Process_Kill = False
    End If
    If TerminateProcess(hProcess, lExitCode) = False Then
        If Not prclist.OwnerIsService Then
            Call MsgBox(Err.LastDllError & " TerminateProcess failed Kill_Process", vbCritical, Application.ActiveWorkbook.Name)
        End If
        Process_Kill = False
    End If
    If CloseHandle(hProcess) = False Then
        If Not prclist.OwnerIsService Then
            Call MsgBox(Err.LastDllError & " CloseHandle failed Kill_Process", vbCritical, Application.ActiveWorkbook.Name)
        End If
        Process_Kill = False
    End If
    
End Function


' InQuest injected base64 decoded content
' ~`ZrD

INQUEST-PP=macro
