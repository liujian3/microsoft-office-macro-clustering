Attribute VB_Name = "ExList"
Option Explicit

' All Exceptions of head
Private Type HExceptions
    nHead As Integer                    ' The index of the head
    nSize As Integer                    ' The allocated size of dynamic arrays
    nExceptions As Integer              ' Number Of Exceptions
    strNames() As String                ' Check name of the exceptions
    fMin() As Boolean                   ' is min exception
    fMax() As Boolean                   ' is max exception
    fUMin() As Boolean                  ' is umin exception
    fUMax() As Boolean                  ' is umax exception
    fRange() As Boolean                 ' is range exception
    fCountersinkLessThanLength() As Boolean ' countersink less than length
End Type

Private ExList() As HExceptions         ' The exceptions list
Private nHExceptions As Integer         ' Number of heads with exceptions
Private nExListSize As Integer          ' exceptions list size

' Check if out of spec, return the type by ref
Public Function IsOutOfSpec(ByVal dValue As Single, ByVal dStdMin As Single, _
    ByVal dStdMax As Single, ByVal dStdUMin As Single, ByVal dStdUMax As Single, _
    ByRef fMin As Boolean, ByRef fUMin As Boolean, ByRef fMax As Boolean, _
    ByRef fUMax As Boolean) As Boolean
    IsOutOfSpec = False
    fUMin = False
    fUMax = False
    If fMode5 Then
        If dValue > dStdUMax And dStdUMax <> dStdMax And dStdUMax <> 0 Then
            IsOutOfSpec = True
            fUMax = True
            If dValue > dStdMax And dStdMax <> 0 Then
                fMax = True
            End If
        ElseIf dValue < dStdUMin And dStdUMin <> dStdMin And dStdUMin <> 0 Then
            IsOutOfSpec = True
            fUMin = True
            If dValue < dStdMin And dStdMin <> 0 Then
                fMin = True
            End If
        ElseIf dValue > dStdMax And dStdMax <> 0 Then
            IsOutOfSpec = True
            fMax = True
        ElseIf dValue < dStdMin And dStdMin <> 0 Then
            IsOutOfSpec = True
            fMin = True
        End If
    Else
        If dValue > dStdMax And dStdMax <> 0 Then
            IsOutOfSpec = True
            fMax = True
        ElseIf dValue < dStdMin And dStdMin <> 0 Then
            IsOutOfSpec = True
            fMin = True
        End If
    End If
End Function


' Initialize head exception list
Private Sub HExceptionsInit(ByRef e As HExceptions, ByVal nHead As Integer)
    e.nHead = nHead
    e.nSize = 10
    e.nExceptions = 0
    ReDim e.strNames(e.nSize)
    ReDim e.fMax(e.nSize)
    ReDim e.fMin(e.nSize)
    ReDim e.fUMax(e.nSize)
    ReDim e.fUMin(e.nSize)
    ReDim e.fRange(e.nSize)
    ReDim e.fCountersinkLessThanLength(e.nSize)
End Sub

' Deallocate head exceptions list
Private Sub HExceptionsEnd(ByRef e As HExceptions)
    e.nSize = 0
    e.nExceptions = 0
    Erase e.fMax
    Erase e.fMin
    Erase e.fUMax
    Erase e.fUMin
    Erase e.fRange
    Erase e.strNames
    Erase e.fCountersinkLessThanLength
End Sub

' Copy content of one head exceptions list to another
Private Sub HExceptionsCopy(e1 As HExceptions, e2 As HExceptions)
    e1.nExceptions = e2.nExceptions
    e1.nHead = e2.nHead
    e1.nSize = e2.nSize
    ReDim e1.fMax(e1.nSize)
    ReDim e1.fMin(e1.nSize)
    ReDim e1.fUMin(e1.nSize)
    ReDim e1.fUMax(e1.nSize)
    ReDim e1.fRange(e1.nSize)
    ReDim e1.strNames(e1.nSize)
    ReDim e1.fCountersinkLessThanLength(e1.nSize)
    Dim i As Integer
    For i = 1 To e1.nExceptions
        e1.fMax(i) = e2.fMax(i)
        e1.fMin(i) = e2.fMin(i)
        e1.fUMax(i) = e2.fUMax(i)
        e1.fUMin(i) = e2.fUMin(i)
        e1.fRange(i) = e2.fRange(i)
        e1.strNames(i) = e2.strNames(i)
        e1.fCountersinkLessThanLength(i) = e2.fCountersinkLessThanLength(i)
    Next
End Sub

' Get the index of a check name in head exceptions list. 0 if not found
Private Function HExceptionsIndex(e As HExceptions, ByVal sName As String) As Integer
    HExceptionsIndex = 0            ' Default value
    Dim i As Integer
    For i = 1 To e.nExceptions
        If StrComp(e.strNames(i), sName) = 0 Then
            HExceptionsIndex = i
            Exit For
        End If
    Next
End Function

' Get string representation of the head exceptions list
Private Function HExceptionsString(e As HExceptions) As String
    If e.nExceptions = 0 Then
        HExceptionsString = ""
    Else
        HExceptionsString = CStr(textCells(nExceptionRow, 4).Value) & CStr(e.nHead) & ": "
        Dim i As Integer
        For i = 1 To e.nExceptions
            If e.fRange(i) Then
                HExceptionsString = HExceptionsString & "!"
            End If
            If e.fCountersinkLessThanLength(i) Then
                HExceptionsString = HExceptionsString & "#"
            End If
            If e.fUMax(i) Then
                 HExceptionsString = HExceptionsString & "+" & e.strNames(i) & "*"
            ElseIf e.fUMin(i) Then
                HExceptionsString = HExceptionsString & "-" & e.strNames(i) & "*"
            ElseIf e.fMax(i) Then
                HExceptionsString = HExceptionsString & "+" & e.strNames(i)
            ElseIf e.fMin(i) Then
                HExceptionsString = HExceptionsString & "-" & e.strNames(i)
            ElseIf e.fRange(i) Then
                HExceptionsString = HExceptionsString & e.strNames(i)
            End If
            If i < e.nExceptions Then
                HExceptionsString = HExceptionsString & ",  "
            End If
        Next
    End If
End Function

' Add exception to head exception list
Private Sub HExceptionsAdd(ByRef e As HExceptions, ByVal sName As String, _
    ByVal fMin As Boolean, ByVal fMax As Boolean, ByVal fUMin As Boolean, _
    ByVal fUMax As Boolean, ByVal fRange As Boolean, ByVal fCountersinkLessThanLength As Boolean)
    
    If (Not fMin) And (Not fMax) And (Not fUMin) And (Not fUMax) And (Not fRange) And (Not fCountersinkLessThanLength) Then
        Exit Sub
    End If
    Dim nIndex As Integer               ' check index in list
    nIndex = HExceptionsIndex(e, sName)
    If nIndex = 0 Then
        If e.nExceptions = e.nSize Then
            e.nSize = e.nSize + 10
            ReDim Preserve e.fMin(e.nSize)
            ReDim Preserve e.fMax(e.nSize)
            ReDim Preserve e.fUMin(e.nSize)
            ReDim Preserve e.fUMax(e.nSize)
            ReDim Preserve e.fRange(e.nSize)
            ReDim Preserve e.strNames(e.nSize)
            ReDim Preserve e.fCountersinkLessThanLength(e.nSize)
        End If
            e.nExceptions = e.nExceptions + 1
            e.fCountersinkLessThanLength(e.nExceptions) = fCountersinkLessThanLength
            e.fMin(e.nExceptions) = fMin
            e.fMax(e.nExceptions) = fMax
            e.fUMin(e.nExceptions) = fUMin
            e.fUMax(e.nExceptions) = fUMax
            e.fRange(e.nExceptions) = fRange
            e.strNames(e.nExceptions) = sName
    Else
        e.fMin(nIndex) = e.fMin(nIndex) Or fMin
        e.fMax(nIndex) = e.fMax(nIndex) Or fMax
        e.fUMin(nIndex) = e.fUMin(nIndex) Or fUMin
        e.fUMax(nIndex) = e.fUMax(nIndex) Or fUMax
        e.fRange(nIndex) = e.fRange(nIndex) Or fRange
        e.fCountersinkLessThanLength(nIndex) = e.fCountersinkLessThanLength(nIndex) Or fCountersinkLessThanLength
    End If
End Sub

' Initialize exceptions list
Public Sub ExListInit()
    nHExceptions = 0
    nExListSize = 10
    ReDim ExList(nExListSize)
End Sub

' Deallocation of exceptions list for all heads
Public Sub ExListEnd()
    If nExListSize = 0 Then Exit Sub
    If nHExceptions = 0 Then
        Erase ExList
        Exit Sub
    End If
    Dim i As Integer
    For i = 1 To nHExceptions
        HExceptionsEnd ExList(i)
    Next
    Erase ExList
End Sub

' Find list index of an headin the list. return 0 if not found
Public Function ExListIndex(ByVal nHead As Integer)
    ExListIndex = 0     ' Default value
    If nHExceptions > 0 Then
        Dim i As Integer
        For i = 1 To nHExceptions
            If ExList(i).nHead = nHead Then
                ExListIndex = i
                Exit For
            End If
        Next
    End If
End Function

' Add exception to list
Public Sub ExListAdd(ByVal nHead As Integer, ByVal sName As String, ByVal fMin As Boolean, _
    ByVal fMax As Boolean, ByVal fUMin As Boolean, _
    ByVal fUMax As Boolean, ByVal fRange As Boolean, ByVal fCountersinkLessThanLength As Boolean)
    
    If (Not fMin) And (Not fMax) And (Not fUMin) And (Not fUMax) And (Not fRange) And (Not fCountersinkLessThanLength) Then Exit Sub         ' no exception
   
    Dim nIndex As Integer
    nIndex = ExListIndex(nHead)
    If nIndex = 0 Then          ' Add new head exception list
        If nHExceptions = nExListSize Then
            nExListSize = nExListSize + 10
            ReDim Preserve ExList(nExListSize)
        End If
        nHExceptions = nHExceptions + 1
        HExceptionsInit ExList(nHExceptions), nHead
        HExceptionsAdd ExList(nHExceptions), sName, fMin, fMax, fUMin, fUMax, fRange, fCountersinkLessThanLength
    Else
        HExceptionsAdd ExList(nIndex), sName, fMin, fMax, fUMin, fUMax, fRange, fCountersinkLessThanLength
    End If
End Sub

' Sort exceptions list by the heads numbers
Public Sub ExListSort()
    If nHExceptions = 0 Then
        Exit Sub
    End If
    Dim ehTemp As HExceptions    'Temporary variable for replacing
    Dim i As Integer, j As Integer
    For i = 1 To nHExceptions
        For j = 1 To nHExceptions - i
            If ExList(j).nHead > ExList(j + 1).nHead Then   ' Replace Values
                HExceptionsCopy ehTemp, ExList(j)
                HExceptionsCopy ExList(j), ExList(j + 1)
                HExceptionsCopy ExList(j + 1), ehTemp
            End If
        Next
    Next
End Sub

' Write exceptions list header to report sheet
Public Sub ExListWriteHeader(ByVal nRow As Integer)
    With Range(reportCells(nRow, 2), reportCells(nRow, 2))
        .Font.FontStyle = "Bold"
        .Font.Size = nFontSize + 2
        .Font.Underline = xlUnderlineStyleSingle
'        .Font.ColorIndex = xlAutomatic
    End With
    reportCells(nRow, 2).Value = textCells(nExceptionRow, 2).Value
End Sub

' Write exceptions list to report sheet
Public Sub ExListWrite()
    If nHExceptions = 0 Then Exit Sub
    Dim nRow As Integer     ' The row where the exception list begin
    nRow = nPageHeight + 1
    
    RegularFontFormat Range(reportCells(nRow, 2), reportCells(nRow + nHExceptions, 2))
    ExListSort
    
    
    ExListWriteHeader nRow
    
    Dim i As Integer
    For i = 1 To nHExceptions
        reportCells(i + nRow, 2).Value = HExceptionsString(ExList(i))
    Next
    nPageHeight = nPageHeight + nHExceptions + 2
    
    ' Deallocating
    ExListEnd                                           ' Erase list
    ExListTest 0, 0, 0, 0, 0, 0, 0, 0, False, True      ' Preparing test for user
End Sub

' Test if there is an exception. If so add it to list
Sub ExListTest(ByVal nHead As Integer, ByVal nNameCol As Integer, ByVal sFormat As String, ByVal dValue As Single, ByVal dStdMin As Single, ByVal dStdMax As Single, Optional dStdUMin As Single = 0, Optional dStdUMax As Single = 0, Optional fRange As Boolean = False, Optional fLastCall As Boolean = False, Optional fCountersinkLessThanLength As Boolean)
    Static fReentrant As Boolean
    If fLastCall Then               ' When last call: Shutting down fReentrant flag for
        fReentrant = False          ' user tests of the program
        Exit Sub
    End If
    If Not fReentrant Then
        ExListInit
    End If
    fReentrant = True
    
    Dim fMin As Boolean, fMax As Boolean, fUMin As Boolean, fUMax As Boolean
    dValue = CSng(Format$(dValue, sFormat))
    If (Not IsOutOfSpec(dValue, dStdMin, dStdMax, dStdUMin, dStdUMax, fMin, fUMin, fMax, fUMax)) And (Not fRange) Then
        Exit Sub
    End If
    Dim strCheck As String          ' Name of the checking process
    strCheck = CStr(textCells(nNameRow, nNameCol).Value)
    ExListAdd nHead, strCheck, fMin, fMax, fUMin, fUMax, fRange, fCountersinkLessThanLength
End Sub

Attribute VB_Name = "Graphs"
Option Explicit

Private nChartsInReport As Integer          ' Visible charts
Private nMaxRow As Integer

' Get position of via refference
Sub GetChartPos(ByVal iRowGraph As Integer, ByRef nLeft As Integer, ByRef nTop As Integer)
    Dim nVPos As Integer, nHPos As Integer
    nVPos = (nChartsInReport - 1) \ nGraphsInRow
    nHPos = 1 + ((nChartsInReport - 1) Mod nGraphsInRow)
    
    Dim nRow As Integer
    nRow = iRowGraph + (nVPos * 12)
    
    nLeft = (nHPos - 1) * 190 + (nHPos * 5)
    nTop = ActiveSheet.Rows(nRow).Top
    
    If (nRow > nMaxRow) Then nMaxRow = nRow
End Sub

' Write data to grid sheet
Sub WriteToGrid(ByVal nRow As Integer, ByVal nCol As Integer, Optional dValue1, Optional dValue2, Optional dValue3)
    If IsMissing(dValue1) Then      ' No value to put in cells
        gridCells(nRow, nCol).Value = ""
        gridCells(nRow, nCol + 1).Value = ""
        gridCells(nRow, nCol + 2).Value = ""
        Exit Sub
    End If
    gridCells(nRow, nCol).Value = dValue1
    If IsMissing(dValue2) Then
        gridCells(nRow, nCol + 1).Value = dValue1
        gridCells(nRow, nCol + 2).Value = dValue1
    Else
        gridCells(nRow, nCol + 1).Value = dValue2
        If IsMissing(dValue3) Then
            gridCells(nRow, nCol + 2).Value = dValue2
        Else
            gridCells(nRow, nCol + 2).Value = dValue3
        End If
    End If
End Sub

' Set Graph headers
Sub SetGraphHeaders(ByVal nRow As Integer)
    If nTableCols = 0 Then Exit Sub
    With Range("A" & CStr(nRow) & ":O" & CStr(nRow))
        .HorizontalAlignment = xlCenterAcrossSelection
        .VerticalAlignment = xlCenter
        .Font.Name = strFontName
        .Font.Size = nFontSize
        
'        .ReadingOrder = xlContext
'        .MergeCells = True
    End With
    reportCells(nRow, 1).Value = textCells(nNameRow + 4, 1).Value
    
    If (fPageBreakBeforeGraphics) Then
        reportCells(nRow, 1).Select
On Error Resume Next
        ActiveWindow.SelectedSheets.HPageBreaks.Add Before:=ActiveCell
    End If
    
End Sub

'   Set graph size
Sub SizeGraph(ByVal nLeft As Integer, ByVal nTop As Integer)
    If (ActiveChart Is Nothing Or Not fResizeChart) Then
        Exit Sub
    End If
    ActiveChart.Parent.Top = nTop
    ActiveChart.Parent.Left = nLeft
    ActiveChart.Parent.Width = 180
    ActiveChart.Parent.Height = 140
End Sub

' Creat the group of charts
Sub CreateGraph()
    Dim iRowGraph As Integer        ' The Row Where the graph begin. few rows below table.
    Dim fOneResizeChart As Boolean  ' Was atleast 1 chart resized.
    Dim Object As Integer
           
    Dim nTop As Integer, nLeft As Integer           ' Chart position
    
    nChartsInReport = 0                             ' No active chart yet
    nMaxRow = 0
    fOneResizeChart = False
    iRowGraph = nPageHeight + 3      ' 8 rows below table
    SetGraphHeaders iRowGraph - 2
    
    ' SEAM HEIGHT
    If DrawChart(gridCells.Range("B2:D" & CStr(nHeads + 4)), textCells(nNameRow + 4, 2).Value, textCells(9, 2).Value, textCells(nNameRow - 1, 2)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
    
    ' SEAM THICKNESS
    If DrawChart(gridCells.Range("E2:G" & CStr(nHeads + 4)), textCells(nNameRow + 4, 3).Value, textCells(9, 5).Value, textCells(nNameRow - 1, 5)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
    
    ' COUNTERSINK
    If DrawChart(gridCells.Range("H2:J" & CStr(nHeads + 4)), textCells(nNameRow + 4, 4).Value, textCells(9, 8).Value, textCells(nNameRow - 1, 8)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
    
    ' BODY HOOK
    If DrawChart(gridCells.Range("K2:M" & CStr(nHeads + 4)), textCells(nNameRow + 4, 5).Value, textCells(9, 11).Value, textCells(nNameRow - 1, 11)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
    
    ' OVER LAP %
    If DrawChart(gridCells.Range("N2:P" & CStr(nHeads + 4)), textCells(nNameRow + 4, 6).Value, textCells(9, 14).Value, textCells(nNameRow - 1, 14)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
   
    ' COVR HOOK
    If DrawChart(gridCells.Range("Q2:S" & CStr(nHeads + 4)), textCells(nNameRow + 4, 7).Value, textCells(9, 17).Value, textCells(nNameRow - 1, 17)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
   
    ' TGHT %
    If DrawChart(gridCells.Range("T2:V" & CStr(nHeads + 4)), textCells(nNameRow + 4, 8).Value, textCells(9, 20).Value, textCells(nNameRow - 1, 20)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
    
    ' BHButting
    If DrawChart(gridCells.Range("W2:Y" & CStr(nHeads + 4)), textCells(nNameRow + 4, 9).Value, textCells(9, 23).Value, textCells(nNameRow - 1, 23)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
   
     ' Free Space
    If DrawChart(gridCells.Range("Z2:AB" & CStr(nHeads + 4)), textCells(nNameRow + 4, 10).Value, textCells(9, 26).Value, textCells(nNameRow - 1, 26)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
   
     ' Over Lap
    If DrawChart(gridCells.Range("AC2:AE" & CStr(nHeads + 4)), textCells(nNameRow + 4, 11).Value, textCells(9, 29).Value, textCells(nNameRow - 1, 29)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
   
     ' Over Lap
    If DrawChart(gridCells.Range("AF2:AH" & CStr(nHeads + 4)), textCells(nNameRow + 4, 12).Value, textCells(9, 32).Value, textCells(nNameRow - 1, 32)) Then
        GetChartPos iRowGraph, nLeft, nTop
        SizeGraph nLeft, nTop
        fOneResizeChart = fOneResizeChart Or fResizeChart
    End If
   
   ' Clearing grid sheet
    If nPageHeight <> 0 Then
        gridCells.Range("A1:O" + CStr(nPageHeight)).ClearContents
    End If
    
    nPageHeight = nMaxRow + 13

End Sub

' Draw a chart
Function DrawChart(ByVal chartRange As Range, ByVal strTitle As String, ByVal sFormat As String, ByVal sHide As String) As Boolean
    DrawChart = False
    If (chartRange(1, 1).Value = "") Or (strTitle = "") Then
        fResizeChart = False
        Exit Function
    End If
    
    If (sHide <> "") Then
        fResizeChart = False
        Exit Function
    End If
    
    Charts.Add
    Dim c As Chart
    Set c = ActiveChart
    
    c.Visible = xlSheetVeryHidden
    c.ChartType = xlXYScatterLines
    c.SetSourceData Source:=chartRange, PlotBy:=xlRows
    
    With c.Axes(xlCategory)
        .HasMajorGridlines = False
        .HasMinorGridlines = False
    End With
    With c.Axes(xlValue)
        .HasMajorGridlines = False
        .HasMinorGridlines = False
    End With
    c.HasLegend = False

    With c
        .PlotArea.Interior.ColorIndex = 2
        .HasTitle = True
        .ChartTitle.Characters.Text = strTitle   ' replace with current title
        .Axes(xlCategory).Delete
        .Axes(xlValue, xlPrimary).HasTitle = False
                
        .ChartTitle.AutoScaleFont = True
        .ChartTitle.Font.Name = strFontName
        .ChartTitle.Font.FontStyle = "Bold"
        .ChartTitle.Font.Size = 18              ' Should be 8, but 8 became tiny
    End With
    
    ' For every head the set of  min, max, avg values is represented by 2 series in the chart.
    ' First seria contains the min and max values, and set a line between them on the
    ' y axis. The second seria contains avg value and set a dot in the middle of this line.
    ' Set valid number of series: nHead + 1 for Std. Min. + 1 for Std. Max.
    Dim i As Integer                ' seies index
    i = c.SeriesCollection.Count
    Dim nStandards As Integer        ' Number of standard values
    If fMode5 Then
        nStandards = 4
    Else
        nStandards = 2
    End If
    While i > (2 * nHeads) + nStandards       ' too Many Series
        c.SeriesCollection(i).Select
        Selection.Delete
        i = i - 1
    Wend
    While i < (2 * nHeads) + nStandards       ' not enough Series
        c.SeriesCollection.NewSeries
        i = i + 1
    Wend
    
    ' Defining Series values that are shared by all series
    For i = 1 To c.SeriesCollection.Count
        c.SeriesCollection(i).Border.ColorIndex = xlNone '!nRegularColor
        c.SeriesCollection(i).Border.Weight = xlThin
        c.SeriesCollection(i).MarkerSize = 6
    Next
    Dim dValue As Single            ' value in row
    ' Set standard min/max lines. length = table length, height = std. min/max values
    Dim dStdMax As Single, dStdMin As Single, dStdUMax As Single, dStdUMin As Single
    dStdUMin = CSng(DoFormat(chartRange(nHeads + 1, 1).Value, sFormat))
    dStdMin = CSng(DoFormat(chartRange(nHeads + 2, 1).Value, sFormat))
    dStdMax = CSng(DoFormat(chartRange(nHeads + 3, 1).Value, sFormat))
    dStdUMax = CSng(DoFormat(chartRange(nHeads + 4, 1).Value, sFormat))
    
    ' Calculate Extream points in chart for design perpuse
    Dim dChartMin As Single, dChartMax As Single
    If fMode5 Then
        If dStdUMin < dStdMin And dStdUMin <> 0 Then    '' Added 0 check
            dChartMin = dStdUMin
        Else
            dChartMin = dStdMin
        End If
        If dStdUMax > dStdMax And dStdUMax <> 0 Then    '' Added 0 check
            dChartMax = dStdUMax
        Else
            dChartMax = dStdMax
        End If
    Else
        dChartMin = dStdMin
        dChartMax = dStdMax
    End If
    For i = 1 To nHeads
        dValue = chartRange(i, 1).Value       ' Minimal value of head
        If dValue < dChartMin Then
            dChartMin = dValue
        End If
        dValue = chartRange(i, 2).Value       ' Maximal value of head
        If dValue > dChartMax Then
            dChartMax = dValue
        End If
    Next
    If dChartMin <> 0 And dChartMax <> 0 And dChartMin <> dChartMax Then
        Dim strValue As String
        With c.Axes(xlValue)
           .MinimumScale = dChartMin - ((dChartMax - dChartMin) / 10)
           .MaximumScale = dChartMax + ((dChartMax - dChartMin) / 10)
           'Putting contanst string as format because axes label may not recognize my format.
           .TickLabels.NumberFormat = "0.00"
        End With
    End If
    
    Dim nMinMaxColor As Integer, nUMinUMaxColor As Integer
    nMinMaxColor = textCells(nColorMinMaxRow, 2).Value
    nUMinUMaxColor = textCells(nColorUMinUMaxRow, 2).Value
    
    c.SeriesCollection(1).Name = "=""" + sMin + """"
    c.SeriesCollection(2).Name = "=""" + sMax + """"
    If dStdMin <> 0 Then        ' Valid min value
        c.SeriesCollection(1).XValues = "={0," & CStr(nHeads + 1) & "}"
        c.SeriesCollection(1).Values = "={" & CStr(dStdMin) & "," & CStr(dStdMin) & "}"
    Else
        c.SeriesCollection(1).XValues = "={0,0}"
        c.SeriesCollection(1).Values = "={0,0}"
    End If
    c.SeriesCollection(1).Border.LineStyle = xlDot
    c.SeriesCollection(1).Border.ColorIndex = nMinMaxColor
    c.SeriesCollection(1).MarkerStyle = xlNone
    If dStdMax <> 0 Then        ' Valid max value
        c.SeriesCollection(2).XValues = "={0," & CStr(nHeads + 1) & "}"
        c.SeriesCollection(2).Values = "={" & CStr(dStdMax) & "," & CStr(dStdMax) & "}"
    Else
        c.SeriesCollection(2).XValues = "={0,0}"
        c.SeriesCollection(2).Values = "={0,0}"
    End If
    c.SeriesCollection(2).Border.LineStyle = xlDot
    c.SeriesCollection(2).Border.ColorIndex = nMinMaxColor
    c.SeriesCollection(2).MarkerStyle = xlNone
    If fMode5 Then
        c.SeriesCollection(3).Name = "=""" + sUMin + """"
        c.SeriesCollection(4).Name = "=""" + sUMax + """"
        If dStdUMin <> 0 And dStdUMin <> dStdMin Then       ' Valid UMin value
            c.SeriesCollection(3).XValues = "={0," & CStr(nHeads + 1) & "}"
            c.SeriesCollection(3).Values = "={" & CStr(dStdUMin) & "," & CStr(dStdUMin) & "}"
        Else
            c.SeriesCollection(3).XValues = "={0,0}"
            c.SeriesCollection(3).Values = "={0,0}"
        End If
        c.SeriesCollection(3).Border.LineStyle = xlContinuous
        c.SeriesCollection(3).Border.ColorIndex = nUMinUMaxColor
        c.SeriesCollection(3).MarkerStyle = xlNone
        If dStdUMax <> 0 And dStdUMax <> dStdMax Then       ' Valid UMax value
            c.SeriesCollection(4).XValues = "={0," & CStr(nHeads + 1) & "}"
            c.SeriesCollection(4).Values = "={" & CStr(dStdUMax) & "," & CStr(dStdUMax) & "}"
        Else
            c.SeriesCollection(4).XValues = "={0,0}"
            c.SeriesCollection(4).Values = "={0,0}"
        End If
        c.SeriesCollection(4).Border.LineStyle = xlContinuous
        c.SeriesCollection(4).Border.ColorIndex = nUMinUMaxColor
        c.SeriesCollection(4).MarkerStyle = xlNone
    End If
    ' Loop over results, for every head 1 result set
    Dim iSeria As Integer           ' Seria index
    For i = 1 To nHeads
        ' Dealing with series from #nStandards to #(nHead * 2 + nStandards)
        iSeria = (i * 2) + nStandards - 1
        PutSeriesInChart chartRange, c.SeriesCollection, iSeria, i, dStdMin, dStdMax, dStdUMin, dStdUMax, sFormat
    Next
    
    ' Activate chart (and make it visible again)
    c.Location Where:=xlLocationAsObject, Name:="report"
    
    ActiveSheet.Shapes(ActiveChart.Parent.Name).ScaleWidth 0.64, msoFalse, msoScaleFromTopLeft
    fResizeChart = True
        
    nChartsInReport = nChartsInReport + 1
    DrawChart = True
End Function

' Put 1 pair of Series (min-max and avg) in chart
Sub PutSeriesInChart(ByVal chartRange As Range, ByRef sc As SeriesCollection, ByVal iSeria As Integer, ByVal iHead As Integer, ByVal dStdMin As Single, ByVal dStdMax As Single, ByVal dStdUMin As Single, ByVal dStdUMax As Single, ByVal sFormat As String)
    Dim dMin As Single          ' min value in measurements
    Dim dMax As Single          ' max value in measurements
    Dim dAvg As Single          ' avg value in mesurements
    Dim strMin As String
    Dim strMax As String
    Dim strAvg As String
    'Check for blank in grid, that represent no valid head values
    strMin = CStr(chartRange(iHead, 1))
    If strMin = " " Then      ' No valid value for head: empty space in chart
        sc(iSeria).XValues = "={0}"
        sc(iSeria).Values = "={0}"
        sc(iSeria).MarkerStyle = xlNone
        sc(iSeria + 1).XValues = "={0}"
        sc(iSeria + 1).Values = "={0}"
        sc(iSeria + 1).MarkerStyle = xlNone
    Else
        dMin = chartRange(iHead, 1).Value
        If dMin = 0 Then
            strMin = "0"
        Else
            strMin = Format$(dMin, sFormat)
        End If
        dMax = chartRange(iHead, 2).Value
        If dMax = 0 Then
            strMax = "0"
        Else
            strMax = Format$(dMax, sFormat)
        End If
        dAvg = chartRange(iHead, 3).Value
        If dAvg = 0 Then
            strAvg = "0"
        Else
            strAvg = Format$(dAvg, sFormat)
        End If
    End If
    
    ' min/max seria
    sc(iSeria).XValues = "={" & CStr(iHead) & "," & CStr(iHead) & "}"
    sc(iSeria).Values = "={" & strMin & _
        "," & strMax & "}"
    sc(iSeria).Border.LineStyle = xlContinuous
    sc(iSeria).MarkerStyle = xlNone
    ' avg dot seria
    sc(iSeria + 1).XValues = "={" & CStr(iHead) & "}"
    sc(iSeria + 1).Values = "={" & strAvg & "}"
    sc(iSeria + 1).Border.LineStyle = xlContinuous
    sc(iSeria + 1).MarkerStyle = xlMarkerStyleCircle
    
    ' Format series by specifications
    Dim nMinMaxColor As Integer
    Dim nUMinUMaxColor As Integer
    Dim nGoodColor As Integer
    nMinMaxColor = textCells(nColorMinMaxRow, 2).Value
    nUMinUMaxColor = textCells(nColorUMinUMaxRow, 2).Value
    nGoodColor = textCells(nColorGoodRow, 2).Value
    sc(iSeria).Border.ColorIndex = 1 ' Always black
    ' Default
    sc(iSeria + 1).MarkerBackgroundColorIndex = nGoodColor
    sc(iSeria + 1).MarkerForegroundColorIndex = xlNone
    If fMode5 Then
        If dAvg > dStdUMax And dStdUMax <> dStdMax And dStdUMax <> 0 Then
            sc(iSeria + 1).MarkerBackgroundColorIndex = nUMinUMaxColor
        ElseIf dAvg < dStdUMin And dStdUMin <> dStdMin And dStdUMin <> 0 Then
            sc(iSeria + 1).MarkerBackgroundColorIndex = nUMinUMaxColor
        ElseIf dAvg > dStdMax And dStdMax <> 0 Then
            sc(iSeria + 1).MarkerBackgroundColorIndex = nMinMaxColor
        ElseIf dAvg < dStdMin And dStdMin <> 0 Then
            sc(iSeria + 1).MarkerBackgroundColorIndex = nMinMaxColor
        End If
    Else
        If dAvg > dStdMax And dStdMax <> 0 Then
            sc(iSeria + 1).MarkerBackgroundColorIndex = nMinMaxColor
        ElseIf dAvg < dStdMin And dStdMin <> 0 Then
            sc(iSeria + 1).MarkerBackgroundColorIndex = nMinMaxColor
        End If
    End If
End Sub

Attribute VB_Name = "MainModule"
''''''''' SEAMCHECK VERSION 4.0
' 25/7/04 - CHButt
' 28/6/04 - countersink / length comparison
' 20/10/03 - modified by Ofer (9th graph bug + selective graphs)
' 25/9/03 - modified by Ofer (footer change)
' 28/8/03 - Modified by Ofer (remark field changed, color codes to AvgAvg).
' 24/8/03 - modified by Ofer (graphs in a row)
' 19/6/03 - modified by Ofer (added *avg exception*)
' 7/5/03 - modified by Ofer (added split rows)

Option Explicit

' Global Variables
Public reportCells As Range                         ' report sheet range
Public dataCells As Range                           ' data sheet range
Public gridCells As Range                           ' grid sheet range
Public textCells As Range                           ' text sheet range
Public fException As Boolean                        ' Is There an exception result
Public fAvgException As Boolean                     ' Is there an average exception...
Public strTitle As String                           ' title of the report
Public book As Workbook                             ' The workbook
Public nHeads As Integer                            ' Number of heads in report
Public nSections As Integer                         ' Number of sections in report
Public fResizeChart As Boolean
Public nFooterTextRow As Integer                    ' The row in text which contains footer
Public nPageSize As Integer                         ' defaults page size (in rows)
Public fMode5 As Boolean                            ' uMin,min,nom,max,uMax mode
Public fShowGraph As Boolean                        ' Show graph flag
Public fRangeCheck As Boolean                       ' Compare range to std. range
Public fPortrait As Boolean                         ' Page Printed with Portrait oriantation
Public nFontSize As Integer                         ' Font Size
Public nHeadlineFontSize As Integer                 ' font size for headlines!
Public strFontName As String                        ' Font type
Public nPageHeight As Integer                       ' Current page size (in rows)
Public nGraphsInRow As Integer                      ' how many graphs in a row
Public fRemarks As String                           ' remark as footer.
Public fAvgOfAverages As Boolean                    ' show average of averages
Public fBCThick As Boolean                          ' Body/Cover thickness.
Public sSeparator As String                         ' separator for + or - signs.
Public fCompareCountersinkLength As Boolean         ' compare countersink length.

' Global Constants
Public Const nChecks As Integer = 11                ' Number of Checks

' The rows in text sheet which contains design data
Public Const nTitleRow As Integer = 2               ' The row of the Title
Public Const nMinMaxCheckFlagRow = 21               ' Min Max check standard flag row
Public Const nColorMinMaxRow = 22                   ' Color code outside min/max row
Public Const nColorUMinUMaxRow = 23                 ' Color code outside umin/umax row
Public Const nColorGoodRow = 24                     ' Color code inside min/max row
Public Const nExceptionListFlagRow = 25             ' Print Exception List flag row
Public Const nShowGraphFlagRow = 26                 ' Show the graph flag row
Public Const nRangeCheckFlagRow = 27                ' Chack range flag row
Public Const nColorRangeRow = 28                    ' Range color
Public Const nLandscapeFlagRow = 29                 ' Landscape orintation flag row
Public Const nFontSizeRow = 30                      ' Font size row
Public Const nFontNameRow = 31                      ' Font type row
Public Const nPagesWideRow = 32
Public Const nPagesHeightRow = 33
Public Const nPageBreakBeforeGraphsRow = 34
Public Const nMaxColRow = 35
Public Const nExceptionRow = 13
Public Const nNameRow = 7

Public nTableRow As Integer  ' The row when the table starts
Dim nPagesWide As Integer, nPagesHeight As Integer
Public iMaxCol As Integer
Public fPageBreakBeforeGraphics As Boolean

'Mode 5 or mode 3
Sub SetMode()
    ' Test if all the UMin row (first row) in the data sheet is empty
    ' the checks result Std. Spec. are from column 4 to 15
    fMode5 = False
    Dim i As Integer
    Dim strCell As String       ' Cell content
    Dim nCol As Integer '!
    For nCol = 4 To 15
        strCell = CStr(dataCells(1, nCol).Value)
        If Not strCell = "" Then
            fMode5 = True
            Exit Sub
        End If
    Next
End Sub

' Add Sheet to workbook
Sub AddASheet(ByVal sName As String)

    On Error Resume Next
    Application.DisplayAlerts = False
        Sheets.Add().Name = sName
        If ActiveSheet.Name <> sName Then ActiveSheet.Delete
    On Error GoTo 0
    Application.DisplayAlerts = True

End Sub

Sub RemoveASheet(ByVal sName As String)
    On Error Resume Next
    Application.DisplayAlerts = False
    Sheets(sName).Delete

    On Error GoTo 0
    Application.DisplayAlerts = True
End Sub

' Initialize global variables value
Sub InitGlobals()
     Set book = Excel.ActiveWorkbook
     AddASheet "grid"
     Sheets("report").Select
   ' set sheets cells values.
    Set reportCells = book.Worksheets("report").Cells
    Set dataCells = book.Worksheets("data").Cells
    Set gridCells = book.Worksheets("grid").Cells
    Set textCells = book.Worksheets("text").Cells
    fException = False
    fAvgException = False
    strTitle = textCells(nTitleRow, 1).Value
    nFontSize = CInt(textCells(nFontSizeRow, 2).Value)
    If nFontSize = 0 Then
        nFontSize = 10
    End If
    strFontName = CStr(textCells(nFontNameRow, 2).Value)
    If strFontName = "" Then
        strFontName = "Arial"
    End If
    
    nPageSize = 90
    nFooterTextRow = 20
    If textCells(nRangeCheckFlagRow, 2).Value = 0 Then
        fRangeCheck = False
    Else
        fRangeCheck = True
    End If
    SetMode
    SetColsTypes
    fPortrait = False
    If textCells(nLandscapeFlagRow, 2).Value = "0" Then
        fPortrait = True
    End If
    
    nPagesWide = CInt(textCells(nPagesWideRow, 2).Value)
    nPagesHeight = CInt(textCells(nPagesHeightRow, 2).Value)
    iMaxCol = CInt(textCells(nMaxColRow, 2).Value)
    nTableRow = 9
    nHeadlineFontSize = CInt(textCells(nMaxColRow + 1, 2).Value)
    nGraphsInRow = CInt(textCells(nMaxColRow + 2, 2).Value)
    fRemarks = (textCells(nMaxColRow + 3, 2).Value = "1")
    fAvgOfAverages = (textCells(nMaxColRow + 4, 2).Value = "1")
    fBCThick = (textCells(nMaxColRow + 5, 2).Value <> "") Or (textCells(nMaxColRow + 5, 3).Value <> "")
    sSeparator = textCells(nMaxColRow + 6, 2).Value
    If sSeparator = "" Then
        sSeparator = " "
    End If
    fCompareCountersinkLength = (textCells(nMaxColRow + 7, 2).Value = "1")
    
    fPageBreakBeforeGraphics = False
    If textCells(nPageBreakBeforeGraphsRow, 2).Value <> "0" Then
        fPageBreakBeforeGraphics = True
    End If
    
    nMinMaxColor = textCells(nColorMinMaxRow, 2).Value
    nUMinUMaxColor = textCells(nColorUMinUMaxRow, 2).Value
    nGoodColor = textCells(nColorGoodRow, 2).Value
    nRangeColor = textCells(nColorRangeRow, 2).Value
    
End Sub

' Set footer text
Sub SetFooter(ByVal sFooterText As String, ByVal fBorder As Boolean, ByVal fAlignCenter As Boolean, Optional nSize As Integer)
    If nSize = 0 Then nSize = 6
    Dim rng As Range
    Set rng = Range("B" + CStr(nPageHeight + 1), reportCells(nPageHeight + nSize, iMaxCol))
    With rng
        .HorizontalAlignment = IIf(fAlignCenter, xlCenter, xlLeft)
        .VerticalAlignment = xlTop
        .WrapText = True
        .MergeCells = True
        .Font.Name = strFontName
        .Font.Size = nFontSize + 2
    End With
    reportCells(nPageHeight + 1, 2).Value = sFooterText
    If fBorder Then
        DrawBorderLines rng, True, True, True, True
    End If
    ' Set end of page
    
    nPageHeight = nPageHeight + nSize + 1
End Sub

' Set Page to fit table and graphs format
Sub SetPrintedPage()
On Error Resume Next
    With Sheets("report").PageSetup
        .Zoom = False
        If nPagesWide > 0 Then
            .FitToPagesWide = nPagesWide
        End If
        If nPagesHeight > 0 Then
            .FitToPagesTall = nPagesHeight
        End If
        If fPortrait Then
            .Orientation = xlPortrait
        Else
            .Orientation = xlLandscape
        End If
    End With
End Sub

' Set regular font Format for specific range
Sub RegularFontFormat(fontRange As Range)
    With fontRange
        .Font.Name = strFontName
        .Font.Size = nFontSize
    End With
End Sub

Sub SetReportCell(ByVal nRow As Integer, ByVal nCol As Integer, ByVal sValue As String)
    reportCells(nRow, nCol).NumberFormat = "@"      ' Text format
    reportCells(nRow, nCol).Value = sValue
    reportCells(nRow, nCol).Font.Size = nHeadlineFontSize
End Sub

' Set report headers
Sub SetReportHeaders()
    ' Set headlines alignment to appropriate positions
    Dim iCol As Integer
    For iCol = 2 To 15
        With Range(reportCells(nTitleRow + 1, iCol), reportCells(nTitleRow + 4, iCol))
            ' cols 2, 5, 8...
            If (iCol + 1) Mod 3 = 0 Then
                .HorizontalAlignment = xlRight
            ElseIf (iCol Mod 3) = 0 Then
                .HorizontalAlignment = xlLeft
            End If
        End With
    Next
    
    
    Dim i As Integer
    
    ' Set first 4 headlines names from 'text' sheet
    For i = 1 To 3
        SetReportCell nTitleRow + i, 2, textCells(nTitleRow + 1, i).Value
    Next
    
    SetReportCell nTitleRow + 1, 5, textCells(nTitleRow + 1, 4).Value
    
    ' First 4 headlines values
    SetReportCell nTitleRow + 1, 3, dataCells(6, 1).Value     '! Report number on A6
    SetReportCell nTitleRow + 2, 3, Format$(CStr(dataCells(7, 1)), "Short Date")
    SetReportCell nTitleRow + 3, 3, Format$(CStr(dataCells(7, 1)), "Long Time")
    SetReportCell nTitleRow + 1, 6, dataCells(9, 1).Value     '! Line number
    
    ' Taking headers Names From A22-A29 in data sheet. Values from A13-A20
    For i = 1 To 8
        SetReportCell nTitleRow + (i Mod 3) + 1, 5 + (3 * (i \ 3)), CStr(dataCells(21 + i, 1).Value) & ":"                    ' Header name
        SetReportCell nTitleRow + (i Mod 3) + 1, 6 + (3 * (i \ 3)), CStr(dataCells(12 + i, 1).Value)                         ' Header value
    Next
    
    SetReportCell nTitleRow + 1, 14, textCells(nTitleRow + 1, 5).Value    ' PROD
    SetReportCell nTitleRow + 1, 15, dataCells(8, 1).Value
    SetReportCell nTitleRow + 2, 14, textCells(nTitleRow + 1, 6).Value    ' number of heads
    SetReportCell nTitleRow + 2, 15, CStr(nHeads)
    SetReportCell nTitleRow + 3, 14, textCells(nTitleRow + 1, 7).Value    ' number of sections
    SetReportCell nTitleRow + 3, 15, CStr(nSections)
    
    ' Body and Cover thickness...
    If fBCThick Then
        SetReportCell nTitleRow + 4, 2, textCells(nMaxColRow + 5, 2).Value
        
        ' body thickness 1,1
        SetReportCell nTitleRow + 4, 3, dataCells(6, 5).Value
        
        SetReportCell nTitleRow + 4, 5, textCells(nMaxColRow + 5, 3).Value
        
        ' cover thickness 1,1
        SetReportCell nTitleRow + 4, 6, dataCells(6, 6).Value
    End If
End Sub


' Set border lines for given range
Sub DrawBorderLines(borderRange As Range, ByVal fTop As Boolean, ByVal fBottom As Boolean, _
    ByVal fRight As Boolean, ByVal fLeft As Boolean)
    borderRange.Borders(xlDiagonalDown).LineStyle = xlNone
    borderRange.Borders(xlDiagonalUp).LineStyle = xlNone
    If (fTop) Then
        With borderRange.Borders(xlEdgeTop)
            .LineStyle = xlDouble
            .Weight = xlThick
            .ColorIndex = xlAutomatic
        End With
    End If
    If (fBottom) Then
        With borderRange.Borders(xlEdgeBottom)
            .LineStyle = xlDouble
            .Weight = xlThick
            .ColorIndex = xlAutomatic
        End With
    End If
    If (fRight) Then
        With borderRange.Borders(xlEdgeRight)
            .LineStyle = xlDouble
            .Weight = xlThick
            .ColorIndex = xlAutomatic
        End With
    End If
    If (fLeft) Then
        With borderRange.Borders(xlEdgeLeft)
            .LineStyle = xlDouble
            .Weight = xlThick
            .ColorIndex = xlAutomatic
        End With
    End If
End Sub

Public Sub DoTitle()
'    Range("2:2").RowHeight = 20         ' Setting Title Format
    ' Set document title
    If fAvgException Then
        strTitle = strTitle + textCells(2, 4).Value
    ElseIf fException = True Then
        strTitle = strTitle + textCells(2, 2).Value
    End If
    Range(reportCells(2, 1), reportCells(2, 15)).MergeCells = True
    With reportCells(2, 1)
        .Font.Name = strFontName
        .Font.Size = nFontSize
        .Value = strTitle
        .HorizontalAlignment = xlCenter
    End With
    
    ' draw line below title.
    DrawBorderLines Range("A" & CStr(nTitleRow) & ":O" & CStr(nTitleRow)), _
        False, True, False, False
        
    Range(reportCells(1, 1), reportCells(1, 15)).MergeCells = True
    With reportCells(1, 1)
        .Font.Name = strFontName
        .Font.Size = nFontSize
        .Value = dataCells(21, 1).Value
        .HorizontalAlignment = xlCenter
    End With
    
    Range(reportCells(7, 1), reportCells(7, 15)).MergeCells = True
    With reportCells(7, 1)
        .Font.Name = strFontName
        .Font.Size = nFontSize
        .Value = dataCells(30, 1).Value
        .HorizontalAlignment = xlCenter
    End With
End Sub

' Main Function
Sub FormatReport()
    Static fReentrant As Boolean
    If fReentrant Then Exit Sub
    fReentrant = True
        
    ' check if allready contains data. if so dont rebuild report
    If Excel.ActiveWorkbook.Worksheets("report").Cells(nTitleRow, 1).Value <> "" Then
        fReentrant = False          ' Allow Reentring when data is cleaned
        Exit Sub
    End If
    
    InitGlobals
    
    ' no report number, don't do a thing
    If (dataCells(6, 1).Value = "") Then
        Set dataCells = Nothing
        Set reportCells = Nothing
        Set gridCells = Nothing
        fReentrant = False
        Exit Sub
    End If
    ' already filled, don't do a thing!
    If (reportCells(2, 3).Value <> "") Then
        Set dataCells = Nothing
        Set reportCells = Nothing
        Set gridCells = Nothing
        fReentrant = False
        Exit Sub
    End If
    reportCells.Clear
    gridCells.Clear
    
    nHeads = dataCells(10, 1).Value
    nSections = dataCells(11, 1).Value
    
    SetPrintedPage
    
'   Header text
    With Range(reportCells(3, 1), reportCells(6, 15))
        .Font.Name = strFontName
        .Font.Size = nFontSize
    End With

    SetReportHeaders
    BuildTable
    
    DoTitle
    
    Dim nToShow As Integer              ' Showing graph, exception list flag
    nToShow = textCells(nShowGraphFlagRow, 2).Value
    If nToShow <> 0 Then
        CreateGraph                         ' drawing all charts
    End If
    nToShow = textCells(nExceptionListFlagRow, 2).Value
    If nToShow <> 0 Then
        ExListWrite
    End If
    
    SetFooter textCells(nFooterTextRow, 1).Value, False, True
    If fRemarks Then
        SetFooter CStr(dataCells(29, 1).Value), False, True, 1
        nPageHeight = nPageHeight - 1
        SetFooter CStr(dataCells(20, 1).Value), False, True, 2
    End If
    
    'hide all user irrelevent sheets
    Worksheets("data").Visible = False
    Worksheets("text").Visible = False
    Worksheets("grid").Visible = False
    
    RemoveASheet "grid"
    Worksheets("report").Range("A1:A1").Select
    fReentrant = False
End Sub


Attribute VB_Name = "RangeException"
Option Explicit

Public sINI As String

' Ranges values
Private dSeamHeightRange As Single          ' Seam Height range
Private dSeamThicknessRange As Single       ' Seam Thickness range
Private dCountersinkRange As Single         ' Countersink range
Private dBodyHookRange As Single            ' Body Hook range
Private dOverLapRange As Single             ' Over Lap range (percent)
Private dCoverHookRange As Single           ' Cover Hook range
Private dTightRange As Single               ' Tight range
Private dBHButtingRange As Single           ' BHButting range
Private dFreeSpaceRange As Single           ' Free Space range
Private dOverLapValRange As Single          ' Over Lap range

Private fRangeValid As Boolean              ' There is some valid range
Private strProd As String                   ' Product name defines the section in ini file

Private Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long
Private Declare Function GetPrivateProfileSection Lib "kernel32" Alias "GetPrivateProfileSectionA" (ByVal lpAppName As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
 
' Read from ini file .
Public Function INIRead(ByVal sSection As String, ByVal sKey As String, _
Optional sDefault As String, Optional fWriteIfDefault As Boolean) As String
    Dim sReturn As String, iCount As Integer
    sReturn = Space$(300)
    iCount = GetPrivateProfileString(sSection, sKey, "", sReturn, Len(sReturn), sINI)

    If (InStr(sReturn, Chr(0)) > 0) And (iCount > 0) Then
        sReturn = Left(sReturn, InStr(sReturn, Chr(0)) - 1)
    Else
        sReturn = sDefault
        If fWriteIfDefault Then
            INIWrite sSection, sKey, sDefault
        End If
    End If

    INIRead = sReturn
End Function

' write into ini file
Public Sub INIWrite(ByVal sSection As String, ByVal sKey As String, sValue As String)
    WritePrivateProfileString sSection, sKey, sValue, sINI
End Sub

' Is there are valid ranges standard (used after setting of values)
Public Function IsValidStdRanges() As Boolean
    If fRangeCheck And fRangeValid Then
        IsValidStdRanges = True
    Else
        IsValidStdRanges = False
    End If
End Function

' Return the value of standard range. 0 returned where value is invalid
Public Function StdRangeValue(ByVal nCheckCol As Integer) As Single
    If (Not fRangeCheck) Or (Not fRangeValid) Then
        StdRangeValue = 0
    ElseIf nCheckCol = 11 Then
        StdRangeValue = dSeamHeightRange
    ElseIf nCheckCol = 7 Then
        StdRangeValue = dSeamThicknessRange
    ElseIf nCheckCol = 12 Then
        StdRangeValue = dCountersinkRange
    ElseIf nCheckCol = 9 Then
        StdRangeValue = dBodyHookRange
    ElseIf nCheckCol = 14 Then
        StdRangeValue = dOverLapRange
    ElseIf nCheckCol = 10 Then
        StdRangeValue = dCoverHookRange
    ElseIf nCheckCol = 17 Then
        StdRangeValue = dTightRange
    ElseIf nCheckCol = 15 Then
        StdRangeValue = dBHButtingRange
    ElseIf nCheckCol = 16 Then
        StdRangeValue = dFreeSpaceRange
    ElseIf nCheckCol = 13 Then
        StdRangeValue = dOverLapValRange
    Else
        StdRangeValue = 0
    End If
End Function

' Check for range exception
Public Function IsRangeException(ByVal nCheckCol As Integer, ByVal dMin As Single, _
    ByVal dMax As Single) As Boolean
    If (Not fRangeCheck) Or (Not fRangeValid) Then
        IsRangeException = False
    Else
        IsRangeException = False        ' default value
        If nCheckCol = 11 Then
            If dSeamHeightRange <> 0 And dSeamHeightRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 7 Then
            If dSeamThicknessRange <> 0 And dSeamThicknessRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 12 Then
            If dCountersinkRange <> 0 And dCountersinkRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 9 Then
            If dBodyHookRange <> 0 And dBodyHookRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 14 Then
            If dOverLapRange <> 0 And dOverLapRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 10 Then
            If dCoverHookRange <> 0 And dCoverHookRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 17 Then
            If dTightRange <> 0 And dTightRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 15 Then
            If dBHButtingRange <> 0 And dBHButtingRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 16 Then
            If dFreeSpaceRange <> 0 And dFreeSpaceRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        ElseIf nCheckCol = 13 Then
            If dOverLapValRange <> 0 And dOverLapValRange < (dMax - dMin) Then
                IsRangeException = True
            End If
        End If
    End If
End Function

' Set values of standard range
Public Sub SetRangeValues()
    sINI = ActiveWorkbook.Path + "\range.ini"

    ' Get section name
    strProd = CStr(dataCells(8, 1))
    dSeamHeightRange = CSng(INIRead(strProd, "Length", "0", True))
    dSeamThicknessRange = CSng(INIRead(strProd, "Thick", "0", True))
    dCountersinkRange = CSng(INIRead(strProd, "Countersink", "0", True))
    dBodyHookRange = CSng(INIRead(strProd, "BHook", "0", True))
    dOverLapRange = CSng(INIRead(strProd, "OverLap", "0", True))
    dCoverHookRange = CSng(INIRead(strProd, "CHook", "0", True))
    dTightRange = CSng(INIRead(strProd, "TGHT", "0", True))
    dBHButtingRange = CSng(INIRead(strProd, "BHButting", "0", True))
    dFreeSpaceRange = CSng(INIRead(strProd, "FreeSpace", "0", True))
    dOverLapValRange = CSng(INIRead(strProd, "OverLapVal", "0", True))
    
    'Check If there is atleast one valid range
    If dSeamHeightRange = 0 And dSeamThicknessRange = 0 And dCountersinkRange = 0 And _
        dBodyHookRange = 0 And dOverLapRange = 0 And dCoverHookRange = 0 And _
        dTightRange = 0 And dBHButtingRange = 0 And dFreeSpaceRange = 0 And _
        dOverLapValRange = 0 Then
        fRangeValid = False
    Else
        fRangeValid = True
    End If
End Sub
Attribute VB_Name = "Sheet1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet2"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Sheet3"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Private Sub Worksheet_Activate()
    FormatReport
End Sub
Attribute VB_Name = "Table"
Option Explicit

Public sUMax As String, sUMin As String, sMin As String, sMax As String, sRangeStd As String, sAvgAvg As String

    ' Getting color representing numbers from text sheet
Public nMinMaxColor As Integer, nUMinUMaxColor As Integer, nGoodColor As Integer, nRangeColor As Integer

Public nColsTypes(nChecks + 1) As Integer      ' 0, 1 or 3 cols for each check
Public nTableCols As Integer                   ' Total number of columns in table
Dim sNumberFormat As String

' Set value 0, 1 or 3 cols for each check
Public Sub SetColsTypes()
    ' Default values
    nColsTypes(1) = 3
    nColsTypes(2) = 3
    nColsTypes(3) = 3
    nColsTypes(4) = 1
    nColsTypes(5) = 1
    nColsTypes(6) = 1
    nColsTypes(7) = 1
    nColsTypes(8) = 1
    nColsTypes(9) = 1
    nColsTypes(10) = 1
    nColsTypes(11) = 3
    nTableCols = 0
    Dim i As Integer, nValue As Integer
    For i = 0 To nChecks               ' read values from 'text' sheet.
        nValue = CInt(textCells(nNameRow + 3, 2 + (i * 3)).Value)
        If nValue = 0 Or nValue = 1 Or nValue = 3 Then
            nColsTypes(i + 1) = nValue
            nTableCols = nTableCols + nValue
        Else                            ' Default value case
            nTableCols = nTableCols + nColsTypes(i + 1)
        End If
    Next
    If nTableCols <> 0 Then
        nTableCols = nTableCols + 1         ' Add columns for hd number.
    End If
End Sub

' Write standard value to sheets
Sub WriteStandardToSheets(ByVal nReportRow As Integer, ByVal nReportCol As Integer, ByVal nGridRow As Integer, ByVal nGridCol As Integer, ByVal dValue As Single, ByVal fAvgOnly As Boolean, ByVal sFormat As String)
    WriteToGrid nGridRow, nGridCol, dValue
    If dValue <> 0 Then
        With reportCells(nReportRow, nReportCol)
            .NumberFormat = sFormat
            .Value = Format$(dValue, sFormat)
        End With
        
        If Not fAvgOnly Then
        
            With reportCells(nReportRow, nReportCol + 1)
                .NumberFormat = sFormat
                .Value = Format$(dValue, sFormat)
            End With
            
            With reportCells(nReportRow, nReportCol + 2)
                .NumberFormat = sFormat
                .Value = Format$(dValue, sFormat)
            End With
        End If
    End If
End Sub

' Write data to report sheet ("Inside the table)
Sub WriteToReport(ByVal dStdMin As Single, ByVal dStdMax As Single, ByVal dStdUMin As Single, ByVal dStdUMax As Single, nRow As Integer, nCol As Integer, ByVal sFormat As String, Optional dValue, Optional fExtream As Boolean = False, Optional fRangeException As Boolean, Optional fIsAvg As Boolean, Optional fCountersinkLessThanLength As Boolean)   'Check Out Of Specifications values
    Dim fMax As Boolean             ' True if value > std. max
    Dim fMin As Boolean             ' True if value < std. min
    Dim fUMax As Boolean            ' True if value > std. unacceptable max
    Dim fUMin As Boolean            ' True if value < std. unacceptable min
    Dim strValue As String
    If IsMissing(dValue) Then
        Exit Sub
    End If
    Dim dVal As Single
    dVal = CSng(Format$(dValue, sFormat))
    
    If IsOutOfSpec(dVal, dStdMin, dStdMax, dStdUMin, dStdUMax, fMin, fUMin, fMax, fUMax) Then
        If fIsAvg Then
            fAvgException = True
        Else
            fException = True
        End If
    End If
    strValue = SetValueString(dVal, fMin, fMax, fUMin, fUMax, sFormat, fExtream, fRangeException, fCountersinkLessThanLength)
    SetTableCellFormat fMin, fMax, fUMin, fUMax, nRow, nCol, fExtream, fRangeException Or fCountersinkLessThanLength
    reportCells(nRow, nCol).NumberFormat = "@"      ' Text format
    reportCells(nRow, nCol).Value = strValue
End Sub

' Set the remark header
Sub SetRemarkHeader(ByVal nSrcCol As Integer, ByVal nTargetCol As Integer, _
    ByVal nColType As Integer)
    If nColType = 0 Or nTableCols = 0 Then Exit Sub
    If nColType = 3 Then   ' Header with a Max Min Avg Format
        With Range(reportCells(nTableRow, nTargetCol), _
            reportCells(nTableRow + 1, nTargetCol + 2))
            .WrapText = True
            .VerticalAlignment = xlCenter
            .MergeCells = True
        End With
        RegularFontFormat Range(reportCells(nTableRow, nTargetCol), _
            reportCells(nTableRow + 1, nTargetCol + 2))
        reportCells(nTableRow, nTargetCol).Value = textCells(nNameRow, nSrcCol).Value
    Else                        ' Single Column Header Format
        With Range(reportCells(nTableRow, nTargetCol), _
            reportCells(nTableRow + 1, nTargetCol))
            .WrapText = True
            .VerticalAlignment = xlCenter
            .MergeCells = True
        End With
        RegularFontFormat Range(reportCells(nTableRow, nTargetCol), _
            reportCells(nTableRow + 1, nTargetCol))
        reportCells(nTableRow, nTargetCol).Value = textCells(nNameRow, nSrcCol).Value
    End If
End Sub

' Set a single header in table
Sub SetTableHeader(ByVal nSrcCol As Integer, ByVal nTargetCol As Integer, _
    ByVal nColType As Integer)
    If nColType = 0 Or nTableCols = 0 Then Exit Sub
    If nColType = 3 Then   ' Header with a Max Min Avg Format
        RegularFontFormat Range(reportCells(nTableRow, nTargetCol), reportCells(nTableRow + 1, nTargetCol + 2))
        With Range(reportCells(nTableRow, nTargetCol), reportCells(nTableRow + 1, nTargetCol + 2))
            .WrapText = True
            .ReadingOrder = xlContext
        End With
        Range(reportCells(nTableRow, nTargetCol), reportCells(nTableRow, nTargetCol + 2)).MergeCells = True
        reportCells(nTableRow, nTargetCol).Value = textCells(nNameRow, nSrcCol).Value
        
        Dim i As Integer
        For i = 0 To 2  ' Copy Min, Max, Avg Strings
            Range(reportCells(nTableRow + 1, nTargetCol + i), reportCells(nTableRow + 1, nTargetCol + i)).MergeCells = True
            reportCells(nTableRow + 1, nTargetCol + i).Value = textCells(nNameRow + 1, nSrcCol + i).Value
        Next
    Else                        ' Single Column Header Format
        With Range(reportCells(nTableRow, nTargetCol), reportCells(nTableRow + 1, nTargetCol))
            .WrapText = True
            .ReadingOrder = xlContext
            .MergeCells = True
            .VerticalAlignment = xlCenter
        End With
        RegularFontFormat Range(reportCells(nTableRow, nTargetCol), reportCells(nTableRow + 1, nTargetCol))
        reportCells(nTableRow, nTargetCol).Value = textCells(nNameRow, nSrcCol).Value
    End If
End Sub

' Set all the border lines in the table
Sub SetTableLines(ByVal iStartCol As Integer)
    Sheets("report").Select
        
    Dim i As Integer, nCol As Integer
    nCol = 2                    ' First column of a check
    For i = iStartCol To nChecks + 1    ' All the checks and Remark column
        If nCol > iMaxCol Then
            Exit For
        End If
        
        If nColsTypes(i) = 3 Then
            DrawBorderLines Range(reportCells(nTableRow, nCol), _
                reportCells(nTableRow + 1 + nHeads, nCol + 2)), False, False, True, False
            nCol = nCol + 3
        ElseIf nColsTypes(i) = 1 Then
            DrawBorderLines Range(reportCells(nTableRow, nCol), _
                reportCells(nTableRow + 1 + nHeads, nCol)), False, False, True, False
            nCol = nCol + 1
        End If
    Next

    ' Set outer border for the table
    DrawBorderLines Range(reportCells(nTableRow, 1), _
        reportCells(nTableRow + 1 + nHeads, nCol - 1)), True, True, True, True
    'Headers seperator line
    DrawBorderLines Range(reportCells(nTableRow, 1), _
        reportCells(nTableRow + 1, nCol - 1)), False, True, False, False
    ' HD Number right seperator line
    DrawBorderLines Range(reportCells(nTableRow, 1), _
        reportCells(nTableRow + 1 + nHeads, 1)), False, False, True, False

End Sub

' Set Table format
Sub SetTableFormat(ByVal iStartCol As Integer)
    Dim nTableCols As Integer, i As Integer
    nTableCols = 1      ' Column for head numbers. Ignore empty table case
    For i = iStartCol To nChecks + 1
        nTableCols = nTableCols + nColsTypes(i)
        If nTableCols > iMaxCol Then
            Exit For
        End If
    Next
    ' Center Alignment for table and standard specification contents.
    ' numbers of rows = table size + 2 rows for headers + 4 rows for std. spec.
    With Range(reportCells(nTableRow, 1), reportCells(nTableRow + nHeads + 6, nTableCols))
        .HorizontalAlignment = xlCenter
        .Font.Name = strFontName
        .Font.Size = nFontSize
    End With
    
    SetTableLines iStartCol
End Sub

' Set Table cell format by the specifications
Sub SetTableCellFormat(ByVal fMinEx As Boolean, ByVal fMaxEx As Boolean, ByVal fUMinEx As Boolean, ByVal fUMaxEx As Boolean, ByVal nRow As Integer, nCol As Integer, Optional fExtream As Boolean = False, _
    Optional fRangeException As Boolean = False)
    ' Check for range exception format
    If fRangeException And fExtream Then
        Range(reportCells(nRow, nCol), reportCells(nRow, nCol)).Font.ColorIndex = nRangeColor
        Exit Sub            ' Range exception color superior to out of spec color
    End If
    Dim nToFormat As Integer    ' '0': Without colors. other values: With colors
    nToFormat = textCells(nMinMaxCheckFlagRow, 2).Value
    If nToFormat = 0 And fExtream Then
        Exit Sub
    End If
    If fUMinEx Or fUMaxEx Then
        Range(reportCells(nRow, nCol), reportCells(nRow, nCol)).Font.ColorIndex = nUMinUMaxColor
    ElseIf fMinEx Or fMaxEx Then
        Range(reportCells(nRow, nCol), reportCells(nRow, nCol)).Font.ColorIndex = nMinMaxColor
    Else
        Range(reportCells(nRow, nCol), reportCells(nRow, nCol)).Font.ColorIndex = nGoodColor
    End If
End Sub

'Set Value As a String for report table
Function SetValueString(ByVal dValue As Single, ByVal fMin As Boolean, ByVal fMax As Boolean, ByVal fUMin As Boolean, ByVal fUMax As Boolean, ByVal sFormat As String, Optional fExtream As Boolean = False, Optional fRangeException As Boolean = False, Optional fCountersinkLessThanLength As Boolean) As String
    Dim strValue As String
    Dim strFormat As String
    Dim nToFormat As Integer    ' '0': Without colors. other values: With colors
    
    If dValue = 0 Then
        strValue = "0"
    Else
        strValue = Format$(dValue, sFormat)
    End If
    
    nToFormat = CInt(textCells(nMinMaxCheckFlagRow, 2).Value)
    If nToFormat = 0 And fExtream Then       ' Do not design table cell contents
        If fRangeException And fExtream And dValue <> 0 Then
            strValue = "!" & sSeparator & strValue & sSeparator
        End If
    Else
        If fMode5 Then
            If fUMax Then
                strValue = "+" & sSeparator & strValue & sSeparator & "*"
            ElseIf fUMin Then
                strValue = "-" & sSeparator & strValue & sSeparator & "*"
            ElseIf fMax Then
                strValue = "+" & sSeparator & strValue & sSeparator
            ElseIf fMin Then
                strValue = "-" & sSeparator & strValue & sSeparator
            End If
        Else
            If fMax Then
                strValue = "+" & sSeparator & strValue & sSeparator
            ElseIf fMin Then
                strValue = "-" & sSeparator & strValue & sSeparator
            End If
        End If
        If fRangeException And fExtream Then
            If InStr(strValue, sSeparator) = 0 Then
                strValue = "!" & sSeparator & strValue & sSeparator
            Else
                strValue = "!" & strValue
            End If
        End If
        If fCountersinkLessThanLength Then
            If InStr(strValue, sSeparator) = 0 Then
                strValue = "#" & sSeparator & strValue & sSeparator
            Else
                strValue = "#" & strValue
            End If
        End If
    End If
    SetValueString = strValue
End Function

Function DoFormat(val As Variant, ByVal sFormat As String) As String
    If IsNumeric(val) And (Not IsEmpty(val)) Then
        DoFormat = Format$(val, sFormat)
    Else
        DoFormat = "0"
    End If
End Function

' Build result column (1 or 3 columns) in the table
Sub BuildResultCol(ByVal nSrcCol As Integer, ByRef nTargetCol As Integer, ByVal nGridCol As Integer, ByVal nCol As Integer, ByVal nColType As Integer, Optional nCompareCol As Integer)
    If nColType = 0 Then Exit Sub
    
    Dim fAvgOnly As Boolean
    If nColType = 1 Then
        fAvgOnly = True
    Else
        fAvgOnly = False
    End If
    Dim iHead As Integer, iSection As Integer
    Dim dStdMax As Single       'standard maximum
    Dim dStdMin As Single       'standard minimum
    Dim dStdUMax As Single      'standard unacceptable maximum
    Dim dStdUMin As Single      'standard unacceptable minimum
    Dim dMin As Single          'minimum result
    Dim dMax As Single          'maximum result
    Dim dAvg As Single          'avarage result
    Dim dValue As Single        'value of a source cell
    Dim strValue As String      'value of a source cell
    Dim nAvg As Integer         ' Number of valid values for calculating average.
    Dim sFormat As String
    
    ' average of averages
    Dim nTotalAvg As Integer, dTotalAvg As Double
    nTotalAvg = 0
    dTotalAvg = 0#
    
    ' get numeric format
    sFormat = CStr(textCells(nNameRow + 2, nGridCol).Value)
        
    dStdMin = CSng(DoFormat(dataCells(2, nSrcCol - 1).Value, sFormat))
    dStdMax = CSng(DoFormat(dataCells(4, nSrcCol - 1).Value, sFormat))
    dStdUMin = CSng(DoFormat(dataCells(1, nSrcCol - 1).Value, sFormat))
    dStdUMax = CSng(DoFormat(dataCells(5, nSrcCol - 1).Value, sFormat))
    nAvg = 0
    Dim fHeadValue As Boolean            ' Is there a valid value in head measerments
    For iHead = 0 To nHeads - 1
        fHeadValue = False
        ' Geting min, max avg values for each head
        For iSection = 0 To nSections - 1  'Calculate values for different cells
            Dim vValue As Variant
            vValue = dataCells(6 + (iHead * nSections) + iSection, nSrcCol)
            If IsNumeric(vValue) And (Not IsEmpty(vValue)) Then
                strValue = DoFormat(vValue, sFormat)
                fHeadValue = True        ' There is a valid value in head measerments
                dValue = CSng(strValue)
                If nAvg = 0 Then    ' Case of first valid input
                    dMin = dValue
                    dMax = dValue
                    dAvg = 0
                End If
                If dValue < dMin Then
                    dMin = dValue
                End If
                If dValue > dMax Then
                    dMax = dValue
                End If
                nAvg = nAvg + 1
                dAvg = dAvg + dValue
                
                dTotalAvg = dTotalAvg + dValue
                nTotalAvg = nTotalAvg + 1
            End If
        Next
        If fHeadValue Then      ' There was some valid values for the head
            If nAvg > 0 Then
                dAvg = dAvg / nAvg
            Else
                dAvg = 0
            End If
            nAvg = 0                    ' Prepering the next check
            
            ' compare countersink and length
            Dim fCountersinkLessThanLength As Boolean
            If nCompareCol > 0 Then
                Dim sCompare As String, dCompare As Double
                sCompare = reportCells(nTableRow + 2 + iHead, nCompareCol)
                If Not IsNumeric(sCompare) Then
                    Dim iPos As Integer
                    iPos = InStr(sCompare, sSeparator)
                    If iPos > 0 Then
                        sCompare = Mid$(sCompare, iPos + 1)
                    End If
                    iPos = InStrRev(sCompare, sSeparator)
                    If iPos > 0 Then
                        sCompare = Left$(sCompare, iPos - 1)
                    End If
                End If
                If IsNumeric(sCompare) Then
                    dCompare = CDbl(sCompare)
                End If
                
                ' valid comparison
                If dCompare > 0 Then
                    If dAvg < dCompare Then
                        fCountersinkLessThanLength = True
                    End If
                End If
            End If
            
            ' Testing exceptons and writing results to sheets
            Dim fRangeException As Boolean
            fRangeException = IsRangeException(nSrcCol, dMin, dMax)
            ExListTest iHead + 1, nGridCol, sFormat, dAvg, dStdMin, dStdMax, dStdUMin, dStdUMax, fRangeException, , fCountersinkLessThanLength

            If nColType = 1 Then
                WriteToReport dStdMin, dStdMax, dStdUMin, dStdUMax, nTableRow + 2 + iHead, nTargetCol, sFormat, dAvg, fIsAvg:=True, fCountersinkLessThanLength:=fCountersinkLessThanLength
                WriteToGrid 2 + iHead, nGridCol, dAvg
            Else
                ExListTest iHead + 1, nGridCol, sFormat, dMin, dStdMin, dStdMax, dStdUMin, dStdUMax
                ExListTest iHead + 1, nGridCol, sFormat, dMax, dStdMin, dStdMax, dStdUMin, dStdUMax
                    
                WriteToGrid 2 + iHead, nGridCol, dMin, dMax, dAvg
                WriteToReport dStdMin, dStdMax, dStdUMin, dStdUMax, nTableRow + 2 + iHead, nTargetCol, sFormat, dMin, True, fRangeException
                WriteToReport dStdMin, dStdMax, dStdUMin, dStdUMax, nTableRow + 2 + iHead, nTargetCol + 1, sFormat, dMax, True, fRangeException
                WriteToReport dStdMin, dStdMax, dStdUMin, dStdUMax, nTableRow + 2 + iHead, nTargetCol + 2, sFormat, dAvg, False, fIsAvg:=True, fCountersinkLessThanLength:=fCountersinkLessThanLength
            End If
        Else
            ' Filling the sheets with blanks
            ' Position in grid sheet: Starts the table from first row.
            WriteToGrid 2 + iHead, nGridCol     ' Writing blank string
            WriteToReport dStdMin, dStdMax, dStdUMin, dStdUMax, nTableRow + 2 + iHead, nTargetCol, sFormat
        End If
    Next
    
    '' Setting standards values as strings in order to avoid slight changes in values.
    Range(reportCells(nTableRow + 2 + nHeads, nTargetCol), reportCells(nTableRow + 5 + nHeads, nTargetCol)).NumberFormat = "@"
    If nColType = 3 Then
        Range(reportCells(nTableRow + 2 + nHeads, nTargetCol + 1), reportCells(nTableRow + 5 + nHeads, nTargetCol + 2)).NumberFormat = "@"
    End If
    
    ' Setting lower Stndard specification values
    If dStdMax = 0 Then             ' Invalid value of standard max
        WriteToGrid 4 + nHeads, nGridCol
        WriteToReport dStdMin, dStdMax, dStdUMin, dStdUMax, nTableRow + 4 + nHeads, nTargetCol, sFormat
    End If
    If dStdMin = 0 Then             ' Invalid value of standard min
        WriteToGrid 3 + nHeads, nGridCol
        WriteToReport dStdMin, dStdMax, dStdUMin, dStdUMax, nTableRow + 3 + nHeads, nTargetCol, sFormat
    End If
    If fMode5 Then
        WriteStandardToSheets nTableRow + 2 + nHeads, nTargetCol, 2 + nHeads, nGridCol, dStdUMin, fAvgOnly, sFormat
        WriteStandardToSheets nTableRow + 5 + nHeads, nTargetCol, 5 + nHeads, nGridCol, dStdUMax, fAvgOnly, sFormat
        ' Write standard range
        WriteStandardToSheets nTableRow + 6 + nHeads, nTargetCol, 6 + nHeads, nGridCol, StdRangeValue(nSrcCol), fAvgOnly, sFormat
    Else
        WriteToGrid 2 + nHeads, nGridCol, dStdMin
        WriteToGrid 5 + nHeads, nGridCol, dStdMax
        ' Write standard range
        WriteStandardToSheets nTableRow + 5 + nHeads, nTargetCol, 6 + nHeads, nGridCol, StdRangeValue(nSrcCol), fAvgOnly, sFormat
    End If
    WriteStandardToSheets nTableRow + 3 + nHeads, nTargetCol, 3 + nHeads, nGridCol, dStdMin, fAvgOnly, sFormat
    WriteStandardToSheets nTableRow + 4 + nHeads, nTargetCol, 4 + nHeads, nGridCol, dStdMax, fAvgOnly, sFormat
    
    If fAvgOfAverages And nColType = 3 And nTotalAvg > 0 Then
        Dim dAvgAvg As Double
        dAvgAvg = dTotalAvg / nTotalAvg
                
        Dim iAvgAvgRow As Integer
        If IsValidStdRanges() Then
            If fMode5 Then
                iAvgAvgRow = nTableRow + 7 + nHeads
            Else
                iAvgAvgRow = nTableRow + 6 + nHeads
            End If
        Else
            If fMode5 Then
                iAvgAvgRow = nTableRow + 6 + nHeads
            Else
                iAvgAvgRow = nTableRow + 5 + nHeads
            End If
        End If
        
        With reportCells(iAvgAvgRow, nTargetCol + 2)
            .NumberFormat = sFormat
            dAvgAvg = CDbl(Format$(dAvgAvg, sFormat))
            
            Dim fMin As Boolean, fUMin As Boolean, fMax As Boolean, fUMax As Boolean
            IsOutOfSpec dAvgAvg, dStdMin, dStdMax, dStdUMin, dStdUMax, fMin, fUMin, fMax, fUMax
    
            .Value = Format$(dAvgAvg, sFormat)
            SetTableCellFormat fMin, fMax, fUMin, fUMax, iAvgAvgRow, nTargetCol + 2
        End With
    End If
    
    nTargetCol = nTargetCol + nColType          ' Next call target column
    
    If nTargetCol > iMaxCol Then
        '!!! Restart!!!
        nTableRow = nPageHeight + 2
        nPageHeight = nTableRow + nHeads + 7
        nTargetCol = 2
        
        SetTableFormat nCol + 1
        InitTable
        SetTableHeader 1, 1, 1
    End If
    
End Sub

Sub InitTable()
    If nHeads = 1 Then          ' Might be a Recheck case
        reportCells(nTableRow + 2, 1).Value = dataCells(6, 2).Value     ' Header number
        reportCells(nTableRow + 2, 1).NumberFormat = sNumberFormat
    Else
        Range(reportCells(nTableRow + 2, 1), reportCells(nTableRow + nHeads + 1, 1)).NumberFormat = sNumberFormat
        Dim i As Integer
        For i = 0 To nHeads - 1
            reportCells(nTableRow + 2 + i, 1).Value = i + 1   ' Head number column
        Next
    End If
        
    If fMode5 Then
        reportCells(nTableRow + 2 + nHeads, 1).Value = sUMin
        reportCells(nTableRow + 5 + nHeads, 1).Value = sUMax
    End If
    reportCells(nTableRow + 3 + nHeads, 1).Value = sMin
    reportCells(nTableRow + 4 + nHeads, 1).Value = sMax
        
    Dim iAvgAvgRow As Integer
    If IsValidStdRanges() Then
        If fMode5 Then
            iAvgAvgRow = nTableRow + 7 + nHeads
            reportCells(nTableRow + 6 + nHeads, 1).Value = sRangeStd
        Else
            iAvgAvgRow = nTableRow + 6 + nHeads
            reportCells(nTableRow + 5 + nHeads, 1).Value = sRangeStd
        End If
    Else
        If fMode5 Then
            iAvgAvgRow = nTableRow + 6 + nHeads
        Else
            iAvgAvgRow = nTableRow + 5 + nHeads
        End If
    End If
    
    If (fAvgOfAverages) Then
        reportCells(iAvgAvgRow, 1).Value = sAvgAvg
    End If
End Sub

' Build Table from Row data
Sub BuildTable()
    If nTableCols = 0 Then
        nPageHeight = nTableRow         ' Page height when there's no table
        Exit Sub                        ' Don't print empty table.
    End If
    
    ' sTableFormat, InitTable, SetTableHeader
    Dim nTargetCol As Integer               ' Column to write in 'report' sheet
    nTargetCol = 2                          ' First Column of checks
    SetTableFormat nTargetCol - 1
    
    sNumberFormat = textCells(nNameRow + 2, 1).Value
    
    'titles!
    sUMax = textCells(nNameRow + 8, 1).Value
    sMax = textCells(nNameRow + 8, 2).Value
    sMin = textCells(nNameRow + 8, 3).Value
    sUMin = textCells(nNameRow + 8, 4).Value
    sRangeStd = textCells(nNameRow + 8, 5).Value
    sAvgAvg = textCells(nNameRow + 8, 6).Value
    
    InitTable
    
    SetRangeValues                          ' Prepare range checks
         
    ' building each check results seperatly
    SetTableHeader 1, 1, 1                              ' Hd number
    nPageHeight = nTableRow + nHeads + 7
    
    ' now start operations!
    SetTableHeader 2, nTargetCol, nColsTypes(1)
    BuildResultCol 11, nTargetCol, 2, 1, nColsTypes(1)  ' SEAM HEIGHT
     
    Dim iLengthAvgCol As Integer
    If nColsTypes(1) >= 1 Then
        If fCompareCountersinkLength Then
            iLengthAvgCol = nTargetCol - 1
        End If
    End If
    
    SetTableHeader 5, nTargetCol, nColsTypes(2)
    BuildResultCol 7, nTargetCol, 5, 2, nColsTypes(2)   ' SEAM THICKNESS
    SetTableHeader 8, nTargetCol, nColsTypes(3)
    BuildResultCol 12, nTargetCol, 8, 3, nColsTypes(3), iLengthAvgCol  ' Countersink
    SetTableHeader 11, nTargetCol, nColsTypes(4)
    BuildResultCol 9, nTargetCol, 11, 4, nColsTypes(4)      ' Body Hook
    SetTableHeader 14, nTargetCol, nColsTypes(5)
    BuildResultCol 14, nTargetCol, 14, 5, nColsTypes(5)    ' %OverLap
    SetTableHeader 17, nTargetCol, nColsTypes(6)
    BuildResultCol 10, nTargetCol, 17, 6, nColsTypes(6)    ' Cover Hook
    SetTableHeader 20, nTargetCol, nColsTypes(7)
    BuildResultCol 17, nTargetCol, 20, 7, nColsTypes(7)   ' Tight
    SetTableHeader 23, nTargetCol, nColsTypes(8)
    BuildResultCol 15, nTargetCol, 23, 8, nColsTypes(8)    ' BHButting
    SetTableHeader 26, nTargetCol, nColsTypes(9)
    BuildResultCol 16, nTargetCol, 26, 9, nColsTypes(9)    ' Free Space
    SetTableHeader 29, nTargetCol, nColsTypes(10)
    BuildResultCol 8, nTargetCol, 29, 10, nColsTypes(10)    ' Over Lap
    
    SetTableHeader 32, nTargetCol, nColsTypes(11)
    BuildResultCol 18, nTargetCol, 32, 11, nColsTypes(11)      ' CHButt
    
    SetRemarkHeader 35, nTargetCol, nColsTypes(12)            ' REMARK
End Sub


Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

' InQuest injected base64 decoded content
' )^J)
' j@^~
' ZrH+

INQUEST-PP=macro
