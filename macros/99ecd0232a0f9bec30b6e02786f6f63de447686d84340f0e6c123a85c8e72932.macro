Attribute VB_Name = "ModBrowseFolder"
Option Explicit

Function BrowseForFolder(Optional strTitle As String) As String
Dim fDialog As FileDialog
    On Error GoTo Err_Handler
    Set fDialog = Application.FileDialog(msoFileDialogFolderPicker)
    With fDialog
        .TITLE = strTitle
        .AllowMultiSelect = False
        .InitialView = msoFileDialogViewList
        If .Show <> -1 Then GoTo Err_Handler:
        BrowseForFolder = fDialog.SelectedItems.Item(1) & Chr(92)
    End With
lbl_Exit:
    Exit Function
Err_Handler:
    BrowseForFolder = vbNullString
    Resume lbl_Exit
End Function

Function BrowseForFile(Optional strTitle As String) As String
Dim fDialog As FileDialog
    On Error GoTo Err_Handler
    Set fDialog = Application.FileDialog(msoFileDialogFilePicker)
    With fDialog
        .TITLE = strTitle
        .AllowMultiSelect = False
        .Filters.Clear
        .Filters.Add "Word documents", "*.doc,*.docx,*.docm"
        .InitialView = msoFileDialogViewList
        If .Show <> -1 Then GoTo Err_Handler:
        BrowseForFile = fDialog.SelectedItems.Item(1)
    End With
lbl_Exit:
    Exit Function
Err_Handler:
    BrowseForFile = vbNullString
    Resume lbl_Exit
End Function


Attribute VB_Name = "ModCloseBtn_TitleBar"
Option Explicit
Private Const mcGWL_STYLE = (-16)
Private Const mcWS_SYSMENU = &H80000
'Windows API calls to handle windows
#If Win64 Then
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, _
                                                                              ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As LongPtr, _
                                                                                    ByVal nIndex As Long) As Long
Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, _
                                                                                    ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwd As LongPtr) As Long
#Else
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, _
                                                                      ByVal lpWindowName As String) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, _
                                                                            ByVal nIndex As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, _
                                                                            ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
#End If

Public Sub RemoveCloseButton(frm As Object)
Dim lngStyle As Long
Dim lngHWnd As Long
    lngHWnd = FindWindow(vbNullString, frm.Caption)
    lngStyle = GetWindowLong(lngHWnd, mcGWL_STYLE)
    If lngStyle And mcWS_SYSMENU > 0 Then
        SetWindowLong lngHWnd, mcGWL_STYLE, (lngStyle And Not mcWS_SYSMENU)
    End If
lbl_Exit:
    Exit Sub
End Sub

Public Sub RemoveTitleBar(oFrm As Object)
Dim lStyle As Long
Dim hMenu As Long
Dim mhWndForm As Long
    mhWndForm = FindWindow("ThunderDFrame", oFrm.Caption)
    lStyle = GetWindowLong(mhWndForm, -16)
    lStyle = lStyle And Not &HC00000
    SetWindowLong mhWndForm, -16, lStyle
    DrawMenuBar mhWndForm
    oFrm.Height = oFrm.Height - 24 + (oFrm.Height - oFrm.InsideHeight)    'Reduce the height of the form by the height of the title bar
lbl_Exit:
    Exit Sub
End Sub




Attribute VB_Name = "ModDatePicker"
Option Explicit

Function BasicCalendar(StartDate As Date) As String
Dim oFrm As New frmDatePicker
    BasicCalendar = oFrm.GetDate( _
                    SelectedDate:=StartDate, _
                    TodayFontColor:=RGB(255, 0, 0))
lbl_Exit:
    Set oFrm = Nothing
    Exit Function
End Function

Function AdvancedCalendar(StartDate As Date) As String
Dim oFrm As New frmDatePicker
    AdvancedCalendar = oFrm.GetDate( _
                       SelectedDate:=StartDate, _
                       FirstDayOfWeek:=Monday, _
                       DateFontSize:=12, _
                       TodayButton:=True, _
                       OkayButton:=True, _
                       ShowWeekNumbers:=True, _
                       BackgroundColor:=RGB(243, 249, 251), _
                       HeaderColor:=RGB(147, 205, 2221), _
                       HeaderFontColor:=RGB(255, 255, 255), _
                       SubHeaderColor:=RGB(223, 240, 245), _
                       SubHeaderFontColor:=RGB(31, 78, 120), _
                       DateColor:=RGB(243, 249, 251), _
                       DateFontColor:=RGB(31, 78, 120), _
                       TrailingMonthFontColor:=RGB(155, 194, 230), _
                       DateHoverColor:=RGB(223, 240, 245), _
                       DateSelectedColor:=RGB(202, 223, 242), _
                       SaturdayFontColor:=RGB(0, 176, 240), _
                       SundayFontColor:=RGB(0, 176, 240), _
                       TodayFontColor:=RGB(0, 176, 80))
lbl_Exit:
    Set oFrm = Nothing
    Exit Function
End Function

Function AdvancedCalendar2(StartDate As Date) As String
Dim oFrm As New frmDatePicker
    AdvancedCalendar2 = oFrm.GetDate( _
                        SelectedDate:=StartDate, _
                        DateFontSize:=11, _
                        TodayButton:=True, _
                        BackgroundColor:=RGB(191, 225, 192), _
                        HeaderColor:=RGB(87, 98, 52), _
                        HeaderFontColor:=RGB(255, 255, 255), _
                        SubHeaderColor:=RGB(191, 225, 192), _
                        SubHeaderFontColor:=RGB(55, 86, 35), _
                        DateColor:=RGB(242, 248, 238), _
                        DateFontColor:=RGB(87, 98, 52), _
                        SaturdayFontColor:=RGB(55, 86, 35), _
                        SundayFontColor:=RGB(55, 86, 35), _
                        TrailingMonthFontColor:=RGB(106, 163, 67), _
                        DateHoverColor:=RGB(198, 224, 180), _
                        DateSelectedColor:=RGB(191, 225, 192), _
                        TodayFontColor:=RGB(255, 0, 0), _
                        DateSpecialEffect:=fmSpecialEffectRaised)
lbl_Exit:
    Set oFrm = Nothing
    Exit Function
End Function

Sub Test()
MsgBox BasicCalendar(Date)
'MsgBox AdvancedCalendar(Date)
'MsgBox AdvancedCalendar2(Date)
End Sub
Attribute VB_Name = "ModExcel"
Option Explicit

Public Function IsFileOpen(fileFullName As String) As Boolean
Dim FileNumber As Integer
Dim errorNum As Integer

    On Error Resume Next
    FileNumber = FreeFile()        ' Assign a free file number.
    ' Attempt to open the file and lock it.
    Open fileFullName For Input Lock Read As #FileNumber
    Close FileNumber        ' Close the file.
    errorNum = Err        ' Assign the Error Number which occured
    On Error GoTo 0       ' Turn error checking on.
    ' Now Check and see which error occurred and based
    ' on that you can decide whether file is already
    ' open
    Select Case errorNum
            ' No error occurred so ErroNum is Zero (0)
            ' File is NOT already open by another user.
        Case 0
            IsFileOpen = False
            ' Error number for "Permission Denied." is 70
            ' File is already opened by another user.
        Case 70
            IsFileOpen = True
            ' For any other Error occurred
        Case Else
            Error errorNum
    End Select
End Function

Public Function IsSheet(strWorkBook As String, strSheet As String) As Boolean
Dim CN As Object
Dim RS As Object
Dim iRows As Integer
Dim strTable As String
Dim strSheetName As String

    Set CN = CreateObject("ADODB.Connection")
    CN.Open ConnectionString:="Provider=Microsoft.ACE.OLEDB.12.0;" & _
                              "Data Source=" & strWorkBook & ";" & _
                              "Extended Properties=""Excel 12.0 Xml;HDR=YES"";"
    Set RS = CN.OpenSchema(20, Array(Empty, Empty, Empty, "Table"))
    With RS
        .MoveLast
        iRows = .RecordCount
        .MoveFirst
    End With
    Do While Not RS.EOF
        strTable = RS!TABLE_NAME
        If Right(strTable, 1) = "$" Then
            strSheetName = Left(RS!TABLE_NAME, Len(RS!TABLE_NAME) - 1)
            If strSheetName = strSheet Then
                IsSheet = True
                Exit Do
            End If
        End If
        RS.MoveNext
    Loop
    If RS.State = 1 Then RS.Close
    Set RS = Nothing
    If CN.State = 1 Then CN.Close
    Set CN = Nothing
lbl_Exit:
    Exit Function
End Function


Attribute VB_Name = "ModFileExists"
Option Explicit

Public Function FileExists(ByVal Filename As String) As Boolean
Dim lngAttr As Long
    On Error GoTo NoFile
    lngAttr = GetAttr(Filename)
    If (lngAttr And vbDirectory) <> vbDirectory Then
        FileExists = True
    End If
NoFile:
    Exit Function
End Function

Public Function FolderExists(ByVal PathName As String) As Boolean
Dim lngAttr As Long
    On Error GoTo NoFolder
    lngAttr = GetAttr(PathName)
    If (lngAttr And vbDirectory) = vbDirectory Then
        FolderExists = True
    End If
NoFolder:
    Exit Function
End Function

Public Function CleanFileName(StrFilename As String, strExtension As String) As String
Dim vfName As Variant
Dim lng_Name As Long
    If InStr(1, StrFilename, Chr(92)) > 0 Then
        vfName = Split(StrFilename, Chr(92))
        CleanFileName = vfName(UBound(vfName))
        vfName = Split(CleanFileName, Chr(46))
    Else
        vfName = Split(StrFilename, Chr(46))
    End If
    CleanFileName = vfName(0)
    If UBound(vfName) > 1 Then
        For lng_Name = 1 To UBound(vfName) - 1
            CleanFileName = CleanFileName & Chr(46) & vfName(lng_Name)
        Next lng_Name
    End If
    vfName = Split(CleanFileName, Chr(11))
    CleanFileName = vfName(0)
    vfName = Split(CleanFileName, Chr(13))
    CleanFileName = vfName(0) & Chr(46) & strExtension
    CleanFileName = Replace(CleanFileName, Chr(34), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(42), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(47), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(58), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(60), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(62), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(63), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(92), Chr(95))
    CleanFileName = Replace(CleanFileName, Chr(124), Chr(95))
lbl_Exit:
    Exit Function
End Function

Public Function FileNameUnique(strPath As String, _
                               StrFilename As String, _
                               strExtension As String) As String
Dim lngF As Long
Dim lngName As Long
    lngF = 1
    lngName = Len(StrFilename) - (Len(strExtension) + 1)
    StrFilename = Left(StrFilename, lngName)
    Do While FileExists(strPath & StrFilename & Chr(46) & strExtension) = True
        StrFilename = Left(StrFilename, lngName) & "(" & lngF & ")"
        lngF = lngF + 1
    Loop
    FileNameUnique = StrFilename & Chr(46) & strExtension
lbl_Exit:
    Exit Function
End Function

Public Function GetFileNameWithoutExtension(ByRef StrFilename As String) As String
    On Error GoTo Err_NoExtension
    GetFileNameWithoutExtension = VBA.Left(StrFilename, (InStrRev(StrFilename, ".", -1, vbTextCompare) - 1))
lbl_Exit:
    Exit Function
Err_NoExtension:
    GetFileNameWithoutExtension = StrFilename
    Resume lbl_Exit
End Function


Public Function GetExtension(ByRef StrFilename As String) As String
    GetExtension = VBA.Right(StrFilename, Len(StrFilename) - InStrRev(StrFilename, Chr(46)) + 1)
lbl_Exit:
    Exit Function
Err_NoExtension:
    GetExtension = vbNullString
    Resume lbl_Exit
End Function

Public Sub FillBM(strBMName As String, strValue As String)
Dim oRng As Range
    With ActiveDocument
        On Error GoTo lbl_Exit
        Set oRng = .Bookmarks(strBMName).Range
        oRng.Text = strValue
        oRng.Bookmarks.Add strBMName
    End With
lbl_Exit:
    Exit Sub
End Sub

Attribute VB_Name = "ModGetOutlook"
Option Explicit
'Ben Clothier - http://www.rondebruin.nl/win/s1/outlook/openclose.htm
#Const LateBind = True

Const olMinimized As Long = 1
Const olMaximized As Long = 2
Const olFolderCalendar As Long = 9
Const olFolderContacts As Long = 10
Const olFolderDrafts As Long = 16
Const olFolderInbox As Long = 6
Const olFolderOutbox = 4
Const olFolderSentMail = 5
Const olFolderTasks = 13

#If LateBind Then

Public Function OutlookApp( _
       Optional WindowState As Long = olMinimized, _
       Optional Folder As Long = olFolderInbox, _
       Optional ReleaseIt As Boolean = False _
       ) As Object
Static o As Object
#Else
Public Function OutlookApp( _
       Optional WindowState As Outlook.OlWindowState = olMinimized, _
       Optional Folder As Long = olFolderInbox, _
       Optional ReleaseIt As Boolean _
       ) As Outlook.Application
Static o As Outlook.Application
#End If
    On Error GoTo errHandler

    Select Case True
        Case o Is Nothing, Len(o.Name) = 0
            Set o = GetObject(, "Outlook.Application")
            If o.Explorers.Count = 0 Then
InitOutlook:
                'Open inbox to prevent errors with security prompts
                o.Session.GetDefaultFolder(Folder).Display
                o.ActiveExplorer.WindowState = WindowState
            End If
        Case ReleaseIt
            Set o = Nothing
    End Select
    Set OutlookApp = o

ExitProc:
    Exit Function
errHandler:
    Select Case Err.Number
        Case -2147352567
            'User cancelled setup, silently exit
            Set o = Nothing
        Case 429, 462
            Set o = GetOutlookApp()
            If o Is Nothing Then
                Err.Raise 429, "OutlookApp", "Outlook Application does not appear to be installed."
            Else
                Resume InitOutlook
            End If
        Case Else
            MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Unexpected error"
    End Select
    Resume ExitProc
    Resume
End Function

#If LateBind Then
Private Function GetOutlookApp() As Object
#Else
Private Function GetOutlookApp() As Outlook.Application
#End If
    On Error GoTo errHandler
    Set GetOutlookApp = CreateObject("Outlook.Application")
ExitProc:
    Exit Function
errHandler:
    Select Case Err.Number
        Case Else
            'Do not raise any errors
            Set GetOutlookApp = Nothing
    End Select
    Resume ExitProc
    Resume
End Function

Sub MyMacroThatUseOutlook()
Dim OutApp As Object
    Set OutApp = OutlookApp()
    'Automate OutApp as desired
End Sub

Attribute VB_Name = "ModHelp"
Option Explicit
Private strColor As String
Private iFont As Long
Private strHelp As String
Private frmHeight As Long

Const hlp1 As String = "Choose the type of merge." & vbCr & vbCr & _
      "Various options are provided according to the system configuration. The process will have attempted to start Outlook, before the main dialog is displayed. Where Outlook is available, there will be options to merge to e-mail, " & _
      "either as an attachment or as the body of the message." & vbCr & vbCr & "It is recommended that Outlook is not closed, while running the processes, and is required should you wish to merge to an e-mail message. The add-in will warn if Outlook is not running." & vbCr & vbCr & _
      "The merge document must have a bookmark named 'Chart' in order to display the chart. Where multiple charts are required in the merge document, there must be a bookmark with the same name as each additional chart worksheet." & vbCr & vbCr & _
      "The process will check for the presence of the primary chart bookmark. It does not check for additional chart bookmarks."

Const hlp2 As String = "You must select at least one record in order to complete the merge process. The available records are displayed in the main list box." & vbCr & vbCr & "Only one data field is displayed in the list box. That field must be selected from the 'Display Worksheet Column #' combo box." & vbCr & vbCr & _
      "The chosen column is retained for further merges. The selection of records to be merged may also be stored by checking the 'Retain Selections' check box." & vbCr & vbCr & _
      "The two shortcut buttons 'Select All' and 'Select None', at the bottom of the dialog, allow all the records to be selected, and selections to be cleared." & vbCr & vbCr & _
      "The two radio buttons 'Select Individually' and 'Extend Selection' change the behaviour of the record selection process." & vbCr & vbCr & _
      "'Select Individually' allows one click selection (and retention) of records from the list. This is the default setting." & vbCr & vbCr & _
      "'Extend Selection' allows groups of records to be selected, by holding the Shift key and selecting the first record and then the last record in the group. The records between are thus all selected in a single action." & vbCr & vbCr & _
      "You may switch between the two modes of selection as required, without losing previous selections."

Const hlp7 As String = "The 'Include a field in the Subject?' option allows the use of a field from the data source to be used as the subject of the messages, either together with the 'E-mail Subject' text or instead of it." & vbCr & vbCr & _
      "Where the text field and the field from the data are used together, you may select whether the text field content appears before or after the field content from the data source."

Const hlp8 As String = "Select a field from the data source to name the individual documents. The name field content will be checked for illegal filename characters and any such character found will be replaced with an underscore character." & vbCr & vbCr & _
      "Where two or more filename fields share the same data, the subsequent record does not overwrite the existing file of the same name. Instead a bracketed number is appended to the filename, e.g 'Filename(1).ext'." & vbCr & vbCr & _
      "This also ensures that should the function be run for a second time, into the same folder, the original file set is preserved."

Const hlp9 As String = "Select the field that contains the e-mail addresses. The field selected must only contain legitimate e-mail addresses, and the field must be completed for all records in the set." & vbCr & vbCr & _
      "While an e-mail message does not have to have a subject, it is desirable to include one as messages without subjects may be treated by the recipient as spam." & vbCr & vbCr & _
      "Where appropriate, you may enter text to be used as the body of the message. The default message format will be HTML, but plain text is an option, and the default signature for the account used to send the messages will be included. Use the 'Enter' key in the 'Text for covering e-mail message:' text box to create a new line." & _
      "Text will wrap to the width of the text box, but this wrap is not reflected in the Outlook message." & vbCr & vbCr & _
      "To avoid sending unwanted messages whilst testing, messages are directed to a temporary sub folder of the default 'Drafts' folder, where they can be examined for accuracy. Messages are only transferred to the 'Outbox' when the 'Send Messages' button in the add-in's Ribbon dropdown menu is employed."

Const hlp10 As String = "Throughout the application, the question mark buttons provide context sensitive help on the various functions."

Const hlp11 As String = "Select a folder on the local hard drive i.e. not a web based folder, in which to save the merged documents."

Const hlp12 As String = "The list box below contains the values from the Chart Merge document's data source. Select the column of that data source you wish to display in the list, by choosing the column number in the dropdown list at the top of the Select Records dialog."

Const hlp13 As String = "'Merge to Individual Word Files' saves each selected record as a separate Word document in DOCX format in the 'Merged Documents Folder'."

Const hlp14 As String = "'Merge to Individual PDF Files' saves each selected record as a separate PDF format document in the 'Merged Documents Folder'."

Const hlp15 As String = "'Merge to Printer' sends the individual documents directly to the printer without saving."

Const hlp16 As String = "'Merge to Email Message' copies the individual documents to the bodies of e-mail messages withgout saving the documents. Because of the differences between Word document and HTML e-mail formats, the message bodies may not be identical to the merge document layout. " & _
"Where accuracy of layout is important, use one of the two e-mail with attachment options instead."

Const hlp17 As String = "'Merge to Email as Word Attachment' saves each selected record as a separate Word document in DOCX format in the 'Merged Documents Folder' and attaches the documents to e-mail messages."

Const hlp18 As String = "Merge to Email as PDF Attachment' saves each selected record as a separate PDF format document in the 'Merged Documents Folder' and attaches the documents to e-mail messages."

Function ShowHelp(ByRef lngHelp As Long)
    strColor = &H80000012
    iFont = 10

    Select Case lngHelp
        Case 1: strHelp = hlp1: frmHeight = 300
        Case 2: strHelp = hlp2: frmHeight = 380
        Case 7: strHelp = hlp7: frmHeight = 170
        Case 8: strHelp = hlp8: frmHeight = 220
        Case 9: strHelp = hlp9: frmHeight = 310
        Case 10: strHelp = hlp10: frmHeight = 110
        Case 11: strHelp = hlp11: frmHeight = 110
        Case 12: strHelp = hlp12: frmHeight = 135
        Case 13: strHelp = hlp13: frmHeight = 110
        Case 14: strHelp = hlp14: frmHeight = 110
        Case 15: strHelp = hlp15: frmHeight = 110
        Case 16: strHelp = hlp16: frmHeight = 150
        Case 17: strHelp = hlp17: frmHeight = 130
        Case 18: strHelp = hlp18: frmHeight = 130
        
        Case Else: strHelp = "Help for this function under development.": frmHeight = 100
    End Select

    With frmHelp
        If Val(Application.Version) > 14 Then
            .Height = frmHeight
        Else
            .Height = frmHeight - 8
        End If
        .lblHelp.Height = .Height - 84
        .cbOK.Top = .Height - 60
        With .lblHelp
            .Font.Name = "Tahoma"
            .Font.Size = iFont
            .ForeColor = strColor
            .Caption = strHelp
            .TextAlign = fmTextAlignLeft
        End With
        PlayASound "Chimes"
        RemoveTitleBar frmHelp

        .Show
    End With
    Unload frmHelp
lbl_Exit:
    Exit Function
End Function


Attribute VB_Name = "ModIsRunning"
Option Explicit
Public Enum OfficeAppName
    ' enums always start from zero, unless otherwise specified
    ' for demonstration purposes (on the worksheet), start from 1
    Outlook = 1
    PowerPoint = 2
    Excel = 3
    Word = 4
    Publisher = 5
    Access = 6
End Enum

Public Function IsAppRunning(appName As OfficeAppName) As Boolean
' check if a particular Office app is running

    On Error GoTo NotRunning
    Dim officeApp As Object
    Dim appString As String
    ' assume true
    IsAppRunning = True
    ' determine which app is being checked
    Select Case appName
        Case 1    ' Outlook
            appString = "Outlook"
        Case 2    ' PowerPoint
            appString = "PowerPoint"
        Case 3    ' Excel
            appString = "Excel"
        Case 4    ' Word
            appString = "Word"
        Case 5    ' Publisher
            appString = "Publisher"
        Case 6    ' Access
            appString = "Access"
    End Select
    ' try to hook into existing object
    Set officeApp = GetObject(, appString & ".Application")
lbl_Exit:
    Exit Function
NotRunning:
    IsAppRunning = False
    Resume lbl_Exit
End Function




Attribute VB_Name = "ModMain"
Option Explicit
Public bCopy As Boolean, bEdit As Boolean, bPrint As Boolean
Public ofrmChart As frmCharts
Public olApp As Object
Public olNS As Object
Public strRecs As String
Public vRecs As Variant
Public iRec As Long
Private iRecs As Long
Private oItem As Object
Private olInsp As Object
Private wdDoc As Object
Private MainDoc As Document
Private MainDocName As String
Private i As Long
Private j As Long
Private k As Long
Private m As Long
Private n As Long
Private p As Long
Private q As Long
Private iCount As Long
Private strDataSource As String
Private strDataName As String
Private xlApp As Object
Private xlBook As Object
Private xlSheet As Object
Private xlS As Object
Private xlChart As Object
Private bxlStarted As Boolean
Private DataArray As Variant
Private DataFields As Variant
Private numrecs As Long
Private numflds As Long
Private strDestination As String
Private strFolder As String
Private Email As Long
Private strSubject As String
Private strMessage As String
Private strAttach As String
Private bStarted As Boolean
Private oPrimaryBar As clsProgressBar
Private bChart As Boolean
Private bReceipt As Boolean
Private bRead As Boolean
Private iImportant As Integer
Private iSubject As Integer
Private bSubject As Boolean
Private strSubjectText As String
Private bPrefix As Boolean
Private fname As Long
Private strFname As String
Private oBM As Bookmark
Private strBM As String
Private oRng As Range
Private lRow As Long, lStart As Long
Private xlMData As Object
Private iFormat As Integer
Private LastCol As Integer
Private lCount As Long
Private lFields As Long
Private bSel As Boolean
Private strDis As String
Private strCol As String
Private arr As Variant
Private bMessage As Boolean
Public Const AppID As String = "Mail Merge Charts"

Sub MergeCharts()

Start:
    If Documents.Count = 0 Then
        ShowMessage 2
        Exit Sub
    End If
    If Len(ActiveDocument.Path) = 0 Then
        ShowMessage 2
        Exit Sub
    End If

    Set MainDoc = ActiveDocument
    MainDocName = MainDoc.FullName
    With MainDoc.MailMerge
        If .MainDocumentType <> wdFormLetters Then
            ShowMessage 2
            If Not MainDoc = ThisDocument Then
                MainDoc.Close wdDoNotSaveChanges
                Documents.Open MainDocName
                ShowMessage 11
            End If
            Set MainDoc = Nothing
            Exit Sub
        End If
        If Len(.DataSource.Name) = 0 Then
            ShowMessage 12
            MainDoc.Close wdDoNotSaveChanges
            Documents.Open MainDocName
            ShowMessage 11
            Set MainDoc = Nothing
            Exit Sub
        End If
        If Not .DataSource.Name Like "*.xl*" Then
            ShowMessage 4
            Set MainDoc = Nothing
            Exit Sub
        End If
    End With

    'On Error GoTo Cleanup
    bChart = False
    If MainDoc.Bookmarks.Exists("Chart") Then bChart = True
    If Not bChart Then
        ShowMessage 8
        Set MainDoc = Nothing
        Exit Sub
    End If

    'Get the details of the datasource
    With MainDoc.MailMerge
        strDataSource = .DataSource.Name
        If Not IsSheet(strDataSource, "Chart") Then
            ShowMessage 6
            Set MainDoc = Nothing
            Exit Sub
        End If
        If Not IsSheet(strDataSource, "MergeData") Then
            ShowMessage 7
            Set MainDoc = Nothing
            Exit Sub
        End If

        With .DataSource
            lFields = .FieldNames.Count
            bMessage = False
            For i = 1 To lFields
                If Left(.FieldNames(i).Name, 1) = "F" And _
                   IsNumeric(Right(.FieldNames(i).Name, Len(.FieldNames(i).Name) - 1)) Then
                    If bMessage = False Then
                        ShowMessage 30, True
                        If frmMsg.Tag = 0 Then
                            Unload frmMsg
                            GoTo Cleanup
                        Else
                            bMessage = True
                        End If
                        Unload frmMsg
                    End If
                End If
                If IsEmpty(arr) Then
                    arr = Array(.FieldNames(i).Name)        'Make the Variant an array with a single element
                Else
                    ReDim Preserve arr(UBound(arr) + 1)        'Add next array element
                    arr(UBound(arr)) = .FieldNames(i).Name        'Assign the array element
                End If
            Next i
        End With

        If Not strDataSource = GetSetting(AppID, "Config", "Workbook") Then
            SaveSetting AppID, "Config", "Save Selection", False
            SaveSetting AppID, "Config", "Column", 0
        End If
        .MainDocumentType = wdNotAMergeDocument
    End With

    SaveSetting AppID, "Config", "Workbook", strDataSource

    On Error Resume Next
    Set xlApp = GetObject(, "Excel.Application")
    If Err Then
        Set xlApp = CreateObject("Excel.Application")
        bxlStarted = True
    End If
    On Error GoTo 0

    'On Error GoTo Cleanup
    With xlApp
        '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        .Visible = True
        .WindowState = -4140

        strDataName = Right(strDataSource, Len(strDataSource) - InStrRev(strDataSource, Chr(92)))

        If IsFileOpen(strDataSource) Then
            For Each xlBook In .workbooks
                If xlBook.Name = strDataName Then
                    xlBook.Close SaveChanges:=False
                    Exit For
                End If
            Next xlBook
        End If

        Set xlBook = .workbooks.Open(strDataSource)

        If Not isNamedRange(xlBook.Worksheets("MergeData"), "ChartData") Then
            ShowMessage 24, False, "ChartData"
            GoTo Cleanup:
        End If
        If Not isNamedRange(xlBook.Worksheets("Chart"), "ChartRecord") Then
            ShowMessage 24, False, "ChartRecord"
            GoTo Cleanup:
        End If

        Set xlMData = xlBook.Worksheets("MergeData").Range("ChartData")
        With xlMData
            .Resize(1, .Columns.Count).Name = .Name.Name
        End With
        Set xlMData = xlBook.Worksheets("MergeData").Range("ChartData")
        lRow = xlMData.Cells(1, 1).Row + xlMData.Rows.Count - 1
        lStart = lRow
        Do While xlApp.CountA(xlMData.Cells(lRow, 1).EntireRow) > 0
            Set xlMData = xlBook.Worksheets("MergeData").Range("ChartData")
            lRow = lRow + 1
        Loop
        With xlMData
            .Resize(.Rows.Count + lRow - lStart, .Columns.Count).Name = .Name.Name
        End With

        Set xlMData = xlBook.Worksheets("MergeData").Range("ChartData")

        Set xlSheet = xlBook.Worksheets("Chart")
        If xlSheet.ChartObjects.Count = 0 Then
            ShowMessage 26
            GoTo Cleanup
        End If
        If xlSheet.ChartObjects.Count > 1 Then
            ShowMessage 10
        End If

        DataArray = xlBook.Worksheets("MergeData").Range("A1").CurrentRegion.value
        DataFields = xlBook.Worksheets("MergeData").Range("A1").CurrentRegion.Rows(1)
    End With

    Set ofrmChart = New frmCharts
    With ofrmChart
        .CheckPlain.value = CBool(GetSetting(AppID, "Config", "Format", False))
        .CheckDisclaimer.value = CBool(GetSetting(AppID, "Config", "Disclaimer", True))
        .CheckKeepList.value = CBool(GetSetting(AppID, "Config", "Save Selection", False))

        If Val(Application.Version) > 14 Then
            .Width = 318
        Else
            .Width = 311
        End If
        .MultiPage1.Visible = True
        .MultiPage1.Width = 282
        .MultiPage1.value = 0
        .MultiPage1.Pages(2).Visible = False
        .Help8.Visible = False
        .lblFileName.Visible = False
        .cmbFileName.Visible = False
        .cmdContinue.Enabled = False
        If Val(Application.Version) > 14 Then
            .MultiPage1.Height = .Height - 120
            .Image5.Top = .Height - 92
            .Image6.Top = .Height - 96
            .CheckDisclaimer.Top = .Height - 90
            .cmdCancel.Top = .Height - 62
            .cmdContinue.Top = .Height - 62
        Else
            .MultiPage1.Height = .Height - 113
            .Image5.Top = .Height - 85
            .Image6.Top = .Height - 89
            .CheckDisclaimer.Top = .Height - 83
            .cmdCancel.Top = .Height - 55
            .cmdContinue.Top = .Height - 55
        End If

        With .cmbDestination
            .Clear
            .AddItem "[Select Merge Destination]"
            .AddItem "Merge to Individual Word Files"
            .AddItem "Merge to Individual PDF Files"
            .AddItem "Merge to Printer"
            If IsAppRunning(Outlook) Then
                .AddItem "Merge to Email Message"
                .AddItem "Merge to Email as Word Attachment"
                .AddItem "Merge to Email as PDF Attachment"
            End If
            .ListIndex = 0
        End With
        With .cmbFileName
            For i = 1 To UBound(DataArray, 2)
                .AddItem
                .list(i - 1, 0) = i
                .list(i - 1, 1) = DataArray(1, i)
            Next i
        End With
        .cmbEmail.list = .cmbFileName.list
        .cmbSubject.list = .cmbFileName.list

        With .cmbImportance
            .Clear
            .AddItem
            .list(0, 0) = "Low"
            .list(0, 1) = 0
            .AddItem
            .list(1, 0) = "Normal"
            .list(1, 1) = 1
            .AddItem
            .list(2, 0) = "High"
            .list(2, 1) = 2
            .ListIndex = 1
        End With
        LastCol = xlBook.Worksheets("MergeData").Cells(1, xlBook.Worksheets("MergeData").Columns.Count).End(-4159).Column

        With .cmbColumn
            .Clear
            .AddItem "[Select Column]"
            For k = 1 To LastCol
                .AddItem k
            Next k
        End With

        If .cmbColumn.ListCount > 0 Then
            .cmbColumn.ListIndex = Val(GetSetting(AppID, "Config", "Column", 0))
        End If


        .OptExt.value = CBool(GetSetting(AppID, "Config", "Selection Mode", False))
        .OptInd.value = Not .OptExt.value

        strRecs = GetSetting(AppID, "Config", "Selected Records")

        If .CheckKeepList.value = True Then
            vRecs = Split(strRecs, Chr(44))
            If .ListRecords.ListCount > UBound(vRecs) - 1 Then
                For iRec = 0 To UBound(vRecs) - 1
                    .ListRecords.Selected(Val(vRecs(iRec))) = True
                Next iRec
            End If
        Else
            For iRec = 0 To .ListRecords.ListCount - 1
                .ListRecords.Selected(iRec) = False
            Next iRec
        End If

        .txtMessage.Text = GetSetting(AppID, "Config", "Message Text")
        .txtDocs.Text = GetSetting(AppID, "Config", "Documents Folder")
        .cmdContinue.Enabled = False
        .lblEmail.Visible = False
        .cmbEmail.Visible = False
        .lblSubject.Visible = False
        .txtSubject.Visible = False
        .lblMsg.Visible = False
        .txtMessage.Visible = False
        .lblFileName.Visible = False
        .cmbFileName.Visible = False
        .Caption = AppID & " - Version " & AppVer
        .Top = 250

        RemoveCloseButton ofrmChart
        .Show vbModal

        If .Tag = 0 Then
            GoTo Cleanup
        End If

        If .CheckPlain.value = True Then
            iFormat = 1
        Else
            iFormat = 2
        End If
        bReceipt = .CheckReceipt.value
        bRead = .CheckRead.value
        iImportant = .cmbImportance.Column(1)

        If .cmbSubject.value <> "" Then
            iSubject = Val(.cmbSubject.value)
        Else
            iSubject = 0
            bSubject = False
        End If

        strFolder = .txtDocs.Text

        Select Case .cmbDestination.value
            Case "Merge to Individual Word Files"
                strDestination = "Files"
            Case "Merge to Individual PDF Files"
                strDestination = "PDF"
            Case "Merge to Printer"
                strDestination = "Print"
            Case "Merge to Email Message"
                strDestination = "MessageBody"
                strSubject = .txtSubject.Text
                If .CheckSubject.value = True And .cmbSubject.Text <> "" Then
                    bSubject = True
                    If .OptPrefix.value = True Then
                        bPrefix = True
                    Else
                        bPrefix = False
                    End If
                End If
                On Error Resume Next
                Set olApp = GetObject(, "Outlook.Application")
                On Error GoTo Cleanup
                ModSendMessages.AddOutlookFolder olApp

            Case "Merge to Email as Word Attachment"
                strDestination = "EmailWordAttachment"
                strSubject = .txtSubject.Text
                If .CheckSubject.value = True And .cmbSubject.Text <> "" Then
                    bSubject = True
                    If .OptPrefix.value = True Then
                        bPrefix = True
                    Else
                        bPrefix = False
                    End If
                End If
                strMessage = .txtMessage.Text
                On Error Resume Next
                Set olApp = OutlookApp()
                On Error GoTo Cleanup
                ModSendMessages.AddOutlookFolder olApp

            Case "Merge to Email as PDF Attachment"
                strDestination = "EmailPDFAttachment"
                strSubject = .txtSubject.Text
                If .CheckSubject.value = True And .cmbSubject.Text <> "" Then
                    bSubject = True
                    If .OptPrefix.value = True Then
                        bPrefix = True
                    Else
                        bPrefix = False
                    End If
                End If
                strMessage = .txtMessage.Text
                On Error Resume Next
                Set olApp = OutlookApp()
                On Error GoTo Cleanup
                ModSendMessages.AddOutlookFolder olApp
        End Select

        Email = Val(.txtEmailIndex.Text)
        If .txtFileNameIndex = "" Then
            fname = .cmbColumn.value
        Else
            fname = Val(.txtFileNameIndex.Text)
        End If

        q = 0
        With .ListRecords
            For p = 0 To .ListCount - 1
                If .Selected(p) = True Then q = q + 1
            Next p
        End With
        Set oPrimaryBar = New clsProgressBar
        With oPrimaryBar
            .Background = &HE6FFFF
            .FontColor = 6291584
            .InitialColor = &HF7FBF7
            .FinalColor = &HFF00&
            .TotalActions = q
            .ApplicationStatusBar = False
            .ShowBar
        End With

        Application.ScreenUpdating = False

        ReplaceFields MainDoc

        strRecs = GetSetting(AppID, "Config", "Selected Records")
        vRecs = Split(strRecs, Chr(44))
        iRecs = UBound(vRecs)
        With xlApp
            For j = 2 To UBound(DataArray, 1)
                bSel = False
                With ofrmChart.ListRecords
                    For lCount = 0 To .ListCount - 1
                        If .Selected(lCount) Then
                            If lCount + 2 = j Then
                                bSel = True
                                Exit For
                            End If
                        End If
                    Next lCount
                End With

                If bSel Then
                    oPrimaryBar.StepBar

                    For i = 1 To UBound(DataArray, 2)
                        If DataArray(j, i) = "" Then
                            MainDoc.Variables(arr(i - 1)).value = " "
                        Else
                            MainDoc.Variables(arr(i - 1)).value = DataArray(j, i)
                        End If
                    Next i

                    xlBook.Names("ChartRecord").RefersToRange.value = j - 1


                    With MainDoc
                        UpdateAllFields        '****************************

                        For Each xlS In xlBook.Sheets
                            If xlS.Name Like "Chart*" And InStr(1, xlS.Name, Chr(32)) = 0 Then
                                If xlS.ChartObjects.Count > 0 Then
                                    For Each oBM In MainDoc.Bookmarks
                                        strBM = oBM.Name
                                        If strBM = xlS.Name Then
                                            Set xlChart = xlS.ChartObjects(1)
                                            xlChart.CopyPicture _
                                                    Appearance:=1, _
                                                    Format:=-4147
                                            Set oRng = oBM.Range
                                            'Add paragraph break to frame if missing
                                            For iCount = 1 To .Frames.Count
                                                If oRng.InRange(.Frames(iCount).Range) Then
                                                    If .Frames(iCount).Range.Paragraphs.Count = oRng.Paragraphs.Count Then
                                                        oRng.ParagraphFormat.SpaceAfter = 0
                                                        oRng.InsertParagraphAfter
                                                    End If
                                                    Exit For
                                                End If
                                            Next iCount
                                            oRng.Text = ""
                                            oRng.Paste
                                            oRng.End = oRng.Paragraphs(1).Range.End
                                            If Not oRng.Information(12) Then oRng.End = oRng.End - 1
                                            .Bookmarks.Add strBM, oRng
                                            ClearClipBoard
                                            Set oRng = Nothing
                                            Set oBM = Nothing
                                            Exit For
                                        End If
                                        DoEvents
                                        xlApp.CutCopyMode = False
                                    Next oBM
                                End If
                            End If
                        Next xlS

                        If bSubject = True Then
                            If bPrefix = True Then
                                strSubjectText = DataArray(j, iSubject) & Chr(32) & strSubject
                            Else
                                strSubjectText = strSubject & Chr(32) & DataArray(j, iSubject)
                            End If
                        Else
                            strSubjectText = strSubject
                        End If


                        Select Case strDestination
                            Case "Files"
                                strFname = FixChars(DataArray(j, fname))
                                strFname = strFname & ".docx"
                                strFname = FileNameUnique(strFolder, strFname, "docx")
                                .SaveAs Filename:=strFolder & strFname, _
                                        fileformat:=wdFormatDocumentDefault, _
                                        AddtoRecentFiles:=False
                            Case "PDF"
                                strFname = FixChars(DataArray(j, fname))
                                strFname = strFname & ".pdf"
                                strFname = FileNameUnique(strFolder, strFname, "pdf")
                                .ExportAsFixedFormat strFolder & strFname, _
                                                     wdExportFormatPDF, _
                                                     False, _
                                                     wdExportOptimizeForPrint

                            Case "Print"
                                .PrintOut Background:=False

                            Case "MessageBody"
                                .Range.Copy
                                DoEvents
                                Set oItem = olApp.CreateItem(0)        'olMailItem
                                On Error Resume Next
                                With oItem
                                    .to = DataArray(j, Email)
                                    If Not .to = "" Then .to = Chr(39) & .to & Chr(39)
                                    .to = Replace(.to, "; ", "'; '")

                                    .Subject = strSubjectText
                                    .OriginatorDeliveryReportRequested = bReceipt
                                    .ReadReceiptRequested = bRead
                                    .Importance = iImportant
                                    .BodyFormat = 2
                                    Set olInsp = oItem.GetInspector
                                    Set wdDoc = olInsp.WordEditor
                                    Set oRng = wdDoc.Range(0, 0)
                                    If Err.Number > 0 Then
                                        .Close 0
                                        ShowMessage 31
                                        Err.Clear
                                        GoTo Cleanup
                                    End If
                                    oRng.Paste
                                    oRng.Fields.Unlink
                                    .Display
                                    .Save
                                    .Close 0
                                    ModUtils.MoveMessages strSubjectText
                                End With
                                Set oItem = Nothing
                                Set olInsp = Nothing
                                Set wdDoc = Nothing
                                Set oRng = Nothing


                            Case "EmailWordAttachment"
                                On Error Resume Next
                                strFname = FixChars(DataArray(j, fname))
                                strFname = strFname & ".docx"
                                strFname = FileNameUnique(strFolder, strFname, "docx")
                                .SaveAs Filename:=strFolder & strFname, _
                                        fileformat:=wdFormatDocumentDefault, _
                                        AddtoRecentFiles:=False
                                strAttach = MainDoc.FullName
                                Set oItem = olApp.CreateItem(0)        'olMailItem
                                With oItem
                                    .to = DataArray(j, Email)

                                    If Not .to = "" Then .to = Chr(39) & .to & Chr(39)
                                    .to = Replace(.to, "; ", "'; '")

                                    .Subject = strSubjectText
                                    .OriginatorDeliveryReportRequested = bReceipt
                                    .ReadReceiptRequested = bRead
                                    .Importance = iImportant
                                    .BodyFormat = iFormat
                                    Set olInsp = .GetInspector
                                    Set wdDoc = olInsp.WordEditor
                                    Set oRng = wdDoc.Range(0, 0)
                                    If Err.Number > 0 Then
                                        .Close 0
                                        ShowMessage 31
                                        Err.Clear
                                        GoTo Cleanup
                                    End If
                                    oRng.Text = strMessage
                                    .Display
                                    .Attachments.Add strAttach
                                    .Save
                                    .Close 0
                                End With
                                ModUtils.MoveMessages strSubjectText
                                Set oItem = Nothing
                                Set olInsp = Nothing
                                Set wdDoc = Nothing
                                Set oRng = Nothing

                            Case "EmailPDFAttachment"
                                On Error Resume Next
                                strFname = FixChars(DataArray(j, fname))
                                strFname = strFname & ".pdf"
                                strFname = FileNameUnique(strFolder, strFname, "pdf")
                                .ExportAsFixedFormat strFolder & strFname, _
                                                     wdExportFormatPDF, _
                                                     False, _
                                                     wdExportOptimizeForPrint
                                Set oItem = olApp.CreateItem(0)        'olMailItem
                                With oItem
                                    .to = DataArray(j, Email)
                                    If Not .to = "" Then .to = Chr(39) & .to & Chr(39)
                                    .to = Replace(.to, "; ", "'; '")

                                    .Subject = strSubjectText
                                    .OriginatorDeliveryReportRequested = bReceipt
                                    .ReadReceiptRequested = bRead
                                    .Importance = iImportant
                                    .BodyFormat = iFormat
                                    Set olInsp = .GetInspector
                                    Set wdDoc = olInsp.WordEditor
                                    Set oRng = wdDoc.Range(0, 0)
                                    If Err.Number > 0 Then
                                        .Close 0
                                        ShowMessage 31
                                        Err.Clear
                                        GoTo Cleanup
                                    End If
                                    oRng.Text = strMessage
                                    .Display
                                    .Attachments.Add strFolder & strFname
                                    .Save
                                    .Close 0
                                    ModUtils.MoveMessages strSubjectText
                                End With
                                Set oItem = Nothing
                                Set oItem = Nothing
                                Set olInsp = Nothing
                                Set wdDoc = Nothing
                                Set oRng = Nothing

                        End Select
                    End With
                    DoEvents
                End If
            Next j
        End With
        oPrimaryBar.Complete 2
        Unload ofrmChart
    End With

Cleanup:
    Application.ScreenUpdating = True
    MainDoc.Close wdDoNotSaveChanges
    Documents.Open MainDocName
    ShowMessage 11
    On Error Resume Next
    xlApp.CutCopyMode = False
    xlBook.Close SaveChanges:=False
    On Error GoTo 0
    Set xlBook = Nothing
    If bxlStarted Then xlApp.Quit
    Set ofrmChart = Nothing
    Set oPrimaryBar = Nothing
    Set xlChart = Nothing
    Set xlSheet = Nothing
    Set xlMData = Nothing
    Set xlApp = Nothing
    Set xlBook = Nothing
    Set oItem = Nothing
    'Set objDoc = Nothing
    Set olApp = Nothing
    Exit Sub
ErrMsg:
    If Err.Number > 0 Then
        ShowMessage 5
        Resume Cleanup
    End If
End Sub


Function isNamedRange(xlWB As Object, strRange As String) As Boolean
Dim rRangecheck As Object
    On Error Resume Next
    Set rRangecheck = xlWB.Range(strRange)
    On Error GoTo Err_Handler
    If Not rRangecheck Is Nothing Then
        isNamedRange = True
    Else
        isNamedRange = False
    End If
lbl_Exit:
    Exit Function
Err_Handler:
    isNamedRange = False
    Resume lbl_Exit
End Function

Function CheckFrame() As Boolean
Dim oBM As Bookmark
Dim oFram As Frame
Dim iCount As Long
Dim oRng As Range
    For Each oBM In ActiveDocument.Bookmarks
        For iCount = 1 To ActiveDocument.Frames.Count
            Set oFram = ActiveDocument.Frames(iCount)
            If oBM.Name Like "Chart*" Then
                Set oRng = oBM.Range
                If oRng.InRange(oFram.Range) Then
                    CheckFrame = True
                    GoTo lbl_Exit
                End If
            End If
        Next iCount
    Next oBM
lbl_Exit:
    Exit Function
End Function

Private Sub ClearClipBoard()
Dim oData As New DataObject        'object to use the clipboard
oData.SetText Text:=Empty        'Clear
oData.PutInClipboard        'take in the clipboard to empty it
lbl_Exit:
    Exit Sub
End Sub

Attribute VB_Name = "ModMessage"
Option Explicit

Function ShowMessage(ByRef lngErr As Long, _
                     Optional bYesNo As Boolean, _
                     Optional sText As String, _
                     Optional sValue As String = "0", _
                     Optional bQuit As Boolean)
Dim pCaption As String
Dim pMessage As String
Dim lngFontSize As Long
Dim strYes As String, strNo As String, strYesAcc As String, strNoAcc As String
Dim strQuit As String, strQuitAcc As String
Dim iHeight As Long
Dim iWide As Long, i As Long
Dim strColor As String
Dim cap1 As String
Dim strAlign As String

Const bShowTitleBar As Boolean = False

Const msg1 As String = "The macro must be run from an open document."
Const msg2 As String = "This application is designed only to be run with a Letter type mail merge main document." & vbCr & vbCr & _
      "Open the correct document or change the document type and try again!"
Const msg3 As String = "The add-in may not be run on the template itself!"
Const msg4 As String = "The data source must be an Excel Spreadsheet." & vbCr & vbCr & _
      "Attach the correct data source and try again."
Const msg6 As String = "The attached data source does not contain a worksheet called 'Chart'." & vbCr & vbCr & _
      "Open the correct merge document or attach the chart merge data file and try again!"
Const msg7 As String = "The attached data source does not contain a worksheet called 'MergeData'." & vbCr & vbCr & _
      "Open the correct merge document or attach the chart merge data file and try again!"
Const msg8 As String = "The merge document requires a bookmark called 'Chart' to be placed at the location where the chart is to appear. " & _
      "The active merge document does not have such a bookmark. " & vbCr & vbCr & _
      "Either edit the current document to include such a bookmark, or open the correct merge document and try again." & vbCr & vbCr & _
      "Where multiple charts are required, there must be a bookmark with the name of each additional chart worksheet, however the process only checks for the presence of the first chart bookmark."
Const msg9 As String = "You have not selected a folder in which to save the merged documents. The documents will thus be saved in the currently active folder." & vbCr & vbCr & _
      "Are you sure you wish to do this?"
Const msg10 As String = "The attached workbook has more than one chart. The first chart only will be merged."
Const msg11 As String = "The original document has been restored."
Const msg12 As String = "The merge document has become detached from the chart merge data source. The process will quit and the merge document will be reloaded, which may correct the problem." & vbCr & vbCr & _
      "If you see the message a second time, re-attach the data source to the merge document before attempting to run the process again."
Const msg13 As String = "The documents will be saved in the default document file location."
Const msg14 As String = "The messages have been moved from the temporary folder to the Outbox." & vbCr & vbCr & "If you have Outlook configured to send messages immediately, " & _
      "the messages will be sent automatically." & vbCr & vbCr & "If not you may click 'Send Now' to send and receive all messages now, otherwise click 'Continue' to close this dialog."
Const msg16 As String = "The temporary folder is not present or there are no messages in the temporary folder to send?"
Const msg17 As String = "Outlook does not appear to be running." & vbCr & vbCr & _
      "Under some conditions, especially when merging to the body of an e-mail message, this can cause the process to crash. " & vbCr & vbCr & _
      "If merging to an e-mail message body, you should 'Cancel' the process and start Outlook before continuing."
Const msg18 As String = "The named range 'ChartData', in the data source used for the merge, has data in the last row." & vbCr & vbCr & _
      "The charts will only merge correctly if the named range includes ALL the rows containing data AND the empty row which follows." & vbCr & vbCr & _
      "Open the data source in Excel and correct the area encompassed by the named range before continuing."
Const msg19 As String = "Outlook is not currently running. The add-in will open Outlook when present when the process is run, however it does not appear to be open currently." & vbCr & vbCr & _
      "The process will therefore end." & vbCr & vbCr & "To restore the correct functionality close Word and Outlook (and Excel if it is running). Click CTRL+SHIFT+ESC to run the Windows Task Manager. Ensure there are no hidden running processes - 'Winword.exe', 'Outlook.exe', or 'Excel.exe', and if there are any listed, end those processes." & vbCr & vbCr & _
      "Outlook should then be restarted automatically when you try merging your document again."
Const msg24 As String = "The attached data source does not contain the named range '"
Const msg25 As String = "Select the records to be merged."
Const msg26 As String = "There are no charts in the worksheet?"
Const msg28 As String = "There has been a problem connecting to the data source to display the record list. " & vbCr & vbCr & _
      "Save your unsaved work and restart Word, which should correct the issue."
Const msg29 As String = "The current merge document uses frames to position the charts. Charts inserted into frames may not display correctly when used as the message body. Use instead a table to maintain the relationships between text and chart." & vbCr & vbCr & _
      "Do you wish to continue, select another option or quit?"
Const msg30 As String = "Word has created dummy mergefields. These fields will appear in the field list on the Mailings tab of the ribbon as the letter 'F', followed by a number that represents the column number." & vbCr & vbCr & _
      "The most likely reason for this is one or more empty columns in the data range without header titles. The merge may proceed, but only fields before the first dummy field will be merged." & vbCr & "(See the web page for more information)." & vbCr & vbCr & _
      "Do you wish to continue?"
Const msg31 As String = "An error has occurred that will not allow the document to be added to the message body. The most usual cause is a breakdown in the link between Outlook and Word. The process will now end." & vbCr & vbCr & _
      "It may be possible to restore the correct functionality by closing Word and Outlook (and Excel if it is running). Click CTRL+SHIFT+ESC to run the Windows Task Manager. Ensure there are no hidden running processes - 'Winword.exe', 'Outlook.exe', or 'Excel.exe', and if there are any listed, end those processes." & vbCr & vbCr & _
      "Outlook will automatically be restarted when you try merging your document again."
Const msg55 As String = "Do you wish to delay the message send time?"
Const msg57 As String = "The process adopted to merge to e-mail requires that the individual messages be displayed, to enable the message body to be edited and to retain the default signature for the account used to send the messages." & vbCr & vbCr & _
      "This will result in some unavoidable on screen flashing as the messages are opened and closed; so please avoid looking at the screen during the process, if flashing lights aggravate health related problems."
Const msg58 As String = "The delay time must be in the format 'HH:MM'"

    cap1 = AppID & " - User Information"

    strYes = "OK"
    strYesAcc = "O"
    strNo = "Cancel"
    strNoAcc = "C"
    strQuit = "Quit"
    strQuitAcc = ""
    iHeight = 140
    strColor = &H80000012
    strAlign = "Center"
    lngFontSize = 10

    Select Case lngErr
        Case 1
            pMessage = msg1
            iHeight = 110
        Case 2
            pMessage = msg2
            iHeight = 150
        Case 3
            pMessage = msg3
            iHeight = 110
        Case 4
            pMessage = msg4
            iHeight = 130
        Case 5
            pMessage = "Error Number " & Err.Number & vbCr & Err.Description
            iHeight = 270
            pMessage = pMessage & vbCr & vbCr & _
                       "This error has crashed the add-in. The add-in will attempt to recover, however before attempting to run the add-in again, close Excel." & vbCr & vbCr & _
                       "As Excel is run as a hidden task, if necessary press CTRL+SHIFT+ESC and end the Process 'EXCEL.EXE'. Then re-open Excel and check your data source. " & vbCr & vbCr & _
                       "Finally close the merge document, without saving, and re-open it."
            strAlign = "Left"
        Case 6
            pMessage = msg6
            iHeight = 150
        Case 7
            pMessage = msg7
            iHeight = 150
        Case 8
            pMessage = msg8
            iHeight = 260
            strAlign = "Left"
        Case 9
            pMessage = msg9
            iHeight = 150
            strYes = "Yes"
            strYesAcc = "Y"
            strNo = "No - Reselect"
            strNoAcc = "N"
        Case 10
            pMessage = msg10
            iHeight = 110
        Case 11
            pMessage = msg11
            iHeight = 100
        Case 12
            pMessage = msg12
            iHeight = 190
            strAlign = "Left"
        Case 13
            pMessage = msg13
            strColor = wdColorRed
            iHeight = 110
        Case 14
            pMessage = msg14
            strColor = wdColorBlue
            strYes = "Send Now"
            strNo = "Continue"
            strYesAcc = "S"
            strNoAcc = "C"
            iHeight = 210
            strAlign = "Left"
        Case 16
            pMessage = msg16
            iHeight = 125
        Case 17
            pMessage = msg17
            iHeight = 200
            strAlign = "left"
            strYes = "Continue"
            strYesAcc = "C"
            strNoAcc = "a"
        Case 18
            pMessage = msg18
            iHeight = 230
            strAlign = "left"
        Case 19
            pMessage = msg19
            iHeight = 290
            strAlign = "left"
            strYes = "End the Process"
            strYesAcc = "E"
        Case 20
            pMessage = "A temporary Outlook folder" & vbCr & vbCr & _
                       Chr(39) & sText & Chr(39) & vbCr & vbCr & "has been created as a sub folder to 'Drafts', to store the messages and their attachments."
            strColor = wdColorBlue
            iHeight = 160
        Case 21
            pMessage = "The temporary Outlook folder" & vbCr & vbCr & _
                       Chr(39) & sText & Chr(39) & vbCr & vbCr & "has been removed."
            strColor = wdColorBlue
            iHeight = 150
        Case 22
            pMessage = "The temporary Outlook folder" & vbCr & vbCr & _
                       Chr(39) & sText & Chr(39) & vbCr & vbCr & "contains files that have not been sent. Are you sure that you wish to remove it?"
            strColor = wdColorRed
            strYes = "Yes"
            strNo = "No"
            strYesAcc = "Y"
            strNoAcc = "N"
            iHeight = 160
        Case 23
            pMessage = "Do you wish to remove the Outlook temporary folder" & vbCr & vbCr & Chr(39) & sText & Chr(39) & vbCr & vbCr & _
                       "If you choose to remove it, it will be recreated next time this application is run."
            strYes = "Yes"
            strNo = "No"
            strYesAcc = "Y"
            strNoAcc = "N"
            strColor = wdColorBlue
            iHeight = 180
        Case 24
            pMessage = msg24 & sText & "'." & vbCr & vbCr & _
                       "Open the correct merge document or attach the correct chart merge data file and try again!"

            iHeight = 150
        Case 25
            pMessage = msg25
            iHeight = 100
        Case 26
            pMessage = msg26
            iHeight = 100
        Case 28
            pMessage = msg28
            iHeight = 150
        Case 29
            pMessage = msg29
            iHeight = 200
            strYes = "Continue"
            strYesAcc = "C"
            strNo = "Select"
            strAlign = "left"
            strNoAcc = "S"
        Case 30
            pMessage = msg30
            iHeight = 250
            strAlign = "left"
        Case 31
            pMessage = msg31
            iHeight = 280
            strAlign = "left"
            strYes = "End Process"
            strYesAcc = "E"
        Case 35
            pMessage = sText
            iHeight = 100
        Case 55
            pMessage = msg55
            strYes = "Yes"
            strYesAcc = "Y"
            strNo = "No"
            strNoAcc = "N"
            iHeight = 100
        Case 57
            pMessage = msg57
            iHeight = 220
            strAlign = "left"
        Case 58
            pMessage = msg58
            iHeight = 100
    End Select

    With frmMsg
        .Height = iHeight

        If Val(Application.Version) > 14 Then
            .Width = .Width - 7
            .Height = .Height - 7
        End If

        .Caption = cap1
        .CB_ErrOK.Caption = strYes
        .CB_ErrOK.Accelerator = strYesAcc
        .CBErrNo.Caption = strNo
        .CBErrNo.Accelerator = strNoAcc
        .txtMessage.Height = .Height - 76
        .CB_ErrOK.Top = .Height - 57
        .CBErrNo.Top = .Height - 57
        .CBQuit.Top = .Height - 57

        .CBQuit.Visible = False
        .CBQuit.Accelerator = ""
        If bYesNo = True Then
            .CB_ErrOK.Left = 120    '108
            .CB_ErrOK.Width = 108
            .CBErrNo.Visible = True
            .CBErrNo.Left = 12
            .CBErrNo.Width = 108
        Else
            .CB_ErrOK.Left = 12
            .CB_ErrOK.Width = 216
            .CBErrNo.Visible = False
        End If
        If bQuit = True Then
            .CBQuit.Width = 72
            .CBQuit.Visible = True
            .CBQuit.Left = 12
            .CBQuit.Caption = strQuit
            .CBQuit.Accelerator = strQuitAcc
            .CBErrNo.Width = 72
            .CBErrNo.Visible = True
            .CBErrNo.Left = 84
            .CB_ErrOK.Width = 72
            .CB_ErrOK.Left = 156
        End If
        With .txtMessage
            .Text = pMessage
            .Font.Name = "Tahoma"
            .Font.Size = lngFontSize
            .Font.Bold = False
            .ForeColor = strColor
            Select Case LCase(strAlign)
                Case Is = "left"
                    .TextAlign = fmTextAlignLeft
                Case Is = "right"
                    .TextAlign = fmTextAlignRight
                Case Else
                    .TextAlign = fmTextAlignCenter
            End Select
            .SetFocus
            .SelStart = 0
        End With
        .CB_ErrOK.SetFocus
        PlayASound "Notify"
        If Not bShowTitleBar = True Then RemoveTitleBar frmMsg
        RemoveCloseButton frmMsg
        .Show
    End With
    If bYesNo = False Then Unload frmMsg
lbl_Exit:
    Exit Function
End Function


Attribute VB_Name = "ModPlayASound"
Option Explicit

#If Win64 Then
Public Declare PtrSafe Function sndPlaySound32 Lib "winmm.dll" Alias "sndPlaySoundA" _
       (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
#Else
Public Declare Function sndPlaySound32 Lib "winmm.dll" Alias "sndPlaySoundA" _
                                       (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
#End If


Public Sub PlayASound(ByVal pSound As String)
#If Win64 Then
    Beep
    GoTo lbl_Exit
#Else
    If Dir(pSound, vbNormal) = "" Then
        pSound = Environ("WinDir") & "\Media\" & pSound
        If InStr(1, pSound, ".") = 0 Then pSound = pSound & ".wav"
        If Dir(pSound, vbNormal) = vbNullString Then
            Beep
            Exit Sub
        End If
    End If
    DoEvents
    sndPlaySound32 pSound, 0&
    DoEvents
#End If
lbl_Exit:
    Exit Sub
End Sub

Sub MySound()
    PlayASound "Notify"
End Sub

Attribute VB_Name = "ModResetRegistry"
Option Explicit

Function RegKeyDelete(i_RegKey As String) As Boolean
Dim myWS As Object

    On Error GoTo ErrorHandler
    'access Windows scripting
    Set myWS = CreateObject("WScript.Shell")
    'delete registry key
    myWS.RegDelete i_RegKey
    'deletion was successful
    RegKeyDelete = True
    Set myWS = Nothing
    Exit Function

ErrorHandler:
    'deletion wasn't successful
    RegKeyDelete = False
    Set myWS = Nothing
lbl_Exit:
    Exit Function
End Function

Sub ResetRegistry(Optional bOmit As Boolean)
    RegKeyDelete "HKEY_CURRENT_USER\Software\VB and VBA Program Settings\" & AppID & "\Config\"
    If Not bOmit Then
        If RegKeyDelete("HKEY_CURRENT_USER\Software\VB and VBA Program Settings\" & AppID & "\") = True Then
            ShowMessage 35, False, AppID & " registry settings reset."
        Else
            ShowMessage 35, False, AppID & " registry settings not present"
        End If
    Else
        RegKeyDelete ("HKEY_CURRENT_USER\Software\VB and VBA Program Settings\" & AppID & "\")
    End If
lbl_Exit:
    Exit Sub
End Sub

Attribute VB_Name = "ModSendMessages"
Option Explicit
Private olItems As Object        'As Outlook.Items
Private olItem As Object        'As Outlook.MailItem
Private olNS As Object        'As Outlook.NameSpace
Private olSycs As Object        'As Outlook.SyncObjects
Private olSyc As Object        'As Outlook.SyncObject
Private iFolder As Object        'As Outlook.Folder
Private oRoot As Object        'As Outlook.Folder
Private olFolders As Object        'As Outlook.folders
Private olFolder As Object        'As Outlook.Folder
Private Folder As Object
Private folders As Object
Private foldercount As Integer
Private iNewFolder As Object        'As Outlook.Folder
Private colStores As Object        'As Outlook.Stores
Private oStore As Object        'As Outlook.Store
Private olAccount As Object        'As Outlook.Account
Private bStarted As Boolean
Private bFolderPresent As Boolean
Private bExists As Boolean
Private PortionDone As Double
Private i As Long
Private strAccount As String
Private olMailItems As Object        'As Outlook.Items

Sub AddOutlookFolder(olProcApp As Object)
    bExists = False
    Set olNS = olProcApp.GetNamespace("MAPI")
    'olNS.logon
    For i = olNS.GetDefaultFolder(16).folders.Count To 1 Step -1
        Set iFolder = olNS.GetDefaultFolder(16).folders(i)
        If iFolder.Name = strFolderName Then
            bExists = True
            Set iNewFolder = olNS.GetDefaultFolder(16).folders(i)
            Exit For
        End If
    Next i

    If Not bExists Then
        Set iFolder = olNS.GetDefaultFolder(16)
        Set iNewFolder = iFolder.folders.Add(strFolderName)
        ShowMessage 20, False, iNewFolder.Name
    End If
    Set iFolder = Nothing
    Set iNewFolder = Nothing
lbl_Exit:
    Exit Sub
End Sub

Sub RemoveOutlookFolder(olProcApp As Object)
    On Error Resume Next
    Set olNS = olProcApp.GetNamespace("MAPI")
    olNS.logon
    For Each iFolder In olNS.GetDefaultFolder(16).folders
        If iFolder.Name = strFolderName Then
            If iFolder.items.Count > 0 Then
                ShowMessage 22, True, strFolderName
                If frmMsg.Tag = 0 Then
                    Unload frmMsg
                    GoTo lbl_Exit
                Else
                    Unload frmMsg
                End If
            End If
            iFolder.Delete
            Exit For
        End If
    Next iFolder
    ShowMessage 21, False, strFolderName
lbl_Exit:
    Set olNS = Nothing
    Set iFolder = Nothing
    Exit Sub
End Sub

Private Sub SendNewMessages(ByVal oStore As Object, oFldr As Object, strTime As String)
    Set folders = oFldr.folders
    foldercount = folders.Count
    'Check if there are any folders below oFolder
    If foldercount Then
        For Each Folder In folders
            If Folder.Name = strFolderName Then
                If Folder.items.Count > 0 Then
                    For i = Folder.items.Count To 1 Step -1
                        Set olItem = Folder.items(i)
                        If Not strTime = vbNullString Then
                            olItem.DeferredDeliveryTime = CDate(strTime)
                        End If
                        olItem.to = Replace(olItem.to, "'", "")
                        olItem.Send
                        DoEvents
                    Next i
                End If
                Exit For
            End If
            SendNewMessages oStore, Folder, strTime
        Next Folder
    End If
lbl_Exit:
    Set folders = Nothing
    Set Folder = Nothing
    Set olItem = Nothing
    Exit Sub
End Sub

Sub SendMessages(olProcApp As Object)
Dim strTime As String
    Set olNS = olProcApp.GetNamespace("MAPI")
    strTime = vbNullString

    ShowMessage 55, True
    If frmMsg.Tag = 1 Then
        With frmDelay
            .Caption = "Delay Messages"
            RemoveCloseButton frmDelay
            .Show
            If .Tag = 1 Then
                strTime = .TextDate.Text & Chr(32) & .TextTime.Text
            End If
            Unload frmDelay
        End With
    End If
    Unload frmMsg

    Set colStores = olNS.Stores
    For Each oStore In colStores
        Set oRoot = oStore.getrootfolder
        SendNewMessages oStore, oRoot, strTime
    Next oStore

    ShowMessage 14, True
    If frmMsg.Tag = 1 Then
        Set olSycs = olNS.SyncObjects
        For i = 1 To olSycs.Count
            Set olSyc = olSycs.Item(i)
            olSyc.Start
            DoEvents
        Next
        'SendAllMessages
        Unload frmMsg
    End If

lbl_Exit:
    Set olNS = Nothing
    Set colStores = Nothing
    Set oRoot = Nothing
    Set oStore = Nothing
    Exit Sub
End Sub

Sub SendAllMessages(olProcApp)
    On Error GoTo lbl_Exit

    Set olNS = olProcApp.GetNamespace("MAPI")
    olNS.logon
    Set olSycs = olNS.SyncObjects
    Set olItems = olNS.GetDefaultFolder(4).items
    For i = olItems.Count To 1 Step -1
        Set olItem = olItems(i)
        olItem.Send
        DoEvents
    Next i
    For i = 1 To olSycs.Count
        Set olSyc = olSycs.Item(i)
        olSyc.Start
        DoEvents
    Next
lbl_Exit:
    Set olItems = Nothing
    Set olItem = Nothing
    Set olNS = Nothing
    Set olSycs = Nothing
    Set olSyc = Nothing
    Exit Sub
End Sub


Attribute VB_Name = "ModUtils"
Option Explicit

Function GetText(ByVal sFile As String) As String
Dim fso As Object
Dim ts As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set ts = fso.GetFile(sFile).OpenAsTextStream(1, -2)
    GetText = ts.ReadAll
    ts.Close
lbl_Exit:
    Exit Function
End Function

Function GetFolder() As String
Dim fd As FileDialog
Dim strFolder As String
    Set fd = Application.FileDialog(msoFileDialogFolderPicker)
    With fd
        .TITLE = "Select the folder into which the documents will be saved."
        If .Show = -1 Then
            strFolder = .SelectedItems(1) & "\"
        Else
            ShowMessage 13
            Set fd = Nothing
            strFolder = ""
        End If
    End With
    GetFolder = strFolder
lbl_Exit:
    Exit Function
End Function

Public Sub UpdateAllFields()
Dim oStory As Range
    For Each oStory In ActiveDocument.StoryRanges
        oStory.Fields.Update
        If oStory.StoryType <> wdMainTextStory Then
            While Not (oStory.NextStoryRange Is Nothing)
                Set oStory = oStory.NextStoryRange
                oStory.Fields.Update
            Wend
        End If
    Next oStory
    Set oStory = Nothing
lbl_Exit:
    Exit Sub
End Sub

Function UnlinkAllFields(oDoc As Document)
Dim oStory As Range
Dim oFld As Field
Dim vFld As Variant
Dim bFld As Boolean
Dim f As Long
Const strFld As String = "3,10,26,33,37,51,70,71,83,88"
    vFld = Split(strFld, ",")


    For Each oStory In oDoc.StoryRanges
        For Each oFld In oStory.Fields
            bFld = False
            For f = 0 To UBound(vFld)
                If oFld.Type = vFld(f) Then
                    bFld = True
                End If
            Next f
            If Not bFld Then oFld.Unlink
        Next oFld
        If oStory.StoryType <> wdMainTextStory Then
            While Not (oStory.NextStoryRange Is Nothing)
                Set oStory = oStory.NextStoryRange
                For Each oFld In oStory.Fields
                    bFld = False
                    For f = 0 To UBound(vFld)
                        If oFld.Type = vFld(f) Then
                            bFld = True
                        End If
                    Next f
                    If Not bFld Then oFld.Unlink
                Next oFld
            Wend
        End If
    Next oStory
    Set oStory = Nothing
lbl_Exit:
    Exit Function
End Function

Function isEmailInvalid(strAddress As String) As Boolean
Dim i As Long, j As Long, k As Long, m As Long
Dim vEmailAddress As Variant
Const strBanned As String = "(|)|,|:|;|<|>|@|[|]"
Dim strBannedInDomain As String
Dim vBannedInDomain As Variant
Dim vBanned As Variant
Dim strLocal As String
Dim strDomain As String
Dim bValidate As Boolean

    If GetSetting(AppID, "Config", "Validate e-mails") = "" Then
        SaveSetting AppID, "Config", "Validate e-mails", True
    End If
    bValidate = CBool(GetSetting(AppID, "Config", "Validate e-mails"))
    If Not bValidate Then
        isEmailInvalid = False
        Exit Function
    End If

    vBanned = Split(strBanned, "|")

    vEmailAddress = Split(strAddress, ";")
    For m = 0 To UBound(vEmailAddress)
        If Len(LTrim(vEmailAddress(m))) < 7 Or _
           Len(LTrim(vEmailAddress(m))) > 253 Then
            isEmailInvalid = True
            Exit Function
        End If
        If InStr(1, LTrim(vEmailAddress(m)), "@") = 0 Then
            isEmailInvalid = True
            Exit Function
        End If
        strLocal = Left(LTrim(vEmailAddress(m)), InStr(1, LTrim(vEmailAddress(m)), "@") - 1)
        strDomain = Right(LTrim(vEmailAddress(m)), Len(LTrim(vEmailAddress(m))) - Len(strLocal) - 1)

        'Check whole address
        If InStr(1, LTrim(vEmailAddress(m)), ".") = 0 Then
            isEmailInvalid = True
            Exit Function
        End If
        If InStr(1, LTrim(vEmailAddress(m)), "..") > 0 Then
            isEmailInvalid = True
            Exit Function
        End If
        If Left(LTrim(vEmailAddress(m)), 1) = "." Then
            isEmailInvalid = True
            Exit Function
        End If
        If Right(LTrim(vEmailAddress(m)), 1) = "." Then
            isEmailInvalid = True
            Exit Function
        End If
        i = InStr(1, LTrim(vEmailAddress(m)), "@") + 1
        If InStr(i, LTrim(vEmailAddress(m)), "@") > 0 And _
           InStr(i, LTrim(vEmailAddress(m)), "@") < 65 Then
            isEmailInvalid = True
            Exit Function
        End If

        'Check local string
        For j = 0 To UBound(vBanned)
            k = InStr(1, strLocal, vBanned(j))
            If k > 0 Then
                If Mid(strLocal, k - 1, 1) <> Chr(34) And _
                   Mid(strLocal, k + 1, 1) <> Chr(34) Then
                    isEmailInvalid = True
                    Exit For
                    Exit Function
                End If
            End If
        Next j
        k = InStr(1, strLocal, " ")
        If k > 0 Then
            If Mid(strLocal, k - 1, 1) <> "\" Then
                isEmailInvalid = True
                Exit Function
            End If
        End If
        k = InStr(1, strLocal, "\")
        If k > 0 Then
            If Mid(strLocal, k + 1, 1) <> "\" Then
                isEmailInvalid = True
                Exit Function
            End If
        End If
        k = InStr(1, strLocal, Chr(34))
        If k > 0 Then
            If Mid(strLocal, k - 1, 1) <> "\" Then
                isEmailInvalid = True
            End If
        End If

        'Check domain
        k = InStr(1, strDomain, " ")
        If k > 0 Then
            isEmailInvalid = True
            Exit Function
        End If
        k = InStr(1, strDomain, "|")
        If k > 0 Then
            isEmailInvalid = True
            Exit Function
        End If

        strBannedInDomain = ""
        For j = 1 To Len(strDomain)
            strBannedInDomain = strBannedInDomain & Mid(strDomain, j, 1)
            If j < Len(strDomain) Then
                strBannedInDomain = strBannedInDomain & "|"
            End If
        Next j
        vBannedInDomain = Split(strBannedInDomain, "|")
        For j = 0 To UBound(vBannedInDomain)
            If Asc(vBannedInDomain(j)) < 46 And _
               Asc(vBannedInDomain(j)) > 122 Then
                isEmailInvalid = True
                Exit Function
            End If
            If Asc(vBannedInDomain(j)) > 57 And _
               Asc(vBannedInDomain(j)) < 65 Then
                isEmailInvalid = True
                Exit Function
            End If
            If Asc(vBannedInDomain(j)) > 90 And _
               Asc(vBannedInDomain(j)) < 97 Then
                isEmailInvalid = True
                Exit Function
            End If
        Next j
    Next m
lbl_Exit:
    Exit Function
End Function

Public Function MoveMessages(strSubject As String)
Dim iLast As Integer
Dim iM As Long
Dim bFoundDraft As Boolean
Dim iFolder As Object
Dim olMailItems As Object
Dim oMail As Object
Dim colStores As Object
Dim oStore As Object
Dim oRoot As Object

    On Error Resume Next
    bFoundDraft = False
    Set olApp = GetObject(, "Outlook.Application")
    If Err <> 0 Then
        Set olApp = CreateObject("Outlook.Application")
    End If

    Set olNS = olApp.GetNamespace("MAPI")
    olNS.logon

    'Identify the temporary folder to store the messages
    Set iFolder = olNS.GetDefaultFolder(16).folders(strFolderName)
    'Identify the saved messages
    Set olMailItems = olNS.GetDefaultFolder(16).items
    iLast = olMailItems.Count

    If iLast > 0 Then
        'there are messages so move the last one to ifolder
        For iM = 1 To iLast        ' so check all the messages
            Set oMail = olMailItems(iM)
            If oMail.Subject = strSubject Then        'And oMail.To = strTo Then
                'if the subject matches, move it
                oMail.Move iFolder
                bFoundDraft = True
                Exit For        'and stop looking
            End If
        Next iM
        'The message is found so exit the function
        If bFoundDraft Then GoTo Cleanup
    End If

    'the message is not found so keep looking
    Set colStores = olNS.Stores
    For Each oStore In colStores
        'omit folders named 'archive'.
        If InStr(1, LCase(oStore.getrootfolder), "archive") = 0 Then
            'Ignore the default folder because we have already looked there
            If oStore.getrootfolder <> olNS.GetDefaultFolder(16).Parent Then
                Set oRoot = oStore.getrootfolder
                'see if there are messages in the Drafts folder of the current store
                Set olMailItems = oRoot.folders("Drafts").items
                iLast = olMailItems.Count
                If iLast > 0 Then        ' so check all the messages
                    For iM = 1 To iLast
                        Set oMail = olMailItems(iM)
                        'if a message matches the subject
                        If oMail.Subject = strSubject Then        'And oMail.To = strTo Then
                            oMail.Move iFolder        'move it
                            bFoundDraft = True
                            Exit For        'end stop looking
                        End If
                    Next iM
                    'message is found so we can stop looking
                    If bFoundDraft Then GoTo Cleanup
                End If
            End If
        End If
    Next oStore        'message is not found so look in the next store

Cleanup:
    Set oStore = Nothing
    Set colStores = Nothing
    Set oRoot = Nothing
    Set oMail = Nothing
    Set iFolder = Nothing
    Set olMailItems = Nothing
lbl_Exit:
    Exit Function
End Function


Public Sub ReplaceFields(oDoc As Document)
Dim oStory As Range
Dim oFld As Field
Dim i As Long
Dim mfCode As Range
    For Each oStory In oDoc.StoryRanges
        With oStory
            For Each oFld In oStory.Fields
                If oFld.Type = wdFieldMergeField Then
                    Set mfCode = oFld.Code
                    mfCode = Replace(UCase(mfCode), "MERGEFIELD", "DOCVARIABLE")
                End If
            Next oFld
        End With
        If oStory.StoryType <> wdMainTextStory Then
            While Not (oStory.NextStoryRange Is Nothing)
                Set oStory = oStory.NextStoryRange
                With oStory
                    For Each oFld In oStory.Fields
                        If oFld.Type = wdFieldMergeField Then
                            Set mfCode = oFld.Code
                            mfCode = Replace(UCase(mfCode), "MERGEFIELD", "DOCVARIABLE")
                        End If
                    Next oFld
                End With
            Wend
        End If
    Next oStory

lbl_Exit:
    Set oStory = Nothing
    Set oFld = Nothing
    Exit Sub
End Sub

Public Function FixChars(strText As Variant) As Variant
    strText = Replace(strText, Chr(34), Chr(95))
    strText = Replace(strText, Chr(42), Chr(95))
    strText = Replace(strText, Chr(44), Chr(95))
    strText = Replace(strText, Chr(46), Chr(95))
    strText = Replace(strText, Chr(47), Chr(95))
    strText = Replace(strText, Chr(58), Chr(95))
    strText = Replace(strText, Chr(60), Chr(95))
    strText = Replace(strText, Chr(62), Chr(95))
    strText = Replace(strText, Chr(63), Chr(95))
    strText = Replace(strText, Chr(64), Chr(95))
    strText = Replace(strText, Chr(124), Chr(95))
    FixChars = strText
lbl_Exit:
    Exit Function
End Function
Attribute VB_Name = "ModVersion"
Option Explicit

Function AppVer() As String
    AppVer = ThisDocument.Name
    AppVer = Right(AppVer, Len(AppVer) - InStr(AppVer, "Ver ") - 3)
    AppVer = Left(AppVer, Len(AppVer) - 5)
lbl_Exit:
    Exit Function
End Function

Function strFolderName() As String
strFolderName = "Merge Charts"
lbl_Exit:
    Exit Function
End Function


Function strDisclaimer(Optional bMaxey As Boolean) As String
    If bMaxey Then
        strDisclaimer = "The processes and features in the " & AppID & " add-in Version " & AppVer & _
                        " were developed and provided by Greg Maxey and Graham Mayor as a courtesy to the Microsoft Word user community." & vbCr & vbCr & _
                        "While exhaustive testing has been performed to ensure that each process is performed reliably " & _
                        "and without risk to the document structure or data, the developers makes no representations " & _
                        "or warranties of any kind, express or implied, about the completeness, accuracy, reliability, " & _
                        "suitability or availability with respect to the add-in or any of the processes that it is intended to perform. " & _
                        "Any reliance you place on the add-in or individual processes is therefore strictly at your own risk." & vbCr & vbCr & _
                        "In no event will the developers be liable for any loss or damage including without limitation, indirect " & _
                        "or consequential loss or damage, or any loss or damage whatsoever arising from loss of data or profits " & _
                        "arising out of, or in connection with, the use of this add-in." & vbCr & vbCr & _
                        "Through the GM Logo links you are directed to support and help information from which " & _
                        "you are able to link to other websites which are not under the developer's control. " & _
                        "The developers have no control over the nature, content and availability of those sites. " & _
                        "The inclusion of any links does not necessarily imply a recommendation or endorsement of the views " & _
                        "expressed within them." & vbCr & vbCr & _
                        "The developers are committed to reasonable effort to address user comments, " & _
                        "suggestions for improvement and technical assistance associated with the add-in. " & _
                        "However, the developers are not bound in any way to address those comments, suggestions for improvement, " & _
                        "or provide technical assistance."

    Else
        strDisclaimer = "The processes and features in the " & AppID & " add-in Version " & AppVer & _
                        " were developed and provided by Graham Mayor as a courtesy to the Microsoft Word user community." & vbCr & vbCr & _
                        "While exhaustive testing has been performed to ensure that each process is performed reliably " & _
                        "and without risk to the document structure or data, the developer makes no representations " & _
                        "or warranties of any kind, express or implied, about the completeness, accuracy, reliability, " & _
                        "suitability or availability with respect to the add-in or any of the processes that it is intended to perform. " & _
                        "Any reliance you place on the add-in or individual processes is therefore strictly at your own risk." & vbCr & vbCr & _
                        "In no event will the developer be liable for any loss or damage including without limitation, indirect " & _
                        "or consequential loss or damage, or any loss or damage whatsoever arising from loss of data or profits " & _
                        "arising out of, or in connection with, the use of this add-in." & vbCr & vbCr & _
                        "Through the GM Logo links you are directed to support and help information from which " & _
                        "you are able to link to other websites which are not under the developer's control. " & _
                        "The developer has no control over the nature, content and availability of those sites. " & _
                        "The inclusion of any links does not necessarily imply a recommendation or endorsement of the views " & _
                        "expressed within them." & vbCr & vbCr & _
                        "The developer is committed to reasonable effort to address user comments, " & _
                        "suggestions for improvement and technical assistance associated with the add-in.  " & _
                        "However, the developer is not bound in any way to address those comments, suggestions for improvement, " & _
                        "or provide technical assistance."
    End If
lbl_Exit:
    Exit Function
End Function

Sub UpdateTemplate()
Dim bBackup As Boolean
    bBackup = Options.CreateBackup
    Options.CreateBackup = False
    ThisDocument.Save
    Options.CreateBackup = bBackup
lbl_Exit:
    Exit Sub
End Sub


Attribute VB_Name = "OpenBrowser"
Option Explicit
Private pWebAddress As String
#If Win64 Then
    Public Declare PtrSafe Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As Long, _
                                                                                          ByVal lpOperation As String, ByVal lpFile As String, _
                                                                                          ByVal lpParameters As String, ByVal lpDirectory As String, _
                                                                                          ByVal nShowCmd As Long) As Long
#Else
    Public Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hwnd As Long, _
                                                                                  ByVal lpOperation As String, ByVal lpFile As String, _
                                                                                  ByVal lpParameters As String, ByVal lpDirectory As String, _
                                                                                  ByVal nShowCmd As Long) As Long
#End If

Public Sub NewShell(cmdLine As String, lngWindowHndl As Long)
    ShellExecute lngWindowHndl, "open", cmdLine, "", "", 1
lbl_Exit:
    Exit Sub
End Sub

Public Sub Info()
    pWebAddress = "http://www.gmayor.com/InsertAddress.htm"
    Call NewShell(pWebAddress, 3)
lbl_Exit:
    Exit Sub
End Sub

Public Sub DonateGB()
    pWebAddress = "https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=C22QAMXJVVZQ4"
    Call NewShell(pWebAddress, 3)
lbl_Exit:
    Exit Sub
End Sub

Public Sub DonateEU()
    pWebAddress = "https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=72JWWJEZX6KXS"
    Call NewShell(pWebAddress, 3)
lbl_Exit:
    Exit Sub
End Sub

Public Sub DonateUS()
    pWebAddress = "https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=HUS7FWLVVNTH4"
    Call NewShell(pWebAddress, 3)
lbl_Exit:
    Exit Sub
End Sub


Attribute VB_Name = "RibbonCommands"
Option Explicit

Sub GMChartMerge(control As IRibbonControl)
    Set olApp = OutlookApp()

    If Not GetSetting(AppID, "Config", "User") = Environ("USERNAME") Or _
       Not GetSetting(AppID, "Config", "Version") = AppVer Then
        ModResetRegistry.ResetRegistry True
    End If

    SaveSetting AppID, "Config", "User", Environ("USERNAME")
    SaveSetting AppID, "Config", "Version", AppVer

    If CBool(GetSetting(AppID, "Config", "Disclaimer", True)) = True Then
        frmDisclaimer.Show
    End If

    Select Case control.ID
        Case "GMChartMergeBtn1"
            ModMain.MergeCharts
        Case "GMChartMergeBtn2"
            ModSendMessages.SendMessages olApp
        Case "GMChartMergeBtn3"
            ModSendMessages.SendAllMessages olApp
        Case "GMChartMergeBtn4"
            ModSendMessages.RemoveOutlookFolder olApp
        Case "GMChartMergeBtn5": ModResetRegistry.ResetRegistry
    End Select
lbl_Exit:
    Exit Sub
End Sub



Attribute VB_Name = "Scratch"
Option Explicit
Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "0{00020906-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "clsProgressBar"
Attribute VB_Base = "0{014FF4A0-B2DD-4179-8ED4-0B8BB976465C}{E056809E-6646-42C1-9776-5D5AB488B042}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
'Module Name: clsProgressBar
'Module Type: UserForm Class
'Source: Adapated and expanded for Word by Gregory K. Maxey http://gregmaxey.com/word_tips.html, 2/9/2018
'from a similar class developed for Excel by Ejaz Ahmed, http://strugglingtoexcel.wordpress.com/

#If Win64 Then
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" ( _
        ByVal lpClassName As String, _
        ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" ( _
        ByVal hwnd As LongPtr, _
        ByVal nIndex As Long) As Long

Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" ( _
        ByVal hwnd As LongPtr, _
        ByVal nIndex As Long, _
        ByVal dwNewLong As Long) As Long

Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hwd As LongPtr) As Long
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
Private Declare Function FindWindow Lib "user32" Alias "FindWindowA" ( _
                                    ByVal lpClassName As String, _
                                    ByVal lpWindowName As String) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" ( _
                                       ByVal hwnd As Long, _
                                       ByVal nIndex As Long) As Long

Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" ( _
                                       ByVal hwnd As Long, _
                                       ByVal nIndex As Long, _
                                       ByVal dwNewLong As Long) As Long
Private Declare Function DrawMenuBar Lib "user32" (ByVal hwnd As Long) As Long
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If


Private m_strFormTitle As String    'Defines the userform caption
Private m_bAppStatusBar As Boolean    'Set True to use the application status bar in lieu of this class's form ojbect to show progress
Private m_lngTotalActions As Long    'Defines range (or number of of progress actions)
Private m_lngActionIndex As Long    'Defines the index 0 base of the current action
Private m_lngActionCounter As Long    'Defines the actual number count of the current action
Private m_strProgMsg As String    'Defines text displayed in form object status textbox
Private m_dblBarWidth As Double    'Initial width of the Progressbar control
Private m_strPercentComplete As String    'Defines text displayed in in form object perecent complete textbox
Private m_bFormShowing As Boolean    'Status of class form object
Private m_bTotalActionsSet As Boolean
Private m_bShowTitleBar As Boolean
'Color variables
Private m_lngBackColor As Long    'Class form object backcolor
Private m_lngFontColor As Long    'Class form object textbox controls forecolor
Private m_lngInitialColor As Long    'Class form object incrementing ProgressBar control initial backcolor
Private m_lngFinalColor As Long    'Class form object incrementing ProgressBar control final backcolor and ProgressBox border color
Private m_bChangeColors As Boolean    'Deterines if incrementing progress bar colors are used.
Private cInitialRed As Long, m_lngFinalRed As Long    'Red component of of initial and final incrementing color
Private cInitialGreen As Long, m_lngFinalGreen As Long    'Green component of of initial and final incrementing color
Private cInitialBlue As Long, m_lngFinalBlue As Long    'Blue component of of initial and final incrementing color

'Events
Private Sub UserForm_Initialize()
'Set variable default values.
    ShowTitleBar = "False"
    m_lngBackColor = &HE6FFFF   '13352870
    m_lngActionIndex = 0
    m_lngTotalActions = 0
    m_strProgMsg = "Processing ..."
    m_strFormTitle = "Progress Bar"
    m_bAppStatusBar = False
    m_bFormShowing = False
    m_bTotalActionsSet = False
    m_strPercentComplete = "0% Completed"
    'Use the property Let procedures to set initial and final incrementing color variables.
    InitialColor = &HE4F3E4    '10653569
    FinalColor = &HFF00&    '4073000
    m_lngFontColor = 6291584
    TITLE = m_strFormTitle
    With StatusMessageBox
        .Caption = " " & m_strProgMsg
        .ForeColor = m_lngFontColor
    End With
    With PercentIndicator
        .Caption = m_strPercentComplete
        .ForeColor = m_lngFontColor
    End With
lbl_Exit:
    Exit Sub
End Sub

Private Sub UserForm_Terminate()
    Application.StatusBar = vbNullString
    Application.ScreenUpdating = True
lbl_Exit:
    Exit Sub
End Sub

'Properties
Property Let TITLE(value As String)
    If Not value = vbNullString Then
        m_strFormTitle = value
        If Not Me Is Nothing Then
            DoEvents
            Caption = m_strFormTitle
        End If
    End If
End Property

Property Get TITLE() As String
    TITLE = m_strFormTitle
End Property

Property Get ShowTitleBar() As Boolean
    ShowTitleBar = m_bShowTitleBar
End Property

Property Let ShowTitleBar(value As Boolean)
    m_bShowTitleBar = value
End Property

Property Let ApplicationStatusBar(value As Boolean)
'Uses the application status bar to show progress in lieu of the this class's form object.
    If m_bFormShowing Then
        Err.Raise 1, m_strFormTitle, "Must be set prior to running the class Show method."
    Else
        m_bAppStatusBar = value
        If value Then Application.DisplayStatusBar = True
    End If
End Property

Property Get ApplicationStatusBar() As Boolean
    ApplicationStatusBar = m_bAppStatusBar
End Property

Property Let TotalActions(value As Long)
    If m_bTotalActionsSet Then
        Err.Raise 4, m_strFormTitle, "The TotalActions cannot be changed after it has been set."
    Else
        m_lngTotalActions = value
        m_bTotalActionsSet = True
    End If
End Property

Property Get TotalActions() As Long
    TotalActions = m_lngTotalActions
End Property

Property Let ActionIndex(value As Long)
    m_lngActionIndex = value
    UpdateDialog
End Property

Property Get ActionIndex() As Long
    ActionIndex = m_lngActionIndex
End Property

Property Get ActionCounter() As Long
    ActionCounter = m_lngActionIndex + 1
End Property

Property Let InitialColor(value As Long)
    If m_bFormShowing Then
        Err.Raise 1, m_strFormTitle, "InitialColor must be set prior to showing the form."
    Else
        m_lngInitialColor = value
        cInitialRed = GetPrimaryColor(m_lngInitialColor, "R")
        cInitialGreen = GetPrimaryColor(m_lngInitialColor, "G")
        cInitialBlue = GetPrimaryColor(m_lngInitialColor, "B")
    End If
End Property

Property Let FinalColor(value As Long)
    If m_bFormShowing Then
        Err.Raise 1, m_strFormTitle, "FinalColor must be set prior to showing the form."
    Else
        m_lngFinalColor = value
        m_lngFinalRed = GetPrimaryColor(m_lngFinalColor, "R")
        m_lngFinalGreen = GetPrimaryColor(m_lngFinalColor, "G")
        m_lngFinalBlue = GetPrimaryColor(m_lngFinalColor, "B")
        m_bChangeColors = Not CBool(m_lngInitialColor = m_lngFinalColor)
    End If
End Property

Property Let StatusMessage(value As String)
    m_strProgMsg = value
    UpdateDialog
End Property

Property Let ActionCounter(value As Long)
    m_lngActionCounter = value
End Property

Property Get StatusMessage() As String
    StatusMessage = m_strProgMsg
End Property

Property Let Background(value As Long)
    m_lngBackColor = value
End Property
Property Let FontColor(value As Long)
    m_lngFontColor = value
End Property

'Public Methods
Public Sub ShowBar()
    If m_bFormShowing Then
        Err.Raise 6, m_strFormTitle, "The Progress Bar has already been Loaded."
    Else
        DoEvents
        'Progress bar initial width
        m_dblBarWidth = ProgressBar.Width
        ProgressBar.Width = 0
        Caption = m_strFormTitle
        m_bFormShowing = True
        BackColor = m_lngBackColor
        ProgressBar.BackColor = m_lngInitialColor
        ProgressBox.BorderColor = m_lngInitialColor
        With PercentIndicator
            .ForeColor = m_lngFontColor
            .BackColor = m_lngBackColor
        End With
        With StatusMessageBox
            .ForeColor = m_lngFontColor
            .BackColor = m_lngBackColor
        End With
        If Not ShowTitleBar Then RemoveTitleBar
        Show
        Repaint
    End If
lbl_Exit:
    Exit Sub
End Sub

Public Sub StepBar(Optional ByVal ProgressMsg As String = vbNullString)
'Triggers display and progress update.
    m_lngActionIndex = m_lngActionIndex + 1
    If Not ProgressMsg = vbNullString Then
        m_strProgMsg = ProgressMsg
    End If
    UpdateDialog
lbl_Exit:
    Exit Sub
End Sub

Public Sub Complete(Optional ByVal Pause As Long = 0, _
                    Optional ByVal Prompt As String = "Processing Complete")
'Provides notification that process is complete and realease application statusbar.
Dim lngCounter As Long
    'Display an error message if the CurrentAction numeber is lesser than the number of TotalActions.
    If m_lngActionIndex < m_lngTotalActions Then
        Err.Raise 5, m_strFormTitle, "Premature call.  Run the Complete Method only after all the actions have been completed."
    Else
        'Release control over Application's status bar
        If m_bAppStatusBar Then Application.StatusBar = vbNullString
        If Pause > 0 Then
            For lngCounter = Pause To 1 Step -1
                DoEvents
                StatusMessageBox.Caption = " " & Prompt & _
                                           ". This dialog will auto-close in " & lngCounter & " " & IIf(lngCounter = 1, "second.", "seconds.")
                DoEvents
                Sleep 1000
            Next lngCounter
            Terminate
        Else
            DoEvents
            'Update the Status Message
            StatusMessageBox.Caption = Prompt
        End If
    End If
lbl_Exit:
    Exit Sub
End Sub

Public Sub Terminate()
    If m_bFormShowing Then
        Hide
        m_bFormShowing = False
        m_bTotalActionsSet = False
        m_lngActionIndex = 0
        m_lngTotalActions = 0
    End If
    'Return the Appliation StatusBar control to Application
    If m_bAppStatusBar Then Application.StatusBar = vbNullString
lbl_Exit:
    Exit Sub
End Sub

Private Sub UpdateDialog()
    If m_bTotalActionsSet Then
        If m_lngActionIndex > m_lngTotalActions Then
            Err.Raise 3, m_strFormTitle, "Current action index is greater than the defined action count."
        Else
            UpdateProgress
        End If
    Else
        Err.Raise 2, m_strFormTitle, "The TotalActions property has not been set."
    End If
lbl_Exit:
    Exit Sub
End Sub

Private Sub UpdateProgress()
Dim dblPercentComplete As Double
Dim dblBarWidth As Double

    dblPercentComplete = m_lngActionIndex / m_lngTotalActions
    dblBarWidth = m_dblBarWidth * dblPercentComplete
    m_strPercentComplete = Format(dblPercentComplete * 100, "0") & "% Completed"
    DoEvents
    ProgressBar.Width = dblBarWidth
    'Update the Percent Indicator
    PercentIndicator.Caption = m_strPercentComplete
    'Change the Color of the Progressbar if needed
    If m_bChangeColors Then
        ProgressBar.BackColor = RGB(cInitialRed + (m_lngFinalRed - cInitialRed) * dblPercentComplete, _
                                    cInitialGreen + (m_lngFinalGreen - cInitialGreen) * dblPercentComplete, _
                                    cInitialBlue + (m_lngFinalBlue - cInitialBlue) * dblPercentComplete)
    End If
    'Set the Status Bar Message
    StatusMessageBox.Caption = " " & m_strProgMsg
    'Update th application's status bar if applicable.
    If m_bAppStatusBar Then
        Application.StatusBar = fcnDevelopStatusBar(m_lngActionIndex, m_lngTotalActions) & _
                                " | " & m_strPercentComplete & " | " & m_strProgMsg
    End If
    'Repaint the form.
    Repaint
lbl_Exit:
    Exit Sub
End Sub

'Private Functions Needed by the form class
Private Function GetPrimaryColor(ByVal lngColor As Long, ByVal RGB As String) As Long
Dim strHex As String
    strHex = CStr(Hex(lngColor))
    'Prefix 0's so the string is always 8 Characters in length
    strHex = String(8 - Len(strHex), "0") & strHex
    Select Case StrConv(RGB, vbUpperCase)
        Case "R": strHex = "&H" & Mid(strHex, 7, 2)
        Case "G": strHex = "&H" & Mid(strHex, 5, 2)
        Case "B": strHex = "&H" & Mid(strHex, 3, 2)
        Case Else: strHex = "-100"
    End Select
    'The R, G, or Blue color component of the color passed (0 to 225).
    GetPrimaryColor = CLng(strHex)
lbl_Exit:
    Exit Function
End Function

Function fcnDevelopStatusBar(ByVal ActionIndex As Long, ByVal TotalActions As Long, _
                             Optional ByVal BarLength As Long = 15)
'Generate unicode characters and text to display on the application status bar.
Dim lngProcessed As Long, lngToProcess As Long
Dim strBarChar As String, strSpaceChar As String
    strBarChar = ChrW(&H2589)
    strSpaceChar = ChrW(&H2000)
    BarLength = Round(BarLength / 2, 0) * 2
    lngProcessed = Fix((ActionIndex * BarLength) / TotalActions)
    lngToProcess = BarLength - lngProcessed
    fcnDevelopStatusBar = String(lngProcessed, strBarChar) & String(lngToProcess, strSpaceChar)
lbl_Exit:
    Exit Function
End Function

Sub RemoveTitleBar()
Dim lStyle As Long
Dim hMenu As Long
Dim mhWndForm As Long
    mhWndForm = FindWindow("ThunderDFrame", Caption)
    lStyle = GetWindowLong(mhWndForm, -16)
    lStyle = lStyle And Not &HC00000
    SetWindowLong mhWndForm, -16, lStyle
    DrawMenuBar mhWndForm
    Height = Height - 24 + (Height - InsideHeight)    'Reduce the height of the form by the height of the title bar
lbl_Exit:
    Exit Sub
End Sub
Attribute VB_Name = "frmCharts"
Attribute VB_Base = "0{8C00853B-24E9-4454-9054-4718AAAFA383}{FCB55E98-1F32-4823-BDA6-06032D16036D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit
Private i As Long, k As Long
Private lCount As Long
Private lRecs As Long
Private bSel As Boolean

Private Sub CheckShow_Click()
    SaveSetting AppID, "Config", "Disclaimer", CheckDisclaimer.value
lbl_Exit:
    Exit Sub
End Sub

Private Sub btnAll_Click()
    With ListRecords
        For i = 0 To .ListCount - 1
            .Selected(i) = True
        Next i
    End With
lbl_Exit:
    Exit Sub
End Sub

Private Sub btnBrowse_Click()
    txtDocs.Text = BrowseForFolder("Select the folder to save the merged documents.")
    SaveSetting AppID, "Config", "Documents Folder", txtDocs.Text
lbl_Exit:
    Exit Sub
End Sub

Private Sub btnNone_Click()
    With ListRecords
        For i = 0 To .ListCount - 1
            .Selected(i) = False
        Next i
    End With
lbl_Exit:
    Exit Sub
End Sub

Private Sub CheckDisclaimer_Click()
    SaveSetting AppID, "Config", "Disclaimer", CheckDisclaimer.value
lbl_Exit:
    Exit Sub
End Sub

Private Sub CheckKeepList_Click()
    SaveSetting AppID, "Config", "Save Selection", CheckKeepList.value
lbl_Exit:
    Exit Sub
End Sub

Private Sub CheckPlain_Click()
    SaveSetting AppID, "Config", "Format", CheckPlain.value
lbl_Exit:
    Exit Sub
End Sub

Private Sub CheckSubject_Click()
    If CheckSubject.value = True Then
        cmbSubject.Enabled = True
        cmbSubject.BackColor = &H80000005
    Else
        cmbSubject.ListIndex = -1
        cmbSubject.Enabled = False
        cmbSubject.BackColor = &HE0E0E0
    End If
    CheckEnable
lbl_Exit:
    Exit Sub
End Sub

Private Sub cmbColumn_Change()
    With cmbColumn
        If .ListIndex > 0 Then SaveSetting AppID, "Config", "Column", .ListIndex
        If .ListIndex > 0 Then
            .BackColor = &H80000005
            xlFillList ListRecords, .ListIndex, GetSetting(AppID, "Config", "Workbook"), "MergeData"
        Else
            ListRecords.Clear
        End If
    End With
lbl_Exit:
    Exit Sub
End Sub

Private Sub cmbDestination_Change()
    If cmbDestination.Text = "Merge to Email Message" Then
        If Not IsAppRunning(Outlook) Then
            ShowMessage 19, True
            Hide
            Tag = 0
            Exit Sub
        Else
            If CheckFrame = True Then
                ShowMessage 29, True, , , True
                Select Case frmMsg.Tag
                    Case 0
                        cmbDestination.ListIndex = 0
                        cmbDestination.SetFocus
                        Unload frmMsg
                        GoTo lbl_Exit
                    Case 3
                        Unload frmMsg
                        Hide
                        Tag = 0
                        GoTo lbl_Exit
                    Case Else
                        Unload frmMsg
                End Select
            End If
        End If
    End If
    If cmbDestination.Text Like "*Email*" Then
        ShowMessage 57
    End If
    MultiPage1_Change
    CheckEnable
lbl_Exit:
    Exit Sub
End Sub

Private Sub cmbEmail_Change()
    With cmbEmail
        If .ListIndex > -1 Then
            txtEmailIndex.Text = CStr(.list(.ListIndex, 0))
            cmbEmail.BackColor = &H80000005
        Else
            cmbEmail.BackColor = &HC0C0FF
        End If
    End With
    CheckEnable

lbl_Exit:
    Exit Sub
End Sub
Private Sub CheckEnable()
Dim m As Integer
Dim bRecSel As Boolean
    cmdContinue.Enabled = False

    For m = 0 To ListRecords.ListCount - 1
        If ListRecords.Selected(m) = True Then
            bRecSel = True
            Exit For
        End If
    Next m

    Select Case cmbDestination.Text
        Case Is = "Merge to Email Message"
            If bRecSel = True And cmbEmail.ListIndex > -1 And txtSubject.BackColor <> &HC0C0FF Then
                cmdContinue.Enabled = True
            End If
        Case Is = "Merge to Email as Word Attachment", "Merge to Email as PDF Attachment"
            If cmbFileName.ListIndex > -1 And FolderExists(txtDocs.Text) = True Then
                If bRecSel = True And cmbEmail.ListIndex > -1 And txtSubject.BackColor <> &HC0C0FF Then
                    cmdContinue.Enabled = True
                End If
            End If
        Case "Merge to Individual Word Files", "Merge to Individual PDF Files"
            If bRecSel = True Then
                If cmbFileName.ListIndex > -1 And FolderExists(txtDocs.Text) = True Then
                    cmdContinue.Enabled = True
                End If
            End If
        Case "Merge to Printer"
            If bRecSel = True Then
                cmdContinue.Enabled = True
            End If
    End Select
lbl_Exit:
    Exit Sub
End Sub


Private Sub cmbFileName_Change()
Dim m As Integer, bListSel As Boolean
    With cmbFileName
        If .ListIndex > -1 Then
            txtFileNameIndex.Text = .list(.ListIndex, 0)
            .BackColor = &H80000005
        End If
    End With
    'SetUpForm cmbDestination.Text
    MultiPage1_Change
    CheckEnable
lbl_Exit:
    Exit Sub
End Sub

Private Sub cmbSubject_Change()
    If cmbSubject.ListIndex > -1 Then
        txtSubject.BackColor = &H80000005
    Else
        If txtSubject.Text = "" Then
            txtSubject.BackColor = &HC0C0FF
        Else
            txtSubject.BackColor = &H80000005
        End If
    End If
    CheckEnable
lbl_Exit:
    Exit Sub
End Sub

Private Sub CmdCancel_Click()
    Tag = 0
    Hide
lbl_Exit:
    Exit Sub
End Sub

Private Sub CmdContinue_Click()
    bSel = False
    strRecs = vbNullString
    With ListRecords
        For lCount = 0 To .ListCount - 1
            If .Selected(lCount) Then
                bSel = True
                strRecs = strRecs & CStr(lCount) & Chr(44)
            End If
        Next lCount
    End With
    SaveSetting AppID, "Config", "Selected Records", strRecs
    If Not bSel Then
        ShowMessage 25
        MultiPage1.value = 1
        cmbColumn.ListIndex = Val(GetSetting(AppID, "Config", "Column"))
        ListRecords.SetFocus
        Exit Sub
    End If
    SaveSetting AppID, "Config", "Message Text", txtMessage.Text
    SaveSetting AppID, "Config", "Selection Mode", OptExt.value

    Tag = 1
    Hide
lbl_Exit:
    Exit Sub
End Sub

Private Sub Help1_Click()
    Select Case cmbDestination.Text
        Case Is = "[Select Merge Destination]": ShowHelp 1
        Case Is = "Merge to Individual Word Files": ShowHelp 13
        Case Is = "Merge to Individual PDF Files": ShowHelp 14
        Case Is = "Merge to Printer": ShowHelp 15
        Case Is = "Merge to Email Message": ShowHelp 16
        Case Is = "Merge to Email as Word Attachment": ShowHelp 17
        Case Is = "Merge to Email as PDF Attachment": ShowHelp 18
    End Select
lbl_Exit:
    Exit Sub
End Sub

Private Sub Help11_Click()
    ShowHelp 11
lbl_Exit:
    Exit Sub
End Sub

Private Sub Help2_Click()
    ShowHelp 2
lbl_Exit:
    Exit Sub
End Sub

Private Sub Help7_Click()
    ShowHelp 7
lbl_Exit:
    Exit Sub
End Sub

Private Sub Help8_Click()
    ShowHelp 8
lbl_Exit:
    Exit Sub
End Sub

Private Sub Help9_Click()
    ShowHelp 9
lbl_Exit:
    Exit Sub
End Sub

Private Sub Image4_Click()
    Info
lbl_Exit:
    Exit Sub
End Sub

Private Sub Image6_Click()
    Info
lbl_Exit:
    Exit Sub
End Sub

Private Sub SetUpForm(ByVal strDestination As String)
    Select Case MultiPage1.value
        Case Is = 0
            Select Case strDestination
                Case Is = "Merge to Individual Word Files", _
                     "Merge to Individual PDF Files"
                    If Val(Application.Version) > 14 Then
                        Height = 300
                    Else
                        Height = 293
                    End If
                    MultiPage1.Pages(2).Visible = False
                    MultiPage1.Pages(1).Visible = False
                    If cmbFileName.ListIndex > -1 And _
                       txtDocs.Text <> "" Then
                        cmdContinue.Enabled = True
                    Else
                        cmdContinue.Enabled = False
                    End If
                    lblFileName.Visible = True
                    cmbFileName.Visible = True
                    Help8.Visible = True
                Case Is = "Merge to Email as Word Attachment", _
                     "Merge to Email as PDF Attachment"
                    If Val(Application.Version) > 14 Then
                        Height = 300
                    Else
                        Height = 293
                    End If
                    MultiPage1.Pages(2).Visible = True
                    lblFileName.Visible = True
                    cmbFileName.Visible = True
                    If cmbEmail.ListIndex > -1 And _
                       cmbFileName.ListIndex > -1 And _
                       txtDocs.Text <> "" Then
                        cmdContinue.Enabled = True
                    Else
                        cmdContinue.Enabled = False
                    End If
                    Help8.Visible = True
                Case Is = "Merge to Email Message"
                    If Val(Application.Version) > 14 Then
                        Height = 204
                    Else
                        Height = 197
                    End If
                    MultiPage1.Pages(2).Visible = True
                    lblFileName.Visible = False
                    cmbFileName.Visible = False
                    Help8.Visible = False
                    If cmbEmail.ListIndex > -1 Then
                        cmdContinue.Enabled = True
                    Else
                        cmdContinue.Enabled = False
                    End If
                Case Is = "Merge to Printer"
                    If Val(Application.Version) > 14 Then
                        Height = 204
                    Else
                        Height = 197
                    End If
                    MultiPage1.Pages(2).Visible = False
                    lblFileName.Visible = False
                    cmbFileName.Visible = False
                    cmdContinue.Enabled = True
                    Help8.Visible = False
                Case Is = "[Select Merge Destination]"
                    If Val(Application.Version) > 14 Then
                        Height = 204
                    Else
                        Height = 197
                    End If
                    MultiPage1.Pages(2).Visible = False
                    lblFileName.Visible = False
                    cmbFileName.Visible = False
                    cmdContinue.Enabled = False
                    Help8.Visible = False
            End Select
        Case 1
            If Val(Application.Version) > 14 Then
                Height = 486    '348
            Else
                Height = 479    '341
            End If
        Case 2
            If Val(Application.Version) > 14 Then
                Height = 486    '352
            Else
                Height = 479    '345
            End If
    End Select
    If Val(Application.Version) > 14 Then
        MultiPage1.Height = Height - 116
        Image5.Top = Height - 98
        Image6.Top = Height - 102
        CheckDisclaimer.Top = Height - 90
        cmdCancel.Top = Height - 62
        cmdContinue.Top = Height - 62
    Else
        MultiPage1.Height = Height - 114
        Image5.Top = Height - 91
        Image6.Top = Height - 95
        CheckDisclaimer.Top = Height - 83
        cmdCancel.Top = Height - 55
        cmdContinue.Top = Height - 55
    End If
    MultiPage1.Width = 282
    Top = 250

lbl_Exit:
    Exit Sub
End Sub

Private Sub ListRecords_Change()
    CheckEnable
lbl_Exit:
    Exit Sub
End Sub

Private Sub MultiPage1_Change()
    SetUpForm cmbDestination.Text
    Select Case MultiPage1.value
        Case Is = 0
            MultiPage1.Pages(2).Visible = False
            MultiPage1.Pages(1).Visible = False
            Select Case cmbDestination.Text
                Case Is = "[Select Merge Destination]"
                    MultiPage1.Pages(2).Visible = False
                    MultiPage1.Pages(1).Visible = False
                Case Is = "Merge to Individual Word Files", "Merge to Individual PDF Files"
                    If cmbFileName.ListIndex > -1 And _
                       FolderExists(txtDocs.Text) = True Then
                        MultiPage1.Pages(1).Visible = True
                    End If
                Case Is = "Merge to Printer"
                    MultiPage1.Pages(1).Visible = True
                Case Is = "Merge to Email Message"
                    MultiPage1.Pages(1).Visible = True
                    MultiPage1.Pages(2).Visible = True
                Case Is = "Merge to Email as Word Attachment", "Merge to Email as PDF Attachment"
                    If cmbFileName.ListIndex > -1 And _
                       FolderExists(txtDocs.Text) = True Then
                        MultiPage1.Pages(1).Visible = True
                        MultiPage1.Pages(2).Visible = True
                    End If
            End Select

        Case Is = 1
            If GetSetting(AppID, "Config", "Column") = "" Then SaveSetting AppID, "Config", "Column", 0

            If cmbColumn.ListCount > 0 Then
                cmbColumn.ListIndex = Val(GetSetting(AppID, "Config", "Column"))
            End If

            strRecs = GetSetting(AppID, "Config", "Selected Records")
            If GetSetting(AppID, "Config", "Save Selection") = vbNullString Then
                CheckKeepList.value = False
            Else
                CheckKeepList.value = CBool(GetSetting(AppID, "Config", "Save Selection"))
            End If

            If CheckKeepList.value = True Then
                vRecs = Split(strRecs, Chr(44))
                If ListRecords.ListCount > UBound(vRecs) - 1 Then
                    For iRec = 0 To UBound(vRecs) - 1
                        ListRecords.Selected(Val(vRecs(iRec))) = True
                    Next iRec
                End If
            Else
                For iRec = 0 To ListRecords.ListCount - 1
                    ListRecords.Selected(iRec) = False
                Next iRec
            End If

        Case Is = 2
            If CheckSubject.value = True Then
                cmbSubject.Enabled = True
                cmbSubject.BackColor = &H80000005
            Else
                cmbSubject.Enabled = False
                cmbSubject.BackColor = &HE0E0E0
            End If
            lblEmail.Visible = True
            lblSubject.Visible = True
            lblMsg.Visible = True
            cmbEmail.Visible = True
            txtSubject.Visible = True
            txtMessage.Visible = True
            If Val(Application.Version) > 14 Then
                If cmbDestination.Text = "Merge to Email Message" Then
                    Height = 402    '396
                    lblMsg.Visible = False
                    txtMessage.Visible = False
                    CheckPlain.Visible = False
                    FrameOptions.Top = 200
                Else
                    Height = 488
                    lblMsg.Visible = True
                    txtMessage.Visible = True
                    CheckPlain.Visible = True
                    FrameOptions.Top = 288
                    Help8.Visible = True
                End If
            Else
                If cmbDestination.Text = "Merge to Email Message" Then
                    Height = 393    '388
                    lblMsg.Visible = False
                    txtMessage.Visible = False
                    CheckPlain.Visible = False
                    FrameOptions.Top = 200
                Else
                    Height = 465
                    lblMsg.Visible = True
                    txtMessage.Visible = True
                    CheckPlain.Visible = True
                    FrameOptions.Top = 272
                End If
            End If
        Case Else
    End Select
    If Val(Application.Version) > 14 Then
        MultiPage1.Height = Height - 116
        Image5.Top = Height - 98
        Image6.Top = Height - 102
        CheckDisclaimer.Top = Height - 90
        cmdCancel.Top = Height - 62
        cmdContinue.Top = Height - 62
    Else
        MultiPage1.Height = Height - 114
        Image5.Top = Height - 91
        Image6.Top = Height - 95
        CheckDisclaimer.Top = Height - 83
        cmdCancel.Top = Height - 55
        cmdContinue.Top = Height - 55
    End If

lbl_Exit:
    Exit Sub
End Sub

Private Sub OptExt_Click()
    strRecs = vbNullString
    With ListRecords
        For lCount = 0 To .ListCount - 1
            If .Selected(lCount) Then
                bSel = True
                strRecs = strRecs & CStr(lCount) & Chr(44)
            End If
        Next lCount
    End With
    If OptInd.value = True Then
        ListRecords.MultiSelect = fmMultiSelectMulti
    Else
        ListRecords.MultiSelect = fmMultiSelectExtended
    End If
    vRecs = Split(strRecs, Chr(44))
    If ListRecords.ListCount > UBound(vRecs) - 1 Then
        For iRec = 0 To UBound(vRecs) - 1
            ListRecords.Selected(Val(vRecs(iRec))) = True
        Next iRec
    End If
lbl_Exit:
    Exit Sub
End Sub

Private Sub OptInd_Click()
    strRecs = vbNullString
    With ListRecords
        For lCount = 0 To .ListCount - 1
            If .Selected(lCount) Then
                bSel = True
                strRecs = strRecs & CStr(lCount) & Chr(44)
            End If
        Next lCount
    End With
    If OptInd.value = True Then
        ListRecords.MultiSelect = fmMultiSelectMulti
    Else
        ListRecords.MultiSelect = fmMultiSelectExtended
    End If
    vRecs = Split(strRecs, Chr(44))
    If ListRecords.ListCount > UBound(vRecs) - 1 Then
        For iRec = 0 To UBound(vRecs) - 1
            ListRecords.Selected(Val(vRecs(iRec))) = True
        Next iRec
    End If
lbl_Exit:
    Exit Sub
End Sub

Private Sub txtDocs_Change()
Dim m As Integer, bListSel As Boolean
    If FolderExists(txtDocs.Text) = True Then
        txtDocs.BackColor = &H80000005
    Else
        txtDocs.BackColor = &HC0C0FF
    End If
    MultiPage1_Change
    CheckEnable
lbl_Exit:
    Exit Sub
End Sub

Private Sub txtSubject_Change()
    If cmbSubject.ListIndex > -1 Then
        txtSubject.BackColor = &H80000005
    ElseIf txtSubject.Text <> "" Then
        txtSubject.BackColor = &H80000005
    Else
        txtSubject.BackColor = &HC0C0FF
    End If
    CheckEnable
lbl_Exit:
    Exit Sub
End Sub
Attribute VB_Name = "frmDatePicker"
Attribute VB_Base = "0{F393EA24-D91D-4B85-8E70-E187C4A0B5D6}{189635BF-9EE2-4707-9796-B7C0C02781D6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'   CalendarForm
'   Developed by Trevor Eyre
'   trevoreyre@gmail.com
'   v1.4 - 09.29.2014
'
'   This custom date picker can be used by importing the CalendarForm.frm file into
'   your VBA project. It is called exclusively through the GetDate function. For
'   instructions on how to call on the CalendarForm, skip to the GetDate function
'   documentation after the Global Variables section.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Overview
'
'The goal in creating this form was first and foremost to overcome the monstrosity that
'is the Microsoft MonthView control. If you're reading this, you probably already know
'what I'm talking about. Many others have been in my place and have come up with their
'own date pickers to solve this problem. So why yet another custom date picker?
'
'I was most interested in the following features:
'   -Ease of use. I wanted a completely self-contained form that could be imported into
'       any VBA project and used without any additional coding.
'   -Simple, attractive design. While a lot of custom date pickers on the internet look
'       good and work well, none of them quite nailed it for me in terms of style and
'       UI design.
'   -Fully customizable functionality and look. I tried to include as many of the
'       options from the MonthView control as I could, without getting too messy.
'
'Since none of the date pickers I have been able to find in all my searching have quite
'completed my checklist, here we are! Now my hope is that some other tired soul may
'also benefit from my labors.
'
'If you encounter any bugs, or have any great ideas or feature requests that could
'improve this bad boy, please send me an email.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Global Variables
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Option Explicit

'These two Enums are used in the GetDate function for the user to select the start day
'of the week, and the behavior of the week numbers. These are used in place of the
'Excel constants vbDayOfWeek and vbFirstWeekOfYear in order to avoid dealing with
'system time, which is an option in both of those. Otherwise the values are identical.
Public Enum calDayOfWeek
    Sunday = 1
    Monday = 2
    Tuesday = 3
    Wednesday = 4
    Thursday = 5
    Friday = 6
    Saturday = 7
End Enum

Public Enum calFirstWeekOfYear      'Controls how the week numbers are calculated and displayed
    FirstJan1 = 1                   'The week with January 1st is always counted as week 1
    FirstFourDays = 2               'The first week in January that has at least four days in it is
                                        'counted as week 1. This calculation will change depending
                                        'on the setting used for first day of the week. The ISO
                                        'standard is calculating week 1 as the first week in January
                                        'with four days with Monday being the first day of the week.
    FirstFullWeek = 3               'The first week in January with a full week is counted as week 1.
                                        'Like the FirstFourDays setting, this calculation will change
                                        'depending on the first day of the week used.
End Enum

Private UserformEventsEnabled As Boolean    'Controls userform events
Private DateOut As Date                     'The date returned from the CalendarForm
Private SelectedDateIn As Date              'The initial selected date, as well as the date currently selected by the
                                                'user if the Okay button is enabled
Private OkayEnabled As Boolean              'Stores whether Okay button is enabled
Private TodayEnabled As Boolean             'Stores whether Today button is enabled
Private MinDate As Date                     'Minimum date set by user
Private MaxDate As Date                     'Maximum date set by user
Private cmbYearMin As Long                  'Current lower bounds of year combobox. Not necessarily restricted to this min
Private cmbYearMax As Long                  'Current upper bounds of year combobox. Not necessarily restricted to this max
Private StartWeek As VbDayOfWeek            'First day of week in calendar
Private WeekOneOfYear As VbFirstWeekOfYear  'First week of year when setting week numbers
Private HoverControlName As String          'Name of the date label that is currently being hovered over. Used when returning
                                                'the hovered control to its original color
Private HoverControlColor As Long           'Original color of the date label that is currently being hovered over
Private RatioToResize As Double             'Ratio to resize elements of userform. This is set by the DateFontSize argument
                                                'in the GetDate function
Private bgDateColor As Long                 'Color of date label backgrounds
Private bgDateHoverColor As Long            'Color of date label backgrounds when hovering over
Private bgDateSelectedColor As Long         'Color of selected date label background
Private lblDateColor As Long                'Font color of date labels
Private lblDatePrevMonthColor As Long       'Font color of trailing month date labels
Private lblDateTodayColor As Long           'Font color of today's date
Private lblDateSatColor As Long             'Font color of Saturday date labels
Private lblDateSunColor As Long             'Font color of Sunday date labels


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GetDate
'
'This function is the point of entry into the CalendarForm. It controls EVERYTHING.
'Every argument is optional, meaning your function call can be as simple as:
'
'   MyDateVariable = CalendarForm.GetDate
'
'That's all there is to it. The calendar initializes, pops up, the user selects a date,
'the selection is received by your variable, and the calendar unloads.
'
'From there, you can use as many or as few arguments as you want in order to get the
'desired calendar that suits your needs. All default values are also set in this
'function, so if you want to change default colors or behavior without having to
'explicitly do so in every function call, you can set those in the argument list
'here.
'
'Below is a list of all arguments, their data type, and their function:
'
'   SelectedDate (Date) - This is the initial selected date on the calendar. Used to
'       show the users last selection. If this value is set, the calendar will
'       initialize to the month and year of the SelectedDate. If not, it will
'       initialize to today's date (with no selection).
'   FirstDayOfWeek (calDayOfWeek) - Sets which day to use as first day of the week.
'   MinimumDate (Date) - Restricts the selection of any dates below this date.
'   MaximumDate (Date) - Restricts the selection of any dates above this date.
'   RangeOfYears (Long) - Sets the range of years to show in the year combobox in
'       either direction from the initial SelectedDate. For example, if the
'       SelectedDate is in 2014, and the RangeOfYears is set to 10 (the default value),
'       the year combobox will show 10 years below 2014 to 10 years above 2014, so it
'       will have a range of 2004-2024. Note that if this range falls outside the bounds
'       set by the MinimumDate or MaximumDate, it will be overridden. Also, this
'       range does NOT limit the years that a user can select. If the upper limit of
'       the year combobox is 2024, and the user clicks the month spinner to surpass
'       December 2024, it will keep right on going to 2025 and beyond (and those
'       years will be added to the year combobox).
'   DateFontSize (Long) - Controls the size of the CalendarForm. This value cannot
'       be set below 9 (the default). To make the form bigger, set this value larger,
'       and everything else in the userform will be resized to fit.
'   TodayButton (Boolean) - Controls whether or not the Today button is visible.
'   OkayButton (Boolean) - Controls whether or not the Okay button is visible. If the
'       Okay button is enabled, when the user selects a date, it is highlighted, but
'       is not returned until they click Okay. If the Okay button is disabled,
'       clicking a date will automatically return that date and unload the form.
'   ShowWeekNumbers (Boolean) - Controls the visibility of the week numbers.
'   FirstWeekOfYear (calFirstWeekOfYear) - Sets the behavior of the week numbers. See
'       the calFirstWeekOfYear Enum in the Global Variables section to see the possible
'       values and their behavior.
'   PositionTop (Long) - Sets the top position of the CalendarForm. If no value is
'       assigned, the CalendarForm is set to position 1 - CenterOwner. Note that
'       PositionTop and PositionLeft must BOTH be set in order to override the default
'       center position.
'   PositionLeft (Long) - Sets the left position of the CalendarForm. If no value is
'       assigned, the CalendarForm is set to position 1 - CenterOwner. Note that
'       PositionTop and PositionLeft must BOTH be set in order to override the default
'       center position.
'   BackgroundColor (Long) - Sets the background color of the CalendarForm.
'   HeaderColor (Long) - Sets the background color of the header. The header is the
'       month and year label at the top.
'   HeaderFontColor (Long) - Sets the color of the header font.
'   SubHeaderColor (Long) - Sets the background color of the subheader. The subheader
'       is the day of week labels under the header (Su, Mo, Tu, etc).
'   DateColor (Long) - Sets the background color of the individual date labels.
'   DateFontColor (Long) - Sets the font color of the individual date labels.
'   SaturdayFontColor (Long) - Sets the font color of Saturday date labels.
'   SundayFontColor (Long) - Sets the font color of Sunday date labels.
'   DateBorder (Boolean) - Controls whether or not the date labels have borders.
'   DateBorderColor (Long) - Sets the color of the date label borders. Note that the
'       argument DateBorder must be set to True for this setting to take effect.
'   DateSpecialEffect (fmSpecialEffect) - Sets a special effect for the date labels.
'       This can be set to bump, etched, flat (default value), raised, or sunken.
'       This can be used to make the date labels look like buttons if you desire.
'       Note that this setting overrides any date border settings you have made.
'   DateHoverColor (Long) - Sets the background color when hovering the mouse over
'       a date label.
'   DateSelectedColor (Long) - Sets the background color of the selected date.
'   TrailingMonthFontColor (Long) - Sets the color of the date labels in trailing
'       months. Trailing months are the date labels from last month at the top of the
'       calendar and from next month at the bottom of the calendar.
'   TodayFontColor (Long) - Sets the font color of today's date.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function GetDate(Optional SelectedDate As Date, _
                        Optional FirstDayOfWeek As calDayOfWeek = Sunday, _
                        Optional MinimumDate As Date, _
                        Optional MaximumDate As Date, _
                        Optional RangeOfYears As Long = 10, _
                        Optional DateFontSize As Long = 9, _
                        Optional TodayButton As Boolean = False, Optional OkayButton As Boolean = False, _
                        Optional ShowWeekNumbers As Boolean = False, Optional FirstWeekOfYear As calFirstWeekOfYear = FirstJan1, _
                        Optional PositionTop As Long = -5, Optional PositionLeft As Long = -5, _
                        Optional BackgroundColor As Long = 16777215, _
                        Optional HeaderColor As Long = 15658734, _
                        Optional HeaderFontColor As Long = 0, _
                        Optional SubHeaderColor As Long = 16448250, _
                        Optional SubHeaderFontColor As Long = 8553090, _
                        Optional DateColor As Long = 16777215, _
                        Optional DateFontColor As Long = 0, _
                        Optional SaturdayFontColor As Long = 0, _
                        Optional SundayFontColor As Long = 0, _
                        Optional DateBorder As Boolean = False, Optional DateBorderColor As Long = 15658734, _
                        Optional DateSpecialEffect As fmSpecialEffect = fmSpecialEffectFlat, _
                        Optional DateHoverColor As Long = 15658734, _
                        Optional DateSelectedColor As Long = 14277081, _
                        Optional TrailingMonthFontColor As Long = 12566463, _
                        Optional TodayFontColor As Long = 15773696) As Date

Dim DefaultFontSize As Long        'Default font size (and minimum). Used to calculate RatioToResize
Dim TempDate As Date        'Used to set selected date, if none has been provided
Dim SelectedYear As Long        'Year of selected date
Dim SelectedMonth As Long        'Month of selected date
Dim SelectedDay As Long        'Day of seledcted date (if applicable)
Dim TempDayOfWeek As Long        'Used to set day labels in subheader
Dim i As Long        'Used for loops
Dim j As Long        'Used for loops

    UserformEventsEnabled = False
    DefaultFontSize = 9

    'Set MinDate and MaxDate. Year will be 1899 if no MinimumDate or MaximumDate
    'has been provided. In this case, set the MinDate to 1/1/1900 and the MaxDate
    'to 12/31/9999. If MaxDate is less than MinDate, it will default to the MinDate.
    If Year(MinimumDate) = 1899 Then
        MinDate = CDate("1/1/1900")
    ElseIf Year(MinimumDate) < 1900 Then
        MinDate = CDate("1/1/1900")
    Else
        MinDate = MinimumDate
    End If
    If Year(MaximumDate) = 1899 Then
        MaxDate = CDate("12/31/9999")
    Else
        MaxDate = MaximumDate
    End If
    If MaxDate < MinDate Then MaxDate = MinDate

    'Set Okay and Today buttons. If today's date falls outside min/max, then
    'Today button is disabled, regardless of setting
    OkayEnabled = OkayButton
    TodayEnabled = TodayButton
    If Date < MinDate Or Date > MaxDate Then TodayEnabled = False

    'Initialize userform position. Initial value of top and left is -5. Check
    'this value to see if a different value has been passed. If not, position
    'to CenterOwner. Must set both top and left positions to override center position
    If PositionTop <> -5 And PositionLeft <> -5 Then
        StartUpPosition = 0
        Top = PositionTop
        Left = PositionLeft
    Else
        StartUpPosition = 1
    End If

    'Initialize userform size. If font size is smaller than default font size, it
    'will revert to default. RatioToResize is the ratio of the new font size to the
    'default. This variable is used to resize all other elements of the userform.
    If DateFontSize < DefaultFontSize Then DateFontSize = DefaultFontSize
    RatioToResize = DateFontSize / DefaultFontSize
    Call SetUserformSize(DateFontSize, ShowWeekNumbers)

    'Set SelectedDateIn. Year will be 1899 if no date has been provided
    'in which case it will default to today's date. If selected date is
    'outside minimum or maximum date, it will be overridden
    If Year(SelectedDate) <> 1899 Then
        If SelectedDate < MinDate Then
            SelectedDate = MinDate
        ElseIf SelectedDate > MaxDate Then
            SelectedDate = MaxDate
        End If
        SelectedDateIn = SelectedDate
        SelectedYear = Year(SelectedDateIn)
        SelectedMonth = Month(SelectedDateIn)
        SelectedDay = Day(SelectedDateIn)
        Call SetSelectionLabel(SelectedDateIn)
    Else        'No SelectedDate provided, default to today's date
        cmdOkay.Enabled = False
        TempDate = Date
        If TempDate < MinDate Then
            TempDate = MinDate
        ElseIf TempDate > MaxDate Then
            TempDate = MaxDate
        End If
        SelectedYear = Year(TempDate)
        SelectedMonth = Month(TempDate)
        SelectedDay = 0        'Don't want to highlight a 'selected date,' since user supplied no date
        Call SetSelectionLabel(Empty)
    End If

    'Initialize month and year comboboxes, as well as month scroll bar. Make sure
    'years are within range of 1900 to 9999. If year combobox falls outside bounds
    'of MinDate and MaxDate, it will be overridden.
    Call SetMonthCombobox(SelectedYear, SelectedMonth)
    scrlMonth.value = SelectedMonth
    cmbYearMin = SelectedYear - RangeOfYears
    cmbYearMax = SelectedYear + RangeOfYears
    If cmbYearMin < Year(MinDate) Then
        cmbYearMin = Year(MinDate)
    End If
    If cmbYearMax > Year(MaxDate) Then
        cmbYearMax = Year(MaxDate)
    End If
    For i = cmbYearMin To cmbYearMax
        cmbYear.AddItem i
    Next i
    cmbYear.value = SelectedYear

    'Set userform colors and effects
    BackColor = BackgroundColor
    bgHeader.BackColor = HeaderColor
    bgScrollCover.BackColor = HeaderColor
    lblMonth.ForeColor = HeaderFontColor
    lblYear.ForeColor = HeaderFontColor
    lblSelection.ForeColor = SubHeaderFontColor
    lblSelectionDate.ForeColor = SubHeaderFontColor
    bgDayLabels.BackColor = SubHeaderColor
    For i = 1 To 7
        Me("lblDay" & CStr(i)).ForeColor = SubHeaderFontColor
    Next i
    If ShowWeekNumbers Then
        lblWk.ForeColor = SubHeaderFontColor
        For i = 1 To 6
            Me("lblWeek" & CStr(i)).ForeColor = SubHeaderFontColor
        Next i
    End If
    bgDateColor = DateColor
    lblDateColor = DateFontColor
    lblDateSatColor = SaturdayFontColor
    lblDateSunColor = SundayFontColor
    For i = 1 To 6
        For j = 1 To 7
            With Me("bgDate" & CStr(i) & CStr(j))
                If DateBorder Then
                    .BorderStyle = fmBorderStyleSingle
                    .BorderColor = DateBorderColor
                End If
                .SpecialEffect = DateSpecialEffect
            End With
        Next j
    Next i
    bgDateHoverColor = DateHoverColor
    bgDateSelectedColor = DateSelectedColor
    lblDatePrevMonthColor = TrailingMonthFontColor
    lblDateTodayColor = TodayFontColor

    'Initialize subheader day labels, based on selected first day of week
    StartWeek = FirstDayOfWeek
    WeekOneOfYear = FirstWeekOfYear
    TempDayOfWeek = StartWeek
    For i = 1 To 7
        Me("lblDay" & CStr(i)).Caption = Choose(TempDayOfWeek, "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
        TempDayOfWeek = TempDayOfWeek + 1
        If TempDayOfWeek = 8 Then TempDayOfWeek = 1
    Next i

    'Set month and year labels in header, as well as date labels
    Call SetMonthYear(SelectedMonth, SelectedYear)
    Call SetDays(SelectedMonth, SelectedYear, SelectedDay)

    'Show userform, return selected date, and unload
    UserformEventsEnabled = True
    RemoveCloseButton Me
    Show
    GetDate = DateOut
    Unload Me
lbl_Exit:
    Exit Function
End Function


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'cmdOkay_Click
'
'When the Okay button is clicked, DateOut is set, and the CalendarForm is hidden to
'return control to the GetDate function.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub cmdOkay_Click()
    DateOut = SelectedDateIn
    Hide
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'cmdToday_Click
'
'The functionality of the Today button changes depending on whether the Okay button is
'enabled or not. If the Okay button is enabled, clicking the Today button jumps to
'today's date and selects it.
'
'If the Okay button is disabled, clicking the Today button jumps to today's date, but
'nothing is selected.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub cmdToday_Click()
    Dim SelectedMonth As Long           'Month of selected date
    Dim SelectedYear As Long            'Year of selected date
    Dim SelectedDay As Long             'Day of selected date, if applicable
    Dim TodayDate As Date               'Today's date
    
    UserformEventsEnabled = False
    SelectedDay = 0
    TodayDate = Date
    
    'If Okay button is enabled, set SelectedDateIn, and the selection labels
    If OkayEnabled Then
        cmdOkay.Enabled = True
        SelectedDateIn = TodayDate
        Call SetSelectionLabel(TodayDate)
        SelectedDay = Day(TodayDate)
    End If
    
    'Get the month, day, and year, and set month scroll bar
    SelectedMonth = Month(TodayDate)
    SelectedYear = Year(TodayDate)
    SelectedDay = GetSelectedDay(SelectedMonth, SelectedYear)
    scrlMonth.value = SelectedMonth
    
    'Set month/year labels and date labels
    Call SetMonthYear(SelectedMonth, SelectedYear)
    Call SetDays(SelectedMonth, SelectedYear, SelectedDay)
    
    UserformEventsEnabled = True
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'UserForm_QueryClose
'
'I originally included this sub to override when the user cancelled the
'CalendarForm using the X button, in order to avoid receiving an invalid date value
'back from the userform (12/30/1899 12:00 am). This sub sets DateOut to currently
'selected Date, or to the initial SelectedDate passed to the GetDate function if user
'has not changed the selection, or the Okay button is not enabled.
'
'Note that it is still possible for the CalendarForm to return an invalid date value
'if no initial SelectedDate is set, the user does not make any selection, and then
'cancels the userform.
'
'I ended up removing the sub, because I like being able to detect if the user has
'cancelled the userform by testing the date from it. For instance, if user selects
'a date, but then changes their mind and cancels the userform, you wouldn't want to
'still return that date to your variable. You would want to revert to their previous
'selection, or do some error handling, if necessary.
'
'If you want the functionality described above, of returning the selected date or
'initial date if the user cancels, you can un-comment this sub.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
'    If CloseMode = 0 Then
'        Cancel = True
'        DateOut = SelectedDateIn
'        Me.Hide
'    End If
'End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'ClickControl
'
'This sub handles the event of clicking on one of the date label controls. Every date
'label has a click event which passes that label to this sub.
'
'If the Okay button is enabled, clicking a date selects that date, but does not return.
'If Okay button is disabled, clicking a date hides the userform and returns that date.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ClickControl(ctrl As control)
    Dim SelectedMonth As Long           'Month of selected date
    Dim SelectedYear As Long            'Year of selected date
    Dim SelectedDay As Long             'Day of selected date
    Dim SelectedDate As Date            'Date that the user has selected
    Dim RowIndex As Long                'Row index of the clicked date label
    Dim ColumnIndex As Long             'Column index of the clicked date label
    
    'Get selected day/year from scroll bar and combobox
    SelectedMonth = scrlMonth.value
    SelectedYear = cmbYear.value
    
    'Get indices of date label from label name and selected day from caption
    RowIndex = CLng(Left(Right(ctrl.Name, 2), 1))
    ColumnIndex = CLng(Right(ctrl.Name, 1))
    SelectedDay = CLng(ctrl.Caption)
    
    'Selection is from previous month. The largest day that could exist in
    'the first row from the current month is 6, so if the day is larger than
    'that, we know it came from the previous month, in which case we need
    'to decrement the selected month
    If RowIndex = 1 And SelectedDay > 7 Then
        SelectedMonth = SelectedMonth - 1
        'Handle January
        If SelectedMonth = 0 Then
            SelectedYear = SelectedYear - 1
            SelectedMonth = 12
        End If
    
    'Selection is from next month. The trailing dates from next month can
    'show up in rows 5 and 6. The smallest day that could exist in these rows
    'from the current month is about 23, so if the day is smaller than that,
    'we know it came from next month.
    ElseIf RowIndex >= 5 And SelectedDay < 20 Then
        SelectedMonth = SelectedMonth + 1
        'Handle December
        If SelectedMonth = 13 Then
            SelectedYear = SelectedYear + 1
            SelectedMonth = 1
        End If
    End If
    
    SelectedDate = DateSerial(SelectedYear, SelectedMonth, SelectedDay)
    
    'If Okay button is disabled, click will automatically hide form to return selected
    'date. If Okay button is enabled, click will select date, but will not return until
    'Okay is clicked
    If Not OkayEnabled Then
        DateOut = SelectedDate
        Hide
    Else
        UserformEventsEnabled = False
            cmdOkay.Enabled = True
            SelectedDateIn = SelectedDate
            scrlMonth.value = SelectedMonth
            Call SetSelectionLabel(SelectedDate)
            Call SetMonthYear(SelectedMonth, SelectedYear)
            Call SetDays(SelectedMonth, SelectedYear, SelectedDay)
        UserformEventsEnabled = True
    End If
lbl_Exit:
    Exit Sub
End Sub



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'HoverControl
'
'This sub handles the event of hovering over one of the date label controls. Every date
'label has a MouseMove event which passes that label to this sub.
'
'This sub returns the last hovered date label to its original color, sets the currently
'hovered date label to the bgDateHoverColor, and stores its name and original color
'to global variables.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HoverControl(ctrl As control)
    If HoverControlName <> vbNullString Then
        Controls(HoverControlName).BackColor = HoverControlColor
    End If
    HoverControlName = ctrl.Name
    HoverControlColor = ctrl.BackColor
    ctrl.BackColor = bgDateHoverColor
lbl_Exit:
    Exit Sub
End Sub



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'UserForm_MouseMove / bgDayLabels_MouseMove
'
'These two subs restore the last hovered date label to its original color when user is
'no longer hovering over any date labels.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
    If HoverControlName <> vbNullString Then
        Controls(HoverControlName).BackColor = HoverControlColor
    End If
lbl_Exit:
    Exit Sub
End Sub

Private Sub bgDayLabels_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
    If HoverControlName <> vbNullString Then
        Controls(HoverControlName).BackColor = HoverControlColor
    End If
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'lblMonth_Click / lblYear_Click
'
'The month and year labels in the header have invisible comboboxes behind them. These
'two subs show the combobox drop downs when you click on the labels.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub lblMonth_Click()
    cmbMonth.Dropdown
lbl_Exit:
    Exit Sub
End Sub

Private Sub lblYear_Click()
    cmbYear.Dropdown
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'cmbMonth_Change / cmbYear_Change
'
'The month and year comboboxes both call the cmbMonthYearChange sub when the user makes
'a selection. The year combobox also resets the month combobox, in case the user
'selects a year that is limited by a minimum or maximum date, to make sure the month
'combobox doesn't end up with selections that shouldn't be available.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub cmbMonth_Change()
    Call cmbMonthYearChange
lbl_Exit:
    Exit Sub
End Sub

Private Sub cmbYear_Change()
    If Not UserformEventsEnabled Then Exit Sub
    
    UserformEventsEnabled = False
    Call SetMonthCombobox(cmbYear.value, scrlMonth.value)
    UserformEventsEnabled = True
    
    Call cmbMonthYearChange
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'cmbMonthYearChange
'
'This sub handles the user making a selection from either the month or year combobox.
'It gets the selected month and year from the comboboxes, sets the value of the month
'scroll bar to match, and resets the calendar date labels.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub cmbMonthYearChange()
    Dim SelectedMonth As Long           'Month of selected date
    Dim SelectedYear As Long            'Year of selected date
    Dim SelectedDay As Long             'Day of selected date
    
    If Not UserformEventsEnabled Then Exit Sub
    UserformEventsEnabled = False
    
    'Get selected month and year. If the selected year has a minimum date set, then
    'the month combobox might not contain all the months of the year. In this case
    'the combobox index has to be offset by the month of the minimum date. No
    'calculation is necessary if the selected year has a maximum date set, because
    'the indices of the months in the combobox are still going to be the same in
    'either case.
    SelectedYear = cmbYear.value
    If SelectedYear = Year(MinDate) Then
        SelectedMonth = cmbMonth.ListIndex + Month(MinDate)
    Else
        SelectedMonth = cmbMonth.ListIndex + 1
    End If
    
    'Get selected day, set the value of the month scroll bar, and reset all
    'date labels on the userform
    SelectedDay = GetSelectedDay(SelectedMonth, SelectedYear)
    scrlMonth.value = SelectedMonth
    Call SetMonthYear(SelectedMonth, SelectedYear)
    Call SetDays(SelectedMonth, SelectedYear, SelectedDay)
    
    UserformEventsEnabled = True
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'scrlMonth_Change
'
'This sub handles the user clicking the scroll bar to increment or decrement the month.
'It checks to keep the month within the bounds set by the minimum or maximum date,
'and resets all the labels of the userform to the new month.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub scrlMonth_Change()
    Dim TempYear As Long        'Temporarily store selected year to test min and max dates
    Dim MinMonth As Long        'Sets lower limit of scroll bar
    Dim MaxMonth As Long        'Sets upper limit of scroll bar
    Dim SelectedMonth As Long   'Month of selected date
    Dim SelectedYear As Long    'Year of selected date
    Dim SelectedDay As Long     'Day of selected date
    
    If Not UserformEventsEnabled Then Exit Sub
    UserformEventsEnabled = False
    
    'Default lower and upper limit of scroll bar to allow full range of months
    MinMonth = 0
    MaxMonth = 13
    
    'If the current year is the min or max year, set min or max months
    TempYear = cmbYear.value
    If TempYear = Year(MinDate) Then MinMonth = Month(MinDate)
    If TempYear = Year(MaxDate) Then MaxMonth = Month(MaxDate)
    
    'Keep scroll bar within range of min and max dates
    If scrlMonth.value < MinMonth Then scrlMonth.value = scrlMonth.value + 1
    If scrlMonth.value > MaxMonth Then scrlMonth.value = scrlMonth.value - 1
    
    'If user goes down one month from January, scroll bar will have value of
    '0. In this case, reset scroll bar back to December and decrement year
    'by 1.
    If scrlMonth.value = 0 Then
        scrlMonth.value = 12
        cmbYear.value = cmbYear.value - 1
        'If new year is outside range of combobox, add it to combobox
        If cmbYear.value < cmbYearMin Then
            cmbYear.AddItem cmbYear.value, 0
            cmbYearMin = cmbYear.value
        End If
        Call SetMonthCombobox(cmbYear.value, scrlMonth.value)
    'If user goes up one month from December, scroll bar will have value of
    '13. Reset to January and increment year.
    ElseIf scrlMonth.value = 13 Then
        scrlMonth.value = 1
        cmbYear.value = cmbYear.value + 1
        'If new year is outside range of combobox, add it to combobox
        If cmbYear.value > cmbYearMax Then
            cmbYear.AddItem cmbYear.value, cmbYear.ListCount
            cmbYearMax = cmbYear.value
        End If
        Call SetMonthCombobox(cmbYear.value, scrlMonth.value)
    End If
    
    'Get selected month, year, and day, and reset all userform labels
    SelectedMonth = scrlMonth.value
    SelectedYear = cmbYear.value
    SelectedDay = GetSelectedDay(SelectedMonth, SelectedYear)
    Call SetMonthYear(SelectedMonth, SelectedYear)
    Call SetDays(SelectedMonth, SelectedYear, SelectedDay)
    
    UserformEventsEnabled = True
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'SetMonthCombobox
'
'This sub clears the list in the month combobox and resets it. This is done every time
'the month changes to make sure the months displayed in the combobox don't ever fall
'outside the bounds set by the minimum or maximum date.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SetMonthCombobox(YearIn As Long, MonthIn As Long)
    Dim YearMinDate As Long             'Year of the minimum date
    Dim YearMaxDate As Long             'Year of the maximum date
    Dim MonthMinDate As Long            'Month of the minimum date
    Dim MonthMaxDate As Long            'Month of the maximum date
    Dim i As Long                       'Used for looping
    
    'Get month and year of minimum and maximum dates and clear combobox
    YearMinDate = Year(MinDate)
    YearMaxDate = Year(MaxDate)
    MonthMinDate = Month(MinDate)
    MonthMaxDate = Month(MaxDate)
    cmbMonth.Clear

    'Both minimum and maximum dates occur in selected year
    If YearIn = YearMinDate And YearIn = YearMaxDate Then
        For i = MonthMinDate To MonthMaxDate
            cmbMonth.AddItem Choose(i, "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")
        Next i
        If MonthIn < MonthMinDate Then MonthIn = MonthMinDate
        If MonthIn > MonthMaxDate Then MonthIn = MonthMaxDate
        cmbMonth.ListIndex = MonthIn - MonthMinDate
    
    'Only minimum date occurs in selected year
    ElseIf YearIn = YearMinDate Then
        For i = MonthMinDate To 12
            cmbMonth.AddItem Choose(i, "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")
        Next i
        If MonthIn < MonthMinDate Then MonthIn = MonthMinDate
        cmbMonth.ListIndex = MonthIn - MonthMinDate
    
    'Only maximum date occurs in selected year
    ElseIf YearIn = YearMaxDate Then
        For i = 1 To MonthMaxDate
            cmbMonth.AddItem Choose(i, "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")
        Next i
        If MonthIn > MonthMaxDate Then MonthIn = MonthMaxDate
        cmbMonth.ListIndex = MonthIn - 1
    
    'No minimum or maximum date in selected year. Add all months to combobox
    Else
        cmbMonth.list = Array("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")
        cmbMonth.ListIndex = MonthIn - 1
    End If

lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'SetMonthYear
'
'This sub sets the month and year comboboxes to keep them in sync with any changes
'made to the selected month or year. It also sets the month and year labels in the
'header, and positions them in the center of the month scroll bar.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SetMonthYear(MonthIn As Long, YearIn As Long)
    Dim ExtraSpace As Double                'Space between month and year labels
    Dim CombinedLabelWidth As Double        'Combined width of both month and year labels
    
    ExtraSpace = 4 * RatioToResize
    
    'Set value of comboboxes
    If YearIn = Year(MinDate) Then
        cmbMonth.ListIndex = MonthIn - Month(MinDate)
    Else
        cmbMonth.ListIndex = MonthIn - 1
    End If
    cmbYear.value = YearIn
    
    'Set labels and position to center of scroll buttons. Labels are first
    'set to the width of the userform to avoid overflow, and then autosized
    'to fit to the text before being centered
    With lblMonth
        .AutoSize = False
        .Width = Width
        .Caption = cmbMonth.value
        .AutoSize = True
    End With
    With lblYear
        .AutoSize = False
        .Width = Width
        .Caption = cmbYear.value
        .AutoSize = True
    End With
    
    'Get combined width of labels and center to scroll bar
    CombinedLabelWidth = lblMonth.Width + lblYear.Width
    With lblMonth
        .Left = ((Width - 4 - CombinedLabelWidth) / 2) - (ExtraSpace / 2)
    End With
    With lblYear
        .Left = lblMonth.Left + lblMonth.Width + ExtraSpace
    End With
    
    'Reposition comboboxes to line up with labels
    cmbMonth.Left = lblMonth.Left - (cmbMonth.Width - lblMonth.Width) - ExtraSpace - 2
    cmbYear.Left = lblYear.Left
    
    'Clear hover control name, so labels in new month don't revert to
    'colors from previously selected month
    HoverControlName = vbNullString
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'SetDays
'
'This sub sets the caption, visibility, and colors of all the date labels on the
'userform, as well as the week number labels. If a selected day is passed to the
'sub, it will highlight that date accordingly. Otherwise, no selected date will be
'highlighted.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SetDays(MonthIn As Long, YearIn As Long, Optional DayIn As Long)
    Dim PrevMonth As Long               'Month preceding selected month. Used for trailing dates
    Dim NextMonth As Long               'Month following selected month. Used for trailing dates
    Dim Today As Date                   'Today's date
    Dim TodayDay As Long                'Day number of today's date
    Dim StartDayOfWeek  As Long         'Stores the weekday number of the first day in selected month
    Dim LastDayOfMonth As Long          'Last day of the month
    Dim LastDayOfPrevMonth As Long      'Last day of preceding month. Used for trailing dates
    Dim CurrentDay As Long              'Tracks current day in the month while setting labels
    Dim TempCurrentDay As Long          'Tracks the current day for previous month without incrementing actual CurrentDay
    Dim WeekNumber As Long              'Stores week number for week number labels
    Dim StartDayOfWeekDate As Date      'Stores first date in the week. Used to calculate week numbers
    Dim SaturdayIndex As Long           'Column index of Saturdays. Used to set color of Saturday labels, if applicable
    Dim SundayIndex As Long             'Column index of Sundays
    Dim MinDay As Long                  'Stores lower limit of days if minimum date falls in selected month
    Dim MaxDay As Long                  'Stores upper limit of days if maximum date falls in selected month
    Dim PrevMonthMinDay As Long         'Stores lower limit of days if minimum date falls in preceding month
    Dim NextMonthMaxDay As Long         'Stores upper limit of days if maximum date falls in next month
    Dim lblControl As control           'Stores current date label while changing settings
    Dim bgControl As control            'Stores current date label background while changing settings
    Dim i As Long                       'Used for looping
    Dim j As Long                       'Used for looping
    
    'Set min and max day, if applicable. If not, min and max day are set to 0 and 32,
    'respectively, since dates will never fall outside those bounds
    MinDay = 0
    MaxDay = 32
    If YearIn = Year(MinDate) And MonthIn = Month(MinDate) Then MinDay = Day(MinDate)
    If YearIn = Year(MaxDate) And MonthIn = Month(MaxDate) Then MaxDay = Day(MaxDate)
    
    'Find previous month and next month. Handle January
    'and December appropriately
    PrevMonth = MonthIn - 1
    If PrevMonth = 0 Then PrevMonth = 12
    NextMonth = MonthIn + 1
    If NextMonth = 13 Then NextMonth = 1
    
    'Set min and max days for previous month and next month, if applicable
    PrevMonthMinDay = 0
    NextMonthMaxDay = 32
    If YearIn = Year(MinDate) And PrevMonth = Month(MinDate) Then PrevMonthMinDay = Day(MinDate)
    If YearIn = Year(MaxDate) And NextMonth = Month(MaxDate) Then NextMonthMaxDay = Day(MaxDate)

    'Find last day of selected month and previous month. Find first weekday
    'in current month, and index of Saturday and Sunday relative to first weekday
    LastDayOfMonth = FindLastDayOfMonth(MonthIn, YearIn)
    LastDayOfPrevMonth = FindLastDayOfMonth(PrevMonth, YearIn)
    StartDayOfWeek = WeekDay(DateSerial(YearIn, MonthIn, 1), StartWeek)
    If StartWeek = 1 Then SundayIndex = 1 Else SundayIndex = 9 - StartWeek
    SaturdayIndex = 8 - StartWeek

    'If user is viewing current month/year, we want to highlight today's date. If
    'not, TodayDay is set to 0, since that value will never be encountered
    Today = Date
    If YearIn = Year(Today) And MonthIn = Month(Today) Then
        TodayDay = Day(Today)
    Else
        TodayDay = 0
    End If
    
    'Loop through all date labels and set captions and colors
    CurrentDay = 1
    For i = 1 To 6 'Rows
    
        'Set week number first, as it happens only once per row
        'Entire first row is last month
        If StartDayOfWeek = 1 And i = 1 Then
            'Calculate day number of first day in the week
            TempCurrentDay = CLng(LastDayOfPrevMonth - (StartDayOfWeek + 5))
            If PrevMonth <> 12 Then
                StartDayOfWeekDate = DateSerial(YearIn, PrevMonth, TempCurrentDay)
            Else
                StartDayOfWeekDate = DateSerial(YearIn - 1, PrevMonth, TempCurrentDay)
            End If
            
        'Previous month, but entire row is not last month. In this
        'case just use first of month. This is done because when using
        'the DatePart function to calculate week number, the last week
        'in December can be calculated incorrectly, so we want to default
        'to January 1st instead, which is always correct
        ElseIf i = 1 Then
            StartDayOfWeekDate = DateSerial(YearIn, MonthIn, 1)
        
        Else
            'Current month
            If CurrentDay <= LastDayOfMonth Then
                TempCurrentDay = CurrentDay
                StartDayOfWeekDate = DateSerial(YearIn, MonthIn, TempCurrentDay)
            
            'Next month
            Else
                TempCurrentDay = CLng(CurrentDay - LastDayOfMonth)
                If NextMonth <> 1 Then
                    StartDayOfWeekDate = DateSerial(YearIn, NextMonth, TempCurrentDay)
                Else
                    StartDayOfWeekDate = DateSerial(YearIn + 1, NextMonth, TempCurrentDay)
                End If
            End If
        End If
        WeekNumber = DatePart("ww", StartDayOfWeekDate, StartWeek, WeekOneOfYear)
        
        'Address DatePart function bug of sometimes incorrectly returning week 53
        'for last week in December when it should be week 1 of new year. If we get
        '53, but January 1st resides in the week we are calculating (any time the
        'first day of the week is greater than Dec 25th), we want to calculate based
        'off January 1st, instead of date in December.
        If WeekNumber > 52 And TempCurrentDay > 25 Then
            WeekNumber = DatePart("ww", DateSerial(YearIn + 1, 1, 1), StartWeek, WeekOneOfYear)
        End If
        Me("lblWeek" & CStr(i)).Caption = WeekNumber
        
        'Set date labels
        For j = 1 To 7 'Columns
            Set lblControl = Me("lblDate" & CStr(i) & CStr(j))
            Set bgControl = Me("bgDate" & CStr(i) & CStr(j))
            With lblControl
                
                'Previous month dates. If month starts on first day of week, entire
                'first row will be previous month
                If StartDayOfWeek = 1 And i = 1 Then
                    'If minimum date is in current month, then previous month shouldn't be visible
                    If MinDay <> 0 Then
                        .Visible = False
                        bgControl.Visible = False
                    Else
                        TempCurrentDay = CLng(LastDayOfPrevMonth - (StartDayOfWeek + 6 - j))
                        'Make sure previous month dates don't go beyond minimum date
                        If TempCurrentDay < PrevMonthMinDay Then
                            .Visible = False
                            bgControl.Visible = False
                        Else
                            .Visible = True
                            bgControl.Visible = True
                            .ForeColor = lblDatePrevMonthColor
                            .Caption = CStr(TempCurrentDay)
                            bgControl.BackColor = bgDateColor
                        End If
                    End If
                    
                'Previous month dates if month DOESN'T start on first day of week
                ElseIf i = 1 And j < StartDayOfWeek Then
                    'If minimum date is in current month, then previous month shouldn't be visible
                    If MinDay <> 0 Then
                        .Visible = False
                        bgControl.Visible = False
                    Else
                        TempCurrentDay = CLng(LastDayOfPrevMonth - (StartDayOfWeek - 1 - j))
                        'Make sure previous month dates don't go beyond minimum date
                        If TempCurrentDay < PrevMonthMinDay Then
                            .Visible = False
                            bgControl.Visible = False
                        Else
                            .Visible = True
                            .Enabled = True
                            bgControl.Visible = True
                            .ForeColor = lblDatePrevMonthColor
                            .Caption = CStr(TempCurrentDay)
                            bgControl.BackColor = bgDateColor
                        End If
                    End If

                'Next month dates
                ElseIf CurrentDay > LastDayOfMonth Then
                    'If maximum date is in current month, then next month shouldn't be visible
                    If MaxDay <> 32 Then
                        .Visible = False
                        bgControl.Visible = False
                    Else
                        TempCurrentDay = CLng(CurrentDay - LastDayOfMonth)
                        'Make sure next month dates don't go beyond maximum date
                        If TempCurrentDay > NextMonthMaxDay Then
                            .Visible = False
                            bgControl.Visible = False
                        Else
                            .Visible = True
                            .Enabled = True
                            bgControl.Visible = True
                            .ForeColor = lblDatePrevMonthColor
                            .Caption = CStr(TempCurrentDay)
                            bgControl.BackColor = bgDateColor
                        End If
                    End If
                    CurrentDay = CurrentDay + 1
                    
                'Current month dates
                Else
                    'Disable any dates outside bounds of minimum or maximum dates.
                    'Background of date label is set to invisible, so it doesn't
                    'hover, and the date label itself is disabled so it can't be clicked
                    If CurrentDay < MinDay Or CurrentDay > MaxDay Then
                        .Visible = True
                        .Enabled = False
                        bgControl.Visible = False
                    Else 'Within bounds. Enable and set colors
                        .Visible = True
                        .Enabled = True
                        bgControl.Visible = True
                        'Set text color
                        If CurrentDay = TodayDay Then
                            .ForeColor = lblDateTodayColor
                        ElseIf j = SaturdayIndex Then
                            .ForeColor = lblDateSatColor
                        ElseIf j = SundayIndex Then
                            .ForeColor = lblDateSunColor
                        Else
                            .ForeColor = lblDateColor
                        End If
                        
                        'Set background color
                        If CurrentDay = DayIn Then
                            bgControl.BackColor = bgDateSelectedColor
                        Else
                            bgControl.BackColor = bgDateColor
                        End If
                    End If
                    .Caption = CStr(CurrentDay)
                    CurrentDay = CurrentDay + 1
                End If
            End With
        Next j
    Next i
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'SetSelectionLabel
'
'This sub sets the caption and position of the labels that show the user's current
'selection if the Okay button is enabled.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SetSelectionLabel(DateIn As Date)
    Dim CombinedLabelWidth As Double        'Combined width of both labels, used to center
    Dim ExtraSpace As Double                'Space between the two labels
    
    ExtraSpace = 3 * RatioToResize
    
    'If there is no selected date set yet, the year of the date will be 1899. In
    'this case, selected date label should be null
    If Year(DateIn) = 1899 Then
        lblSelectionDate.Caption = vbNullString
        lblSelection.Left = Left + ((Width - 4 - lblSelection.Width) / 2)
    Else 'A selection has been made. Set caption and center
        With lblSelectionDate
            .AutoSize = False
            .Width = Width
            .Caption = Format(DateIn, "Short Date")
            .AutoSize = True
        End With
    
        CombinedLabelWidth = lblSelection.Width + lblSelectionDate.Width
        lblSelection.Left = ((Width - 4 - CombinedLabelWidth) / 2) - (ExtraSpace / 2)
        lblSelectionDate.Left = lblSelection.Left + lblSelection.Width + ExtraSpace
    End If
lbl_Exit:
    Exit Sub
End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GetSelectedDay
'
'This function checks the current month and year to see if they match the selected
'date. If so, it returns the day number of the selected date. If not, it returns 0.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function GetSelectedDay(MonthIn As Long, YearIn As Long) As Long
    GetSelectedDay = 0
    
    'Year will be 1899 if user has not provided, in which case selected day should be 0
    If Year(SelectedDateIn) <> 1899 Then
        If MonthIn = Month(SelectedDateIn) And YearIn = Year(SelectedDateIn) Then
            GetSelectedDay = Day(SelectedDateIn)
        End If
    End If
lbl_Exit:
    Exit Function
End Function


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'FindLastDayOfMonth
'
'This function returns the last day of the month passed to it. The year is used to
'check for leap years in February
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function FindLastDayOfMonth(MonthIn As Long, YearIn As Long) As Long
    FindLastDayOfMonth = Choose(MonthIn, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
    If YearIn Mod 4 = 0 And MonthIn = 2 Then FindLastDayOfMonth = 29
lbl_Exit:
    Exit Function
End Function


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'SetUserformSize
'
'This sub initializes the size and positions of every element on the userform.
'Everything is sized based on the RatioToResize variable. RatioToResize is calculated
'based on the ratio of the font size passed to the GetDate function to the default
'font size.
'
'The visibility of the Okay button, Today button, and week numbers is also set here.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SetUserformSize(SizeFont As Long, bWeekNumbers As Boolean)
    Dim BorderSpacing As Double                 'Padding between the outermost elements of userform and edge of userform
    Dim HeaderDefaultFontSize As Long           'Default font size of the header labels (month and year)
    Dim bgHeaderDefaultHeight As Double         'Default height of the background behind header labels
    Dim lblMonthYearDefaultHeight As Double     'Default height of the month and year header labels
    Dim scrlMonthDefaultHeight As Double        'Default height of the month scroll bar
    Dim bgDayLabelsDefaultHeight As Double      'Default height of the background behind the subheader day of week labels
    Dim bgDateDefaultHeight As Double           'Default height of the background behind each date label
    Dim bgDateDefaultWidth As Double            'Default width of the background behind each date label
    Dim lblDateDefaultHeight As Double          'Default height of each date label
    Dim cmdButtonDefaultHeight As Double        'Default height of Today and Okay command buttons
    Dim cmdButtonDefaultWidth As Double         'Default width of Today and Okay command buttons
    Dim cmdButtonsCombinedWidth As Double       'Combined width of Today and Okay buttons. Used to center on userform
    Dim cmdButtonsMaxHeight As Double           'Maximum height of command buttons and month scroll bar
    Dim cmdButtonsMaxWidth As Double            'Maximum width of command buttons
    Dim cmdButtonsMaxFontSize As Long           'Maximum font size of command buttons
    Dim bgControl As control                    'Stores current date label background in loop to initialize various settings
    Dim lblControl As control                   'Stores current date label in loop to initialize various settings
    Dim i As Long                               'Used for loops
    Dim j As Long                               'Used for loops
    
    'Initialize default values
    BorderSpacing = 6 * RatioToResize
    HeaderDefaultFontSize = 11
    bgHeaderDefaultHeight = 30
    lblMonthYearDefaultHeight = 13.5
    scrlMonthDefaultHeight = 18
    bgDayLabelsDefaultHeight = 18
    bgDateDefaultHeight = 18
    bgDateDefaultWidth = 18
    lblDateDefaultHeight = 10.5
    cmdButtonDefaultHeight = 24
    cmdButtonDefaultWidth = 60
    cmdButtonsMaxHeight = 36
    cmdButtonsMaxWidth = 90
    cmdButtonsMaxFontSize = 14
    
    'Size header elements - header background, month scroll bar, scroll cover (which is just
    'a blank label which sits on top of the month scroll bar to make it look like two spin
    'buttons), month/year labels in header, and the month and year comboboxes
    With bgHeader
        .Height = bgHeaderDefaultHeight * RatioToResize
        'The header width depends on whether week numbers are visible or not
        If bWeekNumbers Then
            .Width = 8 * (bgDateDefaultWidth * RatioToResize) + BorderSpacing
        Else
            .Width = 7 * (bgDateDefaultWidth * RatioToResize)
        End If
        .Left = BorderSpacing
        .Top = BorderSpacing
    End With
    'Month scroll bar. I set a maximum height for the scroll bar, because as it gets
    'larger, the width of the scroll buttons never increases, so eventually it ends
    'up looking really tall and skinny and weird.
    With scrlMonth
        .Width = bgHeader.Width - (2 * BorderSpacing)
        .Left = bgHeader.Left + BorderSpacing
        .Height = scrlMonthDefaultHeight * RatioToResize
        If .Height > cmdButtonsMaxHeight Then .Height = cmdButtonsMaxHeight
        .Top = bgHeader.Top + ((bgHeader.Height - .Height) / 2)
    End With
    'Cover over month scroll bar
    With bgScrollCover
        .Height = scrlMonth.Height
        .Width = scrlMonth.Width - 25 '25 is the width of the actual scroll buttons,
                                      'which need to remain visible
        .Left = scrlMonth.Left + 12.5
        .Top = scrlMonth.Top
    End With
    'The .left position of the month and year labels in the header will be set
    'in the function SetMonthYear, as it changes based on the selected month/year.
    'So only the top needs to be positioned now
    With lblMonth
        .AutoSize = False
        .Height = lblMonthYearDefaultHeight * RatioToResize
        .Font.Size = HeaderDefaultFontSize * RatioToResize
        .Top = bgScrollCover.Top + ((bgScrollCover.Height - .Height) / 2)
    End With
    With lblYear
        .AutoSize = False
        .Height = lblMonthYearDefaultHeight * RatioToResize
        .Font.Size = HeaderDefaultFontSize * RatioToResize
        .Top = bgScrollCover.Top + ((bgScrollCover.Height - .Height) / 2)
    End With
    cmbMonth.Top = lblMonth.Top + (lblMonth.Height - cmbMonth.Height)
    cmbYear.Top = lblYear.Top + (lblYear.Height - cmbYear.Height)

    'Size subheader elements - the subheader bacgkround (bgDayLabels), the day of
    'week labels themselves, and the week number subheader label, if applicable
    With bgDayLabels
        .Height = bgDayLabelsDefaultHeight * RatioToResize
        'The width depends on whether week numbers are visible or not
        If bWeekNumbers Then
            .Width = 8 * (bgDateDefaultWidth * RatioToResize) + BorderSpacing
        Else
            .Width = 7 * (bgDateDefaultWidth * RatioToResize)
        End If
        .Left = BorderSpacing
        .Top = bgHeader.Top + bgHeader.Height
    End With
    'Week number subheader label
    If Not bWeekNumbers Then
        lblWk.Visible = False
    Else
        With lblWk
            .AutoSize = False
            .Height = lblDateDefaultHeight * RatioToResize
            .Font.Size = SizeFont
            .Width = bgDateDefaultWidth * RatioToResize
            .Top = bgDayLabels.Top + ((bgDayLabels.Height - .Height) / 2)
            .Left = BorderSpacing
        End With
    End If
    'Day of week subheader labels
    For i = 1 To 7
        With Me("lblDay" & CStr(i))
            .AutoSize = False
            .Height = lblDateDefaultHeight * RatioToResize
            .Font.Size = SizeFont
            .Width = bgDateDefaultWidth * RatioToResize
            .Top = bgDayLabels.Top + ((bgDayLabels.Height - .Height) / 2)
            If i = 1 Then
                'Left position of first label depends on whether week numbers are visible
                If bWeekNumbers Then
                    .Left = lblWk.Left + lblWk.Width + BorderSpacing
                Else
                    .Left = BorderSpacing
                End If
            Else 'All other labels placed directly next to preceding label
                .Left = Me("lblDay" & CStr(i - 1)).Left + Me("lblDay" & CStr(i - 1)).Width
            End If
        End With
    Next i
    
    'Size all date labels and backgrounds
    For i = 1 To 6 'Rows
        'First set position and visibility of week number label
        If Not bWeekNumbers Then
            Me("lblWeek" & CStr(i)).Visible = False
        Else
            With Me("lblWeek" & CStr(i))
                .AutoSize = False
                .Height = lblDateDefaultHeight * RatioToResize
                .Font.Size = SizeFont
                .Width = bgDateDefaultWidth * RatioToResize
                .Left = BorderSpacing
                If i = 1 Then
                    .Top = bgDayLabels.Top + bgDayLabels.Height + (((bgDateDefaultHeight * RatioToResize) - .Height) / 2)
                Else
                    .Top = Me("bgDate" & CStr(i - 1) & "1").Top + Me("bgDate" & CStr(i - 1) & "1").Height + (((bgDateDefaultHeight * RatioToResize) - .Height) / 2)
                End If
            End With
        End If
        
        'Now set position of each date label in current row
        For j = 1 To 7
            Set bgControl = Me("bgDate" & CStr(i) & CStr(j))
            Set lblControl = Me("lblDate" & CStr(i) & CStr(j))
            'The date label background is sized and placed first. Then the actual date label is simply
            'set to the same position and centered vertically.
            With bgControl
                .Height = bgDateDefaultHeight * RatioToResize
                .Width = bgDateDefaultWidth * RatioToResize
                If j = 1 Then
                    'Left position of first label in row depends on whether week numbers are visible
                    If bWeekNumbers Then
                        .Left = Me("lblWeek" & CStr(i)).Left + Me("lblWeek" & CStr(i)).Width + BorderSpacing
                    Else
                        .Left = BorderSpacing
                    End If
                Else 'All other labels placed directly next to preceding label in row
                    .Left = Me("bgDate" & CStr(i) & CStr(j - 1)).Left + Me("bgDate" & CStr(i) & CStr(j - 1)).Width
                End If
                If i = 1 Then
                    .Top = bgDayLabels.Top + bgDayLabels.Height
                Else
                    .Top = Me("bgDate" & CStr(i - 1) & CStr(j)).Top + Me("bgDate" & CStr(i - 1) & CStr(j)).Height
                End If
            End With
            'Size and position actual date label
            With lblControl
                .AutoSize = False
                .Height = lblDateDefaultHeight * RatioToResize
                .Font.Size = SizeFont
                .Width = bgControl.Width
                .Left = bgControl.Left
                .Top = bgControl.Top + ((bgControl.Height - .Height) / 2)
            End With
        Next j
    Next i
    
    'Set userform width. Height set later, since it depends on Today and Okay buttons
    Width = bgDate67.Left + bgDate67.Width + 4 + BorderSpacing

    'Set size and visibility of Okay button and date selection labels
    If Not OkayEnabled Then
        cmdOkay.Visible = False
        lblSelection.Visible = False
        lblSelectionDate.Visible = False
    Else
        'Okay button. I set a maximum and width, for the same reason as the month
        'scroll bar. Eventually, the gigantic buttons just start looking weird.
        With cmdOkay
            .Visible = True
            .Height = cmdButtonDefaultHeight * RatioToResize
            If .Height > cmdButtonsMaxHeight Then .Height = cmdButtonsMaxHeight
            .Width = cmdButtonDefaultWidth * RatioToResize
            If .Width > cmdButtonsMaxWidth Then .Width = cmdButtonsMaxWidth
            If SizeFont > cmdButtonsMaxFontSize Then
                .Font.Size = cmdButtonsMaxFontSize
            Else
                .Font.Size = SizeFont
            End If
            .Top = bgDate61.Top + bgDate61.Height + bgDayLabels.Height + BorderSpacing
        End With
        'The "Selection" label
        With lblSelection
            .Visible = True
            .AutoSize = False
            .Height = lblMonthYearDefaultHeight * RatioToResize
            .Width = Width
            .Font.Size = HeaderDefaultFontSize * RatioToResize
            .AutoSize = True
            .Top = (bgDate61.Top + bgDate61.Height) + ((bgDayLabels.Height + BorderSpacing - .Height) / 2)
        End With
        'The actual selected date label
        With lblSelectionDate
            .Visible = True
            .AutoSize = False
            .Height = lblMonthYearDefaultHeight * RatioToResize
            .Width = Width - lblSelection.Width
            .Font.Size = HeaderDefaultFontSize * RatioToResize
            .Top = lblSelection.Top
        End With
    End If
    
    'Set size and visibility of Today button. Make sure it is within max bounds.
    'Top is not set for Today button yet, because it depends on whether Okay button
    'is enabled. Therefore, it is set farther down.
    If Not TodayEnabled Then
        cmdToday.Visible = False
    Else
        With cmdToday
            .Visible = True
            .Height = cmdButtonDefaultHeight * RatioToResize
            If .Height > cmdButtonsMaxHeight Then .Height = cmdButtonsMaxHeight
            .Width = cmdButtonDefaultWidth * RatioToResize
            If .Width > cmdButtonsMaxWidth Then .Width = cmdButtonsMaxWidth
            If SizeFont > cmdButtonsMaxFontSize Then
                .Font.Size = cmdButtonsMaxFontSize
            Else
                .Font.Size = SizeFont
            End If
        End With
    End If
    
    'Position Okay and Today buttons, depending on which ones are enabled
    If OkayEnabled And TodayEnabled Then 'Both buttons enabled.
        cmdToday.Top = cmdOkay.Top
        cmdButtonsCombinedWidth = cmdToday.Width + cmdOkay.Width
        cmdToday.Left = ((Width - 4 - cmdButtonsCombinedWidth) / 2) - (BorderSpacing / 2)
        cmdOkay.Left = cmdToday.Left + cmdToday.Width + BorderSpacing
    ElseIf OkayEnabled Then 'Only Okay button enabled
        cmdOkay.Left = (Width - 4 - cmdOkay.Width) / 2
    ElseIf TodayEnabled Then 'Only Today button enabled
        cmdToday.Top = bgDate61.Top + bgDate61.Height + BorderSpacing
        cmdToday.Left = (Width - 4 - cmdToday.Width) / 2
    End If
    
    'Set userform height, depending on which buttons are enabled
    If OkayEnabled Then
        Height = cmdOkay.Top + cmdOkay.Height + 21 + BorderSpacing
    ElseIf TodayEnabled Then 'Only Today button enabled
        Height = cmdToday.Top + cmdToday.Height + 21 + BorderSpacing
    Else 'Neither button enabled
        Height = bgDate61.Top + bgDate61.Height + 21 + BorderSpacing
    End If
    'Added GSM
    If Val(Application.Version) > 14 Then
        Height = Height + 7
        Width = Width + 7
    End If

lbl_Exit:
    Exit Sub
End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'The following subs all call the ClickControl sub, passing the date label that has been
'clicked. It could have saved some lines of code to create a class module which handled
'the functionality of hovering and clicking on the different controls, then simply
'declaring each date label as an object of that class. However, that would have
'necessitated the inclusion of another module in order to make the CalendarForm function
'properly. Since the main goal of this project was to have this userform be completely
'self-contained, I opted for this route.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'User clicked on the background of the date label
Private Sub bgDate11_Click(): ClickControl lblDate11: End Sub
Private Sub bgDate12_Click(): ClickControl lblDate12: End Sub
Private Sub bgDate13_Click(): ClickControl lblDate13: End Sub
Private Sub bgDate14_Click(): ClickControl lblDate14: End Sub
Private Sub bgDate15_Click(): ClickControl lblDate15: End Sub
Private Sub bgDate16_Click(): ClickControl lblDate16: End Sub
Private Sub bgDate17_Click(): ClickControl lblDate17: End Sub
Private Sub bgDate21_Click(): ClickControl lblDate21: End Sub
Private Sub bgDate22_Click(): ClickControl lblDate22: End Sub
Private Sub bgDate23_Click(): ClickControl lblDate23: End Sub
Private Sub bgDate24_Click(): ClickControl lblDate24: End Sub
Private Sub bgDate25_Click(): ClickControl lblDate25: End Sub
Private Sub bgDate26_Click(): ClickControl lblDate26: End Sub
Private Sub bgDate27_Click(): ClickControl lblDate27: End Sub
Private Sub bgDate31_Click(): ClickControl lblDate31: End Sub
Private Sub bgDate32_Click(): ClickControl lblDate32: End Sub
Private Sub bgDate33_Click(): ClickControl lblDate33: End Sub
Private Sub bgDate34_Click(): ClickControl lblDate34: End Sub
Private Sub bgDate35_Click(): ClickControl lblDate35: End Sub
Private Sub bgDate36_Click(): ClickControl lblDate36: End Sub
Private Sub bgDate37_Click(): ClickControl lblDate37: End Sub
Private Sub bgDate41_Click(): ClickControl lblDate41: End Sub
Private Sub bgDate42_Click(): ClickControl lblDate42: End Sub
Private Sub bgDate43_Click(): ClickControl lblDate43: End Sub
Private Sub bgDate44_Click(): ClickControl lblDate44: End Sub
Private Sub bgDate45_Click(): ClickControl lblDate45: End Sub
Private Sub bgDate46_Click(): ClickControl lblDate46: End Sub
Private Sub bgDate47_Click(): ClickControl lblDate47: End Sub
Private Sub bgDate51_Click(): ClickControl lblDate51: End Sub
Private Sub bgDate52_Click(): ClickControl lblDate52: End Sub
Private Sub bgDate53_Click(): ClickControl lblDate53: End Sub
Private Sub bgDate54_Click(): ClickControl lblDate54: End Sub
Private Sub bgDate55_Click(): ClickControl lblDate55: End Sub
Private Sub bgDate56_Click(): ClickControl lblDate56: End Sub
Private Sub bgDate57_Click(): ClickControl lblDate57: End Sub
Private Sub bgDate61_Click(): ClickControl lblDate61: End Sub
Private Sub bgDate62_Click(): ClickControl lblDate62: End Sub
Private Sub bgDate63_Click(): ClickControl lblDate63: End Sub
Private Sub bgDate64_Click(): ClickControl lblDate64: End Sub
Private Sub bgDate65_Click(): ClickControl lblDate65: End Sub
Private Sub bgDate66_Click(): ClickControl lblDate66: End Sub
Private Sub bgDate67_Click(): ClickControl lblDate67: End Sub
'User clicked on the actual date label itself
Private Sub lblDate11_Click(): ClickControl lblDate11: End Sub
Private Sub lblDate12_Click(): ClickControl lblDate12: End Sub
Private Sub lblDate13_Click(): ClickControl lblDate13: End Sub
Private Sub lblDate14_Click(): ClickControl lblDate14: End Sub
Private Sub lblDate15_Click(): ClickControl lblDate15: End Sub
Private Sub lblDate16_Click(): ClickControl lblDate16: End Sub
Private Sub lblDate17_Click(): ClickControl lblDate17: End Sub
Private Sub lblDate21_Click(): ClickControl lblDate21: End Sub
Private Sub lblDate22_Click(): ClickControl lblDate22: End Sub
Private Sub lblDate23_Click(): ClickControl lblDate23: End Sub
Private Sub lblDate24_Click(): ClickControl lblDate24: End Sub
Private Sub lblDate25_Click(): ClickControl lblDate25: End Sub
Private Sub lblDate26_Click(): ClickControl lblDate26: End Sub
Private Sub lblDate27_Click(): ClickControl lblDate27: End Sub
Private Sub lblDate31_Click(): ClickControl lblDate31: End Sub
Private Sub lblDate32_Click(): ClickControl lblDate32: End Sub
Private Sub lblDate33_Click(): ClickControl lblDate33: End Sub
Private Sub lblDate34_Click(): ClickControl lblDate34: End Sub
Private Sub lblDate35_Click(): ClickControl lblDate35: End Sub
Private Sub lblDate36_Click(): ClickControl lblDate36: End Sub
Private Sub lblDate37_Click(): ClickControl lblDate37: End Sub
Private Sub lblDate41_Click(): ClickControl lblDate41: End Sub
Private Sub lblDate42_Click(): ClickControl lblDate42: End Sub
Private Sub lblDate43_Click(): ClickControl lblDate43: End Sub
Private Sub lblDate44_Click(): ClickControl lblDate44: End Sub
Private Sub lblDate45_Click(): ClickControl lblDate45: End Sub
Private Sub lblDate46_Click(): ClickControl lblDate46: End Sub
Private Sub lblDate47_Click(): ClickControl lblDate47: End Sub
Private Sub lblDate51_Click(): ClickControl lblDate51: End Sub
Private Sub lblDate52_Click(): ClickControl lblDate52: End Sub
Private Sub lblDate53_Click(): ClickControl lblDate53: End Sub
Private Sub lblDate54_Click(): ClickControl lblDate54: End Sub
Private Sub lblDate55_Click(): ClickControl lblDate55: End Sub
Private Sub lblDate56_Click(): ClickControl lblDate56: End Sub
Private Sub lblDate57_Click(): ClickControl lblDate57: End Sub
Private Sub lblDate61_Click(): ClickControl lblDate61: End Sub
Private Sub lblDate62_Click(): ClickControl lblDate62: End Sub
Private Sub lblDate63_Click(): ClickControl lblDate63: End Sub
Private Sub lblDate64_Click(): ClickControl lblDate64: End Sub
Private Sub lblDate65_Click(): ClickControl lblDate65: End Sub
Private Sub lblDate66_Click(): ClickControl lblDate66: End Sub
Private Sub lblDate67_Click(): ClickControl lblDate67: End Sub


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'The following subs all call the HoverControl sub, passing the background of the date
'label that has been hovered over.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'User hovered over the date background
Private Sub bgDate11_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate11: End Sub
Private Sub bgDate12_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate12: End Sub
Private Sub bgDate13_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate13: End Sub
Private Sub bgDate14_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate14: End Sub
Private Sub bgDate15_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate15: End Sub
Private Sub bgDate16_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate16: End Sub
Private Sub bgDate17_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate17: End Sub
Private Sub bgDate21_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate21: End Sub
Private Sub bgDate22_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate22: End Sub
Private Sub bgDate23_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate23: End Sub
Private Sub bgDate24_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate24: End Sub
Private Sub bgDate25_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate25: End Sub
Private Sub bgDate26_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate26: End Sub
Private Sub bgDate27_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate27: End Sub
Private Sub bgDate31_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate31: End Sub
Private Sub bgDate32_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate32: End Sub
Private Sub bgDate33_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate33: End Sub
Private Sub bgDate34_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate34: End Sub
Private Sub bgDate35_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate35: End Sub
Private Sub bgDate36_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate36: End Sub
Private Sub bgDate37_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate37: End Sub
Private Sub bgDate41_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate41: End Sub
Private Sub bgDate42_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate42: End Sub
Private Sub bgDate43_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate43: End Sub
Private Sub bgDate44_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate44: End Sub
Private Sub bgDate45_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate45: End Sub
Private Sub bgDate46_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate46: End Sub
Private Sub bgDate47_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate47: End Sub
Private Sub bgDate51_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate51: End Sub
Private Sub bgDate52_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate52: End Sub
Private Sub bgDate53_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate53: End Sub
Private Sub bgDate54_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate54: End Sub
Private Sub bgDate55_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate55: End Sub
Private Sub bgDate56_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate56: End Sub
Private Sub bgDate57_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate57: End Sub
Private Sub bgDate61_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate61: End Sub
Private Sub bgDate62_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate62: End Sub
Private Sub bgDate63_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate63: End Sub
Private Sub bgDate64_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate64: End Sub
Private Sub bgDate65_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate65: End Sub
Private Sub bgDate66_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate66: End Sub
Private Sub bgDate67_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate67: End Sub
'User hovered over the actual date label
Private Sub lblDate11_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate11: End Sub
Private Sub lblDate12_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate12: End Sub
Private Sub lblDate13_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate13: End Sub
Private Sub lblDate14_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate14: End Sub
Private Sub lblDate15_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate15: End Sub
Private Sub lblDate16_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate16: End Sub
Private Sub lblDate17_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate17: End Sub
Private Sub lblDate21_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate21: End Sub
Private Sub lblDate22_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate22: End Sub
Private Sub lblDate23_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate23: End Sub
Private Sub lblDate24_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate24: End Sub
Private Sub lblDate25_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate25: End Sub
Private Sub lblDate26_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate26: End Sub
Private Sub lblDate27_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate27: End Sub
Private Sub lblDate31_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate31: End Sub
Private Sub lblDate32_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate32: End Sub
Private Sub lblDate33_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate33: End Sub
Private Sub lblDate34_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate34: End Sub
Private Sub lblDate35_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate35: End Sub
Private Sub lblDate36_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate36: End Sub
Private Sub lblDate37_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate37: End Sub
Private Sub lblDate41_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate41: End Sub
Private Sub lblDate42_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate42: End Sub
Private Sub lblDate43_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate43: End Sub
Private Sub lblDate44_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate44: End Sub
Private Sub lblDate45_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate45: End Sub
Private Sub lblDate46_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate46: End Sub
Private Sub lblDate47_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate47: End Sub
Private Sub lblDate51_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate51: End Sub
Private Sub lblDate52_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate52: End Sub
Private Sub lblDate53_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate53: End Sub
Private Sub lblDate54_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate54: End Sub
Private Sub lblDate55_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate55: End Sub
Private Sub lblDate56_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate56: End Sub
Private Sub lblDate57_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate57: End Sub
Private Sub lblDate61_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate61: End Sub
Private Sub lblDate62_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate62: End Sub
Private Sub lblDate63_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate63: End Sub
Private Sub lblDate64_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate64: End Sub
Private Sub lblDate65_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate65: End Sub
Private Sub lblDate66_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate66: End Sub
Private Sub lblDate67_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single): HoverControl bgDate67: End Sub
Attribute VB_Name = "frmDelay"
Attribute VB_Base = "0{FCAF97E9-3757-4247-80E9-C090EC424150}{7EEF4013-4215-4A2B-8A00-F9F2B4CBAA83}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub btnCancel_Click()
    If Not Len(TextTime.Text) = 5 Then
        ShowMessage 58
        TextTime.Text = Format(Time, "HH:MM")
        TextTime.SetFocus
        GoTo lbl_Exit
    Else
        If Not Mid(TextTime.Text, 3, 1) = Chr(58) Then
            ShowMessage 58
            TextTime.Text = Format(Time, "HH:MM")
            TextTime.SetFocus
            GoTo lbl_Exit
        End If
    End If
    Hide
    Tag = 0
lbl_Exit:
    Exit Sub
End Sub

Private Sub btnOK_Click()
    If Not Len(TextTime.Text) = 5 Then
        ShowMessage 58
        TextTime.Text = Format(Time, "HH:MM")
        TextTime.SetFocus
        GoTo lbl_Exit
    Else
        If Not Mid(TextTime.Text, 3, 1) = Chr(58) Then
            ShowMessage 58
            TextTime.Text = Format(Time, "HH:MM")
            TextTime.SetFocus
            GoTo lbl_Exit
        End If
    End If
    Hide
    Tag = 1
lbl_Exit:
    Exit Sub
End Sub

Private Sub TextDate_Enter()
    TextDate.Text = BasicCalendar(Date)
    TextTime.SetFocus
lbl_Exit:
    Exit Sub
End Sub

Private Sub TextTime_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
Dim bTest As Boolean
    bTest = IsTime(KeyAscii)
    If bTest = False Then
        Beep
        KeyAscii = 0
    End If
lbl_Exit:
    Exit Sub
End Sub

Private Sub UserForm_Initialize()
    TextDate.Text = Date
    TextTime.Text = Format(Time, "HH:MM")
lbl_Exit:
    Exit Sub
End Sub

Private Function IsTime(ByVal i As String) As Boolean
Select Case i        'Check to see if in valid Ascii range for integers plus colon
        Case 48 To 58
            IsTime = True
        Case Else
            IsTime = False
    End Select
lbl_Exit:
    Exit Function
End Function



Attribute VB_Name = "frmDisclaimer"
Attribute VB_Base = "0{A5FF0F48-5D95-4D2E-8688-C2B8D17508DB}{46FE513A-D58F-4AF0-B3AE-A3B581A35164}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

Private Sub chkDisclaimer_Click()
    SaveSetting AppID, "Config", "Disclaimer", chkDisclaimer.value
lbl_Exit:
    Exit Sub
End Sub

Private Sub cmdHideDisclaimer_Click()
    Unload Me
lbl_Exit:
    Exit Sub
End Sub

Private Sub ImageLogo_Click()
    Info
lbl_Exit:
    Exit Sub
End Sub

Private Sub Userform_Activate()
    If Application.Version > 14# Then Width = Width - 7
    lblDisclaimer.Caption = strDisclaimer
    RemoveTitleBar Me
    PlayASound "Notify"
lbl_Exit:
    Exit Sub
End Sub
Attribute VB_Name = "frmDonate"
Attribute VB_Base = "0{A27FF637-3220-482A-B801-3E929E893467}{75B8DB1F-A176-46FE-989B-2D970D12CCBE}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub btnCancel_Click()
    Unload Me
lbl_Exit:
    Exit Sub
End Sub

Private Sub btnDonatePound_Click()
    DonateGB
    Unload Me
lbl_Exit:
    Exit Sub
End Sub

Private Sub btnDonateEuro_Click()
    DonateEU
    Unload Me
lbl_Exit:
    Exit Sub
End Sub

Private Sub btnDonateDollar_Click()
    DonateUS
    Unload Me
lbl_Exit:
    Exit Sub
End Sub

Attribute VB_Name = "frmFilename"
Attribute VB_Base = "0{F22F1CF2-8A6E-4EA8-9667-82620E68D530}{9ACA338D-8BCF-4806-837E-EADB73EF7C61}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub CheckTranspose_Click()
    DefineCaption
End Sub

Private Sub CmbSeparator_Change()
    DefineCaption
End Sub

Private Sub CmdCancel_Click()
    Tag = 0
    Hide
End Sub

Private Sub CmdContinue_Click()
    Tag = 1
    Hide
End Sub

Private Sub Help14_Click()
    ModHelp.ShowHelp 14
End Sub

Private Sub Listfilename_Click()
    DefineCaption
End Sub

Private Sub OptPrefix_Click()
    DefineCaption
End Sub

Private Sub OptSuffix_Click()
    DefineCaption
End Sub

Private Sub TextFilename_Change()
    DefineCaption
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = True
End Sub

Private Sub cmdClose_Click()
    Hide
    Tag = 0
End Sub

Function DefineCaption()
Dim strGhostText As String
Dim strGhostFileName As String
Dim strSeparator As String
Dim strPrefix As String
Dim strSuffix As String
    If Listfilename.ListIndex > -1 Then
        If frmFilename.CheckTranspose.value = True Then
            strGhostFileName = "Field1"
        Else
            strGhostFileName = "Field2"
        End If
    Else
        strGhostFileName = ""
    End If

    Select Case CmbSeparator.value
        Case "[Underscore]": strSeparator = "_"
        Case "[Hyphen]": strSeparator = "-"
        Case "[Space]": strSeparator = Chr(32)
        Case Else: strSeparator = "_"
    End Select

    If OptPrefix.value = True Then
        strPrefix = TextFilename.Text
        strSuffix = ""
    Else
        strPrefix = ""
        strSuffix = TextFilename.Text
    End If

    LabelFormat.Caption = strPrefix

    If strPrefix <> "" Then
        LabelFormat.Caption = LabelFormat.Caption & strSeparator
    End If

    If frmFilename.CheckTranspose.value = True Then
        LabelFormat.Caption = LabelFormat.Caption & "Field2"
    Else
        LabelFormat.Caption = LabelFormat.Caption & "Field1"
    End If

    If strGhostFileName <> "" Then
        LabelFormat.Caption = LabelFormat.Caption & strSeparator
    End If

    LabelFormat.Caption = LabelFormat.Caption & strGhostFileName

    If strSuffix <> "" Then
        LabelFormat.Caption = LabelFormat.Caption & strSeparator
    End If

    LabelFormat.Caption = LabelFormat.Caption & strSuffix
    TextFormat.Text = LabelFormat.Caption
lbl_Exit:
    Exit Function
End Function


Attribute VB_Name = "frmHelp"
Attribute VB_Base = "0{A340E2DC-5642-4B7A-B019-13D2FB708836}{DA7789B7-7616-4CC8-9FF4-6A01080A5D53}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False

Option Explicit

Private Sub cbOK_Click()
   Unload Me
lbl_Exit:
    Exit Sub
End Sub

Private Sub cmdClose_Click()
    Unload Me
lbl_Exit:
    Exit Sub
End Sub

Attribute VB_Name = "frmMsg"
Attribute VB_Base = "0{CBAFAEE9-6E15-4299-8D85-EF41D860406E}{31C1DE6D-9AB7-419A-A440-829FAE6817AD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit
Private Sub CB_ErrOK_Click()
    Tag = "1"
    Hide
lbl_Exit:
    Exit Sub
End Sub

Private Sub CBErrNo_Click()
    Tag = "0"
    Hide
lbl_Exit:
    Exit Sub
End Sub

Private Sub CBQuit_Click()
    Tag = "3"
    Hide
lbl_Exit:
    Exit Sub
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    If CloseMode = vbFormControlMenu Then Cancel = True
lbl_Exit:
    Exit Sub
End Sub


Attribute VB_Name = "modXlData"
Option Explicit
Private RS As Object
Private CN As Object
Private numrecs As Long, q As Long
Private strWidth As String

Public Function xlFillList(ListOrComboBox As Object, _
                           iColumn As Long, _
                           strWorkBook As String, _
                           strRange As String)
    On Error GoTo Err_Handler
    strRange = strRange & "$]"
    Set CN = CreateObject("ADODB.Connection")
    CN.Open ConnectionString:="Provider=Microsoft.ACE.OLEDB.12.0;" & _
                              "Data Source=" & strWorkBook & ";" & _
                              "Extended Properties=""Excel 12.0 Xml;HDR=YES"";"
    Set RS = CreateObject("ADODB.Recordset")
    RS.CursorLocation = 3
    RS.Open "SELECT * FROM [" & strRange, CN, 2, 1        'read the data from the worksheet
    With RS
        .MoveLast
        numrecs = .RecordCount
        .MoveFirst
    End With
    With ListOrComboBox
        .ColumnCount = RS.Fields.Count
        .Column = RS.GetRows(numrecs)
        strWidth = vbNullString
        For q = 1 To .ColumnCount
            If q = iColumn Then
                If strWidth = vbNullString Then
                    strWidth = .Width - 4 & " pt"
                Else
                    strWidth = strWidth & .Width - 4 & " pt"
                End If
            Else
                strWidth = strWidth & "0 pt"
            End If
            If q < .ColumnCount Then
                strWidth = strWidth & ";"
            End If
        Next q
        .ColumnWidths = strWidth
    End With
lbl_Exit:
    If RS.State = 1 Then RS.Close
    Set RS = Nothing
    If CN.State = 1 Then CN.Close
    Set CN = Nothing
    Exit Function
Err_Handler:
    ShowMessage 28
    Resume lbl_Exit
End Function




' InQuest injected base64 decoded content
' )zw%

INQUEST-PP=macro
