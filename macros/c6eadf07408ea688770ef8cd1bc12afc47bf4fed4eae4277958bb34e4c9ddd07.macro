Attribute VB_Name = "ApplicationProxy"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit
Implements IApplication


' This small optimization speeds up writing to the excel sheet considerably
' by not updating the user interface for every change
' This function disables these features
Public Sub IApplication_disableWhileRunning(Optional ByVal entryPoint As Boolean = False)
    If entryPoint = True Then
        disableWorksheetFeaturesLevel = 0
    End If
    disableWorksheetFeaturesLevel = disableWorksheetFeaturesLevel + 1
    If disableWorksheetFeaturesLevel = 1 Then
        Application.Calculation = xlCalculationManual
        Application.ScreenUpdating = False
        Application.DisplayStatusBar = False
        'Application.EnableEvents = False
    End If
End Sub


' This function reenables the features
' By running after all updates are written, all changes will be shown in a single update
Public Sub IApplication_enableAfterRunning(Optional ByVal endPoint As Boolean = False)
    If endPoint = True Then
        disableWorksheetFeaturesLevel = 0
    Else
        disableWorksheetFeaturesLevel = disableWorksheetFeaturesLevel - 1
    End If
    If disableWorksheetFeaturesLevel < 1 Then
        Application.Calculation = xlCalculationAutomatic
        Application.ScreenUpdating = True
        Application.DisplayStatusBar = True
        'Application.EnableEvents = True
    End If
End Sub
Attribute VB_Name = "CBin"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@IgnoreModule ObjectVariableNotSet
'@Folder("Classes")
Option Explicit

' CBin class

' A CBin is a container that can hold CPiece's

Private Type TBin
    pieces() As CPiece       ' Used
    length As Long           ' The total length of the container, in 1/10 mm
    capacity As Long         ' The capacity of the container, in 1/10 mm
    capacityCuttable As Long '
    pieceCount As Long       ' Number of pieces currently in this bin
    channelTypeKey As String ' The type of channel this bin corresponds to
    sum As Long              ' In 1/10 mm
    filled As Boolean        ' If the bin is filled or not
    quantity As Long         ' Keeps track of quantity, Only relevant if uniqueProfile is set, for all others this this value stays at zero
    profileNo As Long        ' Same as above but for profile number, with this for normal bins it will just incrementing numbers
    uniqueProfile As Boolean ' This profile is different from the previous one in a set
    availableLength As Long
    availableLengthBeforeCutFreeSpace As Long ' todo: delete?
    permutation As CLongArray  ' Used in the brute force solver to save the quantities index so that it can be sorted together with the bins (by size)
End Type

Private this As TBin

' Initialization
Private Sub class_initialize()
    ReDim this.pieces(1 To 1)
    this.length = 0
    this.capacity = 0
    this.capacityCuttable = 0
    this.pieceCount = 0
    this.channelTypeKey = vbNullString
    this.filled = False
    this.quantity = 0
    this.profileNo = 0
    this.uniqueProfile = False
End Sub


Public Sub setValues( _
    ByVal length As Long, _
    ByVal capacity As Long, _
    ByVal capacityCuttable As Long, _
    ByVal channelTypeKey As String _
)
    this.length = length
    this.capacity = capacity
    this.capacityCuttable = capacityCuttable
    this.channelTypeKey = channelTypeKey
End Sub

Public Sub setAllValues( _
    ByVal length As Long, _
    ByVal capacity As Long, _
    ByVal capacityCuttable As Long, _
    ByVal channelTypeKey As String, _
    ByVal pieceCount As Long, _
    ByVal filled As Boolean, _
    ByVal quantity As Long, _
    ByVal profileNo As Long, _
    ByVal uniqueProfile As Boolean, _
    ByVal permutation As CLongArray _
)
    this.length = length
    this.capacity = capacity
    this.capacityCuttable = capacityCuttable
    this.channelTypeKey = channelTypeKey
    this.pieceCount = pieceCount
    this.filled = filled
    this.quantity = quantity
    this.profileNo = profileNo
    this.uniqueProfile = uniqueProfile
    ' TODO Provide a way to get these values directly instead of using this calculation function since that could make the objects diverge
    updateAvailableLengths
    Set this.permutation = permutation.getCopy
End Sub

Public Function getCopy() As CBin
    Dim pieceNo As Long
    Set getCopy = New CBin
    For pieceNo = 1 To this.pieceCount
        getCopy.addPiece getPieceCopy(pieceNo)
    Next
    getCopy.setAllValues _
        length:=this.length, _
        capacity:=this.capacity, _
        capacityCuttable:=this.capacityCuttable, _
        pieceCount:=this.pieceCount, _
        channelTypeKey:=this.channelTypeKey, _
        filled:=this.filled, _
        quantity:=this.quantity, _
        profileNo:=this.profileNo, _
        uniqueProfile:=this.uniqueProfile, _
        permutation:=this.permutation.getCopy
End Function

Public Function getPieceCopy(ByVal pieceNo As Long) As CPiece
    Set getPieceCopy = this.pieces(pieceNo).getCopy
End Function

Public Property Get getPieces() As CPiece()
'@Ignore ObjectVariableNotSet
    getPieces = this.pieces
End Property

Public Property Get length() As Long
    length = this.length
End Property

Public Property Get capacity() As Long
    capacity = this.capacity
End Property

Public Property Get pieceCount() As Long
    pieceCount = this.pieceCount
End Property

Public Property Get channelTypeKey() As String
    channelTypeKey = this.channelTypeKey
End Property

Public Property Get filled() As Boolean
    filled = this.filled
End Property

Public Property Let filled(ByVal value As Boolean)
    this.filled = value
End Property

Public Property Get quantity() As Long
    quantity = this.quantity
End Property

Public Property Let quantity(ByVal value As Long)
    this.quantity = value
End Property

Public Property Get profileNo() As Long
    profileNo = this.profileNo
End Property

Public Property Let profileNo(ByVal value As Long)
    this.profileNo = value
End Property

Public Property Get uniqueProfile() As Boolean
    uniqueProfile = this.uniqueProfile
End Property

Public Property Let uniqueProfile(ByVal value As Boolean)
    this.uniqueProfile = value
End Property

Public Property Get permutation() As CLongArray
    Set permutation = this.permutation
End Property

Public Property Let permutation(ByVal value As CLongArray)
    Set this.permutation = value
End Property


' Returns the sum of the length all used pieces
Public Function getUsefullSum() As Long
    getUsefullSum = 0
    Dim pieceNo As Long
    For pieceNo = 1 To this.pieceCount
        If this.pieces(pieceNo).pieceType = enumPieceType.normal Then
            getUsefullSum = getUsefullSum + this.pieces(pieceNo).length
        End If
    Next
End Function


' Returns the sum of all pieces
Public Function getSum() As Long
    getSum = 0
    Dim pieceNo As Long
    For pieceNo = 1 To this.pieceCount
        getSum = getSum + this.pieces(pieceNo).length
    Next
End Function


' Returns the sum of all waste pieces
Public Function getWasteSum() As Long
    getWasteSum = 0
    Dim pieceNo As Long
    For pieceNo = 1 To this.pieceCount
        If this.pieces(pieceNo).pieceType = enumPieceType.waste _
            Or this.pieces(pieceNo).pieceType = enumPieceType.cut _
        Then
            getWasteSum = getWasteSum + this.pieces(pieceNo).length
        End If
    Next
End Function

' Returns the sum of all waste pieces
Public Function getWastePlusUnusedSpaceSum() As Long
    getWastePlusUnusedSpaceSum = 0
    Dim usedSum As Long
    Dim pieceNo As Long
    For pieceNo = 1 To this.pieceCount
        If this.pieces(pieceNo).pieceType = enumPieceType.waste _
            Or this.pieces(pieceNo).pieceType = enumPieceType.cut _
        Then
            getWastePlusUnusedSpaceSum = getWastePlusUnusedSpaceSum + this.pieces(pieceNo).length
        End If
        usedSum = usedSum + this.pieces(pieceNo).length
    Next
    getWastePlusUnusedSpaceSum = getWastePlusUnusedSpaceSum + (this.length - usedSum)
End Function

' Returns the the piecetype of the specified pieceNo
Public Function getPieceType(ByVal pieceNo As Long) As enumPieceType
    getPieceType = this.pieces(pieceNo).pieceType
End Function


' Returns the the HPR placement of the specified pieceNo
Public Function getPieceHPRPlacement(ByVal pieceNo As Long) As enumHPRPlacement
    getPieceHPRPlacement = this.pieces(pieceNo).hprPlacement
End Function


' Returns the the length of the specified pieceNo
Public Function getPieceLength(ByVal pieceNo As Long) As Long
    getPieceLength = this.pieces(pieceNo).length
End Function

' Adds a piece to the end of the array
' TODO Currently this is done in a non optimal way as the variable is redimed every time it is run
' A better version would be to initialize a buffer and have a counter that denotes the size and only
' redim when nessecary
Public Sub addPiece(ByVal piece As CPiece)
    this.pieceCount = this.pieceCount + 1
    ReDim Preserve this.pieces(1 To this.pieceCount)
    Set this.pieces(this.pieceCount) = piece
    If piece.length = 0 Then
        Logger.logBug "Placement bug: Empty piece added"
    End If
    
    If piece.pieceType = enumPieceType.cut Then
        Logger.logDeep "Adding cut, length=" & piece.length & ", new pieceCount=" & this.pieceCount
    ElseIf piece.pieceType = enumPieceType.waste Then
        Logger.logDeep "Adding wastepiece, length=" & piece.length & ", new pieceCount=" & this.pieceCount
    ElseIf piece.pieceType = enumPieceType.normal Then
        Logger.logDeep _
            "Adding piece, length=" & piece.length & _
            ", Placement=" & hprPlacementToString(piece.hprPlacement) & _
            ", new pieceCount=" & this.pieceCount
    End If
End Sub


' Compares this CBin to another CBin
' If all pieces match, they are considered equal
Public Function isEqualTo(ByVal testBin As CBin) As Boolean
    ' Assume that it is equal and prove that it is not
    isEqualTo = True
    Dim pieceNo As Long
    Dim comparePiece As CPiece
    ' This checker assumes that the bins are sorted
    ' so it only needs to check the current bin with the previous bin
    If this.pieceCount = testBin.pieceCount Then
        ' Check all pieces
        For pieceNo = 1 To this.pieceCount
            ' TODO Enhancement: Dont create a copy here, instead make a property that returns a object reference
            Set comparePiece = testBin.getPieceCopy(pieceNo)
    
            If Not this.pieces(pieceNo).length = comparePiece.length Or _
                Not this.pieces(pieceNo).hprPlacement = comparePiece.hprPlacement Or _
                Not this.pieces(pieceNo).pieceType = comparePiece.pieceType Or _
                Not this.pieces(pieceNo).placed = comparePiece.placed Or _
                Not this.pieces(pieceNo).channelTypeKey = comparePiece.channelTypeKey _
            Then
                isEqualTo = False
                Exit For
            End If
        Next
    Else
        isEqualTo = False
    End If
End Function


' Tries to place the CPiece in this CBin, returns true/false on success/failure
Public Function placePiece( _
    ByVal cuttingType As enumCuttingType, _
    ByVal piece As CPiece, _
    ByVal cutWidth As Long _
) As Boolean
    Dim piecePlaced As Boolean
    piecePlaced = False
    
    ' Update available lengths
    updateAvailableLengths
    
    ' Use the right placement function depending on the piece cuttingType:
    Select Case cuttingType
    Case enumCuttingType.A
        piecePlaced = placePieceA(piece, cutWidth)
    Case enumCuttingType.B1
        piecePlaced = placePieceB1(piece, cutWidth)
    Case enumCuttingType.B2
        piecePlaced = placePieceB2(piece, cutWidth)
    Case enumCuttingType.C1
        piecePlaced = placePieceC1(piece, cutWidth)
    Case enumCuttingType.c2
        piecePlaced = placePieceC2(piece, cutWidth)
    End Select
    
    If piecePlaced Then
        ' Add an endcut of the right size (unless the bin is already filled)
        addRightCut cutWidth
        
        ' Check if the channel was filled
        updateAvailableLengths
        If this.availableLength = 0 Then
            this.filled = True
        End If
    End If
    placePiece = piecePlaced
End Function


Private Sub addRightCut(ByVal cutWidth As Long)
    Dim availableLength As Long
    Dim shortenedCutWidth As Long

    ' Recalculate
    availableLength = this.capacity - getSum

    ' Check if a full sized cut fits
    If availableLength >= cutWidth Then
        ' Add cut
        addCutPiece cutWidth
    ' Check if a cut fits at all
    ElseIf availableLength > 0 Then
        ' Add cut that is smaller than a whole cut as we are at the end of the channel
        shortenedCutWidth = availableLength
        Logger.logInfo "Space available for a cut is smaller then the cut so it needs to be adjusted, cutWidth = " & shortenedCutWidth
        addCutPiece shortenedCutWidth
    End If
End Sub


Public Function placePieceA( _
    ByVal piece As CPiece, _
    ByVal cutWidth As Long _
) As Boolean
    Dim wasteSpaceWidth As Long
    Dim diffToPerfectFit As Long
    Dim toleranceNeeded As Long
    
    wasteSpaceWidth = 0
        
    Logger.logDeep "   this.availableLength:" & this.availableLength
    Logger.logDeep "   piece.allowedTolerance:" & piece.allowedTolerance
    Logger.logDeep "   piece.allowedToleranceRounded:" & piece.allowedToleranceRoundedDown
    Logger.logDeep "   Settings.cutfreeSpaceEnd: " & Settings.cutFreeSpaceEnd

    ' Could it at all be possible to fit this piece?
    ' No rounding is needed for this check
    If couldBeFittedAtAll(piece) Then
        Logger.logDeep "   a fit could be possible, fits within total availableLength"
    
        ' Cut-free space
        ' Will this piece end up in the cut-free space?
        ' Is it larger than the available length before the cut free space but smaller then total free space on the channel?
        If cutAfterPieceEndsInCutFreeSpace(piece, cutWidth) Then
            Logger.logDeep "     inside the cut-free space"
    
            ' The piece has to be larger than or equal to the cut-free space (or be able to be made equal or larger) in order to be placed here
            If largerThanOrEqualToCutFreeSpaceUsingTolerance(piece, Settings.cutFreeSpaceEnd) Then
    
                Logger.logDeep "      piece is larger than cutfree space, it will fit"
    
                ' It would be possible to fit this piece, find out how
    
                toleranceNeeded = getToleranceNeededToPlaceOverCutFreeSpaceRounded( _
                    piece, _
                    Settings.cutFreeSpaceEnd)
                
                ' Make sure that the tolerance we want to use does not actually make it too large to fit (this could happen because of rounding)
                If toleranceNeeded + piece.length <= this.availableLength + Settings.cutFreeSpaceEnd Then
                    
                    ' Do we need to use tolerance?
                    '
                    If Not toleranceNeeded = 0 Then
                        piece.usedTolerance = toleranceNeeded
                        piece.length = piece.length + piece.usedTolerance
                        Logger.logDeep "       using tolerance: " & piece.usedTolerance
                        Logger.logDeep "       new piece length: " & piece.length
                    End If
        
                    ' Now we have taken care of the piece, time to look at possible wasteSpece that we need to insert before the piece is inserted to shift it toward the end of the channel
                    ' There is a problem with rounding here:
                    ' If the piece is to be shifted all the way toward the end of the channel, and if the
                    ' length of the channel is defined in sub mm length then we have two options:
                    ' -Either we do not shift the piece all the way to the end of the channel, leaving a sub mm length that has to be cut away manually
                    ' or
                    ' -We let the waste piece be defined in a sub mm length
        
                    wasteSpaceWidth = this.availableLength - piece.length
                    ' Waste pieces could still be mm decimal
    
                    ' Do we need to insert a waste piece?
                    If wasteSpaceWidth > 0 Then
                        Dim wasteSpaceRoundErrorUp As Long
                        Dim wasteSpaceRoundErrorDown As Long
                        
                        ' Now the question is
                        
                        wasteSpaceRoundErrorUp = round10up(wasteSpaceWidth) - wasteSpaceWidth
                        wasteSpaceRoundErrorDown = wasteSpaceWidth - round10down(wasteSpaceWidth)
                        If wasteSpaceWidth Mod 10 = 0 Then
                            Logger.logDeep "     Decimal waste space detected"
                            
                            Logger.logDeep "     wasteSpaceRoundErrorUp: " & wasteSpaceRoundErrorUp
                            Logger.logDeep "     wasteSpaceRoundErrorDown: " & wasteSpaceRoundErrorDown
                            
                            If wasteSpaceRoundErrorUp < wasteSpaceRoundErrorDown And _
                               wasteSpaceRoundErrorUp <= (piece.allowedToleranceRoundedDown - piece.usedTolerance) _
                            Then
                                'wasteSpaceWidth = wasteSpaceWidth + wasteSpaceRoundErrorUp
                                Logger.logDeep "     adjusting tolerance of the piece"
                            ElseIf wasteSpaceRoundErrorDown <= (piece.allowedToleranceRoundedDown - piece.usedTolerance) Then
                                'wasteSpaceWidth = wasteSpaceWidth - wasteSpaceRoundErrorDown
                                Logger.logDeep "     adjusting tolerance of the piece"
                            'Else
                                ' Not possible
                            End If
                        Else
                            Logger.logDeep "    round wastespace detected"
                        End If
                    
                        Logger.logDeep "   We need to insert a waste piece"
    
                        ' Try to fill up waste space
                        If fillWasteSpace(wasteSpaceWidthIn:=wasteSpaceWidth, _
                                          cutWidth:=cutWidth, _
                                          allowUseOfRemainingTolerance:=False, _
                                          piece:=piece) _
                        Then
                            ' Add piece
                            piece.hprPlacement = enumHPRPlacement.noSide
                            piece.placed = True
                            addPiece piece
                        Else
                            Logger.logDeep "   Unable to fillWasteSpace, we can't fit any piece here"
                        End If
                    End If
                Else
                    Logger.logDeep "   The piece could not be fitted because when trying to round it up it became too large"
                End If
            Else
                Logger.logDeep " piece is smaller than cutfree space, it will never fit"
            End If

        ' Does not end up en the cut-free space
        Else
            ' Smaller than round10down(availableLengthBeforeCutFreeSpace + piece.allowedTolerance)
            Logger.logDeep "Not inside cut-free space."
            Logger.logDeep "piece.length - piece.allowedTolerance:" & (piece.length - piece.allowedTolerance)

            diffToPerfectFit = this.availableLength - piece.length
            Logger.logDeep "diffToPerfectFit: " & diffToPerfectFit

            ' Check if diffToPerfect fit is within the tolerance:
            If Not diffToPerfectFit = 0 _
               And diffToPerfectFit <= piece.allowedToleranceRoundedDown _
               And diffToPerfectFit >= -piece.allowedToleranceRoundedDown _
            Then
                If diffToPerfectFit > 0 Then
                    piece.usedTolerance = round10up(diffToPerfectFit)
                Else
                    piece.usedTolerance = round10down(diffToPerfectFit)
                End If
                piece.length = piece.length + piece.usedTolerance   ' Adjust piece length by tolerance
                Logger.logDeep "Adding tolerance!, piece.usedTolerance=" & piece.usedTolerance
            End If
            
            ' Add piece
            piece.hprPlacement = enumHPRPlacement.noSide
            piece.placed = True
            addPiece piece
        End If
    Else
        Logger.logDeep "No fit: piece is bigger than availableLength"
    End If
        
    placePieceA = piece.placed
End Function


Public Function placePieceB1(ByVal piece As CPiece, ByVal cutWidth As Long) As Boolean

    ' cuttingType on one side gives us flexibility as we can choose to turn the piece around
    ' TODO Figure out usedCutWidth
    
    Dim newLength As Long
    Dim binSum As Long
    Dim usedCutWidth As Long
    Dim lefttSidePos As Long
    Dim rightSidePos As Long
    Dim validCutArea_shorter_min As Long
    Dim validCutArea_shorter_max As Long
    Dim validCutArea_longer_min As Long
    Dim validCutArea_longer_max As Long
    Dim validCutArea_longer_min_fromStart As Long
    Dim validCutArea_longer_max_fromStart As Long

    '@Ignore UseMeaningfulName
    Dim n As Long
    Dim diffToRightCutAreaRounded As Long
    Dim diffToLeftCutAreaRounded As Long
    Dim holeStartUsable As Boolean
    Dim holeEndUsable As Boolean
    Dim wasteSpaceWidth_HPR_left As Long
    Dim wasteSpaceWidth_HPR_right As Long
    
    Dim roundingAdjustment_right As Long
    Dim roundingAdjustment_left As Long
    
    usedCutWidth = cutWidth
    
    ' Simplifications
    lefttSidePos = getSum
    rightSidePos = lefttSidePos + piece.length ' Right side of the piece

    Logger.logDeep " capacity: " & this.capacity
    Logger.logDeep " capacityCuttable: " & this.capacityCuttable
    Logger.logDeep " cutWidth: " & cutWidth
    Logger.logDeep " piece.length: " & piece.length
    Logger.logDeep " piece.allowedTolerance: " & piece.allowedTolerance
    Logger.logDeep " piece.allowedToleranceRoundedDown: " & piece.allowedToleranceRoundedDown
    Logger.logDeep " lefttSidePos: " & lefttSidePos
    Logger.logDeep " rightSidePos: " & rightSidePos
    
    Dim thisChannelType As CChannelType
    Set thisChannelType = Request.channelTypeSet.getChTypeFromKey(this.channelTypeKey)
    
    ' TODO Optimization possible for the cases where the two roundings here could have been combined to one
    ' TODO Bug when checking available length rounded we do not take care of the case where the piece is the last piece and the channel is a no rounded number and the piece takes up exacly the avilable space of the channel
    ' If last piece then allow rounded piece size if the piece takes up all the available space
    '   lastPieceCanBeNonRounded = True
    ' endif

    ' Check if the piece could be fitted because of it's length (most general condition)
    If piece.length - piece.allowedTolerance <= this.availableLength Then
        Logger.logDeep "  Piece has a possibility of fitting (it is smaller than free space or could be made smaller by using tolerance)"
        Logger.logDeep "  Checking cuttingType criteria for a possible fit:"
        
        ' Check if it fits with cuttingType on the left side as is
        If thisChannelType.isValidLeftHPR(lefttSidePos) Then
        
            Logger.logDeep "   Case 1: Piece fits with HPR on left side"
        
            ' Check how the pice fits:
           
            ' Piece fits perfectly without adjustments
            If piece.length = this.availableLength Then
            
                Logger.logDeep "    Fits exactly as leftSided"

                ' Add piece
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.leftSide
                addPiece piece
            
            ' Piece fits perfectly by using the tolerance
            ElseIf piece.length - piece.allowedTolerance <= this.availableLength _
               And piece.length + piece.allowedTolerance >= this.availableLength _
            Then
                Logger.logDeep "    Piece fits perfectly by using the tolerance"
                
                ' Adjust piece length by tolerance
                piece.usedTolerance = this.availableLength - piece.length

                Logger.logDeep "usedTolerance = " & piece.usedTolerance
                newLength = piece.length + piece.usedTolerance
                
                ' Add piece
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.leftSide
                piece.length = newLength
                Logger.logDeep "    Adding tolerance!, piece.usedTolerance=" & piece.usedTolerance
                addPiece piece
                
            ' Normal case
            Else
                Logger.logDeep "    Piece fits without using tolerance"
                
                ' Add piece
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.leftSide
                addPiece piece
                        
            End If
            
        ' Try to fit the piece as is with cuttingType on the RIGHT side as is
        ElseIf thisChannelType.isValidRightHPR(rightSidePos) Then
        
            Logger.logDeep "   Case 2: HPR on right side is a valid cut"
            
            ' Does it fit?
            If rightSidePos <= this.capacityCuttable Then
        
                Logger.logDeep "    fit found, fits with HPR right"
        
                ' Place
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.rightSide
                addPiece piece
            Else
                Logger.logDeep "    ends up in the cut-free space"
            End If
        
        Else
            Logger.logDeep "   Case 3: Piece does not fit with the HPR criteria as is"
            
            ' Piece does not fit the HPR criteria as is, now we have two options:
            ' Case 3.1: Try using the tolerance on the right side to adjust the piece length and make it fit
            ' > Can only be placed as HPR right
            ' Case 3.2: Add a waste pice to make the piece fit
            ' > Can be placed as HPR left or HPR right depending on which is closer
            
            ' For C1 we need to know the relevant cut_min and cut_max
            ' The case of adding or subtracting tolerance to the right side with left handed HPR has already been taken care of above.
        
            ' Figure out what lengths are relevant:

            validCutArea_shorter_min = 0
            validCutArea_shorter_max = 0
            validCutArea_longer_min = 0
            validCutArea_longer_max = 0
        
            binSum = getSum
            n = 1
            
            Logger.logDeep "    maxCutsLeft:" & vbTab & thisChannelType.leftCutsMax
            Logger.logDeep "    Finding the positions of the two holes closest to the end of the piece (HPR right)"
        
            ' Allright! so we got the relevant values
            Logger.logDeep "    binsum" & vbTab & binSum
            'Logger.logDeep "    n" & vbTab & "cutMin_lh" & vbTab & "cutMax_lh" & vbTab & "cutMin_rh" & vbTab & "cutMax_rh"
            
            ' Find the positions of the two holes closest to the end of the piece
            Do Until validCutArea_longer_min >= binSum + piece.length _
                  Or n = thisChannelType.rightCutsMax
                validCutArea_shorter_min = thisChannelType.getRightCutMin(n)
                validCutArea_shorter_max = thisChannelType.getRightCutMax(n)
                validCutArea_longer_min = thisChannelType.getRightCutMin(n + 1)
                validCutArea_longer_max = thisChannelType.getRightCutMax(n + 1)
                'Logger.logDeep n & vbTab & validCutArea_shorter_min & vbTab & validCutArea_shorter_max & vbTab & validCutArea_longer_min & vbTab & validCutArea_longer_max
                'If validCutArea_longer_min >= binSum + piece.length Then
                '   Logger.logDeep "Stop condition: validCutArea_longer_min >= binsum + piece.length" & vbTab & validCutArea_longer_min & " >= " & binSum & " + " & piece.length
                'End If
                n = n + 1
            Loop
        
            ' Allright! so we got the relevant values
            Logger.logDeep "     validCutArea_shorter_max: " & vbTab & validCutArea_shorter_min
            Logger.logDeep "     validCutArea_shorter_max: " & vbTab & validCutArea_shorter_max
            Logger.logDeep "     validCutArea_longer_min: " & vbTab & validCutArea_longer_min
            Logger.logDeep "     validCutArea_longer_max: " & vbTab & validCutArea_longer_max
            Logger.logDeep "    Case 3.1: Trying to use the tolerance on the right side to adjust the piece length and make it fit"
            
            ' Calculate how for off we are from the closest cut areas
            diffToLeftCutAreaRounded = round10up(rightSidePos - validCutArea_shorter_max)
            diffToRightCutAreaRounded = round10up(validCutArea_longer_min - rightSidePos)
    
            Logger.logDeep "     diffToLeftCutAreaRounded:" & vbTab & diffToLeftCutAreaRounded
            Logger.logDeep "     diffToRightCutAreaRounded:" & vbTab & diffToRightCutAreaRounded
    
            ' Stop condition, when diff to right hole is negative, we are already beyond the last hole, and nothing more is possible.
            If diffToRightCutAreaRounded > 0 Then

                ' If the distance to the right or left holes are within the tolerance
                If diffToLeftCutAreaRounded <= piece.allowedToleranceRoundedDown _
                Or diffToRightCutAreaRounded <= piece.allowedToleranceRoundedDown Then
                
                    Logger.logDeep "     Distance to hole is within the tolerance"
                
                    If diffToLeftCutAreaRounded <= diffToRightCutAreaRounded Then
                        ' We are closest to the left cutarea
                        Logger.logDeep "     closest to the left cutarea (or equal)"
                        piece.usedTolerance = -diffToLeftCutAreaRounded
                        Logger.logDeep "     Using tolerance!, piece.usedTolerance=" & piece.usedTolerance
                    Else
                        ' We are closest to the right cutarea
                        piece.usedTolerance = diffToRightCutAreaRounded
                        If diffToRightCutAreaRounded > 0 Then
                            Logger.logDeep "     Using tolerance!, piece.usedTolerance=" & piece.usedTolerance
                        End If
                        Logger.logDeep "     closest to the right cutarea"
                    End If
                    
                    ' Adjust piece length by tolerance
                    Logger.logDeep "     Adjusting piece length by tolerance"
                    Logger.logDeep "     piece.usedTolerance = " & piece.usedTolerance
                    newLength = piece.length + piece.usedTolerance
                    piece.length = newLength
    
                    ' Add piece
                    piece.hprPlacement = enumHPRPlacement.rightSide
                    piece.placed = True
                    addPiece piece
                
                ' The piece can not be placed in its current position, even by using tolerance
                ' Try to fit the piece by adding a waste piece
                Else
                
                    Logger.logDeep "     The piece cannot be placed in its current position, even by using tolerance [allowedToleranceRoundedDown: " & piece.allowedToleranceRoundedDown & "]"
                    Logger.logDeep "    Case 3.2: Trying to add a waste pice to make the piece fit"

                    validCutArea_longer_min_fromStart = 0
                    validCutArea_longer_max_fromStart = 0
                    holeStartUsable = False
                    holeEndUsable = False
                    
                    ' Find the positions of the next cutarea from the start of the piece
                    ' where the difference between the binsum and validCutArea_longer_min_fromStart is at least cutWidth wide
                    Logger.logDeep "     Finding the position of the next valid cutarea from the start of the piece"
                    Logger.logDeep "     where the difference between the binsum and validCutArea_longer_min_fromStart is at least cutWidth wide"
                    
                    n = 1
                    
                    Do Until validCutArea_longer_min_fromStart >= binSum + cutWidth Or n = thisChannelType.leftCutsMax
                        roundingAdjustment_left = getRoundingAdj10(thisChannelType.getLeftCutMin(n) - binSum - cutWidth)
                        validCutArea_longer_min_fromStart = thisChannelType.getLeftCutMin(n) + roundingAdjustment_left
                        validCutArea_longer_max_fromStart = thisChannelType.getLeftCutMax(n)
                        Logger.logDeep "     n: " & n & ", roundingAdjustment_left: getRoundingAdj10(" & thisChannelType.getLeftCutMin(n) & " - " & binSum & " - " & cutWidth & ") = " & roundingAdjustment_left
                        n = n + 1
                    Loop
                    
                    Logger.logDeep "     validCutArea_longer_min_fromStart:" & vbTab & validCutArea_longer_min_fromStart
                    Logger.logDeep "     validCutArea_longer_max_fromStart:" & vbTab & validCutArea_longer_max_fromStart
                    
                    ' Make sure the loop did not run to the end without a valid value
                    If validCutArea_longer_min_fromStart >= binSum + cutWidth Then
                        holeStartUsable = True
                    End If
                    Logger.logDeep "     holeStartUsable:" & vbTab & holeStartUsable
                    
                    ' Find the positions of the next hole from the start of the piece
                    ' where the difference between the binsum and cutMin_rightHoleStart is at least cutWidth wide
                    Logger.logDeep "     Finding the position of the next valid cutarea from the start of the piece"
                    Logger.logDeep "     where the difference between the binsum and validCutArea_longer_min is at least cutWidth wide"
                    
                    
                    n = 1
                    validCutArea_longer_min = 0
                    validCutArea_longer_max = 0
                    Logger.logDeep validCutArea_longer_min & " >= " & binSum & " + " & piece.length & " + " & cutWidth & " Or " & n & " = " & thisChannelType.rightCutsMax
                    
                    Do Until validCutArea_longer_min >= binSum + piece.length + cutWidth _
                    Or n = thisChannelType.rightCutsMax
                        roundingAdjustment_right = getRoundingAdj10(thisChannelType.getRightCutMin(n + 1) - binSum - cutWidth)
                        validCutArea_longer_min = thisChannelType.getRightCutMin(n + 1) + roundingAdjustment_right
                        validCutArea_longer_max = thisChannelType.getRightCutMax(n + 1)
                        Logger.logDeep "     n: " & n & ", roundingAdjustment_right: getRoundingAdj10(" & thisChannelType.getRightCutMin(n + 1) & " - " & binSum & " - " & cutWidth & ") = " & roundingAdjustment_right
                        n = n + 1
                    Loop
                    
                    Logger.logDeep "     validCutArea_longer_min:" & vbTab & validCutArea_longer_min
                    Logger.logDeep "     validCutArea_longer_max:" & vbTab & validCutArea_longer_max
                    
                    ' Make sure the loop did not run to the end without a valid value
                    If validCutArea_longer_min >= binSum + piece.length + cutWidth Then
                        holeEndUsable = True
                    End If
                    
                    ' Now we got all the values needed in order to calculate the properties of the waste piece.
                    wasteSpaceWidth_HPR_left = validCutArea_longer_min_fromStart - binSum
                    wasteSpaceWidth_HPR_right = validCutArea_longer_min - binSum - piece.length
                    
                    Logger.logDeep "     wasteSpaceWidth_HPR_left: (" & validCutArea_longer_min_fromStart & " - " & binSum & ") = " & wasteSpaceWidth_HPR_left
                    Logger.logDeep "     wasteSpaceWidth_HPR_right: (" & validCutArea_longer_min & " - " & binSum & " - " & piece.length & ") = " & wasteSpaceWidth_HPR_right
                    Logger.logDeep "     holeEndUsable:" & vbTab & holeEndUsable
                    
                    ' HPR Left
                    ' Also determine what gives less waste HPR left or HPR right:
                    ' Is it possible to add the piece here?
                    If wasteSpaceWidth_HPR_left <= wasteSpaceWidth_HPR_right _
                       And thisChannelType.isValidLeftHPR(validCutArea_longer_min_fromStart) _
                       And piece.length + wasteSpaceWidth_HPR_left <= this.availableLength Then
                        ' TODO Add support for using the tolerance here
                        ' TODO Add support for cutfree space here

                        Logger.logDeep "      A) Setting piece as HPR left"
                     
                        If wasteSpaceWidth_HPR_left > cutWidth Then
                            ' Add waste pice
                            addWastePiece wasteSpaceWidth_HPR_left - cutWidth
                        End If
    
                        ' Add cut
                        addCutPiece usedCutWidth
                        
                        ' Add piece
                        piece.hprPlacement = enumHPRPlacement.leftSide
                        piece.placed = True
                        addPiece piece

                    ' HPR Right
                    ' Is it possible to add the piece here?
                    ElseIf thisChannelType.isValidRightHPR(validCutArea_longer_min) _
                           And piece.length + wasteSpaceWidth_HPR_left <= this.availableLength Then
                        ' TODO Add support for using the tolerance here
                        ' TODO Add support for cutfree space here
                        
                        Logger.logDeep "      B) Setting piece as HPR right"
                    
                        If wasteSpaceWidth_HPR_right > cutWidth Then
                            ' Add waste pice
                            addWastePiece wasteSpaceWidth_HPR_right - cutWidth
                        End If
    
                        ' Add cut
                        addCutPiece usedCutWidth
                        
                        ' Add piece
                        piece.hprPlacement = enumHPRPlacement.rightSide
                        piece.placed = True
                        addPiece piece
                    End If
                    
                End If
            Else
                Logger.logDeep "   Went beyond the last hole, not possible to place piece in this bin"
            End If
        End If
    Else
        Logger.logDeep "Piece length is longer than available lenght"
    End If
    
    placePieceB1 = piece.placed
End Function


Public Function placePieceC1(ByVal piece As CPiece, ByVal cutWidth As Long) As Boolean

    ' HPR on both sides is the hardest condition to fulfill
    Dim leftCutPos As Long
    Dim rightCutPos As Long
    '@Ignore UseMeaningfulName
    Dim n As Long
    '@Ignore UseMeaningfulName
    Dim m As Long
    
    Dim fitFound As Boolean
    Dim fitPosition As Long
    Dim leftOk As Boolean
    Dim rightOk As Boolean

    Dim usedMargin As Long
    Dim startPosMin As Long
    Dim areaMaxSize As Long
    Dim areaMinSize As Long
    Dim pieceMinLength As Long
    Dim pieceMaxLength As Long
    
    Dim wastePieceSize As Long
    Dim wasteSize As Long
    
    Dim addOverlappingCuts As Boolean
    Dim addTwoCuts As Boolean
    Dim secondCutSize As Long
    
    addOverlappingCuts = False
    addTwoCuts = False
    secondCutSize = 0
    

    Dim roundingAdjustmentUp As Long
    Dim roundingAdjustmentDown As Long

    Dim thisChannelType As CChannelType
    Set thisChannelType = Request.channelTypeSet.getChTypeFromKey(this.channelTypeKey)

    fitFound = False
    usedMargin = 0

    ' Grab the next available cutting position and see if it works
    leftCutPos = getSum
    rightCutPos = leftCutPos + piece.length

    Logger.logDeep "  Checking if the two cuts are valid:"
    ' Left
    Logger.logDeep "  isValidLeftHPR(" & leftCutPos & ")"
    leftOk = thisChannelType.isValidLeftHPR(leftCutPos)
    'Logger.logDeep "  >Left side valid = " & leftOk
    ' Right
    Logger.logDeep "  isValidRightHPR(" & rightCutPos & ")"
    rightOk = thisChannelType.isValidRightHPR(rightCutPos)
    Logger.logDeep "  >Right side valid: " & rightOk
    
    
    ' Check if the sides are valid accoding to HPR
    If leftOk And rightOk Then
        Logger.logDeep "  Left and right are ok, check if a right cut is possible [capacityCuttable: " & this.capacityCuttable & ", rightCutPos: " & rightCutPos & ", cutWidth: " & cutWidth & "]"
        If rightCutPos <= this.capacityCuttable Then
            ' It fits direcly!
            fitFound = True
            fitPosition = leftCutPos
            Logger.logDeep "  >Right cut is possible"
        Else
            Logger.logDeep "  >Right cut is not possible"
        End If
    
    ' Does not fit in place accodring to HPR, see if it would fit if we add a waste piece to the left
    Else
        Logger.logDeep "  Does not fit in place accodring to HPR, see if it would fit if we add a waste piece to the left [leftCutPos: " & vbTab & leftCutPos & ", thisChannelType.maxCutsLeft: " & vbTab & thisChannelType.leftCutsMax & "]"
        Logger.logDeep "  Left side: Looking for a fit (" & thisChannelType.leftCutsMax & " positions to check)"
        
        ' Find the next cut area for the left side
        For n = 1 To thisChannelType.leftCutsMax
            'Logger.logDeep "n: " & vbTab & n
            
            ' Make sure we are not trying to use an area that is to the left of the current fill position of the bin
            startPosMin = thisChannelType.getLeftCutMin(n)
            If leftCutPos > startPosMin Then
                startPosMin = leftCutPos
            End If
            
            ' Now check that the available cut area is big enough to insert a cut into on the left side
            If thisChannelType.getLeftCutMax(n) - leftCutPos >= cutWidth Then
                ' Yes a cut is possible here
                Logger.logDeep "  >Found a left fit [n=" & n & "]"
                
                Logger.logDeep "  Right side: Looking for a fit (" & thisChannelType.rightCutsMax & " positions to check)"
                
                Logger.logDeep "  areaMinSize: " & vbTab & "areaMaxSize: " & vbTab & "piece.length:" & vbTab & "pieceMinLength:" & vbTab & "pieceMaxLength:"
                
                ' Does the piece fit here?
                ' Find the right side to land the cut
                ' TODO Possible optimization start from n and not from 1
                For m = 1 To thisChannelType.rightCutsMax
                    
                    ' Pass over all where the cutMinRight < cutMaxLeft
                    If thisChannelType.getRightCutMin(m) > thisChannelType.getLeftCutMax(n) Then

                        areaMinSize = round10up(thisChannelType.getRightCutMin(m) - thisChannelType.getLeftCutMax(n))
                        areaMaxSize = round10down(thisChannelType.getRightCutMax(m) - startPosMin)

                        'Logger.logDeep thisChannelType.getCutMinRight(m) & " - " & thisChannelType.getCutMaxLeft(n) & " ~=" & areaMinSize
                        'Logger.logDeep thisChannelType.getCutMaxRight(m) & " - " & startPosMin & " ~=" & areaMaxSize

                        pieceMinLength = piece.length - piece.allowedToleranceRoundedDown
                        pieceMaxLength = piece.length + piece.allowedToleranceRoundedDown

                        ' Write table
                        Logger.logDeep "  " & areaMinSize & vbTab & vbTab & vbTab & vbTab & areaMaxSize & vbTab & vbTab & vbTab & vbTab & piece.length & vbTab & vbTab & vbTab & pieceMinLength & vbTab & vbTab & vbTab & pieceMaxLength

                        ' Most general condition, check that the piece would fit if we used the margin
                        ' Check if the area is large enough and that the area is small enough
                        If areaMaxSize >= pieceMinLength And _
                           areaMinSize <= pieceMaxLength Then

                            ' Check if we need to use a margin
                            If areaMaxSize < piece.length Then
                                ' Negative margin
                                usedMargin = areaMaxSize - piece.length
                            ElseIf areaMinSize > piece.length Then
                                ' Positive margin
                                usedMargin = areaMinSize - piece.length
                            End If

                            ' Where exacly does it fit?
                            fitPosition = thisChannelType.getRightCutMin(m) - piece.length + usedMargin
                            Logger.logDeep "fitPosition (exact): " & fitPosition
                            
                            ' wasteSize is the area between the last cut position and the start of the piece
                            wasteSize = fitPosition - leftCutPos
                            Logger.logDeep "wasteSize (exact): " & wasteSize
                            wastePieceSize = 0
                            
                            If wasteSize < 0 Then
                                ' wasteSize should never be below 0
                                Logger.logBug "  wasteSize < 0 , wasteSize: " & wasteSize
                            ElseIf wasteSize = 0 Then
                                ' Waste piece size as is
                                wastePieceSize = 0
                                ' Fits
                                fitFound = True
                            ElseIf wasteSize < cutWidth Then
                                ' Overlapping waste pieces
                                addOverlappingCuts = True
                                secondCutSize = cutWidth - wasteSize
                                wastePieceSize = 0
                                ' Overlapping cuts disabled
                                fitFound = False
                            ElseIf wasteSize = cutWidth Then
                                ' two cuts
                                addTwoCuts = True
                                wastePieceSize = 0
                                ' Fits!
                                fitFound = True
                            Else
                            
                                wastePieceSize = wasteSize - cutWidth
                            
                                ' Rounding adjustment is to make sure that the waste space is set to a rounded value
                                roundingAdjustmentUp = 10 - getRounding10(wasteSize - cutWidth)
                                If roundingAdjustmentUp = 10 Then
                                    roundingAdjustmentUp = 0
                                End If
                                roundingAdjustmentDown = -getRounding10(wasteSize - cutWidth)
                                
                                Logger.logDeep "  roundingAdjustmentUp: " & roundingAdjustmentUp & vbTab & "roundingAdjustmentDown: " & roundingAdjustmentDown

                                If thisChannelType.getRightCutMax(m) - startPosMin >= pieceMinLength + roundingAdjustmentDown And _
                                   thisChannelType.getRightCutMin(m) - thisChannelType.getLeftCutMax(n) <= pieceMaxLength + roundingAdjustmentDown Then
                                    wastePieceSize = wastePieceSize + roundingAdjustmentDown
                                    fitPosition = fitPosition + roundingAdjustmentDown
                                    Logger.logDeep "  Rounding down [wastePieceSize: " & wastePieceSize & ",  roundingAdjustmentDown: " & roundingAdjustmentDown & "]"
                                    ' Fits!
                                    fitFound = True
                                ElseIf thisChannelType.getRightCutMax(m) - startPosMin >= pieceMinLength + roundingAdjustmentUp And _
                                       thisChannelType.getRightCutMin(m) - thisChannelType.getLeftCutMax(n) <= pieceMaxLength + roundingAdjustmentUp Then
                                    wastePieceSize = wastePieceSize + roundingAdjustmentUp
                                    fitPosition = fitPosition + roundingAdjustmentUp
                                    Logger.logDeep "  Rounding up [wastePieceSize: " & wastePieceSize & ",  roundingAdjustmentUp: " & roundingAdjustmentUp & "]"
                                    ' Fits!
                                    fitFound = True
                                Else
                                    wastePieceSize = 0
                                    ' Fit here not possible
                                    ' TODO It might be possible by reexamining all previous tolerances here to find a fit
                                End If
                                
                            End If
                        
                            If fitFound Then
                                Exit For
                            End If
                            
                        End If

                    End If
                Next
                ' Since we found the right area (and no futher areas would be any better), there is nothing more to do than to exit the for loop and give up here
                Exit For
            End If
        Next
    End If
    
    If fitFound Then
        Logger.logDeep "  Fit was found"
        ' Should we add a waste piece?
        If fitPosition > leftCutPos Then
            
            ' Adjust accodring to marign:
            If Not usedMargin = 0 Then
                piece.usedTolerance = usedMargin
                piece.length = piece.length + piece.usedTolerance
            End If
            
            ' Is the area we want to fill larger than one cut?
            Logger.logDeep "  fitPosition: " & fitPosition & vbTab & "leftCutPos: " & leftCutPos & vbTab & "cutWidth: " & cutWidth & vbTab & "wastepiece-size: " & wastePieceSize
            If wastePieceSize > 0 Then
                ' Add waste piece
                addWastePiece wastePieceSize
            ElseIf addOverlappingCuts Then
                ' Add overlapping cut
                addCutPiece secondCutSize
            ElseIf addTwoCuts Then
                ' Add cut
                addCutPiece cutWidth
            End If
            
            ' Add cut
            addCutPiece cutWidth
            
            Logger.logDeep "  Adding a cut"
        End If
        
        ' Add piece
        piece.hprPlacement = enumHPRPlacement.bothSides
        piece.placed = True
        addPiece piece
    End If

    Logger.logDeep "  end sum:" & getSum


    placePieceC1 = piece.placed
End Function


Public Function placePieceB2(ByVal piece As CPiece, ByVal cutWidth As Long) As Boolean

    ' HPR on one side gives us flexibility as we can choose to turn the piece around
    ' TODO Figure out usedCutWidth
    
    Dim newLength As Long
    Dim binSum As Long
    Dim usedCutWidth As Long
    Dim lefttSidePos As Long
    Dim rightSidePos As Long
    Dim validCutArea_shorter_min As Long
    Dim validCutArea_shorter_max As Long
    Dim validCutArea_longer_min As Long
    Dim validCutArea_longer_max As Long
    Dim validCutArea_longer_min_fromStart As Long
    Dim validCutArea_longer_max_fromStart As Long

    '@Ignore UseMeaningfulName
    Dim n As Long
    Dim diffToRightCutAreaRounded As Long
    Dim diffToLeftCutAreaRounded As Long
    Dim holeStartUsable As Boolean
    Dim holeEndUsable As Boolean
    Dim wasteSpaceWidth_HPR_left As Long
    Dim wasteSpaceWidth_HPR_right As Long
    
    Dim roundingAdjustment_right As Long
    Dim roundingAdjustment_left As Long
    
    
    usedCutWidth = cutWidth
    
    ' Simplifications
    lefttSidePos = getSum
    rightSidePos = lefttSidePos + piece.length ' Right side of the piece

    Logger.logDeep " capacity: " & this.capacity
    Logger.logDeep " capacityCuttable: " & this.capacityCuttable
    Logger.logDeep " cutWidth: " & cutWidth
    Logger.logDeep " piece.length: " & piece.length
    Logger.logDeep " piece.allowedTolerance: " & piece.allowedTolerance
    Logger.logDeep " piece.allowedToleranceRoundedDown: " & piece.allowedToleranceRoundedDown
    Logger.logDeep " lefttSidePos: " & lefttSidePos
    Logger.logDeep " rightSidePos: " & rightSidePos
    
    Dim thisChannelType As CChannelType
    Set thisChannelType = Request.channelTypeSet.getChTypeFromKey(this.channelTypeKey)
    
    ' TODO Optimization possible for the cases where the two roundings here could have been combined to one
    ' TODO Bug when checking available length rounded we do not take care of the case where the piece is the last piece and the channel is a no rounded number and the piece takes up exacly the avilable space of the channel
    ' If last piece then allow rounded piece size if the piece takes up all the available space
    '   lastPieceCanBeNonRounded = True
    ' endif

    ' Check if the piece could be fitted because of it's length (most general condition)
    If piece.length - piece.allowedTolerance <= this.availableLength Then
        Logger.logDeep "  Piece has a possibility of fitting (it is smaller than free space or could be made smaller by using tolerance)"
        Logger.logDeep "  Checking HPR criteria for a possible fit:"
        
        ' Check if it fits with HPR on the left side as is
        If thisChannelType.isValidLeftHPR(lefttSidePos) Then
        
            Logger.logDeep "   Case 1: Piece fits with HPR on left side"
        
            ' Check how the pice fits:
           
            ' Piece fits perfectly without adjustments
            If piece.length = this.availableLength Then
            
                Logger.logDeep "    Fits exactly as leftSided"

                ' Add piece
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.leftSide
                addPiece piece
            
            ' Piece fits perfectly by using the tolerance
            ElseIf piece.length - piece.allowedTolerance <= this.availableLength _
               And piece.length + piece.allowedTolerance >= this.availableLength _
            Then
                Logger.logDeep "    Piece fits perfectly by using the tolerance"
                
                ' Adjust piece length by tolerance
                piece.usedTolerance = this.availableLength - piece.length

                Logger.logDeep "usedTolerance = " & piece.usedTolerance
                newLength = piece.length + piece.usedTolerance
                
                ' Add piece
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.leftSide
                piece.length = newLength
                Logger.logDeep "    Adding tolerance!, piece.usedTolerance=" & piece.usedTolerance
                addPiece piece
                
            ' Normal case
            Else
                Logger.logDeep "    Piece fits without using tolerance"
                
                ' Add piece
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.leftSide
                addPiece piece
                        
            End If
            
        ' Try to fit the piece as is with HPR on the RIGHT side as is
        ElseIf thisChannelType.isValidRightHPR(rightSidePos) Then
        
            Logger.logDeep "   Case 2: HPR on right side is a valid cut"
            
            ' Does it fit?
            If rightSidePos <= this.capacityCuttable Then
        
                Logger.logDeep "    fit found, fits with HPR right"
        
                ' Place
                piece.placed = True
                piece.hprPlacement = enumHPRPlacement.rightSide
                addPiece piece
            Else
                Logger.logDeep "    ends up in the cut-free space"
            End If
        
        Else
            Logger.logDeep "   Case 3: Piece does not fit with the HPR criteria as is"
            
            ' Piece does not fit the HPR criteria as is, now we have two options:
            ' Case 3.1: Try using the tolerance on the right side to adjust the piece length and make it fit
            ' > Can only be placed as HPR right
            ' Case 3.2: Add a waste pice to make the piece fit
            ' > Can be placed as HPR left or HPR right depending on which is closer
            
            ' For both we need to know the relevant cut_min and cut_max
            ' The case of adding or subtracting tolerance to the right side with left handed HPR has already been taken care of above.
        
            ' Figure out what lengths are relevant:

            validCutArea_shorter_min = 0
            validCutArea_shorter_max = 0
            validCutArea_longer_min = 0
            validCutArea_longer_max = 0
        
            binSum = getSum
            n = 1
            
            Logger.logDeep "    maxCutsLeft:" & vbTab & thisChannelType.leftCutsMax
            Logger.logDeep "    Finding the positions of the two holes closest to the end of the piece (HPR right)"
        
            ' Allright! so we got the relevant values
            Logger.logDeep "    binsum" & vbTab & binSum
            'Logger.logDeep "    n" & vbTab & "cutMin_lh" & vbTab & "cutMax_lh" & vbTab & "cutMin_rh" & vbTab & "cutMax_rh"
            
            ' Find the positions of the two holes closest to the end of the piece
            Do Until validCutArea_longer_min >= binSum + piece.length _
                  Or n = thisChannelType.rightCutsMax
                validCutArea_shorter_min = thisChannelType.getRightCutMin(n)
                validCutArea_shorter_max = thisChannelType.getRightCutMax(n)
                validCutArea_longer_min = thisChannelType.getRightCutMin(n + 1)
                validCutArea_longer_max = thisChannelType.getRightCutMax(n + 1)
                'Logger.logDeep n & vbTab & validCutArea_shorter_min & vbTab & validCutArea_shorter_max & vbTab & validCutArea_longer_min & vbTab & validCutArea_longer_max
                'If validCutArea_longer_min >= binSum + piece.length Then
                '   Logger.logDeep "Stop condition: validCutArea_longer_min >= binsum + piece.length" & vbTab & validCutArea_longer_min & " >= " & binSum & " + " & piece.length
                'End If
                n = n + 1
            Loop
        
            ' Allright! so we got the relevant values
            Logger.logDeep "     validCutArea_shorter_max: " & vbTab & validCutArea_shorter_min
            Logger.logDeep "     validCutArea_shorter_max: " & vbTab & validCutArea_shorter_max
            Logger.logDeep "     validCutArea_longer_min: " & vbTab & validCutArea_longer_min
            Logger.logDeep "     validCutArea_longer_max: " & vbTab & validCutArea_longer_max
            Logger.logDeep "    Case 3.1: Trying to use the tolerance on the right side to adjust the piece length and make it fit"
            
            ' Calculate how for off we are from the closest cut areas
            diffToLeftCutAreaRounded = round10up(rightSidePos - validCutArea_shorter_max)
            diffToRightCutAreaRounded = round10up(validCutArea_longer_min - rightSidePos)
    
            Logger.logDeep "     diffToLeftCutAreaRounded:" & vbTab & diffToLeftCutAreaRounded
            Logger.logDeep "     diffToRightCutAreaRounded:" & vbTab & diffToRightCutAreaRounded
    
            ' Stop condition, when diff to right hole is negative, we are already beyond the last hole, and nothing more is possible.
            If diffToRightCutAreaRounded > 0 Then

                ' If the distance to the right or left holes are within the tolerance
                If diffToLeftCutAreaRounded <= piece.allowedToleranceRoundedDown _
                Or diffToRightCutAreaRounded <= piece.allowedToleranceRoundedDown Then
                
                    Logger.logDeep "     Distance to hole is within the tolerance"
                
                    If diffToLeftCutAreaRounded <= diffToRightCutAreaRounded Then
                        ' We are closest to the left cutarea
                        Logger.logDeep "     closest to the left cutarea (or equal)"
                        piece.usedTolerance = -diffToLeftCutAreaRounded
                        Logger.logDeep "     Using tolerance!, piece.usedTolerance=" & piece.usedTolerance
                    Else
                        ' We are closest to the right cutarea
                        piece.usedTolerance = diffToRightCutAreaRounded
                        If diffToRightCutAreaRounded > 0 Then
                            Logger.logDeep "     Using tolerance!, piece.usedTolerance=" & piece.usedTolerance
                        End If
                        Logger.logDeep "     closest to the right cutarea"
                    End If
                    
                    ' Adjust piece length by tolerance
                    Logger.logDeep "     Adjusting piece length by tolerance"
                    Logger.logDeep "     piece.usedTolerance = " & piece.usedTolerance
                    newLength = piece.length + piece.usedTolerance
                    piece.length = newLength
    
                    ' Add piece
                    piece.hprPlacement = enumHPRPlacement.rightSide
                    piece.placed = True
                    addPiece piece
                
                ' The piece can not be placed in its current position, even by using tolerance
                ' Try to fit the piece by adding a waste piece
                Else
                
                    Logger.logDeep "     The piece cannot be placed in its current position, even by using tolerance [allowedToleranceRoundedDown: " & piece.allowedToleranceRoundedDown & "]"
                    Logger.logDeep "    Case 3.2: Trying to add a waste pice to make the piece fit"

                    validCutArea_longer_min_fromStart = 0
                    validCutArea_longer_max_fromStart = 0
                    holeStartUsable = False
                    holeEndUsable = False
                    
                    ' Find the positions of the next cutarea from the start of the piece
                    ' where the difference between the binsum and validCutArea_longer_min_fromStart is at least cutWidth wide
                    Logger.logDeep "     Finding the position of the next valid cutarea from the start of the piece"
                    Logger.logDeep "     where the difference between the binsum and validCutArea_longer_min_fromStart is at least cutWidth wide"
                    
                    n = 1
                    
                    Do Until validCutArea_longer_min_fromStart >= binSum + cutWidth Or n = thisChannelType.leftCutsMax
                        roundingAdjustment_left = getRoundingAdj10(thisChannelType.getLeftCutMin(n) - binSum - cutWidth)
                        validCutArea_longer_min_fromStart = thisChannelType.getLeftCutMin(n) + roundingAdjustment_left
                        validCutArea_longer_max_fromStart = thisChannelType.getLeftCutMax(n)
                        Logger.logDeep "     n: " & n & ", roundingAdjustment_left: getRoundingAdj10(" & thisChannelType.getLeftCutMin(n) & " - " & binSum & " - " & cutWidth & ") = " & roundingAdjustment_left
                        n = n + 1
                    Loop
                    
                    Logger.logDeep "     validCutArea_longer_min_fromStart:" & vbTab & validCutArea_longer_min_fromStart
                    Logger.logDeep "     validCutArea_longer_max_fromStart:" & vbTab & validCutArea_longer_max_fromStart
                    
                    ' Make sure the loop did not run to the end without a valid value
                    If validCutArea_longer_min_fromStart >= binSum + cutWidth Then
                        holeStartUsable = True
                    End If
                    Logger.logDeep "     holeStartUsable:" & vbTab & holeStartUsable
                    
                    ' Find the positions of the next hole from the start of the piece
                    ' where the difference between the binsum and cutMin_rightHoleStart is at least cutWidth wide
                    Logger.logDeep "     Finding the position of the next valid cutarea from the start of the piece"
                    Logger.logDeep "     where the difference between the binsum and validCutArea_longer_min is at least cutWidth wide"
                    
                    
                    n = 1
                    validCutArea_longer_min = 0
                    validCutArea_longer_max = 0
                    Logger.logDeep validCutArea_longer_min & " >= " & binSum & " + " & piece.length & " + " & cutWidth & " Or " & n & " = " & thisChannelType.rightCutsMax
                    
                    Do Until validCutArea_longer_min >= binSum + piece.length + cutWidth _
                    Or n = thisChannelType.rightCutsMax
                        roundingAdjustment_right = getRoundingAdj10(thisChannelType.getRightCutMin(n + 1) - binSum - cutWidth)
                        validCutArea_longer_min = thisChannelType.getRightCutMin(n + 1) + roundingAdjustment_right
                        validCutArea_longer_max = thisChannelType.getRightCutMax(n + 1)
                        Logger.logDeep "     n: " & n & ", roundingAdjustment_right: getRoundingAdj10(" & thisChannelType.getRightCutMin(n + 1) & " - " & binSum & " - " & cutWidth & ") = " & roundingAdjustment_right
                        n = n + 1
                    Loop
                    
                    Logger.logDeep "     validCutArea_longer_min:" & vbTab & validCutArea_longer_min
                    Logger.logDeep "     validCutArea_longer_max:" & vbTab & validCutArea_longer_max
                    
                    ' Make sure the loop did not run to the end without a valid value
                    If validCutArea_longer_min >= binSum + piece.length + cutWidth Then
                        holeEndUsable = True
                    End If
                    
                    ' Now we got all the values needed in order to calculate the properties of the waste piece.
                    wasteSpaceWidth_HPR_left = validCutArea_longer_min_fromStart - binSum
                    wasteSpaceWidth_HPR_right = validCutArea_longer_min - binSum - piece.length
                    
                    Logger.logDeep "     wasteSpaceWidth_HPR_left: (" & validCutArea_longer_min_fromStart & " - " & binSum & ") = " & wasteSpaceWidth_HPR_left
                    Logger.logDeep "     wasteSpaceWidth_HPR_right: (" & validCutArea_longer_min & " - " & binSum & " - " & piece.length & ") = " & wasteSpaceWidth_HPR_right
                    Logger.logDeep "     holeEndUsable:" & vbTab & holeEndUsable
                    
                    ' HPR Left
                    ' Also determine what gives less waste HPR left or HPR right:
                    ' Is it possible to add the piece here?
                    If wasteSpaceWidth_HPR_left <= wasteSpaceWidth_HPR_right _
                       And thisChannelType.isValidLeftHPR(validCutArea_longer_min_fromStart) _
                       And piece.length + wasteSpaceWidth_HPR_left <= this.availableLength Then
                        ' TODO Add support for using the tolerance here
                        ' TODO Add support for cutfree space here

                        Logger.logDeep "      A) Setting piece as HPR left"
                     
                        If wasteSpaceWidth_HPR_left > cutWidth Then
                            ' Add waste pice
                            addWastePiece wasteSpaceWidth_HPR_left - cutWidth
                        End If
    
                        ' Add cut
                        addCutPiece usedCutWidth
                        
                        ' Add piece
                        piece.hprPlacement = enumHPRPlacement.leftSide
                        piece.placed = True
                        addPiece piece

                    ' HPR Right
                    ' Is it possible to add the piece here?
                    ElseIf thisChannelType.isValidRightHPR(validCutArea_longer_min) _
                           And piece.length + wasteSpaceWidth_HPR_left <= this.availableLength Then
                        ' TODO Add support for using the tolerance here
                        ' TODO Add support for cutfree space here
                        
                        Logger.logDeep "      B) Setting piece as HPR right"
                    
                        If wasteSpaceWidth_HPR_right > cutWidth Then
                            ' Add waste pice
                            addWastePiece wasteSpaceWidth_HPR_right - cutWidth
                        End If
    
                        ' Add cut
                        addCutPiece usedCutWidth
                        
                        ' Add piece
                        piece.hprPlacement = enumHPRPlacement.rightSide
                        piece.placed = True
                        addPiece piece
                    End If
                    
                End If
            Else
                Logger.logDeep "   Went beyond the last hole, not possible to place piece in this bin"
            End If
        End If
    Else
        Logger.logDeep "Piece length is longer than available lenght"
    End If
    
    placePieceB2 = piece.placed
End Function


Public Function placePieceC2(ByVal piece As CPiece, ByVal cutWidth As Long) As Boolean

    ' HPR on both sides is the hardest condition to fulfill
    Dim leftCutPos As Long
    Dim rightCutPos As Long
    '@Ignore UseMeaningfulName
    Dim n As Long
    '@Ignore UseMeaningfulName
    Dim m As Long
    
    Dim fitFound As Boolean
    Dim fitPosition As Long
    Dim leftOk As Boolean
    Dim rightOk As Boolean

    Dim usedMargin As Long
    Dim startPosMin As Long
    Dim areaMaxSize As Long
    Dim areaMinSize As Long
    Dim pieceMinLength As Long
    Dim pieceMaxLength As Long
    
    Dim wastePieceSize As Long
    Dim wasteSize As Long
    
    Dim addOverlappingCuts As Boolean
    Dim addTwoCuts As Boolean
    Dim secondCutSize As Long
    
    addOverlappingCuts = False
    addTwoCuts = False
    secondCutSize = 0

    Dim roundingAdjustmentUp As Long
    Dim roundingAdjustmentDown As Long

    Dim thisChannelType As CChannelType
    Set thisChannelType = Request.channelTypeSet.getChTypeFromKey(this.channelTypeKey)

    fitFound = False
    usedMargin = 0

    ' Grab the next available cutting position and see if it works
    leftCutPos = getSum
    rightCutPos = leftCutPos + piece.length

    Logger.logDeep "  Checking if the two cuts are valid:"
    ' Left
    Logger.logDeep "  isValidLeftHPR(" & leftCutPos & ")"
    leftOk = thisChannelType.isValidLeftHPR(leftCutPos)
    'Logger.logDeep "  >Left side valid = " & leftOk
    ' Right
    Logger.logDeep "  isValidRightHPR(" & rightCutPos & ")"
    rightOk = thisChannelType.isValidRightHPR(rightCutPos)
    Logger.logDeep "  >Right side valid: " & rightOk
    
    
    ' Check if the sides are valid accoding to HPR
    If leftOk And rightOk Then
        Logger.logDeep "  Left and right are ok, check if a right cut is possible [capacityCuttable: " & this.capacityCuttable & ", rightCutPos: " & rightCutPos & ", cutWidth: " & cutWidth & "]"
        If rightCutPos <= this.capacityCuttable Then
            ' It fits direcly!
            fitFound = True
            fitPosition = leftCutPos
            Logger.logDeep "  >Right cut is possible"
        Else
            Logger.logDeep "  >Right cut is not possible"
        End If
    
    ' Does not fit in place accodring to HPR, see if it would fit if we add a waste piece to the left
    Else
        Logger.logDeep "  Does not fit in place accodring to HPR, see if it would fit if we add a waste piece to the left [leftCutPos: " & vbTab & leftCutPos & ", thisChannelType.maxCutsLeft: " & vbTab & thisChannelType.leftCutsMax & "]"
        Logger.logDeep "  Left side: Looking for a fit (" & thisChannelType.leftCutsMax & " positions to check)"
        
        ' Find the next cut area for the left side
        For n = 1 To thisChannelType.leftCutsMax
            'Logger.logDeep "n: " & vbTab & n
            
            ' Make sure we are not trying to use an area that is to the left of the current fill position of the bin
            startPosMin = thisChannelType.getLeftCutMin(n)
            If leftCutPos > startPosMin Then
                startPosMin = leftCutPos
            End If
            
            ' Now check that the available cut area is big enough to insert a cut into on the left side
            If thisChannelType.getLeftCutMax(n) - leftCutPos >= cutWidth Then
                ' Yes a cut is possible here
                Logger.logDeep "  >Found a left fit [n=" & n & "]"
                
                Logger.logDeep "  Right side: Looking for a fit (" & thisChannelType.rightCutsMax & " positions to check)"
                
                Logger.logDeep "  areaMinSize: " & vbTab & "areaMaxSize: " & vbTab & "piece.length:" & vbTab & "pieceMinLength:" & vbTab & "pieceMaxLength:"
                
                ' Does the piece fit here?
                ' Find the right side to land the cut
                ' TODO Possible optimization start from n and not from 1
                For m = 1 To thisChannelType.rightCutsMax
                    
                    ' Pass over all where the cutMinRight < cutMaxLeft
                    If thisChannelType.getRightCutMin(m) > thisChannelType.getLeftCutMax(n) Then

                        areaMinSize = round10up(thisChannelType.getRightCutMin(m) - thisChannelType.getLeftCutMax(n))
                        areaMaxSize = round10down(thisChannelType.getRightCutMax(m) - startPosMin)

                        'Logger.logDeep thisChannelType.getCutMinRight(m) & " - " & thisChannelType.getCutMaxLeft(n) & " ~=" & areaMinSize
                        'Logger.logDeep thisChannelType.getCutMaxRight(m) & " - " & startPosMin & " ~=" & areaMaxSize

                        pieceMinLength = piece.length - piece.allowedToleranceRoundedDown
                        pieceMaxLength = piece.length + piece.allowedToleranceRoundedDown

                        ' Write table
                        Logger.logDeep "  " & areaMinSize & vbTab & vbTab & vbTab & vbTab & areaMaxSize & vbTab & vbTab & vbTab & vbTab & piece.length & vbTab & vbTab & vbTab & pieceMinLength & vbTab & vbTab & vbTab & pieceMaxLength

                        ' Most general condition, check that the piece would fit if we used the margin
                        ' Check if the area is large enough and that the area is small enough
                        If areaMaxSize >= pieceMinLength And _
                           areaMinSize <= pieceMaxLength Then

                            ' Check if we need to use a margin
                            If areaMaxSize < piece.length Then
                                ' Negative margin
                                usedMargin = areaMaxSize - piece.length
                            ElseIf areaMinSize > piece.length Then
                                ' Positive margin
                                usedMargin = areaMinSize - piece.length
                            End If

                            ' Where exacly does it fit?
                            fitPosition = thisChannelType.getRightCutMin(m) - piece.length + usedMargin
                            Logger.logDeep "fitPosition (exact): " & fitPosition
                            
                            ' wasteSize is the area between the last cut position and the start of the piece
                            wasteSize = fitPosition - leftCutPos
                            Logger.logDeep "wasteSize (exact): " & wasteSize
                            wastePieceSize = 0
                            
                            If wasteSize < 0 Then
                                ' wasteSize should never be below 0
                                Logger.logBug "  wasteSize < 0 , wasteSize: " & wasteSize
                            ElseIf wasteSize = 0 Then
                                ' Waste piece size as is
                                wastePieceSize = 0
                                ' Fits
                                fitFound = True
                            ElseIf wasteSize < cutWidth Then
                                ' Overlapping waste pieces
                                addOverlappingCuts = True
                                secondCutSize = cutWidth - wasteSize
                                wastePieceSize = 0
                                ' Overlapping cuts disabled
                                fitFound = False
                            ElseIf wasteSize = cutWidth Then
                                ' two cuts
                                addTwoCuts = True
                                wastePieceSize = 0
                                ' Fits!
                                fitFound = True
                            Else
                            
                                wastePieceSize = wasteSize - cutWidth
                            
                                ' Rounding adjustment is to make sure that the waste space is set to a rounded value
                                roundingAdjustmentUp = 10 - getRounding10(wasteSize - cutWidth)
                                If roundingAdjustmentUp = 10 Then
                                    roundingAdjustmentUp = 0
                                End If
                                roundingAdjustmentDown = -getRounding10(wasteSize - cutWidth)
                                
                                Logger.logDeep "  roundingAdjustmentUp: " & roundingAdjustmentUp & vbTab & "roundingAdjustmentDown: " & roundingAdjustmentDown

                                If thisChannelType.getRightCutMax(m) - startPosMin >= pieceMinLength + roundingAdjustmentDown And _
                                   thisChannelType.getRightCutMin(m) - thisChannelType.getLeftCutMax(n) <= pieceMaxLength + roundingAdjustmentDown Then
                                    wastePieceSize = wastePieceSize + roundingAdjustmentDown
                                    fitPosition = fitPosition + roundingAdjustmentDown
                                    Logger.logDeep "  Rounding down [wastePieceSize: " & wastePieceSize & ",  roundingAdjustmentDown: " & roundingAdjustmentDown & "]"
                                    ' Fits!
                                    fitFound = True
                                ElseIf thisChannelType.getRightCutMax(m) - startPosMin >= pieceMinLength + roundingAdjustmentUp And _
                                       thisChannelType.getRightCutMin(m) - thisChannelType.getLeftCutMax(n) <= pieceMaxLength + roundingAdjustmentUp Then
                                    wastePieceSize = wastePieceSize + roundingAdjustmentUp
                                    fitPosition = fitPosition + roundingAdjustmentUp
                                    Logger.logDeep "  Rounding up [wastePieceSize: " & wastePieceSize & ",  roundingAdjustmentUp: " & roundingAdjustmentUp & "]"
                                    ' Fits!
                                    fitFound = True
                                Else
                                    wastePieceSize = 0
                                    ' Fit here not possible
                                    ' TODO It might be possible by reexamining all previous tolerances here to find a fit
                                End If
                                
                            End If
                        
                            If fitFound Then
                                Exit For
                            End If
                            
                        End If

                    End If
                Next
                ' Since we found the right area (and no futher areas would be any better), there is nothing more to do than to exit the for loop and give up here
                Exit For
            End If
        Next
    End If
    
    If fitFound Then
        Logger.logDeep "  Fit was found"
        ' Should we add a waste piece?
        If fitPosition > leftCutPos Then
            
            ' Adjust accodring to marign:
            If Not usedMargin = 0 Then
                piece.usedTolerance = usedMargin
                piece.length = piece.length + piece.usedTolerance
            End If
            
            ' Is the area we want to fill larger than one cut?
            Logger.logDeep "  fitPosition: " & fitPosition & vbTab & "leftCutPos: " & leftCutPos & vbTab & "cutWidth: " & cutWidth & vbTab & "wastepiece-size: " & wastePieceSize
            If wastePieceSize > 0 Then
                ' Add waste piece
                addWastePiece wastePieceSize
            ElseIf addOverlappingCuts Then
                ' Add overlapping cut
                addCutPiece secondCutSize
            ElseIf addTwoCuts Then
                ' Add cut
                addCutPiece cutWidth
            End If
            
            ' Add cut
            addCutPiece cutWidth
            
            Logger.logDeep "  Adding a cut"
        End If
        
        ' Add piece
        piece.hprPlacement = enumHPRPlacement.bothSides
        piece.placed = True
        addPiece piece
    End If

    Logger.logDeep "  end sum:" & getSum


    placePieceC2 = piece.placed
End Function


Private Sub addCutPiece(ByVal cutWidth As Long)
    'Logger.logInfo "Adding cut, cutWidth=" & cutWidth & ", new pieceCount=" & (pieceCount + 1)
    Dim cutPiece As CPiece
    Set cutPiece = New CPiece
    cutPiece.pieceType = enumPieceType.cut
    cutPiece.length = cutWidth
    cutPiece.placed = True
    addPiece cutPiece
End Sub


Private Sub addWastePiece(ByVal length As Long)
    'Logger.logInfo "Adding waste piece, length=" & length & ", new pieceCount=" & (pieceCount + 1)
    Dim wastePiece As CPiece
    Set wastePiece = New CPiece
    wastePiece.pieceType = enumPieceType.waste
    wastePiece.length = length
    wastePiece.placed = True
    addPiece wastePiece
End Sub


Private Function fillWasteSpace( _
    ByVal wasteSpaceWidthIn As Long, _
    ByVal cutWidth As Long, _
    ByVal allowUseOfRemainingTolerance As Boolean, _
    Optional ByRef piece As CPiece _
) As Boolean
    Dim wasteSpaceWidth As Long
    wasteSpaceWidth = wasteSpaceWidthIn
    If wasteSpaceWidth < cutWidth Then
        ' Too small space, check if we are allowed to use margin:
        Logger.logInfo "Too small space, check if we are allowed to use margin:"
        If allowUseOfRemainingTolerance Then
            If piece.allowedTolerance - piece.usedTolerance >= wasteSpaceWidth Then
                Logger.logInfo "but we can use the use margin instead of the waste piece"
                piece.usedTolerance = piece.usedTolerance + wasteSpaceWidth
                piece.length = piece.length + wasteSpaceWidth
                Logger.logInfo "using tolerance: " & piece.usedTolerance
                Logger.logInfo "new piece length: " & piece.length
                wasteSpaceWidth = 0
                fillWasteSpace = True
            Else
                fillWasteSpace = False
                Logger.logInfo "and we cannot use margin instead of the waste piece"
            End If
        Else
            fillWasteSpace = False
            Logger.logInfo "Unable to fill waste space as it is smaller than the width of one cut."
        End If
    ElseIf wasteSpaceWidth = cutWidth Then
        ' Add one cut
        addCutPiece cutWidth
        fillWasteSpace = True
    ElseIf wasteSpaceWidth > cutWidth And wasteSpaceWidth < cutWidth Then
        ' Add one cut and part of one cut
        Dim firstCutWidth As Long
        firstCutWidth = wasteSpaceWidth - cutWidth
        addCutPiece firstCutWidth
        addCutPiece cutWidth
        fillWasteSpace = True
    ElseIf wasteSpaceWidth = cutWidth + cutWidth Then
        ' Add two cuts
        addCutPiece cutWidth
        addCutPiece cutWidth
        fillWasteSpace = True
    Else
        ' Add one cut, a waste piece and another cut
        Dim wastePieceWidth As Long
        wastePieceWidth = wasteSpaceWidth - cutWidth
        addWastePiece wastePieceWidth
        addCutPiece cutWidth
        fillWasteSpace = True
    End If
End Function


'
Public Sub updateAvailableLengths()
    this.availableLength = this.capacity - getSum
    'this.availableLengthRounded = round10down(this.availableLength)
    this.availableLengthBeforeCutFreeSpace = this.availableLength - Settings.cutFreeSpaceEnd
    'this.availableLengthBeforeCutFreeSpaceRounded = round10down(this.availableLengthBeforeCutFreeSpace)
End Sub


Public Function couldBeFittedAtAll(ByVal piece As CPiece) As Boolean
    ' Could it at all be possible to fit this piece?
    ' No rounding is needed for this check
    couldBeFittedAtAll = piece.length <= this.availableLength + piece.allowedTolerance
End Function


' Checks if the piece ends up in the cut-free space
Public Function cutAfterPieceEndsInCutFreeSpace( _
    ByVal piece As CPiece, _
    ByVal cutWidth As Long _
) As Boolean
    ' Is it larger than the available length before the cut free space
    '@Ignore BooleanAssignedInIfElse
    If piece.length + cutWidth > round10down(this.availableLengthBeforeCutFreeSpace + piece.allowedTolerance) Then
        cutAfterPieceEndsInCutFreeSpace = True
    Else
        cutAfterPieceEndsInCutFreeSpace = False
    End If
End Function


' Checks wether the piece is larger than or equal to the cut-free space (or if it is able to be made equal by using the tolerance)
Public Function largerThanOrEqualToCutFreeSpaceUsingTolerance( _
    ByVal piece As CPiece, _
    ByVal cutFreeSpaceEnd As Long _
) As Boolean
    '@Ignore BooleanAssignedInIfElse
    If piece.length >= round10up(cutFreeSpaceEnd - piece.allowedTolerance) Then
        largerThanOrEqualToCutFreeSpaceUsingTolerance = True
    Else
        largerThanOrEqualToCutFreeSpaceUsingTolerance = False
    End If
End Function


' Return the tolerance needed if the piece was to be placed over the cut-free space
' The value returned is always rounded to nearest 10, rounded in the safe direction
' Returns 0 if no tolerance is needed, for example if the piece is larger than cut-free space.
Public Function getToleranceNeededToPlaceOverCutFreeSpaceRounded( _
    ByVal piece As CPiece, _
    ByVal cutFreeSpaceEnd As Long _
) As Long
    ' Try to enlarge the piece, this is rounded up as it needs to cover at least the width of the cutFree space
    getToleranceNeededToPlaceOverCutFreeSpaceRounded = round10up(cutFreeSpaceEnd - piece.length)
    ' If we got a negative number it meant that the piece was actually larger then the cutfree space already
    If getToleranceNeededToPlaceOverCutFreeSpaceRounded < 0 Then
        ' It will not need to be extended but it might need to be shortened
        ' Check if we need to shrink it in order to fit it
        ' If the piece is longer than the cut-free space, we also might need to use tolerance in order for the
        ' piece to fit in the availiable space + cutFree space
        If piece.length > this.availableLength + cutFreeSpaceEnd Then
            getToleranceNeededToPlaceOverCutFreeSpaceRounded = round10down(this.availableLength + cutFreeSpaceEnd)
        Else
            getToleranceNeededToPlaceOverCutFreeSpaceRounded = 0
        End If
    End If
End Function






Attribute VB_Name = "CBinSet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CBinSet class

' A CBinSet is a collection of CBin objects and has functions to handle
' the collection (like calculating the fillrate).
' A CBinSet always has a common channelTypeKey

Private Type TBinSet
    bins() As CBin              ' Keeps all CBin objects
    unplaceable() As CPiece     ' Keeps all unplaceable pieces
    binCount As Long
    unplaceableCount As Long
    length As Long              ' The actual length of the channel
    capacity As Long            ' The usable length of the channel
    capacityCuttable As Long    ' Capacity minus Cutfree space end
    channelTypeKey As String    '
End Type

Private this As TBinSet

Private Sub class_initialize()
    ReDim this.bins(1 To 1)
    ReDim this.unplaceable(1 To 1)
    this.binCount = 0                    ' Initialize binCount to zero
    this.unplaceableCount = 0
    this.length = 0                      '
    this.capacity = 0                    ' Set capacity
    this.capacityCuttable = 0
    this.channelTypeKey = vbNullString   ' Initialize channel type to an empty string (not set)
End Sub

Public Sub setValues( _
    ByVal length As Long, _
    ByVal capacity As Long, _
    ByVal capacityCuttable As Long, _
    ByVal channelTypeKey As String _
)
    this.length = length
    this.capacity = capacity
    this.capacityCuttable = capacityCuttable
    this.channelTypeKey = channelTypeKey
End Sub

Public Property Get getBins() As CBin()
    '@Ignore ObjectVariableNotSet
    getBins = this.bins
End Property

Public Property Get count() As Long
    count = this.binCount
End Property

Public Property Get unplaceableCount() As Long
    unplaceableCount = this.unplaceableCount
End Property

Public Property Get getBin(ByVal binNo As Long) As CBin
    Set getBin = this.bins(binNo)
End Property

Public Property Get capacity() As Long
    capacity = this.capacity
End Property

Public Property Get getUnplaceablePieces() As CPiece()
    '@Ignore ObjectVariableNotSet
    getUnplaceablePieces = this.unplaceable
End Property

Public Property Get channelTypeKey() As String
    channelTypeKey = this.channelTypeKey
End Property

Public Property Get getUnplaceablePiece(ByVal unplaceableNo As Long) As CPiece
    Set getUnplaceablePiece = this.unplaceable(unplaceableNo)
End Property


' Adds a CBin to the bins array
Public Sub addBin(ByRef bin As CBin)
    this.binCount = this.binCount + 1
    ReDim Preserve this.bins(1 To this.binCount)
    '@Ignore ObjectVariableNotSet
    Set this.bins(this.binCount) = bin
End Sub

Public Function createBin() As CBin
    Set createBin = New CBin
    ' Inherit from the CBinSet
    createBin.setValues _
        length:=this.length, _
        capacity:=this.capacity, _
        capacityCuttable:=this.capacityCuttable, _
        channelTypeKey:=this.channelTypeKey
End Function


' Adds a CPiece to the unplacable array
Public Sub addUnplaceable(ByVal piece As CPiece)
    this.unplaceableCount = this.unplaceableCount + 1
    ReDim Preserve this.unplaceable(1 To this.unplaceableCount)
    '@Ignore ObjectVariableNotSet
    Set this.unplaceable(this.unplaceableCount) = piece
End Sub


' Removes the last CBin from the array
'Public Sub removeLastBin()
'    this.binCount = this.binCount - 1
'    ReDim Preserve this.bins(1 To this.binCount)
'End Sub


' Adds an existing CBin to the bins array
'Public Sub addExistingBin(ByVal bin As CBin)
'    this.binCount = this.binCount + 1
'    ReDim Preserve this.bins(1 To this.binCount)
'    Set this.bins(this.binCount) = bin
'End Sub


Public Sub clearBins()
    ReDim this.bins(1 To 1)
    this.binCount = 0
    addBin createBin
End Sub

Public Sub clearBinsDontAddOne()
    ReDim this.bins(1 To 1)
    this.binCount = 0
End Sub

' Returns the total capacity of the bin set
Public Function getTotalCapacity() As Long
    getTotalCapacity = 0
    Dim binNo As Long
    For binNo = 1 To this.binCount
        getTotalCapacity = getTotalCapacity + this.bins(binNo).capacity
    Next
End Function

' Returns the total length of the bin set
Public Function getTotalLength() As Long
    getTotalLength = 0
    Dim binNo As Long
    For binNo = 1 To this.binCount
        getTotalLength = getTotalLength + this.bins(binNo).length
    Next
End Function


' Returns the sum of all the in lengths in the CBinSet
Public Function getUsefullSum() As Long
    getUsefullSum = 0
    Dim binNo As Long
    For binNo = 1 To this.binCount
        getUsefullSum = getUsefullSum + this.bins(binNo).getUsefullSum()
    Next
End Function


' Returns the sum of all waste pieces in the CBinSet
'Public Function getWasteSum() As Long
'    getWasteSum = 0
'    Dim binNo As Long
'    For binNo = 1 To this.binCount
'        getWasteSum = getWasteSum + this.bins(binNo).getWasteSum
'    Next
'End Function

' Returns the wasted space
Public Function getWaste() As Long
    getWaste = getTotalCapacity() - getUsefullSum()
End Function


' Returns the fill rate in %
'Public Function getFillrate() As Double
'    getFillrate = (getUsefullSum() / getTotalCapacity()) * 100
'End Function


' Returns the waste rate in %
'Public Function getWasteRate() As Double
'    getWasteRate = 100 - (getWaste() / getTotalCapacity()) * 100
'End Function


Public Sub orderByFillrateDescending()
    qSortBinsInPlace inputArray:=this.bins, lb:=1, ub:=this.binCount, descending:=True
End Sub


'Public Sub orderByFillrateAscending()
'    qSortBinsInPlace inputArray:=bins, lb:=1, ub:=this.binCount, descending:=False
'End Sub


'Public Sub orderByWastRatePlusUnusedSpaceDescending(ByRef pgForm As ProgressForm)
'    qSortBinsByWastePlusUnusedSpaceInPlace inputArray:=bins, lb:=1, ub:=this.binCount, maxlb:=0, minub:=0, pgForm:=pgForm, descending:=True
'End Sub


Public Sub orderByWastRatePlusUnusedSpaceAscending(ByRef pgForm As ProgressForm)
    If this.binCount > 0 Then
        qSortBinsByWastePlusUnusedSpaceInPlace inputArray:=this.bins, lb:=1, ub:=this.binCount, maxlb:=0, minub:=0, pgForm:=pgForm, descending:=False
        'Logger.logInfo "  Sorted " & this.binCount & " bins"
    Else
        'Logger.logBug "  Empty bin encountered when sorting"
    End If
End Sub


' Debug function
' Prints the sum for each CBin in bins
'Public Sub printBinSums()
'    Logger.logInfo "Bins sums:"
'    Dim binNo As Long
'    For binNo = 1 To this.binCount
'        Logger.logInfo binNo & " " & this.bins(binNo).getSum
'    Next binNo
'End Sub


' Debug function
' Prints the piece count for each CBin in bins
'Public Sub printBinPieaceCount()
'    Dim binNo As Long
'    Logger.logInfo "Bin peace counts:"
'    For binNo = 1 To this.binCount
'        Logger.logInfo binNo & " " & this.bins(binNo).pieceCount
'    Next binNo
'End Sub


' Debug function
' Checks if bins are sorted descending/ascending acording to each bin's sum
'Public Function checkSorting(orderDescending As Boolean) As Boolean
'    Dim previousBin As CBin
'    Dim binNo As Long
'    checkSorting = True
'    For binNo = 1 To this.binCount
'        If this.binCount > binNo Then
'            If orderDescending = True Then
'                If this.bins(binNo).getSum < previousBin.getSum Then
'                    checkSorting = False
'                    Exit Function
'                End If
'            Else
'                If this.bins(binNo).getSum > previousBin.getSum Then
'                    checkSorting = False
'                    Exit Function
'                End If
'            End If
'        End If
'        previousBin = this.bins(binNo)
'    Next binNo
'End Function


' Returns a CBinSet consisting of the unique bins from this binset
'Public Function getUniqueBinSet(ByRef lastProfileNo As Long) As CBinSet
'
'    ' The logic of ths function is a little convoluted
'    ' The reason is that it is hard to change to quantity of a bin that has been added to the binset
'    ' Therefore kept in the tmpBin variable until the next unique bin is encountered
'    ' if another bin of the same kind is encountered, the quantity of the tmpBin can be updated.
'    ' Lastly the last bin that is stored in tmpBin is added.
'
'    Dim tmpBin As CBin
'    Dim binNo As Long
'    Dim pieceNo As Long
'    Dim isEqualTo As Boolean
'    Dim thisPiece As CPiece
'    Dim previousPiece As CPiece
'
'    Set getUniqueBinSet = New CBinSet
'    ' Copy the properties of this CBinSet to the unique set
'    getUniqueBinSet.capacity = capacity
'    getUniqueBinSet.capacityCuttable = capacityCuttable
'    getUniqueBinSet.channelTypeKey = channelTypeKey
'    Logger.logInfo "getUniqueBinSet: channelTypeKey=" & channelTypeKey
'
'    ' Loop through all bins, see if they are unique and if so add them to the uniqueBinSet
'    For binNo = 1 To this.binCount
'        'If this.bins(binNo).channelTypeKey = vbNullString Then Logger.logInfo "this.bins(" & binNo & ").channelTypeKey=" & this.bins(binNo).channelTypeKey
'        If binNo = 1 Then                ' Always use the first profile
'            Set tmpBin = getCopy(binNo)
'            tmpBin.quantity = 1
'            'tmpBin.profileNo = lastProfileNo + binNo
'        Else
'            ' Check if the bins are equal:
'            isEqualTo = True
'            ' This checker assumes that the bins are sorted
'            ' so it only needs to check the current bin with the previous bin
'            If this.bins(binNo).pieceCount = this.bins(binNo - 1).pieceCount Then
'                ' Check all pieces
'                For pieceNo = 1 To this.bins(binNo).pieceCount
'                    Set thisPiece = this.bins(binNo).getPieceCopy(pieceNo)
'                    Set previousPiece = this.bins(binNo - 1).getPieceCopy(pieceNo)
'
'                    If Not thisPiece.length = previousPiece.length Or _
'                    Not thisPiece.hprPlacement = previousPiece.hprPlacement Or _
'                    Not thisPiece.pieceType = previousPiece.pieceType Or _
'                    Not thisPiece.placed = previousPiece.placed Or _
'                    Not thisPiece.channelTypeKey = previousPiece.channelTypeKey Then
'                        isEqualTo = False
'                        Exit For
'                    End If
'                Next
'            Else
'                isEqualTo = False
'            End If
'
'            If isEqualTo = False Then
'                ' Add Previous bin (as the first bin is always saved here there should always be one available)
'                getUniqueBinSet.addExistingBin tmpBin
'
'                ' Save this bin for adding later
'                Set tmpBin = getCopy(binNo)
'                tmpBin.quantity = 1
'                'tmpBin.profileNo = lastProfileNo + binNo
'            Else
'                ' This bin was just a copy of the bin above it, just add one to the quantity
'                tmpBin.quantity = tmpBin.quantity + 1
'            End If
'        End If
'    Next
'    ' Add the last bin saved bin
'    getUniqueBinSet.addExistingBin tmpBin
'
'    ' Update lastProfileNo (send by reference)
'    lastProfileNo = lastProfileNo + binNo
'End Function


' Marks profiles, compares this profile with the previous, if it is different mark this profile
' Also counts how the quantity of that piecetype and stores in quantity
Public Sub markUniqueProfiles()
    ' Relies on the fact that bins are always sorted so we only need to compare to the previous one
    Dim binNo As Long
    Dim binNoToCount As Long
    For binNo = 1 To this.binCount
        ' Always mark the first profile
        If binNo = 1 Then
            this.bins(binNo).uniqueProfile = True
            binNoToCount = binNo
        ElseIf Not this.bins(binNo).isEqualTo(this.bins(binNo - 1)) Then
            this.bins(binNo).uniqueProfile = True
            binNoToCount = binNo
        End If
        this.bins(binNoToCount).quantity = this.bins(binNoToCount).quantity + 1
    Next
End Sub


' Assignes profile numbers to the bins
Public Function assignProfileNumbers(ByVal profileNo As Long) As Long
    Dim binNo As Long
    Dim newProfileNo As Long
    newProfileNo = profileNo
    
    For binNo = 1 To this.binCount
        If this.bins(binNo).uniqueProfile Then
            newProfileNo = newProfileNo + 1
        End If
        this.bins(binNo).profileNo = newProfileNo
    Next
    assignProfileNumbers = newProfileNo
End Function


' Prints all cuts, returns the next row
'Public Function showAllCuts(row As Long, col As Long, startNumbering As Long) As Long
'    Dim binNo As Long
'    Dim currentRow As Long
'    currentRow = row
'    With SheetOutputLists
'        For binNo = 1 To this.binCount
'            .Cells(currentRow, col).value = binNo + startNumbering
'            .Cells(currentRow, col + 1).value = channelTypeKey
'            this.bins(binNo).showCuts currentRow, col + 2
'            currentRow = currentRow + 1
'        Next
'    End With
'    showAllCuts = currentRow
'End Function


'Public Function getCopy(binNo As Long) As CBin
'    Dim tmpBin As CBin
'    Dim pieceNo As Long
'
'    Dim tmpPieces() As CPiece
'    Set tmpBin = New CBin
'    ' Copy everything:
'    tmpBin.capacity = this.bins(binNo).capacity
'    tmpBin.capacityCuttable = this.bins(binNo).capacityCuttable
'    tmpBin.profileNo = this.bins(binNo).profileNo
'    tmpBin.quantity = this.bins(binNo).quantity
'    tmpBin.channelTypeKey = this.bins(binNo).channelTypeKey
'    tmpBin.filled = this.bins(binNo).filled
'    tmpBin.pieceCount = this.bins(binNo).pieceCount
'    tmpBin.sum = this.bins(binNo).sum
'    ' Create a copy of the pieces
'    ReDim tmpPieces(1 To this.bins(binNo).pieceCount)
'    For pieceNo = 1 To tmpBin.pieceCount
'        Set tmpPieces(pieceNo) = this.bins(binNo).getPieceCopy(pieceNo)
'    Next
'    tmpBin.setPieces tmpPieces
'    Set getCopy = tmpBin
'End Function


' Find the largest amount of pieces contained in a bin, include cut-pieces
Public Function highestPieceCount() As Long
    highestPieceCount = 0
    Dim binNo As Long
    For binNo = 1 To this.binCount
        If this.bins(binNo).pieceCount > highestPieceCount Then
            highestPieceCount = this.bins(binNo).pieceCount
        End If
    Next
End Function


' Find the largest amount of pieces contained in a bin, does not include cut-pieces
'Public Function highestPieceCountWithoutCutpieces() As Long
'    highestPieceCountWithoutCutpieces = 0
'    Dim pieceCount As Long
'    Dim binNo As Long
'    For binNo = 1 To this.binCount
'        pieceCount = this.bins(binNo).getPieceCountWithoutCutpieces
'        If pieceCount > highestPieceCountWithoutCutpieces Then
'            highestPieceCountWithoutCutpieces = pieceCount
'        End If
'    Next
'End Function


' Find the largest amount of cuts contained in a bin
'Public Function highestCutCount() As Long
'    highestCutCount = 0
'    Dim cutCount As Long
'    Dim binNo As Long
'    For binNo = 1 To this.binCount
'        cutCount = this.bins(binNo).getCutCount
'        If cutCount > highestCutCount Then
'            highestCutCount = cutCount
'        End If
'    Next
'End Function


Public Sub placeItems( _
    ByVal items As CItemSet, _
    ByVal cutWidth As Long, _
    ByRef pgForm As ProgressForm _
)
    ' Mode
    If Settings.optimizationMode = enumOptimizationMode.bestFit Then
        Logger.logInfo "Running bestFit"
        placeItemsBestFit items, cutWidth, pgForm
    ElseIf Settings.optimizationMode = enumOptimizationMode.limitedBruteForce Then
        Logger.logInfo "Running limitedBruteForce"
        placeItemsLimitedBruteForce items, cutWidth, pgForm
    End If
End Sub


' Loops through the given itemset and tries to place all items into bins
' This is the actual packing function where the proverbial 'magic' happens
Public Sub placeItemsBestFit( _
    ByVal items As CItemSet, _
    ByVal cutWidth As Long, _
    ByRef pgForm As ProgressForm _
)
    Dim itemNo As Long
    Dim binNo As Long
    Dim pieceNo As Long
    Dim tmpPiece As CPiece
    Dim tmpItem As CItem
    Dim piecePlaced As Boolean
    Dim testBin As CBin

    Logger.logInfo "Placing " & items.count & " items"
    ' Empty the bins from any existing pieces
    clearBins
    
    ' For each item in the items array
    For itemNo = 1 To items.count
        Logger.logInfo "item no: " & itemNo
        Set tmpItem = items.getItemCopy(itemNo)

        ' TODO Optimization, only recalculate when needed (when deviatingMinimimRemainingWeb has changed)
        ' Always recalculate cut positions (for deviating remaining web)
        If tmpItem.deviatingMinimumRemainingWebWidthSet Then
            Request.channelTypeSet.recalculateCutPositionsForChannelType _
                tmpItem.channelTypeKey, _
                tmpItem.deviatingMinimumRemainingWebWidth
        Else
            Request.channelTypeSet.recalculateCutPositionsForChannelType _
                tmpItem.channelTypeKey, _
                -1
        End If

        Logger.logInfo vbNullString
        Logger.logInfo itemNo & "." & vbTab & "type: " & tmpItem.channelTypeKey & vbTab & "cuttingType: " & tmpItem.cuttingType & vbTab & "tol: " & tmpItem.tolerance & vbTab & "dev_min_rem_web: " & tmpItem.deviatingMinimumRemainingWebWidth & vbTab & "length: " & tmpItem.length & vbTab & "(" & tmpItem.quantity & "x)"
        For pieceNo = 1 To tmpItem.quantity
        
            pgForm.nextStepMain items.channelTypeKey & " - Placing item "
        
            Logger.logInfo "---"
            Logger.logInfo vbTab & "piece no: " & pieceNo
            ' Create piece
            Set tmpPiece = tmpItem.piece ' TODO enhancement? Possible to replace tmpPiece with items(itemNo).piece
            piecePlaced = False
            
            ' Try to fit in any existing bin
            For binNo = 1 To this.binCount
                ' Don't try with already filled bins (optimization)
                If Not this.bins(binNo).filled = True Then
                    Logger.logInfo vbTab & "Trying to place into binNo=" & binNo & vbTab & "cuttingType=" & tmpItem.cuttingType & vbTab & "cutWidth=" & cutWidth
                    piecePlaced = this.bins(binNo).placePiece(tmpItem.cuttingType, tmpPiece, cutWidth)
                    Logger.logInfo vbTab & "Result: " & piecePlaced
                    If piecePlaced Then
                        Exit For
                    End If
                Else
                    Logger.logInfo vbTab & "Found filled bin, skipping"
                End If
            Next
            
            ' Try to fit in a new bin
            If Not piecePlaced Then
                Logger.logInfo vbTab & "Try to fit in a new bin (binNo=" & (this.binCount + 1) & ")"
                ' If the piece could not be placed in any existing bin, add a new one
                ' and try to place the piece in this new bin
                Logger.logInfo vbTab & "adding bin, channelTypeKey=" & this.channelTypeKey
                Set testBin = createBin
                piecePlaced = testBin.placePiece(tmpItem.cuttingType, tmpPiece, cutWidth)
                
                If piecePlaced Then
                    addBin testBin
                Else
                    addUnplaceable tmpPiece
                    Logger.logBug "Bug: Unable to place item in empty bin, l=" & tmpItem.length & ", cuttingType=" & tmpItem.cuttingType
                End If
            End If
        
            ' The only difference between first fit and best fit is a sorting of the bins according to fillrate at this point
            ' Sort bins:
            orderByFillrateDescending
        Next
    Next
End Sub


' Tries to fit pieces using a somewhat reduced brute force method
' The idea is to first calculate how many items it takes of each item type to fill the bin
Public Sub placeItemsLimitedBruteForce( _
    ByVal items As CItemSet, _
    ByVal cutWidth As Long, _
    ByRef pgForm As ProgressForm _
)
    Dim itemNo As Long
    Dim pieceNo As Long
    Dim tmpPiece As CPiece
    Dim tmpItem As CItem
    Dim piecePlaced As Boolean
    Dim thisChannelType As CChannelType
    Dim maxPieces() As Long
    Dim unFiller As CUnfill

    Logger.logInfo "Placing " & items.count & " items"
    ' Empty the bins from any existing pieces
    clearBins
    
    ' TODO: Build tolerance free version
    
    ' Step 1, Sort pieces in size order ascending
    Logger.logInfo "Step 1, Sorting pieces according to length ascending"
    pgForm.showSubProgressBar "Step 1/7 Sorting pieces according to length"
    items.sortByLength descending:=False
    ReDim maxPieces(1 To items.count)
    
    
    
    ' Step 2, Find the number of pieces of each type required to fill a channel
    Logger.logInfo "Step 2, Find the number of pieces of each type required to fill a channel"
    pgForm.showSubProgressBar "Step 2/7 Calculating channel capacities"
    pgForm.resetSubProgress totalSteps:=items.count
    For itemNo = 1 To items.count
        
        Set tmpItem = items.getItemCopy(itemNo)
        maxPieces(itemNo) = 0

        ' Place as many pieces as possible into the bin (until we run out of pieces, the bin is full or if the piece cannot be placed)
        Logger.logDeep "  Placing pieces until the bin is full or we run out of pieces"
        For pieceNo = 1 To tmpItem.quantity
        
            Set tmpPiece = tmpItem.piece
            
            'Logger.logDeep vbTab & "    Trying to place into binNo=" & this.binCount & vbTab & "cuttingType=" & tmpItem.cuttingType & vbTab & "cutWidth=" & cutWidth
            piecePlaced = this.bins(this.binCount).placePiece(tmpItem.cuttingType, tmpPiece, cutWidth)
            If piecePlaced Then
                ' The piece could be placed, count it
                maxPieces(itemNo) = maxPieces(itemNo) + 1
            Else
                ' The piece could not be placed we have reached the end
                Exit For
            End If
        Next
        clearBins
        Logger.logDeep "maxPieces(" & itemNo & "): " & maxPieces(itemNo)
        
        pgForm.nextStepSub "Calculating channel capacities"
    Next
    pgForm.finnishSub
    
    
    
    ' Step 3, Find combinations of pieces for later permutations using the UnFill Algorithm
    pgForm.showSubProgressBar "Step 3/7 Calculating possible combinations"
    pgForm.resetSubProgress items.count
    Logger.logInfo "Step 3, Find combinations of pieces for later permutations using the UnFill Algorithm"
    Set unFiller = New CUnfill
    Set thisChannelType = Request.channelTypeSet.getChTypeFromKey(this.channelTypeKey)
    unFiller.setMaxLength thisChannelType.getMaxUsableLength
    
    ' Find lengths (this gives us a rough maximum)
    Logger.logInfo "  Find lengths (this gives us a rough maximum)"
    For itemNo = 1 To items.count
        ' TODO Enhancement replace with a function that does not make a copy
        Set tmpItem = items.getItemCopy(itemNo)
        Set tmpPiece = tmpItem.piece
        unFiller.addLength (tmpPiece.length - tmpPiece.allowedToleranceRoundedDown)     ' Use shortest piece length
        Logger.logInfo "    unFiller.addLength (" & (tmpPiece.length - tmpPiece.allowedToleranceRoundedDown) & ")"
    Next
    
    'Logger.logInfoBoth "  unFiller.curChar:" & unFiller.curChar
    Logger.logInfoBoth "  Running unfill algorithm"
    unFiller.unfill
    'Logger.logInfoBoth "  " & unFiller.results.count & " combinations generated"
    
    ' List results:
    'Logger.logInfoBoth "  Listing results:"
    'Dim myArr As CLongArray
    'Dim k As Long
    'For k = 1 To unFiller.results.count
    '    Logger.logInfoBoth "    count: " & unFiller.results.element(k).count & ", content: [" & unFiller.results.element(k).getString & "]"
    'Next

    ' Remove duplicates (TODO: improve the algorithm to remove them)
    'Logger.logInfoBoth "before:" & unFiller.results.count
    'unFiller.results.removeDuplicates
    'Logger.logInfoBoth "after:" & unFiller.results.count

    ' TODO enhance with code from here
    ' https://stackoverflow.com/questions/3017852/vba-get-unique-values-from-array
    ' https://stackoverflow.com/questions/152319/vba-array-sort-function/152325#152325



    ' Step 4, Find permutations of previous combinations
    pgForm.showSubProgressBar "Step 4/7 Finding permutations "
    Logger.logInfo "Step 4, Find permutations of previous combinations"

    Dim permutations As Collection
    Set permutations = New Collection

    ' Counting number of permutations:
    Dim binNo As Long
    Dim resultNo As Long
    Dim permutationNo As Long
    Dim counts As CLongArray
    Dim permutationFinder As CFastPermutation
    Dim totalNumberOfPermutations As Double
    totalNumberOfPermutations = 0
    Set permutationFinder = New CFastPermutation
    For binNo = 1 To unFiller.results.count
        Set counts = unFiller.results.element(binNo)
        totalNumberOfPermutations = totalNumberOfPermutations + permutationFinder.noOfPermutations(counts)
    Next
    pgForm.resetSubProgress totalNumberOfPermutations
    Logger.logInfo "Total number of permutations to find: " & totalNumberOfPermutations

    '@Ignore VariableNotUsed
    Dim numberOfPermutationsFound As Long
    For resultNo = 1 To unFiller.results.count
        ' Find permutations
        Set permutationFinder = New CFastPermutation
        Set counts = unFiller.results.element(resultNo)
        Logger.logInfo "  counts: unFiller.results.element(" & resultNo & ").getstring: " & counts.getString
        'Dim tim As New CTimer
        'tim.StartCounter
        numberOfPermutationsFound = permutationFinder.findPermutations(counts, permutations, pgForm)   ' Collect all permutations in the permutations collection object (sent as byref)
        'Logger.logInfo "  " & tim.TimeElapsed & " ms"
        Logger.logInfo "  " & numberOfPermutationsFound & " permutations generated"
    Next
    Logger.logInfo "  Total number of permutations found: " & permutations.count

    'Logger.logInfoBoth "  Listing generated permutations:"
    For permutationNo = 1 To permutations.count
        Set counts = permutations.item(permutationNo)
        Logger.logInfoBoth "   permutationNo=" & permutationNo & ":[" & counts.getString & "]"
    Next
    pgForm.finnishSub



    ' Step 5, Try to actually build the all permutations, discarding unbuildable ones
    ' Within permutations discard the less optimal ones
    'pgForm.finnishSub
    pgForm.showSubProgressBar "Step 5/7 Building all permutations "
    Logger.logInfo "Step 5, Try to actually build the all permutations, discarding unbuildable ones"

    ' Generate item set
    Dim permutation As CLongArray
    Dim countNo As Long
    Dim buildablePermutation As Boolean
    Dim testBin As CBin

    clearBinsDontAddOne
    pgForm.resetSubProgress permutations.count
    
    ' Check which permutations are possible to build by building them all
    For permutationNo = 1 To permutations.count
        Set permutation = permutations.item(permutationNo)
        Set testBin = createBin
        buildablePermutation = True
        Logger.logInfo permutationNo & ", " & permutation.getString
        
        ' Try to see that all pieces are placable according to this permutation of piece order
        For countNo = 1 To permutation.count
            ' element represents a item of a certain kind
            Set tmpItem = items.getItemCopy(permutation.element(countNo))
            Set tmpPiece = tmpItem.piece ' Possible to replace tmpPiece with items(itemNo).piece
            'Logger.logInfo "  Trying to place into binNo=?, length=" & tmpItem.length & "cuttingType=" & tmpItem.cuttingType & vbTab & "cutWidth=" & cutWidth
            piecePlaced = testBin.placePiece(tmpItem.cuttingType, tmpPiece, cutWidth)
            'Logger.logInfo "  Result: " & piecePlaced
            If Not piecePlaced Then
                'Logger.logInfo "  Found unplaceable piece, skipping this permutation.count=" & permutation.count & ", i=" & i
                buildablePermutation = False
                Exit For    ' Stop the loop, no need to try to fit any more pieces
            End If
        Next
        
        ' If testBin was buildable, add it to the bins array
        If buildablePermutation Then
            'Logger.logInfo "  Adding permutation to list of buildable permutations"
            '@Ignore ObjectVariableNotSet
            testBin.permutation = permutation.getCopy   ' Save permutation for later use
            addBin testBin
        End If
        pgForm.nextStepSub "Step 5/7 Building all permutations "
    Next
    Logger.logInfo "  Generated " & this.binCount & " possible profiles out of " & permutationNo & " candidates."
    pgForm.finnishSub



    ' Step 6, Order solutions according to waste
    'pgForm.finnishSub

    pgForm.showSubProgressBar "Step 6/7 Sorting profiles "
    pgForm.resetSubProgress (this.binCount \ 2)
    Logger.logInfo "Step 6, Order solutions according to waste"
    orderByWastRatePlusUnusedSpaceAscending pgForm
    pgForm.finnishSub

    
    
    ' Step 7, A greedy algorithm chooses the most optimal profiles as long as there is enough quantity left
    'pgForm.finnishSub
    pgForm.showSubProgressBar "Step 7/7 Selecting best profiles "
    Logger.logInfo "Step 7, A greedy algorithm chooses to build the most optimal solutions as long as there are enough pieces."
    
    ' Get usable quantities
    Dim itemQuantities As CLongArray
    Dim candidateQuantities As CLongArray     ' fill with the right amount
    Set itemQuantities = New CLongArray
    Set candidateQuantities = New CLongArray
    For itemNo = 1 To items.count
        itemQuantities.addElement items.getItemCopy(itemNo).quantity
        candidateQuantities.addElement 0
    Next
    
    ' Pick profiles until all items are used up
    Dim quantityNo As Long
    Dim elementNo As Long
    Dim outOfQuantity As Boolean
    Dim usedBins() As CBin
    Dim usedBinCount As Long
    Dim piecesStr As String
    Dim piece As CPiece
    usedBinCount = 0

    pgForm.resetSubProgress this.binCount

    For binNo = 1 To this.binCount
        
        pgForm.nextStepSub "Step 7/7 Selecting best profiles "
        ' Convert profile to quantities
        candidateQuantities.zero  ' Reset temporary variable
        For elementNo = 1 To this.bins(binNo).permutation.count
            candidateQuantities.element(this.bins(binNo).permutation.element(elementNo)) = candidateQuantities.element(this.bins(binNo).permutation.element(elementNo)) + 1
        Next
        Logger.logDeep "binNo:" & binNo & " profile: [" & this.bins(binNo).permutation.getString & "] quantities: " & candidateQuantities.getString
        
        ' Match quantities to profiles
        outOfQuantity = False
        Do While Not outOfQuantity
            ' Check if item quantities are enough to fill one more of the current kind
            For quantityNo = 1 To itemQuantities.count
                If itemQuantities.element(quantityNo) < candidateQuantities.element(quantityNo) Then
                    ' Exit this loop and advance outer loop
                    outOfQuantity = True
                    Logger.logDeep "  >outOfQuantity"
                    Exit For
                End If
            Next
    
            ' If there was enough items left, subtract them, save the bin
            Dim allQuantityZero As Boolean
            allQuantityZero = True  ' Assume that all are zero and prove it false
            If Not outOfQuantity Then
                Logger.logDeep "  enough items left:" & itemQuantities.getString & ", itemQuantities.count:" & itemQuantities.count
                For elementNo = 1 To itemQuantities.count
                    itemQuantities.element(elementNo) = itemQuantities.element(elementNo) - candidateQuantities.element(elementNo)
                    ' Check if all are zero
                    If itemQuantities.element(elementNo) > 0 Then
                        allQuantityZero = False
                    End If
                Next
                
                ' Enumerate pieces
                piecesStr = vbNullString
                For pieceNo = 1 To this.bins(binNo).pieceCount
                    Set piece = this.bins(binNo).getPieceCopy(pieceNo)
                    piecesStr = piecesStr & piece.length & ", "
                Next
                
                ' Add a new bin
                usedBinCount = usedBinCount + 1
                Logger.logDeep "  saving bin no. " & usedBinCount & ", binNo:" & binNo & ", binsum: " & this.bins(binNo).getSum & " [" & piecesStr & "]"
                ReDim Preserve usedBins(1 To usedBinCount)
                '@Ignore ObjectVariableNotSet
                Set usedBins(usedBinCount) = this.bins(binNo).getCopy
                                
                ' Break when all items have have been used
                If allQuantityZero Then
                    Logger.logDeep "  allQuantityZero" & itemQuantities.getString
                    Exit Do
                End If
            End If
        Loop
    Next
    pgForm.finnishSub
    
    Logger.logDeep "Result of optimization:"
    For binNo = 1 To usedBinCount
        ' Print pieces
        piecesStr = vbNullString
        For pieceNo = 1 To usedBins(binNo).pieceCount
            Set piece = usedBins(binNo).getPieceCopy(pieceNo)
            piecesStr = piecesStr & piece.length & ", "
        Next
        Logger.logDeep "binNo: " & binNo & ", sum: " & usedBins(binNo).getSum & ", " & usedBins(binNo).quantity & "x" & ", waste: " & usedBins(binNo).getWasteSum & " [" & piecesStr & "]"
    Next
    
    ' Switch result to usedBins
    this.bins = usedBins
    this.binCount = usedBinCount
    
End Sub


'Private Function getUniqueCLongArrayCollection(ByRef coll As Collection) As Collection
'    Dim base As CLongArray
'    Dim compareTo As CLongArray
'    Dim unique As Collection
'    Set unique = New Collection
'    If coll.count > 1 Then
'        For Each base In coll
'            ' Check if it exists in unique collection
'            For Each compareTo In unique
'                If base.equals(compareTo) Then
'                    ' Not unique, poor mans continue
'                    GoTo continueOuter
'                End If
'            Next compareTo
'            ' Yes it is unique, add it to the unique list
'            unique.Add base
'continueOuter:
'        Next base
'    End If
'    Set getUniqueCLongArrayCollection = unique
'End Function




' Do post optimization
Public Sub postOptimization()
    changeChannelTypesToSmaller
    addEndWastePieces
End Sub


' Try to change to shorter material to save on material cost
Public Sub changeChannelTypesToSmaller()
    
    Logger.logInfo "changeChannelTypesToSmaller"
    
    Dim binNo As Long
    Dim variantNo As Long
    Dim channelTypeSmallerVariants() As CChannelTypeVariant
    Dim channelTypeSmallerVariantCount As Long

    ' Get list of shorter variants than current capacity, list is ordered from low to high
    channelTypeSmallerVariants = Request.channelTypeSet.getSmallerVariants(this.channelTypeKey, this.capacity)
    
    
    ' This fixes a problem when there is only one variant of a type
    If Not IsNull(channelTypeSmallerVariants) Then
    
        channelTypeSmallerVariantCount = UBound(channelTypeSmallerVariants)
        
        ' Only if the channel type has variants
        If channelTypeSmallerVariantCount > 0 Then
            ' Loop through all bins
            For binNo = 1 To this.binCount
                Logger.logInfo "   Bin no. " & binNo & ":"
                If Not this.bins(binNo).filled Then
                    Logger.logInfo "    is not already filled"
                    Logger.logInfo "    binSum:" & this.bins(binNo).getSum & ", cutFreeSpaceEnd=" & Settings.cutFreeSpaceEnd
                    For variantNo = 1 To channelTypeSmallerVariantCount
                        Logger.logInfo "    Testing variant #" & variantNo & ", length=" & channelTypeSmallerVariants(variantNo).length & ", safeLength=" & channelTypeSmallerVariants(variantNo).safeLength
                        If this.bins(binNo).getSum <= (channelTypeSmallerVariants(variantNo).safeLength - Settings.cutFreeSpaceEnd) Then
                            Logger.logInfo "     (true) binSum <= safeLength - cutFreeSpaceEnd (" & this.bins(binNo).getSum & " <= " & channelTypeSmallerVariants(variantNo).safeLength & " - " & Settings.cutFreeSpaceEnd & ")"
                            ' change the bin capacity
                            Logger.logInfo "Changing the channel to a shorter variant"
                            ' For completeness also change capacityCuttable
                            this.bins(binNo).setValues _
                                length:=channelTypeSmallerVariants(variantNo).length, _
                                capacity:=channelTypeSmallerVariants(variantNo).safeLength, _
                                capacityCuttable:=( _
                                    channelTypeSmallerVariants(variantNo).safeLength - Settings.cutFreeSpaceEnd _
                                ), _
                                channelTypeKey:=this.bins(binNo).channelTypeKey
                            If this.bins(binNo).getSum = ( _
                                channelTypeSmallerVariants(variantNo).safeLength - _
                                Settings.cutFreeSpaceEnd _
                            ) Then
                                this.bins(binNo).filled = True
                            End If
                            ' Since they were ordered we stop on the first one that fits
                            Exit For
                        Else
                            Logger.logInfo "     (false) binSum <= safeLength - cutFreeSpaceEnd (" & this.bins(binNo).getSum & " <= " & channelTypeSmallerVariants(variantNo).safeLength & " - " & Settings.cutFreeSpaceEnd & ")"
                        End If
                    Next
                Else
                    Logger.logInfo "    is already filled (by definition then we are not able to change it to any shorter variant)"
                End If
            Next
        Else
            Logger.logInfo " No shorter types found"
        End If
    Else
        Logger.logInfo " No shorter types found"
    End If
End Sub


' Add the last wastepiece to every bin
Public Sub addEndWastePieces()
    Logger.logInfo "addEndWastePieces"
    Dim binNo As Long
    Dim endWastePiece As CPiece
    Dim binSum As Long

    Logger.logInfo "binNo" & vbTab & "Filled state" & vbTab & "endWastePiece.length" & vbTab & "this.bins(binNo).capacity" & vbTab & vbTab & "this.bins(binNo).getSum="
    
    For binNo = 1 To this.binCount
        binSum = this.bins(binNo).getSum
        If this.bins(binNo).capacity - binSum > 0 Then
            Set endWastePiece = New CPiece
            endWastePiece.length = this.bins(binNo).capacity - binSum
            endWastePiece.pieceType = enumPieceType.waste
            endWastePiece.placed = True
            Logger.logInfo binNo & vbTab & vbTab & "Not filled" & vbTab & vbTab & endWastePiece.length & vbTab & vbTab & vbTab & vbTab & vbTab & this.bins(binNo).capacity & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & this.bins(binNo).getSum
            this.bins(binNo).addPiece endWastePiece
            this.bins(binNo).filled = True
        End If
    Next
End Sub


Public Function getPieceType(ByVal binNo As Long, ByVal pieceNo As Long) As enumPieceType
    If binNo > this.binCount Then
        Logger.logBug "BUG: tried with too high binNo" & vbTab & binNo
        getPieceType = enumPieceType.normal
    ElseIf pieceNo > this.bins(binNo).pieceCount Then
        Logger.logBug "BUG: tried with too high pieceNo" & vbTab & pieceNo
        getPieceType = enumPieceType.normal
    Else
        getPieceType = this.bins(binNo).getPieceType(pieceNo)
    End If
End Function


Public Function getPieceHPRPlacement(ByVal binNo As Long, ByVal pieceNo As Long) As enumHPRPlacement
    If binNo > this.binCount Then
        Logger.logBug "BUG: tried with to high binNo" & vbTab & binNo
        getPieceHPRPlacement = enumHPRPlacement.noSide
    ElseIf pieceNo > this.bins(binNo).pieceCount Then
        Logger.logBug "BUG: tried with to high pieceNo" & vbTab & pieceNo
        getPieceHPRPlacement = enumHPRPlacement.noSide
    Else
        getPieceHPRPlacement = this.bins(binNo).getPieceHPRPlacement(pieceNo)
    End If
End Function

Public Function getPieceLength(ByVal binNo As Long, ByVal pieceNo As Long) As Long
    If binNo > this.binCount Then
        Logger.logBug "BUG: tried with to high binNo" & vbTab & binNo
        getPieceLength = 0
    ElseIf pieceNo > this.bins(binNo).pieceCount Then
        Logger.logBug "BUG: tried with to high pieceNo" & vbTab & pieceNo
        getPieceLength = 0
    Else
        getPieceLength = this.bins(binNo).getPieceLength(pieceNo)
    End If
End Function


Public Function getPieceCount(ByVal binNo As Long) As Long
    getPieceCount = this.bins(binNo).pieceCount
End Function


'Public Function getPieceChannelType(binNo As Long, pieceNo As Long) As String
'    If binNo > this.binCount Then
'        Logger.logBug "BUG: tried with to high binNo", binNo
'    ElseIf pieceNo > this.bins(binNo).pieceCount Then
'        Logger.logBug "BUG: tried with to high pieceNo", pieceNo
'    Else
'        getPieceChannelType = this.bins(binNo).getPieceType(pieceNo)
'    End If
'End Function


Attribute VB_Name = "CChannelType"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CChannelType class

Private Type TChannelType
    size As String
    channelTypeKey As String
    ctype As String
    extra As String
    material As String
    minimum_item_length As Long
    hilti_standard_tolerance1 As Long
    hilti_standard_tolerance2 As Long
    hilti_standard_tolerance3 As Long
    hilti_standard_tolerance4 As Long
    hilti_standard_tolerance5 As Long
    hilti_standard_tolerance6 As Long
    HPR_enabled As Boolean
    step_length As Long
    hole_length As Long
    web_width As Long
    first_web_width As Long
    first_web_width_cut As Long
    first_web_width_shear As Long
    minimum_remaining_web_width As Long
    start_position_error As Long
    hole_position_error As Long
    hole_length_error_plus As Long
    hole_length_error_minus As Long
    variantCount As Long
    maxRightCuts As Long
    maxLeftCuts As Long
    
    leftCutMinArray() As Long
    rightCutMinArray() As Long
    leftCutMaxArray() As Long
    rightCutMaxArray() As Long
    validLengthsC1Min() As Long
    validLengthsC1Max() As Long
    channelVariants() As CChannelTypeVariant
    firstRightCutArea_usable As Boolean
    validLengthsC1Count As Long
End Type

Private this As TChannelType

Public Property Get leftCutsMax() As Long
    leftCutsMax = this.maxLeftCuts
End Property
Public Property Let leftCutsMax(ByVal value As Long)
    this.maxLeftCuts = value
End Property

Public Property Get rightCutsMax() As Long
    rightCutsMax = this.maxRightCuts
End Property
Public Property Let rightCutsMax(ByVal value As Long)
    this.maxRightCuts = value
End Property

Public Property Get variantCount() As Long
    variantCount = this.variantCount
End Property
Public Property Let variantCount(ByVal value As Long)
    this.variantCount = value
End Property

Public Property Get holeLengthErrorMinus() As Long
    holeLengthErrorMinus = this.hole_length_error_minus
End Property
Public Property Let holeLengthErrorMinus(ByVal value As Long)
    this.hole_length_error_minus = value
End Property

Public Property Get holeLengthErrorPlus() As Long
    holeLengthErrorPlus = this.hole_length_error_plus
End Property
Public Property Let holeLengthErrorPlus(ByVal value As Long)
    this.hole_length_error_plus = value
End Property

Public Property Get holePositionError() As Long
    holePositionError = this.hole_position_error
End Property
Public Property Let holePositionError(ByVal value As Long)
    this.hole_position_error = value
End Property

Public Property Get startPositionError() As Long
    startPositionError = this.start_position_error
End Property
Public Property Let startPositionError(ByVal value As Long)
    this.start_position_error = value
End Property

Public Property Get minimumRemainingWebWidth() As Long
    minimumRemainingWebWidth = this.minimum_remaining_web_width
End Property
Public Property Let minimumRemainingWebWidth(ByVal value As Long)
    this.minimum_remaining_web_width = value
End Property

Public Property Get firstWebWidthShear() As Long
    firstWebWidthShear = this.first_web_width_shear
End Property
Public Property Let firstWebWidthShear(ByVal value As Long)
    this.first_web_width_shear = value
End Property

Public Property Get firstWebWidthCut() As Long
    firstWebWidthCut = this.first_web_width_cut
End Property
Public Property Let firstWebWidthCut(ByVal value As Long)
    this.first_web_width_cut = value
End Property

Public Property Get firstWebWidth() As Long
    firstWebWidth = this.first_web_width
End Property
Public Property Let firstWebWidth(ByVal value As Long)
    this.first_web_width = value
End Property

Public Property Get webWidth() As Long
    webWidth = this.web_width
End Property
Public Property Let webWidth(ByVal value As Long)
    this.web_width = value
End Property

Public Property Get holeLength() As Long
    holeLength = this.hole_length
End Property
Public Property Let holeLength(ByVal value As Long)
    this.hole_length = value
End Property

Public Property Get HPRenabled() As Boolean
    HPRenabled = this.HPR_enabled
End Property
Public Property Let HPRenabled(ByVal value As Boolean)
    this.HPR_enabled = value
End Property

Public Property Get stepLength() As Long
    stepLength = this.step_length
End Property
Public Property Let stepLength(ByVal value As Long)
    this.step_length = value
End Property

Public Property Get hiltiStandardTolerance6() As Long
    hiltiStandardTolerance6 = this.hilti_standard_tolerance6
End Property
Public Property Let hiltiStandardTolerance6(ByVal value As Long)
    this.hilti_standard_tolerance6 = value
End Property

Public Property Get hiltiStandardTolerance5() As Long
    hiltiStandardTolerance5 = this.hilti_standard_tolerance5
End Property
Public Property Let hiltiStandardTolerance5(ByVal value As Long)
    this.hilti_standard_tolerance5 = value
End Property

Public Property Get hiltiStandardTolerance4() As Long
    hiltiStandardTolerance4 = this.hilti_standard_tolerance4
End Property
Public Property Let hiltiStandardTolerance4(ByVal value As Long)
    this.hilti_standard_tolerance4 = value
End Property

Public Property Get hiltiStandardTolerance3() As Long
    hiltiStandardTolerance3 = this.hilti_standard_tolerance3
End Property
Public Property Let hiltiStandardTolerance3(ByVal value As Long)
    this.hilti_standard_tolerance3 = value
End Property

Public Property Get hiltiStandardTolerance2() As Long
    hiltiStandardTolerance2 = this.hilti_standard_tolerance2
End Property
Public Property Let hiltiStandardTolerance2(ByVal value As Long)
    this.hilti_standard_tolerance2 = value
End Property

Public Property Get hiltiStandardTolerance1() As Long
    hiltiStandardTolerance1 = this.hilti_standard_tolerance1
End Property
Public Property Let hiltiStandardTolerance1(ByVal value As Long)
    this.hilti_standard_tolerance1 = value
End Property

Public Property Get minimumItemLength() As Long
    minimumItemLength = this.minimum_item_length
End Property
Public Property Let minimumItemLength(ByVal value As Long)
    this.minimum_item_length = value
End Property

Public Property Get material() As String
    material = this.material
End Property
Public Property Let material(ByVal value As String)
    this.material = value
End Property

Public Property Get extra() As String
    extra = this.extra
End Property
Public Property Let extra(ByVal value As String)
    this.extra = value
End Property

Public Property Get ctype() As String
    ctype = this.ctype
End Property
Public Property Let ctype(ByVal value As String)
    this.ctype = value
End Property

Public Property Get channelTypeKey() As String
    channelTypeKey = this.channelTypeKey
End Property
Public Property Let channelTypeKey(ByVal value As String)
    this.channelTypeKey = value
End Property

Public Property Get size() As String
    size = this.size
End Property
Public Property Let size(ByVal value As String)
    this.size = value
End Property


Private Sub class_initialize()
    this.channelTypeKey = vbNullString
    this.ctype = vbNullString
    this.size = vbNullString
    this.extra = vbNullString
    this.material = vbNullString
    this.minimum_item_length = 0
    this.hilti_standard_tolerance1 = 0
    this.hilti_standard_tolerance2 = 0
    this.hilti_standard_tolerance3 = 0
    this.hilti_standard_tolerance4 = 0
    this.hilti_standard_tolerance5 = 0
    this.hilti_standard_tolerance6 = 0
    this.HPR_enabled = False
    this.step_length = 0
    this.hole_length = 0
    this.web_width = 0
    this.first_web_width = 0
    this.first_web_width_cut = 0
    this.first_web_width_shear = 0
    this.minimum_remaining_web_width = 0
    this.start_position_error = 0
    this.hole_position_error = 0
    this.hole_length_error_plus = 0
    this.hole_length_error_minus = 0
    this.variantCount = 0
    this.maxRightCuts = 0
    this.maxLeftCuts = 0
    this.firstRightCutArea_usable = False
    
    ReDim this.leftCutMinArray(1 To 1)
    ReDim this.rightCutMinArray(1 To 1)
    ReDim this.leftCutMaxArray(1 To 1)
    ReDim this.rightCutMaxArray(1 To 1)
    
    ReDim this.validLengthsC1Min(1 To 1)
    ReDim this.validLengthsC1Max(1 To 1)
    
    ReDim this.channelVariants(1 To 1)
End Sub


Public Property Get variants() As CChannelTypeVariant()
    '@Ignore ObjectVariableNotSet
    variants = this.channelVariants
End Property


' Returns the variant with index number variantNo
Public Property Get getVariant(ByVal varniantNo As Long) As CChannelTypeVariant
    Set getVariant = this.channelVariants(varniantNo)
End Property


' Adds the given variant
Public Sub addVariant(ByVal newChannelVariant As CChannelTypeVariant)
    this.variantCount = this.variantCount + 1
    ReDim Preserve this.channelVariants(1 To this.variantCount)
    '@Ignore ObjectVariableNotSet
    Set this.channelVariants(this.variantCount) = newChannelVariant
End Sub


' Clears the list of variants
'Public Sub clearVariants()
'    variantCount = 0
'    ReDim channelVariants(1 To 1)
'End Sub


' Returns the length of the longest variant
Public Function getMaxSafeLength() As Long
    Dim i As Long
    getMaxSafeLength = 0
    For i = 1 To this.variantCount
        Logger.logDeep i & " : " & this.channelVariants(i).safeLength
        If this.channelVariants(i).safeLength > getMaxSafeLength Then
            getMaxSafeLength = this.channelVariants(i).safeLength
        End If
    Next
End Function


' Returns the usable length of the longest variant
Public Function getMaxUsableLength() As Long
    Dim maxLength As Long
    maxLength = getMaxSafeLength
    ' Adjust for end material left, but never set it below 0:
    If maxLength - Settings.cutFreeSpaceEnd < 0 Then
        getMaxUsableLength = 0
    Else
        getMaxUsableLength = maxLength - Settings.cutFreeSpaceEnd
    End If
End Function


' Returns the length of the longest variant
Public Function getMaxLength() As Long
    Dim i As Long
    getMaxLength = 0
    For i = 1 To this.variantCount
        If this.channelVariants(i).length > getMaxLength Then
            getMaxLength = this.channelVariants(i).length
        End If
    Next
End Function

' For holepattern relevance, gives the cut_min number n
' Returns a number that is in 1/10 mm or -1 if n < 1
Private Function calculateRightCutMin( _
    ByVal n As Long, _
    ByVal deviating_minimum_remaining_web_width As Long _
) As Long
    Dim cutMin As Long
    Dim current_meter As Long
    Dim internal_minimum_remaining_web_width As Long
    
    ' Deviating minimum remaining web
    If deviating_minimum_remaining_web_width = -1 Then
        internal_minimum_remaining_web_width = this.minimum_remaining_web_width
    Else
        internal_minimum_remaining_web_width = deviating_minimum_remaining_web_width
    End If
    
    ' Only valid for 1 and above
    If n < 1 Then
        cutMin = -1
        Logger.logBug "Bug: calculateRightCutMin tried to use n < 1"
    ElseIf n = 1 Then
        ' The first interval is special
        cutMin = 0
    Else
        current_meter = ceiling( _
            ( _
                -this.start_position_error _
                + this.first_web_width _
                + (n - 1) * (this.hole_length + this.web_width) _
            ) / Settings.conversionFactorCurrentMeter _
        )

        cutMin = this.start_position_error _
                 + this.first_web_width _
                 + this.hole_position_error * current_meter _
                 + (n - 1) * this.hole_length _
                 + (n - 2) * this.web_width _
                 + this.hole_length_error_plus _
                 + internal_minimum_remaining_web_width
    End If
    calculateRightCutMin = cutMin
End Function


' For hole pattern relevance, gives the cut_min number n
' Returns a number that is in 1/10 mm or -1 if n < 1
Private Function calculateLeftCutMin( _
    ByVal n As Long, _
    ByVal deviating_minimum_remaining_web_width As Long _
) As Long
    Dim cutMin As Long
    Dim current_meter As Long
    Dim internal_minimum_remaining_web_width As Long
    
    ' Deviating minimum remaining web
    If deviating_minimum_remaining_web_width = -1 Then
        internal_minimum_remaining_web_width = this.minimum_remaining_web_width
    Else
        internal_minimum_remaining_web_width = deviating_minimum_remaining_web_width
    End If
    
    ' Only valid for 1 and above
    If n < 1 Then
        cutMin = -1
        Logger.logBug "Bug: calculateLeftCutMin tried to use n < 1"
    ElseIf n = 1 Then
        ' The first interval is special
        cutMin = 0
    Else
        current_meter = ceiling( _
            ( _
                -this.start_position_error _
                + this.first_web_width _
                + (n - 1) * (this.hole_length + this.web_width) _
                - internal_minimum_remaining_web_width _
            ) / Settings.conversionFactorCurrentMeter _
        )

        cutMin = this.start_position_error _
                 + this.first_web_width _
                 + this.hole_position_error * current_meter _
                 + (n - 1) * this.hole_length _
                 + (n - 2) * this.web_width _
                 + this.hole_length_error_plus
    End If
    calculateLeftCutMin = cutMin
End Function


' For hole pattern relevance, gives the cut_max number n
' Returns -1 if n < 1 or if the channelType is illegal
' Returns a number that is in 1/10 mm
Private Function calculateRightCutMax(ByVal n As Long) As Long
    Dim cutMax As Long
    Dim current_meter As Long
    
    ' Only valid for 1 and above
    If n < 1 Then
        cutMax = -1
        Logger.logBug "Bug: calculateRightCutMax tried to use n < 1"
    ElseIf n = 1 Then
        ' The first interval is special
        cutMax = -this.start_position_error _
                 + this.first_web_width _
                 - this.hole_position_error
    Else
        ' Find current meter
        current_meter = ceiling( _
            ( _
                -this.start_position_error _
                + this.first_web_width _
                + (n - 1) * (this.hole_length + this.web_width) _
            ) / Settings.conversionFactorCurrentMeter _
        )

        cutMax = -this.start_position_error _
                 + this.first_web_width _
                 - this.hole_position_error * current_meter _
                 + (n - 1) * (this.hole_length + this.web_width)
   End If
   calculateRightCutMax = cutMax
End Function


' For hole pattern relevance, gives the cut_max number n
' Returns -1 if n < 1 or if the channelType is illegal
' Returns a number that is in baseunit (1/10 mm or 1/100 inch)
Private Function calculateLeftCutMax(ByVal n As Long, ByVal deviating_minimum_remaining_web_width As Long) As Long
    Dim cutMax As Long
    Dim current_meter As Long
    Dim internal_minimum_remaining_web_width As Long
    
    ' Deviating minimum remaining web
    If deviating_minimum_remaining_web_width - 1 Then
        internal_minimum_remaining_web_width = this.minimum_remaining_web_width
    Else
        internal_minimum_remaining_web_width = deviating_minimum_remaining_web_width
    End If
    
    ' Only valid for 1 and above
    If n < 1 Then
        cutMax = -1
        Logger.logBug "Bug: calculateLeftCutMax tried to use n < 1"
    ElseIf n = 1 Then
        ' The first interval is special
        cutMax = -this.start_position_error _
                 + this.first_web_width _
                 - this.hole_position_error _
                 - internal_minimum_remaining_web_width
    Else
        ' Find current meter
        current_meter = ceiling( _
            ( _
                -this.start_position_error _
                + this.first_web_width _
                + (n - 1) * (this.hole_length + this.web_width) _
                - internal_minimum_remaining_web_width _
            ) / Settings.conversionFactorCurrentMeter _
        )

        cutMax = -this.start_position_error _
                 + this.first_web_width _
                 - this.hole_position_error * current_meter _
                 + (n - 1) * (this.hole_length + this.web_width) _
                 - internal_minimum_remaining_web_width
   End If
   calculateLeftCutMax = cutMax
End Function


' Gives the cut_mark number n
' Returns a number that is in fundamental unit or -1 if n < 1
Private Function calculateCutMark(ByVal n As Long) As Long
    Dim cutMark As Long
    
    ' Only valid for 1 and above
    If n < 1 Then
        cutMark = -1
        Logger.logBug "Bug: calculateCutMark tried to use n < 1"
    ElseIf n = 1 Then
        ' The first interval is special
        cutMark = 0
    Else
        cutMark = this.first_web_width + (n - 1) * (this.hole_length + (this.web_width / 2))
    End If
    calculateCutMark = cutMark
End Function


Public Function getLeftCutMin(ByVal n As Long) As Long
    If n <= this.maxLeftCuts Then
        getLeftCutMin = this.leftCutMinArray(n)
    Else
        getLeftCutMin = 0
        Logger.logBug "BUG: getCutMinLeft: Attempt to access cuts outside cutMax (n: " & n & ", maxCutsLeft: " & this.maxLeftCuts & ", channelType: " & this.channelTypeKey & ")"
    End If
End Function


Public Function getRightCutMin(ByVal n As Long) As Long
    If n <= this.maxRightCuts Then
        getRightCutMin = this.rightCutMinArray(n)
    Else
        getRightCutMin = 0
        Logger.logBug "BUG: getRightCutMin: Attempt to access cuts outside cutMax (n: " & n & ", maxCutsRight: " & this.maxRightCuts & ", channelType: " & this.channelTypeKey & ")"
    End If
End Function


Public Function getLeftCutMax(ByVal n As Long) As Long
    If n <= this.maxLeftCuts Then
       getLeftCutMax = this.leftCutMaxArray(n)
    Else
        getLeftCutMax = 0
        Logger.logBug "BUG: getLeftCutMax: Attempt to access cuts outside maxCuts (n: " & n & ", maxCutsLeft: " & this.maxLeftCuts & ", channelType: " & this.channelTypeKey & ")"
    End If
End Function


Public Function getRightCutMax(ByVal n As Long) As Long
    If n <= this.maxRightCuts Then
       getRightCutMax = this.rightCutMaxArray(n)
    Else
        getRightCutMax = 0
        Logger.logBug "BUG: getRightCutMax: Attempt to access cuts outside maxCuts (n: " & n & ", maxCutsRight: " & this.maxRightCuts & ", channelType: " & this.channelTypeKey & ")"
    End If
End Function


' Generates min max arrays combined - old way
Public Sub generateCutPositions(ByVal deviating_minimum_remaingin_web As Long)
    Logger.logFunctionCall 1, "Running " & this.channelTypeKey & ".generateCutPositions(" & deviating_minimum_remaingin_web & ")"
    If Not Settings.toleranceDisabled Then
        generateLeftCutAreas deviating_minimum_remaingin_web
        generateRightCutAreas deviating_minimum_remaingin_web
    Else
        generateCutMarks
    End If
End Sub


' Assumes that generateCutMinMax has been run
Public Sub genreateValidLengthsC1()
    Dim n As Long
    Dim rightIndexAdjustment As Long
    
    ReDim this.validLengthsC1Min(1 To 1)
    ReDim this.validLengthsC1Max(1 To 1)
    
    this.validLengthsC1Count = 0
    rightIndexAdjustment = 1
    
    If Not this.firstRightCutArea_usable Then
        rightIndexAdjustment = 0
    End If
    'Logger.logInfo "maxCuts, firstRightCutArea_usable: " & vbTab & maxCutsRight & vbTab & firstRightCutArea_usable
    'Logger.logInfo "n" & vbTab & "min" & vbTab & "max"
    
    For n = 1 To this.maxRightCuts - rightIndexAdjustment
        this.validLengthsC1Count = this.validLengthsC1Count + 1
        ReDim Preserve this.validLengthsC1Min(1 To this.validLengthsC1Count)
        ReDim Preserve this.validLengthsC1Max(1 To this.validLengthsC1Count)
        this.validLengthsC1Min(n) = getRightCutMin(n + rightIndexAdjustment) - getLeftCutMax(1)
        this.validLengthsC1Max(n) = getRightCutMax(n + rightIndexAdjustment) - getLeftCutMin(1)
        'Logger.logInfo n & vbTab & validLengthsC1Min(n) & vbTab & "(" & getCutMinRight(n + rightIndexAdjustment) & " - " & getCutMaxLeft(1) & ")" & vbTab & validLengthsC1HprMax(n) & vbTab & "(" & getCutMaxRight(n + rightIndexAdjustment) & " - " & getCutMinLeft(1) & ")"
    Next
End Sub


' Generates min max arrays for the left side - New way to do it
Public Sub generateLeftCutAreas(ByVal deviating_minimum_remaining_web_width As Long)

    ' Set constant GENERATE_CUTAREAS_DEBUGMODE to enable debug mode

    Logger.logFunctionCall 1, "Running " & this.channelTypeKey & ".generateLeftCutAreas(" & deviating_minimum_remaining_web_width & ")"

    ReDim this.leftCutMinArray(1 To 1)
    ReDim this.leftCutMaxArray(1 To 1)
    this.maxLeftCuts = 0

    ' Don't generate if HPR is not enabled
    If this.HPR_enabled Then
        Dim cutMin As Long
        Dim cutMax As Long
        Dim cutAreaWidth As Long
        Dim longestVariant As Long
        Dim validWebNumber As Long
        Dim n As Long
        Dim lastCutMin As Long

        cutMin = 0
        lastCutMin = -1
        validWebNumber = 1
        n = 1

        ' Find longest variant, this assumes that variants have been read
        longestVariant = getMaxSafeLength

        ' Debug
        If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
            Dim i As Long
            '@Ignore AssignmentNotUsed
            i = 0
            Logger.logInfo _
                "i" & vbTab & _
                "cutMin" & vbTab & _
                "cutMax" & vbTab & _
                "validWebNumber" & vbTab & _
                "cutAreaWidth"
        End If
        
        ' Check all possible positions on the full channel length of the longest variant
        Do While cutMin < longestVariant

            If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                i = i + 1
            End If
            
            ' Save old cutMin to be able to check that it is increaseing (a stuck value would indicate end of possible values)
            lastCutMin = cutMin

            ' Find the next min/max
            cutMin = calculateLeftCutMin(n, deviating_minimum_remaining_web_width)
            cutMax = calculateLeftCutMax(n, deviating_minimum_remaining_web_width)

            ' Take care of the case where cutMin < longestVariant but tmp_cutMaxRight > longestVariant
            If cutMax > longestVariant Then
                cutMax = longestVariant
            End If
            
            cutAreaWidth = cutMax - cutMin

            ' Did we get a valid result?
            ' Check if the cut area is positive
            If cutAreaWidth > 0 Then
                If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                    Logger.logInfo _
                        i & vbTab & _
                        cutMin & vbTab & vbTab & vbTab & _
                        cutMax & vbTab & vbTab & vbTab & _
                        validWebNumber & vbTab & vbTab & vbTab & vbTab & _
                        cutAreaWidth
                End If

                ReDim Preserve this.leftCutMinArray(1 To validWebNumber)
                ReDim Preserve this.leftCutMaxArray(1 To validWebNumber)
                this.leftCutMinArray(validWebNumber) = cutMin
                this.leftCutMaxArray(validWebNumber) = cutMax
                validWebNumber = validWebNumber + 1
            Else
                If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                    Logger.logInfo _
                        i & vbTab & _
                        cutMin & vbTab & vbTab & vbTab & _
                        cutMax & vbTab & vbTab & vbTab & _
                        validWebNumber & vbTab & vbTab & vbTab & vbTab & _
                        cutAreaWidth & vbTab & _
                        "<-- not a valid cutArea, skipping!"
                End If
            End If
            
            ' Stop condition, if cutMin is not increasing we have to protect against an endless loop
            If n > 1 And cutMin = lastCutMin Then
                If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                    Logger.logInfo "No more valid cut areas could be found. Stops looking."
                End If
                Exit Do
            End If

            n = n + 1
        Loop

        ' Save max cuts
        this.maxLeftCuts = validWebNumber - 1
    End If
End Sub


' Generates min max arrays for the right side - New way to do it
Public Sub generateRightCutAreas(Optional ByVal deviating_minimum_remaining_web_width As Long)

    ' Set constant GENERATE_CUTAREAS_DEBUGMODE to enable debug mode

    ' Log as 2, as this one runs alot
    Logger.logDeepFunctionCall 2, "Running " & this.channelTypeKey & ".generateRightCutAreas(" & deviating_minimum_remaining_web_width & ")"

    ReDim this.rightCutMinArray(1 To 1)
    ReDim this.rightCutMaxArray(1 To 1)
    this.maxRightCuts = 0
    this.firstRightCutArea_usable = True

    ' Don't generate if HPR is not enabled
    If this.HPR_enabled Then
        Dim cutMin As Long
        Dim cutMax As Long
        Dim cutAreaWidth As Long
        Dim longestVariant As Long
        Dim validWebNumber As Long
        Dim n As Long
        Dim lastCutMin As Long

        cutMin = 0
        lastCutMin = -1
        validWebNumber = 1
        n = 1

        ' Find longest variant, this assumes that variants have been read
        longestVariant = getMaxSafeLength

        ' Debug
        If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
            Dim i As Long
            '@Ignore AssignmentNotUsed
            i = 0
            Logger.logInfo _
                "i" & vbTab & _
                "cutMin" & vbTab & _
                "cutMax" & vbTab & _
                "validWebNumber" & vbTab & _
                "cutAreaWidth"
        End If

        ' Check all possible positions on the full channel length of the longest variant
        Do While cutMin < longestVariant

            If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                i = i + 1
            End If
            
            ' Save old cutMin to be able to check that it is increaseing (a stuck value would indicate end of possible values)
            lastCutMin = cutMin

            ' Find the next min/max
            cutMin = calculateRightCutMin(n, deviating_minimum_remaining_web_width)
            cutMax = calculateRightCutMax(n)    ' Max Right is not dependant upon minumum remaing web

            ' Take care of the case where cutMin < longestVariant but cutMax > longestVariant
            If cutMax > longestVariant Then
                cutMax = longestVariant
            End If

            cutAreaWidth = cutMax - cutMin

            ' Did we get a valid result?
            ' Check if the cut area is positive
            If cutAreaWidth > 0 Then
                If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                    Logger.logInfo _
                        i & vbTab & _
                        cutMin & vbTab & vbTab & vbTab & _
                        cutMax & vbTab & vbTab & vbTab & _
                        validWebNumber & vbTab & vbTab & vbTab & vbTab & _
                        cutAreaWidth
                End If

                ReDim Preserve this.rightCutMinArray(1 To validWebNumber)
                ReDim Preserve this.rightCutMaxArray(1 To validWebNumber)
                this.rightCutMinArray(validWebNumber) = cutMin
                this.rightCutMaxArray(validWebNumber) = cutMax
                validWebNumber = validWebNumber + 1
            Else
                If n = 1 Then
                    this.firstRightCutArea_usable = False
                End If
                
                If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                    Logger.logInfo _
                        i & vbTab & _
                        cutMin & vbTab & vbTab & vbTab & _
                        cutMax & vbTab & vbTab & vbTab & _
                        validWebNumber & vbTab & vbTab & vbTab & vbTab & _
                        cutAreaWidth & vbTab & _
                        "<-- not a valid cutArea, skipping!"
                End If
            End If
            
            ' Stop condition, if cutMin is not increasing we have to protect against an endless loop
            If n > 1 And cutMin = lastCutMin Then
                If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                    Logger.logInfo "No more valid cut areas could be found. Stops looking."
                End If
                Exit Do
            End If

            n = n + 1
        Loop

        ' Save max cuts
        this.maxRightCuts = validWebNumber - 1
    End If
End Sub


' Generates cutMark arrays
Public Sub generateCutMarks()

    ' Set constant GENERATE_CUTAREAS_DEBUGMODE to enable debug mode

    ' Log as 2, as this one runs alot
    Logger.logDeepFunctionCall 2, "Running " & this.channelTypeKey & ".generateCutMarks()"

    ReDim this.rightCutMinArray(1 To 1)
    ReDim this.rightCutMaxArray(1 To 1)
    this.maxRightCuts = 0
    this.firstRightCutArea_usable = True

    ' Don't generate if HPR is not enabled
    If this.HPR_enabled Then
        Dim cutMark As Long
        Dim longestVariant As Long
        Dim validWebNumber As Long
        Dim n As Long
        Dim lastCutMark As Long

        cutMark = 0
        lastCutMark = -1
        validWebNumber = 1
        n = 1

        ' Find longest variant, this assumes that variants have been read
        longestVariant = getMaxSafeLength

        ' Debug
        If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
            Dim i As Long
            '@Ignore AssignmentNotUsed
            i = 0
            Logger.logInfo _
                "i" & vbTab & _
                "cutMin" & vbTab & _
                "cutMax" & vbTab & _
                "validWebNumber" & vbTab & _
                "cutAreaWidth"
        End If

        ' Check all possible positions on the full channel length of the longest variant
        Do While cutMark < longestVariant

            If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                i = i + 1
            End If
            
            ' Save old cutMark to be able to check that it is increaseing (a stuck value would indicate end of possible values)
            lastCutMark = cutMark

            ' Find the next cut mark
            cutMark = calculateCutMark(n)

            If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                Logger.logInfo i & vbTab & _
                               cutMark & vbTab & vbTab & vbTab & _
                               validWebNumber
            End If

            ' TODO: Perhaps change to one cutMark array
            ReDim Preserve this.rightCutMinArray(1 To validWebNumber)
            ReDim Preserve this.rightCutMaxArray(1 To validWebNumber)
            this.rightCutMinArray(validWebNumber) = cutMark
            this.rightCutMaxArray(validWebNumber) = cutMark
            validWebNumber = validWebNumber + 1
            
            ' Stop condition, if cutMark is not increasing we have to protect against an endless loop
            If n > 1 And cutMark = lastCutMark Then
                If Globals.GENERATE_CUTAREAS_DEBUGMODE Then
                    Logger.logInfo "No more valid cut areas could be found. Stops looking."
                End If
                Exit Do
            End If

            n = n + 1
        Loop

        ' TODO: Figure this one out....
        ' Save max cuts (Left and right are the same for cutMarks)
        this.maxRightCuts = validWebNumber - 1
        this.maxLeftCuts = validWebNumber - 1
    End If
End Sub


' Checks the hole pattern relevance on the left side, returns true if the given position is valid
Public Function isValidLeftHPR(ByVal leftPosition As Long) As Boolean
    Dim cutPosNo As Long
    Dim cutPosMin As Long
    Dim cutPosMax As Long
    isValidLeftHPR = False   ' Assume validity to be false and prove that wrong

    If this.HPR_enabled Then
        ' Loop through every possible cut area:
        For cutPosNo = 1 To this.maxLeftCuts
            ' Find cut_min and cut_max
            cutPosMin = getLeftCutMin(cutPosNo)
            cutPosMax = getLeftCutMax(cutPosNo)
            'Logger.logDeep cutPosNo & vbTab & cutPosMin & vbTab & cutPosMax

            ' Check if it fits here at this position
            If leftPosition >= cutPosMin And leftPosition <= cutPosMax Then
                isValidLeftHPR = True
                Exit For
            End If
        Next
    Else
        Logger.logBug "   VALIDATION BUG: Tried to use HPR when not enabled on channelTypeKey=" & this.channelTypeKey
    End If
    Logger.logDeepFunctionCall 1, "   Ran isValidLeftHPR(" & leftPosition & ") = " & isValidLeftHPR & "   [maxCutsLeft: " & this.maxLeftCuts & ", cutPosNo: " & cutPosNo & "]"
End Function


' Checks the hole pattern relevance on the right side, returns true if the given cut is valid
Public Function isValidRightHPR(ByVal rightPosition As Long) As Boolean
    Dim cutPosNo As Long
    Dim cutPosMin As Long
    Dim cutPosMax As Long
    isValidRightHPR = False   ' Assume it is false and prove that wrong
    
    If this.HPR_enabled Then
        For cutPosNo = 1 To this.maxRightCuts
            ' Lookup cut_min and cut_max
            cutPosMin = getRightCutMin(cutPosNo)
            cutPosMax = getRightCutMax(cutPosNo)

            ' Check if it fits here at this position
            If rightPosition >= cutPosMin And rightPosition <= cutPosMax Then
                isValidRightHPR = True
                Exit For
            End If
        Next
    Else
        Logger.logBug "   VALIDATION BUG: Tried to use HPR when not enabled on channelTypeKey=" & this.channelTypeKey
    End If
    Logger.logDeepFunctionCall 1, "   Ran isValidRightHPR(" & rightPosition & ") = " & isValidRightHPR & "   [maxCutsRight: " & this.maxRightCuts & ", cutPosNo: " & cutPosNo & "]"
End Function


' Checks if the given length is valid with regard to hpr, cutWidth and itemMargin.
' Returns an empty string on success, or a string describing the closest range on error.
' Does not care about placement, only checks if it is possible to fit this length anywhere in the channel
' This function needs the channelTypes to have been read in the not to distant past (VBA GC removes the global variables)
' Also needs generateCutMinMax to have been run
Public Function isValidHPRLength( _
    ByVal testLength As Long, _
    ByVal cuttingType As enumCuttingType, _
    ByVal cutWidth As Long, _
    ByVal itemMargin As Long _
) As String
    'Logger.logDeep "isValidHPRLength is run"

    Dim n As Long
    'Dim counter As Long
    Dim isValid As Boolean
    Dim minLength As Long
    Dim maxLength As Long
    Dim lastMin As Long
    Dim lastMax As Long
    Dim itemLengthUsingMargin As Long
    Dim leftSideMax As Long
    Dim rightSideMax As Long
    Dim longestLengthForB As Long
    Dim channelTypeMaxLength As Long

    isValidHPRLength = vbNullString
    
    ' False until proven otherwise
    isValid = False
    
    ' Tests that go for all cuttingTypes:
    
    ' Check that the length is larger than shortest length defined for the channel type
    If testLength < this.minimum_item_length - itemMargin Then
        'Debug.Print "testLength:" & testLength & ", minimum_item_length: " & this.minimum_item_length & ", itemMargin: " & itemMargin & ", conversionFactor: " & Settings.conversionFactor
        isValidHPRLength = Translate("error_length_is_too_short_for_this_type") & " (" & Translate("error_min") & " " & ceiling((this.minimum_item_length - itemMargin) / Settings.conversionFactor) & " " & Translate("var_display_unit_mm") & ")"
    Else
        
        If cuttingType = enumCuttingType.A Then
        
            ' cuttingType A is really simple:
            ' we just add the itemMargin to the length of the channel and we are done.
            channelTypeMaxLength = getMaxSafeLength
            'channelTypeMaxLength = getMaxUsableLength
            
            'Logger.logDeep "channelTypeMaxLength: " & channelTypeMaxLength
            If testLength > channelTypeMaxLength + itemMargin Then
                Logger.logDeep "testLength: " & testLength & " , channelTypeMaxLength = " & channelTypeMaxLength & ", itemMargin = " & itemMargin
                isValidHPRLength = Translate("error_length_is_too_long_for_this_type") & " (" & Translate("error_max") & " " & floor((channelTypeMaxLength + itemMargin) / Settings.conversionFactor) & " " & Translate("var_display_unit_mm") & ")"
            'Else
                ' Ok
                'Logger.logDeep "OK"
            End If
            
        ElseIf cuttingType = enumCuttingType.C1 Then
        
            ' TODO Add support for material margins
        
            'Logger.logDeep "cuttingType = C1"
            ' For cuttingType C1, both sides need to be within the valid cutzones
            ' This gives a bunch of valid lengths, but also restricts the maximum length for cuttingType C pieces
            lastMin = 0
            lastMax = 0
        
            'Logger.logDeep "testLength: " & vbTab & testLength
            'Logger.logDeep "validLengthsC1Count: " & vbTab & validLengthsC1HprCount
            'Logger.logDeep "minimum_item_length: " & vbTab & minimum_item_length
        
            For n = 1 To this.validLengthsC1Count
                minLength = this.validLengthsC1Min(n)
                maxLength = this.validLengthsC1Max(n)
            
                'Logger.logDeep n & vbTab & "minLength" & vbTab & minLength & vbTab & "maxLength" & vbTab & maxLength
            
                If testLength >= minLength And testLength <= maxLength Then
                    ' OK!
                    isValid = True
                    isValidHPRLength = vbNullString
                    Exit For
                    'Logger.logDeep "Valid"
                    'Logger.logDeep "testLength >= minLength And testLength <= maxLength"
                    'Logger.logDeep testLength & " >= " & minLength & " And " & testLength & " <= " & maxLength
                    
                ' Not ok, look if it failed
                ' Shorter than shortest?
                ElseIf n = 1 And testLength < minLength Then
                    ' Fail 1 (shorter than shortest)
                    'Logger.logDeep "Fail 1 (shorter than shortest)"
                    isValid = False
                    isValidHPRLength = Translate("error_invalid_length_closest_range") & ": " & ceiling(minLength / Settings.conversionFactor) & "-" & floor(maxLength / Settings.conversionFactor) & " " & Translate("var_display_unit_mm")
                    Exit For
                    
                ' Not first and not last?
                ElseIf _
                    n > 1 _
                    And n < this.validLengthsC1Count _
                    And testLength < minLength _
                    And testLength > lastMax _
                Then
                    ' Fail 2 (between two ranges)
                    isValid = False
                    'Logger.logDeep "Fail 2 (between two ranges)"
                    'Logger.logDeep "minLength" & vbTab & minLength
                    'Logger.logDeep "testLength" & vbTab & testLength
                    'Logger.logDeep "lastMax" & vbTab & lastMax
                    'Logger.logDeep "n" & vbTab & n
                    isValidHPRLength = Translate("error_invalid_length_closest_range") & ": " & ceiling(lastMin / Settings.conversionFactor) & "-" & floor(lastMax / Settings.conversionFactor) & " " & Translate("error_and") & " " & ceiling(minLength / Settings.conversionFactor) & "-" & floor(maxLength / Settings.conversionFactor) & Translate("var_display_unit_mm")
                    Exit For
                End If
    
                lastMin = minLength
                lastMax = maxLength
            Next
            
            ' If we went through all valid types without finding a valid one
            If isValidHPRLength = vbNullString And Not isValid Then
                ' Fail 3 (larger than last)
                'Logger.logDeep "Fail 3 (larger than last)"
                isValidHPRLength = Translate("error_invalid_length_closest_range") & ": " & ceiling(minLength / Settings.conversionFactor) & "-" & floor(maxLength / Settings.conversionFactor) & " " & Translate("var_display_unit_mm")
            End If
            
        ElseIf cuttingType = enumCuttingType.c2 Then
        
            ' TODO: Add specific support for C2
            ' TODO Add support for material margins
        
            'Logger.logDeep "cuttingType = C2"
            ' For cuttingType C2, both sides need to be within the valid cutzones
            ' This gives a bunch of valid lengths, but also restricts the maximum length for cuttingType C pieces
            lastMin = 0
            lastMax = 0
        
            'Logger.logDeep "testLength: " & vbTab & testLength
            'Logger.logDeep "validLengthsC1Count: " & vbTab & validLengthsC1HprCount
            'Logger.logDeep "minimum_item_length: " & vbTab & minimum_item_length
        
            For n = 1 To this.validLengthsC1Count
                minLength = this.validLengthsC1Min(n)
                maxLength = this.validLengthsC1Max(n)
            
                'Logger.logDeep n & vbTab & "minLength" & vbTab & minLength & vbTab & "maxLength" & vbTab & maxLength
            
                If testLength >= minLength And testLength <= maxLength Then
                    ' OK!
                    isValid = True
                    isValidHPRLength = vbNullString
                    Exit For
                    'Logger.logDeep "Valid"
                    'Logger.logDeep "testLength >= minLength And testLength <= maxLength"
                    'Logger.logDeep testLength & " >= " & minLength & " And " & testLength & " <= " & maxLength
                    
                ' Not ok, look if it failed
                ' Shorter than shortest?
                ElseIf _
                    n = 1 _
                    And testLength < minLength _
                Then
                    ' Fail 1 (shorter than shortest)
                    'Logger.logDeep "Fail 1 (shorter than shortest)"
                    isValid = False
                    isValidHPRLength = Translate("error_invalid_length_closest_range") & ": " & ceiling(minLength / Settings.conversionFactor) & "-" & floor(maxLength / Settings.conversionFactor) & " " & Translate("var_display_unit_mm")
                    Exit For
                    
                ' Not first and not last?
                ElseIf _
                    n > 1 _
                    And n < this.validLengthsC1Count _
                    And testLength < minLength _
                    And testLength > lastMax _
                Then
                    ' Fail 2 (between two ranges)
                    isValid = False
                    'Logger.logDeep "Fail 2 (between two ranges)"
                    'Logger.logDeep "minLength" & vbTab & minLength
                    'Logger.logDeep "testLength" & vbTab & testLength
                    'Logger.logDeep "lastMax" & vbTab & lastMax
                    'Logger.logDeep "n" & vbTab & n
                    isValidHPRLength = Translate("error_invalid_length_closest_range") & ": " & ceiling(lastMin / Settings.conversionFactor) & "-" & floor(lastMax / Settings.conversionFactor) & " " & Translate("error_and") & " " & ceiling(minLength / Settings.conversionFactor) & "-" & floor(maxLength / Settings.conversionFactor) & Translate("var_display_unit_mm")
                    Exit For
                End If
    
                lastMin = minLength
                lastMax = maxLength
            Next
            
            ' If we went through all valid types without finding a valid one
            If isValidHPRLength = vbNullString And Not isValid Then
                ' Fail 3 (larger than last)
                'Logger.logDeep "Fail 3 (larger than last)"
                isValidHPRLength = Translate("error_invalid_length_closest_range") & ": " & ceiling(minLength / Settings.conversionFactor) & "-" & floor(maxLength / Settings.conversionFactor) & " " & Translate("var_display_unit_mm")
            End If
        
        ElseIf cuttingType = enumCuttingType.B1 Then
            'Logger.logDeep "hprType = B1"
            ' For HPR B1, only one side needs to be within a cutting zone.
            ' If this is the left side, the length restriction will be:
            ' from the cut position to the end of the material, on either side of the cut whichever is longer.
            ' Find longest material variant of the given channelType
            
            ' TODO Add support for material margins
            channelTypeMaxLength = getMaxSafeLength
            'channelTypeMaxLength = getMaxUsableLength
            
            ' Find if the longest is on the left or the right side of the cut:
            leftSideMax = getLeftCutMax(1) - cutWidth
            rightSideMax = channelTypeMaxLength - (getRightCutMin(1) + cutWidth)
            If leftSideMax > rightSideMax Then
                longestLengthForB = leftSideMax
                'Logger.logDeep "longest is on right side"
            Else
                longestLengthForB = rightSideMax
                'Logger.logDeep "longest is on right side"
            End If
            'Logger.logDeep "leftSideMax=" & leftSideMax & vbTab & "leftSideMax=" & leftSideMax
            'Logger.logDeep "longestLengthForHPROne=" & longestLengthForHPROne
            
            ' Deal with item margins
            ' For the maximum case, we subtract the marign from the items length
            itemLengthUsingMargin = testLength - itemMargin
            If itemLengthUsingMargin > longestLengthForB Then
                isValidHPRLength = Translate("error_length_is_too_long_for_this_type") & " (" & Translate("error_max") & " " & (toDisplayUnit(longestLengthForB)) & " " & Translate("var_display_unit_mm") & ")"
            'Else
                ' Ok
            End If
            
        ElseIf cuttingType = enumCuttingType.B2 Then
        
            ' TODO: Add specific support for B2 validation
            
            'Logger.logDeep "cuttingType = B2"
            ' For cuttingType B1, only one side needs to be within a cutting zone.
            ' If this is the left side, the length restriction will be:
            ' from the cut position to the end of the material, on either side of the cut whichever is longer.
            ' Find longest material variant of the given channelType
            
            ' TODO Add support for material margins
            channelTypeMaxLength = getMaxSafeLength
            'channelTypeMaxLength = getMaxUsableLength
            
            ' Find if the longest is on the left or the right side of the cut:
            leftSideMax = getLeftCutMax(1) - cutWidth
            rightSideMax = channelTypeMaxLength - (getRightCutMin(1) + cutWidth)
            If leftSideMax > rightSideMax Then
                longestLengthForB = leftSideMax
                'Logger.logDeep "longest is on right side"
            Else
                longestLengthForB = rightSideMax
                'Logger.logDeep "longest is on right side"
            End If
            'Logger.logDeep "leftSideMax=" & leftSideMax & vbTab & "leftSideMax=" & leftSideMax
            'Logger.logDeep "longestLengthForB=" & longestLengthForB
            
            ' Deal with item margins
            ' For the maximum case, we subtract the marign from the items length
            itemLengthUsingMargin = testLength - itemMargin
            If itemLengthUsingMargin > longestLengthForB Then
                isValidHPRLength = Translate("error_length_is_too_long_for_this_type") & " (" & Translate("error_max") & " " & (toDisplayUnit(longestLengthForB)) & " " & Translate("var_display_unit_mm") & ")"
            'Else
                ' Ok
            End If
        End If
    End If
End Function


' Pareses the key and save the result in the individual variables
Public Sub parseKey()
    '@Ignore UseMeaningfulName
    Dim keyArr1() As String
    '@Ignore UseMeaningfulName
    Dim keyArr2() As String
    
    ' Split by - (ctype - size_extra - material)
    ' 0 should always be present, contains type
    ' 1 should always be present, contains size [+ extra]
    ' 2 is opional and contains Material if it exists
    keyArr1 = Split(this.channelTypeKey, "-")
    If UBound(keyArr1) > 0 Then
        this.ctype = keyArr1(0)
        ' Split by + (size + extra)
        keyArr2 = Split(keyArr1(1), "+")
        this.size = keyArr2(0)
        If UBound(keyArr2) > 0 Then
            this.extra = keyArr2(1)
        End If
        If UBound(keyArr1) > 1 Then
            this.material = keyArr1(2)
        End If
    End If
End Sub


Public Function matches( _
    ByVal ctypeTest As String, _
    ByVal sizeTest As String, _
    ByVal extraTest As String, _
    ByVal materialTest As String, _
    ByVal cuttingTypeTest As String, _
    ByVal matchStrict As String _
) As Boolean

    ' Matches strictL: don't treat empty value as wildcard for this value
    ' Assume it matches and prove it does not
    matches = True
    If (Not ctypeTest = vbNullString And Not matchStrict = "type") And Not ctypeTest = this.ctype Then
        matches = False
    ElseIf (Not sizeTest = vbNullString And Not matchStrict = "size") And Not sizeTest = this.size Then
        matches = False
    ElseIf (Not extraTest = vbNullString And Not matchStrict = "extra") And Not extraTest = this.extra Then
        matches = False
    ElseIf (Not materialTest = vbNullString And Not matchStrict = "material") And Not materialTest = this.material Then
        matches = False
    ElseIf (cuttingTypeTest = "B1" Or cuttingTypeTest = "B2" Or cuttingTypeTest = "C1" Or cuttingTypeTest = "C2") And Not this.HPR_enabled Then
        matches = False
    End If
End Function


Public Function getHiltiStdTolerance(ByVal length As Long) As Long

    ' MM
    If Settings.unit = Globals.UNIT_MM Then
        If length <= 10000 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance1
        ElseIf length <= 20000 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance2
        ElseIf length <= 30000 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance3
        ElseIf length <= 40000 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance4
        ElseIf length <= 50000 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance5
        Else ' length > 50000
            getHiltiStdTolerance = this.hilti_standard_tolerance6
        End If
    
    ' INCH
    Else
        '4ft = 4800 (1/100")
        '6ft = 7200 (1/100")
        '10ft = 12000 (1/100")
        '20ft = 24000 (1/100")
        
        If length <= 4800 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance1
        ElseIf length <= 7200 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance2
        ElseIf length <= 12000 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance3
        ElseIf length <= 24000 Then
            getHiltiStdTolerance = this.hilti_standard_tolerance4
        Else ' length > 24000
            getHiltiStdTolerance = this.hilti_standard_tolerance5
        End If
    End If

End Function

Attribute VB_Name = "CChannelTypeSet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CChannelTypeSet contains the currently defined channels

Private Type TChannelTYpeSet
    channelTypes() As CChannelType
    channelTypeCount As Long
    uniqueType As String
    uniqueSize As String
    uniqueExtra As String
    uniqueMaterialCoating As String
End Type

Private this As TChannelTYpeSet

Private Sub class_initialize()
    this.channelTypeCount = 0
    this.uniqueType = vbNullString
    this.uniqueSize = vbNullString
    this.uniqueExtra = vbNullString
    this.uniqueMaterialCoating = vbNullString
End Sub

Public Property Get channelTypes() As CChannelType()
    '@Ignore ObjectVariableNotSet
    channelTypes = this.channelTypes
End Property

Public Property Get uniqueType() As String
    uniqueType = this.uniqueType
End Property

Public Property Get uniqueSize() As String
    uniqueSize = this.uniqueSize
End Property

Public Property Get uniqueExtra() As String
    uniqueExtra = this.uniqueExtra
End Property

Public Property Get uniqueMaterialCoating() As String
    uniqueMaterialCoating = this.uniqueMaterialCoating
End Property

Public Property Get count()
    count = this.channelTypeCount
End Property

Public Function getChType(ByVal channelTypeNo As Long) As CChannelType
    If channelTypeNo > 0 And this.channelTypeCount >= channelTypeNo Then
        Set getChType = this.channelTypes(channelTypeNo)
    End If
End Function

Public Sub addChannelType(ByVal newChannelType As CChannelType)
    this.channelTypeCount = this.channelTypeCount + 1
    ReDim Preserve this.channelTypes(1 To this.channelTypeCount)
    '@Ignore ObjectVariableNotSet
    Set this.channelTypes(this.channelTypeCount) = newChannelType
End Sub


'Public Function getName(channelTypeNo As Long) As String
'    getName = this.channelTypes(channelTypeNo).channelTypeKey
'End Function

Public Sub addVariant( _
    ByVal chTypeVariant As CChannelTypeVariant, _
    ByVal channelTypeNo As Long _
)
    this.channelTypes(channelTypeNo).addVariant chTypeVariant
End Sub

'Public Sub clearChannelTypes()
'    ReDim this.channelTypes(1 To 1)
'    this.channelTypeCount = 0
'End Sub


' Clears variants from all channelTypes
'Public Sub clearVariants()
'    Dim channelTypeNo As Long
'    For channelTypeNo = 1 To this.channelTypeCount
'        this.channelTypes(channelTypeNo).clearVariants
'    Next
'End Sub


Public Function getMaxCapacity(ByVal chtype As String) As Long
    getMaxCapacity = 0
    Dim i As Long
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = chtype Then
            getMaxCapacity = this.channelTypes(i).getMaxSafeLength
        End If
    Next
End Function


Public Function getMaxUsableLength(ByVal chtype As String) As Long
    getMaxUsableLength = 0
    Dim i As Long
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = chtype Then
            getMaxUsableLength = this.channelTypes(i).getMaxUsableLength
        End If
    Next
End Function


Public Function getMaxLength(ByVal chtype As String) As Long
    getMaxLength = 0
    Dim i As Long
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = chtype Then
            getMaxLength = this.channelTypes(i).getMaxLength
        End If
    Next
End Function


' returns the variant of the given type and length
Public Function getVariant(ByVal chtype As String, ByVal length As Long) As CChannelTypeVariant
    Dim i As Long
    Dim j As Long
    Dim allVariants() As CChannelTypeVariant
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = chtype Then
            allVariants = this.channelTypes(i).variants
            For j = 1 To this.channelTypes(i).variantCount
                If allVariants(j).length = length Then
                    Set getVariant = allVariants(j)
                    Exit For
                    Exit For
                End If
            Next
        End If
    Next
End Function


' Returns the channel type number from a SAP number, or -1 if it does not exist
'Public Function getTypeNoFromSAP(ByVal SAP_no As String) As Long
'    Dim i As Long
'    Dim j As Long
'    Dim found As Boolean
'    Dim allVariants() As CChannelTypeVariant
'    For i = 1 To this.channelTypeCount
'        allVariants = this.channelTypes(i).variants
'        For j = 1 To this.channelTypes(i).variantCount
'            If allVariants(j).SAP_number = SAP_no Then
'                getTypeNoFromSAP = i
'                found = True
'                Exit For
'                Exit For
'            End If
'        Next
'    Next
'    If Not found Then
'        getTypeNoFromSAP = -1
'    End If
'End Function


' Returns the channel type number from a SAP number, no error handling, assumes SAP_no is valid
'Public Function getDescriptionFromSAP(ByVal SAP_no As String) As String
'    Dim i As Long
'    Dim j As Long
'    Dim allVariants() As CChannelTypeVariant
'    For i = 1 To this.channelTypeCount
'        allVariants = this.channelTypes(i).variants
'        For j = 1 To this.channelTypes(i).variantCount
'            If allVariants(j).SAP_number = SAP_no Then
'                getDescriptionFromSAP = allVariants(j).SAP_description
'                Exit For
'                Exit For
'            End If
'        Next
'    Next
'End Function


' Returns a channel type from a SAP number, no error handling, assumes SAP_no is valid
'Public Function getChTypeFromSAP(ByVal SAP_no As String) As CChannelType
'    Dim i As Long
'    Dim j As Long
'    Dim variants() As CChannelTypeVariant
'    For i = 1 To this.channelTypeCount
'        variants = this.channelTypes(i).variants
'        For j = 1 To this.channelTypes(i).variantCount
'            If variants(j).SAP_number = SAP_no Then
'                Set getChTypeFromSAP = channelTypes(i)
'                Exit For
'                Exit For
'            End If
'        Next
'    Next
'End Function


' Returns a channel type from a channelType name as string
Public Function getChTypeFromKey(ByVal channelTypeKey As String) As CChannelType
    Dim i As Long
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = channelTypeKey Then
            Set getChTypeFromKey = this.channelTypes(i)
            Exit For
        End If
    Next
End Function


' Returns a channel type from a channelType name as string
Public Function getChTypeIndexFromKey(ByVal channelTypeKey As String) As Long
    Dim i As Long
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = channelTypeKey Then
            getChTypeIndexFromKey = i
            Exit For
        End If
    Next
End Function


'Public Function variantCount(ByVal chType As String) As Long
'    variantCount = 0
'    Dim i As Long
'    For i = 1 To this.channelTypeCount
'        If this.channelTypes(i).channelTypeKey = chType Then
'            variantCount = this.channelTypes(i).variantCount
'        End If
'    Next
'End Function


Public Function getSmallerVariants(ByVal chtype As String, ByVal capacity As Long) As CChannelTypeVariant()
    Dim i As Long
    Dim j As Long
    Dim variantNo As Long
    variantNo = 1
    
    Dim smallarVariants() As CChannelTypeVariant
    Dim allVariants() As CChannelTypeVariant
    'ReDim smallarVariants(1 To 1)

    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = chtype Then
            allVariants = this.channelTypes(i).variants
            For j = 1 To this.channelTypes(i).variantCount
                If allVariants(j).safeLength < capacity Then
                    ReDim Preserve smallarVariants(1 To variantNo)
                    '@Ignore ObjectVariableNotSet
                    Set smallarVariants(variantNo) = allVariants(j)
                    variantNo = variantNo + 1
                End If
            Next
            
            ' Break loop
            Exit For
        End If
    Next
    getSmallerVariants = smallarVariants
End Function


Public Function typeExists(ByVal chtype As String) As Boolean
    Dim i As Long
    typeExists = False
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).channelTypeKey = chtype Then
            typeExists = True
            Exit For
        End If
    Next
End Function


' Generate cut positions for all channel types
' Has to be run after variants has been read
Public Sub generateCutPositionsForAll()
    Logger.logFunctionCall 1, "Running generateCutPositionsForAll()"
    Dim i As Long
    For i = 1 To this.channelTypeCount
        this.channelTypes(i).generateCutPositions -1
    Next
End Sub


' Generate cut positions for all channel types
' Has to be run after variants has been read
Public Sub recalculateCutPositionsForChannelType( _
    ByVal channelTypeKey As String, _
    ByVal deviating_minimum_remaingin_web As Long _
)
    Logger.logFunctionCall 1, "Running recalculateCutPositionsForChannelType(" & channelTypeKey & ", " & deviating_minimum_remaingin_web & ")"
    Logger.logInfo "Recalculating cut positions for chtype=" & channelTypeKey
    Dim channelTypeIndex As Long
    ' Protect against errors when running on an empty set
    If channelTypeKey <> vbNullString Then
        channelTypeIndex = getChTypeIndexFromKey(channelTypeKey)
        this.channelTypes(channelTypeIndex).generateCutPositions deviating_minimum_remaingin_web
    End If
End Sub


' Saves a list of unique values of: type, size, extra and materialCoating in string variables
Public Sub generateValidationStrings()
    Dim i As Long
    Dim j As Long
    
    Dim typeUnique As Boolean
    Dim sizeUnique As Boolean
    Dim extraUnique As Boolean
    Dim materialCoatingUnique As Boolean
    
    Dim typeArr() As String
    Dim sizeArr() As String
    Dim extraArr() As String
    Dim materialCoatingArr() As String
    
    Dim typeArrLength As Long
    Dim sizeArrLength As Long
    Dim extraArrLength As Long
    Dim materialCoatingArrLength As Long
    
    typeArrLength = 0
    sizeArrLength = 0
    extraArrLength = 0
    materialCoatingArrLength = 0
    
    For i = 1 To this.channelTypeCount
        typeUnique = True
        sizeUnique = True
        extraUnique = True
        materialCoatingUnique = True
        
        For j = 1 To typeArrLength
            If typeArr(j) = this.channelTypes(i).ctype Then
                typeUnique = False
            End If
        Next
        For j = 1 To sizeArrLength
            If sizeArr(j) = this.channelTypes(i).size Then
                sizeUnique = False
            End If
        Next
        For j = 1 To extraArrLength
            If extraArr(j) = this.channelTypes(i).extra Then
                extraUnique = False
            End If
        Next
        For j = 1 To materialCoatingArrLength
            If materialCoatingArr(j) = this.channelTypes(i).material Then
                materialCoatingUnique = False
            End If
        Next
        
        If typeUnique And Not this.channelTypes(i).ctype = vbNullString Then
            typeArrLength = typeArrLength + 1
            ReDim Preserve typeArr(1 To typeArrLength)
            typeArr(typeArrLength) = this.channelTypes(i).ctype
        End If
        If sizeUnique And Not this.channelTypes(i).size = vbNullString Then
            sizeArrLength = sizeArrLength + 1
            ReDim Preserve sizeArr(1 To sizeArrLength)
            sizeArr(sizeArrLength) = this.channelTypes(i).size
        End If
        If extraUnique And Not this.channelTypes(i).extra = vbNullString Then
            extraArrLength = extraArrLength + 1
            ReDim Preserve extraArr(1 To extraArrLength)
            extraArr(extraArrLength) = this.channelTypes(i).extra
        End If
        If materialCoatingUnique And Not this.channelTypes(i).material = vbNullString Then
            materialCoatingArrLength = materialCoatingArrLength + 1
            ReDim Preserve materialCoatingArr(1 To materialCoatingArrLength)
            materialCoatingArr(materialCoatingArrLength) = this.channelTypes(i).material
        End If
    Next
    
    qSortInPlace typeArr
    qSortInPlace sizeArr
    qSortInPlace extraArr
    qSortInPlace materialCoatingArr

    this.uniqueType = Join(typeArr, ",")
    this.uniqueSize = Join(sizeArr, ",")
    this.uniqueExtra = Join(extraArr, ",")
    this.uniqueMaterialCoating = Join(materialCoatingArr, ",")
End Sub


Public Function getSpecificValidatorsType( _
    ByVal size As String, _
    ByVal extra As String, _
    ByVal material As String, _
    ByVal cuttingType As String _
) As String
    Dim i As Long
    Dim j As Long
    Dim typeUnique As Boolean
    Dim typeArr() As String
    Dim typeArrLength As Long
    typeArrLength = 0
        
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).matches( _
            ctypeTest:=vbNullString, _
            sizeTest:=size, _
            extraTest:=extra, _
            materialTest:=material, _
            cuttingTypeTest:=cuttingType, _
            matchStrict:=vbNullString _
        ) Then

            typeUnique = True
        
            For j = 1 To typeArrLength
                If typeArr(j) = this.channelTypes(i).ctype Then
                    typeUnique = False
                End If
            Next
        
            If typeUnique And Not this.channelTypes(i).ctype = vbNullString Then
                typeArrLength = typeArrLength + 1
                ReDim Preserve typeArr(1 To typeArrLength)
                typeArr(typeArrLength) = this.channelTypes(i).ctype
            End If
        End If
    Next
    
    ' Sort them so we get a nice display
    If typeArrLength > 0 Then
        qSortInPlace typeArr
        getSpecificValidatorsType = Join(typeArr, ",")
    Else
        getSpecificValidatorsType = vbNullString
    End If
    
End Function


Public Function getSpecificValidatorsSize( _
    ByVal ctype As String, _
    ByVal extra As String, _
    ByVal material As String, _
    ByVal cuttingType As String _
) As String
    Dim i As Long
    Dim j As Long
    
    Dim sizeUnique As Boolean
    Dim sizeArr() As String
    Dim sizeArrLength As Long
    sizeArrLength = 0
            
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).matches( _
            ctypeTest:=ctype, _
            sizeTest:=vbNullString, _
            extraTest:=extra, _
            materialTest:=material, _
            cuttingTypeTest:=cuttingType, _
            matchStrict:=vbNullString _
        ) Then
            sizeUnique = True
        
            For j = 1 To sizeArrLength
                If sizeArr(j) = this.channelTypes(i).size Then
                    sizeUnique = False
                End If
            Next
        
            If sizeUnique And Not this.channelTypes(i).size = vbNullString Then
                sizeArrLength = sizeArrLength + 1
                ReDim Preserve sizeArr(1 To sizeArrLength)
                sizeArr(sizeArrLength) = this.channelTypes(i).size
            End If
        End If
    Next
    
    ' Sort them so we get a nice display
    If sizeArrLength > 0 Then
        qSortInPlace sizeArr
        getSpecificValidatorsSize = Join(sizeArr, ",")
    Else
        getSpecificValidatorsSize = vbNullString
    End If
End Function


Public Function getSpecificValidatorsExtra( _
    ByVal ctype As String, _
    ByVal size As String, _
    ByVal material As String, _
    ByVal cuttingType As String _
) As String

    Dim i As Long
    Dim j As Long
    
    Dim extraUnique As Boolean
    Dim extraArr() As String
    Dim extraArrLength As Long
    extraArrLength = 0
            
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).matches( _
            ctypeTest:=ctype, _
            sizeTest:=size, _
            extraTest:=vbNullString, _
            materialTest:=material, _
            cuttingTypeTest:=cuttingType, _
            matchStrict:=vbNullString _
        ) Then
            extraUnique = True
        
            For j = 1 To extraArrLength
                If extraArr(j) = this.channelTypes(i).extra Then
                    extraUnique = False
                End If
            Next
            
            If extraUnique And Not this.channelTypes(i).extra = vbNullString Then
                extraArrLength = extraArrLength + 1
                ReDim Preserve extraArr(1 To extraArrLength)
                extraArr(extraArrLength) = this.channelTypes(i).extra
            End If
        End If
    Next
    
    If extraArrLength > 0 Then
        qSortInPlace extraArr
        getSpecificValidatorsExtra = Join(extraArr, ",")
    Else
        getSpecificValidatorsExtra = vbNullString
    End If
End Function


Public Function getSpecificValidatorsMaterial( _
    ByVal ctype As String, _
    ByVal size As String, _
    ByVal extra As String, _
    ByVal cuttingType As String _
) As String
    Dim i As Long
    Dim j As Long
    
    Dim materialCoatingUnique As Boolean
    Dim materialCoatingArr() As String
    Dim materialCoatingArrLength As Long
    materialCoatingArrLength = 0
    
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).matches( _
            ctypeTest:=ctype, _
            sizeTest:=size, _
            extraTest:=extra, _
            materialTest:=vbNullString, _
            cuttingTypeTest:=cuttingType, _
            matchStrict:=vbNullString _
        ) Then
            materialCoatingUnique = True
        
            For j = 1 To materialCoatingArrLength
                If materialCoatingArr(j) = this.channelTypes(i).material Then
                    materialCoatingUnique = False
                End If
            Next
            
            If materialCoatingUnique And Not this.channelTypes(i).material = vbNullString Then
                materialCoatingArrLength = materialCoatingArrLength + 1
                ReDim Preserve materialCoatingArr(1 To materialCoatingArrLength)
                materialCoatingArr(materialCoatingArrLength) = this.channelTypes(i).material
            End If
        End If
    Next
    
    ' Sort them so we get a nice display
    If materialCoatingArrLength > 0 Then
        qSortInPlace materialCoatingArr
        getSpecificValidatorsMaterial = Join(materialCoatingArr, ",")
    Else
        getSpecificValidatorsMaterial = vbNullString
    End If
End Function


Public Function getSpecificValidatorsCuttingType( _
    ByVal ctype As String, _
    ByVal size As String, _
    ByVal extra As String, _
    ByVal material As String _
) As String
    Dim i As Long
    Dim hprEnabledOnOneInSet As Boolean    ' Defult case, only A enabled
    
    hprEnabledOnOneInSet = False

    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).matches( _
            ctypeTest:=ctype, _
            sizeTest:=size, _
            extraTest:=extra, _
            materialTest:=material, _
            cuttingTypeTest:=vbNullString, _
            matchStrict:=vbNullString _
        ) Then
            If this.channelTypes(i).HPRenabled Then
                hprEnabledOnOneInSet = True
            End If
        End If
    Next
    
    ' If any one channel in the set has hpr enabled we should give the option of choosing hpr
    If hprEnabledOnOneInSet Then
        getSpecificValidatorsCuttingType = "A,B1,B2,C1,C2"
    Else
        getSpecificValidatorsCuttingType = "A"
    End If
End Function


'Public Sub getSpecificValidators(ByVal ctype As String, _
'                                 ByVal size As String, _
'                                 ByVal extra As String, _
'                                 ByVal material As String, _
'                                 ByVal hpr As String, _
'                                 ByRef sizeValidators As String, _
'                                 ByRef extraValidators As String, _
'                                 ByRef materialValidators As String, _
'                                 ByRef hprValidators As String)
'
'    Dim i As Long
'    Dim j As Long
'
'    Dim sizeUnique As Boolean
'    Dim extraUnique As Boolean
'    Dim materialCoatingUnique As Boolean
'
'    Dim sizeArr() As String
'    Dim extraArr() As String
'    Dim materialCoatingArr() As String
'
'    Dim sizeArrLength As Long
'    Dim extraArrLength As Long
'    Dim materialCoatingArrLength As Long
'
'    sizeArrLength = 0
'    extraArrLength = 0
'    materialCoatingArrLength = 0
'
'    ' Defult case, only zero enabled
'    Dim hprEnabledOnOneInSet As Boolean
'    hprEnabledOnOneInSet = False
'
'    For i = 1 To this.channelTypeCount
'        If this.channelTypes(i).matches(ctypeTest:=ctype, _
'                                        sizeTest:=size, _
'                                        extraTest:=Extra, _
'                                        materialTest:=material, _
'                                        hptTest:=hpr, _
'                                        matchStrict:=vbNullString) _
'        Then
'
'            sizeUnique = True
'            extraUnique = True
'            materialCoatingUnique = True
'
'            For j = 1 To sizeArrLength
'                If sizeArr(j) = this.channelTypes(i).size Then
'                    sizeUnique = False
'                End If
'            Next
'            For j = 1 To extraArrLength
'                If extraArr(j) = this.channelTypes(i).extra Then
'                    extraUnique = False
'                End If
'            Next
'            For j = 1 To materialCoatingArrLength
'                If materialCoatingArr(j) = this.channelTypes(i).material Then
'                    materialCoatingUnique = False
'                End If
'            Next
'
'            If this.channelTypes(i).HPR_enabled Then
'                hprEnabledOnOneInSet = True
'            End If
'
'            If sizeUnique And Not this.channelTypes(i).size = vbNullString Then
'                sizeArrLength = sizeArrLength + 1
'                ReDim Preserve sizeArr(1 To sizeArrLength)
'                sizeArr(sizeArrLength) = this.channelTypes(i).size
'            End If
'            If extraUnique And Not this.channelTypes(i).extra = vbNullString Then
'                extraArrLength = extraArrLength + 1
'                ReDim Preserve extraArr(1 To extraArrLength)
'                extraArr(extraArrLength) = this.channelTypes(i).extra
'            End If
'            If materialCoatingUnique And Not this.channelTypes(i).material = vbNullString Then
'                materialCoatingArrLength = materialCoatingArrLength + 1
'                ReDim Preserve materialCoatingArr(1 To materialCoatingArrLength)
'                materialCoatingArr(materialCoatingArrLength) = this.channelTypes(i).material
'            End If
'        End If
'    Next
'
'    ' Sort them so we get a nice display
'    If sizeArrLength > 0 Then
'        qSortInPlace sizeArr
'        sizeValidators = Join(sizeArr, ",")
'    Else
'        sizeValidators = vbNullString
'    End If
'    If extraArrLength > 0 Then
'        qSortInPlace extraArr
'        extraValidators = Join(extraArr, ",")
'    Else
'        extraValidators = vbNullString
'    End If
'    If materialCoatingArrLength > 0 Then
'        qSortInPlace materialCoatingArr
'        materialValidators = Join(materialCoatingArr, ",")
'    Else
'        materialValidators = vbNullString
'    End If
'
'    ' If any one channel in the set has hpr enabled we should give the option of choosing hpr
'    If hprEnabledOnOneInSet Then
'        hprValidators = "A,B1,B2,C1,C2"
'    Else
'        hprValidators = "A"
'    End If
'End Sub


Public Function isValidType( _
    ByVal ctype As String, _
    ByVal size As String, _
    ByVal extra As String, _
    ByVal materialCoating As String, _
    ByVal cuttingType As String, _
    ByVal matchStrict As String _
) As Boolean
    Dim i As Long
    isValidType = False
    
    For i = 1 To this.channelTypeCount
        If this.channelTypes(i).matches( _
            ctypeTest:=ctype, _
            sizeTest:=size, _
            extraTest:=extra, _
            materialTest:=materialCoating, _
            cuttingTypeTest:=cuttingType, _
            matchStrict:=matchStrict _
        ) Then
            isValidType = True
            Exit For
        End If
    Next
End Function


Public Function getIdFromKey(ByVal channelTypeKeyTest As String) As Long
    getIdFromKey = 0
    For getIdFromKey = 1 To this.channelTypeCount
        If channelTypeKeyTest = this.channelTypes(getIdFromKey).channelTypeKey Then
            Exit For
        End If
    Next
End Function


Attribute VB_Name = "CChannelTypeSheet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit

Public Sub readVariants(ByRef channelTypeSet As CChannelTypeSet)
    'Logger.logInfo "Reading variants:"

    Dim i As Long
    Dim lastRow As Long
    Dim rangeChannelTypeVariantCount As Long
    Dim myVariant As CChannelTypeVariant
    
    ' Used to keep the data from the sheet
    Dim rangeChannelEnabled As Variant
    Dim rangeChannelTypeKey As Variant
    Dim rangeChannelSAPNumber As Variant
    Dim rangeChannelSAPDescription As Variant
    Dim rangeChannelLengthName As Variant
    Dim rangeChannelDeleveryTolerancePlus As Variant
    Dim rangeChannelDeleveryToleranceMinus As Variant
    Dim rangeChannelCutCost As Variant
    Dim rangeChannelLength As Variant
    Dim rangeChannelCost As Variant
    Dim rangeChannelBundleSize As Variant
    
    ' Read channels specifications
    With Settings.sheetChannelTypes
        
        ' Find last row:
        lastRow = .Range( _
            Globals.CHTYPE_COL_TYPE & _
            .Rows.count).End(xlUp).Row
        
        ' Sort the table according to: Channel type, Length
        .Range( _
            Globals.CHTYPE_COL_TYPE & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_BUNDLE_SIZE & _
            lastRow _
        ).sort _
            key1:=.Range( _
                Globals.CHTYPE_COL_TYPE & _
                Globals.CHTYPE_ROW_FIRST & _
                ":" & _
                Globals.CHTYPE_COL_TYPE & _
                lastRow _
            ), _
            order1:=xlAscending, _
            Key2:=.Range( _
                Globals.CHTYPE_COL_LENGTH & _
                Globals.CHTYPE_ROW_FIRST & _
                ":" & _
                Globals.CHTYPE_COL_LENGTH & _
                lastRow _
            ), _
            order2:=xlAscending, _
            MatchCase:=True, _
            Orientation:=xlSortColumns
    
        ' Read the sheet
        rangeChannelEnabled = .Range( _
            Globals.CHTYPE_COL_ENABLED & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_ENABLED & _
            lastRow _
        ).value
        rangeChannelTypeKey = .Range( _
            Globals.CHTYPE_COL_TYPE & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_TYPE & _
            lastRow _
        ).value
        rangeChannelSAPNumber = .Range( _
            Globals.CHTYPE_COL_SAP_NUMBER & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_SAP_NUMBER & _
            lastRow _
        ).value
        rangeChannelSAPDescription = .Range( _
            Globals.CHTYPE_COL_SAP_DESCRIPTION & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_SAP_DESCRIPTION & _
            lastRow _
        ).value
        rangeChannelLengthName = .Range( _
            Globals.CHTYPE_COL_LENGTH_NAME & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_LENGTH_NAME & _
            lastRow _
        ).value
        rangeChannelDeleveryTolerancePlus = .Range( _
            Globals.CHTYPE_COL_DELIVERY_TOLERANCE_PLUS & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_DELIVERY_TOLERANCE_PLUS & _
            lastRow _
        ).value
        rangeChannelDeleveryToleranceMinus = .Range( _
            Globals.CHTYPE_COL_DELIVERY_TOLERANCE_MINUS & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_DELIVERY_TOLERANCE_MINUS & _
            lastRow _
        ).value
        rangeChannelCutCost = .Range( _
            Globals.CHTYPE_COL_CUT_COST & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_CUT_COST & _
            lastRow _
        ).value
        rangeChannelLength = .Range( _
            Globals.CHTYPE_COL_LENGTH & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_LENGTH & _
            lastRow _
        ).value
        rangeChannelCost = .Range( _
            Globals.CHTYPE_COL_COST & _
            Globals.CHTYPE_ROW_FIRST & ":" & _
            Globals.CHTYPE_COL_COST & _
            lastRow _
        ).value
        rangeChannelBundleSize = .Range( _
            Globals.CHTYPE_COL_BUNDLE_SIZE & _
            Globals.CHTYPE_ROW_FIRST & _
            ":" & _
            Globals.CHTYPE_COL_BUNDLE_SIZE & _
            lastRow _
        ).value
        
        ' Count Channel variants names
        rangeChannelTypeVariantCount = UBound(rangeChannelTypeKey)
        
        Dim channelTypeNo As Long
        
        For i = 1 To rangeChannelTypeVariantCount
            If rangeChannelEnabled(i, 1) = "1" Then

                ' Find which channel type to add to
                channelTypeNo = Request.channelTypeSet.getIdFromKey(rangeChannelTypeKey(i, 1))
                
                ' Sanity check
                If channelTypeNo > 0 Then
                    ' Always add a variant
                    Set myVariant = New CChannelTypeVariant
                    myVariant.setValues _
                        lengthName:=rangeChannelLengthName(i, 1), _
                        deliveryTolerancePlus:=rangeChannelDeleveryTolerancePlus(i, 1), _
                        deliveryToleranceMinus:=rangeChannelDeleveryToleranceMinus(i, 1), _
                        cutCost:=rangeChannelCutCost(i, 1), _
                        length:=rangeChannelLength(i, 1), _
                        cost:=rangeChannelCost(i, 1), _
                        bundleSize:=rangeChannelBundleSize(i, 1), _
                        SAP_number:=rangeChannelSAPNumber(i, 1), _
                        SAP_description:=rangeChannelSAPDescription(i, 1)
                    channelTypeSet.addVariant _
                        myVariant, _
                        channelTypeNo
                Else
                    Logger.logError i & vbTab & "Channel type not found " & vbTab & rangeChannelTypeKey(i, 1)
                End If
            End If
        Next
    End With
End Sub


Public Sub readTechnicalData(ByRef channelTypeSet As CChannelTypeSet)
    
    ' Don't try to read values if they contain errors
    If checkTechnicalData_all Then
    
        Dim i As Long
        Dim lastRow As Long
        Dim rangeChannelTypeCount As Long
        Dim tmpChannelType As CChannelType
        
        ' Used to keep the data from the sheet
        Dim rangeChannelTypeKey As Variant
        Dim rangeChannelMinimumItemLength As Variant
        Dim rangeChannelHiltiStandardTolerance1 As Variant
        Dim rangeChannelHiltiStandardTolerance2 As Variant
        Dim rangeChannelHiltiStandardTolerance3 As Variant
        Dim rangeChannelHiltiStandardTolerance4 As Variant
        Dim rangeChannelHiltiStandardTolerance5 As Variant
        Dim rangeChannelHiltiStandardTolerance6 As Variant
        Dim rangeChannelHPREnabled As Variant
        Dim rangeChannelStepLength As Variant
        Dim rangeChannelHoleLength As Variant
        Dim rangeChannelWebWidth As Variant
        Dim rangeChannelFirstWebWidthCut As Variant
        Dim rangeChannelFirstWebWidthShear As Variant
        Dim rangeChannelMinimumRemainingWebWidth As Variant
        Dim rangeChannelStartPositionError As Variant
        Dim rangeChannelHolePositionError As Variant
        Dim rangeChannelHoleLengthErrorPlus As Variant
        Dim rangeChannelHoleLengthErrorMinus As Variant
            
        ' Read channels specifications
        With Settings.sheetTechnicalData
            
            ' Find last row:
            lastRow = .Range(Globals.TECHNICAL_DATA_COL_TYPE & .Rows.count).End(xlUp).Row
            
            ' Sort the table according to: Channel type (unique)
            .Range( _
                Globals.TECHNICAL_DATA_COL_TYPE & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS & _
                lastRow _
            ).sort _
                key1:=.Range( _
                    Globals.TECHNICAL_DATA_COL_TYPE & _
                    Globals.TECHNICAL_DATA_ROW_FIRST & _
                    ":" & _
                    Globals.TECHNICAL_DATA_COL_TYPE & _
                    lastRow), _
                order1:=xlAscending, _
                MatchCase:=True, _
                Orientation:=xlSortColumns
        
            ' Read the sheet
            rangeChannelTypeKey = .Range( _
                Globals.TECHNICAL_DATA_COL_TYPE & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_TYPE & _
                lastRow _
            ).value
            rangeChannelMinimumItemLength = .Range( _
                Globals.TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH & _
                lastRow _
            ).value
            rangeChannelHiltiStandardTolerance1 = .Range( _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 & _
                lastRow _
            ).value
            rangeChannelHiltiStandardTolerance2 = .Range( _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 & _
                lastRow _
            ).value
            rangeChannelHiltiStandardTolerance3 = .Range( _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 & _
                lastRow _
            ).value
            rangeChannelHiltiStandardTolerance4 = .Range( _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 & _
                lastRow _
            ).value
            rangeChannelHiltiStandardTolerance5 = .Range( _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 & _
                lastRow _
            ).value
            rangeChannelHiltiStandardTolerance6 = .Range( _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 & _
                lastRow _
            ).value
            rangeChannelHPREnabled = .Range( _
                Globals.TECHNICAL_DATA_COL_HPR_ENABLED & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HPR_ENABLED & _
                lastRow _
            ).value
            rangeChannelStepLength = .Range( _
                Globals.TECHNICAL_DATA_COL_STEP_LENGTH & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_STEP_LENGTH & _
                lastRow _
            ).value
            rangeChannelHoleLength = .Range( _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH & _
                lastRow _
            ).value
            rangeChannelWebWidth = .Range( _
                Globals.TECHNICAL_DATA_COL_WEB_WIDTH & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_WEB_WIDTH & _
                lastRow _
            ).value
            rangeChannelFirstWebWidthCut = .Range( _
                Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT & _
                lastRow _
            ).value
            rangeChannelFirstWebWidthShear = .Range( _
                Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR & _
                lastRow _
            ).value
            rangeChannelMinimumRemainingWebWidth = .Range( _
                Globals.TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH & _
                lastRow _
            ).value
            rangeChannelStartPositionError = .Range( _
                Globals.TECHNICAL_DATA_COL_START_POSITION_ERROR & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_START_POSITION_ERROR & _
                lastRow _
            ).value
            rangeChannelHolePositionError = .Range( _
                Globals.TECHNICAL_DATA_COL_HOLE_POSITION_ERROR & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HOLE_POSITION_ERROR & _
                lastRow _
            ).value
            rangeChannelHoleLengthErrorPlus = .Range( _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS & _
                lastRow _
            ).value
            rangeChannelHoleLengthErrorMinus = .Range( _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS & _
                Globals.TECHNICAL_DATA_ROW_FIRST & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS & _
                lastRow _
            ).value
            
            ' Count and fix Channel variants names
            rangeChannelTypeCount = UBound(rangeChannelTypeKey)
            
            ' Read variant table:
            Dim hasVariants As Boolean
            Dim j As Long
            Dim variantLastRow As Long
            Dim rangeChannelTypeVariantEnabled As Variant
            Dim rangeChannelTypeVariantType As Variant
            Dim rangeChannelTypeVariantCount As Long
            variantLastRow = Settings.sheetChannelTypes.Range( _
                Globals.CHTYPE_COL_TYPE & _
                Settings.sheetChannelTypes.Rows.count _
            ).End(xlUp).Row
            rangeChannelTypeVariantEnabled = Settings.sheetChannelTypes.Range( _
                Globals.CHTYPE_COL_ENABLED & _
                Globals.CHTYPE_ROW_FIRST & _
                ":" & _
                Globals.CHTYPE_COL_ENABLED & _
                variantLastRow _
            ).value
            rangeChannelTypeVariantType = Settings.sheetChannelTypes.Range( _
                Globals.CHTYPE_COL_TYPE & _
                Globals.CHTYPE_ROW_FIRST & _
                ":" & _
                Globals.CHTYPE_COL_TYPE & _
                variantLastRow _
            ).value
            rangeChannelTypeVariantCount = UBound(rangeChannelTypeVariantType)
            
            For i = 1 To rangeChannelTypeCount
            
                ' Make sure that the a channel from technical data has at least one enabled variant
                hasVariants = False
                For j = 1 To rangeChannelTypeVariantCount
                    If rangeChannelTypeVariantEnabled(j, 1) = 1 _
                    And rangeChannelTypeVariantType(j, 1) = rangeChannelTypeKey(i, 1) Then
                        hasVariants = True
                        Exit For
                    End If
                Next
                
                ' Only add the ones with variants
                If hasVariants Then
                    ' Add a new type
                    Set tmpChannelType = New CChannelType
                    tmpChannelType.channelTypeKey = rangeChannelTypeKey(i, 1)
                    tmpChannelType.minimumItemLength = rangeChannelMinimumItemLength(i, 1)
                    tmpChannelType.hiltiStandardTolerance1 = rangeChannelHiltiStandardTolerance1(i, 1)
                    tmpChannelType.hiltiStandardTolerance2 = rangeChannelHiltiStandardTolerance2(i, 1)
                    tmpChannelType.hiltiStandardTolerance3 = rangeChannelHiltiStandardTolerance3(i, 1)
                    tmpChannelType.hiltiStandardTolerance4 = rangeChannelHiltiStandardTolerance4(i, 1)
                    tmpChannelType.hiltiStandardTolerance5 = rangeChannelHiltiStandardTolerance5(i, 1)
                    tmpChannelType.hiltiStandardTolerance6 = rangeChannelHiltiStandardTolerance6(i, 1)
                    tmpChannelType.HPRenabled = rangeChannelHPREnabled(i, 1)
                    tmpChannelType.stepLength = rangeChannelStepLength(i, 1)
                    tmpChannelType.holeLength = rangeChannelHoleLength(i, 1)
                    tmpChannelType.webWidth = rangeChannelWebWidth(i, 1)
                    tmpChannelType.firstWebWidthCut = rangeChannelFirstWebWidthCut(i, 1)
                    tmpChannelType.firstWebWidthShear = rangeChannelFirstWebWidthShear(i, 1)
                    If Settings.cuttingMethod = enumCuttingMethod.Cutting Then
                        tmpChannelType.firstWebWidth = tmpChannelType.firstWebWidthCut
                    Else
                        tmpChannelType.firstWebWidth = tmpChannelType.firstWebWidthShear
                    End If
                    tmpChannelType.minimumRemainingWebWidth = rangeChannelMinimumRemainingWebWidth(i, 1)
                    tmpChannelType.startPositionError = rangeChannelStartPositionError(i, 1)
                    tmpChannelType.holePositionError = rangeChannelHolePositionError(i, 1)
                    tmpChannelType.holeLengthErrorPlus = rangeChannelHoleLengthErrorPlus(i, 1)
                    tmpChannelType.holeLengthErrorMinus = rangeChannelHoleLengthErrorMinus(i, 1)
                    tmpChannelType.parseKey
                    
                    channelTypeSet.addChannelType tmpChannelType
                End If
            Next
        End With
    End If
End Sub




Attribute VB_Name = "CChannelTypeVariant"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CChannelTypeVariant class

' CChannelTypeVariant contains a the details of a channel variant

Private Type TChannelTypeVariant
    lengthName As String                ' Readable name for this variant
    deliveryTolerancePlus As Long       ' Delevery tolerance in +-1/10 mm, positive side
    deliveryToleranceMinus As Long      ' Delevery tolerance in +-1/10 mm, negative side
    cutCost As Long                     ' Cost per cut |fffd| cents
    length As Long                      ' Length of this type in 1/10 mm
    cost As Long                        ' Cost per material in |fffd| cents
    bundleSize As Long                  ' Number of channels in the bundle
    SAP_number As String                ' SAP number of this variant
    SAP_description As String           ' SAP description for this variant
End Type

Private this As TChannelTypeVariant

Public Property Get cutCost() As Long
    cutCost = this.cutCost
End Property

Public Property Get length() As Long
    length = this.length
End Property

Public Property Get cost() As Long
    cost = this.cost
End Property

Public Property Get SAPnumber() As String
    SAPnumber = this.SAP_number
End Property

Public Property Get SAPdescription() As String
    SAPdescription = this.SAP_description
End Property

Private Sub class_initialize()
    this.lengthName = vbNullString
    this.deliveryTolerancePlus = 0
    this.deliveryToleranceMinus = 0
    this.cutCost = 0
    this.length = 0
    this.cost = 0
    this.bundleSize = 0
    this.SAP_number = vbNullString
    this.SAP_description = vbNullString
End Sub

Public Sub setValues( _
    ByVal lengthName As String, _
    ByVal deliveryTolerancePlus As Long, _
    ByVal deliveryToleranceMinus As Long, _
    ByVal cutCost As Long, _
    ByVal length As Long, _
    ByVal cost As Long, _
    ByVal bundleSize As Long, _
    ByVal SAP_number As String, _
    ByVal SAP_description As String _
)
    this.lengthName = lengthName
    this.deliveryTolerancePlus = deliveryTolerancePlus
    this.deliveryToleranceMinus = deliveryToleranceMinus
    this.cutCost = cutCost
    this.length = length
    this.cost = cost
    this.bundleSize = bundleSize
    this.SAP_number = SAP_number
    this.SAP_description = SAP_description
End Sub

Public Property Get safeLength() As Long
    safeLength = this.length - this.deliveryToleranceMinus
End Property

'Public Function getChannelTypeVariantCopy() As CChannelTypeVariant
'    Set getChannelTypeVariantCopy = New CChannelTypeVariant
'    getChannelTypeVariantCopy.lengthName = this.lengthName
'    getChannelTypeVariantCopy.deliveryTolerancePlus = this.deliveryTolerancePlus
'    getChannelTypeVariantCopy.deliveryToleranceMinus = this.deliveryToleranceMinus
'    getChannelTypeVariantCopy.cutCost = this.cutCost
'    getChannelTypeVariantCopy.length = this.length
'    getChannelTypeVariantCopy.cost = this.cost
'    getChannelTypeVariantCopy.SAP_number = this.SAP_number
'    getChannelTypeVariantCopy.SAP_description = this.SAP_description
'End Function
Attribute VB_Name = "CDiagram"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CDiagram class

' Contains methods for creating diagrams, in particular stacked diagrams where the series are not continuos

' TODO Make columns wider if there are two of them (so the text can be shown)

Private Const DIAGRAM_HEIGHT As Long = 780
Private Const DIAGRAM_COLUMN_WIDTH As Long = 20
Private Const DIAGRAM_LEGEND_WIDTH As Long = 128
Private Const DIAGRAM_LEGEND_MARGIN As Long = 40
Private Const DIAGRAM_PLOTAREA_MARGIN As Long = 60
Private Const DIAGRAM_MARGIN_WIDTH As Long = 80
Private Const DIAGRAM_MARGIN_RIGHT As Long = 40
Private Const DIAGRAM_FUDGE_WIDTH As Long = 52   '32
Private Const DIAGRAM_MINIMUM_WIDTH As Long = 200

' Creates the output diagrams
Public Sub createDiagrams(Optional ByRef pgForm As ProgressForm)
        
    ' Measure time taken
    Dim startTime As Single
    Dim diagramTime As Single
    startTime = Timer
    diagramTime = Timer
    Logger.logInfoBoth "Creating diagrams..."
    
    Const RIGHT_MARGIN As Long = 30
    
    Dim diagramDimenstions As typeDimension
    Dim diagramNo As Long
    Dim diagramCount As Long
    Dim binSetNo As Long
    
    Dim topOffset As Double
    Dim leftOffset As Double
    Dim lineWidth As Double
    Dim lineBreakWidth As Double
    Dim cellNo As Long
    
    lineBreakWidth = 1000
    lineWidth = 0
    cellNo = 1
    topOffset = SheetDiagrams.Range("A" & cellNo).Top
    leftOffset = SheetDiagrams.Range("A" & cellNo).Left
    
    diagramCount = Request.chTypeCount + 1
    pgForm.resetMainProgress diagramCount
    diagramNo = 1
    
    
    ' Create circle diagram
    If Settings.showCosts Then
        pgForm.nextStepMain "Generating diagram "
        diagramCount = diagramCount + 1
        createCircleDiagramTotals _
            Sheet:=SheetOutputLists, _
            dataStartRow:=circleDiagramStartRow, _
            dataStartCol:=2
        Logger.logInfoBoth diagramNo & "/" & diagramCount & "     t=" & Round(Timer - diagramTime, 2) & "s"
        diagramTime = Timer
        diagramNo = diagramNo + 1
    End If
    
    ' Copy Legend image to clipboard from the hidden Images sheet
    ' only copy it once to save some time
    ' Use different images based on the set language
    ' Try to use language specicifed image
    If shapeExists("LegendImage_" & Settings.Language, SheetImages) Then
        SheetImages.Shapes("LegendImage_" & Settings.Language).Copy
    Else
        ' Fallback English legend image
        SheetImages.Shapes("LegendImage_English").Copy
    End If

    ' Create one diagram that holds all types
    pgForm.nextStepMain "Generating diagram "
    diagramDimenstions = createStackedDiagram( _
        sourceSheet:=SheetProfilesUnique, _
        destinationSheet:=SheetDiagrams, _
        chartTitleIn:=Translate("diagram_unique_profiles") & " - " & Translate("diagram_all_channel_types"), _
        parentTop:=topOffset, _
        parentLeft:=leftOffset, _
        doColor:=True, _
        showLegend:=True, _
        onlyUniqueBins:=True, _
        addLabels:=True, _
        channelTypeKey:=vbNullString _
    )

    Logger.logInfoBoth diagramNo & "/" & diagramCount & "     t=" & Round(Timer - diagramTime, 2) & "s"
    diagramTime = Timer
    diagramNo = diagramNo + 1
    
    cellNo = cellNo + 63
    topOffset = SheetDiagrams.Range("A" & cellNo).Top + 2
    leftOffset = SheetDiagrams.Range("A" & cellNo).Left
    
    ' Create one input and one output diagram per used ChannelType
    For binSetNo = 1 To Request.chTypeCount
        
        pgForm.nextStepMain "Generating diagram "
        
        Dim binSets() As CBinSet
        binSets = Request.getSolutions

        diagramDimenstions = createInputDiagram( _
            sourceSheet:=SheetRequestedUnique, _
            destinationSheet:=SheetDiagrams, _
            parentTop:=topOffset, _
            parentLeft:=leftOffset, _
            showLegend:=False, _
            addLabels:=True, _
            channelTypeKey:=binSets(binSetNo).channelTypeKey _
        )
        
        leftOffset = leftOffset + diagramDimenstions.width + RIGHT_MARGIN
        lineWidth = lineWidth + diagramDimenstions.width + RIGHT_MARGIN
        diagramDimenstions = createStackedDiagram( _
            sourceSheet:=SheetProfilesUnique, _
            destinationSheet:=SheetDiagrams, _
            chartTitleIn:=Translate("diagram_unique_profiles"), _
            parentTop:=topOffset, _
            parentLeft:=leftOffset, _
            doColor:=True, _
            showLegend:=True, _
            onlyUniqueBins:=True, _
            addLabels:=True, _
            channelTypeKey:=binSets(binSetNo).channelTypeKey _
        )
        
        lineWidth = lineWidth + diagramDimenstions.width + RIGHT_MARGIN

        'Logger.logInfo "diagramsheet this lineWidth: " & lineWidth

        If binSetNo > 1 And lineWidth < lineBreakWidth Then
            'Logger.logInfo "moving diagram"
            leftOffset = lineWidth + SheetDiagrams.Range("A" & cellNo).Left
        Else
            ' Add "line break"
            lineWidth = 0
            cellNo = cellNo + 63
            topOffset = SheetDiagrams.Range("A" & cellNo).Top + 2
            leftOffset = SheetDiagrams.Range("A" & cellNo).Left
        End If

        Logger.logInfoBoth diagramNo & "/" & diagramCount & "     t=" & Round(Timer - diagramTime, 2) & "s"
        diagramTime = Timer
        diagramNo = diagramNo + 1
    Next
    pgForm.finnishMain

    ' Report time
    Logger.logInfoBoth "done."
    Logger.logInfoBoth "Time " & Round(Timer - startTime, 2) & "s"
    
End Sub

Public Sub createCircleDiagramTotals( _
    ByVal Sheet As Worksheet, _
    ByVal dataStartRow As Long, _
    ByVal dataStartCol As Long _
)
    Dim dia As chartObject
    Dim theChart As chart
    Dim srcRange As Range
    Dim diagramStartCell As Range
    Const CIRCLE_DIAGRAM_WIDTH As Long = 160
    Const CIRCLE_DIAGRAM_HEIGHT As Long = 55
    Const CIRCLE_DIAGRAM_MARGIN_TOP As Long = 10
    Const CIRCLE_DIAGRAM_MARGIN_LEFT As Long = 0

    'Logger.logInfo "dataStartRow:" & dataStartRow
    'Logger.logInfo "dataStartCol:" & dataStartCol
    
    ' Create chart
    With Sheet
        ' Place the diagram just next to the total cost calculation
        Set diagramStartCell = .Range( _
            .Cells(dataStartRow - 1, dataStartCol + 1), _
            .Cells(dataStartRow - 1, dataStartCol + 1) _
        )
        Set dia = .ChartObjects.Add( _
            diagramStartCell.Left + CIRCLE_DIAGRAM_MARGIN_LEFT, _
            diagramStartCell.Top + CIRCLE_DIAGRAM_MARGIN_TOP, _
            CIRCLE_DIAGRAM_WIDTH, CIRCLE_DIAGRAM_HEIGHT _
        )
        Set theChart = dia.chart
    End With
    
    Sheet.Activate
    
    With theChart
        ' This gives two axis
        ' Set source data
        .ChartType = xlPieExploded
        Set srcRange = Sheet.Range( _
            Sheet.Cells(dataStartRow, dataStartCol), _
            Sheet.Cells(dataStartRow + 2, dataStartCol - 1) _
        )
        .SetSourceData Source:=srcRange
        .ChartArea.Format.line.visible = msoFalse ' Disable line around diagram
        
        ' Set to shortened names:
        .SeriesCollection(1).XValues = _
            "={""" & _
            Translate("var_used") & """;""" & _
            Translate("var_waste") & """;""" & _
            Translate("var_cuts") & """}"
        
        ' Use standard colors
        .SeriesCollection(1).Points(1).Format.Fill.ForeColor.RGB = Globals.COLOR_NORMAL_ODD
        .SeriesCollection(1).Points(1).Format.line.ForeColor.RGB = Globals.COLOR_NORMAL_ODD_BORDER
        .SeriesCollection(1).Points(1).Format.line.visible = msoTrue
        .SeriesCollection(1).Points(2).Format.Fill.ForeColor.RGB = Globals.COLOR_WASTE
        .SeriesCollection(1).Points(2).Format.line.ForeColor.RGB = Globals.COLOR_WASTE_BORDER
        .SeriesCollection(1).Points(2).Format.line.visible = msoTrue
        .SeriesCollection(1).Points(3).Format.Fill.ForeColor.RGB = Globals.COLOR_CUT
        .SeriesCollection(1).Points(3).Format.line.ForeColor.RGB = Globals.COLOR_CUT_BORDER
        .SeriesCollection(1).Points(3).Format.line.visible = msoTrue
        
        
        ' These would be used to make the diagram a bit more compressed in size
        ' However, excel becomes really buggy while using them and gives "Run-time error '-2147467259 (80004005)'"
        ' This error is related to timings and objects not existing yet, as running through the debugger works.
        ' Wait until the control is ready:
        '.AutoScaling = False
        
        .legend.Left = 90                        ' Change position of legend
        .legend.width = 82
    End With
End Sub

' Creates a multi series stacked column diagram, with optional coloring
Public Function createStackedDiagram( _
    ByVal sourceSheet As Worksheet, _
    ByVal destinationSheet As Worksheet, _
    ByVal chartTitleIn As String, _
    ByVal parentTop As Double, _
    ByVal parentLeft As Double, _
    ByVal doColor As Boolean, _
    ByVal showLegend As Boolean, _
    ByVal onlyUniqueBins As Boolean, _
    ByVal addLabels As Boolean, _
    ByVal channelTypeKey As String _
) As typeDimension
    
    Dim chartTitle As String
    chartTitle = chartTitleIn
    
    'Logger.logInfo "Input data:"
    'Logger.logInfo "sourceSheet=" & sourceSheet.name & vbTab & "destinationSheet=" & destinationSheet.name & vbTab & "chartTitle=" & chartTitle & vbTab & "parentTop=" & parentTop & vbTab & "parentLeft=" & parentLeft & vbTab & "doColor=" & doColor
    
    ' Work around an ugly Excel bug!
    destinationSheet.Select
    destinationSheet.Range("A1").Select

    Dim binSets() As CBinSet

    Dim firstRow As Long
    Dim firstCol As Long
    Dim lastRow As Long
    Dim lastCol As Long
    '@Ignore VariableNotUsed
    Dim pLoop As Long
    
    Dim binSetNo As Long
    Dim binNo As Long
    Dim pieceNo As Long
    Dim maximiumScaleY As Long
    Dim diagramColumnCount As Long
    Dim diagramSeriesCount As Long
    Dim diagramSeriesCountProtection As Boolean
    Dim diagramWidth As Long
    Dim pieceType As enumPieceType
    Dim pieceHPRPlacement As enumHPRPlacement
    Dim pieceLength As Long
    Dim dia As chartObject
    Dim theChart As chart
    Dim srcRange As Range
    Dim thisRow As Long
    Dim thisCol As Long
    Dim channelLoopStart As Long
    Dim channelLoopStop As Long
    
    diagramSeriesCountProtection = False
    
    ' Find first/last row/col
    With sourceSheet
        If channelTypeKey = vbNullString Then
            ' Make a diagram of all channelTypes
        
            ' Fixed start row/col
            firstRow = Globals.BINS_ROW_PIECES
            firstCol = Globals.BINS_COL_DIAGRAM_START
            
            ' The last non empty row/col in the first col/row
            lastRow = .Range("B" & .Rows.count).End(xlUp).Row
            lastCol = .Cells(1, .Columns.count).End(xlToLeft).Column
            
            ' Set up channel loop to default, this will loop through all the available channel types
            channelLoopStart = 1
            channelLoopStop = Request.chTypeCount
        Else
            ' Make a diagram of a specific channelType
            
            ' First column is fixed
            firstCol = Globals.BINS_COL_DIAGRAM_START
            
            ' Last row is the last row of the table
            lastRow = .Range("B" & .Rows.count).End(xlUp).Row
            
            ' Find first row with the given channel type
            For thisRow = Globals.BINS_ROW_PIECES To lastRow
                If .Cells(thisRow, Globals.BINS_COL_TYPE_NO).value = channelTypeKey Then
                    firstRow = thisRow
                    Exit For
                End If
            Next

            ' It can happen here that the channel type will not exist, this is indicative of a bug in the placement of a higher function
            ' But nevertheless we handle it here as well, we set firstRow=1 which will return an empty set and produce an empty diagram
            If firstRow = 0 Then
                Logger.logBug "channelTypeKey:" & channelTypeKey & " could not be found"
                firstRow = 1
            End If

            ' Find last row with the given channel type
            Dim n As Long
            n = lastRow
            Do While n >= firstRow
                If .Cells(n, Globals.BINS_COL_TYPE_NO).value = channelTypeKey Then
                    lastRow = n
                    Exit Do
                End If
                n = n - 1
            Loop
            
            ' The last non empty row/col in the first col/row
            lastCol = .Cells(1, .Columns.count).End(xlToLeft).Column
            
            ' Set up channel loop to only use the one channel type that was requested

            ' Find the channelTypeKey index number
            binSetNo = Request.getIndexNo(channelTypeKey)
            
            channelLoopStart = binSetNo
            channelLoopStop = binSetNo
            
            ' Find lastcolumn, we cannot just use the heading row to determine, it might be shorter so we have to loop through all rows
            Dim highestCol As Long
            highestCol = 0
            For thisRow = firstRow To lastRow
                thisCol = .Cells(thisRow, .Columns.count).End(xlToLeft).Column
                If lastCol > highestCol Then
                    highestCol = lastCol
                End If
            Next
            lastCol = highestCol
            
            ' Set chart title to channelTypeKey
            chartTitle = channelTypeKey
        End If
    End With
    
    ' Protection here
    ' Calculate number of series (the first two are labels)
    diagramSeriesCount = lastCol - firstCol - 1
    
    ' Protect against too many series:
    If diagramSeriesCount > Globals.MAXIMUM_PIECES_IN_DIAGRAM Then
        lastCol = Globals.MAXIMUM_PIECES_IN_DIAGRAM + firstCol + 1
        diagramSeriesCount = Globals.MAXIMUM_PIECES_IN_DIAGRAM
        diagramSeriesCountProtection = True
    End If

    ' Find Y axis MaximumScale and calculate diagram size
    ' Also find largest bin
    '@Ignore AssignmentNotUsed
    maximiumScaleY = toDisplayUnit(Request.getMaxCapacity)
    
    diagramColumnCount = lastRow - firstRow + 1
    maximiumScaleY = ceiling(maximiumScaleY, 100) ' Round up to nearest thousend
    
    ' Default column width
    Dim diagramColumnWidth As Long
    diagramColumnWidth = DIAGRAM_COLUMN_WIDTH
    ' Set wider columns for diagrams with 2 columns in order for the data labels to be seen fully
    'If diagramColumnCount = 2 Then
    '    diagramColumnWidth = DIAGRAM_COLUMN_WIDTH_WIDE
    'End If
    
    If showLegend Then
        diagramWidth = DIAGRAM_MARGIN_WIDTH + _
            diagramColumnCount * diagramColumnWidth + _
            DIAGRAM_LEGEND_WIDTH + _
            DIAGRAM_LEGEND_MARGIN
    Else
        diagramWidth = DIAGRAM_MARGIN_WIDTH + _
        diagramColumnCount * diagramColumnWidth + _
        DIAGRAM_MARGIN_RIGHT
    End If
    
    If diagramWidth < DIAGRAM_MINIMUM_WIDTH Then
        diagramWidth = DIAGRAM_MINIMUM_WIDTH
    End If
   
    ' Create chart
    With destinationSheet
        ' TODO: Fix issue: method 'Add' of object 'ChartObjects' failed
        Set dia = destinationSheet.ChartObjects.Add( _
            parentTop, _
            parentLeft, _
            diagramWidth, _
            DIAGRAM_HEIGHT _
        )
        Set theChart = dia.chart
    End With
    
    With theChart
        
        ' This gives two axis
        .ChartType = xlColumnStacked
        Set srcRange = sourceSheet.Range( _
            sourceSheet.Cells(firstRow, firstCol), _
            sourceSheet.Cells(lastRow, lastCol) _
        )
        .SetSourceData Source:=srcRange, PlotBy:=xlColumns ' Set to plot by columns explicit (this is normally automatic but fails for small sets)
       
        .setElement msoElementChartTitleAboveChart ' Add title
        .chartTitle.Text = chartTitle
       
        ' X axis
        .setElement msoElementPrimaryCategoryAxisTitleAdjacentToAxis ' Add axis title
        .Axes(xlCategory, xlPrimary).AxisTitle.Text = _
            Translate("diagram_channel_type") & Chr$(13) & _
            Translate("diagram_quantity")
        .Axes(xlCategory).Format.line.visible = msoFalse ' Take off ugly lines on axis
        .Axes(xlCategory).TickLabels.Font.size = 8 ' Set font size 8
        .Axes(xlCategory).TickLabels.Orientation = 50 ' Lean the data axis labels a bit
        
        ' Y axis
        .setElement msoElementPrimaryValueAxisTitleRotated ' Add axis title
        .Axes(xlValue, xlPrimary).AxisTitle.Text = Translate("diagram_length_mm")
        .Axes(xlValue).MaximumScale = maximiumScaleY ' Adjust max
        .Axes(xlValue).MinimumScale = 0
        .Axes(xlValue).MajorUnit = 1000
        .Axes(xlValue).MinorUnit = 100
        
        ' Workaround: Fix axis category labels for diagrams with few columns
        If diagramColumnCount = 1 Then
            Dim xVals() As Variant
            xVals = .SeriesCollection(1).XValues
            xVals(1) = sourceSheet.Cells(firstRow, 3).value & vbCrLf & sourceSheet.Cells(firstRow, 2).value
            .SeriesCollection(1).XValues = xVals
            .Axes(xlCategory).TickLabels.Orientation = 0
            .Axes(xlCategory).TickLabels.Offset = 300
        ElseIf diagramColumnCount = 2 Then
            .Axes(xlCategory).TickLabels.Orientation = 70
        End If
        
        ' Diagram as a whole
        .legend.Delete                           ' No built in legend (it won't work with our series)
        .ChartGroups(1).GapWidth = 0             ' Remove gap between blocks
        .Parent.height = DIAGRAM_HEIGHT
        .Parent.Top = parentTop                  ' Set position to max top left
        .Parent.Left = parentLeft
        
        
        ' This piece of code is needed to work around a bug in Excel 2010
        ' For details see here:
        ' http://stackoverflow.com/questions/13812491/error-setting-plotarea-width-in-excel-vba-excel-2010
        With .PlotArea
            On Error Resume Next
            .height = DIAGRAM_HEIGHT - 2 * DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .height = DIAGRAM_HEIGHT - 2 * DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .width = diagramColumnCount * diagramColumnWidth + DIAGRAM_FUDGE_WIDTH
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .height = DIAGRAM_HEIGHT - 2 * DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .Top = DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .Top = DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .Left = DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .Left = DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .InsideWidth = diagramColumnCount * diagramColumnWidth
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .InsideWidth = diagramColumnCount * diagramColumnWidth
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .InsideLeft = DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .InsideLeft = DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            On Error GoTo 0
        End With

        ' Show legend
        If showLegend Then
            ' Determine legend size and position
            Const LEGEND_HEIGHT As Long = 110
            Const LEGEND_WIDTH As Long = 80
            Dim legendLeft As Long
            Dim legendTop As Long
            legendLeft = diagramWidth - LEGEND_WIDTH - DIAGRAM_LEGEND_MARGIN
            legendTop = DIAGRAM_HEIGHT / 2 - LEGEND_HEIGHT / 2

            ' Copy/paste image from the images sheet
            .ChartArea.Select
            ' There is a timing problem here, sometimes the select command will not work
            DoEvents
            .Paste
            
            ' There will now only be one shape in the diagram area (the fake legend)
            .Shapes(1).Top = legendTop
            .Shapes(1).Left = legendLeft
        End If

        ' Show warning when protection is in use
        If diagramSeriesCountProtection Then
            Const WARNING_HEIGHT As Long = 80
            Const WARNING_WIDTH As Long = 81
            Dim warningLeft As Long
            Dim warningTop As Long
            warningLeft = diagramWidth - WARNING_WIDTH - DIAGRAM_LEGEND_MARGIN
            warningTop = (DIAGRAM_HEIGHT / 3) * 2 - WARNING_HEIGHT / 2
            .Shapes.AddTextbox( _
                Orientation:=msoTextOrientationHorizontal, _
                Left:=warningLeft, _
                Top:=warningTop, _
                width:=WARNING_WIDTH, _
                height:=WARNING_HEIGHT _
            ).Select
            Selection.ShapeRange(1).TextFrame2.TextRange.Characters.Text = _
                Translate("var_showing_only_the_first") & " " & _
                Globals.MAXIMUM_PIECES_IN_DIAGRAM & " " & _
                Translate("var_pieces")
            Selection.ShapeRange.TextFrame2.TextRange.Font.Fill.ForeColor.RGB = RGB(255, 0, 0)
        End If
        
        If doColor Then
            Dim flipFlop_normal As Boolean
            Dim flipFlop_left As Boolean
            Dim flipFlop_right As Boolean
            Dim flipFlop_both As Boolean
            Dim fillColor As Long
            Dim backColor As Long
            Dim fillPattern As Long
            Dim lineColor As Long
            Dim pieceCountUsed As Long
            fillPattern = 0
            
            binSets = Request.getSolutions
            
            thisRow = 1
            ' Loop through BinSets
            'Logger.logInfo "channelLoopStop = " & channelLoopStop
            ' ChannelLoop is an enhancement to be able to color only a certain channeltype, it is set above
            For binSetNo = channelLoopStart To channelLoopStop
                
                'Logger.logInfo binSetNo & "/" & channelLoopStop
                'Logger.logInfo "Doing color ALL"
                'Logger.logInfo "binSets(" & binSetNo & ").binCount=" & binSets(binSetNo).binCount
                For binNo = 1 To binSets(binSetNo).count
                
                    If Not onlyUniqueBins Or (onlyUniqueBins And binSets(binSetNo).getBin(binNo).uniqueProfile) Then
                        ' Reset all flipflops
                        flipFlop_normal = True
                        flipFlop_left = True
                        flipFlop_right = True
                        flipFlop_both = True
                    
                        'Logger.logInfo "binSets(" & binSetNo & ").getPieceCount(" & binNo & ")=" & binSets(binSetNo).getPieceCount(binNo)
                        
                        pieceCountUsed = binSets(binSetNo).getPieceCount(binNo)
                        ' If protection is in place
                        If diagramSeriesCountProtection And pieceCountUsed > Globals.MAXIMUM_PIECES_IN_DIAGRAM Then
                            pieceCountUsed = Globals.MAXIMUM_PIECES_IN_DIAGRAM
                        End If
                        
                        For pieceNo = 1 To pieceCountUsed
                            
                            backColor = Globals.COLOR_DEFAULT_BACKGROUND
                            thisCol = pieceNo
                            pieceType = binSets(binSetNo).getPieceType(binNo, pieceNo)
                            pieceHPRPlacement = binSets(binSetNo).getPieceHPRPlacement(binNo, pieceNo)
                            pieceLength = binSets(binSetNo).getPieceLength(binNo, pieceNo)
                            'Logger.logInfo thisCol & vbTab & ":"
                            'Logger.logInfo ".Axes(xlSecondary).MinimumScale=" & vbTab & .Axes(xlSecondary).MinimumScale
                            'Logger.logInfo ".Axes(xlSecondary).MinimumScale=" & vbTab & .Axes(xlSecondary).MinimumScale

                            If pieceType = enumPieceType.waste Then
                                'Logger.logInfo "Coloring as waste"
                                fillColor = Globals.COLOR_WASTE
                                lineColor = Globals.COLOR_WASTE_BORDER
                                fillPattern = msoPatternWideUpwardDiagonal
                            ElseIf pieceType = enumPieceType.cut Then
                                If Not Settings.diagramHideCuts Then
                                    'Logger.logInfo "Coloring as cut"
                                    ' Show cuts
                                    fillColor = Globals.COLOR_CUT
                                    lineColor = Globals.COLOR_CUT_BORDER
                                    'Else
                                    'Logger.logInfo "Does not coloring as cut due to setting"
                                    ' Hide cuts, disguaise them as the previous piece
                                    ' That means: do nothing, the color should already be set up right from last round, or set to the default on first run
                                    End If
                                    fillPattern = 0
                                ElseIf pieceHPRPlacement = enumHPRPlacement.bothSides Then
                                    'Logger.logInfo "Coloring as HPR both"
                                    fillColor = Globals.COLOR_HPR_BOTH
                                    lineColor = Globals.COLOR_HPR_BOTH_BORDER
                                    backColor = Globals.COLOR_HPR_BOTH_BACKGROUND
                                    fillPattern = msoPatternOutlinedDiamond
                                    flipFlop_both = Not flipFlop_both
                                ElseIf pieceHPRPlacement = enumHPRPlacement.leftSide Then
                                    'Logger.logInfo "Coloring as HPR left"
                                    fillColor = Globals.COLOR_HPR_LEFT
                                    lineColor = Globals.COLOR_HPR_LEFT_BORDER
                                    backColor = Globals.COLOR_HPR_LEFT_BACKGROUND
                                    fillPattern = msoPatternDarkDownwardDiagonal
                                    flipFlop_left = Not flipFlop_left
                                ElseIf pieceHPRPlacement = enumHPRPlacement.rightSide Then
                                    'Logger.logInfo "Coloring as HPR right"
                                    fillColor = Globals.COLOR_HPR_RIGHT
                                    lineColor = Globals.COLOR_HPR_RIGHT_BORDER
                                    backColor = Globals.COLOR_HPR_RIGHT_BACKGROUND
                                    fillPattern = msoPatternDarkUpwardDiagonal
                                    flipFlop_right = Not flipFlop_right
                                ElseIf flipFlop_normal Then
                                    'Logger.logInfo "Coloring as normal 1"
                                    fillColor = Globals.COLOR_NORMAL_ODD
                                    lineColor = Globals.COLOR_NORMAL_ODD_BORDER
                                    fillPattern = 0
                                    flipFlop_normal = Not flipFlop_normal
                                Else
                                    'Logger.logInfo "Coloring as normal 2"
                                    fillColor = Globals.COLOR_NORMAL_EVEN
                                    lineColor = Globals.COLOR_NORMAL_EVEN_BORDER
                                    fillPattern = 0
                                    flipFlop_normal = Not flipFlop_normal
                                End If
                            
                                If Settings.diagramPatternInstedOfColor Then
                                    .SeriesCollection(thisCol).Points(thisRow).Format.Fill.ForeColor.RGB = fillColor
                                    .SeriesCollection(thisCol).Points(thisRow).Format.line.ForeColor.RGB = lineColor
                                    If Not fillPattern = 0 Then
                                        .SeriesCollection(thisCol).Points(thisRow).Format.Fill.Patterned fillPattern
                                    End If
                                Else
                                    .SeriesCollection(thisCol).Points(thisRow).Format.Fill.ForeColor.RGB = fillColor
                                    .SeriesCollection(thisCol).Points(thisRow).Format.line.ForeColor.RGB = lineColor
                                End If
                                .SeriesCollection(thisCol).Points(thisRow).Format.Fill.backColor.RGB = backColor
                            
                                .SeriesCollection(thisCol).Points(thisRow).Format.line.visible = msoTrue
                                'Logger.logInfo "Height:" & .SeriesCollection(thisCol).Points(thisRow).height
                                'Logger.logInfo "  thisCol=" & thisCol & vbTab & "thisRow=" & thisRow & vbTab & "pieceType=" & pieceType & vbTab & "pieceHPRPlacement=" & pieceHPRPlacement & vbTab & "pieceHPRPlacement=" & pieceHPRPlacement
                            
                                If addLabels Then
                                    If Not pieceType = enumPieceType.cut And Not pieceType = enumPieceType.waste Then
                                        If pieceLength >= Settings.diagramLabelsMinSize Then
                                            .SeriesCollection(thisCol).Points(thisRow).ApplyDataLabels
                                            .SeriesCollection(thisCol).Points(thisRow).DataLabel.Font.bold = True
                                            .SeriesCollection(thisCol).Points(thisRow).DataLabel.Orientation = xlUpward
                                            If Not pieceHPRPlacement = enumHPRPlacement.noSide _
                                                And Not pieceHPRPlacement = enumHPRPlacement.notSet _
                                            Then
                                                .SeriesCollection(thisCol).Points(thisRow).DataLabel.Format.Fill.ForeColor.RGB = backColor
                                                If Not fillPattern = 0 Then
                                                    .SeriesCollection(thisCol).Points(thisRow).DataLabel.Format.Fill.Patterned fillPattern
                                                End If
                                            End If
                                                 
                                            ' Changes the text color
                                            '.SeriesCollection(thisCol).Points(thisRow).DataLabel.Format.TextFrame2.TextRange.Characters.Font.Fill.ForeColor.RGB = backColor
                                        End If
                                    End If
                                End If
                            Next
                            thisRow = thisRow + 1
                        End If
                    Next
                Next
            End If
        End With
        
        ' Return height of diagram
        Dim dimension As typeDimension
        dimension.height = DIAGRAM_HEIGHT
        dimension.width = diagramWidth
        createStackedDiagram = dimension
    End Function

Public Function createInputDiagram( _
    ByVal sourceSheet As Worksheet, _
    ByVal destinationSheet As Worksheet, _
    ByVal parentTop As Double, _
    ByVal parentLeft As Double, _
    ByVal showLegend As Boolean, _
    ByVal addLabels As Boolean, _
    ByVal channelTypeKey As String _
) As typeDimension

    Logger.logInfoBoth "Input data:"
    Logger.logInfoBoth "sourceSheet=" & sourceSheet.name & vbTab & "destinationSheet=" & destinationSheet.name & vbTab & "parentTop=" & parentTop & vbTab & "parentLeft=" & parentLeft

    ' Work around an ugly bug!
    destinationSheet.Select
    destinationSheet.Range("A1").Select

    Dim firstRow As Long
    Dim firstCol As Long
    Dim lastRow As Long
    Dim lastCol As Long
    '@Ignore VariableNotUsed
    Dim pLoop As Long
    Dim maximiumScaleY As Long
    Dim diagramColumnCount As Long
    Dim diagramWidth As Long
    Dim dia As chartObject
    Dim theChart As chart
    Dim srcRange As Range
    Dim thisRow As Long
    Dim chartTitle As String
    
    Const FIRST_ROW As Long = 2
    Const FIRST_COL As Long = 2
    Const CHANNELTYPE_COL As Long = 1
    
    ' Find first/last row/col
    With sourceSheet
        If channelTypeKey = vbNullString Then
            ' Make a diagram of all channelTypes
        
            ' Fixed start row/col
            firstRow = FIRST_ROW
            firstCol = FIRST_COL
            
            ' The last non empty row/col in the first col/row
            lastRow = .Range("A" & .Rows.count).End(xlUp).Row
            lastCol = .Cells(1, .Columns.count).End(xlToLeft).Column
            'Logger.logInfo "lastRow=" & lastRow & " lastCol=" & lastCol
        Else
            ' Make a diagram of a specific channelType
            
            ' First column is fixed
            firstCol = FIRST_COL
            
            ' Find first row with the given channel type
            lastRow = .Range("B" & .Rows.count).End(xlUp).Row
            For thisRow = FIRST_ROW To lastRow
                If .Cells(thisRow, CHANNELTYPE_COL).value = channelTypeKey Then
                    firstRow = thisRow
                    'Logger.logInfo "Found first " & channelTypeKey & " at row " & thisRow
                    Exit For
                End If
            Next

            ' Find last row with the given channel type
            'Logger.logInfo "For thisRow = " & firstRow & " To " & lastRow
            'Logger.logInfo "Actual row index start: " & (lastRow - thisRow + 1)
            Dim n As Long
            n = lastRow
            Do While n >= firstRow
                If .Cells(n, CHANNELTYPE_COL).value = channelTypeKey Then
                    lastRow = n
                    'Logger.logInfo "Found last " & channelTypeKey & " at row " & lastRow
                    Exit Do
                End If
                n = n - 1
            Loop
            
            ' The last non empty row/col in the first col/row
            lastCol = .Cells(1, .Columns.count).End(xlToLeft).Column
            'Logger.logInfo "lastRow=" & lastRow & " lastCol=" & lastCol
            
            ' Set up channel loop to only use the one channel type that was requested
            
            ' Find lastcolumn, we cannot just use the heading row to determine, it might be shorter so we have to loop through all rows
            Dim highestCol As Long
            highestCol = 0
            For thisRow = firstRow To lastRow
                If lastCol > highestCol Then
                    highestCol = lastCol
                End If
            Next
            lastCol = highestCol

            ' Set chart title to channelTypeKey
            chartTitle = Translate("diagram_input_pieces") & " - " & channelTypeKey
        End If
    End With
    

    ' Find Y axis MaximumScale and calculate diagram size
    ' Also find largest bin
    '@Ignore AssignmentNotUsed
    maximiumScaleY = toDisplayUnit(Request.getMaxCapacity)
    maximiumScaleY = ceiling(maximiumScaleY, 100) ' Round up to closest thousend
    diagramColumnCount = lastRow - firstRow + 1
    
    ' Default column width
    Dim diagramColumnWidth As Long
    diagramColumnWidth = DIAGRAM_COLUMN_WIDTH
    ' Set wider columns for diagrams with 2 columns in order for the data labels to be seen fully
    'If diagramColumnCount = 2 Then
    '    diagramColumnWidth = DIAGRAM_COLUMN_WIDTH_WIDE
    'End If
    
    If showLegend Then
        diagramWidth = DIAGRAM_MARGIN_WIDTH + _
            diagramColumnCount * diagramColumnWidth + _
            DIAGRAM_LEGEND_WIDTH + _
            DIAGRAM_LEGEND_MARGIN
    Else
        diagramWidth = DIAGRAM_MARGIN_WIDTH + _
        diagramColumnCount * diagramColumnWidth + _
        DIAGRAM_MARGIN_RIGHT
    End If
    
    If diagramWidth < DIAGRAM_MINIMUM_WIDTH Then
        diagramWidth = DIAGRAM_MINIMUM_WIDTH
    End If

    ' Create chart
    With destinationSheet
        Set dia = destinationSheet.ChartObjects.Add( _
            parentTop, _
            parentLeft, _
            diagramWidth, _
            DIAGRAM_HEIGHT _
        )
        Set theChart = dia.chart
    End With
    
    With theChart
        
        ' This gives two axis
        .ChartType = xlColumnClustered
        Set srcRange = sourceSheet.Range( _
            sourceSheet.Cells(firstRow, firstCol), _
            sourceSheet.Cells(lastRow, lastCol))
        Debug.Print "source range: " & srcRange.Address
        .SetSourceData Source:=srcRange          ' Set to plot by columns explicit (this is normally automatic but fails for small sets)
       
        .setElement msoElementChartTitleAboveChart ' Add title
        .chartTitle.Text = chartTitle
        
        ' X axis
        .setElement msoElementPrimaryCategoryAxisTitleAdjacentToAxis ' Add axis title
        .Axes(xlCategory, xlPrimary).AxisTitle.Text = Translate("diagram_hpr") & Chr$(13) & Translate("diagram_quantity")
        .Axes(xlCategory).Format.line.visible = msoFalse ' Take off ugly lines on axis
        .Axes(xlCategory).TickLabels.Orientation = 50 ' Lean the data axis labels a bit
        .Axes(xlCategory).TickLabels.Font.size = 8 ' Set font size 8
        .Axes(xlCategory).MajorTickMark = xlNone ' Perhaps faster with this, does not seem to have any effect

        ' Y axis
        .setElement msoElementPrimaryValueAxisTitleRotated ' Add axis title
        .Axes(xlValue, xlPrimary).AxisTitle.Text = Translate("diagram_length_mm")
        .Axes(xlValue).MaximumScale = maximiumScaleY ' Adjust max
        .Axes(xlValue).MinimumScale = 0
        .Axes(xlValue).MajorUnit = 1000
        .Axes(xlValue).MinorUnit = 100
        
        ' Workaround: Fix axis category labels for diagrams that only have one column
        If diagramColumnCount = 1 Then
            Dim xVals() As Variant
            xVals = .SeriesCollection(1).XValues
            xVals(1) = sourceSheet.Cells(firstRow, 3).value & vbCrLf & sourceSheet.Cells(firstRow, 2).value
            .SeriesCollection(1).XValues = xVals
            .Axes(xlCategory).TickLabels.Orientation = 0
            .Axes(xlCategory).TickLabels.Offset = 300
        End If
        
        ' Diagram as a whole
        .legend.Delete                           ' Don't use built in legend (it won't work with our series)
        .ChartGroups(1).GapWidth = 0             ' Remove gap between blocks
        .Parent.height = DIAGRAM_HEIGHT
        .Parent.Top = parentTop                  ' Set position to max top left
        .Parent.Left = parentLeft
        
        ' This piece of code is needed to work around a bug in Excel 2010
        ' For details see here:
        ' http://stackoverflow.com/questions/13812491/error-setting-plotarea-width-in-excel-vba-excel-2010
        With .PlotArea
            On Error Resume Next
            .height = DIAGRAM_HEIGHT - 2 * DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .height = DIAGRAM_HEIGHT - 2 * DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .width = diagramColumnCount * diagramColumnWidth + DIAGRAM_FUDGE_WIDTH
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .height = DIAGRAM_HEIGHT - 2 * DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .Top = DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .Top = DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .Left = DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .Left = DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .InsideWidth = diagramColumnCount * diagramColumnWidth
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .InsideWidth = diagramColumnCount * diagramColumnWidth
                    If Err.Number = 0 Then Exit For
                Next
            End If
            .InsideLeft = DIAGRAM_PLOTAREA_MARGIN
            If Err.Number <> 0 Then
                For pLoop = 1 To 7
                    Err.clear
                    .InsideLeft = DIAGRAM_PLOTAREA_MARGIN
                    If Err.Number = 0 Then Exit For
                Next
            End If
            On Error GoTo 0
        End With

        ' Show legend
        If showLegend Then
        
            ' Determine legend size and position
            Const LEGEND_HEIGHT As Long = 110
            Const LEGEND_WIDTH As Long = 58
            Dim legendLeft As Long
            Dim legendTop As Long
            legendLeft = diagramWidth - LEGEND_WIDTH - DIAGRAM_LEGEND_MARGIN
            legendTop = DIAGRAM_HEIGHT / 2 - LEGEND_HEIGHT / 2
        
            ' Copy/paste image from the images sheet
            .ChartArea.Select
            .Paste                               ' Image shouls already be in clipboard
            Selection.Left = legendLeft
            Selection.Top = legendTop
        End If
        
        ' Add color
        .SeriesCollection(1).Format.line.visible = msoTrue
        .SeriesCollection(1).Format.line.ForeColor.RGB = RGB(184, 131, 0)
        .SeriesCollection(1).Format.line.Transparency = 0
        .SeriesCollection(1).Format.Fill.ForeColor.RGB = RGB(240, 173, 0)
        
        If addLabels Then
            Dim i As Long
            For i = 1 To .SeriesCollection(1).Points.count
                ' Dont add labels for very short pieces
                If sourceSheet.Cells(firstRow - 1 + i, letter2Column(Globals.OUTPUT_COL_LENGTH)).value >= (Settings.diagramLabelsMinSize / 10) Then
                    .SeriesCollection(1).Points(i).ApplyDataLabels
                    .SeriesCollection(1).Points(i).DataLabel.Position = xlLabelPositionCenter
                    .SeriesCollection(1).Points(i).DataLabel.Font.bold = True
                    .SeriesCollection(1).Points(i).DataLabel.Orientation = xlUpward
                    .SeriesCollection(1).Points(i).DataLabel.Format.Fill.ForeColor.RGB = RGB(247, 197, 75)
                End If
            Next
        End If
    End With
    
    ' Return height of diagram
    Dim dimension As typeDimension
    dimension.height = DIAGRAM_HEIGHT
    dimension.width = diagramWidth
    createInputDiagram = dimension
End Function

Public Sub diagramSheetPrintSetup()
    SheetDiagrams.ResetAllPageBreaks
    SheetDiagrams.PageSetup.PrintArea = vbNullString
    
    ' Prevent crashing if no printer is installed, correct formating will need a printer installed tho
    On Error GoTo NoPrinter

    With SheetDiagrams.PageSetup
        .LeftHeader = vbNullString
        .CenterHeader = vbNullString
        .RightHeader = vbNullString
        .LeftFooter = vbNullString
        .CenterFooter = vbNullString
        .RightFooter = vbNullString
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.75)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .PrintQuality = 600
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlLandscape
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = 62
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = vbNullString
        .EvenPage.CenterHeader.Text = vbNullString
        .EvenPage.RightHeader.Text = vbNullString
        .EvenPage.LeftFooter.Text = vbNullString
        .EvenPage.CenterFooter.Text = vbNullString
        .EvenPage.RightFooter.Text = vbNullString
        .FirstPage.LeftHeader.Text = vbNullString
        .FirstPage.CenterHeader.Text = vbNullString
        .FirstPage.RightHeader.Text = vbNullString
        .FirstPage.LeftFooter.Text = vbNullString
        .FirstPage.CenterFooter.Text = vbNullString
        .FirstPage.RightFooter.Text = vbNullString
    End With
    
NoPrinter:
    Exit Sub

End Sub

'Public Sub compactDiagrams()
'
'    'Logger.logInfo ActiveSheet.ChartObjects.Count
'
'    Dim i As Long
'    Dim widthOnPaper As Long
'    Dim prevWidthOnPaper As Long
'    Dim prevTopPosition As Long
'    Dim topPosition As Long
'
'    Dim topMovedOffset As Long
'
'    widthOnPaper = 0
'    prevWidthOnPaper = 0
'    prevTopPosition = 0
'    topPosition = 0
'
'    topMovedOffset = 0
'
'    If ActiveSheet.ChartObjects.count > 0 Then
'        For i = 1 To ActiveSheet.ChartObjects.count
'            'Logger.logInfo ActiveSheet.ChartObjects(i).Chart.name & vbTab & ActiveSheet.ChartObjects(i).Chart.chartTitle.Text & vbTab & ActiveSheet.ChartObjects(i).width
'            If i > 1 Then
'                If i Mod 2 = 0 Then
'                    ' Save the length of the last two diagrams
'                    prevWidthOnPaper = widthOnPaper
'                    prevTopPosition = topPosition
'                    topPosition = ActiveSheet.ChartObjects(i).Top
'                    widthOnPaper = ActiveSheet.ChartObjects(i).width + DIAGRAM_MARGIN_WIDTH
'                Else
'                    widthOnPaper = widthOnPaper + ActiveSheet.ChartObjects(i).width
'                    'Logger.logInfo "widthOnPaper = " & widthOnPaper
'
'                    ' Only start moving diagrams if we are at least on the fifth diagram
'                    If i > 4 And prevWidthOnPaper + widthOnPaper + DIAGRAM_MARGIN_WIDTH < 2000 Then
'                        'Logger.logInfo "We should move the diagrams!"
'                        topMovedOffset = ActiveSheet.ChartObjects(i).Top - prevTopPosition
'                        ' Move the previous diagram
'                        ActiveSheet.ChartObjects(i - 1).Top = ActiveSheet.ChartObjects(i - 1).Top - topMovedOffset
'                        ActiveSheet.ChartObjects(i - 1).Left = prevWidthOnPaper + DIAGRAM_MARGIN_WIDTH
'                        ' Move the current diagram
'                        ActiveSheet.ChartObjects(i).Left = prevWidthOnPaper + DIAGRAM_MARGIN_WIDTH
'                        prevWidthOnPaper = ActiveSheet.ChartObjects(i).Left + ActiveSheet.ChartObjects(i - 1).width
'                    End If
'                End If
'                'Logger.logInfo "topMovedOffset: " & topMovedOffset
'
'                ' If all the rest of the diagrams should be moved:
'                'If topMovedOffset > 0 Then
'                '    ActiveSheet.ChartObjects(i).Top = ActiveSheet.ChartObjects(i).Top - topMovedOffset
'                '    prevWidthOnPaper = ActiveSheet.ChartObjects(i - 1).Left + ActiveSheet.ChartObjects(i - 1).width
'                'End If
'            End If
'        Next i
'    End If
'End Sub
Attribute VB_Name = "CFastPermutation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CFastPermutation class

' Fast calculation of distinct permutations
' Based on https://stackoverflow.com/questions/22200945/print-the-contents-of-a-list-in-a-textbox#22201286

Private Type TFastPermutation
    basis As CLongArray
    ub As Long
    permutationCount As Long
End Type

Private this As TFastPermutation

' Initialization
Private Sub class_initialize()
    this.permutationCount = 0
End Sub


' This method starts off the permutation finding process
' It takes permutations as a reference variable in order for permutations to be able to be collected
' in the same object from different runs
' The argument counts is a list of how many of each type, thus counts=(3,1,2) gets converted into basis=(1,1,1,2,3,3)
Public Function findPermutations( _
    ByRef counts As CLongArray, _
    ByRef permutations As Collection, _
    Optional ByRef pgForm As ProgressForm _
) As Long
    'Logger.logDeep vbTab & "findPermutations([" & counts.getString & "], permutations, pgForm)"
    ' Convert counts into sorted basis for permutation calculation
    Dim elementNo As Long
    '@Ignore VariableNotUsed
    Dim n As Long
    Set this.basis = New CLongArray
    'Logger.logDeep vbTab & "Setting basis: For elementNo = 1 To " & counts.count
    'Logger.logDeep vbTab & vbTab & "For elementNo = 1 To " & counts.count
    For elementNo = 1 To counts.count
        Logger.logDeep vbTab & vbTab & "For n = 1 To " & counts.element(elementNo)
        For n = 1 To counts.element(elementNo)
            'Logger.logDeep vbTab & vbTab & vbTab & elementNo
            this.basis.addElement elementNo
        Next
    Next
    this.ub = this.basis.count
    'Logger.logDeep vbTab & "this.basis: " & this.basis.getString
    'Logger.logDeep vbTab & "this.ub: " & this.ub
    
    ' Find the permutations
    If pgForm Is Nothing Then
        'Logger.logDeep vbTab & "Starting permutation finding (no pgForm)"
        'Logger.logDeep vbTab & "permutations.count: " & permutations.count
        permutate 1, permutations
    Else
        'Logger.logDeep vbTab & "Starting permutation finding (with pgForm)"
        'Logger.logDeep vbTab & "permutations.count: " & permutations.count
        permutate 1, permutations, pgForm
    End If
    findPermutations = this.permutationCount
End Function


' This function implements a fast distinct permutation finder using the swap algorithm
' It is a recursive function that calls itself
' The permutations found are saved in the variable named permutations
' Start is to keep track of state, it is a variable that begins on the first position of basis and works itself up last position of basis
' Thus start should be set to 1 (as everything is 1-indexed) for the entry run of permutate
Private Sub permutate( _
    ByVal start As Long, _
    ByRef permutations As Collection, _
    Optional ByRef pgForm As ProgressForm _
)
    If start = this.ub Then
        permutations.Add this.basis.getCopy
        this.permutationCount = this.permutationCount + 1
        If Not pgForm Is Nothing Then
            pgForm.nextStepSub "Step 4/7 Finding permutations "
        End If
    Else
        Dim swaps As String
        Dim temp As Long
        Dim i As Long
        For i = start To this.ub
            ' skip if we already done swap with this item
            If InStr(swaps, this.basis.element(i) & ",") = 0 Then
                swaps = swaps & this.basis.element(i) & ","
    
                ' Swap
                If Not start = i Then
                    temp = this.basis.element(start)
                    this.basis.setElement this.basis.element(i), start
                    this.basis.setElement temp, i
                End If
                
                If pgForm Is Nothing Then
                    permutate start + 1, permutations
                Else
                    permutate start + 1, permutations, pgForm
                End If
                
                ' Swap
                If Not start = i Then
                    temp = this.basis.element(start)
                    this.basis.setElement this.basis.element(i), start
                    this.basis.setElement temp, i
                End If
            End If
        Next
    End If
End Sub

' Calculates the number of permutations
' Note that this function can easily overflow the size of a Long
' TODO: Add an overflow warning
Public Static Function noOfPermutations(ByRef counts As CLongArray) As Double

    Dim i As Long
    Dim noOfPositions As Double
    Dim dividend As Double
    Dim divisor As Double
    noOfPositions = 0
    divisor = 1
    
    ' Calculate number of permutations
    For i = 1 To counts.count
        noOfPositions = noOfPositions + counts.element(i)
        divisor = divisor * Application.WorksheetFunction.Fact(counts.element(i))
    Next
    dividend = Application.WorksheetFunction.Fact(noOfPositions)
    noOfPermutations = dividend / divisor
End Function


' Checks wether the given CLongArray exists in the permutations Collection
' Stops on the first existance
' Returns True if it exists False if not
Public Function existsInSet(ByRef permutations As Collection, ByRef testArray As CLongArray) As Boolean
    Dim i As Long
    Dim subSet As CLongArray
    'Logger.logInfo "    permutations.Count: " & permutations.count
    'Logger.logInfo "    testArray.count: " & testArray.count
    'Logger.logInfo "    testArray.getString: [" & testArray.getString & "]"
    existsInSet = False
    
    For i = 1 To permutations.count
        'Logger.logInfo "        i: " & i
        
        Set subSet = permutations.item(i)
        'Logger.logInfo "        subSet = permutations.item(i): [" & subSet.getString & "]"
        'Logger.logInfo "        subSet.equals([" & testArray.getString & "]): " & subSet.equals(testArray)
        If subSet.equals(testArray) Then
            existsInSet = True
            Exit Function
        End If
    Next
    
End Function
Attribute VB_Name = "CItem"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CItem class

Private Type TItem
    length As Long                               ' Length as 1/10 mm
    tolerance As Long                            ' Acceptable tolerance +-1/10 mm
    deviatingMinimumRemainingWebWidth As Long         ' Contains deviating remaingng web in 1/10mm
    deviatingMinimumRemainingWebWidthSet As Boolean   ' Whether deviating remaing web has been set or not
    quantity As Long                             ' How many
    '@Ignore UseMeaningfulName
    cuttingType As enumCuttingType                           ' Hole pattern tolerance (A, B1, B2, C1, C2)
    channelTypeKey As String                     ' Channel type of the item
End Type

Private this As TItem

Public Property Get length() As Long
    length = this.length
End Property

Public Property Get quantity() As Long
    quantity = this.quantity
End Property

Public Property Get channelTypeKey() As String
    channelTypeKey = this.channelTypeKey
End Property

Public Property Get deviatingMinimumRemainingWebWidthSet() As Boolean
    deviatingMinimumRemainingWebWidthSet = this.deviatingMinimumRemainingWebWidthSet
End Property

Public Property Get deviatingMinimumRemainingWebWidth() As Long
    deviatingMinimumRemainingWebWidth = this.deviatingMinimumRemainingWebWidth
End Property

'@Ignore UseMeaningfulName
Public Property Get cuttingType() As enumCuttingType
    cuttingType = this.cuttingType
End Property

Public Property Get tolerance() As Long
    tolerance = this.tolerance
End Property

Private Sub class_initialize()
    this.length = 0
    this.tolerance = 0
    this.deviatingMinimumRemainingWebWidth = 0
    this.deviatingMinimumRemainingWebWidthSet = False
    this.quantity = 0
    this.cuttingType = enumCuttingType.A
    this.channelTypeKey = vbNullString
End Sub

'@Ignore UseMeaningfulName
Public Sub setValues( _
    ByVal length As Long, _
    ByVal tolerance As Long, _
    ByVal deviatingMinimumRemainingWebWidth As Long, _
    ByVal deviatingMinimumRemainingWebWidthSet As Boolean, _
    ByVal quantity As Long, _
    ByVal cuttingType As enumCuttingType, _
    ByVal channelTypeKey As String _
)
    this.length = length
    this.tolerance = tolerance
    this.deviatingMinimumRemainingWebWidth = deviatingMinimumRemainingWebWidth
    this.deviatingMinimumRemainingWebWidthSet = deviatingMinimumRemainingWebWidthSet
    this.quantity = quantity
    this.cuttingType = cuttingType
    this.channelTypeKey = channelTypeKey
End Sub


Public Function getCopy() As CItem
    Set getCopy = New CItem
    getCopy.setValues _
        length:=this.length, _
        tolerance:=this.tolerance, _
        deviatingMinimumRemainingWebWidth:=this.deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet:=this.deviatingMinimumRemainingWebWidthSet, _
        quantity:=this.quantity, _
        cuttingType:=this.cuttingType, _
        channelTypeKey:=this.channelTypeKey
End Function


Public Function piece() As CPiece
    Set piece = New CPiece
    piece.setValues _
        channelTypeKey:=this.channelTypeKey, _
        hprPlacement:=enumHPRPlacement.notSet, _
        cuttingType:=this.cuttingType, _
        pieceType:=enumPieceType.normal, _
        length:=this.length, _
        placed:=False, _
        usedTolerance:=0, _
        allowedTolerance:=this.tolerance
End Function
Attribute VB_Name = "CItemSet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CItemSet class

Private Type TItemSet
    items() As CItem        ' Keeps all CItem objects
    itemCount As Long       ' Number of pieces currently in this bin
    channelTypeKey As String
End Type

Private this As TItemSet

Public Property Get channelTypeKey() As String
    channelTypeKey = this.channelTypeKey
End Property

Public Property Let channelTypeKey(ByVal value As String)
    this.channelTypeKey = value
End Property

Public Property Get count() As Long
    count = this.itemCount
End Property


Private Sub class_initialize()
    ReDim this.items(1 To 1)
    this.itemCount = 0
    this.channelTypeKey = vbNullString
End Sub


' Adds a CItem to the end of the items array
Public Sub addItem(ByVal item As CItem)
    this.itemCount = this.itemCount + 1
    ReDim Preserve this.items(1 To this.itemCount)
    '@Ignore ObjectVariableNotSet
    Set this.items(this.itemCount) = item.getCopy
End Sub


Public Function getItemCopy(ByVal itemNo As Long) As CItem
    Set getItemCopy = this.items(itemNo).getCopy
End Function

' Debug function
' Prints the size of each item
'Public Sub printItems()
'    Logger.logInfo "Items:"
'    Dim itemNo As Long
'    For itemNo = 1 To this.itemCount
'        Logger.logInfo itemNo & ": " & this.items(itemNo)
'    Next
'End Sub


Public Sub sortByLength(ByVal descending As Boolean)
    qSortItemsInPlace _
        inputArray:=this.items, _
        lb:=LBound(this.items), _
        ub:=UBound(this.items), _
        descending:=descending
End Sub
Attribute VB_Name = "CLogger"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CLogger class

Public Enum enumLogLevel
    ebug = 1
    eError = 2
    eInfo = 3
    eDeep = 4
End Enum

Public Enum enumLogLevelSetting
    eOff = 0
    eBugs = 1
    eErrors = 2
    eInfos = 3
    eAll = 4
End Enum

Private Type TLogger
    setting_logToFile As Boolean
    setting_logLevel As enumLogLevelSetting
    setting_logFunctionCallsLevel As Long
    setting_logFileName As String
    
    fso As FileSystemObject
    outputFile As TextStream
    loggingDisabledDueToError As Boolean
End Type

Private this As TLogger


Public Property Get settingLogToFile() As Boolean
    settingLogToFile = this.setting_logToFile
End Property

Public Property Get settingLogLevel() As enumLogLevelSetting
    settingLogLevel = this.setting_logLevel
End Property

Public Property Let settingLogLevel(ByVal value As enumLogLevelSetting)
    this.setting_logLevel = value
End Property

Public Property Let settingLogToFile(ByVal value As Boolean)
    this.setting_logToFile = value
End Property


Private Sub class_initialize()
    ' Default settings
    this.setting_logToFile = True
    this.setting_logLevel = eInfo
    this.setting_logFileName = "Cutting Pattern Calculator.log"
    this.loggingDisabledDueToError = False
    this.setting_logFunctionCallsLevel = 1 ' 0 = dont log any function calls, 1 = log level 1 function calls only, 2 = log level 1 and level 2 function calls, etc...
End Sub


Public Sub logMsg( _
    ByVal message As String, _
    Optional ByVal logLevel As enumLogLevel = eError _
)
    If this.setting_logLevel >= logLevel Then
        If settingLogToFile Then
            logToFile message, logLevel
        Else
            Debug.Print message
        End If
    End If
End Sub


Public Sub logInfo(ByVal message As String)
    logMsg message, eInfo
End Sub

Public Sub logDeep(ByVal message As String)
    logMsg message, eDeep
End Sub

Public Sub logFunctionCall( _
    ByVal level As Long, _
    ByVal message As String _
)
    If this.setting_logFunctionCallsLevel >= level Then
        logMsg message, eInfo
    End If
End Sub

Public Sub logDeepFunctionCall( _
    ByVal level As Long, _
    ByVal message As String _
)
    If this.setting_logFunctionCallsLevel >= level Then
        logMsg message, eDeep
    End If
End Sub

Public Sub logError(ByVal message As String)
    logMsg message, eError
End Sub


Public Sub logBug(ByVal message As String)
    logMsg message, ebug
End Sub


' Will log both to a file and to the Immidiate window if logToFile is enabled, otherwise will just print to the Immediate window
Public Sub logInfoBoth(ByVal message As String)
    If Not this.setting_logLevel = eOff Then
        logToFile message, eInfo
    End If
    Debug.Print message
End Sub


'Private Sub logToFile_single(ByVal message As String, ByVal logLevel As enumLogLevel)
'    If Not this.loggingDisabledDueToError Then
'        openOrCreateFile
'        logToFile message, logLevel
'        closeFile
'    End If
'End Sub


Private Sub logToFile( _
    ByVal message As String, _
    ByVal logLevel As enumLogLevel _
)
    Dim messageToLog As String
    If Not this.loggingDisabledDueToError Then
        On Error GoTo FileFail
        If this.fso Is Nothing Or this.outputFile Is Nothing Then
            openOrCreateFile
        End If
        Select Case logLevel
           Case ebug
              messageToLog = "B: " & message
           Case eError
              messageToLog = "E: " & message
           Case eInfo
              messageToLog = "I: " & message
           Case eDeep
              messageToLog = "D: " & message
        End Select
        this.outputFile.WriteLine messageToLog
    End If
    Exit Sub
FileFail:
    fileFailed Err.Description
End Sub


Public Sub openOrCreateFile()
    If Not this.loggingDisabledDueToError Then
        On Error GoTo FileFail
        Set this.fso = New FileSystemObject
        Set this.outputFile = this.fso.OpenTextFile(ThisWorkbook.Path & "\" & this.setting_logFileName, ForAppending, True)
        If Err.Number <> 0 Then
            this.loggingDisabledDueToError = True
            Debug.Print "Logging disabled because an error occured: " & Err.Description
        End If
    End If
    Exit Sub
FileFail:
    fileFailed Err.Description
End Sub


Public Sub closeFile()
    If Not this.loggingDisabledDueToError Then
        On Error GoTo FileFail
        If Not this.outputFile Is Nothing Then
            this.outputFile.Close
        End If
        Set this.fso = Nothing
        Set this.outputFile = Nothing
    End If
    Exit Sub
FileFail:
    fileFailed Err.Description
End Sub


Public Function readLastLine() As String
    If Not this.loggingDisabledDueToError Then
        On Error GoTo FileFail
        Dim lastLine As String
        If Not this.outputFile Is Nothing And Not this.fso Is Nothing Then
            closeFile
        End If
        Set this.fso = New FileSystemObject
        Set this.outputFile = this.fso.OpenTextFile(this.setting_logFileName, ForReading, True)
        Do Until this.outputFile.AtEndOfStream
            lastLine = this.outputFile.ReadLine
        Loop
        readLastLine = lastLine
        closeFile
    End If
    Exit Function
FileFail:
    fileFailed Err.Description
End Function


Public Sub fileFailed(ByVal errorMsg As String)
    this.loggingDisabledDueToError = True
    Debug.Print "Disabling logging due to an error: " & errorMsg
End Sub
Attribute VB_Name = "CLongArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CLongArray class

' A substitute for normal integer arrays

Private Type TLongArray
    elements() As Long
    elementCount As Long
End Type

Private this As TLongArray

Private Sub class_initialize()
    this.elementCount = 0
    ReDim this.elements(1 To 1)
End Sub

Public Function getCopy() As CLongArray
    Set getCopy = New CLongArray
    Dim elementNo As Long
    For elementNo = 1 To this.elementCount
        getCopy.addElement this.elements(elementNo)
    Next
End Function

Public Sub setElement( _
    ByVal newValue As Long, _
    ByVal elementNo As Long _
)
    this.elements(elementNo) = newValue
End Sub

Public Sub addElement(ByVal newValue As Long)
    this.elementCount = this.elementCount + 1
    ReDim Preserve this.elements(1 To this.elementCount)
    this.elements(this.elementCount) = newValue
End Sub

Public Property Get count() As Long
    count = this.elementCount
End Property

' Sets the number of elements this object can take, does not preserve earlier elements
Public Property Let count(ByVal newElementCount As Long)
    this.elementCount = newElementCount
    ReDim this.elements(1 To this.elementCount)
End Property
    
Public Property Get element(ByVal elementNo As Long) As Long
    element = this.elements(elementNo)
End Property

Public Property Let element( _
    ByVal elementNo As Long, _
    ByVal newValue As Long _
)
    this.elements(elementNo) = newValue
End Property

Public Function equals(ByVal compareTo As CLongArray) As Boolean
    Dim elementNo As Long
    equals = True   ' Assume equal and prove that is false
    If Not this.elementCount = compareTo.count Then
        equals = False
        Exit Function
    End If
    For elementNo = 1 To this.elementCount
        If Not this.elements(elementNo) = compareTo.element(elementNo) Then
            equals = False
            Exit Function
        End If
    Next
End Function

' Used for debugging, returns a string with the content
Public Function getString() As String
    getString = vbNullString
    Dim elementNo As Long
    For elementNo = 1 To this.elementCount
        If getString = vbNullString Then
            getString = this.elements(elementNo)
        Else
            getString = getString & "," & this.elements(elementNo)
        End If
    Next
End Function

Public Sub swap( _
    ByVal firstElementNo As Long, _
    ByVal secondElementNo As Long _
)
    Dim tempElement As Long
    tempElement = this.elements(firstElementNo)
    this.elements(firstElementNo) = this.elements(secondElementNo)
    this.elements(secondElementNo) = tempElement
End Sub

Public Function subArray( _
    ByVal startIndex As Long, _
    ByVal length As Long _
) As CLongArray
    Dim elementNo As Long
    Set subArray = New CLongArray
    For elementNo = startIndex To startIndex + length - 1
        subArray.addElement this.elements(elementNo)
    Next
End Function

Public Function subArrayRight(ByVal length As Long) As CLongArray
    Dim elementNo As Long
    Set subArrayRight = New CLongArray
    For elementNo = this.elementCount - length + 1 To this.elementCount
        subArrayRight.addElement this.elements(elementNo)
    Next
End Function

Public Function subArrayLeft(ByVal length As Long) As CLongArray
    Dim elementNo As Long
    Set subArrayLeft = New CLongArray
    For elementNo = 1 To length
        subArrayLeft.addElement this.elements(elementNo)
    Next
End Function

Public Sub addArray(ByVal arrayToAdd As CLongArray)
    Dim elementNo As Long
    For elementNo = 1 To arrayToAdd.count
        addElement arrayToAdd.element(elementNo)
    Next
End Sub

Public Sub removeAt(ByVal index As Long)
    If this.elementCount = 1 Then
        this.elementCount = 0
    Else
        Dim elementNo As Long
         ' Move all element back one position after the specified index, overwriting the one we want to remove
         For elementNo = index + 1 To this.elementCount
             this.elements(elementNo - 1) = this.elements(elementNo)
         Next
         ' Shrink the array by one, removing the last one
         this.elementCount = this.elementCount - 1
         ReDim Preserve this.elements(1 To this.elementCount)
    End If
End Sub

' Reset all elements to zero
Public Sub zero()
    Dim elementNo As Long
    For elementNo = 1 To this.elementCount
        this.elements(elementNo) = 0
    Next
End Sub
Attribute VB_Name = "CLongArrayArray"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CLongArrayArray class

' A collection class for arrays of CLongArrays

Private Type TLongArrayArray
    elements() As CLongArray
    elementCount As Long
End Type

Private this As TLongArrayArray

Private Sub class_initialize()
    this.elementCount = 0
    ReDim this.elements(1 To 1)
End Sub

Public Sub addElement(ByVal newValue As CLongArray)
    this.elementCount = this.elementCount + 1
    ReDim Preserve this.elements(1 To this.elementCount)
    '@Ignore ObjectVariableNotSet
    Set this.elements(this.elementCount) = newValue.getCopy
End Sub

Public Property Get count() As Long
    count = this.elementCount
End Property

' Sets the number of elements this object can take, does not preserve earlier elements
Public Property Let count(ByVal newElementCount As Long)
    this.elementCount = newElementCount
    ReDim this.elements(1 To this.elementCount)
End Property
    
Public Property Get element(ByVal elementNo As Long) As CLongArray
    Set element = this.elements(elementNo)
End Property

Public Property Let element( _
    ByVal elementNo As Long, _
    ByVal newValue As CLongArray _
)
    '@Ignore ObjectVariableNotSet
    Set this.elements(elementNo) = newValue
End Property

'Public Function equals(ByVal compareTo As CLongArray) As Boolean
'    Dim elementNo As Long
'    equals = True   ' Assume equal and prove that is false
'    If Not this.elementCount = compareTo.count Then
'        equals = False
'        Exit Function
'    End If
'    For elementNo = 1 To elementCount
'        If Not this.elements(elementNo) = compareTo.element(elementNo) Then
'            equals = False
'            Exit Function
'        End If
'    Next
'End Function

'Public Sub swap(ByVal firstElementNo As Long, _
'                ByVal secondElementNo As Long)
'    Dim tempArray As CLongArray
'    Set tempArray = this.elements(firstElementNo)
'    Set this.elements(firstElementNo) = this.elements(secondElementNo)
'    Set this.elements(secondElementNo) = tempArray
'End Sub

'Public Function subArray(ByVal startIndex As Long, _
'                        ByVal length As Long) As CLongArrayArray
'    Dim i As Long
'    Set subArray = New CLongArray
'    For i = startIndex To startIndex + length - 1
'        subArray.addElement this.elements(i)
'    Next
'End Function

'Public Function subArrayRight(ByVal length As Long) As CLongArrayArray
'    Dim i As Long
'    Set subArrayRight = New CLongArray
'    For i = elementCount - length + 1 To this.elementCount
'        subArrayRight.addElement this.elements(i)
'    Next
'End Function

'Public Function subArrayLeft(ByVal length As Long) As CLongArrayArray
'    Dim i As Long
'    Set subArrayLeft = New CLongArray
'    For i = 1 To length
'        subArrayLeft.addElement this.elements(i)
'    Next
'End Function

'Public Sub addArray(ByVal arrayToAdd As CLongArrayArray)
'    Dim i As Long
'    For i = 1 To arrayToAdd.count
'        addElement arrayToAdd.element(i)
'    Next
'End Sub

'Public Sub removeAt(ByVal index As Long)
'    If this.elementCount = 1 Then
'        this.elementCount = 0
'    Else
'        Dim i As Long
'         ' Move all element back one position after the specified index, overwriting the one we want to remove
'         For i = index + 1 To this.elementCount
'             Set this.elements(i - 1) = this.elements(i)
'         Next
'         ' Shrink the array by one, removing the last one
'         this.elementCount = this.elementCount - 1
'         ReDim Preserve this.elements(1 To this.elementCount)
'    End If
'End Sub


'Public Sub removeDuplicates()
'    Dim i As Long
'    Dim j As Long
'    Dim removed As Long
'    Dim tmpRes As CLongArray
'    Dim compareToRes As CLongArray
'    removed = 0
'    For i = 1 To this.elementCount - removed
'        Set tmpRes = this.elements(i)
'        For j = i + 1 To this.elementCount - removed - 1
'            Set compareToRes = this.elements(j)
'            If tmpRes.equals(compareToRes) Then
'                'Logger.logInfo ("i:" & tmpRes.getString)
'                'Logger.logInfo ("j:" & compareToRes.getString)
'                'Logger.logInfo (i & " equals " & j & " removing " & j)
'                removed = removed + 1
'                'Logger.logInfo ("removed: " & removed)
'                'Logger.logInfo ("New count: " & results.count)
'            End If
'        Next
'    Next
'End Sub
Attribute VB_Name = "COutputSheets"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit


' Set up connection with the actual sheets through the proxy interface
Private outputSheets As IOutputSheets
Private genericSheet As IGenericSheet

Private Sub class_initialize()
    Set outputSheets = New OutputSheetsProxy
    Set genericSheet = New GenericSheetProxy
End Sub


' Clears the output sheet before inserting new data
Public Sub clear()
    Dim appProxy As IApplication
    Set appProxy = New ApplicationProxy

    genericSheet.deleteCells SheetOutputLists
    genericSheet.clearFormats SheetOutputLists
    genericSheet.deleteCells SheetCuttingPattern
    genericSheet.clearFormats SheetCuttingPattern
    genericSheet.deleteCells SheetProfilesAll
    genericSheet.deleteCells SheetRequestedAll
    genericSheet.deleteCells SheetProfilesUnique
    genericSheet.deleteCells SheetRequestedUnique
    genericSheet.deleteCells SheetDiagrams
    
    ' Delete shapes from Cutlist (legend) and Picklist (buttons)
    genericSheet.clearShapes SheetOutputLists
    genericSheet.clearShapes SheetCuttingPattern
    
    ' Delete diagrams:
    genericSheet.clearDiagrams SheetDiagrams
    genericSheet.clearDiagrams SheetOutputLists
    
    ' TODO: remove if the diagrams placement problems are solved another way
    ' Does not seem to have an effect, but we keep it in place
    ' Wait a little to make sure it excel can catch up
    appProxy.enableAfterRunning
    appProxy.disableWhileRunning
    waitFor 1
End Sub


Public Sub writeProfileSheets()
    ' Measure time taken
    Dim startTime As Single
    startTime = Timer
    Logger.logInfoBoth "Writing profile sheets..."

    ' Print the sheets used for diagrams
        
    ' All bins
    writeProfiles onlyUniqueProfiles:=False
    ' Unique bins
    writeProfiles onlyUniqueProfiles:=True

    ' All input items
    writeIRequestedItems onlyUniqueItems:=False
    ' Unique input items
    writeIRequestedItems onlyUniqueItems:=True
        
    ' Report time
    Logger.logInfoBoth "done."
    Logger.logInfoBoth "Time " & Round(Timer - startTime, 2) & "s"
End Sub


' Prints the contents of the CBinSet
Public Sub writeProfiles(ByVal onlyUniqueProfiles As Boolean)
    
    Dim solutionNo As Long
    Dim maxPieceCount As Long
    Dim pieceCount As Long
    Dim currentRow As Long
    Dim binsSheet As Worksheet
    Dim profileNo As Long
    Dim binSet As CBinSet
    Dim profile As CBin
    Dim solutions() As CBinSet
    
    solutions = Request.getSolutions
    maxPieceCount = 0
    currentRow = Globals.BINS_ROW_HEADING + 1
    
    If onlyUniqueProfiles Then
        Set binsSheet = SheetProfilesUnique
    Else
        Set binsSheet = SheetProfilesAll
    End If
    
    ' Print pieces
    ' For each solution
    For solutionNo = 1 To Request.chTypeCount
        Set binSet = solutions(solutionNo)
        For profileNo = 1 To binSet.count
            Set profile = binSet.getBin(profileNo)
            
            If profile.uniqueProfile Or Not onlyUniqueProfiles Then
                outputSheets.writeBinToRow profile, currentRow, binsSheet
                currentRow = currentRow + 1
            End If
        Next
                                   
        pieceCount = binSet.highestPieceCount
        If pieceCount > maxPieceCount Then
            maxPieceCount = pieceCount
        End If
    Next
    
    ' Write headings
    outputSheets.writeBinHeadings binsSheet, maxPieceCount
End Sub


' Prints the contents of the
Public Sub writeIRequestedItems(ByVal onlyUniqueItems As Boolean)
    Dim itemSetNo As Long
    Dim itemSets() As CItemSet
    Dim itemSet As CItemSet
    Dim item As CItem
    Dim itemNo As Long
    Dim currentRow As Long
    
    '@Ignore VariableNotUsed
    Dim line As Long
    
    itemSets = Request.getItemSets
    currentRow = Globals.OUTPUT_ROW_HEADING + 1
    
    ' Print data For each CItemSet
    ' TODO: Add a more secure measurement of the size of the itemSets array here
    For itemSetNo = 1 To Request.chTypeCount
        Set itemSet = itemSets(itemSetNo)
        
        For itemNo = 1 To itemSet.count
            Set item = itemSet.getItemCopy(itemNo)
            
            If onlyUniqueItems Then
                outputSheets.writeInputItem item, currentRow, item.quantity & "x", SheetRequestedUnique
                currentRow = currentRow + 1
            Else
                ' Print one line for each item
                For line = 1 To item.quantity
                    outputSheets.writeInputItem item, currentRow, "1x", SheetRequestedAll
                    currentRow = currentRow + 1
                Next
            End If
        Next
    Next
    
    ' Print headings
    If onlyUniqueItems Then
        outputSheets.writeInputHeadings SheetRequestedUnique
    Else
        outputSheets.writeInputHeadings SheetRequestedAll
    End If

End Sub


' Prints all cuts and other information to the Cutting Pattern sheet
Private Sub writeCuttingPattern( _
    ByRef binSets() As CBinSet, _
    ByRef channelTypeSet As CChannelTypeSet, _
    ByVal chTypeCount As Long _
)
    ' Measure time taken
    Dim startTime As Single
    startTime = Timer
    Logger.logInfoBoth "Generating output..."
    
    Dim binSetNo As Long
    Dim boldColNo As Long
    Dim lastRow As Long
    
    lastRow = Globals.CPATTERN_ROW_START
    
    ' Print pieces (unique profiles only)
    Dim binNo As Long
    Dim tmpBin As CBin
    Dim tmpChVariant As CChannelTypeVariant
    Dim tmpPiece As CPiece
    Dim pieceNo As Long
    Dim col As Long
    Dim prevPieceType As enumPieceType
    Dim highestCol As Long
    
    prevPieceType = enumPieceType.normal
    highestCol = 0
    
    For binSetNo = 1 To chTypeCount
        For binNo = 1 To binSets(binSetNo).count
            Set tmpBin = binSets(binSetNo).getBin(binNo)
            Set tmpChVariant = channelTypeSet.getVariant( _
                tmpBin.channelTypeKey, _
                tmpBin.length _
            )
            If tmpBin.uniqueProfile Or Not Globals.CPATTERN_SHOW_UNIQUE_PROFILES Then
                lastRow = lastRow + 1
                col = Globals.CPATTERN_COL_START

                With SheetCuttingPattern
                    .Cells(lastRow, col).value = tmpBin.profileNo & " "
                    col = col + 1
                    .Cells(lastRow, col).value = tmpChVariant.SAPdescription
                    col = col + 1
                    .Cells(lastRow, col).value = tmpChVariant.SAPnumber
                    col = col + 1
                    .Cells(lastRow, col).value = tmpBin.quantity
                    col = col + 1
                    For pieceNo = 1 To tmpBin.pieceCount
                        ' Convert to mm in output
                        ' Show cut pieces:
                        ' TODO Enhancement: Dont create a copy here, instead make a property that returns a object reference
                        Set tmpPiece = tmpBin.getPieceCopy(pieceNo)
                        If tmpPiece.pieceType = enumPieceType.cut Then
                            If Globals.CPATTERN_SHOW_CUT_PIECES Then
                                .Cells(lastRow, col).value = toDisplayUnitDouble(tmpPiece.length)
                                ' Add coloring
                                If Globals.CPATTERN_SHOW_COLOR Then
                                    .Cells(lastRow, col).Interior.ColorIndex = 3
                                End If
                                col = col + 1
                            Else
                                ' Show special, two cuts in a row
                                ' Don't show for the first one
                                If Not pieceNo = 1 Then
                                    If prevPieceType = enumPieceType.cut Then
                                        ' Show special
                                        .Cells(lastRow, col).value = toDisplayUnitDouble(tmpPiece.length)
                                        Logger.logInfo "Two cuts in a row detected"
                                        'If CPATTERN_SHOW_COLOR Then
                                            .Cells(lastRow, col).Interior.ColorIndex = 3
                                        'End If
                                        col = col + 1
                                    End If
                                End If
                            End If
                        ElseIf tmpPiece.pieceType = enumPieceType.waste Then
                            If Globals.CPATTERN_SHOW_WASTE_PIECES Then
                                .Cells(lastRow, col).value = toDisplayUnitDouble(tmpPiece.length)
                                .Cells(lastRow, col).Font.italic = True
                                .Cells(lastRow, col).Font.underline = False
                                .Cells(lastRow, col).Font.bold = False
                                .Cells(lastRow, col).Interior.color = 0
                                .Cells(lastRow, col).Font.color = 16777215 ' White
                                col = col + 1
                            End If
                        Else
                            .Cells(lastRow, col).value = toDisplayUnitDouble(tmpPiece.length)
                            ' Format pieces according to HPR placement
                            If tmpPiece.hprPlacement = enumHPRPlacement.noSide Then
                                .Cells(lastRow, col).Font.italic = False
                                .Cells(lastRow, col).Font.underline = False
                                .Cells(lastRow, col).Font.bold = False
                            ElseIf tmpPiece.hprPlacement = enumHPRPlacement.leftSide Then
                                .Cells(lastRow, col).Font.italic = False
                                .Cells(lastRow, col).Font.underline = True
                                .Cells(lastRow, col).Font.bold = False
                            ElseIf tmpPiece.hprPlacement = enumHPRPlacement.rightSide Then
                                .Cells(lastRow, col).Font.italic = False
                                .Cells(lastRow, col).Font.underline = False
                                .Cells(lastRow, col).Font.bold = True
                            ElseIf tmpPiece.hprPlacement = enumHPRPlacement.bothSides Then
                                .Cells(lastRow, col).Font.italic = False
                                .Cells(lastRow, col).Font.underline = True
                                .Cells(lastRow, col).Font.bold = True
                            End If
                            col = col + 1
                        End If
                        prevPieceType = tmpPiece.pieceType  ' Used to recognize two cuts in a row
                    Next
                End With
                
                If col > highestCol Then
                    highestCol = col
                End If
            End If
        Next
    Next

    ' Print headings
    With SheetCuttingPattern
        .Cells(Globals.CPATTERN_ROW_START - 1, Globals.CPATTERN_COL_START).value = Translate("tbl_cutting")
        .Cells(Globals.CPATTERN_ROW_START - 1, Globals.CPATTERN_COL_START).Font.bold = True
        .Cells(Globals.CPATTERN_ROW_START - 1, Globals.CPATTERN_COL_START).HorizontalAlignment = xlCenter
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START).value = Translate("tbl_profile")
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START).Font.bold = True
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START).HorizontalAlignment = xlCenter
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 1).value = Translate("tbl_sap_description")
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 1).Font.bold = True
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 1).HorizontalAlignment = xlLeft
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 2).value = Translate("tbl_sap_no")
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 2).Font.bold = True
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 2).HorizontalAlignment = xlRight
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 3).value = Translate("tbl_qty")
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 3).Font.bold = True
        .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 3).HorizontalAlignment = xlRight

        ' Print heading over piece counts
        .Cells(Globals.CPATTERN_ROW_START - 1, Globals.CPATTERN_COL_START + 4).value = Translate("tbl_pieces")
        .Cells(Globals.CPATTERN_ROW_START - 1, Globals.CPATTERN_COL_START + 4).Font.bold = True
        .Cells(Globals.CPATTERN_ROW_START - 1, Globals.CPATTERN_COL_START + 4).HorizontalAlignment = xlLeft
        For boldColNo = 1 To (highestCol - Globals.CPATTERN_COL_START - 4)
            .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 3 + boldColNo).value = boldColNo
            .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 3 + boldColNo).Font.bold = True
            .Cells(Globals.CPATTERN_ROW_START, Globals.CPATTERN_COL_START + 3 + boldColNo).HorizontalAlignment = xlRight
        Next
        
        ' Special case for disabled tolerance, print "Cut on cutting mark"
        ' TODO: Translate
        'Nous Added Functionality
        Dim lsRange As Range
        Set lsRange = SheetRequest.Range("E1:E1000")
        If WorksheetFunction.CountIf(lsRange, "B2") + WorksheetFunction.CountIf(lsRange, "C2") > 0 Then
            .Range(Globals.CPATTERN_NOTE).value = "Cut on the cutting mark"
            .Range(Globals.CPATTERN_NOTE).Font.bold = True
        Else
            .Range(Globals.CPATTERN_NOTE).value = ""
            .Range(Globals.CPATTERN_NOTE).Font.bold = True
        End If
    End With
            
    ' Report time
    Logger.logInfoBoth "done."
    Logger.logInfoBoth "Time " & Round(Timer - startTime, 2) & "s"
End Sub


' Shows statistics and the cut material list
Public Function writePicklist( _
    ByRef binSets() As CBinSet, _
    ByRef channelTypeSet As CChannelTypeSet, _
    ByVal chTypeCount As Long _
) As Long

    ' TODO Define global constants
    
    Const START_ROW_NEEDED_MATERIAL As Long = 2
    Const START_COL_NEEDED_MATERIAL As Long = 1
    Const START_ROW_CUT_MATERIAL As Long = 2
    Const START_COL_CUT_MATERIAL As Long = 7

    Dim curentCol As Long
    Dim curentRow As Long
    Dim savedRow As Long
    
    Dim binSetNo As Long
    Dim totalMaterialCost As Double
    Dim totalWaste As Long
    Dim totalLength As Long
    totalMaterialCost = 0
    Dim lsTemp As String
    
    With SheetOutputLists

        curentCol = START_COL_NEEDED_MATERIAL
        curentRow = START_ROW_NEEDED_MATERIAL

        ' Write SAP customter and order no
'.Cells(curentRow, curentCol).name = "tbl_sap_order_no"
        .Cells(curentRow, curentCol).value = Translate("tbl_sap_order_no")
        .Cells(curentRow, curentCol).Font.bold = True
        
        curentCol = curentCol + 1
        '.Cells(curRow, curCol).value = SheetRequest.Range(REQUEST_HEADER_SAP_ORDER_NO).value
        .Cells(curentRow, curentCol).Interior.color = Globals.COLOR_INPUTFIELD_BACKGROUND
        .Cells(curentRow, curentCol).HorizontalAlignment = xlCenter
        curentCol = START_COL_NEEDED_MATERIAL
        curentRow = curentRow + 1
        
'.Cells(curentRow, curentCol).name = "tbl_sap_customer_no"
        .Cells(curentRow, curentCol).value = Translate("tbl_sap_customer_no")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = vbNullString
        .Cells(curentRow, curentCol).Interior.color = Globals.COLOR_INPUTFIELD_BACKGROUND
        .Cells(curentRow, curentCol).HorizontalAlignment = xlCenter

        curentCol = START_COL_NEEDED_MATERIAL
        curentRow = curentRow + 2
        
        ' Insert button
        Dim PDFExportButton As Button
        Dim curentCell As Range
        Set curentCell = .Range(.Cells(curentRow, curentCol), .Cells(curentRow, curentCol))
        Set PDFExportButton = .Buttons.Add(curentCell.Left, curentCell.Top, 70, 20)
        With PDFExportButton
            .OnAction = "PDFExportButton_Click"
            .Caption = Translate("button_export_to_pdf")
            .name = "ExportButton"
        End With

        curentCol = START_COL_NEEDED_MATERIAL
        curentRow = curentRow + 3
        
        ' Heading Needed material
'.Cells(curentRow, curentCol).name = "tbl_needed_material"
        .Cells(curentRow, curentCol).value = Translate("tbl_needed_material")
        .Cells(curentRow, curentCol).Font.bold = True
        
        curentRow = curentRow + 1
'.Cells(curentRow, curentCol).name = "tbl_sap_description"
        .Cells(curentRow, curentCol).value = Translate("tbl_sap_description")
        .Cells(curentRow, curentCol).Font.bold = True
        
        curentCol = curentCol + 1
'.Cells(curentRow, curentCol).name = "tbl_sap_no"
        .Cells(curentRow, curentCol).value = Translate("tbl_sap_no")
        .Cells(curentRow, curentCol).Font.bold = True
        
        curentCol = curentCol + 1
'.Cells(curentRow, curentCol).name = "tbl_qty"
        .Cells(curentRow, curentCol).value = Translate("tbl_qty")
        .Cells(curentRow, curentCol).Font.bold = True
        
        curentCol = curentCol + 1
        lsTemp = Translate("tbl_length") & " (" & Translate("var_long_unit_mm") & ")"
        .Cells(curentRow, curentCol).value = lsTemp
        .Cells(curentRow, curentCol).Font.bold = True
        .Cells(curentRow, curentCol).HorizontalAlignment = xlRight
        
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_waste_rate")
        .Cells(curentRow, curentCol).Font.bold = True
        .Cells(curentRow, curentCol).HorizontalAlignment = xlRight
        
        If Settings.showCosts Then
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = Translate("tbl_cost")
            .Cells(curentRow, curentCol).Font.bold = True
            .Cells(curentRow, curentCol).HorizontalAlignment = xlRight
        End If
        curentRow = curentRow + 1
        
        ' Print list of needed materials, needed material is the same as number of bins
        Dim chVariant As CChannelTypeVariant
        Dim bins() As CBin
        Dim pieces() As CPiece
        Dim chVariants() As CChannelTypeVariant
        Dim chVariantType() As String
        Dim chVariantQuantity() As Long
        Dim chVariantLength() As Long
        Dim chVariantTotalLength() As Long
        Dim chVariantWaste() As Long
        Dim chVariantUsed() As Long
        Dim chVariantCount As Long
        Dim binNo As Long
        Dim chVariantNo As Long
        Dim foundOne As Boolean
        Dim channelTypeCuts() As Long
        Dim channelTypeKeys() As String
        chVariantCount = 0
        
        Dim pieceNo As Long
        Dim innerPieceNo As Long
        Dim totalUsedPieceCost As Double
        Dim totalWasteCost As Double
        Dim totalWastePieceCost As Double
        Dim totalCutWasteCost As Double
        Dim totalCutCost As Double
        Dim pieceRepresentation() As CPiece
        Dim pieceRepresentationQuantity() As Long
        Dim pieceRepresentationCutCost() As Long
        Dim pieceRepresentationMaterialCost() As Double
        Dim pieceRepresentationCount As Long
        Dim pieceCost As Double
        pieceCost = 0
        pieceRepresentationCount = 0
        totalUsedPieceCost = 0
        totalWasteCost = 0
        totalCutWasteCost = 0
        totalWastePieceCost = 0
        totalCutCost = 0
        
        ' Quick hack to get number of cuts:
        Dim numberOfCutsTotal_hack As Long
        
        ReDim channelTypeCuts(1 To chTypeCount)
        ReDim channelTypeKeys(1 To chTypeCount)
        
        
        ' Count material used
        ' loops through every CBinSet in AllBinSets
        For binSetNo = 1 To chTypeCount
            bins = binSets(binSetNo).getBins
            totalWaste = totalWaste + binSets(binSetNo).getWaste
            totalLength = totalLength + binSets(binSetNo).getTotalLength
            
            ' For counting cuts
            channelTypeKeys(binSetNo) = binSets(binSetNo).channelTypeKey
            
            ' loops through every CBin in the current CBinSet
            For binNo = 1 To binSets(binSetNo).count
                Set chVariant = channelTypeSet.getVariant(bins(binNo).channelTypeKey, bins(binNo).length)
                '.Cells(curRow, curCol).Value = chVariant.lengthName
                foundOne = False
                
                ' Find the right variant to count up
                ' loops through every channel variant (to count for the right Channel type variant)
                For chVariantNo = 1 To chVariantCount
                    If chVariantType(chVariantNo) = bins(binNo).channelTypeKey _
                        And chVariantLength(chVariantNo) = bins(binNo).length _
                    Then
                        ' Found one, add to its counters
                        chVariantQuantity(chVariantNo) = chVariantQuantity(chVariantNo) + 1
                        chVariantLength(chVariantNo) = bins(binNo).length
                        chVariantTotalLength(chVariantNo) = chVariantTotalLength(chVariantNo) + bins(binNo).length
                        chVariantWaste(chVariantNo) = chVariantWaste(chVariantNo) + bins(binNo).getWasteSum ' Add waste sum
                        chVariantUsed(chVariantNo) = chVariantUsed(chVariantNo) + bins(binNo).getUsefullSum
                        foundOne = True
                        Exit For
                    End If
                Next
                ' If it was of a variant that was not counted before
                If Not foundOne Then
                    ' We have not counted this one yet, add it to the arrays and reinitialize them
                    chVariantCount = chVariantCount + 1
                    ReDim Preserve chVariantType(1 To chVariantCount)
                    ReDim Preserve chVariantQuantity(1 To chVariantCount)
                    ReDim Preserve chVariantLength(1 To chVariantCount)
                    ReDim Preserve chVariantTotalLength(1 To chVariantCount)
                    ReDim Preserve chVariantWaste(1 To chVariantCount)
                    ReDim Preserve chVariantUsed(1 To chVariantCount)
                    ReDim Preserve chVariants(1 To chVariantCount)
                    '@Ignore ObjectVariableNotSet
                    Set chVariants(chVariantCount) = chVariant
                    chVariantType(chVariantCount) = bins(binNo).channelTypeKey
                    chVariantLength(chVariantCount) = bins(binNo).length
                    chVariantTotalLength(chVariantCount) = bins(binNo).length
                    chVariantWaste(chVariantCount) = bins(binNo).getWasteSum
                    chVariantUsed(chVariantNo) = bins(binNo).getUsefullSum
                    chVariantQuantity(chVariantCount) = 1
                End If
                
                ' Count all the material used as well as cuts
                pieces = bins(binNo).getPieces
                For pieceNo = 1 To bins(binNo).pieceCount
                    
                    ' Calculate the material cost of the piece
                    pieceCost = (pieces(pieceNo).length / CDbl(chVariant.safeLength)) * CDbl(chVariant.cost)
                    
                    ' Normal piece
                    If pieces(pieceNo).pieceType = enumPieceType.normal Then
                        foundOne = False
                        For innerPieceNo = 1 To pieceRepresentationCount
                            If pieces(pieceNo).hasSameFundamentals(pieceRepresentation(innerPieceNo)) Then
                                ' Found a piece type that we have already seen, add it to the
                                pieceRepresentationQuantity(innerPieceNo) = pieceRepresentationQuantity(innerPieceNo) + 1
                                foundOne = True
                                Exit For
                            End If
                        Next
                        If Not foundOne Then
                            ' Unique type of piece found, add it to the array
                            ' We have not counted this one yet, add it to the arrays and reinialize them
                            pieceRepresentationCount = pieceRepresentationCount + 1
                            ReDim Preserve pieceRepresentation(1 To pieceRepresentationCount)
                            ReDim Preserve pieceRepresentationQuantity(1 To pieceRepresentationCount)
                            ReDim Preserve pieceRepresentationCutCost(1 To pieceRepresentationCount)
                            ReDim Preserve pieceRepresentationMaterialCost(1 To pieceRepresentationCount)
                            '@Ignore ObjectVariableNotSet
                            Set pieceRepresentation(pieceRepresentationCount) = pieces(pieceNo).getCopy
                            pieceRepresentationQuantity(pieceRepresentationCount) = 1
                            pieceRepresentationCutCost(pieceRepresentationCount) = chVariant.cutCost
                            pieceRepresentationMaterialCost(pieceRepresentationCount) = pieceCost
                        End If
                        totalUsedPieceCost = totalUsedPieceCost + pieceCost
                    ElseIf pieces(pieceNo).pieceType = enumPieceType.cut Then
                        numberOfCutsTotal_hack = numberOfCutsTotal_hack + 1
                        totalCutWasteCost = totalCutWasteCost + pieceCost
                        totalCutCost = totalCutCost + chVariant.cutCost
                        
                        ' Count no of cuts
                        channelTypeCuts(binSetNo) = channelTypeCuts(binSetNo) + 1
                        
                    ElseIf pieces(pieceNo).pieceType = enumPieceType.waste Then
                        ' Calculate total waste cost
                        totalWastePieceCost = totalWastePieceCost + pieceCost
                    End If
                Next
            Next
        Next
        
        totalWasteCost = totalWastePieceCost + totalCutWasteCost
        ' Print what we found while we count total cost
        For chVariantNo = 1 To chVariantCount
            totalMaterialCost = totalMaterialCost + chVariants(chVariantNo).cost * chVariantQuantity(chVariantNo)
            curentCol = START_COL_NEEDED_MATERIAL
            .Cells(curentRow, curentCol).value = chVariants(chVariantNo).SAPdescription
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = chVariants(chVariantNo).SAPnumber
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = chVariantQuantity(chVariantNo)
            curentCol = curentCol + 1
            ' TODO: Fix for inch version
            .Cells(curentRow, curentCol).value = chVariantTotalLength(chVariantNo) / Settings.conversionFactorLongUnit ' Convert from fundamental unit to long unit
            .Cells(curentRow, curentCol).NumberFormat = "0"
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = CDbl(chVariantWaste(chVariantNo)) / (CDbl(chVariants(chVariantNo).length) * CDbl(chVariantQuantity(chVariantNo)))
            .Cells(curentRow, curentCol).NumberFormat = "0.0%"
            If Settings.showCosts Then
                curentCol = curentCol + 1
                .Cells(curentRow, curentCol).value = chVariants(chVariantNo).cost * chVariantQuantity(chVariantNo) / 100  ' Convert from cents to EUR
                .Cells(curentRow, curentCol).NumberFormat = "0.0"
            End If
            curentRow = curentRow + 1
        Next
        
        ' Print waste rate and waste cost
        curentCol = START_COL_NEEDED_MATERIAL
        curentRow = curentRow + 1
        
        .Cells(curentRow, curentCol).value = Translate("var_total_waste")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        If CDbl(totalLength) > 0 Then
            .Cells(curentRow, curentCol).value = CDbl(totalWaste) / CDbl(totalLength)
        Else
            .Cells(curentRow, curentCol).value = 0
        End If
        
        .Cells(curentRow, curentCol).NumberFormat = "0.0%"
        
        ' Save row for later:
        savedRow = curentRow
        
        ' Print headings for cut material
        curentCol = START_COL_CUT_MATERIAL
        '@Ignore AssignmentNotUsed
        curentRow = START_ROW_CUT_MATERIAL
        
        curentRow = curentRow + 2
        .Cells(curentRow, curentCol).value = Translate("subheading_cut_material")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 4
        .Cells(curentRow, curentCol).value = Translate("tbl_used")
        .Cells(curentRow, curentCol).Font.bold = True
        .Cells(curentRow, curentCol).HorizontalAlignment = xlCenter
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_allowed")
        .Cells(curentRow, curentCol).Font.bold = True
        .Cells(curentRow, curentCol).HorizontalAlignment = xlCenter
        curentRow = curentRow + 1
        curentCol = START_COL_CUT_MATERIAL
        .Cells(curentRow, curentCol).value = Translate("tbl_type")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_qty")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_length") & " (" & Translate("var_display_unit_mm") & ")"
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_cutting_type")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_tolerance") & " (" & Translate("var_display_unit_mm") & ")"
        .Cells(curentRow, curentCol).Font.bold = True
        .Cells(curentRow, curentCol).HorizontalAlignment = xlCenter
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_tolerance") & " (" & Translate("var_display_unit_mm") & ")"
        .Cells(curentRow, curentCol).Font.bold = True
        .Cells(curentRow, curentCol).HorizontalAlignment = xlCenter
        If Settings.showCosts Then
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = Translate("tbl_cost") & " *"
            .Cells(curentRow, curentCol).Font.bold = True
            .Cells(curentRow, curentCol).HorizontalAlignment = xlRight
        End If
       
        ' Print cut material
        curentCol = START_COL_CUT_MATERIAL
        curentRow = curentRow + 1
        For pieceNo = 1 To pieceRepresentationCount
            curentCol = START_COL_CUT_MATERIAL
            .Cells(curentRow, curentCol).value = pieceRepresentation(pieceNo).channelTypeKey
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = pieceRepresentationQuantity(pieceNo)
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = toDisplayUnitDouble(pieceRepresentation(pieceNo).length)
            curentCol = curentCol + 1
            If pieceRepresentation(pieceNo).hprPlacement = enumHPRPlacement.noSide Then
                .Cells(curentRow, curentCol).value = "zero"
            ElseIf pieceRepresentation(pieceNo).hprPlacement = enumHPRPlacement.rightSide Then
                .Cells(curentRow, curentCol).value = "right"
            ElseIf pieceRepresentation(pieceNo).hprPlacement = enumHPRPlacement.leftSide Then
                .Cells(curentRow, curentCol).value = "left"
            ElseIf pieceRepresentation(pieceNo).hprPlacement = enumHPRPlacement.bothSides Then
                .Cells(curentRow, curentCol).value = "both"
            Else
                .Cells(curentRow, curentCol).value = "not set!"
            End If
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = toDisplayUnitDouble(pieceRepresentation(pieceNo).usedTolerance)
            .Cells(curentRow, curentCol).NumberFormat = "0.0"
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = toDisplayUnitDouble(pieceRepresentation(pieceNo).allowedTolerance)
            .Cells(curentRow, curentCol).NumberFormat = "0.0"
            If Settings.showCosts Then
                ' In EUR
                ' TODO: Break out constant
                curentCol = curentCol + 1
                .Cells(curentRow, curentCol).value = (pieceRepresentationMaterialCost(pieceNo) * pieceRepresentationQuantity(pieceNo)) / 10
                .Cells(curentRow, curentCol).NumberFormat = "0.0"
            End If
            curentRow = curentRow + 1
        Next
        
        curentCol = START_COL_CUT_MATERIAL
        .Cells(curentRow, curentCol).value = "* " & Translate("var_does_not_include_waste_or_cut")
        
        curentRow = curentRow + 2
        
        ' Heading Total cuts
        .Cells(curentRow, curentCol).value = Translate("tbl_total_cuts_per_type")
        .Cells(curentRow, curentCol).Font.bold = True
        curentRow = curentRow + 1
        curentCol = START_COL_CUT_MATERIAL
        .Cells(curentRow, curentCol).value = Translate("tbl_type")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = Translate("tbl_cuts")
        .Cells(curentRow, curentCol).Font.bold = True
        
        curentCol = START_COL_CUT_MATERIAL
        curentRow = curentRow + 1
        
        
        ' Print no of cuts per channel type
        For binSetNo = 1 To chTypeCount
            .Cells(curentRow, curentCol).value = channelTypeKeys(binSetNo)
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = channelTypeCuts(binSetNo)
            .Cells(curentRow, curentCol).NumberFormat = "0"
            curentRow = curentRow + 1
            curentCol = START_COL_CUT_MATERIAL
        Next
        
        curentRow = curentRow + 1

        ' Heading Total cuts
        .Cells(curentRow, curentCol).value = Translate("var_total_cuts")
        .Cells(curentRow, curentCol).Font.bold = True
        curentCol = curentCol + 1
        .Cells(curentRow, curentCol).value = numberOfCutsTotal_hack
        .Cells(curentRow, curentCol).NumberFormat = "0"
                
        If Settings.showCosts Then
            ' Print Heading Total cost
            '@Ignore AssignmentNotUsed
            curentRow = savedRow
            curentRow = curentRow + 2
            curentCol = START_COL_NEEDED_MATERIAL
            
            .Cells(curentRow, curentCol).value = Translate("subheading_total_cost")
            .Cells(curentRow, curentCol).Font.bold = True
            curentRow = curentRow + 1
            
            ' Print Total costs
            circleDiagramStartRow = curentRow  ' Set global variable
            .Cells(curentRow, curentCol).value = Translate("var_used_material")
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = totalMaterialCost / 100 ' Convert to EUR from cents
            .Cells(curentRow, curentCol).NumberFormat = "0.0"
            curentCol = START_COL_NEEDED_MATERIAL
            curentRow = curentRow + 1
            .Cells(curentRow, curentCol).value = Translate("var_waste_material")
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = totalWasteCost / 100
            .Cells(curentRow, curentCol).NumberFormat = "0.0"
            curentCol = START_COL_NEEDED_MATERIAL
            curentRow = curentRow + 1
            .Cells(curentRow, curentCol).value = Translate("var_cutting_cost")
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = totalCutCost / 100 ' Convert to EUR from cents
            .Cells(curentRow, curentCol).NumberFormat = "0.0"
            curentCol = START_COL_NEEDED_MATERIAL
            curentRow = curentRow + 1
            .Cells(curentRow, curentCol).value = Translate("var_sum")
            .Cells(curentRow, curentCol).Font.bold = True
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = (totalMaterialCost + totalCutCost + totalWasteCost) / 100  ' Convert to EUR from cents
            .Cells(curentRow, curentCol).NumberFormat = "0.0"
            .Cells(curentRow, curentCol).Font.bold = True
            curentRow = curentRow + 4
        Else
            curentRow = curentRow + 2
        End If
    End With
    
    writePicklist = curentRow
End Function


' Shows statistics, the left part of the output page
Private Sub writeFailList( _
    ByVal startRow As Long, _
    ByRef binSets() As CBinSet, _
    ByVal chTypeCount As Long _
)
    ' TODO Define global constants
    Const START_COL As Long = 7
    
    Dim curentCol As Long
    Dim curentRow As Long
    
    Dim binSetNo As Long

    Dim unplaceableNo As Long
    Dim uniqueFailedPieces() As CPiece
    Dim uniqueFailedPieceQty() As Long
    Dim uniqueFailedPiecesCount As Long
    Dim uniqueFailedPieceNo As Long
    Dim matchNo As Long

    uniqueFailedPiecesCount = 0
   
    ' Look for pieces that were not placed
   
    ' Loops through every CBinSet in AllBinSets
    For binSetNo = 1 To chTypeCount
                
        ' Loops through every CPiece in unplaceable
        For unplaceableNo = 1 To binSets(binSetNo).unplaceableCount
                            
            matchNo = 0
            
            ' Check uniqueness against the list of previously failed pieces.
            For uniqueFailedPieceNo = 1 To uniqueFailedPiecesCount
                If uniqueFailedPieces(uniqueFailedPieceNo).hasSameFundamentals(binSets(binSetNo).getUnplaceablePiece(unplaceableNo)) Then
                    matchNo = uniqueFailedPieceNo
                    Exit For
                End If
            Next
            
            If matchNo > 0 Then
                ' The piece matches one that we alredy have in the array, increase the quantity
                uniqueFailedPieceQty(matchNo) = uniqueFailedPieceQty(matchNo) + 1
            Else
                ' The piece did not exist already in the array of unique failed pieces, add it to the array
                uniqueFailedPiecesCount = uniqueFailedPiecesCount + 1
                ReDim Preserve uniqueFailedPieces(1 To uniqueFailedPiecesCount)
                ReDim Preserve uniqueFailedPieceQty(1 To uniqueFailedPiecesCount)
                '@Ignore ObjectVariableNotSet
                Set uniqueFailedPieces(uniqueFailedPiecesCount) = binSets(binSetNo).getUnplaceablePiece(unplaceableNo).getCopy
                uniqueFailedPieceQty(uniqueFailedPiecesCount) = 1
            End If
        Next
    Next

    ' If any failed pieces were found
    If uniqueFailedPieceNo > 0 Then
        
        With SheetOutputLists
            ' Print headings for cut material
            curentCol = START_COL
            curentRow = startRow
            
            .Cells(curentRow, curentCol).value = Translate("error_these_items_could_not_be_placed")
            .Cells(curentRow, curentCol).Font.bold = True
            curentRow = curentRow + 1
            curentCol = START_COL
            .Cells(curentRow, curentCol).value = Translate("tbl_type")
            .Cells(curentRow, curentCol).Font.bold = True
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = Translate("tbl_qty")
            .Cells(curentRow, curentCol).Font.bold = True
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = Translate("tbl_length") & " (" & Translate("var_display_unit_mm") & ")"
            .Cells(curentRow, curentCol).Font.bold = True
            curentCol = curentCol + 1
            .Cells(curentRow, curentCol).value = Translate("tbl_cutting_type")
            .Cells(curentRow, curentCol).Font.bold = True
           
            ' Print list of pieces that could not be placed
            For uniqueFailedPieceNo = 1 To uniqueFailedPiecesCount
                curentRow = curentRow + 1
                curentCol = START_COL
                
                .Cells(curentRow, curentCol).value = uniqueFailedPieces(uniqueFailedPieceNo).channelTypeKey
                curentCol = curentCol + 1
                .Cells(curentRow, curentCol).value = uniqueFailedPieceQty(uniqueFailedPieceNo)
                curentCol = curentCol + 1
                .Cells(curentRow, curentCol).value = toDisplayUnitDouble(uniqueFailedPieces(uniqueFailedPieceNo).length)
                curentCol = curentCol + 1
                .Cells(curentRow, curentCol).value = cuttingTypeToString(uniqueFailedPieces(uniqueFailedPieceNo).cuttingType)
            Next
        End With
    End If
End Sub


Public Sub writeOutputListsSheet( _
    ByRef binSets() As CBinSet, _
    ByRef channelTypeSet As CChannelTypeSet, _
    ByVal chTypeCount As Long _
)
    ' Set the background on all cells to white
    genericSheet.setBackground Globals.COLOR_DEFAULT_BACKGROUND, SheetOutputLists
    Dim endRow As Long
    endRow = writePicklist(binSets, channelTypeSet, chTypeCount)
    writeFailList endRow + 2, binSets, chTypeCount
    outputSheets.adjustOutputListsSheet
End Sub


Public Sub writeCuttingPatternSheet( _
    ByRef binSets() As CBinSet, _
    ByRef channelTypeSet As CChannelTypeSet, _
    ByVal chTypeCount As Long _
)
    ' Set the background on all cells to white
    genericSheet.setBackground Globals.COLOR_DEFAULT_BACKGROUND, SheetCuttingPattern
    writeCuttingPattern binSets, channelTypeSet, chTypeCount
    outputSheets.adjustCuttingPatternSheet
    outputSheets.addLegend
End Sub
Attribute VB_Name = "CPDFExporter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CPDFExporter class

' Saves the output sheet as a PDF
Private Sub exportToPDF(ByVal choosenFileName As String)

    ' Measure time taken
    Dim startTime As Single
    startTime = Timer
    Logger.logInfoBoth "Creating PDF..."
    
    SheetDiagrams.PageSetup.Orientation = xlLandscape

    With SheetOutputLists.PageSetup
        .PrintTitleRows = vbNullString
        .PrintTitleColumns = vbNullString
        .PrintArea = vbNullString
        .LeftHeader = vbNullString
        .CenterHeader = vbNullString
        .RightHeader = vbNullString
        .LeftFooter = vbNullString
        .CenterFooter = vbNullString
        .RightFooter = vbNullString
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.75)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlLandscape
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlOverThenDown
        .BlackAndWhite = False
        .Zoom = 100
        .FitToPagesWide = 1
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = vbNullString
        .EvenPage.CenterHeader.Text = vbNullString
        .EvenPage.RightHeader.Text = vbNullString
        .EvenPage.LeftFooter.Text = vbNullString
        .EvenPage.CenterFooter.Text = vbNullString
        .EvenPage.RightFooter.Text = vbNullString
        .FirstPage.LeftHeader.Text = vbNullString
        .FirstPage.CenterHeader.Text = vbNullString
        .FirstPage.RightHeader.Text = vbNullString
        .FirstPage.LeftFooter.Text = vbNullString
        .FirstPage.CenterFooter.Text = vbNullString
        .FirstPage.RightFooter.Text = vbNullString
    End With
    
    With SheetCuttingPattern.PageSetup
        .PrintTitleRows = vbNullString
        .PrintTitleColumns = vbNullString
        .PrintArea = vbNullString
        .LeftHeader = vbNullString
        .CenterHeader = vbNullString
        .RightHeader = vbNullString
        .LeftFooter = vbNullString
        .CenterFooter = vbNullString
        .RightFooter = vbNullString
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.75)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlLandscape
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlOverThenDown
        .BlackAndWhite = False
        .Zoom = 80
        .FitToPagesWide = 1
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = vbNullString
        .EvenPage.CenterHeader.Text = vbNullString
        .EvenPage.RightHeader.Text = vbNullString
        .EvenPage.LeftFooter.Text = vbNullString
        .EvenPage.CenterFooter.Text = vbNullString
        .EvenPage.RightFooter.Text = vbNullString
        .FirstPage.LeftHeader.Text = vbNullString
        .FirstPage.CenterHeader.Text = vbNullString
        .FirstPage.RightHeader.Text = vbNullString
        .FirstPage.LeftFooter.Text = vbNullString
        .FirstPage.CenterFooter.Text = vbNullString
        .FirstPage.RightFooter.Text = vbNullString
    End With

    With SheetDiagrams.PageSetup
        .PrintTitleRows = vbNullString
        .PrintTitleColumns = vbNullString
        .PrintArea = vbNullString
        .LeftHeader = vbNullString
        .CenterHeader = vbNullString
        .RightHeader = vbNullString
        .LeftFooter = vbNullString
        .CenterFooter = vbNullString
        .RightFooter = vbNullString
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.75)
        .BottomMargin = Application.InchesToPoints(0.75)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)
        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .CenterHorizontally = False
        .CenterVertically = False
        .Orientation = xlLandscape
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = 62
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = vbNullString
        .EvenPage.CenterHeader.Text = vbNullString
        .EvenPage.RightHeader.Text = vbNullString
        .EvenPage.LeftFooter.Text = vbNullString
        .EvenPage.CenterFooter.Text = vbNullString
        .EvenPage.RightFooter.Text = vbNullString
        .FirstPage.LeftHeader.Text = vbNullString
        .FirstPage.CenterHeader.Text = vbNullString
        .FirstPage.RightHeader.Text = vbNullString
        .FirstPage.LeftFooter.Text = vbNullString
        .FirstPage.CenterFooter.Text = vbNullString
        .FirstPage.RightFooter.Text = vbNullString
    End With
    
    ' Try to remove the blank pages
    SheetOutputLists.UsedRange.SpecialCells (xlCellTypeLastCell)
    SheetCuttingPattern.UsedRange.SpecialCells (xlCellTypeLastCell)
    SheetDiagrams.UsedRange.SpecialCells (xlCellTypeLastCell)
    
    ' Select the sheets to export:
    ThisWorkbook.Sheets( _
        Array(SheetOutputLists.name, _
        SheetCuttingPattern.name, _
        SheetDiagrams.name) _
    ).Select
    
    ' TODO: Figure out if ActiveSheet can be changed here:
    ' The actual export
    ActiveSheet.ExportAsFixedFormat _
        Type:=xlTypePDF, _
        fileName:=choosenFileName, _
        Quality:=xlQualityStandard, _
        IncludeDocProperties:=False, _
        IgnorePrintAreas:=False, _
        OpenAfterPublish:=True

    Logger.logInfoBoth "Saved as " & choosenFileName
    ' Report time
    Logger.logInfoBoth "done."
    Logger.logInfoBoth "Time " & Round(Timer - startTime, 2) & "s"
    
    ' Reset the sheet selection so the user interface works again (it is very hard for the user to see that tabs have been selected)
    SheetOutputLists.Select
End Sub

Public Sub saveAsPdfDialog()
    Dim choosenFileNameVariant As Variant
    Dim choosenFileName As String
    Dim sapOrderNo As String
    Dim suggestedFileName As String
    Dim askAgain As Boolean
    Dim okToWrite As Boolean

    askAgain = True
    okToWrite = False

    ' Default filename
    sapOrderNo = SheetOutputLists.Range(Globals.OUTPUTLISTS_HEADER_SAP_ORDER_NO).value
    suggestedFileName = Translate("pdf_filename") & " " & sapOrderNo & ".pdf"
    
    ' Show 'Save file as'-dialog until the user selects a file that does not exist or accepts to overwrite it or closes the dialog
    While askAgain
        choosenFileNameVariant = Application.GetSaveAsFilename( _
            InitialFileName:=suggestedFileName, _
            FileFilter:=Translate("pdf_pdf_files") & " (*.pdf), *.pdf" _
        )
        
        If VarType(choosenFileNameVariant) = vbString Then
            Dim result As VbMsgBoxResult
            
            ' Check if the file aready exists
            If Dir(choosenFileNameVariant) <> vbNullString Then
                result = MsgBox( _
                    Prompt:=Translate("pdf_the_file") & ": " & choosenFileNameVariant & " " & _
                        Translate("pdf_already_exists") & "." & vbCrLf & _
                        Translate("pdf_do_you_want_to_overwrite_it"), _
                    Buttons:=vbYesNo, _
                    title:=Translate("pdf_the_confirm_save_as") _
                )
                If result = vbYes Then
                    ' File exists but the user is ok with overwriting it
                    
                    ' Check if the file is open
                    If isFileOpen(choosenFileNameVariant) Then
                        ' Show a dialog telling the user that the file could not be written because it is open
                        MsgBox _
                            Prompt:=Translate("pdf_the_file") & ": " & _
                                choosenFileNameVariant & " " & Translate("pdf_file_could_not_be_written"), _
                            Buttons:=vbOKOnly, _
                            title:=Translate("pdf_error_saving_file")
                        askAgain = True
                        okToWrite = False
                    Else
                        askAgain = False
                        okToWrite = True
                    End If
                Else
                    ' File exists but the user does not want to overwrite it
                    askAgain = False
                End If
            Else
                ' File does not exist
                okToWrite = True
                askAgain = False
            End If
        Else
            ' The user canceled the dialog
            askAgain = False
        End If
    Wend
    
    If okToWrite Then
        choosenFileName = choosenFileNameVariant
        exportToPDF choosenFileName
    End If
End Sub


' Checks if the given file is open by trying to open it with a lock state
' If opening fails it is assumed that the file was opened by another application
Public Function isFileOpen(ByVal filePath As String) As Boolean
    Dim fileHandle As Long
        On Error GoTo FileIsOpen:
        fileHandle = FreeFile
        Open filePath For Random Access Read Write Lock Read Write As fileHandle
        isFileOpen = False
        Close fileHandle
        Exit Function
FileIsOpen:
        isFileOpen = True
        Close fileHandle
End Function
Attribute VB_Name = "CPiece"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CPiece class

Private Type TPices
    channelTypeKey As String         ' Channel type of the piece
    hprPlacement As enumHPRPlacement ' Hole pattern relevance placement, tells how the piece was placed
    cuttingType As enumCuttingType           ' Hole pattern relevance type, the requested HPR of the item
    pieceType As enumPieceType       ' Type of piece, this is either normal or waste piece
    length As Long                   ' Length as 1/10 mm, lenght of pieces is not fixed but is set at placement time
    placed As Boolean
    usedTolerance As Long            ' How much of the tolerance this piece actually uses
    allowedTolerance As Long         ' How much of the tolerance is allowed
End Type

Private this As TPices

Private Sub class_initialize()
    this.channelTypeKey = vbNullString
    this.hprPlacement = enumHPRPlacement.notSet
    this.cuttingType = enumCuttingType.A
    this.pieceType = enumPieceType.normal
    this.length = 0
    this.placed = False
    this.usedTolerance = 0
    this.allowedTolerance = 0
End Sub

Public Function getCopy() As CPiece
    Set getCopy = New CPiece
    getCopy.setValues _
        channelTypeKey:=this.channelTypeKey, _
        hprPlacement:=this.hprPlacement, _
        cuttingType:=this.cuttingType, _
        pieceType:=this.pieceType, _
        length:=this.length, _
        placed:=this.placed, _
        usedTolerance:=this.usedTolerance, _
        allowedTolerance:=this.allowedTolerance
End Function

Public Sub setValues( _
    ByVal channelTypeKey As String, _
    ByVal hprPlacement As enumHPRPlacement, _
    ByVal cuttingType As enumCuttingType, _
    ByVal pieceType As enumPieceType, _
    ByVal length As Long, _
    ByVal placed As Boolean, _
    ByVal usedTolerance As Long, _
    ByVal allowedTolerance As Long _
)
    this.channelTypeKey = channelTypeKey
    this.hprPlacement = hprPlacement
    this.cuttingType = cuttingType
    this.pieceType = pieceType
    this.length = length
    this.placed = placed
    this.usedTolerance = usedTolerance
    this.allowedTolerance = allowedTolerance
End Sub

Public Property Get channelTypeKey() As String
    channelTypeKey = this.channelTypeKey
End Property
Public Property Get hprPlacement() As enumHPRPlacement
    hprPlacement = this.hprPlacement
End Property
Public Property Get cuttingType() As enumCuttingType
    cuttingType = this.cuttingType
End Property
Public Property Get pieceType() As enumPieceType
    pieceType = this.pieceType
End Property
Public Property Get length() As Long
    length = this.length
End Property
Public Property Get placed() As Boolean
    placed = this.placed
End Property
Public Property Get usedTolerance() As Long
    usedTolerance = this.usedTolerance
End Property
Public Property Get allowedTolerance() As Long
    allowedTolerance = this.allowedTolerance
End Property

Public Property Let length(ByVal value As Long)
    this.length = value
End Property
Public Property Let usedTolerance(ByVal value As Long)
    this.usedTolerance = value
End Property
Public Property Let placed(ByVal value As Boolean)
    this.placed = value
End Property
Public Property Let hprPlacement(ByVal value As enumHPRPlacement)
    this.hprPlacement = value
End Property
Public Property Let pieceType(ByVal value As enumPieceType)
    this.pieceType = value
End Property

' Rounded down
Public Property Get allowedToleranceRoundedDown() As Long
    allowedToleranceRoundedDown = round10down(this.allowedTolerance)
End Property


Public Function isEqualTo(ByVal pieceToCheck As CPiece) As Boolean
    isEqualTo = False
    If _
        this.length = pieceToCheck.length And _
        this.hprPlacement = pieceToCheck.hprPlacement And _
        this.cuttingType = pieceToCheck.cuttingType And _
        this.pieceType = pieceToCheck.pieceType And _
        this.placed = pieceToCheck.placed And _
        this.allowedTolerance = pieceToCheck.allowedTolerance And _
        this.usedTolerance = pieceToCheck.usedTolerance And _
        this.channelTypeKey = pieceToCheck.channelTypeKey _
    Then
        isEqualTo = True
    End If
End Function


Public Function hasSameFundamentals(ByVal pieceToCheck As CPiece) As Boolean
    hasSameFundamentals = False
    If _
        this.length = pieceToCheck.length And _
        this.hprPlacement = pieceToCheck.hprPlacement And _
        this.cuttingType = pieceToCheck.cuttingType And _
        this.pieceType = pieceToCheck.pieceType And _
        this.allowedTolerance = pieceToCheck.allowedTolerance And _
        this.usedTolerance = pieceToCheck.usedTolerance And _
        this.channelTypeKey = pieceToCheck.channelTypeKey _
    Then
        hasSameFundamentals = True
    End If
End Function
Attribute VB_Name = "CRequest"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CRequest class

Private Type TRequest
    allBinSets() As CBinSet                 ' One set of CBins per channelType
    itemSets() As CItemSet                  ' One set of CItems per channelType
    itemSetCount As Long                    '
    chTypeCount As Long                     ' Counts the number of channeltypes, will correspond to the number of AllBinSets as well as itemSets
    channelTypeSet As CChannelTypeSet
    requestSheet As CRequestSheet
    channelTypeSheet As CChannelTypeSheet
    outputSheets As COutputSheets
    diagrams As CDiagram
    validators As CRequestValidators
    toleranceMode As enumToleranceMode     ' Tolerance mode, either normal or toleranceFree determined by the types in the request, used for validating requests
End Type

Private this As TRequest

Public Property Get validators() As CRequestValidators
    If IsObject(this.validators) Then
        Set validators = this.validators
    Else
        '@Ignore ObjectVariableNotSet
        validators = this.validators
    End If
End Property

Public Property Get diagrams() As CDiagram
    If IsObject(this.diagrams) Then
        Set diagrams = this.diagrams
    Else
        '@Ignore ObjectVariableNotSet
        diagrams = this.diagrams
    End If
End Property

Public Property Get outputSheets() As COutputSheets
    If IsObject(this.outputSheets) Then
        Set outputSheets = this.outputSheets
    Else
        '@Ignore ObjectVariableNotSet
        outputSheets = this.outputSheets
    End If
End Property

Public Property Get channelTypeSheet() As CChannelTypeSheet
    If IsObject(this.channelTypeSheet) Then
        Set channelTypeSheet = this.channelTypeSheet
    Else
        '@Ignore ObjectVariableNotSet
        channelTypeSheet = this.channelTypeSheet
    End If
End Property

Public Property Get requestSheet() As CRequestSheet
    If IsObject(this.requestSheet) Then
        Set requestSheet = this.requestSheet
    Else
        '@Ignore ObjectVariableNotSet
        requestSheet = this.requestSheet
    End If
End Property

Public Property Get channelTypeSet() As CChannelTypeSet
    If IsObject(this.channelTypeSet) Then
        Set channelTypeSet = this.channelTypeSet
    Else
        '@Ignore ObjectVariableNotSet
        channelTypeSet = this.channelTypeSet
    End If
End Property


Private Sub class_initialize()
    ' Initiate
    'Set this.allBinSets = New CBinSet()
    'Set this.itemSets = New CItemSet()
    Set this.channelTypeSet = New CChannelTypeSet
    Set this.requestSheet = New CRequestSheet
    Set this.channelTypeSheet = New CChannelTypeSheet
    Set this.outputSheets = New COutputSheets
    Set this.diagrams = New CDiagram
    Set this.validators = New CRequestValidators
    this.toleranceMode = enumToleranceMode.modeNotSet
    ' Clear the allBinSets and itemSets arrays
    clearVariables
End Sub


Public Sub clearVariables()
    this.chTypeCount = 0
    this.itemSetCount = 0
    ReDim this.allBinSets(1 To 1)
    ReDim this.itemSets(1 To 1)
End Sub


' Getters and setters

Public Property Get getSolutions() As CBinSet()
    '@Ignore ObjectVariableNotSet
    getSolutions = this.allBinSets
End Property

Public Property Get getItemSets() As CItemSet()
    '@Ignore ObjectVariableNotSet
    getItemSets = this.itemSets
End Property

Public Property Get chTypeCount() As Long
    chTypeCount = this.chTypeCount
End Property

Public Property Get getToleranceMode() As enumToleranceMode
    getToleranceMode = this.toleranceMode
End Property

Public Property Let setToleranceMode(ByVal newMode As enumToleranceMode)
    this.toleranceMode = newMode
End Property

Public Sub readRequestSheet()
    this.requestSheet.read _
        binSets:=this.allBinSets, _
        items:=this.itemSets, _
        chTypeCount:=this.chTypeCount, _
        itemSetCount:=this.itemSetCount
End Sub

' Optimizes the cutting of the request
Public Sub optimize(Optional ByRef pgForm As ProgressForm)
    ' Measure time taken
    Dim startTime As Single
    startTime = Timer
    
    Dim optimizationMode As String
    optimizationMode = "Quick sovler"
    If Settings.optimizationMode = enumOptimizationMode.limitedBruteForce Then
        optimizationMode = "Complex sovler"
    End If
    Logger.logInfoBoth "Optimizing using " & optimizationMode & "..."
    
    Dim profileNo As Long
    Dim binSetNo As Long
    Dim itemCount As Long
    Dim itemNo As Long
    Dim cutWidth As Long
    
    profileNo = 0
    itemCount = 0
    itemNo = 0
    pgForm.resetMainProgress 100
    pgForm.resetSubProgress 100

    If Settings.optimizationMode = enumOptimizationMode.bestFit Then
        ' Count total pices
        For binSetNo = 1 To chTypeCount
            For itemNo = 1 To this.itemSets(binSetNo).count
                ' TODO Enhancement: Dont create a copy here, instead make a property that returns a object reference
                itemCount = itemCount + this.itemSets(binSetNo).getItemCopy(itemNo).quantity
            Next
        Next
        
        ' Reset progress bar
        pgForm.showMainProgressBar vbNullString
        pgForm.resetMainProgress itemCount
    ElseIf Settings.optimizationMode = limitedBruteForce _
        Or Settings.optimizationMode = fullBruteForce _
    Then
        ' Reset progress bar
        pgForm.resetMainProgress chTypeCount
        pgForm.showMainProgressBar vbNullString
    End If

    ' Set cutwidth depending on tolerance mode (for disabled tolerance cutwidth = 0)
    cutWidth = Settings.maximumCuttingWidth
    If Settings.toleranceDisabled Then
        cutWidth = 0
    End If

    ' Optimize channel type individually
    For binSetNo = 1 To chTypeCount
        If Settings.optimizationMode = enumOptimizationMode.limitedBruteForce _
            Or Settings.optimizationMode = enumOptimizationMode.fullBruteForce _
        Then
            ' TODO Can owerflow if totalnumber of channels is zero
            pgForm.nextStepMain this.allBinSets(binSetNo).channelTypeKey & " - Channel "
        End If
        ' Calculate numbers needed to fill
        ' Find optimal placement
        this.allBinSets(binSetNo).placeItems _
            items:=this.itemSets(binSetNo), _
            cutWidth:=cutWidth, _
            pgForm:=pgForm
        this.allBinSets(binSetNo).postOptimization
        this.allBinSets(binSetNo).markUniqueProfiles
        profileNo = this.allBinSets(binSetNo).assignProfileNumbers(profileNo:=profileNo)
        'Logger.logInfoBoth binSetNo & ": Waste rate: " & this.allBinSets(binSetNo).getWaste
    Next
    
    'Logger.logInfoBoth "Waste rate: " & getTotalWasteRate & "%"

    ' End update
    pgForm.finnishMain

    ' Report time
    Logger.logInfoBoth "done."
    Logger.logInfoBoth "Time " & Round(Timer - startTime, 2) & "s"
    
    ' Hide progressbar
    pgForm.hideMainProgressBar
    If Settings.optimizationMode = enumOptimizationMode.limitedBruteForce _
        Or Settings.optimizationMode = enumOptimizationMode.fullBruteForce _
    Then
        pgForm.hideSubProgressBar
    End If
End Sub


' Checks if items contains an empty set
Public Function isEmpty() As Boolean
    this.itemSetCount = UBound(this.itemSets) - LBound(this.itemSets) + 1
    If this.itemSetCount = 1 Then
        ' As the array is always initialized to 1 whether it is used or not we have to check this specifically
        isEmpty = this.itemSets(1) Is Nothing
    ElseIf this.itemSetCount > 1 Then
        isEmpty = False
    Else
        isEmpty = True
    End If
End Function

Public Sub addItemSet(ByVal itemSet As CItemSet)
    this.itemSetCount = this.itemSetCount + 1
    ReDim this.itemSets(1 To this.itemSetCount)
    '@Ignore ObjectVariableNotSet
    Set this.itemSets(this.itemSetCount) = itemSet
End Sub

Public Sub addBinSet(ByVal binSet As CBinSet)
    this.chTypeCount = this.chTypeCount + 1
    ReDim this.allBinSets(1 To this.chTypeCount)
    '@Ignore ObjectVariableNotSet
    Set this.allBinSets(this.chTypeCount) = binSet
End Sub

' Returns the index of the given channelTypeKey (returns 1 on if not found)
Public Function getIndexNo(ByVal chTypeKeyTest As String) As Long
    getIndexNo = 1
    For getIndexNo = 1 To chTypeCount
        If this.allBinSets(getIndexNo).channelTypeKey = chTypeKeyTest Then
            Exit For
        End If
    Next
End Function

' Returns the capacity of the largest bin
Public Function getMaxCapacity() As Long
    Logger.logFunctionCall 1, "Running getMaxCapacity()"
    getMaxCapacity = 0
    Dim binSetNo As Long
    For binSetNo = 1 To chTypeCount
        If this.allBinSets(binSetNo).capacity > getMaxCapacity Then
            getMaxCapacity = this.allBinSets(binSetNo).capacity
        End If
    Next
End Function

Public Sub readChannelTypesSheets()
    Logger.logFunctionCall 1, "Running readChannelTypesSheets()"

    Set this.channelTypeSet = New CChannelTypeSet
    Set this.channelTypeSheet = New CChannelTypeSheet

    this.channelTypeSheet.readTechnicalData channelTypeSet:=this.channelTypeSet
    this.channelTypeSheet.readVariants channelTypeSet:=this.channelTypeSet
    this.channelTypeSet.generateCutPositionsForAll
End Sub


Public Sub writeOutputs()
    Logger.logFunctionCall 1, "Running writeOutputs()"
    outputSheets.writeOutputListsSheet _
        this.allBinSets, _
        this.channelTypeSet, _
        this.chTypeCount
    outputSheets.writeCuttingPatternSheet _
        this.allBinSets, _
        this.channelTypeSet, _
        this.chTypeCount
End Sub


' Returns the total wasterate for the request
Public Function getTotalWasteRate() As Double
    Dim binSetNo As Long
    Dim totalWaste As Long
    Dim totalLength As Long
    binSetNo = 0
    
    For binSetNo = 1 To Request.chTypeCount
        totalWaste = totalWaste + this.allBinSets(binSetNo).getWaste
        totalLength = totalLength + this.allBinSets(binSetNo).getTotalCapacity
    Next
    
    If CDbl(totalLength) > 0 Then
        getTotalWasteRate = 100 * (CDbl(totalWaste) / CDbl(totalLength))
    Else
        getTotalWasteRate = 0
    End If
End Function
Attribute VB_Name = "CRequestSheet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit

' Clears the request
Public Sub clearSheet()
    ' Clear old values, everything in each column
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_TYPE
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_SIZE
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_EXTRA
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_MATERIAL_COATING
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_LENGTH
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_QUANTITY
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_CUTTING_TYPE
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_DEVIATING_TOLERANCE
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_STD_TOLERANCE
    clearRow SheetRequest, Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_ERROR
End Sub


' This function reads the request and loads the data in the AllBinSets array
' Assumes the sheet has already been sorted
Public Sub read( _
    ByRef binSets() As CBinSet, _
    ByRef items() As CItemSet, _
    ByRef chTypeCount As Long, _
    ByRef itemSetCount As Long _
)
    ' Measure time taken
    Dim startTime As Single
    startTime = Timer
    Logger.logInfoBoth "Loading items..."

    Dim itemNo As Long
    Dim lastRow As Long
    Dim sheetItemCount As Long
    
    Dim sheetItemType As Variant
    Dim sheetItemSize As Variant
    Dim sheetItemExtra As Variant
    Dim sheetItemMaterialCoating As Variant
    Dim sheetItemLength As Variant
    Dim sheetItemQuantity As Variant
    Dim sheetItemCuttingType As Variant
    Dim sheetItemDeviatingTolerance As Variant
    Dim sheetItemDeviatingMinimumRemainingWebWidth As Variant

    Dim ctype As String
    Dim size As String
    Dim extraString As String
    Dim materialCoating As String
    
    Dim item As CItem
    Dim length As Long
    Dim lengthLong As Long
    Dim deviatingToleranceLong As Long
    Dim deviatingToleranceString As String
    Dim tolerance As Long
    Dim deviatingMinimumRemainingWebWidth As Long
    Dim deviatingMinimumRemainingWebWidthString As String
    Dim deviatingMinimumRemainingWebWidthSet As Boolean
    Dim quantity As Long
    '@Ignore UseMeaningfulName
    Dim cuttingType As enumCuttingType
    Dim cuttingTypeString As String
    Dim channelTypeKey As String
    
    Dim lastChType As String
    
    tolerance = 0
    deviatingMinimumRemainingWebWidth = 0
    deviatingMinimumRemainingWebWidthSet = False
    quantity = 0
    cuttingType = enumCuttingType.A
    channelTypeKey = vbNullString
    
    lastChType = vbNullString
    
    ReDim binSets(1 To 1)
    ReDim items(1 To 1)
    
    ' Clear the AllBinSets and itemSets arrays
    'clearVariables
    
    With SheetRequest
        
        ' Sort the sheet
        'sort
        
        ' Find last row, so we can calculate how many items the request contains
        ' Use the Type column as reference
        lastRow = .Range(Globals.REQUEST_COL_TYPE & .Rows.count).End(xlUp).Row
        sheetItemCount = lastRow - (Globals.REQUEST_ROW_FIRST - 1)
        
        ' Read order, loads the contents of the respective columns into variant variables
        sheetItemType = .Range( _
            Globals.REQUEST_COL_TYPE & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_TYPE & lastRow).value
        sheetItemSize = .Range( _
            Globals.REQUEST_COL_SIZE & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_SIZE & lastRow).value
        sheetItemExtra = .Range( _
            Globals.REQUEST_COL_EXTRA & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_EXTRA & lastRow).value
        sheetItemMaterialCoating = .Range( _
            Globals.REQUEST_COL_MATERIAL_COATING & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_MATERIAL_COATING & lastRow).value
        sheetItemLength = .Range( _
            Globals.REQUEST_COL_LENGTH & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_LENGTH & lastRow).value
        sheetItemQuantity = .Range( _
            Globals.REQUEST_COL_QUANTITY & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_QUANTITY & lastRow).value
        sheetItemCuttingType = .Range( _
            Globals.REQUEST_COL_CUTTING_TYPE & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_CUTTING_TYPE & lastRow).value
        sheetItemDeviatingTolerance = .Range( _
            Globals.REQUEST_COL_DEVIATING_TOLERANCE & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_DEVIATING_TOLERANCE & lastRow).value
        sheetItemDeviatingMinimumRemainingWebWidth = .Range( _
            Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & lastRow).value

        Logger.logInfo _
            "channelTypeKey" & vbTab & _
            "cuttingType" & vbTab & vbTab & _
            "length" & vbTab & _
            "quantity" & vbTab & _
            "tolerance"

        ' Loop through every item in the request and interpret the data:
        For itemNo = 1 To sheetItemCount
            
            ' Create a new CItemSet for each channel type
            ctype = rangeGetString(sheetItemType, itemNo)
            size = rangeGetString(sheetItemSize, itemNo)
            extraString = rangeGetString(sheetItemExtra, itemNo)
            materialCoating = rangeGetString(sheetItemMaterialCoating, itemNo)
            
            channelTypeKey = buildChTypeKey(ctype, size, extraString, materialCoating)
            ' We rely data sorted by channel type, thus when the channel type changes we add a new channel type
            If Not channelTypeKey = lastChType Then
                chTypeCount = chTypeCount + 1
                itemSetCount = itemSetCount + 1
                ReDim Preserve items(1 To chTypeCount)
                ReDim Preserve binSets(1 To chTypeCount)
                '@Ignore ObjectVariableNotSet
                Set binSets(chTypeCount) = New CBinSet
                
                ' Set capacity to the largest variant of the specified type
                binSets(chTypeCount).setValues _
                    length:=Request.channelTypeSet.getMaxLength(channelTypeKey), _
                    capacity:=Request.channelTypeSet.getMaxCapacity(channelTypeKey), _
                    capacityCuttable:=Request.channelTypeSet.getMaxUsableLength(channelTypeKey), _
                    channelTypeKey:=channelTypeKey
                
                'Logger.logInfo "capacity of new bin: " & binSets(chTypeCount).capacity
                
                '@Ignore ObjectVariableNotSet
                Set items(chTypeCount) = New CItemSet
                items(chTypeCount).channelTypeKey = channelTypeKey
            End If
            
            ' This line converts the length to a Long
            lengthLong = rangeGetLong(sheetItemLength, itemNo)
            ' Use 1/10 mm internally
            length = toBaseUnit(lengthLong)
            
            cuttingTypeString = rangeGetString(sheetItemCuttingType, itemNo)
            
            ' cuttingType B1,B2 or C1,C2
            If cuttingTypeString = "B1" Or cuttingTypeString = "B2" Or cuttingTypeString = "C1" Or cuttingTypeString = "C2" Then
            
                deviatingToleranceString = rangeGetString(sheetItemDeviatingTolerance, itemNo)
                
                ' If there is a user tolerance override, use that
                If deviatingToleranceString <> vbNullString _
                And IsNumeric(deviatingToleranceString) Then
                    deviatingToleranceLong = rangeGetLong(sheetItemDeviatingTolerance, itemNo)
                    tolerance = toBaseUnit(deviatingToleranceLong)
                Else
                    ' Set the tolerance to the tolerance of the channel
                    Dim thisChannelType As CChannelType
                    Set thisChannelType = Request.channelTypeSet.getChTypeFromKey(channelTypeKey)
            
                    tolerance = thisChannelType.getHiltiStdTolerance(length)
                End If
                
                deviatingMinimumRemainingWebWidthString = rangeGetString(sheetItemDeviatingMinimumRemainingWebWidth, itemNo)
            
                If deviatingMinimumRemainingWebWidthString <> vbNullString _
                And IsNumeric(deviatingMinimumRemainingWebWidthString) Then
                    '@Ignore AssignmentNotUsed
                    deviatingMinimumRemainingWebWidth = rangeGetLong(sheetItemDeviatingMinimumRemainingWebWidth, itemNo)
                    ' Convert to base unit
                    deviatingMinimumRemainingWebWidth = toBaseUnit(deviatingMinimumRemainingWebWidth)
                    deviatingMinimumRemainingWebWidthSet = True
                End If
            ' cuttingType = A
            Else
                ' If cuttingType is A we use the default tolerance
                tolerance = Settings.defaultTolerance
            End If

            quantity = rangeGetLong(sheetItemQuantity, itemNo)
            cuttingType = stringToCuttingType(cuttingTypeString)
            
            Logger.logInfo _
                channelTypeKey & vbTab & vbTab & _
                cuttingType & vbTab & vbTab & _
                length & vbTab & _
                quantity & vbTab & vbTab & vbTab & _
                tolerance
            
            Set item = New CItem
            item.setValues _
                length:=length, _
                tolerance:=tolerance, _
                deviatingMinimumRemainingWebWidth:=deviatingMinimumRemainingWebWidth, _
                deviatingMinimumRemainingWebWidthSet:=deviatingMinimumRemainingWebWidthSet, _
                quantity:=quantity, _
                cuttingType:=cuttingType, _
                channelTypeKey:=channelTypeKey

            items(chTypeCount).addItem item
            lastChType = channelTypeKey
        Next
    End With

    ' Report time
    Logger.logInfoBoth "done."
    Logger.logInfoBoth "Time " & Round(Timer - startTime, 2) & "s"
End Sub


Public Sub sort()
    Dim appProxy As IApplication
    Dim lastRow As Long
    
    Set appProxy = New ApplicationProxy
    
    With SheetRequest
        ' Find last row, so we can calculate how many items the request contains
        ' Use the Type column as reference
        lastRow = .Range(Globals.REQUEST_COL_TYPE & .Rows.count).End(xlUp).Row
        .sort.SortFields.clear
        .sort.SortFields.Add _
            Key:=.Range( _
                Globals.REQUEST_COL_TYPE & Globals.REQUEST_ROW_FIRST & ":" & _
                Globals.REQUEST_COL_TYPE & lastRow), _
            SortOn:=xlSortOnValues, _
            Order:=xlAscending, _
            DataOption:=xlSortNormal
        .sort.SortFields.Add _
            Key:=.Range( _
                Globals.REQUEST_COL_SIZE & Globals.REQUEST_ROW_FIRST & ":" & _
                Globals.REQUEST_COL_SIZE & lastRow), _
            SortOn:=xlSortOnValues, _
            Order:=xlAscending, _
            DataOption:=xlSortNormal
        .sort.SortFields.Add _
            Key:=.Range( _
                Globals.REQUEST_COL_EXTRA & Globals.REQUEST_ROW_FIRST & ":" & _
                Globals.REQUEST_COL_EXTRA & lastRow), _
            SortOn:=xlSortOnValues, _
            Order:=xlAscending, _
            DataOption:=xlSortNormal
        .sort.SortFields.Add _
            Key:=.Range( _
                Globals.REQUEST_COL_MATERIAL_COATING & Globals.REQUEST_ROW_FIRST & ":" & _
                Globals.REQUEST_COL_MATERIAL_COATING & lastRow), _
             SortOn:=xlSortOnValues, _
            Order:=xlAscending, _
            DataOption:=xlSortNormal
        .sort.SortFields.Add _
            Key:=.Range( _
                Globals.REQUEST_COL_CUTTING_TYPE & Globals.REQUEST_ROW_FIRST & ":" & _
                Globals.REQUEST_COL_CUTTING_TYPE & lastRow), _
            SortOn:=xlSortOnValues, _
            Order:=xlAscending, _
            DataOption:=xlSortNormal
        .sort.SortFields.Add _
            Key:=.Range( _
                Globals.REQUEST_COL_LENGTH & Globals.REQUEST_ROW_FIRST & ":" & _
                Globals.REQUEST_COL_LENGTH & lastRow), _
            SortOn:=xlSortOnValues, _
            Order:=xlDescending, _
            DataOption:=xlSortNormal
        .sort.SetRange .Range( _
            Globals.REQUEST_COL_TYPE & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & lastRow _
        )
        .sort.Header = xlNo
        .sort.MatchCase = True
        .sort.Orientation = xlTopToBottom
        .sort.SortMethod = xlPinYin
        .sort.Apply
    End With

    ' Make sure the data is updated
    ' TODO Enhancement: Delete these lines and make the request reader read what the user supplied and not what is on the line.
    appProxy.enableAfterRunning
    appProxy.disableWhileRunning
End Sub


' Generates a random request
Public Sub generateRandom()

    ' TODO: Add support for shortest length
    ' TODO: Fix length generation
    ' TODO: Add support for Disabled tolerance (while generating)

    ' Measure time taken
    Dim startTime As Single
    startTime = Timer
    Logger.logInfoBoth "Generating random request..."

    Dim lineNo As Long
    Dim randomTypeNo As Long
    Dim chtype As String
    Dim size As String
    Dim extra As String
    Dim materialCoating As String
    Dim maxLength As Long
    Dim quantity As Long
    Dim length As Long
    Dim cuttingType As enumCuttingType
    Dim cuttingTypeString As String
    Dim deviatingTolerance As String
    Dim numberOfRequestLines As Long
    Dim customerToleranceIsSet As Long
    Dim randomChannelType As CChannelType

    Dim cutAreaNumber As Long
    Dim minLengthHPR As Long
    Dim maxLengthHPR As Long
    
    Dim number_of_same_channel As Long
    number_of_same_channel = 0
    
    ' Settings
    Const MIN_LENGTH As Long = 100
    Const MIN_REQUEST_LINES As Long = 20
    Const MAX_REQUEST_LINES As Long = 20
    Const MIN_QUANTITY As Long = 4
    Const MAX_QUANTITY As Long = 100
    Const CUTTING_TYPES_COUNT As Long = 5
    Const MIN_CUSTOMER_TOLERANCE As Long = 0
    Const MAX_CUSTOMER_TOLERANCE As Long = 5
    Const MIN_OF_SAME_CHANNEL_TYPE As Long = 10
    Const MAX_LENGTH_FACTOR As Long = 4

    cuttingTypeString = vbNullString
    
    With SheetRequest
        numberOfRequestLines = getRandomNumber( _
            lb:=MIN_REQUEST_LINES, _
            ub:=MAX_REQUEST_LINES)
        If Request.channelTypeSet.count > 0 Then

            For lineNo = 1 To numberOfRequestLines

                ' Easy ones
                quantity = getRandomNumber( _
                    lb:=MIN_QUANTITY, _
                    ub:=MAX_QUANTITY)
                customerToleranceIsSet = getRandomNumber(0, 1)
                If customerToleranceIsSet = 1 Then
                    deviatingTolerance = getRandomNumber( _
                        lb:=MIN_CUSTOMER_TOLERANCE, _
                        ub:=MAX_CUSTOMER_TOLERANCE)
                Else
                    deviatingTolerance = vbNullString
                End If
                
                ' Generate a random channel type:
                ' Make sure that at least MIN_OF_SAME_CHANNEL_TYPE are generated as the first type.
                ' This is done in order to better excercice optimization as the optimization is always done per channel type.
                If number_of_same_channel = 0 Then
                    ' number_of_same_channel = 0 means that no channel has been generated
                    ' Always generate a random one for the first line
                    number_of_same_channel = number_of_same_channel + 1
                    randomTypeNo = getRandomNumber( _
                        lb:=1, _
                        ub:=Request.channelTypeSet.count)
                ElseIf number_of_same_channel < MIN_OF_SAME_CHANNEL_TYPE Then
                    ' We have not yet generated enough channels
                    number_of_same_channel = number_of_same_channel + 1
                Else
                    ' Normal operation, generate a new random channel with each loop
                    randomTypeNo = getRandomNumber( _
                        lb:=1, _
                        ub:=Request.channelTypeSet.count)
                End If
                Set randomChannelType = Request.channelTypeSet.getChType(randomTypeNo)
                
                chtype = randomChannelType.ctype
                size = randomChannelType.size
                extra = randomChannelType.extra
                materialCoating = randomChannelType.material
                
                ' length is the upper bound used for non cuttingType=C1,C2 channels (encourage smaller sizes for better testing by dividing by a factor)
                maxLength = toDisplayUnit(randomChannelType.getMaxUsableLength) / MAX_LENGTH_FACTOR
                length = getRandomNumber( _
                    lb:=randomChannelType.minimumItemLength, _
                    ub:=maxLength)
                
                If randomChannelType.HPRenabled Then
                    Select Case getRandomNumber(lb:=0, ub:=CUTTING_TYPES_COUNT - 1)
                        Case 0
                            cuttingType = enumCuttingType.A
                        Case 1
                            cuttingType = enumCuttingType.B1
                        Case 2
                            cuttingType = enumCuttingType.B2
                        Case 3
                            cuttingType = enumCuttingType.C1
                        Case 4
                            cuttingType = enumCuttingType.c2
                    End Select
                Else
                    cuttingType = enumCuttingType.A
                End If
                cuttingTypeString = cuttingTypeToString(cuttingType)
                'Debug.Print cuttingTypeString

                If cuttingType = enumCuttingType.C1 Or cuttingType = enumCuttingType.c2 Then
                    ' Generate a random cut area and to get a random range
                    ' This is right for MQ, TODO: fix for the others
                    cutAreaNumber = getRandomNumber( _
                        lb:=2, _
                        ub:=randomChannelType.rightCutsMax _
                    )

                    ' TODO: For tolerance disabled, dont take the cutting width into account
                    'If Settings.toleranceDisabled Then
                        maxLengthHPR = _
                            randomChannelType.getRightCutMax(cutAreaNumber) _
                            - randomChannelType.getLeftCutMin(1)
                    'Else
                    '    maxLengthHPR = (randomChannelType.getCutMaxRight(cutAreaNumber) _
                    '                    - randomChannelType.getCutMinLeft(1)) _
                    '                    - Settings.maximumCuttingWidth
                    'End If
                    minLengthHPR = _
                        randomChannelType.getRightCutMin(cutAreaNumber) _
                        - randomChannelType.getLeftCutMax(1)
                    length = toDisplayUnit(getRandomNumber( _
                        lb:=minLengthHPR, _
                        ub:=maxLengthHPR) _
                    )
                    
                    Logger.logInfoBoth _
                        "cutAreaNumber=" & cutAreaNumber & vbTab & _
                        "maxLengthHPR=" & maxLengthHPR & vbTab & _
                        "minLengthHPR=" & minLengthHPR & vbTab & _
                        "length=" & length
                End If
                
                ' Fill out the line in the form
                .Range( _
                    Globals.REQUEST_COL_TYPE & _
                        lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = chtype
                .Range( _
                    Globals.REQUEST_COL_SIZE & _
                    lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = size
                .Range( _
                    Globals.REQUEST_COL_EXTRA & _
                    lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = extra
                .Range( _
                    Globals.REQUEST_COL_MATERIAL_COATING & _
                    lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = materialCoating
                .Range( _
                    Globals.REQUEST_COL_QUANTITY & _
                    lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = quantity
                .Range( _
                    Globals.REQUEST_COL_LENGTH & _
                    lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = length
                .Range( _
                    Globals.REQUEST_COL_CUTTING_TYPE & _
                    lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = cuttingTypeString
                .Range( _
                    Globals.REQUEST_COL_DEVIATING_TOLERANCE & _
                    lineNo + (Globals.REQUEST_ROW_FIRST - 1) _
                ).value = deviatingTolerance
            Next
        Else
            MsgBox Translate("error_you_need_at_least_one_channel_type_enabled")
        End If
    End With
    
    ' Report time
    Logger.logInfoBoth "done."
    Logger.logInfoBoth "Time " & Round(Timer - startTime, 2) & "s"
End Sub


Private Function buildChTypeKey( _
    ByVal ctype As String, _
    ByVal size As String, _
    ByVal extra As String, _
    ByVal materialCoating As String _
) As String
    buildChTypeKey = vbNullString
    If Not ctype = vbNullString And Not size = vbNullString Then
        buildChTypeKey = ctype & "-" & size
        If Not extra = vbNullString Then
            buildChTypeKey = buildChTypeKey & "+" & extra
        End If
        If Not materialCoating = vbNullString Then
            buildChTypeKey = buildChTypeKey & "-" & materialCoating
        End If
    End If
End Function








Attribute VB_Name = "CRequestValidators"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CRequestValidators class

Public Sub applyVaildators()
    
    ' Read channel variants and apply the fullest set of available type, size, extra, material
    If checkChannelTypes_all Then
        Request.readChannelTypesSheets
        Request.channelTypeSet.generateValidationStrings
        
        'NOUS START: REMOVING ALL THE VALIDATIONS DELETE AND REAPPLY CODES
        ' Delete all previous validations
        'SheetRequest.Cells.Validation.Delete
        
        'requestApplyGeneralDataValidation _
            Request.channelTypeSet.uniqueType, _
            Request.channelTypeSet.uniqueSize, _
            Request.channelTypeSet.uniqueExtra, _
            Request.channelTypeSet.uniqueMaterialCoating
        'requestApplySpecificValidators _
            Request.channelTypeSet.uniqueType, _
            Request.channelTypeSet.uniqueSize, _
            Request.channelTypeSet.uniqueExtra, _
            Request.channelTypeSet.uniqueMaterialCoating
        'requestApplySpecialValidation
        'NOUS END:
    Else
        Logger.logInfoBoth "checkChannelTypes_all returned false, channel types are not read."
    End If
End Sub

' Applies validation to the input data fields on the Request sheet
' Sets the values of the dropdown boexes to any aviable data.
Public Sub requestApplyGeneralDataValidation( _
    ByVal uniqueType As String, _
    ByVal uniqueSize As String, _
    ByVal uniqueExtra As String, _
    ByVal uniqueMaterialCoating As String _
)
    Dim typeRange As Range
    Dim sizeRange As Range
    Dim extraRange As Range
    Dim materialCoatingRange As Range
    Dim nominalLengthRange As Range
    Dim quantityRange As Range
    Dim cuttingTypeRange As Range
    Dim deviatingToleranceRange As Range
    'Dim deviatingMinimumRemaingingWebRange As Range
    
    SheetRequest.Activate   ' TODO is this nessecary?
    
    With SheetRequest
        Set typeRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_TYPE), _
            .Cells(.Rows.count, Globals.REQUEST_COL_TYPE))
        Set sizeRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_SIZE), _
            .Cells(.Rows.count, Globals.REQUEST_COL_SIZE))
        Set extraRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_EXTRA), _
            .Cells(.Rows.count, Globals.REQUEST_COL_EXTRA))
        Set materialCoatingRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_MATERIAL_COATING), _
            .Cells(.Rows.count, Globals.REQUEST_COL_MATERIAL_COATING))
        Set nominalLengthRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_LENGTH), _
            .Cells(.Rows.count, Globals.REQUEST_COL_LENGTH))
        Set quantityRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_QUANTITY), _
            .Cells(.Rows.count, Globals.REQUEST_COL_QUANTITY))
        Set cuttingTypeRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_CUTTING_TYPE), _
            .Cells(.Rows.count, Globals.REQUEST_COL_CUTTING_TYPE))
        Set deviatingToleranceRange = .Range( _
            .Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_DEVIATING_TOLERANCE), _
            .Cells(.Rows.count, Globals.REQUEST_COL_DEVIATING_TOLERANCE))
        'Set deviatingMinimumRemaingingWebRange = .Range(.Cells(Globals.REQUEST_ROW_FIRST, Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH), _

        ' Add the validators that we need
        typeRange.Validation.Add _
            Type:=xlValidateList, _
            AlertStyle:=xlValidAlertStop, _
            Formula1:=uniqueType
        sizeRange.Validation.Add _
            Type:=xlValidateList, _
            AlertStyle:=xlValidAlertStop, _
            Formula1:=uniqueSize
        extraRange.Validation.Add _
            Type:=xlValidateList, _
            AlertStyle:=xlValidAlertStop, _
            Formula1:=uniqueExtra
        nominalLengthRange.Validation.Add _
            Type:=xlValidateWholeNumber, _
            AlertStyle:=xlValidAlertStop, _
            Operator:=xlGreater, _
            Formula1:=0
        quantityRange.Validation.Add _
            Type:=xlValidateWholeNumber, _
            AlertStyle:=xlValidAlertStop, _
            Operator:=xlGreater, _
            Formula1:=0
        deviatingToleranceRange.Validation.Add _
            Type:=xlValidateWholeNumber, _
            AlertStyle:=xlValidAlertStop, _
            Operator:=xlGreaterEqual, _
            Formula1:=0
        materialCoatingRange.Validation.Add _
            Type:=xlValidateList, _
            AlertStyle:=xlValidAlertStop, _
            Formula1:=uniqueMaterialCoating
        cuttingTypeRange.Validation.Add _
            Type:=xlValidateList, _
            AlertStyle:=xlValidAlertStop, _
            Formula1:="A,B1,B2,C1,C2"
    End With
End Sub

' Apply specific validations for rows that have cells that are used
Public Sub requestApplySpecificValidators( _
    ByVal uniqueType As String, _
    ByVal uniqueSize As String, _
    ByVal uniqueExtra As String, _
    ByVal uniqueMaterialCoating As String _
)
    Dim highestLastRow As Long
    Dim i As Long
    
    ' Look for the last used cell in the sheet
    highestLastRow = request_lastUsedCell
    
    For i = Globals.REQUEST_ROW_FIRST To highestLastRow
        requestApplySpecificValidatorsRow _
            rowNo:=i, _
            uniqueType:=uniqueType, _
            uniqueSize:=uniqueSize, _
            uniqueExtra:=uniqueExtra, _
            uniqueMaterialCoating:=uniqueMaterialCoating
    Next
End Sub

Public Sub requestApplySpecificValidatorsRow( _
    ByVal rowNo As Long, _
    ByVal uniqueType As String, _
    ByVal uniqueSize As String, _
    ByVal uniqueExtra As String, _
    ByVal uniqueMaterialCoating As String _
)
    Dim typeRange As Range
    Dim sizeRange As Range
    Dim extraRange As Range
    Dim materialCoatingRange As Range
    Dim cuttingTypeRange As Range

    Dim ctype As String
    Dim size As String
    Dim extra As String
    Dim material As String
    '@Ignore UseMeaningfulName
    Dim cuttingType As String

    Dim typeValidators As String
    Dim sizeValidators As String
    Dim extraValidators As String
    Dim materialValidators As String
    Dim cuttingTypeValidators As String
    
    'NOUS Start; exiting the validation list changes routine
    Exit Sub
    'NOUS End

    SheetRequest.Activate   ' TODO is this needed?

    ' Default validators
    typeValidators = uniqueType
    sizeValidators = uniqueSize
    extraValidators = uniqueExtra
    materialValidators = uniqueMaterialCoating
    cuttingTypeValidators = "A;B1;B2;C1;C2"

    With SheetRequest
    
        Set typeRange = .Cells(rowNo, Globals.REQUEST_COL_TYPE)
        Set sizeRange = .Cells(rowNo, Globals.REQUEST_COL_SIZE)
        Set extraRange = .Cells(rowNo, Globals.REQUEST_COL_EXTRA)
        Set materialCoatingRange = .Cells(rowNo, Globals.REQUEST_COL_MATERIAL_COATING)
        Set cuttingTypeRange = .Cells(rowNo, Globals.REQUEST_COL_CUTTING_TYPE)
        
        ' Read data strings
        ctype = typeRange.value
        size = sizeRange.value
        extra = extraRange.value
        material = materialCoatingRange.value
        cuttingType = cuttingTypeRange.value
        
        ' Delete previous validations
        typeRange.Validation.Delete
        sizeRange.Validation.Delete
        extraRange.Validation.Delete
        materialCoatingRange.Validation.Delete
        cuttingTypeRange.Validation.Delete
        
        ' Determine the new validations:
        
        ' For an empty row we keep the defualt validations
        ' Also if cuttingType = A since all types support this
        If _
            Not ctype = vbNullString _
            Or Not size = vbNullString _
            Or Not extra = vbNullString _
            Or Not material = vbNullString _
            Or Not cuttingType = vbNullString _
            Or Not cuttingType = "A" _
        Then
            ' Get list of validators for this specific set of specifiers
            typeValidators = Request.channelTypeSet.getSpecificValidatorsType( _
                size:=size, _
                extra:=extra, _
                material:=material, _
                cuttingType:=cuttingType)
            sizeValidators = Request.channelTypeSet.getSpecificValidatorsSize( _
                ctype:=ctype, _
                extra:=extra, _
                material:=material, _
                cuttingType:=cuttingType)
            extraValidators = Request.channelTypeSet.getSpecificValidatorsExtra( _
                ctype:=ctype, _
                size:=size, _
                material:=material, _
                cuttingType:=cuttingType)
            materialValidators = Request.channelTypeSet.getSpecificValidatorsMaterial( _
                ctype:=ctype, _
                size:=size, _
                extra:=extra, _
                cuttingType:=cuttingType)
            cuttingTypeValidators = Request.channelTypeSet.getSpecificValidatorsCuttingType( _
                ctype:=ctype, _
                size:=size, _
                extra:=extra, _
                material:=material)
        End If
        
        ' Apply validatators, only if non empty
        ' TODO Might have to change this so it is applied
        
        If Not typeValidators = vbNullString Then
            typeRange.Validation.Delete
            typeRange.Validation.Add _
                Type:=xlValidateList, _
                AlertStyle:=xlValidAlertStop, _
                Formula1:=typeValidators
        End If
        If Not sizeValidators = vbNullString Then
            sizeRange.Validation.Delete
            sizeRange.Validation.Add _
                Type:=xlValidateList, _
                AlertStyle:=xlValidAlertStop, _
                Formula1:=sizeValidators
        End If
        If Not extraValidators = vbNullString Then
            extraRange.Validation.Delete
            extraRange.Validation.Add _
                Type:=xlValidateList, _
                AlertStyle:=xlValidAlertStop, _
                Formula1:=extraValidators
        End If
        If Not materialValidators = vbNullString Then
            materialCoatingRange.Validation.Delete
            materialCoatingRange.Validation.Add _
                Type:=xlValidateList, _
                AlertStyle:=xlValidAlertStop, _
                Formula1:=materialValidators
        End If
        If Not cuttingTypeValidators = vbNullString Then
            cuttingTypeRange.Validation.Delete
            cuttingTypeRange.Validation.Add _
                Type:=xlValidateList, _
                AlertStyle:=xlValidAlertStop, _
                Formula1:=cuttingTypeValidators
        End If
    End With
End Sub


' Applies validation to the header field, specifically the Algorithm setting
Public Sub requestApplySpecialValidation()
    Dim optimizationModeRange As Range
    Set optimizationModeRange = SheetRequest.Range(Globals.REQUEST_OPTIMIZATION_MODE)

    ' Add the validators that we need
    optimizationModeRange.Validation.Add _
        Type:=xlValidateList, _
        AlertStyle:=xlValidAlertStop, _
        Formula1:=Globals.OPTIMIZATION_MODE_BEST_FIT & "," & Globals.OPTIMIZATION_MODE_LIMITED_BRUTE_FORCE
End Sub





Attribute VB_Name = "CSettings"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CSettings class

Private Type TSettings
    ' Settings - user changeable:
    maximumCuttingWidth As Long            ' in fundamental unit
    cutFreeSpaceEnd As Long                ' in fundamental unit
    defaultTolerance As Long               ' in fundamental unit
    Language As String
    materialCountry As String
    cuttingMethod As enumCuttingMethod
    conversionFactor As Long
    conversionFactorCurrentMeter As Long
    conversionFactorLongUnit As Long
    fundamentalUnit As String
    unit As String
    logging As Boolean
    optimizationMode As enumOptimizationMode
    toleranceDisabled As Boolean
    
    ' Settings - hardcoded:
    diagramShowCombinedDiagram As Boolean
    diagramHideCuts As Boolean
    diagramPatternInstedOfColor As Boolean
    inputValidationOnchange As Boolean
    showCosts As Boolean
    diagramLabelsMinSize As Long                ' The shortest lenth of a piece for which a data label is shown
    unitChangingTriggerEnabled As Boolean       ' Used to allow for changing the unit programatically without triggering the questionbox
    sheetTechnicalData As Worksheet
    sheetChannelTypes As Worksheet
    
    ' Proxys:
    ApplicationProxy As IApplication
    genericSheet As IGenericSheet
End Type

Private this As TSettings

Private Sub class_initialize()

    ' Initiate
    this.maximumCuttingWidth = 0
    this.cutFreeSpaceEnd = 0
    this.defaultTolerance = 0
    this.Language = vbNullString
    this.materialCountry = vbNullString
    this.cuttingMethod = enumCuttingMethod.Cutting
    this.conversionFactor = 1
    this.conversionFactorCurrentMeter = 1
    this.conversionFactorLongUnit = 1
    this.fundamentalUnit = vbNullString
    this.unit = vbNullString
    this.logging = False
    this.optimizationMode = enumOptimizationMode.bestFit
    this.toleranceDisabled = False

    ' Hardcoded Settings
    this.inputValidationOnchange = Globals.DEFAULT_INPUT_VALIDATION_ON_CHANGE
    this.showCosts = Globals.DEFAULT_SHOW_COSTS
    this.diagramShowCombinedDiagram = Globals.DEFAULT_DIAGRAM_SHOW_COMBINED_DIAGRAM
    this.diagramHideCuts = Globals.DEFAULT_DIAGRAM_HIDE_CUTS
    this.diagramPatternInstedOfColor = Globals.DEFAULT_DIAGRAM_PATTERN_INSTEAD_OF_COLOR
    this.diagramLabelsMinSize = Globals.DEFAULT_DIAGRAM_LABEL_MIN_SIZE
    this.unitChangingTriggerEnabled = True
    
    ' Proxys
    Set this.ApplicationProxy = New ApplicationProxy
    Set this.genericSheet = New GenericSheetProxy
End Sub


' Getters

Public Property Get maximumCuttingWidth() As Long
    maximumCuttingWidth = this.maximumCuttingWidth
End Property

Public Property Get cutFreeSpaceEnd() As Long
    cutFreeSpaceEnd = this.cutFreeSpaceEnd
End Property

Public Property Get defaultTolerance() As Long
    defaultTolerance = this.defaultTolerance
End Property

Public Property Get Language() As String
    Language = this.Language
End Property

Public Property Get materialCountry() As String
    materialCountry = this.materialCountry
End Property

Public Property Get cuttingMethod() As enumCuttingMethod
    cuttingMethod = this.cuttingMethod
End Property

Public Property Get conversionFactor() As Long
    conversionFactor = this.conversionFactor
End Property

Public Property Get conversionFactorCurrentMeter() As Long
    conversionFactorCurrentMeter = this.conversionFactorCurrentMeter
End Property

Public Property Get conversionFactorLongUnit() As Long
    conversionFactorLongUnit = this.conversionFactorLongUnit
End Property

Public Property Get fundamentalUnit() As String
    fundamentalUnit = this.fundamentalUnit
End Property

Public Property Get unit() As String
    unit = this.unit
End Property

Public Property Get diagramShowCombinedDiagram() As Boolean
    diagramShowCombinedDiagram = this.diagramShowCombinedDiagram
End Property

Public Property Get diagramHideCuts() As Boolean
    diagramHideCuts = this.diagramHideCuts
End Property

Public Property Get diagramPatternInstedOfColor() As Boolean
    diagramPatternInstedOfColor = this.diagramPatternInstedOfColor
End Property

Public Property Get inputValidationOnchange() As Boolean
    inputValidationOnchange = this.inputValidationOnchange
End Property

Public Property Get logging() As Boolean
    logging = this.logging
End Property

Public Property Get showCosts() As Boolean
    showCosts = this.showCosts
End Property

Public Property Get optimizationMode() As enumOptimizationMode
    optimizationMode = this.optimizationMode
End Property

Public Property Get diagramLabelsMinSize() As Long
    diagramLabelsMinSize = this.diagramLabelsMinSize
End Property

Public Property Get unitChangingTriggerEnabled() As Boolean
    unitChangingTriggerEnabled = this.unitChangingTriggerEnabled
End Property

Public Property Get sheetTechnicalData() As Worksheet
    Set sheetTechnicalData = this.sheetTechnicalData
End Property

Public Property Get sheetChannelTypes() As Worksheet
    Set sheetChannelTypes = this.sheetChannelTypes
End Property

Public Property Get toleranceDisabled() As Boolean
    toleranceDisabled = this.toleranceDisabled
End Property

' Setters

Public Property Let defaultTolerance(ByVal tolerance As Long)
    SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_DEFAULT_TOLERANCE).value = tolerance
    this.defaultTolerance = tolerance
End Property

Public Property Let Language(ByVal Lang As String)
    SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_LANGUAGE).value = Lang
    this.Language = Lang
End Property

Public Property Let materialCountry(ByVal country As String)
    SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_MATERIAL_COUNTRY).value = country
    this.materialCountry = country
End Property

Public Property Let cuttingMethod(ByVal value As enumCuttingMethod)
    this.cuttingMethod = value
End Property

Public Property Let conversionFactor(ByVal factor As Long)
    this.conversionFactor = factor
End Property

Public Property Let conversionFactorCurrentMeter(ByVal factor As Long)
    this.conversionFactorCurrentMeter = factor
End Property

Public Property Let conversionFactorLongUnit(ByVal factor As Long)
    this.conversionFactorLongUnit = factor
End Property

Public Property Let fundamentalUnit(ByVal value As String)
    SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_UNIT).value = value
    this.fundamentalUnit = value
End Property

Public Property Let unit(ByVal value As String)
    this.unit = value
End Property

Public Property Let diagramShowCombinedDiagram(ByVal show As Boolean)
    this.diagramShowCombinedDiagram = show
End Property

Public Property Let diagramHideCuts(ByVal value As Boolean)
    this.diagramHideCuts = value
End Property

Public Property Let diagramPatternInstedOfColor(ByVal value As Boolean)
    this.diagramPatternInstedOfColor = value
End Property

Public Property Let inputValidationOnchange(ByVal onChange As Boolean)
    this.inputValidationOnchange = onChange
End Property

Public Property Let logging(ByVal loggingOn As Boolean)
    If loggingOn Then
        SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_LOGGING).value = "On"
    Else
        SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_LOGGING).value = "Off"
    End If
    this.logging = loggingOn
End Property

Public Property Let showCosts(ByVal show As Boolean)
    this.showCosts = show
End Property

Public Property Let optimizationMode(ByVal mode As enumOptimizationMode)
    this.optimizationMode = mode
    ' Update the request sheet
    SheetRequest.Range(Globals.REQUEST_OPTIMIZATION_MODE).value = optimizationModeToString(mode)
End Property

Public Property Let diagramLabelsMinSize(ByVal size As Long)
    this.diagramLabelsMinSize = size
End Property

Public Property Let maximumCuttingWidth(ByVal width As Long)
    SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_MAXIMUM_CUTTING_WIDTH).value = width
    this.maximumCuttingWidth = width
End Property

Public Property Let cutFreeSpaceEnd(ByVal space As Long)
    SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_CUTFREE_SPACE_END).value = space
    this.cutFreeSpaceEnd = space
End Property

Public Property Let unitChangingTriggerEnabled(ByVal enabled As Boolean)
    this.unitChangingTriggerEnabled = enabled
End Property

Public Property Let sheetTechnicalData(ByRef Sheet As Worksheet)
    '@Ignore ObjectVariableNotSet
    sheetTechnicalData = Sheet
End Property

Public Property Let sheetChannelTypes(ByRef Sheet As Worksheet)
    '@Ignore ObjectVariableNotSet
    sheetChannelTypes = Sheet
End Property

Public Property Let toleranceDisabled(ByVal value As Boolean)
    this.toleranceDisabled = value
    If this.toleranceDisabled Then
        SheetRequest.Shapes("DisableToleranceCheckbox").ControlFormat.value = xlOn
    Else
        SheetRequest.Shapes("DisableToleranceCheckbox").ControlFormat.value = xlOff
    End If
    'Debug.Print "this.toleranceDisabled: " & this.toleranceDisabled
End Property

' Setting readers

Public Sub readMaximumCuttingWidth()
    this.maximumCuttingWidth = SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_MAXIMUM_CUTTING_WIDTH).value
End Sub

Public Sub readCutfreeSpaceEnd()
    this.cutFreeSpaceEnd = toBaseUnit(SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_CUTFREE_SPACE_END).value)
End Sub

Public Sub readDefaultTolerance()
    this.defaultTolerance = toBaseUnit(SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_DEFAULT_TOLERANCE).value)
End Sub

Public Sub readMaterialCountry()
    this.materialCountry = SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_MATERIAL_COUNTRY).value
    this.cuttingMethod = findCuttingMethod(this.materialCountry)
End Sub

Public Sub readLogging()
    Dim loggingString As String
    loggingString = SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_LOGGING).value
    this.logging = loggingString = "On"
End Sub

Public Sub readOptimizationMode()
    Dim optimizationModeString As String
    optimizationModeString = SheetRequest.Range(Globals.REQUEST_OPTIMIZATION_MODE).value
    this.optimizationMode = stringToOptimizationMode(optimizationModeString)
    'Debug.Print "optimizationModeString: " & optimizationModeString
    'Debug.Print "this.optimizationMode: " & this.optimizationMode
    'Debug.Print "optimizationModeToString(this.optimizationMode): " & optimizationModeToString(this.optimizationMode)
End Sub


' This function reads the countries sheet
Private Function findCuttingMethod(ByVal materialCountry As String) As enumCuttingMethod
    Dim countryNo As Long
    Dim lastRow As Long
    Dim sheetCountryCount As Long
    Dim sheetCountry As Variant
    Dim sheetCuttingMethod As Variant

    Dim country As String
    Dim cuttingMethod As String
    
    ' Default setting: cutting
    findCuttingMethod = enumCuttingMethod.Cutting
    
    With SheetCountries
        
        ' Find last row
        lastRow = .Range(Globals.COUNTRIES_COL_COUNTRY & .Rows.count).End(xlUp).Row
        sheetCountryCount = lastRow - (Globals.COUNTRIES_ROW_FIRST - 1)
                
        ' Loads the contents of the respective columns into variant variables
        sheetCountry = .Range( _
           Globals.COUNTRIES_COL_COUNTRY & _
           Globals.COUNTRIES_ROW_FIRST & _
           ":" & _
           Globals.COUNTRIES_COL_COUNTRY & _
           lastRow _
        ).value
        sheetCuttingMethod = .Range( _
            Globals.COUNTRIES_COL_CUTTING_METHOD & _
            Globals.COUNTRIES_ROW_FIRST & _
            ":" & _
            Globals.COUNTRIES_COL_CUTTING_METHOD & _
            lastRow _
        ).value

        ' Loop through every country in the countries sheet:
        For countryNo = 1 To sheetCountryCount
            
            ' Read strings
            country = rangeGetString(sheetCountry, countryNo)
            cuttingMethod = rangeGetString(sheetCuttingMethod, countryNo)
            
            ' Look for matching country to the country that has been set
            If country = materialCountry Then
                If cuttingMethod = "Cutting" Then
                    findCuttingMethod = enumCuttingMethod.Cutting
                ElseIf cuttingMethod = "Shearing" Then
                    findCuttingMethod = enumCuttingMethod.shearing
                End If
                Exit For
            End If
        Next
    End With
End Function


' Reads the language set the settings page and verifies that it is an existing language according to the languages defined on the translations page
' Returns true if language has been changed
Public Function readLanguageSetting() As Boolean
    Dim Lang As String
    Dim previousLanguage As String
    Dim i As Long
    readLanguageSetting = False
    previousLanguage = this.Language
    Lang = SheetSettings.Range( _
        Globals.SETTINGS_COL_VALUE & _
        Globals.SETTINGS_ROW_LANGUAGE _
    )
    If Translation Is Nothing Then
        Set Translation = New CTranslation
    End If
    If Not Translation.translationsHasBeenRead Then
        Translation.readTranslations
    End If
    ' Make sure the set language is valid
    For i = 1 To Translation.languageCount
        If Translation.GetLanguage(i) = Lang Then
            this.Language = Lang
            Exit For
        End If
    Next
    ' Set default language to English if it was not set to anything
    If this.Language = vbNullString Then
        Logger.logBug "BUG: Language not set, setting to default, English"
        this.Language = "English"
    End If
    If Not previousLanguage = this.Language Then
        ' Language has been set, report true
        readLanguageSetting = True
    End If
End Function


Public Sub readLanguage()
    Dim languageChanged As Boolean
    languageChanged = readLanguageSetting
    If languageChanged Then
        'Logger.logInfo "Language set to " & language & ", translating"
        Translation.translateEverything
    End If
End Sub


Public Sub readAll()
    Dim appProxy As IApplication
    Set appProxy = New ApplicationProxy
    
    readMaximumCuttingWidth
    readCutfreeSpaceEnd
    readDefaultTolerance
    readMaterialCountry
    ' ReadUnit needs to be run separately after Translations has been read as it has circular dependancy on the Translation object
    
    appProxy.disableWhileRunning
    readLanguage
    appProxy.enableAfterRunning
    
    readLogging
    readOptimizationMode
End Sub


Public Sub setDefaults()
    this.maximumCuttingWidth = Globals.DEFAULT_MAXIMUM_CUTTING_WIDTH
    this.cutFreeSpaceEnd = Globals.DEFAULT_CUT_FREE_SPACE_END
    this.defaultTolerance = Globals.DEFAULT_TOLERANCE
    ' TODO Enhancement: For completeness, set language/country to the first in the list instead of to hardcoded defaults which might not exist
    this.Language = Globals.DEFAULT_LANGUAGE
    this.materialCountry = Globals.DEFAULT_MATERIAL_COUNTRY
    
    this.cuttingMethod = enumCuttingMethod.Cutting
    this.conversionFactor = Globals.DEFAULT_CONVERSION_FACTOR
    this.conversionFactorCurrentMeter = Globals.DEFAULT_CONVERSION_FACTOR_CURRENT_METER
    this.conversionFactorLongUnit = Globals.DEFAULT_CONVERSION_FACTOR_LONG_UNIT
    this.fundamentalUnit = Globals.DEFAULT_FUNDAMENTAL_UNIT
    this.unit = Globals.DEFAULT_UNIT
    this.logging = Globals.DEFAULT_LOGGING
    this.optimizationMode = enumOptimizationMode.bestFit

    this.diagramShowCombinedDiagram = Globals.DEFAULT_SHOW_COSTS
    this.diagramHideCuts = Globals.DEFAULT_DIAGRAM_HIDE_CUTS
    this.diagramPatternInstedOfColor = Globals.DEFAULT_DIAGRAM_PATTERN_INSTEAD_OF_COLOR
    this.inputValidationOnchange = Globals.DEFAULT_INPUT_VALIDATION_ON_CHANGE
    this.showCosts = Globals.DEFAULT_SHOW_COSTS
    this.diagramLabelsMinSize = Globals.DEFAULT_DIAGRAM_LABEL_MIN_SIZE
    
    If Globals.DEFAULT_UNIT = Globals.UNIT_MM Then
        Set this.sheetTechnicalData = SheetTechnicalDataMM
        Set this.sheetChannelTypes = SheetChannelTypesMM
    Else
        Set this.sheetTechnicalData = SheetTechnicalDataInch
        Set this.sheetChannelTypes = SheetChannelTypesInch
    End If
End Sub



Public Sub ChangeUnit()

    Dim worksheetName_channel_types_mm As String
    Dim worksheetName_channel_types_inch As String
    Dim worksheetName_technical_data_mm As String
    Dim worksheetName_technical_data_inch As String

    ' Set variables:
    If this.unit = Globals.UNIT_INCH Then
        ' Set units to mm
        this.unit = Globals.UNIT_MM
        this.fundamentalUnit = Globals.FUNDAMENTAL_UNIT_MM
        this.conversionFactor = Globals.CONVERSION_FACTOR_MM
        this.conversionFactorCurrentMeter = Globals.CONVERSION_FACTOR_CURRENT_METER_MM
        this.conversionFactorLongUnit = Globals.CONVERSION_FACTOR_LONG_UNIT_MM
        ' Reset all settings to defaults for mm
        this.maximumCuttingWidth = Globals.DEFAULT_MAXIMUM_CUTTING_WIDTH_MM
        this.defaultTolerance = Globals.DEFAULT_TOLERANCE_MM
        this.cutFreeSpaceEnd = Globals.DEFAULT_CUT_FREE_SPACE_END_MM
    ElseIf this.unit = Globals.UNIT_MM Then
        ' Set units to inch
        this.unit = Globals.UNIT_INCH
        this.fundamentalUnit = Globals.FUNDAMENTAL_UNIT_INCH
        this.conversionFactor = Globals.CONVERSION_FACTOR_INCH
        this.conversionFactorCurrentMeter = Globals.CONVERSION_FACTOR_CURRENT_METER_INCH
        this.conversionFactorLongUnit = Globals.CONVERSION_FACTOR_LONG_UNIT_INCH
        ' Reset all settings to defaults for inch
        this.maximumCuttingWidth = Globals.DEFAULT_MAXIMUM_CUTTING_WIDTH_INCH
        this.defaultTolerance = Globals.DEFAULT_TOLERANCE_INCH
        this.cutFreeSpaceEnd = Globals.DEFAULT_CUT_FREE_SPACE_END_INCH
    End If

    ' Change visible setting
    SheetSettings.Range(Globals.SETTINGS_COL_VALUE & Globals.SETTINGS_ROW_UNIT).value = this.unit

    ' Get field names:
    ' TODO: Circular dependency between Settings and Translation, they each require each other her
'    worksheetName_channel_types_mm = Translation.translateField( _
'        fieldNameIn:="tab_channel_types_mm", _
'        statical:=True _
'    )
'    worksheetName_channel_types_inch = Translation.translateField( _
'        fieldNameIn:="tab_channel_types_inch", _
'        statical:=True _
'    )
'    worksheetName_technical_data_mm = Translation.translateField( _
'        fieldNameIn:="tab_technical_data_mm", _
'        statical:=True _
'    )
'    worksheetName_technical_data_inch = Translation.translateField( _
'        fieldNameIn:="tab_technical_data_inch", _
'        statical:=True _
'    )

    worksheetName_channel_types_mm = SheetChannelTypesMM.name
    worksheetName_channel_types_inch = SheetChannelTypesInch.name
    worksheetName_technical_data_mm = SheetTechnicalDataMM.name
    worksheetName_technical_data_inch = SheetTechnicalDataInch.name


    If this.unit = Globals.UNIT_INCH Then
        ' Chaning to inch

        ' Only show sheets whos equivivalent was shown before changing the setting
        'If this.genericSheet.getVisibilityByName(worksheetName_channel_types_mm) = True Then
            'Debug.Print "channel type mm visible, enabling inch"
            this.genericSheet.setVisibilityByName worksheetName_channel_types_inch, True
        'End If
        'If this.genericSheet.getVisibilityByName(worksheetName_technical_data_mm) = True Then
            'Debug.Print "technical data mm visible, enabling inch"
            this.genericSheet.setVisibilityByName worksheetName_technical_data_inch, True
        'End If
        
        ' Change sheets
        Set this.sheetTechnicalData = SheetTechnicalDataInch
        Set this.sheetChannelTypes = SheetChannelTypesInch
        
        ' Always hide mm sheets
        this.genericSheet.setVisibilityByName worksheetName_channel_types_mm, False
        this.genericSheet.setVisibilityByName worksheetName_technical_data_mm, False
        
        ' Reset settings to default values for inch:
        this.defaultTolerance = Globals.DEFAULT_TOLERANCE_INCH
        this.cutFreeSpaceEnd = Globals.DEFAULT_CUT_FREE_SPACE_END_INCH
        this.maximumCuttingWidth = Globals.DEFAULT_MAXIMUM_CUTTING_WIDTH_INCH
                
    Else
        ' Chaning to mm

        ' Only show sheets whos equivivalent was shown before changing the setting
        'If this.genericSheet.getVisibilityByName(worksheetName_channel_types_inch) = True Then
            'Debug.Print "channel types inch visible, enabling mm"
            this.genericSheet.setVisibilityByName worksheetName_channel_types_mm, True
        'End If
        'If this.genericSheet.getVisibilityByName(worksheetName_technical_data_inch) = True Then
            'Debug.Print "technical data inch visible, enabling mm"
            this.genericSheet.setVisibilityByName worksheetName_technical_data_mm, True
        'End If
        
        ' Change sheets
        Set this.sheetTechnicalData = SheetTechnicalDataMM
        Set this.sheetChannelTypes = SheetChannelTypesMM
        
        ' Always hide inch sheets
        this.genericSheet.setVisibilityByName worksheetName_channel_types_inch, False
        this.genericSheet.setVisibilityByName worksheetName_technical_data_inch, False
        
        ' Reset settings to default values for inch:
        this.defaultTolerance = Globals.DEFAULT_TOLERANCE_MM
        this.cutFreeSpaceEnd = Globals.DEFAULT_CUT_FREE_SPACE_END_MM
        this.maximumCuttingWidth = Globals.DEFAULT_MAXIMUM_CUTTING_WIDTH_MM
        
    End If

    ' Update display of the changed settings
    SheetSettings.Range( _
        Globals.SETTINGS_COL_VALUE & _
        Globals.SETTINGS_ROW_DEFAULT_TOLERANCE _
    ).value = Settings.defaultTolerance
    SheetSettings.Range( _
        Globals.SETTINGS_COL_VALUE & _
        Globals.SETTINGS_ROW_CUTFREE_SPACE_END _
    ).value = Settings.cutFreeSpaceEnd
    SheetSettings.Range( _
        Globals.SETTINGS_COL_VALUE & _
        Globals.SETTINGS_ROW_MAXIMUM_CUTTING_WIDTH _
    ).value = Settings.maximumCuttingWidth

    ' Translate because labels changes
    Translation.TranslateCells
        
    ' Reset request because underlying data has changed.
    Set Request = New CRequest
    Request.requestSheet.clearSheet
    Request.outputSheets.clear
    
    ' Check Technical Data for errors
    If Not checkTechnicalData_all Then
        ' As there is a error on this sheet, make it visible and activate it
        Settings.sheetTechnicalData.visible = xlSheetVisible
        Settings.sheetTechnicalData.Activate
        Logger.logInfo "Error in sheetTechnicalData sheet: " & Settings.sheetTechnicalData.name
    Else
        ' Check channel types for errors
        If Not checkChannelTypes_all Then
            ' As there is a error on this sheet, make it visible and activate it
            Settings.sheetChannelTypes.visible = xlSheetVisible
            Settings.sheetChannelTypes.Activate
            Logger.logInfo "Error in sheetChannelTypes sheet: " & Settings.sheetChannelTypes.name
        Else
    
            Request.outputSheets.writeProfileSheets
            Request.readChannelTypesSheets
            checkRequest_all
            Request.validators.applyVaildators
            
            SheetSettings.Activate
        End If
    End If

End Sub






Attribute VB_Name = "CTimer"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CTimer class

Private Type LargeInteger
    lowpart As Long
    highpart As Long
End Type

Private Type TTimer
    counterStart As LargeInteger
    counterEnd As LargeInteger
    crFrequency As Double
End Type

Private this As TTimer
Private Declare PtrSafe Function QueryPerformanceCounter Lib "kernel32" (ByRef lpPerformanceCount As LargeInteger) As Long
Private Declare PtrSafe Function QueryPerformanceFrequency Lib "kernel32" (ByRef lpFrequency As LargeInteger) As Long
Private Const TWO_32BITS As Variant = 4294967296# ' = 256# * 256# * 256# * 256#

'@Ignore UseMeaningfulName
Private Function li2Double(ByRef li As LargeInteger) As Double
    Dim low As Double
    low = li.lowpart
    If low < 0 Then
        low = low + TWO_32BITS
    End If
    li2Double = li.highpart * TWO_32BITS + low
End Function

Private Sub class_initialize()
    Dim perfFrequency As LargeInteger
    QueryPerformanceFrequency perfFrequency
    this.crFrequency = li2Double(perfFrequency)
End Sub

Public Sub startCounter()
    QueryPerformanceCounter this.counterStart
End Sub

Public Property Get timeElapsed() As Double
    Dim crStart As Double
    Dim crStop As Double
    QueryPerformanceCounter this.counterEnd
    crStart = li2Double(this.counterStart)
    crStop = li2Double(this.counterEnd)
    timeElapsed = 1000# * (crStop - crStart) / this.crFrequency
End Property
Attribute VB_Name = "CTranslation"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CTranslation class

Private Type TTranslations
    translationFields() As CTranslationField    ' Contains the data for all translations
    Languages() As String                       ' Contains the name of each language
    translationsHasBeenRead As Boolean
    languageCount As Long                       ' Number of languages defined
    translationFieldCount As Long
    genericSheet As IGenericSheet
End Type

Private this As TTranslations

Public Property Get translationFieldCount() As Long
    translationFieldCount = this.translationFieldCount
End Property
Public Property Let translationFieldCount(ByVal value As Long)
    this.translationFieldCount = value
End Property

Public Property Get languageCount() As Long
    languageCount = this.languageCount
End Property
Public Property Let languageCount(ByVal value As Long)
    this.languageCount = value
End Property

Public Property Get translationsHasBeenRead() As Boolean
    translationsHasBeenRead = this.translationsHasBeenRead
End Property
Public Property Let translationsHasBeenRead(ByVal value As Boolean)
    this.translationsHasBeenRead = value
End Property


Private Sub class_initialize()
    ReDim this.translationFields(1 To 1)
    ReDim this.Languages(1 To 1)
    this.translationsHasBeenRead = False
    this.translationFieldCount = 0
    this.languageCount = 0
    Set this.genericSheet = New GenericSheetProxy
End Sub


Public Function GetLanguage(ByVal languageNo As Long) As String
    GetLanguage = this.Languages(languageNo)
End Function

' Returns the translation of the given field name
' If the field name is not defined, it returns an empty string
' Optional language, if this is set a specific language will be used, otherwise it uses the set language
Public Function translateField( _
    ByVal fieldNameIn As String, _
    Optional ByVal statical As Boolean, _
    Optional ByVal overrideLanguage As String _
) As String
    Dim fieldName As String
    fieldName = fieldNameIn
    'Logger.logInfo "fieldName: " & fieldName

    Dim i As Long
    Dim languageNo As Long
    Dim languageString As String

    ' Debug:
    'Logger.logInfo "TranslationsHasBeenRead: " & vbTab & translationsHasBeenRead
    'Logger.logInfo "TranslationFieldCount: " & vbTab & translationFieldCount
    'Logger.logInfo "Settings.language: " & vbTab & Settings.language

    If Settings Is Nothing Then
        Set Settings = New CSettings
    End If
    If Translation Is Nothing Then
        Set Translation = New CTranslation
    End If
    
    ' Read the language setting if it is not set
    ' This seems to happen if the code has run into a problem, the value of this variable gets reset
    If Settings.Language = vbNullString Then
        Settings.readLanguageSetting
    End If
    
    ' If this is the first time, make sure the translations has been read
    If Not this.translationsHasBeenRead = True Then
        readTranslations
    End If
    
    languageNo = 0
    translateField = vbNullString
    
    ' Optional given language
    If overrideLanguage = vbNullString Then
        languageString = Settings.Language
        'Logger.logInfo "Using set language: " & Settings.language
    Else
        languageString = overrideLanguage
        'Logger.logInfo "Using custom language: " & overrideLanguage
    End If
    
    ' Find languageNo
    For i = 1 To this.languageCount
        If this.Languages(i) = languageString Then
            languageNo = i
            'Logger.logInfo "Found languageNo: " & languageNo
            Exit For
        End If
    Next
    
    ' Translate units by changing the postfix of the fieldName from _mm to _inch
    ' The tool is set in mm per default, so this is only needed if it is set to INCH
    
    If Settings.unit = Globals.UNIT_INCH _
    And Not statical And Right$(fieldName, 3) = "_mm" Then
        fieldName = Left$(fieldName, Len(fieldName) - 3) & "_inch"
    End If

    If languageNo > 0 Then
        ' Translate the given FieldName
        For i = 1 To this.translationFieldCount
            'Logger.logInfo i & vbTab & translationFields(i).fieldName
            If this.translationFields(i).fieldName = fieldName Then
                translateField = this.translationFields(i).getTranslation(languageNo)
                'Logger.logInfo "Found translation: " & translateField
                Exit For
            End If
        Next
    End If
    'If translateField = vbNullString Then
        'Logger.logError "Missing translation for: " & fieldName
    'End If
End Function


Public Sub readTranslations()
    'Logger.logInfoBoth "Reading translations"

    Dim lineNo As Long
    Dim columnNo As Long
    Dim lastRow As Long
    Dim firstCol As Long
    Dim lastCol As Long
    Dim lastColLetter As String
    
    Dim languageName As String
    Dim fieldName As String
    Dim languageTranslation As String
    
    ' Used to keep the data from the sheet
    Dim sheetData As Variant
       
    ' Clear any previously loaded translations
    clearTranslations
    
    ' Read channels specifications
    With SheetTranslations
        
        ' Find last row:
        lastRow = .Range( _
            Globals.TRANSLATIONS_COL_FIELD_NAME & _
            .Rows.count _
        ).End(xlUp).Row
        firstCol = letter2Column(Globals.TRANSLATIONS_COL_FIELD_NAME)
        lastCol = .Cells( _
            Globals.TRANSLATIONS_ROW_HEADER_ROW, _
            .Columns.count _
        ).End(xlToLeft).Column
        lastColLetter = column2Letter(lastCol)
         
        ' Read the data
        sheetData = .Range( _
            Globals.TRANSLATIONS_COL_FIELD_NAME & _
            Globals.TRANSLATIONS_ROW_HEADER_ROW & _
            ":" & _
            lastColLetter & _
            lastRow _
        ).value

        ' Loop over every line
        For lineNo = 1 To (lastRow - Globals.TRANSLATIONS_ROW_HEADER_ROW + 1)
            
            ' Loop over every column
            For columnNo = 1 To (lastCol - firstCol + 1)
            
                ' In the first line is the name of the language
                If lineNo = 1 Then
                    ' Colmun 1 on line 1 contains no useful information
                    If columnNo > 1 Then
                        languageName = sheetData(lineNo, columnNo)
                        this.languageCount = this.languageCount + 1
                        ReDim Preserve this.Languages(1 To this.languageCount)
                        this.Languages(this.languageCount) = languageName
                    End If
                Else
                    ' Col 1 of lines > 1 contains the field name
                    If columnNo = 1 Then
                        fieldName = sheetData(lineNo, columnNo)
                        ' Skip empty lines
                        If Not fieldName = vbNullString Then
                            this.translationFieldCount = this.translationFieldCount + 1
                            ReDim Preserve this.translationFields(1 To this.translationFieldCount)
                            '@Ignore ObjectVariableNotSet
                            Set this.translationFields(this.translationFieldCount) = New CTranslationField
                            this.translationFields(this.translationFieldCount).fieldName = fieldName
                        End If
                    ' Col > 1 contains the actual translations
                    Else
                        ' Skip empty
                        If Not fieldName = vbNullString Then
                            languageTranslation = sheetData(lineNo, columnNo)
                            this.translationFields(this.translationFieldCount).addTranslation languageTranslation
                        End If
                    End If
                End If
            Next
        Next
    End With
    
    this.translationsHasBeenRead = True
End Sub


Public Sub clearTranslations()
    ReDim this.Languages(1 To 1)
    ReDim this.translationFields(1 To 1)
    this.languageCount = 0
    this.translationFieldCount = 0
    this.translationsHasBeenRead = False
End Sub

Public Sub translateEverything()
'    disableWorksheetFeaturesLevel = 0
'    'translateTabs
'    TranslateButtons
'    ' Recalculate all worksheet in this workbook
'    Dim worksheetNo As Long
'    Application.Calculation = xlManual
'    For worksheetNo = 1 To ThisWorkbook.Worksheets.count
'        ThisWorkbook.Worksheets.item(worksheetNo).Calculate
'    Next
'    ' TODO: Is this needed?
'    'Application.Calculation = xlAutomatic
End Sub

Public Sub TranslateCells()
    disableWorksheetFeaturesLevel = 0
    ' Recalculate all worksheet in this workbook
    Dim worksheetNo As Long
    Application.Calculation = xlManual
    For worksheetNo = 1 To ThisWorkbook.Worksheets.count
        ThisWorkbook.Worksheets.item(worksheetNo).Calculate
    Next
    'Application.Calculation = xlAutomatic
End Sub

Public Sub translateTabs()
'    ' Translate the names of the tabs
'    If Not translateField("tab_all_profiles") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetProfilesAll, _
'            translateField("tab_all_profiles", True)
'    End If
'    If Not translateField("tab_all_requested") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetRequestedAll, _
'            translateField("tab_all_requested", True)
'    End If
'    If Not translateField("tab_channel_types_mm") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetChannelTypesMM, _
'            translateField("tab_channel_types_mm", True)
'    End If
'    If Not translateField("tab_channel_types_inch") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetChannelTypesInch, _
'            translateField("tab_channel_types_inch", True)
'    End If
'    If Not translateField("tab_countries") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetCountries, _
'            translateField("tab_countries", True)
'    End If
'    If Not translateField("tab_cutting_pattern") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetCuttingPattern, _
'            translateField("tab_cutting_pattern", True)
'    End If
'    If Not translateField("tab_diagrams") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetDiagrams, _
'            translateField("tab_diagrams", True)
'    End If
'    If Not translateField("tab_images") = vbNullString Then
'        this.genericSheet.renameSheet _
'        SheetImages, _
'        translateField("tab_images", True)
'    End If
'    If Not translateField("tab_output_lists") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetOutputLists, _
'            translateField("tab_output_lists", True)
'    End If
'    If Not translateField("tab_request") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetRequest, _
'            translateField("tab_request", True)
'    End If
'    If Not translateField("tab_technical_data_mm") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetTechnicalDataMM, _
'            translateField("tab_technical_data_mm", True)
'    End If
'    If Not translateField("tab_technical_data_inch") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetTechnicalDataInch, _
'            translateField("tab_technical_data_inch", True)
'    End If
'    If Not translateField("tab_settings") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetSettings, _
'            translateField("tab_settings", True)
'    End If
'    If Not translateField("tab_translations") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetTranslations, _
'            translateField("tab_translations", True)
'    End If
'    If Not translateField("tab_unique_profiles") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetProfilesUnique, _
'            translateField("tab_unique_profiles", True)
'    End If
'    If Not translateField("tab_unique_requested") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetRequestedUnique, _
'            translateField("tab_unique_requested", True)
'    End If
'    If Not translateField("tab_channel_overview") = vbNullString Then
'        this.genericSheet.renameSheet _
'            SheetChannelOverview, _
'            translateField("tab_channel_overview", True)
'    End If
'
'    ' Special case for the "How to use"-sheet:
'    ' instead of translating we display another one instead
'    Dim worksheetName As String
'    Dim languageNo As Long
'    ' Hide all
'    For languageNo = 1 To this.languageCount
'        ' Only hide existing worksheets, enabling us to add a language specific one.
'        worksheetName = translateField( _
'            fieldNameIn:="tab_how_to_use", _
'            statical:=True, _
'            overrideLanguage:=this.Languages(languageNo) _
'        )
'        If this.genericSheet.WorkSheetExists(worksheetName) Then
'            this.genericSheet.setVisibility ThisWorkbook.Sheets(worksheetName), False
'        End If
'    Next
'
'    ' Display the sheet for the currently set language, if one exists
'    worksheetName = translateField("tab_how_to_use")
'    If this.genericSheet.WorkSheetExists(worksheetName) Then
'        this.genericSheet.setVisibility ThisWorkbook.Sheets(worksheetName), True
'    Else
'        ' As fallback, show the first existing sheet
'        For languageNo = 1 To this.languageCount
'            worksheetName = translateField( _
'                fieldNameIn:="tab_how_to_use", _
'                statical:=False, _
'                overrideLanguage:=this.Languages(languageNo) _
'            )
'            If this.genericSheet.WorkSheetExists(worksheetName) Then
'                this.genericSheet.setVisibility ThisWorkbook.Sheets(worksheetName), True
'                ' Break once an existing sheet is found
'                Exit For
'            End If
'        Next
'    End If
End Sub

' Translates the text on all buttons
Public Sub TranslateButtons()
    this.genericSheet.changeButtonText _
        Sheet:=SheetRequest, _
        name:="FindSolutionButton", _
        newText:=translateField("button_find_best_solution")
    this.genericSheet.changeButtonText _
        Sheet:=SheetRequest, _
        name:="CheckSpecificationButton", _
        newText:=translateField("button_check_specification")
    this.genericSheet.changeButtonText _
        Sheet:=SheetRequest, _
        name:="GenerateSpecificationButton", _
        newText:=translateField("button_generate_request")
    this.genericSheet.changeButtonText _
        Sheet:=SheetChannelTypesMM, _
        name:="CheckChTypeButton", _
        newText:=translateField("button_check")
    this.genericSheet.changeButtonText _
        Sheet:=SheetTechnicalDataMM, _
        name:="CheckTechnicalDataButton", _
        newText:=translateField("button_check")
    this.genericSheet.changeButtonText _
        Sheet:=SheetChannelTypesInch, _
        name:="CheckChTypeButton", _
        newText:=translateField("button_check")
    this.genericSheet.changeButtonText _
        Sheet:=SheetTechnicalDataInch, _
        name:="CheckTechnicalDataButton", _
        newText:=translateField("button_check")
    this.genericSheet.changeButtonText _
        Sheet:=SheetOutputLists, _
        name:="ExportButton", _
        newText:=translateField("button_export_to_pdf")
    this.genericSheet.changeButtonText _
        Sheet:=SheetTranslations, _
        name:="ApplyTranslationButton", _
        newText:=translateField("button_apply_translation")
    this.genericSheet.changeButtonText _
        Sheet:=SheetSettings, _
        name:="ChangeUnitButton", _
        newText:=translateField("button_change_unit")
End Sub


Attribute VB_Name = "CTranslationField"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CTranslationField class

Private Type TTranslationField
    Languages() As String     ' List of translations
    fieldName As String
    languageCount As Long      ' Number of translations defined for this field
End Type

Private this As TTranslationField

Public Property Get fieldName() As String
    fieldName = this.fieldName
End Property

Public Property Let fieldName(ByVal value As String)
    this.fieldName = value
End Property


Private Sub class_initialize()
    this.fieldName = vbNullString
    ReDim this.Languages(1 To 1)
    this.languageCount = 0
End Sub


Public Sub addTranslation(ByVal fieldTranslation As String)
    this.languageCount = this.languageCount + 1
    ReDim Preserve this.Languages(1 To this.languageCount)
    this.Languages(this.languageCount) = fieldTranslation
End Sub


Public Function getTranslation(ByVal languageNo As Long) As String
    If languageNo > 0 _
    And languageNo <= this.languageCount Then
        getTranslation = this.Languages(languageNo)
    Else
        getTranslation = vbNullString
    End If
End Function
Attribute VB_Name = "CUnfill"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' CUnfill class

' A class implementing the unfill algorithm

Private Type TUnfill
    fillrate As Long
    lengths As CLongArray
    used As CLongArray
    maxLength As Long
    current As Long
    results As CLongArrayArray        ' Keeps all results
End Type

Private this As TUnfill

Public Property Get results() As CLongArrayArray
    Set results = this.results
End Property

' Initialization
Private Sub class_initialize()
    this.maxLength = 0
    this.fillrate = 0
    this.current = 1
    Set this.results = New CLongArrayArray
    Set this.lengths = New CLongArray
    Set this.used = New CLongArray
End Sub


Public Sub addLength(ByVal newLength As Long)
    this.lengths.addElement newLength
    this.used.addElement 0  ' Always add a new used as well to keep them in sync
End Sub


Public Sub setMaxLength(ByVal maxLength As Long)
    this.maxLength = maxLength
End Sub


Public Sub unfill()
    fillItUp
    Do While removeOne And this.current >= 1
        fillItUp
    Loop
End Sub


Public Function removeOne() As Boolean
    Dim ranAtLeastOnce As Boolean
    Dim backedAtLeastOnce As Boolean
    
    ranAtLeastOnce = False
    backedAtLeastOnce = False
    
    Do While this.current >= 1
        If this.used.element(this.current) > 0 Then
            this.used.element(this.current) = this.used.element(this.current) - 1
            this.fillrate = this.fillrate - this.lengths.element(this.current)
            ranAtLeastOnce = True
            Exit Do
        End If
        this.current = this.current - 1
        backedAtLeastOnce = True
    Loop
    If Not ranAtLeastOnce Then
        removeOne = False
        Exit Function
    End If
    
    If Not backedAtLeastOnce Then
        save
    End If
    If this.current < this.lengths.count Then
        this.current = this.current + 1
    Else
        removeOne
    End If
    
    removeOne = True
End Function


Public Sub fillItUp()
    Dim ranAtLeastOnce  As Boolean
    ranAtLeastOnce = False
    Do While this.fillrate + this.lengths.element(this.current) < this.maxLength
        ' TODO Enhancement: Possible with tighter bounds here, we can use the placement function to
        ' find the maximum number of pieces each kind which will be eqaual to or lower than this value.
        this.used.element(this.current) = this.used.element(this.current) + 1
        this.fillrate = this.fillrate + this.lengths.element(this.current)
        ranAtLeastOnce = True
    Loop
    If ranAtLeastOnce Then
        save
    Else
        this.current = this.current - 1
    End If
End Sub


Private Sub save()
    ' Skip empty
    If this.fillrate > 0 Then
        ' Create a copy of the object
        ' TODO Enhancement: Check if this is the most optimal way to copy the CLongArray
        Dim pieceArrayCopy As CLongArray
        Set pieceArrayCopy = New CLongArray
        pieceArrayCopy.addArray this.used
        ' Save result
        this.results.addElement pieceArrayCopy
    End If
End Sub
Attribute VB_Name = "Check_ChType"
'@Folder("Checkers")
Option Explicit

' Checks one single cell
Public Sub checkChannelTypes_cell(ByVal thisRow As Long, ByVal thisCol As Long)
    Dim note As String
    note = vbNullString
    
    With Settings.sheetChannelTypes
        ' Ignore blank lines
        If .Range(Globals.CHTYPE_COL_ENABLED & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_TYPE & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_SAP_NUMBER & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_SAP_DESCRIPTION & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_LENGTH_NAME & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_PLUS & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_MINUS & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_CUT_COST & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_LENGTH & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_COST & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_BUNDLE_SIZE & thisRow).value <> vbNullString _
        Then
            ' First check the column the user changed
            If column2Letter(thisCol) = Globals.CHTYPE_COL_ENABLED Then
                note = chtype_check_enabled(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_TYPE Then
                note = chtype_check_chType(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_SAP_NUMBER Then
                note = chtype_check_SAP_number(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_SAP_DESCRIPTION Then
                note = chtype_check_SAP_description(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_LENGTH_NAME Then
                note = chtype_check_lengthName(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_DELIVERY_TOLERANCE_PLUS Then
                note = chtype_check_deliveryTolerancePlus(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_DELIVERY_TOLERANCE_MINUS Then
                note = chtype_check_deliveryToleranceMinus(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_CUT_COST Then
                note = chtype_check_cutCost(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_LENGTH Then
                note = chtype_check_length(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_COST Then
                note = chtype_check_cost(thisRow)
            ElseIf column2Letter(thisCol) = Globals.CHTYPE_COL_BUNDLE_SIZE Then
                note = chtype_check_bundle_size(thisRow)
            End If
            
            ' If that did not result in an error, check the others
            If note = vbNullString Then note = chtype_check_enabled(thisRow)
            If note = vbNullString Then note = chtype_check_chType(thisRow)
            If note = vbNullString Then note = chtype_check_SAP_number(thisRow)
            If note = vbNullString Then note = chtype_check_SAP_description(thisRow)
            If note = vbNullString Then note = chtype_check_lengthName(thisRow)
            If note = vbNullString Then note = chtype_check_deliveryTolerancePlus(thisRow)
            If note = vbNullString Then note = chtype_check_deliveryToleranceMinus(thisRow)
            If note = vbNullString Then note = chtype_check_cutCost(thisRow)
            If note = vbNullString Then note = chtype_check_length(thisRow)
            If note = vbNullString Then note = chtype_check_cost(thisRow)
            If note = vbNullString Then note = chtype_check_bundle_size(thisRow)
        End If
        ' Set note string (done outside the if blank lines checker so that it will reset the note to nothing on blank lines)
        .Range(Globals.CHTYPE_COL_ERROR & thisRow).value = note
    End With
End Sub


' Check a full row
Public Function checkChannelTypes_row(ByVal thisRow As Long) As Boolean

    Dim note As String
    note = vbNullString

    ' Ignore blank lines
    With Settings.sheetChannelTypes
        If .Range(Globals.CHTYPE_COL_ENABLED & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_TYPE & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_SAP_NUMBER & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_SAP_DESCRIPTION & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_LENGTH_NAME & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_PLUS & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_MINUS & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_CUT_COST & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_LENGTH & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_COST & thisRow).value <> vbNullString _
            Or .Range(Globals.CHTYPE_COL_BUNDLE_SIZE & thisRow).value <> vbNullString _
        Then
            ' If that did not result in an error, check the others
            If note = vbNullString Then note = chtype_check_enabled(thisRow)
            If note = vbNullString Then note = chtype_check_chType(thisRow)
            If note = vbNullString Then note = chtype_check_SAP_number(thisRow)
            If note = vbNullString Then note = chtype_check_SAP_description(thisRow)
            If note = vbNullString Then note = chtype_check_lengthName(thisRow)
            If note = vbNullString Then note = chtype_check_deliveryTolerancePlus(thisRow)
            If note = vbNullString Then note = chtype_check_deliveryToleranceMinus(thisRow)
            If note = vbNullString Then note = chtype_check_cutCost(thisRow)
            If note = vbNullString Then note = chtype_check_length(thisRow)
            If note = vbNullString Then note = chtype_check_cost(thisRow)
            If note = vbNullString Then note = chtype_check_bundle_size(thisRow)
           
            If note <> vbNullString Then
                Logger.logInfo "Error in " & Settings.sheetChannelTypes.name & " on line " & thisRow & ": " & note
            End If
            
            ' Set note string
            .Range(Globals.CHTYPE_COL_ERROR & thisRow).value = note
        End If
    End With

    ' Return status depending on if there is a error message
    '@Ignore BooleanAssignedInIfElse
    If note = vbNullString Then
        checkChannelTypes_row = True
    Else
        checkChannelTypes_row = False
    End If
End Function


' Returns true if there is no error, otherwise false
Public Function checkChannelTypes_all() As Boolean

    checkChannelTypes_all = True
    
    
    Dim lastRow As Long
    Dim highestLastRow As Long

    With Settings.sheetChannelTypes
        ' Look at all columns and find the highest row that contains any data
        highestLastRow = .Range(Globals.CHTYPE_COL_ENABLED & .Rows.count).End(xlUp).Row    ' No need for checking on the first one
        lastRow = .Range(Globals.CHTYPE_COL_TYPE & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_SAP_NUMBER & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_SAP_DESCRIPTION & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_LENGTH_NAME & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_PLUS & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_MINUS & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_CUT_COST & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_LENGTH & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_COST & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_BUNDLE_SIZE & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.CHTYPE_COL_ERROR & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
    End With

    ' Sanity check
    If highestLastRow >= Globals.CHTYPE_ROW_FIRST Then
        ' Start at the first line and loop through all used lines
        Dim line As Long
        Dim appProxy As IApplication
        Set appProxy = New ApplicationProxy
        appProxy.disableWhileRunning
        For line = Globals.CHTYPE_ROW_FIRST To highestLastRow
            If Not checkChannelTypes_row(line) Then
                checkChannelTypes_all = False
                Logger.logInfo "Error on " & Settings.sheetChannelTypes.name & " on line " & line
            End If
        Next
        appProxy.enableAfterRunning
    End If

End Function

'' Checkers for indivudual columns
' Takes a row and checks the specific column for errors according to it's
' special requirements. Returns a string on error.

' Makes sure that enabled is either 1 or 0:
Public Function chtype_check_enabled(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_ENABLED & affectedRow).value
    chtype_check_enabled = vbNullString
    If Not value = "0" And Not value = "1" Then
        chtype_check_enabled = _
            Translate("tbl_enabled") & " " & _
            Translate("error_has_to_be_1_or_0") ' Enabled has to be 1 or 0
    'Else
        ' Ok
    End If
End Function

' Make sure that Channel type is of a valid type as read from the Technical Data sheet
Public Function chtype_check_chType(ByVal affectedRow As Long) As String
    Dim value As String
    Dim foundMatch As Boolean
    foundMatch = False
    Dim typesList As String
    
    Dim lastRow As Long
    Dim i As Long
    Dim chtype As String
    
    typesList = vbNullString
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_TYPE & affectedRow).value
    chtype_check_chType = vbNullString

    If value = vbNullString Then
        chtype_check_chType = _
            Translate("tbl_channel_type") & " " & _
            Translate("error_is_missing")                                 ' Channel type is missing
    Else
        ' Check if it matches a channel in technical data
        lastRow = Settings.sheetTechnicalData.Range( _
            Globals.TECHNICAL_DATA_COL_TYPE & _
            Settings.sheetTechnicalData.Rows.count _
        ).End(xlUp).Row
        If lastRow >= Globals.TECHNICAL_DATA_ROW_FIRST Then
            For i = Globals.TECHNICAL_DATA_ROW_FIRST To lastRow
                chtype = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_TYPE & i).value
                If value = chtype Then
                    foundMatch = True
                End If
                If Not chtype = vbNullString Then
                    typesList = typesList & ", " & chtype
                End If
            Next
            If Not typesList = vbNullString Then
                ' Remove first ', '
                typesList = Right$(typesList, Len(typesList) - 2)
                
                If Not foundMatch Then
                    chtype_check_chType = _
                        Translate("tbl_channel_type") & " " & _
                        Translate("error_has_to_be_one_of") & _
                        " (" & typesList & ")"                            'Channel type has to be one of (" & typesList & ")
                'Else
                    ' Ok
                End If
            Else
                chtype_check_chType = Translate("error_channel_types_defined_technical_data") & 1
            End If
        Else
            chtype_check_chType = Translate("error_channel_types_defined_technical_data") & 2
        End If
    End If
End Function


' Makes sure that SAP number is set to a unique value
' And that this value is a whole number larger than -1
Public Function chtype_check_SAP_number(ByVal affectedRow As Long) As String
    Dim value As String
    'Dim duplicate_found As Boolean
    'Dim lastRow As Long
    'Dim i As Long
    'duplicate_found = False
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_SAP_NUMBER & affectedRow).value
    chtype_check_SAP_number = vbNullString

    ' Empty value check
    If value = vbNullString Then
        chtype_check_SAP_number = _
            Translate("tbl_sap_number") & " " & _
            Translate("error_is_missing")                 ' SAP number is missing
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            chtype_check_SAP_number = _
                Translate("tbl_sap_number") & " " & _
                Translate("error_cannot_be_decimal")      ' SAP number cannot be decimal
        ElseIf value < 0 Then
            chtype_check_SAP_number = _
                Translate("tbl_sap_number") & " " & _
                Translate("error_is_below_0")             ' SAP number is below 0
        ElseIf value = 0 Then
            chtype_check_SAP_number = _
                Translate("tbl_sap_number") & " " & _
                Translate("error_is_0")                   ' SAP number is 0
        ElseIf InStr(1, value, ".") > 0 Then
            chtype_check_SAP_number = _
                Translate("tbl_sap_number") & " " & _
                Translate("error_contains_a_dot")         ' SAP number contains a dot
        'Else
            ' OK
            
            ' Check for uniqueness
            'lastRow = SheetChannelTypesMM.Range(CHTYPE_COL_SAP_NUMBER & SheetChannelTypesMM.Rows.count).End(xlUp).row
            'If lastRow > CHTYPE_ROW_FIRST Then
            '    For i = CHTYPE_ROW_FIRST To lastRow
            '        If Not i = affectedRow And SheetChannelTypesMM.Range(CHTYPE_COL_SAP_NUMBER & i).value = value Then
            '            duplicate_found = True
            '        End If
            '    Next
            'End If
            '
            'If duplicate_found Then
            '    chtype_check_SAP_number = Translate("tbl_sap_number") & " " & _
            '                              Translate("error_has_to_be_unique")      ' SAP number has to be unique
            'Else
            '    ' OK
            'End If
        End If
    ElseIf Not IsNumeric(value) Then
        chtype_check_SAP_number = _
            Translate("tbl_sap_number") & " " & _
            Translate("error_is_not_a_number")                ' SAP number is not a number
    End If
End Function

' Makes sure that SAP description is set
Public Function chtype_check_SAP_description(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_SAP_DESCRIPTION & affectedRow).value
    chtype_check_SAP_description = vbNullString
    If value = vbNullString Then
        chtype_check_SAP_description = _
            Translate("tbl_sap_description") & " " & _
            Translate("error_is_missing")                ' SAP description is missing
    End If
End Function

' Makes sure that length name is set
Public Function chtype_check_lengthName(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_LENGTH_NAME & affectedRow).value
    chtype_check_lengthName = vbNullString
    If value = vbNullString Then
        chtype_check_lengthName = _
            Translate("tbl_length_name") & " " & _
            Translate("error_is_missing")                     ' Length name is missing
    End If
End Function

' Makes sure that delivery tolerance - is set to a whole number larger than -1
Public Function chtype_check_deliveryTolerancePlus(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_PLUS & affectedRow).value
    chtype_check_deliveryTolerancePlus = vbNullString
    If value = vbNullString Then
        chtype_check_deliveryTolerancePlus = _
            Translate("tbl_delivery_tolerance") & " [+] " & _
            Translate("error_is_missing")                      ' Delivery tolerence [+] is missing
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            chtype_check_deliveryTolerancePlus = _
                Translate("tbl_delivery_tolerance") & " [+] " & _
                Translate("error_cannot_be_decimal")           ' Delivery tolerence [+] cannot be decimal
        ElseIf value < 0 Then
            chtype_check_deliveryTolerancePlus = _
                Translate("tbl_delivery_tolerance") & " [+] " & _
                Translate("error_is_below_0")                  ' Delivery tolerence [+] is below 0
        ElseIf InStr(1, value, ".") > 0 Then
            chtype_check_deliveryTolerancePlus = _
                Translate("tbl_delivery_tolerance") & " [+] " & _
                Translate("error_error_contains_a_dot")        ' Delivery tolerence [+] contains a dot
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        chtype_check_deliveryTolerancePlus = _
            Translate("tbl_delivery_tolerance") & " " & _
            Translate("error_is_not_a_number")                 ' Delivery tolerance is not a number
    End If
End Function

' Makes sure that delivery tolerance + is set to a whole number larger than -1
Public Function chtype_check_deliveryToleranceMinus(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_DELIVERY_TOLERANCE_MINUS & affectedRow).value
    chtype_check_deliveryToleranceMinus = vbNullString
    If value = vbNullString Then
        chtype_check_deliveryToleranceMinus = _
            Translate("tbl_delivery_tolerance") & " [-] " & _
            Translate("error_is_missing")                     ' Delivery tolerence [-] is missing
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            chtype_check_deliveryToleranceMinus = _
                Translate("tbl_delivery_tolerance") & " [-] " & _
                Translate("error_cannot_be_decimal")          ' Delivery tolerence [-] cannot be decimal
        ElseIf value < 0 Then
            chtype_check_deliveryToleranceMinus = _
                Translate("tbl_delivery_tolerance") & " [-] " & _
                Translate("error_is_below_0")                 ' Delivery tolerence [-] is below 0
        ElseIf InStr(1, value, ".") > 0 Then
            chtype_check_deliveryToleranceMinus = _
                Translate("tbl_delivery_tolerance") & " [-] " & _
                Translate("error_error_contains_a_dot")       ' Delivery tolerence [-] contains a dot
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        chtype_check_deliveryToleranceMinus = _
            Translate("tbl_delivery_tolerance") & " [-] " & _
            Translate("error_is_not_a_number")                ' Delivery tolerance [-] is not a number
    End If
End Function

' Makes sure that cut cost is set to a whole number larger than -1
Public Function chtype_check_cutCost(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_CUT_COST & affectedRow).value
    chtype_check_cutCost = vbNullString
    If value = vbNullString Then
        chtype_check_cutCost = _
            Translate("tbl_cut_cost") & " " & _
            Translate("error_is_missing")                ' Cut cost is missing
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            chtype_check_cutCost = _
                Translate("tbl_cut_cost") & " " & _
                Translate("error_cannot_be_decimal")     ' Cut cost cannot be decimal
        ElseIf value < 0 Then
            chtype_check_cutCost = _
                Translate("tbl_cut_cost") & " " & _
                Translate("error_is_below_0")            ' Cut cost is below 0
        ElseIf InStr(1, value, ".") > 0 Then
            chtype_check_cutCost = _
                Translate("tbl_cut_cost") & " " & _
                Translate("error_error_contains_a_dot")  ' Cut cost contains a dot
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        chtype_check_cutCost = Translate("tbl_cut_cost") & " " & Translate("error_is_not_a_number") ' Cut cost is not a number
    End If
End Function

' Makes sure that length is set to a whole number larger than 0
Public Function chtype_check_length(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_LENGTH & affectedRow).value
    chtype_check_length = vbNullString
    If value = vbNullString Then
        chtype_check_length = _
            Translate("tbl_length") & " " & _
            Translate("error_is_missing")                 ' Length is missing
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            chtype_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_cannot_be_decimal")      ' Length cannot be decimal
        ElseIf value < 0 Then
            chtype_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_is_below_0")             ' Length is below 0
        ElseIf value = 0 Then
            chtype_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_is_0")                   ' Length is 0
        ElseIf InStr(1, value, ".") > 0 Then
            chtype_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_error_contains_a_dot")   ' Length contains a dot
        'Else
            ' OK!
            ' TODO Add uniqueness check within type
        End If
    ElseIf Not IsNumeric(value) Then
        chtype_check_length = _
            Translate("tbl_length") & " " & _
            Translate("error_is_not_a_number")            ' Length is not a number
    End If
End Function

' Makes sure that cost set to a whole number larger than -1
Public Function chtype_check_cost(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_COST & affectedRow).value
    chtype_check_cost = vbNullString
    If value = vbNullString Then
        chtype_check_cost = _
            Translate("tbl_cost") & " " & _
            Translate("error_is_missing")                   ' Cost is missing
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            chtype_check_cost = _
                Translate("tbl_cost") & " " & _
                Translate("error_cannot_be_decimal")        ' Cost cannot be decimal
        ElseIf value < 0 Then
            chtype_check_cost = _
                Translate("tbl_cost") & " " & _
                Translate("error_is_below_0")               ' Cost is below 0
        ElseIf InStr(1, value, ".") > 0 Then
            chtype_check_cost = _
                Translate("tbl_cost") & " " & _
                Translate("error_error_contains_a_dot")     ' Cost contains a dot
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        chtype_check_cost = _
            Translate("tbl_cost") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that bundle size is set to a whole number larger than 0
Public Function chtype_check_bundle_size(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetChannelTypes.Range(CHTYPE_COL_BUNDLE_SIZE & affectedRow).value
    chtype_check_bundle_size = vbNullString
    If value = vbNullString Then
        chtype_check_bundle_size = _
            Translate("tbl_bundle_size") & " " & _
            Translate("error_is_missing")                ' Bundle size is missing
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            chtype_check_bundle_size = _
                Translate("tbl_bundle_size") & " " & _
                Translate("error_cannot_be_decimal")     ' Bundle size cannot be decimal
        ElseIf value < 0 Then
            chtype_check_bundle_size = _
                Translate("tbl_bundle_size") & " " & _
                Translate("error_is_below_0")            ' Bundle size is below 0
        ElseIf value = 0 Then
            chtype_check_bundle_size = _
                Translate("tbl_bundle_size") & " " & _
                Translate("error_is_0")                  ' Bundle size is 0
        ElseIf InStr(1, value, ".") > 0 Then
            chtype_check_bundle_size = _
                Translate("tbl_bundle_size") & " " & _
                Translate("error_error_contains_a_dot")  ' Bundle size contains a dot
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        chtype_check_bundle_size = _
            Translate("tbl_bundle_size") & " " & _
            Translate("error_is_not_a_number")           ' Bundle size is not a number
    End If
End Function



Attribute VB_Name = "Check_OutputLists"
'@Folder("Checkers")
Option Explicit

' TODO: remove comment in file 2

' Checks for SAP order no, returns true if OK
Public Function checkOutputLists_sap_order_no() As Boolean

    Dim note As String
    
    checkOutputLists_sap_order_no = False
    
    note = outputLists_check_SAP_order_no
    
    SheetOutputLists.Range(Globals.OUTPUTLISTS_HEADER_NOTE_SAP_ORDER_NO).value = note
    
    If note = vbNullString Then
        checkOutputLists_sap_order_no = True
    End If
    
End Function

' Checks for SAP customer no, returns true if OK
Public Function checkOutputLists_sap_customer_no() As Boolean
    Dim note As String
    checkOutputLists_sap_customer_no = False
    note = outputLists_check_SAP_customer_no
    SheetOutputLists.Range(Globals.OUTPUTLISTS_HEADER_NOTE_SAP_CUSTOMER_NO).value = note
    If note = vbNullString Then
        checkOutputLists_sap_customer_no = True
    End If
End Function

' Makes sure that SAP order no is a whole number larger than -1
Public Function outputLists_check_SAP_order_no() As String

    Dim value As String
    
    value = SheetOutputLists.Range(Globals.OUTPUTLISTS_HEADER_SAP_ORDER_NO).value
    
    outputLists_check_SAP_order_no = vbNullString
    
    If value = vbNullString Then
        outputLists_check_SAP_order_no = _
            Translate("var_sap_order_no") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
    
        If Not Int(value) = value Then
            outputLists_check_SAP_order_no = _
                Translate("var_sap_order_no") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            outputLists_check_SAP_order_no = _
                Translate("var_sap_order_no") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            outputLists_check_SAP_order_no = _
                Translate("var_sap_order_no") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK!
        End If
        
    ElseIf Not IsNumeric(value) Then
    
        outputLists_check_SAP_order_no = _
            Translate("var_sap_order_no") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that SAP customer no is a whole number larger than -1
Public Function outputLists_check_SAP_customer_no() As String
    Dim value As String
    value = SheetOutputLists.Range(Globals.OUTPUTLISTS_HEADER_SAP_CUSTOMER_NO).value
    outputLists_check_SAP_customer_no = vbNullString
    If value = vbNullString Then
        outputLists_check_SAP_customer_no = _
            Translate("var_sap_customer_no") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            outputLists_check_SAP_customer_no = _
                Translate("var_sap_customer_no") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            outputLists_check_SAP_customer_no = _
                Translate("var_sap_customer_no") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            outputLists_check_SAP_customer_no = _
                Translate("var_sap_customer_no") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        outputLists_check_SAP_customer_no = _
            Translate("var_sap_customer_no") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function
Attribute VB_Name = "Check_Request"
'@Folder("Checkers")
Option Explicit

' Checks one single cell
Public Sub checkRequest_cell(ByVal thisRow As Long, ByVal thisCol As Long)
    Dim note As String
    Dim highestLastRow As Long
    note = vbNullString

    If Request Is Nothing Then
        Set Request = New CRequest
    End If

    Request.validators.requestApplySpecificValidatorsRow _
        thisRow, _
        Request.channelTypeSet.uniqueType, _
        Request.channelTypeSet.uniqueSize, _
        Request.channelTypeSet.uniqueExtra, _
        Request.channelTypeSet.uniqueMaterialCoating
    
    highestLastRow = request_lastUsedCell
    Request.setToleranceMode = getToleranceMode(highestLastRow)
    
    With SheetRequest
        ' Ignore blank lines
        If .Range(Globals.REQUEST_COL_TYPE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_SIZE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_EXTRA & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_MATERIAL_COATING & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_CUTTING_TYPE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_LENGTH & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_QUANTITY & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_DEVIATING_TOLERANCE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & thisRow).value <> vbNullString _
        Then
            ' First check the column the user changed
            If column2Letter(thisCol) = Globals.REQUEST_COL_TYPE Then
                note = request_check_type(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_SIZE Then
                note = request_check_size(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_EXTRA Then
                note = request_check_extra(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_MATERIAL_COATING Then
                note = request_check_material_coating(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_CUTTING_TYPE Then
                note = request_check_cuttingType(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_LENGTH Then
                note = request_check_length(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_QUANTITY Then
                note = request_check_quantity(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_DEVIATING_TOLERANCE Then
                note = request_check_deviating_tolerance(thisRow)
            ElseIf column2Letter(thisCol) = Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH Then
                note = request_check_deviating_minimum_remaining_web_width(thisRow)
            End If
            
            ' Reset std tolerance
            .Range(Globals.REQUEST_COL_STD_TOLERANCE & thisRow).value = vbNullString

            ' If that did not result in an error, check the others
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_TYPE Then note = request_check_type(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_SIZE Then note = request_check_size(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_EXTRA Then note = request_check_extra(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_MATERIAL_COATING Then note = request_check_material_coating(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_CUTTING_TYPE Then note = request_check_cuttingType(thisRow)
            ' Check combination
            If note = vbNullString Then note = request_check_combination(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_LENGTH Then note = request_check_length(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_QUANTITY Then note = request_check_quantity(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_DEVIATING_TOLERANCE Then note = request_check_deviating_tolerance(thisRow)
            If note = vbNullString And Not column2Letter(thisCol) = Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH Then note = request_check_deviating_minimum_remaining_web_width(thisRow)
            
        Else
            ' Reset std tolerance for blank lines
            .Range(Globals.REQUEST_COL_STD_TOLERANCE & thisRow).value = vbNullString
        
        End If
        ' Set note string (done outside the if blank lines checker so that it will reset the note to nothing on blank lines)
        .Range(Globals.REQUEST_COL_ERROR & thisRow).value = note
    End With
End Sub

' Check a full row
Public Function checkRequest_row(ByVal thisRow As Long) As Boolean

    Request.validators.requestApplySpecificValidatorsRow _
        thisRow, _
        Request.channelTypeSet.uniqueType, _
        Request.channelTypeSet.uniqueSize, _
        Request.channelTypeSet.uniqueExtra, _
        Request.channelTypeSet.uniqueMaterialCoating
        
    Dim note As String
    note = vbNullString

    ' Ignore blank lines
    With SheetRequest
        If .Range(Globals.REQUEST_COL_TYPE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_SIZE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_EXTRA & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_MATERIAL_COATING & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_CUTTING_TYPE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_LENGTH & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_QUANTITY & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_DEVIATING_TOLERANCE & thisRow).value <> vbNullString _
            Or .Range(Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & thisRow).value <> vbNullString _
        Then
            ' If that did not result in an error, check the others
            If note = vbNullString Then note = request_check_type(thisRow)
            If note = vbNullString Then note = request_check_size(thisRow)
            If note = vbNullString Then note = request_check_extra(thisRow)
            If note = vbNullString Then note = request_check_material_coating(thisRow)
            If note = vbNullString Then note = request_check_cuttingType(thisRow)
            If note = vbNullString Then note = request_check_combination(thisRow)
            If note = vbNullString Then note = request_check_length(thisRow)
            If note = vbNullString Then note = request_check_quantity(thisRow)
            If note = vbNullString Then note = request_check_deviating_tolerance(thisRow)
            If note = vbNullString Then note = request_check_deviating_minimum_remaining_web_width(thisRow)
           
            ' Set note string
            .Range(Globals.REQUEST_COL_ERROR & thisRow).value = note
        Else
            ' Reset std tolerance
            .Range(Globals.REQUEST_COL_STD_TOLERANCE & thisRow).value = vbNullString
        End If
    End With

    ' Return status depending on if there is a error message
    '@Ignore BooleanAssignedInIfElse
    If note = vbNullString Then
        checkRequest_row = True
    Else
        checkRequest_row = False
    End If
End Function

' Returns true if there is no error, otherwise false
Public Function checkRequest_all() As Boolean
    
    Dim highestLastRow As Long
    checkRequest_all = True
    highestLastRow = request_lastUsedCell
    ' Sanity check
    If highestLastRow >= Globals.REQUEST_ROW_FIRST Then
    
        ' Figure out tolerance mode by reading all cuttingTypes
        Request.setToleranceMode = getToleranceMode(highestLastRow)
        
        ' Start at the first line and loop through all used lines
        Dim i As Long
        For i = Globals.REQUEST_ROW_FIRST To highestLastRow
            If Not checkRequest_row(i) Then
                checkRequest_all = False
            End If
        Next
    End If
    
    ' applyVaildators
End Function

Private Function getToleranceMode(ByVal highestLastRow As Long) As enumToleranceMode
    ' Figure out tolerance mode
    ' Reset mode
    getToleranceMode = enumToleranceMode.modeNotSet
    Dim i As Long
    Dim cuttingTypeString As String
    Dim cuttingType As enumCuttingType
    For i = Globals.REQUEST_ROW_FIRST To highestLastRow
        cuttingTypeString = SheetRequest.Range(Globals.REQUEST_COL_CUTTING_TYPE & i).value
        cuttingType = stringToCuttingType(cuttingTypeString)
        ' Break on first defining cuttingType found
        If cuttingType = enumCuttingType.B1 Or cuttingType = enumCuttingType.C1 Then
            getToleranceMode = enumToleranceMode.withTolerances
            Exit For
        ElseIf cuttingType = enumCuttingType.B2 Or cuttingType = enumCuttingType.c2 Then
            getToleranceMode = enumToleranceMode.withoutTolerances
            Exit For
        End If
    Next
End Function

'' Checkers for indivudual columns
' Takes a row and checks the specific column for errors according to it's
' special requirements. Returns a string on error.

' Makes sure that type is valid and enabled
Public Function request_check_type(ByVal affectedRow As Long) As String

    Dim foundMatch As Boolean
    Dim foundEnabledMatch As Boolean
    foundMatch = False
    foundEnabledMatch = False

    Dim lastRow As Long
    Dim i As Long
    Dim chTypeKey As String
    Dim chTypeKeyArr As Variant

    Dim value As String
    value = SheetRequest.Range(Globals.REQUEST_COL_TYPE & affectedRow).value
    request_check_type = vbNullString

    If value = vbNullString Then
        request_check_type = "Type " & Translate("error_is_missing")
    Else
        ' Check if it matches a type
        lastRow = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_TYPE & Settings.sheetChannelTypes.Rows.count).End(xlUp).Row
        If lastRow > Globals.CHTYPE_ROW_FIRST Then
            For i = Globals.CHTYPE_ROW_FIRST To lastRow
                chTypeKey = Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_TYPE & i).value
                If Not chTypeKey = vbNullString Then
                    chTypeKeyArr = Split(chTypeKey, "-")
                    ' Check if the type matches
                    If value = chTypeKeyArr(0) Then
                        foundMatch = True
                        ' Check if it is enabled
                        If Settings.sheetChannelTypes.Range(Globals.CHTYPE_COL_ENABLED & i).value = 1 Then
                            foundEnabledMatch = True
                            Exit For
                        End If
                    End If
                End If
            Next
            If foundMatch Then
                If Not foundEnabledMatch Then
                   request_check_type = Translate("error_this_type_is_disabled")
                'Else
                    ' Ok
                End If
            Else
                request_check_type = Translate("error_this_type_is_not_defined")
            End If
        Else
            request_check_type = Translate("error_no_channel_types_defined")
        End If
    End If
End Function


' Makes sure that size is valid for this type
Public Function request_check_size(ByVal affectedRow As Long) As String
    Dim ctype As String
    Dim size As String
    Dim extra  As String
    Dim materialCoating As String
    Dim cuttingType As String

    size = SheetRequest.Range(Globals.REQUEST_COL_SIZE & affectedRow).value
    ctype = SheetRequest.Range(Globals.REQUEST_COL_TYPE & affectedRow).value
    extra = vbNullString              ' Extra, material, cuttingType is ignored as types are checked hirearcically
    materialCoating = vbNullString
    cuttingType = vbNullString
    
    request_check_size = vbNullString
    
    If size = vbNullString Then
        request_check_size = _
            Translate("tbl_size") & " " & _
            Translate("error_is_missing")
    ElseIf Not Request.channelTypeSet.isValidType( _
            ctype:=ctype, _
            size:=size, _
            extra:=extra, _
            materialCoating:=materialCoating, _
            cuttingType:=cuttingType, _
            matchStrict:=vbNullString _
        ) _
    Then
        request_check_size = _
            Translate("tbl_size") & " " & _
            Translate("error_is_not_valid_for_this_type")
    'Else
        ' Ok
    End If
End Function


' Makes sure that extra is valid for this type with this size
Public Function request_check_extra(ByVal affectedRow As Long) As String
    Dim ctype As String
    Dim size As String
    Dim extra  As String
    Dim materialCoating As String
    Dim cuttingType As String

    size = SheetRequest.Range(Globals.REQUEST_COL_SIZE & affectedRow).value
    ctype = SheetRequest.Range(Globals.REQUEST_COL_TYPE & affectedRow).value
    extra = SheetRequest.Range(Globals.REQUEST_COL_EXTRA & affectedRow).value
    materialCoating = vbNullString        ' Material, cuttingType is ignored as types are checked hirearcically
    cuttingType = vbNullString
    
    request_check_extra = vbNullString
    
    If Not Request.channelTypeSet.isValidType( _
        ctype:=ctype, _
        size:=size, _
        extra:=extra, _
        materialCoating:=materialCoating, _
        cuttingType:=cuttingType, _
        matchStrict:="extra" _
    ) Then
        request_check_extra = _
            Translate("tbl_extra") & " " & _
            Translate("error_is_not_valid_for_this_type")
    'Else
        ' Ok
    End If
End Function


' Makes sure that material/coating is valid for this type with this size and this extra
Public Function request_check_material_coating(ByVal affectedRow As Long) As String
    Dim ctype As String
    Dim size As String
    Dim extra  As String
    Dim materialCoating As String
    Dim cuttingType As String

    size = SheetRequest.Range(Globals.REQUEST_COL_SIZE & affectedRow).value
    ctype = SheetRequest.Range(Globals.REQUEST_COL_TYPE & affectedRow).value
    extra = SheetRequest.Range(Globals.REQUEST_COL_EXTRA & affectedRow).value
    materialCoating = SheetRequest.Range(Globals.REQUEST_COL_MATERIAL_COATING & affectedRow).value
    cuttingType = vbNullString            ' cuttingType is ignored as types are checked hirearcically
    
    request_check_material_coating = vbNullString
    
    If materialCoating = vbNullString Then
        request_check_material_coating = _
            Translate("tbl_material_coating") & " " & _
            Translate("error_is_missing")
    ElseIf Not Request.channelTypeSet.isValidType( _
        ctype:=ctype, _
        size:=size, _
        extra:=extra, _
        materialCoating:=materialCoating, _
        cuttingType:=cuttingType, _
        matchStrict:="material" _
    ) Then
        request_check_material_coating = _
            Translate("tbl_material_coating") & " " & _
            Translate("error_is_not_valid_for_this_type")
    'Else
        ' Ok
    End If
End Function


' Makes sure combination is valid and enabled
Public Function request_check_combination(ByVal affectedRow As Long) As String

    Dim ctype As String
    Dim size As String
    Dim extra As String
    Dim material_coating As String
    Dim channelType As String
    
    ctype = SheetRequest.Range(Globals.REQUEST_COL_TYPE & affectedRow).value
    size = SheetRequest.Range(Globals.REQUEST_COL_SIZE & affectedRow).value
    extra = SheetRequest.Range(Globals.REQUEST_COL_EXTRA & affectedRow).value
    material_coating = SheetRequest.Range(Globals.REQUEST_COL_MATERIAL_COATING & affectedRow).value
    request_check_combination = vbNullString
    
    channelType = ctype & "-" & size
    If Not extra = vbNullString Then
        channelType = channelType & "+" & extra
    End If
    If Not material_coating = vbNullString Then
        channelType = channelType & "-" & material_coating
    End If
     
    If Request.channelTypeSet.typeExists(channelType) Then
        ' OK, type exists, show tolerance
        printHiltiStdTolerance channelType, affectedRow
    Else
        request_check_combination = _
            Translate("error_invalid_combination_of") & " " & _
            Translate("tbl_type") & "/" & _
            Translate("tbl_size") & "/" & _
            Translate("tbl_extra") & "/" & _
            Translate("tbl_material") & "/" & _
            Translate("tbl_cutting_type")
    End If
End Function

' Displays the value of the hilti standard tolerance that is set for this row
Public Sub printHiltiStdTolerance(ByVal channelType As String, ByVal affectedRow As Long)
    Dim length As Long
    Dim cuttingTypeString As String
    Dim hilti_std_tolerance As Double
    'Dim setDefaultToleranceDbl As Double
    'setDefaultToleranceDbl = Settings.defaultTolerance
    length = toBaseUnit(SheetRequest.Range(Globals.REQUEST_COL_LENGTH & affectedRow).value)
    cuttingTypeString = SheetRequest.Range(Globals.REQUEST_COL_CUTTING_TYPE & affectedRow).value
    hilti_std_tolerance = _
        toDisplayUnitDouble(Request.channelTypeSet.getChTypeFromKey(channelType).getHiltiStdTolerance(length))
    
    ' Only use variable tolerance if cuttingType is set to B1,B2 or C1,C2
    If cuttingTypeString = "B1" Or cuttingTypeString = "B2" Or cuttingTypeString = "C1" Or cuttingTypeString = "C2" Then
        hilti_std_tolerance = _
            toDisplayUnit(Request.channelTypeSet.getChTypeFromKey(channelType).getHiltiStdTolerance(length))
    Else
        hilti_std_tolerance = toDisplayUnit(Settings.defaultTolerance)
    End If
    
    SheetRequest.Range(Globals.REQUEST_COL_STD_TOLERANCE & affectedRow).value = hilti_std_tolerance
End Sub


' Makes sure that quantity is a whole number larger than -1
Public Function request_check_quantity(ByVal affectedRow As Long) As String
    Dim value As String
    value = SheetRequest.Range(Globals.REQUEST_COL_QUANTITY & affectedRow).value
    request_check_quantity = vbNullString
    If value = vbNullString Then
        request_check_quantity = _
            Translate("tbl_quantity") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            request_check_quantity = _
                Translate("tbl_quantity") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            request_check_quantity = _
                Translate("tbl_quantity") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            request_check_quantity = _
                Translate("tbl_quantity") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        request_check_quantity = _
            Translate("tbl_quantity") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that length is a whole number larger than 0
' Also checks that length is longer than minimum length
' TODO add check that checks for cuttingType validity here
Public Function request_check_length(ByVal affectedRow As Long) As String
    Dim value As String
    value = SheetRequest.Range(Globals.REQUEST_COL_LENGTH & affectedRow).value
    request_check_length = vbNullString
    If value = vbNullString Then
        request_check_length = _
            Translate("tbl_length") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            request_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            request_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_is_below_0")
        ElseIf value = 0 Then
            request_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_is_0")
        ElseIf InStr(1, value, ".") > 0 Then
            request_check_length = _
                Translate("tbl_length") & " " & _
                Translate("error_error_contains_a_dot")
        Else

            ' Length is a whole number
            ' Check if a valid type is specified:
            Dim length As Long
            Dim channelType As String
            Dim ctype As String
            Dim size As String
            Dim extra As String
            Dim material_coating As String
            Dim cuttingTypeString As String
            Dim deviating_tolerance As String
            Dim deviating_minimum_remaining_web_width As String
            Dim deviating_minimum_remaining_web_width_long As Long
            Dim cuttingType As enumCuttingType
            Dim tolerance As Long
            ctype = SheetRequest.Range(Globals.REQUEST_COL_TYPE & affectedRow).value
            size = SheetRequest.Range(Globals.REQUEST_COL_SIZE & affectedRow).value
            extra = SheetRequest.Range(Globals.REQUEST_COL_EXTRA & affectedRow).value
            material_coating = SheetRequest.Range(Globals.REQUEST_COL_MATERIAL_COATING & affectedRow).value
            cuttingTypeString = SheetRequest.Range(Globals.REQUEST_COL_CUTTING_TYPE & affectedRow).value
            deviating_tolerance = SheetRequest.Range(Globals.REQUEST_COL_DEVIATING_TOLERANCE & affectedRow).value
            deviating_minimum_remaining_web_width = _
                SheetRequest.Range(Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & affectedRow).value
            
            channelType = ctype & "-" & size
            If Not extra = vbNullString Then
                channelType = channelType & "+" & extra
            End If
            If Not material_coating = vbNullString Then
                channelType = channelType & "-" & material_coating
            End If
             
            If Request.channelTypeSet.typeExists(channelType) Then
                ' type exists, check if the length is valid
                '@Ignore AssignmentNotUsed
                length = value               ' Convert to long
                'Logger.logInfo "length (before conversion): " & length
                length = toBaseUnit(length)   ' Convert to base unit
                'Logger.logInfo "length (after conversion): " & length
                    
                cuttingType = stringToCuttingType(cuttingTypeString)

                ' Minumum remainging web, check if it is usable:
                deviating_minimum_remaining_web_width_long = 0

                If deviating_minimum_remaining_web_width = vbNullString Then
                    deviating_minimum_remaining_web_width_long = -1
                ElseIf IsNumeric(value) Then
                    If Not Int(value) = value Then
                        deviating_minimum_remaining_web_width_long = -1
                    ElseIf value < 0 Then
                        deviating_minimum_remaining_web_width_long = -1
                    ElseIf value = 0 Then
                        deviating_minimum_remaining_web_width_long = -1
                    ElseIf InStr(1, value, ".") > 0 Then
                        deviating_minimum_remaining_web_width_long = -1
                    End If
                End If

                If Not deviating_minimum_remaining_web_width_long = -1 Then
                    ' Convert to long
                    '@Ignore AssignmentNotUsed
                    deviating_minimum_remaining_web_width_long = deviating_minimum_remaining_web_width
                    ' Convert to base unit
                    deviating_minimum_remaining_web_width_long = toBaseUnit(deviating_minimum_remaining_web_width_long)
                    If deviating_minimum_remaining_web_width_long < 0 Then
                        deviating_minimum_remaining_web_width_long = -1
                    End If
                End If
    
                ' If deviating min. rem. web. is set, then use this for generating cutminmax
                If Not Settings.toleranceDisabled Then
                    Request.channelTypeSet.getChTypeFromKey(channelType).generateCutPositions _
                        deviating_minimum_remaining_web_width_long
                    Request.channelTypeSet.getChTypeFromKey(channelType).genreateValidLengthsC1
                Else
                    Request.channelTypeSet.getChTypeFromKey(channelType).generateCutMarks
                    Request.channelTypeSet.getChTypeFromKey(channelType).genreateValidLengthsC1
                End If
                
                If deviating_tolerance = vbNullString Or Not IsNumeric(deviating_tolerance) Then
                    tolerance = Request.channelTypeSet.getChTypeFromKey(channelType).getHiltiStdTolerance(length)
                Else
                    tolerance = toBaseUnit(CLng(deviating_tolerance))
                End If

                ' Set cutwidth depending on tolerance mode (for disabled tolerance cutwidth = 0)
                Dim cutWidth As Long
                cutWidth = Settings.maximumCuttingWidth
                If Settings.toleranceDisabled Then
                    cutWidth = 0
                End If

                ' Report the result of this check
                request_check_length = Request.channelTypeSet.getChTypeFromKey(channelType).isValidHPRLength( _
                    length, _
                    cuttingType, _
                    cutWidth, _
                    tolerance _
                )
            End If

        End If
    ElseIf Not IsNumeric(value) Then
        request_check_length = _
            Translate("tbl_length") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Checks that cuttingType is one of A, B1, B2, C1, C2
' Also checks that cuttingType is enabled for this type
Public Function request_check_cuttingType(ByVal affectedRow As Long) As String
    Dim cuttingTypeString As String
    Dim cuttingType As enumCuttingType
    cuttingTypeString = SheetRequest.Range(Globals.REQUEST_COL_CUTTING_TYPE & affectedRow).value
    request_check_cuttingType = vbNullString
    cuttingType = stringToCuttingType(cuttingTypeString)

    ' cuttingType missing
    If cuttingTypeString = vbNullString Then
        request_check_cuttingType = _
            Translate("tbl_cutting_type") & " " & _
            Translate("error_is_missing")

    ' cuttingType incorrect
    ElseIf cuttingType = enumCuttingType.typeNotSet Then
        request_check_cuttingType = _
            Translate("tbl_cutting_type") & " " & _
            Translate("error_has_to_be_one_of") & " " & _
            cuttingTypeToString(enumCuttingType.A) & ", " & _
            cuttingTypeToString(enumCuttingType.B1) & ", " & _
            cuttingTypeToString(enumCuttingType.B2) & ", " & _
            cuttingTypeToString(enumCuttingType.C1) & ", " & _
            cuttingTypeToString(enumCuttingType.c2)

    ' Check valid cuttingType combinations
    ElseIf ((cuttingType = enumCuttingType.B1 Or cuttingType = enumCuttingType.C1) And Request.getToleranceMode = enumToleranceMode.withoutTolerances) Or _
           ((cuttingType = enumCuttingType.B2 Or cuttingType = enumCuttingType.c2) And Request.getToleranceMode = enumToleranceMode.withTolerances) _
    Then
        ' TODO Translate
        request_check_cuttingType = _
            "You can not mix " & _
            cuttingTypeToString(enumCuttingType.B1) & "/" & _
            cuttingTypeToString(enumCuttingType.C1) & " with " & _
            cuttingTypeToString(enumCuttingType.B2) & "/" & _
            cuttingTypeToString(enumCuttingType.c2) & _
            " in the same request"

    ' For B1,B2 or C1,C2 check if cuttingType is enabled for the type given by the SAP number
    ElseIf Not cuttingType = enumCuttingType.A Then
        ' Lookup HPR enabled
        Dim HPRenabled As Long
        Dim thisChType As String
        Dim lastRow As Long
        Dim i As Long
        Dim technicalDataRow As Long
        Dim foundMatch As Boolean

        thisChType = SheetRequest.Range(Globals.REQUEST_COL_TYPE & affectedRow).value

        With Settings.sheetTechnicalData
            ' Only try to look it up if a channel type has actually been recognized
            ' Perhaps better would be to go through the SAP number lookup, otherwise the order would matter...
            If Not thisChType = vbNullString Then
                HPRenabled = 0
                lastRow = .Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & .Rows.count).End(xlUp).Row
                If lastRow > Globals.TECHNICAL_DATA_ROW_FIRST Then
                    For i = Globals.TECHNICAL_DATA_ROW_FIRST To lastRow
                        If thisChType = .Range(Globals.TECHNICAL_DATA_COL_TYPE & i).value Then
                            foundMatch = True
                            technicalDataRow = i
                            Exit For
                        End If
                    Next
                    If foundMatch Then
                        HPRenabled = .Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & technicalDataRow).value
                        If HPRenabled <> 1 Then
                            request_check_cuttingType = Translate("error_hpr_is_not_supported_for_this_type")
                        'Else
                            ' Ok
                        End If
                    End If
                End If
            End If
        End With
    End If
End Function

' Checkes that customer tolerance is a whole number larger than -1
Public Function request_check_deviating_tolerance(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.REQUEST_COL_DEVIATING_TOLERANCE & affectedRow).value
    request_check_deviating_tolerance = vbNullString
    If value = vbNullString Then
        ' No customer tolerance override is OK
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            request_check_deviating_tolerance = _
                Translate("tbl_deviating_tolerance") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            request_check_deviating_tolerance = _
                Translate("tbl_deviating_tolerance") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            request_check_deviating_tolerance = _
                Translate("tbl_deviating_tolerance") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        request_check_deviating_tolerance = _
            Translate("tbl_deviating_tolerance") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Checkes that customer tolerance is a whole number larger than -1
Public Function request_check_deviating_minimum_remaining_web_width(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range( _
        Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & _
        affectedRow _
    ).value
    request_check_deviating_minimum_remaining_web_width = vbNullString
    If value = vbNullString Then
        ' No customer override is OK
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            request_check_deviating_minimum_remaining_web_width = _
                Translate("tbl_deviating_min_rem_web") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            request_check_deviating_minimum_remaining_web_width = _
                Translate("tbl_deviating_min_rem_web") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            request_check_deviating_minimum_remaining_web_width = _
                Translate("tbl_deviating_min_rem_web") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        request_check_deviating_minimum_remaining_web_width = _
            Translate("tbl_deviating_min_rem_web") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


Public Function request_lastUsedCell() As Long
    Dim lastRow As Long
    Dim highestLastRow As Long
    
    With SheetRequest
        ' Look at all columns and find the highest row that contains any data
        highestLastRow = .Range(Globals.REQUEST_COL_TYPE & .Rows.count).End(xlUp).Row    ' No need for checking on the first one
        lastRow = .Range(Globals.REQUEST_COL_SIZE & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_EXTRA & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_MATERIAL_COATING & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_LENGTH & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_QUANTITY & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_CUTTING_TYPE & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_DEVIATING_TOLERANCE & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_STD_TOLERANCE & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.REQUEST_COL_ERROR & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
    End With
    request_lastUsedCell = highestLastRow
End Function












Attribute VB_Name = "Check_RootChType"
'@Folder("Checkers")
Option Explicit

Public Sub checkTechnicalData_cell(ByVal thisRow As Long, ByVal thisCol As Long)
    Dim note As String
    note = vbNullString

    With Settings.sheetTechnicalData
        ' Ignore blank lines
        If .Range(Globals.TECHNICAL_DATA_COL_TYPE & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_WEB_WIDTH & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_START_POSITION_ERROR & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_POSITION_ERROR & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS & thisRow).value <> vbNullString _
            Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS & thisRow).value <> vbNullString _
        Then

            ' First check the column the user changed
            If column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_TYPE Then
                note = technical_data_check_chtype(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH Then
                note = technical_data_check_mimimum_item_length(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 Then
                note = technical_data_check_hilti_standard_tolerance1(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 Then
                note = technical_data_check_hilti_standard_tolerance2(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 Then
                note = technical_data_check_hilti_standard_tolerance3(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 Then
                note = technical_data_check_hilti_standard_tolerance4(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 Then
                note = technical_data_check_hilti_standard_tolerance5(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 Then
                note = technical_data_check_hilti_standard_tolerance6(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HPR_ENABLED Then
                note = technical_data_check_hpr_enabled(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HOLE_LENGTH Then
                note = technical_data_check_hole_length(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_WEB_WIDTH Then
                note = technical_data_check_web_width(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT Then
                note = technical_data_check_first_web_width_cut(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR Then
                note = technical_data_check_first_web_width_shear(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH Then
                note = technical_data_check_minimum_remaining_web_width(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_START_POSITION_ERROR Then
                note = technical_data_check_start_position_error(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HOLE_POSITION_ERROR Then
                note = technical_data_check_hole_position_error(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS Then
                note = technical_data_check_hole_length_error_plus(thisRow)
            ElseIf column2Letter(thisCol) = Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS Then
                note = technical_data_check_hole_length_error_minus(thisRow)
            End If

            ' If that did not result in an error, check the others
            If note = vbNullString Then note = technical_data_check_chtype(thisRow)
            If note = vbNullString Then note = technical_data_check_mimimum_item_length(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance1(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance2(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance3(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance4(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance5(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance6(thisRow)
            If note = vbNullString Then note = technical_data_check_hpr_enabled(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_length(thisRow)
            If note = vbNullString Then note = technical_data_check_web_width(thisRow)
            If note = vbNullString Then note = technical_data_check_first_web_width_cut(thisRow)
            If note = vbNullString Then note = technical_data_check_first_web_width_shear(thisRow)
            If note = vbNullString Then note = technical_data_check_minimum_remaining_web_width(thisRow)
            If note = vbNullString Then note = technical_data_check_start_position_error(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_position_error(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_length_error_plus(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_length_error_minus(thisRow)
            
        End If
        ' Set note string (done outside the if blank lines checker so that it will reset the note to nothing on blank lines)
        .Range(Globals.TECHNICAL_DATA_COL_ERROR & thisRow).value = note
    End With
End Sub


Public Function checkTechnicalData_row(ByVal thisRow As Long) As Boolean

    Dim note As String
    note = vbNullString

    ' Ignore blank lines
    With Settings.sheetTechnicalData
    
        ' Clear any previous error
        .Range(Globals.TECHNICAL_DATA_COL_ERROR & thisRow).value = vbNullString

        ' Ignore blank lines
        If .Range(Globals.TECHNICAL_DATA_COL_TYPE & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_WEB_WIDTH & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_START_POSITION_ERROR & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_POSITION_ERROR & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS & thisRow).value <> vbNullString _
        Or .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS & thisRow).value <> vbNullString _
        Then
            ' If that did not result in an error, check the others
            If note = vbNullString Then note = technical_data_check_chtype(thisRow)
            If note = vbNullString Then note = technical_data_check_mimimum_item_length(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance1(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance2(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance3(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance4(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance5(thisRow)
            If note = vbNullString Then note = technical_data_check_hilti_standard_tolerance6(thisRow)
            If note = vbNullString Then note = technical_data_check_hpr_enabled(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_length(thisRow)
            If note = vbNullString Then note = technical_data_check_web_width(thisRow)
            If note = vbNullString Then note = technical_data_check_first_web_width_cut(thisRow)
            If note = vbNullString Then note = technical_data_check_first_web_width_shear(thisRow)
            If note = vbNullString Then note = technical_data_check_minimum_remaining_web_width(thisRow)
            If note = vbNullString Then note = technical_data_check_start_position_error(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_position_error(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_length_error_plus(thisRow)
            If note = vbNullString Then note = technical_data_check_hole_length_error_minus(thisRow)
            
            If note <> vbNullString Then
                Logger.logInfo "Error in " & Settings.sheetTechnicalData.name & " on line " & thisRow & ": " & note
            End If
            ' Set note string
            .Range(Globals.TECHNICAL_DATA_COL_ERROR & thisRow).value = note
        End If
    End With
    
    ' Return status depending on if there is a error message
    '@Ignore BooleanAssignedInIfElse
    If note = vbNullString Then
        checkTechnicalData_row = True
    Else
        checkTechnicalData_row = False
    End If
End Function


' Returns true if there is no error, otherwise false
Public Function checkTechnicalData_all() As Boolean
    
    Dim lastRow As Long
    Dim highestLastRow As Long
    
    checkTechnicalData_all = True

    With Settings.sheetTechnicalData
        ' Look at all columns and find the highest row that contains any data
        highestLastRow = .Range(Globals.TECHNICAL_DATA_COL_TYPE & .Rows.count).End(xlUp).Row    ' No need for checking on the first one
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_WEB_WIDTH & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_START_POSITION_ERROR & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HOLE_POSITION_ERROR & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
        lastRow = .Range(Globals.TECHNICAL_DATA_COL_ERROR & .Rows.count).End(xlUp).Row
        If lastRow > highestLastRow Then highestLastRow = lastRow
    End With

    ' Sanity check
    If highestLastRow >= Globals.TECHNICAL_DATA_ROW_FIRST Then
        ' Start at the first line and loop through all used lines
        Dim line As Long
        Dim appProxy As IApplication
        Set appProxy = New ApplicationProxy
        appProxy.disableWhileRunning
        For line = Globals.TECHNICAL_DATA_ROW_FIRST To highestLastRow
            If Not checkTechnicalData_row(line) Then
                checkTechnicalData_all = False
                Logger.logInfo "Error on " & Settings.sheetTechnicalData.name & " on line " & line
            End If
        Next
        appProxy.enableAfterRunning
    End If

End Function


'' Checkers for indivudual columns
' Takes a row and checks the specific column for errors according to it's
' special requirements. Returns a string on error.


' Makes sure that Channel type set to a unique value
Public Function technical_data_check_chtype(ByVal affectedRow As Long) As String
    Dim value As String
    Dim duplicate_found As Boolean
    Dim lastRow As Long
    Dim i As Long
    duplicate_found = False
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_TYPE & affectedRow).value
    technical_data_check_chtype = vbNullString

    ' Empty value check
    If value = vbNullString Then
        technical_data_check_chtype = _
            Translate("tbl_channel_type") & " " & _
            Translate("error_is_missing")
    Else
        ' Check for uniqueness
        lastRow = Settings.sheetTechnicalData.Range( _
            Globals.TECHNICAL_DATA_COL_TYPE & _
            Settings.sheetTechnicalData.Rows.count _
        ).End(xlUp).Row
        If lastRow > Globals.TECHNICAL_DATA_ROW_FIRST Then
            For i = Globals.TECHNICAL_DATA_ROW_FIRST To lastRow
                If Not i = affectedRow _
                    And Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_TYPE & i).value = value _
                Then
                    duplicate_found = True
                End If
            Next
        End If
        
        If duplicate_found Then
            technical_data_check_chtype = _
                Translate("tbl_channel_type") & " " & _
                Translate("error_has_to_be_unique")
        'Else
            ' OK
        End If
    End If
End Function

' Makes sure that minimum item length is a whole number larger than -1
Public Function technical_data_check_mimimum_item_length(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH & affectedRow).value
    technical_data_check_mimimum_item_length = vbNullString
    If value = vbNullString Then
        technical_data_check_mimimum_item_length = _
            Translate("tbl_minimum item_length") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_mimimum_item_length = _
                Translate("tbl_minimum item_length") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_mimimum_item_length = _
                Translate("tbl_minimum item_length") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_mimimum_item_length = _
                Translate("tbl_minimum item_length") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_mimimum_item_length = _
            Translate("tbl_minimum item_length") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that Hilti standard tolerance is a whole number larger than -1
Public Function technical_data_check_hilti_standard_tolerance1(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 & affectedRow).value
    technical_data_check_hilti_standard_tolerance1 = vbNullString
    If value = vbNullString Then
        technical_data_check_hilti_standard_tolerance1 = _
            Translate("tbl_hilti_std_tol") & _
            " <=1m " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hilti_standard_tolerance1 = _
                Translate("tbl_hilti_std_tol") & _
                " <=1m " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hilti_standard_tolerance1 = _
                Translate("tbl_hilti_std_tol") & _
                " <=1m " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hilti_standard_tolerance1 = _
                Translate("tbl_hilti_std_tol") & _
                " <=1m " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hilti_standard_tolerance1 = _
            "Hilti std. tol. <=1m " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that Hilti standard tolerance is a whole number larger than -1
Public Function technical_data_check_hilti_standard_tolerance2(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 & affectedRow).value
    technical_data_check_hilti_standard_tolerance2 = vbNullString
    If value = vbNullString Then
        technical_data_check_hilti_standard_tolerance2 = _
            Translate("tbl_hilti_std_tol") & _
            " <=2m " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hilti_standard_tolerance2 = _
                Translate("tbl_hilti_std_tol") & _
                " <=2m " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hilti_standard_tolerance2 = _
                Translate("tbl_hilti_std_tol") & _
                " <=2m " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hilti_standard_tolerance2 = _
                Translate("tbl_hilti_std_tol") & _
                " <=2m " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hilti_standard_tolerance2 = _
            Translate("tbl_hilti_std_tol") & _
            " <=2m " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that Hilti standard tolerance is a whole number larger than -1
Public Function technical_data_check_hilti_standard_tolerance3(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range( _
        Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 & _
        affectedRow _
    ).value
    technical_data_check_hilti_standard_tolerance3 = vbNullString
    If value = vbNullString Then
        technical_data_check_hilti_standard_tolerance3 = _
            Translate("tbl_hilti_std_tol") & _
            " <=3m " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hilti_standard_tolerance3 = _
                Translate("tbl_hilti_std_tol") & _
                " <=3m " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hilti_standard_tolerance3 = _
                Translate("tbl_hilti_std_tol") & _
                " <=3m " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hilti_standard_tolerance3 = _
                Translate("tbl_hilti_std_tol") & _
                " <=3m " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hilti_standard_tolerance3 = Translate("tbl_hilti_std_tol") & _
                                                      " <=3m " & _
                                                      Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that Hilti standard tolerance is a whole number larger than -1
Public Function technical_data_check_hilti_standard_tolerance4(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range( _
        Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 & _
            affectedRow _
        ).value
    technical_data_check_hilti_standard_tolerance4 = vbNullString
    If value = vbNullString Then
        technical_data_check_hilti_standard_tolerance4 = _
            Translate("tbl_hilti_std_tol") & _
            " <=4m " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hilti_standard_tolerance4 = _
                Translate("tbl_hilti_std_tol") & _
                " <=4m " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hilti_standard_tolerance4 = _
                Translate("tbl_hilti_std_tol") & _
                " <=4m " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hilti_standard_tolerance4 = _
                Translate("tbl_hilti_std_tol") & _
                " <=4m " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hilti_standard_tolerance4 = _
            Translate("tbl_hilti_std_tol") & _
            " <=4m " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that Hilti standard tolerance is a whole number larger than -1
Public Function technical_data_check_hilti_standard_tolerance5(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range( _
        Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 & _
        affectedRow _
    ).value
    technical_data_check_hilti_standard_tolerance5 = vbNullString
    If value = vbNullString Then
        technical_data_check_hilti_standard_tolerance5 = _
            Translate("tbl_hilti_std_tol") & _
            " <=5m " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hilti_standard_tolerance5 = _
                Translate("tbl_hilti_std_tol") & _
                " <=5m " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hilti_standard_tolerance5 = _
                Translate("tbl_hilti_std_tol") & _
                " <=5m " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hilti_standard_tolerance5 = _
                Translate("tbl_hilti_std_tol") & _
                " <=5m " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hilti_standard_tolerance5 = _
            Translate("tbl_hilti_std_tol") & _
            " <5m " & _
            Translate("error_is_not_a_number")
    End If
End Function

' Makes sure that Hilti standard tolerance is a whole number larger than -1
Public Function technical_data_check_hilti_standard_tolerance6(ByVal affectedRow As Long) As String

    ' Only check this one if we are working with MM
    If Settings.unit = Globals.UNIT_MM Then
        Dim value As String
        value = Settings.sheetTechnicalData.Range( _
            Globals.TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 & _
                affectedRow _
        ).value
        technical_data_check_hilti_standard_tolerance6 = vbNullString
        If value = vbNullString Then
            technical_data_check_hilti_standard_tolerance6 = _
                Translate("tbl_hilti_std_tol") & _
                " >5m " & _
                Translate("error_is_missing")
        ElseIf IsNumeric(value) Then
            If Not Int(value) = value Then
                technical_data_check_hilti_standard_tolerance6 = _
                    Translate("tbl_hilti_std_tol") & _
                    " >5m " & _
                    Translate("error_cannot_be_decimal")
            ElseIf value < 0 Then
                technical_data_check_hilti_standard_tolerance6 = _
                    Translate("tbl_hilti_std_tol") & _
                    " >5m " & _
                    Translate("error_is_below_0")
            ElseIf InStr(1, value, ".") > 0 Then
                technical_data_check_hilti_standard_tolerance6 = _
                    Translate("tbl_hilti_std_tol") & _
                    " >5m " & _
                    Translate("error_error_contains_a_dot")
            'Else
                ' OK
            End If
        ElseIf Not IsNumeric(value) Then
            technical_data_check_hilti_standard_tolerance6 = _
                Translate("tbl_hilti_std_tol") & _
                " tol. >5m " & _
                Translate("error_is_not_a_number")
        End If
    End If
End Function

' Makes sure that HPR enabled is either 1 or 0:
Public Function technical_data_check_hpr_enabled(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value
    technical_data_check_hpr_enabled = vbNullString
    If Not value = "0" And Not value = "1" Then
         technical_data_check_hpr_enabled = _
            Translate("tbl_hpr_enabled") & " " & _
            Translate("error_has_to_be_1_or_0")
     'Else
        ' OK
    End If
End Function


' Makes sure that hole length is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_hole_length(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH & affectedRow).value
    technical_data_check_hole_length = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_hole_length = _
                Translate("tbl_hole_length") & " " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hole_length = _
                Translate("tbl_hole_length") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hole_length = _
                Translate("tbl_hole_length") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hole_length = _
                Translate("tbl_hole_length") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hole_length = _
            Translate("tbl_hole_length") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that web width is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_web_width(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_WEB_WIDTH & affectedRow).value
    technical_data_check_web_width = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_web_width = _
                Translate("tbl_web_width") & " " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_web_width = _
                Translate("tbl_web_width") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_web_width = _
                Translate("tbl_web_width") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_web_width = _
                Translate("tbl_web_width") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_web_width = _
            Translate("tbl_web_width") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function



' Makes sure that first web width cut is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_first_web_width_cut(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT & affectedRow).value
    technical_data_check_first_web_width_cut = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_first_web_width_cut = _
                Translate("tbl_first_web_width_cut") & " " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_first_web_width_cut = _
                Translate("tbl_first_web_width_cut") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_first_web_width_cut = _
                Translate("tbl_first_web_width_cut") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_first_web_width_cut = _
                Translate("tbl_first_web_width_cut") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_first_web_width_cut = _
            Translate("tbl_first_web_width_cut") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that first web width shear is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_first_web_width_shear(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR & affectedRow).value
    technical_data_check_first_web_width_shear = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_first_web_width_shear = _
                Translate("tbl_first_web_width_shear") & " " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_first_web_width_shear = _
                Translate("tbl_first_web_width_shear") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_first_web_width_shear = _
                Translate("tbl_first_web_width_shear") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_first_web_width_shear = _
                Translate("tbl_first_web_width_shear") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_first_web_width_shear = _
            Translate("tbl_first_web_width_shear") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that minimum remaining web width is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_minimum_remaining_web_width(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH & affectedRow).value
    technical_data_check_minimum_remaining_web_width = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_minimum_remaining_web_width = _
                Translate("tbl_min_remaining_web_width") & " " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_minimum_remaining_web_width = _
                Translate("tbl_min_remaining_web_width") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_minimum_remaining_web_width = _
                Translate("tbl_min_remaining_web_width") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_minimum_remaining_web_width = _
                Translate("tbl_min_remaining_web_width") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_minimum_remaining_web_width = _
            Translate("tbl_min_remaining_web_width") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that start position error is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_start_position_error(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_START_POSITION_ERROR & affectedRow).value
    technical_data_check_start_position_error = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_start_position_error = _
                Translate("tbl_start_position_error") & " " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_start_position_error = _
                Translate("tbl_start_position_error") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_start_position_error = _
                Translate("tbl_start_position_error") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_start_position_error = _
                Translate("tbl_start_position_error") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_start_position_error = _
            Translate("tbl_start_position_error") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that hole position error is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_hole_position_error(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HOLE_POSITION_ERROR & affectedRow).value
    technical_data_check_hole_position_error = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_hole_position_error = _
                Translate("tbl_hole_position_error") & " " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hole_position_error = _
                Translate("tbl_hole_position_error") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hole_position_error = _
                Translate("tbl_hole_position_error") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hole_position_error = _
                Translate("tbl_hole_position_error") & " " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hole_position_error = _
            Translate("tbl_hole_position_error") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that hole size error plus is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_hole_length_error_plus(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS & affectedRow).value
    technical_data_check_hole_length_error_plus = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_hole_length_error_plus = _
                Translate("tbl_hole_length_error") & " [+] " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hole_length_error_plus = _
                Translate("tbl_hole_length_error") & " [+] " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hole_length_error_plus = _
                Translate("tbl_hole_length_error") & " [+] " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hole_length_error_plus = _
                Translate("tbl_hole_length_error") & " [+] " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hole_length_error_plus = _
            Translate("tbl_hole_length_error") & " [+] " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that hole size error minus is a whole number larger than -1
' But only checks it if HPR is enabled
Public Function technical_data_check_hole_length_error_minus(ByVal affectedRow As Long) As String
    Dim value As String
    value = Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS & affectedRow).value
    technical_data_check_hole_length_error_minus = vbNullString
    If value = vbNullString Then
        If Settings.sheetTechnicalData.Range(Globals.TECHNICAL_DATA_COL_HPR_ENABLED & affectedRow).value = 1 Then
            technical_data_check_hole_length_error_minus = _
                Translate("tbl_hole_length_error") & " [-] " & _
                Translate("error_is_missing")
        End If
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            technical_data_check_hole_length_error_minus = _
                Translate("tbl_hole_length_error") & " [-] " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            technical_data_check_hole_length_error_minus = _
                Translate("tbl_hole_length_error") & " [-] " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            technical_data_check_hole_length_error_minus = _
                Translate("tbl_hole_length_error") & " [-] " & _
                Translate("error_error_contains_a_dot")
        'Else
            ' OK
        End If
    ElseIf Not IsNumeric(value) Then
        technical_data_check_hole_length_error_minus = _
            Translate("tbl_hole_length_error") & " [-] " & _
            Translate("error_is_not_a_number")
    End If
End Function
Attribute VB_Name = "EventHandlers"
'@Folder("Globals")
Option Explicit

Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

' Initialization function
' skipValidators skips validators (a slow operation) in order to run faster in tests
Public Sub initialize_tool(Optional ByVal skipValidators As Boolean = False)
    disableWorksheetFeaturesLevel = 0
    ensureGlobalObjectsExist skipValidators
End Sub

' Route button clicks
Public Sub generateRequestButton_Click()
    ' Don't disable, we will use the cell change feature
    Dim appProxy As IApplication
    Set appProxy = New ApplicationProxy
    
    appProxy.disableWhileRunning True
    ensureGlobalObjectsExist
    
    ' Clear any previous request
    Set Request = New CRequest
    Request.requestSheet.clearSheet
    
    ' Read channel types
    Request.readChannelTypesSheets
    
    ' Generate random request
    Request.requestSheet.generateRandom
    
    ' Be sure that what was generated passes, also generates Hilti Std. Tolerance
    checkRequest_all
    
    ' Apply validators
    Request.validators.applyVaildators
    
    ' Write two empty lines and close the logfile
    Logger.logInfo vbNullString
    Logger.logInfo vbNullString
    Logger.closeFile
    
    appProxy.enableAfterRunning True
End Sub

Public Sub checkRequestButton_Click()
    Dim appProxy As IApplication
    Set appProxy = New ApplicationProxy
    
    ensureGlobalObjectsExist
    
    ' Read channel types
    Request.readChannelTypesSheets
     
    ' Check reqest
    appProxy.disableWhileRunning True
    checkRequest_all
    appProxy.enableAfterRunning True
    
    ' Close the logfile
    Logger.closeFile

End Sub

Public Sub findSolutionButton_Click()
    Dim forceTabSwitch As Boolean
    Dim myProgressForm As ProgressForm
    Dim appProxy As IApplication
    
    Set appProxy = New ApplicationProxy
    Set myProgressForm = New ProgressForm
    forceTabSwitch = False
    
    ' Make sure the right sheet is active
    SheetRequest.Activate
    
    ' Set focus to the first item in the request
    SheetRequest.Range(Globals.REQUEST_COL_TYPE & Globals.REQUEST_ROW_FIRST).Select

    ensureGlobalObjectsExist
    
    'Initialize a New Instance of the ProgressForm
    
    ' Set up progressbar
    With myProgressForm
        .setTitle Translate("action_title_optimizing")
        .addAction Translate("action_checking_request")
        .addAction Translate("action_checking_channel_types")
        .addAction Translate("action_optimizing")
        .addAction Translate("action_writing_diagram_data")
        .addAction Translate("action_generating_output")
        .addAction Translate("action_creating_diagrams")
        .addAction Translate("action_done")
        ' TODO Make sure it works, then add it, in the meantime the user can (most of the time) click the X-button of the optimizer window to exit the optimizer
        ' For now, clicking the x in the corner works to close it
        '.AddCancelButton
    End With
    
    'Show the Bar
    myProgressForm.showBar
    myProgressForm.hideMainProgressBar
    myProgressForm.hideSubProgressBar
    myProgressForm.nextAction    ' Start it off with the first one
    
    ' Generate a new Request object
    Set Request = New CRequest
    
    ' Sort the table once before anything else is done
    appProxy.disableWhileRunning True
    Request.requestSheet.sort
    
    ' When sorting, vaildators could be wrong, so reapply them
    Request.validators.applyVaildators
    
    ' Check Technical Data for errors
    If Not checkTechnicalData_all Then
        ' As there is a error on this sheet, make it visible and activate it
        Settings.sheetTechnicalData.visible = xlSheetVisible
        Settings.sheetTechnicalData.Activate
    Else
        ' Check channel types for errors
        If Not checkChannelTypes_all Then
            ' As there is a error on this sheet, make it visible and activate it
            Settings.sheetChannelTypes.visible = xlSheetVisible
            Settings.sheetChannelTypes.Activate
        Else
        
            ' Read the channel types
            Request.readChannelTypesSheets
            
            ' Check the request, only continue if it is valid
            If Not checkRequest_all Then
                SheetRequest.Activate
            Else
            
                ' Checking Request
                ' Sleep for a second for the interface to become more stable
                Sleep 1000
                myProgressForm.nextAction
                Request.readRequestSheet
                
                ' Make sure this setting has been read:
                Settings.readOptimizationMode

                ' Cannot continue on empty requests
                If Not Request.isEmpty Then
                
                    ' Optimize
                    myProgressForm.nextAction
                    Request.optimize myProgressForm
                    
                    ' Write bin sheet
                    myProgressForm.nextAction
                    Request.outputSheets.clear
                    Request.outputSheets.writeProfileSheets
                    
                    ' Write pick and cut list
                    myProgressForm.nextAction
                    Request.writeOutputs
                    
'''JAGGU2Change: This will be done in Phase 2
''Call TranslateOneSheet(SheetOutputLists, "Output Lists")
                    
                    ' Create diagrams
                    myProgressForm.nextAction
                    myProgressForm.showMainProgressBar labelString:=vbNullString
                    myProgressForm.hideSubProgressBar
                    Request.diagrams.createDiagrams pgForm:=myProgressForm
                    Request.diagrams.diagramSheetPrintSetup
                    
                    ' Finnish
                    myProgressForm.hideMainProgressBar
                    myProgressForm.nextAction
                    SheetOutputLists.Activate

                    'forceTabSwitch = True
                Else
                    ' Go to done on error
                    myProgressForm.nextAction
                    myProgressForm.nextAction
                    myProgressForm.nextAction
                    myProgressForm.nextAction
                    myProgressForm.nextAction
                End If
            End If
        End If
    End If
    
    myProgressForm.complete 200
    Set myProgressForm = Nothing
    
    appProxy.enableAfterRunning True

    If forceTabSwitch Then
        Logger.logInfo "Waiting 5 seconds to switch tab..."
        Application.Wait 5
        Logger.logInfo "tab changed"
    End If
    
    ' Write two empty lines and close the logfile
    Logger.logInfo vbNullString
    Logger.logInfo vbNullString
    Logger.closeFile
    
    ' Clean up request to try to reclaim some memory
    Set Request = Nothing
End Sub

Public Sub waitFor(ByVal numOfSeconds As Long)
    Dim stopTime As Long
    stopTime = Timer + numOfSeconds
    Do While Timer < stopTime
        DoEvents
    Loop
End Sub

Public Sub checkTechnicalDataButton_Click()
    ensureGlobalObjectsExist
    checkTechnicalData_all
End Sub

Public Sub checkChTypeButton_Click()
    ensureGlobalObjectsExist
    checkChannelTypes_all
End Sub

Public Sub pdfExportButton_Click()
    ' Make sure that the user has entered customer no and order no
    
    If Not checkOutputLists_sap_customer_no _
    And Not checkOutputLists_sap_order_no Then
        SheetOutputLists.Activate
        ActiveSheet.Range(Globals.OUTPUTLISTS_HEADER_SAP_CUSTOMER_NO).Select
        MsgBox _
            Prompt:=Translate("pdf_error_missing_customerno_orderno"), _
            Buttons:=vbOKOnly, _
            title:=Translate("pdf_export_title")
    ElseIf Not checkOutputLists_sap_customer_no Then
        SheetOutputLists.Activate
        ActiveSheet.Range(Globals.OUTPUTLISTS_HEADER_SAP_CUSTOMER_NO).Select
        MsgBox _
            Prompt:=Translate("pdf_error_missing_customerno"), _
            Buttons:=vbOKOnly, _
            title:=Translate("pdf_export_title")
    ElseIf Not checkOutputLists_sap_order_no Then
        SheetOutputLists.Activate
        ActiveSheet.Range(Globals.OUTPUTLISTS_HEADER_SAP_ORDER_NO).Select
        MsgBox _
            Prompt:=Translate("pdf_error_missing_orderno"), _
            Buttons:=vbOKOnly, _
            title:=Translate("pdf_export_title")
    Else
        ensureGlobalObjectsExist
        Dim pdfExporter As CPDFExporter
        Set pdfExporter = New CPDFExporter
        pdfExporter.saveAsPdfDialog
    End If
End Sub


' Run when the button on the translations page is clicked
Public Sub applyTranslations_click()
    Dim appProxy As IApplication
    Set appProxy = New ApplicationProxy
    
    ensureGlobalObjectsExist
    
    ' Read the language setting if it is not set
    ' This seems to happen if the code has run into a problem, the value of this variable gets reset
    Settings.readLanguageSetting

    ' If this is the first time, make sure the translations has been read
    If Not Translation.translationsHasBeenRead = True Then
        Translation.readTranslations
    End If
    
    appProxy.disableWhileRunning True
    Translation.clearTranslations
    Translation.translateEverything
    appProxy.enableAfterRunning True
End Sub


' Run when the change unit button on the Settings sheet is clicked
Public Sub changeUnit_click()
    ensureGlobalObjectsExist
    
    ' Ask the user if they want to change this setting:
    If MsgBox(Translate("warning_reset_question"), _
        vbQuestion + vbYesNo, _
        Translate("warning_reset_question")) = vbYes Then
        Settings.ChangeUnit
    End If
End Sub

Attribute VB_Name = "Extra"
'@Folder("X-Extras")
Option Explicit

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


' Prepares the document for release
Public Sub prepareForRelease()
    Dim appProxy As IApplication
    Set appProxy = New ApplicationProxy

    appProxy.disableWhileRunning
    
    Set Settings = New CSettings
    Set Translation = New CTranslation
    Set Logger = New CLogger
    Set Request = New CRequest

    ' Hide all tabs that should not be shown
    SheetProfilesAll.visible = xlSheetHidden
    SheetRequestedAll.visible = xlSheetHidden
    SheetChannelTypesInch.visible = xlSheetHidden
    SheetCountries.visible = xlSheetHidden
    SheetImages.visible = xlSheetHidden
    SheetTechnicalDataInch.visible = xlSheetHidden
    SheetTechnicalDataMM.visible = xlSheetHidden
    SheetTranslations.visible = xlSheetHidden
    SheetProfilesUnique.visible = xlSheetHidden
    SheetRequestedUnique.visible = xlSheetHidden
    
    ' Make sure the ones that should be shown are shown:
    SheetChannelTypesMM.visible = xlSheetVisible

    Settings.setDefaults    ' Set default settings
    Settings.readAll        ' Read settings

    ' Clear sheets
    Request.requestSheet.clearSheet
    Request.outputSheets.clear
    Request.outputSheets.writeProfileSheets
        
    ' Read channel types
    Request.readChannelTypesSheets
    
    ' Be sure that what was generated passes, also generates Hilti Std. Tolerance
    checkRequest_all
    
    ' Apply validators
    Request.validators.applyVaildators

    appProxy.enableAfterRunning
End Sub

' End RubberDuck conditional compilation
#End If

Attribute VB_Name = "FrmLangSelection"
Attribute VB_Base = "0{DDC16985-A0D8-4363-BBF4-C25294325530}{05B03588-D348-440B-BEA9-7DAB6343217D}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub cmdCancel_Click()
Unload Me
End Sub

Private Sub cmdTranslate_Click()

Dim liSelectedLang As Integer

liSelectedLang = cmbLanguage.ListIndex + 1

Unload Me

'Execute the Translation
Call TranslateWorkbook(liSelectedLang)

End Sub



Private Sub UserForm_Activate()
 
Me.cmbLanguage.clear

Dim lsLang As Range
Dim ws As Worksheet
Set ws = Worksheets("Translations")

For Each lsLang In ws.Range("C21:K21")

  With Me.cmbLanguage
    .addItem lsLang.value
  End With
  If lsLang.value = nsMain.Range("B1") Then
        cmbLanguage.Text = nsMain.Range("B1")
  End If
Next lsLang



End Sub
Private Sub UserForm_Initialize()

'Center the Printer Form
Call CenterScreen(Me)

End Sub

Attribute VB_Name = "GenericSheetProxy"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit
Implements IGenericSheet

Public Sub IGenericSheet_setBackground(ByVal color As Long, ByVal Sheet As Worksheet)
    Sheet.Cells.Interior.color = color
End Sub

' Clear any previous chart on the specified sheet
Public Sub IGenericSheet_clearDiagrams(ByVal Sheet As Worksheet)
    Dim chart As Object
    For Each chart In Sheet.ChartObjects
        chart.Delete
    Next
End Sub

' Clear any previous shape on the specified sheet
Public Sub IGenericSheet_clearShapes(ByVal Sheet As Worksheet)
    Dim shapeNo As Long
    For shapeNo = 1 To Sheet.Shapes.count
        Sheet.Shapes(shapeNo).Delete
    Next
End Sub

Public Sub IGenericSheet_clearSheetDetele(ByVal Sheet As Worksheet)
    Sheet.Cells.Delete
End Sub

Public Sub IGenericSheet_deleteCells(ByVal Sheet As Worksheet)
    Sheet.Cells.Delete
End Sub

Public Sub IGenericSheet_clearFormats(ByVal Sheet As Worksheet)
    Sheet.Cells.clearFormats
End Sub

Public Sub IGenericSheet_renameSheet(ByVal Sheet As Worksheet, ByVal newName As String)
    Sheet.name = newName
End Sub

Public Sub IGenericSheet_setVisibility(ByVal Sheet As Worksheet, ByVal visible As Boolean)
    Sheet.visible = visible
End Sub

Public Sub IGenericSheet_setVisibilityByName(ByVal SheetName As String, ByVal visible As Boolean)
    ' Make sure that the sheet exists before trying to change visibility
    If IGenericSheet_worksheetExists(SheetName) Then
        IGenericSheet_setVisibility ThisWorkbook.Sheets(SheetName), visible
    Else
        Logger.logBug "Sheet named " & SheetName & " was expected but does not exist."
    End If
End Sub

'@Ignore FunctionReturnValueNotUsed
'Public Function IGenericSheet_getVisibility(ByVal sheet As Worksheet) As Boolean
'    IGenericSheet_getVisibility = sheet.visible
'End Function

Public Function IGenericSheet_getVisibilityByName(ByVal SheetName As String) As Boolean
    If IGenericSheet_worksheetExists(SheetName) Then
        IGenericSheet_getVisibilityByName = ThisWorkbook.Sheets(SheetName).visible
    Else
        IGenericSheet_getVisibilityByName = False
        Logger.logBug "Sheet named " & SheetName & " was expected but does not exist."
    End If
End Function

' Changes the text on a given button on a given sheet if the button exists.
' If the button does not exist, if just fails silently
Public Sub IGenericSheet_changeButtonText( _
    ByVal Sheet As Worksheet, _
    ByVal name As String, _
    ByVal newText As String _
)
    Dim shapeNo As Long
    For shapeNo = 1 To Sheet.Shapes.count
        If Sheet.Shapes(shapeNo).name = name Then
            Sheet.Shapes(shapeNo).OLEFormat.Object.Characters.Text = newText
            Exit For
        End If
    Next
End Sub

' Checks if a worksheet with the given name exists
Public Function IGenericSheet_worksheetExists(ByVal worksheetName As String) As Boolean
    IGenericSheet_worksheetExists = Evaluate("ISREF('" & worksheetName & "'!A1)")
End Function
Attribute VB_Name = "Globals"
'@Folder("Globals")
Option Explicit

' This module contains the project setup, a bunch of constants
' and "constant" variables that are used throghout the project.

Public Settings As CSettings
Public Translation As CTranslation
Public Request As CRequest
Public Logger As CLogger

Public circleDiagramStartRow As Long
Public disableWorksheetFeaturesLevel As Long              ' Initialized to zero
                                                          ' Increases for each disable that happens, only enables worksheet feature when it goes to zero
                                                          ' Related to disableWhileRunning and enableAfterRunning functions

' Constants
Public Const CONVERSION_FACTOR_MM As Long = 10                      ' Fundamental unit for mm based is 1/10 mm
Public Const CONVERSION_FACTOR_INCH As Long = 1                     ' Fundamental unit for inch based is 1/100 inch
Public Const CONVERSION_FACTOR_CURRENT_METER_MM As Long = 10000     ' Divide by this to convert 1 m to 1/10 mm
Public Const CONVERSION_FACTOR_CURRENT_METER_INCH As Long = 40000   ' Divide by this to convert 40 inch to 1/100 inch
Public Const CONVERSION_FACTOR_LONG_UNIT_MM As Long = 10000         ' Divide by this to convert 1 m to 1/10 mm
Public Const CONVERSION_FACTOR_LONG_UNIT_INCH As Long = 1200        ' Divide by this to convert 1 ft to 1/100 inch
Public Const FUNDAMENTAL_UNIT_MM As String = "1/10 mm"              ' TODO: Replace with translated version
Public Const FUNDAMENTAL_UNIT_INCH As String = "1/100"""
Public Const UNIT_MM As String = "Millimeter"
Public Const UNIT_INCH As String = "Inch"
Public Const MAXIMUM_PIECES_IN_DIAGRAM As Long = 255

' Settings
Public Const GENERATE_CUTAREAS_DEBUGMODE As Boolean = True

' Default settings
Public Const DEFAULT_MAXIMUM_CUTTING_WIDTH_MM As Long = 15      ' In 1/10 mm
Public Const DEFAULT_MAXIMUM_CUTTING_WIDTH_INCH As Long = 6     ' In 1/100 inch
Public Const DEFAULT_TOLERANCE_MM As Long = 2                   ' In 1/10 mm
Public Const DEFAULT_TOLERANCE_INCH As Long = 1                 ' In 1/100 inch
Public Const DEFAULT_CUT_FREE_SPACE_END_MM As Long = 3          ' In 1/10 mm
Public Const DEFAULT_CUT_FREE_SPACE_END_INCH As Long = 1        ' In 1/100 inch

Public Const DEFAULT_LANGUAGE As String = "English"
Public Const DEFAULT_MATERIAL_COUNTRY As String = "Germany"
Public Const DEFAULT_LOGGING As Boolean = False

' Default unit: mm
Public Const DEFAULT_UNIT As String = UNIT_MM
Public Const DEFAULT_CONVERSION_FACTOR As Long = CONVERSION_FACTOR_MM
Public Const DEFAULT_CONVERSION_FACTOR_CURRENT_METER As Long = CONVERSION_FACTOR_CURRENT_METER_MM
Public Const DEFAULT_CONVERSION_FACTOR_LONG_UNIT As Long = CONVERSION_FACTOR_LONG_UNIT_MM
Public Const DEFAULT_FUNDAMENTAL_UNIT As String = FUNDAMENTAL_UNIT_MM
Public Const DEFAULT_MAXIMUM_CUTTING_WIDTH As Long = DEFAULT_MAXIMUM_CUTTING_WIDTH_MM   'In Fundamental unit
Public Const DEFAULT_TOLERANCE As Long = DEFAULT_TOLERANCE_MM                           'In Fundamental unit
Public Const DEFAULT_CUT_FREE_SPACE_END As Long = DEFAULT_CUT_FREE_SPACE_END_MM         'In Fundamental unit

' Hardcoded Settings
Public Const DEFAULT_DIAGRAM_SHOW_COMBINED_DIAGRAM As Boolean = True
Public Const DEFAULT_DIAGRAM_HIDE_CUTS As Boolean = True
Public Const DEFAULT_DIAGRAM_PATTERN_INSTEAD_OF_COLOR As Boolean = True
Public Const DEFAULT_DIAGRAM_LABEL_MIN_SIZE As Long = 2000
Public Const DEFAULT_INPUT_VALIDATION_ON_CHANGE As Boolean = True
Public Const DEFAULT_SHOW_COSTS As Boolean = False

' Request sheet setup
Public Const REQUEST_ROW_FIRST As Long = 11
Public Const REQUEST_COL_TYPE As String = "A"
Public Const REQUEST_COL_SIZE As String = "B"
Public Const REQUEST_COL_EXTRA As String = "C"
Public Const REQUEST_COL_MATERIAL_COATING As String = "D"
Public Const REQUEST_COL_CUTTING_TYPE As String = "E"
Public Const REQUEST_COL_LENGTH As String = "F"
Public Const REQUEST_COL_QUANTITY As String = "G"
Public Const REQUEST_COL_DEVIATING_TOLERANCE As String = "H"
Public Const REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH As String = "I"
Public Const REQUEST_COL_STD_TOLERANCE As String = "J"
Public Const REQUEST_COL_ERROR As String = "K"
Public Const REQUEST_OPTIMIZATION_MODE As String = "$J$8"

' Channel types sheet setup
Public Const CHTYPE_ROW_FIRST As Long = 10
Public Const CHTYPE_COL_ENABLED As String = "A"
Public Const CHTYPE_COL_TYPE As String = "B"
Public Const CHTYPE_COL_SAP_NUMBER As String = "C"
Public Const CHTYPE_COL_SAP_DESCRIPTION As String = "D"
Public Const CHTYPE_COL_DELIVERY_TOLERANCE_PLUS As String = "E"
Public Const CHTYPE_COL_DELIVERY_TOLERANCE_MINUS As String = "F"
Public Const CHTYPE_COL_LENGTH As String = "G"
Public Const CHTYPE_COL_LENGTH_NAME As String = "H"
Public Const CHTYPE_COL_COST As String = "I"
Public Const CHTYPE_COL_CUT_COST As String = "J"
Public Const CHTYPE_COL_BUNDLE_SIZE As String = "K"
'Public Const CHTYPE_COL_BUNDLE_COST As String = "L"
Public Const CHTYPE_COL_ERROR As String = "M"

' Technical data sheet setup
Public Const TECHNICAL_DATA_ROW_FIRST As Long = 10
Public Const TECHNICAL_DATA_COL_TYPE As String = "A"
Public Const TECHNICAL_DATA_COL_MINIMUM_ITEM_LENGTH As String = "B"
Public Const TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_1 As String = "C"
Public Const TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_2 As String = "D"
Public Const TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_3 As String = "E"
Public Const TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_4 As String = "F"
Public Const TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_5 As String = "G"
Public Const TECHNICAL_DATA_COL_HILTI_STANDARD_TOLERANCE_6 As String = "H"
Public Const TECHNICAL_DATA_COL_HPR_ENABLED As String = "I"
Public Const TECHNICAL_DATA_COL_STEP_LENGTH As String = "J"
Public Const TECHNICAL_DATA_COL_HOLE_LENGTH As String = "K"
Public Const TECHNICAL_DATA_COL_WEB_WIDTH As String = "L"
Public Const TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_CUT As String = "M"
Public Const TECHNICAL_DATA_COL_FIRST_WEB_WIDTH_SHEAR As String = "N"
Public Const TECHNICAL_DATA_COL_MINIMUM_REMAINING_WEB_WIDTH As String = "O"
Public Const TECHNICAL_DATA_COL_START_POSITION_ERROR As String = "P"
Public Const TECHNICAL_DATA_COL_HOLE_POSITION_ERROR As String = "Q"
Public Const TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_PLUS As String = "R"
Public Const TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS As String = "S"
Public Const TECHNICAL_DATA_COL_ERROR As String = "T"

' Output sheet setup
'Public Const OUTPUT_CUTS_HEADER_ROW1 As Long = 5
'Public Const OUTPUT_CUTS_HEADER_ROW2 As Long = 6
'Public Const OUTPUT_CUTS_ROW_FIRST As Long = 7
'Public Const OUTPUT_CUTS_COL_FIRST As Long = 9

' OutputLists sheet setup
Public Const OUTPUTLISTS_HEADER_NOTE_SAP_ORDER_NO As String = "C2"
Public Const OUTPUTLISTS_HEADER_NOTE_SAP_CUSTOMER_NO As String = "C3"
Public Const OUTPUTLISTS_HEADER_SAP_ORDER_NO As String = "$B$2"
Public Const OUTPUTLISTS_HEADER_SAP_CUSTOMER_NO As String = "$B$3"
Public Const OUTPUTLISTS_HEADER_RANGE As String = "B2:B3"

' Translations sheet setup
Public Const TRANSLATIONS_ROW_HEADER_ROW As Long = 21
'Public Const TRANSLATIONS_ROW_FIRST As Long = 9
Public Const TRANSLATIONS_COL_FIELD_NAME As String = "B"
'Public Const TRANSLATIONS_COL_FIRST_LANGUAGE As String = "C"

' All bins / Unique bins sheet setup (share the same)
Public Const BINS_ROW_HEADING As Long = 1
Public Const BINS_ROW_PIECES As Long = 2
Public Const BINS_COL_DIAGRAM_START As Long = 2
Public Const BINS_COL_FIRST As Long = 1
Public Const BINS_COL_CUTTING_PROFILE As String = "A"
Public Const BINS_COL_QUANTITY As String = "B"
Public Const BINS_COL_TYPE As String = "C"
Public Const BINS_COL_TYPE_NO As Long = 3
Public Const BINS_COL_PIECES As Long = 4
Public Const BINS_SHOW_QUANTITY As Boolean = True
Public Const BINS_SHOW_PROFILE_NUMBER As Boolean = True
Public Const BINS_SHOW_CHANNEL_TYPE As Boolean = True
Public Const BINS_SHOW_COLOR As Boolean = True
Public Const BINS_SHOW_CUT_PIECES As Boolean = True
Public Const BINS_SHOW_WASTE_PIECES As Boolean = True


' TODO: Checked until here

' All input / Unique input sheet setup (share the same)
Public Const OUTPUT_ROW_HEADING As Long = 1
'Public Const OUTPUT_ROW_PIECES As Long = 2
Public Const OUTPUT_COL_TYPE As String = "A"
Public Const OUTPUT_COL_QUANTITY As String = "B"
Public Const OUTPUT_COL_CUTTING_TYPE As String = "C"
Public Const OUTPUT_COL_LENGTH As String = "D"

' Settings sheet set up
Public Const SETTINGS_COL_VALUE As String = "B"
Public Const SETTINGS_COL_ERROR As String = "D"
Public Const SETTINGS_ROW_MAXIMUM_CUTTING_WIDTH As Long = 8
Public Const SETTINGS_ROW_CUTFREE_SPACE_END As Long = 9
Public Const SETTINGS_ROW_DEFAULT_TOLERANCE As Long = 10
Public Const SETTINGS_ROW_MATERIAL_COUNTRY As Long = 16
Public Const SETTINGS_ROW_LANGUAGE As Long = 17
Public Const SETTINGS_ROW_UNIT As Long = 18
Public Const SETTINGS_ROW_LOGGING As Long = 24

' Countries sheet set up
Public Const COUNTRIES_ROW_FIRST As Long = 8
Public Const COUNTRIES_COL_COUNTRY As String = "A"
Public Const COUNTRIES_COL_CUTTING_METHOD As String = "B"
'Public Const COUNTRIES_COL_ERROR As String = "C"
'Public Const COUNTRIES_COL_NOTE As String = "D"

' Cutting pattern sheet set up
Public Const CPATTERN_ROW_START As Long = 6
Public Const CPATTERN_COL_START As Long = 1
Public Const CPATTERN_SHOW_COLOR As Boolean = False
Public Const CPATTERN_SHOW_CUT_PIECES As Boolean = False
Public Const CPATTERN_SHOW_WASTE_PIECES As Boolean = True
Public Const CPATTERN_SHOW_UNIQUE_PROFILES As Boolean = True
Public Const CPATTERN_NOTE As String = "$L$2"

' Colors used for coloring diagrams
Public Const COLOR_NORMAL_ODD As Long = 8355711
Public Const COLOR_NORMAL_ODD_BORDER As Long = 3881787 '7237230
Public Const COLOR_NORMAL_EVEN As Long = 7171437   'Darker 4210752
Public Const COLOR_NORMAL_EVEN_BORDER As Long = 3881787
Public Const COLOR_HPR_LEFT As Long = 12419407
Public Const COLOR_HPR_LEFT_BORDER As Long = 12221512
Public Const COLOR_HPR_RIGHT As Long = 10642560
Public Const COLOR_HPR_RIGHT_BORDER As Long = 9919350
Public Const COLOR_HPR_BOTH As Long = 2712913 ' 5880731
Public Const COLOR_HPR_BOTH_BORDER As Long = 3642231
Public Const COLOR_HPR_BOTH_BACKGROUND As Long = 12253404
Public Const COLOR_CUT As Long = 58087
Public Const COLOR_CUT_BORDER As Long = 948104 ' lighter 55774
Public Const COLOR_WASTE As Long = 192
Public Const COLOR_WASTE_BORDER As Long = 134 ' lighter 176

Public Const COLOR_DEFAULT_BACKGROUND As Long = 16777215 ' White
Public Const COLOR_HPR_LEFT_BACKGROUND As Long = 16117983
Public Const COLOR_HPR_RIGHT_BACKGROUND As Long = 15781089

Public Const COLOR_INPUTFIELD_BACKGROUND As Long = 15392959 ' Light blue

' English names for optimization modes:
Public Const OPTIMIZATION_MODE_BEST_FIT As String = "Quick solver"
Public Const OPTIMIZATION_MODE_IMPROVED_BIN_COMPLETION As String = "Improved bin completion"
Public Const OPTIMIZATION_MODE_LIMITED_BRUTE_FORCE As String = "Complex solver"
Public Const OPTIMIZATION_MODE_FULL_BRUTE_FORCE As String = "Full solver"

' Enums
Public Enum enumCuttingType
    typeNotSet
    A
    B1
    B2
    C1
    c2
End Enum

Public Enum enumHPRPlacement
    notSet
    noSide
    leftSide
    rightSide
    bothSides
End Enum

Public Enum enumPieceType
    normal
    cut
    waste
End Enum

Public Enum enumCuttingMethod
    Cutting
    shearing
End Enum

Public Enum enumToleranceMode
    modeNotSet
    withTolerances
    withoutTolerances
End Enum

Public Enum enumOptimizationMode
    bestFit
    improvedBinCompletion
    limitedBruteForce
    fullBruteForce
End Enum

' Types
Public Type typeDimension
    height As Long
    width As Long
End Type


' Globally accessible functions


' Returns the translation of the given field name
' If the field name is not defined, it returns an empty string
' Optional language, if this is set a specific language will be used, otherwise it uses the set language
Public Function Translate( _
    ByVal fieldName As String, _
    Optional ByVal statical As Boolean, _
    Optional ByVal overrideLanguage As String _
) As String
    '<hilticheck>
    Static jaggu As Integer
    
    jaggu = jaggu + 1
    
    Debug.Print jaggu
    
'    Application.Volatile True

    ensureGlobalObjectsExist

    If statical = False Then
        Translate = Translation.translateField(fieldName)
    ElseIf overrideLanguage = vbNullString Then
        Translate = Translation.translateField(fieldName, statical)
    Else
        Translate = Translation.translateField(fieldName, statical, overrideLanguage)
    End If

End Function

' Goes through all global objects that need to exist for operation of the tool and
' creates them where they dont exist.
' This is needed because the VBA garbage collector does delete these objects from time to time
' This function needs to be called before at every code entry-point to be sure that the objects
' always exist.
Public Sub ensureGlobalObjectsExist(Optional ByVal skipValidators As Boolean = False)


    Dim appProxy As IApplication
    Set appProxy = New ApplicationProxy

    If Settings Is Nothing Then
        Set Settings = New CSettings
        Settings.setDefaults
        Settings.readAll
    End If
    If Translation Is Nothing Then
        Set Translation = New CTranslation
        Translation.readTranslations
        appProxy.disableWhileRunning
        Translation.translateEverything
        appProxy.enableAfterRunning
    End If
    If Logger Is Nothing Then
        Set Logger = New CLogger
        If Settings.logging Then
            Logger.settingLogLevel = eInfo
        Else
            Logger.settingLogLevel = eOff
        End If
    End If
    If Request Is Nothing Then
        Set Request = New CRequest
        If Not skipValidators Then
            appProxy.disableWhileRunning
            Request.validators.applyVaildators
            appProxy.enableAfterRunning
        End If
    End If
End Sub
Attribute VB_Name = "IApplication"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit

Public Sub disableWhileRunning(Optional ByVal entryPoint As Boolean = False)
End Sub

Public Sub enableAfterRunning(Optional ByVal endPoint As Boolean = False)
End Sub

Attribute VB_Name = "IGenericSheet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit

Public Sub setBackground(ByVal color As Long, ByVal Sheet As Worksheet)
End Sub

Public Sub clearDiagrams(ByVal Sheet As Worksheet)
End Sub

Public Sub clearShapes(ByVal Sheet As Worksheet)
End Sub

Public Sub clearSheetDetele(ByVal Sheet As Worksheet)
End Sub

Public Sub deleteCells(ByVal Sheet As Worksheet)
End Sub

Public Sub clearFormats(ByVal Sheet As Worksheet)
End Sub

Public Sub renameSheet(ByVal Sheet As Worksheet, ByVal newName As String)
End Sub

Public Sub setVisibility(ByVal Sheet As Worksheet, ByVal visible As Boolean)
End Sub

Public Sub setVisibilityByName(ByVal SheetName As String, ByVal visible As Boolean)
End Sub

'@Ignore FunctionReturnValueNotUsed
'Public Function getVisibility(ByVal sheet As Worksheet) As Boolean
'End Function

Public Function getVisibilityByName(ByVal SheetName As String) As Boolean
End Function

Public Sub changeButtonText( _
    ByVal Sheet As Worksheet, _
    ByVal name As String, _
    ByVal newText As String _
)
End Sub

Public Function WorkSheetExists(ByVal worksheetName As String) As Boolean
End Function




Attribute VB_Name = "IOutputSheets"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit


' Clears the output sheet before inserting new data
Public Sub clear()
End Sub

Public Sub writeBinToRow( _
    ByVal bin As CBin, _
    ByVal currentRow As Long, _
    ByVal binsSheet As Worksheet _
)
End Sub

Public Sub writePieceToCell( _
    ByVal piece As CPiece, _
    ByVal cell As Range _
)
End Sub

Public Sub writeInputItem( _
    ByVal item As CItem, _
    ByVal rowNo As Long, _
    ByVal quantity As String, _
    ByVal inputSheet As Worksheet _
)
End Sub

Public Sub writeInputHeadings( _
    ByVal inputSheet As Worksheet _
)
End Sub

Public Sub writeBinHeadings( _
    ByVal binsSheet As Worksheet, _
    ByVal maxPieceCount As Long _
)
End Sub

Public Sub addLegend()
End Sub

Public Sub adjustCuttingPatternSheet()
End Sub

Public Sub adjustOutputListsSheet()
End Sub

Attribute VB_Name = "MyTests"
'@Folder("Tests")
Option Explicit

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


' Prints valid cut areas for all defined types to a file
Public Sub check_generateCutPositionsForAll(Optional ByVal useRight As Boolean)

    Dim tmpChannel As CChannelType
    Dim i As Long
    Dim j As Long
    Dim minMaxFile As String
    Dim maxCuts As Long
    Dim cutMax As Long
    Dim cutMin As Long

    initialize_tool
    
    Request.clearVariables
    
    Request.readChannelTypesSheets
    Request.channelTypeSet.generateCutPositionsForAll

    Set Logger = New CLogger

    If useRight Then
        Logger.logInfo "Generating Min Max Right"
        minMaxFile = "E:\Cutting tool\MinMaxRight.txt"
    Else
        Logger.logInfo "Generating Min Max Left"
        minMaxFile = "E:\Cutting tool\MinMaxLeft.txt"
    End If

    Request.channelTypeSheet.readTechnicalData channelTypeSet:=Request.channelTypeSet
    Request.channelTypeSheet.readVariants channelTypeSet:=Request.channelTypeSet
    Request.channelTypeSet.generateCutPositionsForAll
    Request.channelTypeSet.generateValidationStrings

    Logger.logInfo "Opening file: " & minMaxFile
    Open minMaxFile For Output As #1

    For j = 1 To Request.channelTypeSet.count
        Set tmpChannel = Request.channelTypeSet.getChType(j)
        'Logger.logInfo "Running genreateValidLengthsC1 from check_generateCutMinMaxForAll"
        'tmpChannel.genreateValidLengthsC1

        If tmpChannel.HPRenabled Then

            Print #1, tmpChannel.channelTypeKey
            'Print #1, "HPR enabled: " & tmpChannel.HPR_enabled
            Print #1, "min" & vbTab & "Max" & vbTab & "size"

            If useRight Then
                maxCuts = tmpChannel.rightCutsMax
            Else
                maxCuts = tmpChannel.leftCutsMax
            End If

            Logger.logInfo tmpChannel.channelTypeKey & vbTab & maxCuts

            For i = 1 To maxCuts
                If useRight Then
                    cutMax = tmpChannel.getRightCutMax(i)
                    cutMin = tmpChannel.getRightCutMin(i)
                Else
                    cutMax = tmpChannel.getLeftCutMax(i)
                    cutMin = tmpChannel.getLeftCutMin(i)
                End If

                Print #1, cutMin & vbTab & cutMax & vbTab & (cutMax - cutMin)
            Next
        End If
    Next

    Close #1
End Sub



' Debug MQ-21.5-GALV
Public Sub check_mq215galv()
    Dim useRight As Boolean

    Dim tmpChannel As CChannelType
    Dim i As Long
    Dim j As Long
    Dim minMaxFile As String
    Dim maxCuts As Long
    Dim cutMax As Long
    Dim cutMin As Long

    useRight = False
    
    initialize_tool
    
    Request.clearVariables
    
    Request.readChannelTypesSheets
    Request.channelTypeSet.generateCutPositionsForAll

    Set Logger = New CLogger

    If useRight Then
        Logger.logInfo "Generating Min Max Right"
        minMaxFile = "E:\Cutting tool\MinMaxRight_mq215galv.txt"
    Else
        Logger.logInfo "Generating Min Max Left"
        minMaxFile = "E:\Cutting tool\MinMaxLeft_mq215galv.txt"
    End If

    Request.channelTypeSheet.readTechnicalData channelTypeSet:=Request.channelTypeSet
    Request.channelTypeSheet.readVariants channelTypeSet:=Request.channelTypeSet
    Request.channelTypeSet.generateCutPositionsForAll
    Request.channelTypeSet.generateValidationStrings

    Logger.logInfo "Opening file: " & minMaxFile
    Open minMaxFile For Output As #1

    For j = 1 To Request.channelTypeSet.count
        Set tmpChannel = Request.channelTypeSet.getChType(j)

        If tmpChannel.channelTypeKey = "MQ-21.5-GALV" Then
            
            'Logger.logInfo "Running genreateValidLengthsC1 from check_generateCutMinMaxForAll"
            'tmpChannel.genreateValidLengthsC1
            
            ' Print general channel info:
            Print #1, "ctype:" & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & tmpChannel.ctype
            Print #1, "extra:" & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & tmpChannel.extra
            Print #1, "first_web_width:" & vbTab & vbTab & vbTab & tmpChannel.firstWebWidth
            Print #1, "first_web_width_cut:" & vbTab & vbTab & tmpChannel.firstWebWidthCut
            Print #1, "first_web_width_shear:" & vbTab & vbTab & tmpChannel.firstWebWidthShear
            Print #1, "hole_length:" & vbTab & vbTab & vbTab & vbTab & tmpChannel.holeLength
            Print #1, "hole_length_error_minus:" & vbTab & tmpChannel.holeLengthErrorMinus
            Print #1, "hole_length_error_plus:" & vbTab & vbTab & tmpChannel.holeLengthErrorPlus
            Print #1, "hole_position_error:" & vbTab & vbTab & tmpChannel.holePositionError
            Print #1, "HPR_enabled:" & vbTab & vbTab & vbTab & vbTab & tmpChannel.HPRenabled
            Print #1, "material:" & vbTab & vbTab & vbTab & vbTab & vbTab & tmpChannel.material
            Print #1, "maxCutsLeft:" & vbTab & vbTab & vbTab & vbTab & tmpChannel.leftCutsMax
            Print #1, "maxCutsRight:" & vbTab & vbTab & vbTab & vbTab & tmpChannel.rightCutsMax
            Print #1, "minimum_item_length:" & vbTab & vbTab & tmpChannel.minimumItemLength
            Print #1, "minimum_remaining_web_width:" & vbTab & tmpChannel.minimumRemainingWebWidth
            Print #1, "size:" & vbTab & vbTab & vbTab & vbTab & vbTab & vbTab & tmpChannel.size
            Print #1, "start_position_error:" & vbTab & vbTab & tmpChannel.startPositionError
            Print #1, "variantCount:" & vbTab & vbTab & vbTab & vbTab & tmpChannel.variantCount
            Print #1, "web_width:" & vbTab & vbTab & vbTab & vbTab & vbTab & tmpChannel.webWidth
            
            
            If tmpChannel.HPRenabled Then
    
                Print #1, tmpChannel.channelTypeKey
                'Print #1, "HPR enabled: " & tmpChannel.HPR_enabled
                Print #1, "min" & vbTab & "Max" & vbTab & "size"
    
                If useRight Then
                    maxCuts = tmpChannel.rightCutsMax
                Else
                    maxCuts = tmpChannel.leftCutsMax
                End If
    
                Logger.logInfo tmpChannel.channelTypeKey & vbTab & maxCuts
    
                For i = 1 To maxCuts
                    If useRight Then
                        cutMax = tmpChannel.getRightCutMax(i)
                        cutMin = tmpChannel.getRightCutMin(i)
                    Else
                        cutMax = tmpChannel.getLeftCutMax(i)
                        cutMin = tmpChannel.getLeftCutMin(i)
                    End If
    
                    Print #1, cutMin & vbTab & cutMax & vbTab & (cutMax - cutMin)
                Next
            End If
        End If
    Next

    Close #1
End Sub




' Debug function:
Public Sub test_validators()
    Dim myRange As Range
    Dim validValues As String
    validValues = "a;b;c"
    Set myRange = SheetRequest.Cells(16, 2)
    myRange.Validation.Delete
    myRange.Validation.Add _
    Type:=xlValidateList, _
    AlertStyle:=xlValidAlertStop, _
    Formula1:=validValues
    
    Dim sizeRange As Range
    Set sizeRange = SheetRequest.Cells(15, Globals.REQUEST_COL_SIZE)
    Dim sizeValidators As String

    sizeValidators = "a,b,c"
    Logger.logInfo sizeValidators
    sizeRange.Validation.Delete
    sizeRange.Validation.Add _
        Type:=xlValidateList, _
        AlertStyle:=xlValidAlertStop, _
        Formula1:=sizeValidators
End Sub


Public Sub checked()
    With ActiveSheet.Range("K2")
        .Style = "Good"
        .Font.bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .FormulaR1C1 = "Checked OK"
    End With
End Sub


Public Sub not_checked()
    With ActiveSheet.Range("K2")
        .Style = "Neutral"
        .Font.bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .FormulaR1C1 = "Not checked"
    End With
End Sub


Public Sub not_ok()
    With ActiveSheet.Range("K2")
        .Style = "Bad"
        .Font.bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .FormulaR1C1 = "Not OK"
    End With
End Sub


'Public Sub cut_minmax()
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    channelTypeSet.generateMinMaxForAll
'    channelTypeSet.generateValidationStrings
'
'    Dim MQ As CChannelType
'    Set MQ = channelTypeSet.getChTypeFromKey("MQ-41")
'    MQ.generateCutMinMax
'    'MQ.genreateValidLengthsC1
'    Dim i As Long
'    For i = 1 To MQ.maxCutsLeft
'        Logger.logInfo i & vbTab & MQ.getCutMaxLeft(i) & vbTab & MQ.getCutMinLeft(i) & vbTab & MQ.getCutMaxLeft(i) - MQ.getCutMinLeft(i)
'    Next
'End Sub


' Prints information about a channel type
'Public Sub check_channelTypes()
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    channelTypeSet.generateMinMaxForAll
'    channelTypeSet.generateValidationStrings
'
'    Dim MQ As CChannelType
'    Set MQ = channelTypeSet.getChTypeFromKey("MQ-1in5/8_14GA-R")
'    MQ.generateCutMinMax
'    'MQ.genreateValidLengthsC1
'    Logger.logInfo "channelTypeKey: " & MQ.channelTypeKey
'    Logger.logInfo "first_web_width: " & MQ.first_web_width
'    Logger.logInfo "first_web_width_cut: " & MQ.first_web_width_cut
'    Logger.logInfo "first_web_width_shear: " & MQ.first_web_width_shear
'    Logger.logInfo "hilti_standard_tolerance1: " & MQ.hilti_standard_tolerance1
'    Logger.logInfo "hilti_standard_tolerance2: " & MQ.hilti_standard_tolerance2
'    Logger.logInfo "hilti_standard_tolerance3: " & MQ.hilti_standard_tolerance3
'    Logger.logInfo "hilti_standard_tolerance4: " & MQ.hilti_standard_tolerance4
'    Logger.logInfo "hilti_standard_tolerance5: " & MQ.hilti_standard_tolerance5
'    Logger.logInfo "hilti_standard_tolerance6: " & MQ.hilti_standard_tolerance6
'    Logger.logInfo "hole_position_error: " & MQ.hole_position_error
'    Logger.logInfo "hole_length: " & MQ.hole_length
'    Logger.logInfo "hole_length_error_plus: " & MQ.hole_length_error_plus
'    Logger.logInfo "hole_length_error_minus: " & MQ.hole_length_error_minus
'    Logger.logInfo "HPR_enabled: " & MQ.HPR_enabled
'    Logger.logInfo "minimum_item_length: " & MQ.minimum_item_length
'    Logger.logInfo "minimum_remaining_web_width: " & MQ.minimum_remaining_web_width
'    Logger.logInfo "start_position_error: " & MQ.start_position_error
'    Logger.logInfo "variantCount: " & MQ.variantCount
'    Logger.logInfo "web_width: " & MQ.web_width
'End Sub


' Prints valid cut areas
'Public Sub check_generateCutMinMax()
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    channelTypeSet.generateMinMaxForAll
'    channelTypeSet.generateValidationStrings
'
'    Dim MQ As CChannelType
'    Set MQ = channelTypeSet.getChTypeFromKey("MQ-1in5/8_14GA-R")
'    MQ.generateCutMinMax
'    'MQ.genreateValidLengthsC1
'    Dim i As Long
'    Logger.logInfo "Valid cut areas for " & MQ.channelTypeKey
'    Logger.logInfo "n" & vbtab & "From" & vbTab & "To", "Width"
'    For i = 1 To MQ.maxCutsLeft
'        Logger.logInfo i & vbTab & MQ.getCutMinLeft(i) & vbTab & MQ.getCutMaxLeft(i) & vbTab & MQ.getCutMaxLeft(i) - MQ.getCutMinLeft(i)
'    Next
'End Sub


'Public Sub check_generateLeftRightMinMax()
'    ' Left
'    check_generateCutMinMaxForAll
'    ' Right
'    check_generateCutMinMaxForAll True
'End Sub


'Public Sub test_single_n()
'
'    Dim myChannel As CChannelType
'    Dim chType As String
'    'Dim n As Long
'
'    chType = "MC-41-GALV"
'
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'
'    Set myChannel = channelTypeSet.getChTypeFromKey(chType)
'
'    'n = 2
'
'    Logger.logInfo chType
'
'    'Logger.logInfo "minRight[" & n & "]: " & myChannel.calculateCutMinRight(n)
'    'Logger.logInfo "maxRight[" & n & "]: " & myChannel.calculateCutMaxRight(n)
'
'End Sub


'Public Sub check_generateMinMax_forSpecificChannel()
'    Dim myChannel As CChannelType
'    Dim chType As String
'    chType = "MM-16-GALV"
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    Set myChannel = channelTypeSet.getChTypeFromKey(chType)
'    myChannel.generateCutMinMax True
'End Sub


'Public Sub check_generateLengths_forSpecificChannel()
'    Logger.logInfo "genreating cutminmax left for a specific channel"
'
'    Dim myChannel As CChannelType
'    Dim chType As String
'
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants

'    chType = "MQ-41+LL-GALV"
'    Set myChannel = channelTypeSet.getChTypeFromKey(chType)
    
'    myChannel.generateCutMinMax True
'    myChannel.genreateValidLengthsC1
'End Sub


' Debug function that adds a specific set of items for testing
'Public Sub testSpecificCase()
'    Dim chType As String
'    Dim item As CItem

'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    channelTypeSet.generateMinMaxForAll
'    channelTypeSet.generateValidationStrings
'    chType = "MC-41-GALV"

'    ' Initiate a set of items
'    ' Reset previous
'    chTypeCount = 1
'
'    ReDim allBinSets(1 To chTypeCount)
'    ReDim itemSets(1 To chTypeCount)
'
'    Set itemSets(chTypeCount) = New CItemSet
'    itemSets(chTypeCount).channelTypeKey = chType

'    Set allBinSets(chTypeCount) = New CBinSet
'    ' Set capacity to the largest variant of the specified type
'    allBinSets(chTypeCount).capacity = channelTypeSet.getMaxUsableLength(chType)
'    allBinSets(chTypeCount).channelTypeKey = chType

'    Set item = New CItem
'   item.channelTypeKey = chType
'    item.length = 9900
'    item.tolerance = 30
'    item.quantity = 6
'    item.cuttingType = C1

    'Logger.logInfo "Adding item:"
    'Logger.logInfo " channelTypeKey" & vbTab & item.channelTypeKey
    'Logger.logInfo " cuttingType" & vbTab & item.cuttingType
    'Logger.logInfo " length" & vbTab & item.length
    'Logger.logInfo " quantity" & vbTab & item.quantity
    'Logger.logInfo " tolerance" & vbTab & item.tolerance
'    itemSets(chTypeCount).addItem item

'    optimize
'    ClearOutputSheets
'    Request.outputSheets.write

'    CreateDiagrams
'End Sub


'Public Sub testValidators_DefaultSet()
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    channelTypeSet.generateMinMaxForAll
'    channelTypeSet.generateValidationStrings
'    Logger.logInfo channelTypeSet.uniqueType
'    Logger.logInfo channelTypeSet.uniqueSize
'    Logger.logInfo channelTypeSet.uniqueExtra
'    Logger.logInfo channelTypeSet.uniqueMaterialCoating
'End Sub


'Public Sub testCalcs()
'    Dim hole_length As Long
'    Dim web_width As Long
'    Dim first_web_width_cut As Long
'    Dim min_remaining_web_width As Long
'    Dim start_position_error As Long
'    Dim hole_position_error As Long
'    Dim hole_length_error_plus As Long
'    Dim n As Long
'    Dim cutMax As Long
'    Dim cutMin As Long
'    hole_length = 350
'    web_width = 150
'    first_web_width_cut = 45
'    min_remaining_web_width = 50
'    start_position_error = 10
'    hole_position_error = 10
'    hole_length_error_plus = 5
'    n = 21
'    cutMax = -start_position_error + first_web_width_cut + ((n - 1) * (hole_length + web_width))
'    ' Find current meter
'    Dim current_meter As Long
'    current_meter = Ceiling(cutMax / 10000)
'    cutMin = start_position_error + first_web_width_cut + hole_position_error * current_meter + (n - 1) * hole_length + (n - 2) * web_width + hole_length_error_plus + min_remaining_web_width
'    ' Deal with hole position error
'    cutMax = cutMax - (hole_position_error * current_meter)
'    Logger.logInfo "current_meter: " & current_meter
'    Logger.logInfo "cutMin: " & cutMin
'    Logger.logInfo "cutMax: " & cutMax
'    Dim myChannel As CChannelType
'    Dim chType As String
'    chType = "MM-16-GALV"
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
 '   Set myChannel = channelTypeSet.getChTypeFromKey(chType)
'    myChannel.generateCutMinMax True
'    Logger.logInfo "cutMin: " & myChannel.getCutMinLeft(n)
'    Logger.logInfo "cutMax: " & myChannel.getCutMaxLeft(n)
'End Sub


'Public Sub testValidators_TestSpecifics()
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    channelTypeSet.generateMinMaxForAll
'    channelTypeSet.generateValidationStrings
'    Dim ctype As String
'    Dim size As String
'    Dim extra As String
'    Dim material As String
'    Dim cuttingType As String
'    Dim sizeValidators As String
'    Dim extraValidators As String
'    Dim materialValidators As String
'    Dim hprValidators As String
'    sizeValidators = vbNullString
'    extraValidators = vbNullString
'    materialValidators = vbNullString
'    hprValidators = vbNullString
'    ctype = "HS"
'    size = "13/16_12GA"
'    extra = vbNullString
'    material = vbNullString
'    cuttingType = vbNullString
'    Logger.logInfo channelTypeSet.isValidType(ctype, size, extra, material, cuttingType, vbNullString)
'    channelTypeSet.getSpecificValidators ctype, size, extra, material, cuttingType, sizeValidators, extraValidators, materialValidators, hprValidators
'    Logger.logInfo "2: " & sizeValidators
'    Logger.logInfo "3: " & extraValidators
'    Logger.logInfo "4: " & materialValidators
'    Logger.logInfo "5: " & hprValidators
'End Sub


' Finds the corner cases where validity changes
' This tester seems to not work
'Public Sub test_isValidHPRLength()
'    Dim testLength As Long
'    Dim lastLength As Long
'    Dim thisResult As String
'    Dim lastResult As String
'    Dim channelMaxLength As Long
'    Dim itemMargin As Long
'    Dim cuttingType As enumHPRType
'    ' Settings:
'    itemMargin = 30
'    hpr = zero
'    ' Read and set channel type
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    Dim myChannel As CChannelType
'    Set myChannel = channelTypeSet.getChTypeFromKey("MC-41-GALV")
'    myChannel.generateCutMinMax
'    myChannel.genreateValidLengthsC1Hpr
'    channelMaxLength = myChannel.getMaxUsableLength
'    lastResult = False
'    lastLength = 1
'    Logger.logInfo "Valid lengths for " & myChannel.channelTypeKey & " with these parameters:"
'    Logger.logInfo "  SetMaximumCuttingWidth   = " & Settings.maximumCuttingWidth
'    Logger.logInfo "  itemMargin = " & itemMargin
'    Logger.logInfo "  HPR        = " & hpr
'    Logger.logInfo "  channelMaxLength = " & channelMaxLength
'    Logger.logInfo "-----"
'    For testLength = 60001 To 60001 'channelMaxLength
'        thisResult = myChannel.isValidHPRLength(testLength, hpr, Settings.maximumCuttingWidth, itemMargin)
'        If Not thisResult = lastResult Then
'            If thisResult <> vbNullString Or (testLength = channelMaxLength) Then
'                Logger.logInfo lastLength & " - " & testLength
'            End If
'            lastLength = testLength
'        End If
'        lastResult = thisResult
'    Next
'    Logger.logInfo "-----"
'End Sub


' Finds the corner cases where validity changes
'Public Sub test_isValidHPRLengthSingle()
'    Dim testLength As Long
'    Dim result As String
'    Dim channelMaxLength As Long
'    Dim itemMargin As Long
'    Dim hpr As enumHPRType
'    ' Settings:
'    itemMargin = 30
'    hpr = C1
'    ' Read and set channel type
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    Dim myChannel As CChannelType
'    Set myChannel = channelTypeSet.getChTypeFromKey("MC-41-GALV")
'    myChannel.generateCutMinMax
'    myChannel.genreateValidLengthsC1Hpr
'    channelMaxLength = myChannel.getMaxUsableLength
'    testLength = 29730
'    'Logger.logInfo "Valid lengths for " & myChannel.channelTypeKey & " with these parameters:"
'    'Logger.logInfo "  SetMaximumCuttingWidth   = " & SetMaximumCuttingWidth
'    'Logger.logInfo "  itemMargin = " & itemMargin
'    'Logger.logInfo "  HPR        = " & hpr
'    'Logger.logInfo "  testLength        = " & testLength
'    'Logger.logInfo "  channelMaxLength = " & channelMaxLength
'    'Logger.logInfo "-----"
'    result = myChannel.isValidHPRLength(testLength, hpr, Settings.maximumCuttingWidth, itemMargin)
'    If result <> vbNullString Then
'        Logger.logInfo "Result: " & result
'    Else
'        Logger.logInfo "Result: OK"
'    End If
'End Sub


'Public Sub testcutterFunctions()
'    Const START_NUMBER As Long = 1800
'    Const STOP_NUMBER As Long = 2100
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    Dim MQ As CChannelType
'    Set MQ = channelTypeSet.getChTypeFromKey("MQ-41")
'    MQ.generateCutMinMax
'   ' MQ.genreateValidLengthsC1Hpr
'    Logger.logInfo "Listing valid HPR cutting numbers between " & START_NUMBER & " to " & STOP_NUMBER & ":"
'    Dim n As Long
'    For n = START_NUMBER To STOP_NUMBER
'        If MQ.isValidLeftHPR(n) Then
'            Logger.logInfo n
'        End If
'    Next
'    Logger.logInfo "..done."
'End Sub


'Public Sub printValidmInvalidCutAreas()
'    Dim n As Long
'    Dim currentPos As Long
'    Dim validArea As Long
'    Dim invalidArea As Long
'    Dim prevCutMax As Long
'    prevCutMax = 0
'    currentPos = 0
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    Dim MQ As CChannelType
'    Set MQ = channelTypeSet.getChTypeFromKey("MQ-1in5/8_14GA-R")
'    MQ.generateCutMinMax
'    'MQ.genreateValidLengthsC1Hpr
'    For n = 1 To MQ.maxCutsLeft
'        invalidArea = MQ.getCutMinLeft(n) - prevCutMax
'        currentPos = currentPos + invalidArea
'        validArea = MQ.getCutMaxLeft(n) - currentPos
'        currentPos = currentPos + validArea
'        prevCutMax = MQ.getCutMaxLeft(n)
'        Logger.logInfo "invalid" & vbTab & invalidArea
'        Logger.logInfo "valid" & vbTab & validArea
'    Next
'End Sub


'Public Sub fixitnow()
'    channelTypeSet.readTechnicalData
'    channelTypeSet.readVariants
'    Dim MQ As CChannelType
'    Set MQ = channelTypeSet.getChTypeFromKey("MQ-41")
'    MQ.generateCutMinMax
'    'MQ.genreateValidLengthsC1Hpr
'    Logger.logInfo MQ.isValidHPRLength(8030, C1, 30, 0)
'End Sub


Public Sub sortTest()
    Dim lastRow As Long
    With SheetRequest
        ' Find last row, so we can calculate how many items the request contains
        ' Use the Type column as reference
        lastRow = .Range(Globals.REQUEST_COL_TYPE & .Rows.count).End(xlUp).Row
        Logger.logInfo "sorting"
            
        .sort.SortFields.clear
        .sort.SortFields.Add Key:=.Range(Globals.REQUEST_COL_TYPE & Globals.REQUEST_ROW_FIRST & ":" & _
                                         Globals.REQUEST_COL_TYPE & lastRow), _
            SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        '.sort.SortFields.Add key:=.Range(Globals.REQUEST_COL_SIZE & Globals.REQUEST_ROW_FIRST & ":" & Globals.REQUEST_COL_SIZE & lastRow), _
            SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        '.sort.SortFields.Add key:=.Range(Globals.REQUEST_COL_EXTRA & Globals.REQUEST_ROW_FIRST & ":" & Globals.REQUEST_COL_EXTRA & lastRow), _
            SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        '.sort.SortFields.Add key:=.Range(Globals.REQUEST_COL_MATERIAL_COATING & Globals.REQUEST_ROW_FIRST & ":" & Globals.REQUEST_COL_MATERIAL_COATING & lastRow), _
            SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        '.sort.SortFields.Add key:=.Range(Globals.REQUEST_COL_HPR & Globals.REQUEST_ROW_FIRST & ":" & Globals.REQUEST_COL_HPR & lastRow), _
            SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        '.sort.SortFields.Add key:=.Range(Globals.REQUEST_COL_LENGTH & Globals.REQUEST_ROW_FIRST & ":" & Globals.REQUEST_COL_LENGTH & lastRow), _
            SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        .sort.SetRange .Range( _
            Globals.REQUEST_COL_TYPE & Globals.REQUEST_ROW_FIRST & ":" & _
            Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH & lastRow _
        )
        .sort.Header = xlNo
        .sort.MatchCase = True
        .sort.Orientation = xlTopToBottom
        .sort.SortMethod = xlPinYin
        .sort.Apply
    End With
End Sub


Public Sub roundingTest()
    Dim val As Long
    val = -29
    Debug.Print val, ">", getRounding10abs(val)
End Sub

Public Sub settingsTest()
    '@Ignore UseMeaningfulName
    Dim S As CSettings
    Set S = New CSettings
    Debug.Print S.showCosts
    If S.showCosts Then
        Debug.Print "show them"
    Else
        Debug.Print "dont show"
    End If
End Sub


Public Sub testLoggger()
    '@Ignore UseMeaningfulName
    Dim l As CLogger
    Set l = New CLogger
    l.logInfo "info"
End Sub


' Script to run multiple runs to test different algorithms
Public Sub multiTester()
    Dim i As Long
    Dim j As Long
    Dim noOfRuns As Long

    If Settings Is Nothing Then
        Set Settings = New CSettings
    End If
    If Translation Is Nothing Then
        Set Translation = New CTranslation
    End If
    If Logger Is Nothing Then
        Set Logger = New CLogger
    End If

    ' Read settings
    Settings.setDefaults
    Settings.readAll
    enableLogging
    noOfRuns = 1

    Logger.logInfoBoth "Multi optimization testing script"

    For i = 1 To noOfRuns
        enableLogging
        Logger.logInfoBoth "Run " & i & " / " & noOfRuns

        disableLogging
        generateRequestButton_Click

        ' Run on each mode
        For j = 1 To 2
            enableLogging
            If j = 2 Then
                Logger.logInfoBoth "Optimization: BestFit"
                Settings.optimizationMode = enumOptimizationMode.bestFit
            ElseIf j = 3 Then
                Logger.logInfoBoth "Optimization: Limited Brute Force"
                Settings.optimizationMode = enumOptimizationMode.improvedBinCompletion
            ElseIf j = 4 Then
                Logger.logInfoBoth "Optimization: Full Brute Force"
                Settings.optimizationMode = enumOptimizationMode.fullBruteForce
            End If
            disableLogging
            findSolutionButton_Click

            enableLogging
            Logger.logInfoBoth "Optimization: " & Settings.optimizationMode
            Logger.logInfoBoth "Waste rate: " & Request.getTotalWasteRate & " %"
        Next
    Next

    Logger.logInfoBoth "Multi optimization testing script DONE."
End Sub


Private Sub enableLogging()
    Settings.logging = True
    Logger.settingLogLevel = eInfos
    Logger.settingLogToFile = True
End Sub

Private Sub disableLogging()
    Settings.logging = False
    Logger.settingLogLevel = eBugs
    Logger.settingLogToFile = False
End Sub

' Loop through every piece type and try to place every length
Public Sub findUnplaceablePieces()

End Sub


Public Sub testLongArrayArray()
    Dim myArr As CLongArray
    Dim myArrArr As CLongArrayArray
    '@Ignore UseMeaningfulName
    Dim myArrArr2 As CLongArrayArray
    
    Set myArr = New CLongArray
    Set myArrArr = New CLongArrayArray
    Set myArrArr2 = New CLongArrayArray
    
    myArr.addElement 1
    myArr.addElement 2
    myArr.addElement 3
    
    myArrArr.addElement myArr

    myArr.addElement 4
    
    Debug.Print myArrArr.element(1).getString
End Sub


Public Sub testUnfiller()

    If Settings Is Nothing Then
        Set Settings = New CSettings
    End If
    If Translation Is Nothing Then
        Set Translation = New CTranslation
    End If
    If Logger Is Nothing Then
        Set Logger = New CLogger
    End If
    enableLogging
    Settings.setDefaults
    Settings.readAll
    
    Logger.logError "starting"

    Dim items   As CItemSet
    Dim itemNo As Long
    '@Ignore VariableNotUsed
    Dim pieceNo As Long
    Dim tmpPiece As CPiece
    Dim tmpItem As CItem
    '@Ignore UseMeaningfulName
    Dim tmpItem2 As CItem
    Dim piecePlaced As Boolean
    Dim maxPieces() As Long
    Dim unFiller As CUnfill
    Dim cutWidth As Long
    '@Ignore VariableNotUsed
    Dim binCount As Long
    Dim tmpBin As CBin
    binCount = 0
    
    cutWidth = 15
    
    
    Set tmpBin = New CBin
    tmpBin.setValues 60900, 60900, 60900, "MQ-41-HDG"
    
    Set items = New CItemSet
    Set tmpItem = New CItem
    Set tmpItem2 = New CItem
    
    tmpItem.setValues _
        length:=550, _
        tolerance:=0, _
        deviatingMinimumRemainingWebWidth:=0, _
        deviatingMinimumRemainingWebWidthSet:=False, _
        quantity:=4, _
        cuttingType:=enumCuttingType.A, _
        channelTypeKey:=vbNullString
    Set tmpItem2 = tmpItem.getCopy
    items.addItem tmpItem2
    
    tmpItem.setValues _
        length:=500, _
        tolerance:=0, _
        deviatingMinimumRemainingWebWidth:=0, _
        deviatingMinimumRemainingWebWidthSet:=False, _
        quantity:=15, _
        cuttingType:=enumCuttingType.A, _
        channelTypeKey:=vbNullString
    Set tmpItem2 = tmpItem.getCopy
    items.addItem tmpItem2
    
    tmpItem.setValues _
        length:=800, _
        tolerance:=0, _
        deviatingMinimumRemainingWebWidth:=0, _
        deviatingMinimumRemainingWebWidthSet:=False, _
        quantity:=8, _
        cuttingType:=enumCuttingType.A, _
        channelTypeKey:=vbNullString
    Set tmpItem2 = tmpItem.getCopy
    items.addItem tmpItem2
    
    Logger.logInfo "Placing " & items.count & " items"
    
    ' Empty the bins from any existing pieces
    
    
    ' Step 1, Sort pieces in size order ascending
    Logger.logInfoBoth "Step 1, Sorting pieces according to length ascending"
    items.sortByLength descending:=False
    ReDim maxPieces(1 To items.count)
    
    For itemNo = 1 To items.count
        Logger.logInfoBoth "    length: " & items.getItemCopy(itemNo).length
    Next
    
    
    
    
    ' Step 2, Find the number of pieces of each type required to fill a channel
    Logger.logInfoBoth "Step 2, Find the number of pieces of each type required to fill a channel"
    
    For itemNo = 1 To items.count
        
        Set tmpItem = items.getItemCopy(itemNo)
        maxPieces(itemNo) = 0

        ' Place as many pieces as possible into the bin (until we run out of pieces, the bin is full or if the piece cannot be placed)
        'Logger.logInfoBoth "  Place pieces until the bin is full or we run out of pieces"
        For pieceNo = 1 To tmpItem.quantity
        
            Set tmpPiece = tmpItem.piece
            
            'Logger.logInfoBoth vbTab & "    Trying to place into binNo=" & binCount & vbTab & "hpr=" & tmpItem.hpr & vbTab & "cutWidth=" & cutWidth
            piecePlaced = tmpBin.placePiece( _
                tmpItem.cuttingType, _
                tmpPiece, _
                cutWidth _
            )
            If piecePlaced Then
                ' The piece could be placed, count it
                maxPieces(itemNo) = maxPieces(itemNo) + 1
            Else
                ' The piece could not be placed we have reached the end
                Exit For
            End If
        Next
        Set tmpBin = New CBin
        tmpBin.setValues _
            60900, _
            60900, _
            60900, _
            "MQ-41-HDG"
        
        Logger.logInfoBoth "maxPieces(" & itemNo & "): " & maxPieces(itemNo)
        
    Next
    
    
    
    ' Step 3, Find combinations of pieces for later permutations using the UnFill Algorithm
    Logger.logInfoBoth "Step 3, Find combinations of pieces for later permutations using the UnFill Algorithm"
    Set unFiller = New CUnfill
    unFiller.setMaxLength 6090
    
    ' Find lengths (this gives us a rough maximum)
    Logger.logInfoBoth "  Find lengths (this gives us a rough maximum)"
    For itemNo = 1 To items.count
        ' TODO Enhancement replace with a function that does not make a copy
        Set tmpItem = items.getItemCopy(itemNo)
        Set tmpPiece = tmpItem.piece
        unFiller.addLength tmpPiece.length - tmpPiece.allowedToleranceRoundedDown     ' Use shortest piece length
        Logger.logInfo "    unFiller.addLength (" & (tmpPiece.length - tmpPiece.allowedToleranceRoundedDown) & ")"
    Next
    
    'Logger.logInfoBoth "  unFiller.curChar:" & unFiller.curChar
    Logger.logInfo "  Running unfill algorithm"
    unFiller.unfill
    Logger.logInfo "  " & unFiller.results.count & " combinations generated"
    
    ' List results:
    Logger.logInfo "  Listing results:"
    '@Ignore UseMeaningfulName
    Dim k As Long
    For k = 1 To unFiller.results.count
        Logger.logInfo "    count: " & unFiller.results.element(k).count & ", content: [" & unFiller.results.element(k).getString & "]"
    Next

    ' Remove duplicates (TODO: improve the algorithm to remove them)
    'Logger.logInfoBoth "before:" & unFiller.results.count
    'unFiller.results.removeDuplicates
    'Logger.logInfoBoth "after:" & unFiller.results.count

    ' TODO enhance with code from here
    ' https://stackoverflow.com/questions/3017852/vba-get-unique-values-from-array
    ' https://stackoverflow.com/questions/152319/vba-array-sort-function/152325#152325



    ' Step 4, Find permutations of previous combinations
    Dim permutations As Collection
    Set permutations = New Collection

    ' Counting number of permutations:
    Dim i As Long
    Dim counts As CLongArray
    Dim permutationFinder As CFastPermutation
    Dim totalNumberOfPermutations As Double
    totalNumberOfPermutations = 0
    Set permutationFinder = New CFastPermutation
    For i = 1 To unFiller.results.count
        Set counts = unFiller.results.element(i)
        totalNumberOfPermutations = totalNumberOfPermutations + permutationFinder.noOfPermutations(counts)
    Next
    
    Logger.logInfo "Total number of permutations to find: " & totalNumberOfPermutations

    'Dim numberOfPermutationsFound As Long
    For i = 1 To unFiller.results.count
        ' Find permutations
        Set permutationFinder = New CFastPermutation
        Set counts = unFiller.results.element(i)
        'Logger.logInfoBoth "  counts: unFiller.results.element(" & i & ").getstring: " & counts.getString
        Dim tim As CTimer
        Set tim = New CTimer
        tim.startCounter
        'numberOfPermutationsFound = permutationFinder.findPermutations(counts, permutations, vbNull)   ' Collect all permutations in the permutations collection object (sent as byref)
        'Logger.logInfoBoth "  " & tim.timeElapsed & " ms"
        'Logger.logInfoBoth "  " & numberOfPermutationsFound & " permutations generated"
    Next
    Logger.logInfoBoth "  Total number of permutations found: " & permutations.count

    'Logger.logInfoBoth "  Listing generated permutations:"
    'For i = 1 To permutations.count
        'Set counts = permutations.item(i)
        'Logger.logInfoBoth "   i=" & i & ":[" & counts.getString & "]"
    'Next
End Sub


' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "OutputSheetsProxy"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("SheetRelated")
Option Explicit
Implements IOutputSheets

Private genericSheet As IGenericSheet

Private Sub class_initialize()
    Set genericSheet = New GenericSheetProxy
End Sub


' Clears the output sheet before inserting new data
Public Sub IOutputSheets_clear()
    SheetOutputLists.Cells.Delete
    SheetOutputLists.Cells.clearFormats
    SheetCuttingPattern.Cells.Delete
    SheetCuttingPattern.Cells.clearFormats
    SheetProfilesAll.Cells.Delete
    SheetRequestedAll.Cells.Delete
    SheetProfilesUnique.Cells.Delete
    SheetRequestedUnique.Cells.Delete
    SheetDiagrams.Cells.Delete
    
    ' Delete shapes from Cutlist (legend) and Picklist (buttons)
    genericSheet.clearShapes SheetOutputLists
    genericSheet.clearShapes SheetCuttingPattern
    
    ' Delete diagrams:
    genericSheet.clearDiagrams SheetDiagrams
    genericSheet.clearDiagrams SheetOutputLists
    
End Sub

Public Sub IOutputSheets_writeBinToRow( _
    ByVal bin As CBin, _
    ByVal currentRow As Long, _
    ByVal binsSheet As Worksheet _
)
    Dim currentColumn As Long
    Dim pieceNo As Long
    Dim piece As CPiece
    currentColumn = Globals.BINS_COL_FIRST
    With binsSheet
        If Globals.BINS_SHOW_PROFILE_NUMBER Then
            .Cells(currentRow, currentColumn).value = bin.profileNo & " "
            currentColumn = currentColumn + 1
        End If
        If Globals.BINS_SHOW_QUANTITY Then
            .Cells(currentRow, currentColumn).value = bin.quantity & "x"
            currentColumn = currentColumn + 1
        End If
        If Globals.BINS_SHOW_PROFILE_NUMBER Then
            .Cells(currentRow, currentColumn).value = bin.channelTypeKey
            currentColumn = currentColumn + 1
        End If
        For pieceNo = 1 To bin.pieceCount
        
            Set piece = bin.getPieceCopy(pieceNo)
            
            If piece.pieceType = enumPieceType.normal _
                Or (piece.pieceType = enumPieceType.cut And Globals.BINS_SHOW_CUT_PIECES) _
                Or (piece.pieceType = enumPieceType.waste And Globals.BINS_SHOW_WASTE_PIECES) _
            Then
                IOutputSheets_writePieceToCell piece, .Cells(currentRow, currentColumn)
                currentColumn = currentColumn + 1
            End If
        Next
    End With
End Sub

Public Sub IOutputSheets_writePieceToCell(ByVal piece As CPiece, ByVal cell As Range)
    ' Convert to mm in output
    ' Show cut pieces:
    If piece.pieceType = enumPieceType.cut Then
        cell.value = toDisplayUnitDouble(piece.length)
        ' Add coloring
        If Globals.BINS_SHOW_COLOR Then
            cell.Interior.ColorIndex = 3
        End If
    ElseIf piece.pieceType = enumPieceType.waste Then
        cell.value = toDisplayUnitDouble(piece.length)
        cell.Font.italic = True
        cell.Font.underline = False
        cell.Font.bold = False
        cell.Interior.color = 0
        cell.Font.color = 16777215 ' White
    Else
        cell.value = toDisplayUnitDouble(piece.length)
        ' Format pieces according to HPR
        If piece.hprPlacement = enumHPRPlacement.noSide Then
            cell.Font.italic = False
            cell.Font.underline = False
            cell.Font.bold = False
        ElseIf piece.hprPlacement = enumHPRPlacement.leftSide Then
            cell.Font.italic = False
            cell.Font.underline = True
            cell.Font.bold = False
        ElseIf piece.hprPlacement = enumHPRPlacement.rightSide Then
            cell.Font.italic = False
            cell.Font.underline = False
            cell.Font.bold = True
        ElseIf piece.hprPlacement = enumHPRPlacement.bothSides Then
            cell.Font.italic = False
            cell.Font.underline = True
            cell.Font.bold = True
        End If
    End If
End Sub


' Print headings
Public Sub IOutputSheets_writeBinHeadings( _
    ByVal binsSheet As Worksheet, _
    ByVal maxPieceCount As Long _
)
    Dim headingCol As Long
    Dim pieceNo As Long
    With binsSheet
        If Globals.BINS_SHOW_PROFILE_NUMBER Then
            .Range(Globals.BINS_COL_CUTTING_PROFILE & Globals.BINS_ROW_HEADING).value = Translate("tbl_cutting_profile")
        End If
        If Globals.BINS_SHOW_QUANTITY Then
            .Range(Globals.BINS_COL_QUANTITY & Globals.BINS_ROW_HEADING).value = Translate("tbl_qty")
        End If
        If Globals.BINS_SHOW_CHANNEL_TYPE Then
            .Range(Globals.BINS_COL_TYPE & Globals.BINS_ROW_HEADING).value = Translate("tbl_typ")
        End If
        
        headingCol = Globals.BINS_COL_PIECES
        ' Print heading over piece counts
        For pieceNo = 1 To maxPieceCount
            .Cells(Globals.BINS_ROW_HEADING, headingCol).value = pieceNo
            headingCol = headingCol + 1
        Next

        ' TODO: Let A:XFD depend on the constants as used above
        .Columns("A:XFD").EntireColumn.AutoFit
    End With
End Sub



Public Sub IOutputSheets_writeInputItem( _
    ByVal item As CItem, _
    ByVal rowNo As Long, _
    ByVal quantity As String, _
    ByVal inputSheet As Worksheet _
)
    Const START_COL As Long = 1
    With inputSheet
        .Cells(rowNo, START_COL).value = item.channelTypeKey
        .Cells(rowNo, START_COL + 1).value = quantity
        Debug.Print "item.cuttingType :", item.cuttingType, "cuttingTypeToString(item.cuttingType) :", cuttingTypeToString(item.cuttingType)
        .Cells(rowNo, START_COL + 2).value = cuttingTypeToString(item.cuttingType)
        .Cells(rowNo, START_COL + 3).value = toDisplayUnitDouble(item.length)
    End With
End Sub


' Print headings
Public Sub IOutputSheets_writeInputHeadings(ByVal inputSheet As Worksheet)
    With inputSheet
        .Range(Globals.OUTPUT_COL_TYPE & Globals.OUTPUT_ROW_HEADING).value = Translate("tbl_type")
        .Range(Globals.OUTPUT_COL_QUANTITY & Globals.OUTPUT_ROW_HEADING).value = Translate("tbl_qty")
        .Range(Globals.OUTPUT_COL_CUTTING_TYPE & Globals.OUTPUT_ROW_HEADING).value = Translate("tbl_cutting_type")
        .Range(Globals.OUTPUT_COL_LENGTH & Globals.OUTPUT_ROW_HEADING).value = Translate("tbl_length") & "( " & Translate("var_display_unit_mm") & " )"
        ' TODO Enhancement: Let A:D depend on the constants as used above
        .Columns("A:D").EntireColumn.AutoFit
    End With
End Sub


Public Sub IOutputSheets_addLegend()

    Const LEGEND_WIDTH As Long = 440
    Const LEGEND_HEIGHT As Long = 47
    
    Dim pos As Long
    Dim legend As String
    Dim italic As String
    Dim normal_text As String
    Dim underline As String
    Dim bold As String
    Dim bold_underline As String
    Dim red As String
    Dim waste As String
    Dim no_HPR As String
    Dim HPR_left_side As String
    Dim HPR_right_side As String
    Dim HPR_both_sides As String
    Dim extra_cut As String
    
    Dim space As String
    Dim space28 As String
    
    Dim part1 As String
    Dim part2 As String
    Dim part3 As String
    Dim part4 As String
    Dim part5 As String
    Dim part6 As String
    Dim part7 As String
    
    ' TODO Enhancement: Set placement of textbox in terms of row/col (K2)

    If shapeExists("Legend_textbox", SheetOutputLists) Then
        ' Use exising textbox
        SheetCuttingPattern.Shapes.Range(Array("Legend_textbox")).Select
    Else
        ' Add new textbox
        SheetCuttingPattern.Shapes.AddTextbox( _
            Orientation:=msoTextOrientationHorizontal, _
            Left:=1, _
            Top:=1, _
            width:=LEGEND_WIDTH, _
            height:=LEGEND_HEIGHT _
        ).Select
        Selection.name = "Legend_textbox"
    End If
    
    ' Needed for selections to work
    SheetCuttingPattern.Activate
    
    ' Translate:
    legend = Translate("var_legend")
    
    italic = Translate("var_italic")
    normal_text = Translate("var_normal_text")
    underline = Translate("var_underline")
    bold = Translate("var_bold")
    bold_underline = Translate("var_bold_underline")
    red = Translate("var_red")
    
    waste = Translate("var_waste")
    no_HPR = Translate("var_no_hpr")
    HPR_left_side = Translate("var_hpr_left_side")
    HPR_right_side = Translate("var_hpr_right_side")
    HPR_both_sides = Translate("var_hpr_both_sides")
    extra_cut = Translate("var_extra_cut")
    
    space = "      "
    space28 = "                            "
    
    part1 = legend & Chr$(13)
    part2 = italic & " = " & waste & space28
    part3 = normal_text & " = " & no_HPR & space
    part4 = underline & " = " & HPR_left_side & Chr$(13)
    part5 = bold & " = " & HPR_right_side & space
    part6 = bold_underline & " = " & HPR_both_sides & space
    part7 = red & " = " & extra_cut

    Selection.ShapeRange.TextFrame2.TextRange.Characters.Text = _
        part1 & _
        part2 & _
        part3 & _
        part4 & _
        part5 & _
        part6 & _
        part7
    
    ' Set the style of the shape
    With Selection.ShapeRange.Fill
        .visible = msoTrue
        .ForeColor.RGB = RGB(242, 242, 242)
        .ForeColor.TintAndShade = 0
        .ForeColor.Brightness = -0.0500000007
        .Transparency = 0
        .Solid
    End With

    With Selection.ShapeRange.TextFrame2.TextRange
        ' General
        .Font.size = 10
        .Font.bold = msoFalse
        pos = 1
        ' Title
        .Characters(pos, Len(legend)).Font.bold = msoTrue
        pos = pos + Len(part1)
        ' Italic
        .Characters(pos, Len(italic)).Font.italic = msoTrue
        pos = pos + Len(part2)
        ' Normal text
        pos = pos + Len(part3)
        ' Underline
        .Characters(pos, Len(underline)).Font.UnderlineStyle = msoUnderlineSingleLine
        pos = pos + Len(part4)
        ' Bold
        .Characters(pos, Len(bold)).Font.bold = msoTrue
        pos = pos + Len(part5)
        ' Bold & underline
        .Characters(pos, Len(bold_underline)).Font.bold = msoTrue
        .Characters(pos, Len(bold_underline)).Font.UnderlineStyle = msoUnderlineSingleLine
        pos = pos + Len(part6)
        ' Red
        '.Characters(pos, Len(red)).Font.bold = msoTrue
        '.Characters(pos, Len(red)).Font.UnderlineStyle = msoUnderlineSingleLine
    End With

    SheetCuttingPattern.Range("A1").Select
End Sub


Public Sub IOutputSheets_adjustCuttingPatternSheet()
    With SheetCuttingPattern
        .Columns("A:D").EntireColumn.AutoFit
        .Columns("E:XFD").ColumnWidth = 6.86
    End With
End Sub


Public Sub IOutputSheets_adjustOutputListsSheet()
    ' Adjust column widths
    With SheetOutputLists
        .Columns("A:E").EntireColumn.AutoFit
        .Columns("F:F").ColumnWidth = 5
        .Columns("G:P").EntireColumn.AutoFit
    End With
End Sub



Attribute VB_Name = "ProgressForm"
Attribute VB_Base = "0{CAB8E4CD-3312-40CD-85FD-39DC922C25A2}{442A210B-1A26-4CF8-A419-849112B94B12}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'@Folder("Classes")
Option Explicit

' ProfressForm

'##########################################################################
'##########################################################################
'Module Name: ProgressForm
'Module Type: Class
'Purpose    : Define a Progressbar Object
'##########################################################################
'Author     : Ejaz Ahmed
'Email      : StrugglingToExcel@outlook.com
'Website    : http://strugglingtoexcel.wordpress.com/
'Date       : 26 August 2014
'Modified by: JKAbrams, December 2017
'##########################################################################


'##########################################################################
'Private variables and objects
'##########################################################################
' Private variables for storing the main properties of the object
' used to set to total number of actions the user wishes to perform.

Private Type TProgressForm

    totalActions As Long
    ' Remembers the number of completed actions. This variable can be overriddin
    ' by setting a number to the actionNumber property.
    actionNumber As Long
    mainStepNumber As Long
    subStepNumber As Long
    mainTotalSteps As Long
    subTotalSteps As Long
    mainPercentComplete As String
    subPercentComplete As String
    mainLabelProgress As String
    subLabelProgress As String
    mainFractionComplete As Double
    subFractionComplete2 As Double
    mainBarWidth As Double
    subBarWidth As Double
    mainBarProgress As Double
    subBarProgress As Double
    mainLastTitle As String
    subLastTitle As String
    
    myTimer As CTimer
    firstRun As Boolean
    
    ' To remember if certain properties were set
    formShowStatus As Boolean
End Type

Private this As TProgressForm

Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Private Const FIRST_LABEL_TOP As Long = 60
Private Const LABEL_HEIGHT As Long = 19
Private Const LABEL_MARGIN As Long = 12
Private Const LABEL_MARGIN_LEFT As Long = 42
Private Const LABEL_WIDTH As Long = 276


'Private Sub cancelButton_Click()
'    terminate
'End Sub


'##########################################################################

'##########################################################################
'Error numbers and description:
'##########################################################################
' 1 - Set this property before running the show method.
' 2 - Set totalActions property First.
' 3 - Current action number is greater than total actions.
' 4 - totalActions cannot be changed after it has been set.
' 5 - Run the show method first
' 6 - Run the complete method only after all the actions have been completed.
' 7 - Progress bar has already been loaded.
'##########################################################################

'##########################################################################
'Class events
'##########################################################################


' This procedure is run when the form is initiated
'@Ignore ProcedureNotUsed
Private Sub UserForm_Initialize()
    ' Set default values for all the variables
    this.actionNumber = 0
    this.totalActions = 0
    this.formShowStatus = False
    this.totalActions = 0
    
    this.mainBarWidth = Me.MainProgressBar.width
    this.subBarWidth = this.mainBarWidth   ' Setting it to subProgressbar.width makes it not show up
        
    resetMainProgress 0
    resetSubProgress 0
    
    Set this.myTimer = New CTimer
    this.firstRun = True
    this.myTimer.startCounter
End Sub


'@Ignore UseMeaningfulName
Public Sub resetMainProgress(ByVal totalSteps As Long)
    this.mainStepNumber = 0
    this.mainTotalSteps = totalSteps
    this.mainPercentComplete = vbNullString
    this.mainFractionComplete = 0
    this.mainBarProgress = 0
    this.mainLabelProgress = vbNullString
End Sub


'@Ignore UseMeaningfulName
Public Sub resetSubProgress(ByVal totalSteps As Long)
    this.subStepNumber = 0
    this.subTotalSteps = totalSteps
    this.subPercentComplete = vbNullString
    this.subFractionComplete2 = 0
    this.subBarProgress = 0
    this.subLabelProgress = vbNullString
End Sub


' This sub is run when the class is terminated
'@Ignore ProcedureNotUsed
Private Sub userForm_Terminate()
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    End
End Sub


'##########################################################################
'Public methods
'##########################################################################


Public Sub addAction(ByVal actionTitle As String)
        
    Dim actionLabel As Variant
    
    Set actionLabel = Me.Controls.Add("Forms.Label.1", "lblAction" & (this.totalActions + 1), True)
    With actionLabel
        .Font.size = 16
        .ForeColor = RGB(200, 200, 200)
        .Font.name = "Tahoma"
        .Top = (LABEL_HEIGHT + LABEL_MARGIN) * this.totalActions + FIRST_LABEL_TOP
        .Left = LABEL_MARGIN_LEFT
        .width = LABEL_WIDTH
        .height = LABEL_HEIGHT
        .Caption = actionTitle
    End With

    this.totalActions = this.totalActions + 1
    ' Change height of the progressform
    Me.height = Me.height + LABEL_HEIGHT + LABEL_MARGIN
    ' Change the location of the lower frame
    Me.FrameLower.Top = Me.FrameLower.Top + LABEL_HEIGHT + LABEL_MARGIN
End Sub


Public Sub setTitle(ByVal title As String)
    Me.Controls.item("lbl_optimizing").Caption = title
End Sub


'Public Sub addCancelButton()
'    Dim cancelButton As Variant
'    Set cancelButton = Me.Controls.Add("Forms.CommandButton.1", "cmd1")
'    With cancelButton
'        .Top = (LABEL_HEIGHT + LABEL_MARGIN) * (cTotalActions - 1) + FIRST_LABEL_TOP
'        .left = 230
'        .width = 80
'        .height = 20
'        .Caption = "Cancel"
'    End With
'End Sub


Public Sub showBar()
    If this.formShowStatus Then
        Err.Raise 7, "progress bar", "Progress Bar has already been Loaded."
    Else
        ' DoEvents makes sure the rest of the macro keeps running
        DoEvents
        ' Set the width of the progressbar to zero
        Me.MainProgressBar.width = 0
        ' Initialize the private class variable
        this.formShowStatus = True
        ' Show the form
        Me.show
        ' Repaint the form
        Me.Repaint
    End If
End Sub


Public Sub showMainProgressBar(ByVal labelString As String)
    Me.MainProgressBox.visible = True
    Me.MainProgressBar.visible = True
    Me.MainProgressLabel.Caption = labelString
    Me.MainProgressLabel.visible = True
    Me.MainProgressBar.width = 0
    Me.FrameLower.Repaint
End Sub


Public Sub showSubProgressBar(ByVal labelString As String)
    Me.SubProgressBox.visible = True
    Me.SubProgressBar.visible = True
    Me.SubProgressLabel.Caption = labelString
    Me.SubProgressLabel.visible = True
    Me.SubProgressBar.width = 0
    Me.FrameLower.Repaint
End Sub


Public Sub hideMainProgressBar()
    Me.MainProgressBox.visible = False
    Me.MainProgressBar.visible = False
    Me.MainProgressLabel.visible = False
End Sub


Public Sub hideSubProgressBar()
    Me.SubProgressBox.visible = False
    Me.SubProgressBar.visible = False
    Me.SubProgressLabel.visible = False
End Sub


' nextAction: Let the Progressbar know an action has been completed. I recommend using this
' method over manually overriding the progressStatusMessage and currentAction properties
Public Sub nextAction()
    this.actionNumber = this.actionNumber + 1
    updateAction
    Sleep 200
End Sub


Public Sub nextStepMain(ByVal title As String)
    ' TODO Change this quick fix to a proper fix
    If this.subTotalSteps > 0 Then
        this.mainFractionComplete = this.mainStepNumber / this.mainTotalSteps
        this.mainStepNumber = this.mainStepNumber + 1
        this.mainBarProgress = this.mainBarProgress * this.mainFractionComplete
        this.mainPercentComplete = Format$(this.mainFractionComplete * 100, "0") & "%"
        If Not title = vbNullString Then
            this.mainLabelProgress = _
                title & _
                this.mainStepNumber & "/" & this.mainTotalSteps & _
                " (" & this.mainPercentComplete & ")"
        Else
            this.mainLabelProgress = _
                this.mainLastTitle & _
                this.mainStepNumber & "/" & this.mainTotalSteps & _
                " (" & this.mainPercentComplete & ")"
        End If
        this.mainLastTitle = title
        updateMainProgress
    End If
End Sub


Public Sub nextStepSub(ByVal title As String)
    ' TODO Change this quick fix to a proper fix
    If this.subTotalSteps > 0 Then
        this.subFractionComplete2 = this.subStepNumber / this.subTotalSteps
        this.subStepNumber = this.subStepNumber + 1
        this.subBarProgress = this.subBarProgress * this.subFractionComplete2
        this.subPercentComplete = Format$(this.subFractionComplete2 * 100, "0") & "%"
        If Not title = vbNullString Then
            this.subLabelProgress = _
                title & _
                this.subStepNumber & "/" & this.subTotalSteps & _
                " (" & this.subPercentComplete & ")"
        Else
            this.subLabelProgress = _
                this.subLastTitle & _
                this.subStepNumber & "/" & this.subTotalSteps & _
                " (" & this.subPercentComplete & ")"
        End If
        this.subLastTitle = title
        updateSubProgress
    End If
End Sub


Public Sub moreStepsSub(ByVal steps As Long)
    this.subFractionComplete2 = this.subStepNumber / this.subTotalSteps
    this.subStepNumber = this.subStepNumber + steps
    this.subBarProgress = this.subBarProgress * this.subFractionComplete2
    this.subPercentComplete = Format$(this.subFractionComplete2 * 100, "0") & "%"
    this.subLabelProgress = _
        this.subLastTitle & _
        this.subStepNumber & "/" & this.subTotalSteps & _
        "(" & this.subPercentComplete & ")"
    updateSubProgress
End Sub


Public Sub finnishMain()
    ' TODO: Find proper fix
    ' Protect from overflow
    If this.mainTotalSteps > 0 Then
        this.mainFractionComplete = this.mainStepNumber / this.mainTotalSteps
        this.mainBarProgress = this.mainBarProgress * this.mainFractionComplete
        this.mainPercentComplete = Format$(this.mainFractionComplete * 100, "0") & "%"
        this.mainLabelProgress = _
            this.mainLastTitle & _
            this.mainStepNumber & "/" & this.mainTotalSteps & _
            " (" & this.mainPercentComplete & ")"
        updateMainProgress
    End If
End Sub


Public Sub finnishSub()
    ' TODO: Find proper fix
    ' Protect from overflow
    If this.subTotalSteps > 0 Then
        this.subFractionComplete2 = this.subStepNumber / this.subTotalSteps
        this.subBarProgress = this.subBarProgress * this.subFractionComplete2
        this.subPercentComplete = Format$(this.subFractionComplete2 * 100, "0") & "%"
        this.subLabelProgress = _
            this.subLastTitle & _
            this.subStepNumber & "/" & this.subTotalSteps & _
            " (" & this.subPercentComplete & ")"
        updateSubProgress
    End If
End Sub


' complete: This method can be used to let the user know that the run has
' been completed. It changes the statues message to the message specified
' and releases the control this object has over the excel status bar.
Public Sub complete(Optional ByVal WaitForMilliSeconds As Long = 0)
    ' Proceed if the ProgressBar has already been loaded
    ' Display an error message otherwise
    If this.formShowStatus Then
        If WaitForMilliSeconds > 0 Then
            DoEvents
            Sleep WaitForMilliSeconds
            terminate
        Else
            ' DoEvents makes sure the rest of the macro keeps running
            DoEvents
        End If
    Else
        Err.Raise 5, "progress bar", "Run the show method first"
    End If
End Sub


' terminate: Let the user terminate manually if they prefer
Public Sub terminate()
    ' Terminate the form if it is already loaded. Display an error message otherwise
    If this.formShowStatus Then
        ' If the form is loaded, unload it
        Me.Hide
        this.formShowStatus = False
        this.actionNumber = 0
        this.totalActions = 0
    Else
        Err.Raise 5, "progress bar", "Run the show method first"
    End If
End Sub

'##########################################################################

Private Sub updateMainProgress()
    
    ' DoEvents makes sure the rest of the macro keeps running
    DoEvents
    this.mainBarProgress = this.mainBarWidth * this.mainFractionComplete
    
    ' Change the width of the label
    Me.MainProgressBar.width = this.mainBarProgress
    Me.MainProgressLabel.Caption = this.mainLabelProgress
    
    If this.firstRun Or this.myTimer.timeElapsed > 200 Then

        ' Repaint only the lower part of the form
        Me.FrameLower.Repaint

        ' Reset timer
        this.myTimer.startCounter
        this.firstRun = False
    End If
End Sub


Private Sub updateSubProgress()
    
    ' DoEvents makes sure the rest of the macro keeps running
    DoEvents
    this.subBarProgress = this.subBarWidth * this.subFractionComplete2
    
    ' Change the width of the label
    Me.SubProgressBar.width = this.subBarProgress
    Me.SubProgressLabel.Caption = this.subLabelProgress
    
    If this.firstRun Or this.myTimer.timeElapsed > 200 Then

        ' Repaint only the lower part of the form
        Me.FrameLower.Repaint

        ' Reset timer
        this.myTimer.startCounter
        this.firstRun = False
    End If
End Sub


Private Sub updateAction()
    
    ' DoEvents makes sure the rest of the macro keeps running
    DoEvents
    
    ' Change currently showing action
    Me.Controls("lblAction" & this.actionNumber).Font.bold = True
    Me.Controls("lblAction" & this.actionNumber).ForeColor = RGB(0, 0, 0)
    If this.actionNumber > 1 Then
        ' Change previous
        Me.Controls("lblAction" & (this.actionNumber - 1)).Font.bold = False
        Me.Controls("lblAction" & (this.actionNumber - 1)).ForeColor = RGB(0, 0, 0)
    End If
    
    ' Repaint the form
    Me.Repaint
End Sub
Attribute VB_Name = "SheetChannelOverview"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SheetChannelTypesInch"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)
Exit Sub
If gbStopCellChange = True Then Exit Sub

    ensureGlobalObjectsExist
    If Settings.inputValidationOnchange Then
        Dim interestingRange As Range
        Set interestingRange = Intersect( _
            userChangedRange, _
            Me.Range( _
                Globals.CHTYPE_COL_ENABLED & _
                ":" & _
                Globals.CHTYPE_COL_BUNDLE_SIZE _
            ) _
        )
        If Not interestingRange Is Nothing Then
            ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
            If Not rangeAddressRepresentsColumn(interestingRange.Address) _
                And Not interestingRange.Rows.count > 50000 _
            Then
                Dim rowNo As Long
                Dim appProxy As IApplication
                Set appProxy = New ApplicationProxy
                appProxy.disableWhileRunning
                ' This loop makes it work if multiple cells are changed, for example when pasting cells
                For rowNo = 1 To interestingRange.Cells.count
                    ' Protect the header rows
                    If interestingRange.Cells(rowNo).Row >= Globals.CHTYPE_ROW_FIRST Then
                        checkChannelTypes_cell _
                            interestingRange.Cells(rowNo).Row, _
                            interestingRange.Cells(rowNo).Column
                    End If
                Next
                appProxy.enableAfterRunning
            End If
        End If
    End If
End Sub


Attribute VB_Name = "SheetChannelTypesMM"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)
Exit Sub
If gbStopCellChange = True Then Exit Sub

    ensureGlobalObjectsExist
    If Settings.inputValidationOnchange Then
        Dim interestingRange As Range
        Set interestingRange = Intersect( _
            userChangedRange, _
            Me.Range( _
                Globals.CHTYPE_COL_ENABLED & _
                ":" & _
                Globals.CHTYPE_COL_BUNDLE_SIZE _
            ) _
        )
        If Not interestingRange Is Nothing Then
            ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
            If Not rangeAddressRepresentsColumn(interestingRange.Address) _
                And Not interestingRange.Rows.count > 50000 _
            Then
                Dim rowNo As Long
                Dim appProxy As IApplication
                Set appProxy = New ApplicationProxy
                appProxy.disableWhileRunning
                ' This loop makes it work if multiple cells are changed, for example when pasting cells
                For rowNo = 1 To interestingRange.Cells.count
                    ' Protect the header rows
                    If interestingRange.Cells(rowNo).Row >= Globals.CHTYPE_ROW_FIRST Then
                        checkChannelTypes_cell _
                            interestingRange.Cells(rowNo).Row, _
                            interestingRange.Cells(rowNo).Column
                    End If
                Next
                appProxy.enableAfterRunning
            End If
        End If
    End If
End Sub


Attribute VB_Name = "SheetCountries"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)
Exit Sub
If gbStopCellChange = True Then Exit Sub

    ensureGlobalObjectsExist
    If Settings.inputValidationOnchange Then
        Dim interestingRange As Range
        Set interestingRange = Intersect( _
            userChangedRange, _
            Me.Range( _
                Globals.COUNTRIES_COL_COUNTRY & _
                ":" & _
                Globals.COUNTRIES_COL_CUTTING_METHOD _
            ) _
        )
        If Not interestingRange Is Nothing Then
            ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
            If Not rangeAddressRepresentsColumn(interestingRange.Address) _
                And Not interestingRange.Rows.count > 50000 _
            Then
                Dim rowNo As Long
                Dim appProxy As IApplication
                Set appProxy = New ApplicationProxy
                appProxy.disableWhileRunning
                ' This loop makes it work if multiple cells are changed, for example when pasting cells
                For rowNo = 1 To interestingRange.Cells.count
                    ' Protect the header rows
                    If interestingRange.Cells(rowNo).Row >= Globals.COUNTRIES_ROW_FIRST Then
                        ' This sheet does have any fancy checking currently, just reread the setting
                        Settings.readMaterialCountry
                    End If
                Next
                appProxy.enableAfterRunning
            End If
        End If
    End If
End Sub
Attribute VB_Name = "SheetCuttingPattern"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "SheetDiagrams"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SheetHowToUse"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Private Sub Worksheet_Activate()

End Sub

Attribute VB_Name = "SheetImages"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SheetOutputLists"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)

Exit Sub

If gbStopCellChange = True Then Exit Sub

    ensureGlobalObjectsExist
    
    If Settings.inputValidationOnchange Then
    
        Dim interestingRange As Range
        
        Set interestingRange = Intersect( _
            userChangedRange, _
            Me.Range( _
                Globals.OUTPUTLISTS_HEADER_RANGE & _
                ":" & _
                Globals.OUTPUTLISTS_HEADER_SAP_CUSTOMER_NO _
            ) _
        )
        If Not interestingRange Is Nothing Then
            ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
            If Not rangeAddressRepresentsColumn(interestingRange.Address) _
                And Not interestingRange.Rows.count > 50000 _
            Then
                Dim appProxy As IApplication
                
                Set appProxy = New ApplicationProxy
                
                appProxy.disableWhileRunning
                
                ' This loop makes it work if multiple cells are changed, for example when pasting cells
                If userChangedRange.Address = Globals.OUTPUTLISTS_HEADER_SAP_ORDER_NO Then
                    ' Check
                    checkOutputLists_sap_order_no
                ElseIf userChangedRange.Address = Globals.OUTPUTLISTS_HEADER_SAP_CUSTOMER_NO Then
                    ' Check
                    checkOutputLists_sap_customer_no
                End If
                
                appProxy.enableAfterRunning
                
            End If
        End If
    End If
End Sub
Attribute VB_Name = "SheetProfilesAll"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SheetProfilesUnique"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SheetRequest"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)
    
'    ensureGlobalObjectsExist
'    If Settings.inputValidationOnchange Then
'        Dim requestRange As Range
'
'        Set requestRange = Intersect( _
'            userChangedRange, _
'            Me.Range(Globals.REQUEST_COL_TYPE & ":" & Globals.REQUEST_COL_DEVIATING_MINIMUM_REMAINING_WEB_WIDTH) _
'        )
'
'        If userChangedRange.address = Globals.REQUEST_OPTIMIZATION_MODE Then
'            ' Set Optimization mode
'            Settings.readOptimizationMode
'        ElseIf Not requestRange Is Nothing Then
'            ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
'            If Not rangeAddressRepresentsColumn(requestRange.address) _
'                And Not requestRange.Rows.count > 50000 _
'            Then
'                Dim rowNo As Long
'                Dim appProxy As IApplication
'                Set appProxy = New ApplicationProxy
'
'                appProxy.disableWhileRunning
'
'                ' Reset toleranceMode (we will figure it out by the first significant cuttingType type)
'                Request.setToleranceMode = enumToleranceMode.modeNotSet
'
'                ' This loop makes it work if multiple cells are changed, for example when pasting cells
'                For rowNo = 1 To requestRange.Cells.count
'                    ' Protect the header rows
'                    If requestRange.Cells(rowNo).Row >= Globals.REQUEST_ROW_FIRST Then
'                        checkRequest_cell _
'                            requestRange.Cells(rowNo).Row, _
'                            requestRange.Cells(rowNo).Column
'                    End If
'                Next
'                appProxy.enableAfterRunning
'            End If
'        End If
'    End If
End Sub
Attribute VB_Name = "SheetRequestedAll"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SheetRequestedUnique"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SheetSettings"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit


' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)
Exit Sub
If gbStopCellChange = True Then Exit Sub

    ensureGlobalObjectsExist
    Dim interestingRange As Range
    Set interestingRange = Intersect( _
        userChangedRange, _
        Me.Range( _
            Globals.SETTINGS_COL_VALUE & _
            ":" & _
            Globals.SETTINGS_COL_VALUE _
        ) _
    )
    If Not interestingRange Is Nothing Then
        ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
        If Not rangeAddressRepresentsColumn(interestingRange.Address) _
        And Not interestingRange.Rows.count > 50000 Then
            Dim appProxy As IApplication
            Set appProxy = New ApplicationProxy
            
            appProxy.disableWhileRunning
            ' This loop makes it work if multiple cells are changed, for example when pasting cells
            ' Protect the header rows
            If userChangedRange.Address = ( _
                "$" & Globals.SETTINGS_COL_VALUE & _
                "$" & Globals.SETTINGS_ROW_MAXIMUM_CUTTING_WIDTH _
            ) Then
                ' Set Maximum cutting width only if the value is valid
                If checkSettings_maximum_cutting_width Then
                    Settings.readMaximumCuttingWidth
                End If
            ElseIf userChangedRange.Address = ( _
                "$" & Globals.SETTINGS_COL_VALUE & _
                "$" & Globals.SETTINGS_ROW_CUTFREE_SPACE_END _
            ) Then
                ' Set Cut-free space end only if the value is valid
                If checkSettings_cutfree_space_end Then
                    Settings.readCutfreeSpaceEnd
                End If
            ElseIf userChangedRange.Address = ( _
                "$" & Globals.SETTINGS_COL_VALUE & _
                "$" & Globals.SETTINGS_ROW_DEFAULT_TOLERANCE _
            ) Then
                ' Set default tolerance only if the value is valid
                If checkSettings_default_tolerance Then
                    Settings.readDefaultTolerance
                End If
            ElseIf userChangedRange.Address = ( _
                "$" & Globals.SETTINGS_COL_VALUE & _
                "$" & Globals.SETTINGS_ROW_MATERIAL_COUNTRY _
            ) Then
                ' Set Channels made in
                Settings.readMaterialCountry
            ElseIf userChangedRange.Address = ( _
                "$" & Globals.SETTINGS_COL_VALUE & _
                "$" & Globals.SETTINGS_ROW_LANGUAGE _
            ) Then
                ' Set Language
                Settings.readLanguage
            ElseIf userChangedRange.Address = ( _
                "$" & Globals.SETTINGS_COL_VALUE & _
                "$" & Globals.SETTINGS_ROW_LOGGING _
            ) Then
                ' Set Logging
                Settings.readLogging
            End If
            Logger.logInfo "Enable SheetSettings.worksheetChange()"
            appProxy.enableAfterRunning
        End If
    End If
End Sub


' Check maximum cutting width, returns true if OK
Private Function checkSettings_maximum_cutting_width() As Boolean
    Dim note As String
    checkSettings_maximum_cutting_width = False
    note = settings_check_maximum_cutting_width
    
    SheetSettings.Range( _
        "$" & Globals.SETTINGS_COL_ERROR & _
        "$" & Globals.SETTINGS_ROW_MAXIMUM_CUTTING_WIDTH _
    ).value = note
    If note = vbNullString Then
        checkSettings_maximum_cutting_width = True
    End If
End Function


' Check end material left, returns true if OK
Private Function checkSettings_cutfree_space_end() As Boolean
    Dim note As String
    checkSettings_cutfree_space_end = False
    note = settings_check_cutfree_space_end
    
    SheetSettings.Range( _
        "$" & Globals.SETTINGS_COL_ERROR & _
        "$" & Globals.SETTINGS_ROW_CUTFREE_SPACE_END _
    ).value = note
    If note = vbNullString Then
        checkSettings_cutfree_space_end = True
    End If
End Function


' Check end default tolerance, returns true if OK
Private Function checkSettings_default_tolerance() As Boolean
    Dim note As String
    checkSettings_default_tolerance = False
    note = settings_check_default_tolerance
    
    SheetSettings.Range( _
        "$" & Globals.SETTINGS_COL_ERROR & _
        "$" & Globals.SETTINGS_ROW_DEFAULT_TOLERANCE _
    ).value = note
    If note = vbNullString Then
        checkSettings_default_tolerance = True
    End If
End Function


' Makes sure that Maximum cutting width is a whole number larger than -1
Private Function settings_check_maximum_cutting_width() As String
    Dim value As String
    value = SheetSettings.Range( _
        "$" & Globals.SETTINGS_COL_VALUE & _
        "$" & Globals.SETTINGS_ROW_MAXIMUM_CUTTING_WIDTH _
    ).value
    settings_check_maximum_cutting_width = vbNullString
    If value = vbNullString Then
        settings_check_maximum_cutting_width = _
            Translate("error_value") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            settings_check_maximum_cutting_width = _
                Translate("error_value") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            settings_check_maximum_cutting_width = _
                Translate("error_value") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            settings_check_maximum_cutting_width = _
                Translate("error_value") & " " & _
                Translate("error_contains_a_dot")
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        settings_check_maximum_cutting_width = _
            Translate("error_value") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that Cut-free space end is a whole number larger than -1
Private Function settings_check_cutfree_space_end() As String
    Dim value As String
    value = SheetSettings.Range( _
        "$" & Globals.SETTINGS_COL_VALUE & _
        "$" & Globals.SETTINGS_ROW_CUTFREE_SPACE_END _
    ).value
    settings_check_cutfree_space_end = vbNullString
    If value = vbNullString Then
        settings_check_cutfree_space_end = _
            Translate("error_value") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            settings_check_cutfree_space_end = _
                Translate("error_value") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            settings_check_cutfree_space_end = _
                Translate("error_value") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            settings_check_cutfree_space_end = _
                Translate("error_value") & " " & _
                Translate("error_contains_a_dot")
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        settings_check_cutfree_space_end = _
            Translate("error_value") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function


' Makes sure that Default tolerance is a whole number larger than -1
Private Function settings_check_default_tolerance() As String
    Dim value As String
    value = SheetSettings.Range( _
        "$" & Globals.SETTINGS_COL_VALUE & _
        "$" & Globals.SETTINGS_ROW_DEFAULT_TOLERANCE _
    ).value
    settings_check_default_tolerance = vbNullString
    If value = vbNullString Then
        settings_check_default_tolerance = _
            Translate("error_value") & " " & _
            Translate("error_is_missing")
    ElseIf IsNumeric(value) Then
        If Not Int(value) = value Then
            settings_check_default_tolerance = _
                Translate("error_value") & " " & _
                Translate("error_cannot_be_decimal")
        ElseIf value < 0 Then
            settings_check_default_tolerance = _
                Translate("error_value") & " " & _
                Translate("error_is_below_0")
        ElseIf InStr(1, value, ".") > 0 Then
            settings_check_default_tolerance = _
                Translate("error_value") & " " & _
                Translate("error_contains_a_dot")
        'Else
            ' OK!
        End If
    ElseIf Not IsNumeric(value) Then
        settings_check_default_tolerance = _
            Translate("error_value") & " " & _
            Translate("error_is_not_a_number")
    End If
End Function
Attribute VB_Name = "SheetTechnicalDataInch"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)
Exit Sub
If gbStopCellChange = True Then Exit Sub

    ensureGlobalObjectsExist
    If Settings.inputValidationOnchange Then
        Dim interestingRange As Range
        Set interestingRange = Intersect( _
            userChangedRange, _
            Me.Range( _
                Globals.TECHNICAL_DATA_COL_TYPE & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS _
            ) _
        )
        If Not interestingRange Is Nothing Then
            ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
            If Not rangeAddressRepresentsColumn(interestingRange.Address) _
                And Not interestingRange.Rows.count > 50000 _
            Then
                Dim rowNo As Long
                Dim appProxy As IApplication
                Set appProxy = New ApplicationProxy
                appProxy.disableWhileRunning
                ' This loop makes it work if multiple cells are changed, for example when pasting cells
                For rowNo = 1 To interestingRange.Cells.count
                    ' Protect the header rows
                    If interestingRange.Cells(rowNo).Row >= Globals.TECHNICAL_DATA_ROW_FIRST Then
                        checkTechnicalData_cell _
                            interestingRange.Cells(rowNo).Row, _
                            interestingRange.Cells(rowNo).Column
                    End If
                Next
                appProxy.enableAfterRunning
            End If
        End If
    End If
End Sub

Attribute VB_Name = "SheetTechnicalDataMM"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

' Run every time something is changed in the sheet, it then filters on actions in the table
Private Sub Worksheet_Change(ByVal userChangedRange As Range)

Exit Sub
If gbStopCellChange = True Then Exit Sub

    ensureGlobalObjectsExist
    If Settings.inputValidationOnchange Then
        Dim interestingRange As Range
        Set interestingRange = Intersect( _
            userChangedRange, _
            Me.Range( _
                Globals.TECHNICAL_DATA_COL_TYPE & _
                ":" & _
                Globals.TECHNICAL_DATA_COL_HOLE_LENGTH_ERROR_MINUS _
            ) _
        )
        If Not interestingRange Is Nothing Then
            ' Guard against the user inserting a Column as well as excessive number of rows, arbitrarily set at 50000
            If Not rangeAddressRepresentsColumn(interestingRange.Address) _
                And Not interestingRange.Rows.count > 50000 _
            Then
                Dim rowNo As Long
                Dim appProxy As IApplication
                Set appProxy = New ApplicationProxy
                appProxy.disableWhileRunning
                ' This loop makes it work if multiple cells are changed, for example when pasting cells
                For rowNo = 1 To interestingRange.Cells.count
                    ' Protect the header rows
                    If interestingRange.Cells(rowNo).Row >= Globals.TECHNICAL_DATA_ROW_FIRST Then
                        checkTechnicalData_cell _
                            interestingRange.Cells(rowNo).Row, _
                            interestingRange.Cells(rowNo).Column
                    End If
                Next
                appProxy.enableAfterRunning
            End If
        End If
    End If
End Sub

Attribute VB_Name = "SheetTranslations"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
'@Folder("Sheets")
Option Explicit

Attribute VB_Name = "SupportFunctionsGeneric"
'@Folder("GlobalSupportFunctions")
Option Explicit

'
' Collection of Generic Support Functions,
' ie. boring support functions that does something generic like clearing a row

' Returns a random integer between the provided bounds
Public Function getRandomNumber( _
    ByVal lb As Long, _
    ByVal ub As Long _
) As Long
    Randomize
    getRandomNumber = Int((ub - lb + 1) * Rnd + lb)
End Function

' Clear the given column to the last input, starting from the given row number
Public Sub clearRow( _
    ByVal Sheet As Worksheet, _
    ByVal firstRow As Long, _
    ByVal col As String _
)
    Dim lastRow As Long
    With Sheet
        lastRow = .Range(col & .Rows.count).End(xlUp).Row
        If lastRow >= firstRow Then
            .Range(col & firstRow & ":" & col & lastRow).ClearContents
        End If
    End With
End Sub

' Takes an array and returns an array with only unique values
'Public Function unique(ByVal inArray As Variant) As Variant
'    Dim arrCollection As Collection
'    Set arrCollection = New Collection
'    Dim key As Variant
'    Dim arrOut As Variant
'    Dim i As Long
'
'    ' Duplicate keys will return an error, which will be ignored, thus we end up with a collection of unique values
'    On Error Resume Next
'    For Each key In inArray
'        arrCollection.Add key, key
'    Next
'
'    ' Translate collation into variant
'    ReDim arrOut(1 To arrCollection.count)
'    For i = 1 To arrCollection.count
'        arrOut(i) = arrCollection(i)
'    Next
'
'    unique = arrOut
'End Function


' Searches the given array for the given string, returns true if found
'Public Function isInArray(ByVal stringToBeFound As String, ByVal arr As Variant) As Boolean
'    isInArray = (UBound(Filter(arr, stringToBeFound)) > -1)
'End Function


' Returns true if Num is a multiple of 10
'Public Function isMultipleTen(ByVal num As Long) As Boolean
'    isMultipleTen = num / 10 = Fix(num / 10)
'End Function


' Rounds up
'@Ignore UseMeaningfulName
Public Function ceiling( _
    ByVal x As Double, _
    Optional ByVal factor As Long = 1 _
) As Long
    ' X is the value you want to round
    ' Factor is the multiple to which you want to round
    ceiling = (Int(x / factor) - (x / factor - Int(x / factor) > 0)) * factor
End Function

' Rounds down
'@Ignore UseMeaningfulName
Public Function floor( _
    ByVal x As Double, _
    Optional ByVal factor As Long = 1 _
) As Long
    ' X is the value you want to round
    ' Factor is the multiple to which you want to round
    floor = Int(x / factor) * factor
End Function

' Converts a string of letters into the corresponding column number
' Maximum allowed input is XFD, higher values and the function will return -1
Public Function letter2Column(ByVal letter As String) As Long
    ' Prevent errors on too large columns
    If Len(letter) < 4 And Right$("AA" & letter, 3) < "XFE" Then
        letter2Column = ActiveSheet.Range(letter & 1).Column
    Else
        letter2Column = -1
    End If
End Function

' Converts a column number to a letter sequence
' Maximum allowed is column number in Excel is 16384, lowest is 1, values outside of this scope will return an empty string
Public Function column2Letter(ByVal inCol As Long) As String
    '@Ignore UseMeaningfulName
    Dim n As Long
    '@Ignore UseMeaningfulName
    Dim c As Byte
    '@Ignore UseMeaningfulName
    Dim S As String

    If inCol > 0 And inCol <= 16384 Then
        n = inCol
        Do
            c = (n - 1) Mod 26
            S = Chr$(c + 65) & S
            n = (n - c) \ 26
        Loop While n > 0
        column2Letter = S
    Else
        column2Letter = vbNullString
    End If
End Function

' Returns true if the a shape exists with the given name in the given worksheet
Public Function shapeExists( _
    ByVal name As String, _
    ByVal Sheet As Worksheet _
) As Boolean
    Dim shapeNo As Long
    shapeExists = False
    If Sheet.Shapes.count = 0 Then Exit Function
    For shapeNo = 1 To Sheet.Shapes.count
        If Sheet.Shapes.item(shapeNo).name = name Then
            shapeExists = True
            Exit Function
        End If
    Next
End Function

' Takes an address string as input and determines if it represents a full column
' A full column is on the form $A:$A for a single column or $A:$C for multiple colums.
' The unique characteristic of a column address is that it has always two
' dollar signs and one colon
Public Function rangeAddressRepresentsColumn(ByVal Address As String) As Boolean
    Dim dollarSignCount As Long
    Dim hasColon As Boolean
    Dim counter As Long
    hasColon = False
    dollarSignCount = 0
    ' Loop through each character in the string
    For counter = 1 To Len(Address)
        If Mid$(Address, counter, 1) = "$" Then
            dollarSignCount = dollarSignCount + 1
        ElseIf Mid$(Address, counter, 1) = ":" Then
            hasColon = True
        End If
    Next
    '@Ignore BooleanAssignedInIfElse
    If hasColon And dollarSignCount = 2 Then
        rangeAddressRepresentsColumn = True
    Else
        rangeAddressRepresentsColumn = False
    End If
End Function

' Returns the variable type as a string
'Public Function getVariableType(ByVal myVar As Variant) As String
'    ' ---------------------------------------------------------------
'    ' Written By Shanmuga Sundara Raman for http://vbadud.blogspot.com
'    ' ---------------------------------------------------------------
'    If VarType(myVar) = vbNull Then
'        getVariableType = "Null (no valid data) "
'    ElseIf VarType(myVar) = vbInteger Then
'        getVariableType = "Integer "
'    ElseIf VarType(myVar) = vbLong Then
'        getVariableType = "Long integer "
'    ElseIf VarType(myVar) = vbSingle Then
'        getVariableType = "Single-precision floating-point number "
'    ElseIf VarType(myVar) = vbDouble Then
'        getVariableType = "Double-precision floating-point number "
'    ElseIf VarType(myVar) = vbCurrency Then
'        getVariableType = "Currency value "
'    ElseIf VarType(myVar) = vbDate Then
'        getVariableType = "Date value "
'    ElseIf VarType(myVar) = vbString Then
'        getVariableType = "String "
'    ElseIf VarType(myVar) = vbObject Then
'        getVariableType = "Object "
'    ElseIf VarType(myVar) = vbError Then
'        getVariableType = "Error value "
'    ElseIf VarType(myVar) = vbBoolean Then
'        getVariableType = "Boolean value "
'    ElseIf VarType(myVar) = vbVariant Then
'        getVariableType = "Variant (used only with arrays of variants) "
'    ElseIf VarType(myVar) = vbDataObject Then
'        getVariableType = "A data access object "
'    ElseIf VarType(myVar) = vbDecimal Then
'        getVariableType = "Decimal value "
'    ElseIf VarType(myVar) = vbByte Then
'        getVariableType = "Byte value "
'    ElseIf VarType(myVar) = vbUserDefinedType Then
'        getVariableType = "Variants that contain user-defined types "
'    ElseIf VarType(myVar) = vbArray Then
'        getVariableType = "Array "
'    Else
'        getVariableType = VarType(myVar)
'    End If
'
'    ' Excel VBA, Visual Basic, Get Variable Type, VarType
'End Function


'Public Function fileFolderExists(ByVal fullPath As String) As Boolean
'    Dim check As String
'    check = Dir(fullPath)
'    If Len(check) > 0 Then
'        fileFolderExists = True
'    Else
'        fileFolderExists = False
'    End If
'End Function


' Rounds to closest 10 according to specification
' num is reference
' Returns true on success
'Public Function roundToTen(ByRef num As Long, ByVal roundDownOk As Boolean, ByVal roundUpOk As Boolean) As Boolean
'    Dim rest As Long
'    roundToTen = False
'    rest = num Mod 10
'    If rest = 0 Then
'        ' already rounded
'        roundToTen = True
'    ElseIf rest > 0 And rest < 5 Or rest < -5 Then
'        If roundDownOk Then
'            ' Round down
'            num = num - rest
'            roundToTen = True
'        ElseIf roundUpOk Then
'            ' Round down
'            num = num + (10 - rest)
'            roundToTen = True
'        End If
'    Else
'        If roundUpOk Then
'            ' Round up
'            num = num + (10 - rest)
'            roundToTen = True
'        ElseIf roundDownOk Then
'            ' Round down
'            num = num - rest
'            roundToTen = True
'        End If
'    End If
'End Function


Public Function round10up(ByVal val As Long) As Long
    round10up = ceiling(val / 10) * 10
End Function

Public Function round10down(ByVal val As Long) As Long
    round10down = floor(val / 10) * 10
End Function

'Public Function getRounding10up(ByVal val As Long) As Long
'    getRounding10up = val - round10up(val)
'End Function

'@Ignore UseMeaningfulName
Public Function getRounding10(ByVal val As Long) As Long
    If val > 0 Then
        getRounding10 = val - round10down(val)
    Else
        getRounding10 = val - round10up(val)
    End If
End Function

'@Ignore UseMeaningfulName
Public Function getRoundingAdj10(ByVal val As Long) As Long
    If val > 0 Then
        getRoundingAdj10 = 10 - getRounding10(val)
    Else
        getRoundingAdj10 = -(10 + getRounding10(val))
    End If
    If getRoundingAdj10 = 10 Or getRoundingAdj10 = -10 Then
        getRoundingAdj10 = 0
    End If
End Function

Public Function getRounding10abs(ByVal val As Long) As Long
    getRounding10abs = Abs(getRounding10(val))
End Function

' Takes a range and a rowNo and an optional colNo and returns the data as a string
' If colNo is not specified it is assumed to be 1 (a one column range)
Public Function rangeGetString( _
    ByRef myRange As Variant, _
    ByVal rowNo As Long, _
    Optional ByVal columnNo As Long = 1 _
) As String
    Dim tmpVariant As Variant
    
    ' Works around a stupid language bug where VBA gives plain strings instead of one sized arrays
    ' so that myRange(1, 1) does not work if myRange is of size [1, 1]
    If Not TypeName(myRange) = "Variant()" Then
        tmpVariant = myRange
    Else
        tmpVariant = myRange(rowNo, columnNo)
    End If
    
    ' Read as string:
    rangeGetString = tmpVariant
End Function

' Takes a range and a rowNo and an optional colNo and returns the data as a long
' If colNo is not specified it is assumed to be 1 (a one column range)
Public Function rangeGetLong( _
    ByRef myRange As Variant, _
    ByVal rowNo As Long, _
    Optional ByVal columnNo As Long = 1 _
) As Long
    Dim tmpVariant As Variant
    
    ' Works around a stupid language bug where VBA gives plain strings instead of one sized arrays
    ' so that myRange(1, 1) does not work if myRange is of size [1, 1]
    If Not TypeName(myRange) = "Variant()" Then
        tmpVariant = myRange
    Else
        tmpVariant = myRange(rowNo, columnNo)
    End If
    
    ' Read as long:
    rangeGetLong = tmpVariant
End Function
Attribute VB_Name = "SupportFunctionsSorting"
'@Folder("GlobalSupportFunctions")
Option Explicit

'
' Collection of Support Functions to deal with sorting


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modqSortObjectCompare
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This module contains an example qSortObjectCompare function to be used as the comparison
' function for the qSortObjectsInPlace function. It assumes that obj1 and obj2 are
' instances of a custom class than has a Long-type Property named Value. This property
' is used to compare the objects. This function contains code to work with non-object
' variables.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function qSortBinsCompare( _
    ByRef bin1 As CBin, _
    ByRef bin2 As CBin _
) As Long
    
    Const C_OBJECT1_LESS_THAN_OBJECT2 As Long = -1
    Const C_OBJECT1_EQUALS_OBJECT2 As Long = 0
    Const C_OBJECT1_GREATER_THAN_OBJECT2 As Long = 1
    
    ' Only calculate this once
    Dim sumobj1 As Long
    Dim sumobj2 As Long
    sumobj1 = bin1.getSum
    sumobj2 = bin2.getSum
    
    If sumobj1 < sumobj2 Then
        qSortBinsCompare = C_OBJECT1_LESS_THAN_OBJECT2
        Exit Function
    End If
    If sumobj1 = sumobj2 Then
        qSortBinsCompare = C_OBJECT1_EQUALS_OBJECT2
        Exit Function
    End If
    If sumobj1 > sumobj2 Then
        qSortBinsCompare = C_OBJECT1_GREATER_THAN_OBJECT2
        Exit Function
    End If
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modqSortObjectsInPlace
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub qSortBinsInPlace( _
       ByRef inputArray() As CBin, _
       ByVal lb As Long, _
       ByVal ub As Long, _
       Optional ByVal descending As Boolean = False _
)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' qSortObjectsInPlace
    '
    ' This function sorts the array inputArray in place -- this is, the original array in the
    ' calling procedure is sorted. inputArray must be an array of Objects or Variants containing
    ' Objects. An error will occur if an element of the array is not an Object. (Objects that
    ' are Nothing are acceptable.)
    '
    ' It need not sort the entire array. You can sort only part of the array by setting the lb and
    ' ub parameters to the first (lb) and last (ub) element indexes that you want to sort.
    ' lb and ub are optional parameters. If omitted lb is set to the LBound of inputArray, and if
    ' omitted ub is set to the UBound of the inputArray. If you want to sort the entire array,
    ' omit the lb and ub parameters, or set both to -1, or set lb = LBound(inputArray) and set
    ' ub to UBound(inputArray).
    '
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' The qSortObjectCompare Procedure To Compare Two Objects
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' You must create a function named qSortObjectCompare that accepts two Objects, compares
    ' them in a manner suitable for the given type of object, and returns the result of
    ' the comparison. The declaration of the function you supply is:
    '
    '   Function qSortObjectCompare(obj1 As Variant, obj2 As Variant, _
    '           compareMode As VbCompareMethod) As Long
    '
    ' The function qSortObjectCompare should return:
    '       -1 if obj1 is less than obj2
    '        0 if obj1 is equal to obj2
    '       +1 if obj1 is greater than obj2
    '
    ' Of course, the meaning of "less than", "equal to", and "greater than" will depend
    ' on the object type in the array. It is the responsibility of the qSortObjectCompare
    ' function of determine what constitutes the relationship between the two objects
    ' passed to it.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' MODIFYING THIS CODE:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' You can modify this code to meet your needs, although since it can handle
    ' any type of object, this likely isn't necessary. If you are going to use this
    ' code to sort only one type and one type only of object, and you know when writing the
    ' code what type of object that will be (e.g., always arrays of ranges), you can
    ' change the declarations from "As Object" to "As yourObjectType". This will improve
    ' the performace of the sort. If your code calls Exit Function, you MUST decrement
    ' the recursionLevel variable before exiting the code. E.g,
    '       If somethingThatCausesAnExit Then
    '           recursionLevel = recursionLevel - 1
    '           Exit Function
    '       End If
    '
    ' If you don't decrement the recursionLevel variable, the code will not perform as
    ' expected on subsequent calls.
    '
    ' Note: If you coerce inputArray to a ByVal argument, qSortObjectsInPlace will not be
    ' able to reference the inputArray in the calling procedure and the array will
    ' not be sorted.
    '
    ' This function uses the following procedures. These are declared as Private procedures
    ' at the end of this module:
    '       reversePieceArrayInPlace
    '
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    Dim temp As CBin
    Dim buffer As CBin
    Dim currentLow As Long
    Dim currentHigh As Long
    Dim currentMidpoint As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This variable is used to determine the level
    ' of recursion  (the function calling itself).
    ' recursionLevel is incremented when this procedure
    ' is called, either initially by a calling procedure
    ' or recursively by itself. The variable is decremented
    ' when the procedure exits. We do the input parameter
    ' validation only when recursionLevel is 1 (when
    ' the function is called by another function, not
    ' when it is called recursively).
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Static recursionLevel As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Keep track of the recursion level -- that is, how many
    ' times the procedure has called itself.
    ' Carry out the validation routines only when this
    ' procedure is first called. Don't run the
    ' validations on a recursive call to the
    ' procedure.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    recursionLevel = recursionLevel + 1
    
    If recursionLevel = 1 Then
        ' if ub = lb, we have nothing to sort, so get out.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''
        If ub = lb Then
            recursionLevel = recursionLevel - 1
            Exit Sub
        End If
    
    End If                                       ' recursionLevel = 1
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Begin the actual sorting process.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    currentLow = lb
    currentHigh = ub
    
    currentMidpoint = (lb + ub) \ 2              ' note integer division (\) here
    
    Set temp = inputArray(currentMidpoint)
    
    Do While currentLow <= currentHigh
        
        Do While qSortBinsCompare(inputArray(currentLow), temp) < 0
            currentLow = currentLow + 1
            If currentLow = ub Then
                Exit Do
            End If
        Loop
        
        Do While qSortBinsCompare(temp, inputArray(currentHigh)) < 0
            currentHigh = currentHigh - 1
            If currentHigh = lb Then
                Exit Do
            End If
        Loop
    
        If currentLow <= currentHigh Then
            Set buffer = inputArray(currentLow)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentLow) = inputArray(currentHigh)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentHigh) = buffer
            currentLow = currentLow + 1
            currentHigh = currentHigh - 1
        End If
    Loop
    
    If lb < currentHigh Then
        qSortBinsInPlace inputArray:=inputArray, lb:=lb, ub:=currentHigh, descending:=descending
    End If
    
    If currentLow < ub Then
        qSortBinsInPlace inputArray:=inputArray, lb:=currentLow, ub:=ub, descending:=descending
    End If
    
    '''''''''''''''''''''''''''''''''''''
    ' If descending is True, reverse the
    ' order of the array, but only if the
    ' recursion level is 1.
    '''''''''''''''''''''''''''''''''''''
    If descending = True Then
        If recursionLevel = 1 Then
            reverseBinArrayInPlace inputArray, ub, lb
        End If
    End If
    
    recursionLevel = recursionLevel - 1

End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modqSortObjectCompare
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This module contains an example qSortObjectCompare function to be used as the comparison
' function for the qSortObjectsInPlace function. It assumes that obj1 and obj2 are
' instances of a custom class than has a Long-type Property named Value. This property
' is used to compare the objects. This function contains code to work with non-object
' variables.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function qSortBinsByWastePlusUnusedSpaceCompare(ByRef bin1 As CBin, ByRef bin2 As CBin) As Long
    
    Const C_OBJECT1_LESS_THAN_OBJECT2 As Long = -1
    Const C_OBJECT1_EQUALS_OBJECT2 As Long = 0
    Const C_OBJECT1_GREATER_THAN_OBJECT2 As Long = 1
    Dim wasteSumobj1 As Long
    Dim wasteSumobj2 As Long
    
    ' Only calculate this sum once
    wasteSumobj1 = bin1.getWastePlusUnusedSpaceSum
    wasteSumobj2 = bin2.getWastePlusUnusedSpaceSum
    
    If wasteSumobj1 < wasteSumobj2 Then
        qSortBinsByWastePlusUnusedSpaceCompare = C_OBJECT1_LESS_THAN_OBJECT2
        Exit Function
    End If
    If wasteSumobj1 = wasteSumobj2 Then
        qSortBinsByWastePlusUnusedSpaceCompare = C_OBJECT1_EQUALS_OBJECT2
        Exit Function
    End If
    If wasteSumobj1 > wasteSumobj2 Then
        qSortBinsByWastePlusUnusedSpaceCompare = C_OBJECT1_GREATER_THAN_OBJECT2
        Exit Function
    End If
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' QSortBinsByWasteInPlace
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub qSortBinsByWastePlusUnusedSpaceInPlace( _
       ByRef inputArray() As CBin, _
       ByVal lb As Long, _
       ByVal ub As Long, _
       ByRef maxlb As Long, _
       ByRef minub As Long, _
       ByRef pgForm As ProgressForm, _
       Optional ByVal descending As Boolean = False)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' qSortObjectsInPlace
    '
    ' This function sorts the array inputArray in place -- this is, the original array in the
    ' calling procedure is sorted. inputArray must be an array of Objects or Variants containing
    ' Objects. An error will occur if an element of the array is not an Object. (Objects that
    ' are Nothing are acceptable.)
    '
    ' It need not sort the entire array. You can sort only part of the array by setting the lb and
    ' ub parameters to the first (lb) and last (ub) element indexes that you want to sort.
    ' lb and ub are optional parameters. If omitted lb is set to the LBound of inputArray, and if
    ' omitted ub is set to the UBound of the inputArray. If you want to sort the entire array,
    ' omit the lb and ub parameters, or set both to -1, or set lb = LBound(inputArray) and set
    ' ub to UBound(inputArray).
    '
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' The qSortObjectCompare Procedure To Compare Two Objects
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' You must create a function named qSortObjectCompare that accepts two Objects, compares
    ' them in a manner suitable for the given type of object, and returns the result of
    ' the comparison. The declaration of the function you supply is:
    '
    '   Function qSortObjectCompare(obj1 As Variant, obj2 As Variant, _
    '           compareMode As VbCompareMethod) As Long
    '
    ' The function qSortObjectCompare should return:
    '       -1 if obj1 is less than obj2
    '        0 if obj1 is equal to obj2
    '       +1 if obj1 is greater than obj2
    '
    ' Of course, the meaning of "less than", "equal to", and "greater than" will depend
    ' on the object type in the array. It is the responsibility of the qSortObjectCompare
    ' function of determine what constitutes the relationship between the two objects
    ' passed to it.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' MODIFYING THIS CODE:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' You can modify this code to meet your needs, although since it can handle
    ' any type of object, this likely isn't necessary. If you are going to use this
    ' code to sort only one type and one type only of object, and you know when writing the
    ' code what type of object that will be (e.g., always arrays of ranges), you can
    ' change the declarations from "As Object" to "As yourObjectType". This will improve
    ' the performace of the sort. If your code calls Exit Function, you MUST decrement
    ' the recursionLevel variable before exiting the code. E.g,
    '       If somethingThatCausesAnExit Then
    '           recursionLevel = recursionLevel - 1
    '           Exit Function
    '       End If
    '
    ' If you don't decrement the recursionLevel variable, the code will not perform as
    ' expected on subsequent calls.
    '
    ' Note: If you coerce inputArray to a ByVal argument, qSortObjectsInPlace will not be
    ' able to reference the inputArray in the calling procedure and the array will
    ' not be sorted.
    '
    ' This function uses the following procedures. These are declared as Private procedures
    ' at the end of this module:
    '       reversePieceArrayInPlace
    '
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    Dim temp As CBin
    Dim buffer As CBin
    Dim currentLow As Long
    Dim currentHigh As Long
    Dim currentMidpoint As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This variable is used to determine the level
    ' of recursion  (the function calling itself).
    ' recursionLevel is incremented when this procedure
    ' is called, either initially by a calling procedure
    ' or recursively by itself. The variable is decremented
    ' when the procedure exits. We do the input parameter
    ' validation only when recursionLevel is 1 (when
    ' the function is called by another function, not
    ' when it is called recursively).
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Static recursionLevel As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Keep track of the recursion level -- that is, how many
    ' times the procedure has called itself.
    ' Carry out the validation routines only when this
    ' procedure is first called. Don't run the
    ' validations on a recursive call to the
    ' procedure.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    recursionLevel = recursionLevel + 1
    
    If recursionLevel = 1 Then
        ' if ub = lb, we have nothing to sort, so get out.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''
        If ub = lb Then
            recursionLevel = recursionLevel - 1
            'Debug.Print "Recursionlevel = 1, Final"
            Exit Sub
        Else
            'Debug.Print "Recursionlevel = 1"
        End If
    
    End If                                       ' recursionLevel = 1
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Begin the actual sorting process.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    currentLow = lb
    currentHigh = ub
    
    currentMidpoint = (lb + ub) \ 2              ' note integer division (\) here
    
    Set temp = inputArray(currentMidpoint)
    
    Do While currentLow <= currentHigh
        
        Do While qSortBinsByWastePlusUnusedSpaceCompare(inputArray(currentLow), temp) < 0
            currentLow = currentLow + 1
            If currentLow > maxlb Then
                pgForm.moreStepsSub currentLow - maxlb
                maxlb = currentLow
            End If
            If currentLow = ub Then
                Exit Do
            End If
        Loop
        
        Do While qSortBinsByWastePlusUnusedSpaceCompare(temp, inputArray(currentHigh)) < 0
            currentHigh = currentHigh - 1
            If currentHigh < minub Then
                pgForm.moreStepsSub minub - currentHigh
                minub = currentHigh
            End If
            If currentHigh = lb Then
                Exit Do
            End If
        Loop
    
        If currentLow <= currentHigh Then
            Set buffer = inputArray(currentLow)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentLow) = inputArray(currentHigh)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentHigh) = buffer
            currentLow = currentLow + 1
            currentHigh = currentHigh - 1
            If currentLow > maxlb Then
                pgForm.moreStepsSub currentLow - maxlb
                maxlb = currentLow
            End If
            If currentHigh < minub Then
                pgForm.moreStepsSub minub - currentHigh
                minub = currentHigh
            End If
        End If
    Loop
    
    If lb < currentHigh Then
        qSortBinsByWastePlusUnusedSpaceInPlace inputArray:=inputArray, lb:=lb, ub:=currentHigh, maxlb:=maxlb, minub:=minub, pgForm:=pgForm, descending:=descending
    End If
    
    If currentLow < ub Then
        qSortBinsByWastePlusUnusedSpaceInPlace inputArray:=inputArray, lb:=currentLow, ub:=ub, maxlb:=maxlb, minub:=minub, pgForm:=pgForm, descending:=descending
    End If
    
    'Debug.Print "CurHigh: " & CurHigh & ", CurLow: " & CurLow
    
    '''''''''''''''''''''''''''''''''''''
    ' If descending is True, reverse the
    ' order of the array, but only if the
    ' recursion level is 1.
    '''''''''''''''''''''''''''''''''''''
    If descending = True Then
        If recursionLevel = 1 Then
            reverseBinArrayInPlace inputArray, ub, lb
        End If
    End If
    
    recursionLevel = recursionLevel - 1

End Sub

Private Sub reverseBinArrayInPlace(ByRef inputArray() As CBin, ByVal ub As Long, ByVal lb As Long)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ReverseBinArrayInPlace
    ' This reverses the order of objects in an array of objects in place. That
    ' is, the array in the calling procedure is reversed.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim temp As CBin
    Dim ndx As Long
    Dim ndx2 As Long
    
    ndx2 = ub

    ' loop from the LBound of inputArray to the midpoint of inputArray.
    For ndx = lb To ((ub - lb + 1) \ 2)

        ' swap the elements
        Set temp = inputArray(ndx)
        '@Ignore ObjectVariableNotSet
        Set inputArray(ndx) = inputArray(ndx2)
        '@Ignore ObjectVariableNotSet
        Set inputArray(ndx2) = temp

        ' decrement the upper index
        ndx2 = ndx2 - 1
    Next ndx

End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modqSortObjectCompare
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This module contains an example qSortObjectCompare function to be used as the comparison
' function for the qSortObjectsInPlace function. It assumes that obj1 and obj2 are
' instances of a custom class than has a Long-type Property named Value. This property
' is used to compare the objects. This function contains code to work with non-object
' variables.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Public Function qSortItemsCompare(ByRef item1 As CItem, ByRef item2 As CItem) As Long
    
    Const C_OBJECT1_LESS_THAN_OBJECT2 As Long = -1
    Const C_OBJECT1_EQUALS_OBJECT2 As Long = 0
    Const C_OBJECT1_GREATER_THAN_OBJECT2 As Long = 1
    
    If item1.length < item2.length Then
        qSortItemsCompare = C_OBJECT1_LESS_THAN_OBJECT2
        Exit Function
    End If
    If item1.length = item2.length Then
        qSortItemsCompare = C_OBJECT1_EQUALS_OBJECT2
        Exit Function
    End If
    If item1.length > item2.length Then
        qSortItemsCompare = C_OBJECT1_GREATER_THAN_OBJECT2
        Exit Function
    End If
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modqSortObjectsInPlace
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub qSortItemsInPlace( _
       ByRef inputArray() As CItem, _
       ByVal lb As Long, _
       ByVal ub As Long, _
       Optional ByVal descending As Boolean = False)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' qSortObjectsInPlace
    '
    ' This function sorts the array inputArray in place -- this is, the original array in the
    ' calling procedure is sorted. inputArray must be an array of Objects or Variants containing
    ' Objects. An error will occur if an element of the array is not an Object. (Objects that
    ' are Nothing are acceptable.)
    '
    ' It need not sort the entire array. You can sort only part of the array by setting the lb and
    ' ub parameters to the first (lb) and last (ub) element indexes that you want to sort.
    ' lb and ub are optional parameters. If omitted lb is set to the LBound of inputArray, and if
    ' omitted ub is set to the UBound of the inputArray. If you want to sort the entire array,
    ' omit the lb and ub parameters, or set both to -1, or set lb = LBound(inputArray) and set
    ' ub to UBound(inputArray).
    '
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' The qSortObjectCompare Procedure To Compare Two Objects
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' You must create a function named qSortObjectCompare that accepts two Objects, compares
    ' them in a manner suitable for the given type of object, and returns the result of
    ' the comparison. The declaration of the function you supply is:
    '
    '   Function qSortObjectCompare(obj1 As Variant, obj2 As Variant, _
    '           compareMode As VbCompareMethod) As Long
    '
    ' The function qSortObjectCompare should return:
    '       -1 if obj1 is less than obj2
    '        0 if obj1 is equal to obj2
    '       +1 if obj1 is greater than obj2
    '
    ' Of course, the meaning of "less than", "equal to", and "greater than" will depend
    ' on the object type in the array. It is the responsibility of the qSortObjectCompare
    ' function of determine what constitutes the relationship between the two objects
    ' passed to it.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' MODIFYING THIS CODE:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' You can modify this code to meet your needs, although since it can handle
    ' any type of object, this likely isn't necessary. If you are going to use this
    ' code to sort only one type and one type only of object, and you know when writing the
    ' code what type of object that will be (e.g., always arrays of ranges), you can
    ' change the declarations from "As Object" to "As yourObjectType". This will improve
    ' the performace of the sort. If your code calls Exit Function, you MUST decrement
    ' the recursionLevel variable before exiting the code. E.g,
    '       If somethingThatCausesAnExit Then
    '           recursionLevel = recursionLevel - 1
    '           Exit Function
    '       End If
    '
    ' If you don't decrement the recursionLevel variable, the code will not perform as
    ' expected on subsequent calls.
    '
    ' Note: If you coerce inputArray to a ByVal argument, qSortObjectsInPlace will not be
    ' able to reference the inputArray in the calling procedure and the array will
    ' not be sorted.
    '
    ' This function uses the following procedures. These are declared as Private procedures
    ' at the end of this module:
    '       reversePieceArrayInPlace
    '
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    Dim temp As CItem
    Dim buffer As CItem
    Dim currentLow As Long
    Dim currentHigh As Long
    Dim currentMidpoint As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This variable is used to determine the level
    ' of recursion  (the function calling itself).
    ' recursionLevel is incremented when this procedure
    ' is called, either initially by a calling procedure
    ' or recursively by itself. The variable is decremented
    ' when the procedure exits. We do the input parameter
    ' validation only when recursionLevel is 1 (when
    ' the function is called by another function, not
    ' when it is called recursively).
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Static recursionLevel As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Keep track of the recursion level -- that is, how many
    ' times the procedure has called itself.
    ' Carry out the validation routines only when this
    ' procedure is first called. Don't run the
    ' validations on a recursive call to the
    ' procedure.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    recursionLevel = recursionLevel + 1
    
    If recursionLevel = 1 Then
        ' if ub = lb, we have nothing to sort, so get out.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''
        If ub = lb Then
            recursionLevel = recursionLevel - 1
            Exit Sub
        End If
    
    End If                                       ' recursionLevel = 1
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Begin the actual sorting process.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    currentLow = lb
    currentHigh = ub
    
    currentMidpoint = (lb + ub) \ 2              ' note integer division (\) here
    
    Set temp = inputArray(currentMidpoint)
    
    Do While currentLow <= currentHigh
        
        Do While qSortItemsCompare(inputArray(currentLow), temp) < 0
            currentLow = currentLow + 1
            If currentLow = ub Then
                Exit Do
            End If
        Loop
        
        Do While qSortItemsCompare(temp, inputArray(currentHigh)) < 0
            currentHigh = currentHigh - 1
            If currentHigh = lb Then
                Exit Do
            End If
        Loop
    
        If currentLow <= currentHigh Then
            Set buffer = inputArray(currentLow)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentLow) = inputArray(currentHigh)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentHigh) = buffer
            currentLow = currentLow + 1
            currentHigh = currentHigh - 1
        End If
    Loop
    
    If lb < currentHigh Then
        qSortItemsInPlace inputArray:=inputArray, lb:=lb, ub:=currentHigh, descending:=descending
    End If
    
    If currentLow < ub Then
        qSortItemsInPlace inputArray:=inputArray, lb:=currentLow, ub:=ub, descending:=descending
    End If
    
    '''''''''''''''''''''''''''''''''''''
    ' If descending is True, reverse the
    ' order of the array, but only if the
    ' recursion level is 1.
    '''''''''''''''''''''''''''''''''''''
    If descending = True Then
        If recursionLevel = 1 Then
            reverseItemsArrayInPlace inputArray, ub, lb
        End If
    End If
    
    recursionLevel = recursionLevel - 1

End Sub

Private Sub reverseItemsArrayInPlace(ByRef inputArray() As CItem, ByVal ub As Long, ByVal lb As Long)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' reversePieceArrayInPlace
    ' This reverses the order of objects in an array of objects in place. That
    ' is, the array in the calling procedure is reversed.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim temp As CItem
    Dim ndx As Long
    Dim ndx2 As Long
    
    ndx2 = ub

    ' loop from the LBound of inputArray to the midpoint of inputArray
    For ndx = lb To ((ub - lb + 1) \ 2)
    
        'swap the elements
        Set temp = inputArray(ndx)
        '@Ignore ObjectVariableNotSet
        Set inputArray(ndx) = inputArray(ndx2)
        '@Ignore ObjectVariableNotSet
        Set inputArray(ndx2) = temp
        
        ' decrement the upper index
        ndx2 = ndx2 - 1
    Next ndx

End Sub

Public Function qSortPiecesCompare(ByVal P1 As CPiece, ByVal P2 As CPiece) As Long
    Const C_OBJECT1_LESS_THAN_OBJECT2 As Long = -1
    Const C_OBJECT1_EQUALS_OBJECT2 As Long = 0
    Const C_OBJECT1_GREATER_THAN_OBJECT2 As Long = 1
    
    If P1.length < P2.length Then
        qSortPiecesCompare = C_OBJECT1_LESS_THAN_OBJECT2
        Exit Function
    End If
    If P1.length = P2.length Then
        qSortPiecesCompare = C_OBJECT1_EQUALS_OBJECT2
        Exit Function
    End If
    If P1.length > P2.length Then
        qSortPiecesCompare = C_OBJECT1_GREATER_THAN_OBJECT2
        Exit Function
    End If
End Function

Public Sub qSortPiecesInPlace( _
       ByRef inputArray() As CPiece, _
       ByVal lb As Long, _
       ByVal ub As Long, _
       Optional ByVal descending As Boolean = False _
)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' qSortPiecesInPlace
    '
    ' This function sorts the array inputArray in place -- this is, the original array in the
    ' calling procedure is sorted. inputArray must be an array of Objects or Variants containing
    ' Objects. An error will occur if an element of the array is not an Object. (Objects that
    ' are Nothing are acceptable.)
    '
    ' It need not sort the entire array. You can sort only part of the array by setting the lb and
    ' ub parameters to the first (lb) and last (ub) element indexes that you want to sort.
    ' lb and ub are optional parameters. If omitted lb is set to the LBound of inputArray, and if
    ' omitted ub is set to the UBound of the inputArray. If you want to sort the entire array,
    ' omit the lb and ub parameters, or set both to -1, or set lb = LBound(inputArray) and set
    ' ub to UBound(inputArray).
    '
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' The qSortObjectCompare Procedure To Compare Two Objects
    ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ' You must create a function named qSortObjectCompare that accepts two Objects, compares
    ' them in a manner suitable for the given type of object, and returns the result of
    ' the comparison. The declaration of the function you supply is:
    '
    '   Function qSortObjectCompare(obj1 As Variant, obj2 As Variant, _
    '           compareMode As VbCompareMethod) As Long
    '
    ' The function qSortObjectCompare should return:
    '       -1 if obj1 is less than obj2
    '        0 if obj1 is equal to obj2
    '       +1 if obj1 is greater than obj2
    '
    ' Of course, the meaning of "less than", "equal to", and "greater than" will depend
    ' on the object type in the array. It is the responsibility of the qSortObjectCompare
    ' function of determine what constitutes the relationship between the two objects
    ' passed to it.
    '
    '
    ' This function uses the following procedures. These are declared as Private procedures
    ' at the end of this module:
    '       reversePieceArrayInPlace
    '
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    Dim temp As CPiece
    Dim buffer As CPiece
    Dim currentLow As Long
    Dim currentHigh As Long
    Dim currentMidpoint As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This variable is used to determine the level
    ' of recursion  (the function calling itself).
    ' recursionLevel is incremented when this procedure
    ' is called, either initially by a calling procedure
    ' or recursively by itself. The variable is decremented
    ' when the procedure exits. We do the input parameter
    ' validation only when recursionLevel is 1 (when
    ' the function is called by another function, not
    ' when it is called recursively).
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Static recursionLevel As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Keep track of the recursion level -- that is, how many
    ' times the procedure has called itself.
    ' Carry out the validation routines only when this
    ' procedure is first called. Don't run the
    ' validations on a recursive call to the
    ' procedure.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    recursionLevel = recursionLevel + 1
    
    If recursionLevel = 1 Then
        ' if ub = lb, we have nothing to sort, so get out.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''
        If ub = lb Then
            recursionLevel = recursionLevel - 1
            Exit Sub
        End If
    
    End If                                       ' recursionLevel = 1
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Begin the actual sorting process.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    currentLow = lb
    currentHigh = ub
    
    currentMidpoint = (lb + ub) \ 2              ' note integer division (\) here
    
    Set temp = inputArray(currentMidpoint)
    
    Do While currentLow <= currentHigh
        
        Do While qSortPiecesCompare(inputArray(currentLow), temp) < 0
            currentLow = currentLow + 1
            If currentLow = ub Then
                Exit Do
            End If
        Loop
        
        Do While qSortPiecesCompare(temp, inputArray(currentHigh)) < 0
            currentHigh = currentHigh - 1
            If currentHigh = lb Then
                Exit Do
            End If
        Loop
    
        If currentLow <= currentHigh Then
            Set buffer = inputArray(currentLow)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentLow) = inputArray(currentHigh)
            '@Ignore ObjectVariableNotSet
            Set inputArray(currentHigh) = buffer
            currentLow = currentLow + 1
            currentHigh = currentHigh - 1
        End If
    Loop
    
    If lb < currentHigh Then
        qSortPiecesInPlace inputArray:=inputArray, lb:=lb, ub:=currentHigh, descending:=descending
    End If
    
    If currentLow < ub Then
        qSortPiecesInPlace inputArray:=inputArray, lb:=currentLow, ub:=ub, descending:=descending
    End If
    
    '''''''''''''''''''''''''''''''''''''
    ' If descending is True, reverse the
    ' order of the array, but only if the
    ' recursion level is 1.
    '''''''''''''''''''''''''''''''''''''
    If descending = True Then
        If recursionLevel = 1 Then
            reversePieceArrayInPlace inputArray, ub, lb
        End If
    End If
    
    recursionLevel = recursionLevel - 1
End Sub

Private Sub reversePieceArrayInPlace(ByRef inputArray() As CPiece, ByVal ub As Long, ByVal lb As Long)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' reversePieceArrayInPlace
    ' This reverses the order of objects in an array of objects in place. That
    ' is, the array in the calling procedure is reversed.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim temp As CPiece
    Dim ndx As Long
    Dim ndx2 As Long
    
    ndx2 = ub

    ' loop from the LBound of inputArray to the midpoint of inputArray
    For ndx = lb To ((ub - lb + 1) \ 2)
    
        'swap the elements
        Set temp = inputArray(ndx)
        '@Ignore ObjectVariableNotSet
        Set inputArray(ndx) = inputArray(ndx2)
        '@Ignore ObjectVariableNotSet
        Set inputArray(ndx2) = temp
        
        ' decrement the upper index
        ndx2 = ndx2 - 1
    Next ndx

End Sub

Public Sub qSortStringArrayInPlace( _
    ByVal inputArray As Variant, _
    Optional ByVal lbIn As Long = -1&, _
    Optional ByVal ubIn As Long = -1& _
)
    
    Dim lb As Long
    Dim ub As Long
    Dim temp As Variant
    Dim buffer As Variant
    Dim currentLow As Long
    Dim currentHigh As Long
    Dim currentMidpoint As Long
    
    Static recursionLevel As Long
    recursionLevel = recursionLevel + 1
    
    lb = lbIn
    ub = ubIn
    
    If recursionLevel = 1 Then
        If lb < 0 Then
            lb = LBound(inputArray)
        End If
        If ub < 0 Then
            ub = UBound(inputArray)
        End If
        If ub = lb Then
            recursionLevel = recursionLevel - 1
            Exit Sub
        End If
    End If
    
    currentLow = lb
    currentHigh = ub
    
    If lb = 0 Then
        currentMidpoint = ((lb + ub) \ 2) + 1
    Else
        currentMidpoint = (lb + ub) \ 2
    End If
    temp = inputArray(currentMidpoint)
    
    Do While currentLow <= currentHigh
        
        Do While StrComp(inputArray(currentLow), temp) < 0
            currentLow = currentLow + 1
            If currentLow = ub Then
                Exit Do
            End If
        Loop
        
        Do While StrComp(temp, inputArray(currentHigh)) < 0
            currentHigh = currentHigh - 1
            If currentHigh = lb Then
                Exit Do
            End If
        Loop
    
        If currentLow <= currentHigh Then
            buffer = inputArray(currentLow)
            inputArray(currentLow) = inputArray(currentHigh)
            inputArray(currentHigh) = buffer
            currentLow = currentLow + 1
            currentHigh = currentHigh - 1
        End If
    Loop
    
    If lb < currentHigh Then
        qSortStringArrayInPlace inputArray:=inputArray, lbIn:=lb, ubIn:=currentHigh
    End If
    
    If currentLow < ub Then
        qSortStringArrayInPlace inputArray:=inputArray, lbIn:=currentLow, ubIn:=ub
    End If
    
    recursionLevel = recursionLevel - 1
End Sub

Public Sub qSortInPlace( _
       ByRef inputArray As Variant, _
       Optional ByVal lbIn As Long = -1&, _
       Optional ByVal ubIn As Long = -1&, _
       Optional ByVal descending As Boolean = False, _
       Optional ByVal compareMode As VbCompareMethod = vbTextCompare _
)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' qSortInPlace
    '
    ' This function sorts the array inputArray in place -- this is, the original array in the
    ' calling procedure is sorted. It will work with either string data or numeric data.
    ' It need not sort the entire array. You can sort only part of the array by setting the lb and
    ' ub parameters to the first (lb) and last (ub) element indexes that you want to sort.
    ' lb and ub are optional parameters. If omitted lb is set to the LBound of inputArray, and if
    ' omitted ub is set to the UBound of the inputArray. If you want to sort the entire array,
    ' omit the lb and ub parameters, or set both to -1, or set lb = LBound(inputArray) and set
    ' ub to UBound(inputArray).
    '
    ' By default, the sort method is case INSENSTIVE (case doens't matter: "A", "b", "C", "d").
    ' To make it case SENSITIVE (case matters: "A" "C" "b" "d"), set the compareMode argument
    ' to vbBinaryCompare (=0). If Compare mode is omitted or is any value other than vbBinaryCompare,
    ' it is assumed to be vbTextCompare and the sorting is done case INSENSITIVE.
    '
    ' This function uses the following procedures. These are declared as Private procedures
    ' at the end of this module:
    '       isSimpleDataType
    '       isSimpleNumericType
    '       qSortCompare
    '       reverseArrayInPlace
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim lb As Long
    Dim ub As Long
    ub = ubIn
    lb = lbIn
    Dim temp As Variant
    Dim buffer As Variant
    Dim currentLow As Long
    Dim currentHigh As Long
    Dim currentMidpoint As Long
    Dim pCompareMode As VbCompareMethod
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' This variable is used to determine the level
    ' of recursion  (the function calling itself).
    ' recursionLevel is incremented when this procedure
    ' is called, either initially by a calling procedure
    ' or recursively by itself. The variable is decremented
    ' when the procedure exits. We do the input parameter
    ' validation only when recursionLevel is 1 (when
    ' the function is called by another function, not
    ' when it is called recursively).
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Static recursionLevel As Long
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Keep track of the recursion level -- that is, how many
    ' times the procedure has called itself.
    ' Carry out the validation routines only when this
    ' procedure is first called. Don't run the
    ' validations on a recursive call to the
    ' procedure.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    recursionLevel = recursionLevel + 1
    
    If recursionLevel = 1 Then
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' Test lb and ub. If < 0 then set to LBound and UBound
        ' of the inputArray.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        If lb < 0 Then
            lb = LBound(inputArray)
        End If
        If ub < 0 Then
            ub = UBound(inputArray)
        End If
        
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' if ub = lb, we have nothing to sort, so get out.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''
        If ub = lb Then
            recursionLevel = recursionLevel - 1
            Exit Sub
        End If
    
    End If                                       ' recursionLevel = 1
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Ensure that compareMode is either vbBinaryCompare  or
    ' vbTextCompare. If it is neither, default to vbTextCompare.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If compareMode = vbBinaryCompare Or compareMode = vbTextCompare Then
        pCompareMode = compareMode
    Else
        pCompareMode = vbTextCompare
    End If
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Begin the actual sorting process.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    currentLow = lb
    currentHigh = ub
    
    If lb = 0 Then
        currentMidpoint = ((lb + ub) \ 2) + 1
    Else
        currentMidpoint = (lb + ub) \ 2          ' note integer division (\) here
    End If
    temp = inputArray(currentMidpoint)
    
    Do While currentLow <= currentHigh
        
        Do While qSortCompare(v1:=inputArray(currentLow), v2:=temp, compareMode:=pCompareMode) < 0
            currentLow = currentLow + 1
            If currentLow = ub Then
                Exit Do
            End If
        Loop
        
        Do While qSortCompare(v1:=temp, v2:=inputArray(currentHigh), compareMode:=pCompareMode) < 0
            currentHigh = currentHigh - 1
            If currentHigh = lb Then
                Exit Do
            End If
        Loop
    
        If currentLow <= currentHigh Then
            buffer = inputArray(currentLow)
            inputArray(currentLow) = inputArray(currentHigh)
            inputArray(currentHigh) = buffer
            currentLow = currentLow + 1
            currentHigh = currentHigh - 1
        End If
    Loop
    
    If lb < currentHigh Then
        qSortInPlace inputArray:=inputArray, lbIn:=lb, ubIn:=currentHigh, _
                     descending:=descending, compareMode:=pCompareMode
    End If
    
    If currentLow < ub Then
        qSortInPlace inputArray:=inputArray, lbIn:=currentLow, ubIn:=ub, _
                     descending:=descending, compareMode:=pCompareMode
    End If
    
    '''''''''''''''''''''''''''''''''''''
    ' If descending is True, reverse the
    ' order of the array, but only if the
    ' recursion level is 1.
    '''''''''''''''''''''''''''''''''''''
    If descending = True Then
        If recursionLevel = 1 Then
            reverseArrayInPlace2 inputArray, lb, ub
        End If
    End If
    
    recursionLevel = recursionLevel - 1
End Sub

Public Function qSortCompare( _
    ByVal v1 As Variant, _
    ByVal v2 As Variant, _
    Optional ByVal compareMode As VbCompareMethod = vbTextCompare _
) As Long
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' qSortCompare
    ' This function is used in qSortInPlace to compare two elements. If
    ' v1 AND v2 are both numeric data types (integer, long, single, double)
    ' they are converted to Doubles and compared. If v1 and v2 are BOTH strings
    ' that contain numeric data, they are converted to Doubles and compared.
    ' If either v1 or v2 is a string and does NOT contain numeric data, both
    ' v1 and v2 are converted to Strings and compared with StrComp.
    '
    ' The result is -1 if v1 < v2,
    '                0 if v1 = v2
    '                1 if v1 > v2
    ' For text comparisons, case sensitivity is controlled by compareMode.
    ' If this is vbBinaryCompare, the result is case SENSITIVE. If this
    ' is omitted or any other value, the result is case INSENSITIVE.
    '
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim d1 As Double
    Dim d2 As Double
    '@Ignore HungarianNotation
    Dim s1 As String
    '@Ignore HungarianNotation
    Dim s2 As String
    
    Dim compare As VbCompareMethod
    ''''''''''''''''''''''''''''''''''''''''''''''''
    ' Test compareMode. Any value other than
    ' vbBinaryCompare will default to vbTextCompare.
    ''''''''''''''''''''''''''''''''''''''''''''''''
    If compareMode = vbBinaryCompare Or compareMode = vbTextCompare Then
        compare = compareMode
    Else
        compare = vbTextCompare
    End If
    '''''''''''''''''''''''''''''''''''''''''''''''
    ' If either v1 or v2 is either an array or
    ' an Object, raise a error 13 - Type Mismatch.
    '''''''''''''''''''''''''''''''''''''''''''''''
    If IsArray(v1) = True Or IsArray(v2) = True Then
        Err.Raise 13
        Exit Function
    End If
    If IsObject(v1) = True Or IsObject(v2) = True Then
        Err.Raise 13
        Exit Function
    End If
    
    If isSimpleNumericType(v1) = True Then
        If isSimpleNumericType(v2) = True Then
            '''''''''''''''''''''''''''''''''''''
            ' If BOTH v1 and v2 are numeric data
            ' types, then convert to Doubles and
            ' do an arithmetic compare and
            ' return the result.
            '''''''''''''''''''''''''''''''''''''
            d1 = CDbl(v1)
            d2 = CDbl(v2)
            If d1 = d2 Then
                qSortCompare = 0
                Exit Function
            End If
            If d1 < d2 Then
                qSortCompare = -1
                Exit Function
            End If
            If d1 > d2 Then
                qSortCompare = 1
                Exit Function
            End If
        End If
    End If
    ''''''''''''''''''''''''''''''''''''''''''''
    ' Either v1 or v2 was not numeric data type.
    ' Test whether BOTH v1 AND v2 are numeric
    ' strings. If BOTH are numeric, convert to
    ' Doubles and do a arithmetic comparison.
    ''''''''''''''''''''''''''''''''''''''''''''
    If IsNumeric(v1) = True And IsNumeric(v2) = True Then
        d1 = CDbl(v1)
        d2 = CDbl(v2)
        If d1 = d2 Then
            qSortCompare = 0
            Exit Function
        End If
        If d1 < d2 Then
            qSortCompare = -1
            Exit Function
        End If
        If d1 > d2 Then
            qSortCompare = 1
            Exit Function
        End If
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''
    ' Either or both v1 and v2 was not numeric
    ' string. In this case, convert to Strings
    ' and use StrComp to compare.
    ''''''''''''''''''''''''''''''''''''''''''''''
    s1 = CStr(v1)
    s2 = CStr(v2)
    qSortCompare = StrComp(s1, s2, compare)

End Function

Public Sub reverseArrayInPlace2( _
    ByRef inputArray As Variant, _
    Optional ByRef lb As Long = -1, _
    Optional ByRef ub As Long = -1 _
)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' reverseArrayInPlace2
    ' This reverses the order of elements in inputArray. To reverse the entire array, omit or
    ' set to less than 0 the lb and ub parameters. To reverse only part of tbe array, set lb and/or
    ' ub to the LBound and UBound of the sub array to be reversed.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    Dim n As Long
    Dim temp As Variant
    
    If lb < 0 Then
        lb = LBound(inputArray)
    End If
    If ub < 0 Then
        ub = UBound(inputArray)
    End If
    
    For n = lb To (lb + ((ub - lb - 1) \ 2))
        temp = inputArray(n)
        inputArray(n) = inputArray(ub - (n - lb))
        inputArray(ub - (n - lb)) = temp
    Next n
End Sub

Public Function isSimpleNumericType(ByVal v As Variant) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' isSimpleNumericType
    ' This returns TRUE if V is one of the following data types:
    '        vbBoolean
    '        vbByte
    '        vbCurrency
    '        vbDate
    '        vbDecimal
    '        vbDouble
    '        vbInteger
    '        vbLong
    '        vbSingle
    '        vbVariant if it contains a numeric value
    ' It returns FALSE for any other data type, including any array
    ' or vbEmpty.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If isSimpleDataType(v) = True Then
        Select Case VarType(v)
        Case vbBoolean, _
             vbByte, _
             vbCurrency, _
             vbDate, _
             vbDecimal, _
             vbDouble, _
             vbInteger, _
             vbLong, _
             vbSingle
            isSimpleNumericType = True
        Case vbVariant
            isSimpleNumericType = IsNumeric(v) = True
        Case Else
            isSimpleNumericType = False
        End Select
    Else
        isSimpleNumericType = False
    End If
End Function

Public Function isSimpleDataType(ByVal v As Variant) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' isSimpleDataType
    ' This function returns TRUE if V is one of the following
    ' variable types (as returned by the VarType function:
    '    vbBoolean
    '    vbByte
    '    vbCurrency
    '    vbDate
    '    vbDecimal
    '    vbDouble
    '    vbEmpty
    '    vbError
    '    vbInteger
    '    vbLong
    '    vbNull
    '    vbSingle
    '    vbString
    '    vbVariant
    '
    ' It returns FALSE if V is any one of the following variable
    ' types:
    '    vbArray
    '    vbDataObject
    '    vbObject
    '    vbUserDefinedType
    '    or if it is an array of any type.
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    '@Ignore UnhandledOnErrorResumeNextInspection
    On Error Resume Next
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Test if V is an array. We can't just use VarType(V) = vbArray
    ' because the VarType of an array is vbArray + VarType(type
    ' of array element). E.g, the VarType of an Array of Longs is
    ' 8195 = vbArray + vbLong.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If IsArray(v) = True Then
        isSimpleDataType = False
        Exit Function
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' We must also explicitly check whether V is an object, rather
    ' relying on VarType(V) to equal vbObject. The reason is that
    ' if V is an object and that object has a default proprety, VarType
    ' returns the data type of the default property. For example, if
    ' V is an Excel.Range object pointing to cell A1, and A1 contains
    ' 12345, VarType(V) would return vbDouble, the since Value is
    ' the default property of an Excel.Range object and the default
    ' numeric type of Value in Excel is Double. Thus, in order to
    ' prevent this type of behavior with default properties, we test
    ' IsObject(V) to see if V is an object.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If IsObject(v) = True Then
        isSimpleDataType = False
        Exit Function
    End If
    '''''''''''''''''''''''''''''''''''''
    ' Test the value returned by VarType.
    '''''''''''''''''''''''''''''''''''''
    Select Case VarType(v)
    Case vbArray, vbDataObject, vbObject, vbUserDefinedType
        '''''''''''''''''''''''
        ' not simple data types
        '''''''''''''''''''''''
        isSimpleDataType = False
    Case Else
        ''''''''''''''''''''''''''''''''''''
        ' otherwise it is a simple data type
        ''''''''''''''''''''''''''''''''''''
        isSimpleDataType = True
    End Select

End Function
Attribute VB_Name = "SupportFunctionsSpecific"
'@Folder("GlobalSupportFunctions")
Option Explicit

'
' Collection of Specific Support Functions,

Public Function toBaseUnit(ByVal value As Long) As Long
    toBaseUnit = value * Settings.conversionFactor
End Function

Public Function toDisplayUnit(ByVal value As Long) As Long
    toDisplayUnit = value / Settings.conversionFactor
End Function

' Converts the given value to a unit that is suitable for display
' This will reduce the number of decimals according to the set conversion factor (this is dependant on if the tool is set to mm or inches)
Public Function toDisplayUnitDouble(ByVal value As Double) As Double
    toDisplayUnitDouble = value / Settings.conversionFactor
    ' TODO: in some cases Settings might not be set here causing a division by zero
End Function

' Takes a cuttingType in sting format and returns a enumCuttingType if valid, returns typeNotSet
Public Function stringToCuttingType(ByVal value As String) As enumCuttingType
    Select Case value
    Case "A"
        stringToCuttingType = enumCuttingType.A
    Case "B1"
        stringToCuttingType = enumCuttingType.B1
    Case "B2"
        stringToCuttingType = enumCuttingType.B2
    Case "C1"
        stringToCuttingType = enumCuttingType.C1
    Case "C2"
        stringToCuttingType = enumCuttingType.c2
    Case Else
        stringToCuttingType = enumCuttingType.typeNotSet
    End Select
End Function


' Takes a cuttingType and returns a string version
Public Function cuttingTypeToString(ByVal value As enumCuttingType) As String
    Select Case value
    Case enumCuttingType.A
        cuttingTypeToString = "A"
    Case enumCuttingType.B1
        cuttingTypeToString = "B1"
    Case enumCuttingType.B2
        cuttingTypeToString = "B2"
    Case enumCuttingType.C1
        cuttingTypeToString = "C1"
    Case enumCuttingType.c2
        cuttingTypeToString = "C2"
    Case enumCuttingType.typeNotSet
        cuttingTypeToString = "typeNotSet"
    End Select
End Function

Public Function hprPlacementToString(ByVal placement As enumHPRPlacement) As String
    Select Case placement
    Case enumHPRPlacement.bothSides
        hprPlacementToString = "bothSides"
    Case enumHPRPlacement.leftSide
        hprPlacementToString = "leftSide"
    Case enumHPRPlacement.noSide
        hprPlacementToString = "noSide"
    Case enumHPRPlacement.notSet
        hprPlacementToString = "notSet"
    Case enumHPRPlacement.rightSide
        hprPlacementToString = "rightSide"
    End Select
End Function

' Takes a toleranceMode and returns a string version
Public Function toleranceModeToString(ByVal mode As enumToleranceMode) As String
    Select Case mode
    Case enumToleranceMode.modeNotSet
        toleranceModeToString = "modeNotSet"
    Case enumToleranceMode.withoutTolerances
        toleranceModeToString = "toleranceFreeMode"
    Case enumToleranceMode.withTolerances
        toleranceModeToString = "toleranceMode"
    End Select
End Function

Public Function optimizationModeToString(ByVal mode As enumOptimizationMode) As String
    Select Case mode
    Case enumOptimizationMode.bestFit
        optimizationModeToString = Globals.OPTIMIZATION_MODE_BEST_FIT
    Case enumOptimizationMode.limitedBruteForce
        optimizationModeToString = Globals.OPTIMIZATION_MODE_LIMITED_BRUTE_FORCE
    Case enumOptimizationMode.fullBruteForce
        optimizationModeToString = Globals.OPTIMIZATION_MODE_FULL_BRUTE_FORCE
    Case enumOptimizationMode.improvedBinCompletion
        optimizationModeToString = Globals.OPTIMIZATION_MODE_IMPROVED_BIN_COMPLETION
    End Select
End Function

Public Function stringToOptimizationMode(ByVal mode As String) As enumOptimizationMode
    Select Case mode
    Case Globals.OPTIMIZATION_MODE_BEST_FIT
        stringToOptimizationMode = enumOptimizationMode.bestFit
    Case Globals.OPTIMIZATION_MODE_LIMITED_BRUTE_FORCE
        stringToOptimizationMode = enumOptimizationMode.limitedBruteForce
    Case Globals.OPTIMIZATION_MODE_FULL_BRUTE_FORCE
        stringToOptimizationMode = enumOptimizationMode.fullBruteForce
    Case Globals.OPTIMIZATION_MODE_IMPROVED_BIN_COMPLETION
        stringToOptimizationMode = enumOptimizationMode.improvedBinCompletion
    Case Default
        Logger.logBug "Unrecognized mode found: " & mode
    End Select
End Function
Attribute VB_Name = "TeLogger"
'@TestModule
'@folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
Private Logger As CLogger

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
    Set Logger = New CLogger
    Logger.closeFile
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
    Logger.closeFile
    Set Logger = Nothing
End Sub

' Tests writing of of log-messages
'@IgnoreTest
'@TestMethod
Public Sub TestLogLevel()
    On Error GoTo TestFail
    Dim rndNum As Long
    
    ' Should go through the filter
    
    ' eAll is supposed to log eBug, eError and eInfo
    Logger.settingLogLevel = eAll
    rndNum = CLng(Int(999999 * Rnd()) + 1)
    Logger.logMsg "eBug on eAll " & rndNum, ebug
    Assert.AreEqual "B: eBug on eAll " & rndNum, Logger.readLastLine
    rndNum = CLng(Int(999999 * Rnd()) + 1)
    Logger.logMsg "eError on eAll " & rndNum, eError
    Assert.AreEqual "E: eError on eAll " & rndNum, Logger.readLastLine
    rndNum = CLng(Int(999999 * Rnd()) + 1)
    Logger.logMsg "eInfo on eAll " & rndNum, eInfo
    Assert.AreEqual "I: eInfo on eAll " & rndNum, Logger.readLastLine

    ' eErrors is supposed to log eBug and eError
    Logger.settingLogLevel = eErrors
    rndNum = CLng(Int(999999 * Rnd()) + 1)
    Logger.logMsg "eBug on eErrors " & rndNum, ebug
    Assert.AreEqual "B: eBug on eErrors " & rndNum, Logger.readLastLine
    rndNum = CLng(Int(999999 * Rnd()) + 1)
    Logger.logMsg "eError on eErrors " & rndNum, eError
    Assert.AreEqual "E: eError on eErrors " & rndNum, Logger.readLastLine
    
    ' eBugs is supposed to log eBug
    Logger.settingLogLevel = eBugs
    rndNum = CLng(Int(999999 * Rnd()) + 1)
    Logger.logMsg "eBug on eBugs " & rndNum, ebug
    Assert.AreEqual "B: eBug on eBugs " & rndNum, Logger.readLastLine

    ' Should be blocked by the filter
    
    ' Log a message that should go through
    Logger.settingLogLevel = eAll
    rndNum = CLng(Int(999999 * Rnd()) + 1)
    Logger.logMsg "eError on eAll " & rndNum, eError
    
    ' eErrors should block eInfo
    Logger.settingLogLevel = eErrors
    Logger.logMsg "Not logged", eInfo
    Assert.AreEqual "E: eError on eAll " & rndNum, Logger.readLastLine

    ' eBugs should block eInfo and eErrors
    Logger.settingLogLevel = eBugs
    Logger.logMsg "Not logged", eInfo
    Assert.AreEqual "E: eError on eAll " & rndNum, Logger.readLastLine
    Logger.logMsg "Not logged", eError
    Assert.AreEqual "E: eError on eAll " & rndNum, Logger.readLastLine

    ' eOff should block eBug, eInfo and eError
    Logger.settingLogLevel = eOff
    Logger.logMsg "Not logged", ebug
    Assert.AreEqual "E: eError on eAll " & rndNum, Logger.readLastLine
    Logger.logMsg "Not logged", eInfo
    Assert.AreEqual "E: eError on eAll " & rndNum, Logger.readLastLine
    Logger.logMsg "Not logged", eError
    Assert.AreEqual "E: eError on eAll " & rndNum, Logger.readLastLine

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "TeOptimization"
'@TestModule
'@folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


'Private Assert As New Rubberduck.AssertClass
Private Assert As Object


'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    
    Set Settings = New CSettings
    Set Request = New CRequest
    Set Translation = New CTranslation
    Set Logger = New CLogger
    Settings.setDefaults
    Settings.readAll
    Request.validators.applyVaildators
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
    
    Settings.setDefaults
    Settings.readAll
    Request.clearVariables
    
    Request.readChannelTypesSheets
    Request.channelTypeSet.generateCutPositionsForAll
    Request.channelTypeSet.generateValidationStrings
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
    
    Settings.setDefaults
    Settings.readAll
    Request.clearVariables
    
End Sub

'@IgnoreTest
'@TestMethod
Public Sub simpleZeroHPRTe()
    
' This test adds one item and checks:
' -That all bins are filled
    
    On Error GoTo TestFail
        
    'Arrange:
    Dim chtype As String
    Dim myItemSet As CItemSet
    Dim myBinSet As CBinSet
    Dim item As CItem

    ' Initiate a set of items
    
    chtype = "MC-41-GALV"
    
    Set myItemSet = New CItemSet
    myItemSet.channelTypeKey = chtype
    
    Set item = New CItem
    item.setValues _
        length:=9900, _
        tolerance:=30, _
        deviatingMinimumRemainingWebWidth:=0, _
        deviatingMinimumRemainingWebWidthSet:=False, _
        quantity:=1, _
        cuttingType:=enumCuttingType.A, _
        channelTypeKey:=chtype
    
    myItemSet.addItem item
    Request.addItemSet myItemSet
    
    Set myBinSet = New CBinSet
    myBinSet.setValues 0, Request.channelTypeSet.getMaxCapacity(chtype), 0, chtype
    Request.addBinSet myBinSet
    
    
    'Act:

    Logger.logInfo "Adding item:"
    Logger.logInfo " channelTypeKey" & vbTab & item.channelTypeKey
    Logger.logInfo " cuttingType" & vbTab & item.cuttingType
    Logger.logInfo " length" & vbTab & item.length
    Logger.logInfo " quantity" & vbTab & item.quantity
    Logger.logInfo " tolerance" & vbTab & item.tolerance

    Request.optimize

    Request.outputSheets.clear
    Request.outputSheets.writeProfileSheets
    Request.writeOutputs
    Request.diagrams.createDiagrams
    Request.diagrams.diagramSheetPrintSetup
    
    Dim binSets() As CBinSet
    binSets = Request.getSolutions
    Dim bins() As CBin
    
    Dim binSetNo As Long
    Dim binNo As Long
    
    Dim allBinsFilled As Boolean
    allBinsFilled = True
    
    binSetNo = Request.chTypeCount
    For binSetNo = 1 To Request.chTypeCount
        Logger.logInfo "binCount: " & binSets(binSetNo).count
        Logger.logInfo "capacity: " & binSets(binSetNo).capacity
        
        For binNo = 1 To binSets(binSetNo).count
            bins = binSets(binSetNo).getBins
            Logger.logInfo "capacity: " & bins(binNo).capacity
            Logger.logInfo "filled: " & bins(binNo).filled
            If Not bins(binNo).filled Then
                allBinsFilled = False
            End If
        Next
    Next


    'Assert:
    
    ' One bin was not filled. All bins are supposed to be filled once all optimizations are done
    Assert.isTrue allBinsFilled

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


Public Sub fastRun()
    ModuleInitialize
    TestInitialize
    simpleZeroHPRTe
    TestCleanup
    ModuleCleanup
End Sub


' End RubberDuck conditional compilation
#End If


Attribute VB_Name = "TeSettings"
'@TestModule
'@folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
    initialize_tool
End Sub

'@TestCleanup
Public Sub TestCleanup()
    ' this method runs after every test in the module.
End Sub

'@IgnoreTest
'@TestMethod
Public Sub initiationTe() ' TODO Rename test
    On Error GoTo TestFail

    'Arrange:

    'Dim long0 As Long
    'long0 = 0
    '@Ignore UseMeaningfulName
    Dim long10 As Long
    long10 = 10
    '@Ignore UseMeaningfulName
    Dim long15 As Long
    long15 = 15
    '@Ignore UseMeaningfulName
    Dim long3000 As Long
    long3000 = 3000
    '@Ignore UseMeaningfulName
    Dim long30 As Long
    long30 = 30

    Dim string1_10mm As String
    string1_10mm = "1/10 mm"

    Dim stringGermany As String
    stringGermany = "Germany"

    Dim stringEnglish As String
    stringEnglish = "English"

    'Act:
    Settings.setDefaults
    Settings.readAll

    'Assert:
    Assert.AreEqual long10, Settings.conversionFactor
    Assert.AreEqual long3000, Settings.cutFreeSpaceEnd
    Assert.AreEqual long30, Settings.defaultTolerance
    Assert.isTrue Settings.diagramHideCuts
    Assert.isTrue Settings.diagramPatternInstedOfColor
    Assert.isTrue Settings.diagramShowCombinedDiagram
    Assert.AreEqual string1_10mm, Settings.fundamentalUnit
    Assert.isTrue Settings.inputValidationOnchange
    Assert.AreEqual stringEnglish, Settings.Language
    Assert.AreEqual stringGermany, Settings.materialCountry
    Assert.AreEqual long15, Settings.maximumCuttingWidth

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
'@Ignore LineLabelNotUsed
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If


Attribute VB_Name = "TeTranslation"
'@TestModule
'@folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then

Private Assert As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub

'@TestMethod("Trivial")
Public Sub clearTranslationsTe()
    
    'Arrange:
    Dim longZero As Long
    'Dim longOne As Long
    longZero = 0
    'longOne = 1
    
    ' Force initialization of objects
    Translate vbNullString
    
    ' Set to non zero values
    'ReDim Translation.languages(0 To 1)
    'ReDim Translation.translationFields(0 To 1)
    Translation.languageCount = 242
    Translation.translationFieldCount = 13
    Translation.translationsHasBeenRead = True

    'Act:
    Translation.clearTranslations

    'Assert:
    ' Make sure that translations were successfully cleared
    
    ' Check counts:
    Assert.AreEqual longZero, Translation.languageCount
    Assert.AreEqual longZero, Translation.translationFieldCount
    
    ' Check the flag:
    Assert.isFalse Translation.translationsHasBeenRead
        
    ' TODO: Check languages array and the actual translation fields
    'Assert.AreEqual longOne, LBound(Translation.languages)
    'Assert.AreEqual longOne, UBound(Translation.languages)
    'Assert.AreEqual longOne, LBound(Translation.translationFields)
    'Assert.AreEqual longOne, UBound(Translation.translationFields)

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
'@Ignore LineLabelNotUsed
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "TestCBin"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then

Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@TestMethod
Public Sub Test_setValues()
    On Error GoTo TestFail

    'Arrange:
    Dim testBin As CBin
    Set testBin = New CBin
    
    ' Testvalues
    Dim length As Long
    Dim capacity As Long
    Dim capacityCuttable As Long
    Dim channelTypeKey As String
    
    ' Values
    length = 1000
    capacity = 990
    capacityCuttable = 989
    channelTypeKey = "MQ-41-GALV"
    
    'Act:
    testBin.setValues length, capacity, capacityCuttable, channelTypeKey

    'Assert:
    Assert.AreEqual testBin.length, length, "length failed #1"
    Assert.AreEqual testBin.capacity, capacity, "capacity failed #1"
    ' capacityCuttable cannot be tested
    Assert.AreEqual testBin.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"

    ' New values
    length = 2000
    capacity = 500
    capacityCuttable = 400
    channelTypeKey = "MQ-21"
    
    'Act:
    testBin.setValues length, capacity, capacityCuttable, channelTypeKey
    
    'Assert:
    Assert.AreEqual testBin.length, length, "length failed #2"
    Assert.AreEqual testBin.capacity, capacity, "capacity failed #2"
    ' capacityCuttable cannot be tested
    Assert.AreEqual testBin.channelTypeKey, channelTypeKey, "channelTypeKey failed #2"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_setAllValues()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testBin As CBin
    Set testBin = New CBin
    
    Dim length As Long
    Dim capacity As Long
    Dim capacityCuttable As Long
    Dim channelTypeKey As String
    Dim pieceCount As Long
    Dim filled As Boolean
    Dim quantity As Long
    Dim profileNo As Long
    Dim uniqueProfile As Boolean
    Dim permutation As CLongArray
    
    length = 1000
    capacity = 990
    capacityCuttable = 989
    channelTypeKey = "MQ-41-GALV"
    pieceCount = 0
    filled = True
    quantity = 1
    profileNo = 1
    uniqueProfile = True
    
    Set permutation = New CLongArray
    permutation.addElement 1
    permutation.addElement 2
    
    ' CBin requires the Setting object
    ' TODO delete this
    ensureGlobalObjectsExist
    
    'Act:
    testBin.setAllValues _
        length, _
        capacity, _
        capacityCuttable, _
        channelTypeKey, _
        pieceCount, _
        filled, _
        quantity, _
        profileNo, _
        uniqueProfile, _
        permutation
    
    'Assert:
    Assert.AreEqual testBin.length, length, "length failed #1 "
    Assert.AreEqual testBin.capacity, capacity, "capacity failed #1"
    ' capacityCuttable cannot be tested
    Assert.AreEqual testBin.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"
    Assert.AreEqual testBin.pieceCount, pieceCount, "pieceCount failed #1"
    Assert.AreEqual testBin.filled, filled, "filled failed #1"
    Assert.AreEqual testBin.quantity, quantity, "quantity failed #1"
    Assert.AreEqual testBin.profileNo, profileNo, "profileNo failed #1"
    Assert.AreEqual testBin.uniqueProfile, uniqueProfile, "uniqueProfile failed #1"
    
    'Arrange:
    ' New valeus
    length = 2000
    capacity = 1990
    capacityCuttable = 1989
    channelTypeKey = "MQ-42-GALV"
    pieceCount = 0
    filled = False
    quantity = 5
    profileNo = 2
    uniqueProfile = False
    
    'Act:
    testBin.setAllValues _
        length, _
        capacity, _
        capacityCuttable, _
        channelTypeKey, _
        pieceCount, _
        filled, _
        quantity, _
        profileNo, _
        uniqueProfile, _
        permutation
    
    'Assert:
    Assert.AreEqual testBin.length, length, "length failed #1 "
    Assert.AreEqual testBin.capacity, capacity, "capacity failed #1"
    ' capacityCuttable cannot be tested
    Assert.AreEqual testBin.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"
    Assert.AreEqual testBin.pieceCount, pieceCount, "pieceCount failed #1"
    Assert.AreEqual testBin.filled, filled, "filled failed #1"
    Assert.AreEqual testBin.quantity, quantity, "quantity failed #1"
    Assert.AreEqual testBin.profileNo, profileNo, "profileNo failed #1"
    Assert.AreEqual testBin.uniqueProfile, uniqueProfile, "uniqueProfile failed #1"
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_getCopy()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testBin As CBin
    Set testBin = New CBin
    
    Dim binCopy As CBin
        
    ' Testvalues
    Dim length As Long
    Dim capacity As Long
    Dim capacityCuttable As Long
    Dim channelTypeKey As String
    Dim pieceCount As Long
    Dim filled As Boolean
    Dim quantity As Long
    Dim profileNo As Long
    Dim uniqueProfile As Boolean
    Dim permutation As CLongArray
    
    Dim newLength As Long
    Dim newCapacity As Long
    Dim newCapacityCuttable As Long
    Dim newChannelTypeKey As String
    Dim newPieceCount  As Long
    Dim newFilled As Boolean
    Dim newQuantity As Long
    Dim newProfileNo As Long
    Dim newuUiqueProfile As Boolean
    Dim newPermutation As CLongArray
    
    length = 1000
    capacity = 990
    capacityCuttable = 989
    channelTypeKey = "MQ-41-GALV"
    pieceCount = 0
    filled = True
    quantity = 0
    profileNo = 1
    uniqueProfile = True
    
    Set permutation = New CLongArray
    permutation.addElement 1
    permutation.addElement 2
    
    ' CBin requires the Setting object
    ' TODO delete this
    ensureGlobalObjectsExist
    
    ' Set values of testItem
    ' Create a copy and verify that the new object has the same properties as the old
    
    'Act:
    testBin.setAllValues _
        length, _
        capacity, _
        capacityCuttable, _
        channelTypeKey, _
        pieceCount, _
        filled, _
        quantity, _
        profileNo, _
        uniqueProfile, _
        permutation
                         
    Set binCopy = testBin.getCopy
    
    ' Make sure we don't just have references to the same object
    Assert.AreNotSame binCopy, testBin, "Object separation failed, objects are the same."

    'Assert:
    Assert.AreEqual binCopy.length, length, "length failed #1 "
    Assert.AreEqual binCopy.capacity, capacity, "capacity failed #1"
    ' capacityCuttable cannot be tested
    Assert.AreEqual binCopy.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"
    Assert.AreEqual binCopy.pieceCount, pieceCount, "pieceCount failed #1"
    Assert.AreEqual binCopy.filled, filled, "filled failed #1"
    Assert.AreEqual binCopy.quantity, quantity, "quantity failed #1"
    Assert.AreEqual binCopy.profileNo, profileNo, "profileNo failed #1"
    Assert.AreEqual binCopy.uniqueProfile, uniqueProfile, "uniqueProfile failed #1"
    
    ' New values
    newLength = 2000
    newCapacity = 490
    newCapacityCuttable = 389
    newChannelTypeKey = "MQ-41-GALV"
    newPieceCount = 0
    newFilled = False
    newQuantity = 0
    newProfileNo = 3
    newuUiqueProfile = False
    
    Set newPermutation = New CLongArray
    newPermutation.addElement 2
    newPermutation.addElement 1
    
    ' Change values of the original.
    ' The copy should not change.
    
    'Act:
    testBin.setAllValues _
        newLength, _
        newCapacity, _
        newCapacityCuttable, _
        newChannelTypeKey, _
        newPieceCount, _
        newFilled, _
        newQuantity, _
        newProfileNo, _
        newuUiqueProfile, _
        newPermutation

    'Assert:
    Assert.AreEqual binCopy.length, length, "length failed #2"
    Assert.AreEqual binCopy.capacity, capacity, "capacity failed #2"
    ' capacityCuttable cannot be tested
    Assert.AreEqual binCopy.channelTypeKey, channelTypeKey, "channelTypeKey failed #2"
    Assert.AreEqual binCopy.pieceCount, pieceCount, "pieceCount failed #2"
    Assert.AreEqual binCopy.filled, filled, "filled failed #2"
    Assert.AreEqual binCopy.quantity, quantity, "quantity failed #2"
    Assert.AreEqual binCopy.profileNo, profileNo, "profileNo failed #2"
    Assert.AreEqual binCopy.uniqueProfile, uniqueProfile, "uniqueProfile failed #2"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_getPieceCopy()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testBin As CBin
    Dim piece1 As CPiece
    Dim piece2 As CPiece
    Dim pieceCopy As CPiece
    
    Set testBin = New CBin
    Set piece1 = New CPiece
    Set piece2 = New CPiece
    Set pieceCopy = New CPiece
    
    ' Testvalues
    Dim channelTypeKey1 As String
    Dim hprPlacement1 As enumHPRPlacement
    Dim cuttingType1 As enumCuttingType
    Dim pieceType1 As enumPieceType
    Dim length1 As Long
    Dim placed1 As Boolean
    Dim usedTolerance1 As Long
    Dim allowedTolerance1 As Long
    
    ' Values
    channelTypeKey1 = "MQ-41"
    hprPlacement1 = enumHPRPlacement.rightSide
    cuttingType1 = enumCuttingType.C1
    pieceType1 = enumPieceType.normal
    length1 = 2000
    placed1 = True
    usedTolerance1 = 1
    allowedTolerance1 = 30
    
    Dim channelTypeKey2 As String
    Dim hprPlacement2 As enumHPRPlacement
    Dim cuttingType2 As enumCuttingType
    Dim pieceType2 As enumPieceType
    Dim length2 As Long
    Dim placed2 As Boolean
    Dim usedTolerance2 As Long
    Dim allowedTolerance2 As Long
    
    ' Values
    channelTypeKey2 = "MQ-42"
    hprPlacement2 = enumHPRPlacement.bothSides
    cuttingType2 = enumCuttingType.B1
    pieceType2 = enumPieceType.waste
    length2 = 4000
    placed2 = False
    usedTolerance2 = 2
    allowedTolerance2 = 1
    
    piece1.setValues _
        channelTypeKey1, _
        hprPlacement1, _
        cuttingType1, _
        pieceType1, _
        length1, _
        placed1, _
        usedTolerance1, _
        allowedTolerance1
        
    piece2.setValues _
        channelTypeKey2, _
        hprPlacement2, _
        cuttingType2, _
        pieceType2, _
        length2, _
        placed2, _
        usedTolerance2, _
        allowedTolerance2
        
    testBin.addPiece piece1
    testBin.addPiece piece2
    
    'Act:
    Set pieceCopy = testBin.getPieceCopy(1)
    
    'Assert:
    
    ' Make sure we don't just have references to the same object
    Assert.AreNotSame pieceCopy, piece1, "Object separation failed, objects are the same. #1"

    ' Check that values are correct
    Assert.AreEqual pieceCopy.channelTypeKey, channelTypeKey1, "channelTypeKey failed #1"
    Assert.AreEqual pieceCopy.hprPlacement, hprPlacement1, "hprPlacement failed #1"
    Assert.AreEqual pieceCopy.cuttingType, cuttingType1, "cuttingType failed #1"
    Assert.AreEqual pieceCopy.pieceType, pieceType1, "pieceType failed #1"
    Assert.AreEqual pieceCopy.length, length1, "length failed #1"
    Assert.AreEqual pieceCopy.placed, placed1, "placed failed #1"
    Assert.AreEqual pieceCopy.usedTolerance, usedTolerance1, "usedTolerance failed #1"
    Assert.AreEqual pieceCopy.allowedTolerance, allowedTolerance1, "allowedTolerance failed #1"
    
    'Act:
    Set pieceCopy = testBin.getPieceCopy(2)
    
    'Assert:
    
    ' Make sure we don't just have references to the same object
    Assert.AreNotSame pieceCopy, piece2, "Object separation failed, objects are the same. #2"
    
    ' Check that values are correct
    Assert.AreEqual pieceCopy.channelTypeKey, channelTypeKey2, "channelTypeKey failed #2"
    Assert.AreEqual pieceCopy.hprPlacement, hprPlacement2, "hprPlacement failed #2"
    Assert.AreEqual pieceCopy.cuttingType, cuttingType2, "cuttingType failed #2"
    Assert.AreEqual pieceCopy.pieceType, pieceType2, "pieceType failed #2"
    Assert.AreEqual pieceCopy.length, length2, "length failed #2"
    Assert.AreEqual pieceCopy.placed, placed2, "placed failed #2"
    Assert.AreEqual pieceCopy.usedTolerance, usedTolerance2, "usedTolerance failed #2"
    Assert.AreEqual pieceCopy.allowedTolerance, allowedTolerance2, "allowedTolerance failed #2"
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getUsefullSum()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getSum()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getWasteSum()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getWastePlusUnusedSpaceSum()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getPieceType()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getPieceHPRPlacement()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getPieceLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addPiece()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_isEqualTo()
    ' TODO: Work in progress
    On Error GoTo TestFail
 
    'Arrange:
    Dim testBin As CBin
    Dim equalBin As CBin
    Dim notEqualBin As CBin
    Dim piece1 As CPiece
    Dim piece2 As CPiece
    
    Dim isTrue As Boolean
    Dim isFalse As Boolean
    
    Set testBin = New CBin
    Set equalBin = New CBin
    Set notEqualBin = New CBin
    Set piece1 = New CPiece
    Set piece2 = New CPiece
    
    
    Dim length As Long
    Dim capacity As Long
    Dim capacityCuttable As Long
    Dim channelTypeKey As String
    Dim pieceCount As Long
    Dim filled As Boolean
    Dim quantity As Long
    Dim profileNo As Long
    Dim uniqueProfile As Boolean
    Dim permutation As CLongArray
    
    Dim newLength As Long
    Dim newCapacity As Long
    Dim newCapacityCuttable As Long
    Dim newChannelTypeKey As String
    Dim newPieceCount  As Long
    Dim newFilled As Boolean
    Dim newQuantity As Long
    Dim newProfileNo As Long
    Dim newuUiqueProfile As Boolean
    Dim newPermutation As CLongArray
    
    length = 1000
    capacity = 990
    capacityCuttable = 989
    channelTypeKey = "MQ-41-GALV"
    pieceCount = 0
    filled = True
    quantity = 0
    profileNo = 1
    uniqueProfile = True
    
    Set permutation = New CLongArray
    permutation.addElement 1
    permutation.addElement 2
    
    ' CBin requires the Setting object
    ' TODO delete this
    ensureGlobalObjectsExist
    
    ' Set values of testItem
    ' Create a copy and verify that the new object has the same properties as the old
    
    'Act:
    testBin.setAllValues _
        length, _
        capacity, _
        capacityCuttable, _
        channelTypeKey, _
        pieceCount, _
        filled, _
        quantity, _
        profileNo, _
        uniqueProfile, _
        permutation
                             
    Set equalBin = testBin.getCopy
    
    ' Assert:
    'Assert.AreEquals
    
    ' Testvalues
    Dim channelTypeKey1 As String
    Dim hprPlacement1 As enumHPRPlacement
    Dim cuttingType1 As enumCuttingType
    Dim pieceType1 As enumPieceType
    Dim length1 As Long
    Dim placed1 As Boolean
    Dim usedTolerance1 As Long
    Dim allowedTolerance1 As Long
    
    ' Values
    channelTypeKey1 = "MQ-41"
    hprPlacement1 = enumHPRPlacement.rightSide
    cuttingType1 = enumCuttingType.C1
    pieceType1 = enumPieceType.normal
    length1 = 2000
    placed1 = True
    usedTolerance1 = 1
    allowedTolerance1 = 30
    
    Dim channelTypeKey2 As String
    Dim hprPlacement2 As enumHPRPlacement
    Dim cuttingType2 As enumCuttingType
    Dim pieceType2 As enumPieceType
    Dim length2 As Long
    Dim placed2 As Boolean
    Dim usedTolerance2 As Long
    Dim allowedTolerance2 As Long
    
    ' Values
    channelTypeKey2 = "MQ-42"
    hprPlacement2 = enumHPRPlacement.bothSides
    cuttingType2 = enumCuttingType.B1
    pieceType2 = enumPieceType.waste
    length2 = 4000
    placed2 = False
    usedTolerance2 = 2
    allowedTolerance2 = 1
    
    piece1.setValues _
        channelTypeKey1, _
        hprPlacement1, _
        cuttingType1, _
        pieceType1, _
        length1, _
        placed1, _
        usedTolerance1, _
        allowedTolerance1
    
    piece2.setValues _
        channelTypeKey2, _
        hprPlacement2, _
        cuttingType2, _
        pieceType2, _
        length2, _
        placed2, _
        usedTolerance2, _
        allowedTolerance2
    
    testBin.addPiece piece1
    testBin.addPiece piece2
        
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placePiece()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addRightCut()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placePieceZeroHPR()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placePieceOneHPR()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placePieceBothHPR()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placePieceBothHPRNoMargin()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addCut()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addWastePiece()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_fillWasteSpace()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_updateAvailableLengths()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_couldBeFittedAtAll()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_cutAfterPieceEndsInCutFreeSpace()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_largerThanOrEqualToCutFreeSpaceUsingTolerance()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getToleranceNeededToPlaceOverCutFreeSpaceRounded()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "TestCBinSet"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_setValues()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addBin()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_createBin()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addUnplaceable()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_clearBins()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_clearBinsDontAddOne()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getTotalCapacity()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getTotalLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getUsefullSum()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getWaste()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_orderByFillrateDescending()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_orderByWastRatePlusUnusedSpaceAscending()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_markUniqueProfiles()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_assignProfileNumbers()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_highestPieceCount()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placeItems()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_postOptimization()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_changeChannelTypesToSmaller()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addEndWastePieces()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getPieceType()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getPieceLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getPieceCount()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getPieceHPRPlacement()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placeItemsBestFit()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placeItemsBestFitDisabledTolerance()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_placeItemsLimitedBruteForce()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "TestCChannelType"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addVariant()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_calculateCutMark()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_calculateLeftCutMax()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_calculateLeftCutMin()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_calculateRightCutMax()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_calculateRightCutMin()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_generateCutMarks()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_generateCutPositions()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_generateLeftCutAreas()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_generateRightCutAreas()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_genreateValidLengthsBothHpr()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getHiltiStdTolerance()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getLeftCutMax()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getLeftCutMin()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getMaxLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getMaxSafeLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getMaxUsableLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getRightCutMax()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getRightCutMin()
'#Stub
     On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_isValidHPRLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_isValidLeftHPR()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_isValidRightHPR()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_matches()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_parseKey()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If

Attribute VB_Name = "TestCChannelTypeSet"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addChannelType()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_addVariant()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_generateCutPositionsForAll()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_generateValidationStrings()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getChType()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getChTypeFromKey()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getChTypeIndexFromKey()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getIdFromKey()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getMaxCapacity()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getMaxLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getMaxUsableLength()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getSmallerVariants()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getVariant()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getSpecificValidatorsExtra()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getSpecificValidatorsHPR()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getSpecificValidatorsMaterial()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getSpecificValidatorsSize()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getSpecificValidatorsType()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_isValidType()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_recalculateCutPositionsForChannelType()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_typeExists()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If

Attribute VB_Name = "TestCChannelTypeVariant"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@TestMethod
Public Sub Test_setValues()
    On Error GoTo TestFail
        
    'Arrange:
    Dim testChannelTypeVariant As CChannelTypeVariant
    
    Set testChannelTypeVariant = New CChannelTypeVariant
    
    Dim lengthName As String
    Dim deliveryTolerancePlus As Long
    Dim deliveryToleranceMinus As Long
    Dim cutCost As Long
    Dim length As Long
    Dim cost As Long
    Dim bundleSize As Long
    Dim SAP_number As String
    Dim SAP_description As String
    
    Dim deliveryToleranceMinus_reconstructed As Long
    Dim safeLength_supposed As Long
    
    lengthName = "3m"
    deliveryTolerancePlus = 10
    deliveryToleranceMinus = 10
    cutCost = 1200
    length = 20000
    cost = 4000
    bundleSize = 10
    SAP_number = "2352385"
    SAP_description = "MQ-41"
    
    'Act:
    testChannelTypeVariant.setValues _
        lengthName, _
        deliveryTolerancePlus, _
        deliveryToleranceMinus, _
        cutCost, _
        length, _
        cost, _
        bundleSize, _
        SAP_number, _
        SAP_description
    
    ' Reconstruct delivery tolerance minus:
    ' Safe length is supposed to give the length - deliveryToleranceMinus
    deliveryToleranceMinus_reconstructed = -1 * (testChannelTypeVariant.safeLength - length)
    safeLength_supposed = length - deliveryToleranceMinus
    
    'Assert:
    ' lengthName cannot be tested
    Assert.AreEqual testChannelTypeVariant.length, length, "length failed #1"
    ' deliveryTolerancePlus cannot be tested
    Assert.AreEqual deliveryToleranceMinus_reconstructed, deliveryToleranceMinus, "deliveryToleranceMinus failed #1"
    Assert.AreEqual testChannelTypeVariant.safeLength, safeLength_supposed, "safeLength failed #1"
    Assert.AreEqual testChannelTypeVariant.cutCost, cutCost, "cutCost failed #1"
    ' cost cannot be tested
    ' budleSize cannot be tested
    Assert.AreEqual testChannelTypeVariant.SAPnumber, SAP_number, "SAP_number failed #1"
    Assert.AreEqual testChannelTypeVariant.SAPdescription, SAP_description, "SAP_description failed #1"
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If

Attribute VB_Name = "TestCFastPermutation"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

Private inputCounts As CLongArray
Private testNumberOfPermutations As Long
Private testPermutations As Collection
Private testPermutation As CLongArray
Private correctNumberOfPermutations As Long
Private correctPermutations As Collection
Private correctPermutation As CLongArray
Private permutationFinder As CFastPermutation
Private i As Long

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
    initialize_tool True
    i = 0
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_existsInSet()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub



'@TestMethod
Public Sub Test_findPermutations()
    On Error GoTo TestFail
    
    Dim j As Long

    ' Test #1, only one element
    ' Arrange:
    resetObjects
    i = i + 1
    inputCounts.addElement 1
    correctNumberOfPermutations = 1
    Set correctPermutation = New CLongArray
    correctPermutation.addElement 1
    correctPermutations.Add correctPermutation.getCopy
    ' Act:
    testNumberOfPermutations = permutationFinder.findPermutations(inputCounts, testPermutations)   ' Collect all permutations in the permutations collection object (sent as byref)
    'Assert:
    checkPermutations
    
    '
    ' Test #2, two elements counts(1,2)
    '
    ' Input:
    ' A,BB
    '
    ' Correct:
    ' ABB
    ' BAB
    ' BBA
    '
    ' Arrange:
    resetObjects
    i = i + 1
    inputCounts.addElement 1
    inputCounts.addElement 2
    correctNumberOfPermutations = 3
    
    Set correctPermutation = New CLongArray
    correctPermutation.addElement 1
    correctPermutation.addElement 2
    correctPermutation.addElement 2
    correctPermutations.Add correctPermutation.getCopy
    
    Set correctPermutation = New CLongArray
    correctPermutation.addElement 2
    correctPermutation.addElement 1
    correctPermutation.addElement 2
    correctPermutations.Add correctPermutation.getCopy
     
    Set correctPermutation = New CLongArray
    correctPermutation.addElement 2
    correctPermutation.addElement 2
    correctPermutation.addElement 1
    correctPermutations.Add correctPermutation.getCopy
     
    ' Act:
    ' Collect all permutations in the permutations collection object (sent as byref)
    testNumberOfPermutations = permutationFinder.findPermutations(inputCounts, testPermutations)
    For j = 1 To testPermutations.count
        Set testPermutation = testPermutations.item(j)
    Next
    'Assert:
    checkPermutations

    ' Test #3, two elements counts(2,1)
    '
    ' Input:
    ' AA,B
    '
    ' Correct:
    ' AAB
    ' ABA
    ' BAA
    '
    ' Arrange:
    resetObjects
    i = i + 1
    inputCounts.addElement 2
    inputCounts.addElement 1
    correctNumberOfPermutations = 3
    
    
    Set correctPermutation = New CLongArray
    correctPermutation.addElement 1
    correctPermutation.addElement 1
    correctPermutation.addElement 2
    correctPermutations.Add correctPermutation.getCopy
    
    Set correctPermutation = New CLongArray
    correctPermutation.addElement 1
    correctPermutation.addElement 2
    correctPermutation.addElement 1
    correctPermutations.Add correctPermutation.getCopy
    
    Set correctPermutation = New CLongArray
    correctPermutation.addElement 2
    correctPermutation.addElement 1
    correctPermutation.addElement 1
    correctPermutations.Add correctPermutation.getCopy
    
    ' Act:
    ' Collect all permutations in the permutations collection object (sent as byref)
    testNumberOfPermutations = permutationFinder.findPermutations(inputCounts, testPermutations)
    For j = 1 To testPermutations.count
        Set testPermutation = testPermutations.item(j)
    Next
    'Assert:
    checkPermutations

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_noOfPermutations()
    On Error GoTo TestFail
    
    ' Test #1, Three elements counts(1)
    '
    ' Input:
    ' A
    '
    ' Correct:
    ' A
    '
    
    'Arrange:
    resetObjects
    i = i + 1
    inputCounts.addElement 1
    correctNumberOfPermutations = 1

    'Act:
    testNumberOfPermutations = permutationFinder.noOfPermutations(inputCounts)
    
    'Assert:
    Assert.AreEqual testNumberOfPermutations, correctNumberOfPermutations, "Incorrect number of permutations, Test #" & i
    
    
    ' Test #2, Three elements counts(1,1,1)
    '
    ' Input:
    ' A,B,C
    '
    ' Correct:
    ' ABC
    ' ACB
    ' BAC
    ' BCA
    ' CAB
    ' CBA
    '
    
    'Arrange:
    resetObjects
    i = i + 1
    inputCounts.addElement 1
    inputCounts.addElement 1
    inputCounts.addElement 1
    correctNumberOfPermutations = 6
    
    'Act:
    testNumberOfPermutations = permutationFinder.noOfPermutations(inputCounts)
    
    'Assert:
    Assert.AreEqual correctNumberOfPermutations, testNumberOfPermutations, "Incorrect number of permutations, Test #" & i
    Logger.logInfo "testNumberOfPermutations" & testNumberOfPermutations
    
    
    ' Test #3, Empty set, should give zero, but it gives one.
    '
    ' Input:
    '
    ' Correct:
    '
    
    'Arrange:
    'resetObjects
    'i = i + 1
    'correctNumberOfPermutations = 0

    'Act:
    'testNumberOfPermutations = permutationFinder.noOfPermutations(inputCounts)
    
    'Assert:
    'Assert.AreEqual correctNumberOfPermutations, testNumberOfPermutations, "Incorrect number of permutations, Test #" & i
    'Logger.logInfo "testNumberOfPermutations" & testNumberOfPermutations
    
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_permutate()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


Private Sub resetObjects()
    Set inputCounts = New CLongArray
    testNumberOfPermutations = 0
    Set testPermutations = New Collection
    Set testPermutation = New CLongArray
    correctNumberOfPermutations = 0
    Set correctPermutations = New Collection
    Set correctPermutation = New CLongArray
    Set permutationFinder = New CFastPermutation
End Sub


Private Sub checkPermutations()
    Dim j As Long
    Assert.AreEqual testNumberOfPermutations, correctNumberOfPermutations, "Permutations failed #" & i
    'Logger.logInfo vbTab & "Assertloop #1, testing if all correctPermutations exists in testPermutations"
    For j = 1 To correctPermutations.count
        'Logger.logInfo vbTab & vbTab & "checking correctPermutation " & j & ":" & correctPermutation.getString
        Set correctPermutation = correctPermutations.item(j)
        Assert.isTrue permutationFinder.existsInSet(testPermutations, correctPermutation), j & " - The permutation [" & correctPermutation.getString & "] does not exist in testPermutations"
    Next
    'Logger.logInfo vbTab & "Assertloop #2, testing if all testPermutations exists in correctPermutations"
    For j = 1 To testPermutations.count
        'Logger.logInfo vbTab & vbTab & "checking testPermutation " & j & ":" & testPermutation.getString
        Set testPermutation = testPermutations.item(j)
        Assert.isTrue permutationFinder.existsInSet(correctPermutations, testPermutation), j & " - The permutation [" & testPermutation.getString & "] does not exist in correctPermutations"
    Next
End Sub


' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "TestCItem"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub

'@TestMethod
Public Sub Test_setValues()
    On Error GoTo TestFail

    'Arrange:
    Dim testItem As CItem
    Set testItem = New CItem
    
    ' Testvalues
    Dim length As Long
    Dim tolerance As Long
    Dim deviatingMinimumRemainingWebWidth As Long
    Dim deviatingMinimumRemainingWebWidthSet As Boolean
    Dim quantity As Long
    '@Ignore UseMeaningfulName
    Dim cuttingType As enumCuttingType
    Dim channelTypeKey As String
    
    ' Values
    length = 50000
    tolerance = 200
    deviatingMinimumRemainingWebWidth = 0
    deviatingMinimumRemainingWebWidthSet = False
    quantity = 20
    cuttingType = enumCuttingType.C1
    channelTypeKey = "MQ-41"
    
        
    'Act:
    testItem.setValues _
        length, _
        tolerance, _
        deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet, _
        quantity, _
        cuttingType, _
        channelTypeKey

    'Assert:
    Assert.AreEqual testItem.length, length, "length failed #1"
    Assert.AreEqual testItem.tolerance, tolerance, "tolerance failed #1"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth, "deviatingMinimumRemainingWebWidth failed #1"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet, "deviatingMinimumRemainingWebWidthSet failed #1"
    Assert.AreEqual testItem.quantity, quantity, "quantity failed #1"
    Assert.AreEqual testItem.cuttingType, cuttingType, "cuttingType failed #1"
    Assert.AreEqual testItem.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"

    ' New values
    length = 30000
    tolerance = 100
    deviatingMinimumRemainingWebWidth = 150
    deviatingMinimumRemainingWebWidthSet = True
    quantity = 4
    cuttingType = enumCuttingType.B1
    channelTypeKey = "MQ-21"
    
    'Act:
    testItem.setValues _
        length, _
        tolerance, _
        deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet, _
        quantity, _
        cuttingType, _
        channelTypeKey

    'Assert:
    Assert.AreEqual testItem.length, length, "length failed #2"
    Assert.AreEqual testItem.tolerance, tolerance, "tolerance failed #2"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth, "deviatingMinimumRemainingWebWidth failed #2"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet, "deviatingMinimumRemainingWebWidthSet failed #2"
    Assert.AreEqual testItem.quantity, quantity, "quantity failed #2"
    Assert.AreEqual testItem.cuttingType, cuttingType, "cuttingType failed #2"
    Assert.AreEqual testItem.channelTypeKey, channelTypeKey, "channelTypeKey failed #2"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_getCopy()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testItem As CItem
    Set testItem = New CItem
    
    Dim itemCopy As CItem
        
    ' Testvalues
    Dim length As Long
    Dim tolerance As Long
    Dim deviatingMinimumRemainingWebWidth As Long
    Dim deviatingMinimumRemainingWebWidthSet As Boolean
    Dim quantity As Long
    '@Ignore UseMeaningfulName
    Dim cuttingType As enumCuttingType
    Dim channelTypeKey As String
    
    ' Values
    length = 50000
    tolerance = 200
    deviatingMinimumRemainingWebWidth = 0
    deviatingMinimumRemainingWebWidthSet = False
    quantity = 20
    cuttingType = enumCuttingType.C1
    channelTypeKey = "MQ-41"
    
    
    ' Set values of testItem
    ' Create a copy and verify that the new object has the same properties as the old
    
    'Act:
    testItem.setValues _
        length, _
        tolerance, _
        deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet, _
        quantity, _
        cuttingType, _
        channelTypeKey
    Set itemCopy = testItem.getCopy
    
    ' Make sure we don't just have references to the same object
    Assert.AreNotSame itemCopy, testItem, "Object separation failed, objects are the same."

    'Assert:
    Assert.AreEqual itemCopy.length, length, "length failed #1"
    Assert.AreEqual itemCopy.tolerance, tolerance, "tolerance failed #1"
    Assert.AreEqual itemCopy.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth, "deviatingMinimumRemainingWebWidth failed #1"
    Assert.AreEqual itemCopy.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet, "deviatingMinimumRemainingWebWidthSet failed #1"
    Assert.AreEqual itemCopy.quantity, quantity, "quantity failed #1"
    Assert.AreEqual itemCopy.cuttingType, cuttingType, "cuttingType failed #1"
    Assert.AreEqual itemCopy.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"
    
    ' New values
    length = 30000
    tolerance = 100
    deviatingMinimumRemainingWebWidth = 150
    deviatingMinimumRemainingWebWidthSet = True
    quantity = 4
    cuttingType = enumCuttingType.B1
    channelTypeKey = "MQ-21"
    
    ' Change values of the original.
    ' The copy should not change.
    
    'Act:
    testItem.setValues _
        length, _
        tolerance, _
        deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet, _
        quantity, _
        cuttingType, _
        channelTypeKey
    
    'Assert:
    Assert.AreNotEqual itemCopy.length, length, "length failed #2"
    Assert.AreNotEqual itemCopy.tolerance, tolerance, "tolerance failed #2"
    Assert.AreNotEqual itemCopy.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth, "deviatingMinimumRemainingWebWidth failed #2"
    Assert.AreNotEqual itemCopy.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet, "deviatingMinimumRemainingWebWidthSet failed #2"
    Assert.AreNotEqual itemCopy.quantity, quantity, "quantity failed #2"
    Assert.AreNotEqual itemCopy.cuttingType, cuttingType, "cuttingType failed #2"
    Assert.AreNotEqual itemCopy.channelTypeKey, channelTypeKey, "channelTypeKey failed #2"
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_piece()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testItem As CItem
    Set testItem = New CItem
    
    Dim myPiece As CPiece
    Set myPiece = New CPiece
    
    Dim longZero As Long
    longZero = 0
    
    ' Testvalues
    Dim length As Long
    Dim tolerance As Long
    Dim deviatingMinimumRemainingWebWidth As Long
    Dim deviatingMinimumRemainingWebWidthSet As Boolean
    Dim quantity As Long
    '@Ignore UseMeaningfulName
    Dim cuttingType As enumCuttingType
    Dim channelTypeKey As String
        
    ' Values
    length = 50000
    tolerance = 200
    deviatingMinimumRemainingWebWidth = 0
    deviatingMinimumRemainingWebWidthSet = False
    quantity = 20
    cuttingType = enumCuttingType.C1
    channelTypeKey = "MQ-41"
        
    'Act:
    testItem.setValues _
        length, _
        tolerance, _
        deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet, _
        quantity, _
        cuttingType, _
        channelTypeKey

    ' Create a piece from the item
    Set myPiece = testItem.piece

    ' Test if it is a CPiece object
    If Not TypeOf myPiece Is CPiece Then
        Assert.Fail "the returned piece is not a CPiece object"
    End If

    ' Test values that should be the same as the item
    Assert.AreEqual myPiece.channelTypeKey, testItem.channelTypeKey, "channelTypeKey failed"
    Assert.AreEqual myPiece.cuttingType, testItem.cuttingType, "cuttingType failed"
    Assert.AreEqual myPiece.length, testItem.length, "length failed"
    Assert.AreEqual myPiece.allowedTolerance, testItem.tolerance, "tolerance failed"
    
    ' Values that should be reset by default
    Assert.AreEqual myPiece.hprPlacement, enumHPRPlacement.notSet, "hprPlacement failed"
    Assert.isFalse myPiece.placed, "placed failed"
    Assert.AreEqual myPiece.usedTolerance, longZero, "usedTolerance failed"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


#End If

Attribute VB_Name = "TestCItemSet"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@TestMethod
Public Sub Test_addItem()
    On Error GoTo TestFail

    'Arrange:
    Dim testItem As CItem
    Set testItem = New CItem
    Dim testItemSet As CItemSet
    Set testItemSet = New CItemSet
    
    ' Testvalues
    Dim length As Long
    Dim tolerance As Long
    Dim deviatingMinimumRemainingWebWidth As Long
    Dim deviatingMinimumRemainingWebWidthSet As Boolean
    Dim quantity As Long
    '@Ignore UseMeaningfulName
    Dim cuttingType As enumCuttingType
    Dim channelTypeKey As String
    Dim one As Long
    
    ' Values
    length = 50000
    tolerance = 200
    deviatingMinimumRemainingWebWidth = 0
    deviatingMinimumRemainingWebWidthSet = False
    quantity = 20
    cuttingType = enumCuttingType.C1
    channelTypeKey = "MQ-41"
    
    ' Test variables
    one = 1
        
    'Act:
    testItem.setValues _
        length, _
        tolerance, _
        deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet, _
        quantity, _
        cuttingType, _
        channelTypeKey

    testItemSet.addItem testItem
    
    'Assert:
    ' Make sure it was added
    Assert.AreEqual testItemSet.count, one, "count failed #1"
    ' Test values
    Assert.AreEqual testItemSet.count, one, "length failed #1"
    Assert.AreEqual testItem.tolerance, tolerance, "tolerance failed #1"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth, "deviatingMinimumRemainingWebWidth failed #1"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet, "deviatingMinimumRemainingWebWidthSet failed #1"
    Assert.AreEqual testItem.quantity, quantity, "quantity failed #1"
    Assert.AreEqual testItem.cuttingType, cuttingType, "cuttingType failed #1"
    Assert.AreEqual testItem.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"

    ' New values
    length = 30000
    tolerance = 100
    deviatingMinimumRemainingWebWidth = 150
    deviatingMinimumRemainingWebWidthSet = True
    quantity = 4
    cuttingType = one
    channelTypeKey = "MQ-21"
    
    'Act:
    testItem.setValues _
        length, _
        tolerance, _
        deviatingMinimumRemainingWebWidth, _
        deviatingMinimumRemainingWebWidthSet, _
        quantity, _
        cuttingType, _
        channelTypeKey

    'Assert:
    Assert.AreEqual testItem.length, length, "length failed #2"
    Assert.AreEqual testItem.tolerance, tolerance, "tolerance failed #2"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth, "deviatingMinimumRemainingWebWidth failed #2"
    Assert.AreEqual testItem.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet, "deviatingMinimumRemainingWebWidthSet failed #2"
    Assert.AreEqual testItem.quantity, quantity, "quantity failed #2"
    Assert.AreEqual testItem.cuttingType, cuttingType, "cuttingType failed #2"
    Assert.AreEqual testItem.channelTypeKey, channelTypeKey, "channelTypeKey failed #2"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_getItemCopy()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testItemSet As CItemSet
    Set testItemSet = New CItemSet
    
    Dim itemCopy As CItem
        
    Dim testItem1 As CItem
    Dim testItem2 As CItem
    
    Set testItem1 = New CItem
    Set testItem2 = New CItem
    
    ' Testvalues
    Dim length1 As Long
    Dim tolerance1 As Long
    Dim deviatingMinimumRemainingWebWidth1 As Long
    Dim deviatingMinimumRemainingWebWidthSet1 As Boolean
    Dim quantity1 As Long
    '@Ignore UseMeaningfulName
    Dim cuttingType1 As enumCuttingType
    Dim channelTypeKey1 As String
    
    Dim length2 As Long
    Dim tolerance2 As Long
    Dim deviatingMinimumRemainingWebWidth2 As Long
    Dim deviatingMinimumRemainingWebWidthSet2 As Boolean
    Dim quantity2 As Long
    '@Ignore UseMeaningfulName
    Dim cuttingType2 As enumCuttingType
    Dim channelTypeKey2 As String
    
    ' Values
    length1 = 50000
    tolerance1 = 200
    deviatingMinimumRemainingWebWidth1 = 0
    deviatingMinimumRemainingWebWidthSet1 = False
    quantity1 = 20
    cuttingType1 = enumCuttingType.C1
    channelTypeKey1 = "MQ-41"
    
    length2 = 55000
    tolerance2 = 150
    deviatingMinimumRemainingWebWidth2 = 1
    deviatingMinimumRemainingWebWidthSet2 = True
    quantity2 = 15
    cuttingType2 = enumCuttingType.B1
    channelTypeKey2 = "MQ-21"
    
    
    ' Set values of testItem
    ' Create a copy and verify that the new object has the same properties as the old
    
    testItem1.setValues _
        length1, _
        tolerance1, _
        deviatingMinimumRemainingWebWidth1, _
        deviatingMinimumRemainingWebWidthSet1, _
        quantity1, _
        cuttingType1, _
        channelTypeKey1
        
    testItem2.setValues _
        length2, _
        tolerance2, _
        deviatingMinimumRemainingWebWidth2, _
        deviatingMinimumRemainingWebWidthSet2, _
        quantity2, _
        cuttingType2, _
        channelTypeKey2

    testItemSet.addItem testItem1
    testItemSet.addItem testItem2

    'Act:
    Set itemCopy = testItemSet.getItemCopy(1)
    
    ' Make sure we don't just have references to the same object
    Assert.AreNotSame itemCopy, testItem1, "Object separation failed, objects are the same."

    'Assert:
    Assert.AreEqual itemCopy.length, length1, "length failed #1"
    Assert.AreEqual itemCopy.tolerance, tolerance1, "tolerance failed #1"
    Assert.AreEqual itemCopy.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth1, "deviatingMinimumRemainingWebWidth failed #1"
    Assert.AreEqual itemCopy.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet1, "deviatingMinimumRemainingWebWidthSet failed #1"
    Assert.AreEqual itemCopy.quantity, quantity1, "quantity failed #1"
    Assert.AreEqual itemCopy.cuttingType, cuttingType1, "cuttingType failed #1"
    Assert.AreEqual itemCopy.channelTypeKey, channelTypeKey1, "channelTypeKey failed #1"
    
    'Act:
    Set itemCopy = testItemSet.getItemCopy(2)
    
    'Assert:
    Assert.AreEqual itemCopy.length, length2, "length failed #2"
    Assert.AreEqual itemCopy.tolerance, tolerance2, "tolerance failed #2"
    Assert.AreEqual itemCopy.deviatingMinimumRemainingWebWidth, deviatingMinimumRemainingWebWidth2, "deviatingMinimumRemainingWebWidth failed #2"
    Assert.AreEqual itemCopy.deviatingMinimumRemainingWebWidthSet, deviatingMinimumRemainingWebWidthSet2, "deviatingMinimumRemainingWebWidthSet failed #2"
    Assert.AreEqual itemCopy.quantity, quantity2, "quantity failed #2"
    Assert.AreEqual itemCopy.cuttingType, cuttingType2, "cuttingType failed #2"
    Assert.AreEqual itemCopy.channelTypeKey, channelTypeKey2, "channelTypeKey failed #2"
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_sortByLength()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testItemSet As CItemSet
    Set testItemSet = New CItemSet
    
    Dim testItem1 As CItem
    Dim testItem2 As CItem
    Dim testItem3 As CItem
    Dim testItem4 As CItem
    Dim testItem5 As CItem
    
    Dim outItem1 As CItem
    Dim outItem2 As CItem
    Dim outItem3 As CItem
    Dim outItem4 As CItem
    Dim outItem5 As CItem
    
    Set testItem1 = New CItem
    Set testItem2 = New CItem
    Set testItem3 = New CItem
    Set testItem4 = New CItem
    Set testItem5 = New CItem
    
    ' Testvalues
    Dim length1 As Long
    Dim length2 As Long
    Dim length3 As Long
    Dim length4 As Long
    Dim length5 As Long

    ' Values (correct sorting according to name, ascending)
    length1 = 8000
    length2 = 9000
    length3 = 10000
    length4 = 11000
    length5 = 12500
    
    ' Set lengths
    testItem1.setValues length1, 0, 0, False, 1, enumCuttingType.A, "MQ"
    testItem2.setValues length2, 0, 0, False, 1, enumCuttingType.A, "MQ"
    testItem3.setValues length3, 0, 0, False, 1, enumCuttingType.A, "MQ"
    testItem4.setValues length4, 0, 0, False, 1, enumCuttingType.A, "MQ"
    testItem5.setValues length5, 0, 0, False, 1, enumCuttingType.A, "MQ"

    ' Add items in unsorted order
    testItemSet.addItem testItem4
    testItemSet.addItem testItem1
    testItemSet.addItem testItem5
    testItemSet.addItem testItem3
    testItemSet.addItem testItem2
    
    Set outItem1 = testItemSet.getItemCopy(1)
    
    'Act:
    testItemSet.sortByLength descending:=False
    
    ' Read out items:
    Set outItem1 = testItemSet.getItemCopy(1)
    Set outItem2 = testItemSet.getItemCopy(2)
    Set outItem3 = testItemSet.getItemCopy(3)
    Set outItem4 = testItemSet.getItemCopy(4)
    Set outItem5 = testItemSet.getItemCopy(5)
    
    'Assert:
    ' Supposed to be increasing
    Assert.AreEqual outItem1.length, length1, "outItem1 failed #1"
    Assert.AreEqual outItem2.length, length2, "outItem2 failed #2"
    Assert.AreEqual outItem3.length, length3, "outItem3 failed #3"
    Assert.AreEqual outItem4.length, length4, "outItem4 failed #4"
    Assert.AreEqual outItem5.length, length5, "outItem5 failed #5"
    
    'Act:
    ' Re-sort values descending
    testItemSet.sortByLength descending:=True
    
    ' Read out items:
    Set outItem1 = testItemSet.getItemCopy(1)
    Set outItem2 = testItemSet.getItemCopy(2)
    Set outItem3 = testItemSet.getItemCopy(3)
    Set outItem4 = testItemSet.getItemCopy(4)
    Set outItem5 = testItemSet.getItemCopy(5)
    
    'Assert:
    ' Supposed to be decreasing
    Assert.AreEqual outItem1.length, length5, "outItem1 failed #2"
    Assert.AreEqual outItem2.length, length4, "outItem2 failed #2"
    Assert.AreEqual outItem3.length, length3, "outItem3 failed #2"
    Assert.AreEqual outItem4.length, length2, "outItem4 failed #2"
    Assert.AreEqual outItem5.length, length1, "outItem5 failed #2"
    
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


#End If

Attribute VB_Name = "TestCLongArray"
Option Explicit

Option Private Module

'@TestModule
'@Folder("Tests")

Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@TestMethod
Public Sub Test_getCopy()
    On Error GoTo TestFail
        
    Dim testArray As CLongArray
    Dim testArrayCopy As CLongArray
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long

    'Arrange:
    Set testArray = New CLongArray
    
    val1 = 10
    val2 = 30
    val3 = 15
    
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    
    Set testArrayCopy = testArray.getCopy

    ' Make sure we don't just have references to the same object
    Assert.AreNotSame testArray, testArrayCopy, "Object separation failed, objects are the same."
    
    Assert.AreEqual val1, testArrayCopy.element(1), "value failed #1"
    Assert.AreEqual val2, testArrayCopy.element(2), "value failed #2"
    Assert.AreEqual val3, testArrayCopy.element(3), "value failed #3"
    Assert.AreEqual testArray.count, testArrayCopy.count, "not same length as the original"

    ' New values
    val1 = 20
    val2 = 17
    val3 = 44
    
    testArrayCopy.setElement val1, 1
    testArrayCopy.setElement val2, 2
    testArrayCopy.setElement val3, 3

    Assert.AreEqual val1, testArrayCopy.element(1), "new value failed #1"
    Assert.AreEqual val2, testArrayCopy.element(2), "new value failed #2"
    Assert.AreEqual val3, testArrayCopy.element(3), "new value failed #3"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod("Trivial")
Public Sub Test_GettersLetters()
    On Error GoTo TestFail
        
    Dim testArray As CLongArray
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    Dim newValue As Long
    Dim oldValue As Long
    Dim expectedElementCount As Long

    'Arrange:
    Set testArray = New CLongArray
    
    val1 = 10
    val2 = 30
    val3 = 15
    
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    expectedElementCount = 3
    
    'Assert:
    Assert.AreEqual val1, testArray.element(1), "value failed #1"
    Assert.AreEqual val2, testArray.element(2), "value failed #2"
    Assert.AreEqual val3, testArray.element(3), "value failed #3"
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"

    ' New values
    val1 = 20
    val2 = 17
    val3 = 44
    
    testArray.setElement val1, 1
    testArray.setElement val2, 2
    testArray.setElement val3, 3
    
    Assert.AreEqual val1, testArray.element(1), "new value failed #1"
    Assert.AreEqual val2, testArray.element(2), "new value failed #2"
    Assert.AreEqual val3, testArray.element(3), "new value failed #3"
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"

    ' Make sure we are assigning values and not references
    oldValue = 10
    newValue = 20
    
    val1 = oldValue
    testArray.setElement val1, 1
    val1 = newValue
    
    Assert.AreEqual oldValue, testArray.element(1), "value changed after assignment due to reference"
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_zero()
    On Error GoTo TestFail
        
    Dim testArray As CLongArray
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    Dim zero As Long
    zero = 0

    ' Initial length = 0:
    Set testArray = New CLongArray
    
    ' Add 3 elements
    val1 = 20
    val2 = 17
    val3 = 44
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3

    testArray.zero

    Assert.AreEqual zero, testArray.element(1), "not set to zero #1"
    Assert.AreEqual zero, testArray.element(2), "not set to zero #2"
    Assert.AreEqual zero, testArray.element(3), "not set to zero #3"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_count()
    On Error GoTo TestFail
        
    Dim testArray As CLongArray
    Dim expectedElementCount As Long

    Set testArray = New CLongArray
    expectedElementCount = 0
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"
    
    ' Add 3 elements, length = 3:
    testArray.addElement 10
    testArray.addElement 30
    testArray.addElement 15
    expectedElementCount = 3
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"

    ' Make all elements zero, length = 3 (still!)
    testArray.zero
    expectedElementCount = 3
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"

    ' Set number of elements to 2 (lower), length = 2
    testArray.count = 2
    expectedElementCount = 2
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"

    ' Set number of elements to 4 (higher), length = 4
    testArray.count = 4
    expectedElementCount = 4
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_setElement()
    On Error GoTo TestFail
        
    Dim testArray As CLongArray
    Dim val As Long
    Dim newVal As Long
    
    val = 10
    newVal = 30
    
    Set testArray = New CLongArray
    
    ' Add 1 element and set it to a new value
    testArray.addElement val
    testArray.setElement newVal, 1
    Assert.AreEqual newVal, testArray.element(1), "setElement failed"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_addElement()
    On Error GoTo TestFail
    
    Dim testArray As CLongArray
    Dim val As Long
    Dim expectedElementCount As Long

    Set testArray = New CLongArray
    expectedElementCount = 0
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"
    
    val = 10
        
    ' Add 1 element and set it to a new value
    testArray.addElement val
    Assert.AreEqual val, testArray.element(1), "addElement failed, wrong value"
    expectedElementCount = 1
    Assert.AreEqual expectedElementCount, testArray.count, "addElement failed, wrong length"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_getString()
    On Error GoTo TestFail
        
    Dim testArray As CLongArray
    Dim expectedString As String

    Set testArray = New CLongArray
    expectedString = vbNullString
    Assert.AreEqual expectedString, testArray.getString, "string failed"
        
    testArray.addElement 10
    testArray.addElement 40
    testArray.addElement 80
    expectedString = "10,40,80"
    Assert.AreEqual expectedString, testArray.getString, "string failed, multiple numbers"

    testArray.zero
    expectedString = "0,0,0"
    Assert.AreEqual expectedString, testArray.getString, "string failed, after zero"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_addArray()
    On Error GoTo TestFail
        
    Dim testArray As CLongArray
    Dim endArray As CLongArray
    Dim expectedLength As Long
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    '@Ignore UseMeaningfulName
    Dim val4 As Long
    
    val1 = 15
    val2 = 11
    val3 = 1000
    val4 = 1
    
    ' With empty testArray and empty addArray
    Set testArray = New CLongArray
    Set endArray = New CLongArray
    testArray.addArray endArray
    expectedLength = 0
    Assert.AreEqual expectedLength, testArray.count, "wrong length, empty+empty"

    ' With empty testArray and non-empty addArray
    Set testArray = New CLongArray
    Set endArray = New CLongArray
    endArray.addElement val1
    endArray.addElement val2
    testArray.addArray endArray
    expectedLength = 2
    Assert.AreEqual expectedLength, testArray.count, "wrong length, 2+empty"
    Assert.AreEqual val1, testArray.element(1), "wrong value #1"
    Assert.AreEqual val2, testArray.element(2), "wrong value #2"

    ' With non-empty testArray and empty addArray
    Set testArray = New CLongArray
    Set endArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addArray endArray
    expectedLength = 2
    Assert.AreEqual expectedLength, testArray.count, "wrong length, empty+2"
    Assert.AreEqual val1, testArray.element(1), "wrong value #1"
    Assert.AreEqual val2, testArray.element(2), "wrong value #2"
    
    ' With non-empty testArray and non-empty addArray
    Set testArray = New CLongArray
    Set endArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    endArray.addElement val3
    endArray.addElement val4
    testArray.addArray endArray
    expectedLength = 4
    Assert.AreEqual expectedLength, testArray.count, "wrong length, 2+2"
    Assert.AreEqual val1, testArray.element(1), "wrong value #1"
    Assert.AreEqual val2, testArray.element(2), "wrong value #2"
    Assert.AreEqual val3, testArray.element(3), "wrong value #3"
    Assert.AreEqual val4, testArray.element(4), "wrong value #4"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_equals()
    On Error GoTo TestFail
    
    Dim testArray As CLongArray
    Dim equalArray As CLongArray
    Dim differentArray As CLongArray
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    '@Ignore UseMeaningfulName
    Dim val4 As Long
    
    val1 = 11
    val2 = 8
    val3 = 9
    val4 = 5

    ' Copied array should be equal
    Set testArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    Set equalArray = testArray.getCopy
    Assert.isTrue testArray.equals(equalArray), "getCopy should be equal"

    ' Two arrays manually set up the same should be equal
    Set testArray = New CLongArray
    Set equalArray = testArray.getCopy
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    equalArray.addElement val1
    equalArray.addElement val2
    equalArray.addElement val3
    equalArray.addElement val4
    Assert.isTrue testArray.equals(equalArray), "manually, should be equal"
    
    ' Adding one element to equalArray should make it not equal anymore
    Set testArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    Set differentArray = testArray.getCopy
    differentArray.addElement 20
    Assert.isFalse testArray.equals(differentArray), "added element, should not be equal"

    ' Changing one value should make it not equal anymore
    Set testArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    Set differentArray = testArray.getCopy
    differentArray.setElement 20, 2
    Assert.isFalse testArray.equals(differentArray), "changed element, should not be equal"

    ' Two different array should not be equal
    Set testArray = New CLongArray
    Set equalArray = testArray.getCopy
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    equalArray.addElement val1
    equalArray.addElement val2
    equalArray.addElement val3
    equalArray.addElement val4
    Assert.isTrue testArray.equals(equalArray), "manually, should be equal"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_removeAt()
    On Error GoTo TestFail
    
    Dim testArray As CLongArray
    Dim expectedLength As Long
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    '@Ignore UseMeaningfulName
    Dim val4 As Long
    
    val1 = 11
    val2 = 8
    val3 = 9
    val4 = 5

    ' Remove one
    Set testArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    testArray.removeAt 2
    expectedLength = 3
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"
    Assert.AreEqual val3, testArray.element(2), "not equal #2"
    Assert.AreEqual val4, testArray.element(3), "not equal #3"

    ' Remove all from the beginning
    Set testArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    testArray.removeAt 1
    testArray.removeAt 1
    testArray.removeAt 1
    testArray.removeAt 1
    expectedLength = 0
    Assert.AreEqual expectedLength, testArray.count, "wrong length"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod("Trivial")
Public Sub Test_swap()
    On Error GoTo TestFail
    
    Dim testArray As CLongArray
    Dim expectedLength As Long
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    '@Ignore UseMeaningfulName
    Dim val4 As Long
    
    val1 = 11
    val2 = 8
    val3 = 9
    val4 = 5

    ' Swap i=1 & 2
    Set testArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    testArray.swap 1, 2
    expectedLength = 4
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val2, testArray.element(1), "not equal #1"
    Assert.AreEqual val1, testArray.element(2), "not equal #2"
    Assert.AreEqual val3, testArray.element(3), "not equal #3"
    Assert.AreEqual val4, testArray.element(4), "not equal #4"

    ' Swap i=1 & 4
    Set testArray = New CLongArray
    testArray.addElement val1
    testArray.addElement val2
    testArray.addElement val3
    testArray.addElement val4
    testArray.swap 1, 4
    expectedLength = 4
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val4, testArray.element(1), "not equal #1"
    Assert.AreEqual val2, testArray.element(2), "not equal #2"
    Assert.AreEqual val3, testArray.element(3), "not equal #3"
    Assert.AreEqual val1, testArray.element(4), "not equal #4"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_subArray()
    On Error GoTo TestFail
    
    Dim originalArray As CLongArray
    Dim testArray As CLongArray
    Dim expectedLength As Long
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    '@Ignore UseMeaningfulName
    Dim val4 As Long
    
    val1 = 11
    val2 = 8
    val3 = 9
    val4 = 5

    Set originalArray = New CLongArray
    originalArray.addElement val1
    originalArray.addElement val2
    originalArray.addElement val3
    originalArray.addElement val4

    ' Cut 2,3
    Set testArray = originalArray.subArray(2, 2)
    expectedLength = 2
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val2, testArray.element(1), "not equal #1"
    Assert.AreEqual val3, testArray.element(2), "not equal #2"

    ' Cut 1,4
    Set testArray = originalArray.subArray(1, 4)
    expectedLength = 4
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"
    Assert.AreEqual val2, testArray.element(2), "not equal #2"
    Assert.AreEqual val3, testArray.element(3), "not equal #3"
    Assert.AreEqual val4, testArray.element(4), "not equal #4"

    ' Cut 3,4
    Set testArray = originalArray.subArray(3, 2)
    expectedLength = 2
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val3, testArray.element(1), "not equal #1"
    Assert.AreEqual val4, testArray.element(2), "not equal #2"

    ' Cut 4,4
    Set testArray = originalArray.subArray(4, 1)
    expectedLength = 1
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val4, testArray.element(1), "not equal #1"

    ' Cut 1,1
    Set testArray = originalArray.subArray(1, 1)
    expectedLength = 1
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_subArrayRight()
    On Error GoTo TestFail
    
    Dim originalArray As CLongArray
    Dim testArray As CLongArray
    Dim expectedLength As Long
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    '@Ignore UseMeaningfulName
    Dim val4 As Long
    
    val1 = 11
    val2 = 8
    val3 = 9
    val4 = 5

    Set originalArray = New CLongArray
    originalArray.addElement val1
    originalArray.addElement val2
    originalArray.addElement val3
    originalArray.addElement val4

    ' Cut 0
    Set testArray = originalArray.subArrayRight(0)
    expectedLength = 0
    Assert.AreEqual expectedLength, testArray.count, "wrong length"

    ' Cut 1
    Set testArray = originalArray.subArrayRight(1)
    expectedLength = 1
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val4, testArray.element(1), "not equal #1"

    ' Cut 2
    Set testArray = originalArray.subArrayRight(2)
    expectedLength = 2
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val3, testArray.element(1), "not equal #1"
    Assert.AreEqual val4, testArray.element(2), "not equal #2"

    ' Cut 3
    Set testArray = originalArray.subArrayRight(3)
    expectedLength = 3
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val2, testArray.element(1), "not equal #1"
    Assert.AreEqual val3, testArray.element(2), "not equal #2"
    Assert.AreEqual val4, testArray.element(3), "not equal #3"

    ' Cut 4
    Set testArray = originalArray.subArrayRight(4)
    expectedLength = 4
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"
    Assert.AreEqual val2, testArray.element(2), "not equal #2"
    Assert.AreEqual val3, testArray.element(3), "not equal #3"
    Assert.AreEqual val4, testArray.element(4), "not equal #4"


'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_subArrayLeft()
    On Error GoTo TestFail
    
    Dim originalArray As CLongArray
    Dim testArray As CLongArray
    Dim expectedLength As Long
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    '@Ignore UseMeaningfulName
    Dim val4 As Long
    
    val1 = 11
    val2 = 8
    val3 = 9
    val4 = 5

    Set originalArray = New CLongArray
    originalArray.addElement val1
    originalArray.addElement val2
    originalArray.addElement val3
    originalArray.addElement val4

    ' Cut 0
    Set testArray = originalArray.subArrayLeft(0)
    expectedLength = 0
    Assert.AreEqual expectedLength, testArray.count, "wrong length"

    ' Cut 1
    Set testArray = originalArray.subArrayLeft(1)
    expectedLength = 1
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"

    ' Cut 2
    Set testArray = originalArray.subArrayLeft(2)
    expectedLength = 2
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"
    Assert.AreEqual val2, testArray.element(2), "not equal #2"

    ' Cut 3
    Set testArray = originalArray.subArrayLeft(3)
    expectedLength = 3
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"
    Assert.AreEqual val2, testArray.element(2), "not equal #2"
    Assert.AreEqual val3, testArray.element(3), "not equal #3"

    ' Cut 4
    Set testArray = originalArray.subArrayLeft(4)
    expectedLength = 4
    Assert.AreEqual expectedLength, testArray.count, "wrong length"
    Assert.AreEqual val1, testArray.element(1), "not equal #1"
    Assert.AreEqual val2, testArray.element(2), "not equal #2"
    Assert.AreEqual val3, testArray.element(3), "not equal #3"
    Assert.AreEqual val4, testArray.element(4), "not equal #4"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub
Attribute VB_Name = "TestCLongArrayArray"
Option Explicit

Option Private Module

'@TestModule
'@Folder("Tests")

Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub

'@TestMethod
Public Sub Test_addElement()
    On Error GoTo TestFail
    
    Dim testArray As CLongArrayArray
    Dim firstArray As CLongArray
    '@Ignore UseMeaningfulName
    Dim val1 As Long
    '@Ignore UseMeaningfulName
    Dim val2 As Long
    '@Ignore UseMeaningfulName
    Dim val3 As Long
    Dim expectedElementCount As Long

    val1 = 15
    val2 = 41
    val3 = 10

    Set testArray = New CLongArrayArray
    Set firstArray = New CLongArray
    
    ' Make sure it is zero before we begin
    expectedElementCount = 0
    Assert.AreEqual expectedElementCount, testArray.count, "wrong length"
    
    ' Add one and make sure it works
    firstArray.addElement val1
    firstArray.addElement val2
    firstArray.addElement val3
    
    testArray.addElement firstArray
    
    Assert.AreEqual val1, testArray.element(1).element(1), "wrong value #1"
    Assert.AreEqual val2, testArray.element(1).element(2), "wrong value #2"
    Assert.AreEqual val3, testArray.element(1).element(3), "wrong value #3"

    ' Make sure it was set as value and not as reference
    ' Remove one from the array we added and make sure the count on the ArrayArray does not change
    firstArray.removeAt 1
    expectedElementCount = 3
    Assert.AreEqual expectedElementCount, testArray.element(1).count, "wrong length - variable was set as a reference"
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub
Attribute VB_Name = "TestCPiece"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub

'@TestMethod("Trivial")
Public Sub Test_setValues()
    On Error GoTo TestFail

    'Arrange:
    Dim testPiece As CPiece
    Set testPiece = New CPiece
    
    ' Testvalues
    Dim channelTypeKey As String
    Dim hprPlacement As enumHPRPlacement
    Dim cuttingType As enumCuttingType
    Dim pieceType As enumPieceType
    Dim length As Long
    Dim placed As Boolean
    Dim usedTolerance As Long
    Dim allowedTolerance As Long
    
    ' Values
    channelTypeKey = "MQ-41"
    hprPlacement = enumHPRPlacement.rightSide
    cuttingType = enumCuttingType.C1
    pieceType = enumPieceType.normal
    length = 2000
    placed = True
    usedTolerance = 1
    allowedTolerance = 30
    
    'Act:
    testPiece.setValues channelTypeKey, hprPlacement, cuttingType, pieceType, length, placed, usedTolerance, allowedTolerance

    'Assert:
    Assert.AreEqual testPiece.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"
    Assert.AreEqual testPiece.hprPlacement, hprPlacement, "hprPlacement failed #1"
    Assert.AreEqual testPiece.cuttingType, cuttingType, "cuttingType failed #1"
    Assert.AreEqual testPiece.pieceType, pieceType, "pieceType failed #1"
    Assert.AreEqual testPiece.length, length, "length failed #1"
    Assert.AreEqual testPiece.placed, placed, "placed failed #1"
    Assert.AreEqual testPiece.usedTolerance, usedTolerance, "usedTolerance failed #1"
    Assert.AreEqual testPiece.allowedTolerance, allowedTolerance, "allowedTolerance failed #1"

    ' New values
    channelTypeKey = "MQ-21"
    hprPlacement = enumHPRPlacement.bothSides
    cuttingType = enumCuttingType.B1
    pieceType = enumPieceType.waste
    length = 3000
    placed = False
    usedTolerance = 2
    allowedTolerance = 20
    
    'Act:
    testPiece.setValues channelTypeKey, hprPlacement, cuttingType, pieceType, length, placed, usedTolerance, allowedTolerance

    'Assert:
    Assert.AreEqual testPiece.channelTypeKey, channelTypeKey, "channelTypeKey failed #2"
    Assert.AreEqual testPiece.hprPlacement, hprPlacement, "hprPlacement failed #2"
    Assert.AreEqual testPiece.cuttingType, cuttingType, "cuttingType failed #2"
    Assert.AreEqual testPiece.pieceType, pieceType, "pieceType failed #2"
    Assert.AreEqual testPiece.length, length, "length failed #2"
    Assert.AreEqual testPiece.placed, placed, "placed failed #2"
    Assert.AreEqual testPiece.usedTolerance, usedTolerance, "usedTolerance failed #2"
    Assert.AreEqual testPiece.allowedTolerance, allowedTolerance, "allowedTolerance failed #2"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub



'@TestMethod
Public Sub Test_Letters()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testPiece As CPiece
    Set testPiece = New CPiece
    
    ' Dummy values
    Dim length As Long
    Dim usedTolerance As Long
    Dim placed As Boolean
    Dim hprPlacement As enumHPRPlacement
    Dim pieceType As enumPieceType
    
    ' Values:
    length = 2000
    usedTolerance = 1
    placed = True
    hprPlacement = enumHPRPlacement.rightSide
    pieceType = enumPieceType.normal

    'Act:
    testPiece.length = length
    testPiece.usedTolerance = usedTolerance
    testPiece.placed = placed
    testPiece.hprPlacement = hprPlacement
    testPiece.pieceType = pieceType

    'Assert:
    Assert.AreEqual testPiece.length, length, "length failed #1"
    Assert.AreEqual testPiece.usedTolerance, usedTolerance, "usedTolerance failed #1"
    Assert.AreEqual testPiece.placed, placed, "placed failed #1"
    Assert.AreEqual testPiece.hprPlacement, hprPlacement, "hprPlacement failed #1"
    Assert.AreEqual testPiece.pieceType, pieceType, "pieceType failed #1"
    
    
    ' New Values:
    length = 1000
    usedTolerance = 2
    placed = False
    hprPlacement = enumHPRPlacement.notSet
    pieceType = enumPieceType.waste

    'Act:
    testPiece.length = length
    testPiece.usedTolerance = usedTolerance
    testPiece.placed = placed
    testPiece.hprPlacement = hprPlacement
    testPiece.pieceType = pieceType

    'Assert:
    Assert.AreEqual testPiece.length, length, "length failed #2"
    Assert.AreEqual testPiece.usedTolerance, usedTolerance, "usedTolerance failed #2"
    Assert.AreEqual testPiece.placed, placed, "placed failed #2"
    Assert.AreEqual testPiece.hprPlacement, hprPlacement, "hprPlacement failed #2"
    Assert.AreEqual testPiece.pieceType, pieceType, "pieceType failed #2"
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub




'@TestMethod
Public Sub Test_hasSameFundamentals()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testPiece As CPiece
    Set testPiece = New CPiece
    
    Dim testPiece_sameFundamentals As CPiece
    Set testPiece_sameFundamentals = New CPiece
    
    Dim testPiece_notSameFundamentals As CPiece
    Set testPiece_notSameFundamentals = New CPiece
        
    ' Testvalues
    Dim fundamental_length As Long
    Dim fundamental_hprPlacement As enumHPRPlacement
    Dim fundamental_cuttingType As enumCuttingType
    Dim fundamental_pieceType As enumPieceType
    Dim fundamental_allowedTolerance As Long
    Dim fundamental_usedTolerance As Long
    Dim fundamental_channelTypeKey As String
    Dim notFundamental_placed As Boolean
    
    Dim fundamental_length_diff As Long
    Dim fundamental_hprPlacement_diff As enumHPRPlacement
    Dim fundamental_cuttingType_diff As enumCuttingType
    Dim fundamental_pieceType_diff As enumPieceType
    Dim fundamental_allowedTolerance_diff As Long
    Dim fundamental_usedTolerance_diff As Long
    Dim fundamental_channelTypeKey_diff As String
    Dim notFundamental_placed_diff As Boolean
    
    
    ' Values
    fundamental_length = 2000
    fundamental_hprPlacement = enumHPRPlacement.rightSide
    fundamental_cuttingType = enumCuttingType.C1
    fundamental_pieceType = enumPieceType.normal
    fundamental_allowedTolerance = 30
    fundamental_usedTolerance = 1
    fundamental_channelTypeKey = "MQ-41"
    notFundamental_placed = True
    
    fundamental_length_diff = 1000
    fundamental_hprPlacement_diff = enumHPRPlacement.bothSides
    fundamental_cuttingType_diff = enumCuttingType.B1
    fundamental_pieceType_diff = enumPieceType.waste
    fundamental_allowedTolerance_diff = 10
    fundamental_usedTolerance_diff = 10
    fundamental_channelTypeKey_diff = "MQ-21"
    notFundamental_placed_diff = False
    
    
    'Act:
    testPiece.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement, _
        fundamental_cuttingType, _
        fundamental_pieceType, _
        fundamental_length, _
        notFundamental_placed, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance

    ' Setting placed to a differing value should still pass
    testPiece_sameFundamentals.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement, _
        fundamental_cuttingType, _
        fundamental_pieceType, _
        fundamental_length, _
        notFundamental_placed_diff, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance

    'Assert:
    Assert.isTrue testPiece.hasSameFundamentals(testPiece_sameFundamentals), "Failed"
    
    
    ' Make sure all diffs are discovered
    testPiece_notSameFundamentals.setValues _
        fundamental_channelTypeKey_diff, _
        fundamental_hprPlacement, _
        fundamental_cuttingType, _
        fundamental_pieceType, _
        fundamental_length, _
        notFundamental_placed, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance
    Assert.isFalse testPiece.hasSameFundamentals(testPiece_notSameFundamentals), "Failed to find differing channelTypeKey"
    
    testPiece_notSameFundamentals.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement_diff, _
        fundamental_cuttingType, _
        fundamental_pieceType, _
        fundamental_length, _
        notFundamental_placed, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance
    Assert.isFalse testPiece.hasSameFundamentals(testPiece_notSameFundamentals), "Failed to find differing hprPlacement"

    testPiece_notSameFundamentals.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement, _
        fundamental_cuttingType_diff, _
        fundamental_pieceType, _
        fundamental_length, _
        notFundamental_placed, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance
    Assert.isFalse testPiece.hasSameFundamentals(testPiece_notSameFundamentals), "Failed to find differing cuttingType"
    
    testPiece_notSameFundamentals.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement, _
        fundamental_cuttingType, _
        fundamental_pieceType_diff, _
        fundamental_length, _
        notFundamental_placed, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance
    Assert.isFalse testPiece.hasSameFundamentals(testPiece_notSameFundamentals), "Failed to find differing pieceType"

    testPiece_notSameFundamentals.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement, _
        fundamental_cuttingType, _
        fundamental_pieceType, _
        fundamental_length_diff, _
        notFundamental_placed, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance
    Assert.isFalse testPiece.hasSameFundamentals(testPiece_notSameFundamentals), "Failed to find differing length"

    testPiece_notSameFundamentals.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement, _
        fundamental_cuttingType, _
        fundamental_pieceType, _
        fundamental_length, _
        notFundamental_placed, _
        fundamental_usedTolerance_diff, _
        fundamental_allowedTolerance
    Assert.isFalse testPiece.hasSameFundamentals(testPiece_notSameFundamentals), "Failed to find differing usedTolerance"

    testPiece_notSameFundamentals.setValues _
        fundamental_channelTypeKey, _
        fundamental_hprPlacement, _
        fundamental_cuttingType, _
        fundamental_pieceType, _
        fundamental_length, _
        notFundamental_placed, _
        fundamental_usedTolerance, _
        fundamental_allowedTolerance_diff
    Assert.isFalse testPiece.hasSameFundamentals(testPiece_notSameFundamentals), "Failed to find differing allowedTolerance"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub




'@TestMethod
Public Sub Test_allowedToleranceRoundedDown()
    On Error GoTo TestFail
    
    ' This function is supposed to return allowed tolerance rounded down to the nearest 10
    
    ' -30 to -21 should return -30
    ' -20 to -11 should return -20
    ' -10 to  -1 should return -10
    '   0 to   9 should return   0
    '  10 to  19 should return  10
    '  20 to  29 should return  20
    '  30 to  39 should return  30
    ' ...
    
    ' We'll test it by a loop running from -1000 to +1000
   
    
    'Arrange:
    Dim testPiece As CPiece
    Set testPiece = New CPiece
    
    Dim i As Long
    Dim expected As Long
    
    ' Has to start on a number divisible by 10
    Const LOOP_START As Long = -1000
    Const LOOP_END As Long = 1000

    expected = LOOP_START - 10 ' Actually first expected is LOOP_START, but it will be changed the first run of the loop


    'Act/Assert:
    For i = LOOP_START To LOOP_END
        
        ' Find the thresholds where the expected value changes
        If i Mod 10 = 0 Then
            expected = expected + 10
        End If
        
        testPiece.setValues vbNullString, enumHPRPlacement.noSide, enumCuttingType.A, enumPieceType.cut, 0, False, 0, i
        Assert.AreEqual expected, testPiece.allowedToleranceRoundedDown, "failed"
    Next

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub



'@TestMethod
Public Sub Test_getCopy()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testPiece As CPiece
    Set testPiece = New CPiece
    
    Dim pieceCopy As CPiece
        
    ' Testvalues
    Dim channelTypeKey As String
    Dim hprPlacement As enumHPRPlacement
    Dim cuttingType As enumCuttingType
    Dim pieceType As enumPieceType
    Dim length As Long
    Dim placed As Boolean
    Dim usedTolerance As Long
    Dim allowedTolerance As Long
    
    ' Values
    channelTypeKey = "MQ-41"
    hprPlacement = enumHPRPlacement.rightSide
    cuttingType = enumCuttingType.C1
    pieceType = enumPieceType.normal
    length = 2000
    placed = True
    usedTolerance = 1
    allowedTolerance = 30
    
    
    ' Set values of testPiece
    ' Create a copy and verify that the new object has the same properties as the old
    
    'Act:
    testPiece.setValues channelTypeKey, hprPlacement, cuttingType, pieceType, length, placed, usedTolerance, allowedTolerance
    Set pieceCopy = testPiece.getCopy

    ' Make sure we don't just have references to the same object
    Assert.AreNotSame pieceCopy, testPiece, "Object separation failed, objects are the same."

    'Assert:
    Assert.AreEqual pieceCopy.channelTypeKey, channelTypeKey, "channelTypeKey failed #1"
    Assert.AreEqual pieceCopy.hprPlacement, hprPlacement, "hprPlacement failed #1"
    Assert.AreEqual pieceCopy.cuttingType, cuttingType, "cuttingType failed #1"
    Assert.AreEqual pieceCopy.pieceType, pieceType, "pieceType failed #1"
    Assert.AreEqual pieceCopy.length, length, "length failed #1"
    Assert.AreEqual pieceCopy.placed, placed, "placed failed #1"
    Assert.AreEqual pieceCopy.usedTolerance, usedTolerance, "usedTolerance failed #1"
    Assert.AreEqual pieceCopy.allowedTolerance, allowedTolerance, "allowedTolerance failed #1"

    ' New values
    channelTypeKey = "MQ-21"
    hprPlacement = enumHPRPlacement.bothSides
    cuttingType = enumCuttingType.B1
    pieceType = enumPieceType.waste
    length = 3000
    placed = False
    usedTolerance = 2
    allowedTolerance = 20
    
    ' Change values of the original.
    ' The copy should not change.
    
    'Act:
    testPiece.setValues channelTypeKey, hprPlacement, cuttingType, pieceType, length, placed, usedTolerance, allowedTolerance

    'Assert:
    Assert.AreNotEqual pieceCopy.channelTypeKey, channelTypeKey, "channelTypeKey failed #2"
    Assert.AreNotEqual pieceCopy.hprPlacement, hprPlacement, "hprPlacement failed #2"
    Assert.AreNotEqual pieceCopy.cuttingType, cuttingType, "cuttingType failed #2"
    Assert.AreNotEqual pieceCopy.pieceType, pieceType, "pieceType failed #2"
    Assert.AreNotEqual pieceCopy.length, length, "length failed #2"
    Assert.AreNotEqual pieceCopy.placed, placed, "placed failed #2"
    Assert.AreNotEqual pieceCopy.usedTolerance, usedTolerance, "usedTolerance failed #2"
    Assert.AreNotEqual pieceCopy.allowedTolerance, allowedTolerance, "allowedTolerance failed #2"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub




'@TestMethod("Trivial")
Public Sub Test_isEqualTo()
    On Error GoTo TestFail
    
    'Arrange:
    Dim testPiece As CPiece
    Set testPiece = New CPiece
    
    Dim testPiece_same As CPiece
    Set testPiece_same = New CPiece
    
    Dim testPiece_notSame As CPiece
    Set testPiece_notSame = New CPiece
        
    ' Testvalues
    Dim length As Long
    Dim hprPlacement As enumHPRPlacement
    Dim cuttingType As enumCuttingType
    Dim pieceType As enumPieceType
    Dim allowedTolerance As Long
    Dim usedTolerance As Long
    Dim channelTypeKey As String
    Dim placed As Boolean
    
    Dim length_diff As Long
    Dim hprPlacement_diff As enumHPRPlacement
    Dim cuttingType_diff As enumCuttingType
    Dim pieceType_diff As enumPieceType
    Dim allowedTolerance_diff As Long
    Dim usedTolerance_diff As Long
    Dim channelTypeKey_diff As String
    Dim placed_diff As Boolean
    
    
    ' Values
    length = 2000
    hprPlacement = enumHPRPlacement.rightSide
    cuttingType = enumCuttingType.C1
    pieceType = enumPieceType.normal
    allowedTolerance = 30
    usedTolerance = 1
    channelTypeKey = "MQ-41"
    placed = True
    
    length_diff = 1000
    hprPlacement_diff = enumHPRPlacement.bothSides
    cuttingType_diff = enumCuttingType.B1
    pieceType_diff = enumPieceType.waste
    allowedTolerance_diff = 10
    usedTolerance_diff = 10
    channelTypeKey_diff = "MQ-21"
    placed_diff = False
    
    
    'Act:
    testPiece.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType, _
        pieceType, _
        length, _
        placed, _
        usedTolerance, _
        allowedTolerance

    ' Setting placed to a differing value should still pass
    testPiece_same.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType, _
        pieceType, _
        length, _
        placed, _
        usedTolerance, _
        allowedTolerance

    'Assert:
    Assert.isTrue testPiece.isEqualTo(testPiece_same), "Failed"
    
    
    ' Make sure all diffs are discovered
    testPiece_notSame.setValues _
        channelTypeKey_diff, _
        hprPlacement, _
        cuttingType, _
        pieceType, _
        length, _
        placed, _
        usedTolerance, _
        allowedTolerance
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing channelTypeKey"
    
    testPiece_notSame.setValues _
        channelTypeKey, _
        hprPlacement_diff, _
        cuttingType, _
        pieceType, _
        length, _
        placed, _
        usedTolerance, _
        allowedTolerance
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing hprPlacement"

    testPiece_notSame.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType_diff, _
        pieceType, _
        length, _
        placed, _
        usedTolerance, _
        allowedTolerance
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing cuttingType"
    
    testPiece_notSame.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType, _
        pieceType_diff, _
        length, _
        placed, _
        usedTolerance, _
        allowedTolerance
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing pieceType"

    testPiece_notSame.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType, _
        pieceType, _
        length_diff, _
        placed, _
        usedTolerance, _
        allowedTolerance
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing length"

    testPiece_notSame.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType, _
        pieceType, _
        length, _
        placed_diff, _
        usedTolerance, _
        allowedTolerance
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing placed"

    testPiece_notSame.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType, _
        pieceType, _
        length, _
        placed, _
        usedTolerance_diff, _
        allowedTolerance
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing usedTolerance"

    testPiece_notSame.setValues _
        channelTypeKey, _
        hprPlacement, _
        cuttingType, _
        pieceType, _
        length, _
        placed, _
        usedTolerance, _
        allowedTolerance_diff
    Assert.isFalse testPiece.isEqualTo(testPiece_notSame), "Failed to find differing allowedTolerance"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub

' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "TestSupportFunctionsGeneric"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@TestMethod
Public Sub Test_ceiling()
    On Error GoTo TestFail
        
    Dim testValue1 As Double
    Dim testValue2 As Double
    Dim testValue3 As Double
    Dim testValue4 As Double
    Dim testValue5 As Double
    Dim testValue6 As Double
    Dim testValue7 As Double
    Dim testValue8 As Double
    Dim testValue9 As Double
    Dim testValue10 As Double
    Dim testValue11 As Double
    Dim testValue12 As Double

    Dim testFactor1 As Long
    Dim testFactor2 As Long
    Dim testFactor3 As Long
    Dim testFactor4 As Long
    Dim testFactor5 As Long
    Dim testFactor6 As Long
    
    Dim correctCeiling1 As Long
    Dim correctCeiling2 As Long
    Dim correctCeiling3 As Long
    Dim correctCeiling4 As Long
    Dim correctCeiling5 As Long
    Dim correctCeiling6 As Long
    Dim correctCeiling7 As Long
    Dim correctCeiling8 As Long
    Dim correctCeiling9 As Long
    Dim correctCeiling10 As Long
    Dim correctCeiling11 As Long
    Dim correctCeiling12 As Long

    'Arrange:

    testValue1 = 0.1
    testValue2 = 1.9
    testValue3 = 1.5
    testValue4 = 2.9999999999
    testValue5 = 0.0000000001
    testValue6 = -1.5

    correctCeiling1 = 1
    correctCeiling2 = 2
    correctCeiling3 = 2
    correctCeiling4 = 3
    correctCeiling5 = 1
    correctCeiling6 = -1

    'Act/Assert:
    Assert.AreEqual correctCeiling1, SupportFunctionsGeneric.ceiling(testValue1), "failed on testValue1"
    Assert.AreEqual correctCeiling2, SupportFunctionsGeneric.ceiling(testValue2), "failed on testValue2"
    Assert.AreEqual correctCeiling3, SupportFunctionsGeneric.ceiling(testValue3), "failed on testValue3"
    Assert.AreEqual correctCeiling4, SupportFunctionsGeneric.ceiling(testValue4), "failed on testValue4"
    Assert.AreEqual correctCeiling5, SupportFunctionsGeneric.ceiling(testValue5), "failed on testValue5"
    Assert.AreEqual correctCeiling6, SupportFunctionsGeneric.ceiling(testValue6), "failed on testValue6"
        
    'Arrange:
    testValue7 = 78.15125
    testValue8 = 3
    testValue9 = -11
    testValue10 = -8
    testValue11 = 7.3
    testValue12 = 99.99
    
    testFactor1 = 1
    testFactor2 = 2
    testFactor3 = 10
    testFactor4 = 8
    testFactor5 = 4
    testFactor6 = 50
    
    correctCeiling7 = 79
    correctCeiling8 = 4
    correctCeiling9 = -10
    correctCeiling10 = -8
    correctCeiling11 = 8
    correctCeiling12 = 100
    
    'Act/Assert:
    Assert.AreEqual correctCeiling7, SupportFunctionsGeneric.ceiling(testValue7, testFactor1), "failed on testValue7"
    Assert.AreEqual correctCeiling8, SupportFunctionsGeneric.ceiling(testValue8, testFactor2), "failed on testValue8"
    Assert.AreEqual correctCeiling9, SupportFunctionsGeneric.ceiling(testValue9, testFactor3), "failed on testValue9"
    Assert.AreEqual correctCeiling10, SupportFunctionsGeneric.ceiling(testValue10, testFactor4), "failed on testValue10"
    Assert.AreEqual correctCeiling11, SupportFunctionsGeneric.ceiling(testValue11, testFactor5), "failed on testValue11"
    Assert.AreEqual correctCeiling12, SupportFunctionsGeneric.ceiling(testValue12, testFactor6), "failed on testValue12"
    
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_clearRow()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_letter2Column()
    On Error GoTo TestFail

    'Assert:
    Dim n As Long
    n = 1
    Assert.AreEqual n, letter2Column("A"), "A"
    n = n + 1
    Assert.AreEqual n, letter2Column("B"), "B"
    n = n + 1
    Assert.AreEqual n, letter2Column("C"), "C"
    n = n + 1
    Assert.AreEqual n, letter2Column("D"), "D"
    n = n + 1
    Assert.AreEqual n, letter2Column("E"), "E"
    n = n + 1
    Assert.AreEqual n, letter2Column("F"), "F"
    n = n + 1
    Assert.AreEqual n, letter2Column("G"), "G"
    n = n + 1
    Assert.AreEqual n, letter2Column("H"), "H"
    n = n + 1
    Assert.AreEqual n, letter2Column("I"), "I"
    n = n + 1
    Assert.AreEqual n, letter2Column("J"), "J"
    n = n + 1
    Assert.AreEqual n, letter2Column("K"), "K"
    n = n + 1
    Assert.AreEqual n, letter2Column("L"), "L"
    n = n + 1
    Assert.AreEqual n, letter2Column("M"), "M"
    n = n + 1
    Assert.AreEqual n, letter2Column("N"), "N"
    n = n + 1
    Assert.AreEqual n, letter2Column("O"), "O"
    n = n + 1
    Assert.AreEqual n, letter2Column("P"), "P"
    n = n + 1
    Assert.AreEqual n, letter2Column("Q"), "Q"
    n = n + 1
    Assert.AreEqual n, letter2Column("R"), "R"
    n = n + 1
    Assert.AreEqual n, letter2Column("S"), "S"
    n = n + 1
    Assert.AreEqual n, letter2Column("T"), "T"
    n = n + 1
    Assert.AreEqual n, letter2Column("U"), "U"
    n = n + 1
    Assert.AreEqual n, letter2Column("V"), "V"
    n = n + 1
    Assert.AreEqual n, letter2Column("W"), "W"
    n = n + 1
    Assert.AreEqual n, letter2Column("X"), "X"
    n = n + 1
    Assert.AreEqual n, letter2Column("Y"), "Y"
    n = n + 1
    Assert.AreEqual n, letter2Column("Z"), "Z"
    n = n + 1
    Assert.AreEqual n, letter2Column("AA"), "AA"
    n = n + 1
    Assert.AreEqual n, letter2Column("AB"), "AB"
    n = n + 1
    Assert.AreEqual n, letter2Column("AC"), "AC"
    n = n + 1
    Assert.AreEqual n, letter2Column("AD"), "AD"
    
    ' Test the highest possible column
    n = 16384
    Assert.AreEqual n, letter2Column("XFD"), "AD"

    ' Test higher than possible column, should return -1
    n = -1
    Assert.AreEqual n, letter2Column("XFE"), "XFE (overflow)"

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_column2Letter()
    On Error GoTo TestFail

    'Assert:
    Dim n As Long
    n = 1
    Assert.AreEqual "A", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "B", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "C", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "D", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "E", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "F", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "G", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "H", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "I", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "J", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "K", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "L", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "M", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "N", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "O", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "P", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "Q", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "R", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "S", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "T", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "U", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "V", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "W", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "X", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "Y", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "Z", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "AA", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "AB", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "AC", column2Letter(n), vbNullString & n
    n = n + 1
    Assert.AreEqual "AD", column2Letter(n), vbNullString & n
    
    ' Test the highest possible column
    n = 16384
    Assert.AreEqual "XFD", column2Letter(n), vbNullString & n

    ' Test lower than possible column, should return an empty string
    n = 0
    Assert.AreEqual vbNullString, column2Letter(n), vbNullString & n
    n = -1
    Assert.AreEqual vbNullString, column2Letter(n), vbNullString & n

    ' Test higher than possible column, should return an empty string
    n = 16385
    Assert.AreEqual vbNullString, column2Letter(n), vbNullString & n

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_column2Letter_and_letter2Column()
    On Error GoTo TestFail
    
    ' Test both letter2Column and column2Letter

    'Assert:
    Dim n As Long
    For n = 1 To 16384
        Assert.AreEqual n, letter2Column(column2Letter(n)), "failed on n=" & n
    Next

'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@TestMethod
Public Sub Test_floor()
    On Error GoTo TestFail
        
    
    Dim testValue1 As Double
    Dim testValue2 As Double
    Dim testValue3 As Double
    Dim testValue4 As Double
    Dim testValue5 As Double
    Dim testValue6 As Double
    Dim testValue7 As Double
    Dim testValue8 As Double
    Dim testValue9 As Double
    Dim testValue10 As Double
    Dim testValue11 As Double
    Dim testValue12 As Double

    Dim testFactor1 As Long
    Dim testFactor2 As Long
    Dim testFactor3 As Long
    Dim testFactor4 As Long
    Dim testFactor5 As Long
    Dim testFactor6 As Long
    
    Dim correctFloor1 As Long
    Dim correctFloor2 As Long
    Dim correctFloor3 As Long
    Dim correctFloor4 As Long
    Dim correctFloor5 As Long
    Dim correctFloor6 As Long
    Dim correctFloor7 As Long
    Dim correctFloor8 As Long
    Dim correctFloor9 As Long
    Dim correctFloor10 As Long
    Dim correctFloor11 As Long
    Dim correctFloor12 As Long

    'Arrange:
    testValue1 = 0.1
    testValue2 = 1.9
    testValue3 = 1.5
    testValue4 = 2.9999999999
    testValue5 = 0.0000000001
    testValue6 = -1.5

    correctFloor1 = 0
    correctFloor2 = 1
    correctFloor3 = 1
    correctFloor4 = 2
    correctFloor5 = 0
    correctFloor6 = -2

    'Act/Assert:
    Assert.AreEqual correctFloor1, SupportFunctionsGeneric.floor(testValue1), "failed on testValue1"
    Assert.AreEqual correctFloor2, SupportFunctionsGeneric.floor(testValue2), "failed on testValue2"
    Assert.AreEqual correctFloor3, SupportFunctionsGeneric.floor(testValue3), "failed on testValue3"
    Assert.AreEqual correctFloor4, SupportFunctionsGeneric.floor(testValue4), "failed on testValue4"
    Assert.AreEqual correctFloor5, SupportFunctionsGeneric.floor(testValue5), "failed on testValue5"
    Assert.AreEqual correctFloor6, SupportFunctionsGeneric.floor(testValue6), "failed on testValue6"
        
    'Arrange:
    testValue7 = 78.15125
    testValue8 = 3
    testValue9 = -11
    testValue10 = -8
    testValue11 = 7.3
    testValue12 = 99.99
    
    testFactor1 = 1
    testFactor2 = 2
    testFactor3 = 10
    testFactor4 = 8
    testFactor5 = 4
    testFactor6 = 50
    
    correctFloor7 = 78
    correctFloor8 = 2
    correctFloor9 = -20
    correctFloor10 = -8
    correctFloor11 = 4
    correctFloor12 = 50
    
    'Act/Assert:
    Assert.AreEqual correctFloor7, SupportFunctionsGeneric.floor(testValue7, testFactor1), "failed on testValue7"
    Assert.AreEqual correctFloor8, SupportFunctionsGeneric.floor(testValue8, testFactor2), "failed on testValue8"
    Assert.AreEqual correctFloor9, SupportFunctionsGeneric.floor(testValue9, testFactor3), "failed on testValue9"
    Assert.AreEqual correctFloor10, SupportFunctionsGeneric.floor(testValue10, testFactor4), "failed on testValue10"
    Assert.AreEqual correctFloor11, SupportFunctionsGeneric.floor(testValue11, testFactor5), "failed on testValue11"
    Assert.AreEqual correctFloor12, SupportFunctionsGeneric.floor(testValue12, testFactor6), "failed on testValue12"
    
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getRandomNumber()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getRounding10()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getRounding10abs()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_getRoundingAdj10()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_rangeAddressRepresentsColumn()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_rangeGetLong()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_rangeGetString()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_round10down()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_round10up()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_shapeExists()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "TestTemplate"
'@TestModule
'@Folder("Tests")
Option Explicit
Option Private Module

' RubberDuck conditional compilation
#If HAS_RUBBERDUCK = 1 Then


Private Assert As Object
'Private Fakes As Object

'@ModuleInitialize
Public Sub ModuleInitialize()
    'this method runs once per module.
    Set Assert = CreateObject("Rubberduck.AssertClass")
    'Set Fakes = CreateObject("Rubberduck.FakesProvider")
End Sub

'@ModuleCleanup
Public Sub ModuleCleanup()
    'this method runs once per module.
    Set Assert = Nothing
    'Set Fakes = Nothing
End Sub

'@TestInitialize
Public Sub TestInitialize()
    'this method runs before every test in the module.
End Sub

'@TestCleanup
Public Sub TestCleanup()
    'this method runs after every test in the module.
End Sub


'@IgnoreTest
'@TestMethod
Public Sub Test_method()
'#Stub
    On Error GoTo TestFail
        
    'Arrange:
    
    'Act:
    
    'Assert:
    Assert.Inconclusive
    
'@Ignore LineLabelNotUsed
TestExit:
    Exit Sub
TestFail:
    Assert.Fail "Test raised an error: #" & Err.Number & " - " & Err.Description
End Sub


' End RubberDuck conditional compilation
#End If
Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
 '@Folder("Sheets")
Option Explicit
Dim JustOpened As Boolean

Private Sub Workbook_Activate()
If JustOpened = True Then
    JustOpened = False
    Worksheets("Start").Unprotect (SheetPassword)
    Worksheets("Start").Range("A1:R100").Font.color = Worksheets("Start").Range("A1").Interior.color
    Worksheets("Start").Range("A1:R100").Interior.color = Worksheets("Start").Range("A1").Interior.color
    Worksheets("Start").Protect (SheetPassword)
    Application.ScreenUpdating = True
    frmHiltiStart.show 1
End If
End Sub

Private Sub Workbook_Open()

'The workbook is a Template 1 Type and this is not the first time this workbook is being opened.
If Worksheets(nsMain.name).Range("a1") = "1" Then
    Application.ScreenUpdating = False
    Call FirstTemplate
    Application.ScreenUpdating = True
ElseIf Worksheets(nsMain.name).Range("a1") = "2" Then 'The workbook is a Template 2 Type and this is not the first time this workbook is being opened.
    Application.ScreenUpdating = False
    Call SecondTemplate
    Application.ScreenUpdating = True
Else 'This Workbook is a new instance
    Application.ScreenUpdating = False
    Worksheets("Start").visible = xlSheetVisible
    Worksheets(nsMain.name).visible = xlSheetHidden
    Worksheets("Master List").visible = xlSheetHidden
    JustOpened = True
End If

Set goMaterials = CreateObject("Scripting.Dictionary")

Call GetMasterObjectsforPISheets(goMaterials)

End Sub

'
Attribute VB_Name = "frmHelp"
Attribute VB_Base = "0{B0AA6415-45A6-4FA7-9D45-72F7AB0F4E21}{9A0F4CBC-F00D-41D1-BCD0-86E5B516B457}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Private Sub cmdDone_Click()
Unload Me
End Sub

Private Sub UserForm_Initialize()
'Load the screen on the center of the application
Call CenterScreen(Me)
End Sub
Public Function ShowMessage(piMsgIndex As Integer)


Select Case piMsgIndex

Case 1
    lblHelp.Caption = "Please fill in columns A to I." & _
    vbCrLf & vbCrLf & "Total Qty and Relevant IFUs columns will be auto filled in the next step." & _
    vbCrLf & vbCrLf & "After entering data in colums A to I, please click the 'Main' button on the header."
Case 2


End Select

Me.show 1

End Function

Attribute VB_Name = "frmHiltiStart"
Attribute VB_Base = "0{767452D5-D22E-48AD-927C-D12CB6D69A7B}{7341C998-5C0E-4D20-B79A-3DE866B168C7}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Dim lbComboLoading As Boolean
Dim lbClose As Boolean

Private Sub UserForm_Initialize()

'Load the screen on the center of the application
Call CenterScreen(Me)

End Sub
Private Sub UserForm_Activate()

'Load the form with the proper message

Dim ls As String

imgBack.width = Me.width
imgBack.height = Me.height
imgBack.Top = 0
imgBack.Left = 0


ls = "Welcome to The Hilti QA Sheet Program!"

ls = ls & vbCrLf & vbCrLf & "Quality Assurance Sheet supports two types of templates:"

ls = ls & vbCrLf & vbCrLf & "Template 1: Starts with Individual Production and Inspection Sheet"

ls = ls & vbCrLf & vbCrLf & "Template 2: Starts with Total BOM Sheet"

ls = ls & vbCrLf & vbCrLf & "Please select the appropriate Template.  You may not be able to change this template later."

lblHelp.Caption = ls


Dim lsLang As Range
Dim ws As Worksheet
Set ws = Worksheets("Translations")
lbComboLoading = True
For Each lsLang In ws.Range("C21:K21")

  With Me.cmbLanguage
    .addItem lsLang.value
  End With
  
Next lsLang

cmbLanguage.ListIndex = 0
lbComboLoading = False
End Sub

Private Sub cmbLanguage_Change()
If lbComboLoading = True Then Exit Sub
Dim liSelectedLang As Integer

liSelectedLang = cmbLanguage.ListIndex + 1

'Execute the Translation
Call TranslateWorkbook(liSelectedLang)

cmdTotalBOM.SetFocus

End Sub

Private Sub cmdPI_Click()

On Error GoTo ErrorHandler

lbClose = True
Application.ScreenUpdating = False
'Calling first time; send parameter 1 as it has to write the template number
Call FirstTemplate(1)
ActiveWorkbook.Sheets(nsMain.name).Activate
Application.ScreenUpdating = True
Unload Me

Exit Sub
ErrorHandler:
lbClose = True
End Sub

Private Sub cmdTotalBOM_Click()

On Error GoTo ErrorHandler

lbClose = True

Application.ScreenUpdating = False

Call SecondTemplate(1)

Call TotalBOM2PISheets

ActiveWorkbook.Sheets(nsTB1.name).visible = xlSheetVisible

ActiveWorkbook.Sheets(nsTB1.name).Activate

Application.ScreenUpdating = True

Unload Me

Exit Sub
ErrorHandler:
lbClose = True
End Sub
Private Sub TotalBOM2PISheets()

On Error GoTo ErrorHandler

Dim loSheet As Object

'Worksheet Integrity Check, if not proper exit
If CheckStructure = False Then
     GoTo ErrorHandler
End If

'--- Check if the Total BOM Sheet Exists, if not create it from TB Template
If WorkSheetExists(nsTB1.name) = False Then

    If WorkSheetExists("TB") = True Then

        'Set the worksheet to TB
        Set loSheet = ActiveWorkbook.Sheets("TB")
        
        loSheet.visible = xlSheetVisible
        
        'Copy the sheet after the active sheet
        Call CopySheet("TB")
        
        'set the copied sheet as the active sheet
        ActiveSheet.name = "Total BOM"
        
        ActiveSheet.Unprotect (SheetPassword)
        
        ActiveSheet.Range("A5").Select
        
        loSheet.visible = xlSheetHidden
        
    Else
        'Show message and go to failure point
        MsgBox "The Total BOM { TB } Template is Missing" & vbCrLf & vbCrLf & "Total BOM Sheet cannot be created"
        GoTo ErrorHandler
    End If

End If


Exit Sub

ErrorHandler:


End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)

If lbClose = False Then
    MsgBox "The Program is going to load the default Template" & vbCrLf & vbCrLf & "Template 2: Start with Total BOM Sheet"
    Application.ScreenUpdating = False
    Call SecondTemplate(1)
    Call TotalBOM2PISheets
    ActiveWorkbook.Sheets(nsMain.name).Activate
    Application.ScreenUpdating = True
End If

ErrorHandler:
Err.clear
End Sub


Attribute VB_Name = "frmPrint"
Attribute VB_Base = "0{86E921DC-FC31-4025-9C12-D646328AC027}{F6E482FC-0D0B-4C8B-B8F3-A59BFE1E7FC6}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False



Private Sub cmdCancel_Click()
Unload Me
End Sub

Private Sub cmdPrint_Click()

Dim lbDeselect As Boolean
Dim liCounter As Integer
Dim myArray() As Variant
Dim lsSheetName As String
Dim lbPrint As Boolean
Dim objSheet As Worksheet

On Error GoTo ErrorHandler

lbDeselect = True

Unload Me

'Resume next on error to trap the error
On Error GoTo ErrorHandler

Dim ws As Worksheet

For Each ws In Worksheets

    Select Case UCase(Trim(ws.CodeName))
        Case "NSTB1"
            If chkTotalBOM.value = True And Worksheets(ws.name).visible = True Then
                lbPrint = True
                If lbDeselect = True Then
                    Worksheets(ws.name).Select True
                    lbDeselect = False
                Else
                    Worksheets(ws.name).Select False
                End If
            End If
        Case "NSCT1"
            If chkCuttingTracking.value = True And Worksheets(ws.name).visible = True Then
                lbPrint = True
                If lbDeselect = True Then
                    Worksheets(ws.name).Select True
                    lbDeselect = False
                Else
                    Worksheets(ws.name).Select False
                End If
            End If
        Case "NSDR1"
            If chkDeliveryRelease.value = True And Worksheets(ws.name).visible = True Then
                lbPrint = True
                If lbDeselect = True Then
                    Worksheets(ws.name).Select True
                    lbDeselect = False
                Else
                    Worksheets(ws.name).Select False
                End If
            End If
        Case "NSPI1"
            If chkPI.value = True And Worksheets(ws.name).visible = True Then
                lbPrint = True
                If lbDeselect = True Then
                    Worksheets(ws.name).Select True
                    lbDeselect = False
                Else
                    Worksheets(ws.name).Select False
                End If
            End If
        Case "NSWP1"
            If chkWorkPreparation.value = True And Worksheets(ws.name).visible = True Then
                lbPrint = True
                If lbDeselect = True Then
                    Worksheets(ws.name).Select True
                    lbDeselect = False
                Else
                    Worksheets(ws.name).Select False
                End If
            End If
    End Select
Next ws

If lbPrint = True Then
    'ActiveWindow.SelectedSheets.PrintOut , , , yes
    ActiveWindow.SelectedSheets.PrintPreview
Else
    MsgBox "No Pages to Print. Please Check"
End If
Exit Sub

ErrorHandler:
MsgBox Err.Description
End Sub

Private Sub UserForm_Activate()

Dim liCurrentLanguageIndex As Integer


liCurrentLanguageIndex = GetLanguageIndex(nsMain.Range("B1").Text)

chkPI.Caption = GetTranslatedValueByKey("Frm_lbl_Production_and_ Inspection", liCurrentLanguageIndex)
chkCuttingTracking.Caption = GetTranslatedValueByKey("Frm_lbl_Cutting_Tracking", liCurrentLanguageIndex)
chkWorkPreparation.Caption = GetTranslatedValueByKey("Frm_lbl_Work_Preparation", liCurrentLanguageIndex)
chkDeliveryRelease.Caption = GetTranslatedValueByKey("Frm_lbl_ Delivery_Release", liCurrentLanguageIndex)
chkTotalBOM.Caption = GetTranslatedValueByKey("Frm_lbl_Total_BOM", liCurrentLanguageIndex)
lblCaption.Caption = GetTranslatedValueByKey("Frm_lbl_PRINT_SHEETS", liCurrentLanguageIndex)
lblHelp.Caption = GetTranslatedValueByKey("Frm_lbl_Please_select_the_sheets", liCurrentLanguageIndex)
cmdCancel.Caption = GetTranslatedValueByKey("Frm_btn_Cancel", liCurrentLanguageIndex)
cmdPrint.Caption = GetTranslatedValueByKey("Frm_btn_Print", liCurrentLanguageIndex)


End Sub

Private Sub UserForm_Initialize()

'Center the Printer Form
Call CenterScreen(Me)

End Sub

Attribute VB_Name = "modGeneral"
Public Sub CenterScreen(frm As Object)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CenterScreen
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 15-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Load the frm (form) in the center of the application
'Trans OK
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

'Set the Top and Left of a screen and make it center screen
frm.Top = Application.Top + (Application.height - frm.height) / 2
frm.Left = Application.Left + (Application.width - frm.width) / 2

Exit Sub

ErrorHandler:

Err.clear
End Sub
Public Function CopySheet(psSheetName As String) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CopySheet
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 06-Nov-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to copy the sheet to a new sheet.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------
Dim objExcel As Object

'Resume next on error to trap the error
On Error Resume Next

'Set the object to an instance of the given sheet
Set objExcel = ActiveWorkbook.Sheets(psSheetName)

'If No error, sheet exists else sheet does not exist
If Err.Number = 0 Then
    objExcel.Copy After:=Worksheets(nsMain.name)
    CopySheet = True
Else
    CopySheet = False
End If

'Clear the error
Err.clear

'set the object to nothing
Set objExcel = Nothing

End Function

Public Function CopyRange(psSourceSheet As String, psTargetSheet As String, psRange As String)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CopyRange
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 06-Nov-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to copy the sheet to a new sheet.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

 
psSourceSheet.Range(psRange).Copy
psTargetSheet.Range(psRange).PasteSpecial Paste:=xlPasteFormats
psTargetSheet.Range(psRange).PasteSpecial Paste:=xlPasteValues
Application.CutCopyMode = False

Exit Function

ErrorHandler:

Err.clear

Exit Function
 
 
End Function


Sub DisplayError(pErr As ErrObject)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : DisplayError
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 14-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Display Error from the Error Object.  This Sub to be called in all error handlers
'
'------------------------------------------------------------------------------------------

'Show the Error to the user
MsgBox pErr.Number & "  " & pErr.Description

'Set the Screen Updating
Application.ScreenUpdating = True

End Sub
Public Function WorkSheetObject(ByVal psCodeName As String, psObject As Object) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : WorkSheetExists
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 12-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to set an object to the given name.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------
Dim objSheet As Worksheet

'Resume next on error to trap the error
On Error GoTo ErrorHandler

Dim ws As Worksheet

psCodeName = UCase(Trim(psCodeName))

For Each ws In Worksheets
    If UCase(Trim(ws.CodeName)) = psCodeName Then
       WorkSheetObject = True
       Set psObject = ws
       Exit For
    End If
Next ws

Exit Function

ErrorHandler:
WorkSheetObject = False
Err.clear

Exit Function

End Function


Public Function WorkSheetObjectExists(ByVal psCodeName As String, Optional psReturnSheetName As String) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : WorkSheetExists
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 12-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to set an object to the given name.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------
Dim objSheet As Worksheet

'Resume next on error to trap the error
On Error GoTo ErrorHandler

Dim ws As Worksheet

WorkSheetObjectExists = False

psCodeName = UCase(Trim(psCodeName))

For Each ws In Worksheets
    If UCase(Trim(ws.CodeName)) = psCodeName Then
       WorkSheetObjectExists = True
       psReturnSheetName = ws.name
       Exit For
    End If
Next ws

Exit Function

ErrorHandler:

Err.clear

Exit Function

End Function
Public Function DeleteSheet(psCodeName As String) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : WorkSheetExists
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 12-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to set an object to the given name.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------
Dim loWorkSheet As Worksheet
Dim lsName As String
'Resume next on error to trap the error
On Error GoTo ErrorHandler
Application.DisplayAlerts = False
Select Case psCodeName

    Case "nsPI1"
        lsName = nsPI1.name
    Case "nsCT1"
        lsName = nsCT1.name
    Case "nsDR1"
        lsName = nsDR1.name
    Case "nsWP1"
        lsName = nsWP1.name
    Case Else
        GoTo ErrorHandler

End Select

Worksheets(lsName).Delete
DeleteSheet = True
Application.DisplayAlerts = True
Exit Function

ErrorHandler:

DeleteSheet = False

End Function
Public Function SheetActivate(psCodeName As String) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : WorkSheetExists
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 12-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to set an object to the given name.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------
Dim loWorkSheet As Worksheet
Dim lsName As String
'Resume next on error to trap the error
On Error GoTo ErrorHandler

Select Case psCodeName

    Case "nsTB1"
        nsTB1.Activate
    Case "nsCT1"
        nsCT1.Activate
    Case Else
        GoTo ErrorHandler

End Select


Activate = True

Exit Function

ErrorHandler:

Activate = False

End Function

Attribute VB_Name = "modHiltiPI"
Option Explicit
Public Const SheetPassword As String = "0000"
Public goMaterials As Object
Public CalcStatus As Variant 'Holds the Calculation Status of the sheet (usually Automatic)
Public Const gsMainSheet As String = "Main"
Public Const gsStartSheet As String = "Start"
Public Const gsCuttingTrackingSheet As String = "Cutting Tracking"
Public Const gsWorkPreparationSheet As String = "Work Preparation"
Public Const gsMasterListSheet As String = "Master List"
Public Const gsOutputListsSheet As String = "Output Lists"
Public Const gsChannelOverview As String = "Channel Overview"
Public Const gsPITemplate As String = "PI Template"
Public Const gsPIAll As String = "PI All"
Public Const gsWorkPreparation As String = "Work Preparation"
Public Const gsTotalBOM As String = "Total BOM"
Public Const gsDeliveryRelease As String = "Delivery Release"
Public Const gsCuttingTracking As String = "Cutting Tracking"
Public Sub Step1()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : Step1
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 11-Nov-2019
'VERSION           : 1.0
'DESCRIPTION       : To Re-direct to Option1 or Option2  based on the user selection
'--------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Call ProcessStarts

If nsMain.Range("A1") = 1 Then
    Call T1S1_PreparePISheetsForEntry 'Template 1
Else
    Call T2S1_FillSettingsTableFromTotalBOM 'Template 2
End If

Call ProcessEnds

Exit Sub

ErrorHandler:
Err.clear
ProcessEnds
End Sub

Sub T2S1_FillSettingsTableFromTotalBOM()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : T2S1_FillSettingsTableFromTotalBOM
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 15-Mar-2019
'VERSION           : 2.0
'DESCRIPTION       : Create Setting Table in Settings Sheet from Total BOM Sheets
'
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

Dim llArrayCounter As Long
Dim liUniqueItem As Integer
Dim loUniqueItems As Object
Dim lvSettingsArray() As Variant
Dim lvSettingsTransposedArray() As Variant
Dim loRange As Range
Dim loWorkSheet As Worksheet
Dim lvTempArray() As Variant
Dim lvBOMArray() As Variant

'Alert the user before continuing if the settings table is not empty
If Len(Trim(Worksheets(nsMain.name).Range("C13"))) > 0 Then
    If MsgBox("The Production and Inspection Table on the right is not empty" & vbCrLf & vbCrLf & "Are you sure you want to continue with Step 1?", vbYesNo + vbDefaultButton2) = vbNo Then
        GoTo Failure
    End If
End If

'This step ensures that the sheet is flawless
If PrimaryCheck = False Then GoTo Failure

'Set this to reduce the flickering
Application.ScreenUpdating = False

'Item Designation Object
Set loUniqueItems = CreateObject("Scripting.Dictionary")

'Set the Worksheet
Set loWorkSheet = nsTB1

'Set the Range
Set loRange = loWorkSheet.Range("$A$5:$L$4098")

'Assign to the Array
lvTempArray() = loRange
      
'Convert from vertical to horizontal array list
lvBOMArray = Application.Transpose(lvTempArray)

'Erase the temp array
Erase lvTempArray


'Loop through the items in the lvFinalarray (BOM items) to identify the unique Items and Item Designations
For llArrayCounter = LBound(lvBOMArray, 2) To UBound(lvBOMArray, 2)

    'Second array element is the item # of the item, which cannot be blank
    If Len(Trim(lvBOMArray(2, llArrayCounter))) > 0 Then
    
        'Check if this item has already been added to the array by checking with the dictionary object
        If loUniqueItems.exists(lvBOMArray(2, llArrayCounter)) = False Then
            
            'One more item found
            liUniqueItem = liUniqueItem + 1
            
            'Add the item to the dictionary
            loUniqueItems.Add lvBOMArray(2, llArrayCounter), liUniqueItem
            
            'populate the array
            ReDim Preserve lvSettingsArray(1 To 3, 1 To liUniqueItem)
            lvSettingsArray(1, liUniqueItem) = lvBOMArray(1, llArrayCounter)
            lvSettingsArray(2, liUniqueItem) = lvBOMArray(2, llArrayCounter)
            lvSettingsArray(3, liUniqueItem) = lvBOMArray(3, llArrayCounter)
        End If
        
    Else
        Exit For
    End If
Next llArrayCounter

'Erase the BOM Array
Erase lvBOMArray

If liUniqueItem = 0 Then
    MsgBox "The Total BOM Sheet is not proper!" & vbCrLf & vbCrLf & "This program cannot continue"
    GoTo Failure
End If

'Transpose the array list
lvSettingsTransposedArray = Application.Transpose(lvSettingsArray)

'Clear any entry in Total Bom Sheet
nsMain.Range("C13:G512") = ""

'Assign the contents of the array to the Total BOM sheet from cell A5
nsMain.[C13].Resize(liUniqueItem, 3) = lvSettingsTransposedArray


'Clear and Hide other Sheets
nsTB1.Range("K5:L5000").value = ""
Call CleanSheets("nsWP1", True)
Call CleanSheets("nsDR1", True)
Call CleanSheets("nsCT1", True)
nsPI1.Range("1:8200").EntireRow.Hidden = False
nsPI1.visible = xlSheetHidden

Application.ScreenUpdating = True

'Success Message
MsgBox "The Production and Inspection Table has been updated successfully." & vbCrLf & vbCrLf & "Please continue with Step 2"

'Set the settings sheet as the active sheet
nsMain.Activate

'All Good.  Exit the function.
Exit Sub

Failure:

'Set the settings sheet as the active sheet
nsMain.Activate

Application.ScreenUpdating = True

Exit Sub

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Sub
Public Sub Step2()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : Step2
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 11-Nov-2019
'VERSION           : 1.0
'DESCRIPTION       : To Re-direct to Option1 or Option2  based on the user selection
'--------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler
ProcessStarts
If nsMain.Range("A1") = 1 Then
    Call T1S2_Create_BOM_Sheet
Else
    Call T2S2_Create_PI_Sheets_From_BOM
End If
ProcessEnds
Exit Sub

ErrorHandler:

Err.clear
ProcessEnds
End Sub

Sub T2S2_Create_PI_Sheets_From_BOM()
'----------------------------------------------------------------------------------------
'PROCEDURE NAME    : T2S2_Create_PI_Sheets_From_BOM
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 15-Mar-2019
'VERSION           : 2.0
'DESCRIPTION       : Create PI Sheets from Total BOM Sheet; Added a new column for Batch;
'                  : Cutting Tracking Sheet creation, Request Sheet Update.
'----------------------------------------------------------------------------------------
' NOTES:
'   Total BOM Sheet Columns
'       1. Batch #
'       2. Item Number - on March 25 order changed ..this is new order of columns
'       3. Item Designation - on March 25 order changed ..this is new order of columns
'       4. Pos.
'       5. L
'       6. Mat.Nr.
'       7. Material Description
'       8. Qty [pcs.]
'       9. Length L [mm]
'       10. Cutting Type
'       11. Total Qty[pcs]
'       12. Relevant IFUs
'   Column Positions in PI sheets
'       1. Position (4 in BOM)
'       2. Material Number (6 in BOM)
'       3. Material Description (7 in BOM)
'       4. Qty (8 in BOM)
'       5. Length (9 in BOM)
'       6. Cutting Type (10 in BOM)
'       7. Total Qty (Calculation Formula is there) (11 in BOM)
'       8. Relevant IFUs (cols 8 and 9 cols combined in excel sheet - 12th col in BOM)
'       10.For Kitting Service: Completeness Test (cols 10 and 11 combined - Not filled)
'----------------------------------------------------------------------------------------


On Error GoTo ErrorHandler

Dim lsaAddress() As String
Dim llArrayCounter As Long
Dim liUniqueItem As Integer
Dim liTotalBOMItems As Integer
Dim lvSettingsArray() As Variant
Dim lvSettingsTransposedArray() As Variant
Dim loRange As Range
Dim lsRange As String
Dim lvTempMaterial As Variant
Dim loWorkSheet As Worksheet
Dim lvTempArray() As Variant
Dim lvBOMArray() As Variant
Dim lsLastItem As String
Dim liArrayCounter As Integer
Dim loHyperLinks As Object
Dim loChannels As Object
Dim lvPISheetsArray() As Variant
Dim liCounter As Long
Dim lsSheetName As String
Dim liNumOfPISheets As Integer
Dim lsSource As String
Dim lsDestination As String
Dim lvFinalArray() As Variant
Dim liSheetCounter As Integer
Dim loSheet As Worksheet
Dim loQty As Object
Dim lsItem As String
Dim lsmaterial As Variant
Dim lbFailed As Boolean
Dim loHeader As Object
Dim loItemDesignation As Object
Dim Pic As Object
Dim lvCuttingArray() As Variant
Dim liCuttingCounter As Integer
Dim lsHeader As String
Dim llTotal As Long
Dim lvTransposedArray() As Variant
Dim lss As String
Dim liSummaryRow As Integer
Dim loMasterAll             As Object
Dim lvMasterAll()           As Variant
Dim liPageCount As Integer
Dim liNextRow As Integer
Dim liCurrentLang As Integer

Debug.Print Now & "  - 1"

'Set this to reduce the flickering
Application.ScreenUpdating = False

'Clear PI Sheet
Call ClearPI

'Basic Check
If PrimaryCheck = False Then GoTo Failure

'---Start: Get the Hyperlinks and Channels in dictionary objects--------------------------------------------
liArrayCounter = GetMasterObjects(loHyperLinks, loChannels)

'If the Master List missing or if the reading fails then exit
If liArrayCounter = -1 Then

    MsgBox "The Master List Sheet Missing!" & vbCrLf & vbCrLf & "Sheets Cannot be Created"
    GoTo Failure

ElseIf liArrayCounter = 0 Then

    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure

End If
    

'---Start: Read the PI_Table, if any failure exit---------------------------------------------------------
liCounter = GetTableInfoFromSettings(lvPISheetsArray, True)

If liCounter = -1 Then
    MsgBox "Please follow the Step 1" & vbCrLf & vbCrLf & "Step 1 will fill the Production and Inspection Table on the right"
    GoTo Failure
ElseIf liCounter = -2 Then
    MsgBox "All fields in the Production & Inspection Sheet Table are mandatory. " & vbCrLf & vbCrLf & _
    "An entire row in the table can be left blank but if one cell is filled, all the cells in that row must be filled."
    GoTo Failure
ElseIf liCounter = 0 Then
    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
End If

'Ensure all the 'Qty' are entered on the Production and Inspection Table
For liCounter = 1 To UBound(lvPISheetsArray, 2)
    If lvPISheetsArray(6, liCounter) = "" Then
        lbFailed = True
        Exit For
    End If
Next liCounter

If lbFailed = True Then
    MsgBox "One or more Qty is empty on the Production and Inspection Table on the right" & vbCrLf & vbCrLf & "Please enter the missing Qty entries"
    GoTo Failure
End If
    
Debug.Print Now & "  - 2"
'---Start: Reading Total BOM Sheet----------------------------------------------------------------------

    'Set the Worksheet
    Set loWorkSheet = nsTB1
    
    'Set the Range
    Set loRange = loWorkSheet.Range("$A$5:$L$4098")
    
    'Assign to the Array
    lvTempArray() = loRange
          
    'Convert from vertical to horizontal array list
    lvBOMArray = Application.Transpose(lvTempArray)
    
    'Erase the temp array
    Erase lvTempArray
    
    'Set the counter to Zero
    liCounter = 0
    
    'Trim the array to have only non-empty items
    For llArrayCounter = 1 To UBound(lvBOMArray, 2)
        'First array element is the item # of the item, which cannot be blank
        If Len(Trim(lvBOMArray(2, llArrayCounter))) > 0 Then
            liCounter = liCounter + 1
        Else
            If liCounter > 0 Then
                ReDim Preserve lvBOMArray(1 To 12, 1 To liCounter)
                Exit For
            Else
                MsgBox "The Total BOM Sheet is either empty or not proper.  Please Check."
                GoTo Failure
            End If
        End If
    Next llArrayCounter
    
    'Sort the array by the item #
    Call BOMSorting(lvBOMArray, 1, True)
    

'nsTB1.Activate 'Veno?

'Total number of PI sheets
liNumOfPISheets = UBound(lvPISheetsArray, 2)

'Item Designation Object
Set loQty = CreateObject("Scripting.Dictionary")

For llArrayCounter = 1 To UBound(lvPISheetsArray, 2)
    If loQty.exists(lvPISheetsArray(3, llArrayCounter)) = False Then
        loQty.Add CStr(lvPISheetsArray(3, llArrayCounter)), CStr(lvPISheetsArray(6, llArrayCounter))
    End If

Next llArrayCounter


liTotalBOMItems = UBound(lvBOMArray, 2)

'Set the Unique Item count to zero
liUniqueItem = 0
lsLastItem = ""

nsPI1.visible = xlSheetVisible

'Loop through the items in the lvBOMArray (BOM items)
For llArrayCounter = 1 To liTotalBOMItems

    'First array element is the item # of the item, which cannot be blank
    If Len(Trim(lvBOMArray(2, llArrayCounter))) > 0 Then
    
        If lsLastItem <> Trim(lvBOMArray(2, llArrayCounter)) Then
        
            lsLastItem = Trim(lvBOMArray(2, llArrayCounter))
            
            'Increase the page Count by one
            liPageCount = liPageCount + 1
            
            'Find the starting starting row number
            liNextRow = (liPageCount - 1) * 41 + 5
            
            'C3 = Item (Third Column)
            nsPI1.Range("C" & liNextRow - 2) = lvPISheetsArray(3, liPageCount)
            'G2 = Hilti Drawing Number & Index (Fifth Column)
            nsPI1.Range("G" & liNextRow - 3) = lvPISheetsArray(5, liPageCount)
            'g3 = Item Designation acc. Drawing (Fourth Column)
            nsPI1.Range("G" & liNextRow - 2) = lvPISheetsArray(4, liPageCount)
            'J3 = Qty(Sixth Column)
            nsPI1.Range("J" & liNextRow - 2) = lvPISheetsArray(6, liPageCount)
            'J2 = Batch(First Column)
            nsPI1.Range("J" & liNextRow - 3) = lvPISheetsArray(2, liPageCount)
            
            nsPI1.Range("F" & liNextRow + 23) = lvPISheetsArray(4, liPageCount)
            
            nsPI1.Range("F" & liNextRow + 32) = lvPISheetsArray(4, liPageCount)
            
        End If
                
        'Col A = Position
        lsRange = "A" & liNextRow
        nsPI1.Range(lsRange) = lvBOMArray(4, llArrayCounter) 'BOM 4 is Position
        
        'Col B = Material Number
        lsRange = "B" & liNextRow
        nsPI1.Range(lsRange) = lvBOMArray(6, llArrayCounter) 'BOM 6 is Material #
        
        'Col C = Material Description
        lsRange = "C" & liNextRow
        nsPI1.Range(lsRange) = lvBOMArray(7, llArrayCounter) 'BOM 7 Material Desc
        
        'Col D = Qty
        lsRange = "D" & liNextRow
        nsPI1.Range(lsRange) = lvBOMArray(8, llArrayCounter) 'BOM 8 Qty
        
        'Col E = Length
        lsRange = "E" & liNextRow
        nsPI1.Range(lsRange) = lvBOMArray(9, llArrayCounter) 'BOM 9 Length
        
        'Col F = Cutting Type
        lsRange = "F" & liNextRow
        nsPI1.Range(lsRange) = lvBOMArray(10, llArrayCounter) 'BOM 10 Cutting Type
            
        'Col G = Total Qty
        lsRange = "G" & liNextRow
        nsPI1.Range(lsRange) = lvBOMArray(8, llArrayCounter) * lvPISheetsArray(6, liPageCount)
        
        'Update the Total BOM with the Total Qty and Link

        lsSource = "L" & llArrayCounter + 4
        lsmaterial = lvBOMArray(6, llArrayCounter)
        lsRange = "H" & liNextRow

        'Check if the Material Number is not blank
        If Len(lsmaterial) > 0 Then
        
            'If Hyperlink Exists for the material
            If loHyperLinks.exists(lsmaterial) Then
    
                lsDestination = loHyperLinks.item(lsmaterial)
                
                If Left(lsDestination, 10) = "HYPERLINK:" Then
    
                    lsDestination = "C" & Mid(lsDestination, 11)
                    nsTB1.Range(lsSource).Hyperlinks.Add nsTB1.Range(lsSource), Worksheets(gsMasterListSheet).Range(lsDestination).Hyperlinks(1).Address, , , Worksheets(gsMasterListSheet).Range(lsDestination).Text
                    nsPI1.Range(lsRange).Hyperlinks.Add nsPI1.Range(lsRange), Worksheets(gsMasterListSheet).Range(lsDestination).Hyperlinks(1).Address, , , Worksheets(gsMasterListSheet).Range(lsDestination).Text
                    
                Else
                    
                    lsDestination = "C" & lsDestination
                    nsTB1.Range(lsSource) = Worksheets(gsMasterListSheet).Range(lsDestination)
                    nsPI1.Range(lsRange) = Worksheets(gsMasterListSheet).Range(lsDestination)
                End If
                 lvBOMArray(12, llArrayCounter) = nsPI1.Range(lsRange)
            End If
            
            'Update the Total Quantity Table
            lsDestination = "K" & llArrayCounter + 4
            lsSource = "H" & llArrayCounter + 4
            lsItem = "B" & llArrayCounter + 4
            lsItem = nsTB1.Range(lsItem)
            lsItem = loQty.item(lsItem)
            
            nsTB1.Range(lsDestination) = val(nsTB1.Range(lsSource)) * val(lsItem)
            lvBOMArray(11, llArrayCounter) = nsTB1.Range(lsDestination)
            
            'Update L in the columns
            lsDestination = "E" & llArrayCounter + 4
            nsTB1.Range(lsDestination) = "L"
            lvBOMArray(5, llArrayCounter) = "L"
            
            'Update Col A with the Batch number from the settings
            lsDestination = "A" & llArrayCounter + 4
            nsTB1.Range(lsDestination) = lvPISheetsArray(2, liPageCount)
            lvBOMArray(1, llArrayCounter) = lvPISheetsArray(2, liPageCount)
        End If
                                
        liNextRow = liNextRow + 1
        
        'Store the item as last item
        lsLastItem = Trim(lvBOMArray(2, llArrayCounter))
                
    Else
        Exit For
    End If
Next llArrayCounter

'Remove the blank rows so that the print works fine.
'Clear any entry in Total Bom Sheet
lss = "A" & (liTotalBOMItems + 5) & ":L5000"
nsTB1.Range(lss).clear
nsTB1.Range(lss).Borders.LineStyle = xlLineStyleNone

'Create the Cutting Tracking Sheet from loChannels
'Create an array only with the Channel type

ReDim lvItemDesignation(1 To UBound(lvPISheetsArray, 2))

For liArrayCounter = 1 To UBound(lvPISheetsArray, 2)
    lvItemDesignation(liArrayCounter) = lvPISheetsArray(3, liArrayCounter)
Next liArrayCounter

Set loHeader = CreateObject("Scripting.Dictionary")
'Item Designation Object
Set loItemDesignation = CreateObject("Scripting.Dictionary")

'Sort the item designations
Call SingleSorting(lvItemDesignation)

'Set the Item Designation Number differently so that descending sort returns them ascending; This is required for BOMSort Below
For liArrayCounter = 1 To UBound(lvItemDesignation)
    
    If loItemDesignation.exists(lvItemDesignation(liArrayCounter)) = False Then
        loItemDesignation.Add lvItemDesignation(liArrayCounter), (9999 - liArrayCounter)
    End If
    
Next liArrayCounter


ReDim lvCuttingArray(1 To 15, 1 To 1)


For liArrayCounter = 1 To UBound(lvBOMArray, 2)

    If loChannels.exists(lvBOMArray(6, liArrayCounter)) = True Then
    
        liCuttingCounter = liCuttingCounter + 1
        
        ReDim Preserve lvCuttingArray(1 To 15, 1 To liCuttingCounter)
        'Item Description
        lvCuttingArray(1, liCuttingCounter) = lvBOMArray(3, liArrayCounter)
        
        'Position
        lvCuttingArray(2, liCuttingCounter) = lvBOMArray(4, liArrayCounter)
        
        'Material #
        lvCuttingArray(3, liCuttingCounter) = lvBOMArray(6, liArrayCounter)
        
        'Material Description
        lvCuttingArray(4, liCuttingCounter) = lvBOMArray(7, liArrayCounter)
        
        'Cutting Type
        lvCuttingArray(5, liCuttingCounter) = lvBOMArray(10, liArrayCounter)
        
        'Total Quantity
        lvCuttingArray(6, liCuttingCounter) = lvBOMArray(11, liArrayCounter)
        
        'Length
        lvCuttingArray(7, liCuttingCounter) = lvBOMArray(9, liArrayCounter) '* 1000
        
         'Sorting # for item designation
        lvCuttingArray(8, liCuttingCounter) = loItemDesignation.item(lvBOMArray(2, liArrayCounter))
    
        
        'Check if the header row is unique else add a header row
        lsHeader = Right("000000000000" & lvBOMArray(9, liArrayCounter), 12) & Right("000000000000" & lvBOMArray(6, liArrayCounter), 12)
        
        If loHeader.exists(lsHeader) = False Then
        
            liCounter = liCounter + 1
            
            loHeader.Add lsHeader, liCounter
            
            liCuttingCounter = liCuttingCounter + 1
            
            ReDim Preserve lvCuttingArray(1 To 15, 1 To liCuttingCounter)
            'Item Designation
            lvCuttingArray(1, liCuttingCounter) = ""
            
            'Position
            lvCuttingArray(2, liCuttingCounter) = ""
            
            'Material #
            lvCuttingArray(3, liCuttingCounter) = lvBOMArray(6, liArrayCounter)
            
            'Material Description
            lvCuttingArray(4, liCuttingCounter) = lvBOMArray(7, liArrayCounter)
            
            'Cutting Type
            lvCuttingArray(5, liCuttingCounter) = lvBOMArray(10, liArrayCounter) 'lvCuttingTypeArray(liArrayCounter)
            
            'Total Quantity
            lvCuttingArray(6, liCuttingCounter) = ""
            
            'Length
            lvCuttingArray(7, liCuttingCounter) = lvBOMArray(9, liArrayCounter) '* 1000 removed as Total BOM also is in mm now 20/Mar/2019
            
             'Sorting # for item designation
            lvCuttingArray(8, liCuttingCounter) = "9999"
            
        End If
        
    End If

Next liArrayCounter


'Sort the array
If BOMSorting(lvCuttingArray) = False Then

    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
    
End If


'Process the lvcutting array and make Summary Rows and Detailed Rows
For liArrayCounter = UBound(lvCuttingArray, 2) To 1 Step -1
    
    'Detailed rows will not have 9999
    If lvCuttingArray(8, liArrayCounter) <> "9999" Then
       
        'Add to the Material Totals
        llTotal = llTotal + lvCuttingArray(6, liArrayCounter)
        
        'Blank the detailed rows; Details shown only in the header rows
        lvCuttingArray(3, liArrayCounter) = ""
        lvCuttingArray(4, liArrayCounter) = ""
        lvCuttingArray(5, liArrayCounter) = ""
        lvCuttingArray(7, liArrayCounter) = ""
        
    Else 'Summary Row will have 9999; Assign Totals and do not clear the details
        lvCuttingArray(6, liArrayCounter) = llTotal

        llTotal = 0
    End If

Next liArrayCounter

'Convert from vertical to horizontal array list
lvTransposedArray = Application.Transpose(lvCuttingArray)

'Clear any entry in Cutting Tracking Sheet
nsCT1.Range("A8:O5000").clear

'Assign the contents of the array to the Cutting Tracking sheet from cell A8
nsCT1.[A8].Resize(UBound(lvCuttingArray, 2), 7) = lvTransposedArray

lss = "A8:M" & UBound(lvCuttingArray, 2) + 8
nsCT1.Range(lss).Borders.LineStyle = xlContinuous
nsCT1.Range(lss).HorizontalAlignment = xlCenter
nsCT1.Range(lss).VerticalAlignment = xlCenter


For liArrayCounter = 1 To UBound(lvCuttingArray, 2)

    If lvCuttingArray(1, liArrayCounter) = "" Then
        'Row number is array number + 7 fixed rows
        liSummaryRow = 7 + liArrayCounter
        lss = "C" & liSummaryRow & ":G" & liSummaryRow
        nsCT1.Range(lss).Font.bold = True
        nsCT1.Range(lss).Interior.color = RGB(255, 200, 100)

    End If

Next liArrayCounter

With nsCT1.Range(lss).Interior
    .Pattern = xlSolid
End With

nsCT1.visible = xlSheetVisible

Debug.Print Now & "  - 4"

lsRange = (liPageCount * 41) + 1 & ":8200"
nsPI1.Range(lsRange).EntireRow.Hidden = True

nsPI1.Activate
nsPI1.Range("A5").Select

'*********************  UPDATING REQUEST SHEET ****************************

Call FillRequestSheet(lvCuttingArray)

'------------------------------------------------------------------------------------------------

Call GetSheetAddressAllLanguages(lsaAddress)

'Get the selected Language
liCurrentLang = GetLanguageIndex(nsMain.Range("B1").Text)

'Set the Translated sheet names for the newly created sheets
nsTB1.name = TranslateSheetName(lsaAddress, "nsTB1", liCurrentLang)
nsCT1.name = TranslateSheetName(lsaAddress, "nsCT1", liCurrentLang)

'Do not change sheet name to Object("nsPI1")
Sheets(gsPIAll).name = TranslateSheetName(lsaAddress, "nsPI1", liCurrentLang)

'Success Message
MsgBox "Production & Inspection, Cutting Tracking and Request Sheets have been created successfully"

Application.ScreenUpdating = True

'All Good.  Exit the function.
Exit Sub

Failure:

'Set the settings sheet as the active sheet
nsMain.Activate

Application.ScreenUpdating = True

Exit Sub

Return

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Sub



Public Function CheckMandatory() As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CheckMandatory
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 15-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Check if the Mandatory fields are filled
'Trans OK
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

'Hilti Order Number empty check
If Len(Trim(nsMain.Range("E4"))) = 0 Then
    MsgBox "Hilti Order Number cannot be blank. Please check."
    GoTo ErrorHandler
End If

'Version empty check
If Len(Trim(nsMain.Range("E7"))) = 0 Then
    MsgBox "Version cannot be blank. Please check."
    GoTo ErrorHandler
End If

CheckMandatory = True

Exit Function

ErrorHandler:
CheckMandatory = False
Err.clear
End Function
Public Function PrimaryCheck() As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : PrimaryCheck
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 22-Nov-2019
'VERSION           : 2.0
'DESCRIPTION       : Do All the checks and if this function returns fail, do not proceed with Step 1/2/3
'--------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

'Worksheet Integrity Check, if not proper exit
If CheckStructure = False Then GoTo Failure

'Check Mandatory Settings (Hilti Order Number and Version)
If CheckMandatory = False Then GoTo Failure

PrimaryCheck = True
Exit Function

Failure:
PrimaryCheck = False
Exit Function

ErrorHandler:
Err.clear
End Function


Public Sub Step3()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : Step3
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 11-Nov-2019
'VERSION           : 1.0
'DESCRIPTION       : To Re-direct to Option1 or Option2  based on the user selection
'--------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

ProcessStarts

Call T1T2S3_StartProcess

ProcessEnds

Exit Sub

ErrorHandler:
Err.clear
ProcessEnds
End Sub
Public Sub Step3_21()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : Step3
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 11-Nov-2019
'VERSION           : 1.0
'DESCRIPTION       : To Re-direct to Option1 or Option2  based on the user selection
'--------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

ProcessStarts
Call TotalBOM2PI_Step3
ProcessEnds

Exit Sub

ErrorHandler:
Err.clear
ProcessEnds
End Sub
Sub TotalBOM2PI_Step3()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : TotalBOM2PI_Step3
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 19-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Copy Hyperlinks from another cell
'
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler
Dim loSheet         As Worksheet
Dim loPrev          As Worksheet
Dim lsMessage       As String



'Worksheet Integrity Check
If CheckStructure = False Then GoTo Failure

'Check Mandatory Settings (Hilti Order Number and Version)
If CheckMandatory = False Then GoTo Failure

'To make sure the Step 2 is executed
If WorkSheetObjectExists("nsPI1") = False Then
    MsgBox "The PI Sheet is Missing!" & vbCrLf & vbCrLf & "Please complete Step 2 before using Step 3"
    GoTo Failure
End If

''Check if Total BOM sheet is there
If WorkSheetObjectExists("nsTB1") = False Then
    MsgBox "The Total BOM Sheet is Missing!" & vbCrLf & vbCrLf & "Please complete Step 2 before using Step 3"
    GoTo Failure
End If

'Check if Cutting Tracking Sheet is available, which is an input for this.
If WorkSheetObjectExists("nsCT1") = False Then
    MsgBox "The Cutting Tracking Sheet is Missing!" & vbCrLf & vbCrLf & "Please complete Step 2 before using Step 3"
    GoTo Failure
End If

'If the Delivery Release and Work Preparation Sheets exists, delete it
If WorkSheetObjectExists("nsWP1") Then
   lsMessage = "Work Preparation sheet"
End If

If WorkSheetObjectExists("nsDR1") Then
   If Len(lsMessage) > 0 Then
        lsMessage = lsMessage + " & Delivery Release sheet"
   Else
        lsMessage = "Delivery Release sheet"
   End If
End If

If Len(lsMessage) > 0 Then
    If MsgBox(lsMessage & " must be deleted before continuing." & vbCrLf & vbCrLf & "Do You Want to DELETE the sheet now?", vbYesNo) = vbYes Then
        Call DeleteSheet("nsWP1")
        Call DeleteSheet("nsDR1")
        MsgBox lsMessage & " has been deleted successfully.  Please click Step 3 Again."
    End If
    'Set this to reduce the flickering
    Application.ScreenUpdating = True
    Exit Sub
End If

'Create Blank Work Preparation
If WorkSheetObjectExists("nsWP1") = False Then
    
    Call CopyFromTemplates("WP", gsWorkPreparationSheet)
    
End If

'Creation of Delivery Release
If WorkSheetObjectExists("nsDR1") = False Then
    
     Call CopyFromTemplates("DR", "Delivery Release")
 
End If

Exit Sub

'All Checks done.  Call the function to generate WP and DR Sheets
Call Create_WP_and_DR_Sheets

'All good, exit the routine
Exit Sub

Failure:

'Set the settings sheet as the active sheet
nsMain.Activate

'Set the screen updating back to True
Application.ScreenUpdating = True

Exit Sub

Exit Sub

ErrorHandler:



End Sub

Public Function TableMandatoryCheck(pvTableArray() As Variant) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : TableMandatoryCheck
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 15-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Check if the Mandatory fields are filled
'Trans OK
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler
Dim liCounter As Integer
Dim liInner As Integer
Dim liTableCol As Integer
 
 
 For liCounter = LBound(pvTableArray, 2) To UBound(pvTableArray, 2)
    'Check for the non-blanks, all columns must be filled
    
    liTableCol = 0
    
    For liInner = 2 To 6
        'Check if item number is blank
        If Len(Trim(pvTableArray(liInner, liCounter))) > 0 Then
           liTableCol = liTableCol + 1
        End If
    Next liInner
   
   If liTableCol > 0 And liTableCol <> 5 Then
        TableMandatoryCheck = False
        Exit Function
   End If

Next liCounter

TableMandatoryCheck = True

Exit Function

ErrorHandler:
TableMandatoryCheck = False
Err.clear
End Function
Public Sub PrintSheets()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : PrintSheets
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 25-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Load the Printing Dialog
'Trans OK
'------------------------------------------------------------------------------------------

frmPrint.show 1

End Sub

'End Sub
Public Sub FirstTemplate(Optional piFirst As Integer)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : FirstTemplate
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 15-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Setting First Template (PI Sheets to Total BOM)
'Trans OK
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

nsMain.visible = xlSheetVisible

nsStart.Unprotect (SheetPassword)
nsStart.Range("A1:R100").Font.color = nsStart.Range("A1").Interior.color
nsStart.Range("A1:R100").Interior.color = nsStart.Range("A1").Interior.color
nsStart.Protect (SheetPassword)
nsStart.visible = xlSheetHidden

nsMain.Activate

If piFirst = 1 Then 'Write the Template selected in A1
    nsMain.Unprotect (SheetPassword)
    nsMain.Range("A1") = 1
    
    'To Update the text based on the option selection
    nsMain.Range("J4") = GetTranslatedValueByKey("O1-SH", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J7") = GetTranslatedValueByKey("O1-S1H", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J8") = GetTranslatedValueByKey("O1-S1D", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J14") = GetTranslatedValueByKey("O1-S2H", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J15") = GetTranslatedValueByKey("O1-S2D", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J21") = GetTranslatedValueByKey("O1-S3H", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J22") = GetTranslatedValueByKey("O1-S3D", GetLanguageIndex(nsMain.Range("B1").Text))
    
    nsMain.Protect (SheetPassword)
End If

'
Exit Sub

ErrorHandler:
MsgBox Err.Description & vbCrLf & vbCrLf & "FirstTemplate Procedure"
End Sub

Public Sub SecondTemplate(Optional piFirst As Integer)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : SecondTemplate
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 15-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Setting Second Template (Total BOM to PI Sheets)
'Trans OK
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler


nsMain.visible = xlSheetVisible

nsStart.Unprotect (SheetPassword)
nsStart.Range("A1:R100").Font.color = nsStart.Range("A1").Interior.color
nsStart.Range("A1:R100").Interior.color = nsStart.Range("A1").Interior.color
nsStart.Protect (SheetPassword)
nsStart.visible = xlSheetHidden

If piFirst <> 1 Then
    nsMain.Activate
End If

If piFirst = 1 Then 'Write the Template selected in A1

    nsMain.Unprotect (SheetPassword)
    nsMain.Range("A1") = 2

    'To Update the text based on the option selection
    nsMain.Range("J4") = GetTranslatedValueByKey("O2-SH", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J7") = GetTranslatedValueByKey("O2-S1H", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J8") = GetTranslatedValueByKey("O2-S1D", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J14") = GetTranslatedValueByKey("O2-S2H", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J15") = GetTranslatedValueByKey("O2-S2D", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J21") = GetTranslatedValueByKey("O2-S3H", GetLanguageIndex(nsMain.Range("B1").Text))
    nsMain.Range("J22") = GetTranslatedValueByKey("O2-S3D", GetLanguageIndex(nsMain.Range("B1").Text))

    nsMain.Protect (SheetPassword)
    
End If


Exit Sub

ErrorHandler:
MsgBox Err.Description & vbCrLf & vbCrLf & "FirstTemplate Procedure"
End Sub
Public Function WorkSheetExists(pvSheetName As Variant) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : WorkSheetExists
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 12-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to set an object to the given name.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------
Dim objExcel As Object

'Resume next on error to trap the error
On Error Resume Next

'Set the object to an instance of the given sheet
Set objExcel = ActiveWorkbook.Sheets(pvSheetName)

'If No error, sheet exists else sheet does not exist
If Err.Number = 0 Then
    WorkSheetExists = True
Else
    WorkSheetExists = False
End If

'Clear the error
Err.clear

'set the object to nothing
Set objExcel = Nothing

End Function


Public Function GetTableInfoFromSettings(pvArray() As Variant, pbMandatoryCheckRequired As Boolean) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetTableInfoFromSettings
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 12-Feb-2019
'VERSION           : 2.0
'DESCRIPTION       : Read the user entered settings for the Production and Inspection Sheets (PI sheets)
'                  : From the table
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

Dim lvLocalSettingsArray() As Variant
Dim lvTempArray() As Variant
Dim loTable As ListObject
Dim loWorkSheet As Worksheet
Dim liArrayDimension As Integer
Dim liCounter As Integer


'Set the return value to False
GetTableInfoFromSettings = 0

'set the worksheet to settings sheet
Set loWorkSheet = nsMain

'Set path for Table variable
Set loTable = loWorkSheet.ListObjects("PI_Table")

'Create Array List from Table
lvTempArray = loTable.DataBodyRange.Columns()
  
'Transpose the Array
lvLocalSettingsArray = Application.Transpose(lvTempArray)

'Loop through the items in the array to redimension the array, remove the blanks.
liArrayDimension = 0

'if Mandatory Check Required, make sure all the rows have valid info.
If pbMandatoryCheckRequired = True Then
    If TableMandatoryCheck(lvLocalSettingsArray) = False Then
        GetTableInfoFromSettings = -2
        Exit Function
    End If
    
End If

'Loop through the array and keep only the non-blanks, redimension the array accordingly
For liCounter = LBound(lvLocalSettingsArray, 2) To UBound(lvLocalSettingsArray, 2)
    
        If Len(Trim(lvLocalSettingsArray(3, liCounter))) > 0 Then
        
            liArrayDimension = liArrayDimension + 1
            
        Else
            'Exit the loop as soon as the first blank appears
            Exit For
        End If
        
Next liCounter

'If the table is empty return -1
If liArrayDimension < 1 Then
    GetTableInfoFromSettings = -1
    Exit Function
End If

'Redimension the array to have only the non-blanks
ReDim Preserve lvLocalSettingsArray(1 To 6, 1 To liArrayDimension)

'Assign the array to the return
pvArray = lvLocalSettingsArray

'All Good; set the return value to TRUE
GetTableInfoFromSettings = 1

Exit Function

ErrorHandler:

GetTableInfoFromSettings = 0
'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear


End Function

Sub T1S1_PreparePISheetsForEntry()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : T1S1_PreparePISheetsForEntry
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 14-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Create PI sheets based on the info from settings sheet, also fill the 4 cells with the infol
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim myArray() As Variant
Dim liCounter As Long
Dim lsSheetName As String
Dim loSheet As Worksheet
Dim liSheetNumber As Integer
Dim lsRange As String
Dim liCurrentLang As Integer
Dim lsaAddress()    As String

'Set the screen update to false to avoid screen blinking
Application.ScreenUpdating = False

If PrimaryCheck = False Then GoTo Failure

'Read the PI_Table for the PI Sheets
liCounter = GetTableInfoFromSettings(myArray, True)

'Alert the user before continuing if the settings table is not empty
If Len(Trim(nsPI1.Range("A5"))) > 0 Then
    If MsgBox("The Production and Inspection Sheet is not Blank. If you continue, all the entered values will be deleted." & vbCrLf & vbCrLf & "Are you sure you want to start entering values again?", vbYesNo + vbDefaultButton2) = vbNo Then
        GoTo Failure
    End If
End If


If liCounter = -1 Then
    MsgBox "Please enter the Production & Inspection Sheet details" & vbCrLf & vbCrLf & "The PI Sheet details must be entered in the table"
    GoTo Failure
ElseIf liCounter = -2 Then
    MsgBox "All fields in the Production & Inspection Sheet Table are mandatory. " & vbCrLf & vbCrLf & "An entire row in the table can be left blank but if one cell is filled, all the cells in that row must be filled."
    GoTo Failure
ElseIf liCounter = 0 Then
    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
End If

nsPI1.Unprotect (SheetPassword)

'Clear PI Sheet
Call ClearPI

' Loop through all the pages and if not exists, create them
For liCounter = 1 To UBound(myArray, 2)
    
    'Check if the P & I Item Number is not blank
    If Len(Trim(myArray(2, liCounter))) > 0 Then
        
        '---- Assign other values ---
        'C3 = Item (Second Column)
        nsPI1.Range("C" & (liSheetNumber * 41) + 3) = myArray(3, liCounter)
        
        'G2 = Hilti Drawing Number & Index (Fourth Column)
        nsPI1.Range("G" & (liSheetNumber * 41) + 2) = myArray(5, liCounter)
        
        'g3 = Item Designation acc. Drawing (Third Column)
        nsPI1.Range("G" & (liSheetNumber * 41) + 3) = myArray(4, liCounter)
        
        'J3 = Qty(Fifth Column)
        nsPI1.Range("J" & (liSheetNumber * 41) + 3) = myArray(6, liCounter)
        
        'J2 = Batch
        nsPI1.Range("J" & (liSheetNumber * 41) + 2) = myArray(2, liCounter)
        
        'Item Designation
        nsPI1.Range("F" & (liSheetNumber * 41) + 28) = myArray(4, liCounter)
        
        'Item Designation
        nsPI1.Range("F" & (liSheetNumber * 41) + 37) = myArray(4, liCounter)
        
        liSheetNumber = liSheetNumber + 1
        
    End If
    
Next liCounter

'Make the rows visible
lsRange = "1:" & (liSheetNumber * 41)
nsPI1.Range(lsRange).EntireRow.Hidden = False

'Hide the rows of unused PI Sheets
lsRange = (liSheetNumber * 41) + 1 & ":8200"
nsPI1.Range(lsRange).EntireRow.Hidden = True

nsPI1.visible = xlSheetVisible

'Clear and Hide other Sheets
nsTB1.Range("A5:L5000") = ""
nsTB1.visible = xlSheetHidden

Call CleanSheets("nsCT1", True)
Call CleanSheets("nsWP1", True)
Call CleanSheets("nsDR1", True)

MsgBox "Production & Inspection Sheet has been created successfully."
'Set the settings sheet as the active sheet
ActiveWorkbook.Sheets(nsMain.name).Activate

'Set the Screen Updating
Application.ScreenUpdating = True
    
'All good. Exit
Exit Sub

Failure:
'Set this to reduce the flickering
Application.ScreenUpdating = True
Exit Sub


ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Sub

Sub T1S2_Create_BOM_Sheet()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : T1S2_Create_BOM_Sheet
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 22-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Create BOM sheet and Cutting Tracking Sheet from individual PI sheets
'
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

Dim liArrayCounter As Long
Dim liBOMCounter As Integer
Dim liCounter As Integer
Dim liCuttingCounter As Integer
Dim liItemDesignationCounter As Integer
Dim liSheetCounter As Integer
Dim liSummaryRow As Integer
Dim loPrev As Worksheet
Dim llTotal As Long
Dim lsRange As String
Dim liTotalSheet As Integer
Dim liCurrentLang As Integer
Dim lsaAddress()    As String
Dim liLineItem As Integer 'Alexa

Dim loChannels As Object
Dim loHeader As Object
Dim loHyperLinks As Object
Dim loItemDesignation As Object

Dim loRange As Range

Dim loSheet As Worksheet
Dim loWorkSheet As Worksheet

Dim ls As String
Dim ls2 As String
Dim lsHeader As String
Dim lss As String

Dim lvBOMArray() As Variant
Dim lvCuttingArray() As Variant
Dim lvCuttingTypeArray() As Variant
Dim lvFinalArray() As Variant
Dim lvHyper() As Variant
Dim lvInputCalculator() As Variant
Dim lvItemDesignation() As Variant
Dim lvSettingsArray() As Variant
Dim lvSheetNames() As Variant
Dim lvTempArray() As Variant
Dim lvTransposedArray() As Variant

If PrimaryCheck = False Then GoTo Failure

'Set this to reduce the flickering
Application.ScreenUpdating = False

'Item Designation Object
Set loItemDesignation = CreateObject("Scripting.Dictionary")

'Set the Function as False
ReDim lvBOMArray(1 To 12, 1 To 1)

'Populate the array with the Table! Data from the settings worksheet
liCounter = GetTableInfoFromSettings(lvSettingsArray, True)

'Check if the table has info from Row 1.
If liCounter = -1 Then
    MsgBox "Production and Inspection Sheet Table not proper." & vbCrLf & vbCrLf & _
    "The PI Sheet details must be entered from the first row in that table and follow Step 1"
    GoTo Failure
ElseIf liCounter = -2 Then
    MsgBox "All fields in the Production & Inspection Sheet Table are mandatory. " & vbCrLf & vbCrLf & _
    "An entire row in the table can be left blank but if one cell is filled, all the cells in that row must be filled."
    GoTo Failure
ElseIf liCounter = 0 Then

    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
    
End If

''loop through all the table entries where item is non-blank, exits the loop at the first blank
For liCounter = 1 To UBound(lvSettingsArray, 2)

    If Len(Trim(lvSettingsArray(2, liCounter))) > 0 Then
        liTotalSheet = liTotalSheet + 1
    End If

Next liCounter


'Get the Hyperlinks and Channels in dictionary objects
liArrayCounter = GetMasterObjects(loHyperLinks, loChannels)

'If the Master List missing or if the reading fails then exit
If liArrayCounter = -1 Then

    MsgBox "Master List Sheet Missing!" & vbCrLf & vbCrLf & "Sheets Cannot be Created"
    GoTo Failure
    
ElseIf liArrayCounter = 0 Then

    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
    
End If

'Set the Worksheet
Set loWorkSheet = Worksheets(nsPI1.name)

'Set the item Designation dictionary
ReDim lvItemDesignation(0 To liCounter - 1)

'Loop through all the sheets to get the data from the sheets
For liSheetCounter = 0 To liTotalSheet - 1
    
    'Update the Qty also (in case there was a change in the settings sheet after the Step 1)
    nsPI1.Range("J" & (liSheetCounter * 41 + 3)) = lvSettingsArray(6, liSheetCounter + 1)

    
    'Set the Range
    lsRange = "A" & (liSheetCounter * 41 + 5) & ":K" & (liSheetCounter * 41 + 26)
    Set loRange = nsPI1.Range(lsRange)
    
    'Assign to the Array
    lvTempArray() = loRange
      
    'Convert from vertical to horizontal array list
    lvFinalArray = Application.Transpose(lvTempArray)
    
    'Get the item  in an array
    lvItemDesignation(liSheetCounter) = nsPI1.Range("C" & (liSheetCounter * 41 + 3))
    
    
    
    'Loop through the items in the array to redimension the array, remove the blanks.
    For liArrayCounter = LBound(lvFinalArray, 2) To UBound(lvFinalArray, 2)
    
        'Second array element is the name of the item, which cannot be blank
        If Len(Trim(lvFinalArray(2, liArrayCounter))) > 0 Then
        
            'Increment the counter by one as the record is non-blank
            liBOMCounter = liBOMCounter + 1
            
            'Redimension the array for the new entry
            ReDim Preserve lvBOMArray(1 To 12, 1 To liBOMCounter)
            ReDim Preserve lvCuttingTypeArray(1 To liBOMCounter)
            
            'Batch Number = comes from the sheet, J2 cell
            lvBOMArray(1, liBOMCounter) = loWorkSheet.Range("J" & (liSheetCounter * 41) + 2)
            
            'Item Number = comes from the sheet, C3 cell
            lvBOMArray(2, liBOMCounter) = loWorkSheet.Range("C" & (liSheetCounter * 41) + 3)
            
            'Item Designation = comes from the sheet, G3 cell
            lvBOMArray(3, liBOMCounter) = loWorkSheet.Range("G" & (liSheetCounter * 41) + 3)
            
            'Pos. (element 1)
            lvBOMArray(4, liBOMCounter) = lvFinalArray(1, liArrayCounter)
            
            'Filling L
            lvBOMArray(5, liBOMCounter) = "L"
            
            'Mat.Nr (element 2)
            lvBOMArray(6, liBOMCounter) = lvFinalArray(2, liArrayCounter)
            
            'Material Description (element 3)
            lvBOMArray(7, liBOMCounter) = lvFinalArray(3, liArrayCounter)
            
            'Quantity (element 4)
            lvBOMArray(8, liBOMCounter) = lvFinalArray(4, liArrayCounter)
            
            'Length (element 5)
            lvBOMArray(9, liBOMCounter) = lvFinalArray(5, liArrayCounter)
            
            'Cutting Type
            lvBOMArray(10, liBOMCounter) = lvFinalArray(6, liArrayCounter)
            
            'Total Quantity of component (element 7)
            lvBOMArray(11, liBOMCounter) = lvFinalArray(4, liArrayCounter) * lvSettingsArray(6, liSheetCounter + 1)
            
            
            'To Update the 'Total Qty (pcs)' column in the 'PI All' sheet
            nsPI1.Range("G" & (liSheetCounter * 41 + 4 + liArrayCounter)) = lvFinalArray(4, liArrayCounter) * lvSettingsArray(6, liSheetCounter + 1)
            
'            'Relevant IFUs (element 8)
'            lvBOMArray(12, liBOMCounter) = lvFinalArray(8, liArrayCounter)
            
            'Cutting type for Cutting type sheet (Not removing this even though Cutting Type is added to Total BOM in Phase 2.
            lvCuttingTypeArray(liBOMCounter) = lvFinalArray(6, liArrayCounter)
            
        Else
            Exit For
        End If
    Next liArrayCounter
        
Next liSheetCounter


If liBOMCounter = 0 Then

    MsgBox "All the Production and Inspection Sheets are empty" & vbCrLf & vbCrLf & "Sheets Cannot be Created"
    GoTo Failure
    
End If

'Transpose the array list
lvFinalArray = Application.Transpose(lvBOMArray)

'Clear any entry in Total Bom Sheet
nsTB1.Range("A5:L5000").clear

'Assign the contents of the array to the Total BOM sheet from cell A5
nsTB1.[A5].Resize(liBOMCounter, 11) = lvFinalArray

'Set the Border
lss = "A5:L" & liBOMCounter + 4
nsTB1.Range(lss).Borders.LineStyle = xlContinuous


''Fix the IFU Links
For liArrayCounter = 1 To liBOMCounter
    'Check if the Material Number is not blank
    If Len(Trim(lvBOMArray(6, liArrayCounter))) > 0 Then
    
        'If Hyperlink Exists for the material
        If loHyperLinks.exists(lvBOMArray(6, liArrayCounter)) Then

            ls = "L" & (4 + liArrayCounter)

            ls2 = loHyperLinks(lvBOMArray(6, liArrayCounter))

            If Left(ls2, 10) = "HYPERLINK:" Then

                ls2 = "C" & Mid(ls2, 11)
                nsTB1.Range(ls).Hyperlinks.Add nsTB1.Range(ls), nsMasterList.Range(ls2).Hyperlinks(1).Address, , , nsMasterList.Range(ls2).Text
            
            Else
                
                ls2 = "C" & ls2
                nsTB1.Range(ls) = nsMasterList.Range(ls2)
            
            End If

        End If

    End If

Next liArrayCounter

'Set the Worksheet
Set loWorkSheet = nsPI1


 For liSheetCounter = 0 To liTotalSheet - 1
    
    'Set the Range
    'Set loRange = loWorkSheet.Range("PI_Data")
    
    'Set the Range
    lsRange = "A" & (liSheetCounter * 41 + 5) & ":K" & (liSheetCounter * 41 + 26)
    Set loRange = nsPI1.Range(lsRange)

    'Assign to the Array
    lvTempArray() = loRange
      
    'Convert from vertical to horizontal array list
    lvFinalArray = Application.Transpose(lvTempArray)
    
    For liArrayCounter = 1 To UBound(lvFinalArray, 2)

        If Len(Trim(lvFinalArray(2, liArrayCounter))) > 0 Then
    
            If loHyperLinks.exists(lvFinalArray(2, liArrayCounter)) Then
    
                ls = "H" & ((liSheetCounter * 41) + 4 + liArrayCounter)
    
                ls2 = loHyperLinks(lvFinalArray(2, liArrayCounter))
    
                If Left(ls2, 10) = "HYPERLINK:" Then
    
                    ls2 = "C" & Mid(ls2, 11)
                    nsPI1.Range(ls).Hyperlinks.Add nsPI1.Range(ls), nsMasterList.Range(ls2).Hyperlinks(1).Address, , , nsMasterList.Range(ls2).Text
                
                Else
                    
                    ls2 = "C" & ls2
                    nsPI1.Range(ls) = nsMasterList.Range(ls2)
                
                End If
    
            End If
    
        End If

    Next liArrayCounter
    
Next liSheetCounter


'Create the Cutting Tracking Sheet from loChannels
'Create an array only with the Channel type

ReDim lvCuttingArray(1 To 15, 1 To 1)

Set loHeader = CreateObject("Scripting.Dictionary")

'Sort the item designations
Call SingleSorting(lvItemDesignation)

'Set the Item Designation Number differently so that descending sort returns them ascending; This is required for BOMSort Below
For liArrayCounter = 1 To UBound(lvItemDesignation)
    
    If loItemDesignation.exists(lvItemDesignation(liArrayCounter)) = False Then
        loItemDesignation.Add lvItemDesignation(liArrayCounter), (9999 - liArrayCounter)
    End If
    
Next liArrayCounter

For liArrayCounter = 1 To liBOMCounter

    If loChannels.exists(lvBOMArray(6, liArrayCounter)) = True Then
    
        liCuttingCounter = liCuttingCounter + 1
        
        ReDim Preserve lvCuttingArray(1 To 15, 1 To liCuttingCounter)
        
        'Item Designation
        lvCuttingArray(1, liCuttingCounter) = lvBOMArray(2, liArrayCounter)
        
        'Position
        lvCuttingArray(2, liCuttingCounter) = lvBOMArray(3, liArrayCounter)
        
        'Material #
        lvCuttingArray(3, liCuttingCounter) = lvBOMArray(6, liArrayCounter)
        
        'Material Description
        lvCuttingArray(4, liCuttingCounter) = lvBOMArray(7, liArrayCounter)
        
        'Cutting Type
        lvCuttingArray(5, liCuttingCounter) = lvBOMArray(10, liArrayCounter) 'lvCuttingTypeArray(liArrayCounter)
        
        'Total Quantity
        lvCuttingArray(6, liCuttingCounter) = lvBOMArray(11, liArrayCounter)
        
        'Length
        lvCuttingArray(7, liCuttingCounter) = lvBOMArray(9, liArrayCounter) '* 1000
        
         'Sorting # for item designation
        lvCuttingArray(8, liCuttingCounter) = loItemDesignation(lvBOMArray(2, liArrayCounter))
    
        
        'Check if the header row is unique else add a header row
        lsHeader = Right("000000000000" & lvBOMArray(9, liArrayCounter), 12) & Right("000000000000" & lvBOMArray(6, liArrayCounter), 12)
        
        If loHeader.exists(lsHeader) = False Then
        
            liCounter = liCounter + 1
            
            loHeader.Add lsHeader, liCounter
            
            liCuttingCounter = liCuttingCounter + 1
            
            ReDim Preserve lvCuttingArray(1 To 15, 1 To liCuttingCounter)
            'Item Designation
            lvCuttingArray(1, liCuttingCounter) = ""
            
            'Position
            lvCuttingArray(2, liCuttingCounter) = ""
            
            'Material #
            lvCuttingArray(3, liCuttingCounter) = lvBOMArray(6, liArrayCounter)
            
            'Material Description
            lvCuttingArray(4, liCuttingCounter) = lvBOMArray(7, liArrayCounter)
            
            'Cutting Type
            lvCuttingArray(5, liCuttingCounter) = lvBOMArray(10, liArrayCounter) 'lvCuttingTypeArray(liArrayCounter)
            
            'Total Quantity
            lvCuttingArray(6, liCuttingCounter) = ""
            
            'Length
            lvCuttingArray(7, liCuttingCounter) = lvBOMArray(9, liArrayCounter) '* 1000 removed as Total BOM also is in mm now 20/Mar/2019
            
             'Sorting # for item designation
            lvCuttingArray(8, liCuttingCounter) = "9999"
            
        End If
        
    End If

Next liArrayCounter


'Sort the array
If BOMSorting(lvCuttingArray) = False Then

    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
    
End If


'Process the lvcutting array and make Summary Rows and Detailed Rows
For liArrayCounter = UBound(lvCuttingArray, 2) To 1 Step -1
    
    'Detailed rows will not have 9999
    If lvCuttingArray(8, liArrayCounter) <> "9999" Then
       
        'Add to the Material Totals
        llTotal = llTotal + lvCuttingArray(6, liArrayCounter)
        
        'Blank the detailed rows; Details shown only in the header rows
        lvCuttingArray(3, liArrayCounter) = ""
        lvCuttingArray(4, liArrayCounter) = ""
        lvCuttingArray(5, liArrayCounter) = ""
        lvCuttingArray(7, liArrayCounter) = ""
        
    Else 'Summary Row will have 9999; Assign Totals and do not clear the details
        lvCuttingArray(6, liArrayCounter) = llTotal

        llTotal = 0
    End If

Next liArrayCounter

'Convert from vertical to horizontal array list
lvTransposedArray = Application.Transpose(lvCuttingArray)

'Clear any entry in Cutting Tracking Sheet
Call CleanSheets("nsCT1", False)

'Assign the contents of the array to the Cutting Tracking sheet from cell A8
nsCT1.[A8].Resize(UBound(lvCuttingArray, 2), 7) = lvTransposedArray

lss = "A8:M" & UBound(lvCuttingArray, 2) + 8
nsCT1.Range(lss).Borders.LineStyle = xlContinuous
nsCT1.Range(lss).HorizontalAlignment = xlCenter
nsCT1.Range(lss).VerticalAlignment = xlCenter


For liArrayCounter = 1 To UBound(lvCuttingArray, 2)
    If lvCuttingArray(1, liArrayCounter) = "" Then
        'Row number is array number + 7 fixed rows
        liSummaryRow = 7 + liArrayCounter
        lss = "C" & liSummaryRow & ":G" & liSummaryRow
        nsCT1.Range(lss).Font.bold = True
        nsCT1.Range(lss).Interior.color = RGB(255, 200, 100)
    End If
Next liArrayCounter

With nsCT1.Range(lss).Interior
    .Pattern = xlSolid
End With

nsCT1.visible = xlSheetVisible
nsTB1.visible = xlSheetVisible
Call CleanSheets("nsWP1", True)
Call CleanSheets("nsDR1", True)


Call FillRequestSheet(lvCuttingArray)

'Success Message
MsgBox "Total BOM, Cutting Tracking and Input Calculator Sheets have been created successfully"


Application.ScreenUpdating = True


'All Good.  Exit the function.
Exit Sub

Failure:

'Set the settings sheet as the active sheet
nsMain.Activate

Application.ScreenUpdating = True

Exit Sub

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Sub
'
Function FillRequestSheet(pvCuttingArray() As Variant)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : FillRequestSheet
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 19-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : This function will be called in Step 2 (in both Template 1 & 2).  This
'                  : Function will update the Request Sheet (previously Input Calculator Sheet)
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim loMasterAll             As Object
Dim lvMasterAll()           As Variant
Dim liArrayCounter          As Integer
Dim liCuttingCounter        As Integer
Dim lvTransposedArray()     As Variant
Dim lvTempMaterial          As Variant
ReDim lvInputCalculator(1 To 11, 1 To 1)

'Read Master Data of the Channels from Channel Overview
Call GetMasterForInputCalc(loMasterAll, lvMasterAll)

ReDim lvInputCalculator(1 To 11, 1 To 1)
liCuttingCounter = 0

For liArrayCounter = 1 To UBound(pvCuttingArray, 2)

    If pvCuttingArray(1, liArrayCounter) = "" Then
    
        liCuttingCounter = liCuttingCounter + 1
        
        ReDim Preserve lvInputCalculator(1 To 11, 1 To liCuttingCounter)

        
        'Check if this item is present in the Master Array
        If loMasterAll.exists(pvCuttingArray(3, liArrayCounter)) = True Then
            
            'Material Number
            lvTempMaterial = loMasterAll(pvCuttingArray(3, liArrayCounter))
        
            '-------- *** The next four values come from the Channel Overview and search it using Material Number *** --------------
            'Type
            lvInputCalculator(1, liCuttingCounter) = lvMasterAll(4, lvTempMaterial)
            
            'Size
            lvInputCalculator(2, liCuttingCounter) = lvMasterAll(5, lvTempMaterial)
            
            'Extra
            lvInputCalculator(3, liCuttingCounter) = lvMasterAll(6, lvTempMaterial)
            
            'Material
            lvInputCalculator(4, liCuttingCounter) = lvMasterAll(7, lvTempMaterial)
            
            ' Cutting Type
            lvInputCalculator(5, liCuttingCounter) = pvCuttingArray(5, liArrayCounter)
            
            ' Nominal Length (mm)
            lvInputCalculator(6, liCuttingCounter) = pvCuttingArray(7, liArrayCounter)
            
            ' Qty(pcs)
            lvInputCalculator(7, liCuttingCounter) = pvCuttingArray(6, liArrayCounter)
        
        End If

    End If

Next liArrayCounter


'transpose the array to assign the array to a range
lvTransposedArray = Application.Transpose(lvInputCalculator)

Application.EnableEvents = False

'Clear any entry in Input Calculator Sheet
SheetRequest.Range("A11:I5000").ClearContents

SheetRequest.Activate

'Assign the contents of the array to the Input Calculator sheet from cell A2
SheetRequest.[A11].Resize(liCuttingCounter, 11) = lvTransposedArray

Application.EnableEvents = True


Exit Function

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear


End Function

Sub T1T2S3_StartProcess()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : T1T2S3_StartProcess
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 19-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Copy Hyperlinks from another cell
'
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler
Dim loSheet         As Worksheet
Dim loPrev          As Worksheet
Dim lsMessage       As String


If PrimaryCheck = False Then GoTo Failure

'All Checks done.  Call the function to generate WP and DR Sheets
Call Create_WP_and_DR_Sheets

'All good, exit the routine
Exit Sub

Failure:

'Set the settings sheet as the active sheet
nsMain.Activate

'Set the screen updating back to True
Application.ScreenUpdating = True

Exit Sub

Exit Sub

ErrorHandler:



End Sub
Private Function CopyFromTemplates(psSource As String, psTarget As String, Optional pbProtect As Boolean) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CopyFromTemplates
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 06-Nov-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to copy the sheet to a new sheet.
'                  : If the sheet does not exist, it throws an error
'------------------------------------------------------------------------------------------

On Error Resume Next

Dim loSheet As Worksheet

'Set the Source Sheet
Set loSheet = ActiveWorkbook.Worksheets(psSource)

'If the sheet is protected, Unprotect it
If pbProtect = True Then
    loSheet.Unprotect (SheetPassword)
End If

loSheet.visible = xlSheetVisible

'loSheet.Activate

loSheet.Copy After:=Worksheets(nsMain.index)

ActiveSheet.name = psTarget

loSheet.visible = xlSheetHidden
 
End Function
Sub Create_WP_and_DR_Sheets()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : Create_WP_and_DR_Sheets
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 01-March-2019
'VERSION           : 1.0
'DESCRIPTION       : Create Work Preparation from BOM Sheet and Output Calculator
'
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

Dim liChannelCounter        As Integer
Dim liExistingNum           As Integer
Dim liIncrement             As Integer
Dim liLastRow               As Integer
Dim liNotFoundinBOM         As Integer
Dim liNotFoundInBOMLoc      As Integer
Dim liUniqueChannel         As Integer
Dim liUniqueMaterial        As Integer
Dim liCurrentLang           As Integer
Dim liItemCount             As Integer

Dim llArrayCounter          As Long

Dim loItemTypes             As Object
Dim loMasterAll             As Object
Dim loMaterial              As Object
Dim loUniqueChannelBOM      As Object
Dim loUniqueWork            As Object

Dim loRange                 As Range
Dim Search                  As Range
Dim SearchRange             As Range
Dim Source                  As Range

Dim lsTempRange             As String
Dim lsRange                 As String
Dim lsaAddress()            As String

Dim lvaNonChannelTrans()    As Variant
Dim lvaWorkPreparation()    As Variant
Dim lvBOMArray()            As Variant
Dim lvChannelArray()        As Variant
Dim lvFinalArray()          As Variant
Dim lvMasterAll()           As Variant
Dim lvNotFoundinBOM()       As Variant
Dim lvTempArray()           As Variant
Dim myArray()               As Variant
Dim lvIFUArray()            As Variant

Dim loSheet                 As Worksheet
Dim loWorkSheet             As Worksheet
Dim lvaPackSize()           As Variant

'-------------------------------------

'Set it to failure value
llArrayCounter = 0

'Read all Master Sheet Details
llArrayCounter = GetMasterArray(loMasterAll, lvMasterAll)

'Check the success of Master Array
If llArrayCounter = -1 Then
    MsgBox "Master List Sheet is Missing!" & vbCrLf & vbCrLf & "Sheets Cannot be Created"
    GoTo Failure
    
ElseIf llArrayCounter = 0 Then

    MsgBox "Master List is empty!" & vbCrLf & vbCrLf & "Sheets Cannot be Created"
    GoTo Failure
End If

'Set it to failure value
llArrayCounter = 0

'Read the PI_Table for the PI Sheets (for Delivery Release Sheet)
llArrayCounter = GetTableInfoFromSettings(myArray, True)

'If Table in Settings Sheet has issues, show message and exit
If llArrayCounter = -1 Then
    MsgBox "Please enter the Production & Inspection Sheet details" & vbCrLf & vbCrLf & "The PI Sheet details must be entered in the table"
    GoTo Failure
ElseIf llArrayCounter = -2 Then
    MsgBox "All fields in the Production & Inspection Sheet Table are mandatory. " & vbCrLf & vbCrLf & _
    "An entire row in the table can be left blank but if one cell is filled, all the cells in that row must be filled."
    GoTo Failure
ElseIf llArrayCounter = 0 Then
    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
End If

'Set the Range
Set loRange = nsTB1.Range("$A$5:$L$4098")

'Assign to the Array
lvTempArray() = loRange
      
'Convert from vertical to horizontal array list
lvBOMArray = Application.Transpose(lvTempArray)


'Erase the temp array
Erase lvTempArray

'Dictionary object holds all the unique entries from Total BOM sheet
Set loUniqueWork = CreateObject("Scripting.Dictionary")
Set loUniqueChannelBOM = CreateObject("Scripting.Dictionary")

'Loop through the items in the lvFinalarray (BOM items),
For llArrayCounter = LBound(lvBOMArray, 2) To UBound(lvBOMArray, 2)

    'Second array element is the name of the item, which cannot be blank
    If Len(Trim(lvBOMArray(2, llArrayCounter))) > 0 Then
        
        'Check if this item is present in the Master Array
        If loMasterAll.exists(lvBOMArray(6, llArrayCounter)) = True Then
            
            'If lvBOMArray(6, llArrayCounter) = "369623" Then Stop
            'Channel Type come from calculator, so do not add that to the list, all non-channel types are added to the array from BOM Sheet
            If UCase(Trim(lvMasterAll(4, loMasterAll(lvBOMArray(6, llArrayCounter))))) <> "CHANNEL" Then
            
                If loUniqueWork.exists(lvBOMArray(1, llArrayCounter) & "--" & lvBOMArray(6, llArrayCounter)) = True Then
                    
                    liExistingNum = CInt(loUniqueWork(lvBOMArray(1, llArrayCounter) & "--" & lvBOMArray(6, llArrayCounter)))
                    
                    lvaWorkPreparation(5, liExistingNum) = lvaWorkPreparation(5, liExistingNum) + lvBOMArray(11, llArrayCounter)
                    
                    'lvaWorkPreparation(6, liExistingNum) = lvaWorkPreparation(6, liExistingNum) + Int(lvBOMArray(11, llArrayCounter) / lvMasterAll(6, loMasterAll(lvBOMArray(6, llArrayCounter))) + 0.99999999)
                    lvaWorkPreparation(6, liExistingNum) = lvaWorkPreparation(6, liExistingNum) + lvBOMArray(11, llArrayCounter)
                Else
                    liUniqueMaterial = liUniqueMaterial + 1
                    
                    loUniqueWork.Add (lvBOMArray(1, llArrayCounter) & "--" & lvBOMArray(6, llArrayCounter)), liUniqueMaterial
                    
                    ReDim Preserve lvaWorkPreparation(1 To 7, 1 To liUniqueMaterial)
                    ReDim Preserve lvaPackSize(1 To liUniqueMaterial)
                    'Batch #
                    lvaWorkPreparation(1, liUniqueMaterial) = lvBOMArray(1, llArrayCounter)
                    'Material #
                    lvaWorkPreparation(2, liUniqueMaterial) = lvBOMArray(6, llArrayCounter)
                    'Material Description
                    lvaWorkPreparation(3, liUniqueMaterial) = lvBOMArray(7, llArrayCounter)
                    'Item Type
                    lvaWorkPreparation(4, liUniqueMaterial) = lvMasterAll(4, loMasterAll(lvBOMArray(6, llArrayCounter)))
                    'Total Qty
                    lvaWorkPreparation(5, liUniqueMaterial) = lvBOMArray(11, llArrayCounter)
                    'Qty (Packets)
                    lvaWorkPreparation(6, liUniqueMaterial) = lvBOMArray(11, llArrayCounter)
                    lvaPackSize(liUniqueMaterial) = lvMasterAll(6, loMasterAll(lvBOMArray(6, llArrayCounter)))
                    'Total Length
                    lvaWorkPreparation(7, liUniqueMaterial) = ""
                    
                End If
            Else 'Channel Type add to the BOM Channels Dictionary
            
                If loUniqueChannelBOM.exists(lvBOMArray(6, llArrayCounter)) = False Then
                    liUniqueChannel = liUniqueChannel + 1
                    loUniqueChannelBOM.Add (lvBOMArray(6, llArrayCounter)), liUniqueChannel
                End If

            End If
        End If
    Else
        
        Exit For
    End If
Next llArrayCounter


For llArrayCounter = 1 To liUniqueMaterial

    lvaWorkPreparation(6, llArrayCounter) = Int(lvaWorkPreparation(6, llArrayCounter) / lvaPackSize(llArrayCounter) + 0.99999999)

Next llArrayCounter

If liUniqueChannel = 0 And liUniqueMaterial = 0 Then
    MsgBox "The Total BOM Sheet is either empty or not proper.  Please Check."
    GoTo Failure
End If

Call Multisort(lvaWorkPreparation, 1, 2, True)



Erase lvFinalArray

'----------------------------------------------------------------
' Read Output Lists for Channel type items
lsRange = "B10:D100"

'Assign to the Array
lvTempArray() = SheetOutputLists.Range(lsRange)

'Loop through the items in the lvFinalarray (BOM items),
For llArrayCounter = LBound(lvTempArray, 1) To UBound(lvTempArray, 1)

        If lvTempArray(llArrayCounter, 1) <> "" Then
        
            If loUniqueChannelBOM.exists(lvTempArray(llArrayCounter, 1)) = True Then
        
                liUniqueMaterial = liUniqueMaterial + 1
                            
                ReDim Preserve lvaWorkPreparation(1 To 7, 1 To liUniqueMaterial)
                
                lvaWorkPreparation(2, liUniqueMaterial) = lvTempArray(llArrayCounter, 1)
                
                lvaWorkPreparation(3, liUniqueMaterial) = lvMasterAll(2, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvaWorkPreparation(4, liUniqueMaterial) = lvMasterAll(4, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvaWorkPreparation(5, liUniqueMaterial) = lvTempArray(llArrayCounter, 2)
                
                lvaWorkPreparation(7, liUniqueMaterial) = lvTempArray(llArrayCounter, 2) * lvMasterAll(5, loMasterAll(lvTempArray(llArrayCounter, 1)))
            Else
                liNotFoundinBOM = liNotFoundinBOM + 1
                            
                ReDim Preserve lvNotFoundinBOM(1 To 7, 1 To liNotFoundinBOM)
                
                lvNotFoundinBOM(2, liNotFoundinBOM) = lvTempArray(llArrayCounter, 1)
                
                lvNotFoundinBOM(3, liNotFoundinBOM) = lvMasterAll(2, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvNotFoundinBOM(4, liNotFoundinBOM) = lvMasterAll(4, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvNotFoundinBOM(5, liNotFoundinBOM) = lvTempArray(llArrayCounter, 2)
                
                lvNotFoundinBOM(7, liNotFoundinBOM) = lvTempArray(llArrayCounter, 2) * lvMasterAll(5, loMasterAll(lvTempArray(llArrayCounter, 1)))
            
            End If
        
        Else
            Exit For
        End If
        
Next llArrayCounter


'Add to the end
If liNotFoundinBOM > 0 Then
    
        liUniqueMaterial = liUniqueMaterial + 1
        
        liNotFoundInBOMLoc = liUniqueMaterial + 6
                                    
        ReDim Preserve lvaWorkPreparation(1 To 7, 1 To liUniqueMaterial)
        
        lvaWorkPreparation(1, liUniqueMaterial) = "NOT IN ORIGINAL BOM, BUT RESULT OF THE CALCULATOR"
        
    
    For llArrayCounter = 1 To liNotFoundinBOM
    
        liUniqueMaterial = liUniqueMaterial + 1
                                    
        ReDim Preserve lvaWorkPreparation(1 To 7, 1 To liUniqueMaterial)
        
        lvaWorkPreparation(2, liUniqueMaterial) = lvNotFoundinBOM(2, llArrayCounter)
        
        lvaWorkPreparation(3, liUniqueMaterial) = lvNotFoundinBOM(3, llArrayCounter)
        
        lvaWorkPreparation(4, liUniqueMaterial) = lvNotFoundinBOM(4, llArrayCounter)
        
        lvaWorkPreparation(5, liUniqueMaterial) = lvNotFoundinBOM(5, llArrayCounter)
        
        lvaWorkPreparation(7, liUniqueMaterial) = lvNotFoundinBOM(7, llArrayCounter)
        
    Next llArrayCounter


End If

'Set the screen update to false to avoid screen blinking
Application.ScreenUpdating = False

If liUniqueMaterial < 25 Then
    liLastRow = 25
Else
    liLastRow = liUniqueMaterial
End If

nsWP1.Range("5:500").EntireRow.Hidden = False
nsWP1.Range("A7:M500") = ""

'-------------------------------------------------------------------------------------

'Transpose the array list
lvaNonChannelTrans = Application.Transpose(lvaWorkPreparation)

'Assign the contents of the array and to the cells
nsWP1.[A7].Resize(liUniqueMaterial, 7) = lvaNonChannelTrans

If liNotFoundInBOMLoc > 0 Then
    lsRange = "A" & liNotFoundInBOMLoc
    nsWP1.Range(lsRange).Font.color = vbRed
    nsWP1.Range(lsRange).Font.bold = True
End If

nsWP1.Range("A" & liLastRow + 7 & ":A500").EntireRow.Hidden = True

'--------------------- DR Sheet -------------------

'Set the worksheet to PI
Set loSheet = nsDR1

'Clear the Cells
loSheet.Range("5:504").EntireRow.Hidden = False
loSheet.Range("A5:F504").Hyperlinks.Delete
loSheet.Range("A5:F504") = ""
        
        
liIncrement = 4
liItemCount = UBound(myArray, 2)

For llArrayCounter = 1 To liItemCount
    
    'Check if the P & I Item Number is not blank
    If Len(Trim(myArray(3, llArrayCounter))) > 0 Then
    
       liIncrement = liIncrement + 1
       
       lsRange = "A" & liIncrement
       loSheet.Range(lsRange) = myArray(3, llArrayCounter)
      
        lsRange = "B" & liIncrement
        loSheet.Range(lsRange) = myArray(4, llArrayCounter)
        
        lsRange = "C" & liIncrement
        loSheet.Range(lsRange) = myArray(6, llArrayCounter)
        
    End If
    
Next llArrayCounter

'Erase the array to be used in BOM Links
Erase myArray

'Set the IFUs from BOM
'Clear the Cells
If GetBOMLinks(lvIFUArray) = -1 Then
    
    For llArrayCounter = 1 To UBound(lvIFUArray, 2)
    
        lsTempRange = "E" & llArrayCounter + 4
        loSheet.Range(lsTempRange).Hyperlinks.Add loSheet.Range(lsTempRange), nsTB1.Range(lvIFUArray(1, llArrayCounter)).Hyperlinks(1).Address, , , nsTB1.Range(lvIFUArray(1, llArrayCounter)).Text & " (" & lvIFUArray(2, llArrayCounter) & ")"

    Next llArrayCounter
    
End If

If liItemCount > 30 Then
    loSheet.Range("A" & liItemCount + 5 & ":A504").EntireRow.Hidden = True
Else
    loSheet.Range("A35:A504").EntireRow.Hidden = True
End If

Call GetSheetAddressAllLanguages(lsaAddress)

'Get the selected Language
liCurrentLang = GetLanguageIndex(nsMain.Range("B1").Text)

'Set the Translated sheet names for the newly created sheets
nsDR1.name = TranslateSheetName(lsaAddress, "nsDR1", liCurrentLang)
nsWP1.name = TranslateSheetName(lsaAddress, "nsWP1", liCurrentLang)
nsPI1.name = TranslateSheetName(lsaAddress, "nsPI1", liCurrentLang)

'ActiveWorkbook.Sheets(nsWP1.name).Activate
'ActiveSheet.Range("A2").Select

Worksheets(nsDR1.name).visible = xlSheetVisible
Worksheets(nsWP1.name).visible = xlSheetVisible

'Show success message
MsgBox "Work Preparation and Delivery Release Sheets have been created successfully"

'Reset the screen updating back
Application.ScreenUpdating = True

''Set the settings sheet as the active sheet
'ActiveWorkbook.Sheets(nsMain.name).Activate

'All good, exit the routine
Exit Sub

Failure:

'Set the settings sheet as the active sheet
ActiveWorkbook.Sheets(nsMain.name).Activate

'Set the screen updating back to True
Application.ScreenUpdating = True

Exit Sub

ErrorHandler:

'Turn on ScreenUpdating
Application.ScreenUpdating = True

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear


End Sub
'Sub CreateDeliveryReleaseSheet()
''------------------------------------------------------------------------------------------
''PROCEDURE NAME    : CreateDeliveryReleaseSheet
''DEVELOPER'S NAME  : Jagannathan Srinivasamurthy
''DATE OF CREATION  : 14-Feb-2019
''VERSION           : 1.0
''DESCRIPTION       : Create Delivery Release Sheet from Setting Sheet and BOM
''
''------------------------------------------------------------------------------------------
'On Error GoTo ErrorHandler
'
'Dim myArray() As Variant
'Dim liCounter As Long
'Dim lsSheetName As String
'Dim loSheet As Worksheet
'Dim lvDeliveryRelease() As Variant
'Dim liIncrement As Integer
'Dim lsRange As String
'
''----------------------------
'Application.ScreenUpdating = False
'
'If WorkSheetExists("Delivery Release") = False Then
'
'    If WorkSheetExists("DR") = True Then
'
'        'Set the worksheet to PI
'        Set loSheet = ActiveWorkbook.Sheets("DR")
'
'        loSheet.Visible = xlSheetVisible
'
'        'Copy the sheet after the active sheet
'        loSheet.Copy After:=ActiveWorkbook.Sheets(gsWorkPreparationSheet)
'
'        'set the copied sheet as the active sheet
'        ActiveSheet.Name = "Delivery Release"
'
'        ActiveSheet.Unprotect (SheetPassword)
'
'        loSheet.Visible = xlSheetHidden
'
'
'    Else
'        MsgBox "Delivery Release { DR } Template is Missing" & vbCrLf & vbCrLf & "Delivery Release Sheet cannot be created"
'
'        'Set the settings sheet as the active sheet
'        ActiveWorkbook.Sheets(gsMainSheet).Activate
'
'        Application.ScreenUpdating = True
'
'        Exit Sub
'    End If
'
'End If
'
'
'
''Read the PI_Table for the PI Sheets
'If GetTableInfoFromSettings(myArray) = False Then
'    Exit Sub
'End If
'
''Set the worksheet to PI
'Set loSheet = ActiveWorkbook.Sheets("Delivery Release")
'
''Clear the Cells
'loSheet.Range("A5:G30") = ""
'
'liIncrement = 4
'
'' Loop through all the pages and if not exists, create them
'For liCounter = 1 To UBound(myArray, 2)
'
'    'Check if the P & I Item Number is not blank
'    If Len(Trim(myArray(2, liCounter))) > 0 Then
'
'       liIncrement = liIncrement + 1
'
'       lsRange = "A" & liIncrement
'       loSheet.Range(lsRange) = myArray(2, liCounter)
'
'        lsRange = "C" & liIncrement
'        loSheet.Range(lsRange) = myArray(3, liCounter)
'
'        lsRange = "E" & liIncrement
'        loSheet.Range(lsRange) = myArray(5, liCounter)
'
'    End If
'
'Next liCounter
'
'Erase myArray
'
'
''Set the IFUs from BOM
''Clear the Cells
'loSheet.Range("H5:K30") = ""
'
'Call GetBOMLinks(myArray)
'
'loSheet.Range("I5:K30") = myArray
'
'
''Set the settings sheet as the active sheet
'ActiveWorkbook.Sheets(gsMainSheet).Activate
'
''Set the Screen Updating
'Application.ScreenUpdating = True
'
''All good. Exit
'Exit Sub
'
'ErrorHandler:
'
''Set the Screen Updating
'Application.ScreenUpdating = True
'
''Call Error Message
'Call DisplayError(Err)
'
''Clear the error object
'Err.Clear
'
'End Sub
'''Function CreateSheetNames(pvSheetNames As Variant) As Integer
''''------------------------------------------------------------------------------------------
''''   PROCEDURE NAME    : CreateSheetNames
''''   DEVELOPER'S NAME  : JS
''''   DATE OF CREATION  : 18-Feb-2019
''''   VERSION           : 1.0
''''   DESCRIPTION       : Reads the settings from the settings sheet using GetTableInfoFromSettings
''''                     : then creates the actual sheet names from the "Item".  Sheetname is PI-X(where x is item)
''''
''''------------------------------------------------------------------------------------------
'''On Error GoTo ErrorHandler
'''
'''Dim lvSettingsArray() As Variant
'''Dim liCounter As Integer
'''
'''
''''Populate the array with the Table! Data from the settings worksheet
'''liCounter = GetTableInfoFromSettings(lvSettingsArray)
'''
'''If liCounter = -1 Then
'''    CreateSheetNames = -1
'''    Exit Function
'''End If
'''
''''loop through all the table entries where item is non-blank, exits the loop at the first blank
'''For liCounter = 1 To UBound(lvSettingsArray, 2)
'''
'''    If Len(Trim(lvSettingsArray(2, liCounter))) > 0 Then
'''        'Redimension the array
'''        ReDim Preserve pvSheetNames(1 To liCounter)
'''        'format the name and assign to the array
'''        pvSheetNames(liCounter) = "PI-" & lvSettingsArray(2, liCounter)
'''    Else
'''        Exit For
'''    End If
'''
'''Next liCounter
'''
'''CreateSheetNames = 1
''''All good, exit the routine
'''Exit Function
'''
'''ErrorHandler:
'''
''''Call Error Message
'''Call DisplayError(Err)
'''
''''Clear the error object
'''Err.Clear
'''
'''CreateSheetNames = 0
'''End Function
Function GetMasterObjects(poHyperlinks As Object, poChannels As Object) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetMasterObjects
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 19-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Copy Hyperlinks from another cell
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim rngHyperlinks As Range
Dim rngMaterialNumber As Range
Dim rngItemType As Range

Dim wksht As Worksheet
Dim liCounter As Integer

'Create Array List from Table

If WorkSheetExists(gsMasterListSheet) = False Then
    GetMasterObjects = -1
    Exit Function
End If


Set wksht = Worksheets(gsMasterListSheet)
Set rngMaterialNumber = wksht.Range("A2:A5000")
Set rngHyperlinks = wksht.Range("C2:C5000")
Set rngItemType = wksht.Range("D2:D5000")

Set poHyperlinks = CreateObject("Scripting.Dictionary")

Set poChannels = CreateObject("Scripting.Dictionary")



For liCounter = 1 To 4999
    
    If Len(Trim(rngMaterialNumber(liCounter).value)) > 0 Then
    
        If poHyperlinks.exists(rngMaterialNumber(liCounter).value) = False Then
            If rngHyperlinks(liCounter).Hyperlinks.count > 0 Then
                poHyperlinks.Add (rngMaterialNumber(liCounter).value), "HYPERLINK:" & liCounter + 1
            Else
                poHyperlinks.Add (rngMaterialNumber(liCounter).value), (liCounter + 1)
            End If
        End If
        
        If UCase(rngItemType(liCounter)) = "CHANNEL" Then
        
            If poChannels.exists(rngMaterialNumber(liCounter).value) = False Then
            
                poChannels.Add (rngMaterialNumber(liCounter).value), (liCounter + 1)
                
            End If
        
        End If
    End If
Next liCounter

GetMasterObjects = 1

Exit Function
ErrorHandler:

GetMasterObjects = 0

'Set the Screen Updating
Application.ScreenUpdating = True

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Function GetMasterObjectsforPISheets(poMaterials As Object) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetMasterObjects
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 19-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Copy Hyperlinks from another cell
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim rngDescriptions As Range
Dim rngMaterialNumber As Range


Dim wksht As Worksheet
Dim liCounter As Integer

'Create Array List from Table

If WorkSheetExists(gsMasterListSheet) = False Then
    GetMasterObjectsforPISheets = -1
    Exit Function
End If

Set wksht = Worksheets(gsMasterListSheet)
Set rngMaterialNumber = wksht.Range("A2:A5000")
Set rngDescriptions = wksht.Range("B2:B5000")


Set poMaterials = CreateObject("Scripting.Dictionary")


For liCounter = 1 To 4999
    
    If Len(Trim(rngMaterialNumber(liCounter).value)) > 0 Then
    
        If poMaterials.exists(rngMaterialNumber(liCounter).value) = False Then
            poMaterials.Add (rngMaterialNumber(liCounter).value), rngDescriptions(liCounter).value
        End If
        
    End If
    
Next liCounter

GetMasterObjectsforPISheets = 1

Exit Function
ErrorHandler:

GetMasterObjectsforPISheets = 0

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

Function GetMasterArray(poMaster As Object, poMasterArray() As Variant) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetMasterArray
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 02-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Get all the Master Data in an array and poMaster object to get the array index given material number
'Trans OK
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler


Dim liCounter As Integer
Dim lvMasterAll() As Variant
Dim liIncrement As Integer


lvMasterAll = nsMasterList.Range("A1:F10000")

Set poMaster = CreateObject("Scripting.Dictionary")

ReDim poMasterArray(1 To 6, 1 To 1)

For liCounter = 2 To 10000

    If Len(Trim(lvMasterAll(liCounter, 1))) > 0 Then
    
        If poMaster.exists(lvMasterAll(liCounter, 1)) = False Then
        
        
            liIncrement = liIncrement + 1
            
            poMaster.Add lvMasterAll(liCounter, 1), liIncrement
            
            ReDim Preserve poMasterArray(1 To 6, 1 To liIncrement)
            
            poMasterArray(1, liIncrement) = lvMasterAll(liCounter, 1)
            poMasterArray(2, liIncrement) = lvMasterAll(liCounter, 2)
            poMasterArray(3, liIncrement) = lvMasterAll(liCounter, 3)
            poMasterArray(4, liIncrement) = lvMasterAll(liCounter, 4)
            poMasterArray(5, liIncrement) = lvMasterAll(liCounter, 5)
            poMasterArray(6, liIncrement) = lvMasterAll(liCounter, 6)
        End If
        
    Else
    
        Exit For
    
    End If

Next liCounter

If liIncrement = 0 Then
    GetMasterArray = 0
Else
    GetMasterArray = 1
End If


Exit Function
ErrorHandler:

GetMasterArray = 0

'Set the Screen Updating
Application.ScreenUpdating = True

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

 Function BOMSorting(psaBOM() As Variant, Optional piCustom As Integer, Optional piAsc As Boolean) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : BOMSorting
'DEVELOPER'S NAME  : Jagannathan Srinivasamurthy
'DATE OF CREATION  : 28-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Sorting BOM Array Descending by Length, Material Number and then Designation
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim liFirst As Integer      'For loop
Dim liSecond As Integer     'For loop
Dim liThird As Integer      'For loop
Dim liOuter As Integer
Dim liInner As Integer
Dim lsTemp As Variant   'For Swapping the string
Dim lsaSort() As String 'Array for sorting
ReDim lsaSort(1 To UBound(psaBOM(), 2))

'Get the number of array elements into an array
liOuter = UBound(psaBOM(), 2)
liInner = UBound(psaBOM(), 1)

If piCustom = 0 Then
    'Making of Array for sorting, concatenate length (format with 0000), material number and then Item Designation
    For liFirst = 1 To liOuter
        lsaSort(liFirst) = Right("000000000000" & psaBOM(7, liFirst), 12) & Right("000000000000" & psaBOM(3, liFirst), 12) & Right("0000" & psaBOM(8, liFirst), 4)
    Next liFirst
ElseIf piCustom = 1 Then
    For liFirst = 1 To liOuter
        lsaSort(liFirst) = psaBOM(2, liFirst)
    Next liFirst
End If


'Sorts the array by Bubble Sort
If piAsc = True Then
    For liFirst = 1 To liOuter - 1
        For liSecond = liFirst + 1 To liOuter
        
            If UCase(lsaSort(liFirst)) > UCase(lsaSort(liSecond)) Then
            
                'Swapping the Array Contents for Array for Sorting
                lsTemp = lsaSort(liSecond)
                lsaSort(liSecond) = lsaSort(liFirst)
                lsaSort(liFirst) = lsTemp
                
                'Actual array Swapping
                For liThird = 1 To liInner
                    lsTemp = psaBOM(liThird, liSecond)
                    psaBOM(liThird, liSecond) = psaBOM(liThird, liFirst)
                    psaBOM(liThird, liFirst) = lsTemp
                Next liThird
            End If
        Next liSecond
    Next liFirst
Else 'Descending Sort
    For liFirst = 1 To liOuter - 1
        For liSecond = liFirst + 1 To liOuter
        
            If UCase(lsaSort(liFirst)) < UCase(lsaSort(liSecond)) Then
            
                'Swapping the Array Contents for Array for Sorting
                lsTemp = lsaSort(liSecond)
                lsaSort(liSecond) = lsaSort(liFirst)
                lsaSort(liFirst) = lsTemp
                
                'Actual array Swapping
                For liThird = 1 To liInner
                    lsTemp = psaBOM(liThird, liSecond)
                    psaBOM(liThird, liSecond) = psaBOM(liThird, liFirst)
                    psaBOM(liThird, liFirst) = lsTemp
                Next liThird
            End If
        Next liSecond
    Next liFirst
End If

'''Sorts the array by Bubble Sort
''For liFirst = 1 To liOuter - 1
''    For liSecond = 1 To liOuter - 1
''        If UCase(lsaSort(liSecond)) >= _
''               UCase(lsaSort(liSecond + 1)) Then
''            GoTo LOOP2
''        Else
''            'Swapping the Array Contents for Array for Sorting
''            lsTemp = lsaSort(liSecond)
''            lsaSort(liSecond) = lsaSort(liSecond + 1)
''            lsaSort(liSecond + 1) = lsTemp
''
''            'Actual array Swapping
''            For liThird = 1 To liInner
''                lsTemp = psaBOM(liThird, liSecond)
''                psaBOM(liThird, liSecond) = _
''                              psaBOM(liThird, liSecond + 1)
''                psaBOM(liThird, liSecond + 1) = lsTemp
''            Next liThird
''
''        End If
''LOOP2:
''    Next liSecond
''Next liFirst


BOMSorting = True
Exit Function

ErrorHandler:
BOMSorting = False

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear
End Function
 Function Multisort(psaBOM() As Variant, piFirstCol As Integer, piSecondCol As Integer, Optional piAsc As Boolean) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : BOMSorting
'DEVELOPER'S NAME  : Jagannathan Srinivasamurthy
'DATE OF CREATION  : 28-Feb-2019
'VERSION           : 1.0
'DESCRIPTION       : Sorting BOM Array Descending by Length, Material Number and then Designation
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim liFirst As Integer      'For loop
Dim liSecond As Integer     'For loop
Dim liThird As Integer      'For loop
Dim liOuter As Integer
Dim liInner As Integer
Dim lsTemp As Variant   'For Swapping the string
Dim lsaSort() As String 'Array for sorting
ReDim lsaSort(1 To UBound(psaBOM(), 2))

'Get the number of array elements into an array
liOuter = UBound(psaBOM(), 2)
liInner = UBound(psaBOM(), 1)

For liFirst = 1 To liOuter
    lsaSort(liFirst) = Right("000" & Trim(psaBOM(piFirstCol, liFirst)), 3) & Right("0000000000" & Trim(psaBOM(piSecondCol, liFirst)), 10)
Next liFirst

'Sorts the array by Bubble Sort
If piAsc = True Then
    For liFirst = 1 To liOuter - 1
        For liSecond = liFirst + 1 To liOuter
        
            If lsaSort(liFirst) > lsaSort(liSecond) Then
            
                'Swapping the Array Contents for Array for Sorting
                lsTemp = lsaSort(liSecond)
                lsaSort(liSecond) = lsaSort(liFirst)
                lsaSort(liFirst) = lsTemp
                
                'Actual array Swapping
                For liThird = 1 To liInner
                    lsTemp = psaBOM(liThird, liSecond)
                    psaBOM(liThird, liSecond) = psaBOM(liThird, liFirst)
                    psaBOM(liThird, liFirst) = lsTemp
                Next liThird
            End If
        Next liSecond
    Next liFirst
Else 'Descending Sort
    For liFirst = 1 To liOuter - 1
        For liSecond = liFirst + 1 To liOuter
        
            If UCase(lsaSort(liFirst)) < UCase(lsaSort(liSecond)) Then
            
                'Swapping the Array Contents for Array for Sorting
                lsTemp = lsaSort(liSecond)
                lsaSort(liSecond) = lsaSort(liFirst)
                lsaSort(liFirst) = lsTemp
                
                'Actual array Swapping
                For liThird = 1 To liInner
                    lsTemp = psaBOM(liThird, liSecond)
                    psaBOM(liThird, liSecond) = psaBOM(liThird, liFirst)
                    psaBOM(liThird, liFirst) = lsTemp
                Next liThird
            End If
        Next liSecond
    Next liFirst
End If

'''Sorts the array by Bubble Sort
''For liFirst = 1 To liOuter - 1
''    For liSecond = 1 To liOuter - 1
''        If UCase(lsaSort(liSecond)) >= _
''               UCase(lsaSort(liSecond + 1)) Then
''            GoTo LOOP2
''        Else
''            'Swapping the Array Contents for Array for Sorting
''            lsTemp = lsaSort(liSecond)
''            lsaSort(liSecond) = lsaSort(liSecond + 1)
''            lsaSort(liSecond + 1) = lsTemp
''
''            'Actual array Swapping
''            For liThird = 1 To liInner
''                lsTemp = psaBOM(liThird, liSecond)
''                psaBOM(liThird, liSecond) = _
''                              psaBOM(liThird, liSecond + 1)
''                psaBOM(liThird, liSecond + 1) = lsTemp
''            Next liThird
''
''        End If
''LOOP2:
''    Next liSecond
''Next liFirst


Multisort = True
Exit Function

ErrorHandler:
Multisort = False

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear
End Function
Sub SingleSorting(psaSingleDimensionArray() As Variant)
'********************************************************************************************
'*  PROCEDURE NAME        :  Sorting
'*  DEVELOPER'S NAME      :  S.JAGANNATH
'*  VERSION               :  1.0
'*  DESCRIPTION           :  sorts the data in 4 ways
'*  DATE OF CREATION      :  16th july 1999
'********************************************************************************************

Dim liFirstCounter As Integer      'For loop
Dim liSecondCounter As Integer     'For loop
Dim lsTemporaryStorage As Variant   'For Swapping the string


'Sorts the array by Bubble Sort
For liFirstCounter = 1 To UBound(psaSingleDimensionArray()) - 1
    For liSecondCounter = 1 To UBound(psaSingleDimensionArray()) - 1
        If UCase(psaSingleDimensionArray(liSecondCounter)) <= _
               UCase(psaSingleDimensionArray(liSecondCounter + 1)) Then
            GoTo LOOP2
        Else
            lsTemporaryStorage = psaSingleDimensionArray(liSecondCounter)
            psaSingleDimensionArray(liSecondCounter) = psaSingleDimensionArray(liSecondCounter + 1)
            psaSingleDimensionArray(liSecondCounter + 1) = lsTemporaryStorage
        End If
LOOP2:
    Next liSecondCounter
Next liFirstCounter
End Sub
Function GetBOMLinks(psaBOMLinks() As Variant) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetBOMLinks
'DEVELOPER'S NAME  : Jagannathan Srinivasamurthy
'DATE OF CREATION  : 02-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Get all unique IFU links from BOM Sheet
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim lvArray() As Variant
Dim lvmaterial() As Variant

Dim loWorkSheet As Worksheet
Dim loHyperLinks As Object
Dim liCounter As Integer
Dim liIncrement As Integer

'Create Array List from Table
Set loWorkSheet = nsTB1
lvArray = loWorkSheet.Range("L1:L5000")
lvmaterial = loWorkSheet.Range("B1:B5000")
Set loHyperLinks = CreateObject("Scripting.Dictionary")


For liCounter = 5 To 5000
    
    If liIncrement = 25 Then Exit For
    
    If Len(Trim(lvmaterial(liCounter, 1))) > 0 Then
        If Len(Trim(lvArray(liCounter, 1))) > 0 Then
            If loHyperLinks.exists(lvArray(liCounter, 1)) = False Then
                liIncrement = liIncrement + 1
                loHyperLinks.Add lvArray(liCounter, 1), liIncrement
                ReDim Preserve psaBOMLinks(1 To 2, 1 To liIncrement)
                psaBOMLinks(1, liIncrement) = "L" & liCounter
                psaBOMLinks(2, liIncrement) = 1
            Else
                psaBOMLinks(2, loHyperLinks(lvArray(liCounter, 1))) = psaBOMLinks(2, loHyperLinks(lvArray(liCounter, 1))) + 1
            End If
    
        End If
    Else
        Exit For
    End If
Next liCounter

If liIncrement > 0 Then
    GetBOMLinks = -1
Else
    GetBOMLinks = 0
End If

Exit Function
ErrorHandler:

GetBOMLinks = 0

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

Public Function CheckStructure() As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CheckStructure
'DEVELOPER'S NAME  : Jagannathan Srinivasamurthy
'DATE OF CREATION  : 02-Mar-2019
'VERSION           : 1.0
'DESCRIPTION       : Check if the structure of the excel is intact
'
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim objSheet As Worksheet
Dim liSheetCount As Integer

'Resume next on error to trap the error
On Error GoTo ErrorHandler

Dim ws As Worksheet

CheckStructure = False

For Each ws In Worksheets
    Select Case UCase(Trim(ws.CodeName))
        Case "NSCT"
            liSheetCount = liSheetCount + 1
        Case "NSDR"
            liSheetCount = liSheetCount + 1
        Case "NSMAIN"
            liSheetCount = liSheetCount + 1
        Case "NSMASTERLIST"
            liSheetCount = liSheetCount + 1
        Case "NSPI"
            liSheetCount = liSheetCount + 1
        Case "NSSTART"
            liSheetCount = liSheetCount + 1
        Case "NSTB"
            liSheetCount = liSheetCount + 1
        Case "NSTRANSMAP"
            liSheetCount = liSheetCount + 1
        Case "NSWP"
            liSheetCount = liSheetCount + 1
        Case "SHEETCHANNELOVERVIEW"
            liSheetCount = liSheetCount + 1
        Case "SHEETCHANNELTYPESINCH"
            liSheetCount = liSheetCount + 1
        Case "SHEETCHANNELTYPESMM"
            liSheetCount = liSheetCount + 1
        Case "SHEETCOUNTRIES"
            liSheetCount = liSheetCount + 1
        Case "SHEETCUTTINGPATTERN"
            liSheetCount = liSheetCount + 1
        Case "SHEETDIAGRAMS"
            liSheetCount = liSheetCount + 1
        Case "SHEETHOWTOUSE"
            liSheetCount = liSheetCount + 1
        Case "SHEETIMAGES"
            liSheetCount = liSheetCount + 1
        Case "SHEETOUTPUTLISTS"
            liSheetCount = liSheetCount + 1
        Case "SHEETPROFILESALL"
            liSheetCount = liSheetCount + 1
        Case "SHEETPROFILESUNIQUE"
            liSheetCount = liSheetCount + 1
        Case "SHEETREQUEST"
            liSheetCount = liSheetCount + 1
        Case "SHEETREQUESTEDALL"
            liSheetCount = liSheetCount + 1
        Case "SHEETREQUESTEDUNIQUE"
            liSheetCount = liSheetCount + 1
        Case "SHEETSETTINGS"
            liSheetCount = liSheetCount + 1
        Case "SHEETTECHNICALDATAINCH"
            liSheetCount = liSheetCount + 1
        Case "SHEETTECHNICALDATAMM"
            liSheetCount = liSheetCount + 1
        Case "SHEETTRANSLATIONS"
            liSheetCount = liSheetCount + 1
    
    End Select
Next ws
'If all sheets are there then the liSheetCount will be 27
If liSheetCount = 27 Then
    CheckStructure = True
Else
    CheckStructure = False
End If

Exit Function

ErrorHandler:

CheckStructure = False

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Function GetMasterForInputCalc(poMaster As Object, poMasterArray() As Variant) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetMasterArray
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 02-Mar-2019
'VERSION           : 2.0
'DESCRIPTION       : Get all the Master Data in an array and poMaster object to get the array index given material number
'
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler


Dim liCounter As Integer
Dim lvMasterAll() As Variant
Dim liIncrement As Integer


lvMasterAll = SheetChannelOverview.Range("A8:G5000")

Set poMaster = CreateObject("Scripting.Dictionary")

ReDim poMasterArray(1 To 7, 1 To 1)

For liCounter = 8 To 5000
    If Len(Trim(lvMasterAll(liCounter, 1))) > 0 Then
    
        If poMaster.exists(lvMasterAll(liCounter, 2)) = False Then
        
        
            liIncrement = liIncrement + 1
            
            poMaster.Add lvMasterAll(liCounter, 2), liIncrement
            ReDim Preserve poMasterArray(1 To 7, 1 To liIncrement)
            poMasterArray(1, liIncrement) = lvMasterAll(liCounter, 1)
            poMasterArray(2, liIncrement) = lvMasterAll(liCounter, 2)
            poMasterArray(3, liIncrement) = lvMasterAll(liCounter, 3)
            poMasterArray(4, liIncrement) = lvMasterAll(liCounter, 4)
            poMasterArray(5, liIncrement) = lvMasterAll(liCounter, 5)
            poMasterArray(6, liIncrement) = lvMasterAll(liCounter, 6)
            poMasterArray(7, liIncrement) = lvMasterAll(liCounter, 7)
            
        End If
    Else
        Exit For
    
    End If

Next liCounter

If liIncrement = 0 Then
    GetMasterForInputCalc = 0
Else
    GetMasterForInputCalc = 1
End If


Exit Function
ErrorHandler:

GetMasterForInputCalc = 0

'Set the Screen Updating
Application.ScreenUpdating = True

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

Sub CreateWork_Preparation()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CreateWork_Preparation
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 01-March-2019
'VERSION           : 1.0
'DESCRIPTION       : Create Work Preparation from BOM Sheet and Output Calculator
'
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

Dim liChannelCounter        As Integer
Dim liExistingNum           As Integer
Dim liIncrement             As Integer
Dim liLastRow               As Integer
Dim liNotFoundinBOM         As Integer
Dim liNotFoundInBOMLoc      As Integer
Dim liUniqueChannel         As Integer
Dim liUniqueMaterial        As Integer

Dim llArrayCounter          As Long

Dim loItemTypes             As Object
Dim loMasterAll             As Object
Dim loMaterial              As Object
Dim loUniqueChannelBOM      As Object
Dim loUniqueWork            As Object

Dim loRange         As Range
Dim Search          As Range
Dim SearchRange     As Range
Dim Source          As Range

Dim lsTempRange     As String
Dim lsRange         As String

Dim lvaNonChannelTrans()    As Variant
Dim lvaWorkPreparation()    As Variant
Dim lvBOMArray()            As Variant
Dim lvChannelArray()        As Variant
Dim lvFinalArray()          As Variant
Dim lvMasterAll()           As Variant
Dim lvNotFoundinBOM()       As Variant
Dim lvTempArray()           As Variant
Dim myArray()               As Variant
Dim lvIFUArray()              As Variant

Dim loSheet         As Worksheet
Dim loWorkSheet     As Worksheet


'-------------------------------------

'Worksheet Integrity Check
If CheckStructure = False Then Exit Sub

'Check Mandatory Settings (Hilti Order Number and Version)
If CheckMandatory = False Then GoTo Failure

'Check if Total BOM sheet is there
If WorkSheetExists("Total BOM") = False Then
    MsgBox "The Total BOM Sheet is Missing!" & vbCrLf & vbCrLf & "Please complete Step 2 before using Step 3"
    GoTo Failure
End If

'Check if Total BOM sheet is there
If WorkSheetExists("Cutting Tracking") = False Then
    MsgBox "The Cutting Tracking Sheet is Missing!" & vbCrLf & vbCrLf & "Please complete Step 2 before using Step 3"
    GoTo Failure
End If

'Check if Total BOM sheet is there
If WorkSheetExists("Input Calculator") = False Then
    MsgBox "The Input Calculator Sheet is Missing!" & vbCrLf & vbCrLf & "Please complete Step 2 before using Step 3"
    GoTo Failure
End If

'Set it to failure value
llArrayCounter = 0

'Read all Master Sheet Details
llArrayCounter = GetMasterArray(loMasterAll, lvMasterAll)

'Check the success of Master Array
If llArrayCounter = -1 Then
    MsgBox "Master List Sheet is Missing!" & vbCrLf & vbCrLf & "Sheets Cannot be Created"
    GoTo Failure
    
ElseIf llArrayCounter = 0 Then

    MsgBox "Master List is empty!" & vbCrLf & vbCrLf & "Sheets Cannot be Created"
    GoTo Failure
End If

'Set it to failure value
llArrayCounter = 0

'Read the PI_Table for the PI Sheets (for Delivery Release Sheet)
llArrayCounter = GetTableInfoFromSettings(myArray, True)

'If Table in Settings Sheet has issues, show message and exit
If llArrayCounter = -1 Then
    MsgBox "Please enter the Production & Inspection Sheet details" & vbCrLf & vbCrLf & "The PI Sheet details must be entered in the table"
    GoTo Failure
ElseIf llArrayCounter = -2 Then
    MsgBox "All fields in the Production & Inspection Sheet Table are mandatory. " & vbCrLf & vbCrLf & _
    "An entire row in the table can be left blank but if one cell is filled, all the cells in that row must be filled."
    GoTo Failure
ElseIf llArrayCounter = 0 Then
    MsgBox "Error! Please close and open the workbook and try again."
    GoTo Failure
End If


'Set the Worksheet
Set loWorkSheet = Worksheets("Total BOM")

'Set the Range
Set loRange = loWorkSheet.Range("$A$5:$K$4098")

'Assign to the Array
lvTempArray() = loRange
      
'Convert from vertical to horizontal array list
lvBOMArray = Application.Transpose(lvTempArray)

'Erase the temp array
Erase lvTempArray

'This dictionary object holds all the unique entries from Total BOM sheet
Set loUniqueWork = CreateObject("Scripting.Dictionary")
Set loUniqueChannelBOM = CreateObject("Scripting.Dictionary")

'Loop through the items in the lvFinalarray (BOM items),
For llArrayCounter = LBound(lvBOMArray, 2) To UBound(lvBOMArray, 2)

    'First array element is the name of the item, which cannot be blank
    If Len(Trim(lvBOMArray(1, llArrayCounter))) > 0 Then
        
        'Check if this item is present in the Master Array
        If loMasterAll.exists(lvBOMArray(5, llArrayCounter)) = True Then
            
            'Channel Type come from calculator, so do not add that to the list, all non-channel types are added to the array from BOM Sheet
            If UCase(Trim(lvMasterAll(4, loMasterAll(lvBOMArray(5, llArrayCounter))))) <> "CHANNEL" Then
            
                If loUniqueWork.exists(lvBOMArray(5, llArrayCounter)) = True Then
                    
                    liExistingNum = CInt(loUniqueWork(lvBOMArray(5, llArrayCounter)))
                    
                    lvaWorkPreparation(4, liExistingNum) = lvaWorkPreparation(4, liExistingNum) + lvBOMArray(10, llArrayCounter)
                    

                Else
                    liUniqueMaterial = liUniqueMaterial + 1
                    
                    loUniqueWork.Add (lvBOMArray(5, llArrayCounter)), liUniqueMaterial
                    
                    ReDim Preserve lvaWorkPreparation(1 To 5, 1 To liUniqueMaterial)
                    'Material #
                    lvaWorkPreparation(1, liUniqueMaterial) = lvBOMArray(5, llArrayCounter)
                    'Material Description
                    lvaWorkPreparation(2, liUniqueMaterial) = lvBOMArray(6, llArrayCounter)
                    'Item Type
                    lvaWorkPreparation(3, liUniqueMaterial) = lvMasterAll(4, loMasterAll(lvBOMArray(5, llArrayCounter)))
                    'Qty
                    lvaWorkPreparation(4, liUniqueMaterial) = lvBOMArray(10, llArrayCounter)
                    
                    lvaWorkPreparation(5, liUniqueMaterial) = ""
                End If
            Else 'Channel Type add to the BOM Channels Dictionary
            
                If loUniqueChannelBOM.exists(lvBOMArray(5, llArrayCounter)) = False Then
                    liUniqueChannel = liUniqueChannel + 1
                    loUniqueChannelBOM.Add (lvBOMArray(5, llArrayCounter)), liUniqueChannel
                End If

            End If
        End If
    Else
        
        Exit For
    End If
Next llArrayCounter

If liUniqueChannel = 0 And liUniqueMaterial = 0 Then
    MsgBox "The Total BOM Sheet is either empty or not proper.  Please Check."
    GoTo Failure
End If

Erase lvFinalArray

'----------------------------------------------------------------
' Read Output Calculator for Channel type items
Set loWorkSheet = Nothing
Set loWorkSheet = Worksheets("Output Calculator")
Set SearchRange = loWorkSheet.Range("A2:F20")
Set Source = SearchRange(1, 1)

lsRange = ""

For Each Source In SearchRange
    If UCase(Source.value) = "SAP NO." Then
       lsRange = Chr(64 + Source.Column) & (Source.Row + 1) & ":" & Chr(64 + Source.Column + 1) & (Source.Row + 1000)
        Exit For
    End If
Next Source

If lsRange = "" Then
    MsgBox "The Output Calculator Sheet is not proper!" & vbCrLf & vbCrLf & "Work Preparation and Delivery Release Sheets Cannot be Created"
    GoTo Failure
End If

'Assign to the Array
lvTempArray() = loWorkSheet.Range(lsRange)

'Loop through the items in the lvFinalarray (BOM items),
For llArrayCounter = LBound(lvTempArray, 1) To UBound(lvTempArray, 1)

        If lvTempArray(llArrayCounter, 1) <> "" Then
        
            If loUniqueChannelBOM.exists(lvTempArray(llArrayCounter, 1)) = True Then
        
                liUniqueMaterial = liUniqueMaterial + 1
                            
                ReDim Preserve lvaWorkPreparation(1 To 5, 1 To liUniqueMaterial)
                
                lvaWorkPreparation(1, liUniqueMaterial) = lvTempArray(llArrayCounter, 1)
                
                lvaWorkPreparation(2, liUniqueMaterial) = lvMasterAll(2, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvaWorkPreparation(3, liUniqueMaterial) = lvMasterAll(4, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvaWorkPreparation(4, liUniqueMaterial) = lvTempArray(llArrayCounter, 2)
                
                lvaWorkPreparation(5, liUniqueMaterial) = lvTempArray(llArrayCounter, 2) * lvMasterAll(5, loMasterAll(lvTempArray(llArrayCounter, 1)))
            Else
                liNotFoundinBOM = liNotFoundinBOM + 1
                            
                ReDim Preserve lvNotFoundinBOM(1 To 5, 1 To liNotFoundinBOM)
                
                lvNotFoundinBOM(1, liNotFoundinBOM) = lvTempArray(llArrayCounter, 1)
                
                lvNotFoundinBOM(2, liNotFoundinBOM) = lvMasterAll(2, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvNotFoundinBOM(3, liNotFoundinBOM) = lvMasterAll(4, loMasterAll(lvTempArray(llArrayCounter, 1)))
                
                lvNotFoundinBOM(4, liNotFoundinBOM) = lvTempArray(llArrayCounter, 2)
                
                lvNotFoundinBOM(5, liNotFoundinBOM) = lvTempArray(llArrayCounter, 2) * lvMasterAll(5, loMasterAll(lvTempArray(llArrayCounter, 1)))
            
            
            End If
        
        
        Else
            Exit For
        End If
        

Next llArrayCounter


'Add to the end
If liNotFoundinBOM > 0 Then
    
        liUniqueMaterial = liUniqueMaterial + 1
        
        liNotFoundInBOMLoc = liUniqueMaterial + 6
                                    
        ReDim Preserve lvaWorkPreparation(1 To 5, 1 To liUniqueMaterial)
        
        lvaWorkPreparation(1, liUniqueMaterial) = "NOT IN ORIGINAL BOM, BUT RESULT OF THE CALCULATOR"
        
    
    For llArrayCounter = 1 To liNotFoundinBOM
    
        liUniqueMaterial = liUniqueMaterial + 1
                                    
        ReDim Preserve lvaWorkPreparation(1 To 5, 1 To liUniqueMaterial)
        
        lvaWorkPreparation(1, liUniqueMaterial) = lvNotFoundinBOM(1, llArrayCounter)
        
        lvaWorkPreparation(2, liUniqueMaterial) = lvNotFoundinBOM(2, llArrayCounter)
        
        lvaWorkPreparation(3, liUniqueMaterial) = lvNotFoundinBOM(3, llArrayCounter)
        
        lvaWorkPreparation(4, liUniqueMaterial) = lvNotFoundinBOM(4, llArrayCounter)
        
        lvaWorkPreparation(5, liUniqueMaterial) = lvNotFoundinBOM(5, llArrayCounter)
        
    Next llArrayCounter


End If


'Set the screen update to false to avoid screen blinking
Application.ScreenUpdating = False

'If "Work Preparation" Sheet not found, copy from the template
If WorkSheetExists("Work Preparation") = False Then

    If WorkSheetExists("WP") = True Then
    
        'Set the worksheet to PI
        Set loSheet = ActiveWorkbook.Sheets("WP")
        
        loSheet.visible = xlSheetVisible
        
        'Copy the sheet after the active sheet
        loSheet.Copy After:=ActiveWorkbook.Sheets("Cutting Tracking")
        
        'set the copied sheet as the active sheet
        ActiveSheet.name = "Work Preparation"
        
        ActiveSheet.Unprotect (SheetPassword)
        
        loSheet.visible = xlSheetHidden
        
        If liUniqueMaterial < 25 Then
            lsRange = "A8:K35"
            liLastRow = 35
        Else
            lsRange = "A8:K" & (liUniqueMaterial + 6)
            liLastRow = liUniqueMaterial + 6
        End If
        
        ActiveSheet.Range("A7:K7").Select
        Selection.Copy
        ActiveSheet.Range(lsRange).Select
        ActiveSheet.Paste
        ActiveSheet.Range("A7").Select
        
        lsRange = "A" & (liLastRow + 3)
        
        Worksheets("Work Preparation").Range(lsRange).Font.bold = True
        Worksheets("Work Preparation").Range(lsRange) = "Operator: "
        
        lsRange = "B" & (liLastRow + 3)
        Worksheets("Work Preparation").Range(lsRange) = "______________________________________"

    Else
        MsgBox "The Work Preparation { WP } Template is Missing" & vbCrLf & vbCrLf & "Work Preparation Sheet cannot be created"
        GoTo Failure
    End If

End If
'-------------------------------------------------------------------------------------

'Transpose the array list
lvaNonChannelTrans = Application.Transpose(lvaWorkPreparation)

'Assign the contents of the array to the Total BOM sheet from cell A9
Worksheets("Work Preparation").[A7].Resize(liUniqueMaterial, 5) = lvaNonChannelTrans


lsRange = "A" & liNotFoundInBOMLoc & ":E" & liNotFoundInBOMLoc
Worksheets("Work Preparation").Range(lsRange).Font.color = vbRed
Worksheets("Work Preparation").Range(lsRange).Font.bold = True
Worksheets("Work Preparation").Range(lsRange).Merge


'Creation of Delivery Release

If WorkSheetExists("Delivery Release") = False Then

    If WorkSheetExists("DR") = True Then
    
        'Set the worksheet to PI
        Set loSheet = ActiveWorkbook.Sheets("DR")
        
        loSheet.visible = xlSheetVisible
        
        'Copy the sheet after the active sheet
        loSheet.Copy After:=ActiveWorkbook.Sheets("Work Preparation")
        
        'set the copied sheet as the active sheet
        ActiveSheet.name = "Delivery Release"
        
        ActiveSheet.Unprotect (SheetPassword)
        
        loSheet.visible = xlSheetHidden
        
        
    Else
        MsgBox "The Delivery Release { DR } Template is Missing" & vbCrLf & vbCrLf & "Delivery Release Sheet cannot be created"
        GoTo Failure
    End If

End If


'Set the worksheet to PI
Set loSheet = ActiveWorkbook.Sheets("Delivery Release")

'Clear the Cells
loSheet.Range("A5:G40") = ""

liIncrement = 4

'Entering the values in the left table
For llArrayCounter = 1 To UBound(myArray, 2)
    
    'Check if the P & I Item Number is not blank
    If Len(Trim(myArray(2, llArrayCounter))) > 0 Then
    
       liIncrement = liIncrement + 1
       
       lsRange = "A" & liIncrement
       loSheet.Range(lsRange) = myArray(2, llArrayCounter)
      
        lsRange = "C" & liIncrement
        loSheet.Range(lsRange) = myArray(3, llArrayCounter)
        
        lsRange = "E" & liIncrement
        loSheet.Range(lsRange) = myArray(5, llArrayCounter)
        
    End If
    
Next llArrayCounter

'Erase the array to be used in BOM Links
Erase myArray

'Set the IFUs from BOM
'Clear the Cells
If GetBOMLinks(lvIFUArray) = -1 Then
    
    For llArrayCounter = 5 To 40
    
        loSheet.Range("I" & llArrayCounter).Hyperlinks.Delete
        loSheet.Range("I" & llArrayCounter) = ""
        loSheet.Range("I" & llArrayCounter & ":L" & llArrayCounter).Borders.LineStyle = xlContinuous
    
    Next llArrayCounter
    
    
    For llArrayCounter = 1 To UBound(lvIFUArray, 2)
        
        lsTempRange = "I" & llArrayCounter + 4
        loSheet.Range(lsTempRange).Hyperlinks.Add loSheet.Range(lsTempRange), Worksheets("Total BOM").Range(lvIFUArray(1, llArrayCounter)).Hyperlinks(1).Address, , , Worksheets("Total BOM").Range(lvIFUArray(1, llArrayCounter)).Text & " (" & lvIFUArray(2, llArrayCounter) & ")"
    
        
    Next llArrayCounter
    
End If

'Show success message
MsgBox "Work Preparation and Delivery Release Sheets have been created successfully"

'Reset the screen updating back
Application.ScreenUpdating = True

'Set the settings sheet as the active sheet
ActiveWorkbook.Sheets("Settings").Activate


'All good, exit the routine
Exit Sub

Failure:

'Set the settings sheet as the active sheet
ActiveWorkbook.Sheets("Settings").Activate

'Set the screen updating back to True
Application.ScreenUpdating = True

Exit Sub

ErrorHandler:

'Turn on ScreenUpdating
Application.ScreenUpdating = True

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear
End Sub

Private Sub ProcessStarts()
gbStopCellChange = True
'Set the calculation method as manual and reset it back to whatever it was before after loading
Application.ScreenUpdating = False
CalcStatus = Application.Calculation
Application.EnableEvents = False
Application.Calculation = xlCalculationManual

End Sub
Private Sub ProcessEnds()

Application.EnableEvents = True
Application.Calculation = CalcStatus
Application.ScreenUpdating = True
gbStopCellChange = False
End Sub

Public Sub GotoMainSheet()

Worksheets(nsMain.name).Activate

End Sub


Public Function CleanSheets(psSheet As String, pbHide As Boolean) As Boolean
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : CleanSheets
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 21-Nov-2019
'VERSION           : 2.0
'DESCRIPTION       : This function resets a sheet to template style; Any change to template
'                  : will NOT affect this function.  Code changes required for template change
'------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

Select Case psSheet
    
    Case "nsWP1"
        nsWP1.Range("A7:M500") = ""
        If pbHide = True Then
            nsWP1.visible = xlSheetHidden
        End If
    Case "nsDR1"
        nsDR1.Range("A5:F504") = ""
        If pbHide = True Then
            nsDR1.visible = xlSheetHidden
        End If
    Case "nsCT1"
        nsCT1.Range("A8:O5000").clear
        If pbHide = True Then
            nsCT1.visible = xlSheetHidden
        End If

    Case "nsTB1"

End Select

CleanSheets = True

Exit Function

ErrorHandler:

CleanSheets = False

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Public Sub ClearPI()

Dim liPage As Integer
Dim liNextRow As Integer
Dim lsRange As String

'Blank everything for the first page
nsPI1.Range("C3") = ""
nsPI1.Range("G3") = ""
nsPI1.Range("G2") = ""
nsPI1.Range("J2") = ""
nsPI1.Range("J3") = ""
nsPI1.Range("F28") = ""
nsPI1.Range("F37") = ""

lsRange = "A" & (liNextRow + 5) & ":J" & (liNextRow + 26)
nsPI1.Range(lsRange) = ""
      
'Apply first page to the other 199 pages
For liPage = 1 To 199
    'Find the starting starting row number
    liNextRow = liPage * 41
    lsRange = "A" & (liNextRow + 1) & ":K" & (liNextRow + 41)
    nsPI1.Range(lsRange).value = nsPI1.Range("A1:K41").value
Next liPage


End Sub
Attribute VB_Name = "modHiltiTrans"
Option Explicit

Private Type TransChild
    TransKey    As String
    ControlType As String
    SheetName   As String
    Address As String
End Type

Dim TabList()           As TransChild
Dim SheetCells()        As TransChild
Dim Labels()            As TransChild
Dim SheetButtons()      As TransChild
Dim PI_Sheets()         As TransChild

Public Type QATemplateSheets
    CuttingTracking     As Boolean
    DeliveryRelease     As Boolean
    TotalBOM            As Boolean
    WorkPreparation     As Boolean
    PIAll               As Boolean
End Type

Public Enum ProtectYesNo
    Protect = 1
    Unprotect = 2
End Enum

Public gbStopCellChange As Boolean
Dim ProtectedSheets()   As String
Dim QATemplateSheetExists As QATemplateSheets
Public gsaSheetNamesTranslations() As String
Public Function ProtectSheets(psaSheets() As Object, pProtect As ProtectYesNo, pPassword As String) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : ProtectSheets
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 16-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : To Protect the sheets after Translate
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim liTemp As Integer
Dim liArrayBound As Integer
Dim liProtectedSheetCnt As Integer


Dim ws As Worksheet

If pProtect = Protect Then '
    For liTemp = 1 To UBound(psaSheets)
        'Worksheets(psaSheets(liTemp)).Protect (pPassword)
        psaSheets(liTemp).Protect (pPassword)
    Next liTemp
ElseIf pProtect = Unprotect Then
    For Each ws In Worksheets
        If ws.ProtectContents = True Then
            ws.Unprotect (pPassword)
            liTemp = liTemp + 1
            ReDim Preserve psaSheets(liTemp)
            'psaSheets(liTemp) = ws.name
            Set psaSheets(liTemp) = ws
        End If
    Next ws
End If

ProtectSheets = liTemp

Exit Function

ErrorHandler:

ProtectSheets = -1
'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear


End Function
Public Function SortArray(pArray() As Variant, pWhichCol As Integer)
''------------------------------------------------------------------------------------------
''PROCEDURE NAME    : SortArray
''DEVELOPER'S NAME  : Prajeesh MG
''DATE OF CREATION  : 17-Oct-2019
''VERSION           : 1.0
''DESCRIPTION       : Return a sorted Array
''------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim liFirst As Integer      'For loop
Dim liSecond As Integer     'For loop
Dim liThird As Integer      'For loop

Dim liNumRows As Integer
Dim liNumCols As Integer
Dim lsTemp As Variant   'For Swapping the string

'Get the number of array elements into an array
liNumRows = UBound(pArray, 1)
liNumCols = UBound(pArray, 2)

'Sorts the array by Bubble Sort
For liFirst = 1 To liNumRows - 1
    For liSecond = 1 To liNumRows - 1
        If UCase(pArray(liSecond, pWhichCol)) < UCase(pArray(liSecond + 1, pWhichCol)) Then
            GoTo LOOP2
        Else
            'Actual array Swapping
            For liThird = 1 To liNumCols
                lsTemp = pArray(liSecond, liThird)
                pArray(liSecond, liThird) = pArray(liSecond + 1, liThird)
                pArray(liSecond + 1, liThird) = lsTemp
            Next liThird

        End If
LOOP2:
    Next liSecond
Next liFirst

Exit Function

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Public Function GetTableInfo(psSheet As String, psTable As String, pvArray() As Variant) As Integer
'--------------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetTableInfo
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 10-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Read the psTable Table of psSheet Worksheet and return the details in pvArray
'--------------------------------------------------------------------------------------------------

On Error GoTo ErrorHandler

Dim lvTempArray() As Variant
Dim loTable As ListObject
Dim loWorkSheet As Worksheet
Dim liArrayDimension As Integer
Dim liCounter As Integer


'Set the return value to False
 GetTableInfo = 0

'set the worksheet to settings sheet
Set loWorkSheet = Worksheets(psSheet)

'Set path for Table variable
Set loTable = loWorkSheet.ListObjects(psTable)

'Create Array List from Table
lvTempArray = loTable.DataBodyRange.Columns()

'Assign the array to the return
pvArray = lvTempArray

'All Good; set the return value to 1
GetTableInfo = 1

Exit Function

ErrorHandler:

GetTableInfo = 0

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

'-TBR-
Public Function TranslateWorkbook(piNewLanguage As Integer)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : TransCells
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 10-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Set the translated value to the Range
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim lvaTransChild() As Variant
Dim lvaTransMaster() As Variant

Dim liCounter As Integer
Dim liArrayBound As Integer
Dim liLoop As Integer
Dim loTransCollection  As Object
Dim loTransMasterRowNum As Object
Dim liSheetCount As Integer

Dim lsTargetSheet As String
Dim lsTargetCell As String
Dim lsKey As String
Dim lbSheetExists As Boolean
Dim lsType As String
Dim liNumProtectedSheets As Integer
Dim lbPIAllSheetExists As Boolean

Dim lsSheet As String
Dim lsTable As String

Dim lsTrans As String
Dim lbUnProtectSheet As Boolean
Dim liCSCounter As Integer
Dim liButtonCounter As Integer
Dim liPICounter As Integer
Dim liTabCounter As Integer
Dim lsaSheets() As Object
Dim SheetNamesTranslations() As String
Dim liCurrentLanguage As Integer
Dim liRowNum As Integer

'Pause screen updating
Application.ScreenUpdating = False

'Set this to True to avoid firing cell change as the calculator has Cell Change events in most of the sheets
gbStopCellChange = True

'Unprotect all sheets before the process and keep those sheet names in lsaSheets Array for protecting again
liNumProtectedSheets = ProtectSheets(lsaSheets, Unprotect, SheetPassword)

'If ProtectSheets function fails then exit
If liNumProtectedSheets < 0 Then Exit Function

'Get the Translation Master to an Array
Call GetTableInfo("Translations", "tblTransMaster", lvaTransMaster)

'Create a collection of Translations with key
Set loTransCollection = CreateObject("Scripting.Dictionary")

Set loTransMasterRowNum = CreateObject("Scripting.Dictionary")
liArrayBound = UBound(lvaTransMaster, 1)

For liCounter = 1 To liArrayBound
    lsKey = Trim(lvaTransMaster(liCounter, 2))
    If Len(lsKey) > 0 Then
        If loTransCollection.exists(lsKey) = False Then
            lsTrans = lvaTransMaster(liCounter, piNewLanguage + 2)
            loTransCollection.Add lsKey, lsTrans
            loTransMasterRowNum.Add lsKey, CStr(liCounter + 21) '21 Rows are header lines
        End If
    End If
Next liCounter

'Get the Translation Details to an Array
Call GetTableInfo("Trans-Map", "tblTransMap", lvaTransChild)

'Sort the Array by sheet name to make them together
Call SortArray(lvaTransChild, 3)

'Get all the sheet names with translations
'Zeroth element will have the key
'First element will have English...
liArrayBound = UBound(lvaTransChild, 1)

For liCounter = 1 To liArrayBound

    If UCase(Trim(lvaTransChild(liCounter, 2))) = "TAB" Then
    
        lsKey = Trim(lvaTransChild(liCounter, 5))
        
        If Len(lsKey) > 0 Then
            
            If loTransMasterRowNum.exists(lsKey) = True Then
            
                liSheetCount = liSheetCount + 1
                liRowNum = loTransMasterRowNum(lsKey)
                ReDim Preserve SheetNamesTranslations(0 To 20, 1 To liSheetCount)
                
                For liLoop = 0 To 20
                    SheetNamesTranslations(liLoop, liSheetCount) = Worksheets("Translations").Range(Chr(66 + liLoop) & liRowNum)
                Next liLoop
                
            End If
        End If
    
    End If
Next liCounter

'Temporarily change the language to English
Call TranslateAllTabNames(SheetNamesTranslations, 1)

'Remove entries of non-existing sheets
'Loop through all the entries and blank the translation type
'blanks will not be considered for translation
liArrayBound = UBound(lvaTransChild, 1)

For liCounter = 1 To liArrayBound
    If lsSheet = lvaTransChild(liCounter, 3) Then
        If lbSheetExists = False Then
            lvaTransChild(liCounter, 1) = -1
        End If
    Else
        If WorkSheetExists(lvaTransChild(liCounter, 3)) = True Then
            lbSheetExists = True
        Else
            lbSheetExists = False
            lvaTransChild(liCounter, 1) = -1
        End If
    End If
    lsSheet = lvaTransChild(liCounter, 3)
Next liCounter

'Translation starts from here;
liArrayBound = UBound(lvaTransChild, 1)

For liCounter = 1 To liArrayBound
    lsTargetSheet = lvaTransChild(liCounter, 3)
    lsKey = lvaTransChild(liCounter, 5)
    lsTargetCell = lvaTransChild(liCounter, 4)
    lsType = lvaTransChild(liCounter, 2)
    'If lvaTransChild(liCounter, 1) <> -1 Then
        Select Case lsTargetSheet
            Case "PI Template"
                'Translate the PI Template sheet
                Call UpdatePISheets("PI Template", lsTargetCell, lsKey, loTransCollection, lsType)
                
                'If QATemplateSheetExists.PIAll = True Then
                If WorkSheetObjectExists("nsPI1") = True Then
                    Call UpdatePISheets("PI All", lsTargetCell, lsKey, loTransCollection, lsType)
                End If
                
            Case "Cutting Tracking"
                'Translate the CT sheet
                Call UpdateObject("CT", lsTargetCell, lsKey, loTransCollection, lsType)
                
                'If the Cutting Tracking sheet available, translate the sheet
                'If QATemplateSheetExists.CuttingTracking = True Then
                If WorkSheetObjectExists("nsCT1") = True Then
                    Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
                End If
                
            Case "Delivery Release"
                'Translate the DR sheet
                Call UpdateObject("DR", lsTargetCell, lsKey, loTransCollection, lsType)
            
                'If the Delivery Release sheet available, translate the sheet
                'If QATemplateSheetExists.DeliveryRelease = True Then
                If WorkSheetObjectExists("nsDR1") = True Then
                    Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
                End If
                
            Case "Work Preparation"
                'Translate the WP sheet
                Call UpdateObject("WP", lsTargetCell, lsKey, loTransCollection, lsType)
                
                'If the Work Preparation sheet available, translate the sheet
                'If QATemplateSheetExists.WorkPreparation = True Then
                If WorkSheetObjectExists("nsWP1") = True Then
                    Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
                End If
            Case "Total BOM"
                'Translate the TB sheet
                Call UpdateObject("TB", lsTargetCell, lsKey, loTransCollection, lsType)

                'If the Work Preparation sheet available, translate the sheet
                'If QATemplateSheetExists.TotalBOM = True Then
                If WorkSheetObjectExists("nsTB1") = True Then
                    Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
                End If
            Case "Main"
                    If UCase(Left(lsKey, 2)) = "O1" Then
                        If nsMain.Range("A1") = 1 Then
                            Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
                        End If
                    ElseIf UCase(Left(lsKey, 2)) = "O2" Then
                        If nsMain.Range("A1") = 2 Then
                            Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
                        End If
                    Else
                        Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
                    End If
            Case Else
                Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
            
        End Select
    'End If
Next liCounter

'To set the "How to use" sheet columns based on the selected language
HideSheetColumns (piNewLanguage)

'Change the Sheetnames to the new language
Call TranslateAllTabNames(SheetNamesTranslations, piNewLanguage)

'Set the language in settings and main sheet
'SheetSettings.Range("B17") = WorksheetFunction.HLookup(piNewLanguage, Worksheets("Translations").Range("C17:K21"), 5, False)
SheetSettings.Range("B17").value = GetLanguage(piNewLanguage)

nsMain.Range("B1") = SheetSettings.Range("B17")

'Protect all sheets before the process
If liNumProtectedSheets > 0 Then
    Call ProtectSheets(lsaSheets, Protect, SheetPassword)
End If

'Pause screen updating
Application.ScreenUpdating = True

gbStopCellChange = False

Exit Function

ErrorHandler:

gbStopCellChange = False

'If error protect all the sheets before exiting
Call ProtectSheets(lsaSheets, Protect, SheetPassword)

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

Public Function GetLanguage(piIndex As Integer) As String
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetLanguage
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 17-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Get the Language Name when index is passed
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim lsRange As Range
Dim lvArray() As Variant
Dim liCounter As Integer

Set lsRange = Worksheets("Translations").Range("C21:K21")

'in case of error
GetLanguage = "English"

lvArray = lsRange


GetLanguage = lvArray(1, piIndex)

'For liCounter = 1 To UBound(lvArray, 1)
'
'
'
'Next liCounter


Exit Function

ErrorHandler:
GetLanguage = "English"

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Public Function GetLanguageIndex(psLanguage As String) As Integer
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetLanguageIndex
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 17-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Get the Language Name when index is passed
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim lsRange As Range
Dim lvArray() As Variant
Dim liCounter As Integer

Set lsRange = Worksheets("Translations").Range("C21:K21")

'in case of error
GetLanguageIndex = 1

lvArray = lsRange


For liCounter = 1 To UBound(lvArray, 2)

    If UCase(Trim(psLanguage)) = UCase(Trim(lvArray(1, liCounter))) Then
        GetLanguageIndex = liCounter
        Exit For
    End If

Next liCounter


Exit Function

ErrorHandler:
GetLanguageIndex = 1

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

Public Function UpdateObject(ByVal psTargetSheet As String, ByVal psTargetCell As String, ByVal psKey As String, ByVal poTransCollection As Dictionary, ByVal psType As String)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : UpdateObject
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 17-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Set the translated value to the cells, button text
'------------------------------------------------------------------------------------------
On Error Resume Next
Select Case psType

    Case "Cell"
        Worksheets(psTargetSheet).Range(psTargetCell) = poTransCollection(psKey)
    Case "Button"
        Worksheets(psTargetSheet).Shapes(psTargetCell).OLEFormat.Object.Caption = poTransCollection(psKey)
    Case "ActiveX Button"
        Worksheets(psTargetSheet).Shapes(psTargetCell).OLEFormat.Object.Object.Caption = poTransCollection(psKey)
    Case "Label"
        Worksheets(psTargetSheet).Shapes(psTargetCell).OLEFormat.Object.Caption = poTransCollection(psKey)
    Case "FormControl"
        'Application.Currentproject.forms(psTargetSheet).Controls(psTargetCell).Caption = poTransCollection(psKey)
        'UserForms(psTargetSheet).Controls(psTargetCell).Caption = poTransCollection(psKey)
    Case ""
        '** Blank Types for the non-existent sheets; do not add any translations here **
End Select

Exit Function

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

Public Function UpdatePISheets(ByVal psTargetSheet As String, ByVal psTargetCell As String, ByVal psKey As String, ByVal poTransCollection As Dictionary, ByVal psType As String)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : UpdatePISheets
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 17-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Set the translated value to the PI Sheets
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim llRow As Long
Dim lsCol As String
Dim lsFirstCell As String
Dim llPageNum As Long

llRow = val(Mid(psTargetCell, 2))
lsCol = Left(psTargetCell, 1)
lsFirstCell = "A1"

Do While Sheets(psTargetSheet).Range(lsFirstCell) <> ""
    Call UpdateObject(psTargetSheet, psTargetCell, psKey, poTransCollection, psType)
    llPageNum = llPageNum + 1
    lsFirstCell = "A" & (41 * llPageNum + 1)
    psTargetCell = lsCol & (41 * llPageNum + llRow)
Loop

Exit Function

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear
End Function


Public Sub TranslateAllTabNames(pSheetArray() As String, piLanguage As Integer)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : TranslateAllTabNamesToEnglish
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 23-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : To reset the sheet names to English
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim liCounter As Integer
Dim lsKey As String

Dim loTransCollection  As Object
Set loTransCollection = CreateObject("Scripting.Dictionary")


For liCounter = 1 To UBound(pSheetArray, 2)
    lsKey = Trim(pSheetArray(0, liCounter))
    If Len(lsKey) > 0 Then
        If loTransCollection.exists(lsKey) = False Then
            loTransCollection.Add lsKey, pSheetArray(piLanguage, liCounter)
        End If
    End If
Next liCounter

Dim sh As Worksheet
Dim shName As String

' Cycle through all sheets
For Each sh In ThisWorkbook.Worksheets

    If loTransCollection.exists(sh.CodeName) = True Then
        sh.name = loTransCollection(sh.CodeName)
    End If
    
Next sh


Exit Sub

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Sub
Public Function GetSheetNamesAllLanguages()
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetSheetNamesAllLanguages
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 24-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Get the translated sheet names for all sheets
'Trans OK
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim lvaTransChild() As Variant
Dim lvaTransMaster() As Variant
Dim liRowNum As Integer
Dim lsKey As String
Dim loTransCollection  As Object
Dim liArrayBound As Integer
Dim liCounter As Integer
Dim liSheetCount As Integer
Dim liLoop As Integer

'Get the Translation Master to an Array
Call GetTableInfo("Translations", "tblTransMaster", lvaTransMaster)

Erase gsaSheetNamesTranslations

liRowNum = 0

liArrayBound = UBound(lvaTransMaster, 1)

For liCounter = 1 To liArrayBound
    If Trim(lvaTransMaster(liCounter, 1)) = "Tab_Name" Then
        ReDim Preserve gsaSheetNamesTranslations(0 To 20, 1 To liRowNum)
        liRowNum = liRowNum + 1
        For liLoop = 1 To 20
            gsaSheetNamesTranslations(liLoop, liRowNum) = lvaTransMaster(liLoop + 2)
        Next liLoop

    End If
Next liCounter

Exit Function

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Public Function GetSheetAddressAllLanguages(psaAddress() As String)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetSheetNamesAllLanguages
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 24-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Get the translated sheet names for all sheets
'Trans OK
'------------------------------------------------------------------------------------------

Dim lvaTransChild() As Variant
Dim lvaTransMaster() As Variant
Dim liRowNum As Integer
Dim lsKey As String
Dim loTransCollection  As Object
Dim liArrayBound As Integer
Dim liCounter As Integer
Dim liSheetCount As Integer
Dim liLoop As Integer

'Get the Translation Master to an Array
Call GetTableInfo("Translations", "tblTransMaster", lvaTransMaster)

liRowNum = 0

liArrayBound = UBound(lvaTransMaster, 1)

For liCounter = 1 To liArrayBound
    If Trim(lvaTransMaster(liCounter, 1)) = "Tab_Name" Then
        liRowNum = liRowNum + 1
        ReDim Preserve psaAddress(0 To 20, 1 To liRowNum)
        psaAddress(0, liRowNum) = lvaTransMaster(liCounter, 2)
        For liLoop = 1 To 20
            psaAddress(liLoop, liRowNum) = Chr(66 + liLoop) & (liCounter + 21)
        Next liLoop

    End If
Next liCounter

Exit Function


ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Public Function TranslateSheetName(psaSheetNamesAllLanguages() As String, pSheetName As String, pLanguage As Integer) As String
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : TranslateSheetName
'DEVELOPER'S NAME  : Prajeesh
'DATE OF CREATION  : 24-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Get the translated name of the sheet
' Sample: Call GetTranslatedSheetName(gsaSheetNamesTranslations, "SheetDiagrams", 7)
'Trans OK
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim liArrayBound As Integer
Dim liCounter As Integer

liArrayBound = UBound(psaSheetNamesAllLanguages, 2)

TranslateSheetName = pSheetName

For liCounter = 1 To liArrayBound
    If UCase(Trim(psaSheetNamesAllLanguages(0, liCounter))) = UCase(Trim(pSheetName)) Then
        TranslateSheetName = Worksheets("Translations").Range(psaSheetNamesAllLanguages(pLanguage, liCounter))
        Exit For
    End If
Next liCounter

Exit Function

ErrorHandler:

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function
Public Function HideSheetColumns(piLanguage As Integer)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : HideSheetColumns
'DEVELOPER'S NAME  : Prajeesh
'DATE OF CREATION  : 25-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Functions tries to set visible for the to the given language.
'------------------------------------------------------------------------------------------
'Resume next on error to trap the error
On Error GoTo ErrorHandler

Dim lsStart As String
Dim lsEnd As String

Application.ScreenUpdating = False

SheetHowToUse.Unprotect (SheetPassword)

SheetHowToUse.Columns("A:FY").Hidden = False

With SheetHowToUse
    
Select Case piLanguage
    Case 1
        lsStart = ""
        lsEnd = "K:FY"
        .Columns(lsEnd).Hidden = True
    Case 2
        lsStart = "B:J"
        lsEnd = "T:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 3
        lsStart = "B:S"
        lsEnd = "AC:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 4
        lsStart = "B:AB"
        lsEnd = "AL:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 5
        lsStart = "B:AK"
        lsEnd = "AU:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 6
        lsStart = "B:AT"
        lsEnd = "BD:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 7
        lsStart = "B:BC"
        lsEnd = "BM:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 8
        lsStart = "B:BL"
        lsEnd = "BV:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 9
        lsStart = "B:BU"
        lsEnd = "CE:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 10
        lsStart = "B:CD"
        lsEnd = "CN:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 11
        lsStart = "B:CM"
        lsEnd = "CW:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 12
        lsStart = "B:CV"
        lsEnd = "DF:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 13
        lsStart = "B:DE"
        lsEnd = "DO:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 14
        lsStart = "B:DN"
        lsEnd = "DX:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 15
        lsStart = "B:DW"
        lsEnd = "EG:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 16
        lsStart = "B:EF"
        lsEnd = "EP:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 17
        lsStart = "B:EO"
        lsEnd = "EY:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 18
        lsStart = "B:EX"
        lsEnd = "FH:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 19
        lsStart = "B:FG"
        lsEnd = "FQ:FY"
        .Columns(lsStart).Hidden = True
        .Columns(lsEnd).Hidden = True
    Case 19
        lsStart = "B:FP"
        'lsEnd = "FQ:FY"
        .Columns(lsStart).Hidden = True
        '.Columns(lsEnd).Hidden = True
End Select



End With

SheetHowToUse.Columns("A1").Select

SheetHowToUse.Protect (SheetPassword)

Application.ScreenUpdating = True

Exit Function

ErrorHandler:

Err.clear

End Function

Public Function CallTranslateForm()
FrmLangSelection.show (1)
End Function
'-TBR-
Public Function GetTranslatedValueByKey(pkey As String, piNewLanguage As Integer) As String
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : GetTranslatedValueByKey
'DEVELOPER'S NAME  : Prajeesh MG
'DATE OF CREATION  : 13-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Get the translated value of a Key
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler

Dim lvaTransMaster() As Variant

Dim liCounter As Integer
Dim liArrayBound As Integer

'Pause screen updating
Application.ScreenUpdating = False

'Get the Translation Master to an Array
Call GetTableInfo("Translations", "tblTransMaster", lvaTransMaster)

liArrayBound = UBound(lvaTransMaster, 1)

For liCounter = 1 To liArrayBound
    If Trim(lvaTransMaster(liCounter, 2)) = Trim(pkey) Then
        GetTranslatedValueByKey = Trim(lvaTransMaster(liCounter, piNewLanguage + 2))
        Exit For
    End If
Next liCounter

'Pause screen updating
Application.ScreenUpdating = True

Exit Function

ErrorHandler:

GetTranslatedValueByKey = ""
'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function

Public Function TranslateOneSheet(psSheet As Object, Optional ByVal psEnglishSheetName As String)
'------------------------------------------------------------------------------------------
'PROCEDURE NAME    : TransCells
'DEVELOPER'S NAME  : JS
'DATE OF CREATION  : 10-Oct-2019
'VERSION           : 1.0
'DESCRIPTION       : Set the translated value to the Range
'------------------------------------------------------------------------------------------
On Error GoTo ErrorHandler



Dim piNewLanguage As Integer



Dim liLoop As Integer

Dim loTransMasterRowNum As Object
Dim liSheetCount As Integer

Dim lsTargetSheet As String
Dim lsTargetCell As String

Dim lbSheetExists As Boolean
Dim lsType As String
Dim liNumProtectedSheets As Integer
Dim lbPIAllSheetExists As Boolean

Dim lsSheet As String
Dim lsTable As String

Dim lsTrans As String
Dim lbUnProtectSheet As Boolean
Dim liCSCounter As Integer
Dim liButtonCounter As Integer
Dim liPICounter As Integer
Dim liTabCounter As Integer
Dim lsaSheets() As Object
Dim SheetNamesTranslations() As String
Dim liCurrentLanguage As Integer
Dim liRowNum As Integer
Dim lvaTransMaster() As Variant
Dim loTransCollection  As Object


'-----------------
Dim liLanguageIndex As Integer
Dim lbProtectStatus As Boolean
Dim lvaTransChild() As Variant
Dim lvaOneSheetTransChild() As Variant
Dim loOneSheetKeys  As Object

Dim lsSheetName As String
Dim liArrayBound As Integer
Dim liCounter As Integer
Dim lsKey As String
Dim liUpper As Integer

'Get the Sheet Name
lsSheetName = psSheet.name
psEnglishSheetName = UCase(Trim(psEnglishSheetName))

'Set this to True to avoid firing cell change as the calculator has Cell Change events in most of the sheets
gbStopCellChange = True

'Get the Language Index
liLanguageIndex = GetLanguageIndex(nsMain.Range("B1").Text)

'Unprotect all sheets before the process and keep those sheet names in lsaSheets Array for protecting again
lbProtectStatus = psSheet.ProtectContents

'Get all the keys of this Sheet from the Translation Mapping Sheet
Call GetTableInfo("Trans-Map", "tblTransMap", lvaTransChild)

'Create a collection of Translations with key
Set loOneSheetKeys = CreateObject("Scripting.Dictionary")

liArrayBound = UBound(lvaTransChild, 1)

For liCounter = 1 To liArrayBound

    If UCase(Trim(lvaTransChild(liCounter, 3))) = psEnglishSheetName Then
    
        lsKey = Trim(lvaTransChild(liCounter, 5))
        
        liUpper = liUpper + 1
        ReDim Preserve lvaOneSheetTransChild(1 To 5, 1 To liUpper)
        
        lvaOneSheetTransChild(1, liUpper) = lvaTransChild(liCounter, 1)
        lvaOneSheetTransChild(2, liUpper) = lvaTransChild(liCounter, 2)
        lvaOneSheetTransChild(3, liUpper) = lvaTransChild(liCounter, 3)
        lvaOneSheetTransChild(4, liUpper) = lvaTransChild(liCounter, 4)
        lvaOneSheetTransChild(5, liUpper) = lvaTransChild(liCounter, 5)
        
        If Len(lsKey) > 0 Then
            If loOneSheetKeys.exists(lsKey) = False Then
                loOneSheetKeys.Add lsKey, liUpper
            End If
        End If
    
    End If
    
Next liCounter


'Get the Translation Master to an Array
Call GetTableInfo("Translations", "tblTransMaster", lvaTransMaster)

'Create a collection of Translations with key
Set loTransCollection = CreateObject("Scripting.Dictionary")

Set loTransMasterRowNum = CreateObject("Scripting.Dictionary")

liArrayBound = UBound(lvaTransMaster, 1)

For liCounter = 1 To liArrayBound
    lsKey = Trim(lvaTransMaster(liCounter, 2))
    If Len(lsKey) > 0 Then
        If loTransCollection.exists(lsKey) = False Then
            lsTrans = lvaTransMaster(liCounter, liLanguageIndex + 2)
            loTransCollection.Add lsKey, lsTrans
            loTransMasterRowNum.Add lsKey, CStr(liCounter + 21) '21 Rows are header lines
        End If
    End If
Next liCounter

'Temporarily change the language to English
psSheet.name = psEnglishSheetName

'Translation starts from here;
liArrayBound = UBound(lvaOneSheetTransChild, 2)

For liCounter = 1 To liArrayBound
    lsTargetSheet = lvaOneSheetTransChild(3, liCounter)
    lsKey = lvaOneSheetTransChild(5, liCounter)
    lsTargetCell = lvaOneSheetTransChild(4, liCounter)
    lsType = lvaOneSheetTransChild(2, liCounter)
        
    Call UpdateObject(lsTargetSheet, lsTargetCell, lsKey, loTransCollection, lsType)
            

Next liCounter


'Change the Sheetnames to the new language
psSheet.name = lsSheetName

If lbProtectStatus = True Then
    psSheet.Protect (SheetPassword)
End If


'Pause screen updating
Application.ScreenUpdating = True

gbStopCellChange = False

Exit Function

ErrorHandler:

gbStopCellChange = False

'If error protect all the sheets before exiting
Call ProtectSheets(lsaSheets, Protect, SheetPassword)

'Call Error Message
Call DisplayError(Err)

'Clear the error object
Err.clear

End Function


Attribute VB_Name = "modMessages"
Private Sub Messages(piMsgNumber As Integer)






End Sub
Attribute VB_Name = "nsCT"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsCT1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsDR"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsDR1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsMain"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub Worksheet_Activate()

End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)

End Sub
Attribute VB_Name = "nsMasterList"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsPI"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsPI1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsStart"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsTB"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub cmdHome_Click()
ActiveSheet.Range("A5").Activate
Worksheets(gsMainSheet).Activate
End Sub

Attribute VB_Name = "nsTB1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

Private Sub cmdHome_Click()
ActiveSheet.Range("A5").Activate
Worksheets(gsMainSheet).Activate
End Sub

Private Sub Worksheet_SelectionChange(ByVal Target As Range)

End Sub
Attribute VB_Name = "nsTransMap"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsWP"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "nsWP1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True

' InQuest injected base64 decoded content
' /j)ZnW
' -y*Zq
' -y*Zq
' u*Zq
' u*Zq
' u:%z
' u:%z
' z{Lz
' Kzx-
' O*^U
' u:%z
' u:%z
' O*^U
' O*^U
' /x(Z
' *^r'
' u:%z
' ^u:%z
' O*^U
' !(^z
' !(^z
' "-z`
' y(^z
' x%x8
' j{%j
' ^u(^z

INQUEST-PP=macro
