Attribute VB_Name = "CurrencyFormatter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'# Autor:   Christian Streit
'# Datum:   17.11.2009 16:00
'# Version: 1.01

'#Versionshistory:
'# v1.00 - Neuentwicklung
'# v1.01 - CHS 17.11.2009 Fehlerbehebung beim Runden in FormatValue 12.079 wird nicht mehr zu 12.8 (wenn 2-stellige Ausgabe)
'# v1.02 - GEM 05.01.2010 Funktion preis_ohne_wehrung neu ( Anzeige der Preise ohne W|fffd|hrung )


Option Explicit

Private M_Currency As String '#W|fffd|hrung
Private M_CurWithSpace As Boolean '#gibt an ob ein Leerzeichen zwischen W|fffd|hrung und Betrag gesetzt werden soll
Private M_CurAfterValue As Boolean '#gibt an, ob die W|fffd|hrung nach dem Zahlenwert stehen soll oder davor
Private M_Thousand_Seperator As String '# Tausender-Trennzeichen
Private M_Comma_Seperator As String '# Zeichen f|fffd|r Komma

'#Beispiel1: EUR 1.234,56
'#M_Currency = "EUR"
'#M_CurWithSpace = True
'#M_CurAfterValue = False
'#M_Thousand_Seperator = "."
'#M_Comma_Seperator = ","

'#Beispiel2: 1,234.56Kr
'#M_Currency = "Kr"
'#M_CurWithSpace = False
'#M_CurAfterValue = True
'#M_Thousand_Seperator = ","
'#M_Comma_Seperator = "."

Private Sub Class_Initialize()
    M_Currency = "EUR"
    M_CurWithSpace = True
    M_CurAfterValue = True
    M_Thousand_Seperator = "."
    M_Comma_Seperator = ","
End Sub

'# Setzt das Format f|fffd|r die W|fffd|hrung.
'# Tausendertrenner und Kommazeichen m|fffd|ssen sich unterscheiden, sonst wird das Kommazeichen entsprechend angepasst
'#
Public Sub SetFormat(ByVal cur As String, ByVal curWithSpace As Boolean, ByVal curAfterValue As Boolean, ByVal thousand_Seperator As String, ByVal comma_Separator As String)
    M_Currency = cur
    M_CurWithSpace = curWithSpace
    M_CurAfterValue = curAfterValue
    M_Thousand_Seperator = thousand_Seperator
    M_Comma_Seperator = comma_Separator
    If M_Thousand_Seperator = M_Comma_Seperator Or M_Comma_Seperator = "" Then
        '#damit wird sichergestellt, dass es das Kommazeichen immer geben muss, auch wenn kein Tausendertrenner angegeben ist, bzw. dass beide sich immer unterscheiden m|fffd|ssen
        M_Comma_Seperator = IIf(M_Thousand_Seperator = ",", ".", ",")
    End If
End Sub

'#
'#Funktion gibt die |fffd|bergebene Zahl in dem mit SetFormat gesetzten Format zur|fffd|ck
'#
Public Function FormatValue(ByVal value As Double, Optional ByVal anzNachkommaStellen As Integer = 2) As String
    Dim Ergebnis As String
    Dim VorKommaVal As String, NachKommaVal As String
    Dim AnzThSeperators As Integer, i As Integer, Position As Integer
    '###########################################################
    Ergebnis = CStr(value)
    Ergebnis = Replace$(Ergebnis, ",", ".") '# f|fffd|r den Fall, dass die Zahl in einer anderen Sprache mit ',' verwaltet wird
    VorKommaVal = Split(Ergebnis, ".")(0)
    '-----------------
    NachKommaVal = ""
    If InStr(Ergebnis, ".") <> 0 Then '#falls es einen Nachkommawert gibt
        NachKommaVal = Split(Ergebnis, ".")(1)
    End If
    '#wenn keine Nachkommastellen angegeben werden sollen, aber ein Nachkommawert geschrieben ist, muss der Vorkommawert ggf. aufgerundet werden
    If anzNachkommaStellen = 0 And NachKommaVal <> "" Then
        If CInt(Left$(NachKommaVal, 1)) >= 5 Then
            VorKommaVal = Round(CDbl(VorKommaVal) + 1, 0)
        End If
    Else
        If anzNachkommaStellen = -1 Then
            anzNachkommaStellen = Len(NachKommaVal)
        End If
        '# Nachkommawert mit '0'en auff|fffd|llen, falls nicht gen|fffd|gend Ziffern vorhanden
        Do While Len(NachKommaVal) < anzNachkommaStellen
            NachKommaVal = NachKommaVal & "0"
        Loop
        '#falls zuviele Ziffern vorhanden, den Wert auf die Zifferanzahl abrunden
        If Len(NachKommaVal) > anzNachkommaStellen Then
            Dim toRound As Double
            Dim tempStr As String
            '#nur eine Nachkommastelle interessiert uns beim runden, deshalb den Rest verwerfen
            tempStr = Left$(NachKommaVal, anzNachkommaStellen + 1) '# +1 ist gew|fffd|hrleistet, wegen IF-Bedingung
            '#f|fffd|r den Fall, dass vorne eine 0 steht (w|fffd|rde beim Runden abgeschnitten) eine 1 anh|fffd|ngen
            tempStr = "1" & tempStr
            
            '#Wegen dem Excelrundungsproblem bei '.5' wird noch eine 1 angeh|fffd|ngt (dadurch, dass der Rest verworfen wurde, bleibt die Zahl korrekt, trotz des anh|fffd|ngens
            If Mid(tempStr, anzNachkommaStellen + 2, 1) = "5" Then
                tempStr = tempStr & "1"
                toRound = tempStr / 100 '#durch 100, da die 1 dazu kam
            Else
                toRound = tempStr / 10 '# durch 10 (es gibt nur 1 Nachkommastelle)
            End If
            
            tempStr = Round(toRound, 0)
            
            '#f|fffd|r den Fall, dass zB 12.99999 gerundet wird:
            '#aus toRound = 199.9 wird 200 --> die erste Ziffer ist nun nicht mehr die angeh|fffd|ngte 1, sondern wurde gr|fffd||fffd|er --> es muss auf den Vorkommawert eins dazu addiert werden
            If Left$(tempStr, 1) = "2" Then
                VorKommaVal = Round(CDbl(VorKommaVal) + 1, 0)
            End If
            '#jetzt die angeh|fffd|ngte 1 bzw. die durch Runden entstandene 2 wieder entfernen.
            NachKommaVal = Mid(tempStr, 2)
        End If
    End If
    
    Ergebnis = CStr(VorKommaVal)
    AnzThSeperators = (Len(Ergebnis) - 1) \ 3 '# Anzahl der Tausendertrennzeichen bestimmen
    '#Tausendertrenner in den String einf|fffd|gen
    For i = 1 To AnzThSeperators
        Position = Len(Ergebnis) - 3 * i  '#n|fffd|chste Position (von hinten beginnend) bestimmen
        Position = Position - i * Len(M_Thousand_Seperator) + Len(M_Thousand_Seperator) '#ein bereits eingef|fffd|gter Seperator muss ebenfalls beachtet werden (Len(M_Thousand_Seperator) ==> Seperator kann beliebig viele Zeichen beinhalten)
        Ergebnis = Left(Ergebnis, Position) & M_Thousand_Seperator & Right(Ergebnis, Len(Ergebnis) - Position)
    Next i
    '#Nachkommastellen an den String anf|fffd|gen, falls vorhanden
    If anzNachkommaStellen > 0 Then
        Ergebnis = Ergebnis & M_Comma_Seperator & NachKommaVal
    End If
    '#W|fffd|hrungskennzeichen anf|fffd|gen
    If M_CurAfterValue Then
        Ergebnis = Ergebnis & IIf(M_CurWithSpace, " ", "") & M_Currency
    Else
        Ergebnis = M_Currency & IIf(M_CurWithSpace, " ", "") & Ergebnis
    End If
    'Ergebnis = AnzThSeperators
    FormatValue = Ergebnis
End Function

'#Funktion sucht in einem String nach einer Zahl und der entsprechenden W|fffd|hrung. Es muss entweder <W|fffd|hrung und Zahl> oder <Zahl und W|fffd|hrung> sein. ("1,25 EUR" und EUR 1.25 sind g|fffd|ltig;;; "EUR 1,25 EUR" ist nicht g|fffd|ltig, da vor und nach der Zahl text steht)
'#Der String darf nur eine Zahl beinhalten! Eine W|fffd|hrung ist nicht notwendig!
'#
Public Function GetValueFromStringAndSetFormat(ByVal Text As String) As Double
    Dim TEMP_Currency As String
    Dim TEMP_CurWithSpace As Boolean
    Dim TEMP_CurAfterValue As Boolean
    Dim TEMP_Thousand_Seperator As String
    Dim TEMP_Comma_Seperator As String

    Dim Links As Integer, Rechts As Integer, i As Integer
    Dim StrValue As String, StrCur As String, StrZAHL As String, VorKomma As String, NachKomma As String
    Links = 0
    Rechts = 0
    '#suchen, wo die Zahl beginnt
    For i = 1 To Len(Text)
        If IsNumeric(Mid(Text, i, 1)) Then
            Links = i
            Exit For
        End If
    Next i
    '#suchen, wo die Zahl endet
    For i = Len(Text) To 1 Step -1
        If IsNumeric(Mid(Text, i, 1)) Then
            Rechts = i
            Exit For
        End If
    Next i
    '#Links oder Rechts von der gefundenen Zahl darf nix stehen (es darf nur eine W|fffd|hrungsangabe geben)
    If Not (Links = 1 Or Rechts = Len(Text)) Then
        Call Err.Raise(2000, , "|fffd|bergebener String liegt im falschen Format vor. (" & Text & ")")
    End If
    '######################## W|fffd|HRUNG ZERLEGEN ####################################
    '#pr|fffd|fen, wo die W|fffd|hrung steht und diese in StrCur merken
    If Links = 1 Then
        TEMP_CurAfterValue = True
        StrCur = Right$(Text, Len(Text) - Rechts)
    Else
        TEMP_CurAfterValue = False
        StrCur = Left$(Text, Links - 1)
    End If
    '#pr|fffd|fen, ob zwischen Wert und W|fffd|hrung ein Leerzeichen steht und W|fffd|hrung wegspeichern
    '#Variable TEMP_CurAfterValue wird ben|fffd|tigt, falls ein Leerzeichen zB am Anfang des Strings steht, aber nicht zwischen Zahl und String
    '#folglich muss das Leerzeichen links sein, wenn TEMP_CurAfterValue = True ist und umgekehrt
    If Left$(StrCur, 1) = " " And TEMP_CurAfterValue Then
        TEMP_CurWithSpace = True
        TEMP_Currency = Right$(StrCur, Len(StrCur) - 1)
    ElseIf Right$(StrCur, 1) = " " And Not TEMP_CurAfterValue Then
        TEMP_CurWithSpace = True
        TEMP_Currency = Left$(StrCur, Len(StrCur) - 1)
    Else
        TEMP_CurWithSpace = False
        TEMP_Currency = StrCur
    End If
    '######################## WERT ZERLEGEN ####################################
    '#gefundene Zahl als String speichern
    StrValue = Mid(Text, Links, Rechts - Links + 1)
    '#Links und Rechts neu initialisieren
    Links = 0
    Rechts = 0
    '#ersten Seperator von Links suchen (das ist der 'm|fffd|gliche' Tausendertrenner)
    For i = 1 To Len(StrValue) '#suchen wo keine Zahl mehr steht
        If Not IsNumeric(Mid(StrValue, i, 1)) Then
            Links = i
            Exit For
        End If
    Next i
    '#ab gefundener Position schauen, wo die erste Zahl wieder auftritt
    For i = Links + 1 To Len(StrValue)
        If IsNumeric(Mid(StrValue, i, 1)) Then
            Rechts = i - 1
            Exit For
        End If
    Next i
    '------------------------------------------------------
    If Links = 0 Or Rechts = 0 Then
        TEMP_Thousand_Seperator = "" '#keine Seperatoren vorhanden
        TEMP_Comma_Seperator = ""
    Else
        TEMP_Thousand_Seperator = Mid(StrValue, Links, Rechts - Links + 1) '#mgl. Tausenderseperator gefunden
        '--------------------------------------------------------------------------
        '#Suche nach mgl. Kommaseperator
        Links = 0 '#Links und Rechts neu initialisieren
        Rechts = 0
        '#ersten Seperator von Links suchen (das ist der 'm|fffd|gliche' Tausendertrenner)
        For i = Len(StrValue) To 1 Step -1 '#suchen wo keine Zahl mehr steht
            If Not IsNumeric(Mid(StrValue, i, 1)) Then
                Rechts = i
                Exit For
            End If
        Next i
        '#ab gefundener Position schauen, wo die erste Zahl wieder auftritt
        For i = Rechts - 1 To 1 Step -1
            If IsNumeric(Mid(StrValue, i, 1)) Then
                Links = i + 1
                Exit For
            End If
        Next i
        TEMP_Comma_Seperator = Mid(StrValue, Links, Rechts - Links + 1) '#mgl. Kommaseperator gefunden
    End If
    '------------------- PR|fffd|FUNG, der gefundenen M|fffd|GLICHEN SEPERATOREN
    '# wenn Seperatoren gleich, dann muss geschaut werden, ob es entweder kein Tausendertrenner oder kein Komma gibt
    If TEMP_Thousand_Seperator = TEMP_Comma_Seperator And TEMP_Comma_Seperator <> "" Then
        '#Wenn nur 1 Seperator in StrValue vorkommt, dann ist es der Kommaseperator
        If UBound(Split(StrValue, TEMP_Comma_Seperator)) - LBound(Split(StrValue, TEMP_Comma_Seperator)) = 1 Then
            TEMP_Thousand_Seperator = ""
        Else '#Wenn mehr als 1 Seperator vorkommt, dann ist es der Tausendertrenner
            TEMP_Comma_Seperator = ""
        End If
    End If
    '######################## ZAHL auslesen ########################################
    StrZAHL = Replace$(StrValue, TEMP_Thousand_Seperator, "")
    If TEMP_Comma_Seperator <> "" Then '#wenn es einen Kommaseperator gibt, die Kommastellen beachten
        VorKomma = Split(StrZAHL, TEMP_Comma_Seperator)(0)
        NachKomma = Split(StrZAHL, TEMP_Comma_Seperator)(1)
        GetValueFromStringAndSetFormat = CDbl(VorKomma) + CDbl(NachKomma / (10 ^ (Len(NachKomma))))
    Else '#in diesem Fall = GANZZAHL
        GetValueFromStringAndSetFormat = CDbl(StrZAHL)
    End If
    '######################## FORMAT setzen #####################
    Dim OLD_Currency As String
    Dim OLD_CurWithSpace As Boolean
    Dim OLD_CurAfterValue As Boolean
    Dim OLD_Thousand_Seperator As String
    Dim OLD_Comma_Seperator As String
    '#alte Werte wegspeichern, vor dem Formatsetzen, denn wenn ein Fehler auftritt, dann altes Format wiederherstellen
    OLD_Currency = Me.GetCurrency
    OLD_CurWithSpace = Me.GetCurrencyWithSpace
    OLD_CurAfterValue = Me.GetCurrencyAfterValue
    OLD_Thousand_Seperator = Me.GetThousandSeperator
    OLD_Comma_Seperator = Me.GetCommaSeperator
    
    Call SetFormat(TEMP_Currency, TEMP_CurWithSpace, TEMP_CurAfterValue, TEMP_Thousand_Seperator, TEMP_Comma_Seperator)
    
    If Text <> Me.FormatValue(GetValueFromStringAndSetFormat, Len(NachKomma)) Then '#im Fehlerfall
        Call SetFormat(OLD_Currency, OLD_CurWithSpace, OLD_CurAfterValue, OLD_Thousand_Seperator, OLD_Comma_Seperator)
        Call Err.Raise(2001, , "|fffd|bergebener String liegt im falschen Format vor. (" & Text & ")")
    End If
End Function


Public Property Get GetCurrency() As String
    GetCurrency = M_Currency
End Property

Public Property Get GetCurrencyWithSpace() As Boolean
    GetCurrencyWithSpace = M_CurWithSpace
End Property

Public Property Get GetCurrencyAfterValue() As Boolean
    GetCurrencyAfterValue = M_CurAfterValue
End Property

Public Property Get GetCommaSeperator() As String
    GetCommaSeperator = M_Comma_Seperator
End Property

Public Property Get GetThousandSeperator() As String
    GetThousandSeperator = M_Thousand_Seperator
End Property

Public Function preis_ohne_wehrung(preis As String) As String

    Dim my_d As Double
    Dim my_coma As String
    Dim my_tausend As String
    Dim my_preis As CurrencyFormatter
    Set my_preis = New CurrencyFormatter
    
    If preis <> "" Then
        my_d = my_preis.GetValueFromStringAndSetFormat(preis)
        my_coma = my_preis.GetCommaSeperator
        my_tausend = my_preis.GetThousandSeperator
        Call my_preis.SetFormat("", False, False, my_tausend, my_coma)
        preis_ohne_wehrung = my_preis.FormatValue(my_d)
    Else
        preis_ohne_wehrung = ""
    End If
    
End Function

Attribute VB_Name = "RegionalOffice"
Attribute VB_Base = "0{4EDB304C-E1C1-4F14-9D8D-307011A23A92}{A9FF82C3-D519-4604-84B9-DDFD3F9A7A20}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False




Private Sub CommandButton1_Click()
RegionalOffice.Hide
RegionIndex = RegionalOffice.office.ListIndex
ClosingIndex = RegionalOffice.lst_closing.ListIndex
modifyRegionBookmarks RegionIndex + 1, ClosingIndex + 1
ActiveDocument.PrintPreview
ActiveDocument.ClosePrintPreview
End Sub

Private Sub office_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
RegionalOffice.Hide
RegionIndex = RegionalOffice.office.ListIndex
modifyRegionBookmarks RegionIndex + 1, ClosingIndex + 1
ActiveDocument.PrintPreview
ActiveDocument.ClosePrintPreview
End Sub

Attribute VB_Name = "ThisDocument"
Attribute VB_Base = "1Normal.ThisDocument"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = True
Attribute VB_Customizable = True
Option Explicit

Attribute VB_Name = "clsFeatures"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       clsFeatures - Provide flags for run-time determination of feature sets.
' Creation:     2007/08/06
' Modifications:
'   2007/08/06  DAH     Added.
'   2007/08/16  DAH @01 Added Property HideDescriptionsOnDetailTables().
'   2007/09/20  DAH @02 Response Times now go in Headers on LONG versions also.
'   2007/09/29  DAH @03 Added clsFeatures.UseBTextIfBlankETextInGlossary.
'   2008/03/24  DAH @04 Added processing for Sales Template.
'   2008/08/03  DAH @05 Added List Price Template, tightened up all other unused code.
'   2008/08/07  DAH @06 Added Lock switch.
'-----------------------------------------------------------------------------

Option Explicit

Private mobjDocument       As Document
Private mstrTemplateFormat As String
Private mblnShowListPrices As Boolean '@05
Private mblnLockDocument   As Boolean '@06

Public Property Get Document() As Document
    Set Document = mobjDocument
End Property

Public Property Set Document(ByVal doc As Document)
    If Not mobjDocument Is Nothing Then
        ClearFeatures
    End If
    Set mobjDocument = doc
    LoadFeatures
End Property

Public Property Get TemplateFormat() As String
    TemplateFormat = mstrTemplateFormat
End Property

' Allowable (case-insensitive) values are: Sales, List
' If one of the above values is not provided, default functioning is provided.
' The heavy lifting is done here.
Public Property Let TemplateFormat(ByVal vNewValue As String)
    vNewValue = UCase$(RTrimWhite(vNewValue)) ' strip off any cr/lf/etc. and go upper
    mstrTemplateFormat = vNewValue
    ShowListPrices = CBool(vNewValue = "LIST") '@05
    LogMessage 3, "TemplateFormat = """ & vNewValue & """"   '@04
End Property

' This feature is usually controlled by TemplateFormat.
Public Property Get ShowListPrices() As Boolean '@05
    ShowListPrices = mblnShowListPrices
End Property

Public Property Let ShowListPrices(ByVal vNewValue As Boolean) '@05
    mblnShowListPrices = vNewValue
End Property

' This feature is usually controlled by TemplateFormat.
Public Property Get LockDocument() As Boolean '@06
    LockDocument = mblnLockDocument
End Property

Public Property Let LockDocument(ByVal vNewValue As Boolean) '@06
    mblnLockDocument = vNewValue
End Property

Private Sub ClearFeatures()
    TemplateFormat = vbNullString
End Sub

Private Sub LoadFeatures()
    If Document Is Nothing Then Exit Sub
    LoadTemplateFormat
    LoadLockDocument '@06
End Sub

Private Sub LoadTemplateFormat()
    Const cBkNameTemplateFormat As String = "TemplateFormat"
    If Document.Bookmarks.Exists(cBkNameTemplateFormat) Then
        With Document.Bookmarks(cBkNameTemplateFormat).Range
            TemplateFormat = .Text
            .Delete ' Delete the text.
        End With
    Else
        TemplateFormat = vbNullString
    End If
End Sub

Private Sub LoadLockDocument() '@06
    Const cBkNameLockDoc As String = "LockDoc"
    If Document.Bookmarks.Exists(cBkNameLockDoc) Then
        With Document.Bookmarks(cBkNameLockDoc).Range
            LockDocument = CBool(UCase$(Trim$(.Text)) = "LOCK")
            .Delete ' Delete the text.
        End With
    Else
        LockDocument = False
    End If
End Sub
Attribute VB_Name = "clsRecordsetFilter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Module:       clsRecordsetFilter
' Purpose:      ADODB.Recordset helper class - stores filters and bookmarks for later restoration
' Assumptions:
' Creation:     2007/03/31
' Author:       David Horowitz
' Use:          SetFilter, followed by Set/Restore paired calls
'               Sorry, the use of Set/Restore cannot be nested.
'               Instead, create another instance of the class.
' Modifications:
'   2007/03/31  DAH     Created this module.
'   2008/08/26  DAH @01 Checking for "AS" for roots now to accommodate data weirdness for MultiModality.
'-----------------------------------------------------------------------------

Option Explicit

Private mvarPreviousBookmark As Variant
Private mvarPreviousFilter As Variant
Private mobjRS As ADODB.Recordset
Private Const cNoBookmark = -1

Public Sub SetFilter(rs As ADODB.Recordset, ByVal Filter As String)
    On Error GoTo SetFilter_Error
        Set mobjRS = rs
        With rs
            mvarPreviousBookmark = .Bookmark
            mvarPreviousFilter = .Filter
            .Filter = Filter
        End With
    Exit Sub

SetFilter_Error:
    LogMessage 1, "clsRecordsetFilter::SetFilter"
    Resume Next
End Sub

Public Sub RestoreFilter()
    With mobjRS
        .Filter = mvarPreviousFilter
        If mvarPreviousBookmark <> cNoBookmark Then .Bookmark = mvarPreviousBookmark
        mvarPreviousBookmark = cNoBookmark
        mvarPreviousFilter = adFilterNone
    End With
End Sub

' Special case you can use.
'@01 Now checking for [Position Code]='AS' also.
Public Sub SetFilterOnRootSystems(rs As ADODB.Recordset)
    SetFilter rs, "[Parent Quote Item Id]=Null AND [Position Code]='AS'"
End Sub

Private Sub Class_Initialize()
    mvarPreviousBookmark = cNoBookmark
    mvarPreviousFilter = adFilterNone
End Sub

Public Property Set rs(rs As ADODB.Recordset)
    Set mobjRS = rs
End Property

Public Property Get rs() As ADODB.Recordset
    Set rs = mobjRS
End Property

Attribute VB_Name = "clsSourceTables"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Module:       clsSourceTables
' Purpose:      Provide access to the source data elements in the source document.
' Assumptions:  All data needed is present in the document.
' Creation:     2007/03/24
' Author:       David Horowitz
' Use:          Call Set Document, followed by Tables("Name")
' Modifications:
'   2007/03/24  DAH Created this module.
'   2007/05/01  DAH @01 Added Glossary.
'   2007/10/19  DAH @02 Glossary table mechanism revamped; no table sent in.
'   2008/03/24  DAH @03 New Table indices for Sales.
'   2008/04/03  DAH @04 Revamped for Sales.
'-----------------------------------------------------------------------------

Option Explicit

Private mobjDocument As Document

Public Property Get Document() As Document
    Set Document = mobjDocument
End Property

Public Property Set Document(ByVal doc As Document)
    Set mobjDocument = doc
End Property

' pseudo-collection
Public Property Get Tables(ByVal Name As String) As Word.Table
    Set Tables = GetTableFromBookmark(Name)
End Property

' Returns the next Table after the Bookmark.
' Returns Nothing if Bookmark not found.
Public Function GetTableFromBookmark(ByVal BookmarkName As String) As Word.Table
    If mobjDocument Is Nothing Then Exit Function
    If Not mobjDocument.Bookmarks.Exists(BookmarkName) Then Exit Function
    Set GetTableFromBookmark = GetTableFromRangeStart(mobjDocument.Bookmarks(BookmarkName).Range.start)
End Function

Public Function GetTableFromRangeStart(ByVal start As Long) As Word.Table
    Dim t As Word.Table
    For Each t In mobjDocument.Tables
        If t.Range.start >= start Then
            Set GetTableFromRangeStart = t
            Exit Function
        End If
    Next t
End Function

Attribute VB_Name = "clsSystemEmitter"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Module:       clsSystemEmitter
' Purpose:      Emits Systems (Detail Records)
' Assumptions:
' Creation:     2007/03/31
' Author:       David Horowitz
' Use:          Call EmitSystem with all the required paramters.
'               Afterwards, you should update your Range variable with .Range.
' Modifications:
'   2007/03/31 DAH     Created this module.
'   2008/04/04 DAH     Gutted from Service and reworked for Sales.
'   2008/04/21 DAH @01 Added more spacing.
'   2008/05/06 DAH @02 Removed Unit Price display. Use "Extended Net Price".
'                  @03 Print totals - created EmitTableFooter().
'   2008/06/02 DAH @03 Change the Total language.
'   2008/06/03 DAH @04 Added B-Text Suppression via field "B-Text Print".
'                  @05 Added Price Suppression via field "Price Print Suppress".
'   2008/06/10 DAH @06 Don't suppress Qty if Price Print Suppressed.
'                  @07 Don't print "Extended Net Price" if all prices are duppressed.
'                  @08 Suppress Print for Summary Table
'   2008/06/12 DAH @09 New A Rel Group processing.
'   2008/06/20 DAH @10 Suppress Print now works for all Relevancies, as per Dennis Huston.
'                  @11 Moved Qty left, centered it, added underlines for Initials.
'   2008/06/23 DAH @12 Suppress Print at the AS level.
'                  @13 B-Text Print at the AS level.
'                  @14 Price Print Suppress at the AS level.
'                  @15 Handle the situation in which a user might suppress all line items
'                      in a system, and then the system needs to be removed.
'   2008/06/24 DAH @16 "Alternative" -> "Alternate"
'                  @17 Make SystemNumberString consistent
'   2008/06/25 DAH @18 "Extended Net Price" -> "Incremental Net Price" for Alternate products.
'                  @19 Extra language before the Proposal Price Summary.
'                  @20 On Summary, change "Extended Price" to "Contract Total".
'                  @21 On Summary, do not print +/-.
'   2008/06/29 DAH @22 On Summary, for alternate systems,
'                      print Extended Net Price instead of Delta Price.
'   2008/07/01 DAH @23 Increase Price column width to accommodate "Incremental Net Price".
'                  @24 Tweaks to Proposal Price Summary, Column 2.
'   2008/07/03 DAH @25 Added Quote # / Rev at beginning of system.
'   2008/07/15 DAH @26 New system header.
'   2008/07/18 DAH @27 Proposal Price Summary text now 10pt to match other text.
'                  @28 Consecutively number DISPLAYED systems.
'   2008/07/27 DAH @29 Colon between IncoTerms.
'                  @30 When no Purchasing Agreement, display "Not Applicable".
'                  @31 Place Alternate product section before the Optional product section.
'                  @32 Change Optional and Alternate products headings.
'                  @33 Proposal Price Summary: Remove the System number column.
'   2008/07/28 DAH @34 Remove "System #" from the system header.
'   2008/07/29 DAH @35 Read system name from AS line instead of first PS line.
'                  @36 Proposal Price Summary: Move Relevancy indication to after system name.
'   2008/07/30 DAH @37 Local No Print Flag for Products.
'   2008/08/03 DAH @38 Added List Price Template, revamp use of gobjFeatures.
'   2008/08/05 DAH @39 Correct logic error in getting pricing info.
'                  @40 Adjust tab settings for contract totals.
'                  @41 Tweak language: "Alternates:" -> "ALTERNATE PRODUCTS:"
'                  @42 Tweak to complete @30
'                  @43 Tweak to correct an error in @06
'   2008/08/06 DAH @44 Reduce prices (Style PTAmount) to 8pt.
'                  @45 Reduce totals to 8pt and realign.
'                  @46 Revamp columns.
'   2008/08/07 DAH @47 Reduce prices and initials headings to 8pt.
'   2008/08/07 DAH @48 Make Total Bold 10pt.
'   2008/08/11 DAH @49 Tweak Totals formatting as per CSG Sales.
'   2008/08/12 DAH @50 Add RemoveSeeEndMessages.
'   2008/08/14 DAH @51 Pricing field adjustments.
'   2008/08/18 DAH @52 Move total prices over a bit to the right.
'                  @53 Correct InchresToPoints oversight.
'   2008/08/26 DAH @54 MultiModality
'                  @55 "Non-Discounted Extended Price" -> "Ext List Price"
'   2008/09/02 DAH @56 Relevant total prices change from 8pt to 10pt.
'                  @57 "Total Net Price" -> "Total Price"
'                  @58 Change total display
'                  @59 Change price column headings
'                  @60 Change Proposal Price Summary headings back to 10pt, reversing @47.
'   2008/09/03 DAH @61 Show List Price OR Net Price, not both.
'                  @62 Summary table only shown if it contains O or A systems.
'   2008/09/16 DAH @63 Negate the Discount on List Price proposals.
'                  @64 Use Parens around negative numbers on totals.
'   2008/09/18 DAH @65 Alternate prices don't multiply by Quantity.
'                  @66 Show Delta Price for A's even on List Price format.
'-----------------------------------------------------------------------------

Option Explicit

'-----------------------------------------------------------------------------
' Below is the call hierarchy. EmitSystem is the main external entry point.
' Range(Get) is the only other Public member.
'
'Range
'EmitSystem
'  SetVars
'  EmitSystemHeader
'    EmitSystemHeaderTable
'    EmitSystemHeaderText
'  EmitRecords
'    EmitTableHeader
'    BeginTable
'    EmitRecord
'    EndTable
'      FormatTable
'        DefineStyles
'          StylesExist
'          CreateNewStyle
'        SetColumnWidths
'    EmitTableFooter
'  EmitSystemFooter
'-----------------------------------------------------------------------------

' PT = Parts Table
Const cStyleNamePTTitleHeader = "PTTitleHeader" ' "<System> Configuration" / "Optional" / "Alternate", etc.
Const cStyleNamePTHeaderRow = "PTHeaderRow"
Const cStyleNamePTHeaderRowRight = "PTHeaderRowRight"
Const cStyleNamePTHeaderRowCenter = "PTHeaderRowCenter" '@11
Const cStyleNamePTQuantity = "PTQuantity" '@11
Const cStyleNamePTPartNumber = "PTPartNumber"
Const cStyleNamePTPartName = "PTPartName"
Const cStyleNamePTDescription = "PTDescription" ' B-Text or E-Text
Const cStyleNamePTAlternativeMessage = "PTAlternate" ' the Alternative Message '@16
Const cStyleNamePTAmount = "PTAmount"           ' applies to Qty, Unit Price, Price

Private Const SecretAltCode As String = "AAAAA" '@09

Private Enum dcDetailColumnType '@11 for detail tables '@38
    dcQuantity = 1
    dcPartNumber
    dcDescription
    dcPrice '@61
    dcInitials
    dcSecretAltCode = 2
    dcBText = dcDescription
    dcAltMessage = dcDescription
End Enum

Private Enum scDetailColumnType '@11 for summary table, @38
    scQuantity = 1 '@11
    scConfiguration
    scPrice
    scInitials
End Enum

Private mobjRng               As Word.Range
Private mobjRS                As ADODB.Recordset
Private mstrRootSystemId      As String
Private mintRootItemNumber    As Integer '@28 number DISPLAYED systems consecutively
Private mrfRootRelevancyFlag  As RelevancyFlags
Private mobjSummaryTextTable  As New clsTextTable ' to build the Summary table
Private mblnRootBTextSuppress As Boolean '@13
Private mblnRootPriceSuppress As Boolean '@14
Private mblnAnyRecordsAdded   As Boolean '@15 handled by Begin/AddTo/EndSummaryTable()
Private mblnAnyNonRSystemsAdded As Boolean '@61 handled by Begin/AddTo/EndSummaryTable()
Private mstrQuoteNumber       As String  '@25 use Property to Let
Private mstrRevisionNumber    As String  '@25 use Property to Let
Private mstrPaymentTerm       As String  '@26
Private mstrIncoTerms1        As String
Private mstrIncoTerms2        As String
Private mstrPurchasingAgreement As String
Private mblnPaymentTerm       As Boolean
Private mblnIncoTerms1        As Boolean
Private mblnIncoTerms2        As Boolean
Private mblnPurchasingAgreement As Boolean
Private mstrSystemName        As String  '@35
' Watch these - they are shared use and non-reentrant
Private mobjTextTable         As New clsTextTable ' for temporary use
Private mobjTbl               As Word.Table ' for temporary use

Public Function EmitSystem( _
            ByRef rng As Word.Range, _
            ByRef rs As ADODB.Recordset, _
            ByVal RootSystemId As String, _
            ByVal RecordNumber As Integer, _
            ByVal TotalRecords As Integer _
        ) As Boolean
    Dim RecordsAdded As Boolean '@15
    Dim retval As Boolean
    retval = True
    SetVars rng, rs, RootSystemId, RecordNumber
    If RecordNumber = 1 Then retval = retval And BeginSummaryTable
    If FieldValue(rs, "Suppress Print") <> "Y" Then '@12
        '@15 moved into EmitRecords(): retval = retval And EmitSystemHeader
        RecordsAdded = False                                            '@15
        retval = retval And EmitRecords(rfRelevant, RecordsAdded)       '@15
        retval = retval And EmitRecords(rfAlternative, RecordsAdded)    '@15, @31
        retval = retval And EmitRecords(rfOptional, RecordsAdded)       '@15, @31
        If RecordsAdded Then '@15
            retval = retval And EmitSystemFooter '@01
            retval = retval And AddToSummaryTable
        End If
    End If '@12
    If RecordNumber = TotalRecords Then retval = retval And EndSummaryTable
    Set rng = mobjRng ' set ByRef parameter
    EmitSystem = retval
End Function

Private Sub SetVars( _
            ByRef rng As Word.Range, _
            ByRef rs As ADODB.Recordset, _
            ByVal RootSystemId As String, _
            ByVal RecordNumber As Integer _
        )
    Set mobjRng = rng
    Set mobjRS = rs
    mstrRootSystemId = RootSystemId
    If RecordNumber = 1 Then '@28 used to be just mintRootItemNumber = RecordNumber
        mintRootItemNumber = 1
    Else
        mintRootItemNumber = mintRootItemNumber + 1
    End If
    mrfRootRelevancyFlag = Rel2RelevancyFlag(FieldValue(rs, "Rel"))
    mblnRootBTextSuppress = CBool(FieldValue(rs, "B-Text Print") = "Y") '@13
    '@13, by the way, just so you don't think you're crazy, the field is
    'called "B-Text Print", but if it's "Y", it means to SUPPRESS the printing
    'of B-Text.
    mblnRootPriceSuppress = CBool(FieldValue(rs, "Price Print Suppress") = "Y") '@14
    mstrPaymentTerm = FieldValue(mobjRS, "Payment Term") '@26
    mstrIncoTerms1 = FieldValue(mobjRS, "Incoterms 1")
    mstrIncoTerms2 = FieldValue(mobjRS, "Incoterms 2")
    mstrPurchasingAgreement = FieldValue(mobjRS, "Purchasing Agreement")
    mblnPaymentTerm = CBool(LenB(mstrPaymentTerm) <> 0)
    mblnIncoTerms1 = CBool(LenB(mstrIncoTerms1) <> 0)
    mblnIncoTerms2 = CBool(LenB(mstrIncoTerms2) <> 0)
    mblnPurchasingAgreement = CBool(LenB(mstrPurchasingAgreement) <> 0)
    mstrSystemName = FieldValue(mobjRS, "Description") '@35
    GetNewQuoteInfo '@54
End Sub

Private Function EmitSystemHeader() As Boolean
    Dim retval As Boolean
    retval = True
    If retval Then retval = EmitSystemHeaderTable
    If retval Then retval = EmitSystemHeaderText
    EmitSystemHeader = retval
End Function

Private Function EmitSystemHeaderTable() As Boolean '@26
    On Error GoTo EmitSystemHeaderTable_Error
    
    ' Create the table.
    With mobjTextTable
        .Clear
        .AddCell "Quote Nr:"
        .AddCell mstrQuoteNumber & "  Rev. " & mstrRevisionNumber
        .EndOfRow
        If mblnPaymentTerm Or mblnIncoTerms1 Or mblnIncoTerms2 Then
            If mblnPaymentTerm Then
                .AddCell "Terms of Payment:"
                .AddText mstrPaymentTerm
                If mblnIncoTerms1 Or mblnIncoTerms2 Then
                    .AddText SpecialCharacter
                End If
            Else
                .AddCell vbNullString
            End If
            If mblnIncoTerms1 Then
                .AddText mstrIncoTerms1
                If mblnIncoTerms2 Then
                    .AddText ": " '@29
                End If
            End If
            If mblnIncoTerms2 Then
                .AddText mstrIncoTerms2
            End If
            .AddCell vbNullString ' finish it off
            .EndOfRow
        End If
        .AddCell "Purchasing Agreement:" '@30 unconditional, @42
        If mblnPurchasingAgreement Then
            .AddCell mstrPurchasingAgreement
        Else
            .AddCell "Not Applicable" '@30
        End If
        .EndOfRow
        Set mobjTbl = .ConvertToTable(mobjRng, False) ' We'll draw our own borders.
        .Clear
    End With 'mobjTextTable
    ReplaceSpecialCharacterWithParagraphMarks mobjTbl.Range
    
    ' Format the table.
    Set mobjRng = mobjTbl.Range
    With mobjRng
        With .Font ' yyy styles
            .Name = "Arial"
            .Size = 11
            .Bold = True
        End With
        With mobjTbl
            If .Rows.Count > 1 Then
                .Cell(2, 2).Range.Font.Bold = False
                With .Rows(1)
                    .HeightRule = wdRowHeightAtLeast
                    .Height = 24 ' 2 12-pt lines
                End With
                If .Rows.Count > 2 Then
                    .Cell(3, 2).Range.Font.Bold = False
                    With .Rows(2)
                        .HeightRule = wdRowHeightAtLeast
                        .Height = 24 ' 2 12-pt lines
                    End With
                End If
            End If
            .Cell(1, 1).TopPadding = InchesToPoints(0.08)
            SetColumnWidths .Columns, Array(2.95, 4.3)
        End With ' mobjTbl
        ' Create top and bottom horizontal lines. Could have used borders
        ' but they don't work right.
        .Parent.Range(.start - 1, .start - 1).InlineShapes.AddHorizontalLineStandard
        .Collapse Direction:=wdCollapseEnd
        .InlineShapes.AddHorizontalLineStandard
        .start = .start + 1
        
        ' Set up the next position.
        .InsertParagraphAfter: .InsertParagraphAfter
        .Font.Size = 10
        .Collapse Direction:=wdCollapseEnd
    End With 'mobjRng
    EmitSystemHeaderTable = True
    Exit Function

EmitSystemHeaderTable_Error:
    LogMessage 1, "clsSystemEmitter::EmitSystemHeaderTable"
    Resume Next
End Function

Private Function EmitSystemHeaderText() As Boolean
    Dim strSystemName As String
    Dim strOptAlt As String '@16, @17
    If IsOptional(mrfRootRelevancyFlag) Then
        strOptAlt = " - Option"
    ElseIf IsAlternative(mrfRootRelevancyFlag) Then
        strOptAlt = " - Alternate"
    End If
'@35strSystemName = FieldValue(mobjRS, "Description") & strOptAlt
    strSystemName = mstrSystemName & strOptAlt
    AddTOCEntry mobjRng, strSystemName '@16
    With mobjRng
'@34    .InsertAfter "System #" & mintRootItemNumber & ": " & strSystemName
        .InsertAfter strSystemName
        With .Font ' YYY make a style
            .Name = "Arial": .Size = 12: .Bold = True
        End With
        .Collapse Direction:=wdCollapseEnd
        .InsertAfter vbCrLf & vbCrLf
        .ParagraphFormat.KeepWithNext = True
        .Font.Size = 8 ' YYY make a style
        .Collapse Direction:=wdCollapseEnd
    End With
    EmitSystemHeaderText = True
End Function

#If False Then '@33
Private Function GetSystemNumberString() As String '@17
    Dim s As String
    s = "System #" & mintRootItemNumber
    If IsOptional(mrfRootRelevancyFlag) Then
        s = s & " - Option"
    ElseIf IsAlternative(mrfRootRelevancyFlag) Then
        s = s & " - Alternate" '@16
    End If
    GetSystemNumberString = s
End Function
#End If '@33

'@15 Upon return, Added tells you if any records were added.
'We do NOT change Added unless we add records. Otherwise it will be sent back
'with whatever value it was passed in with. This is so you can combine
'multiple calls for different relevancies.
Private Function EmitRecords( _
            ByVal RelevancyFlag As RelevancyFlags, _
            ByRef Added As Boolean _
        ) As Boolean '@15
    Dim objRSFilter As New clsRecordsetFilter
    Dim blnRecordsEmitted As Boolean ' Indicates if records have been added IN THIS CALL.
    Dim rfRecordRelevancyFlag As RelevancyFlags
    Dim retval As Boolean
    
    retval = True
    objRSFilter.SetFilter mobjRS, "[Root Quote Item Id]='" & mstrRootSystemId & "'"
        Do While Not mobjRS.EOF
            Select Case FieldValue(mobjRS, "Position Code")
                Case "AS"
                    ' Do nothing.
                Case "PS", "PL"
                    rfRecordRelevancyFlag = Rel2RelevancyFlag(FieldValue(mobjRS, "Rel"))
                    If RelevancyFlag <> rfRecordRelevancyFlag Then GoTo GotoNextRecord ' relevancy match
                    '@10 If Not IsOptional(RelevancyFlag) Then GoTo ReadyToEmit
                    If FieldValue(mobjRS, "Suppress Print") = "Y" Then GoTo GotoNextRecord
                    If FieldValue(mobjRS, "Local No Print Flag") = "Y" Then GoTo GotoNextRecord '@37
ReadyToEmit:        If Added Then GoTo CheckThisTable        '@15
                    If retval Then retval = EmitSystemHeader '@15
                    Added = True                             '@15
                    GoTo EmitTableHeader                     '@15
CheckThisTable:     If blnRecordsEmitted Then GoTo JustEmitTheRecord
EmitTableHeader:    If retval Then retval = EmitTableHeader(RelevancyFlag)
                    If retval Then retval = BeginTable(RelevancyFlag)
                    blnRecordsEmitted = True
JustEmitTheRecord:  If retval Then retval = EmitRecord(RelevancyFlag)
                Case "AE"
                    If FieldValue(mobjRS, "Parent Quote Item Id") = _
                                          mstrRootSystemId Then
                        Exit Do ' buh-bye!
                    End If
            End Select
GotoNextRecord:
            mobjRS.MoveNext
        Loop
        If blnRecordsEmitted Then
            If retval Then retval = EndTable(RelevancyFlag)
            If retval Then retval = EmitTableFooter(RelevancyFlag) '@03
        End If
    objRSFilter.RestoreFilter
    EmitRecords = True
End Function

'@32 redone
Private Function EmitTableHeader(ByVal RelevancyFlag As RelevancyFlags) As Boolean
    Dim str As String
    With mobjRng
        If IsRelevant(RelevancyFlag) Then
            str = vbCrLf & "All items listed below are included for this "
            If IsOptional(mrfRootRelevancyFlag) Then
                str = str & "optional "
            ElseIf IsAlternative(mrfRootRelevancyFlag) Then
                str = str & "alternate " '@16
            End If
            str = str & "system:"
            .InsertAfter str
            With .Font
                .Name = "Arial"
                .Size = 10 '@32
                .Bold = True
            End With
            .ParagraphFormat.KeepWithNext = True
            .Collapse Direction:=wdCollapseEnd
            .InsertAfter " (See Detailed Technical Specifications at end of Proposal.)" & vbCrLf & vbCrLf
            With .Font ' YYY style
                .Name = "Arial"
                .Size = IIf(IsRelevant(RelevancyFlag), 10, 9) '@62,@64 was 8
                .Italic = True
                .Bold = False
            End With
            .Bookmarks.Add GetBookmarkName(mstrRootSystemId, "R"), .Parent.Range(.start, .End - 2) '@50
        Else
'@31        If IsOptional(RelevancyFlag) Then '@01
            If IsAlternative(RelevancyFlag) Then '@01, @31
                .InsertAfter vbCrLf & vbCrLf & vbCrLf ' YYY consider SpaceBefore or After
            Else
                .InsertAfter vbCrLf
            End If
            .Collapse Direction:=wdCollapseEnd
            str = IIf(IsOptional(RelevancyFlag), "OPTIONS:", "ALTERNATE PRODUCTS:") & vbCrLf & vbCrLf '@16, @32, @41
            .InsertAfter str
            With .Font
                .Name = "Arial"
                .Size = 10 '@32
                .Bold = True
            End With
        End If
        .ParagraphFormat.KeepWithNext = True
        .Collapse Direction:=wdCollapseEnd
        .ParagraphFormat.KeepWithNext = False
    End With ' mobjRng
    EmitTableHeader = True
End Function

#If False Then '@32
Private Function EmitTableHeader(ByVal RelevancyFlag As RelevancyFlags) As Boolean
    Dim str As String
    With mobjRng
        If IsRelevant(RelevancyFlag) Then
            str = vbCrLf & "All items listed below are included for this "
            If IsOptional(mrfRootRelevancyFlag) Then
                str = str & "optional "
            ElseIf IsAlternative(mrfRootRelevancyFlag) Then
                str = str & "alternate " '@16
            End If
            str = str & "system: "
        Else
'@31        If IsOptional(RelevancyFlag) Then '@01
            If IsAlternative(RelevancyFlag) Then '@01, @31
                .InsertAfter vbCrLf & vbCrLf & vbCrLf ' YYY consider SpaceBefore or After
            Else
                .InsertAfter vbCrLf
            End If
            .Collapse Direction:=wdCollapseEnd
            str = "The " & IIf(IsOptional(RelevancyFlag), "Options", "Alternates") & _
                  " listed below will be included only if initialed: " '@16
        End If
        .InsertAfter str
        With .Font
            .Name = "Arial"
            .Size = IIf(IsRelevant(RelevancyFlag), 10, 9) '@62,@64 was 8
            .Bold = True
        End With
        .ParagraphFormat.KeepWithNext = True
        .Collapse Direction:=wdCollapseEnd
        .InsertAfter "(See Detailed Technical Specifications at end of Proposal.)" & vbCrLf & vbCrLf
        With .Font ' YYY style
            .Name = "Arial"
            .Size = IIf(IsRelevant(RelevancyFlag), 10, 9) '@62,@64 was 8
            .Italic = True
            .Bold = False
        End With
        .ParagraphFormat.KeepWithNext = True
        .Collapse Direction:=wdCollapseEnd
        .ParagraphFormat.KeepWithNext = False
    End With ' mobjRng
    EmitTableHeader = True
End Function
#End If '@32

Private Function BeginTable(ByVal RelevancyFlag As RelevancyFlags) As Boolean
    With mobjTextTable
        .Clear
        .AddCell "Qty" '@11
        .AddCell "Part No."
        .AddCell "Item Description"
        If IsAlternative(RelevancyFlag) Then '@59
            .AddCell "Incremental Price"
        Else
            .AddCell "Extended Price"
        End If
        If Not IsRelevant(RelevancyFlag) Then '@38 move down here
            .AddCell "Initial to Accept"
        End If
        .EndOfRow
    End With ' mobjTextTable
    BeginTable = True
End Function

Private Function EmitRecord(ByVal RelevancyFlag As RelevancyFlags) As Boolean
    Dim blnPriceSuppressed As Boolean '@05
    Dim Quantity As String
    Dim price As String '@66
    With mobjTextTable
        
        '@38 moved up here
        If IsRelevant(RelevancyFlag) Then '@05
            If mblnRootPriceSuppress Then '@14
                blnPriceSuppressed = True
            ElseIf FieldValue(mobjRS, "Price Print Suppress") = "Y" Then
                blnPriceSuppressed = True
                ' do it this way for a short-circuit And since VBA doesn't have it
            End If
        End If
        ' We need either just Qty, or all pricing info now:
        If blnPriceSuppressed Then '@39 moved up here
            Quantity = FieldValue(mobjRS, "Quantity", "0")
        Else
            GetPriceInfo Quantity, price, RelevancyFlag '@38, @66
        End If
        
        ' Quantity @11
        .AddCell Quantity '@06 always print
        
        ' Part No.
        .AddCell FieldValue(mobjRS, "Product")
        
        ' Item Description
        .AddCell FieldValue(mobjRS, "Description")
        
        ' Price @38, @61
        If blnPriceSuppressed Then '@05
            .AddCell vbNullString ' List Price
        Else
            .AddCell CurrencyFormat(price, Not IsRelevant(RelevancyFlag)) ' Price @66
        End If
        
        ' Initial to Accept '@38 moved to the end
        If Not IsRelevant(RelevancyFlag) Then
            .AddCell vbNullString ' Intentionally left blank for Customer Initials.
        End If
        
        .EndOfRow
        
        ' Show B-Text on 2nd row and in 2nd column, if it's not suppressed and
        ' if it exists. @11 3rd column
        If Not mblnRootBTextSuppress Then '@13
            If FieldValue(mobjRS, "B-Text Print") <> "Y" Then '@04, @09
                Dim BText As String
                BText = FieldValue(mobjRS, "B-Text")
                If LenB(BText) <> 0 Then
                    .AddCell vbNullString ' Quantity @11
                    .AddCell vbNullString ' Part No.
                    .AddCell FieldValue(mobjRS, "B-Text")
                    .AddCell vbNullString ' Price @61
                    If Not IsRelevant(RelevancyFlag) Then
                        .AddCell vbNullString ' Initial to Accept @38
                    End If
                    .EndOfRow
                End If
            End If '@09
        End If '@13
        '@09 Show Alternative link message, if it exists.
        If IsAlternative(RelevancyFlag) Then
            Dim RelGroup As String, Product As String, Description As String
            Dim AlternativeLinkMessage As String
            RelGroup = "R" & Mid$(FieldValue(mobjRS, "Rel Group"), 2)
            If Len(RelGroup) > 1 Then
                GetProductAndDescription RelGroup, Product, Description
                If LenB(Product) <> 0 Then
                    AlternativeLinkMessage = GetAlternativeLinkMessage(Product, Description)
                    .AddCell vbNullString  ' Quantity @11
                    .AddCell SecretAltCode ' Part No. - secret code
                    .AddCell AlternativeLinkMessage ' Alternative Link Message
                    .AddCell vbNullString ' Price @61
                    If Not IsRelevant(RelevancyFlag) Then
                        .AddCell vbNullString ' Initial to Accept @38
                    End If
                    .EndOfRow
                End If
            End If
        End If '@09
        
    End With ' mobjTextTable
    
    EmitRecord = True
End Function

Private Sub GetProductAndDescription( _
            ByRef RelGroup As String, _
            ByRef Product As String, _
            ByRef Description As String _
        ) '@09
    Dim objRSFilter As New clsRecordsetFilter
    objRSFilter.SetFilter mobjRS, _
                "[Parent Quote Item Id]='" & mstrRootSystemId & "' AND " & _
                "[Rel Group]='" & RelGroup & "'"
        If mobjRS.RecordCount = 1 Then
            Product = FieldValue(mobjRS, "Product")
            Description = FieldValue(mobjRS, "Description")
        Else
            Product = vbNullString
            Description = vbNullString
        End If
    objRSFilter.RestoreFilter
End Sub

Private Function GetAlternativeLinkMessage( _
            Product As String, _
            Description As String _
        ) As String '@09
    Static top As String, middle As String, bottom As String
    If LenB(top) = 0 Then ' avoid frequent numerous concat operations
        top = _
                "This item has been quoted as a substitute for" & _
                " Part" & nbsp & "No." & nbsp
        middle = _
                nbsp & "- "
        bottom = _
                " that has been included in the quotation."
    End If
    GetAlternativeLinkMessage = _
            top & Product & middle & Description & bottom
End Function

Private Function EndTable(ByVal RelevancyFlag As RelevancyFlags) As Boolean
    
    With mobjTextTable
        ' Convert to a Table.
        Set mobjTbl = .ConvertToTable(rng:=mobjRng, Borders:=False)
        .Clear
    End With ' mobjTextTable
        
    FormatTable mobjTbl, RelevancyFlag     ' Format the table.
        
    Set mobjRng = mobjTbl.Range
    With mobjRng
        .Collapse Direction:=wdCollapseEnd ' Set up next position.
        .InsertParagraph
        .Collapse Direction:=wdCollapseEnd
    End With ' mobjRng
    
    EndTable = True

End Function

Private Sub FormatTable(tbl As Word.Table, ByVal RelevancyFlag As RelevancyFlags)
    Dim blnAllPricesSuppressed As Boolean '@07 only comes into play if Relevant
    Dim r As Integer, lastRow As Integer
    Dim vHeaderRowStyleArray As Variant, vDataRowStyleArray As Variant, vColumnWidthArray As Variant
    
    '@02 remove Unit Price, @23, @38, @46, @61
    GetArrays IsRelevant(RelevancyFlag), _
            vHeaderRowStyleArray, vDataRowStyleArray, vColumnWidthArray

    blnAllPricesSuppressed = True '@07 assume true until discovered otherwise
    
    With tbl
        
        DefineStyles .Range.Parent
        
        ' All Rows:
        .Rows.AllowBreakAcrossPages = False
        
        ' Header Row:
        With .Rows(1)
            .Cells.VerticalAlignment = wdCellAlignVerticalBottom
            .HeadingFormat = True
        End With
        SetRowStyles tbl, 1, vHeaderRowStyleArray
        
        ' Data Rows:
        r = 2
        lastRow = .Rows.Count
        Do While r <= lastRow
            SetRowStyles tbl, r, vDataRowStyleArray
            With .Rows(r)
                .Cells.VerticalAlignment = wdCellAlignVerticalBottom
                .Range.ParagraphFormat.KeepWithNext = True
            End With
            If IsRelevant(RelevancyFlag) Then '@07
                If LenB(GetTableText(tbl, r, dcPrice)) <> 0 Then '@38, @61
                    blnAllPricesSuppressed = False
                End If
            Else '@11, @38
                SetTableText tbl, r, dcInitials, "X" & vbTab '@61
                With tbl.Cell(r, dcInitials) '@61
                    .Range.ParagraphFormat.TabStops.Add InchesToPoints(0.65)
                    .Range.Underline = wdUnderlineSingle
                End With
            End If
            r = r + 1 ' go to the next row
            '@09 If there is an Altermative message, then set the Style.
            If IsAlternative(RelevancyFlag) Then
                If GetTableText(tbl, r, dcSecretAltCode) = SecretAltCode Then '@11 col 2 now
                    .Cell(r, dcAltMessage).Range.Style = cStyleNamePTAlternativeMessage
                    .Cell(r, dcSecretAltCode).Range.Delete
                    r = r + 1
                    GoTo LetsTwistAgain
                End If
            End If
            ' If there is B-Text, then set the Style.
            If LenB(GetTableText(tbl, r, dcQuantity)) = 0 Then
                .Cell(r, dcBText).Range.Style = cStyleNamePTDescription
                r = r + 1
            End If
            '@09 If there is an Altermative message, then set the Style.
            If IsAlternative(RelevancyFlag) Then
                If GetTableText(tbl, r, dcSecretAltCode) = SecretAltCode Then '@11 col 2 now
                    .Cell(r, dcAltMessage).Range.Style = cStyleNamePTAlternativeMessage
                    .Cell(r, dcSecretAltCode).Range.Delete
                    r = r + 1
                End If
            End If
LetsTwistAgain:
        Loop
        '@07, @61 If all prices were suppressed delete the Price column.
        SetColumnWidths .Columns, vColumnWidthArray '@46 moved up
        If IsRelevant(RelevancyFlag) And blnAllPricesSuppressed Then
            .Columns(dcPrice).Delete '@46, @61
            .Columns(dcDescription).Width = _
                    InchesToPoints( _
                        vColumnWidthArray(dcDescription - 1) + _
                        vColumnWidthArray(dcPrice - 1)) '@46, must do -1 to account for 0-origin, @53, @61
        End If

    End With ' tbl
End Sub

Private Sub DefineStyles(doc As Word.Document)
    On Error Resume Next
    If StylesExist(doc) Then Exit Sub
    With CreateNewStyle(doc, cStyleNamePTTitleHeader, wdStyleTypeParagraph)
        With .Font
            .Name = "Arial"
            .Size = 12
            .Bold = True
        End With
        .ParagraphFormat.SpaceAfter = .Font.Size
    End With
    
    With CreateNewStyle(doc, cStyleNamePTHeaderRow, wdStyleTypeParagraph)
        With .Font
            .Name = "Arial"
            .Size = 10
            .Bold = True
        End With
        With .ParagraphFormat
            .SpaceAfter = 4
            .KeepWithNext = True
        End With
    End With
    
    With CreateNewStyle(doc, cStyleNamePTHeaderRowRight, wdStyleTypeParagraph)
        With .Font
            .Name = "Arial"
            .Size = 10
            .Bold = True
        End With
        With .ParagraphFormat
            .SpaceAfter = 4
            .KeepWithNext = True
            .Alignment = wdAlignParagraphRight
        End With
    End With
    
    With CreateNewStyle(doc, cStyleNamePTHeaderRowCenter, wdStyleTypeParagraph) '@11
        With .Font
            .Name = "Arial"
            .Size = 10
            .Bold = True
        End With
        With .ParagraphFormat
            .SpaceAfter = 4
            .KeepWithNext = True
            .Alignment = wdAlignParagraphCenter
        End With
    End With
    
    With CreateNewStyle(doc, cStyleNamePTQuantity, wdStyleTypeParagraph) '@11
        With .Font
            .Name = "Arial"
            .Size = 8
            .Bold = False
        End With
        .ParagraphFormat.Alignment = wdAlignParagraphCenter
    End With
    
    With CreateNewStyle(doc, cStyleNamePTPartNumber, wdStyleTypeParagraph)
        With .Font
            .Name = "Arial"
            .Size = 8
            .Bold = False
        End With
    End With
    
    With CreateNewStyle(doc, cStyleNamePTPartName, wdStyleTypeParagraph)
        With .Font
            .Name = "Arial"
            .Size = 10
            .Bold = False
        End With
        .ParagraphFormat.SpaceBefore = 6
    End With
    
    With CreateNewStyle(doc, cStyleNamePTDescription, wdStyleTypeParagraph)
        With .Font
            .Name = "Arial"
            .Size = 8
            .Bold = False
        End With
        With .ParagraphFormat
            .Alignment = wdAlignParagraphJustify
            .SpaceBefore = 2
        End With
    End With
    
    With CreateNewStyle(doc, cStyleNamePTAlternativeMessage, wdStyleTypeParagraph) '@09
        With .Font
            .Name = "Arial"
            .Size = 8
            .Bold = False
            .Italic = True
        End With
        With .ParagraphFormat
            .Alignment = wdAlignParagraphLeft
            .SpaceBefore = 3
        End With
    End With
    
    With CreateNewStyle(doc, cStyleNamePTAmount, wdStyleTypeParagraph)
        With .Font
            .Name = "Arial"
            .Size = 10
            .Bold = False
        End With
        With .ParagraphFormat
            .Alignment = wdAlignParagraphRight
            .SpaceBefore = 4
        End With
    End With
End Sub

Private Function StylesExist(doc As Word.Document) As Boolean
    On Error Resume Next
    Dim sty As Word.Style
    Set sty = doc.Styles(cStyleNamePTAmount)
    StylesExist = Not sty Is Nothing
End Function

' delete the style if it already exists and create it
Private Function CreateNewStyle( _
            ByRef doc As Word.Document, _
            ByVal StyleName As String, _
            ByVal StyleType As Word.WdStyleType _
        ) As Word.Style
    On Error Resume Next
    Dim sty As Word.Style
    Set sty = doc.Styles(StyleName)
    If Not sty Is Nothing Then sty.Delete
    Set CreateNewStyle = doc.Styles.Add(StyleName, StyleType)
End Function

Private Sub SetRowStyles(tbl As Word.Table, ByVal r As Integer, a As Variant)
    On Error Resume Next
    Dim c As Integer
    For c = 0 To UBound(a)
        tbl.Cell(r, c + 1).Range.Style = a(c)
    Next
End Sub

Private Sub SetColumnStyles(tbl As Word.Table, a As Variant)
    On Error Resume Next
    Dim c As Integer
    For c = 0 To UBound(a)
        tbl.Columns(c + 1).Select
        Selection.Style = a(c)
    Next
    Selection.Collapse
End Sub

Private Function EmitTableFooter(ByVal RelevancyFlag As RelevancyFlags) As Boolean '@03
    EmitTableFooter = True
    If Not IsRelevant(RelevancyFlag) Then Exit Function
    ' We're still on the AE line - how convenient!
    With mobjTextTable '@45
        .Clear
        If gobjFeatures.ShowListPrices Then '@58
            EmitCurrency "List Total", "LP Less Promo and Trade-in"
            EmitCurrency "Less Discount", "Manual Discount Amount", True '@63
            EmitCurrency "Less Promotion(s)", "Total Promo Price"
            EmitCurrency "Less Trade-in", "Total Trade-in Allowance"
            EmitCurrency "Contract Total", "Extended Net Price" '@55, @61
        Else 'Net Price
            EmitCurrency "Total Price", "Extended Net Price"
        End If
        Set mobjTbl = .ConvertToTable(mobjRng, False)
        .Clear
    End With 'mobjTextTable
'@58 no longer needed ReplaceSpecialCharacterWithParagraphMarks mobjTbl.Range '@49
    With mobjTbl
        With .Range
            .Font.Size = 10 '@56 was 8
            .Bold = True '@49
            '@63 .ParagraphFormat.Alignment = wdAlignParagraphRight
        End With
        SetColumnWidths .Columns, Array(6.2, 1.05) '@46 see GetArrays() '@52 added .12
        'The 0.20555 is a fudge factor so the column won't expand to the right.
        .Range.ParagraphFormat.TabStops.Add InchesToPoints(1.05 - 0.14), wdAlignTabDecimal '@63
        .Columns(1).Select '@63
        Selection.ParagraphFormat.Alignment = wdAlignParagraphRight '@63 first column only
#If False Then '@58
        '@49 - underline all but the word "Total" and the Shift-Enter
        .Range.Parent.Range(.Cell(1, 2).Range.start + 6, .Cell(1, 2).Range.End).Font.Underline = wdUnderlineSingle
        If gobjFeatures.ShowListPrices Then '@38, @49
            .Range.Parent.Range(.Cell(1, 3).Range.start + 6, .Cell(1, 3).Range.End).Font.Underline = wdUnderlineSingle
        End If
        .Rows(1).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter '@49 was Right
        .Rows(2).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter '@49 was Right
        .RightPadding = 0
        If gobjFeatures.ShowListPrices Then '@38, @49
            SetColumnWidths .Columns, Array(5.67, 0.85, 0.85) '@46 see GetArrays() '@52 added .12
        Else
            SetColumnWidths .Columns, Array(6.52, 0.85) '@46 see GetArrays() '@52 added .12
        End If
#End If
        Set mobjRng = .Range
    End With 'mobjTbl
    With mobjRng
        .Collapse Direction:=wdCollapseEnd ' Set up next position.
        .InsertParagraph
        .Collapse Direction:=wdCollapseEnd
    End With ' mobjRng
End Function

Private Sub EmitCurrency(FieldLabel As String, FieldName As String, _
            Optional ByVal Negate As Boolean = False)  '@58, @63
    With mobjTextTable
        Dim value As String '@63
        .AddCell FieldLabel & ":"
        value = FieldValue(mobjRS, FieldName)
        If Negate Then value = -value '@63
        .AddCell CurrencyFormat(value:=value, UseParens:=True) '@64
        .EndOfRow
    End With 'mobjTextTabe
End Sub

' Currently only for roots.
Private Function EmitSystemFooter() As Boolean
    With mobjRng
        .Collapse Direction:=wdCollapseEnd
        .InsertBreak Type:=wdPageBreak
        .Collapse Direction:=wdCollapseEnd
#If False Then
        .InsertAfter vbCrLf & vbCrLf '@74
        .Collapse Direction:=wdCollapseEnd
        .InsertAfter "No Further Options or Alternates are included in the above listed equipment." & vbCrLf '@16
        .Font.Name = "Arial" ' YYY style
        .Font.Size = 12
        .Font.Bold = True
        .Shading.Texture = wdTexture20Percent
        .ParagraphFormat.Alignment = wdAlignParagraphCenter
        .Collapse Direction:=wdCollapseEnd
#End If
    End With ' mobjRng
    EmitSystemFooter = True
End Function

Private Function BeginSummaryTable() As Boolean '@02, @11, @20, @33
    With mobjSummaryTextTable
        .AddCell "Qty" '@11
        .AddCell "Configuration"
        .AddCell "Contract Total"    '@61
        .AddCell "Initial to Accept" '@38 moved down here
        .EndOfRow
    End With ' mobjSummaryTextTable
    mblnAnyRecordsAdded = False '@15
    mblnAnyNonRSystemsAdded = False '@61
    BeginSummaryTable = True
End Function

' We're on the root system's AS record.
Private Function AddToSummaryTable() As Boolean
    Dim Quantity As String
    Dim price As String '@38, @66
    Dim RelevancyFlag As RelevancyFlags
    Dim strSystemName As String '@36
    AddToSummaryTable = True   '@08
    mblnAnyRecordsAdded = True '@15
    RelevancyFlag = Rel2RelevancyFlag(FieldValue(mobjRS, "Rel"))
    GetSystemPriceInfo Quantity, price, RelevancyFlag '@38, @66
    With mobjSummaryTextTable
        ' Quantity @11
        .AddCell Quantity
        ' Configuration
        strSystemName = FieldValue(mobjRS, "Description")
        If IsOptional(mrfRootRelevancyFlag) Then
            strSystemName = strSystemName & " - OPTION"
            mblnAnyNonRSystemsAdded = True '@61
        ElseIf IsAlternative(mrfRootRelevancyFlag) Then
            strSystemName = strSystemName & " - ALTERNATE"
            mblnAnyNonRSystemsAdded = True '@61
        End If
        .AddCell strSystemName
        ' Price '@38, @61, @66
        .AddCell CurrencyFormat(price) '@38
        ' Initial to Accept '@38 moved to bottom
        .AddCell vbNullString ' leave blank cell for initials
        .EndOfRow
    End With ' mobjSummaryTextTable
End Function

Private Sub GetSystemPriceInfo( _
            ByRef Quantity As String, _
            ByRef price As String, _
            ByVal RelevancyFlag As RelevancyFlags _
        ) '@22 added Summary, @38 added ExtListPrice, @66
    Dim objRSFilter As New clsRecordsetFilter
    objRSFilter.SetFilter mobjRS, _
                "[Parent Quote Item Id]='" & mstrRootSystemId & "' AND " & _
                "[Position Code]='AE'"
        If mobjRS.RecordCount = 1 Then
            GetPriceInfo Quantity, price, RelevancyFlag, True  '@22, @38, @66
        End If
    objRSFilter.RestoreFilter
End Sub

' Return Quantity and Price, given RelevancyFlag and Optional Summary.
Private Sub GetPriceInfo( _
            ByRef Quantity As String, _
            ByRef price As String, _
            ByVal RelevancyFlag As RelevancyFlags, _
            Optional ByVal Summary As Boolean = False _
        )
    Quantity = FieldValue(mobjRS, "Quantity", "0")
    If Summary Then
        price = FieldValue(mobjRS, "Extended Net Price", "0")
    ElseIf IsAlternative(RelevancyFlag) Then
        price = FieldValue(mobjRS, "Delta Price", "0")
    ElseIf gobjFeatures.ShowListPrices Then
        price = FieldValue(mobjRS, "Ext List Price", "0")
    Else
        price = FieldValue(mobjRS, "Extended Net Price", "0")
    End If
End Sub

Private Function EndSummaryTable() As Boolean
    
    If Not mblnAnyRecordsAdded Then '@15
        AddTOCEntry mobjRng, "Error: All systems or all line items were print suppressed"
        mobjSummaryTextTable.Clear
        EndSummaryTable = True
        Exit Function
    End If
    
    If Not mblnAnyNonRSystemsAdded Then '@61
        mobjSummaryTextTable.Clear
        EndSummaryTable = True
        Exit Function
    End If
    
    AddTOCEntry mobjRng, "Proposal Price Summary"
    
    With mobjRng
        .InsertAfter "Proposal Price Summary" & vbCrLf
        '.Style = "YYY" ' YYY style
        With .Font
            .Name = "Arial"
            .Size = 12 '@01
            .Bold = True
        End With
        .start = .start + 1
        .ParagraphFormat.SpaceAfter = 6
        .Collapse Direction:=wdCollapseEnd
        .InsertAfter "The Proposal Price Summary represents the contract total " & _
                "for all the products in the configuration; it does not include " & _
                "any optional or alternate products." & vbCrLf & vbCrLf '@19
        .Font.Size = 10 '@27
        .Collapse Direction:=wdCollapseEnd
    End With ' mobjRng
    
    With mobjSummaryTextTable
        ' Convert to a Table.
        Set mobjTbl = .ConvertToTable(rng:=mobjRng, Borders:=False)
'@38was:Set mobjTbl = .ConvertToTable(mobjRng, gobjFeatures.TemplateDivision <> "Sales")
        .Clear
    End With ' mobjSummaryTextTable
        
    FormatSummaryTable mobjTbl   ' Format the table.
        
    Set mobjRng = mobjTbl.Range  ' Set up next position.
    With mobjRng
        .Collapse Direction:=wdCollapseEnd
        .InsertParagraph
        .Collapse Direction:=wdCollapseEnd
    End With ' mobjRng
    
    EndSummaryTable = True

End Function

Private Sub FormatSummaryTable(tbl As Word.Table)
    Dim vHeaderRowStyleArray As Variant, vDataRowStyleArray As Variant, vColumnWidthArray
    Dim r As Integer '@11
    
#If False Then '@60
    If gobjFeatures.ShowListPrices Then '@38
        vHeaderRowStyleArray = Array( _
                                    cStyleNamePTHeaderRowCenter, _
                                    cStyleNamePTHeaderRow, _
                                    cStyleNamePTHeaderRowCenter, _
                                    cStyleNamePTHeaderRowCenter, _
                                    cStyleNamePTHeaderRowCenter)
        vDataRowStyleArray = Array( _
                                    cStyleNamePTQuantity, _
                                    cStyleNamePTPartName, _
                                    cStyleNamePTAmount, _
                                    cStyleNamePTAmount, _
                                    cStyleNamePTAmount)
        vColumnWidthArray = Array(0.45, 4.37, 0.85, 0.85, 0.73)
    Else
#End If '@60
        vHeaderRowStyleArray = Array( _
                                    cStyleNamePTHeaderRowCenter, _
                                    cStyleNamePTHeaderRow, _
                                    cStyleNamePTHeaderRowCenter, _
                                    cStyleNamePTHeaderRowCenter)
        vDataRowStyleArray = Array( _
                                    cStyleNamePTQuantity, _
                                    cStyleNamePTPartName, _
                                    cStyleNamePTAmount, _
                                    cStyleNamePTAmount)
        vColumnWidthArray = Array(0.45, 5.12, 0.95, 0.73)
'@60    End If
    
    With tbl
        
        SetColumnStyles tbl, vDataRowStyleArray
        SetRowStyles tbl, 1, vHeaderRowStyleArray
        .Rows.AllowBreakAcrossPages = False
        .Range.Cells.VerticalAlignment = wdCellAlignVerticalBottom
        .Rows(1).Range.ParagraphFormat.KeepWithNext = True
        If .Rows.Count > 2 Then
            .Rows(2).Range.ParagraphFormat.KeepWithNext = True
        End If
        If .Rows.Count > 3 Then
            .Rows(.Rows.Count - 1).Range.ParagraphFormat.KeepWithNext = True
        End If
        .Rows(1).HeadingFormat = True
#If False Then '@60
        '@47
        .Cell(1, scFirstPriceColumn).Range.Font.Size = 8
        If gobjFeatures.ShowListPrices Then
            .Cell(1, scNetPrice).Range.Font.Size = 8
            .Cell(1, scInitials).Range.Font.Size = 8
        Else
            .Cell(1, scInitialsNoList).Range.Font.Size = 8
        End If
#End If '@60
        SetColumnWidths .Columns, vColumnWidthArray
        For r = 2 To .Rows.Count '@11
            SetTableText tbl, r, scInitials, "X" & vbTab '@38, @61
            With tbl.Cell(r, scInitials) '@38, @61
                .Range.ParagraphFormat.TabStops.Add InchesToPoints(0.65)
                .Range.Underline = wdUnderlineSingle
            End With
        Next r

#If False Then
        For colIndex = 2 To .Rows(1).Cells.Count ' leave the first column alone
            .Cell(1, colIndex).LeftPadding = 0
            .Cell(1, colIndex).RightPadding = 0
        Next colIndex
#End If
    
    End With ' tbl
End Sub

Public Property Let QuoteNumber(ByVal QuoteNumber As String) '@25
    mstrQuoteNumber = QuoteNumber
End Property

Public Property Let RevisionNumber(ByVal RevisionNumber As String) '@25
    mstrRevisionNumber = RevisionNumber
End Property

Private Sub GetArrays( _
    Relevant As Boolean, _
    vHeaderRowStyleArray As Variant, vDataRowStyleArray As Variant, vColumnWidthArray As Variant) '@46, @61
    'xxx make these statics...
    If Relevant Then
        vHeaderRowStyleArray = Array( _
                                cStyleNamePTHeaderRowCenter, _
                                cStyleNamePTHeaderRow, _
                                cStyleNamePTHeaderRow, _
                                cStyleNamePTHeaderRowRight)
        vDataRowStyleArray = Array( _
                                cStyleNamePTQuantity, _
                                cStyleNamePTPartNumber, _
                                cStyleNamePTPartName, _
                                cStyleNamePTAmount)
        vColumnWidthArray = Array(0.45, 0.95, 4.8, 1.05)
    Else
        vHeaderRowStyleArray = Array( _
                                cStyleNamePTHeaderRowCenter, _
                                cStyleNamePTHeaderRow, _
                                cStyleNamePTHeaderRow, _
                                cStyleNamePTHeaderRowRight, _
                                cStyleNamePTHeaderRowCenter)
        vDataRowStyleArray = Array( _
                                cStyleNamePTQuantity, _
                                cStyleNamePTPartNumber, _
                                cStyleNamePTPartName, _
                                cStyleNamePTAmount, _
                                cStyleNamePTAmount)
        vColumnWidthArray = Array(0.45, 0.95, 4.07, 1.05, 0.73)
    End If
End Sub

' This is a pretty weird routine.
' We want to set the Quote Number and Revision Number for new quotes.
' If this is the first System, as evidenced by the Bookmark being < 5, then the caller
' should already have Quote Number and Revision Number set.
' Otherwise, we want to back up three records and check for the "Quote Nr" heading.
' If it's found, then this is the first System in a new Quote. We move forward one
' and grab the values from the first two fields.
' Then we put everything back the way we found it.
' We could have used FieldValue() here, but didn't want to rely on Field names in case
' they change in the future.
Private Sub GetNewQuoteInfo() '@54
    On Error Resume Next
    If mobjRS.Bookmark < 5 Then Exit Sub ' we already did the first one before coming in
    Dim objRSFilter As New clsRecordsetFilter
    Dim varBookmark As Variant
    With mobjRS
        varBookmark = .Bookmark
        objRSFilter.SetFilter mobjRS, vbNullString
            .Bookmark = varBookmark
            .MovePrevious
            .MovePrevious
            .MovePrevious
            If Nz(.Fields(0).value) = "Quote Nr" Then
                .MoveNext
                mstrQuoteNumber = Nz(.Fields(0).value)
                mstrRevisionNumber = Nz(.Fields(1).value)
            End If
        objRSFilter.RestoreFilter
    End With 'mobjRS
End Sub

' Remove "See Detailed Tech Specs as end..." messages from Detail Pages.
Public Static Function RemoveSeeEndMessages(doc As Word.Document, RootSystemId As String) As Boolean '@50
    Dim retval As Boolean
    retval = True
    retval = retval And RemoveSeeEndMessage(doc, RootSystemId, "R")
'@32retval = retval And RemoveSeeEndMessage(doc, RootSystemId, "A") '@31
'@32retval = retval And RemoveSeeEndMessage(doc, RootSystemId, "O")
    RemoveSeeEndMessages = retval
End Function

' Remove "See Detailed Tech Specs as end..." message for specified Relevancy from Detail Pages.
Private Static Function RemoveSeeEndMessage( _
            doc As Word.Document, _
            RootSystemId As String, _
            Relevancy As String _
        ) As Boolean  '@50
    Dim Name As String
    Name = GetBookmarkName(RootSystemId, Relevancy)
    If doc.Bookmarks.Exists(Name) Then
        doc.Bookmarks(Name).Range.Delete
    End If
    RemoveSeeEndMessage = True ' successful either way
End Function

Private Static Function GetBookmarkName(RootSystemId As String, Relevancy As String) As String '@50
    GetBookmarkName = "bkTS" & Replace(RootSystemId, "-", "_") & "_" & Relevancy
End Function
Attribute VB_Name = "clsTextTable"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Module:       clsTextTable
' Purpose:      Build up a tab delimited String that can then be converted to a Word Table.
' Assumptions:
' Creation:     2007/03/24
' Author:       David Horowitz
' Use:          Call Clear, loop on AddCell, EndRecord at end of row, ConvertToTable
' Modifications:
'   2007/03/24  DAH Created this module.
'   2007/05/07  DAH @01 Added Table.Style = "Table Grid" in ConvertToTable().
'   2008/03/24  DAH @02 Added Borders parameter to ConvertToTable.
'   2008/06/20  DAH @03 No Borders is now performed using white borders,
'                       so even Grid Lines don't show on screen.
'   2008/06/21  DAH @04 #@03 is not working, so we reverted back.
'   2009/01/14  STB @05 Added Translation with Array "translate(bookmark, text)"
'                       use sub translate_international
'   2009/02/19  STB @06 move dan layout to translate_international
'   2009/03/04  STB correct the DAN Translation
'-----------------------------------------------------------------------------

Option Explicit

Private translate() As String
Private mstrText As String



Private Sub BIH_translate()
'GEM 20100215 Bosnien und Herzegovina

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Quote Number"
translate(0, 6) = "Contact"
translate(0, 7) = "Telefon"
translate(0, 8) = "Telefax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Va|fffd| znak"
translate(0, 11) = "Na|fffd| znak"
translate(0, 12) = "Datum"
translate(0, 13) = "Web Address"
translate(0, 14) = "Address"
translate(0, 15) = "Ponuda:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Korisnik:"
translate(0, 18) = "Address:"
translate(0, 19) = "Contact:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-mail:"
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Item"
translate(0, 26) = "Description"
translate(0, 27) = "Qty"
translate(0, 28) = "Item Price"
translate(0, 29) = "Conditions"
translate(0, 30) = "Best Regards"
translate(0, 31) = "Item"
translate(0, 32) = "Description"
translate(0, 33) = "Ime"
translate(0, 34) = "Odjel"
translate(0, 35) = "Part.-No."
translate(0, 36) = "Part.-No."
translate(0, 37) = "Single Price" & vbVerticalTab & "in CHF"
translate(0, 38) = "Total Price" & vbVerticalTab & "in CHF"
End Sub


Private Sub ROM_translate()
'GEM 20091223 Rum|fffd|nien

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Quote Number"
translate(0, 6) = "Contact"
translate(0, 7) = "Tel"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Referinta Dvs"
translate(0, 11) = "Referinta noastra"
translate(0, 12) = "Data"
translate(0, 13) = "Web Address"
translate(0, 14) = "Address"
translate(0, 15) = "Quote:"
translate(0, 16) = "Data:"
translate(0, 17) = "Site:"
translate(0, 18) = "Address:"
translate(0, 19) = "Contact:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-mail:"
translate(0, 23) = "Pagina"
translate(0, 24) = "din"
translate(0, 25) = "Poz"
translate(0, 26) = "Descriere"
translate(0, 27) = "Cant"
translate(0, 28) = "Pret"
translate(0, 29) = "Conditions"
translate(0, 30) = "Best Regards"
translate(0, 31) = "Poz"
translate(0, 32) = "Descriere"
translate(0, 33) = "Nume"
translate(0, 34) = "Divizie"
translate(0, 35) = "Part.-No."
translate(0, 36) = "Part.-No."
translate(0, 37) = "Single Price" & vbVerticalTab & "in CHF"
translate(0, 38) = "Total Price" & vbVerticalTab & "in CHF"
End Sub



Private Sub HRV_translate()
'GEM 20100111 Croatien

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Quote Number"
translate(0, 6) = "Contact"
translate(0, 7) = "Telefon"
translate(0, 8) = "Telefax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Va|fffd| znak"
translate(0, 11) = "Na|fffd| znak"
translate(0, 12) = "Datum"
translate(0, 13) = "Web Address"
translate(0, 14) = "Address"
translate(0, 15) = "Ponuda:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lokacija:"
translate(0, 18) = "Address:"
translate(0, 19) = "Contact:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-mail:"
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Br."
translate(0, 26) = "Opis"
translate(0, 27) = "Kol."
translate(0, 28) = "Cijena"
translate(0, 29) = "Uvjeti"
translate(0, 30) = "Best Regards"
translate(0, 31) = "Br."
translate(0, 32) = "Opis"
translate(0, 33) = "Ime"
translate(0, 34) = "Odjel"
translate(0, 35) = "Part.-No."
translate(0, 36) = "Part.-No."
translate(0, 37) = "Single Price" & vbVerticalTab & "in CHF"
translate(0, 38) = "Total Price" & vbVerticalTab & "in CHF"
End Sub



Private Sub UNG_translate()
'ANT 20091203 Ungarn

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Telefon"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Level|fffd|k jele"
translate(0, 11) = "Level|fffd|nk jele"
translate(0, 12) = "D|fffd|tum"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "D|fffd|tum"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Item"
translate(0, 26) = "Description"
translate(0, 27) = "Qty"
translate(0, 28) = "Item Price"
translate(0, 29) = "Konditionen"
translate(0, 30) = "Mit freundlichen Gr|fffd||fffd|en"
translate(0, 31) = "Item"
translate(0, 32) = "Description"
translate(0, 33) = "N|fffd|v"
translate(0, 34) = "Oszt|fffd|ly"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"

End Sub


Private Sub CA_FRA_Translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Soumission"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Soumission "
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "T|fffd|l|fffd|phone"
translate(0, 8) = "Tel|fffd|c"   'ANT 20091201 Fax -> Tel|fffd|c
translate(0, 9) = "Courriel"
translate(0, 10) = "Votre r|fffd|f|fffd|rence"
translate(0, 11) = "Notre r|fffd|f|fffd|rence"
translate(0, 12) = "Date"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Soumission:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Client:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "Courriel:"
translate(0, 23) = "Page "
translate(0, 24) = "de "
translate(0, 25) = "Item"
translate(0, 26) = "Description"
translate(0, 27) = "Qt|fffd|"
translate(0, 28) = "Prix"
translate(0, 29) = "CONDITIONS"
translate(0, 30) = ""
translate(0, 31) = "Item"
translate(0, 32) = "Description"
translate(0, 33) = "Nom"
translate(0, 34) = "D|fffd|partement"
'---------------------------------
translate(0, 35) = "N|fffd| d'article"
translate(0, 36) = "N|fffd| d'article"
translate(0, 37) = "Prix unitaire" ' was ist mit 'in' beim Preis???
translate(0, 38) = "Prix total"
'--------------------------------
'???"translate_name"
'???"translate_grussformel"
'???"translate_footer-..."

End Sub
Private Sub EST_translate() ' GEM 20090619

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Quote Number"
translate(0, 6) = "Contact"
translate(0, 7) = "Telefon:"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = ""
translate(0, 11) = ""
translate(0, 12) = "Kuup|fffd|ev"
translate(0, 13) = "Web Address"
translate(0, 14) = "Address"
translate(0, 15) = "Quote:"
translate(0, 16) = "Date:"
translate(0, 17) = "Site:"
translate(0, 18) = "Address:"
translate(0, 19) = "Contact:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-mail:"
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Jrk"
translate(0, 26) = "Kirjeldus"
translate(0, 27) = "Kogus"
translate(0, 28) = "Hind"
translate(0, 29) = "Conditions"
translate(0, 30) = "Best Regards"
translate(0, 31) = "Jrk"
translate(0, 32) = "Kirjeldus"
translate(0, 33) = "Nimi"
translate(0, 34) = "Aadress"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub


'LYG 20090722 New
Private Sub NOW_translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Tlf:"
translate(0, 8) = "Faks:"
translate(0, 9) = "E-post:"
translate(0, 10) = "Deres referanse:"
translate(0, 11) = "V" & Chr(229) & "r referanse:"
translate(0, 12) = "Datum:"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Dato:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tlf:"
translate(0, 21) = "Faks:"
translate(0, 22) = "E-post:"
translate(0, 23) = "Side"
translate(0, 24) = "av"
'translate(0, 25) = "Art."  ANT 20100129 SR2896
translate(0, 25) = "Art.nr" 'LYG 20100208
'translate(0, 26) = "Beskrivelse"  ANT 20100129 SR2896
translate(0, 26) = "Beskrivelse" 'LYG 20100208
'translate(0, 27) = "Ant." ANT 20100129 SR2896
translate(0, 27) = "Ant." 'LYG 20100208
'translate(0, 28) = ""   ANT 20100129 SR2896
translate(0, 28) = "Veil.pris" 'LYG 20100208
translate(0, 29) = "Konditionen"
translate(0, 30) = "Med vennlig hilsen"
translate(0, 31) = "Art."
translate(0, 32) = "Beskrivelse"
translate(0, 33) = "Navn"
translate(0, 34) = "Divisjon"
translate(0, 35) = "Delnr" 'LYG 20100208
translate(0, 36) = "Delnr" 'LYG 20100208
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in EUR"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in EUR"
'translate(0, 33) = "translate_"


End Sub

Public Sub translate_international(mylanguage As String)

Dim menge_translate             'Bookmarks to translate
Dim i As Integer                'counter for langs and bookmarks
Dim machs As Integer
Dim langs() As String
Dim menge_langs As Integer
menge_translate = 38
ReDim translate(2, menge_translate)
'menge_langs = 15 ' ANT 20091203
'menge_langs = 16 ' GEM 20091223
'menge_langs = 17 ' GEM 20100111
menge_langs = 18 ' GEM 20100111
ReDim langs(menge_langs)

machs = 0

langs(1) = "DEU"
langs(2) = "DAN"
langs(3) = "NLD"
langs(4) = "FRA"
langs(5) = "ENS"
langs(6) = "POL"
langs(7) = "FIN"
langs(8) = "SWE"
langs(9) = "RUS" ' GEM 20090603
langs(10) = "LET" ' GEM 20090608
langs(11) = "EST" ' GEM 20090619
langs(12) = "NOW"   ' LYG 20090722
langs(13) = "CA_FRA"   ' LYG 20091111
langs(14) = "CZE"   'ANT 20091124
langs(15) = "UNG"   'ANT 20091203
langs(16) = "ROM"   'GEM 20091223
langs(17) = "HRV"   'GEM 20100111
langs(18) = "BIH"   'GEM 20100215


For i = 1 To menge_langs
    If mylanguage = langs(i) Then
        machs = 1
        Exit For
    End If
Next i

If machs <> 1 Then Exit Sub

translate(1, 1) = "translate_header1"
translate(1, 2) = "translate_header2"
translate(1, 3) = "translate_header3"
translate(1, 4) = "translate_header4"
translate(1, 5) = "translate_quoteno"
translate(1, 6) = "translate_aspa"
translate(1, 7) = "translate_aspa_tel"
translate(1, 8) = "translate_aspa_fax"
translate(1, 9) = "translate_aspa_mail"
translate(1, 10) = "translate_yr"
translate(1, 11) = "translate_or"
translate(1, 12) = "translate_date"
translate(1, 13) = "translate_web"
translate(1, 14) = "translate_regoffice"
translate(1, 15) = "translate_head_quoteno"
translate(1, 16) = "translate_head_date"
translate(1, 17) = "translate_head_site"
translate(1, 18) = "translate_footer_regoffice"
translate(1, 19) = "translate_footer_aspa"
translate(1, 20) = "translate_footer_tel"
translate(1, 21) = "translate_footer_fax"
translate(1, 22) = "translate_footer_email"
translate(1, 23) = "translate_footer_page"
translate(1, 24) = "translate_footer_of"
translate(1, 25) = "translate_header_pos"
translate(1, 26) = "translate_header_description"
translate(1, 27) = "translate_header_qty"
translate(1, 28) = "translate_header_price"
translate(1, 29) = "translate_tc"
translate(1, 30) = "translate_closing"
translate(1, 31) = "translate_ts_pos"
translate(1, 32) = "translate_ts_description"
translate(1, 33) = "translate_aspa_name"
translate(1, 34) = "translate_aspa_abteilung"
translate(1, 35) = "translate_ts_artikelnr"
translate(1, 36) = "translate_header_artikelnr"
translate(1, 37) = "translate_header_eprice"
translate(1, 38) = "translate_header_gprice"
'translate(1, 35) = "translate_aspa_name"
'translate(1, 36) = "translate_aspa_name"


If mylanguage = "DEU" Then Call DEU_translate
If mylanguage = "DAN" Then Call DAN_translate
If mylanguage = "NLD" Then Call NLD_Translate
If mylanguage = "FRA" Then Call FRA_Translate
If mylanguage = "ENS" Then Call ENS_translate
If mylanguage = "POL" Then Call POL_translate
If mylanguage = "FIN" Then Call FIN_translate
If mylanguage = "SWE" Then Call SWE_translate
If mylanguage = "RUS" Then Call RUS_translate ' GEM 20090603
If mylanguage = "LET" Then Call LET_translate ' GEM 20090608
If mylanguage = "EST" Then Call EST_translate ' GEM 20090619
If mylanguage = "NOW" Then Call NOW_translate ' LYG 20090722
If mylanguage = "CA_FRA" Then Call CA_FRA_Translate ' LYG 20091111
If mylanguage = "CZE" Then Call CZE_translate ' ANT 20091124
If mylanguage = "UNG" Then Call UNG_translate ' ANT 20091203
If mylanguage = "ROM" Then Call ROM_translate ' GEM 20091223
If mylanguage = "HRV" Then Call HRV_translate ' GEM 20100111
If mylanguage = "BIH" Then Call BIH_translate ' GEM 20100215


For i = 1 To menge_translate
    modLocal.writeIntoBookmark translate(1, i), translate(0, i)
Next i

End Sub


Private Sub RUS_translate() ' GEM 20090603

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Quote Number"
translate(0, 6) = "Contact"
translate(0, 7) = "Telephone"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Your reference"
translate(0, 11) = "Our reference"
translate(0, 12) = "Date"
translate(0, 13) = "Web Address"
translate(0, 14) = "Address"
translate(0, 15) = "Quote:"
translate(0, 16) = "Date:"
translate(0, 17) = "Site:"
translate(0, 18) = "Address:"
translate(0, 19) = "Contact:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-mail:"
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Item"
translate(0, 26) = "Description"
translate(0, 27) = "Qty"
translate(0, 28) = "Item Price"
translate(0, 29) = "Conditions"
translate(0, 30) = "Best Regards"
translate(0, 31) = "Item"
translate(0, 32) = "Description"
translate(0, 33) = "Name"
translate(0, 34) = "Department"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub

Private Sub LET_translate() ' GEM 20090608

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Quote Number"
translate(0, 6) = "Contact"
translate(0, 7) = "Telephone"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Your reference"
translate(0, 11) = "Our reference"
translate(0, 12) = "Date"
translate(0, 13) = "Web Address"
translate(0, 14) = "Address"
translate(0, 15) = "Quote:"
translate(0, 16) = "Date:"
translate(0, 17) = "Site:"
translate(0, 18) = "Address:"
translate(0, 19) = "Contact:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-mail:"
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Item"
translate(0, 26) = "Description"
translate(0, 27) = "Qty"
translate(0, 28) = "Item Price"
translate(0, 29) = "Conditions"
translate(0, 30) = "Best Regards"
translate(0, 31) = "Item"
translate(0, 32) = "Description"
translate(0, 33) = "Name"
translate(0, 34) = "Department"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub



Private Sub DEU_translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Telefon:"
translate(0, 8) = "Telefax:"
translate(0, 9) = "E-Mail:"
translate(0, 10) = "Ihre Zeichen:"
translate(0, 11) = "Unser Zeichen:"
translate(0, 12) = "Datum:"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Seite"
translate(0, 24) = "von"
translate(0, 25) = "Pos"
translate(0, 26) = "Beschreibung"
translate(0, 27) = "Menge"
translate(0, 28) = "Preis"
translate(0, 29) = "Konditionen"
translate(0, 30) = "Mit freundlichen Gr|fffd||fffd|en"
translate(0, 31) = "Pos"
translate(0, 32) = "Beschreibung"
translate(0, 33) = "Name"
translate(0, 34) = "Abteilung"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub
Private Sub DAN_translate()

translate(0, 1) = ""
translate(0, 2) = "Tilbud P|fffd|"
translate(0, 3) = ""
translate(0, 4) = "Til"
translate(0, 5) = "Tilbudsnummer"
translate(0, 6) = "Hospitalsr|fffd|dgiver"
translate(0, 7) = "Direkte telefon:"
translate(0, 8) = "Direkte fax:"
translate(0, 9) = "e-mail:"
translate(0, 10) = "Deres reference:"
translate(0, 11) = "Vores reference:"
translate(0, 12) = "Dato:"
translate(0, 13) = "Web addresse"
translate(0, 14) = ""
translate(0, 15) = "Tilbudsnummer:"
translate(0, 16) = "Dato:"
translate(0, 17) = "Tilbud:"
translate(0, 18) = ""
translate(0, 19) = ""
translate(0, 20) = ""
translate(0, 21) = ""
translate(0, 22) = ""
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Item"
translate(0, 26) = "Description"
translate(0, 27) = "Qty"
translate(0, 28) = "Item Price"
translate(0, 29) = "Terms and Conditions"
translate(0, 30) = "Yours faithfully"
translate(0, 31) = "Item"
translate(0, 32) = "Description"
translate(0, 33) = ""
translate(0, 34) = ""
translate(0, 35) = ""
translate(0, 36) = ""
translate(0, 37) = ""
translate(0, 38) = ""
'translate(0, 33) = "translate_"

End Sub

Private Sub FIN_translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Telefon:"
translate(0, 8) = "Telefax:"
translate(0, 9) = "E-Mail:"
translate(0, 10) = "Ihre Zeichen:"
translate(0, 11) = "Unser Zeichen:"
translate(0, 12) = "Datum:"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Seite"
translate(0, 24) = "von"
translate(0, 25) = "Pos"
translate(0, 26) = "Tuotenimi"
translate(0, 27) = "Kpl"
translate(0, 28) = "EUR"
translate(0, 29) = "Konditionen"
translate(0, 30) = "Mit freundlichen Gr|fffd||fffd|en"
translate(0, 31) = "Pos"
translate(0, 32) = "Tuotenimi"
translate(0, 33) = "Name"
translate(0, 34) = "Abteilung"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub
'
Private Sub FRA_Translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "T|fffd|l|fffd|phone"
translate(0, 8) = "Fax"
translate(0, 9) = "e-mail"
translate(0, 10) = "Votre r|fffd|f|fffd|rence"
translate(0, 11) = "Notre r|fffd|f|fffd|rence"
translate(0, 12) = "Date"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Seite"
translate(0, 24) = "von"
translate(0, 25) = "Pos"
translate(0, 26) = "Description"
translate(0, 27) = "Quantit|fffd|"
translate(0, 28) = "Prix"
translate(0, 29) = "CONDITIONS"
translate(0, 30) = ""
translate(0, 31) = "Pos"
translate(0, 32) = "Description"
translate(0, 33) = "Nom"
translate(0, 34) = "D|fffd|partement"
'---------------------------------
translate(0, 35) = "N|fffd| d'article"
translate(0, 36) = "N|fffd| d'article"
translate(0, 37) = "Prix unitaire" & vbVerticalTab & "en CHF" ' was ist mit 'in' beim Preis???
translate(0, 38) = "Prix total" & vbVerticalTab & "en CHF"
'--------------------------------
'???"translate_name"
'???"translate_grussformel"
'???"translate_footer-..."


End Sub


Private Sub NLD_Translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Telefoon"
translate(0, 8) = "Fax"
translate(0, 9) = "E-Mail"
translate(0, 10) = "Uw referentie"
translate(0, 11) = "Onze referentie"
translate(0, 12) = "Datum"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Pagina"
translate(0, 24) = "van"
translate(0, 25) = "Post"
translate(0, 26) = "Omschrijving"
translate(0, 27) = "Aantal"
translate(0, 28) = "Totaalprijs"
translate(0, 29) = "LEVERINGS- EN BETALINGSCONDITIES"
translate(0, 30) = "Met vriendelijke groet,"
translate(0, 31) = "Post"
translate(0, 32) = "Omschrijving"
translate(0, 33) = "Naam"
translate(0, 34) = ""
translate(0, 35) = ""
translate(0, 36) = ""
translate(0, 37) = ""
translate(0, 38) = ""
'translate(0, 35) = "translate_"
'translate(0, 36) = "translate_"

End Sub

Private Sub POL_translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Telefon"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Wasze pismo z"
translate(0, 11) = "Nasz znak"
translate(0, 12) = "Data"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Strona" 'Achtung andere Sprachen 1. Seite
translate(0, 24) = "z" 'Achtung andere Sprachen 1. Seite
translate(0, 25) = "L.p"
translate(0, 26) = "Opis"
translate(0, 27) = "Il."
translate(0, 28) = "Cena"
translate(0, 29) = "Konditionen"
translate(0, 30) = "Mit freundlichen Gr|fffd||fffd|en"
translate(0, 31) = "L.p."
translate(0, 32) = "Opis"
translate(0, 33) = "Nazwisko"
translate(0, 34) = "Dzial" 'text falsch
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub

Private Sub CZE_translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Telefon"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = "V|fffd| dopis"
translate(0, 11) = "Na|fffd|e znacka"
translate(0, 12) = "Datum"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Strana"
translate(0, 24) = "z"
translate(0, 25) = "Polo|fffd|ka ?."
translate(0, 26) = "Popis"
translate(0, 27) = "ks"
translate(0, 28) = "Cena CZK bez DPH"
translate(0, 29) = "Konditionen"
translate(0, 30) = "Mit freundlichen Gr|fffd||fffd|en"
translate(0, 31) = "L.p.Polo|fffd|ka ?."
translate(0, 32) = "Popis"
translate(0, 33) = "Jm|fffd|no"
translate(0, 34) = "Oddelen|fffd|"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub
Private Sub SWE_translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Angebots Nummer"
translate(0, 6) = "Ansprechpartner"
translate(0, 7) = "Telefon:"
translate(0, 8) = "Telefax:"
translate(0, 9) = "E-Mail:"
translate(0, 10) = "Ihre Zeichen:"
translate(0, 11) = "Unser Zeichen:"
translate(0, 12) = "Datum:"
translate(0, 13) = "Web Adresse"
translate(0, 14) = "Adresse:"
translate(0, 15) = "Angebot:"
translate(0, 16) = "Datum:"
translate(0, 17) = "Lage:"
translate(0, 18) = "Adresse:"
translate(0, 19) = "Ansprechpartner:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-Mail:"
translate(0, 23) = "Seite"
translate(0, 24) = "von"
translate(0, 25) = "Pos"
translate(0, 26) = "Ben|fffd|mning"
translate(0, 27) = "Antal"
translate(0, 28) = "SEK"
translate(0, 29) = "Konditionen"
translate(0, 30) = "Mit freundlichen Gr|fffd||fffd|en"
translate(0, 31) = "Pos"
translate(0, 32) = "Ben|fffd|mning"
translate(0, 33) = "Name"
translate(0, 34) = "Abteilung"
translate(0, 35) = "Artikel-Nr."
translate(0, 36) = "Artikel-Nr."
translate(0, 37) = "Einzelpreis" & vbVerticalTab & "in CHF"
translate(0, 38) = "Gesamtpreis" & vbVerticalTab & "in CHF"
'translate(0, 33) = "translate_"


End Sub

Private Sub ENS_translate()

translate(0, 1) = "Gesch|fffd|ftlich im Vertrauen"
translate(0, 2) = "Angebot |fffd|ber"
translate(0, 3) = "Anschlu|fffd| und Installation von"
translate(0, 4) = "im"
translate(0, 5) = "Quote Number"
translate(0, 6) = "Contact"
translate(0, 7) = "Telephone"
translate(0, 8) = "Fax"
translate(0, 9) = "E-mail"
translate(0, 10) = "Your reference"
translate(0, 11) = "Our reference"
translate(0, 12) = "Date"
translate(0, 13) = "Web Address"
translate(0, 14) = "Address"
translate(0, 15) = "Quote:"
translate(0, 16) = "Date:"
translate(0, 17) = "Site:"
translate(0, 18) = "Address:"
translate(0, 19) = "Contact:"
translate(0, 20) = "Tel:"
translate(0, 21) = "Fax:"
translate(0, 22) = "E-mail:"
translate(0, 23) = "Page"
translate(0, 24) = "of"
translate(0, 25) = "Item"
translate(0, 26) = "Description"
translate(0, 27) = "Qty"
translate(0, 28) = "Item Price"
translate(0, 29) = "Conditions"
translate(0, 30) = "Best Regards"
translate(0, 31) = "Item"
translate(0, 32) = "Description"
translate(0, 33) = "Name"
translate(0, 34) = "Department"
translate(0, 35) = "Part.-No." 'ANT 20091212
translate(0, 36) = "Part.-No." 'ANT 20091212
translate(0, 37) = "Single Price" & vbVerticalTab & "in CHF" 'ANT 20091212
translate(0, 38) = "Total Price" & vbVerticalTab & "in CHF" 'ANT 20091212
'translate(0, 33) = "translate_"


End Sub

Public Sub Clear()
    mstrText = vbNullString
End Sub

Public Sub AddCell(ByVal value As String)
    mstrText = mstrText & value & vbTab
End Sub

Public Sub AddText(ByVal value As String)
    mstrText = mstrText & value
End Sub

Public Sub EndOfRow()
    ' Replace the last vbTab with vbCr
    If LenB(mstrText) <> 0 Then
        Mid(mstrText, Len(mstrText), 1) = vbCr
    End If
End Sub

Public Property Get Text() As String
    Text = mstrText
End Property

Public Property Let Text(value As String)
    mstrText = value
End Property

#If False Then '@04
'@03 Revamped.
Public Function ConvertToTable(rng As Word.Range, Optional Borders As Boolean = True) As Word.Table '@02
    Dim tbl As Word.Table
    rng.Text = mstrText
    rng.ParagraphFormat.TabStops.ClearAll
    Set tbl = rng.ConvertToTable(Separator:=vbTab, _
                                 AutoFitBehavior:=wdAutoFitFixed, _
                                 DefaultTableBehavior:=cDefaultTableBehavior)
    With Options
        .DefaultBorderLineStyle = cDefaultLineStyle
        .DefaultBorderLineWidth = cDefaultLineWidth
        .DefaultBorderColor = IIf(Borders, cDefaultColor, wdColorWhite)
    End With ' Options
    tbl.Borders.Enable = True ' apply defaults
    Options.DefaultBorderColor = cDefaultColor
    Set ConvertToTable = tbl
End Function
#End If '@04

'@04 #If False Then '@03
Public Function ConvertToTable(rng As Word.Range, Optional Borders As Boolean = True) As Word.Table '@02
    Dim tbl As Word.Table
    rng.Text = mstrText
    ' xxx see if this has the desired effect without the explicit border setting...
    Options.DefaultBorderLineStyle = cDefaultLineStyle
    Options.DefaultBorderLineWidth = cDefaultLineWidth
    rng.ParagraphFormat.TabStops.ClearAll
    Set tbl = rng.ConvertToTable(Separator:=vbTab, _
                                 AutoFitBehavior:=wdAutoFitFixed, _
                                 DefaultTableBehavior:=cDefaultTableBehavior)
    If Borders Then              '@02
        tbl.Style = "Table Grid" '@01
    End If
    Set ConvertToTable = tbl
End Function
'@04 #End If '@03
Attribute VB_Name = "frm_picklist"
Attribute VB_Base = "0{28DFC14D-E875-44B4-86B9-50E49DCED5FE}{AAED6354-1B3C-463F-9600-83AFE5B9CECD}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False


Option Explicit

Private Sub cmb_left_Change()
    If Me.cmb_left.ListIndex <> -1 Then
    '    Me.txt_pos_left.Text = Closings_left(Me.cmb_left.ListIndex + 1).Title
'        Me.txt_pos_high.Text = Closings(Me.cmb_left.ListIndex + 1).Name_H
'        Me.txt_pos_high.Enabled = False
        Me.txt_pos_left.Text = Closings(Me.cmb_left.ListIndex + 1).Title
        Me.txt_pos_left.Enabled = False
'        Me.txt_pos_right.Text = Closings(Me.cmb_left.ListIndex + 1).Title_H
'        Me.txt_pos_right.Enabled = False
    Else
        Me.txt_pos_left.Enabled = True
    End If
End Sub

Private Sub cmd_cancel_Click()
    End
End Sub

Private Sub cmd_ok_Click()
    Dim name_left As String
    Dim title_left As String
'    Dim name_right As String
'    Dim title_right As String
    frm_picklist.Hide
    name_left = Me.cmb_left.Text
    title_left = Me.txt_pos_left.Text
'    name_right = Me.txt_pos_high.Text
'    title_right = Me.txt_pos_right.Text
    
'    Call insert_closing(name_left, title_left, name_right, title_right)
    Call insert_closing(name_left, title_left)
    
    ActiveDocument.PrintPreview
    ActiveDocument.ClosePrintPreview
End Sub

Attribute VB_Name = "modLocal"
'@ 2010-02-22 GEM picklist for IL

Public Type Region
    Name As String              ' Name of the region, used as title at the formular
    AddrStreet As String        ' Street-Addr of the region
    AddrZipcode As String       ' Zip-Code of the region
    AddrCity As String          ' City of the region
    AddrDistrict As String      ' District of the region
End Type

Public Type Closing
    Name As String              ' Name of the closing, used as title at the formular
    Title As String             ' titel of closing
    Name_H As String              ' Name of the closing, used as title at the formular
    Title_H As String             ' titel of closing
End Type
Public RegionIndex As Integer   ' Int-Value from ListIndex of formular
Public Regions() As Region      ' List of Type Region
Public ClosingIndex As Integer   ' Int-Value from ListIndex of formular
Public Closings() As Closing      ' List of Type Region

'LYG 20110105 Alle Felder des Documents aktualisieren
Sub updateAllFields()

    Application.ScreenUpdating = False
    Application.DisplayAlerts = wdAlertsNone

    ActiveDocument.Fields.Update
          
    Application.DisplayAlerts = wdAlertsAll
    Application.ScreenUpdating = True
  
End Sub

Public Sub check_Region()
If ActiveDocument.Bookmarks.Exists("PropOrganization") = True Then
    Select Case ActiveDocument.Bookmarks("PropOrganization").Range.Text
    Case "Siemens Healthcare IL"
        Call Closing_bestimmen_IL
        frm_picklist.Show
    Case "Siemens Healthcare GB"
        Call Closing_bestimmen_IL
        frm_picklist.Show
    Case Else
        MsgBox "No Office to select!"
        End
    End Select
Else
    MsgBox "No Office to select!"
    End
End If
End Sub
Public Sub Closing_bestimmen_IL()
'GEM 20100222
    
    mengeclosing = 4                     'Anzahl 4
    Dim mClor As Closing
    ReDim Closings(mengeclosing) As Closing
'    mClor.Name = "Shay Yonovitch"
'    mClor.Title = "Key Account Manager"
'    mClor.Name_H = ActiveDocument.Bookmarks("print_unt_name1").Range.Text
'    mClor.Title_H = ActiveDocument.Bookmarks("print_unt_title1").Range.Text
    mClor.Name = ActiveDocument.Bookmarks("print_unt_name1").Range.Text
    mClor.Title = ActiveDocument.Bookmarks("print_unt_title1").Range.Text
    Closings(1) = mClor
'    mClor.Name = "Nir Gothelf"
'    mClor.Title = "Key Account Manager"
'    mClor.Name_H = ActiveDocument.Bookmarks("print_unt_name2").Range.Text
'    mClor.Title_H = ActiveDocument.Bookmarks("print_unt_title2").Range.Text
    mClor.Name = ActiveDocument.Bookmarks("print_unt_name2").Range.Text
    mClor.Title = ActiveDocument.Bookmarks("print_unt_title2").Range.Text
    Closings(2) = mClor
'    mClor.Name = "Haim Regev"
'    mClor.Title = "Sales Department Manager"
'    mClor.Name_H = ActiveDocument.Bookmarks("print_unt_name3").Range.Text
'    mClor.Title_H = ActiveDocument.Bookmarks("print_unt_title3").Range.Text
    mClor.Name = ActiveDocument.Bookmarks("print_unt_name3").Range.Text
    mClor.Title = ActiveDocument.Bookmarks("print_unt_title3").Range.Text
    Closings(3) = mClor
'    mClor.Name = "???"
'    mClor.Title = "Key Account Manager"
'    mClor.Name_H = ActiveDocument.Bookmarks("print_unt_name4").Range.Text
'    mClor.Title_H = ActiveDocument.Bookmarks("print_unt_title4").Range.Text
    mClor.Name = ActiveDocument.Bookmarks("print_unt_name4").Range.Text
    mClor.Title = ActiveDocument.Bookmarks("print_unt_title4").Range.Text
    Closings(4) = mClor
   
    frm_picklist.cmb_left.Clear
    
    For i = 1 To mengeclosing
      mClor = Closings(i)
      frm_picklist.cmb_left.AddItem (mClor.Name), i - 1
    Next i
    frm_picklist.cmb_left.ListIndex() = 0

    
End Sub
'Public Sub insert_closing(name_left As String, title_left As String, name_right As String, title_right As String)
Public Sub insert_closing(name_left As String, title_left As String)
    Dim my_doc As Document
    Set my_doc = ActiveDocument
    Dim mb As Range
    Dim boky_name As String
    
    If my_doc.Bookmarks.Exists("print_unterschrift1") = True Then
        boky_name = "print_unterschrift1"
    End If
    
    Set mb = my_doc.Bookmarks(boky_name).Range
    'mb.Text = name_left & vbTab & name_right & vbVerticalTab & title_left & vbTab & title_right
    mb.Text = name_left
    mb.Bold = False
    my_doc.Bookmarks.Add Name:=boky_name, Range:=mb
    
    If my_doc.Bookmarks.Exists("print_unterschrift2") = True Then
        boky_name = "print_unterschrift2"
    End If
    
    Set mb = my_doc.Bookmarks(boky_name).Range
    'mb.Text = name_left & vbTab & name_right & vbVerticalTab & title_left & vbTab & title_right
    mb.Text = title_left
    mb.Bold = False
    my_doc.Bookmarks.Add Name:=boky_name, Range:=mb
    
End Sub


Public Sub modifyRegionBookmarks(myRegIndex As Integer, myCloIndex As Integer)
    Debug.Print "modifyRegionBookmarks>"
    Dim mReg As Region
    Dim mClo As Closing
    Dim strFirstName As String
    Dim doc As Word.Document
    Dim bok As Bookmark
    Dim cdp As Variant
    Dim fld As Field
    Dim rng As Range
    
    Set doc = ActiveDocument
    mClo = Closings(myCloIndex)
    writeIntoBookmark "layout_closing", mClo.Name
    writeIntoBookmark "layout_titel", mClo.Title
End Sub
' write into given Bookmarkname 1. value, the given Value 2. value
Public Sub writeIntoBookmark(strTextMarkeName As String, strNeuerInhalt As String)
    Debug.Print "writeIntoBookmark>"
    Dim rngHier As Range
       
    If ActiveDocument.Bookmarks.Exists(strTextMarkeName) Then
        Set rngHier = ActiveDocument.Bookmarks(strTextMarkeName).Range
        rngHier.Text = strNeuerInhalt
        rngHier.End = rngHier.start + Len(strNeuerInhalt)
        ActiveDocument.Bookmarks.Add strTextMarkeName, rngHier
    Else
        Debug.Print "writeIntoBookmark<" & strTextMarkeName & "> does no exist."
    End If
    Debug.Print "writeIntoBookmark<"
End Sub
' set value of CustomDocumentProperty "Share_RegionOfficeSet" to "Yes"
' if property not exists, or value <> "Yes"
Private Function setRegionOfficeSet() As Boolean
    Dim bYes As Boolean
    bYes = True
On Error GoTo setRegionOfficeSet_Error
    If getCustomProperty("Share_RegionOfficeSet") <> "Yes" Then
        ' Set CustomDocumentProperty that Region Office was used
        ActiveDocument.CustomDocumentProperties.Add _
                        Name:="Share_RegionOfficeSet", LinkToContent:=False, value:="Yes", _
                        Type:=msoPropertyTypeString
    End If
    setRegionOfficeSet = bYes
    Exit Function

setRegionOfficeSet_Error:
    bYes = False
    Resume Next
End Function
' get value of handled CustomDocumentProperty
' if no property exist u get "XXX-empty"
Private Function getCustomProperty(doc_Property_Name As String)
    Dim dummy As String
    Dim prop As Variant
    dummy = "XXX-empty"
    For Each prop In ActiveDocument.CustomDocumentProperties
            If LCase(prop.Name) = LCase(doc_Property_Name) Then
                dummy = prop.value
                Exit For
            End If
    Next
    getCustomProperty = dummy
End Function

Attribute VB_Name = "modMain"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modMain - Contains main macro entry points.
' Creation:     2007/03/31
' Modifications:
'   2007/03/31  DAH Created.
'   2007/04/19  DAH @01 Moved code from ThisDocument here to facilitate
'                       copying between files since ThisDocument
'                       does not get copied by Macro Organizer.
'                       Added error handler to AutoClose().
'   2007/05/10  DAH @02 RunningOnServer -> Not Application.Visisble
'   2008/06/12  DAH @03 Added SetGlobals.
'   2008/08/27  DAH @04 Added call to ClearClipboard().
'   2008/10/31  STB @05 Change proofing status refomated document
'   2008/10/31  STB @06 Change Error Message from MsgBox into Description in the document
'   2009/04/16  STB CHANGE do LAYOUT 2
'-----------------------------------------------------------------------------

'-----------------------------------------------------------------------------
' GENERAL NOTES for the whole system:
' - Checking for LenB=0 executes faster than Len=0 or comparing against vbNullString,
'   so it is used extensively to check for empty Strings.
' - Checking for <>0 executes faster than >0 so it is used when appropriate.
'-----------------------------------------------------------------------------

Option Explicit

'@03
Public nbsp As String
Public SpecialCharacter As String
Public share_Country_Code As String
Public Sub AutoClose()
'STB please activate for productive Server
    On Error GoTo AutoClose_Error

    If Not Application.Visible Then '@02
        Call nach_ac
        ActiveDocument.Save
    End If

    Exit Sub

AutoClose_Error:
    Dim mb As Range
    Set mb = ActiveDocument.Range
    mb.SetRange start:=0, End:=0
    mb.Text = "Error in modMain::AutoClose: " & Err.Number & ": " & Err.Description
    Set mb = Nothing
    Resume Next
End Sub
'
'
'
Public Sub nach_ac()
    On Error GoTo AutoClose_Error
    Dim myVar As Variable
    Dim isFormated As Boolean
    isFormated = False
'''#######################################
'''#######################################
'''STB !!!ACHTUNG NUR FUER TEST !!!!!!
'''please deactivate for productive Server
''If UCase(Environ("USERNAME")) = UCase("deb002a7") Then
''Dim lang As String
''Dim orgi As String
''lang = "ENS" 'ENS
''orgi = "Siemens Healthcare IL"
''MsgBox "achtung test fuer gem" & vbCr & "lang: " & lang & vbCr & "orgi: " & orgi
''    Call writeIntoBookmark("layout_language", lang)
''    Call writeIntoBookmark("layout_organization", orgi)
''End If
'''STB !!!!! ENDE TESTEINSTELLUNG !!!!!
'''#######################################
'''#######################################
        For Each myVar In ActiveDocument.Variables  '@05
            If myVar.Name = "reformated" Then
                   isFormated = True
                   Exit For
            End If
        Next myVar
        If isFormated = False Then
            Call ReformatDocument
                ActiveDocument.Variables.Add "reformated", "1"
                ActiveDocument.PrintPreview
                ActiveDocument.ClosePrintPreview
                ActiveDocument.Save
        End If
    Exit Sub

AutoClose_Error:
'@06
    Dim mb As Range
    Set mb = ActiveDocument.Range
    mb.SetRange start:=0, End:=0
    mb.Text = "!!Error in creating Document, please Contact your Share Administrator!!" & vbCr & _
    "Error in modMain::nach_ac: " & Err.Number & ": " & Err.Description
    mb.Collapse wdCollapseEnd
    mb.InsertAfter wdPageBreak
    Resume Next
End Sub
Public Sub ReformatDocument()
'STB Auswahl der organisation und der entsprechenden Module
    'der Sprachqualifier wird gegebenenfalls umgestellt
    'die Produkttexte werden dann im Share zB. in englisch geliefert, der Rest soll aber in der organisationsprache kommen
    SetGlobals '@03
    If share_Country_Code = "" Then share_Country_Code = Right(ActiveDocument.Bookmarks("layout_organization").Range.Text, 2)

    Dim mb As Range

    Select Case UCase(share_Country_Code)
    Case "IL" ' GEM 20100219
'        Call writeIntoBookmark("layout_language", "ENS")
        TranslateDoc_IL ActiveDocument
    Case Else
        Set mb = ActiveDocument.Range
        mb.SetRange start:=0, End:=0
        mb.Text = "!!Error in creating Document (no existing organization), please Contact your Share Administrator!!" & vbCr & "XX"
        Set mb = Nothing
    End Select
    
    'GEM 20100111 loesche ueberfluessige returns am ende des doc-----------------
    Dim AnzPara As Integer
    'Anzahl Abs|fffd|tze im Dokument
    AnzPara = ActiveDocument.Paragraphs.Count
 
    'STB in meinen Testdocumenten war in der vorletzten zeile ein leerzeichen, dann hat die routine nix gemacht (was auch gut war)
    If Left(ActiveDocument.Paragraphs(AnzPara - 1).Range.Text, 1) = " " And Len(ActiveDocument.Paragraphs(AnzPara - 1).Range.Text) = 2 Then ActiveDocument.Paragraphs(AnzPara - 1).Range.Delete
    AnzPara = ActiveDocument.Paragraphs.Count
    
On Error GoTo exxfert
    Do While ActiveDocument.Paragraphs(AnzPara - 1).Range.Characters.Count = 1
        ActiveDocument.Paragraphs(AnzPara - 1).Range.Delete
        AnzPara = AnzPara - 1
    Loop
exxfert:
    '----------------------------------------------------------------------------
    
    ClearClipboard '@04
End Sub
Private Sub SetGlobals() '@03
    share_Country_Code = getCustomProperty("Share_Country")
    nbsp = Chr$(160)
    SpecialCharacter = Chr$(182) & Chr$(182)
End Sub
Private Function getCustomProperty(doc_Property_Name As String)
    Dim dummy As String
    Dim prop As Variant
    dummy = ""
    For Each prop In ActiveDocument.CustomDocumentProperties
            If LCase(prop.Name) = LCase(doc_Property_Name) Then
                dummy = prop.value
                Exit For
            End If
    Next
    getCustomProperty = dummy
End Function

Attribute VB_Name = "modModificationHistory"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modModificationHistory
' Creation:     2007/08/06
' Modifications:
'  Date       Who Vers. Stamp        Description
'  2010/06/14 GEM v1.001 20100614    - IL hebr new
'  2010/06/21 GEM v1.002 20100621    - corr SR 5121
'  2011/01/03 GEM v1.003 20110103    - im Header HealthCare statt Medical Solutions, im ganzem Layout Opportunity Name statt Proposal Name,
'                                    - Reihenfolge|fffd|nderung f|fffd|r layout_quotenumber und layout_quotetype, Korrektur der Pos- und TecSpeclistenk|fffd|pfe
'                                    - l|fffd|schen der letzten zwei Seiten des Layouts bei bestimmten QuoteType
'  2011/01/07 LYG v1.004 20110103    - layout_account anstatt FN, LN
'                                    - Hebr. Monatsnamen
'                                    - layout_quotetype - Fehler beim Kopieren
'                                    - AS-Desc anstatt Opportunity-Name
'                                    - Quote-Type <> Tender --> letzte 2 Seiten l|fffd|schen
'                                    - AE der unteren Ebenen und GE nicht drucken
'                                    - setProposalNotes-Fehler behoben
'                                    - setItemQuotes-Fehler behoben (fehlende Textmarke)
' !!!Achtung - bei mehreren Anlagen will man wahrscheinlich den Abschlu|fffd|satz nach jeder Anlage - ist zur Zeit nicht so realisiert!
'  2011/02/25 GEM v1.005 20110225    - Datumsformat hebr unabh|fffd|ngig von der Sprache, l|fffd|schen(nicht ausblenden) der letzten zwei Seiten des Layouts bei QuoteType <> Tender
'-----------------------------------------------------------------------------

Option Explicit

'-----------------------------------------------------------------------------
' PLEASE UPDATE THESE CONSTANTS EVERY TIME A NEW VERSION IS RELEASED.
'-----------------------------------------------------------------------------
Public Const cVersionStamp = "v1.005"
Public Const cTimeStamp = "201102251030" 'YYYYMMDDHHMM

Attribute VB_Name = "modProcess"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modProcess - Provides ExecAndWait function to spawn a new process.
' Creation:     2007/03/31
' Modifications:
'   2007/07/10  DAH     Added header.
'   2008/06/27  DAH @01 Tweak OpenProcess call for Windows XP.
'-----------------------------------------------------------------------------

Option Explicit

Private Const SYNCHRONIZE    As Long = &H100000
Public Declare Function OpenProcess Lib "kernel32" ( _
                                    ByVal dwDesiredAccess As Long, _
                                    ByVal bInheritHandle As Long, _
                                    ByVal dwProcessId As Long _
                                    ) As Long

Private Const INFINITE       As Long = &HFFFF
Private Const WAIT_ABANDONED As Long = &H80
Private Const WAIT_OBJECT_0  As Long = &H0
Private Const WAIT_TIMEOUT   As Long = &H102
Private Const WAIT_FAILED    As Long = &HFFFFFFFF
Public Declare Function WaitForSingleObject Lib "kernel32" ( _
                                            ByVal hHandle As Long, _
                                            ByVal dwMilliseconds As Long _
                                            ) As Long

Public Declare Function CloseHandle Lib "kernel32" ( _
                                    ByVal hObject As Long _
                                    ) As Long

Private Const FORMAT_MESSAGE_ALLOCATE_BUFFER As Long = &H100
Private Const FORMAT_MESSAGE_ARGUMENT_ARRAY  As Long = &H2000
Private Const FORMAT_MESSAGE_FROM_HMODULE    As Long = &H800
Private Const FORMAT_MESSAGE_FROM_STRING     As Long = &H400
Private Const FORMAT_MESSAGE_FROM_SYSTEM     As Long = &H1000
Private Const FORMAT_MESSAGE_MAX_WIDTH_MASK  As Long = &HFF
Private Const FORMAT_MESSAGE_IGNORE_INSERTS  As Long = &H200
Private Const FORMAT_MESSAGE_TEXT_LEN        As Long = &HA0 ' from VC++ ERRORS.H file
Private Declare Function FormatMessage Lib "kernel32" _
    Alias "FormatMessageA" ( _
    ByVal dwFlags As Long, _
    ByVal lpSource As Any, _
    ByVal dwMessageId As Long, _
    ByVal dwLanguageId As Long, _
    ByVal lpBuffer As String, _
    ByVal nSize As Long, _
    ByRef Arguments As Long) As Long

'Return True if OK.
Public Function ExecAndWait(ByVal ExecString) As Boolean
    Dim lngProID As Long
    Dim lngProHn As Long
    Dim timeout As Long ' in seconds
    Dim lngRtn As Long
    Dim LastDllError As Long
    
    On Error Resume Next
    lngProID = Shell(ExecString, vbHide)
    If lngProID = 0 Then
        LogMessage 1, "ExecAndWait::Shell failed"
        Err.Clear
        Exit Function
    End If
    
    ' wait for completion
    lngProHn = OpenProcess(SYNCHRONIZE, True, lngProID)
    If lngProHn = 0 Then
        LastDllError = Err.LastDllError
        '@01 On non-Windows NT systens, the SYNCHORNIZE flag returns
        ' DLL error 87 "The parameter is incorrect." IF the process has already
        ' finished. If the process is still running, it works correctly.
        If LastDllError = 87 Then '@01
            ExecAndWait = True
            Exit Function
        End If
        LogMessage 1, "ExecAndWait::OpenProcess() returned error " & LastDllError & _
                " (0x" & Hex(LastDllError) & "): " & _
                GetSystemErrorMessageText(LastDllError)
        Exit Function
    End If
    timeout = 30 ' seconds
    ' XXX should really call DoEvents here with a shorter timeout and loop
    lngRtn = WaitForSingleObject(lngProHn, timeout * 1000&)
    LastDllError = Err.LastDllError ' Just in case...
    Call CloseHandle(lngProHn)
    Select Case lngRtn
        Case WAIT_ABANDONED
            LogMessage 1, "ExecAndWait::WaitForSingleObject() reported an abandoned thread"
        Case WAIT_FAILED
            LogMessage 1, "ExecAndWait::WaitForSingleObject() returned error " & LastDllError & _
                " (0x" & Hex(LastDllError) & "): " & _
                GetSystemErrorMessageText(LastDllError)
        Case WAIT_TIMEOUT
            LogMessage 1, "ExecAndWait::WaitForSingleObject() timed out after " & timeout & " seconds"
        Case WAIT_OBJECT_0
            ExecAndWait = True ' It's all good.
    End Select
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''
' GetSystemErrorMessageText
' By Chip Pearson, www.cpearson.com, chip@cpearson.com
'
' This function gets the system error message text that corresponds
' to the error code parameter ErrorNumber. This value is the value returned
' by Err.LastDLLError or by GetLastError, or occasionally as the returned
' result of a Windows API function.
'
' These are NOT the error numbers returned by Err.Number (for these
' errors, use Err.Description to get the description of the error).
'
' In general, you should use Err.LastDllError rather than GetLastError
' because under some circumstances the value of GetLastError will be
' reset to 0 before the value is returned to VBA. Err.LastDllError will
' always reliably return the last error number raised in an API function.
'
' The function returns vbNullString is an error occurred or if there is
' no error text for the specified error number.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function GetSystemErrorMessageText(ErrorNumber As Long) As String

Dim ErrorText As String
Dim TextLen As Long
Dim FormatMessageResult As Long
Dim LangID As Long

''''''''''''''''''''''''''''''''
' initialize the variables
''''''''''''''''''''''''''''''''
LangID = 0& 'default language
ErrorText = String$(FORMAT_MESSAGE_TEXT_LEN, vbNullChar)
TextLen = FORMAT_MESSAGE_TEXT_LEN

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Call FormatMessage to get the text of the error message text
' associated with ErrorNumber.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
FormatMessageResult = FormatMessage( _
                        dwFlags:=FORMAT_MESSAGE_FROM_SYSTEM Or _
                                 FORMAT_MESSAGE_IGNORE_INSERTS, _
                        lpSource:=0&, _
                        dwMessageId:=ErrorNumber, _
                        dwLanguageId:=LangID, _
                        lpBuffer:=ErrorText, _
                        nSize:=TextLen, _
                        Arguments:=0&)

If FormatMessageResult = 0& Then
    ''''''''''''''''''''''''''''''''''''''''''''''''''
    ' An error occured. Display the error number, but
    ' don't call GetSystemErrorMessageText to get the
    ' text, which would likely cause the error again,
    ' getting us into a loop.
    ''''''''''''''''''''''''''''''''''''''''''''''''''
'    MsgBox "An error occurred with the FormatMessage" & _
'           " API function call." & vbCrLf & _
'           "Error: " & CStr(Err.LastDllError) & _
'           " Hex(" & Hex(Err.LastDllError) & ")."
    GetSystemErrorMessageText = vbNullString
    Exit Function
End If
''''''''''''''''''''''''''''''''''''''''''''''''''''''
' If FormatMessageResult is not zero, it is the number
' of characters placed in the ErrorText variable.
' Take the left FormatMessageResult characters and
' return that text.
''''''''''''''''''''''''''''''''''''''''''''''''''''''
ErrorText = Left$(ErrorText, FormatMessageResult)
'''''''''''''''''''''''''''''''''''''''''''''
' Get rid of the trailing vbCrLf, if present.
'''''''''''''''''''''''''''''''''''''''''''''
If Len(ErrorText) >= 2 Then
    If Right$(ErrorText, 2) = vbCrLf Then
        ErrorText = Left$(ErrorText, Len(ErrorText) - 2)
    End If
End If
GetSystemErrorMessageText = ErrorText

End Function

Attribute VB_Name = "modShareInternational"
Option Explicit
' Types and global using function for sh@re
' Version sh@re 1.0.3-01  2009/07/20  ULK
' Version sh@re 1.0.3-02  2009/08/04  STB Embargos von Boolean auf String geaendert
'                         2009/09/09  STB changes for replace typo character
' 2009/10/16 ULK new Selection of position list, if you disable txt-routines, you don't need ADODB anymore ...
' if you want to use the new selection : Items = modShareInternational.generateItemsArray(.Tables("tblDetailRecords"))
' exclude: generateItemsTextFile(.Tables("tblDetailRecords")) ...   getItemsFromTextFile
'2009/11/18 STB delete of not use prozedurs like writeinTextfile, readTextfile usw....
'Bestimmen der Region
Public xabsender() As String
' Type Item using Positions-Items
Public Type Item                        ' Item sind die Inhalte fuer DetailStart...
    lineNr As Long                      ' Zeilennummer
    PositionCode As String * 2          ' Positions code (AS, PS, PL, AE...)
    Relevance As String * 1             ' Relevance (R, O, A)
    ParentQuoteItemId As String         ' Eltern Quote Id (kann leer sein im Root)
    RootQuoteItemId As String           ' Quote Id (Bezug auf die Quote Id)
    Product As String                   ' Product Number (maybe characters)
    Description As String               ' Description of this Item
    BText       As String               ' B-Text
    BTextPrint As Boolean               ' B-Text Print ?
    Path As String                      ' full path to saf-file of B-Text
    ETextPrint As Boolean               ' E-Text Print ?
    Quantity As Long                    ' Quantity of this item
    'BasePrice As String                 ' Base price of this item ---
    CustomerPriceGross As String        ' Customer price inkl.   VAT, without QUANTITY of this item
    CustomerPriceNet As String          ' Customer price without VAT, without QUANTITY of this item
    ExtendesNetPrice As String          ' Customer price without VAT, inkl.   QUANTITY of this item
    'ManualDiscountAmount As String      ' manual Discount ---
    SuppressPrint  As Boolean           ' hmmm unterdruecken der ganzen Zeile
    'DeltaPrice As String                ' hmmm ---
    FLEquipmentNr As String             ' hmmm
    GG As String                        ' GG of this item
    PricePrintSuppress As Boolean       ' hmmm unterdruecken des preises customerprice
    GZ As String                        ' GZ of this item
    SaleType   As String                ' Sales type
    ShipToAccount As String             ' Ship to account
    ShipToAddress As String             ' Ship to address
    ShipToAddress2 As String            ' Ship to address hmmm
    ShipToCity As String                ' Ship to city
    ShipToState As String               ' Ship to state (Bundesland etc.)
    ShipToZip As String                 ' Ship to Zip-Code
    RelGroup As String                  ' hmmm
    PaymentTerm As String               ' hmmm
    Incoterms1 As String                ' hmmm
    Incoterms2 As String                ' hmmm
    ExtListPrice As String              ' hmmm
    PurchasingAgreement As String       ' hmmm
    LocalNoPrintFlag As Boolean         ' Print flag maybe empty
    'LPLessPromoAndTrade As String       ' hmmm maybe empty ---
    TotalPromoPrice As String           ' hmmm maybe empty
    TotalTradeInAllowance As String     ' hmmm maybe empty
    SMSVisibleOrder As String           ' SMS Visible Order |20081119 ULK
    PositionRowId As String             ' RowId der Position, wenn PositionCode = 'TX'
                                        '                     und Relevance = ''
                                        ' dann aus RootQuoteItemId bef|fffd|llen |20081119 ULK
    SMSRecordType As String                ' enth|fffd|lt 10 f|fffd|r pre, 20 f|fffd|r line und 30 f|fffd|r post |20081119 ULK
    SiebelId As String                     ' enth|fffd|lt die Id f|fffd|r den Link auf die TX-Position |20081125 ULK
    SMSTotalPrintFlag As Boolean           ' Print flag maybe empty |20090323 ULK new field at sh@re 1.0.1
    SMSSubTotalPrintFlag As Boolean        ' Print flag maybe empty |20090323 ULK new field at sh@re 1.0.1
    SMSCustomerPricePrintFlag As Boolean   ' Print flag maybe empty |20090323 ULK new field at sh@re 1.0.1
    SMSCPGrossPrintFlag As Boolean         ' Print flag maybe empty |20090720 ULK new field , min. sh@re 1.0.1
    SMSExtendesGrossPrice As String        ' Customer Price inkl. VAT, inkl. Quantity |20090720 ULK new field at sh@re 1.0.3
    SMSEmbargoDE As String                 ' Embargo-Flag DE |20090720 ULK new field at sh@re 1.0.3
    SMSEmbargoUSA As String                ' Embargo-Flag USA |20090720 ULK new field at sh@re 1.0.3
    SMSCountryOfOrigin As String           ' Country of Origin |20090720 ULK new field at sh@re 1.0.3
    SMSRelGroup As String                  ' Rel Group |20090720 ULK new field at sh@re 1.0.3
    SMSDiffPrice As String                 ' Difference Price (Customer R / A) |20090720 ULK new field at sh@re 1.0.3
End Type
Private PositionNames As Variant
'' at this place we save and customize the positions / item list with the order and names
'' use it to get the needed and normally given item list
'' ULK 2009/10/16
'' ULK 2009/10/16 49 Felder!
Private Function getPositionNames()
  Dim aNames() As String
  Dim i As Integer
  Dim vArray As Variant
  vArray = Array("Line", "Position Code", "Rel", "Parent Quote Item Id", "Root Quote Item Id", "Product", _
                   "Description", "B-Text", "B-Text Print", "Path", "E-Text Print", "Quantity", _
                   "Customer Price Gross", "Customer Price Net", "Extended Net Price", "Suppress Print", _
                   "FL/Equipment Nr", "GG", "Price Print Suppress", "GZ", "Sale Type", "Ship To Account", _
                   "Ship To Address", "Ship To Address 2", "Ship To City", "Ship To State", "Ship To Zip", _
                   "Rel Group", "Payment Term", "Incoterms 1", "Incoterms 2", "Ext List Price", _
                   "Purchasing Agreement", "Local No Print Flag", "Total Promo Price", _
                   "Total Trade-in Allowance", "Visible Order", "Record Type", "Siebel Id", _
                   "Total", "Sub Total", "Cust. Net", "CP Gross Print", "Extended Customer Gross Price", _
                   "Embargo DE", "Embargo USA", "Country of Origin", "Rel Group", "Delta Price")
  ReDim aNames(UBound(vArray))
  For i = 0 To UBound(vArray)
    aNames(i) = vArray(i)
  Next
  getPositionNames = aNames
End Function
'################
Private Function isPosListReady(tbl As Word.Table, aPositionNames() As String) As Boolean
  Dim bReady As Boolean
  Dim i As Integer
  bReady = True
  For i = 0 To UBound(aPositionNames)
    Debug.Print aPositionNames(i) & "|" & GetTableText(tbl, 1, i + 1) & "|" & i
    If aPositionNames(i) <> GetTableText(tbl, 1, i + 1) Then
      bReady = False
      LogMessage 1, "modShareInternational::isPosListReady ERROR at Position (" & i + 1 & ")(" & aPositionNames(i) & ")"
      Exit For
    End If
  Next
  isPosListReady = bReady
End Function
'#############
' Select, generate array, and delete old table of the given Word.Table
' after that it will be create a new Bookmark
' Used for DetailsStart aka Items
' NOTE: this a new solution to kick textfile.txt, so we read correctly, what we got ;-)
' NOTE: by the way --> chinese is funny *lol*
' ULK 2009/10/15

' STB ATTENTION SONDERSOLVE FOR CN I PUT THE DESCRIPTION AND B-TEXT IN A NEW RANGE because CN Signs are not usable in a VBA-String, you get "???"

Public Function generateItemsArray(tbl As Word.Table) As Item() 'As Boolean
  Dim rng As Word.Range
  Dim objRSFilter As New clsRecordsetFilter
  Dim objSystemEmitter As New clsSystemEmitter
  Dim retval As Boolean
  Const cTempBookmarkName As String = "StartOfDetailRecords" '@06
  Dim bk As Word.Bookmark '@06
  Dim aTableHeaders() As String
  
  On Error GoTo generateItemsArray_Error
  ' Perform table translation
  ' Delete all blank quotes at the top here, then get the first Quote Nr, and delete the Quote Nr.
  Do '@07 revamped
      If GetTableText(tbl, 1, 1) = "Quote Nr" Then ' sanity check
          '@05 Grab the first Quote Nr and Revision from the top of the table before we delete it.
          ' In later runs, we grab it from the Recordset.
          ' We delete them here though so we'll have all the field headings for the detail records.
          objSystemEmitter.QuoteNumber = GetTableText(tbl, 2, 1)    '@05
          objSystemEmitter.RevisionNumber = GetTableText(tbl, 2, 2) '@05
          tbl.Rows(1).Delete ' now delete "Quote Nr" (the labels)
          If tbl.Rows.Count = 1 Then '@07 if it's the last Quote, then no data, so bail out...
              tbl.Delete ' delete this 1-row table first
              Exit Function ' and bail out
          End If
          tbl.Rows(1).Delete ' now delete Quote Nr (the values)
          If LenB(GetTableText(tbl, 1, 1)) <> 0 Then Exit Do ' we found some data, as evidenced by field headings
          tbl.Rows(1).Delete ' blank quote, so delete the blank separator row and continue
      Else
          tbl.Range.InsertBefore "THE DATA IN THIS TABLE IS NOT FORMATTED CORRECTLY!" & vbCrLf
          Exit Function ' bad data!!!
      End If
  Loop
   '20091016 ULK first we need the headers of the table, we know
  aTableHeaders = getPositionNames
  If isPosListReady(tbl, aTableHeaders) = False Then
    tbl.Range.InsertBefore "THE DATA IN THIS TABLE IS NOT FORMATTED CORRECTLY (HEAD)!" & vbCrLf
    Exit Function ' bad data!!!
  End If
  '
  'ANT 20100409, Umstellung 0D0A
'  ReplaceNonBreakingSpaces tbl.Range
'  ' Embedded Line Breaks in B-Text was throwing everything off, so temporarily replace them
'  ' with a funky character sequence and then we'll change them all back when we're done.
'  ReplaceLineBreaksWithSpecialCharacter tbl.Range '@04
  'ULK At this point we will generate the needed array ...
  Dim i, j, iTableActive, iMengeFelder As Integer
  Dim mt_read As Table
  Dim mb As Range
  Dim Items() As Item         ' Datenfeld f|fffd|r die Item
  Dim myItem As Item          ' aktuelles Item
  Dim hallo As Integer
  iMengeFelder = 49
  'ReDim Items(iMengeFelder)   'Array angepasst

  '1 2 3 4 5 6 7 8 9 10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49
  'Line,Position Code,Rel,Parent Quote Item Id,Root Quote Item Id,Product,Description,B-Text,B-Text Print,Path,Q-Text Print,Quantity,Customer Price Gross,Customer Price Net,Extended Net Price,Suppress Print,FL/Equipment Nr,GG,Price Print Suppress,GZ,Sale Type,Ship To Account,Ship To Address, Ship To Address 2, Ship To City,  Ship To State, Ship To Zip, Rel Group, Payment Term,  Incoterms 1, Incoterms 2, Ext List Price,  Purchasing Agreement,  Local No Print Flag, Total Promo Price, Total Trade-in Allowance,Visible Order,Record Type, Siebel Id, Total, Sub Total,Cust. Net, CP Gross Print,Extended Customer Gross Price,Embargo DE,Embargo USA,Country of Origin,Rel Group,Delta Price
  Set mt_read = tbl           ' Tabelle |fffd|bergeben
  Dim my_rows_count           ' Zeilen der Tabelle
  my_rows_count = mt_read.Rows.Count
  
  ReDim Items(my_rows_count - 1) 'Array angepasst
  
  j = 1                       ' Item-Zaehler
  
  
  
  With myItem
    For i = 2 To my_rows_count
      .lineNr = CLng(GetTableText(mt_read, i, 1))
      .PositionCode = GetTableText(mt_read, i, 2)
      .Relevance = GetTableText(mt_read, i, 3)
      .ParentQuoteItemId = GetTableText(mt_read, i, 4)
      .RootQuoteItemId = GetTableText(mt_read, i, 5)
      .Product = GetTableText(mt_read, i, 6)
      .Description = GetTableText(mt_read, i, 7)
      .BText = GetTableText(mt_read, i, 8)
      
      If GetTableText(mt_read, i, 9) = "Y" Then
        .BTextPrint = True
      Else
        .BTextPrint = False
      End If
      .Path = GetTableText(mt_read, i, 10)
      ' 11
      If GetTableText(mt_read, i, 11) = "Y" Then
        .ETextPrint = True
      Else
        .ETextPrint = False
      End If
      .Quantity = CLng(GetTableText(mt_read, i, 12))
      .CustomerPriceGross = GetTableText(mt_read, i, 13)
      .CustomerPriceNet = GetTableText(mt_read, i, 14)
      .ExtendesNetPrice = GetTableText(mt_read, i, 15)
      If GetTableText(mt_read, i, 16) = "Y" Then
        .SuppressPrint = True
      Else
        .SuppressPrint = False
      End If
      .FLEquipmentNr = GetTableText(mt_read, i, 17)
      .GG = GetTableText(mt_read, i, 18)
      If GetTableText(mt_read, i, 19) = "Y" Then
        .PricePrintSuppress = True
      Else
        .PricePrintSuppress = False
      End If
      .GZ = GetTableText(mt_read, i, 20)
      ' 21
      .SaleType = GetTableText(mt_read, i, 21)
      .ShipToAccount = GetTableText(mt_read, i, 22)
      .ShipToAddress = GetTableText(mt_read, i, 23)
      .ShipToAddress2 = GetTableText(mt_read, i, 24)
      .ShipToCity = GetTableText(mt_read, i, 25)
      .ShipToState = GetTableText(mt_read, i, 26)
      .ShipToZip = GetTableText(mt_read, i, 27)
      .RelGroup = GetTableText(mt_read, i, 28)
      .PaymentTerm = GetTableText(mt_read, i, 29)
      .Incoterms1 = GetTableText(mt_read, i, 30)
      ' 31
      .Incoterms2 = GetTableText(mt_read, i, 31)
      .ExtListPrice = GetTableText(mt_read, i, 32)
      .PurchasingAgreement = GetTableText(mt_read, i, 33)
      If GetTableText(mt_read, i, 34) = "N" Then
        .LocalNoPrintFlag = False
      Else
        .LocalNoPrintFlag = True
      End If
      .TotalPromoPrice = GetTableText(mt_read, i, 35)
      .TotalTradeInAllowance = GetTableText(mt_read, i, 36)       ' ...
      .SMSVisibleOrder = GetTableText(mt_read, i, 37)
      If .Relevance = "" And .PositionCode = "TX" Then
        .PositionRowId = .RootQuoteItemId
      End If
      .SMSRecordType = GetTableText(mt_read, i, 38)
      .SiebelId = GetTableText(mt_read, i, 39)
      If GetTableText(mt_read, i, 40) = "Y" Then                  'SMS Total Print Flag
        .SMSTotalPrintFlag = True
      Else
        .SMSTotalPrintFlag = False
      End If
      ' 41
      If GetTableText(mt_read, i, 41) = "Y" Then                  'SMS Sub Total Print Flag
        .SMSSubTotalPrintFlag = True
      Else
        .SMSSubTotalPrintFlag = False
      End If
      If GetTableText(mt_read, i, 42) = "Y" Then                  'SMS Customer Price Print Flag
        .SMSCustomerPricePrintFlag = True
      Else
        .SMSCustomerPricePrintFlag = False
      End If
      If GetTableText(mt_read, i, 43) = "Y" Then                  'SMS CP Gross Print Flag
        .SMSCPGrossPrintFlag = True
      Else
        .SMSCPGrossPrintFlag = False
      End If
      .SMSExtendesGrossPrice = GetTableText(mt_read, i, 44) 'SMS Extendes Gross Price
      .SMSEmbargoDE = GetTableText(mt_read, i, 45)          ' SMS Embargo DE
      .SMSEmbargoUSA = GetTableText(mt_read, i, 46)         ' SMS Embargo USA
      .SMSCountryOfOrigin = GetTableText(mt_read, i, 47)    ' SMS Country Of Origin
      .SMSRelGroup = GetTableText(mt_read, i, 48)           ' SMS Rel Group
      .SMSDiffPrice = GetTableText(mt_read, i, 49)          ' SMS Diff Price
      
      Items(j) = myItem ' anhaengen des Items an die Liste
      j = j + 1
    Next
  End With
    
  Set rng = tbl.Range
  tbl.Delete
   
  Set bk = rng.Parent.Bookmarks.Add(cTempBookmarkName, rng) '@06
  generateItemsArray = Items
  Exit Function

generateItemsArray_Error: '
    LogMessage 1, "modShareInternational::generateItemsArray"
    Resume Next
End Function
Attribute VB_Name = "modXlat0Common"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modTablesCommon - common constants and translation functions
' Creation:     2007/03/31
' Modifications:
'   2007/03/31  DAH Broke out into this module.
'   2007/04/04  DAH @01 Nz: Changed names of params.
'   2007/04/04  DAH @02 Added IsWarranty()
'   2007/04/10  DAH @03 Added scServiceClassType, gpGuardianProductType,
'                       GetServiceClass, GetGuardianProduct, ContainsTube.
'   2007/04/11  DAH @04 Added Run Once code.
'   2007/04/13  DAH @05 Added new Tube criteria and Shock wave,
'                       added ReplaceLineBreaks().
'   2007/04/16  DAH @06 Added SetTableBorders().
'   2007/04/17  DAH @07 Added AddColumnHeadings(), AlignColumn(), RunningOnServer
'                       MessageBox() and LogMessage().
'   2007/04/18  DAH @08 Added LogLevel(), LogFilename().
'   2007/04/19  DAH @09 LogFilename() is now LogFIle() and relies on FilePath().
'   2007/04/19  DAH @10 RunningOnServer() now a function.
'   2007/04/20  DAH @11 Added IsRealSubSystem().
'   2007/04/25  DAH @12 Added scServiceClassSharedServiceExpert.
'   2007/04/27  DAH @13 Changed IsWarranty() logic.
'                   @14 Added Basic and Extended Warranty.
'                   @15 Added Or = vbNullString to Nz().
'   2007/05/01  DAH @16 Added Glossary.
'   2007/05/02  DAH @17 Added IsElementOfCollection().
'   2007/05/08  DAH @18 Added TimeFormat().
'                   @19 Added IsCoveragePeriodRecord().
'   2007/05/08  DAH @20 Changed all Parts Text Part Numbers.
'   2007/05/10  DAH @21 Added SetRegistryValue().
'                       RunningOnServer -> Not Application.Visible
'   2007/05/14  DAH @22 Added HasPOS parameter to Header and IncludesExcludes calls.
'   2007/05/21  DAH @23 Changed share structure as per J.Krivoshey.
'   2007/05/23  DAH @24 Store a "no code" backup of the file.
'   2007/05/24  DAH @25 Add cAppName and LogFilename -> cLogFilename.
'   2007/05/25  DAH @26 New Guardian Part numbers.
'   2007/05/30  DAH @27 New Guardian Service Classes.
'   2007/05/31  DAH @28 Added TranslateContractTotal.
'   2007/06/01  DAH @29 Guardian text no longer is restricted to R/A - O's too now.
'   2007/06/04  DAH @30 Real Subsystems must have ServiceClass = "OEM Contract".
'   2007/06/05  DAH @31 Additional subsystem handling.
'   2007/06/08  DAH @32 Stub out Contract Total call.
'   2007/06/25  DAH @33 Added RelevancyString(), AlignColumns() and SetColumnWidths().
'   2007/07/10  DAH @34 GetGuardianProductType now keys off Description instead of Product.
'                   @35 Added cVersionStamp and cTimeStamp. Please keep updated!
'   2007/07/16  DAH @36 Tweaked Shared Service Expert logic.
'   2007/07/25  DAH @37 Better error handling on LastProposal.doc.
'   2007/07/26  DAH @38 Added ReplaceSpaces() and ReplaceHyphens().
'   2007/08/01  DAH @39 Moved GetGuardianProduct() into another module, added
'                       gpGuardianCount.
'   2007/08/03  DAH @40 Added IsShockwaveOrTubeLimitRecord().
'   2007/08/06  DAH @41 Added clsFeatures code.
'                   @42 Added GetResponseTimeValue().
'   2007/08/09  DAH @43 Added Nonbreaking Space to TimeFormat().
'   2007/08/13  DAH @44 Added CreateAddress().
'   2007/09/21  DAH @45 Basic and Extended Warranties now print Gold text for Guardians.
'   2007/09/29  DAH @46 Added IsAlphaChar() and AnyAlphaChars().
'   2007/10/03  DAH @47 Added IsShockwaveOrTubeLimit().
'   2007/10/19  DAH @48 Glossary table mechanism revamped; no table sent in.
'   2008/03/24  DAH @49 Reversed order of SourceTables and Features initialization
'                       so SourceTables functioning can be dependent on which Template we're in.
'   2008/03/29  DAH @50 Update Table of Contents.
'   2008/04/03  DAH @51 Removed Header Table and Includes/Excludes.
'                   @52 Added Relevant flag functions
'   2008/04/21  DAH @53 Protecting document.
'   2008/04/25  DAH @54 TweakPageOne - Form Fields on Page One signature area.
'   2008/05/05  DAH @55 Form Field sigs removed.
'   2008/05/29  DAH @56 AddTOCEntry moved here from clsSystemEmiiter b/c of its general usefulness.
'   2008/05/31  DAH @57 Handle QuoteNotes.
'   2008/06/10  DAH @58 Tweak the Warranty Info TC field code.
'   2008/06/11  DAH @59 Added SpecialCharacter functions.
'   2008/06/20  DAH @60 Changed cDefaultColor.
'   2008/06/27  DAH @61 Tweak to use FreeFile in LogMessage.
'   2008/07/01  DAH @62 Added Ping code.
'   2008/07/02  DAH @63 Change CurrencyFormat to always put a space before negative values.
'   2008/07/14  DAH @64 Link all headers and footers.
'   2008/07/31  DAH @65 Removed SpecialCharacter handling from TranslateDoc and
'                       move it to B-Text processing in TranslateDetailRecordsTable.
'   2008/08/06  DAH @66 Undid @49 - we don't need it, AND clsSourceTables resets TemplateFormat bookmark.
'   2008/08/07  DAH @67 Only lock document if switch is set.
'   2008/08/22  DAH @68 DeleteLabelRows() and RemoveDuplicateRows() moved here from modXlatTandC
'   2008/08/27  DAH @69 Added ClearClipboard().
'   2008/09/16  DAH @70 Added UseParens parameter to CurrencyFormat.
'   2008/10/31  STB @71 Change proofing status refomated document, proofing in modul modMain @06
'   2009/09/09  STB @72 insert new subs for replace typo character
'-----------------------------------------------------------------------------

' xxx see if we can convert to CSV instead of TabDelim, then we don't need schema.ini
' xxx change Reference to ADO to CreateObject call, in Addendum also

' Note: All records roughly keep to normalization rules except AS records.
' Anytime we read an AS record, let's interpret the ParentId to be that of
' the row below it, or to make less DB access, for roots, it's the RootId
' on the same row. This means we change our interpretation of if something's
' a root or not from whether the ParentId is blank to
' if the Parent and Root are equal.

Option Explicit

' LOG LEVEL
' 0 = NONE
' 1 = regular operations, log errors only
' 2 = debugging, log errors and useful traces
' 3 = debugging, log errors and more useful traces
' 4 = debugging, log errors, useful traces and verbose info
Public Const cServerLogLevel = 4 ' 1 is normal
Public Const cNonServerLogLevel = 4

Public Const cDefaultTableBehavior = wdWord9TableBehavior
Public Const cDefaultLineStyle = wdLineStyleSingle '@06
Public Const cDefaultLineWidth = wdLineWidth075pt
Public Const cDefaultColor = wdColorAutomatic '@60 was wdColorBlack
Public Const cLogFilename = "MSWordErr.log" '@25
Public Const cAppName = "Siemens Proposal Reformatter" '@25

'@41 Putting in a dreaded global class here.
Public gobjFeatures As New clsFeatures

Public Enum fldFolder '@62
    fldbin
    fldlog
    fldrtf
    fldtemp
End Enum

Declare Function CloseClipboard Lib "user32" () As Long '@69
Declare Function EmptyClipboard Lib "user32" () As Long
Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long

' True = success
Public Function TranslateDoc(doc As Document) As Boolean
    Dim objSourceTables As New clsSourceTables
    Dim blnAlreadyRun As Boolean
    Dim HasPOS As Boolean '@22
    Dim FullName As String '@24
    Dim retval As Boolean
    On Error GoTo TranslateDoc_Error '@37

    retval = True
    Set objSourceTables.Document = doc
    With objSourceTables
'@71        blnAlreadyRun = CBool(GetTableText(.Tables("tblDetailRecords"), 1, 1) <> "Quote Nr") '@04 Run Once
'@71        If blnAlreadyRun Then
'@71            MessageBox "This document has already been reformatted.", vbInformation + vbOKOnly, cAppName '@25
'@71        Else
            If Application.Visible Then System.Cursor = wdCursorWait '@21
            If LCase(doc.Name) <> "lastproposal.doc" Then '@24, @37
                FullName = doc.FullName
                doc.SaveAs FileName:=TempFilePath & "LastProposal.doc", AddToRecentFiles:=False
                doc.SaveAs FileName:=FullName, AddToRecentFiles:=False
            End If
            Set gobjFeatures.Document = doc '@41, @49, @66
'@55        If retval Then '@54
'@55            LogMessage 3, "TweakPageOne..."
'@55            retval = TweakPageOne(doc)
'@55        End If
            If retval Then '@57
                LogMessage 3, "TranslateQuoteNotes..."
                retval = TranslateQuoteNotes(.Tables("tblQuoteNotes"))
            End If
            If retval Then
                LogMessage 3, "TranslateDetailRecordsTable..."
                retval = TranslateDetailRecordsTable(.Tables("tblDetailRecords"))
            End If
            If retval Then
                LogMessage 3, "TranslateTandCTable..."
                retval = TranslateTandCTable(.Tables("tblTandC"))
            End If
            If retval Then '@64
                LogMessage 3, "LinkAllHeadersFooters..."
                retval = LinkAllHeadersFooters(doc)
            End If
            If retval Then '@16
                LogMessage 3, "GenerateTechSpecs..." '@48
                retval = GenerateTechSpecs(doc)      '@48
            End If
            If retval Then '@58
                LogMessage 3, "TweakTOC..."
                retval = TweakTOC(doc)
            End If
'@65        Moved into TranslateDetailRecordsTable()
'@65        If retval Then '@59
'@65            ReplaceSpecialCharacterWithParagraphMarks doc.Range
'@65        End If
'@58        Moved into modXlatTOC
'@58        If retval Then '@50
'@58            doc.Styles("TOC 1").Font.Size = 10
'@58            If doc.TablesOfContents.Count > 0 Then
'@58                doc.TablesOfContents(1).Update
'@58            End If
'@58        End If
            '@53
            If Not Application.Visible Then
                If gobjFeatures.LockDocument Then '@67
                    LogMessage 3, "Locking document..."
                    retval = ProtectDocument(doc)
                End If
            End If
            If retval Then
                LogMessage 3, "Finishing up..."
            End If
            If Application.Visible Then System.Cursor = wdCursorNormal '@21
            If retval Then '@07
                MessageBox "Reformatting was completed successfully.", vbInformation + vbOKOnly, cAppName '@25
            Else
                MessageBox "An error occurred while reformatting.", vbExclamation + vbOKOnly, cAppName '@25
            End If
'@71        End If
    End With
    TranslateDoc = retval

    Exit Function

TranslateDoc_Error: '@37
    LogMessage 1, "modXlat0Common::TranslateDoc"
    Resume Next
End Function

Public Sub SetTableText(tbl As Table, ByVal Row As Integer, ByVal col As Integer, ByVal s As String)
    On Error Resume Next
    tbl.Cell(Row, col).Range.Text = s
End Sub

Public Function GetTableText(tbl As Table, ByVal Row As Integer, ByVal col As Integer) As String
    On Error Resume Next
    With tbl.Cell(Row, col).Range
        GetTableText = Left$(.Text, Len(.Text) - 2) ' chop off the 0x0d, 0x07
    End With
End Function

Public Sub SetColumnHeadings(tbl As Table, a As Variant)
    Dim c As Integer
    On Error Resume Next
    For c = 0 To UBound(a)
        SetTableText tbl, 1, c + 1, a(c)
    Next
End Sub

'@07
Public Sub AddColumnHeadings(TextTable As clsTextTable, a As Variant)
    Dim c As Integer
    On Error Resume Next
    For c = 0 To UBound(a)
        TextTable.AddCell a(c)
    Next
End Sub

'@07
' This function changes the Selection. You may want to Collapse it later.
Public Sub AlignColumn(col As Word.Column, ParagraphAlignment As WdParagraphAlignment)
    col.Select
    Selection.ParagraphFormat.Alignment = ParagraphAlignment
End Sub

'@33
Public Sub AlignColumns(cols As Word.Columns, a As Variant)
    Dim c As Integer, ParagraphAlignment As WdParagraphAlignment
    On Error Resume Next
    For c = 0 To UBound(a)
        ParagraphAlignment = a(c)
        AlignColumn cols(c + 1), ParagraphAlignment
    Next
End Sub

'@33
' Please send in Inches; we'll convert to Points.
Public Sub SetColumnWidths(cols As Word.Columns, a As Variant)
    Dim c As Integer
    On Error Resume Next
    For c = LBound(a) To UBound(a)
        cols(c + 1).Width = InchesToPoints(a(c))
    Next
End Sub

Public Sub ReplaceNonBreakingSpaces(rng As Range)
    rng.Find.Execute FindText:="^s", ReplaceWith:=" ", Replace:=wdReplaceAll
End Sub

Public Sub ReplaceLineBreaks(rng As Range)
    rng.Find.Execute FindText:="^l", ReplaceWith:="^p", Replace:=wdReplaceAll
End Sub

'@59 Replace Spaces with Nonbreaking Spaces.
Public Sub ReplaceSpaces(rng As Range)
    rng.Find.Execute FindText:=" ", ReplaceWith:="^s", Replace:=wdReplaceAll
End Sub

'@59 Replace Hyphens with Nonbreaking Hyphens.
Public Sub ReplaceHyphens(rng As Range)
    rng.Find.Execute FindText:="-", ReplaceWith:="^~", Replace:=wdReplaceAll
End Sub

'@53 Replace Line Breaks with SpecialCharacter.
Public Sub ReplaceLineBreaksWithSpecialCharacter(rng As Range)
    rng.Find.Execute FindText:="^l", ReplaceWith:=SpecialCharacter, Replace:=wdReplaceAll
End Sub

'@53 Replace SpecialCharacter with Paragraph Marks.
Public Sub ReplaceSpecialCharacterWithParagraphMarks(rng As Range)
    rng.Find.Execute FindText:=SpecialCharacter, ReplaceWith:="^p", Replace:=wdReplaceAll
End Sub

'@72 20090909 STB typo character
Public Sub ReplaceAnfuerhungWithAnfuehrung(rng As Range)
    rng.Find.Execute FindText:=ChrW(8222), ReplaceWith:=Chr(34), Replace:=wdReplaceAll
End Sub
'@72 20090909 STB  typo character
Public Sub ReplacefrAnfuerhungWithfrAnfuehrung(rng As Range)
    rng.Find.Execute FindText:=Chr(187), ReplaceWith:=">>", Replace:=wdReplaceAll
End Sub
'@72 20090909 STB  typo character
Public Sub ReplacefrEndfuerhungWithfrEndfuehrung(rng As Range)
    rng.Find.Execute FindText:=Chr(171), ReplaceWith:="<<", Replace:=wdReplaceAll
End Sub

'@01, @15
Public Function Nz( _
                value As Variant, _
                Optional ValueIfNull As Variant = vbNullString _
            ) As Variant
    If IsNull(value) Then
        Nz = ValueIfNull
    ElseIf value = vbNullString Then
        Nz = ValueIfNull
    Else
        Nz = value
    End If
End Function

' If the Parent Id is a vbNullString or if equal to Parent=Root,
' then this is a Root System.
Public Function IsRootSystem( _
            ByVal strParentSystemId As String, _
            ByVal strRootSystemId As String _
        ) As Boolean
    Dim retval As Boolean
    If Not retval Then retval = CBool(LenB(strParentSystemId) = 0)
    If Not retval Then retval = CBool(strParentSystemId = strRootSystemId)
    IsRootSystem = retval
End Function

'@42
Public Function IsAlphanumeric(ByVal Char As String) As Boolean
    IsAlphanumeric = True
    If Char >= "a" And Char <= "z" Then Exit Function
    If Char >= "A" And Char <= "Z" Then Exit Function
    If Char >= "0" And Char <= "9" Then Exit Function
    IsAlphanumeric = False
End Function

'@46
Public Function IsAlphaChar(ByVal Char As String) As Boolean
    ' The mulptiple case checks are probably redundant because Option Case Text is assumed.
    IsAlphaChar = True
    If Char >= "a" And Char <= "z" Then Exit Function
    If Char >= "A" And Char <= "Z" Then Exit Function
    IsAlphaChar = False
End Function

'@46
Public Function AnyAlphaChars(ByVal String1 As String) As Boolean
    Dim i As Long
    For i = 1 To Len(String1)
        If IsAlphaChar(Mid(String1, i, 1)) Then
            AnyAlphaChars = True
            Exit Function
        End If
    Next i
End Function

'@41
Public Function RTrimWhite(ByVal s As String) As String
    Do Until IsAlphanumeric(Right(s, 1)) Or LenB(s) = 0
        s = Left(s, Len(s) - 1)
    Loop
    RTrimWhite = s
End Function

'@44
Public Function CreateAddress(rs As ADODB.Recordset) As String
    Dim strAddress As String
    ConcatAddressField strAddress, rs, "Ship To Address", vbNullString
    ConcatAddressField strAddress, rs, "Ship To Address 2", ", "
    ConcatAddressField strAddress, rs, "Ship To City", ", "
    ConcatAddressField strAddress, rs, "Ship To State", ", "
    ConcatAddressField strAddress, rs, "Ship To Zip", "  "
    CreateAddress = strAddress
End Function

'@44
Public Sub ConcatAddressField( _
            ByRef Address As String, _
            rs As ADODB.Recordset, _
            ByVal FieldName As String, _
            ByVal Separator As String _
        )
    Dim strFieldValue As String
    strFieldValue = FieldValue(rs, FieldName)
    If LenB(strFieldValue) <> 0 Then
        If LenB(Address) <> 0 Then
            Address = Address & Separator & strFieldValue
        Else
            Address = strFieldValue
        End If
    End If
End Sub

'@06
' Full grid - you want anything else, do it yourself!
Public Sub SetTableBorders( _
            tbl As Word.Table, _
            ByVal LineStyle As WdLineStyle, _
            ByVal LineWidth As WdLineWidth, _
            ByVal Color As WdColor _
        )
    Dim c As Cell
    On Error GoTo SetTableBorders_Error
    
    For Each c In tbl.Range.Cells
        With c
            With .Borders(wdBorderLeft)
                .LineStyle = LineStyle
                .LineWidth = LineWidth
                .Color = Color
            End With
            With .Borders(wdBorderRight)
                .LineStyle = LineStyle
                .LineWidth = LineWidth
                .Color = Color
            End With
            With .Borders(wdBorderTop)
                .LineStyle = LineStyle
                .LineWidth = LineWidth
                .Color = Color
            End With
            With .Borders(wdBorderBottom)
                .LineStyle = LineStyle
                .LineWidth = LineWidth
                .Color = Color
            End With
        End With
    Next

    Exit Sub

SetTableBorders_Error:
    LogMessage 1, "modXlat0Common::SetTableBorders"
    Resume Next
End Sub

'@07
Public Function MessageBox( _
            ByVal Prompt As String, _
            Optional ByVal Buttons As VbMsgBoxStyle = vbOKOnly, _
            Optional Title As String = vbNullString _
        ) As VbMsgBoxResult
    If Application.Visible Then '@21
        If LenB(Title) = 0 Then
            Title = Application.Name
        End If
        MsgBox Prompt, Buttons, Title
    Else
        LogMessage 2, Prompt
    End If
End Function

'@08
Public Function LogLevel() As Integer
    Static sblnInitialized As Boolean
    Static sintLogLevel As Integer
    If Not sblnInitialized Then
        sintLogLevel = IIf(Application.Visible, cNonServerLogLevel, cServerLogLevel) '@21
        sblnInitialized = True
    End If
    LogLevel = sintLogLevel
End Function

'@08, @09
Public Function LogFile() As String
    LogFile = LogFilePath & cLogFilename '@23, @25
End Function

'@07, @08
Public Sub LogMessage(ByVal mLogLevel As Integer, Text As String)
    If LogLevel >= mLogLevel Or (Err.Number <> 0 And LogLevel > 0) Then
        Dim FileNum As Integer '@61
        FileNum = FreeFile
        Open LogFile For Append As #FileNum '@09
        Print #FileNum, Now & ": " & ActiveDocument.FullName & ", Word Build:" & Application.Build & _
                ", Template Version:" & cVersionStamp & "(" & cTimeStamp & ")" & _
                ", User:" & Application.UserName & _
                IIf(LenB(Text) <> 0, ", Msg:" & Text, vbNullString) & _
                IIf(Err.Number <> 0, ", Error #" & Err.Number & " (" & Err.Description & _
                    ") from " & Err.Source, vbNullString)
        Close #FileNum
    End If
End Sub

'@13
Public Function NumberOf( _
            ByVal Count As Variant, _
            ByVal IfSingular As String, _
            ByVal IfPlural As String _
        ) As String
    NumberOf = Count & " " & IIf(Count = 1, IfSingular, IfPlural)
End Function

'@70 UseParens takes precedence over ShowPlusSigns.
'@63 Always put a space before negative numbers.
Public Function CurrencyFormat( _
            ByVal value As Variant, _
            Optional ByVal ShowPlusSigns As Boolean = False, _
            Optional ByVal UseParens As Boolean = False _
        ) As String '@13, @63, @70
    Dim Fmt As String
    If UseParens Then
        Fmt = "$#,##0;($#,##0)"
    ElseIf ShowPlusSigns Then
        Fmt = "+ $#,##0;- $#,##0"
    Else
        Fmt = "$#,##0;- $#,##0"
    End If
    CurrencyFormat = Format(value, Fmt)
End Function

#If False Then '@70
Public Function CurrencyFormat( _
            ByVal value As Variant, _
            Optional ByVal ShowPlusSigns As Boolean = False _
        ) As String '@13, @63
    CurrencyFormat = Format(value, "$#,##0")
    '@63 Always put a space before negative numbers.
    If Left$(CurrencyFormat, 1) = "-" Then
        CurrencyFormat = "- " & Mid$(CurrencyFormat, 2) '@09 was "Subtract "
    ElseIf ShowPlusSigns Then
        CurrencyFormat = "+ " & CurrencyFormat '@09 was "Add "
    End If
End Function
#End If '@70

'@18
Public Function TimeFormat(ByVal value As Variant) As String
    TimeFormat = Format(value, "hh:mm" & nbsp & "AM/PM") '@43
End Function

'@17
Public Function IsElementOfCollection(ByVal e As Variant, c As Collection) As Boolean
    Dim x As Variant
    For Each x In c
        If x = e Then
            IsElementOfCollection = True
        End If
    Next
End Function

'@21
Public Sub SetRegValue(ByVal strFolderName As String, ByVal strValueName As String, ByVal StrValue As String)
    ' "" uses Registry
    System.PrivateProfileString("", strFolderName, strValueName) = StrValue
End Sub

'@33
' Send in R/O/A and get back Rel/Opt/Alt.
Public Function RelevancyString(ByVal Relevancy As String) As String
    Select Case UCase(Relevancy)
        Case "O": RelevancyString = "Opt"
        Case "A": RelevancyString = "Alt"
        Case "R": RelevancyString = "Rel"
    End Select
End Function

'@52
Public Function IsRelevant(ByVal Relevant As RelevancyFlags) As Boolean
    IsRelevant = CBool(Relevant And rfRelevant) ' bit-wise And
End Function

Public Function IsOptional(ByVal Relevant As RelevancyFlags) As Boolean
    IsOptional = CBool(Relevant And rfOptional)  ' bit-wise And
End Function

Public Function IsAlternative(ByVal Relevant As RelevancyFlags) As Boolean
    IsAlternative = CBool(Relevant And rfAlternative)  ' bit-wise And
End Function

Public Function Rel2RelevancyFlag(ByVal RString As String) As RelevancyFlags
    Select Case UCase(RString)
        Case "R":   Rel2RelevancyFlag = rfRelevant
        Case "O":   Rel2RelevancyFlag = rfOptional
        Case "A":   Rel2RelevancyFlag = rfAlternative
        Case Else:  Rel2RelevancyFlag = rfNone
    End Select
End Function

Public Function ProtectDocument(doc As Word.Document) As Boolean '@53
    On Error GoTo ProtectDoc_Error
    doc.Protect Type:=wdAllowOnlyFormFields, Password:="GiraffE4MagiC"
    ProtectDocument = True
    Exit Function
    
ProtectDoc_Error: '@37
    LogMessage 1, "modXlat0Common::ProtectDoc"
    Resume Next
End Function

Public Sub AddTOCEntry(rng As Word.Range, Text As String)
    With rng
        .start = .Fields.Add( _
                            rng, _
                            wdFieldTOCEntry, _
                            """" & Text & """", _
                            False _
                        ).Code.End + 1
    End With
End Sub

Public Sub CheckFileSystem(ByRef FileSystem As String) '@62
    ' Cautious here about using spaces in the path, because I'm not sure
    ' UncompressSAF will not work.
'    On Error Resume Next
'    Dim Server As String
'    Server = Mid$(FileSystem, 3, InStr(3, FileSystem, "\") - 3)
'    If Ping(Server) Then Exit Sub      ' OK!
    If Not FolderExists(FileSystem) Then
        Const LocalPath As String = "\Progra~1\Siebel\7.8\WebCli~1\Local\Files"
        If FolderExists("C:" & LocalPath) Then
            FileSystem = "C:" & LocalPath
        ElseIf FolderExists("D:" & LocalPath) Then
            FileSystem = "D:" & LocalPath
        'else? leave it alone and just bomb
        End If
    End If
End Sub

' Caution: Only works on Windows 2000+.
Public Function Ping(Machine As String) As Boolean '@62
    Dim objPing, objStatus
    Set objPing = GetObject("winmgmts:"). _
        ExecQuery("select * from Win32_PingStatus where address = '" _
        & Machine & "'")
    For Each objStatus In objPing
        If IsNull(objStatus.StatusCode) Or objStatus.StatusCode <> 0 Then Exit Function
        Ping = True
    Next
End Function

' From here on down is currently not used:
Public Function PRFFolder(Folder As fldFolder) As String '@62
    Dim strFolder As String
    Select Case Folder
        Case fldbin:  strFolder = "\bin"
        Case fldlog:  strFolder = "\log"
        Case fldrtf:  strFolder = "\rtf"
        Case fldtemp: strFolder = "\temp"
        Case Else:    Exit Function
    End Select
    strFolder = BasePRFFolder & strFolder
    If FolderExists(strFolder) Then
        PRFFolder = strFolder
    End If
End Function

Public Function BasePRFFolder() As String '@62
    Static sstrPath As String
    If LenB(sstrPath) = 0 Then
        If Not Application.Visible Then
            sstrPath = "\\" & Environ$("COMPUTERNAME") & "\proposalreformatter"
            If Not FolderExists(sstrPath & "\log") Then  ' see if the log folder exists
                sstrPath = vbNullString
                Const LocalPath As String = "\Progra~1\Siebel\7.8\WebCli~1\Local\Files\proposalreformatter"
                If FolderExists("C:" & LocalPath) Then
                    sstrPath = "C:" & LocalPath
                ElseIf FolderExists("D:" & LocalPath) Then
                    sstrPath = "D:" & LocalPath
                End If
            End If
        End If
        If LenB(sstrPath) = 0 Then
            sstrPath = "c:\ProposalReformatterLocal"
            If Not FolderExists(sstrPath) Then
                On Error Resume Next
                MkDir sstrPath
                Err.Clear
                If Not FolderExists(sstrPath) Then
                    sstrPath = "d:\ProposalReformatterLocal"
                    If Not FolderExists(sstrPath) Then
                        MkDir sstrPath
                        Err.Clear
                        If Not FolderExists(sstrPath) Then
                            sstrPath = vbNullString
                        End If
                    End If
                End If
            End If
        End If
    End If
    BasePRFFolder = sstrPath
End Function

' WATCH OUT - this function yields false positive on files.
' Don't have time to fix it, and it's not crucial for our current purposes.
' Dir() can generate an error if it can't reach the location, so we handle it here.
Public Function FolderExists(Folder As String) As Boolean '@62
    On Error Resume Next
    Dim i As Integer
    i = LenB(Dir(Folder, vbDirectory))
    Err.Clear
    FolderExists = CBool(i <> 0)
End Function

Public Function FileExists(File As String) As Boolean '@62
    On Error Resume Next
    Dim i As Integer
    i = LenB(Dir(File))
    Err.Clear
    FileExists = CBool(i <> 0)
End Function

' Link all primary headers and footers.
' Dependency: Make sure the main template begins with a Continuous Section Break
' and that Section 1 has the desired header and footer for the entire document.
' All other assigned headers and footers will therefore be discarded.
' Even and FirstPage headers and footers are not currently dealth with.
Public Function LinkAllHeadersFooters(doc As Word.Document) As Boolean '@64
    Dim iSection As Integer
    For iSection = 2 To doc.Sections.Count
        With doc.Sections(iSection)
            .Headers(wdHeaderFooterPrimary).LinkToPrevious = True
            .Footers(wdHeaderFooterPrimary).LinkToPrevious = True
        End With ' doc.Sections(iSection)
    Next iSection
    LinkAllHeadersFooters = True
End Function

' Give us a Table, we'll delete all heading info and blank separator rows between Quotes
' and return the number of rows remaining. If the number of rows remaining is 0,
' any further use of tbl will yield a 5825 Object Deleted Run-Time Error, so PLEASE be sure
' to check the return value.
Public Function DeleteLabelRows(tbl As Word.Table) As Integer '@68
    On Error GoTo Error ' if we hit an error, assume it's because the table is all deleted
    Dim r As Integer
    With tbl
        r = 1
        Do While r <= .Rows.Count
            If GetTableText(tbl, r, 1) = "Quote Nr" Then ' start of new quote
                If r > 1 Then .Rows(r - 1).Delete: r = r - 1 ' blank row above (except for the first row)
                .Rows(r).Delete ' "Quote Nr" (the label)
                .Rows(r).Delete '  Quote Nr  (the value)
                If r < .Rows.Count Then  ' can't be the last row
                    If LenB(GetTableText(tbl, r, 1)) <> 0 Then .Rows(r).Delete ' more labels
                End If
            Else
                r = r + 1
            End If
        Loop
        DeleteLabelRows = .Rows.Count
    End With 'tbl
    Exit Function
Error:
    Err.Clear ' return 0 rows
End Function

' Send us a Table with Rows already pre-sorted by the key field in the first column
' and we'll erase rows with duplicate keys. We'll return the number of rows remaining.
Public Function RemoveDuplicateRows(tbl As Word.Table) As Integer '@68
    On Error GoTo Error ' if we hit an error, assume it's because the table is all deleted
    Dim r As Integer
    With tbl
        r = 2
        Do While r <= .Rows.Count
            If GetTableText(tbl, r, 1) = GetTableText(tbl, r - 1, 1) Then
                .Rows(r).Delete
            Else
                r = r + 1
            End If
        Loop
        RemoveDuplicateRows = .Rows.Count ' may yield an error and return 0
    End With 'tbl
    Exit Function
Error:
    Err.Clear
End Function

Public Sub ClearClipboard() '@69
    OpenClipboard 0&
    EmptyClipboard
    CloseClipboard
End Sub

Attribute VB_Name = "modXlat1PageOne"
#If False Then '@01

'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modXlat1PageOne - tweak Page One, including Form Fields
' Creation:     2008/04/25
' Modifications:
'   2008/04/25  DAH Created this module.
'   2008/05/06  DAH @01 Removed functionality.
'-----------------------------------------------------------------------------

Option Explicit

Public Function TweakPageOne(ByRef doc As Word.Document) As Boolean
    TweakPageOne = ConvertBookmarksToFormFields(doc)
End Function

' Capture current bookmark contents.
' Convert bookmarks to textinput form fields.
' Configure the form fields, including setting the default values to the old values.
Private Function ConvertBookmarksToFormFields(ByRef doc As Word.Document) As Boolean
    On Error GoTo ConvertBookmarksToFormFields_Err
    Dim strName As String, strPosition As String
    strName = GetSiemensRepName(doc)
    ConvertBookmarkToFormField _
            doc, _
            "ffRepName", _
            "You may edit the name of the Siemens repesentative here.", _
            strName
    strPosition = doc.Bookmarks("Position").Range.Text
    ConvertBookmarkToFormField _
            doc, _
            "ffPosition", _
            "You may edit the position / title of the Siemens repesentative here.", _
            strPosition
    ConvertBookmarkToFormField _
            doc, _
            "ffDate", _
            "You may enter the date of signing here.", _
            vbNullString
    ConvertBookmarksToFormFields = True
    Exit Function
    
ConvertBookmarksToFormFields_Err:
    LogMessage 1, "modXlat1PageOne::ConvertBookmarksToFormFields"
    Resume Next
End Function

Private Function GetSiemensRepName(doc As Word.Document) As String
    On Error GoTo GetSiemensRepName_Err
    Dim strFirstName As String, strLastName As String, strName As String
    strFirstName = doc.Bookmarks("FirstName").Range.Text ' Position
    strLastName = doc.Bookmarks("LastName").Range.Text
    If LenB(strFirstName) <> 0 Then
        If LenB(strLastName) <> 0 Then
            strName = strFirstName & " " & strLastName
        Else
            strName = strFirstName
        End If
    ElseIf LenB(strLastName) <> 0 Then
        strName = strLastName
    End If
    GetSiemensRepName = strName
    Exit Function
    
GetSiemensRepName_Err:
    LogMessage 1, "modXlat1PageOne::GetSiemensRepName"
    Resume Next
End Function

Private Function ConvertBookmarkToFormField( _
            ByRef doc As Word.Document, _
            ByVal BookmarkName As String, _
            ByVal HelpText As String, _
            Optional ByVal DefaultValue As String _
        ) As Boolean
    On Error GoTo ConvertBookmarkToFormField_Err
    Dim rng As Word.Range
    Set rng = doc.Bookmarks(BookmarkName).Range
    With rng.FormFields.Add(Range:=rng, Type:=wdFieldFormTextInput)
        .Name = BookmarkName
        .OwnStatus = True
        .StatusText = HelpText
        With .TextInput
            .EditType Type:=wdRegularText, Default:=DefaultValue, Format:=""
            .Width = 0
        End With
    End With
    ConvertBookmarkToFormField = True
    Exit Function
    
ConvertBookmarkToFormField_Err:
    LogMessage 1, "modXlat1PageOne::ConvertBookmarkToFormField"
    Resume Next
End Function

#End If '@01
Attribute VB_Name = "modXlat2DetailRecords"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modXlatDetailRecords
' Creation:     2007/03/31
' Modifications:
'   2007/03/31  DAH Created this module.
'   2007/04/27  DAH @01 Handle warranty.
'   2007/05/24  DAH @02 Duplicated functionality for O/A root systems.
'   2007/06/05  DAH @03 Slight rewrite when rewriting all subsystem code.
'   2008        DAH     Major rewrite for CSG Sales.
'   2008/06/11  DAH @04 Handle embedded line breaks in B-Text.
'   2008/07/03  DAH @05 Grab first QuoteNr and Revision from table.
'   2008/07/31  DAH @06 SpecialCharacter resetting moved here from TranslateDoc.
'   2008/08/26  DAH @07 Skip potentially empty Quotes at the beginning of the table.
'-----------------------------------------------------------------------------
Private Const cTempBookmarkName As String = "StartOfDetailRecords"
Option Explicit
'' Select, generate, write (textfile.txt) and delete old table of the given Word.Table
'' after that it will be create a new Bookmark
'' Used for DetailsStart aka Items
'Public Function generateDetailRecordsTextFile(tbl As Word.Table) As Boolean
'    Dim rng As Word.Range
'    Dim rs As ADODB.Recordset
'    Dim objRSFilter As New clsRecordsetFilter
'    Dim objSystemEmitter As New clsSystemEmitter
'    Dim retval As Boolean
'    'uk Const cTempBookmarkName As String = "StartOfDetailRecords" '@06
'    Dim bk As Word.Bookmark '@06
'    ' Perform table translation
'    ' Delete all blank quotes at the top here, then get the first Quote Nr, and delete the Quote Nr.
'    Do '@07 revamped
'        If GetTableText(tbl, 1, 1) = "Quote Nr" Then ' sanity check
'            '@05 Grab the first Quote Nr and Revision from the top of the table before we delete it.
'            ' In later runs, we grab it from the Recordset.
'            ' We delete them here though so we'll have all the field headings for the detail records.
'            objSystemEmitter.QuoteNumber = GetTableText(tbl, 2, 1)    '@05
'            objSystemEmitter.RevisionNumber = GetTableText(tbl, 2, 2) '@05
'            tbl.Rows(1).Delete ' now delete "Quote Nr" (the labels)
'            If tbl.Rows.Count = 1 Then '@07 if it's the last Quote, then no data, so bail out...
'                tbl.Delete ' delete this 1-row table first
'                Exit Function ' and bail out
'            End If
'            tbl.Rows(1).Delete ' now delete Quote Nr (the values)
'            If LenB(GetTableText(tbl, 1, 1)) <> 0 Then Exit Do ' we found some data, as evidenced by field headings
'            tbl.Rows(1).Delete ' blank quote, so delete the blank separator row and continue
'        Else
'            tbl.Range.InsertBefore "THE DATA IN THIS TABLE IS NOT FORMATTED CORRECTLY!" & vbCrLf
'            Exit Function ' bad data!!!
'        End If
'    Loop
'    ReplaceNonBreakingSpaces tbl.Range
'    ' Embedded Line Breaks in B-Text was throwing everything off, so temporarily replace them
'    ' with a funky character sequence and then we'll change them all back when we're done.
'    ReplaceLineBreaksWithSpecialCharacter tbl.Range '@04
'    'uk At this point the textfile.txt will be generated
'    Set rs = ConvertTableToRS(tbl)
'    If rs.State <> adStateOpen Then Exit Function
'    Set rng = tbl.Range
'    tbl.Delete
'
'    Set bk = rng.Parent.Bookmarks.Add(cTempBookmarkName, rng) '@06
'
''    objRSFilter.SetFilterOnRootSystems rs
''    ' now the new Table will be generated, no reading in textfile.txt
''        retval = EmitSystemTables(rs, rng, objSystemEmitter)
''    objRSFilter.RestoreFilter
''    ReplaceSpecialCharacterWithParagraphMarks rng.Parent.Range(bk.Start, rng.End) '@06
'
'
'   generateDetailRecordsTextFile = retval
'End Function
'Public Sub getDetailRecordsFromTextFile()
'    Dim retval As Boolean
'    Dim rs     As ADODB.Recordset
'    Dim intRecord    As Integer
'    Dim intRecords   As Integer
'    Dim objRSFilter  As New clsRecordsetFilter
'    Dim Items() As Item
'    Dim myI As Item
'    Dim i As Integer
'    Dim ArrayLaenge As Integer
'
'    retval = True
'    ' Get and display data.
'    'retval = EmitTechSpecsHeader(rng) '@28
'    Set rs = OpenRS
'    'objRSFilter.SetFilterOnRootSystems rs
'    intRecords = rs.RecordCount
'    ReDim Items(intRecords) 'Array angepasst
'    For intRecord = 1 To intRecords
'        'retval = retval And GenerateTechSpecsForSystem(rs, rng, intRecord, RecordsAdded)
'        Items(intRecord) = modShareInternational.getItemFromRS(rs, intRecord)
'        'Debug.Print "1-" & Time & "|" & Items(intRecord).lineNr & "|" & Items(intRecord).PositionCode & "|" & Items(intRecord).Relevance & "|" & Items(intRecord).Product & "|" & Items(intRecord).Description
'       ' Debug.Print "1--" & Items(intRecord).PositionCode & "|" & Items(intRecord).Relevance & "|" & Items(intRecord).Product & "|" & Items(intRecord).Description
'        rs.MoveNext
'
'    Next intRecord
'
'   ' objRSFilter.RestoreFilter
'   ' rs.Close
'   ' Set rs = Nothing
'    ''
'    ArrayLaenge = (UBound(Items) - LBound(Items) + 1)
'    For i = 1 To ArrayLaenge
'        myI = Items(i)
'        Debug.Print "2-" & Time & "|" & myI.lineNr & "|" & myI.PositionCode & "|" & myI.Relevance & "|" & myI.Product & "|" & myI.Description & "|" & myI.BasePrice
'    Next i
'
'    ''
'    'getDetailRecordsFromTextFile = retval
'End Sub

Public Function TranslateDetailRecordsTable(tbl As Word.Table) As Boolean
    Dim rng As Word.Range
    Dim rs As ADODB.Recordset
    Dim objRSFilter As New clsRecordsetFilter
    Dim objSystemEmitter As New clsSystemEmitter
    Dim retval As Boolean
    Const cTempBookmarkName As String = "StartOfDetailRecords" '@06
    Dim bk As Word.Bookmark '@06
    ' Perform table translation
    ' Delete all blank quotes at the top here, then get the first Quote Nr, and delete the Quote Nr.
    Do '@07 revamped
        If GetTableText(tbl, 1, 1) = "Quote Nr" Then ' sanity check
            '@05 Grab the first Quote Nr and Revision from the top of the table before we delete it.
            ' In later runs, we grab it from the Recordset.
            ' We delete them here though so we'll have all the field headings for the detail records.
            objSystemEmitter.QuoteNumber = GetTableText(tbl, 2, 1)    '@05
            objSystemEmitter.RevisionNumber = GetTableText(tbl, 2, 2) '@05
            tbl.Rows(1).Delete ' now delete "Quote Nr" (the labels)
            If tbl.Rows.Count = 1 Then '@07 if it's the last Quote, then no data, so bail out...
                tbl.Delete ' delete this 1-row table first
                Exit Function ' and bail out
            End If
            tbl.Rows(1).Delete ' now delete Quote Nr (the values)
            If LenB(GetTableText(tbl, 1, 1)) <> 0 Then Exit Do ' we found some data, as evidenced by field headings
            tbl.Rows(1).Delete ' blank quote, so delete the blank separator row and continue
        Else
            tbl.Range.InsertBefore "THE DATA IN THIS TABLE IS NOT FORMATTED CORRECTLY!" & vbCrLf
            Exit Function ' bad data!!!
        End If
    Loop
    ReplaceNonBreakingSpaces tbl.Range
    ' Embedded Line Breaks in B-Text was throwing everything off, so temporarily replace them
    ' with a funky character sequence and then we'll change them all back when we're done.
    ReplaceLineBreaksWithSpecialCharacter tbl.Range '@04
    ' At this point the textfile.txt will be generated
    Set rs = ConvertTableToRS(tbl)
    If rs.State <> adStateOpen Then Exit Function
    Set rng = tbl.Range
    tbl.Delete
    Set bk = rng.Parent.Bookmarks.Add(cTempBookmarkName, rng) '@06
    objRSFilter.SetFilterOnRootSystems rs
        retval = EmitSystemTables(rs, rng, objSystemEmitter)
    objRSFilter.RestoreFilter
    ReplaceSpecialCharacterWithParagraphMarks rng.Parent.Range(bk.start, rng.End) '@06
    TranslateDetailRecordsTable = retval
End Function

Public Function EmitSystemTables( _
            rs As ADODB.Recordset, _
            rng As Word.Range, _
            SystemEmitter As clsSystemEmitter _
        ) As Boolean
    Dim intRecord As Integer, intRecords As Integer
    Dim retval As Boolean
        
    retval = True
    intRecords = rs.RecordCount
    For intRecord = 1 To intRecords
        If Not SystemEmitter.EmitSystem( _
                                rng:=rng, _
                                rs:=rs, _
                                RootSystemId:=FieldValue(rs, "Root Quote Item Id"), _
                                RecordNumber:=intRecord, _
                                TotalRecords:=intRecords _
                            ) Then
            retval = False
            Exit For
        End If

        ' Go to next root system
        rs.MoveNext
    Next intRecord
    EmitSystemTables = retval
End Function
Attribute VB_Name = "modXlat2DetailRecordsDB"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modXlatDetailRecordsDB - convert Detail Records Table into an ADODB.RecordSet
' Creation:     2007/03/31
' Modifications:
'   2007/03/31  DAH Created this module.
'   2007/04/19  DAH @01 FieldValue now returns ValueIfNull if
'                       there are no records in the provided RecordSet.
'   2007/04/19  DAH @02 Added ServerFilePath, NonServerFilePath and FilePath().
'   2007/04/27  DAH @03 Changed processing inside FieldValue().
'   2007/05/10  DAH @04 Added SetRegistryValues().
'   2007/05/16  DAH @05 RunningOnServer->Not Application.Visible
'                   @06 CreateSchemaIni now uses Table fields to specify all
'                       Text and Memo where appropriate.
'   2007/05/21  DAH @07 Changed share structure as per J.Krivoshey.
'   2007/05/31  DAH @08 Address embedded quotes by double-quoting.
'   2007/07/16  DAH @09 Made OpenRS Public so external callers can open the last textfile.
'   2008/06/27  DAH @10 Use FreeFile in CreateSchemaIni.
'-----------------------------------------------------------------------------

Option Explicit

'-----------------------------------------------------------------------------
'
' WARNING: FilePath() uses logic that sends data
'           on servers to a "log" share and
'           on non-servers to "C:\".
'
'-----------------------------------------------------------------------------

'-----------------------------------------------------------------------------
' LOCAL CONSTANTS FOR FILE ACCESS
'-----------------------------------------------------------------------------
' XXX Filenames. These will change to temp files, schema.ini will go away as we go CSV
' XXX move from TabDelimited to CSV and get rid of schema.ini
Private Const TextFilename As String = "textfile.txt"
Private Const SchemaFilename As String = "schema.ini"

'-----------------------------------------------------------------------------
' BEGIN WIN32 FUNCTIONS
'-----------------------------------------------------------------------------
Private Const OPEN_ALWAYS As Long = 4
Private Const FILE_BEGIN As Long = 0
Private Const GENERIC_WRITE As Long = &H40000000
Private Const GENERIC_READ As Long = &H80000000
Private Const FILE_ATTRIBUTE_NORMAL As Long = &H80

Private Declare Function CreateFile Lib "kernel32" _
   Alias "CreateFileA" _
  (ByVal lpFileName As String, _
   ByVal dwDesiredAccess As Long, _
   ByVal dwShareMode As Long, _
   ByVal lpSecurityAttributes As Long, _
   ByVal dwCreationDisposition As Long, _
   ByVal dwFlagsAndAttributes As Long, _
   ByVal hTemplateFile As Long) As Long

Private Declare Function GetFileSize Lib "kernel32" _
   (ByVal hfile As Long, lpFileSizeHigh As Long) As Long

Private Declare Function SetFilePointer Lib "kernel32" _
   (ByVal hfile As Long, _
    ByVal lDistanceToMove As Long, _
    lpDistanceToMoveHigh As Long, _
    ByVal dwMoveMethod As Long) As Long

Private Declare Function SetEndOfFile Lib "kernel32" _
  (ByVal hfile As Long) As Long

Private Declare Function CloseHandle Lib "kernel32" _
   (ByVal hfile As Long) As Long
'-----------------------------------------------------------------------------
' END WIN32 FUNCTIONS
'-----------------------------------------------------------------------------

Public Sub DeleteLastCRLF(ByVal FileName As String)
    Dim hfile As Long
    Dim newfilesize As Long
    Dim dwFileSizeLow As Long
    Dim dwFileSizeHigh As Long
      
    ' Open the file using Win32
    hfile = CreateFile(FileName, _
                        GENERIC_WRITE Or GENERIC_READ, _
                        0&, ByVal 0&, _
                        OPEN_ALWAYS, _
                        FILE_ATTRIBUTE_NORMAL, _
                        0&)
                          
    ' If the file is REALLY big, we'd need to deal with dwFileSizeHigh.
    dwFileSizeLow = GetFileSize(hfile, dwFileSizeHigh)
    If dwFileSizeHigh = 0 Then
        newfilesize = dwFileSizeLow - 2
        If SetFilePointer(hfile, newfilesize, dwFileSizeHigh, FILE_BEGIN) > 0 Then
            Call SetEndOfFile(hfile)
        End If
    End If
    CloseHandle hfile
End Sub

'-----------------------------------------------------------------------------
'
' WARNING: FilePath() uses logic that sends data
'           on servers to a "log" share and
'           on non-servers to "C:\".
'
'-----------------------------------------------------------------------------

'@02
Public Function TempFilePath() As String
    Static sstrPath As String
    If LenB(sstrPath) = 0 Then
        sstrPath = IIf(Application.Visible, _
                        "C:\", _
                        "\\" & Environ$("COMPUTERNAME") & "\proposalreformatter\temp\") '@05, @07
    End If
    TempFilePath = sstrPath
End Function

Public Function LogFilePath() As String '@07
    Static sstrPath As String
    If LenB(sstrPath) = 0 Then
        If Application.Visible Then
            sstrPath = "C:\"
        Else '@62
            sstrPath = "\\" & Environ$("COMPUTERNAME") & "\proposalreformatter\log\"  '@05, @07
            If Not FolderExists(sstrPath) Then
                Const LocalPath As String = "\Progra~1\Siebel\7.8\WebCli~1\Local\Files\proposalreformatter\log\"
                If FolderExists("C:" & LocalPath) Then
                    sstrPath = "C:" & LocalPath
                ElseIf FolderExists("D:" & LocalPath) Then
                    sstrPath = "D:" & LocalPath
                Else
                    sstrPath = "C:\"
                End If
            End If
        End If
    End If
    LogFilePath = sstrPath
End Function

Public Function ConvertTableToRS(tbl As Table) As ADODB.Recordset
    Dim newdoc As Document
    Dim rs As ADODB.Recordset
    CreateSchemaIni tbl '@06
    tbl.Range.Copy
    Set newdoc = Documents.Add
    newdoc.Range.Paste
    SetLineNumbers newdoc.Tables(1)
    newdoc.Tables(1).ConvertToText Separator:=wdSeparateByTabs, _
            NestedTables:=True
    '@08 Replace all quotes with double quotes.
    newdoc.Range.Find.Execute FindText:="""", ReplaceWith:="""""", Replace:=wdReplaceAll
    ' xxx Should use a temp filename in case several users are doing it simultaneously.
    newdoc.SaveAs _
            FileName:=TempFilePath & TextFilename, _
            FileFormat:=wdFormatText, _
            AddToRecentFiles:=False
    ' For Word2002+
    '        InsertLineBreaks:=False, _
    '        AllowSubstitutions:=False, _
    '        LineEnding:=wdCRLF
    newdoc.Close SaveChanges:=wdDoNotSaveChanges
    Call DeleteLastCRLF(TempFilePath & TextFilename)
    Set rs = OpenRS
    Set ConvertTableToRS = rs
End Function

Public Function OpenRS() As ADODB.Recordset '@09
    Dim cn As New ADODB.Connection
    Dim rs As New ADODB.Recordset
'@06    CreateSchemaIni - moved into ConvertTableToRS
'@06    SetRegistryValues '@04 - no longer in use
    cn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _
          "Data Source=" & TempFilePath & ";" & _
          "Extended Properties=""text;HDR=YES;FMT=TabDelimited"""
    rs.CursorLocation = adUseClient ' to allow us to disconnect
    rs.Open "select * from " & TextFilename, _
          cn, adOpenStatic, adLockReadOnly, adCmdText
'   rs.Open "SELECT * FROM [Text;Database=" & TextFilename & ";" & _
'          "HDR=YES;FMT=Delimited].[textfile.txt]", _
'          ,cn, adOpenStatic, adLockReadOnly, adCmdText
    Set rs.ActiveConnection = Nothing
    cn.Close
    Set OpenRS = rs
End Function

'@06 Added Table parameter and processing.
' If I had a config file, I'd put "b-text" in it as an option.
Private Sub CreateSchemaIni(tbl As Word.Table)
    Dim iCol As Integer
    Dim strFieldName As String
    Dim FileNum As Integer '@10
    FileNum = FreeFile
    Open TempFilePath & SchemaFilename For Output As #FileNum
    Print #FileNum, "[" & TextFilename & "]"
    Print #FileNum, "Format=TabDelimited"
    For iCol = 1 To tbl.Rows(1).Cells.Count
        strFieldName = GetTableText(tbl, 1, iCol)
        Print #FileNum, "Col" & iCol & "=" & QuoteIfMultipleWords(strFieldName) & " " & _
                IIf(LCase(strFieldName) = "b-text", "Memo", "Text")
    Next iCol
    Close #FileNum
End Sub

'@06
Private Function QuoteIfMultipleWords(ByVal str As String) As String
    If InStr(1, str, " ") > 0 Then
        QuoteIfMultipleWords = """" & str & """"
    Else
        QuoteIfMultipleWords = str
    End If
End Function

'@04
Private Sub SetRegistryValues()
    SetRegValue "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Jet\4.0\Engines\Text", _
        "ImportMixedTypes", "Text"
End Sub

Private Sub SetLineNumbers(tbl As Table)
Exit Sub ' xxx
    Dim r As Integer
    For r = 2 To tbl.Rows.Count
        tbl.Cell(r, 1).Range = r - 1
    Next
End Sub

'@03 Made vFieldValue from strFieldValue to correctly process Null.
' Be careful -- if assigning the result to an Integer - you should
' pass in ValueIfNull = "0", otherwise you may get a "Type mismatch"
' error if vbNullString is assigned to an Integer.
Public Function FieldValue( _
                rs As ADODB.Recordset, _
                ByVal FieldName As String, _
                Optional ValueIfNull As String = vbNullString _
            ) As String
    On Error Resume Next
    Dim vFieldValue As Variant
    vFieldValue = rs(FieldName)
    If Err.Number = 3265 Then ' Item cannot be found in the collection corresponding to the requested name or ordinal.
        LogMessage 1, "Bad field name: " & FieldName
        Err.Clear
        vFieldValue = """" & FieldName & """ not valid"
    ElseIf Err.Number = 3021 Then ' @01 Either BOF or EOF is True, or the current record has been deleted. Requested operation requires a current record.
        vFieldValue = ValueIfNull
        Err.Clear
    Else
        vFieldValue = Nz(vFieldValue, ValueIfNull)
    End If
    FieldValue = vFieldValue
End Function

Attribute VB_Name = "modXlat3TandC"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modXlatTandC- common constants and translation functions
' Creation:     2007/03/31
' Modifications:
'   2007/03/31  DAH Created this module.
'   2007/04/03  DAH @01 Added line numbers to T&C paragraphs.
'   2007/04/04  DAH @02 Changed body font size to 7 from 6.5 as per Mary Forbes.
'   2007/04/13  DAH @03 Added call to ReplaceLineBreaks.
'   2007/05/24  DAH @04 Fixed that pesky issue about the 15 tab chars, etc.
'   2007/05/30  DAH @05 Increased space around heading at customer's request.
'   2007/09/20  DAH @06 Bold the headings.
'   2007/10/04  DAH @07 T&C headings Arial 8pt.
'   2008/03/29  DAH @08 Table of Contents fields.
'   2008/07/12  DAH @09 Fixed long-standing 15-char deletion bogusness.
'                   @10 Added SectionBreak at end of T&C's.
'                   @11 Add trailing PageBreak. Don't make it a trailing NextPage SectionBreak,
'                       even though that seems logical, because we'll sweep by later and
'                       remove a trailing PageBreak, but we don't want special code to
'                       look instead for a NextPage SectionBreak.
'   2008/08/20  DAH @12 MultiModality
'   2008/08/22  DAH @13 DeleteLabelRows() and RemoveDuplicateRows() moved to modXlat0Common
'-----------------------------------------------------------------------------

Option Explicit

Public Function TranslateTandCTable(tbl As Table) As Boolean
    Dim rng As Word.Range
    Dim r As Integer
    With tbl
        ' Perform table translation
        If DeleteLabelRows(tbl) = 0 Then '@12
            TranslateTandCTable = True
            Exit Function ' no T&C's - get our of here - should never really happen
        End If
        .Sort                   '@12
        RemoveDuplicateRows tbl '@12
        .Columns(1).Delete      '@12 remove SMS Search Id
        ReplaceNonBreakingSpaces .Range
        ReplaceLineBreaks .Range
        .Range.Font.Size = 7 '@02
        .Range.Font.Name = "Arial"
        For r = 1 To .Rows.Count
            .Cell(r, 1).Range.InsertBefore r & ".  " '@01
            .Cell(r, 1).Range.Font.Name = "Times New Roman"
            .Cell(r, 1).Range.Bold = True   '@06
            .Cell(r, 1).Range.Font.Size = 8 '@07
            .Cell(r, 2).Range.InsertParagraphAfter
        Next
        Set rng = .ConvertToText(vbCrLf)
    End With ' tbl
    MakeTandCColumns rng
    With rng
        .ParagraphFormat.Alignment = wdAlignParagraphJustify ' justify the columnar sections
        .start = .start - 1 '@09 back up to the Paragraph Mark before the columnar section
        .Collapse Direction:=wdCollapseStart
        AddTOCEntry rng, "General Terms and Conditions" '@08, @09
        .InsertAfter "Siemens Medical Solutions USA, Inc. General Terms and Conditions" '@09 & vbCrLf '@04
        With .Font 'YYY style please
            .Name = "Arial"
            .Size = 14
            .Bold = True
        End With ' .Font
        With .ParagraphFormat
            .Alignment = wdAlignParagraphCenter
            .SpaceBefore = 12 '@05
            .SpaceAfter = 3   '@05
        End With ' .PararaphFormat
        ' Make just the Paragraph Mark 5pt. @09
        .Collapse Direction:=wdCollapseEnd
        .End = .End + 1 '@04
        .Font.Size = 5
        ' Insert the Horizontal Line right at the Section Break. @09
        .Collapse Direction:=wdCollapseEnd
        .InlineShapes.AddHorizontalLineStandard
    End With ' rng
    TranslateTandCTable = True
End Function

' Make 2-column format, with Continuous SectionBreaks before and after.
Sub MakeTandCColumns(rng As Range) '@10 many updates
    Dim rngTemp As Word.Range
    Set rngTemp = rng.Duplicate
    With rngTemp
        .InsertBreak Type:=wdSectionBreakContinuous ' SectionBreak before
        .Parent.Range(rng.End, rng.End).InsertBreak Type:=wdSectionBreakContinuous '@10 SectionBreak after
        .Parent.Range(rng.End + 1, rng.End + 1).InsertBreak Type:=wdPageBreak '@11 PageBreak after
        '@11 See note at top of file as to why we didn't use a NextPage SectionBreak here.
        With .PageSetup.TextColumns
            .SetCount NumColumns:=2
            .EvenlySpaced = True
            .LineBetween = True
            .Spacing = InchesToPoints(0.25)
        End With ' .PageSetup.TextColumns
    End With ' rngTemp
End Sub

#If False Then '@10
Private Sub MakeTandCColumns(rng As Range)
    Dim rngTemp As Range
    ' In Word2002+, Range has a member called Document, but in Word 2000, just Parent.
    '@10 Set rngTemp = rng.Parent.Range(rng.Start, rng.End)
    Set rngTemp = rng.Duplicate '@10
    rngTemp.InsertBreak Type:=wdSectionBreakContinuous
    ' We know there is a Section Break at the end, so don't put it in.
    With rngTemp.PageSetup.TextColumns
        .SetCount NumColumns:=2
        .EvenlySpaced = True
        .LineBetween = True
        .Spacing = InchesToPoints(0.25)
    End With
End Sub
#End If '@10

Attribute VB_Name = "modXlat4TechSpecs"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modXlatTechSpecs
' Creation:     2007/03/31
' Modifications:
'   2007/03/31  DAH Created this module.
'   2007/05/01  DAH Significantly fleshout out.
'   2007/05/07  DAH @01 Stubbed out call to SetTableBorders().
'   2007/05/10  DAH @02 gConfigInfo - defer on this - changes rolled back out.
'   2007/05/11  DAH @03 Add table headings.
'                   @04 Make Deliverables column Bold.
'   2007/05/21  DAH @05 Changed share structure as per J.Krivoshey.
'   2007/05/24  DAH @06 Hard-coded filesystem for UAT.
'   2007/06/04  DAH @07 Added hard-coded filesystem for Production Environment.
'   2007/06/06  DAH @08 Sorted.
'   2007/07/16  DAH @09 Storing unique Deliverables instead of SAF FileNames in the Collection
'                       to provide for Homogenized Deliverable names.
'   2007/07/25  DAH @10 Proposal Changes / Glossary #2 - widen Deliverables column
'                   @11 Proposal Changes / Glossary #3 - Deliverables 9pt Bold
'                   @12 Proposal Changes / Glossary #4 - Description 9pt
'                   @13 Proposal Changes / Glossary #5 - repeat heading rows
'                   @14 New Siebel config sending complete file path, not just filename.
'   2007/08/24  DAH @15 Added Parts Order Requirement and Parts Delivery to homogenization list.
'   2007/09/28  DAH @16 Addition of B-Text and Suppress Print columns.
'   2007/09/30  DAH @17 All rows in Glossary get AllowBreakAcrossPages = False.
'   2007/10/03  DAH @18 Don't print Shockwave or Tube Limit records.
'   2007/10/04  DAH @19 (Optional/Alternative) in Glossary now Italic, not Bold
'   2007/10/19  DAH @20 Complete overhaul.
'   2008/03/14  DAH @21 Corrected Glossary behavior - on Long format, if there is no E-Text,
'                       then NO entry prints for the item - not even a blank E-Text -
'                       no row at all.
'   2008/03/15  DAH @22 Final tweak on above.
'   2008/04/08  DAH @23 Added E-Text indentation adjustment.
'                   @24 Now all rows AllowBreakAcrossPages - some E-Texts are multiple pages long.
'   2008/05/06  DAH @24 Revamped for Sales.
'   2008/05/28  DAH @25 Added Part No.
'                   @26 Added Print Suppress.
'   2008/06/05  DAH @27 Continuation logic added.
'                   @28 Moved Tech Specs header into code from template.
'                   @29 Remove systems and/or Tech Specs if no data.
'   2008/06/09  DAH @30 Made 2 columns.
'   2008/06/19  DAH @31 Put borders back in.
'   2008/06/20  DAH @32 As per Dennis Huston, "(Continued)" has initial cap,
'                       comes before everything else. "(Optional)" and "(Alternate)"
'                       are boldface.
'   2008/06/23  DAH @33 Don't delete to the very end of the doc - there are Fields there -
'                       instead, just delete to the end of the range.
'   2008/06/24  DAH @34 "Alternative" -> "Alternate"
'                   @35 Make the system names consistent.
'   2008/06/27  DAH @36 Add in some code for Remote Web Clients.
'   2008/07/13  DAH @37 PageBreaks now come AFTER systems instead of before.
'   2008/07/17  DAH @38 Move Products to next page if Product Name spills over.
'   2008/07/18  DAH @39 Center the Tech Specs header.
'   2008/07/28  DAH @40 Remove "System #" from the system header.
'   2008/07/30  DAH @41 Local No Print Flag for Products.
'                   @42 Efficiency improvements.
'   2008/07/31  DAH @43 Correct flow issues.
'                   @44 Changed padding.
'   2008/08/01  DAH @45 Tweak indentation manipulation code.
'                   @46 Restore old padding - I think it was causing page flow problems.
'   2008/08/07  DAH @47 Reverse A/O order to match Detail Pages, a decision made 7/27/2008 (@31).
'   2008/08/12  DAH @48 Change "See End" message mechanism.
'   2008/08/18  DAH @49 Tweaking of "See End" message mechanism.
'   2009/04/17  STB @50 We need the empty line
'-----------------------------------------------------------------------------

Option Explicit

Private Enum gcGlossaryColumnType
    gcPartNumber = 1  '@25
    gcDeliverable = 1 '@30 - made same column as Part No.
    gcEText
End Enum

Public Enum RelevancyFlags ' bit flags
    rfNone = 0
    rfRelevant = 1
    rfOptional = 2
    rfAlternative = 4
End Enum

Private SystemsAdded As Boolean '@29

Private Const cstrOptional As String = "(Optional)" '@30
Private Const cstrAlternative As String = "(Alternate)" '@34
Private Const cstrContinued As String = "(Continued)" '@32 was all lowercase
Private Const cintLenContinued As Integer = 11 ' This must match string length of cstrContinued.
Private Const cblnOptAltBoldFlag As Boolean = True '@32 was False 'YYY make a style
Private Const cblnOptAltItalicFlag As Boolean = False '@32 was True
Private Const cblnContinuedBoldFlag As Boolean = True
Private Const cblnContinuedItalicFlag As Boolean = True

Public Function GenerateTechSpecs(doc As Word.Document) As Boolean  '@20
    On Error GoTo GenerateTechSpecs_Error
    Dim retval As Boolean
    Dim rng    As Word.Range
    Dim rs     As ADODB.Recordset
    Dim intRecord    As Integer
    Dim intRecords   As Integer
    Dim objRSFilter  As New clsRecordsetFilter
    Dim intStartPage As Integer '@27
    Const cBookmarkName As String = "TechSpecs"
    Dim bk As Word.Bookmark '@29
    Dim RecordsAdded As Boolean '@29
    
    GenerateTechSpecs = True
    ' Get rng in document.
    If Not doc.Bookmarks.Exists(cBookmarkName) Then
        LogMessage 1, "modXlat6Glossary::GenerateGlossaryTable: bookmark " & cBookmarkName & " not found"
        Exit Function ' don't flag an error that stops the show
    End If
    Set bk = doc.Bookmarks(cBookmarkName) '@29
    Set rng = bk.Range '@29
    intStartPage = rng.Information(wdActiveEndPageNumber) '@27
    ' Get and display data.
    retval = EmitTechSpecsHeader(rng) '@28
    Set rs = OpenRS
    SystemsAdded = False
    objRSFilter.SetFilterOnRootSystems rs
        intRecords = rs.RecordCount
        For intRecord = 1 To intRecords
            retval = retval And GenerateTechSpecsForSystem(rs, rng, intRecord, RecordsAdded)
            If RecordsAdded Then SystemsAdded = True '@29
            rs.MoveNext
        Next intRecord
    objRSFilter.RestoreFilter
    rs.Close
    Set rs = Nothing
    If SystemsAdded Then '@29
        CreateContinuationMessages doc, intStartPage '@27 YYY error checking!!!
    Else ' no data, remove the whole section
'@33    doc.Range(bk.Start, doc.Range.End).Delete
        doc.Range(bk.start, rng.End).Delete
    End If
    GenerateTechSpecs = True ' Always return True - don't halt processing.
    Exit Function
    
GenerateTechSpecs_Error:
    LogMessage 1, "modXlatTechSpecs::GenerateTechSpecs"
    Resume Next
End Function

' Upon return, Added tells you if any records were added.
Private Function GenerateTechSpecsForSystem( _
            rs As ADODB.Recordset, _
            rng As Word.Range, _
            ByVal intRecord As Integer, _
            ByRef Added As Boolean _
        ) As Boolean '@29
    On Error GoTo GenerateTechSpecsForSystem_Error
    Dim retval As Boolean
    Dim tbl As Word.Table
    Dim RootSystemId As String
    Dim bk As Word.Bookmark '@29
    Const cTempBookmarkName As String = "TempTechSpecsSystemBookmark" '@29

    GenerateTechSpecsForSystem = True '@29
    Added = False '@29
    retval = True '@26
    RootSystemId = FieldValue(rs, "Root Quote Item Id") '@49 moved up here
    If Not IsSuppressed(rs) Then '@48, @26 check if the whole system is suppressed
        Set bk = rng.Document.Bookmarks.Add(cTempBookmarkName, rng) '@29
        retval = EmitSystemHeader(rs, rng, intRecord)
        Set tbl = CreateTable(rng) ' Create the table.
        retval = retval And GenerateTechSpecsForSystemWithRelevancy(rs, tbl, RootSystemId, "R")
        retval = retval And GenerateTechSpecsForSystemWithRelevancy(rs, tbl, RootSystemId, "A") '@47
        retval = retval And GenerateTechSpecsForSystemWithRelevancy(rs, tbl, RootSystemId, "O")
        If tbl.Rows.Count > 1 Then ' We got data! @29 Lot's of changes.
            retval = retval And FormatTable(tbl)
            SetNextPosition tbl, rng
            Added = True
        Else ' no data - back up and erase any header we had created
            rng.Parent.Range(bk.start, tbl.Range.End).Delete
        End If
        bk.Delete '@29
    End If
    If Not Added Then
        Dim objSystemEmitter As New clsSystemEmitter '@48
        retval = retval And objSystemEmitter.RemoveSeeEndMessages(rng.Parent, RootSystemId) '@48
    End If
    GenerateTechSpecsForSystem = retval '@49 moved down here
    Exit Function
    
GenerateTechSpecsForSystem_Error:
    LogMessage 1, "modXlatTechSpecs::GenerateTechSpecsForSystem"
    Resume Next
End Function

Private Function GenerateTechSpecsForSystemWithRelevancy( _
            ByRef rs As ADODB.Recordset, _
            ByRef tbl As Word.Table, _
            ByRef RootSystemId As String, _
            ByRef Relevancy As String _
        ) As Boolean
    On Error GoTo GenerateTechSpecsForSystemWithRelevancy_Error
    Dim retval As Boolean
    Dim objRSFilter As New clsRecordsetFilter
    
    objRSFilter.SetFilter rs, _
            "[Root Quote Item Id]='" & RootSystemId & "' AND Rel='" & Relevancy & "'"
        Do While Not rs.EOF
            Select Case FieldValue(rs, "Position Code")
                Case "PS", "PL"
                    If Not IsSuppressed(rs) Then '@26
                        retval = retval And EmitProduct(rs, tbl, Relevancy)
                    End If
            End Select
            rs.MoveNext
        Loop
    objRSFilter.RestoreFilter
    GenerateTechSpecsForSystemWithRelevancy = retval
    Exit Function
    
GenerateTechSpecsForSystemWithRelevancy_Error:
    LogMessage 1, "modXlatTechSpecs::GenerateTechSpecsForSystemWithRelevancy"
    Resume Next
End Function

Private Function IsSuppressed(rs As ADODB.Recordset) As Boolean '@26
    IsSuppressed = True
    If FieldValue(rs, "Suppress Print") = "Y" Then Exit Function
    If FieldValue(rs, "E-Text Print") = "Y" Then Exit Function
    If FieldValue(rs, "Local No Print Flag") = "Y" Then Exit Function '@41
    IsSuppressed = False
End Function

Private Function EmitTechSpecsHeader(rng As Word.Range) As Boolean  '@28
    On Error GoTo EmitTechSpecsHeader_Error
    Dim retval As Boolean
    Dim s As String
    With rng
        ' Start a new page, add the TOC entry, and display the header.
        '@37 .InsertBreak Type:=wdPageBreak
        s = "Detailed Technical Specifications"
        AddTOCEntry rng, s
        .InsertAfter s & vbCrLf '@39
        With .Font ' YYY make a style
            .Name = "Arial": .Size = 16: .Bold = True
        End With
        .ParagraphFormat.Alignment = wdAlignParagraphCenter '@39
        .Collapse Direction:=wdCollapseEnd
        .InsertParagraph '@39
        .Font.Size = 8 ' YYY make a style
        .Collapse Direction:=wdCollapseEnd
    End With ' rng
    EmitTechSpecsHeader = True
    Exit Function
    
EmitTechSpecsHeader_Error:
    LogMessage 1, "modXlatTechSpecs::EmitTechSpecsHeader"
    Resume Next
End Function

Private Function EmitSystemHeader( _
            rs As ADODB.Recordset, _
            rng As Word.Range, _
            intRecord As Integer _
        ) As Boolean
    On Error GoTo EmitSystemHeader_Error
    Dim retval As Boolean
    Dim strOptAlt As String
    With rng
        '@37 If this is not the first system, start a new page.
        '@37 If SystemsAdded Then '@29
        '@37     .InsertBreak Type:=wdPageBreak
        '@37 End If
        ' Display system number, name, and relevancy.
        Select Case UCase(FieldValue(rs, "Rel"))
            Case "O"
                strOptAlt = " - Optional"
            Case "A"
                strOptAlt = " - Alternate" '@34
        End Select
'@40    .InsertAfter "System #" & intRecord & ": " & FieldValue(rs, "Description") & strOptAlt
        '@39 The horizontal line code is very sensitive. It's all designed to make sure
        ' it behaves the same whether at the very top of a page or down some.
        .InlineShapes.AddHorizontalLineStandard
        If Asc(.Parent.Range(.start, .start + 1).Text) = 13 Then .Delete
        .start = .start + 1
        .InlineShapes.AddHorizontalLineStandard
        .start = .start + 1
        .InsertAfter FieldValue(rs, "Description") & strOptAlt
        With .Font ' YYY make a style
            .Name = "Arial": .Size = 12: .Bold = True
        End With
        With .ParagraphFormat
            .SpaceBefore = 6
            .Alignment = wdAlignParagraphCenter
        End With
        .Collapse Direction:=wdCollapseEnd
        .start = .End + 2
        .InsertParagraph
        .ParagraphFormat.KeepWithNext = True
        .Font.Size = 8 ' YYY make a style
        .Collapse Direction:=wdCollapseEnd
    End With ' rng
    EmitSystemHeader = retval
    Exit Function
    
EmitSystemHeader_Error:
    LogMessage 1, "modXlatTechSpecs::EmitSystemHeader"
    Resume Next
End Function

Private Function CreateTable(rng As Word.Range) As Word.Table
    Dim objTextTable As New clsTextTable
    With objTextTable
'@30        .AddCell "Part No." '@25 added
'@30        .AddCell "Product"  '@25 used to be "Deliverables"
        .AddCell "Part No. / Product" '@30
        .AddCell "Description"
        .EndOfRow
        Set CreateTable = .ConvertToTable(rng:=rng, Borders:=True)  '@31 borders back, @25 no borders
    End With
End Function

Private Function EmitProduct( _
            rs As ADODB.Recordset, _
            tbl As Word.Table, _
            Relevancy As String _
        ) As Boolean
    On Error GoTo EmitProduct_Error
    Dim retval As Boolean
    Dim strOptAltText As String
    retval = True
    tbl.Rows.Add
    AddPartNumber tbl, tbl.Rows.Count, FieldValue(rs, "Product") '@25
    AddDeliverable tbl, tbl.Rows.Count, FieldValue(rs, "Description")
    strOptAltText = RelevancyString(Relevancy)
    If LenB(strOptAltText) <> 0 Then
        AddOptAltText tbl, tbl.Rows.Count, strOptAltText
    End If
    retval = retval And AddEText(tbl, tbl.Rows.Count, FieldValue(rs, "Path"))
    EmitProduct = retval
    Exit Function
    
EmitProduct_Error:
    LogMessage 1, "modXlatTechSpecs::EmitProduct"
    Resume Next
End Function

Private Sub AddPartNumber(tbl As Word.Table, ByVal Row As Integer, PartNumber As String) '@25
    SetTableText tbl, Row, gcPartNumber, PartNumber
End Sub

Private Sub AddDeliverable(tbl As Word.Table, ByVal Row As Integer, Deliverable As String)
'@30    SetTableText tbl, Row, gcDeliverable, Deliverable
    tbl.Cell(Row, gcDeliverable).Range.InsertAfter vbCrLf & Deliverable
End Sub

Private Function RelevancyString(ByVal Relevancy As String) As String
    Select Case UCase(Relevancy)
        Case "O": RelevancyString = cstrOptional
        Case "A": RelevancyString = cstrAlternative
        Case "R": RelevancyString = vbNullString
    End Select
End Function

Private Sub AddOptAltText(tbl As Word.Table, ByVal Row As Integer, OptAltText As String)
    tbl.Cell(Row, gcDeliverable).Range.InsertAfter vbCrLf & OptAltText
End Sub

'@ STB try to use it from Share_GB setTecSpec
Public Function AddEText( _
            tbl As Word.Table, _
            ByVal Row As Integer, _
            ByVal ETextPath As String _
        ) As Boolean

    Dim strSAFFileName As String, strRTFFullPath As String
    On Error GoTo AddEText_Error

    AddEText = True
    strSAFFileName = UCase(ETextPath)
    If Right$(strSAFFileName, 4) <> ".SAF" Then
        SetTableText tbl, Row, gcEText, "Error: " & strSAFFileName
        LogMessage 2, "modXlat6Glossary::AddEText: Bad E-Text Path Value = " & strSAFFileName
        AddEText = False
        Exit Function
    End If
    If Right$(strSAFFileName, 11) = "S_LIT__.SAF" Then ' skip this special value
    '> 20090417 STB
        'tbl.Rows(Row).Delete '@22 delete the row @50 STB we want it
    '< 20090417 STB
        Exit Function
    End If
    If LenB(strSAFFileName) <> 0 Then
        strRTFFullPath = GetRTFFile(strSAFFileName)
        If LenB(strRTFFullPath) = 0 Then
            SetTableText tbl, Row, gcEText, "Unable to generate or import RTF for " & strSAFFileName
            LogMessage 2, "modXlat6Glossary::AddEText: Can't get E-Text for " & strSAFFileName
            AddEText = False
            Exit Function
        End If
        ' Careful - don't use a With statement here --
        ' it gets messed up because the Range changes.
        tbl.Cell(Row, gcEText).Range.InsertFile FileName:=strRTFFullPath, _
                Range:="", ConfirmConversions:=False, Link:=False, Attachment:=False '@16
        ' Delete trailing vbCr if it exists - this code works in a very
        ' specific way so as not to disturb the formatting. Be very careful
        ' if you mess with it.
#If False Then '@45
        With tbl.Cell(Row, gcEText).Range '@16
            If Asc(Right(.Text, 3)) = Asc(vbCr) Then
                .Parent.Range(.End - 2, .End - 2).InsertParagraph
                .Parent.Range(.End - 3, .End - 1).Delete
            End If
        End With
#End If '@45
    End If
    ' xxx delete or leave blank?
    If Not AnyAlphaChars(GetTableText(tbl, Row, gcEText)) Then
        tbl.Rows(Row).Delete
    End If
    Exit Function

AddEText_Error:
    LogMessage 1, "modXlatTechSpecs::AddEText"
    Resume Next
End Function

' Find the RTF file if it already exists, or decompress it.
' Return the full path to the RTF file, or vbNullString on error.
'@14 - allow for full UNC path names to be passed in.
Public Function GetRTFFile(ByVal SAFFileNameGiven As String) As String
    Dim ComputerName        As String  '@07
    Dim blnFullPathProvided As Boolean '@14
    Static FileSystem       As String  '@36 made Static
    Dim strSAFFileName      As String
    Dim strSAFFullPath      As String
    Dim RTFDir              As String
    Dim strRTFFullPath      As String
    If Left$(SAFFileNameGiven, 2) = "\\" Then
        blnFullPathProvided = True
    ElseIf Mid$(SAFFileNameGiven, 2, 1) = ":" Then
        blnFullPathProvided = True
    End If
    ' If we were given a full path, get just the filename.
    If blnFullPathProvided Then '@14
        Dim iPosLastBackslash As Integer '@36
        iPosLastBackslash = InStrRev(SAFFileNameGiven, "\")
        strSAFFileName = Mid$(SAFFileNameGiven, iPosLastBackslash + 1)
    Else
        strSAFFileName = SAFFileNameGiven
    End If
    ' Now we have a SAF filename (not necessarily a full path yet).
    ' ComputerName is used both to generate the RTF location (and also
    ' to locate the FileSystem later if necessary).
    ComputerName = UCase$(Environ$("COMPUTERNAME")) '@07
    ' Determine RTFDir on this machine.
    RTFDir = "\\" & ComputerName & "\proposalreformatter\rtf" ' @05
    ' Determine target RTF fullpath based on RTFDir and SAFFileName.
    strRTFFullPath = RTFDir & "\" & Replace(strSAFFileName, ".SAF", ".RTF")
    ' If the target RTF already exists, use it, and get out of here, quick,
    ' before all the action starts!
    If LenB(Dir(strRTFFullPath)) <> 0 Then ' RTF already exists
        GetRTFFile = strRTFFullPath
        Exit Function
    End If
    ' OK, the RTF file is not here yet. We have to uncompress the SAF file.
    ' First, let's see if we need to determine the file system by checking our
    ' Static variable, meaning, have we already done this?
    If LenB(FileSystem) = 0 Then
        ' OK, we haven't already determined where the file system is yet.
        ' If we were given a full path, then check it out below.
        If blnFullPathProvided Then
            ' If we were given a path on a drive, just use it.
            If Mid$(SAFFileNameGiven, 2, 1) = ":" Then
                strSAFFullPath = SAFFileNameGiven
            Else
                ' if we were given a UNC path, make sure it's reachable
                ' or find the local file system.
                FileSystem = Left$(SAFFileNameGiven, iPosLastBackslash - 1)
                CheckFileSystem FileSystem
                ' We'll calculate strSAFFullPath below, now that we have the file system.
            End If
        Else
            ' If we were provided just a file name (not a full path), then
            ' do some fancy footwork to find the file system.
            'vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
            'v PUT CORRESPONDENCES BETWEEN DOC SERVERS AND FILESYSTEMS FOR  v
            'v ENVIRONMENTS WITH SEPARATE FILESYSTEMS, MULTIPLE DOC SERVERS v
            'v OR NON-STANDARD FILESYSTEM SHARE NAMES HERE!!!               v
            'v This code is probably never used, because as of @14,         v
            'v we always receive full paths.                                v
            'vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
            If ComputerName = "MLVV1BAA" Or _
               ComputerName = "MLVV1BBA" Then
                FileSystem = "\\mlvv14ma\momfs\att" ' @07
            ElseIf ComputerName = "MLVV2G0A" Or _
                   ComputerName = "MLVV2G1A" Then '@06
                FileSystem = "\\mlvv2g1a\siebfile\att" ' @05
            Else
                FileSystem = "\\" & ComputerName & "\siebfile\att" ' @05
            End If
            ' We'll calculate strSAFFullPath below, now that we have the file system.
        End If
    End If
    ' Now we have FileSystem, so build the full path.
    If LenB(strSAFFullPath) = 0 Then
        strSAFFullPath = FileSystem & "\" & strSAFFileName
    End If
    ' Now we have strSAFFullPath.
    ' We want to uncompress the SAF into the RTF.
    ' First, ensure the SAF file exists. If not, we'll just return
    ' an empty string, which signals that we were unsuccessful.
    If LenB(Dir(strSAFFullPath)) <> 0 Then ' if .saf exists, then uncompress
        ' If we can indeed find the SAF file, then try to uncompress it
        ' and return its fullpath if successful. If not, we'll be returning empty.
        If UncompressSAF(strSAFFullPath, strRTFFullPath) Then
            GetRTFFile = strRTFFullPath
        End If
    End If
End Function

' Return True on success.
Public Function UncompressSAF( _
            ByVal SourceFullPath As String, _
            ByVal TargetFullPath As String _
        ) As Boolean
    Dim UncompressProg As String
    Dim ExecString As String
    Dim retval As Boolean
    UncompressProg = "\\" & Environ$("COMPUTERNAME") & "\proposalreformatter\BIN\SSEUNZIP.EXE" ' @05
    ExecString = "CMD /C " & UncompressProg & " " & _
                 SourceFullPath & " " & TargetFullPath
    retval = ExecAndWait(ExecString)
    If retval Then retval = CBool(LenB(Dir(TargetFullPath)) <> 0)
    UncompressSAF = retval
End Function

Private Function FormatTable(tbl As Word.Table) As Boolean
#If False Then
    .Range.Font.Size = 7
    .Range.Font.Name = "Arial"
    With .Range.Font
        .Name = "Arial"
        .Color = wdColorAutomatic
    End With
#End If
    
    FormatPartNumberColumn tbl '@25
    FormatDeliverablesColumn tbl
    FormatETextColumn tbl
    FormatHeaderRow tbl
    FormatMainTable tbl
    Selection.Collapse
    FormatTable = True
End Function

' YYY change to a Style
Private Sub FormatPartNumberColumn(tbl As Word.Table) '@25
    tbl.Columns(gcPartNumber).Select
    With Selection.Font
        .Name = "Arial"
        .Size = 9
        .Bold = True
    End With
End Sub

' YYY change to a Style
Private Sub FormatDeliverablesColumn(tbl As Word.Table)
    tbl.Columns(gcDeliverable).Select
    With Selection.Font
        .Name = "Arial"
        .Size = 9
        .Bold = True
    End With
    FormatRelevancyStrings
End Sub

Private Sub FormatRelevancyStrings()
    FormatExtraText cstrOptional, cblnOptAltBoldFlag, cblnOptAltItalicFlag '@30
    FormatExtraText cstrAlternative, cblnOptAltBoldFlag, cblnOptAltItalicFlag '@30
End Sub

'@30 Private Sub FormatOptAltText(ByVal OptAltText As String)
Private Sub FormatExtraText( _
            ByVal ExtraText As String, _
            ByVal Bold As Boolean, _
            ByVal Italic As Boolean _
        )
    With Selection.Find
        .ClearFormatting
        .Replacement.ClearFormatting
        .Text = ExtraText '@30 OptAltText
        .Replacement.Text = ""
        .Replacement.Font.Bold = Bold '@30 False
        .Replacement.Font.Italic = Italic '@30 True
        .Forward = True
        .Wrap = wdFindStop
        .Format = True
        .MatchCase = True
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        .Execute Replace:=wdReplaceAll
    End With
End Sub

Private Sub FormatETextColumn(tbl As Word.Table)
    Dim r As Integer
    tbl.Columns(gcEText).Select
    With Selection.Font
        .Size = 8
    End With
    For r = 2 To tbl.Rows.Count
        AdjustLeftAndRightIndents tbl.Cell(r, gcEText).Range
    Next r
End Sub

Private Sub FormatHeaderRow(tbl As Word.Table)
    With tbl
        With .Rows(1)
            .HeadingFormat = True '@13
            With .Range
                .ParagraphFormat.Alignment = wdAlignParagraphLeft '@25 was Center
                With .Font
                    .Name = "Arial"
                    .Size = 11
                    .Bold = True
                End With ' .Font
            End With ' .Range
        End With ' .Rows(1)
    End With ' tbl
End Sub

Private Sub FormatMainTable(tbl As Word.Table)
    With tbl
        .TopPadding = InchesToPoints(0.08)  '@44 was 0.1 '@25 was 0
        .BottomPadding = 0                  '@46 was 0.08 '@44 was 0
        .LeftPadding = InchesToPoints(0.08)
        .RightPadding = InchesToPoints(0.08)
        .PreferredWidthType = wdPreferredWidthPercent
        .PreferredWidth = 100
        .Columns(gcPartNumber).Width = 104.4 ' InchesToPoints(1)  '@25
        '.Columns(gcDeliverable).Width = InchesToPoints(2) '@10
        .Columns(gcEText).Width = 418.3 ' InchesToPoints(4.28)    '@10, @25 was 5.28
        .Rows.AllowBreakAcrossPages = True '@17
        .Range.Cells.VerticalAlignment = wdCellAlignVerticalTop '@25 was Center
    End With ' tbl
End Sub

Private Sub AdjustLeftAndRightIndents(rng As Range)
    Dim least As Single
    GetLeftIndentInfoAndSetRightIndent rng, least
    If least <> 0 Then '@42
        OffsetLeftIndents rng, least
    End If
End Sub

Private Sub GetLeftIndentInfoAndSetRightIndent(ByRef rng As Word.Range, ByRef least As Single)
    Dim p As Word.Paragraph, LeftIndent As Single, FirstLineIndent As Single '@45
    least = 99999
    For Each p In rng.Paragraphs
        With p
            .RightIndent = 0 '@42
            LeftIndent = .LeftIndent
            FirstLineIndent = .FirstLineIndent
            If FirstLineIndent < 0 Then LeftIndent = LeftIndent + FirstLineIndent
' This causes problems with 2nd level bullets. '@45
'@45        If LeftIndent <> 0 Then '@45
                If LeftIndent < least Then
                    If .Range.Characters.Count > 1 Then
                        least = LeftIndent
                    End If
                End If
'@45         End If '@45
        End With 'p
    Next p
'    if least = 99999 then least = 0 '@45
End Sub

Private Sub OffsetLeftIndents(ByRef rng As Word.Range, ByRef Offset As Single)
    Dim p As Word.Paragraph, LeftIndent As Single
    For Each p In rng.Paragraphs
        With p
            LeftIndent = .LeftIndent
            If .FirstLineIndent < 0 Then LeftIndent = LeftIndent + .FirstLineIndent '@45
            If LeftIndent <> 0 Then
                .LeftIndent = .LeftIndent - Offset
            End If
        End With
    Next p
End Sub

Private Sub SetNextPosition(tbl As Word.Table, rng As Word.Range)
    ' Set up rng for the next system.
    Set rng = tbl.Range
    With rng
        .Collapse Direction:=wdCollapseEnd
        .InsertParagraph
        .InsertBreak Type:=wdPageBreak '@37
        .Collapse Direction:=wdCollapseEnd
    End With ' rng
End Sub

Private Sub CreateContinuationMessages(doc As Word.Document, ByVal StartPage As Integer)  '@27, @30
    doc.Repaginate
    Selection.GoTo What:=wdGoToPage, Which:=wdGoToAbsolute, Count:=StartPage
    Do While Selection.Information(wdActiveEndPageNumber) < _
             Selection.Information(wdNumberOfPagesInDocument)
        Selection.GoTo What:=wdGoToPage, Which:=wdGoToNext
        If Selection.Information(wdWithInTable) Then
            If Selection.Information(wdStartOfRangeColumnNumber) = 1 Then
                ' We could be here if Column 1 wraps or if we just happen to start
                ' a new page in just the right place. The next line tells the difference.
                If Selection.start <> Selection.Cells(1).Range.start Then
                    MoveProductToNextPage '@38
                End If
            Else ' if we land on Column 2, then obviously it's a continuation.
                AddContinuation
            End If
        End If
    Loop
    ' Clean up the bookmark for AddContinuation.
    ' Slightly faster execution time if we just delete it once here
    ' instead of having AddContinuation delete it each time after it creates it.
    '@30 We will use the presence of the bookmark as a flag to indicate we did have continuations.
    If doc.Bookmarks.Exists("bk") Then
        doc.Bookmarks("bk").Delete
        Selection.GoTo What:=wdGoToPage, Which:=wdGoToAbsolute, Count:=StartPage
        doc.Range(Selection.start, doc.Range.End).Select
        FormatExtraText cstrContinued, cblnContinuedBoldFlag, cblnContinuedItalicFlag '@30
    End If
End Sub

Private Sub MoveProductToNextPage() '@38
    ' Split the table.
    Dim tbl1 As Word.Table, tbl2 As Word.Table
    Dim bk As Word.Bookmark
    Set bk = Selection.Bookmarks.Add("bk")
    Selection.SplitTable
    Set tbl1 = Selection.Tables(1) ' this seems to go one back
    Set tbl2 = bk.Range.Tables(1)
    Selection.InsertBreak Type:=wdPageBreak
    tbl1.Rows(1).Range.Copy ' copy the heading row
    tbl2.Range.Paste
    tbl2.Cell(1, gcPartNumber).Range.Select ' Put our cursor in the right place for the next loop.
End Sub

Private Sub AddContinuation() '@27, @43
    
    Dim lt As ListTemplate
    Dim blnStartOfParagraph As Boolean
    Dim LeftIndent As Single, FirstLineIndent As Single
    
    ' Move up two lines. We were having some overflow from the previous page sometimes.
    ' Count:=2 was not working; needed separate calls.
    Selection.MoveUp Unit:=wdLine, Count:=1
    Selection.MoveUp Unit:=wdLine, Count:=1
    Selection.HomeKey Unit:=wdLine
    TakeFormattingSnapshot blnStartOfParagraph, lt, LeftIndent, FirstLineIndent
    
    ' Store the point where it wraps.
    Dim bk As Word.Bookmark
    Set bk = Selection.Bookmarks.Add("bk")
    
    ' Split the table.
    Selection.SplitTable
    Dim tbl1 As Word.Table, tbl2 As Word.Table
    Set tbl1 = Selection.Tables(1) ' this seems to go one back
    Set tbl2 = bk.Range.Tables(1)
    
    With tbl1.Rows.Add
        .Range.Style = "Normal"
        .HeadingFormat = False
    End With
    tbl2.Cell(1, gcPartNumber).Range.Copy
    tbl1.Cell(tbl1.Rows.Count, gcPartNumber).Range.Paste
    Selection.Range.Parent.Range(tbl2.Cell(1, gcEText).Range.start, bk.Range.End).Cut
    tbl1.Cell(tbl1.Rows.Count, gcEText).Range.Paste
    
    FixUpFormatting tbl1, bk, blnStartOfParagraph, lt, LeftIndent, FirstLineIndent
    
    If Left$(GetTableText(tbl2, 1, gcPartNumber), cintLenContinued) <> cstrContinued Then '@30
        tbl2.Cell(1, gcPartNumber).Range.InsertBefore cstrContinued & vbCrLf '@32
    End If
    tbl1.Rows(1).Range.Copy ' copy the heading row
    tbl2.Range.Paste
    tbl2.Cell(1, gcPartNumber).Range.Select ' Put our cursor in the right place for the next loop.

End Sub

Private Sub TakeFormattingSnapshot(blnStartOfParagraph As Boolean, lt As ListTemplate, LeftIndent As Single, FirstLineIndent As Single) '@43
    blnStartOfParagraph = CBool(Selection.start = Selection.Paragraphs(1).Range.start)
    Set lt = Selection.Range.ListFormat.ListTemplate
    LeftIndent = Selection.ParagraphFormat.LeftIndent
    FirstLineIndent = Selection.ParagraphFormat.FirstLineIndent
End Sub

Private Sub FixUpFormatting(tbl1 As Table, bk As Bookmark, blnStartOfParagraph As Boolean, lt As ListTemplate, LeftIndent As Single, FirstLineIndent As Single) '@43
    If Not blnStartOfParagraph Then
        Dim rng1 As Range
        tbl1.Cell(tbl1.Rows.Count, gcEText).Select
        Selection.EndKey
        Selection.HomeKey wdLine
        Set rng1 = Selection.Range
        If lt Is Nothing Then
            rng1.ParagraphFormat.LeftIndent = LeftIndent
        Else
            rng1.ListFormat.ApplyListTemplate lt
            rng1.ParagraphFormat.LeftIndent = LeftIndent
            rng1.ParagraphFormat.FirstLineIndent = FirstLineIndent
            bk.Range.ListFormat.RemoveNumbers
            bk.Range.ParagraphFormat.LeftIndent = LeftIndent
        End If
    End If
End Sub
Attribute VB_Name = "modXlat5TOC"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modXlatTOC
' Creation:     2008/06/10
' Modifications:
'   2008/06/10  DAH Created this module.
'   2008/07/11  DAH @01 Warranty TOC no longer needs tweaking.
'                   @02 Remove a final PageBreak that may occur after T&C or Warranty.
'   2008/07/31  DAH @03 Removed call to doc.Repaginate so we don't mess up Tech Specs.
'-----------------------------------------------------------------------------

Option Explicit

Public Function TweakTOC(doc As Word.Document) As Boolean
    Dim retval As Boolean
    '@01 retval = MoveWarrantyTCCode(doc)
    retval = True '@02
    Call RemoveFinalPageBreak(doc) '@02
    doc.Styles("TOC 1").Font.Size = 10
    If doc.TablesOfContents.Count <> 0 Then
        doc.TablesOfContents(1).Update
    End If
    TweakTOC = retval
End Function

#If False Then '@01
Private Function MoveWarrantyTCCode(doc As Word.Document) As Boolean
    Dim f As Word.Field
    MoveWarrantyTCCode = True
    Set f = FindWarrantyTCCode(doc)
    If f Is Nothing Then Exit Function
    f.Select
    f.Cut
    Selection.GoToNext What:=wdGoToPage
    Selection.Paste
End Function

Private Function FindWarrantyTCCode(doc As Word.Document) As Word.Field
    Dim f As Word.Field
    For Each f In doc.Fields
        If LCase$(Left$(TOCFieldValue(f), 7)) = "warrant" Then
            Set FindWarrantyTCCode = f
            Exit Function
        End If
    Next f
End Function

Private Function TOCFieldValue(f As Word.Field) As String
    TOCFieldValue = Mid$(f.Code.Text, 6, Len(f.Code.Text) - 7)
End Function
#End If '@01

' Remove a trailing PageBreak if the last page has no printable data on it.
' Remember there may be field codes at the end.
' Return True if we removed a PageBreak.
Private Function RemoveFinalPageBreak(doc As Word.Document) As Boolean '@02
    Dim rng As Word.Range
    ' Turn off the display of Field Codes.
    ActiveWindow.View.ShowFieldCodes = False
'@03doc.Repaginate
    ' Go to the top of the last page.
    Set rng = doc.GoTo(What:=wdGoToPage, Which:=wdGoToAbsolute, Count:=doc.Range.Information(wdNumberOfPagesInDocument))
    With rng
        ' Search for any printable characters.
        .Find.Execute FindText:="[! ^l^m^n^s^t^0013]", MatchWildcards:=True, Forward:=True
        ' If found, then we're good, and abort.
        If .Find.Found Then Exit Function
    End With
    ' Otherwise, find the page break above the top of the page and get rid of it.
    Set rng = doc.GoTo(What:=wdGoToPage, Which:=wdGoToAbsolute, Count:=doc.Range.Information(wdNumberOfPagesInDocument))
    With rng
        .start = .start - 1
        .Collapse Direction:=wdCollapseStart
        .Delete
    End With 'rng
    RemoveFinalPageBreak = True
End Function

Attribute VB_Name = "modXlatQuoteNotes"
'-----------------------------------------------------------------------------
' Application:  Siebel Proposal Generator Translation Application
' Client:       Siemens Medical Systems, Malvern, PA, USA
' Developer:    Soundside Inc. Bayville, NY
' Author:       David Horowitz
' Purpose:      Translate "raw" Word documents as generated by
'               Siebel Proposal Generator into customer's desired format.
' Assumptions:  All data needed is present in the document.
' Module:       modXlatQuoteNotes
' Creation:     2007/05/30
' Modifications:
'   2008/05/30  DAH Created this module.
'   2008/07/30  DAH @01 If no Quote Notes, don't log an error.
'   2008/08/22  DAH @02 MultiModality
'-----------------------------------------------------------------------------

Option Explicit

' Take tbl as the source, massage the data and stick it at bookmark "QuoteNotes".
' 2008/10/31 STB for this we need information about the uk layout, at the moment i deactivate it
Public Function TranslateQuoteNotes(tbl As Table) As Boolean
    Dim rng As Word.Range
    Dim r As Integer
' STB deactivate this function
If tbl Is Nothing Then
    TranslateQuoteNotes = True
    Exit Function
End If

    With tbl
        ' Perform table translation
        ReplaceNonBreakingSpaces .Range
        ReplaceLineBreaks .Range
        If TweakTable(tbl) = 0 Then '@02
            TranslateQuoteNotes = True
            Exit Function ' no Quote Notes - get out!
        End If
        'xxx sorting is not being done - hopefully any sorting is being done before we get the data
        ' YYY style
        .Range.Font.Size = 10 ' xxx is that the right size?
        .Range.Font.Name = "Arial"
        Set rng = .ConvertToText(vbCrLf)
    End With ' tbl
    MoveRange rng, "QuoteNotes"
    With rng
'xxx        .ParagraphFormat.Alignment = wdAlignParagraphJustify
        .start = .End + 1
    End With ' rng
    TranslateQuoteNotes = True
End Function

' Return True if the Range was moved, False if not.
Public Function MoveRange(rng As Word.Range, BookmarkName As String) As Boolean
    If rng.Parent.Bookmarks.Exists(BookmarkName) Then
        rng.Cut
        Set rng = rng.Parent.Bookmarks(BookmarkName).Range
        rng.Paste
        MoveRange = True
    End If
End Function

' Give us the Table, we'll manipulate it and get it all ready for conversion to text.
' We will return the number of rows remaining in the table. If the number of rows remaining is 0,
' any further use of tbl will yield a 5825 Object Deleted Run-Time Error, so PLEASE be sure
' to check the return value.
Private Function TweakTable(tbl As Word.Table) As Integer '@02
    On Error GoTo Error ' if we hit an error, assume it's because the table is all deleted
    Dim r As Integer
    With tbl
        r = 1
        Do While r <= .Rows.Count
            If GetTableText(tbl, r, 1) = "Quote Nr" Then ' start of new quote
                If r + 2 <= .Rows.Count And LenB(GetTableText(tbl, r + 2, 1)) <> 0 Then ' there is data here
                    SetTableText tbl, r, 1, "Notes for Quote Nr " & _
                            GetTableText(tbl, r + 1, 1) & ":"
                    .Cell(r, 1).Range.Bold = True
                    .Rows(r + 1).Delete ' Quote Nr (the value)
                    .Rows(r + 1).Delete ' more labels
                    r = r + 1 ' skip to the next row, deleting cells in the first two columns below
                Else ' no data for this Quote
                    .Rows(r).Delete ' "Quote Nr" (the label)
                    .Rows(r).Delete '  Quote Nr  (the value)
                    If r < .Rows.Count Then .Rows(r).Delete ' the blank row (if not at end)
                    ' r stays the same
                End If
            Else
                ' delete SMS Sequence and Note Type
                ' leave a blank row though
                If .Rows(r).Cells.Count > 1 Then
                    .Cell(r, 1).Delete Shiftcells:=wdDeleteCellsShiftLeft
                    .Cell(r, 1).Delete Shiftcells:=wdDeleteCellsShiftLeft
                End If
                r = r + 1
            End If
        Loop
        TweakTable = .Rows.Count
    End With 'tbl
    Exit Function
Error:
    Err.Clear ' return 0 rows
End Function

Attribute VB_Name = "share_IL"
'@ GEM 2010-06-10 create the modul
'@ GEM 2010-06-21 corr
Option Explicit
Private pos_zahler As Integer
Private Items() As Item
Private mlv_r() As Item 'for sort Relevance
Private mlv_a() As Item
Private mlv_o() As Item
Private mlv_tx() As Item
Private r_zahler As Integer        'for sort Relevance
Private a_zahler As Integer
Private o_zahler As Integer
Private g As Integer    'intemszaehler
Private anz_Anl As Integer
Private anl1_Desc As String
Private nr As String
Private anlage_start As Boolean
Private aend_rel As Boolean
Private aend_wert As String
Private anlProduct As String
Private d_ok As Boolean
Private preis_druck_immer As Boolean
Const MYMODUL = "share_IL:"

Public Function TranslateDoc_IL(my_doc As Document) As Boolean
    Const MYMETHOD = "TranslateDoc_IL"
    Dim objSourceTables As New clsSourceTables
    Dim transl As New clsTextTable
    Dim FullName As String
    Dim retval As Boolean
    Dim dummy As String
    Dim mb As Range
    Dim mt As Table
    Dim mb_read As Range    'lese range
    Dim mb_write As Range   'schreibe range
    Dim ml As String
    Dim mb_seiten As Range   'schreibe range
    
    Dim l_datum As String
    d_ok = True
    
    On Error GoTo TranslateDoc_IL_Error
    dummy = ""
    anlage_start = True
    'Der Anfang von Allem
    LogMessage 3, "Begining... TranslateDoc_IL"
    'wenn keine Sprache dann ENS
    If ActiveDocument.Bookmarks.Exists("layout_language") = True Then
        ml = Left(UCase(ActiveDocument.Bookmarks("layout_language").Range.Text), 3)
    Else
        ml = "ENS"
    End If
    
'GEM 20101230 an der Stelle kommt FN und LN
'    'ReFormat PrintAdress for the right LineFeeds
'    Set mb = my_doc.Bookmarks("layout_print_address").Range
'    dummy = mb.Text
'    dummy = Replace(dummy, Chr(11), vbCr)
'    Call writeIntoBookmark("layout_print_address", dummy)
'    Set mb = Nothing
    
    'GEM 20100429 Datum immer Englisch
    l_datum = GetDatumFromCommonString(my_doc, my_doc.Bookmarks("layout_startdate").Range.Text, ml)
'    l_datum = GetDatumFromCommonString("03/05/2009", ml)
    If d_ok Then
'        Call writeIntoBookmark("print_date", l_datum)
'        Call writeIntoBookmark("print_date2", l_datum)
        Set mb_read = my_doc.Bookmarks("print_datum").Range
        Set mb_write = my_doc.Bookmarks("print_date").Range
        mb_read.Copy
        mb_write.Paste
        Set mb_write = my_doc.Bookmarks("print_date2").Range
        mb_read.Copy
        mb_write.Paste
    End If

'''        Call writeIntoBookmark("print_date", Format(Date, "dddd, d mmmm yyyy"))
'''        Call writeIntoBookmark("print_date", Format(Date, "dddd, d mmmm yyyy"))
''        Call writeIntoBookmark("print_date", Format(Date, "yyyy mmmm d ,dddd"))
''        Call writeIntoBookmark("print_date2", Format(Date, "yyyy mmmm d ,dddd"))

    If my_doc.Bookmarks.Exists("layout_quotetype") = True Then
        'LYG 20110107
        Set mb_read = my_doc.Bookmarks("layout_quotetype").Range
        Set mb_write = my_doc.Bookmarks("print_quotetype1").Range
        mb_read.Copy
        mb_write.Paste
        Set mb_write = my_doc.Bookmarks("print_quotetype2").Range
        mb_read.Copy
        mb_write.Paste
        Set mb_write = my_doc.Bookmarks("print_quotetype3").Range
        mb_read.Copy
        mb_write.Paste
        Set mb_write = my_doc.Bookmarks("print_quotetype4").Range
        mb_read.Copy
        mb_write.Paste
'        Call writeIntoBookmark("print_quotetype1", my_doc.Bookmarks("layout_quotetype").Range.Text)
'        Call writeIntoBookmark("print_quotetype2", my_doc.Bookmarks("layout_quotetype").Range.Text)
'        Call writeIntoBookmark("print_quotetype3", my_doc.Bookmarks("layout_quotetype").Range.Text)
'        Call writeIntoBookmark("print_quotetype4", my_doc.Bookmarks("layout_quotetype").Range.Text & " ")
    End If
    If my_doc.Bookmarks.Exists("layout_quotenumber") = True Then
        Call writeIntoBookmark("print_quotenumber1", " " & my_doc.Bookmarks("layout_quotenumber").Range.Text)
        Call writeIntoBookmark("print_quotenumber2", my_doc.Bookmarks("layout_quotenumber").Range.Text & " ")
        Call writeIntoBookmark("print_quotenumber3", my_doc.Bookmarks("layout_quotenumber").Range.Text & " ")
    End If
    If my_doc.Bookmarks.Exists("layout_opportunityname") = True Then
        Call writeIntoBookmark("print_opportunityname1", my_doc.Bookmarks("layout_opportunityname").Range.Text)
        Call writeIntoBookmark("print_opportunityname2", my_doc.Bookmarks("layout_opportunityname").Range.Text)
'        Call writeIntoBookmark("print_opportunityname3", my_doc.Bookmarks("layout_opportunityname").Range.Text & " ")
'        Call writeIntoBookmark("print_opportunityname4", my_doc.Bookmarks("layout_opportunityname").Range.Text)
        Call writeIntoBookmark("print_opportunityname5", my_doc.Bookmarks("layout_opportunityname").Range.Text)
        Call writeIntoBookmark("print_opportunityname6", my_doc.Bookmarks("layout_opportunityname").Range.Text)
    End If
    If my_doc.Bookmarks.Exists("layout_name") = True Then
        Call writeIntoBookmark("print_name1", my_doc.Bookmarks("layout_name").Range.Text)
    End If
    
    'first make a save of the document
    retval = True
    Set objSourceTables.Document = my_doc
    With objSourceTables
        If Application.Visible Then System.Cursor = wdCursorWait '@21
''        If LCase(my_doc.Name) <> "lastproposal.doc" Then '@24, @37
''            FullName = my_doc.FullName
''            my_doc.SaveAs FileName:=TempFilePath & "LastProposal.doc", AddToRecentFiles:=False
''            my_doc.SaveAs FileName:=FullName, AddToRecentFiles:=False
''        End If
        Set gobjFeatures.Document = my_doc

        'read write proposal notes
        If retval Then
            LogMessage 3, MYMODUL & MYMETHOD & "TranslateQuoteNotes..."
            retval = setProposalNotes(my_doc)
        End If

        'read write pos items
        If retval Then
            LogMessage 3, MYMODUL & MYMETHOD & "modShareInternational.generateItemsArray..."
            Items = modShareInternational.generateItemsArray(.Tables("tblDetailRecords"))
            ' write Quote Items
            LogMessage 3, MYMODUL & MYMETHOD & "share_IL.setItemsQuote..."
            retval = setItemsQuote(my_doc, Items())
        End If

        'read write TaC
        If retval Then
            LogMessage 3, MYMODUL & MYMETHOD & "TranslateTandCTable..."
            retval = setTC(my_doc)
        End If

        'LYG 20110107
        Set mt = my_doc.Bookmarks("layout_tab_quotetype").Range.Tables(1)
        Set mb = mt.Rows(3).Cells(2).Range 'Hier ist Tender auf Hebr|fffd|isch versteckt
        mb.SetRange mb.start, mb.End - 1
        'GEM 20101230 letzten 2 Seiten nicht drucken
        If ActiveDocument.Bookmarks.Exists("layout_quotetype") = True Then
'            If ActiveDocument.Bookmarks("layout_quotetype").Range.Text = ActiveDocument.Bookmarks("ges_quotetype1").Range.Text Or _
'                ActiveDocument.Bookmarks("layout_quotetype").Range.Text = ActiveDocument.Bookmarks("ges_quotetype2").Range.Text Then
            If ActiveDocument.Bookmarks("layout_quotetype").Range.Text <> mb.Text Then
'            If ActiveDocument.Bookmarks("layout_quotetype").Range.Text = "DEFAULT" Or _
'                ActiveDocument.Bookmarks("layout_quotetype").Range.Text = "Default" Then
                If ActiveDocument.Bookmarks.Exists("seiten_loeschen") = True Then
''                    Set mb_seiten = ActiveDocument.Bookmarks("seiten_loeschen").Range
''                    mb_seiten.SetRange start:=mb_seiten.start, End:=mb_seiten.End
''                    mb_seiten.Font.Hidden = True 'hier unsichtbar machen
                    ActiveDocument.Bookmarks("seiten_loeschen").Range.Delete 'GEM 20110224
                End If
            End If
        End If


        If Not Application.Visible Then
            If gobjFeatures.LockDocument Then '@67
                LogMessage 3, "Locking document..."
                retval = ProtectDocument(my_doc)
            End If
        End If

        If retval Then
            LogMessage 3, "Finishing up..."
        End If

        If Application.Visible Then System.Cursor = wdCursorNormal '@21
        If retval Then '@07
            MessageBox "Reformatting was completed successfully.", vbInformation + vbOKOnly, cAppName '@25
        Else
            MessageBox "An error occurred while reformatting.", vbExclamation + vbOKOnly, cAppName '@25
        End If

    End With

    TranslateDoc_IL = retval

    Exit Function

TranslateDoc_IL_Error:
    LogMessage 1, MYMODUL & MYMETHOD & " share_IL::TranslateDoc_IL"
    Resume Next
End Function

Private Function setItemsQuote(my_doc As Word.Document, Items() As Item)
    Const MYMETHOD = "setItemsQuote"
    setItemsQuote = False
    On Error GoTo setItemsQuote_Error
    Dim anl1_Product As String
    Dim anl2_Product As String
    Dim anl2_Rel As String
    Dim anl2 As Boolean
    Dim gr_Product As String
    Dim gr_Rel As String
    Dim gr As Boolean
    Dim rest As String
    Dim alt_SiebID As String
    Dim alt_rel As String
    Dim schreiben_TX As Boolean

    r_zahler = 0
    a_zahler = 0
    o_zahler = 0
    pos_zahler = 0
    anz_Anl = 0
    
    For g = 1 To UBound(Items)
        Select Case Items(g).PositionCode
        Case "AS"
            If (anl1_Product = "") Then
                anl1_Product = Items(g).Product 'Hier wird sich Ebene1 gemerkt
                anl1_Desc = Items(g).Description 'Hier wird sich Ebene1 gemerkt
                r_zahler = 0
                a_zahler = 0
                o_zahler = 0
                anz_Anl = anz_Anl + 1
                If anz_Anl > 1 Then
                    If Items(g).Relevance = "A" Or Items(g).Relevance = "O" Then
                        aend_rel = True
                        aend_wert = Items(g).Relevance
                    End If
                End If
                If anlage_start Then
                    Call writeIntoBookmark("print_anlage_start", Items(g).Description)
''                    Call writeIntoBookmark("print_anlage_start2", " " & Items(g).Description & " ")
''                    my_doc.Bookmarks("print_anlage_start2").Range.BoldBi = True
'''                    my_doc.Bookmarks("print_anlage_start").Range.Font.Size = 11
''                    Call writeIntoBookmark("print_anlage_start3", " " & Items(g).Description & " ")
                    anlage_start = False
                End If
            Else
                If anl2_Product = "" Then
                    anl2 = True
                    anl2_Rel = Items(g).Relevance
                    anl2_Product = Items(g).Product
                Else
                    anl2 = False
                End If
            End If
            alt_SiebID = Items(g).SiebelId
            
            If anl2 Or gr Then
            Else
                alt_rel = Items(g).Relevance
            End If
'            sortiere_pos Items(g).Relevance
            If aend_rel Then
                sortiere_pos aend_wert
            Else
                sortiere_pos Items(g).Relevance
            End If
        Case "PS", "TX", "PL"
            rest = Items(g).Relevance
            If schreiben_TX Then
                'sortiere nach R,A,O
                If UCase(rest) = "R" Then
                    r_zahler = r_zahler + 1
                    ReDim Preserve mlv_r(r_zahler)
                    mlv_r(r_zahler) = mlv_tx(1)
                ElseIf UCase(rest) = "A" Then
                    a_zahler = a_zahler + 1
                    ReDim Preserve mlv_a(a_zahler)
                    mlv_a(a_zahler) = mlv_tx(1)
                ElseIf UCase(rest) = "O" Then
                    o_zahler = o_zahler + 1
                    ReDim Preserve mlv_o(o_zahler)
                    mlv_o(o_zahler) = mlv_tx(1)
                Else
                'dann stimmt was nicht
                End If
                schreiben_TX = False
            End If
            If Items(g).PositionCode = "TX" Then
                If Items(g).ParentQuoteItemId = alt_SiebID Then
                    If anl2 Then
                        anl2_Rel = alt_rel
                    Else
                        If gr Then
                            gr_Rel = alt_rel
                        Else
                            rest = alt_rel
                        End If
                    End If
                Else
                    If Items(g).Relevance = "R" Or Items(g).Relevance = "A" Or Items(g).Relevance = "O" Then
                        If anl2 Then
                            anl2_Rel = alt_rel
                        Else
                            If gr Then
                                gr_Rel = alt_rel
                            Else
                                rest = alt_rel
                            End If
                        End If
                    Else
                    'hier die TX sich merken zum sp|fffd|terem einsortieren
                        schreiben_TX = True
                        ReDim Preserve mlv_tx(1)
                        mlv_tx(1) = Items(g)
                        rest = " "
                    End If
                End If
            End If
            If aend_rel Then
                sortiere_pos aend_wert
            Else
                If anl2 Then
                    sortiere_pos anl2_Rel
                Else
                    If gr Then
                        sortiere_pos gr_Rel
                    Else
                        sortiere_pos rest
                    End If
                End If
            End If
            alt_SiebID = Items(g).SiebelId
            If anl2 Or gr Then
            Else
                alt_rel = Items(g).Relevance
            End If
            'sortieren
        Case "GS"
            If (gr_Product = "") Then
                gr_Product = Items(g).SiebelId 'Hier wird sich Ebene1 gemerkt
                gr_Rel = Items(g).Relevance
                gr = True
'                sortiere_pos Items(g).Relevance
                If aend_rel Then
                    sortiere_pos aend_wert
                Else
                    sortiere_pos Items(g).Relevance
                End If
            Else
                If aend_rel Then
                    sortiere_pos aend_wert
                Else
                    If anl2 Then
                        sortiere_pos anl2_Rel
                    Else
                        sortiere_pos Items(g).Relevance
                    End If
                End If
            End If
            alt_SiebID = Items(g).SiebelId
            alt_rel = Items(g).Relevance
        Case "GE"
            If gr_Product = Items(g).ParentQuoteItemId Then
                'sortieren
                gr_Product = ""
                gr = False
                If aend_rel Then
                    sortiere_pos aend_wert
                Else
                    sortiere_pos gr_Rel
                End If
            Else
                If aend_rel Then
                    sortiere_pos aend_wert
                Else
                    sortiere_pos Items(g).Relevance
                End If
            End If
            alt_SiebID = Items(g).SiebelId
            alt_rel = Items(g).Relevance
        Case "AE"
            If anl1_Product = Items(g).Product Then
                If aend_rel Then
                    sortiere_pos aend_wert
                Else
                    sortiere_pos Items(g).Relevance
                End If
                anl1_Product = ""
                pos_zahler = 0
                If r_zahler > 0 Then write_table_items mlv_r, my_doc, mlv_r
                pos_zahler = 0
                preis_druck_immer = True
                If a_zahler > 0 Then write_table_items mlv_a, my_doc, mlv_r
                pos_zahler = 0
                If o_zahler > 0 Then write_table_items mlv_o, my_doc, mlv_r
                preis_druck_immer = False
                pos_zahler = 0
                If r_zahler > 0 Then setTecSpec mlv_r, my_doc
                pos_zahler = 0
                If a_zahler > 0 Then setTecSpec mlv_a, my_doc
                pos_zahler = 0
                If o_zahler > 0 Then setTecSpec mlv_o, my_doc
                If aend_rel Then
                    aend_rel = False
                End If
            Else
                'sortieren
                If anl2_Product = Items(g).Product Then
                    anl2 = False
                Else
                
                End If
                If aend_rel Then
                    sortiere_pos aend_wert
                Else
                    sortiere_pos anl2_Rel
                End If
            End If
            alt_SiebID = Items(g).SiebelId
            If anl2 Or gr Then
            Else
                alt_rel = Items(g).Relevance
            End If
        Case Else
        '
        End Select
    Next g
    
    setItemsQuote = True
    Exit Function
    
setItemsQuote_Error:
    LogMessage 1, MYMODUL & MYMETHOD & "share_IL::setItemsQuote_Error"
    Resume Next
End Function

Private Function sortiere_pos(rel As String)
    'sortiere nach R,A,O
    If UCase(rel) = "R" Then
        r_zahler = r_zahler + 1
        ReDim Preserve mlv_r(r_zahler)
        mlv_r(r_zahler) = Items(g)
    ElseIf UCase(rel) = "A" Then
        a_zahler = a_zahler + 1
        ReDim Preserve mlv_a(a_zahler)
        mlv_a(a_zahler) = Items(g)
    ElseIf UCase(rel) = "O" Then
        o_zahler = o_zahler + 1
        ReDim Preserve mlv_o(o_zahler)
        mlv_o(o_zahler) = Items(g)
    Else
    'dann stimmt was nicht
    End If
End Function

Private Function setProposalNotes(my_doc As Word.Document)
    Const MYMETHOD = "setProposalNotes"
    setProposalNotes = False
    On Error GoTo setProposalNotes_Error
    Dim mt_read As Table
    Dim mt_write As Table
    Dim mb As Range 'for formating text
    Dim my_Err As String
    Dim dummy As String
    Dim dummy_ph As String
    Dim i As Integer 'zahler
    my_Err = ":setProposalNotes_Not_exist"

    'change from Sequence to Proposal Nr
    For i = 3 To my_doc.Tables.Count
        If my_doc.Tables(i).Rows.Count > 3 Then
            If Len(my_doc.Tables(i).Rows(1).Cells(1).Range.Text) >= Len("Proposal Nr") Then
                If Left(my_doc.Tables(i).Rows(1).Cells(1).Range.Text, Len("Proposal Nr")) = "Proposal Nr" Then
                    Set mt_read = my_doc.Tables(i)
                    my_Err = ""
                End If
            End If
        End If
    Next i

    If my_Err <> "" Then
        setProposalNotes = True
        LogMessage 3, MYMODUL & MYMETHOD & "share_IL::setProposalNotes: " & my_Err
    Else
        mt_read.Rows(1).Delete
        mt_read.Rows(1).Delete
        mt_read.Rows(1).Delete
        For i = 1 To mt_read.Rows.Count
            dummy = mt_read.Rows(i).Cells(2).Range.Text
            Debug.Print dummy
            If Left(LCase(dummy), Len("your")) = "your" Then
                Call writeIntoBookmark("print_yr", mt_read.Rows(i).Cells(3).Range.Text)
            End If
        Next i
        mt_read.Delete
    End If

    setProposalNotes = True
    Exit Function
setProposalNotes_Error:
    LogMessage 1, MYMODUL & MYMETHOD & "share_IL::setProposalNotes_Error " & my_Err
    Resume Next

End Function

Private Function setTC(my_doc As Word.Document)
    Const MYMETHOD = "setTC"
    setTC = False
    On Error GoTo setTC_Error
    Dim mt_read As Table
    Dim mt_write As Table
    Dim mb As Range 'for formating text

    Dim i As Integer 'zahler
    Dim mystart As Integer 'zahler
    Dim pos_zahler As Integer
    Dim my_Err As String

    my_Err = ":setTC_Not_exist"

    For i = 3 To my_doc.Tables.Count
        If my_doc.Tables(i).Rows.Count > 3 Then
            If Left(my_doc.Tables(i).Rows(3).Cells(1).Range.Text, Len("Cond. ID")) = "Cond. ID" Then
                Set mt_read = my_doc.Tables(i)
                my_Err = ""
            End If
        End If
    Next i
    
    If my_Err <> "" Then
        setTC = True
        GoTo setTC_Error
    Else
        Set mt_write = my_doc.Bookmarks("print_tc").Range.Tables(1)
        mt_read.Rows(1).Delete
        mt_read.Rows(1).Delete
        mt_read.Rows(1).Delete
        For i = 1 To mt_read.Rows.Count
            If i <> 1 Then
                mt_write.Rows.Add
            End If
            pos_zahler = mt_write.Rows.Count
            mt_write.Rows(pos_zahler).Cells(1).Range.Text = mt_read.Rows(i).Cells(2).Range.Text
            mt_write.Rows(pos_zahler).Cells(1).Range.Bold = True
            mt_write.Rows(pos_zahler).Cells(1).Range.Underline = wdUnderlineSingle
            mt_write.Rows.Add
            pos_zahler = pos_zahler + 1
            
            mt_write.Rows(pos_zahler).Cells(1).Range.Text = mt_read.Rows(i).Cells(3).Range.Text
            mt_write.Rows(pos_zahler).Cells(1).Range.Bold = False
            mt_write.Rows(pos_zahler).Cells(1).Range.Underline = wdUnderlineNone
            ReplaceNonBreakingSpaces mt_write.Rows(pos_zahler).Cells(1).Range
            ReplaceLineBreaks mt_write.Rows(pos_zahler).Cells(1).Range
        Next i
        mt_read.Delete
    End If
    
    setTC = True
    Exit Function
setTC_Error:
    LogMessage 1, MYMODUL & MYMETHOD & "share_IL::setTC_Error"
    Resume Next
End Function

Private Sub write_table_items(PosList() As Item, doc As Word.Document, PosList2() As Item)
    Dim dummy As String 'for stingvalue
    Dim mlv As Item
    Dim mt As Table
    Dim z, i As Integer   'row count
    Dim AS_Mind 'remeinder for AS
    Dim my_d As Double
    Dim my_preis As CurrencyFormatter
    Set my_preis = New CurrencyFormatter
    
        
    Set mt = doc.Bookmarks("print_posliste").Range.Tables(1)
    
    If PosList(1).Relevance = "R" Then
        If anz_Anl > 1 Then
            doPageBreak doc, mt, "print_posliste", "R", PosList(1).Description
        Else
            writeIntoBookmark "print_as_desc", PosList(1).Description
        End If
    ElseIf PosList(1).Relevance = "A" Then
        doPageBreak doc, mt, "print_posliste", "A", PosList(1).Description
    ElseIf PosList(1).Relevance = "O" Then
        doPageBreak doc, mt, "print_posliste", "O", PosList(1).Description
    Else
        '...
    End If
    
    For i = 1 To UBound(PosList)
        mlv = PosList(i)
        
        If mlv.SuppressPrint <> True Then
            dummy = ""
            'AnlagenStart
            If mlv.PositionCode = "AS" Then
                If i <> 1 Then mt.Rows.Add
                If (anlProduct = "") Then
                    anlProduct = mlv.Product 'Hier wird sich Ebene1 gemerkt
                End If
                With mt.Rows(mt.Rows.Count).Cells(3)
                    .Range.Text = mlv.Description
                    If i = 1 Then
                        .Range.Style = "layout_AS"
                    Else
                        .Range.Style = "layout_position"
                    End If
                    .Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                    .Range.Font.Underline = wdUnderlineNone
                End With
                'write the first AS in AS_Mind for noprint AE when a new AS
                If AS_Mind = "" Then AS_Mind = mlv.Product
            End If
            'Position
            If mlv.PositionCode = "PS" Or mlv.PositionCode = "PL" Then
                pos_zahler = pos_zahler + 1
                'GEM 20100621 keine leere Zeile
                'mt.Rows.Add
                If (mlv.Relevance = "O" Or mlv.Relevance = "A") And pos_zahler = 1 Then
                Else
                    mt.Rows.Add
                End If
                
                If mlv.Relevance = "A" And mlv.RelGroup <> "" Then
                    'finde die zugeh|fffd|rige Relation und h|fffd|nge Text an
                    mt.Rows(mt.Rows.Count).Range.Style = "layout_position"
                    With mt.Rows(mt.Rows.Count)
                        .Cells(3).Range.Text = findRelGroup(mlv, PosList2, mt)
                        .Cells(3).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                        If InStr(mlv.SMSDiffPrice, "-") > 0 Then
                            .Cells(5).Range.Text = "Price reduction"
                        Else
                            If mlv.SMSDiffPrice <> "" Then
                                my_d = my_preis.GetValueFromStringAndSetFormat(mlv.SMSDiffPrice)
                                If my_d = 0 Then
                                    .Cells(5).Range.Text = ""
                                Else
                                    .Cells(5).Range.Text = "Additional Charge"
                                End If
                            Else
                                .Cells(5).Range.Text = ""
                            End If
                        End If
                        .Cells(5).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                    End With
                mt.Rows.Add
                End If
                With mt.Rows(mt.Rows.Count)
                    .Range.Style = "layout_position"
                    .Range.Bold = False
                    .Cells(1).Range.Text = pos_zahler
                    .Cells(1).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                    .Cells(2).Range.Text = mlv.Product
                    .Cells(2).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                    .Cells(3).Range.Text = mlv.Description
                    .Cells(3).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                    .Cells(4).Range.Text = mlv.Quantity
                    .Cells(4).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
'                    If mlv.PricePrintSuppress <> True Then'20100608 GEM Preise f|fffd|r Optional und Alternativ immer drucken
'                    If mlv.PricePrintSuppress <> True Or preis_druck_immer = True Then
                    If preis_druck_immer = True Then '20100621 GEM nur Preise f|fffd|r Optional und Alternativ drucken
                        If mlv.Relevance = "A" Then
                            If mlv.SMSDiffPrice <> "" Then
                                .Cells(5).Range.Text = mlv.SMSDiffPrice
                            Else
                                .Cells(5).Range.Text = mlv.ExtendesNetPrice
                            End If
                            .Cells(5).Range.ParagraphFormat.Alignment = wdAlignParagraphRight
                        Else
                                .Cells(5).Range.Text = mlv.ExtendesNetPrice
                                .Cells(5).Range.ParagraphFormat.Alignment = wdAlignParagraphRight
                        End If
                    End If
                End With
'                mt.Rows.Add
'                With mt.Rows(mt.Rows.Count)
'                    If mlv.BTextPrint <> True Then  'nicht wundern wenn print positiv, dann nciht drucken
'                        .Cells(3).Range.Text = mlv.BText & vbCr
'                    End If
'                    .Cells(3).Range.Bold = False
'                End With
                'GEM 20100621 nur wenn BText dann neue Zeile
                If mlv.BTextPrint <> True Then
                    mt.Rows.Add
                    With mt.Rows(mt.Rows.Count)
                        .Cells(3).Range.Text = mlv.BText & vbCr
                        .Cells(3).Range.Bold = False
                    End With
                End If

            End If  'end Position
            'AnlagenEnde
            If mlv.PositionCode = "AE" Then
                mt.Rows.Add
                
                If anlProduct = mlv.Product Then
                    anlProduct = ""
                    With mt.Rows(mt.Rows.Count)
                        If i = UBound(PosList) Then
                            .Range.Style = "layout_AS"
                        Else
                            .Range.Style = "layout_position"
                        End If
                        If mlv.Description = "" Then
                            .Cells(3).Range.Text = "Total Price"
                        Else
                            .Cells(3).Range.Text = mlv.Description
                        End If
                        .Cells(3).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                        .Cells(3).Range.Font.Underline = wdUnderlineNone
                        .Cells(3).Range.Font.Size = 13
                        .Cells(3).Range.Font.Color = wdColorDarkBlue
                        .Cells(5).Range.Text = mlv.ExtendesNetPrice
                        .Cells(5).Range.ParagraphFormat.Alignment = wdAlignParagraphRight
                        .Cells(5).Range.Font.Underline = wdUnderlineNone
                        .Cells(5).Range.Font.Size = 13
                        .Cells(5).Range.Font.Color = wdColorDarkBlue
                    End With
                Else
                'LYG 20110107: Wunsch: keine AE-Preise der unteren Ebenen
'                    With mt.Rows(mt.Rows.Count)
'                        .Range.Style = "layout_position"
'                        If mlv.Description = "" Then
'                            .Cells(3).Range.Text = "Total"
'                        Else
'                            .Cells(3).Range.Text = mlv.Description
'                        End If
'                        .Cells(3).Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
'                        .Cells(3).Range.Font.Underline = wdUnderlineNone
'                        If mlv.PricePrintSuppress <> True Then
'                            .Cells(5).Range.Text = mlv.ExtendesNetPrice
'                            .Cells(5).Range.ParagraphFormat.Alignment = wdAlignParagraphRight
'                         End If
'                    End With
                End If
                 
            End If  'end AnlagenEnde
            If mlv.PositionCode = "TX" Or mlv.PositionCode = "GS" Then
                mt.Rows.Add
                With mt.Rows(mt.Rows.Count).Cells(3)
                    .Range.Style = "layout_position"
                    .Range.Text = mlv.Description
                    .Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                End With
            End If
            If mlv.PositionCode = "GE" Then
            'LYG 20110107: Wunsch: keine GE-Preise
''                mt.Rows.Add
''                With mt.Rows(mt.Rows.Count).Cells(3)
''                    .Range.Style = "layout_position"
''                    .Range.Text = mlv.Description
''                    .Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
''                End With
'''                If mlv.PricePrintSuppress <> True Then'20100608 GEM Preise f|fffd|r Optional und Alternativ immer drucken
''                'GEM 20100621 Gruppen Totalpreis auch nicht drucken?
'''                If mlv.PricePrintSuppress <> True Or preis_druck_immer = True Then
''                If preis_druck_immer = True Then
''                    With mt.Rows(mt.Rows.Count).Cells(5)
''                        .Range.Style = "layout_position"
''                        .Range.Text = mlv.ExtendesNetPrice
''                        .Range.ParagraphFormat.Alignment = wdAlignParagraphRight
''                    End With
''                End If
            End If
        End If
    Next i
End Sub

Private Function setTecSpec(PosList() As Item, doc As Word.Document)
    Const MYMETHOD = "setTecSpec"
    setTecSpec = False
    On Error GoTo setTecSpec_Error
    Dim mt As Table
    Dim i As Integer    'zahler
    Dim mlv As Item
    Dim dummy As String
    Dim kopf_text As String
    
    Set mt = doc.Bookmarks("print_tecspec").Range.Tables(1)
    
    If PosList(1).Relevance = "R" Then
        If anz_Anl > 1 Then
            doPageBreak doc, mt, "print_tecspec", "R", PosList(1).Description
        Else
            writeIntoBookmark "print_as_desc_ts", PosList(1).Description
        End If
    ElseIf PosList(1).Relevance = "A" Then
        doPageBreak doc, mt, "print_tecspec", "A", PosList(1).Description
    ElseIf PosList(1).Relevance = "O" Then
        doPageBreak doc, mt, "print_tecspec", "O", PosList(1).Description
    Else
        '...
    End If
    
    For i = 1 To UBound(PosList)
        mlv = PosList(i)
        dummy = ""
        'AnlagenStart
        If mlv.SuppressPrint <> True Then
            If mlv.PositionCode = "AS" Then
                If i <> 1 Then mt.Rows.Add
                With mt.Rows(mt.Rows.Count).Cells(2)
                    .Range.Text = mlv.Description
                    .Range.Style = "layout_Position"
                    .Range.Bold = True
                    .Range.ParagraphFormat.Alignment = wdAlignParagraphLeft
                    .Range.Font.Underline = wdUnderlineNone
                End With
            End If
            'Position
            If mlv.PositionCode = "PS" Or mlv.PositionCode = "PL" Then
                pos_zahler = pos_zahler + 1
                'GEM 20100621 keine leere Zeilen
                'mt.Rows.Add
                If (mlv.Relevance = "O" Or mlv.Relevance = "A") And pos_zahler = 1 Then
                Else
                    mt.Rows.Add
                End If
                
                With mt.Rows(mt.Rows.Count)
                    .Range.Style = "layout_Position"
                    .Range.Bold = True
                    .Cells(1).Range = pos_zahler
                    .Cells(1).Range.ParagraphFormat.Alignment = wdAlignParagraphRight
                    .Cells(2).Range = mlv.Description
                End With
                If mlv.ETextPrint <> True Then 'nicht wundern wenn print positiv, dann nciht drucken
                    'falls BText nicht leer --> schreiben
                    If mlv.BText <> "" Then
                        mt.Rows.Add
                        With mt.Rows(mt.Rows.Count)
                            .Cells(2).Range.Bold = False
                            .Cells(2).Range = mlv.BText & vbCr
                        End With
                    End If
                    mt.Rows.Add
                    With mt.Rows(mt.Rows.Count)
                        .Cells(2).Range.Bold = False
                            AddEText mt, mt.Rows.Count, mlv.Path
                    End With
                    'GEM 20100621 keine leere Zeilen
                    'mt.Rows.Add
                End If
            End If  'end Position
        End If
    Next i
    setTecSpec = True
    Exit Function
setTecSpec_Error:
    LogMessage 1, MYMODUL & MYMETHOD & "share_IL::setTecSpec_Error"
    Resume Next
End Function

'LYG 20090910   kopiert die |fffd|-Zeile der Tabelle
'               trennt die Tabelle |fffd|ber der |fffd|-Zeile
'               macht einen Seitenumbruch an der Stelle
'               schreibt die Seitenkopf-|fffd|berschrift
'GEM 20100318 angepasst f|fffd|r IL
'LYG 20110107 AS-Description eingef|fffd|gt
Sub doPageBreak(my_doc As Word.Document, mt As Table, nameBook As String, ueb_text As String, asDesc As String)

    Dim mb As Range ' zum Kopieren der |fffd|-Zeile
    Dim mb_read As Range ' zum Kopieren der |fffd|-Zeile
    Dim mb_write As Range ' zum Kopieren der |fffd|-Zeile
    Dim mb_par As Range
    mt.Rows.Add
    
    If nameBook = "print_posliste" Then
        With mt.Rows(mt.Rows.Count)
            .Range.Style = "layout_Position"
            .Cells(3).Range.Style = "layout_Position"
            .Cells(5).Range.Style = "layout_Position"
        End With
    End If
                    
    '############## Aktion Seitenumbruch Start ##################################
    'Merke dir die erste Zeile
    Set mb_read = mt.Rows(1).Range
    'Merke dir den Anfang der letzten Zeile
    Set mb_write = mt.Rows(mt.Rows.Count).Range
    mb_write.SetRange start:=mb_write.start, End:=mb_write.start
    'die |fffd|berschriftszeile kopieren
    mb_read.Copy
    mb_write.Paste
    'neue leere Zeile einf|fffd|gen
    mt.Rows.Add
    'Tabelle teilen
    mt.Split (mt.Rows.Count - 2)
    'Seitenumbruch
    Set mb = mb_write.Tables(1).Range
    mb.SetRange start:=mb.start, End:=mb.start
    mb.InsertBreak Type:=wdPageBreak
    
    'die akt. Tabelle auf die mb_write setzen und unbedingt die Bookmark auch setzen
    Set mt = mb_write.Tables(1)
    my_doc.Bookmarks.Add nameBook, mt.Range
    
    'LYG 20100204 Return und neue Tabelle verbinden, sonst entsteht eine Leerseite
    Set mb = mt.Range
    mb.SetRange start:=mb.start - 1, End:=mb.End
    mb.Paragraphs.KeepWithNext = True
    
    '############## Aktion Seitenumbruch Ende ##################################
    '---------------------
    'GEM
    mb.InsertBefore ("" & vbCr)
    
    Select Case ueb_text
    Case "R"
        If nameBook = "print_posliste" Then
            Set mb_read = my_doc.Bookmarks("print_pos_kopf1").Range
            Set mb_write = mb.Paragraphs(2).Range
            mb_write.SetRange start:=mb_write.start, End:=mb_write.start
            mb_read.Copy
            mb_write.Paste
            
            Set mb_par = mb.Paragraphs(2).Range
            'GEM 20110103
'            mb_par.SetRange start:=mb_par.start + 68, End:=mb_par.start + 68
            mb_par.SetRange start:=mb_par.start + 62, End:=mb_par.start + 62
'            mb_par.Text = " " & anl1_Desc & " "
'            mb_par.Text = " " & my_doc.Bookmarks("layout_opportunityname").Range.Text & " "
            'LYG 20110107
            mb_par.Text = " " & asDesc & " "
            
            Set mb_par = mb.Paragraphs(2).Range
            'GEM 20110103
'            mb_par.SetRange start:=mb_par.start + 69, End:=mb_par.start + (69 + Len(anl1_Desc))
'            mb_par.SetRange start:=mb_par.start + 63, End:=mb_par.start + (63 + Len(my_doc.Bookmarks("layout_opportunityname").Range.Text))
            'LYG 20110107
            mb_par.SetRange start:=mb_par.start + 63, End:=mb_par.start + (63 + Len(asDesc))
            mb_par.Select
            mb_par.BoldBi = True
            
       Else
            If nameBook = "print_tecspec" Then
'                mb.InsertBefore (my_doc.Bookmarks("print_tec_ueb1").Range.Text & anl1_Desc & " ")
                mb.InsertBefore ("" & vbCr)
                
                Set mb_read = my_doc.Bookmarks("print_tec_kopf1").Range
                Set mb_write = mb.Paragraphs(2).Range
                mb_write.SetRange start:=mb_write.start, End:=mb_write.start
                mb_read.Copy
                mb_write.Paste
                
                Set mb_par = mb.Paragraphs(2).Range
                'GEM 20110103
'                mb_par.SetRange start:=mb_par.start + 38, End:=mb_par.start + 38
                mb_par.SetRange start:=mb_par.start + 38, End:=mb_par.start + 38
'                mb_par.Text = " " & anl1_Desc & " "
'                mb_par.Text = " " & my_doc.Bookmarks("layout_opportunityname").Range.Text & " "
                'LYG 20110107
                mb_par.Text = " " & asDesc & " "
            Else
                mb.InsertBefore ("" & vbCr)
            End If
        End If
    Case "A"
        'GEM 20110103
'        mb.InsertBefore ("Alternatives for " & anl1_Desc & " system:")
        mb.InsertBefore ("Alternatives for " & my_doc.Bookmarks("layout_opportunityname").Range.Text & " system:")
        mb.InsertBefore ("" & vbCr)
        Set mb_par = mb.Paragraphs(2).Range
        With mb_par.Font
            .Name = "Arial"
            .Size = 11
            .Bold = True
            .Underline = wdUnderlineSingle
            .Color = wdColorDarkBlue '20100609 GEM Text muss noch |fffd|bersetzt werden - deshalb blau
        End With
    Case "O"
        'GEM 20110103
'        mb.InsertBefore ("Options for " & anl1_Desc & " system:")
        mb.InsertBefore ("Options for " & my_doc.Bookmarks("layout_opportunityname").Range.Text & " system:")
        mb.InsertBefore ("" & vbCr)
        Set mb_par = mb.Paragraphs(2).Range
        With mb_par.Font
            .Name = "Arial"
            .Size = 11
            .Bold = True
            .Underline = wdUnderlineSingle
            .Color = wdColorDarkBlue '20100609 GEM Text muss noch |fffd|bersetzt werden - deshalb blau
        End With
    Case Else
    '
    End Select

    mb.Tables(1).Rows(2).Select
    Selection.Rows.Delete
    Set mb_par = Nothing
    '---------------------
    'GEM
    Set mb = Nothing
    Set mb_read = Nothing
    Set mb_write = Nothing
End Sub

'LYG 20090925 Findet die zugeh|fffd|rige Relation und h|fffd|ngt einen bestimmten Text an die Description an
'   Parameter:  mlv Item
'               PosList() Array mit Item
'               mt  Tabelle, in der nach der Pos-Nr gesucht wird
'GEM 20100318 angepasst f|fffd|r IL
Private Function findRelGroup(mlv As Item, PosList() As Item, mt As Table) As String
    findRelGroup = mlv.Description
    On Error GoTo findRelGroup_Error
                    
    Dim dummy, posRel As String
    Dim y As Integer
    
    y = 0
    nr = 0
    dummy = ""
    posRel = ""
                              
    'Suche in der Variablen-Liste nach der R-Position, die zu der Gruppe geh|fffd|rt
    dummy = "R" & Mid(mlv.RelGroup, 2)
    For y = 1 To UBound(PosList)
        If PosList(y).SuppressPrint <> True And (PosList(y).PositionCode = "PS" Or PosList(y).PositionCode = "PL") Then
            nr = nr + 1
        End If
        If dummy = PosList(y).RelGroup Then
            dummy = PosList(y).Description
            Exit For
        End If
    Next y
    dummy = "Alternative to Position:"
    dummy = dummy & nr
        
    findRelGroup = dummy
    Exit Function

findRelGroup_Error:
    LogMessage 1, MYMODUL & ":findRelGroup_Error"
    Resume Next
End Function

'Konvertiert ein String, je nach ProposalLanguage in ein "mmmm tt, yyyy" Format-String
Public Function GetDatumFromCommonString(my_doc As Document, ByVal datum As String, ByVal mk As String) As String
    Dim tag As Integer
    Dim monat As Integer
    Dim jahr As Integer
    Dim Mon_text As String
    Dim mySpalte As Integer
    mySpalte = 1
    Dim mt As Table
    Dim mb As Range
    
    d_ok = True
    If Len(datum) = 10 Then
        If mk = "ENU" Then
            tag = CInt(Mid(datum, 4, 2))
            monat = CInt(Left$(datum, 2))
            jahr = CInt(Right$(datum, 4))
        ElseIf mk = "DEU" Or mk = "ENS" Then
            tag = CInt(Left$(datum, 2))
            monat = CInt(Mid(datum, 4, 2))
            jahr = CInt(Right$(datum, 4))
        Else
            tag = CInt(Left$(datum, 2))
            monat = CInt(Mid(datum, 4, 2))
            jahr = CInt(Right$(datum, 4))
        End If
'        GetDatumFromCommonString = DateSerial(jahr, monat, tag)
        'LYG 20110107
        'GEM 20110225 immer hebr
''        If mk = "ENU" Or mk = "ENS" Or mk = "DEU" Then
''            mySpalte = 1
''        Else
            mySpalte = 2
''        End If
        Set mt = my_doc.Bookmarks("layout_tab_monate").Range.Tables(1)
'        Mon_text = mt.Rows(CInt(monat)).Cells(mySpalte).Range.Text
        Set mb = mt.Rows(CInt(monat)).Cells(mySpalte).Range
        mb.SetRange mb.start, mb.End - 1
        mb.Text = tag & " " & mb.Text & " " & jahr
        Set mb = mt.Rows(CInt(monat)).Cells(mySpalte).Range
        mb.SetRange mb.start, mb.End - 1
        my_doc.Bookmarks.Add "print_datum", mb
        '
'        Select Case monat
'        Case "01"
'            Mon_text = mt.Rows(1).Cells(mySpalte).Range.Text
''            Mon_text = "January"
'        Case "02"
'            Mon_text = "February"
'        Case "03"
'            Mon_text = "March"
'        Case "04"
'            Mon_text = "April"
'        Case "05"
'            Mon_text = "May"
'        Case "06"
'            Mon_text = "June"
'        Case "07"
'            Mon_text = "July"
'        Case "08"
'            Mon_text = "August"
'        Case "09"
'            Mon_text = "September"
'        Case "10"
'            Mon_text = "October"
'        Case "11"
'            Mon_text = "November"
'        Case "12"
'            Mon_text = "December"
'        Case Else
'            Mon_text = monat
'        End Select
'        GetDatumFromCommonString = Mon_text & " " & tag & ", " & jahr
'        GetDatumFromCommonString = jahr & " " & Mon_text & " " & tag
    Else
'        Call Err.Raise(2000, , "Datum im falschen Format")
        d_ok = False
    End If
    Set mt = Nothing
    Set mb = Nothing
End Function


' InQuest injected base64 decoded content
' N+exw
' j)Qy
' abzWl
' Z+K+-z
' Z+K+-ze
' m"w^

INQUEST-PP=macro
