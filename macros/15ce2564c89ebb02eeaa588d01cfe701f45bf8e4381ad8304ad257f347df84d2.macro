Attribute VB_Name = "Hoja1"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja10"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja11"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja12"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja13"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja14"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja15"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja16"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja17"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja18"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja20"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja21"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja4"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja6"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja7"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja8"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "Hoja9"
Attribute VB_Base = "0{00020820-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True
Attribute VB_Name = "M|fffd|dulo1"
Sub StartArelle()

Dim ErrorArelle As Boolean
ErrorArelle = False

Dim comandoIniciarArelle As String

comandoIniciarArelle = Sheets("Index").Cells(7, 4) & "\arelleCmdLine.exe --webserver localhost:8080"

If Dir$(Sheets("Index").Cells(7, 4) & "\scripts\startWebServer.bat") = "" Then
    MsgBox "Arelle program location is not correct", _
    vbOKOnly + vbCritical, "ERROR"
Else

    On Error GoTo Errhandler

    ejecutar = Shell(comandoIniciarArelle)
    
    newHour = Hour(Now())
    newMinute = Minute(Now())
    newSecond = Second(Now()) + 5
    waitTime = TimeSerial(newHour, newMinute, newSecond)
    Application.Wait waitTime
    
    Set objHTTP = CreateObject("MSXML2.ServerXMLHTTP")
    Url = "http://localhost:8080/about"
    objHTTP.Open "GET", Url, False
    objHTTP.send
    
    If objHTTP.Status = "200" Then
        ErrorArelle = False
    Else
        ErrorArelle = True
    End If
    
    If (Not ErrorArelle) Then
        validacion = "Arelle web server has started OK"
        MsgBox validacion, _
        vbOKOnly, "Information"
    Else
        validacion = "Arelle web server can't start"
        MsgBox validacion, _
        vbOKOnly + vbCritical, "ERROR"
    End If

End If

Exit Sub

Errhandler:

    MsgBox "Arelle web service can't start. Please, check Arelle program location and the proper installation of Arelle." & vbNewLine & "Error n|fffd|" & Err & ": " & Error(Err), _
    vbOKOnly + vbCritical, "ERROR"
    
    
End Sub

Sub Validate()

Dim ErrorValidacion As Boolean
ErrorValidacion = False

ruta = Sheets("Index").Cells(100, 1)
ruta = Replace(ruta, "|fffd|", "%C3%A0")
ruta = Replace(ruta, "|fffd|", "%C3%A1")
ruta = Replace(ruta, "|fffd|", "%C3%A2")
ruta = Replace(ruta, "|fffd|", "%C3%A3")
ruta = Replace(ruta, "|fffd|", "%C3%A4")
ruta = Replace(ruta, "|fffd|", "%C3%A5")
ruta = Replace(ruta, "|fffd|", "%C3%A6")
ruta = Replace(ruta, "|fffd|", "%C3%A7")
ruta = Replace(ruta, "|fffd|", "%C3%A8")
ruta = Replace(ruta, "|fffd|", "%C3%A9")
ruta = Replace(ruta, "|fffd|", "%C3%AA")
ruta = Replace(ruta, "|fffd|", "%C3%AB")
ruta = Replace(ruta, "|fffd|", "%C3%AC")
ruta = Replace(ruta, "|fffd|", "%C3%AD")
ruta = Replace(ruta, "|fffd|", "%C3%AE")
ruta = Replace(ruta, "|fffd|", "%C3%AF")
ruta = Replace(ruta, "|fffd|", "%C3%B0")
ruta = Replace(ruta, "|fffd|", "%C3%B1")
ruta = Replace(ruta, "|fffd|", "%C3%B2")
ruta = Replace(ruta, "|fffd|", "%C3%B3")
ruta = Replace(ruta, "|fffd|", "%C3%B4")
ruta = Replace(ruta, "|fffd|", "%C3%B5")
ruta = Replace(ruta, "|fffd|", "%C3%B6")
ruta = Replace(ruta, "|fffd|", "%C3%B7")
ruta = Replace(ruta, "|fffd|", "%C3%B8")
ruta = Replace(ruta, "|fffd|", "%C3%B9")
ruta = Replace(ruta, "|fffd|", "%C3%BA")
ruta = Replace(ruta, "|fffd|", "%C3%BB")
ruta = Replace(ruta, "|fffd|", "%C3%BC")
ruta = Replace(ruta, "|fffd|", "%C3%BD")
ruta = Replace(ruta, "|fffd|", "%C3%BE")
ruta = Replace(ruta, "|fffd|", "%C3%BF")

On Error GoTo Errhandler

Set objHTTP = CreateObject("MSXML2.ServerXMLHTTP")
Url = "http://localhost:8080/rest/xbrl/validation?calcDecimals=1&media=text&file=" & ruta

objHTTP.setTimeouts 3600000, 3600000, 3600000, 3600000
objHTTP.Open "GET", Url, False
objHTTP.send

respuesta = objHTTP.responseText

Dim lineasRes() As String
      
lineasRes = Split(respuesta, vbLf)
respuestaError = ""

For I = LBound(lineasRes) To UBound(lineasRes)

 If ((Not FindString(lineasRes(I), "[info]")) And (Not FindString(lineasRes(I), "[info:profileActivity]")) And (Not FindString(lineasRes(I), "[]")) And (lineasRes(I) <> "") And Not (InStr(1, lineasRes(I), " - ") = 1)) Then
    ErrorValidacion = True
    respuestaError = respuestaError & lineasRes(I) & vbNewLine & vbNewLine
 End If
Next

If (Not (ErrorValidacion)) Then
    MsgBox "XBRL instance document is valid!", _
    vbOKOnly, "Successful validation"
Else
    MsgBox "XBRL instance document has some validation errors. An error description file is going to be generated.", _
    vbOKOnly + vbExclamation, "Validation with errors"
    
    'generamos un fichero con los errores de validaci|fffd|n -> respuestaError
    
    Dim fsT As Object
    
    'Create Stream object
    Set fsT = CreateObject("ADODB.Stream")
    
    'Specify stream type - we want To save text/string data.
    fsT.Type = 2
 
    'Specify charset For the source text data.
    fsT.Charset = "utf-8"
 
    'Open the stream And write binary data To the object
    fsT.Open
    
    'XBRL File: Name and path
    strFilePath = Application.GetSaveAsFilename("XBRL instance document errors.txt", "Text Files (*.txt), *.txt")
    
    ' If the "Save as..." dialog box is cancelled
    If strFilePath = False Then
        Exit Sub
    End If
    
     fsT.writetext respuestaError
     fsT.SaveToFile strFilePath, 2
     RemoveBOM (strFilePath)
    
    MsgBox "The error description file has been generated successfully", _
    vbOKOnly, "Informaci|fffd|n"
 
    
End If

Exit Sub

Errhandler:

    MsgBox "Problem with the validation process of the XBRL instance document." & vbNewLine & "Error n|fffd|" & Err & ": " & Error(Err), _
    vbOKOnly + vbCritical, "ERROR"


End Sub

Sub GenerateXBRL()
' Version 2016-04-17
'LEGAL NOTICE, DO NOT REMOVE: Proof of concept ExcelXbrl converter. Copyrigth Boixo, Mora, 2011. Licenses EUPL & CC BY. See www.OpenFiling.info for details.

Const generateInstance As Boolean = False ' Generate sheet instance for debugging. Select False in production.
Const skipDuplicates As Boolean = True    ' No detect duplicated primaryItems for debugging. Select False in production.
Const skipCoordinates As Boolean = False    ' No inlude the coordinates in RowID (if empty). Select False in production.
Const showDuration As Boolean = False    ' Show the duration of the total processing in seconds. Select False in production.

Const maxItems As Long = 100000    ' max capacity of processing facts. Apply below in Dim arrays
Dim factTableV(100000, 30) As String 'big table to work in memory, for better perfomance. Max number of facts and maxCols
Dim factPrimV(100000) As String 'big table to work in memory, for better perfomance. Max number of facts and maxCols
Dim factTableS(100000), factPrimS(100000), factPrimP(100000), factOrderS(100000), factOrderR(100000), posS, posZ, maxOrderS, maxPrimS As Long 'big table to work in memory, for better perfomance. Pointer of fact or spreadsheet "data" and later reused as pointer to context

Const maxContexts As Long = 20000      ' max capacity of processing contexts. Apply below in Dim arrays
Dim rowInstance, replacesLoopSize, replacesNValue, replacesN(20000) As Long
Dim replacesSValue, replacesS(20000), replacesLoop(100), context, contextID As String
Dim replacesTable(20000, 28) As String ' big table to work in memory, for better perfomance. Max number of replaces and maxCols
Dim replacesT(20000) As String ' Keyword to be expanded and replaced
Dim numReplaces As Long
Dim replacesTValue As String
Dim contextsList(20000) As String
Dim contextsLOrd(20000) As Long

Const maxFootnotes As Long = 10000      ' max capacity of processing contexts. Apply below in Dim arrays
Dim footnoteLang, footnoteT(10000), idNfootnote, arcfootnote, textfootnote As String

Const sheetMain As String = "Index"         ' main sheet
Const sheetData As String = "data"
Const sheetParameters As String = "parameters"
Const sheetInstance As String = "instance"

Dim rowID, scenarioSegment, workCells(100), wSheet, a, b, c  As String
Dim outputHeader, outputMiddle, outputTail, outputTableType(100), outputTableValue(100), orderDim(50, 4) As String
Dim footnoteMax, tupleDepth, tupleItemSequence(100), maxOutputTable As Long
Dim replacedCell, replaceDup, repeatedContext, scenarioSegmentOpen, orderDimFlag, dimFlag As Boolean
Dim row, col, F, J, K, L, M As Long
Dim maxParameters, maxData, maxInstance, maxOrderDim, minOrderDim As Long
Dim strFilePath, item, tupleType(100), itemString, msgD As String
Dim I As Long
Dim iContext As Long
Dim cellValue As String
Dim wRow(100) As String

' Partial and total times
Dim timerN(100) As Long
Dim timerS(100) As String
Dim msgTimer As String

Dim fsT As Object  ' File

Const maxCols As Integer = 28    ' Define maximun of columns for replace
Const firstRowInstance As Integer = 7    ' Define first row to be explored in sheet "instance"
Const firstRowData As Integer = 7    ' Define first row to be explored in sheet "data"
Const firstRowParameters As Integer = 2  ' Define first row to be explored in sheet "parameters"
Const colRowID As Integer = 1   ' column contating the row ID
Const colFootnote As Integer = 2   ' column contating the footnote
Const colPrimaryItem As Integer = 3   ' column contating the PrimaryItem (Code) of the fact
Const colDecimals As Integer = 4   ' column contating the Decimals
Const colUnitRef As Integer = 5   ' column contating the Currency
Const colFact As Integer = 6 ' column containing the value of the Fact
Const colEntity As Integer = 7   ' column contating the Identifier of the Entity
Const colScheme As Integer = 8   ' column contating the Schema of the Entity
Const colPeriodInit As Integer = 9   ' column contating the Period Init
Const colPeriodEnd As Integer = 10   ' column contating the Period End
Const colDimensions As Integer = 11 ' column starting the Dimensions

On Error GoTo Errhandler

' Acelerate processing by disabling options
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False
Application.DisplayStatusBar = False

maxOrderS = 0      ' maximum entry in factOrder table
maxPrimS = 0       ' maximum entry in factPrim table
numReplaces = 0    ' table of replaces empty
maxParameters = 0  ' length sheet "parameters"
maxData = 0        ' length sheet "data"
maxOutputTable = 0 ' length outputTable
footnoteLang = Chr(34) & "en" & Chr(34) ' footnote lang = "en" by default
msgD = ""          ' message/s about errors or duplicated items

Call timerPartial(timerN, timerS, "") ' Init chronometer
If generateInstance = True Then Sheets(sheetInstance).Range("A1:AZ100000").ClearContents ' clear spreadsheet "instance" for debugging. Put false in production

' prepare file for XBRL instance document
Set fsT = CreateObject("ADODB.Stream")    'Create Stream object
fsT.Type = 2    'Specify stream type - we want To save text/string data.
fsT.Charset = "utf-8"    'Specify charset For the source text data.
fsT.Open    'Open the stream And write binary data To the object
'XBRL File: Name and path
strFilePath = Application.GetSaveAsFilename("informe XBRL.xbrl", "XBRL files (*.xbrl; *.xml), *.xbrl")
If strFilePath = False Then GoTo exitSub ' If the "Save as..." dialog box is cancelled, exit
    
Sheets(sheetMain).Cells(100, 1) = strFilePath  ' Put strPath in a specific position in sheet "|fffd|ndice" for further process

Call timerPartial(timerN, timerS, "seleccionar nombre informe XBRL") ' Partial chronometer

' Load the sheets "parameters" and "data" into memory
For K = 1 To 2    ' two sheets

    If K = 1 Then ' Variables of sheet to be processed
        wSheet = sheetParameters
        I = firstRowParameters
    Else
        wSheet = sheetData
        I = firstRowData
    End If
    Sheets(wSheet).Activate  ' activate data/parameters spreadsheet

    For row = I To maxItems  ' very long loop for processing rows, starting in the respective first row
        If IsError(Cells(row, 1)) Or IsError(Cells(row, colPrimaryItem)) Or IsError(Cells(row, colFact)) Then ' Row with error
            c = Cells(row, colFact).Formula            ' Message of row with error/s
            c = findCoordinates(c)              ' Obtain formula, if exists
            If c <> "" Then c = ", apuntando a coordenadas Excel " & c ' if formula exists, document it in message
            msgD = msgD & vbCrLf & "Error en hoja """ & wSheet & """, fila " & row & c & ". Se ignora la fila." & vbCrLf   ' save error message
        Else  ' Process row
            If Cells(row, 1) <> "/*" Then  ' if row commented, ignore
                If K = 1 Then ' check end of sheet "parameters"
                    If Cells(row, 1) = "" Then Exit For   ' end of sheet "parameters"
                    maxParameters = row ' increase the upper limit of the table
                Else           ' check end of sheet "data"
                    If Cells(row, 1) & Cells(row, colPrimaryItem) & Cells(row, colFact) = "" Then Exit For     ' end of sheet "data"
                    maxData = row       ' increase the upper limit of the table
                End If
                'Create an array with the /**Replace rows from the sheets "parameters" and "data"
                If Left(Cells(row, 1), 10) = "/**Replace" Then
                    numReplaces = numReplaces + 1           ' insert additional row in Replace tables
                    For J = 1 To maxCols          ' copy row to Replaces content table
                        replacesTable(numReplaces, J) = Cells(row, J)
                    Next J
                    ' create auxiliar array replacesT to speed up searchs
                    J = numReplaces   ' point j to inserting row in ascending sequence in Replaces pointers tables
                    c = Cells(row, 2) & ""    ' obtain keyword (forcing type String with "")
                    Do While J > 1 And replacesT(J - 1) > c
                        replacesT(J) = replacesT(J - 1)
                        replacesN(J) = replacesN(J - 1)
                        replacesS(J) = replacesS(J - 1)
                        J = J - 1
                    Loop
                    replacesT(J) = c              ' keyword
                    replacesN(J) = numReplaces    ' position in Replaces content table
                    replacesS(J) = wSheet         ' name of sheet: data/parameters
                End If
                'Find and save "/**Output" indications
                If Left(Cells(row, 1), 9) = "/**Output" Then
                    maxOutputTable = maxOutputTable + 1  ' Point to the next entry in outputTable
                    outputTableType(maxOutputTable) = Cells(row, 1)  ' Save output type
                    outputTableValue(maxOutputTable) = Cells(row, 2) ' Save output value
                End If
                'Find and footnote language indications
                If Cells(row, 1) = "/**FootnoteLang" Then
                    footnoteLang = Chr(34) & Cells(row, 2) & Chr(34) ' Save footnote language
                End If
            End If
        End If
    Next row
Next K
Call timerPartial(timerN, timerS, "carga parametros") ' Partial chronometer

replacesT(numReplaces + 1) = "" ' Clean the element just after the end of the of the repacles table

rowInstance = firstRowInstance - 1  ' point just prior to first "instance" target row

Sheets(sheetData).Activate  ' activate "data" spreadsheet

' For each row in sheet "data"
For row = firstRowData To maxData
 If Not (IsError(Cells(row, 1)) Or IsError(Cells(row, colPrimaryItem)) Or IsError(Cells(row, colFact))) Then  ' skip is cell in error
  If Left(Cells(row, 1), 2) <> "/*" Then ' Process the rows NOT starting in "/*"

    ' copy row from "data" sheet to "instance" sheet, simulated by wRow (working row).
    For col = 1 To maxCols
        wRow(col) = Cells(row, col)        'copy row from "data" sheet to workCells.
    Next
    replacesLoopSize = 0  ' avoid infinite loop of replacements. Initializate prior to the first element of the repacles loop table
    
    Do ' algorithm for recursive cell replacement in a row
        replacedCell = False
                        
        ' copy "instance" sheet to workCells. Clean "instance" sheet except for colRowID, colFootnote and colFact
        For col = 3 To maxCols
            workCells(col) = wRow(col)
            If Not (col = colRowID Or col = colFootnote Or col = colFact) Then wRow(col) = ""    ' Clean "instance" sheet.
        Next col
        
        For col = 3 To maxCols        'For each column, except RowID, Footnote and colFact
            If workCells(col) <> "" And col <> colFact Then   'If the cell is not empty and cell is not the Fact value
                replacesTValue = workCells(col) ' use a local variable for faster process
                Call dycotomicSearch(replacesT, 1, numReplaces, replacesTValue, I) ' find cell in table replacesT array
                If replacesTValue <> replacesT(I) Then ' no replace keyword found
                    wRow(col) = workCells(col)  ' Copy cell to "Instance" sheet
                Else ' replace keyword found
                    ' Check if the replace keyword has been already used in this row
                    For J = 1 To replacesLoopSize
                        If replacesTValue = replacesLoop(J) Then Exit For ' keyword already used, Exit For
                    Next J
                    ' if replace keyword already used, ignore it.
                    If J <= replacesLoopSize Then ' replace keyword already used
                        wRow(col) = workCells(col)  ' Copy cell with keyword to "Instance" sheet
                    Else  ' first use of the replace keyword in this row
                        replacesLoopSize = replacesLoopSize + 1   ' insert into replace loop table
                        replacesLoop(replacesLoopSize) = replacesTValue ' take note of the keyword being used
                        Do While I > 0 ' If duplicated ocurrence of replace, find the first ocurrence
                            If replacesTValue <> replacesT(I - 1) Then Exit Do
                            I = I - 1
                        Loop
                        ' If duplicated replace, find the last ocurrence on "parameters" or the inmediately prior ocurrence in "data"
                        Do While replacesTValue = replacesT(I + 1) And (replacesS(I + 1) = "parameters" Or (replacesS(I + 1) = "data" And replacesN(I + 1) < row))
                            I = I + 1
                        Loop
                        ' Replace positionally the complete row with the Replace row, located in replacesTable, row replaceN(i)
                        ' For each column until the maximum of columns, replace if source is not empty and target is empty
                        For J = 3 To maxCols
                            If replacesTable(replacesN(I), J) <> "" Then  ' Column not null
                                wRow(J) = replacesTable(replacesN(I), J) ' insert value in Row
                                replacedCell = True
                                If Left(replacesTValue, 1) = "&" Then Exit For ' keyword starting with "&", replace only the first value in command line
                            End If
                        Next J
                    End If
                End If
            End If
        Next col
    Loop While replacedCell = True
    
    ' replace cells containing "/**Null" with ""
    For col = 1 To maxCols
        If wRow(col) = "/**Null" Then wRow(col) = ""
    Next col

    ' compact and order dimensions area and order independently /**Segment and /**Scenario dimensions
    dimFlag = False ' no need of re-write dimensions
    maxOrderDim = 0
    minOrderDim = 1
    orderDimFlag = True
    For I = colDimensions To maxCols Step 2
        If wRow(I) <> "" Then
            If I > 2 And wRow(I - 2) = "" Then dimFlag = True ' empty dimensions detected before used dimensions
            If wRow(I) = "/**Tuple" Then orderDimFlag = False   ' Tuple detected, order to be maintained
            J = maxOrderDim + 1  ' find j as insertion point
            If orderDimFlag = True Then
                If wRow(I) <> "/**Segment" Then ' create ordened insertion point
                    Do While J > minOrderDim And wRow(I) < orderDim(J - 1, 1) ' new element minor than existing element
                        orderDim(J, 1) = orderDim(J - 1, 1)
                        orderDim(J, 2) = orderDim(J - 1, 2)
                        orderDim(J, 3) = orderDim(J - 1, 3)
                        orderDim(J, 4) = orderDim(J - 1, 4)
                        J = J - 1
                        dimFlag = True ' force re-writing as the order has been changed
                    Loop
                Else ' "/**Segment" detected; then start a new ordenated list of dimensions
                    minOrderDim = J + 1
                End If
            End If
            orderDim(J, 1) = wRow(I)        ' save two dimension cells
            orderDim(J, 2) = wRow(I + 1)
            orderDim(J, 3) = ""             ' clear the other two dimension cells
            orderDim(J, 4) = ""
            If wRow(I + 2) = "/**Typed" Then   ' if /**Typed, save up to four dimension cells
                orderDim(J, 3) = wRow(I + 2)
                orderDim(J, 4) = wRow(I + 3)
                I = I + 2
            End If
            maxOrderDim = maxOrderDim + 1
        End If
    Next I
    If dimFlag = True Then ' restore dimension cells from auxiliar ordenated table
        J = colDimensions     ' point to dimensions area
        For I = 1 To maxOrderDim      ' move from ordenated auxiliar table to dimensions area
            wRow(J) = orderDim(I, 1)      ' move pair of dimensions
            wRow(J + 1) = orderDim(I, 2)
            J = J + 2
            If orderDim(I, 3) = "/**Typed" Then   ' if /**Typed, move the second pair of dimensions
                wRow(J) = orderDim(I, 3)
                wRow(J + 1) = orderDim(I, 4)
                J = J + 2
            End If
        Next I
        For K = J To maxCols  ' clear remaining cols
            wRow(K) = ""
        Next K
    End If
    
    ' if origin of value is a formula with valid Excel coordinates, and RowID is empty, store coordinates as RowID
    If skipCoordinates = False And wRow(colRowID) = "" Then
        c = Cells(row, colFact).Formula     ' Obtain formula, if exists
        c = findCoordinates(c)              ' Extract coordinates
        If c <> "" Then wRow(colRowID) = Replace(Replace(Replace(c, "'", "-"), "!", "_"), " ", ".") & "_-"    ' save coordinates
    End If
    
    ' Save row just created
    rowInstance = rowInstance + 1 ' advance to next target row "instance"
    ' move working cells wRow to factTable and, only when debugging, to "instance" sheet
    For col = 1 To maxCols
        factTableV(rowInstance, col) = wRow(col)      ' use with factTableV in memory, replacing spreadsheet "instance"
        If generateInstance = True Then     ' use spreadsheet "instance" for debugging. Put false in production
            If wRow(col) <> "" Then Sheets(sheetInstance).Cells(rowInstance, col) = wRow(col) ' put value in cell
        End If
    Next col
    factTableS(rowInstance) = row ' take note of the row in sheet "data" originating this fact
    
    ' Check for duplicated items, with Identical (PrimaryItem, Unit and Context). Ignore if part of Tuples
    If skipDuplicates = False And wRow(colDimensions) <> "/**Tuple" Then ' this row is not a tuple
        Call dycotomicSearch(factPrimV, 1, maxPrimS, wRow(colPrimaryItem), I)  ' Find primaryItem in table factPrimV
        ' If wRow(colPrimaryItem) = "ifrs:DisclosureOfGeneralInformationAboutFinancialStatementsExplanatory" Then
        '      I = I stop point for debugging
        ' End If
        If wRow(colPrimaryItem) <> factPrimV(I) Then ' primaryItem no exits, insert in the list
            ' save primaryItem in order, to reduce processing time in duplicates search
            maxPrimS = maxPrimS + 1 ' create new entry of factPrim table (item+context , pointer to Ordertable)
            maxOrderS = maxOrderS + 1   ' create new entry in Order table  (next Ordertable entry for the same primaryItem , position in Factable)
            J = maxPrimS  ' point j to inserting row in ascending sequence in factorder table
            Do While J > 1 And factPrimV(J - 1) > wRow(colPrimaryItem)  ' classify ordened entry
                If factPrimV(J - 1) = wRow(colPrimaryItem) Then I = 1 / 0 ' this condition must never be true
                factPrimV(J) = factPrimV(J - 1)             '
                factPrimS(J) = factPrimS(J - 1)             '
                J = J - 1                                   ' check previous entry
            Loop
            factPrimV(J) = wRow(colPrimaryItem)    ' save keyword of primaryItem
            factPrimS(J) = maxOrderS    ' position in  the list of primaryItems
            factOrderS(maxOrderS) = 0   ' insert terminator in new entry
            factOrderR(maxOrderS) = rowInstance ' save row of primaryItem in new entry
        Else
            posS = factPrimS(I)  ' point to first ocurrence in List of the primaryItem
            For M = 1 To 1 ' Block to allow exit for
                Do While posS > 0  ' explore one by one all the primaryItems, pointed in the list factOrderLS
                    posZ = posS  ' save current pointer
                    K = factOrderR(posS) ' use K to betterv legibility
                    If wRow(colUnitRef) = factTableV(K, colUnitRef) And wRow(colEntity) = factTableV(K, colEntity) And _
                        wRow(colPeriodInit) = factTableV(K, colPeriodInit) And wRow(colPeriodEnd) = factTableV(K, colPeriodEnd) Then  ' Same unitRef, Entity, Period?
                        For J = colDimensions To maxCols - 1 ' Same dimensions?  (- 1 used to avoid index overflow)
                            If wRow(J) = "" Or wRow(J) <> factTableV(K, J) Then Exit For ' No more dimensions or something is different
                        Next J
                        ' Duplicate item found
                        If wRow(J) = factTableV(K, J) Then ' Create duplicated item message and mark flag to ignore row
                            a = "hoja " & sheetData & " fila " & factTableS(K)  ' Save first location
                            If factTableV(factOrderR(posS), colRowID) <> "" Then a = a & " (coordenadas " & factTableV(K, colRowID) & ")" ' Save row if first coordinate present
                            b = "hoja " & sheetData & " fila " & row  ' Save second location
                            If wRow(colRowID) <> "" Then b = b & " (coordenadas " & wRow(colRowID) & ")"     ' Save row if second coordinate present
                            ' Prepare message
                            If wRow(colFact) = factTableV(factOrderR(posS), colFact) Then  ' If the Fact has the same value. take note
                                ' Note: The following two lines would be commented to reduce verbose messages
                                msgD = msgD & vbCrLf & "Celdas duplicadas entre " & a & " y " & b & ", siendo IDENTICO en ambas el valor """ & wRow(colFact) & """" & vbCrLf
                                msgD = msgD & "Se ignora la duplicidad de " & b & vbCrLf
                            Else
                                msgD = msgD & vbCrLf & "Celdas duplicadas entre " & a & " y " & b & ", siendo DISTINTOS sus valores """ & factTableV(factOrderR(posS), colFact) & """ y """ & wRow(colFact) & """" & vbCrLf
                                msgD = msgD & "Se ignora la duplicidad de " & b & ", valor """ & wRow(colFact) & """" & vbCrLf
                            End If
                            ' msgD = msgD & wRow(colPrimaryItem) & wRow(colUnitRef) & wRow(colEntity) & wRow(colPeriodInit) & wRow(colPeriodEnd) & wRow(colDimensions) & wRow(colDimensions + 1) & wRow(colDimensions + 2) & wRow(colDimensions + 3) & vbCrLf
                            ' msgD = msgD & factTableV(K, colPrimaryItem) & factTableV(K, colUnitRef) & factTableV(K, colEntity) & factTableV(K, colPeriodInit) & factTableV(K, colPeriodEnd) & factTableV(K, colDimensions) & factTableV(K, colDimensions + 1) & factTableV(K, colDimensions + 2) & factTableV(K, colDimensions + 3) & vbCrLf
                            rowInstance = rowInstance - 1 ' delete the just created row "instance"
                            Exit For ' exit of the block, ignore this row
                        End If
                    End If
                    posS = factOrderS(posS) ' explore next primaryItem
                Loop
                maxOrderS = maxOrderS + 1 ' create new entry in Order array
                factOrderS(posZ) = maxOrderS ' Point to next entry in factOrder
                factOrderS(maxOrderS) = 0 ' insert terminator in new entry
                factOrderR(maxOrderS) = rowInstance       ' insert row of primaryItem in new entry
            Next M
        End If
     End If  ' End of duplicate item checking

  End If ' close if about "/*"
 End If ' close if iserror
Next row
Call timerPartial(timerN, timerS, "preparaci|fffd|n instancia") ' Partial chronometer

'
' Create Instance
'
'
maxInstance = rowInstance ' save the number of facts
footnoteMax = -1  ' Number of footnotes
tupleDepth = -1  ' Depth of nested tuples
iContext = 0 ' Number of contexts

'Find and write: /**OutputHeader
For row = 1 To maxOutputTable
    If outputTableType(row) = "/**OutputHeader" Then fsT.writetext outputTableValue(row) & vbCrLf  ' Write /**Output indications
Next

'Create the contexts
For row = firstRowInstance To maxInstance
  
    'ID of the context : entity + scheme + periodInit + periodEnd + (dimension + dimension member). Note unitRef is NOT used in this kind of contexts
    contextID = factTableV(row, colEntity) & factTableV(row, colScheme) & factTableV(row, colPeriodInit) & factTableV(row, colPeriodEnd)
    If factTableV(row, colDimensions) <> "/**Tuple" Then ' it no tuple, check for dimensions
        For col = colDimensions To maxCols Step 2 ' Obtain members of dimensions
            If factTableV(row, col) = "" Then Exit For ' Exit at the first emtpy dimensional col
            If factTableV(row, col) <> "/**Typed" And factTableV(row, col) <> "/**Scenario" Then ' ignore two cols for  "/**Typed" or "/**Scenario"
                ' include  dimensiom name and dimension member in the context name
                contextID = contextID & factTableV(row, col) & factTableV(row, col + 1)
            End If
        Next col
    End If
  
    ' Check if this is an already existing context
    Call dycotomicSearch(contextsList, 1, iContext, contextID, I) ' Find context in list of contexts
    If contextsList(I) = contextID Then ' context already created
        factTableS(row) = contextsLOrd(I)    ' Save pointer to context
    Else ' If it is a new context, generate it
        ' Add context to list of contexts, by order
        iContext = iContext + 1
        I = iContext ' pointer to fin ordenated insertion point
        Do While I > 1 And contextsList(I - 1) > contextID ' find ordenated insertion point
            contextsList(I) = contextsList(I - 1) ' desplace value of context
            contextsLOrd(I) = contextsLOrd(I - 1) ' desplace order of context
            I = I - 1 ' prior insertion point
        Loop
        contextsList(I) = contextID ' Value of context
        contextsLOrd(I) = iContext - 1 ' Original order of context, starting in "0"
        factTableS(row) = contextsLOrd(I)    ' Save pointer to context
        
        'Begin of context. Context reference = "_ctx" + contextsequencenumber
        context = "  <xbrli:context id=" & Chr(34) & "_ctx" & factTableS(row) & Chr(34) & ">" & vbCrLf
  
        ' Entity of the context
        context = context & "    <xbrli:entity>" & vbCrLf
        context = context & "      <xbrli:identifier scheme=" & Chr(34) & factTableV(row, colScheme) & Chr(34) & ">" & factTableV(row, colEntity) & "</xbrli:identifier>" & vbCrLf
        ' Segment of the context, hence as part of entity
        col = colDimensions
        If factTableV(row, col) <> "" And factTableV(row, col) <> "/**Tuple" Then ' fact with dimensions, check for segment
            Do While factTableV(row, col) <> "" ' process dimensions
                col = col + 2
                If factTableV(row, col - 1) = "/**Segment" And factTableV(row, col) <> "" And factTableV(row, col + 1) <> "/**Segment" Then ' valid start of segment
                    context = context & "    <xbrli:segment>" & vbCrLf    ' open segment
                    Do While factTableV(row, col) <> "" ' process dimensions of segment
                        If factTableV(row, col + 2) = "/**Typed" Then 'typed dimension
                            context = context & "      <xbrldi:typedMember dimension=" & Chr(34) & factTableV(row, col) & Chr(34) & ">"
                            context = context & "           <" & factTableV(row, col + 3) & ">" & factTableV(row, col + 1) & "</" & factTableV(row, col + 3) & ">"
                            context = context & "      </xbrldi:typedMember>" & vbCrLf
                            col = col + 4
                        Else
                            If factTableV(row, col + 1) <> "/**Segment" Then ' explicit dimension (ignore duplicated /**Segment).
                                context = context & "      <xbrldi:explicitMember dimension=" & Chr(34) & factTableV(row, col) & Chr(34) & ">" & factTableV(row, col + 1) & "</xbrldi:explicitMember>" & vbCrLf
                            End If
                            col = col + 2
                        End If
                    Loop
                    context = context & "    </xbrli:segment>" & vbCrLf  ' close segment
                End If
            Loop
        End If
        context = context & "    </xbrli:entity>" & vbCrLf ' close entity
        'end of entity
  
        ' Period of the context (duration/instant)
        If factTableV(row, colPeriodInit) <> "" Then
            context = context & "    <xbrli:period>" & vbCrLf
            context = context & "      <xbrli:startDate>" & factTableV(row, colPeriodInit) & "</xbrli:startDate>" & vbCrLf
            context = context & "      <xbrli:endDate>" & factTableV(row, colPeriodEnd) & "</xbrli:endDate>" & vbCrLf
            context = context & "    </xbrli:period>" & vbCrLf
        Else
            context = context & "    <xbrli:period>" & vbCrLf & "      <xbrli:instant>" & factTableV(row, colPeriodEnd) & "</xbrli:instant>" & vbCrLf & "    </xbrli:period>" & vbCrLf
        End If
  
        
        ' Scenario of the context
        col = colDimensions
        If factTableV(row, col) <> "" And factTableV(row, col) <> "/**Tuple" And factTableV(row, col + 1) <> "/**Segment" Then ' valid start of scenario
            context = context & "    <xbrli:scenario>" & vbCrLf ' open scenario
            Do While factTableV(row, col) <> "" And factTableV(row, col + 1) <> "/**Segment"
                If factTableV(row, col + 2) = "/**Typed" Then 'typed dimension
                    context = context & "      <xbrldi:typedMember dimension=" & Chr(34) & factTableV(row, col) & Chr(34) & ">"
                    context = context & "<" & factTableV(row, col + 3) & ">" & factTableV(row, col + 1) & "</" & factTableV(row, col + 3) & ">"
                    context = context & "</xbrldi:typedMember>" & vbCrLf
                    col = col + 4
                Else  ' explicit dimension
                    context = context & "      <xbrldi:explicitMember dimension=" & Chr(34) & factTableV(row, col) & Chr(34) & ">" & factTableV(row, col + 1) & "</xbrldi:explicitMember>" & vbCrLf
                    col = col + 2
                End If
            Loop
            context = context & "    </xbrli:scenario>" & vbCrLf    ' close scenario
        End If

        'End of context
        context = context & "  </xbrli:context>"
        fsT.writetext context & vbCrLf
    
    End If ' End of generate context
Next  ' Next row
Call timerPartial(timerN, timerS, "crear contextos") ' Partial chronometer

'Find and write: /**OutputMiddle
For row = 1 To maxOutputTable
    If outputTableType(row) = "/**OutputMiddle" Then fsT.writetext outputTableValue(row) & vbCrLf  ' Write /**Output indications
Next

'Create the items
For row = firstRowInstance To maxInstance
    rowID = factTableV(row, colRowID)  ' Row ID (may be empty)
  
    'footnote (if declared)
    If factTableV(row, colFootnote) <> "" Then
        If rowID = "" Then rowID = "rownumber_" & row  ' Create a default rowID
        idNfootnote = Chr(34) & "#_" & rowID & Chr(34)
        arcfootnote = Chr(34) & "arc_" & rowID & Chr(34)
        textfootnote = Chr(34) & "text_" & rowID & Chr(34)
        footnoteT(footnoteMax + 1) = "  <link:loc xlink:href=" & idNfootnote & " xlink:label=" & arcfootnote & " xlink:type=" & Chr(34) & "locator" & Chr(34) & " /> "
        footnoteT(footnoteMax + 2) = "  <link:footnoteArc xlink:arcrole=" & Chr(34) & "http://www.xbrl.org/2003/arcrole/fact-footnote" & Chr(34) & " xlink:from=" & arcfootnote & " xlink:title=" & Chr(34) & "footnote" & Chr(34) & " xlink:to=" & textfootnote & " xlink:type=" & Chr(34) & "arc" & Chr(34) & " /> "
        footnoteT(footnoteMax + 3) = "  <link:footnote xlink:label=" & textfootnote & " xlink:role=" & Chr(34) & "http://www.xbrl.org/2003/role/footnote" & Chr(34) & " xlink:type=" & Chr(34) & "resource" & Chr(34) & " xml:lang=" & footnoteLang & ">"
        footnoteT(footnoteMax + 3) = footnoteT(footnoteMax + 3) & CleanStringXML(factTableV(row, colFootnote))
        footnoteT(footnoteMax + 3) = footnoteT(footnoteMax + 3) & " </link:footnote> "
        footnoteMax = footnoteMax + 3
    End If
    
    ' Each Tuple must have a master declarative order, well in "parameters", well in "data"
    'If Tuple: if additional nested level, then open it.
    Do While factTableV(row, (colDimensions + (tupleDepth + 1) * 2)) = "/**Tuple"
        ' Store in a pile the Type and PrimaryItem sequence of the Tuple for the additional nested level
        tupleDepth = tupleDepth + 1
        tupleType(tupleDepth) = factTableV(row, (colDimensions + tupleDepth * 2 + 1))
        ' Find PrimaryItem sequence
        For K = 1 To numReplaces   ' find the first occurence PrimaryItem in table resplacesTable to discover the tuple structure
            If factTableV(row, colPrimaryItem) = replacesTable(K, colPrimaryItem) Then Exit For
        Next K
        tupleItemSequence(tupleDepth) = K ' Store the PrimaryItem sequence
        ' Write the tuple opening stuff
        fsT.writetext "  <" & tupleType(tupleDepth) & ">   " & vbCrLf
    Loop
      
    ' Strat creating Primary item
    item = "  <" & factTableV(row, colPrimaryItem)
   
    'RowID (if specified)
    If rowID <> "" Then item = item & " id=" & Chr(34) & "_" & rowID & Chr(34)
    'Decimals (if declared)
    If factTableV(row, colDecimals) <> "" Then item = item & " decimals=" & Chr(34) & factTableV(row, colDecimals) & Chr(34)
    'unitRef (if specified)
    If factTableV(row, colUnitRef) <> "" Then item = item & " unitRef=" & Chr(34) & factTableV(row, colUnitRef) & Chr(34)
    ' Context reference = "_ctx" + contextsequencenumber and closing ">"
    item = item & " contextRef=" & Chr(34) & "_ctx" & factTableS(row) & Chr(34) & ">"
  
    'Value of Fact. Special XML characters to de replaced
    If factTableV(row, colDecimals) <> "" Then
        item = item & Replace(CleanStringXML(factTableV(row, colFact)), ",", ".")  ' force decimal point
    Else
        item = item & CleanStringXML(factTableV(row, colFact))
    End If
  
    'End of item and Write
    item = item & "</" & factTableV(row, colPrimaryItem) & ">"
    fsT.writetext item & vbCrLf
  
    'Tuples closing
    If tupleDepth > -1 Then
        'Check next row for different Type of tuple OR for no "/**Tuple". That detects different nested level
        Do While factTableV((row + 1), (colDimensions + tupleDepth * 2 + 1)) <> tupleType(tupleDepth) Or factTableV((row + 1), (colDimensions + tupleDepth * 2)) <> "/**Tuple"
            fsT.writetext "  </" & tupleType(tupleDepth) & ">   " & vbCrLf
            tupleDepth = tupleDepth - 1
            If tupleDepth < 0 Then Exit Do
        Loop
        ' Each Tuple must have a master declarative order, well in "parameters", well in "data"
        'Check for PrimaryItem in sequence at the nested level
        If tupleDepth > -1 Then
            ' find tuple in table in memory
            For K = 1 To numReplaces    ' find the first occurence PrimaryItem in table resplacesTable to discover the tuple structure
                If factTableV(row, colPrimaryItem) = replacesTable(K, colPrimaryItem) Then Exit For
            Next K
            ' If next PrimaryItem is not in sequence in the Tuple declaration (except for "unbounded" consecutive PrimaryItems)
            If (K < tupleItemSequence(tupleDepth)) Or (K = tupleItemSequence(tupleDepth) And factTableV(row + 1, (colDimensions + (tupleDepth + 1) * 2)) <> "/**Unbounded") Then
                ' Close this nested level in the Tuple. When the next row will processed, then the Tuple will be reopened
                fsT.writetext "  </" & tupleType(tupleDepth) & ">   " & vbCrLf
                tupleDepth = tupleDepth - 1
            Else
                tupleItemSequence(tupleDepth) = K ' Update the PrimaryItem sequence with the next row position
            End If
        End If
    End If  ' Close of tuples
    
Next row

'Write footnotes
If footnoteT(0) <> "" Then
    fsT.writetext "<link:footnoteLink xlink:type=" & Chr(34) & "extended" & Chr(34) & " xlink:role=" & Chr(34) & "http://www.xbrl.org/2003/role/link" & Chr(34) & ">" & vbCrLf
    J = 0
    Do While footnoteT(J) <> ""
        fsT.writetext footnoteT(J) & vbCrLf
        J = J + 1
    Loop
    fsT.writetext "</link:footnoteLink>" & vbCrLf
End If
 
'Find and write: /**OutputTail
outputTail = "" ' vbCrLf unnecessary at end of file, unless more than a single /**OutputTail
For row = 1 To maxOutputTable
    If outputTableType(row) = "/**OutputTail" Then
        fsT.writetext outputTail & outputTableValue(row)  ' Write /**Output indications. If more than one OutputTail, prefix with new line
        outputTail = vbCrLf  ' Prepare a vbCrLf as separator if more than a single /**OutputTail
    End If
Next
 
fsT.SaveToFile strFilePath, 2  ' close XBRL instance
RemoveBOM (strFilePath)        ' remove BOM in XBRL instance
Call timerPartial(timerN, timerS, "escribir informe XBRL") ' Partial chronometer

If showDuration = True Then Call timerTotal(timerN, timerS, msgTimer) ' stop chronometer
MsgBox "XBRL instance document successfully created." & msgTimer, vbOKOnly, "Informaci|fffd|n"

' Print duplicated items
If msgD <> "" Then

    c = Sheets(sheetMain).Cells(100, 1) ' route of XBRL file
    If Right(c, 5) = ".xbrl" Then c = Left(c, Len(c) - 5) ' delete the extension of XBRL file
    c = c & ".errors.txt" ' add suffix and extension of errors file

    MsgBox "ERRORS DETECTED" & vbCrLf & "Saved in the file " & c & vbCrLf & msgD, vbOKOnly, "Informaci|fffd|n"
    Set fsT = CreateObject("ADODB.Stream")    'Create Stream object
    fsT.Type = 2    'Specify stream type - we want To save text/string data.
    fsT.Charset = "utf-8"    'Specify charset For the source text data.
    fsT.Open    'Open the stream And write binary data To the object
    ' text File: Name and path
    ' strFilePath = Application.GetSaveAsFilename("erroresyduplicados.txt", "Text file (*.txt), *.txt") 'Text File: Name and path
    strFilePath = c ' route to errors file
    ' If the "Save as..." dialog box is cancelled
    If strFilePath = False Then GoTo exitSub

    fsT.writetext msgD  ' Write messages created about duplicated items
    fsT.SaveToFile strFilePath, 2  ' Close file
End If

If 1 = 0 Then ' block to manage errors, never to be executed in sequence
Errhandler:
    MsgBox "Error on the process of creation of the XBRL instance document." & vbNewLine & "Error n|fffd|" & Err & ": " & Error(Err), _
    vbOKOnly + vbCritical, "ERROR"
End If
exitSub:
' return: enable normal options
Sheets(sheetMain).Activate  ' active again main spreadsheet
Application.Calculation = xlCalculationAutomatic
Application.ScreenUpdating = True
Application.DisplayStatusBar = True
End Sub

Sub codeValue() ' Module load code-value flat file into a set of tables. Uses a translation list from code to table-cell position.
' Version 2016 03 26
' LEGAL NOTICE, DO NOT REMOVE: Proof of concept ExcelXbrl converter. Module load code-value flat file into a set of tables. Copyrigth 2015, 2016 Ignacio Boixo. All rigths reserved. See license at www.recex.es

Const debugCodetoTable As Boolean = False  ' Create codevalueTablename for debugging. Select False in production.

' positions in entry codevalue spreadsheet. Used when debugging only
Const codevalueTablename As String = "CodeValue" ' name of the "codevalue" spreadsheet
Const codevalueCode As Integer = 2                ' column of code in codevalue spreadsheet
Const codevalueValue As Integer = 3               ' column of value in codevalue spreadsheet

' positions in entry codetotable spreadseheet
Const codetotableTablename As String = "CodeCell" ' name of the "codetotable" spreadsheet. THIS SHEET MUST BE ORDENED BY ASCENDING CODE, OTHERWISE THE RUN DURATION WILL SUFFER
Const codetotableCode As Integer = 2                ' column of code in codetotable spreadsheet
Const codetotableTable As Integer = 3               ' column of table position in codetotable spreadsheet
Const codetoTableFirstRow As Integer = 7            ' first codetotable row

' Capacity of processing codes
Const maxRows As Long = 100000   ' Maximun size of codevalue table
Dim cellPointerCode(100000) As String
Dim cellPointerT(100000) As String

' The format of the table position of the cell is [celda='sheet'!C999] being sheetValue=[sheet], columnValue=[C] (converted to numeric) and rowValue=[999] (tailing zeroes ignored)
Const prefixTableDelimiter As String = "-"    ' string prefixing table position
Const middleTableDelimiter As String = "-_"         ' string as middle separator between sheet and column/row in table position

' Miscelaneous
Const mainSheet As String = "|fffd|ndice"   ' name of the main spreadsheet
Const charCSV As String = ","   ' Character separator in CSV

' Partial and total times
Const showDuration As Boolean = True ' Flag to prepara message with partital and total processing times. Put false in production
Dim timerN(100) As Long
Dim timerS(100) As String
Dim msgTimer As String

Dim cellpointerTValue, msgText, textline, wtextline, vbTab, vbQM, vbdoubleQM As String
Dim c As String
Dim sCode As String
Dim sValue As String
Dim sheetValue As String
Dim col, I, J, K, L, M, textlineL, maxCodeValue    As Long
Dim numCodes As Long
Dim iCode As Long
Dim columnValue As Integer
Dim rowValue As Integer


vbTab = Chr(9)   ' Character tab
vbQM = Chr(34)   ' Character quotation mark
vbdoubleQM = vbQM & vbQM ' Double Character quotation mark

' Acelerate processing by disabling options
Application.Calculation = xlCalculationManual
Application.ScreenUpdating = False
Application.DisplayStatusBar = False

Call timerPartial(timerN, timerS, "") ' Init chronometer

' Load list of correspondences, for each different code to a sheet-cell

Sheets(codetotableTablename).Activate  ' active "codetotable" spreadsheet

numCodes = 0   ' table of replaces empty
'For each row in "codetotable" spreadsheet
For I = codetoTableFirstRow To maxRows
    If Cells(I, 1) & Cells(I, codetotableCode) & Cells(I, codetotableTable) = "" Then Exit For  ' row empty, end of sheet
    If Left(Cells(I, 1), 2) <> "/*" Then  ' skip row being comments
        J = numCodes + 1 ' insertion point
        c = Cells(I, codetotableCode) & ""  ' code to insert (force string type with "")
        Do While J > 1 ' explore prior codes in table of code-value to find ordenated insertion point
            If debugCodetoTable = True And c = cellPointerCode(J - 1) Then ' duplicated code, abort
                MsgBox "ERROR: Sheet " & codetotableTablename & " with duplicated code [" & cellPointerCode(I - 1) & "]", vbOKOnly + vbCritical, "ERROR"
                GoTo exitSub
            End If
            If c > cellPointerCode(J - 1) Then Exit Do ' insertion point found, exit do
            ' displace existing code-value one position to rigth
            cellPointerCode(J) = cellPointerCode(J - 1)
            cellPointerT(J) = cellPointerT(J - 1)
            J = J - 1
        Loop
        ' save code-value
        cellPointerCode(J) = c ' save code
        cellPointerT(J) = Cells(I, codetotableTable) ' save sheet-cell reference (position on table)
        numCodes = numCodes + 1 ' inncrease size of tables code-value
    End If ' end of process row
Next I    ' next row

If numCodes = 0 Then ' If "codetotable" spreadsheet empty or too small, cancel
    MsgBox "ERROR: no elements in the sheet " & codetotableTablename, _
    vbOKOnly + vbCritical, "ERROR"
    GoTo exitSub
End If

'  Ask for the route of the input code-value CSV file
strFileName = Application.GetOpenFilename
If strFileName = False Then GoTo exitSub  ' CSV file not found, exit
Open strFileName For Input As #1   ' open csv file

If debugCodetoTable = True Then     ' only in Debugg mode: clear codeValue sheet
    Sheets(codevalueTablename).Range("a1:c10000").ClearContents
    maxCodeValue = 0    ' empty CodeValue table
End If

Do While (1 = 1)  ' repeat until End of File
    If EOF(1) Then Exit Do
    Line Input #1, textline  ' read 1 line
    If textline <> "" And Left(textline, 2) <> "/*" Then  ' process if not empty and not commented
    sCode = ""    ' clear code
    sValue = ""   ' clear value
    I = InStr(textline, vbQM) ' Check for Quotation Mark
  
    If I = 0 Then ' NOT quotation mark detected. Fast track obtaining code and value, as no Quotation Mark used in the line
        wtextline = Replace(Replace(Replace(textline, vbTab, " "), ";", " "), charCSV, " ") ' transform delimiters into spaces
        wtextline = Trim(wtextline) ' delete leading spaces
        I = InStr(wtextline, " ") ' find next delimiter
        If I > 0 Then   ' more delimiters, hence Value may be present
            sCode = Left(wtextline, I - 1) ' Capture scode
            sValue = Replace(wtextline, " ", "", I)  ' capture svalue, by moving from "i" and deleting all the spaces
        Else  ' no more delimiters, hence only code present
            sCode = wtextline  ' capture code (even it may be "")
        End If
  
    Else  ' slow track as Quotation Mark used, exploring character by character
        wtextline = Trim(textline) ' delete leading spaces
        textlineL = Len(wtextline) ' length of line
        'find first significative character
        For I = 1 To textlineL
            c = Mid(wtextline, I, 1) ' obtain 1 character from textline
            If Not (c = " " Or c = charCSV Or c = ";" Or c = vbTab) Then Exit For
        Next I
        ' delete left delimiters
        If I > 1 Then
            wtextline = Right(wtextline, textlineL - (I - 1)) ' delete left delimiters
            textlineL = Len(wtextline)
        End If

        ' obtain code
        If Left(wtextline, 1) <> vbQM Then  ' code do NOT start with quotation Mark
            For I = 1 To textlineL
                c = Mid(wtextline, I, 1) ' obtain 1 character from textline
                If (c = " " Or c = charCSV Or c = ";" Or c = vbTab) Then Exit For ' if charater is a delimiter, exit from obtain code
            Next I
            sCode = Left(wtextline, I - 1) ' save string of code
        Else ' code starts with Quotation Mark
            For I = 2 To textlineL  ' explore the rest of the line
                If Mid(wtextline, I, 1) = vbQM Then
                    If Mid(wtextline, I + 1, 1) <> vbQM Then Exit For ' Quotation Mark not followed by Quotation Mark, exit
                    I = I + 1 ' force ignore doble Quotation Mark
                End If
            Next I
            sCode = Mid(wtextline, 2, I - 1 - 1) ' save string of code without starting and ending Quotation Marks
            sCode = Replace(sCode, vbdoubleQM, vbQM) ' replace double Quotation Mark for sinle Quotation Mark
            I = I + 1 ' Skip Quotation Mark
        End If
        'ignore middle delimiter/s
        For I = I To textlineL
            c = Mid(wtextline, I, 1) ' obtain 1 character from textline
            If Not (c = " " Or c = charCSV Or c = ";" Or c = vbTab) Then Exit For
        Next
        wtextline = Mid(wtextline, I)  ' delete code and middle delimiters/s
        textlineL = Len(wtextline)
        
        ' obtain value, same instructions than obtain code
        If wtextline <> "" Then ' value present
            If Left(wtextline, 1) <> vbQM Then  ' value do NOT start with quotation Mark
                For I = 1 To textlineL
                    c = Mid(wtextline, I, 1) ' obtain 1 character from textline
                    If (c = " " Or c = charCSV Or c = ";" Or c = vbTab) Then Exit For ' if charater is a delimiter, exit from obtain code
                Next I
                sValue = Left(wtextline, I - 1) ' save string of value
            Else ' value starts with Quotation Mark
                wtextline = Replace(wtextline, vbQM, "", 1, 1) ' delete first charater, that is a Quotation Mark
                textlineL = Len(wtextline)
                Do While I = I ' infinite loop, as the Quotation Mark may be extended across several lines
                    If wtextline <> "" Then ' line not empty
                        For I = 1 To textlineL  ' explore the rest of the line
                            If Mid(wtextline, I, 1) = vbQM Then
                                If Mid(wtextline, I + 1, 1) <> vbQM Then Exit For ' Quotation Mark not followed by Quotation Mark, exit
                                I = I + 1 ' force ignore double Quotation Mark
                            End If
                        Next I
                        sValue = sValue & Left(wtextline, I - 1) ' save string of code
                        If Mid(wtextline, I, 1) = vbQM Then Exit Do ' If last character is a Quotation Mark, exit
                    End If
                    If EOF(1) Then Exit Do   ' if end of file, exit
                    Line Input #1, textline  ' read next line
                    wtextline = textline     ' move to working area
                    textlineL = Len(wtextline)  ' obtain length of textline
                    sValue = sValue & vbCrLf ' store end of line in Value
                Loop
                sValue = Replace(sValue, vbdoubleQM, vbQM) ' replace double Quotation Mark for sinle Quotation Mark
            End If ' end of obtain value
        End If ' end process input line
    End If  ' end slow track
     
    If debugCodetoTable = True Then ' only in debugg mode. Store in codeValue sheet
        maxCodeValue = maxCodeValue + 1 ' Inster position of codevalue table
        Sheets(codevalueTablename).Cells(maxCodeValue, codevalueCode) = sCode    ' save code in codevalue spreadsheet
        Sheets(codevalueTablename).Cells(maxCodeValue, codevalueValue) = sValue     ' save value in codevalue spreadsheet
    End If
    
    ' insert value in table, row, column
    If sCode <> "" Then ' code not null, instert into table
        ' Find cell code in table cellPointerCode, with dycotomic search
        Call dycotomicSearch(cellPointerCode, 1, numCodes, sCode, iCode) ' Find cell code in table cellPointerCode

        If sCode <> cellPointerCode(iCode) Then ' code not found
            msgText = "ERROR: In the sheet [" & codetotableTablename & "], the following code is missing: [" & sCode & "]"
            MsgBox msgText, vbOKOnly + vbCritical, "ERROR"
            Exit Do
        End If
                
        ' The format of the coordinates is [prefixsheet'!C999] being prefix ending in "'", sheetValue=[sheet], columnValue=[CC] (converted to numeric) and rowValue=[999] (tailing zeroes ignored)
        c = cellPointerT(iCode)  ' obtain coordinates
        
        Call extractCoordinates(c, prefixTableDelimiter, middleTableDelimiter, sheetValue, columnValue, rowValue)

        ' check for valid coordinates
        If sheetValue = "" Then  ' coordinates invalid
            MsgBox "ERROR: Coordinates invalid at " & cellPointerT(iCode), vbOKOnly + vbCritical, "ERROR"
            Exit Do
        End If
        
        ' Insert value from entry file into table(row,colmun)
        If sValue <> "" Then
            Sheets(sheetValue).Cells(rowValue, columnValue) = sValue ' move value (preserving leading of tailing spaces) in codevalue table to the corresponding position in table
        Else
            Sheets(sheetValue).Cells(rowValue, columnValue).ClearContents ' clear cell, fast method
        End If
     End If ' closing scode <> ""
  End If ' closing empty record or "/*" comments
Loop

Close 1  ' close input csv file

If showDuration = True Then Call timerTotal(timerN, timerS, msgTimer) ' stop chronometer
MsgBox "Code-value file successfully loaded." & msgTimer, vbOKOnly, "Information"

exitSub:
Sheets(mainSheet).Activate  ' active again main spreadsheet

' return: enable normal options
Application.Calculation = xlCalculationAutomatic
Application.ScreenUpdating = True
Application.DisplayStatusBar = True

End Sub
Function CleanStringXML(inputString As String) As String      ' Convert XML reserved charaters in the cannonical form "&char;"
Dim outputString As String


  outputString = inputString
    
  ' take care of existing cannonical forms before replace "&"
  outputString = Replace(outputString, "&amp;", "&")
  outputString = Replace(outputString, "&lt;", "<")
  outputString = Replace(outputString, "&gt;", ">")
  outputString = Replace(outputString, "&apos;", "'")
  outputString = Replace(outputString, "&quot;", Chr(39))

  ' convert to XML cannonical forms "&char;"
  outputString = Replace(outputString, "&", "&amp;")
  outputString = Replace(outputString, "<", "&lt;")
  outputString = Replace(outputString, ">", "&gt;")
  outputString = Replace(outputString, "'", "&apos;")
  outputString = Replace(outputString, Chr(39), "&quot;")
  ' convert other sometimes XML offending characters
  outputString = Replace(outputString, Chr(145), "&quot;")
  outputString = Replace(outputString, Chr(146), "&quot;")
  outputString = Replace(outputString, Chr(147), "&quot;")
  outputString = Replace(outputString, Chr(148), "&quot;")
  outputString = Replace(outputString, Chr(150), "-")
  
  CleanStringXML = outputString

End Function

Function findCoordinates(inputString As String) As String   ' Extract Excel coordinates as 'SSSSS'!CCCRRR
    ' coordinates are 'SSSSS'!CCCRRR being SSSSS=Sheet name   CCC=Column, 1 to 3 capital letters   RRR=row, 1 to 3 digits
    Dim I, J As Integer
    Dim wItem As String
    
    findCoordinates = "" ' Return empty string if input coordinates invalid
    ' if origin of value is a formula with valid Excel coordinates, and RowID is empty, store coordinates as RowID
    wItem = inputString    ' Obtain formula, if exists
    I = InStr(wItem, "'") ' find first reference to "'" (open spreadsheet name) as origin of value
    J = InStr(I + 1, wItem, "'!")  ' find second reference to "'!" (close spreadsheet name) as origin of clomun and row
    If I > 0 And J > 0 Then ' check for valid sheet name
        J = J + 2   ' Point to first character of Column
        If Mid(wItem, J, 1) >= "A" And Mid(wItem, J, 1) <= "Z" Then ' check for valid alphabetic column
            J = J + 1 ' Point to second character of column, or to row
            If Mid(wItem, J, 1) >= "A" And Mid(wItem, J, 1) <= "Z" Then J = J + 1 ' alfabetic column may have two characters
            If Mid(wItem, J, 1) >= "A" And Mid(wItem, J, 1) <= "Z" Then J = J + 1 ' alfabetic column may have three characters
            If IsNumeric(Mid(wItem, J, 1)) = True Then ' check for valid numeric row
                If IsNumeric(Mid(wItem, J + 1, 1)) = True Then J = J + 1  ' numeric row may have two digits
                If IsNumeric(Mid(wItem, J + 1, 1)) = True Then J = J + 1 ' numeric row may have three digits
                findCoordinates = Mid(wItem, I, (J - I) + 1) ' Create row ID as Excel coordinates of origin of value
            End If
        End If
    End If
End Function


Sub extractCoordinates(txtString As String, prefixDel As String, middleDel As String, sheetName As String, colValue As Integer, rowValue As Integer)
        Dim I, J As Integer
        Dim wString As String
        
        ' Defalut values if coordinates not found
        sheetName = ""
        colValue = 0
        rowValue = 0
        
        ' obtain sheet name
        J = InStr(txtString, prefixDel)  ' find the occurrence of prefixTableDelimiter
        I = InStr(J + 1, txtString, middleDel) ' find the occurrence of middleTableDelimiter
        If I > 1 And J > 0 Then sheetName = Mid(txtString, J + 1, (I - 1) - J) ' extract the name of the table
        I = I + Len(middleDel) ' point to first charater of column
        
        wString = Mid(txtString, I, 1) ' working string of 1 character
        
        Do While wString >= "A" And wString <= "Z"        ' obtain column
            colValue = colValue * 26 + (Asc(wString) - Asc("A") + 1) ' Transfor Column to decimal value
            I = I + 1
            wString = Mid(txtString, I, 1) ' Next character
        Loop
        Do While IsNumeric(wString)        ' obtain row
            rowValue = rowValue * 10 + wString
            I = I + 1
            wString = Mid(txtString, I, 1) ' Next character
        Loop
        If sheetName = "" Or colValue = 0 Or rowValue = 0 Then 'if coordinates not valid
            ' To be sure that results are coherent if coordinates not found
            sheetName = ""
            colValue = 0
            rowValue = 0
        End If
        
End Sub

Sub dycotomicSearch(arrayClassified() As String, minEntry As Long, maxEntry As Long, txtString As String, indexPointer As Long)
        Dim I, J, K As Long
        ' Find a value in a Classified array with dycotomic search
        I = 0           ' index to find
        J = minEntry    ' lowest index
        K = maxEntry    ' highest index
        Do While J <= K ' while lowest index less than highest index
            I = Round(((J + K) / 2)) ' find index i in the middle
            If txtString > arrayClassified(I) Then  ' greather than index i
                J = I + 1 ' increase lowest index
            Else
                If txtString < arrayClassified(I) Then ' lower than index i
                    K = I - 1 ' decrease highest index
                Else    ' match, force end loop
                    Exit Do  ' force end loop
                End If
            End If
        Loop
        indexPointer = I ' Obtain index pointing to element
End Sub

' Removes the Byte Order Mark - BOM from a text file with UTF-8 encoding
' The BOM defines that the file was stored with an UTF-8 encoding.
Function RemoveBOM(filePath)
        
        ' Create a reader and a writer
                Dim writer, reader, fileSize
                Set writer = CreateObject("Adodb.Stream")
                Set reader = CreateObject("Adodb.Stream")
        
        ' Load from the text file we just wrote
                reader.Open
                reader.LoadFromFile filePath
        
        ' Copy all data from reader to writer, except the BOM
                writer.Mode = 3
                writer.Type = 1
                writer.Open
                reader.Position = 2
                reader.copyto writer, -1

        ' Overwrite file
                writer.SaveToFile filePath, 2
        
        ' Return file name
                RemoveBOM = filePath

        ' Kill objects
                Set writer = Nothing
                Set reader = Nothing

End Function
Function FindString(strCheck As String, strFind As String) As Boolean
    intPos = 0
    intPos = InStr(strCheck, strFind)
    FindString = intPos > 0
End Function
Sub timerPartial(timerN() As Long, timerS() As String, msgS As String)
' Save partial time of processing
    
    Dim I As Integer

    If msgS = "" Then ' if first invokation
        Erase timerN    ' Clear data
        Erase timerS
        timerN(0) = Timer  ' Save initial time
    Else
        For I = 1 To UBound(timerN) ' Repeat until find empty entry
            If timerN(I) = 0 Then
                timerN(I) = Timer    ' save partial time
                timerS(I) = msgS     ' save message
                Exit For
            End If
        Next I
    End If
End Sub
Sub timerTotal(timerN() As Long, timerS() As String, msgS As String)
' prepare am edited string with partial and total processing times in seconds
    
    Dim I As Integer

    ' obtain total time of processing
    For I = 1 To UBound(timerN)
        If timerN(I) = 0 Then
            timerN(I) = Timer + timerN(I - 1) - timerN(0) ' Total processing time
            timerS(I) = "total"
            Exit For
        End If
    Next I

    ' Prepare message to be returned
    msgS = "" ' Clear output string
    For I = 1 To UBound(timerN)
        If timerN(I) = 0 Then Exit For ' No more partial times|fffd|
        msgS = msgS & vbCrLf & "Tiempo " & timerS(I) & " " & (timerN(I) - timerN(I - 1)) & " segundos."
    Next I
End Sub










Attribute VB_Name = "ThisWorkbook"
Attribute VB_Base = "0{00020819-0000-0000-C000-000000000046}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = True


INQUEST-PP=macro
